{"buggy_code": ["/* radare - LGPL - Copyright 2014-2017 - inisider */\n\n#include <string.h>\n#include <r_util.h>\n#include <r_core.h>\n#include \"pdb_downloader.h\"\n\nstatic bool checkExtract() {\n#if __WINDOWS__\n\tif (r_sys_cmd (\"expand -? >nul\") != 0) {\n\t\treturn false;\n\t}\n#else\n\tif (r_sys_cmd (\"cabextract -v > /dev/null\") != 0) {\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nstatic bool checkCurl() {\n\tconst char nul[] = R_SYS_DEVNULL;\n\tif (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int download(struct SPDBDownloader *pd) {\n\tSPDBDownloaderOpt *opt = pd->opt;\n\tchar *curl_cmd = NULL;\n\tchar *extractor_cmd = NULL;\n\tchar *abspath_to_archive = NULL;\n\tchar *abspath_to_file = NULL;\n\tchar *archive_name = NULL;\n\tsize_t archive_name_len = 0;\n\tchar *symbol_store_path = NULL;\n\tchar *dbg_file = NULL;\n\tchar *guid = NULL;\n\tchar *archive_name_escaped  = NULL;\n\tchar *user_agent = NULL;\n\tchar *symbol_server = NULL;\n\n\tint res = 0;\n\tint cmd_ret;\n\tif (!opt->dbg_file || !*opt->dbg_file) {\n\t\t// no pdb debug file\n\t\treturn 0;\n\t}\n\tif (!checkCurl ()) {\n\t\treturn 0;\n\t}\n\t// dbg_file len is > 0\n\tarchive_name_len = strlen (opt->dbg_file);\n\tarchive_name = malloc (archive_name_len + 1);\n\tif (!archive_name) {\n\t\treturn 0;\n\t}\n\tmemcpy (archive_name, opt->dbg_file, archive_name_len + 1);\n\tarchive_name[archive_name_len - 1] = '_';\n\tsymbol_store_path = r_str_escape (opt->symbol_store_path);\n\tdbg_file = r_str_escape (opt->dbg_file);\n\tguid = r_str_escape (opt->guid);\n\tarchive_name_escaped = r_str_escape (archive_name);\n\tuser_agent = r_str_escape (opt->user_agent);\n\tsymbol_server = r_str_escape (opt->symbol_server);\n\n\tabspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\t\t    symbol_store_path, R_SYS_DIR,\n\t\t\t    dbg_file, R_SYS_DIR,\n\t\t\t    guid, R_SYS_DIR,\n\t\t\t    archive_name_escaped);\n\n\tabspath_to_file = strdup (abspath_to_archive);\n\tabspath_to_file[strlen (abspath_to_file) - 1] = 'b';\n\tif (r_file_exists (abspath_to_file)) {\n\t\teprintf (\"File already downloaded.\\n\");\n\t\tR_FREE (user_agent);\n\t\tR_FREE (abspath_to_archive);\n\t\tR_FREE (archive_name_escaped);\n\t\tR_FREE (symbol_store_path);\n\t\tR_FREE (dbg_file);\n\t\tR_FREE (guid);\n\t\tR_FREE (archive_name);\n\t\tR_FREE (abspath_to_file);\n\t\tR_FREE (symbol_server);\n\t\treturn 1;\n\t}\n\n\tif (checkExtract () || opt->extract == 0) {\n\t\tres = 1;\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       user_agent,\n\t\t                       symbol_server,\n\t\t\t\t\t\t\t   dbg_file,\n\t\t\t\t\t\t\t   guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_archive);\n#if __WINDOWS__\n\t\tconst char *cabextractor = \"expand\";\n\t\tconst char *format = \"%s %s %s\";\n\n\t\t// extractor_cmd -> %1 %2 %3\n\t\t// %1 - 'expand'\n\t\t// %2 - absolute path to archive\n\t\t// %3 - absolute path to file that will be dearchive\n\t\textractor_cmd = r_str_newf (format, cabextractor,\n\t\t\tabspath_to_archive, abspath_to_file);\n#else\n\t\tconst char *cabextractor = \"cabextract\";\n\t\tconst char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\t// cabextract -d %1 %2\n\t\t// %1 - path to directory where to extract all files from cab archive\n\t\t// %2 - absolute path to cab archive\n\t\textractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);\n\t\tR_FREE (abspath_to_dir);\n#endif\n\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\teprintf (\"Attempting to decompress pdb\\n\");\n\t\tif (opt->extract > 0) {\n\t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n\t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tr_file_rm (abspath_to_archive);\n\t\t}\n\t\tR_FREE (curl_cmd);\n\t}\n\tif (res == 0) {\n\t\teprintf (\"Falling back to uncompressed pdb\\n\");\n\t\tres = 1;\n\n\t\tarchive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       opt->user_agent,\n\t\t                       opt->symbol_server,\n\t\t                       opt->dbg_file,\n\t\t                       opt->guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_file);\n\t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\tR_FREE (curl_cmd);\n\t}\n\tR_FREE (abspath_to_archive);\n\tR_FREE (abspath_to_file);\n\tR_FREE (archive_name);\n\tR_FREE (extractor_cmd);\n\tR_FREE (symbol_store_path);\n\tR_FREE (dbg_file);\n\tR_FREE (guid);\n\tR_FREE (archive_name_escaped);\n\tR_FREE (user_agent);\n\tR_FREE (symbol_server);\n\treturn res;\n}\n\nvoid init_pdb_downloader(SPDBDownloaderOpt *opt, SPDBDownloader *pd) {\n\tpd->opt = R_NEW0 (SPDBDownloaderOpt);\n\tif (!pd->opt) {\n\t\tpd->download = 0;\n\t\teprintf (\"Cannot allocate memory for SPDBDownloaderOpt.\\n\");\n\t\treturn;\n\t}\n\tpd->opt->dbg_file = strdup (opt->dbg_file);\n\tpd->opt->guid = strdup (opt->guid);\n\tpd->opt->symbol_server = strdup (opt->symbol_server);\n\tpd->opt->user_agent = strdup (opt->user_agent);\n\tpd->opt->symbol_store_path = strdup (opt->symbol_store_path);\n\tpd->opt->extract = opt->extract;\n\tpd->download = download;\n}\n\nvoid deinit_pdb_downloader(SPDBDownloader *pd) {\n\tR_FREE (pd->opt->dbg_file);\n\tR_FREE (pd->opt->guid);\n\tR_FREE (pd->opt->symbol_server);\n\tR_FREE (pd->opt->user_agent);\n\tR_FREE (pd->opt->symbol_store_path);\n\tR_FREE (pd->opt);\n\tpd->download = 0;\n}\n\nint r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n\tint ret;\n\tSPDBDownloaderOpt opt;\n\tSPDBDownloader pdb_downloader;\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\n\tif (!info || !info->debug_file_name) {\n\t\teprintf (\"Can't find debug filename\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!options || !options->symbol_server || !options->user_agent) {\n\t\teprintf (\"Can't retrieve pdb configurations\\n\");\n\t\treturn 1;\n\t}\n\n\topt.dbg_file = (char*) r_file_basename (info->debug_file_name);\n\topt.guid = info->guid;\n\topt.symbol_server = options->symbol_server;\n\topt.user_agent = options->user_agent;\n\topt.symbol_store_path = options->symbol_store_path;\n\topt.extract = options->extract;\n\n\tinit_pdb_downloader (&opt, &pdb_downloader);\n\tret = pdb_downloader.download ? pdb_downloader.download (&pdb_downloader) : 0;\n\tif (isradjson && actions_done) {\n\t\tprintf (\"%s\\\"pdb\\\":{\\\"file\\\":\\\"%s\\\",\\\"download\\\":%s}\",\n\t\t        *actions_done ? \",\" : \"\", opt.dbg_file, ret ? \"true\" : \"false\");\n\t} else {\n\t\tprintf (\"PDB \\\"%s\\\" download %s\\n\",\n\t\t        opt.dbg_file, ret ? \"success\" : \"failed\");\n\t}\n\tif (actions_done) {\n\t\t(*actions_done)++;\n\t}\n\tdeinit_pdb_downloader (&pdb_downloader);\n\n\treturn 0;\n}\n", "# config.mk.tail\n\nLIBR:=$(abspath $(dir $(lastword $(MAKEFILE_LIST))))\n# neat???!? trick to support path with spaces\nnull:=\nSPACE:=$(null) $(null)\n\nifeq ($(LIBR),)\nifeq ($(R2DIR),)\n$(error ERROR: Cannot find R2DIR. Please define this variable)\nelse\nLIBR=$(R2DIR)/libr\nMSVC=$(R2DIR)/msvc\nendif\nendif\n\nSHLR:=$(LIBR)/../shlr\n\n#include $(LIBR)/../config-user.mk\ninclude $(LIBR)/../global.mk\ninclude $(LIBR)/../mk/${COMPILER}.mk\n\nCFLAGS+=${CFLAGS_APPEND}\nCFLAGS+=${CPPFLAGS}\n\nifeq (1,1)\n#$(WITHPIC),1)\nLINK+=$(subst r_,-L$(LIBR)/,$(DEPS))\nLINK+=$(subst r_,-lr_,$(DEPS))\nLINK+=$(subst r_,-L$(LIBR)/,$(BINDEPS))\nLINK+=$(subst r_,-lr_,$(BINDEPS))\nCFLAGS+=${PIC_CFLAGS}\nLINK+=${PIC_CFLAGS}\nelse\nifneq ($(DEPS),)\nLINK+=$(shell echo ${DEPS} | sed -e 's:r_\\([^ ]\\+\\):$(LIBR)/\\1/libr_\\1.${EXT_AR}:g')\nendif\nendif\n\n# Compiler: see mk/gcc.mk\n# CC CFLAGS CC_LIB CC_AR LINK\n\n# Debug\nifneq ($(OSTYPE),mingw32)\nCFLAGS+=-g\nendif\nCFLAGS+=-Wall\n\n# libgmp\nifeq (${HAVE_LIB_GMP},1)\nCFLAGS+=-DHAVE_LIB_GMP=1\nBN_LIBS=-lgmp\nendif\n\n#both of these need ssl includes\nifneq (,$(filter r_socket r_util,$(BINDEPS)))\nifeq (${HAVE_LIB_SSL},1)\nCFLAGS+=${SSL_CFLAGS}\nendif\nendif\n\n# XXX do it in configure stage\nOSTYPE?=gnulinux\nifeq (${OSTYPE},auto)\n_UNAME=$(shell uname)\nifeq ($(_UNAME),Darwin)\nOSTYPE=darwin\nelse\nOSTYPE=gnulinux\nendif\nendif\nifeq (${OSTYPE},openbsd)\nOSTYPE=bsd\nendif\nifeq (${OSTYPE},netbsd)\nOSTYPE=bsd\nendif\nifeq (${OSTYPE},freebsd)\nOSTYPE=bsd\nendif\nifeq (${OSTYPE},dragonfly)\nOSTYPE=bsd\nendif\nifeq (${OSTYPE},bitrig)\nOSTYPE=bsd\nendif\n# Output\nifeq (${OSTYPE},windows)\nCFLAGS+=-D__WINDOWS__=1\nEXT_AR=lib\nEXT_SO=dll\nEXT_EXE=.exe\nTH_LIBS=\nendif\nifeq (${OSTYPE},bsd)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=-lpthread\nendif\nifeq (${OSTYPE},qnx)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=\nendif\nifeq (${OSTYPE},gnulinux)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=-lpthread\nendif\nifeq (${OSTYPE},haiku)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=\nendif\nifeq (${OSTYPE},darwin)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=dylib\nEXT_EXE=\nifeq ($(shell uname -p),arm)\n# iOS\nTH_LIBS=\nelse\n# OSX\nTH_LIBS=-lpthread\nendif\nendif\nifeq (${OSTYPE},android)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=\nendif\nifeq (${OSTYPE},solaris)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=\nendif\n\nifeq (${EXT_SO},)\nmain:\n\t@echo\n\t@echo \"OSTYPE: ${OSTYPE}\"\n\t@echo ERROR: Unknown platform\n\t@echo\n\t@exit 1\nendif\n\nLIB=lib${NAME}\nLIBAR=${LIB}.${EXT_AR}\nLIBSO=${LIB}.${EXT_SO}\nifeq (${OSTYPE},android)\nlibname=-shared -o $1.${EXT_SO}\nelse\nifeq (${OSTYPE},windows)\nlibname=-shared -o $1.${EXT_SO}\nelse\nifeq (${OSTYPE},darwin)\nifeq (${HAVE_LIBVERSION},1)\nlibname=-dynamiclib -o $1.${EXT_SO} ${LDFLAGS_SONAME}$1.${LIBVERSION}.${EXT_SO}\nelse\nlibname=-dynamiclib -o $1.${EXT_SO}\nendif\nelse\nifeq (${HAVE_LIBVERSION},1)\nlibname=-shared -o $1.${EXT_SO} ${LDFLAGS_SONAME}$1.${EXT_SO}.${LIBVERSION}\nelse\nlibname=-shared -o $1.${EXT_SO}\nendif\nendif\nendif\nendif\n\nifeq ($(OSTYPE),darwin)\nlibname-version = $(subst ${EXT_SO},$(2).${EXT_SO},$(1))\nelse\nlibname-version = $(1).$(2)\nendif\n\nlibpath-to-name = $(word 2,$(subst /, ,$(1)))\nlibpath-to-name-version = $(call libname-version,$(call libpath-to-name,$(1)),$(2))\n\n# -- singleton\nendif\n", "#ifndef R2_SOCKET_H\n#define R2_SOCKET_H\n\n/* Must be included before windows.h (r_types) */\n#if defined(__WINDOWS__)\n#include <ws2tcpip.h>\n#endif\n\n#include \"r_types.h\"\n#include \"r_bind.h\"\n#include \"r_list.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nR_LIB_VERSION_HEADER (r_socket);\n\n#if __UNIX__\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <poll.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#endif\n\n#if HAVE_LIB_SSL\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n#if __UNIX__\n#include <netinet/tcp.h>\n#endif\n\n/* For the Mingw-W64 toolchain */\n#ifndef MSG_DONTWAIT\n#define MSG_DONTWAIT 0\n#endif\n#ifndef SD_BOTH\n#define SD_RECEIVE  0\n#define SD_SEND 1\n#define SD_BOTH 2\n#endif\n\n#if _MSC_VER\n#define R_INVALID_SOCKET INVALID_SOCKET\n#else\n#define R_INVALID_SOCKET -1\n#endif\n\ntypedef struct {\n\tint child;\n#if __WINDOWS__\n\tHANDLE pipe;\n#else\n\tint input[2];\n\tint output[2];\n#endif\n\tRCoreBind coreb;\n} R2Pipe;\n\ntypedef struct r_socket_t {\n#ifdef _MSC_VER\n\tSOCKET fd;\n#else\n\tint fd;\n#endif\n\tbool is_ssl;\n\tint proto;\n\tint local;\t// TODO: merge ssl with local -> flags/options\n\tint port;\n\tstruct sockaddr_in sa;\n#if HAVE_LIB_SSL\n\tSSL_CTX *ctx;\n\tSSL *sfd;\n\tBIO *bio;\n#endif\n} RSocket;\n\ntypedef struct r_socket_http_options {\n\tRList *authtokens;\n\tbool accept_timeout;\n\tint timeout;\n\tbool httpauth;\n} RSocketHTTPOptions;\n\n\n#define R_SOCKET_PROTO_TCP IPPROTO_TCP\n#define R_SOCKET_PROTO_UDP IPPROTO_UDP\n#define R_SOCKET_PROTO_UNIX 0x1337\n\n#ifdef R_API\nR_API RSocket *r_socket_new_from_fd(int fd);\nR_API RSocket *r_socket_new(bool is_ssl);\nR_API bool r_socket_spawn(RSocket *s, const char *cmd, unsigned int timeout);\nR_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout);\nR_API int r_socket_connect_serial(RSocket *sock, const char *path, int speed, int parity);\n#define r_socket_connect_tcp(a, b, c, d) r_socket_connect (a, b, c, R_SOCKET_PROTO_TCP, d)\n#define r_socket_connect_udp(a, b, c, d) r_socket_connect (a, b, c, R_SOCKET_PROTO_UDP, d)\n#if __UNIX__\n#define r_socket_connect_unix(a, b) r_socket_connect (a, b, b, R_SOCKET_PROTO_UNIX, 0)\n#else\n#define r_socket_connect_unix(a, b) (false)\n#endif\nR_API bool r_socket_listen(RSocket *s, const char *port, const char *certfile);\nR_API int r_socket_port_by_name(const char *name);\nR_API int r_socket_close_fd(RSocket *s);\nR_API int r_socket_close(RSocket *s);\nR_API int r_socket_free(RSocket *s);\nR_API RSocket *r_socket_accept(RSocket *s);\nR_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout);\nR_API int r_socket_block_time(RSocket *s, int block, int sec, int usec);\nR_API int r_socket_flush(RSocket *s);\nR_API int r_socket_ready(RSocket *s, int secs, int usecs);\nR_API char *r_socket_to_string(RSocket *s);\nR_API int r_socket_write(RSocket *s, void *buf, int len);\nR_API int r_socket_puts(RSocket *s, char *buf);\nR_API void r_socket_printf(RSocket *s, const char *fmt, ...);\nR_API int r_socket_read(RSocket *s, ut8 *read, int len);\nR_API int r_socket_read_block(RSocket *s, unsigned char *buf, int len);\nR_API int r_socket_gets(RSocket *s, char *buf, int size);\nR_API ut8 *r_socket_slurp(RSocket *s, int *len);\nR_API bool r_socket_is_connected(RSocket *);\n\n/* process */\ntypedef struct r_socket_proc_t {\n\tint fd0[2];\n\tint fd1[2];\n\tint pid;\n} RSocketProc;\n\nR_API RSocketProc *r_socket_proc_open(char *const argv[]);\nR_API int r_socket_proc_close(RSocketProc *sp);\nR_API int r_socket_proc_read(RSocketProc *sp, unsigned char *buf, int len);\nR_API int r_socket_proc_gets(RSocketProc *sp, char *buf, int size);\nR_API int r_socket_proc_write(RSocketProc *sp, void *buf, int len);\nR_API void r_socket_proc_printf(RSocketProc *sp, const char *fmt, ...);\nR_API int r_socket_proc_ready(RSocketProc *sp, int secs, int usecs);\n\n/* HTTP */\nR_API char *r_socket_http_get(const char *url, int *code, int *rlen);\nR_API char *r_socket_http_post(const char *url, const char *data, int *code, int *rlen);\nR_API void r_socket_http_server_set_breaked(bool *b);\n\ntypedef struct r_socket_http_request {\n\tRSocket *s;\n\tchar *path;\n\tchar *host;\n\tchar *agent;\n\tchar *method;\n\tchar *referer;\n\tut8 *data;\n\tint data_length;\n\tbool auth;\n} RSocketHTTPRequest;\n\nR_API RSocketHTTPRequest *r_socket_http_accept(RSocket *s, RSocketHTTPOptions *so);\nR_API void r_socket_http_response(RSocketHTTPRequest *rs, int code, const char *out, int x, const char *headers);\nR_API void r_socket_http_close(RSocketHTTPRequest *rs);\nR_API ut8 *r_socket_http_handle_upload(const ut8 *str, int len, int *olen);\n\ntypedef int (*rap_server_open)(void *user, const char *file, int flg, int mode);\ntypedef int (*rap_server_seek)(void *user, ut64 offset, int whence);\ntypedef int (*rap_server_read)(void *user, ut8 *buf, int len);\ntypedef int (*rap_server_write)(void *user, ut8 *buf, int len);\ntypedef char *(*rap_server_cmd)(void *user, const char *command);\ntypedef int (*rap_server_close)(void *user, int fd);\n\nenum {\n\tRAP_PACKET_OPEN = 1,\n\tRAP_PACKET_READ = 2,\n\tRAP_PACKET_WRITE = 3,\n\tRAP_PACKET_SEEK = 4,\n\tRAP_PACKET_CLOSE = 5,\n\t// system was deprecated in slot 6,\n\tRAP_PACKET_CMD = 7,\n\tRAP_PACKET_REPLY = 0x80,\n\tRAP_PACKET_MAX = 4096\n};\n\ntypedef struct r_socket_rap_server_t {\n\tRSocket *fd;\n\tchar *port;\n\tut8 buf[RAP_PACKET_MAX + 32];\t// This should be used as a static buffer for everything done by the server\n\trap_server_open open;\n\trap_server_seek seek;\n\trap_server_read read;\n\trap_server_write write;\n\trap_server_cmd system;\n\trap_server_cmd cmd;\n\trap_server_close close;\n\tvoid *user;\t// Always first arg for callbacks\n} RSocketRapServer;\n\nR_API RSocketRapServer *r_socket_rap_server_new(bool is_ssl, const char *port);\nR_API RSocketRapServer *r_socket_rap_server_create(const char *pathname);\nR_API void r_socket_rap_server_free(RSocketRapServer *rap_s);\nR_API bool r_socket_rap_server_listen(RSocketRapServer *rap_s, const char *certfile);\nR_API RSocket *r_socket_rap_server_accept(RSocketRapServer *rap_s);\nR_API bool r_socket_rap_server_continue(RSocketRapServer *rap_s);\n\n/* rap client */\nR_API int r_socket_rap_client_open(RSocket *s, const char *file, int rw);\nR_API char *r_socket_rap_client_command(RSocket *s, const char *cmd, RCoreBind *c);\nR_API int r_socket_rap_client_write(RSocket *s, const ut8 *buf, int count);\nR_API int r_socket_rap_client_read(RSocket *s, ut8 *buf, int count);\nR_API int r_socket_rap_client_seek(RSocket *s, ut64 offset, int whence);\n\n/* run.c */\n#define R_RUN_PROFILE_NARGS 512\ntypedef struct r_run_profile_t {\n\tchar *_args[R_RUN_PROFILE_NARGS];\n\tint _argc;\n\tchar *_system;\n\tchar *_program;\n\tchar *_runlib;\n\tchar *_runlib_fcn;\n\tchar *_stdio;\n\tchar *_stdin;\n\tchar *_stdout;\n\tchar *_stderr;\n\tchar *_chgdir;\n\tchar *_chroot;\n\tchar *_libpath;\n\tchar *_preload;\n\tint _bits;\n\tint _pid;\n\tchar *_pidfile;\n\tint _r2preload;\n\tint _docore;\n\tint _dofork;\n\tint _dodebug;\n\tint _aslr;\n\tint _maxstack;\n\tint _maxproc;\n\tint _maxfd;\n\tint _r2sleep;\n\tint _execve;\n\tchar *_setuid;\n\tchar *_seteuid;\n\tchar *_setgid;\n\tchar *_setegid;\n\tchar *_input;\n\tchar *_connect;\n\tchar *_listen;\n\tint _pty;\n\tint _timeout;\n\tint _timeout_sig;\n\tint _nice;\n} RRunProfile;\n\nR_API RRunProfile *r_run_new(const char *str);\nR_API bool r_run_parse(RRunProfile *pf, const char *profile);\nR_API void r_run_free(RRunProfile *r);\nR_API bool r_run_parseline(RRunProfile *p, const char *b);\nR_API const char *r_run_help(void);\nR_API int r_run_config_env(RRunProfile *p);\nR_API int r_run_start(RRunProfile *p);\nR_API void r_run_reset(RRunProfile *p);\nR_API int r_run_parsefile(RRunProfile *p, const char *b);\n\n/* rapipe */\nR_API R2Pipe *rap_open(const char *cmd);\nR_API R2Pipe *rap_open_corebind(RCoreBind *coreb);\nR_API int rap_close(R2Pipe *rap);\n\nR_API char *rap_cmd(R2Pipe *rap, const char *str);\nR_API char *rap_cmdf(R2Pipe *rap, const char *fmt, ...);\n\nR_API int rap_write(R2Pipe *rap, const char *str);\nR_API char *rap_read(R2Pipe *rap);\n\nR_API int r2pipe_write(R2Pipe *r2pipe, const char *str);\nR_API char *r2pipe_read(R2Pipe *r2pipe);\nR_API int r2pipe_close(R2Pipe *r2pipe);\nR_API R2Pipe *r2pipe_open_corebind(RCoreBind *coreb);\nR_API R2Pipe *r2pipe_open(const char *cmd);\nR_API R2Pipe *r2pipe_open_dl(const char *file);\nR_API char *r2pipe_cmd(R2Pipe *r2pipe, const char *str);\nR_API char *r2pipe_cmdf(R2Pipe *r2pipe, const char *fmt, ...);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "#ifndef R2_TYPES_H\n#define R2_TYPES_H\n\n#undef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n\n// defines like IS_DIGIT, etc'\n#include \"r_util/r_str_util.h\"\n#include <r_userconf.h>\n#include <stddef.h>\n#include <assert.h>\n\n// TODO: fix this to make it crosscompile-friendly: R_SYS_OSTYPE ?\n/* operating system */\n#undef __BSD__\n#undef __KFBSD__\n#undef __UNIX__\n#undef __WINDOWS__\n\n#define R_MODE_PRINT 0x000\n#define R_MODE_RADARE 0x001\n#define R_MODE_SET 0x002\n#define R_MODE_SIMPLE 0x004\n#define R_MODE_JSON 0x008\n#define R_MODE_ARRAY 0x010\n#define R_MODE_SIMPLEST 0x020\n#define R_MODE_CLASSDUMP 0x040\n#define R_MODE_EQUAL 0x080\n\n#define R_IN /* do not use, implicit */\n#define R_OUT /* parameter is written, not read */\n#define R_INOUT /* parameter is read and written */\n#define R_OWN /* pointer ownership is transferred */\n#define R_BORROW /* pointer ownership is not transferred, it must not be freed by the receiver */\n#define R_NONNULL /* pointer can not be null */\n#define R_NULLABLE /* pointer can be null */\n#define R_DEPRECATE /* should not be used in new code and should/will be removed in the future */\n#define R_IFNULL(x) /* default value for the pointer when null */\n#ifdef __GNUC__\n#define R_UNUSED __attribute__((__unused__))\n#else\n#define R_UNUSED /* unused */\n#endif\n\n#ifdef R_NEW\n#undef R_NEW\n#endif\n\n#ifdef R_NEW0\n#undef R_NEW0\n#endif\n\n#ifdef R_FREE\n#undef R_FREE\n#endif\n\n#ifdef R_NEWCOPY\n#undef R_NEWCOPY\n#endif\n\n// used in debug, io, bin, anal, ...\n#define R_PERM_R\t4\n#define R_PERM_W\t2\n#define R_PERM_X\t1\n#define R_PERM_RW\t(R_PERM_R|R_PERM_W)\n#define R_PERM_RX\t(R_PERM_R|R_PERM_X)\n#define R_PERM_RWX\t(R_PERM_R|R_PERM_W|R_PERM_X)\n#define R_PERM_WX\t(R_PERM_W|R_PERM_X)\n#define R_PERM_SHAR\t8\n#define R_PERM_PRIV\t16\n#define R_PERM_ACCESS\t32\n#define R_PERM_CREAT\t64\n\n// HACK to fix capstone-android-mips build\n#undef mips\n#define mips mips\n\n#if defined(__powerpc) || defined(__powerpc__)\n#undef __POWERPC__\n#define __POWERPC__ 1\n#endif\n\n#if __IPHONE_8_0 && TARGET_OS_IPHONE\n#define LIBC_HAVE_SYSTEM 0\n#else\n#define LIBC_HAVE_SYSTEM 1\n#endif\n\n#if APPLE_SDK_IPHONEOS || APPLE_SDK_APPLETVOS || APPLE_SDK_WATCHOS || APPLE_SDK_APPLETVSIMULATOR || APPLE_SDK_WATCHSIMULATOR\n#define LIBC_HAVE_PTRACE 0\n#else\n#define LIBC_HAVE_PTRACE 1\n#endif\n\n#if HAVE_FORK\n#define LIBC_HAVE_FORK 1\n#else\n#define LIBC_HAVE_FORK 0\n#endif\n\n#if defined(__OpenBSD__)\n#include <sys/param.h>\n#undef MAXCOMLEN\t/* redefined in zipint.h */\n#endif\n\n/* release >= 5.9 */\n#if __OpenBSD__ && OpenBSD >= 201605\n#define LIBC_HAVE_PLEDGE 1\n#else\n#define LIBC_HAVE_PLEDGE 0\n#endif\n\n#ifdef __GNUC__\n#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_ ## x\n#else\n#  define UNUSED_FUNCTION(x) UNUSED_ ## x\n#endif\n\n#ifdef __EMSCRIPTEN__\n# define __UNIX__ 1\n#endif\n\n#ifdef __HAIKU__\n# define __UNIX__ 1\n#endif\n\n#if defined (__FreeBSD__) || defined (__FreeBSD_kernel__)\n#define __KFBSD__ 1\n#else\n#define __KFBSD__ 0\n#endif\n\n#ifdef _MSC_VER\n  #define restrict\n  #define strcasecmp stricmp\n  #define strncasecmp strnicmp\n  #define __WINDOWS__ 1\n\n  #include <time.h>\n  static inline struct tm *gmtime_r(const time_t *t, struct tm *r) { return (gmtime_s(r, t))? NULL : r; }\n#endif\n\n#if defined(EMSCRIPTEN) || defined(__linux__) || defined(__APPLE__) || defined(__GNU__) || defined(__ANDROID__) || defined(__QNX__) || defined(__sun)\n  #define __BSD__ 0\n  #define __UNIX__ 1\n#endif\n#if __KFBSD__ || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)\n  #define __BSD__ 1\n  #define __UNIX__ 1\n#endif\n#if __WINDOWS__ || _WIN32\n  #ifdef _MSC_VER\n  /* Must be included before windows.h */\n  #include <winsock2.h>\n  #ifndef WIN32_LEAN_AND_MEAN\n  #define WIN32_LEAN_AND_MEAN\n  #endif\n  #endif\n  typedef int socklen_t;\n  #undef USE_SOCKETS\n  #define __WINDOWS__ 1\n  #undef __UNIX__\n  #undef __BSD__\n#endif\n#if __WINDOWS__ || _WIN32\n  #define __addr_t_defined\n  #include <windows.h>\n#endif\n\n#if defined(__APPLE__) && (__arm__ || __arm64__ || __aarch64__)\n#define TARGET_OS_IPHONE 1\n#else\n#define TARGET_OS_IPHONE 0\n#endif\n\n#ifdef __GNUC__\n  #define FUNC_ATTR_MALLOC __attribute__((malloc))\n  #define FUNC_ATTR_ALLOC_SIZE(x) __attribute__((alloc_size(x)))\n  #define FUNC_ATTR_ALLOC_SIZE_PROD(x,y) __attribute__((alloc_size(x,y)))\n  #define FUNC_ATTR_ALLOC_ALIGN(x) __attribute__((alloc_align(x)))\n  #define FUNC_ATTR_PURE __attribute__ ((pure))\n  #define FUNC_ATTR_CONST __attribute__((const))\n  #define FUNC_ATTR_USED __attribute__((used))\n  #define FUNC_ATTR_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n  #define FUNC_ATTR_ALWAYS_INLINE __attribute__((always_inline))\n\n  #ifdef __clang__\n    // clang only\n  #elif defined(__INTEL_COMPILER)\n    // intel only\n  #else\n    // gcc only\n  #endif\n#else\n  #define FUNC_ATTR_MALLOC\n  #define FUNC_ATTR_ALLOC_SIZE(x)\n  #define FUNC_ATTR_ALLOC_SIZE_PROD(x,y)\n  #define FUNC_ATTR_ALLOC_ALIGN(x)\n  #define FUNC_ATTR_PURE\n  #define FUNC_ATTR_CONST\n  #define FUNC_ATTR_USED\n  #define FUNC_ATTR_WARN_UNUSED_RESULT\n  #define FUNC_ATTR_ALWAYS_INLINE\n#endif\n\n#include <r_types_base.h>\n\n#undef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#undef _GNU_SOURCE\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <fcntl.h> /* for O_RDONLY */\n#include <r_endian.h> /* needs size_t */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define TODO(x) eprintf(__func__\"  \" x)\n\n// TODO: FS or R_SYS_DIR ??\n#undef FS\n#if __WINDOWS__\n#define FS \"\\\\\"\n#define R_SYS_DIR \"\\\\\"\n#define R_SYS_ENVSEP \";\"\n#define R_SYS_HOME \"USERPROFILE\"\n#define R_SYS_TMP \"TEMP\"\n#else\n#define FS \"/\"\n#define R_SYS_DIR \"/\"\n#define R_SYS_ENVSEP \":\"\n#define R_SYS_HOME \"HOME\"\n#define R_SYS_TMP \"TMPDIR\"\n#endif\n\n#define R_JOIN_2_PATHS(p1, p2) p1 R_SYS_DIR p2\n#define R_JOIN_3_PATHS(p1, p2, p3) p1 R_SYS_DIR p2 R_SYS_DIR p3\n#define R_JOIN_4_PATHS(p1, p2, p3, p4) p1 R_SYS_DIR p2 R_SYS_DIR p3 R_SYS_DIR p4\n#define R_JOIN_5_PATHS(p1, p2, p3, p4, p5) p1 R_SYS_DIR p2 R_SYS_DIR p3 R_SYS_DIR p4 R_SYS_DIR p5\n\n#ifndef __packed\n#define __packed __attribute__((__packed__))\n#endif\n\ntypedef int (*PrintfCallback)(const char *str, ...);\n\n/* compile-time introspection helpers */\n#define CTO(y,z) ((size_t) &((y*)0)->z)\n#define CTA(x,y,z) (x+CTO(y,z))\n#define CTI(x,y,z) (*((size_t*)(CTA(x,y,z))))\n#define CTS(x,y,z,t,v) {t* _=(t*)CTA(x,y,z);*_=v;}\n\n#ifdef R_IPI\n#undef R_IPI\n#endif\n\n#define R_IPI\n\n#ifdef R_HEAP\n#undef R_HEAP\n#endif\n#define R_HEAP\n\n#ifdef R_API\n#undef R_API\n#endif\n#if R_SWIG\n  #define R_API export\n#elif R_INLINE\n  #define R_API inline\n#else\n  #if defined(__GNUC__) && __GNUC__ >= 4\n    #define R_API __attribute__((visibility(\"default\")))\n  #elif defined(_MSC_VER)\n    #define R_API __declspec(dllexport)\n  #else\n    #define R_API\n  #endif\n#endif\n\n#define R_LIB_VERSION_HEADER(x) \\\nR_API const char *x##_version(void)\n#define R_LIB_VERSION(x) \\\nR_API const char *x##_version() { return \"\" R2_GITTAP; }\n\n#define BITS2BYTES(x) (((x)/8)+(((x)%8)?1:0))\n#define ZERO_FILL(x) memset (&x, 0, sizeof (x))\n#define R_NEWS0(x,y) (x*)calloc(y,sizeof(x))\n#define R_NEWS(x,y) (x*)malloc(sizeof(x)*(y))\n#define R_NEW0(x) (x*)calloc(1,sizeof(x))\n#define R_NEW(x) (x*)malloc(sizeof(x))\n#define R_NEWCOPY(x,y) (x*)r_new_copy(sizeof(x), y)\n\nstatic inline void *r_new_copy(int size, void *data) {\n\tvoid *a = malloc(size);\n\tif (a) {\n\t\tmemcpy (a, data, size);\n\t}\n\treturn a;\n}\n// TODO: Make R_NEW_COPY be 1 arg, not two\n#define R_NEW_COPY(x,y) x=(void*)malloc(sizeof(y));memcpy(x,y,sizeof(y))\n#define R_MEM_ALIGN(x) ((void *)(size_t)(((ut64)(size_t)x) & 0xfffffffffffff000LL))\n#define R_ARRAY_SIZE(x) (sizeof (x) / sizeof ((x)[0]))\n#define R_PTR_MOVE(d,s) d=s;s=NULL;\n\n#define R_PTR_ALIGN(v,t) \\\n\t((char *)(((size_t)(v) ) \\\n\t& ~(t - 1)))\n#define R_PTR_ALIGN_NEXT(v,t) \\\n\t((char *)(((size_t)(v) + (t - 1)) \\\n\t& ~(t - 1)))\n\n#define R_BIT_SET(x,y) (((ut8*)x)[y>>4] |= (1<<(y&0xf)))\n#define R_BIT_UNSET(x,y) (((ut8*)x)[y>>4] &= ~(1<<(y&0xf)))\n#define R_BIT_TOGGLE(x, y) ( R_BIT_CHK (x, y) ? \\\n\t\tR_BIT_UNSET (x, y): R_BIT_SET (x, y))\n\n//#define R_BIT_CHK(x,y) ((((const ut8*)x)[y>>4] & (1<<(y&0xf))))\n#define R_BIT_CHK(x,y) (*(x) & (1<<(y)))\n\n/* try for C99, but provide backwards compatibility */\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\n#define __func__ __FUNCTION__\n#endif\n\n#define PERROR_WITH_FILELINE 0\n\n#if PERROR_WITH_FILELINE\n/* make error messages useful by prepending file, line, and function name */\n#define _perror(str,file,line,func) \\\n  { \\\n\t  char buf[256]; \\\n\t  snprintf(buf,sizeof(buf),\"[%s:%d %s] %s\",file,line,func,str); \\\n\t  r_sys_perror_str(buf); \\\n  }\n#define perror(x) _perror(x,__FILE__,__LINE__,__func__)\n#define r_sys_perror(x) _perror(x,__FILE__,__LINE__,__func__)\n#else\n#define r_sys_perror(x) r_sys_perror_str(x);\n#endif\n\n#if __UNIX__\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/time.h>\n#endif\n\n#ifndef HAVE_EPRINTF\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define HAVE_EPRINTF 1\n#endif\n\n#ifndef typeof\n#define typeof(arg) __typeof__(arg)\n#endif\n\n#if 1\n#define r_offsetof(type, member) offsetof(type, member)\n#else\n#if __SDB_WINDOWS__\n#define r_offsetof(type, member) ((unsigned long) (ut64)&((type*)0)->member)\n#else\n#define r_offsetof(type, member) ((unsigned long) &((type*)0)->member)\n#endif\n#endif\n\n#define R_BETWEEN(x,y,z) (((y)>=(x)) && ((y)<=(z)))\n#define R_ROUND(x,y) ((x)%(y))?(x)+((y)-((x)%(y))):(x)\n#define R_DIM(x,y,z) (((x)<(y))?(y):((x)>(z))?(z):(x))\n#ifndef R_MAX_DEFINED\n#define R_MAX(x,y) (((x)>(y))?(x):(y))\n#define R_MAX_DEFINED\n#endif\n#ifndef R_MIN_DEFINED\n#define R_MIN(x,y) (((x)>(y))?(y):(x))\n#define R_MIN_DEFINED\n#endif\n#define R_ABS(x) (((x)<0)?-(x):(x))\n#define R_BTW(x,y,z) (((x)>=(y))&&((y)<=(z)))?y:x\n\n#define R_FREE(x) { free((void *)x); x = NULL; }\n\n#if __WINDOWS__\n#define HAVE_REGEXP 0\n#else\n#define HAVE_REGEXP 1\n#endif\n\n#if __WINDOWS__\n#define PFMT64x \"I64x\"\n#define PFMT64d \"I64d\"\n#define PFMT64u \"I64u\"\n#define PFMT64o \"I64o\"\n#define PFMTSZx \"Ix\"\n#define PFMTSZd \"Id\"\n#define PFMTSZu \"Iu\"\n#define PFMTSZo \"Io\"\n#define LDBLFMT \"f\"\n#define HHXFMT  \"x\"\n#else\n#define PFMT64x \"llx\"\n#define PFMT64d \"lld\"\n#define PFMT64u \"llu\"\n#define PFMT64o \"llo\"\n#define PFMTSZx \"zx\"\n#define PFMTSZd \"zd\"\n#define PFMTSZu \"zu\"\n#define PFMTSZo \"zo\"\n#define LDBLFMT \"Lf\"\n#define HHXFMT  \"hhx\"\n#endif\n\n#define PFMT32x \"x\"\n#define PFMT32d \"d\"\n#define PFMT32u \"u\"\n#define PFMT32o \"o\"\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#if __APPLE__\n# if __i386__\n# define R_SYS_BASE ((ut64)0x1000)\n# elif __x86_64__\n# define R_SYS_BASE ((ut64)0x100000000)\n# else\n# define R_SYS_BASE ((ut64)0x1000)\n# endif\n#elif __WINDOWS__\n# define R_SYS_BASE ((ut64)0x01001000)\n#else // linux, bsd, ...\n# if __arm__ || __arm64__\n# define R_SYS_BASE ((ut64)0x4000)\n# else\n# define R_SYS_BASE ((ut64)0x8048000)\n# endif\n#endif\n\n/* arch */\n#if __i386__\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 0\n#elif __EMSCRIPTEN__\n#define R_SYS_ARCH \"wasm\"\n#define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n#define R_SYS_ENDIAN 0\n#elif __x86_64__\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n#define R_SYS_ENDIAN 0\n#elif __POWERPC__\n# define R_SYS_ARCH \"ppc\"\n# ifdef __powerpc64__\n#  define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n# else\n#  define R_SYS_BITS R_SYS_BITS_32\n# endif\n# if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#  define R_SYS_ENDIAN 0\n# else\n#  define R_SYS_ENDIAN 1\n# endif\n#elif __arm__\n#define R_SYS_ARCH \"arm\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 0\n#elif __arm64__ || __aarch64__\n#define R_SYS_ARCH \"arm\"\n#define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n#define R_SYS_ENDIAN 0\n#elif __arc__\n#define R_SYS_ARCH \"arc\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 0\n#elif __s390x__\n#define R_SYS_ARCH \"sysz\"\n#define R_SYS_BITS R_SYS_BITS_64\n#define R_SYS_ENDIAN 1\n#elif __sparc__\n#define R_SYS_ARCH \"sparc\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 1\n#elif __mips__\n#define R_SYS_ARCH \"mips\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 1\n#elif __EMSCRIPTEN__\n/* we should default to wasm when ready */\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS R_SYS_BITS_32\n#elif __riscv__ || __riscv\n# define R_SYS_ARCH \"riscv\"\n# define R_SYS_ENDIAN 0\n# if __riscv_xlen == 32\n#  define R_SYS_BITS R_SYS_BITS_32\n# else\n#  define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n# endif\n#else\n#ifdef _MSC_VER\n#ifdef _WIN64\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n#define R_SYS_ENDIAN 0\n#define __x86_64__ 1\n#else\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS (R_SYS_BITS_32)\n#define __i386__ 1\n#define R_SYS_ENDIAN 0\n#endif\n#else\n#define R_SYS_ARCH \"unknown\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 0\n#endif\n#endif\n\n#define R_SYS_ENDIAN_NONE 0\n#define R_SYS_ENDIAN_LITTLE 1\n#define R_SYS_ENDIAN_BIG 2\n#define R_SYS_ENDIAN_BI 3\n\nenum {\n\tR_SYS_ARCH_NONE = 0,\n\tR_SYS_ARCH_X86 = 0x1,\n\tR_SYS_ARCH_ARM = 0x2,\n\tR_SYS_ARCH_PPC = 0x4,\n\tR_SYS_ARCH_M68K = 0x8,\n\tR_SYS_ARCH_JAVA = 0x10,\n\tR_SYS_ARCH_MIPS = 0x20,\n\tR_SYS_ARCH_SPARC = 0x40,\n\tR_SYS_ARCH_XAP = 0x80,\n\tR_SYS_ARCH_MSIL = 0x100,\n\tR_SYS_ARCH_OBJD = 0x200,\n\tR_SYS_ARCH_BF = 0x400,\n\tR_SYS_ARCH_SH = 0x800,\n\tR_SYS_ARCH_AVR = 0x1000,\n\tR_SYS_ARCH_DALVIK = 0x2000,\n\tR_SYS_ARCH_Z80 = 0x4000,\n\tR_SYS_ARCH_ARC = 0x8000,\n\tR_SYS_ARCH_I8080 = 0x10000,\n\tR_SYS_ARCH_RAR = 0x20000,\n\tR_SYS_ARCH_8051 = 0x40000,\n\tR_SYS_ARCH_TMS320 = 0x80000,\n\tR_SYS_ARCH_EBC = 0x100000,\n\tR_SYS_ARCH_H8300 = 0x200000,\n\tR_SYS_ARCH_CR16 = 0x400000,\n\tR_SYS_ARCH_V850 = 0x800000,\n\tR_SYS_ARCH_SYSZ = 0x1000000,\n\tR_SYS_ARCH_XCORE = 0x2000000,\n\tR_SYS_ARCH_PROPELLER = 0x4000000,\n\tR_SYS_ARCH_MSP430 = 0x8000000LL, // 1<<27\n\tR_SYS_ARCH_CRIS =  0x10000000LL, // 1<<28\n\tR_SYS_ARCH_HPPA =  0x20000000LL, // 1<<29\n\tR_SYS_ARCH_V810 =  0x40000000LL, // 1<<30\n\tR_SYS_ARCH_LM32 =  0x80000000LL, // 1<<31\n};\n\n#if HAVE_CLOCK_NANOSLEEP && CLOCK_MONOTONIC && (__linux__ || (__FreeBSD__ && __FreeBSD_version >= 1101000) || (__NetBSD__ && __NetBSD_Version__ >= 700000000))\n#define HAS_CLOCK_NANOSLEEP 1\n#else\n#define HAS_CLOCK_NANOSLEEP 0\n#endif\n\n/* os */\n#if defined (__QNX__)\n#define R_SYS_OS \"qnx\"\n//#elif TARGET_OS_IPHONE\n//#define R_SYS_OS \"ios\"\n#elif defined (__APPLE__)\n#define R_SYS_OS \"darwin\"\n#elif defined (__linux__)\n#define R_SYS_OS \"linux\"\n#elif defined (__WINDOWS__)\n#define R_SYS_OS \"windows\"\n#elif defined (__NetBSD__ )\n#define R_SYS_OS \"netbsd\"\n#elif defined (__OpenBSD__)\n#define R_SYS_OS \"openbsd\"\n#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)\n#define R_SYS_OS \"freebsd\"\n#else\n#define R_SYS_OS \"unknown\"\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic inline void r_run_call1(void *fcn, void *arg1) {\n\t((void (*)(void *))(fcn))(arg1);\n}\n\nstatic inline void r_run_call2(void *fcn, void *arg1, void *arg2) {\n\t((void (*)(void *, void *))(fcn))(arg1, arg2);\n}\n\nstatic inline void r_run_call3(void *fcn, void *arg1, void *arg2, void *arg3) {\n\t((void (*)(void *, void *, void *))(fcn))(arg1, arg2, arg3);\n}\n\nstatic inline void r_run_call4(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4) {\n\t((void (*)(void *, void *, void *, void *))(fcn))(arg1, arg2, arg3, arg4);\n}\n\nstatic inline void r_run_call5(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5) {\n\t((void (*)(void *, void *, void *, void *, void *))(fcn))(arg1, arg2, arg3, arg4, arg5);\n}\n\nstatic inline void r_run_call6(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6) {\n\t((void (*)(void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6);\n}\n\nstatic inline void r_run_call7(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6, void *arg7) {\n\t((void (*)(void *, void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n}\n\nstatic inline void r_run_call8(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6, void *arg7, void *arg8) {\n\t((void (*)(void *, void *, void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n}\n\nstatic inline void r_run_call9(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6, void *arg7, void *arg8, void *arg9) {\n\t((void (*)(void *, void *, void *, void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n}\n\nstatic inline void r_run_call10(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6, void *arg7, void *arg8, void *arg9, void *arg10) {\n\t((void (*)(void *, void *, void *, void *, void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);\n}\n\n#ifndef container_of\n# ifdef _MSC_VER\n#  define container_of(ptr, type, member) ((type *)((char *)(ptr) - offsetof(type, member)))\n# else\n#  define container_of(ptr, type, member) ((type *)((char *)(__typeof__(((type *)0)->member) *){ptr} - offsetof(type, member)))\n# endif\n#endif\n\n// reference counter\ntypedef int RRef;\n\n#define R_REF_NAME refcount\n#define r_ref(x) x->R_REF_NAME++;\n#define r_ref_init(x) x->R_REF_NAME = 1\n#define r_unref(x,f) { assert (x->R_REF_NAME> 0); if (!--(x->R_REF_NAME)) { f(x); } }\n\n#define R_REF_TYPE RRef R_REF_NAME\n#define R_REF_FUNCTIONS(s, n) \\\nstatic inline void n##_ref(s *x) { x->R_REF_NAME++; } \\\nstatic inline void n##_unref(s *x) { r_unref (x, n##_free); }\n\n#endif // R2_TYPES_H\n", "#ifndef R_STR_H\n#define R_STR_H\n\n#include <wchar.h>\n#include \"r_str_util.h\"\n#include \"r_list.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n\tR_STRING_ENC_LATIN1 = 'a',\n\tR_STRING_ENC_UTF8 = '8',\n\tR_STRING_ENC_UTF16LE = 'u',\n\tR_STRING_ENC_UTF32LE = 'U',\n\tR_STRING_ENC_UTF16BE = 'b',\n\tR_STRING_ENC_UTF32BE = 'B',\n\tR_STRING_ENC_GUESS = 'g',\n} RStrEnc;\n\ntypedef int (*RStrRangeCallback) (void *, int);\n\n#define R_STR_ISEMPTY(x) (!(x) || !*(x))\n#define R_STR_ISNOTEMPTY(x) ((x) && *(x))\n#define R_STR_DUP(x) ((x) ? strdup ((x)) : NULL)\n#define r_str_array(x,y) ((y>=0 && y<(sizeof(x)/sizeof(*x)))?x[y]:\"\")\nR_API char *r_str_repeat(const char *ch, int sz);\nR_API const char *r_str_pad(const char ch, int len);\nR_API const char *r_str_rstr(const char *base, const char *p);\nR_API const char *r_strstr_ansi (const char *a, const char *b);\nR_API const char *r_str_rchr(const char *base, const char *p, int ch);\nR_API const char *r_str_closer_chr(const char *b, const char *s);\nR_API int r_str_bounds(const char *str, int *h);\nR_API char *r_str_crop(const char *str, unsigned int x, unsigned int y, unsigned int x2, unsigned int y2);\nR_API char *r_str_scale(const char *r, int w, int h);\nR_API bool r_str_range_in(const char *r, ut64 addr);\nR_API size_t r_str_len_utf8(const char *s);\nR_API size_t r_str_len_utf8_ansi(const char *str);\nR_API size_t r_str_len_utf8char(const char *s, int left);\nR_API size_t r_str_utf8_charsize(const char *str);\nR_API size_t r_str_utf8_charsize_prev(const char *str, int prev_len);\nR_API size_t r_str_utf8_charsize_last(const char *str);\nR_API void r_str_filter_zeroline(char *str, int len);\nR_API size_t r_str_utf8_codepoint(const char *s, size_t left);\nR_API bool r_str_char_fullwidth(const char *s, size_t left);\nR_API int r_str_write(int fd, const char *b);\nR_API void r_str_ncpy(char *dst, const char *src, size_t n);\nR_API void r_str_sanitize(char *c);\nR_API char *r_str_sanitize_sdb_key(const char *s);\nR_API const char *r_str_casestr(const char *a, const char *b);\nR_API const char *r_str_firstbut(const char *s, char ch, const char *but);\nR_API const char *r_str_lastbut(const char *s, char ch, const char *but);\nR_API int r_str_split(char *str, char ch);\nR_API RList *r_str_split_list(char *str, const char *c, int n);\nR_API RList *r_str_split_duplist(const char *str, const char *c);\nR_API int *r_str_split_lines(char *str, int *count);\nR_API char* r_str_replace(char *str, const char *key, const char *val, int g);\nR_API char *r_str_replace_icase(char *str, const char *key, const char *val, int g, int keep_case);\nR_API char *r_str_replace_in(char *str, ut32 sz, const char *key, const char *val, int g);\n#define r_str_cpy(x,y) memmove(x,y,strlen(y)+1);\nR_API int r_str_bits(char *strout, const ut8 *buf, int len, const char *bitz);\nR_API int r_str_bits64(char *strout, ut64 in);\nR_API ut64 r_str_bits_from_string(const char *buf, const char *bitz);\nR_API int r_str_rwx(const char *str);\nR_API int r_str_replace_ch(char *s, char a, char b, bool g);\nR_API int r_str_replace_char(char *s, int a, int b);\nR_API int r_str_replace_char_once(char *s, int a, int b);\nR_API void r_str_remove_char(char *str, char c);\nR_API const char *r_str_rwx_i(int rwx);\nR_API int r_str_fmtargs(const char *fmt);\nR_API char *r_str_arg_escape(const char *arg);\nR_API int r_str_arg_unescape(char *arg);\nR_API char **r_str_argv(const char *str, int *_argc);\nR_API void r_str_argv_free(char **argv);\nR_API char *r_str_new(const char *str);\nR_API int r_snprintf (char *string, int len, const char *fmt, ...);\nR_API bool r_str_is_ascii(const char *str);\nR_API char *r_str_nextword(char *s, char ch);\nR_API bool r_str_is_printable(const char *str);\nR_API bool r_str_is_printable_limited(const char *str, int size);\nR_API bool r_str_is_printable_incl_newlines(const char *str);\nR_API char *r_str_appendlen(char *ptr, const char *string, int slen);\nR_API char *r_str_newf(const char *fmt, ...);\nR_API char *r_str_newlen(const char *str, int len);\nR_API const char *r_str_sysbits(const int v);\nR_API char *r_str_trunc_ellipsis(const char *str, int len);\nR_API const char *r_str_bool(int b);\nR_API bool r_str_is_true(const char *s);\nR_API bool r_str_is_false(const char *s);\nR_API bool r_str_is_bool(const char *val);\nR_API const char *r_str_ansi_chrn(const char *str, size_t n);\nR_API size_t r_str_ansi_len(const char *str);\nR_API size_t r_str_ansi_nlen(const char *str, size_t len);\nR_API int r_str_ansi_trim(char *str, int str_len, int n);\nR_API int r_str_ansi_filter(char *str, char **out, int **cposs, int len);\nR_API char *r_str_ansi_crop(const char *str, unsigned int x, unsigned int y, unsigned int x2, unsigned int y2);\nR_API int r_str_word_count(const char *string);\nR_API int r_str_char_count(const char *string, char ch);\nR_API char *r_str_word_get0set(char *stra, int stralen, int idx, const char *newstr, int *newlen);\nR_API int r_str_word_set0(char *str);\nR_API int r_str_word_set0_stack(char *str);\nR_API const char *r_str_word_get0(const char *str, int idx);\nR_API char *r_str_word_get_first(const char *string);\nR_API void r_str_trim(char *str);\nR_API char *r_str_trim_dup(const char *str);\nR_API char *r_str_trim_lines(char *str);\nR_API void r_str_trim_head(char *str);\nR_API const char *r_str_trim_head_ro(const char *str);\nR_API const char *r_str_trim_head_wp(const char *str);\nR_API void r_str_trim_tail(char *str);\nR_API ut32 r_str_hash(const char *str);\nR_API ut64 r_str_hash64(const char *str);\nR_API char *r_str_trim_nc(char *str);\nR_API const char *r_str_nstr(const char *from, const char *to, int size);\nR_API const char *r_str_lchr(const char *str, char chr);\nR_API const char *r_sub_str_lchr(const char *str, int start, int end, char chr);\nR_API const char *r_sub_str_rchr(const char *str, int start, int end, char chr);\nR_API char *r_str_ichr(char *str, char chr);\nR_API bool r_str_ccmp(const char *dst, const char *orig, int ch);\nR_API bool r_str_cmp_list(const char *list, const char *item, char sep);\nR_API int r_str_cmp(const char *dst, const char *orig, int len);\nR_API int r_str_casecmp(const char *dst, const char *orig);\nR_API int r_str_ncasecmp(const char *dst, const char *orig, size_t n);\nR_API int r_str_ccpy(char *dst, char *orig, int ch);\nR_API const char *r_str_get(const char *str);\nR_API const char *r_str_get2(const char *str);\nR_API char *r_str_ndup(const char *ptr, int len);\nR_API char *r_str_dup(char *ptr, const char *string);\nR_API int r_str_inject(char *begin, char *end, char *str, int maxlen);\nR_API int r_str_delta(char *p, char a, char b);\nR_API void r_str_filter(char *str, int len);\nR_API const char * r_str_tok(const char *str1, const char b, size_t len);\nR_API wchar_t *r_str_mb_to_wc(const char *buf);\nR_API char *r_str_wc_to_mb(const wchar_t *buf);\nR_API wchar_t *r_str_mb_to_wc_l(const char *buf, int len);\nR_API char *r_str_wc_to_mb_l(const wchar_t *buf, int len);\nR_API const char *r_str_str_xy(const char *s, const char *word, const char *prev, int *x, int *y);\n\ntypedef void(*str_operation)(char *c);\n\nR_API int r_str_do_until_token(str_operation op, char *str, const char tok);\n\nR_API void r_str_reverse(char *str);\nR_API int r_str_re_match(const char *str, const char *reg);\nR_API int r_str_re_replace(const char *str, const char *reg, const char *sub);\nR_API int r_str_path_unescape(char *path);\nR_API char *r_str_path_escape(const char *path);\nR_API int r_str_unescape(char *buf);\nR_API char *r_str_escape(const char *buf);\nR_API char *r_str_escape_dot(const char *buf);\nR_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors);\nR_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash);\nR_API char *r_str_escape_utf8_keep_printable(const char *buf, bool show_asciidot, bool esc_bslash); // like escape_utf8 but leaves valid \\uXXXX chars directly in utf-8\nR_API char *r_str_escape_utf16le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash);\nR_API char *r_str_escape_utf32le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash);\nR_API char *r_str_escape_utf16be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash);\nR_API char *r_str_escape_utf32be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash);\nR_API void r_str_byte_escape(const char *p, char **dst, int dot_nl, bool default_dot, bool esc_bslash);\nR_API char *r_str_format_msvc_argv(size_t argc, const char **argv);\nR_API void r_str_uri_decode(char *buf);\nR_API char *r_str_uri_encode(const char *buf);\nR_API char *r_str_utf16_decode(const ut8 *s, int len);\nR_API int r_str_utf16_to_utf8(ut8 *dst, int len_dst, const ut8 *src, int len_src, int little_endian);\nR_API char *r_str_utf16_encode(const char *s, int len);\nR_API char *r_str_escape_utf8_for_json(const char *s, int len);\nR_API char *r_str_home(const char *str);\nR_API char *r_str_r2_prefix(const char *str);\nR_API size_t r_str_nlen(const char *s, int n);\nR_API size_t r_str_nlen_w(const char *s, int n);\nR_API size_t r_wstr_clen(const char *s);\nR_API char *r_str_prepend(char *ptr, const char *string);\nR_API char *r_str_prefix_all(const char *s, const char *pfx);\nR_API char *r_str_append(char *ptr, const char *string);\nR_API char *r_str_append_owned(char *ptr, char *string);\nR_API char *r_str_appendf(char *ptr, const char *fmt, ...);\nR_API char *r_str_appendch(char *x, char y);\nR_API void r_str_case(char *str, bool up);\nR_API void r_str_trim_path(char *s);\nR_API ut8 r_str_contains_macro(const char *input_value);\nR_API void r_str_truncate_cmd(char *string);\nR_API char* r_str_replace_thunked(char *str, char *clean, int *thunk, int clen,\n\t\t\t\t  const char *key, const char *val, int g);\nR_API bool r_str_glob(const char *str, const char *glob);\nR_API int r_str_binstr2bin(const char *str, ut8 *out, int outlen);\nR_API char *r_str_between(const char *str, const char *prefix, const char *suffix);\nR_API bool r_str_startswith(const char *str, const char *needle);\nR_API bool r_str_endswith(const char *str, const char *needle);\nR_API bool r_str_isnumber (const char *str);\nR_API const char *r_str_last (const char *in, const char *ch);\nR_API char* r_str_highlight(char *str, const char *word, const char *color, const char *color_reset);\nR_API char *r_qrcode_gen(const ut8 *text, int len, bool utf8, bool inverted);\nR_API char *r_str_from_ut64(ut64 val);\nR_API void r_str_stripLine(char *str, const char *key);\nR_API char *r_str_list_join(RList *str, const char *sep);\n\nR_API const char *r_str_sep(const char *base, const char *sep);\nR_API const char *r_str_rsep(const char *base, const char *p, const char *sep);\nR_API char *r_str_donut(int size);\nR_API char *r_str_version(const char *program);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //  R_STR_H\n", "/* radare - LGPL - Copyright 2006-2019 - pancake */\n\n/* must be included first because of winsock2.h and windows.h */\n#include <r_socket.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <errno.h>\n\n#if EMSCRIPTEN\n#define NETWORK_DISABLED 1\n#else\n#define NETWORK_DISABLED 0\n#endif\n\n#define D if(0)\n\nR_LIB_VERSION(r_socket);\n\n\n#if NETWORK_DISABLED\n/* no network */\nR_API RSocket *r_socket_new (bool is_ssl) {\n\treturn NULL;\n}\nR_API bool r_socket_is_connected (RSocket *s) {\n\treturn false;\n}\nR_API bool r_socket_connect (RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\treturn false;\n}\nR_API bool r_socket_spawn (RSocket *s, const char *cmd, unsigned int timeout) {\n\treturn -1;\n}\nR_API int r_socket_close_fd (RSocket *s) {\n\treturn -1;\n}\nR_API int r_socket_close (RSocket *s) {\n\treturn -1;\n}\nR_API int r_socket_free (RSocket *s) {\n\treturn -1;\n}\nR_API int r_socket_port_by_name(const char *name) {\n\treturn -1;\n}\nR_API bool r_socket_listen (RSocket *s, const char *port, const char *certfile) {\n\treturn false;\n}\nR_API RSocket *r_socket_accept(RSocket *s) {\n\treturn NULL;\n}\nR_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\treturn NULL;\n}\nR_API int r_socket_block_time (RSocket *s, int block, int sec, int usec) {\n\treturn -1;\n}\nR_API int r_socket_flush(RSocket *s) {\n\treturn -1;\n}\nR_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n\treturn -1;\n}\nR_API char *r_socket_to_string(RSocket *s) {\n\treturn NULL;\n}\nR_API int r_socket_write(RSocket *s, void *buf, int len) {\n\treturn -1;\n}\nR_API int r_socket_puts(RSocket *s, char *buf) {\n\treturn -1;\n}\nR_API void r_socket_printf(RSocket *s, const char *fmt, ...) {\n\t/* nothing here */\n}\nR_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\treturn -1;\n}\nR_API int r_socket_read_block(RSocket *s, unsigned char *buf, int len) {\n\treturn -1;\n}\nR_API int r_socket_gets(RSocket *s, char *buf,\tint size) {\n\treturn -1;\n}\nR_API RSocket *r_socket_new_from_fd (int fd) {\n\treturn NULL;\n}\nR_API ut8* r_socket_slurp(RSocket *s, int *len) {\n\treturn NULL;\n}\n#else\n\n#if 0\nwinsock api notes\n=================\nclose: closes the socket without flushing the data\nWSACleanup: closes all network connections\n#endif\n#define BUFFER_SIZE 4096\n\nR_API bool r_socket_is_connected(RSocket *s) {\n#if __WINDOWS__\n\tchar buf[2];\n\tr_socket_block_time (s, 0, 0, 0);\n#ifdef _MSC_VER\n\tint ret = recv (s->fd, (char*)&buf, 1, MSG_PEEK);\n#else\n\tssize_t ret = recv (s->fd, (char*)&buf, 1, MSG_PEEK);\n#endif\n\tr_socket_block_time (s, 1, 0, 0);\n\treturn ret == 1;\n#else\n\tint error = 0;\n\tsocklen_t len = sizeof (error);\n\tint ret = getsockopt (s->fd, SOL_SOCKET, SO_ERROR, &error, &len);\n\tif (ret != 0) {\n\t\tperror (\"getsockopt\");\n\t\treturn false;\n\t}\n\tif (error != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n#endif\n}\n\n#if __UNIX__\nstatic bool __connect_unix(RSocket *s, const char *file) {\n\tstruct sockaddr_un addr;\n\tint sock = socket (PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tfree (s);\n\t\treturn false;\n\t}\n\t// TODO: set socket options\n\taddr.sun_family = AF_UNIX;\n\tstrncpy (addr.sun_path, file, sizeof (addr.sun_path)-1);\n\n\tif (connect (sock, (struct sockaddr *)&addr, sizeof(addr))==-1) {\n\t\tclose (sock);\n\t\tfree (s);\n\t\treturn false;\n\t}\n\ts->fd = sock;\n\ts->is_ssl = false;\n\treturn true;\n}\n\nstatic bool __listen_unix (RSocket *s, const char *file) {\n\tstruct sockaddr_un unix_name;\n\tint sock = socket (PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\treturn false;\n\t}\n\t// TODO: set socket options\n\tunix_name.sun_family = AF_UNIX;\n\tstrncpy (unix_name.sun_path, file, sizeof (unix_name.sun_path)-1);\n\n\t/* just to make sure there is no other socket file */\n\tunlink (unix_name.sun_path);\n\n\tif (bind (sock, (struct sockaddr *) &unix_name, sizeof (unix_name)) < 0) {\n\t\tclose (sock);\n\t\treturn false;\n\t}\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n\n\t/* change permissions */\n\tif (chmod (unix_name.sun_path, 0777) != 0) {\n\t\tclose (sock);\n\t\treturn false;\n\t}\n\tif (listen (sock, 1)) {\n\t\tclose (sock);\n\t\treturn false;\n\t}\n\ts->fd = sock;\n\treturn true;\n}\n#endif\n\nR_API RSocket *r_socket_new(bool is_ssl) {\n\tRSocket *s = R_NEW0 (RSocket);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->is_ssl = is_ssl;\n\ts->port = 0;\n#if __UNIX_\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\ts->local = 0;\n\ts->fd = R_INVALID_SOCKET;\n#if HAVE_LIB_SSL\n\tif (is_ssl) {\n\t\ts->sfd = NULL;\n\t\ts->ctx = NULL;\n\t\ts->bio = NULL;\n#if OPENSSL_VERSION_NUMBER < 0x1010000fL\n\t\tif (!SSL_library_init ()) {\n\t\t\tr_socket_free (s);\n\t\t\treturn NULL;\n\t\t}\n\t\tSSL_load_error_strings ();\n#endif\n\t}\n#endif\n\treturn s;\n}\n\nR_API bool r_socket_spawn(RSocket *s, const char *cmd, unsigned int timeout) {\n\t// XXX TODO: dont use sockets, we can achieve the same with pipes\n\tconst int port = 2000 + r_num_rand (2000);\n\tint childPid = r_sys_fork ();\n\tif (childPid == 0) {\n\t\tchar *a = r_str_replace (strdup (cmd), \"\\\\\", \"\\\\\\\\\", true);\n\t\tint res = r_sys_cmdf (\"rarun2 system=\\\"%s\\\" listen=%d\", a, port);\n\t\tfree (a);\n#if 0\n\t\t// TODO: use the api\n\t\tchar *profile = r_str_newf (\n\t\t\t\t\"system=%s\\n\"\n\t\t\t\t\"listen=%d\\n\", cmd, port);\n\t\tRRunProfile *rp = r_run_new (profile);\n\t\tr_run_start (rp);\n\t\tr_run_free (rp);\n\t\tfree (profile);\n#endif\n\t\tif (res != 0) {\n\t\t\teprintf (\"r_socket_spawn: rarun2 failed\\n\");\n\t\t\texit (1);\n\t\t}\n\t\teprintf (\"r_socket_spawn: %s is dead\\n\", cmd);\n\t\texit (0);\n\t}\n\tr_sys_sleep (1);\n\tr_sys_usleep (timeout);\n\n\tchar aport[32];\n\tsprintf (aport, \"%d\", port);\n\t// redirect stdin/stdout/stderr\n\tbool sock = r_socket_connect (s, \"127.0.0.1\", aport, R_SOCKET_PROTO_TCP, 2000);\n\tif (!sock) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tr_sys_sleep (4);\n\tr_sys_usleep (timeout);\n\n\tint status = 0;\n\tint ret = waitpid (childPid, &status, WNOHANG);\n\tif (ret != 0) {\n\t\tr_socket_close (s);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nR_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\tr_return_val_if_fail (s, false);\n#if __WINDOWS__\n\tstruct sockaddr_in sa;\n\tstruct hostent *he;\n\tWSADATA wsadata;\n\tTIMEVAL Timeout;\n\tTimeout.tv_sec = timeout;\n\tTimeout.tv_usec = 0;\n\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n\ts->fd = socket (AF_INET, SOCK_STREAM, 0);\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn false;\n\t}\n\n\tunsigned long iMode = 1;\n\tint iResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n\tif (iResult != NO_ERROR) {\n\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n\t}\n\tmemset (&sa, 0, sizeof (sa));\n\tsa.sin_family = AF_INET;\n\the = (struct hostent *)gethostbyname (host);\n\tif (he == (struct hostent*)0) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n\tsa.sin_addr = *((struct in_addr *)he->h_addr);\n\ts->port = r_socket_port_by_name (port);\n\ts->proto = proto;\n\tsa.sin_port = htons (s->port);\n\tif (!connect (s->fd, (const struct sockaddr*)&sa, sizeof (struct sockaddr))) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n\tiMode = 0;\n\tiResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n\tif (iResult != NO_ERROR) {\n\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n\t}\n\tif (timeout > 0) {\n\t\tr_socket_block_time (s, 1, timeout, 0);\n\t}\n\tfd_set Write, Err;\n\tFD_ZERO (&Write);\n\tFD_ZERO (&Err);\n\tFD_SET (s->fd, &Write);\n\tFD_SET (s->fd, &Err);\n\tselect (0, NULL, &Write, &Err, &Timeout);\n\tif (FD_ISSET (s->fd, &Write)) {\n\t\treturn true;\n\t}\n\treturn false;\n#elif __UNIX__\n\tint ret;\n\tstruct addrinfo hints = {0};\n\tstruct addrinfo *res, *rp;\n\tif (!proto) {\n\t\tproto = R_SOCKET_PROTO_TCP;\n\t}\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n\tif (proto == R_SOCKET_PROTO_UNIX) {\n\t\tif (!__connect_unix (s, host)) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\thints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */\n\t\thints.ai_protocol = proto;\n\t\tint gai = getaddrinfo (host, port, &hints, &res);\n\t\tif (gai != 0) {\n\t\t\teprintf (\"r_socket_connect: Error in getaddrinfo: %s (%s:%s)\\n\",\n\t\t\t\tgai_strerror (gai), host, port);\n\t\t\treturn false;\n\t\t}\n\t\tfor (rp = res; rp != NULL; rp = rp->ai_next) {\n\t\t\tint flag = 1;\n\n\t\t\ts->fd = socket (rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n\t\t\tif (s->fd == -1) {\n\t\t\t\tperror (\"socket\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = setsockopt (s->fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof (flag));\n\t\t\tif (ret < 0) {\n\t\t\t\tperror (\"setsockopt\");\n\t\t\t\tclose (s->fd);\n\t\t\t\ts->fd = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tr_socket_block_time (s, 0, 0, 0);\n\t\t\tret = connect (s->fd, rp->ai_addr, rp->ai_addrlen);\n\n\t\t\tif (ret == 0) {\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (errno == EINPROGRESS) {\n\t\t\t\tstruct timeval tv;\n\t\t\t\ttv.tv_sec = timeout;\n\t\t\t\ttv.tv_usec = 0;\n\t\t\t\tfd_set wfds;\n\t\t\t\tFD_ZERO(&wfds);\n\t\t\t\tFD_SET(s->fd, &wfds);\n\n\t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n\t\t\t\t\tif (r_socket_is_connected (s)) {\n\t\t\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tperror (\"connect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t}\n\t\tfreeaddrinfo (res);\n\t\tif (!rp) {\n\t\t\teprintf (\"Could not resolve address '%s' or failed to connect\\n\", host);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\ts->sfd = SSL_new (s->ctx);\n\t\tSSL_set_fd (s->sfd, s->fd);\n\t\tif (SSL_connect (s->sfd) != 1) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\treturn true;\n}\n\n/* close the file descriptor associated with the RSocket s */\nR_API int r_socket_close_fd(RSocket *s) {\n#ifdef _MSC_VER\n\treturn s->fd != INVALID_SOCKET ? closesocket (s->fd) : false;\n#else\n\treturn s->fd != -1 ? close (s->fd) : false;\n#endif\n}\n\n/* shutdown the socket and close the file descriptor */\nR_API int r_socket_close(RSocket *s) {\n\tint ret = false;\n\tif (!s) {\n\t\treturn false;\n\t}\n\tif (s->fd != R_INVALID_SOCKET) {\n#if __UNIX__\n\t\tshutdown (s->fd, SHUT_RDWR);\n#endif\n#if __WINDOWS__\n\t\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms740481(v=vs.85).aspx\n\t\tshutdown (s->fd, SD_SEND);\n\t\tif (r_socket_ready (s, 0, 250)) {\n\t\t\tdo {\n\t\t\t\tchar buf = 0;\n\t\t\t\tret = recv (s->fd, &buf, 1, 0);\n\t\t\t} while (ret != 0 && ret != SOCKET_ERROR);\n\t\t}\n\t\tret = closesocket (s->fd);\n#else\n\t\tret = close (s->fd);\n#endif\n\t\ts->fd = R_INVALID_SOCKET;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl && s->sfd) {\n\t\tSSL_free (s->sfd);\n\t\ts->sfd = NULL;\n\t}\n#endif\n\treturn ret;\n}\n\n/* shutdown the socket, close the file descriptor and free the RSocket */\nR_API int r_socket_free(RSocket *s) {\n\tint res = r_socket_close (s);\n#if HAVE_LIB_SSL\n\tif (s && s->is_ssl) {\n\t\tif (s->sfd) {\n\t\t\tSSL_free (s->sfd);\n\t\t}\n\t\tif (s->ctx) {\n\t\t\tSSL_CTX_free (s->ctx);\n\t\t}\n\t}\n#endif\n\tfree (s);\n\treturn res;\n}\n\nR_API int r_socket_port_by_name(const char *name) {\n\tstruct servent *p = getservbyname (name, \"tcp\");\n\treturn (p && p->s_port) ? ntohs (p->s_port) : r_num_get (NULL, name);\n}\n\nR_API bool r_socket_listen(RSocket *s, const char *port, const char *certfile) {\n\tint optval = 1;\n\tint ret;\n\tstruct linger linger = { 0 };\n\n\tif (s->proto == R_SOCKET_PROTO_UNIX) {\n#if __UNIX__\n\t\treturn __listen_unix (s, port);\n#endif\n\t\treturn false;\n\t}\n\n\tif (r_sandbox_enable (0)) {\n\t\treturn false;\n\t}\n#if __WINDOWS__\n\tWSADATA wsadata;\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n#endif\n\tif ((s->fd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) == R_INVALID_SOCKET) {\n\t\treturn false;\n\t}\n\n\tlinger.l_onoff = 1;\n\tlinger.l_linger = 1;\n\tret = setsockopt (s->fd, SOL_SOCKET, SO_LINGER, (void*)&linger, sizeof (linger));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n\t{ // fix close after write bug //\n\tint x = 1500; // FORCE MTU\n\tret = setsockopt (s->fd, SOL_SOCKET, SO_SNDBUF, (void*)&x, sizeof (int));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n\t}\n\tret = setsockopt (s->fd, SOL_SOCKET, SO_REUSEADDR, (void*)&optval, sizeof optval);\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n\n\tmemset (&s->sa, 0, sizeof (s->sa));\n\ts->sa.sin_family = AF_INET;\n\ts->sa.sin_addr.s_addr = htonl (s->local? INADDR_LOOPBACK: INADDR_ANY);\n\ts->port = r_socket_port_by_name (port);\n\tif (s->port < 1) {\n\t\treturn false;\n\t}\n\ts->sa.sin_port = htons (s->port); // TODO honor etc/services\n\tif (bind (s->fd, (struct sockaddr *)&s->sa, sizeof (s->sa)) < 0) {\n\t\tr_sys_perror (\"bind\");\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n#if __UNIX__\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\tif (listen (s->fd, 32) < 0) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\tif (!SSL_CTX_use_certificate_chain_file (s->ctx, certfile)) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\tif (!SSL_CTX_use_PrivateKey_file (s->ctx, certfile, SSL_FILETYPE_PEM)) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\tSSL_CTX_set_verify_depth (s->ctx, 1);\n\t}\n#endif\n\treturn true;\n}\n\nR_API RSocket *r_socket_accept(RSocket *s) {\n\tRSocket *sock;\n\tsocklen_t salen = sizeof (s->sa);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tsock = R_NEW0 (RSocket);\n\tif (!sock) {\n\t\treturn NULL;\n\t}\n\t//signal (SIGPIPE, SIG_DFL);\n\tsock->fd = accept (s->fd, (struct sockaddr *)&s->sa, &salen);\n\tif (sock->fd == R_INVALID_SOCKET) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\t// not just a timeout\n\t\t\tr_sys_perror (\"accept\");\n\t\t}\n\t\tfree (sock);\n\t\treturn NULL;\n\t}\n#if HAVE_LIB_SSL\n\tsock->is_ssl = s->is_ssl;\n\tif (sock->is_ssl) {\n\t\tsock->sfd = NULL;\n\t\tsock->ctx = NULL;\n\t\tsock->bio = NULL;\n\t\tBIO *sbio = BIO_new_socket (sock->fd, BIO_NOCLOSE);\n\t\tsock->sfd = SSL_new (s->ctx);\n\t\tSSL_set_bio (sock->sfd, sbio, sbio);\n\t\tif (SSL_accept (sock->sfd) <= 0) {\n\t\t\tr_socket_free (sock);\n\t\t\treturn NULL;\n\t\t}\n\t\tsock->bio = BIO_new (BIO_f_buffer ());\n\t\tsbio = BIO_new (BIO_f_ssl ());\n\t\tBIO_set_ssl (sbio, sock->sfd, BIO_CLOSE);\n\t\tBIO_push (sock->bio, sbio);\n\t}\n#else\n\tsock->is_ssl = 0;\n#endif\n\treturn sock;\n}\n\nR_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\tfd_set read_fds;\n\tfd_set except_fds;\n\n\tFD_ZERO (&read_fds);\n\tFD_SET (s->fd, &read_fds);\n\n\tFD_ZERO (&except_fds);\n\tFD_SET (s->fd, &except_fds);\n\n\tstruct timeval t;\n\tt.tv_sec = timeout;\n\tt.tv_usec = 0;\n\n\tint r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);\n\tif(r < 0) {\n\t\tperror (\"select\");\n\t} else if (r > 0 && FD_ISSET (s->fd, &read_fds)) {\n\t\treturn r_socket_accept (s);\n\t}\n\n\treturn NULL;\n}\n\n// Only applies to read in UNIX\nR_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {0};\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_socket_flush(RSocket *s) {\n#if HAVE_LIB_SSL\n\tif (s->is_ssl && s->bio) {\n\t\treturn BIO_flush (s->bio);\n\t}\n#endif\n\treturn true;\n}\n\n// XXX: rewrite it to use select //\n/* waits secs until new data is received.\t  */\n/* returns -1 on error, 0 is false, 1 is true */\nR_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\t//int msecs = (1000 * secs) + (usecs / 1000);\n\tint msecs = (usecs / 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; /* always ready if unknown */\n#endif\n}\n\nR_API char *r_socket_to_string(RSocket *s) {\n#if __WINDOWS__\n\treturn r_str_newf (\"fd%d\", (int)(size_t)s->fd);\n#elif __UNIX__\n\tchar *str = NULL;\n\tstruct sockaddr sa;\n\tsocklen_t sl = sizeof (sa);\n\tmemset (&sa, 0, sizeof (sa));\n\tif (!getpeername (s->fd, &sa, &sl)) {\n\t\tstruct sockaddr_in *sain = (struct sockaddr_in*) &sa;\n\t\tut8 *a = (ut8*) &(sain->sin_addr);\n\t\tif ((str = malloc (32))) {\n\t\t\tsprintf (str, \"%d.%d.%d.%d:%d\",\n\t\t\t\ta[0], a[1], a[2], a[3], ntohs (sain->sin_port));\n\t\t}\n\t} else {\n\t\teprintf (\"getperrname: failed\\n\"); //r_sys_perror (\"getpeername\");\n\t}\n\treturn str;\n#else\n\treturn NULL;\n#endif\n}\n\n/* Read/Write functions */\nR_API int r_socket_write(RSocket *s, void *buf, int len) {\n\tD { eprintf (\"WRITE \"); int i; ut8 *b = buf; for (i = 0; i<len; i++) { eprintf (\"%02x \", b[i]); } eprintf (\"\\n\"); }\n\tint ret, delta = 0;\n#if __UNIX__\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\tfor (;;) {\n\t\tint b = 1500; //65536; // Use MTU 1500?\n\t\tif (b > len) {\n\t\t\tb = len;\n\t\t}\n#if HAVE_LIB_SSL\n\t\tif (s->is_ssl) {\n\t\t\tif (s->bio) {\n\t\t\t\tret = BIO_write (s->bio, buf+delta, b);\n\t\t\t} else {\n\t\t\t\tret = SSL_write (s->sfd, buf + delta, b);\n\t\t\t}\n\t\t} else\n#endif\n\t\t{\n\t\t\tret = send (s->fd, (char *)buf+delta, b, 0);\n\t\t}\n\t\t//if (ret == 0) return -1;\n\t\tif (ret < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == len) {\n\t\t\treturn len;\n\t\t}\n\t\tdelta += ret;\n\t\tlen -= ret;\n\t}\n\treturn (ret == -1)? -1 : delta;\n}\n\nR_API int r_socket_puts(RSocket *s, char *buf) {\n\treturn r_socket_write (s, buf, strlen (buf));\n}\n\nR_API void r_socket_printf(RSocket *s, const char *fmt, ...) {\n\tchar buf[BUFFER_SIZE];\n\tva_list ap;\n\tif (s->fd != R_INVALID_SOCKET) {\n\t\tva_start (ap, fmt);\n\t\tvsnprintf (buf, BUFFER_SIZE, fmt, ap);\n\t\tr_socket_write (s, buf, strlen (buf));\n\t\tva_end (ap);\n\t}\n}\n\nR_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\tif (!s) {\n\t\treturn -1;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\tif (s->bio) {\n\t\t\treturn BIO_read (s->bio, buf, len);\n\t\t}\n\t\treturn SSL_read (s->sfd, buf, len);\n\t}\n#endif\n#if __WINDOWS__\nrep:\n\t{\n\tint ret = recv (s->fd, (void *)buf, len, 0);\n\tif (ret == -1) {\n\t\tgoto rep;\n\t}\n\treturn ret;\n\t}\n#else\n\t// int r = read (s->fd, buf, len);\n\tint r = recv (s->fd, buf, len, 0);\n\tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n\treturn r;\n#endif\n}\n\nR_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {\n\tint ret = 0;\n\tfor (ret = 0; ret < len; ) {\n\t\tint r = r_socket_read (s, buf + ret, len - ret);\n\t\tif (r == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (r < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tret += r;\n\t}\n\treturn ret;\n}\n\nR_API int r_socket_gets(RSocket *s, char *buf,\tint size) {\n\tint i = 0;\n\tint ret = 0;\n\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\twhile (i < size) {\n\t\tret = r_socket_read (s, (ut8 *)buf + i, 1);\n\t\tif (ret == 0) {\n\t\t\tif (i > 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tr_socket_close (s);\n\t\t\treturn i == 0? -1: i;\n\t\t}\n\t\tif (buf[i] == '\\r' || buf[i] == '\\n') {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t\ti += ret;\n\t}\n\tbuf[i] = '\\0';\n\treturn i;\n}\n\nR_API RSocket *r_socket_new_from_fd(int fd) {\n\tRSocket *s = R_NEW0 (RSocket);\n\tif (s) {\n\t\ts->fd = fd;\n\t}\n\treturn s;\n}\n\nR_API ut8* r_socket_slurp(RSocket *s, int *len) {\n\tint blockSize = 4096;\n\tut8 *ptr, *buf = malloc (blockSize);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tint copied = 0;\n\tif (len) {\n\t\t*len = 0;\n\t}\n\tfor (;;) {\n\t\tint rc = r_socket_read (s, buf + copied, blockSize);\n\t\tif (rc > 0) {\n\t\t\tcopied += rc;\n\t\t}\n\t\tptr = realloc (buf, copied + blockSize);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf = ptr;\n\t\tif (rc < 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (copied == 0) {\n\t\tR_FREE (buf);\n\t}\n\tif (len) {\n\t\t*len = copied;\n\t}\n\treturn buf;\n}\n\n#endif // EMSCRIPTEN\n", "/* radare - LGPL - Copyright 2011-2020 - pancake */\n\n#include <r_socket.h>\n#include <r_util.h>\n\nstatic int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {\n\tint i;\n\tint chsz = 1;\n\t// r_socket_block_time (s, 1, 1, 0);\n\tif (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < bufsz; i += chsz) {\n\t\tbuf[i] =0;\n\t\tr_socket_block_time (s, 1, 0, 1000);\n\t\tint olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);\n\t\tif (olen != chsz) {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {\n\tr_return_val_if_fail (s, NULL);\n\tconst char *p;\n\tint ret, len = 0, bufsz = 32768, delta = 0;\n\tchar *dn, *buf = calloc (1, bufsz + 32); // XXX: use r_buffer here\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tchar *res = NULL;\n\tint olen = __socket_slurp (s, (ut8*)buf, bufsz);\n\tif ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {\n\t\tdelta += 2;\n\t} else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {\n\t\tdelta += 4;\n\t} else {\n\t\tgoto fail;\n\t}\n\n\tolen -= delta;\n\t*dn = 0; // chop headers\n\t/* Parse Len */\n\tp = r_str_casestr (buf, \"Content-Length: \");\n\tif (p) {\n\t\tlen = atoi (p + 16);\n\t} else {\n\t\tlen = olen - (dn - buf);\n\t}\n\tif (len > 0) {\n\t\tif (len > olen) {\n\t\t\tres = malloc (len + 2);\n\t\t\tmemcpy (res, dn + delta, olen);\n\t\t\tdo {\n\t\t\t\tret = r_socket_read_block (s, (ut8*) res + olen, len - olen);\n\t\t\t\tif (ret < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tolen += ret;\n\t\t\t} while (olen < len);\n\t\t\tres[len] = 0;\n\t\t} else {\n\t\t\tres = malloc (len + 1);\n\t\t\tif (res) {\n\t\t\t\tmemcpy (res, dn + delta, len);\n\t\t\t\tres[len] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = NULL;\n\t}\nfail:\n\tfree (buf);\n// is 's' free'd? isn't this going to cause a double free?\n\tr_socket_close (s);\n\tif (rlen) {\n\t\t*rlen = len;\n\t}\n\treturn res;\n}\n\nR_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (curl_env && *curl_env) {\n\t\tchar *encoded_url = r_str_escape (url);\n\t\tchar *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);\n\t\tfree (encoded_url);\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = strlen (res);\n\t\t\t}\n\t\t}\n\t\tfree (curl_env);\n\t\treturn res;\n\t}\n\tfree (curl_env);\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https://\");\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\thost = strstr (uri, \"://\");\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: */*\\r\\n\"\n\t\t\t\t\"Host: %s:%s\\r\\n\"\n\t\t\t\t\"\\r\\n\", path, host, port);\n\t\tresponse = r_socket_http_answer (s, code, rlen);\n\t} else {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tresponse = NULL;\n\t}\n\tfree (uri);\n\tr_socket_free (s);\n\treturn response;\n}\n\nR_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {\n\tRSocket *s;\n\tbool ssl = r_str_startswith (url, \"https://\");\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\n\tchar *host = strstr (uri, \"://\");\n\tif (!host) {\n\t\tfree (uri);\n\t\tprintf (\"Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tchar *port = strchr (host, ':');\n\tif (!port) {\n\t\tport = (ssl)? \"443\": \"80\";\n\t} else {\n\t\t*port++ = 0;\n\t}\n\tchar *path = strchr (host, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\tprintf (\"Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (!r_socket_connect_tcp (s, host, port, 0)) {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\t/* Send */\n\tr_socket_printf (s,\n\t\t\t\"POST /%s HTTP/1.0\\r\\n\"\n\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\"Accept: */*\\r\\n\"\n\t\t\t\"Host: %s\\r\\n\"\n\t\t\t\"Content-Length: %i\\r\\n\"\n\t\t\t\"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n\t\t\t\"\\r\\n\", path, host, (int)strlen (data));\n\tfree (uri);\n\tr_socket_write (s, (void *)data, strlen (data));\n\treturn r_socket_http_answer (s, code, rlen);\n}\n\n#if TEST\nvoid main () {\n\tint ret;\n\tchar *p = r_socket_http_post (\"http://www.radare.org/y/index.php\", \"a=b\", &ret);\n\tprintf (\"%s\\n\", p);\n}\n#endif\n", "/* radare - LGPL - Copyright 2007-2019 - pancake */\n\n#include \"r_types.h\"\n#include \"r_util.h\"\n#include \"r_cons.h\"\n#include \"r_bin.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdarg.h>\n\n/* stable code */\nstatic const char *nullstr = \"\";\nstatic const char *nullstr_c = \"(null)\";\nstatic const char *rwxstr[] = {\n\t[0] = \"---\",\n\t[1] = \"--x\",\n\t[2] = \"-w-\",\n\t[3] = \"-wx\",\n\t[4] = \"r--\",\n\t[5] = \"r-x\",\n\t[6] = \"rw-\",\n\t[7] = \"rwx\",\n\n\t[8] = \"---\",\n\t[9] = \"--x\",\n\t[10] = \"-w-\",\n\t[11] = \"-wx\",\n\t[12] = \"r--\",\n\t[13] = \"r-x\",\n\t[14] = \"rw-\",\n\t[15] = \"rwx\",\n};\n\nR_API int r_str_casecmp(const char *s1, const char *s2) {\n#ifdef _MSC_VER\n\treturn stricmp (s1, s2);\n#else\n\treturn strcasecmp (s1, s2);\n#endif\n}\n\nR_API int r_str_ncasecmp(const char *s1, const char *s2, size_t n) {\n#ifdef _MSC_VER\n\treturn _strnicmp (s1, s2, n);\n#else\n\treturn strncasecmp (s1, s2, n);\n#endif\n}\n\n// GOOD\n// In-place replace the first instance of the character a, with the character b.\nR_API int r_str_replace_ch(char *s, char a, char b, bool global) {\n\tint ret = 0;\n\tchar *o = s;\n\tif (!s || a == b) {\n\t\treturn 0;\n\t}\n\tfor (; *o; s++, o++) {\n\t\tif (*o == a) {\n\t\t\tret++;\n\t\t\tif (b) {\n\t\t\t\t*s = b;\n\t\t\t} else {\n\t\t\t\t/* remove char */\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tif (!global) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\t*s = *o;\n\t\t}\n\t}\n\t*s = 0;\n\treturn ret;\n}\n\nR_API int r_str_replace_char_once(char *s, int a, int b) {\n\treturn r_str_replace_ch (s, a, b, false);\n}\n\nR_API int r_str_replace_char(char *s, int a, int b) {\n\treturn r_str_replace_ch (s, a, b, true);\n}\n\nR_API void r_str_remove_char(char *str, char c) {\n\twhile (*str) {\n\t\tif (*str == c) {\n\t\t\tmemmove (str, str + 1, strlen (str + 1) + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tstr++;\n\t}\n}\n\nR_API void r_str_reverse(char *str) {\n\tint i, len = strlen (str);\n\tint half = len / 2;\n\tfor (i = 0; i < half; i++) {\n\t\tchar ch = str[i];\n\t\tstr[i] = str[len - i - 1];\n\t\tstr[len - i - 1] = ch;\n\t}\n}\n\n// TODO: do not use toupper.. must support modes to also append lowercase chars like in r1\n// TODO: this functions needs some stabilization\nR_API int r_str_bits(char *strout, const ut8 *buf, int len, const char *bitz) {\n\tint i, j, idx;\n\tif (bitz) {\n\t\tfor (i = j = 0; i<len && (!bitz||bitz[i]); i++) {\n\t\t\tif (i > 0 && (i % 8) == 0) {\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t\tif (*buf & (1 << (i % 8))) {\n\t\t\t\tstrout[j++] = toupper ((const ut8)bitz[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = j = 0; i < len; i++) {\n\t\t\tidx = (i / 8);\n\t\t\tint bit = 7 - (i % 8);\n\t\t\tstrout[j++] = (buf[idx] & (1 << bit))? '1' : '0';\n\t\t}\n\t}\n\tstrout[j] = 0;\n\treturn j;\n}\n\nR_API const char *r_str_sysbits(const int v) {\n\tswitch (v) {\n\tcase R_SYS_BITS_8: return \"8\";\n\tcase R_SYS_BITS_16: return \"16\";\n\tcase R_SYS_BITS_32: return \"32\";\n\tcase R_SYS_BITS_64: return \"64\";\n\tcase R_SYS_BITS_16 | R_SYS_BITS_32: return \"16,32\";\n\tcase R_SYS_BITS_16 | R_SYS_BITS_32 | R_SYS_BITS_64: return \"16,32,64\";\n\tcase R_SYS_BITS_32 | R_SYS_BITS_64: return \"32,64\";\n\t}\n\treturn \"?\";\n}\n\n// In-place trims a bitstring to groups of 8 bits.\n// For example, the bitstring 1000000000000000 will not be modified, but the\n// bitstring 0000000001000000 will be changed to 01000000.\nstatic void trimbits(char *b) {\n\tconst int len = strlen (b);\n\tchar *one = strchr (b, '1');\n\tint pos = one ? (int)(size_t)(one - b) : len - 1;\n\tpos = (pos / 8) * 8;\n\tmemmove (b, b + pos, len - pos + 1);\n}\n\n// Set 'strout' to the binary representation of the input value.\n// strout must be a char array of 65 or greater.\n// The string is then trimmed using the \"trimbits\" function above.\nR_API int r_str_bits64(char* strout, ut64 in) {\n\tint i, bit, count = 0;\n\tcount = 0;\n\tfor (i = (sizeof (in) * 8) - 1; i >= 0; i--) {\n\t\tbit = in >> i;\n\t\tif (bit & 1) {\n\t\t\tstrout[count] = '1';\n\t\t} else {\n\t\t\tstrout[count] = '0';\n\t\t}\n\t\tcount++;\n\t}\n\tstrout[count] = '\\0';\n\t/* trim by 8 bits */\n\ttrimbits (strout);\n\treturn count;\n}\n\n/**\n * function: r_str_bits_from_num\n *\n */\nR_API ut64 r_str_bits_from_string(const char *buf, const char *bitz) {\n\tut64 out = 0LL;\n\t/* return the numeric value associated to a string (rflags) */\n\tfor (; *buf; buf++) {\n\t\tchar *ch = strchr (bitz, toupper ((const unsigned char)*buf));\n\t\tif (!ch) {\n\t\t\tch = strchr (bitz, tolower ((const unsigned char)*buf));\n\t\t}\n\t\tif (ch) {\n\t\t\tint bit = (int)(size_t)(ch - bitz);\n\t\t\tout |= (ut64)(1LL << bit);\n\t\t} else {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t}\n\treturn out;\n}\n\nR_API int r_str_binstr2bin(const char *str, ut8 *out, int outlen) {\n\tint n, i, j, k, ret, len;\n\tlen = strlen (str);\n\tfor (n = i = 0; i < len; i += 8) {\n\t\tret = 0;\n\t\twhile (str[i]==' ') {\n\t\t\tstr++;\n\t\t}\n\t\tif (i + 7 < len) {\n\t\t\tfor (k = 0, j = i + 7; j >= i; j--, k++) {\n\t\t\t\t// INVERSE for (k=0,j=i; j<i+8; j++,k++) {\n\t\t\t\tif (str[j] == ' ') {\n\t\t\t\t\t//k--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//\t\tprintf (\"---> j=%d (%c) (%02x)\\n\", j, str[j], str[j]);\n\t\t\t\tif (str[j] == '1') {\n\t\t\t\t\tret|=1 << k;\n\t\t\t\t} else if (str[j] != '0') {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tprintf (\"-======> %02x\\n\", ret);\n\t\tout[n++] = ret;\n\t\tif (n == outlen) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn n;\n}\n\n// Returns the permissions as in integer given an input in the form of rwx, rx,\n// etc.\nR_API int r_str_rwx(const char *str) {\n\tint ret = atoi (str);\n\tif (!ret) {\n\t\tret |= strchr (str, 'm') ? 16 : 0;\n\t\tret |= strchr (str, 'r') ? 4 : 0;\n\t\tret |= strchr (str, 'w') ? 2 : 0;\n\t\tret |= strchr (str, 'x') ? 1 : 0;\n\t} else if (ret < 0 || ret >= R_ARRAY_SIZE (rwxstr)) {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n// Returns the string representation of the permission of the inputted integer.\nR_API const char *r_str_rwx_i(int rwx) {\n\tif (rwx < 0 || rwx >= R_ARRAY_SIZE (rwxstr)) {\n\t\trwx = 0;\n\t}\n\treturn rwxstr[rwx % 24]; // 15 for srwx\n}\n\n// If up is true, upcase all characters in the string, otherwise downcase all\n// characters in the string.\nR_API void r_str_case(char *str, bool up) {\n\tif (up) {\n\t\tchar oc = 0;\n\t\tfor (; *str; oc = *str++) {\n\t\t\t*str = (*str=='x' && oc=='0') ? 'x': toupper ((int)(ut8)*str);\n\t\t}\n\t} else {\n\t\tfor (; *str; str++) {\n\t\t\t*str = tolower ((int)(ut8)*str);\n\t\t}\n\t}\n}\n\nR_API char *r_str_home(const char *str) {\n\tchar *dst, *home = r_sys_getenv (R_SYS_HOME);\n\tsize_t length;\n\tif (!home) {\n\t\thome = r_file_tmpdir ();\n\t\tif (!home) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tlength = strlen (home) + 1;\n\tif (str) {\n\t\tlength += strlen (R_SYS_DIR) + strlen (str);\n\t}\n\tdst = (char *)malloc (length);\n\tif (!dst) {\n\t\tgoto fail;\n\t}\n\tint home_len = strlen (home);\n\tmemcpy (dst, home, home_len + 1);\n\tif (str) {\n\t\tdst[home_len] = R_SYS_DIR[0];\n\t\tstrcpy (dst + home_len + 1, str);\n\t}\nfail:\n\tfree (home);\n\treturn dst;\n}\n\nR_API char *r_str_r2_prefix(const char *str) {\n\treturn r_str_newf (\"%s%s%s\", r_sys_prefix (NULL), R_SYS_DIR, str);\n}\n\n// Compute a 64 bit DJB hash of a string.\nR_API ut64 r_str_hash64(const char *s) {\n\tut64 len, h = 5381;\n\tif (!s) {\n\t\treturn 0;\n\t}\n\tfor (len = strlen (s); len > 0; len--) {\n\t\th = (h ^ (h << 5)) ^ *s++;\n\t}\n\treturn h;\n}\n\n// Compute a 32bit DJB hash of a string.\nR_API ut32 r_str_hash(const char *s) {\n\treturn (ut32) r_str_hash64 (s);\n}\n\nR_API int r_str_delta(char *p, char a, char b) {\n\tchar *_a = strchr (p, a);\n\tchar *_b = strchr (p, b);\n\treturn (!_a || !_b)? 0 : (_a - _b);\n}\n\n// In-place split string using ch as a delimiter. Replaces all instances of ch\n// with a null byte. Returns the number of split strings. For example\n// r_str_split(\"hello world\", ' ') will replace the space with '\\0' and\n// return 2.\nR_API int r_str_split(char *str, char ch) {\n\tint i;\n\tchar *p;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\t/* TODO: sync with r1 code */\n\tfor (i = 1, p = str; *p; p++) {\n\t\tif (*p == ch) {\n\t\t\ti++;\n\t\t\t*p = '\\0';\n\t\t} // s/ /\\0/g\n\t}\n\treturn i;\n}\n\n// Convert a string into an array of string separated by \\0\n// And the last by \\0\\0\n// Separates by words and skip spaces.\n// Returns the number of tokens that the string is tokenized into.\nR_API int r_str_word_set0(char *str) {\n\tint i, quote = 0;\n\tchar *p;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; str[i] && str[i + 1]; i++) {\n\t\tif (i > 0 && str[i-1] == ' ' && str[i] == ' ') {\n\t\t\tint len = strlen (str + i);\n\t\t\tmemmove (str + i, str + i + 1, len);\n\t\t\ti--;\n\t\t}\n\t}\n\tif (str[i] == ' ') {\n\t\tstr[i] = 0;\n\t}\n\tfor (i = 1, p = str; *p; p++) {\n\t\tif (*p == '\\\"') {\n\t\t\tif (quote) {\n\t\t\t\tquote = 0;\n\t\t\t\t*p = '\\0';\n\t\t\t\t// FIX: i++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tquote = 1;\n\t\t\t\tmemmove (p, p + 1, strlen (p + 1) + 1);\n\t\t\t}\n\t\t}\n\t\tif (quote) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ' ') {\n\t\t\tchar *q = p - 1;\n\t\t\tif (p > str && (*q == '\\\\' || !*q)) {\n\t\t\t\tmemmove (p, p + 1, strlen (p + 1) + 1);\n\t\t\t\tif (*q == '\\\\') {\n\t\t\t\t\t*q = ' ';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp--;\n\t\t\t}\n\t\t\ti++;\n\t\t\t*p = '\\0';\n\t\t} // s/ /\\0/g\n\t}\n\treturn i;\n}\n\nR_API int r_str_word_set0_stack(char *str) {\n\tint i;\n\tchar *p, *q;\n\tRStack *s;\n\tvoid *pop;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; str[i] && str[i+1]; i++) {\n\t\tif (i > 0 && str[i - 1] == ' ' && str[i] == ' ') {\n\t\t\tmemmove (str + i, str + i + 1, strlen (str + i));\n\t\t\ti--;\n\t\t}\n\t\tif (i == 0 && str[i] == ' ') {\n\t\t\tmemmove (str + i, str + i + 1, strlen (str + i));\n\t\t}\n\t}\n\tif (str[i] == ' ') {\n\t\tstr[i] = 0;\n\t}\n\ts = r_stack_new (5); //Some random number\n\tfor (i = 1, p = str; *p; p++) {\n\t\tq = p - 1;\n\t\tif (p > str && (*q == '\\\\')) {\n\t\t\tmemmove (q, p, strlen (p) + 1);\n\t\t\tp--;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (*p) {\n\t\tcase '(':\n\t\tcase '{':\n\t\tcase '[':\n\t\t\tr_stack_push (s, (void *)p);\n\t\t\tcontinue;\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tpop = r_stack_pop (s);\n\t\t\tif (pop && *(char *)pop != *p) {\n\t\t\t\tr_stack_push (s, pop);\n\t\t\t\tr_stack_push (s, (void *)p);\n\t\t\t} else if (!pop) {\n\t\t\t\tr_stack_push (s, (void *)p);\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase ')':\n\t\tcase '}':\n\t\tcase ']':\n\t\t\tpop = r_stack_pop (s);\n\t\t\tif (pop) {\n\t\t\t\tif ((*(char *)pop == '(' && *p == ')') ||\n\t\t\t\t\t(*(char *)pop == '{' && *p == '}') ||\n\t\t\t\t\t(*(char *)pop == '[' && *p == ']')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tif (p > str && !*q) {\n\t\t\t\tmemmove (p, p+1, strlen (p + 1) + 1);\n\t\t\t\tif (*q == '\\\\') {\n\t\t\t\t\t*q = ' ';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tif (r_stack_is_empty (s)) {\n\t\t\t\ti++;\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_stack_free (s);\n\treturn i;\n}\n\nR_API char *r_str_word_get0set(char *stra, int stralen, int idx, const char *newstr, int *newlen) {\n\tchar *p = NULL;\n\tchar *out;\n\tint alen, blen, nlen;\n\tif (!stra && !newstr) {\n\t\treturn NULL;\n\t}\n\tif (stra) {\n\t\tp = (char *)r_str_word_get0 (stra, idx);\n\t}\n\tif (!p) {\n\t\tint nslen = strlen (newstr);\n\t\tout = malloc (nslen + 1);\n\t\tif (!out) {\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy (out, newstr);\n\t\tout[nslen] = 0;\n\t\tif (newlen) {\n\t\t\t*newlen = nslen;\n\t\t}\n\t\treturn out;\n\t}\n\talen = (size_t)(p - stra);\n\tblen = stralen - ((alen + strlen (p)) + 1);\n\tif (blen < 0) {\n\t\tblen = 0;\n\t}\n\tnlen = alen + blen + strlen (newstr);\n\tout = malloc (nlen + 2);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\tif (alen > 0) {\n\t\tmemcpy (out, stra, alen);\n\t}\n\tmemcpy (out + alen, newstr, strlen (newstr) + 1);\n\tif (blen > 0) {\n\t\tmemcpy (out + alen + strlen (newstr) + 1, p + strlen (p) + 1, blen + 1);\n\t}\n\tout[nlen + 1] = 0;\n\tif (newlen) {\n\t\t*newlen = nlen + ((blen == 0)? 1 : 0);\n\t}\n\treturn out;\n}\n\n// Get the idx'th entry of a tokenized string.\n// XXX: Warning! this function is UNSAFE, check that the string has, at least,\n// idx+1 tokens.\nR_API const char *r_str_word_get0(const char *str, int idx) {\n\tint i;\n\tconst char *ptr = str;\n\tif (!ptr || idx < 0 /* prevent crashes with negative index */) {\n\t\treturn (char *)nullstr;\n\t}\n\tfor (i = 0; i != idx; i++) {\n\t\tptr += strlen (ptr) + 1;\n\t}\n\treturn ptr;\n}\n\n// Return the number of times that the character ch appears in the string.\nR_API int r_str_char_count(const char *string, char ch) {\n\tint i, count = 0;\n\tfor (i = 0; string[i]; i++) {\n\t\tif (string[i] == ch) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n// Counts the number of words (separated by separator characters: newlines, tabs,\n// return, space). See r_util.h for more details of the IS_SEPARATOR macro.\nR_API int r_str_word_count(const char *string) {\n\tconst char *text, *tmp;\n\tint word;\n\n\tfor (text = tmp = string; *text && IS_SEPARATOR (*text); text++) {\n\t\t;\n\t}\n\tfor (word = 0; *text; word++) {\n\t\tfor (; *text && !IS_SEPARATOR (*text); text++) {\n\t\t\t;\n\t\t}\n\t\tfor (tmp = text; *text && IS_SEPARATOR (*text); text++) {\n\t\t\t;\n\t\t}\n\t}\n\treturn word;\n}\n\n// Returns a pointer to the first instance of a character that isn't chr in a\n// string.\n// TODO: make this const-correct.\n// XXX if the string is only made up of chr, then the pointer will just point to\n// a null byte!\nR_API char *r_str_ichr(char *str, char chr) {\n\twhile (*str == chr) {\n\t\tstr++;\n\t}\n\treturn str;\n}\n\n// Returns a pointer to the last instance of the character chr in the input\n// string.\nR_API const char *r_str_lchr(const char *str, char chr) {\n\tif (str) {\n\t\tint len = strlen (str);\n\t\tfor (; len >= 0; len--) {\n\t\t\tif (str[len] == chr) {\n\t\t\t\treturn str + len;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* find the last char chr in the substring str[start:end] with end not included */\nR_API const char *r_sub_str_lchr(const char *str, int start, int end, char chr) {\n\tdo {\n\t\tend--;\n\t} while (str[end] != chr && end >= start);\n\treturn str[end] == chr ? &str[end] : NULL;\n}\n\n/* find the first char chr in the substring str[start:end] with end not included */\nR_API const char *r_sub_str_rchr(const char *str, int start, int end, char chr) {\n\twhile (str[start] != chr && start < end) {\n\t\tstart++;\n\t}\n\treturn str[start] == chr ? str + start : NULL;\n}\n\nR_API const char *r_str_sep(const char *base, const char *sep) {\n\tint i;\n\twhile (*base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*base == sep[i]) {\n\t\t\t\treturn base;\n\t\t\t}\n\t\t}\n\t\tbase++;\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_rsep(const char *base, const char *p, const char *sep) {\n\tint i;\n\twhile (p >= base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*p == sep[i]) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\tp--;\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_rstr(const char *base, const char *p) {\n\tchar *s = strdup (base);\n\tchar *k = strdup (p);\n\tr_str_reverse (s);\n\tr_str_reverse (k);\n\tchar *q = strstr (s, k);\n\tconst char *r = NULL;\n\tif (q) {\n\t\tr = base + strlen (base) - (q - s) - strlen (p);\n\t}\n\tfree (s);\n\tfree (k);\n\treturn r;\n}\n\nR_API const char *r_str_rchr(const char *base, const char *p, int ch) {\n\tr_return_val_if_fail (base, NULL);\n\tif (!p) {\n\t\tp = base + strlen (base);\n\t}\n\tfor (; p >= base; p--) {\n\t\tif (ch == *p) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (p >= base) ? p: NULL;\n}\n\nR_API const char *r_str_nstr(const char *s, const char *find, int slen) {\n\tchar c, sc;\n\tsize_t len;\n\n\tif ((c = *find++) != '\\0') {\n\t\tlen = strlen (find);\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tif (slen-- < 1 || !(sc = *s++)) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} while (sc != c);\n\t\t\tif (len > slen) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} while (strncmp (s, find, len) != 0);\n\t\ts--;\n\t}\n\treturn (char *)s;\n}\n\n// Returns a new heap-allocated copy of str.\n// XXX what's the diff with r_str_dup ?\nR_API char *r_str_new(const char *str) {\n\treturn str? strdup (str): NULL;\n}\n\n// Returns a new heap-allocated copy of str, sets str[len] to '\\0'.\n// If the input str is longer than len, it will be truncated.\nR_API char *r_str_newlen(const char *str, int len) {\n\tif (len < 1) {\n\t\treturn NULL;\n\t}\n\tchar *buf = malloc (len + 1);\n\tif (buf) {\n\t\tmemcpy (buf, str, len);\n\t\tbuf[len] = 0;\n\t}\n\treturn buf;\n}\n\nR_API char *r_str_trunc_ellipsis(const char *str, int len) {\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tif (strlen (str) < len) {\n\t\treturn strdup (str);\n\t}\n\tchar *buf = r_str_newlen (str, len);\n\tif (buf && len > 4) {\n\t\tstrcpy (buf + len - 4, \"...\");\n\t}\n\treturn buf;\n}\n\nR_API char *r_str_newf(const char *fmt, ...) {\n\tva_list ap, ap2;\n\n\tva_start (ap, fmt);\n\tif (!strchr (fmt, '%')) {\n\t\tva_end (ap);\n\t\treturn strdup (fmt);\n\t}\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t}\n\tva_end (ap2);\n\tva_end (ap);\n\treturn p;\n}\n\n// Secure string copy with null terminator (like strlcpy or strscpy but ours\nR_API void r_str_ncpy(char *dst, const char *src, size_t n) {\n\tint i;\n\n\t// do not do anything if n is 0\n\tif (n == 0) {\n\t\treturn;\n\t}\n\n\tn--;\n\tfor (i = 0; src[i] && n > 0; i++, n--) {\n\t\tdst[i] = src[i];\n\t}\n\tdst[i] = 0;\n}\n\n/* memccmp(\"foo.bar\", \"foo.cow, '.') == 0 */\n// Returns 1 if src and dst are equal up until the first instance of ch in src.\nR_API bool r_str_ccmp(const char *dst, const char *src, int ch) {\n\tint i;\n\tfor (i = 0; src[i] && src[i] != ch; i++) {\n\t\tif (dst[i] != src[i]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// Returns true if item is in sep-separated list\nR_API bool r_str_cmp_list(const char *list, const char *item, char sep) {\n\tif (!list || !item) {\n\t\treturn false;\n\t}\n\tint i = 0, j = 0;\n\tfor (; list[i] && list[i] != sep; i++, j++) {\n\t\tif (item[j] != list[i]) {\n\t\t\twhile (list[i] && list[i] != sep) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (!list[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tj = -1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn true;\n}\n\n// like strncmp, but checking for null pointers\nR_API int r_str_cmp(const char *a, const char *b, int len) {\n\tif ((a == b) || (!a && !b)) {\n\t\treturn 0;\n\t}\n\tif (!a && b) {\n\t\treturn -1;\n\t}\n\tif (a && !b) {\n\t\treturn 1;\n\t}\n\tif (len < 0) {\n\t\treturn strcmp (a, b);\n\t}\n\treturn strncmp (a, b, len);\n}\n\n// Copies all characters from src to dst up until the character 'ch'.\nR_API int r_str_ccpy(char *dst, char *src, int ch) {\n\tint i;\n\tfor (i = 0; src[i] && src[i] != ch; i++) {\n\t\tdst[i] = src[i];\n\t}\n\tdst[i] = '\\0';\n\treturn i;\n}\n\nR_API char *r_str_word_get_first(const char *text) {\n\tfor (; *text && IS_SEPARATOR (*text); text++) {\n\t\t;\n\t}\n\treturn strdup (text);\n}\n\nR_API const char *r_str_get(const char *str) {\n\treturn str? str: nullstr_c;\n}\n\nR_API const char *r_str_get2(const char *str) {\n\treturn str? str: nullstr;\n}\n\nR_API char *r_str_ndup(const char *ptr, int len) {\n\tif (len < 0) {\n\t\treturn NULL;\n\t}\n\tchar *out = malloc (len + 1);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\tstrncpy (out, ptr, len);\n\tout[len] = 0;\n\treturn out;\n}\n\n// TODO: deprecate?\nR_API char *r_str_dup(char *ptr, const char *string) {\n\tfree (ptr);\n\treturn r_str_new (string);\n}\n\nR_API char *r_str_prepend(char *ptr, const char *string) {\n\tint slen, plen;\n\tif (!ptr) {\n\t\treturn strdup (string);\n\t}\n\tplen = strlen (ptr);\n\tslen = strlen (string);\n\tptr = realloc (ptr, slen + plen + 1);\n\tif (!ptr) {\n\t\treturn NULL;\n\t}\n\tmemmove (ptr + slen, ptr, plen + 1);\n\tmemmove (ptr, string, slen);\n\treturn ptr;\n}\n\nR_API char *r_str_appendlen(char *ptr, const char *string, int slen) {\n\tchar *msg = r_str_newlen (string, slen);\n\tchar *ret = r_str_append (ptr, msg);\n\tfree (msg);\n\treturn ret;\n}\n\nR_API char *r_str_append_owned(char *ptr, char *string) {\n\tif (!ptr) {\n\t\treturn string;\n\t}\n\tchar *r = r_str_append(ptr, string);\n\tfree (string);\n\treturn r;\n}\n/*\n * first argument must be allocated\n * return: the pointer ptr resized to string size.\n */\nR_API char *r_str_append(char *ptr, const char *string) {\n\tif (string && !ptr) {\n\t\treturn strdup (string);\n\t}\n\tif (!string) {\n\t\treturn ptr;\n\t}\n\tint plen = strlen (ptr);\n\tint slen = strlen (string);\n\tchar *newptr = realloc (ptr, slen + plen + 1);\n\tif (!newptr) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tptr = newptr;\n\tmemcpy (ptr + plen, string, slen + 1);\n\treturn ptr;\n}\n\nR_API char *r_str_appendf(char *ptr, const char *fmt, ...) {\n\tva_list ap, ap2;\n\n\tva_start (ap, fmt);\n\tif (!strchr (fmt, '%')) {\n\t\tva_end (ap);\n\t\treturn r_str_append (ptr, fmt);\n\t}\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t\tptr = r_str_append (ptr, p);\n\t\tfree (p);\n\t}\n\tva_end (ap2);\n\tva_end (ap);\n\treturn ptr;\n}\n\nR_API char *r_str_appendch(char *x, char y) {\n\tchar b[2] = { y, 0 };\n\treturn r_str_append (x, b);\n}\n\nR_API char* r_str_replace(char *str, const char *key, const char *val, int g) {\n\tif (g == 'i') {\n\t\treturn r_str_replace_icase (str, key, val, g, true);\n\t}\n\tr_return_val_if_fail (str && key && val, NULL);\n\n\tint off, i, slen;\n\tchar *newstr, *p = str;\n\tint klen = strlen (key);\n\tint vlen = strlen (val);\n\tif (klen == 1 && vlen < 2) {\n\t\tr_str_replace_char (str, *key, *val);\n\t\treturn str;\n\t}\n\tif (klen == vlen && !strcmp (key, val)) {\n\t\treturn str;\n\t}\n\tslen = strlen (str);\n\tchar *q = str;\n\tfor (;;) {\n\t\tp = strstr (q, key);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\toff = (int)(size_t)(p - str);\n\t\tif (vlen != klen) {\n\t\t\tint tlen = slen - (off + klen);\n\t\t\tslen += vlen - klen;\n\t\t\tif (vlen > klen) {\n\t\t\t\tnewstr = realloc (str, slen + 1);\n\t\t\t\tif (!newstr) {\n\t\t\t\t\teprintf (\"realloc fail\\n\");\n\t\t\t\t\tR_FREE (str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr = newstr;\n\t\t\t}\n\t\t\tp = str + off;\n\t\t\tmemmove (p + vlen, p + klen, tlen + 1);\n\t\t}\n\t\tmemcpy (p, val, vlen);\n\t\ti = off + vlen;\n\t\tq = str + i;\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API char *r_str_replace_icase(char *str, const char *key, const char *val, int g, int keep_case) {\n\tr_return_val_if_fail (str && key && val, NULL);\n\n\tint off, i, klen, vlen, slen;\n\tchar *newstr, *p = str;\n\tklen = strlen (key);\n\tvlen = strlen (val);\n\n\tslen = strlen (str);\n\tfor (i = 0; i < slen;) {\n\t\tp = (char *)r_str_casestr (str + i, key);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\toff = (int)(size_t) (p - str);\n\t\tif (vlen != klen) {\n\t\t\tint tlen = slen - (off + klen);\n\t\t\tslen += vlen - klen;\n\t\t\tif (vlen > klen) {\n\t\t\t\tnewstr = realloc (str, slen + 1);\n\t\t\t\tif (!newstr) {\n\t\t\t\t\tgoto alloc_fail;\n\t\t\t\t}\n\t\t\t\tstr = newstr;\n\t\t\t}\n\t\t\tp = str + off;\n\t\t\tmemmove (p + vlen, p + klen, tlen + 1);\n\t\t}\n\n\t\tif (keep_case) {\n\t\t\tchar *tmp_val = strdup (val);\n\t\t\tchar *str_case = r_str_ndup (p, klen);\n\t\t\tif (!tmp_val || !str_case) {\n\t\t\t\tfree (tmp_val);\n\t\t\t\tfree (str_case);\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\ttmp_val = r_str_replace_icase (tmp_val, key, str_case, 0, 0);\n\t\t\tfree (str_case);\n\t\t\tif (!tmp_val) {\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tmemcpy (p, tmp_val, vlen);\n\t\t\tfree (tmp_val);\n\t\t} else {\n\t\t\tmemcpy (p, val, vlen);\n\t\t}\n\n\t\ti = off + vlen;\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n\nalloc_fail:\n\teprintf (\"alloc fail\\n\");\n\tfree (str);\n\treturn NULL;\n}\n\n/* replace the key in str with val.\n *\n * str - input string\n * clean - input string cleaned of ANSI chars\n * thunk - array of integers that map each char of the clean string into the\n *         position in the str string\n * clen  - number of elements in thunk\n * key   - string to find in the clean string\n * val   - string that replaces key in the str string\n * g     - if true, replace all occurrences of key\n *\n * It returns a pointer to the modified string */\nR_API char* r_str_replace_thunked(char *str, char *clean, int *thunk, int clen,\n\t\t\t\t  const char *key, const char *val, int g) {\n\tint i, klen, vlen, slen, delta = 0, bias;\n\tchar *newstr, *scnd, *p = clean, *str_p;\n\n\tif (!str || !key || !val || !clean || !thunk) {\n\t\treturn NULL;\n\t}\n\tklen = strlen (key);\n\tvlen = strlen (val);\n\tif (klen == vlen && !strcmp (key, val)) {\n\t\treturn str;\n\t}\n\tslen = strlen (str) + 1;\n\n\tfor (i = 0; i < clen; ) {\n\t\tp = (char *)r_mem_mem (\n\t\t\t(const ut8*)clean + i, clen - i,\n\t\t\t(const ut8*)key, klen);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\ti = (int)(size_t)(p - clean);\n\t\t/* as the original string changes size during replacement\n\t\t * we need delta to keep track of it*/\n\t\tstr_p = str + thunk[i] + delta;\n\n\t\tint newo = thunk[i + klen] - thunk[i];\n\t\tr_str_ansi_filter (str_p, NULL, NULL, newo);\n\t\tscnd = strdup (str_p + newo);\n\t\tbias = vlen - newo;\n\n\t\tslen += bias;\n\t\t// HACK: this 32 avoids overwrites wtf\n\t\tnewstr = realloc (str, slen + klen);\n\t\tif (!newstr) {\n\t\t\teprintf (\"realloc fail\\n\");\n\t\t\tR_FREE (str);\n\t\t\tfree (scnd);\n\t\t\tbreak;\n\t\t}\n\t\tstr = newstr;\n\t\tstr_p = str + thunk[i] + delta;\n\t\tmemcpy (str_p, val, vlen);\n\t\tmemcpy (str_p + vlen, scnd, strlen (scnd) + 1);\n\t\ti += klen;\n\t\tdelta += bias;\n\t\tfree (scnd);\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API char *r_str_replace_in(char *str, ut32 sz, const char *key, const char *val, int g) {\n\tif (!str || !key || !val) {\n\t\treturn NULL;\n\t}\n\tchar *heaped = r_str_replace (strdup (str), key, val, g);\n\tif (heaped) {\n\t\tstrncpy (str, heaped, sz);\n\t\tfree (heaped);\n\t}\n\treturn str;\n}\n\nR_API int r_str_unescape(char *buf) {\n\tunsigned char ch = 0, ch2 = 0;\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; buf[i]; i++) {\n\t\tif (buf[i] != '\\\\') {\n\t\t\tcontinue;\n\t\t}\n\t\tint esc_seq_len = 2;\n\t\tswitch (buf[i + 1]) {\n\t\tcase 'e':\n\t\t\tbuf[i] = 0x1b;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tbuf[i] = '\\\\';\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tbuf[i] = 0x0d;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tbuf[i] = 0x0a;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tbuf[i] = 0x07;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbuf[i] = 0x08;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbuf[i] = 0x09;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tbuf[i] = 0x0b;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tbuf[i] = 0x0c;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\terr = ch2 = ch = 0;\n\t\t\tif (!buf[i + 2] || !buf[i + 3]) {\n\t\t\t\teprintf (\"Unexpected end of string.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\terr |= r_hex_to_byte (&ch,  buf[i + 2]);\n\t\t\terr |= r_hex_to_byte (&ch2, buf[i + 3]);\n\t\t\tif (err) {\n\t\t\t\teprintf (\"Error: Non-hexadecimal chars in input.\\n\");\n\t\t\t\treturn 0; // -1?\n\t\t\t}\n\t\t\tbuf[i] = (ch << 4) + ch2;\n\t\t\tesc_seq_len = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (IS_OCTAL (buf[i + 1])) {\n\t\t\t\tint num_digits = 1;\n\t\t\t\tbuf[i] = buf[i + 1] - '0';\n\t\t\t\tif (IS_OCTAL (buf[i + 2])) {\n\t\t\t\t\tnum_digits++;\n\t\t\t\t\tbuf[i] = (ut8)buf[i] * 8 + (buf[i + 2] - '0');\n\t\t\t\t\tif (IS_OCTAL (buf[i + 3])) {\n\t\t\t\t\t\tnum_digits++;\n\t\t\t\t\t\tbuf[i] = (ut8)buf[i] * 8 + (buf[i + 3] - '0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tesc_seq_len = 1 + num_digits;\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: Unknown escape sequence.\\n\");\n\t\t\t\treturn 0; // -1?\n\t\t\t}\n\t\t}\n\t\tmemmove (buf + i + 1, buf + i + esc_seq_len, strlen (buf + i + esc_seq_len) + 1);\n\t}\n\treturn i;\n}\n\nR_API void r_str_sanitize(char *c) {\n\tchar *d = c;\n\tif (d)  {\n\t\tfor (; *d; c++, d++) {\n\t\t\tswitch (*d) {\n\t\t\tcase '`':\n\t\t\tcase '$':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '~':\n\t\t\tcase '|':\n\t\t\tcase ';':\n\t\t\tcase '#':\n\t\t\tcase '@':\n\t\t\tcase '&':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\t\t*c = '_';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API char *r_str_sanitize_sdb_key(const char *s) {\n\tif (!s || !*s) {\n\t\treturn NULL;\n\t}\n\tsize_t len = strlen (s);\n\tchar *ret = malloc (len + 1);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tchar *cur = ret;\n\twhile (len > 0) {\n\t\tchar c = *s;\n\t\tif (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z') && !(c >= '0' && c <= '9')\n\t\t\t&& c != '_' && c != ':') {\n\t\t\tc = '_';\n\t\t}\n\t\t*cur = c;\n\t\ts++;\n\t\tcur++;\n\t\tlen--;\n\t}\n\t*cur = '\\0';\n\treturn ret;\n}\n\nR_API void r_str_byte_escape(const char *p, char **dst, int dot_nl, bool default_dot, bool esc_bslash) {\n\tchar *q = *dst;\n\tswitch (*p) {\n\tcase '\\n':\n\t\t*q++ = '\\\\';\n\t\t*q++ = dot_nl ? 'l' : 'n';\n\t\tbreak;\n\tcase '\\r':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'r';\n\t\tbreak;\n\tcase '\\\\':\n\t\t*q++ = '\\\\';\n\t\tif (esc_bslash) {\n\t\t\t*q++ = '\\\\';\n\t\t}\n\t\tbreak;\n\tcase '\\t':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 't';\n\t\tbreak;\n\tcase '\"' :\n\t\t*q++ = '\\\\';\n\t\t*q++ = '\"';\n\t\tbreak;\n\tcase '\\f':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'f';\n\t\tbreak;\n\tcase '\\b':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'b';\n\t\tbreak;\n\tcase '\\v':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'v';\n\t\tbreak;\n\tcase '\\a':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'a';\n\t\tbreak;\n\tdefault:\n\t\t/* Outside the ASCII printable range */\n\t\tif (!IS_PRINTABLE (*p)) {\n\t\t\tif (default_dot) {\n\t\t\t\t*q++ = '.';\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'x';\n\t\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\t}\n\t\t} else {\n\t\t\t*q++ = *p;\n\t\t}\n\t}\n\t*dst = q;\n}\n\n/* Internal function. dot_nl specifies whether to convert \\n into the\n * graphiz-compatible newline \\l */\nstatic char *r_str_escape_(const char *buf, int dot_nl, bool parse_esc_seq, bool ign_esc_seq, bool show_asciidot, bool esc_bslash) {\n\tr_return_val_if_fail (buf, NULL);\n\n\t/* Worst case scenario, we convert every byte to a single-char escape\n\t * (e.g. \\n) if show_asciidot, or \\xhh if !show_asciidot */\n\tchar *new_buf = malloc (1 + strlen (buf) * (show_asciidot ? 2 : 4));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase 0x1b: // ESC\n\t\t\tif (parse_esc_seq) {\n\t\t\t\tconst char *start_seq = p;\n\t\t\t\tp++;\n\t\t\t\t/* Parse the ANSI code (only the graphic mode\n\t\t\t\t * set ones are supported) */\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tfor (p++; *p != 'm'; p++) {\n\t\t\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ign_esc_seq) {\n\t\t\t\t\t\tmemcpy (q, start_seq, p - start_seq + 1);\n\t\t\t\t\t\tq += (p - start_seq + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tr_str_byte_escape (p, &q, dot_nl, show_asciidot, esc_bslash);\n\t\t}\n\t\tp++;\n\t}\nout:\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape(const char *buf) {\n\treturn r_str_escape_ (buf, false, true, true, false, true);\n}\n\nR_API char *r_str_escape_dot(const char *buf) {\n\treturn r_str_escape_ (buf, true, true, true, false, true);\n}\n\nR_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors) {\n\treturn r_str_escape_ (buf, false, colors, !colors, show_asciidot, esc_bslash);\n}\n\nstatic char *r_str_escape_utf(const char *buf, int buf_size, RStrEnc enc, bool show_asciidot, bool esc_bslash, bool keep_printable) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tswitch (enc) {\n\tcase R_STRING_ENC_UTF16LE:\n\tcase R_STRING_ENC_UTF16BE:\n\tcase R_STRING_ENC_UTF32LE:\n\tcase R_STRING_ENC_UTF32BE:\n\t\tif (buf_size < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (enc == R_STRING_ENC_UTF16LE || enc == R_STRING_ENC_UTF16BE) {\n\t\t\tend = (char *)r_mem_mem_aligned ((ut8 *)buf, buf_size, (ut8 *)\"\\0\\0\", 2, 2);\n\t\t} else {\n\t\t\tend = (char *)r_mem_mem_aligned ((ut8 *)buf, buf_size, (ut8 *)\"\\0\\0\\0\\0\", 4, 4);\n\t\t}\n\t\tif (!end) {\n\t\t\tend = buf + buf_size - 1; /* TODO: handle overlong strings properly */\n\t\t}\n\t\tlen = end - buf;\n\t\tbreak;\n\tdefault:\n\t\tlen = strlen (buf);\n\t\tend = buf + len;\n\t}\n\t/* Worst case scenario, we convert every byte to \\xhh */\n\tnew_buf = malloc (1 + (len * 4));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tswitch (enc) {\n\t\tcase R_STRING_ENC_UTF16LE:\n\t\tcase R_STRING_ENC_UTF16BE:\n\t\tcase R_STRING_ENC_UTF32LE:\n\t\tcase R_STRING_ENC_UTF32BE:\n\t\t\tif (enc == R_STRING_ENC_UTF16LE || enc == R_STRING_ENC_UTF16BE) {\n\t\t\t\tch_bytes = r_utf16_decode ((ut8 *)p, end - p, &ch, enc == R_STRING_ENC_UTF16BE);\n\t\t\t} else {\n\t\t\t\tch_bytes = r_utf32_decode ((ut8 *)p, end - p, &ch, enc == R_STRING_ENC_UTF32BE);\n\t\t\t}\n\t\t\tif (ch_bytes == 0) {\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\t\tif (ch_bytes == 0) {\n\t\t\t\tch_bytes = 1;\n\t\t\t}\n\t\t}\n\t\tif (show_asciidot && !IS_PRINTABLE(ch)) {\n\t\t\t*q++ = '.';\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (keep_printable) {\n\t\t\t\tq += r_utf8_encode ((ut8 *)q, ch);\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = ch_bytes == 4 ? 'U' : 'u';\n\t\t\t\tfor (i = ch_bytes == 4 ? 6 : 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint offset = enc == R_STRING_ENC_UTF16BE ? 1 : enc == R_STRING_ENC_UTF32BE ? 3 : 0;\n\t\t\tr_str_byte_escape (p + offset, &q, false, false, esc_bslash);\n\t\t}\n\t\tswitch (enc) {\n\t\tcase R_STRING_ENC_UTF16LE:\n\t\tcase R_STRING_ENC_UTF16BE:\n\t\t\tp += ch_bytes < 2 ? 2 : ch_bytes;\n\t\t\tbreak;\n\t\tcase R_STRING_ENC_UTF32LE:\n\t\tcase R_STRING_ENC_UTF32BE:\n\t\t\tp += 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp += ch_bytes;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, -1, R_STRING_ENC_UTF8, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf8_keep_printable(const char *buf, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, -1, R_STRING_ENC_UTF8, show_asciidot, esc_bslash, true);\n}\n\nR_API char *r_str_escape_utf16le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF16LE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf32le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF32LE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf16be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF16BE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf32be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF32BE, show_asciidot, esc_bslash, false);\n}\n\n// JSON has special escaping requirements\n// TODO: merge with r_str_escape_utf() and r_str_byte_escape() using RStrEsc\nR_API char *r_str_escape_utf8_for_json(const char *buf, int buf_size) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tlen = buf_size < 0 ? strlen (buf) : buf_size;\n\tend = buf + len;\n\t/* Worst case scenario, we convert every byte to \\u00hh */\n\tnew_buf = malloc (1 + (len * 6));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\tif (ch_bytes == 1) {\n\t\t\tswitch (*p) {\n\t\t\tcase '\\n':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'n';\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'r';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\tbreak;\n#if 0\n\t\t\tcase '/': /* has 2-char esc seq in JSON spec, but escaping is optional */\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '/';\n\t\t\t\tbreak;\n#endif\n\t\t\tcase '\\t':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 't';\n\t\t\t\tbreak;\n\t\t\tcase '\"' :\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\"';\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'f';\n\t\t\t\tbreak;\n\t\t\tcase '\\b':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'b';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!IS_PRINTABLE (*p)) {\n\t\t\t\t\t*q++ = '\\\\';\n\t\t\t\t\t*q++ = 'u';\n\t\t\t\t\t*q++ = '0';\n\t\t\t\t\t*q++ = '0';\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\t\t} else {\n\t\t\t\t\t*q++ = *p;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes == 4) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRune high, low;\n\t\t\t\tch -= 0x10000;\n\t\t\t\thigh = 0xd800 + (ch >> 10 & 0x3ff);\n\t\t\t\tlow = 0xdc00 + (ch & 0x3ff);\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // ch_bytes == 0\n\t\t\t// Outside JSON spec, but apparently no better\n\t\t\t// alternative if need to reconstruct the original string\n\t\t\t*q++ = '\\\\';\n\t\t\t*q++ = 'x';\n\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\tch_bytes = 1;\n\t\t}\n\t\tp += ch_bytes;\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\n// http://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES\n// https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?redirectedfrom=MSDN&view=vs-2019#parsing-c-command-line-arguments\nR_API char *r_str_format_msvc_argv(size_t argc, const char **argv) {\n\tRStrBuf sb;\n\tr_strbuf_init (&sb);\n\n\tsize_t i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i > 0) {\n\t\t\tr_strbuf_append (&sb, \" \");\n\t\t}\n\t\tconst char *arg = argv[i];\n\t\tbool must_escape = strchr (arg, '\\\"') != NULL;\n\t\tbool must_quote = strpbrk (arg, \" \\t\") != NULL || !*arg;\n\t\tif (!must_escape && must_quote && *arg && arg[strlen (arg) - 1] == '\\\\') {\n\t\t\t// if the last char is a bs and we would quote it, we must also escape\n\t\t\tmust_escape = true;\n\t\t}\n\t\tif (must_quote) {\n\t\t\tr_strbuf_append (&sb, \"\\\"\");\n\t\t}\n\t\tif (must_escape) {\n\t\t\tsize_t bs_count = 0; // bullshit counter\n\t\t\tfor (; *arg; arg++) {\n\t\t\t\tswitch (*arg) {\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tfor (; bs_count; bs_count--) {\n\t\t\t\t\t\t// backslashes must be escaped iff they precede a \"\n\t\t\t\t\t\t// so just duplicate the number of backslashes already printed\n\t\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t\t}\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tbs_count++;\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbs_count = 0;\n\t\t\t\t\tr_strbuf_append_n (&sb, arg, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (must_quote) {\n\t\t\t\t// there will be a quote after this so we have to escape bs here as well\n\t\t\t\tfor (; bs_count; bs_count--) {\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_strbuf_append (&sb, arg);\n\t\t}\n\t\tif (must_quote) {\n\t\t\tr_strbuf_append (&sb, \"\\\"\");\n\t\t}\n\t}\n\n\treturn r_strbuf_drain_nofree (&sb);\n}\n\nstatic size_t __str_ansi_length(char const *str) {\n\tsize_t i = 1;\n\tif (str[0] == 0x1b) {\n\t\tif (str[1] == '[') {\n\t\t\ti++;\n\t\t\twhile (str[i] && str[i] != 'J' && str[i] != 'm' && str[i] != 'H' && str[i] != 'K') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (str[1] == '#') {\n\t\t\twhile (str[i] && str[i] != 'q') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (str[i]) {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\n/* ansi helpers */\nR_API size_t r_str_ansi_nlen(const char *str, size_t slen) {\n\tsize_t i = 0, len = 0;\n\tif (slen > 0) {\n\t\twhile (str[i] && i < slen) {\n\t\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\t\tif (chlen == 1) {\n\t\t\t\tlen ++;\n\t\t\t}\n\t\t\ti += chlen;\n\t\t}\n\t\treturn len > 0 ? len: 1;\n\t}\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen == 1) {\n\t\t\tlen ++;\n\t\t}\n\t\ti += chlen;\n\t}\n\treturn len > 0 ? len: 1;\n}\n\nR_API size_t r_str_ansi_len(const char *str) {\n\treturn r_str_ansi_nlen (str, 0);\n}\n\nR_API size_t r_str_nlen(const char *str, int n) {\n\tsize_t len = 0;\n\tif (str) {\n\t\twhile (*str && n > 0) {\n\t\t\tlen++;\n\t\t\tstr++;\n\t\t\tn--;\n\t\t}\n\t}\n\treturn len;\n}\n\n//to handle wide string as well\n//XXX can be error prone\nR_API size_t r_str_nlen_w(const char *str, int n) {\n\tsize_t len = 0;\n\tif (str) {\n\t\twhile (*str && n > 0) {\n\t\t\tlen++;\n\t\t\tstr++;\n\t\t\tif (!*str) {\n\t\t\t\t//handle wide strings\n\t\t\t \t//xx00yy00bb00\n\t\t\t\tif (n - 2 > 0) {\n\t\t\t\t\tif (str[2]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t}\n\treturn len;\n}\n\nR_API bool r_str_is_ascii(const char *str) {\n\tconst ut8 *ptr;\n\tfor (ptr = (const ut8 *)str; *ptr; ptr++) {\n\t\tif (*ptr > 0x7f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable(const char *str) {\n\twhile (*str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\treturn false;\n\t\t}\n\t\tstr++;\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable_limited(const char *str, int size) {\n\twhile (size > 0 && *str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\treturn false;\n\t\t}\n\t\tstr++;\n\t\tsize--;\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable_incl_newlines(const char *str) {\n\twhile (*str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\tif (*str != '\\r' && *str != '\\n' && *str != '\\t') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tstr++;\n\t}\n\treturn true;\n}\n\n// Length in chars of a wide string (find better name?)\nR_API size_t r_wstr_clen(const char *s) {\n\tsize_t len = 0;\n\tif (!*s++) {\n\t\treturn 0;\n\t}\n\twhile (*s++ || *s++) {\n\t\tlen++;\n\t}\n\treturn len + 1;\n}\n\nR_API const char *r_str_ansi_chrn(const char *str, size_t n) {\n\tint len, i, li;\n\tfor (li = i = len = 0; str[i] && (n != len); i++) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\ti += chlen - 1;\n\t\t} else {\n\t\t\tif ((str[i] & 0xc0) != 0x80) {\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tli = i;\n\t\t}\n\t}\n\treturn str + li;\n}\n\n/*\n * filter out ansi CSI shit in-place!.\n * str - input string,\n * out - if not NULL write a pointer to the original string there,\n * cposs - if not NULL write a pointer to thunk array there\n * (*cposs)[i] is the offset of the out[i] in str\n * len - length of str\n *\n * it returns the number of normal characters found in str\n */\nR_API int r_str_ansi_filter(char *str, char **out, int **cposs, int len) {\n\tint i, j, *cps;\n\n\tif (len == 0) {\n\t\treturn 0;\n\t}\n\tif (len < 0) {\n\t\tlen = strlen (str);\n\t}\n\tchar *tmp = malloc (len + 1);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\tmemcpy (tmp, str, len + 1);\n\tcps = calloc (len + 1, sizeof (int));\n\tif (!cps) {\n\t\tfree (tmp);\n\t\treturn -1;\n\t}\n\n\tfor (i = j = 0; i < len; i++) {\n\t\tif (tmp[i] == 0x1b) {\n\t\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\t\tif (chlen > 1) {\n\t\t\t\ti += chlen;\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else {\n\t\t\tstr[j] = tmp[i];\n\t\t\tcps[j] = i;\n\t\t\tj++;\n\t\t}\n\t}\n\tstr[j] = tmp[i];\n\n\tif (out) {\n\t\t*out = tmp;\n\t} else {\n\t\tfree (tmp);\n\t}\n\n\tif (cposs) {\n\t\t*cposs = cps;\n\t} else {\n\t\tfree (cps);\n\t}\n\n\treturn j;\n}\n\nR_API char *r_str_ansi_crop(const char *str, ut32 x, ut32 y, ut32 x2, ut32 y2) {\n\tchar *r, *r_end, *ret;\n\tconst char *s, *s_start;\n\tsize_t r_len, str_len = 0, nr_of_lines = 0;\n\tut32 ch = 0, cw = 0;\n\tif (x2 <= x || y2 <= y || !str) {\n\t\treturn strdup (\"\");\n\t}\n\ts = s_start = str;\n\twhile (*s) {\n\t\tstr_len++;\n\t\tif (*s == '\\n') {\n\t\t\tnr_of_lines++;\n\t\t}\n\t\ts++;\n\t}\n\tr_len = str_len + nr_of_lines * strlen (Color_RESET) + 1;\n\tr = ret = malloc (r_len);\n\tif (!r) {\n\t\treturn NULL;\n\t}\n\tr_end = r + r_len;\n\twhile (*str) {\n\t\t/* crop height */\n\t\tif (ch >= y2) {\n\t\t\tr--;\n\t\t\tbreak;\n\t\t}\n\t\tif (*str == '\\n') {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\tconst char *reset = Color_RESET \"\\n\";\n\t\t\t\tif (strlen (reset) < (r_end - r)) {\n\t\t\t\t\tconst int reset_length = strlen (reset);\n\t\t\t\t\tmemcpy (r, reset, reset_length + 1);\n\t\t\t\t\tr += reset_length;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr++;\n\t\t\tch++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\tif ((*str & 0xc0) == 0x80) {\n\t\t\t\t\tif (cw > x) {\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r_str_char_fullwidth (str, str_len - (str - s_start))) {\n\t\t\t\t\tcw++;\n\t\t\t\t\tif (cw == x) {\n\t\t\t\t\t\t*r++ = ' ';\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*str == 0x1b && *(str + 1) == '[') {\n\t\t\t\t\tconst char *ptr = str;\n\t\t\t\t\tif ((r_end - r) > 2) {\n\t\t\t\t\t\t/* copy 0x1b and [ */\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t\tfor (ptr = str; *ptr && *ptr != 'J' && *ptr != 'm' && *ptr != 'H'; ptr++) {\n\t\t\t\t\t\t\t*r++ = *ptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*r++ = *ptr++;\n\t\t\t\t\t}\n\t\t\t\t\tstr = ptr;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (cw >= x && cw < x2) {\n\t\t\t\t\t*r++ = *str;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* skip until newline */\n\t\t\tif (cw >= x2) {\n\t\t\t\twhile (*str && *str != '\\n') {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tcw++;\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\nR_API size_t r_str_utf8_codepoint(const char* s, size_t left) {\n\tif ((*s & 0x80) != 0x80) {\n\t\treturn 0;\n\t} else if ((*s & 0xe0) == 0xc0 && left >= 1) {\n\t\treturn ((*s & 0x1f) << 6) + (*(s + 1) & 0x3f);\n\t} else if ((*s & 0xf0) == 0xe0 && left >= 2) {\n\t\treturn ((*s & 0xf) << 12) + ((*(s + 1) & 0x3f) << 6) + (*(s + 2) & 0x3f);\n\t} else if ((*s & 0xf8) == 0xf0 && left >= 3) {\n\t\treturn ((*s & 0x7) << 18) + ((*(s + 1) & 0x3f) << 12) + ((*(s + 2) & 0x3f) << 6) + (*(s + 3) & 0x3f);\n\t}\n\treturn 0;\n}\n\nR_API bool r_str_char_fullwidth (const char* s, size_t left) {\n\tsize_t codepoint = r_str_utf8_codepoint (s, left);\n\treturn (codepoint >= 0x1100 &&\n\t\t (codepoint <= 0x115f ||                  /* Hangul Jamo init. consonants */\n\t\t\t  codepoint == 0x2329 || codepoint == 0x232a ||\n\t\t (R_BETWEEN (0x2e80, codepoint, 0xa4cf)\n\t\t\t&& codepoint != 0x303f) ||        /* CJK ... Yi */\n\t\t R_BETWEEN (0xac00, codepoint, 0xd7a3) || /* Hangul Syllables */\n\t\t R_BETWEEN (0xf900, codepoint, 0xfaff) || /* CJK Compatibility Ideographs */\n\t\t R_BETWEEN (0xfe10, codepoint, 0xfe19) || /* Vertical forms */\n\t\t R_BETWEEN (0xfe30, codepoint, 0xfe6f) || /* CJK Compatibility Forms */\n\t\t R_BETWEEN (0xff00, codepoint, 0xff60) || /* Fullwidth Forms */\n\t\t R_BETWEEN (0xffe0, codepoint, 0xffe6) ||\n\t\t R_BETWEEN (0x20000, codepoint, 0x2fffd) ||\n\t\t R_BETWEEN (0x30000, codepoint, 0x3fffd)));\n\n}\n\n/**\n * Returns size in bytes of the utf8 char\n * Returns 1 in case of ASCII\n * str - Pointer to buffer\n */\nR_API size_t r_str_utf8_charsize(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\tsize_t size = 0;\n\tsize_t length = strlen (str);\n\twhile (size < length && size < 5) {\n\t\tsize++;\n\t\tif ((str[size] & 0xc0) != 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size < 5 ? size : 0;\n}\n\n/**\n * Returns size in bytes of the utf8 char previous to str\n * Returns 1 in case of ASCII\n * str - Pointer to leading utf8 char\n * prev_len - Length in bytes of the buffer until str\n */\nR_API size_t r_str_utf8_charsize_prev(const char *str, int prev_len) {\n\tr_return_val_if_fail (str, 0);\n\tint pos = 0;\n\tsize_t size = 0, minsize = R_MIN (5, prev_len);\n\twhile (size < minsize) {\n\t\tsize++;\n\t\tif ((str[--pos] & 0xc0) != 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size < 5 ? size : 0;\n}\n\n/**\n * Returns size in bytes of the last utf8 char of the string\n * Returns 1 in case of ASCII\n * str - Pointer to buffer\n */\nR_API size_t r_str_utf8_charsize_last(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\tsize_t len = strlen (str);\n\treturn r_str_utf8_charsize_prev (str + len, len);\n}\n\nR_API void r_str_filter_zeroline(char *str, int len) {\n\tint i;\n\tfor (i = 0; i < len && str[i]; i++) {\n\t\tif (str[i] == '\\n' || str[i] == '\\r') {\n\t\t\tbreak;\n\t\t}\n\t\tif (!IS_PRINTABLE (str[i])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr[i] = 0;\n}\n\nR_API void r_str_filter(char *str, int len) {\n\tsize_t i;\n\tif (len < 1) {\n\t\tlen = strlen (str);\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (!IS_PRINTABLE (str[i])) {\n\t\t\tstr[i] = '.';\n\t\t}\n\t}\n}\n\nR_API bool r_str_glob(const char* str, const char *glob) {\n        const char* cp = NULL, *mp = NULL;\n        if (!glob || !strcmp (glob, \"*\")) {\n                return true;\n        }\n        if (!strchr (glob, '*')) {\n                if (*glob == '^') {\n                        glob++;\n                        while (*str) {\n                                if (*glob != *str) {\n                                        return false;\n                                }\n                                if (!*++glob) {\n                                        return true;\n                                }\n                                str++;\n                        }\n                } else {\n                        return strstr (str, glob) != NULL;\n                }\n        }\n        if (*glob == '^') {\n                glob++;\n        }\n        while (*str && (*glob != '*')) {\n                if (*glob != *str) {\n                        return false;\n                }\n                glob++;\n                str++;\n        }\n        while (*str) {\n                if (*glob == '*') {\n                        if (!*++glob) {\n                                return true;\n                        }\n                        mp = glob;\n                        cp = str + 1;\n                } else if (*glob == *str) {\n                        glob++;\n                        str++;\n                } else {\n                        glob = mp;\n                        str = cp++;\n                }\n        }\n        while (*glob == '*') {\n                ++glob;\n        }\n        return (*glob == '\\x00');\n}\n\n// Escape the string arg so that it is parsed as a single argument by r_str_argv\nR_API char *r_str_arg_escape(const char *arg) {\n\tchar *str;\n\tint dest_i = 0, src_i = 0;\n\tif (!arg) {\n\t\treturn NULL;\n\t}\n\tstr = malloc ((2 * strlen (arg) + 1) * sizeof (char)); // Worse case when every character need to be escaped\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tfor (src_i = 0; arg[src_i] != '\\0'; src_i++) {\n\t\tchar c = arg[src_i];\n\t\tswitch (c) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase ' ':\n\t\t\tstr[dest_i++] = '\\\\';\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr[dest_i] = '\\0';\n\treturn realloc (str, (strlen(str)+1) * sizeof (char));\n}\n\n// Unescape the string arg to its original format\nR_API int r_str_arg_unescape(char *arg) {\n\tint dest_i = 0, src_i = 0;\n\tif (!arg) {\n\t\treturn 0;\n\t}\n\tfor (src_i = 0; arg[src_i] != '\\0'; src_i++) {\n\t\tchar c = arg[src_i];\n\t\tif (c == '\\\\') {\n\t\t\tif (arg[++src_i] == '\\0') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ[dest_i++] = arg[src_i];\n\t\t} else {\n\t\t\targ[dest_i++] = c;\n\t\t}\n\t}\n\targ[dest_i] = '\\0';\n\treturn dest_i;\n}\n\nR_API char *r_str_path_escape(const char *path) {\n\tchar *str;\n\tint dest_i = 0, src_i = 0;\n\n\tif (!path) {\n\t\treturn NULL;\n\t}\n\t// Worst case when every character need to be escaped\n\tstr = malloc ((2 * strlen (path) + 1) * sizeof (char));\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\n\tfor (src_i = 0; path[src_i] != '\\0'; src_i++) {\n\t\tchar c = path[src_i];\n\t\tswitch (c) {\n\t\tcase ' ':\n\t\t\tstr[dest_i++] = '\\\\';\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstr[dest_i] = '\\0';\n\treturn realloc (str, (strlen (str) + 1) * sizeof (char));\n}\n\nR_API int r_str_path_unescape(char *path) {\n\tint i;\n\n\tfor (i = 0; path[i]; i++) {\n\t\tif (path[i] != '\\\\') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (path[i + 1] == ' ') {\n\t\t\tpath[i] = ' ';\n\t\t\tmemmove (path + i + 1, path + i + 2, strlen (path + i + 2) + 1);\n\t\t}\n\t}\n\n\treturn i;\n}\n\nR_API char **r_str_argv(const char *cmdline, int *_argc) {\n\tint argc = 0;\n\tint argv_len = 128; // Begin with that, argv will reallocated if necessary\n\tchar *args; // Working buffer for writing unescaped args\n\tint cmdline_current = 0; // Current character index in _cmdline\n\tint args_current = 0; // Current character index in  args\n\tint arg_begin = 0; // Index of the first character of the current argument in args\n\n\tif (!cmdline) {\n\t\treturn NULL;\n\t}\n\n\tchar **argv = malloc (argv_len * sizeof (char *));\n\tif (!argv) {\n\t\treturn NULL;\n\t}\n\targs = malloc (128 + strlen (cmdline) * sizeof (char)); // Unescaped args will be shorter, so strlen (cmdline) will be enough\n\tif (!args) {\n\t\tfree (argv);\n\t\treturn NULL;\n\t}\n\tdo {\n\t\t// States for parsing args\n\t\tint escaped = 0;\n\t\tint singlequoted = 0;\n\t\tint doublequoted = 0;\n\n\t\t// Seek the beginning of next argument (skip whitespaces)\n\t\twhile (cmdline[cmdline_current] != '\\0' && IS_WHITECHAR (cmdline[cmdline_current])) {\n\t\t\tcmdline_current++;\n\t\t}\n\n\t\tif (cmdline[cmdline_current] == '\\0') {\n\t\t\tbreak; // No more arguments\n\t\t}\n\t\t// Read the argument\n\t\twhile (1) {\n\t\t\tchar c = cmdline[cmdline_current];\n\t\t\tint end_of_current_arg = 0;\n\t\t\tif (escaped) {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\'':\n\t\t\t\tcase '\"':\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\\\':\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t}\n\t\t\t\tescaped = 0;\n\t\t\t} else {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (doublequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsinglequoted = !singlequoted;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tif (singlequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoublequoted = !doublequoted;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ' ':\n\t\t\t\t\tif (singlequoted || doublequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\n\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (end_of_current_arg) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcmdline_current++;\n\t\t}\n\t\targs[args_current++] = '\\0';\n\t\targv[argc++] = strdup (&args[arg_begin]);\n\t\tif (argc >= argv_len) {\n\t\t\targv_len *= 2;\n\t\t\tchar **tmp = realloc (argv, argv_len * sizeof (char *));\n\t\t\tif (!tmp) {\n\t\t\t\tfree (args);\n\t\t\t\tfree (argv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\targv = tmp;\n\t\t}\n\t\targ_begin = args_current;\n\t} while (cmdline[cmdline_current++] != '\\0');\n\targv[argc] = NULL;\n\tchar **tmp = realloc (argv, (argc + 1) * sizeof (char *));\n\tif (tmp) {\n\t\targv = tmp;\n\t} else {\n\t\tfree (argv);\n\t\targv = NULL;\n\t}\n\tif (_argc) {\n\t\t*_argc = argc;\n\t}\n\tfree (args);\n\treturn argv;\n}\n\nR_API void r_str_argv_free(char **argv) {\n\tint argc = 0;\n\tif (!argv) {\n\t\treturn;\n\t}\n\twhile (argv[argc]) {\n\t\tfree (argv[argc++]);\n\t}\n\tfree (argv);\n}\n\nR_API const char *r_str_firstbut(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn strchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\teprintf (\"r_str_firstbut: but string too long\\n\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_lastbut(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p, *lp = NULL;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn r_str_lchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\teprintf (\"r_str_lastbut: but string too long\\n\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\tlp = p;\n\t\t}\n\t}\n\treturn lp;\n}\n\n// Must be merged inside strlen\nR_API size_t r_str_len_utf8char(const char *s, int left) {\n\tsize_t i = 1;\n\twhile (s[i] && (!left || i<left)) {\n\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\ti++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nR_API size_t r_str_len_utf8(const char *s) {\n\tsize_t i = 0, j = 0, fullwidths = 0;\n\twhile (s[i]) {\n\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\tj++;\n\t\t\tif (r_str_char_fullwidth (s + i, 4)) {\n\t\t\t\tfullwidths++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn j + fullwidths;\n}\n\nR_API size_t r_str_len_utf8_ansi(const char *str) {\n\tint i = 0, len = 0, fullwidths = 0;\n\twhile (str[i]) {\n\t\tchar ch = str[i];\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\ti += chlen - 1;\n\t\t} else if ((ch & 0xc0) != 0x80) { // utf8\n\t\t\tlen++;\n\t\t\tif (r_str_char_fullwidth (str + i, 4)) {\n\t\t\t\tfullwidths++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn len + fullwidths;\n}\n\n// XXX must find across the ansi tags, as well as support utf8\nR_API const char *r_strstr_ansi(const char *a, const char *b) {\n\tconst char *ch, *p = a;\n\tdo {\n\t\tch = strchr (p, '\\x1b');\n\t\tif (ch) {\n\t\t\tconst char *v = r_str_nstr (p, b, ch - p);\n\t\t\tif (v) {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tp = ch + __str_ansi_length (ch);\n\t\t}\n\t} while (ch);\n\treturn strstr (p, b);\n}\n\nR_API const char *r_str_casestr(const char *a, const char *b) {\n\t// That's a GNUism that works in many places.. but we don't want it\n\t// return strcasestr (a, b);\n\tsize_t hay_len = strlen (a);\n\tsize_t needle_len = strlen (b);\n\tif (!hay_len || !needle_len) {\n\t\treturn NULL;\n\t}\n\twhile (hay_len >= needle_len) {\n\t\tif (!r_str_ncasecmp (a, b, needle_len)) {\n\t\t\treturn (const char *) a;\n\t\t}\n\t\ta++;\n\t\thay_len--;\n\t}\n\treturn NULL;\n}\n\nR_API int r_str_write(int fd, const char *b) {\n\treturn write (fd, b, strlen (b));\n}\n\nR_API void r_str_range_foreach(const char *r, RStrRangeCallback cb, void *u) {\n\tconst char *p = r;\n\tfor (; *r; r++) {\n\t\tif (*r == ',') {\n\t\t\tcb (u, atoi (p));\n\t\t\tp = r + 1;\n\t\t}\n\t\tif (*r == '-') {\n\t\t\tif (p != r) {\n\t\t\t\tint from = atoi (p);\n\t\t\t\tint to = atoi (r + 1);\n\t\t\t\tfor (; from <= to; from++) {\n\t\t\t\t\tcb (u, from);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"Invalid range\\n\");\n\t\t\t}\n\t\t\tfor (r++; *r && *r != ',' && *r != '-'; r++) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\tif (*p) {\n\t\tcb (u, atoi (p));\n\t}\n}\n\nR_API bool r_str_range_in(const char *r, ut64 addr) {\n\tconst char *p = r;\n\tut64 min = UT64_MAX;\n\tut64 max = 0;\n\tif (!r) {\n\t\treturn false;\n\t}\n\tfor (; *r; r++) {\n\t\tif (*r == ',') {\n\t\t\tif (max == 0) {\n\t\t\t\tif (addr == r_num_get (NULL, p)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (addr >= min && addr <= r_num_get (NULL, p)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = r + 1;\n\t\t}\n\t\tif (*r == '-') {\n\t\t\tif (p != r) {\n\t\t\t\tut64 from = r_num_get (NULL, p);\n\t\t\t\tut64 to = r_num_get (NULL, r + 1);\n\t\t\t\tif (addr >= from && addr <= to) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"Invalid range\\n\");\n\t\t\t}\n\t\t\tfor (r++; *r && *r != ',' && *r != '-'; r++) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\tif (*p) {\n\t\tif (addr == r_num_get (NULL, p)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// convert from html escaped sequence \"foo%20bar\" to \"foo bar\"\n// TODO: find better name.. unencode? decode\nR_API void r_str_uri_decode(char *s) {\n\tint n;\n\tchar *d;\n\tfor (d = s; *s; s++, d++) {\n\t\tif (*s == '%') {\n\t\t\tsscanf (s + 1, \"%02x\", &n);\n\t\t\t*d = n;\n\t\t\ts += 2;\n\t\t} else {\n\t\t\t*d = *s;\n\t\t}\n\t}\n\t*d = 0;\n}\n\nR_API char *r_str_uri_encode(const char *s) {\n\tchar ch[4], *d, *od;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tod = d = malloc (1 + (strlen (s) * 4));\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tfor (; *s; s++) {\n\t\tif((*s>='0' && *s<='9')\n\t\t|| (*s>='a' && *s<='z')\n\t\t|| (*s>='A' && *s<='Z')) {\n\t\t\t*d++ = *s;\n\t\t} else {\n\t\t\t*d++ = '%';\n\t\t\tsnprintf (ch, sizeof (ch), \"%02x\", 0xff & ((ut8)*s));\n\t\t\t*d++ = ch[0];\n\t\t\t*d++ = ch[1];\n\t\t}\n\t}\n\t*d = 0;\n\tchar *trimDown = realloc (od, strlen (od) + 1); // FIT\n\treturn trimDown? trimDown: od;\n}\n\nR_API int r_str_utf16_to_utf8(ut8 *dst, int len_dst, const ut8 *src, int len_src, int little_endian) {\n\tut8 *outstart = dst;\n\tut8 *outend = dst + len_dst;\n\tut16 *in = (ut16*)src;\n\tut16 *inend;\n\tut32 c, d, inlen;\n\tut8 *tmp;\n\tint bits;\n\n\tif ((len_src % 2) == 1) {\n\t\tlen_src--;\n\t}\n\tinlen = len_src / 2;\n\tinend = in + inlen;\n\twhile ((in < inend) && (dst - outstart + 5 < len_dst)) {\n\t\tif (little_endian) {\n\t\t\tc = *in++;\n\t\t} else {\n\t\t\ttmp = (ut8*) in;\n\t\t\tc = *tmp++;\n\t\t\tif (!c && !*tmp) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = c | (((ut32)*tmp) << 8);\n\t\t\tin++;\n\t\t}\n\t\tif ((c & 0xFC00) == 0xD800) {    /* surrogates */\n\t\t\tif (in >= inend) {           /* (in > inend) shouldn't happens */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (little_endian) {\n\t\t\t\td = *in++;\n\t\t\t} else {\n\t\t\t\ttmp = (ut8*) in;\n\t\t\t\td = *tmp++;\n\t\t\t\td = d | (((ut32)*tmp) << 8);\n\t\t\t\tin++;\n\t\t\t}\n\t\t\tif ((d & 0xFC00) == 0xDC00) {\n\t\t\t\tc &= 0x03FF;\n\t\t\t\tc <<= 10;\n\t\t\t\tc |= d & 0x03FF;\n\t\t\t\tc += 0x10000;\n\t\t\t} else {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\t/* assertion: c is a single UTF-4 value */\n\t\tif (dst >= outend) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c < 0x80) {\n\t\t\t*dst++ =  c; bits= -6;\n\t\t} else if (c < 0x800) {\n\t\t\t*dst++ = ((c >> 6) & 0x1F) | 0xC0;\n\t\t\tbits =  0;\n\t\t} else if (c < 0x10000) {\n\t\t\t*dst++ = ((c >> 12) & 0x0F) | 0xE0;\n\t\t\tbits =  6;\n\t\t} else {\n\t\t\t*dst++ = ((c >> 18) & 0x07) | 0xF0;\n\t\t\tbits = 12;\n\t\t}\n\n\t\tfor (; bits >= 0; bits -= 6) {\n\t\t\tif (dst >= outend) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*dst++ = ((c >> bits) & 0x3F) | 0x80;\n\t\t}\n\t}\n\tlen_dst = dst - outstart;\n\treturn len_dst;\n}\n\nR_API char *r_str_utf16_decode(const ut8 *s, int len) {\n\tint i = 0;\n\tint j = 0;\n\tchar *result = NULL;\n\tint count_unicode = 0;\n\tint count_ascii = 0;\n\tint lenresult = 0;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len && (s[i] || s[i+1]); i += 2) {\n\t\tif (!s[i+1] && 0x20 <= s[i] && s[i] <= 0x7E) {\n\t\t\t++count_ascii;\n\t\t} else {\n\t\t\t++count_unicode;\n\t\t}\n\t}\n\tlenresult = 1 + count_ascii + count_unicode * 6; // len(\"\\\\uXXXX\") = 6\n\tif (!(result = calloc (1 + count_ascii + count_unicode * 6, 1))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len && j < lenresult && (s[i] || s[i+1]); i += 2) {\n\t\tif (!s[i+1] && IS_PRINTABLE(s[i])) {\n\t\t\tresult[j++] = s[i];\n\t\t} else {\n\t\t\tj += snprintf (&result[j], lenresult - j, \"\\\\u%.2\"HHXFMT\"%.2\"HHXFMT\"\", s[i], s[i+1]);\n\t\t}\n\t}\n\treturn result;\n}\n\n// TODO: kill this completely, it makes no sense:\nR_API char *r_str_utf16_encode(const char *s, int len) {\n\tint i;\n\tchar ch[4], *d, *od, *tmp;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tif (len < 0) {\n\t\tlen = strlen (s);\n\t}\n\tif ((len * 7) + 1 < len) {\n\t\treturn NULL;\n\t}\n\tod = d = malloc (1 + (len * 7));\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len; s++, i++) {\n\t\tif (*s == '\\\\') {\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = '\\\\';\n\t\t} else if (*s == '\"') {\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = '\"';\n\t\t} else if ((*s >= 0x20) && (*s <= 126)) {\n\t\t\t*d++ = *s;\n\t\t} else {\n\t\t\t*d++ = '\\\\';\n\t\t\t//\t*d++ = '\\\\';\n\t\t\t*d++ = 'u';\n\t\t\t*d++ = '0';\n\t\t\t*d++ = '0';\n\t\t\tsnprintf (ch, sizeof (ch), \"%02x\", 0xff & ((ut8)*s));\n\t\t\t*d++ = ch[0];\n\t\t\t*d++ = ch[1];\n\t\t}\n\t}\n\t*d = 0;\n\ttmp = realloc (od, strlen (od) + 1); // FIT\n\tif (!tmp) {\n\t\tfree (od);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nR_API char *r_str_prefix_all(const char *s, const char *pfx) {\n\tconst char *os = s;\n\tchar *p;\n\tint newlines = 1;\n\tint len = 0;\n\tint pfx_len = 0;\n\n\tif (!s) {\n\t\treturn strdup (pfx);\n\t}\n\tif (!pfx) {\n\t\treturn strdup (s);\n\t}\n\tlen = strlen (s);\n\tpfx_len = strlen (pfx);\n\tfor (os = s; *os; os++)  {\n\t\tif (*os == '\\n') {\n\t\t\tnewlines++;\n\t\t}\n\t}\n\tchar *o = malloc (len + (pfx_len * newlines) + 1);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tmemcpy (o, pfx, pfx_len);\n\tfor (p = o + pfx_len; *s; s++) {\n\t\t*p++ = *s;\n\t\tif (*s == '\\n' && s[1]) {\n\t\t\tmemcpy (p, pfx, pfx_len);\n\t\t\tp += pfx_len;\n\t\t}\n\t}\n\t*p = 0;\n\treturn o;\n}\n\n#define HASCH(x) strchr (input_value,x)\n#define CAST (void*)(size_t)\nR_API ut8 r_str_contains_macro(const char *input_value) {\n\tchar *has_tilde = input_value ? HASCH('~') : NULL,\n\t\t *has_bang = input_value ? HASCH('!') : NULL,\n\t\t *has_brace = input_value ? CAST(HASCH('[') || HASCH(']')) : NULL,\n\t\t *has_paren = input_value ? CAST(HASCH('(') || HASCH(')')) : NULL,\n\t\t *has_cbrace = input_value ? CAST(HASCH('{') || HASCH('}')) : NULL,\n\t\t *has_qmark = input_value ? HASCH('?') : NULL,\n\t\t *has_colon = input_value ? HASCH(':') : NULL,\n\t\t *has_at = input_value ? strchr (input_value, '@') : NULL;\n\n\treturn has_tilde || has_bang || has_brace || has_cbrace || has_qmark \\\n\t\t|| has_paren || has_colon || has_at;\n}\n\nR_API void r_str_truncate_cmd(char *string) {\n\tut32 pos = 0;\n\tif (string && *string) {\n\t\tut32 sz = strlen (string);\n\t\tfor (pos = 0; pos < sz; pos++) {\n\t\t\tswitch (string[pos]) {\n\t\t\tcase '!':\n\t\t\tcase ':':\n\t\t\tcase ';':\n\t\t\tcase '@':\n\t\t\tcase '~':\n\t\t\tcase '(':\n\t\t\tcase '[':\n\t\t\tcase '{':\n\t\t\tcase '?':\n\t\t\t\tstring[pos] = '\\0';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API const char *r_str_closer_chr(const char *b, const char *s) {\n\tconst char *a;\n\twhile (*b) {\n\t\tfor (a = s; *a; a++) {\n\t\t\tif (*b == *a) {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t\tb++;\n\t}\n\treturn NULL;\n}\n\nR_API int r_str_bounds(const char *_str, int *h) {\n\tconst char *str, *ptr;\n\tint W = 0, H = 0;\n\tint cw = 0;\n\n\tif (_str) {\n\t\tptr = str = _str;\n\t\twhile (*str) {\n\t\t\tif (*str == '\\n') {\n\t\t\t\tH++;\n\t\t\t\tcw = r_str_ansi_nlen (ptr, (size_t)(str - ptr));\n\t\t\t\tif (cw > W) {\n\t\t\t\t\tW = cw;\n\t\t\t\t}\n\t\t\t\tcw = 0;\n\t\t\t\tptr = str + 1;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tcw++;\n\t\t}\n\t\tif (*str == '\\n') {// skip last newline\n\t\t\tH--;\n\t\t}\n\t\tif (h) {\n\t\t\t*h = H;\n\t\t}\n\t}\n\treturn W;\n}\n\n/* crop a string like it is in a rectangle with the upper-left corner at (x, y)\n * coordinates and the bottom-right corner at (x2, y2) coordinates. The result\n * is a newly allocated string, that should be deallocated by the user */\nR_API char *r_str_crop(const char *str, unsigned int x, unsigned int y,\n\t\tunsigned int x2, unsigned int y2) {\n\tchar *r, *ret;\n\tunsigned int ch = 0, cw = 0;\n\tif (x2 < 1 || y2 < 1 || !str) {\n\t\treturn strdup (\"\");\n\t}\n\tr = ret = strdup (str);\n\twhile (*str) {\n\t\t/* crop height */\n\t\tif (ch >= y2) {\n\t\t\tr--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*str == '\\n') {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\t*r++ = *str;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tch++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (ch >= y && ch < y2 && cw >= x && cw < x2) {\n\t\t\t\t*r++ = *str;\n\t\t\t}\n\t\t\t/* crop width */\n\t\t\t/* skip until newline */\n\t\t\tif (cw >= x2) {\n\t\t\t\twhile (*str && *str != '\\n') {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tcw++;\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\nR_API const char * r_str_tok(const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p || !*p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p == b) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == len) {\n\t\tp = NULL;\n\t}\n\treturn p;\n}\n\nR_API int r_str_do_until_token(str_operation op, char *str, const char tok) {\n\tint ret;\n\tif (!str) {\n\t\treturn -1;\n\t}\n\tif (!op) {\n\t\tfor (ret = 0; (str[ret] != tok) && str[ret]; ret++) {\n\t\t\t//empty body\n\t\t}\n\t} else {\n\t\tfor (ret = 0; (str[ret] != tok) && str[ret]; ret++) {\n\t\t\top (str + ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API const char *r_str_pad(const char ch, int sz) {\n\tstatic char pad[1024];\n\tif (sz < 0) {\n\t\tsz = 0;\n\t}\n\tmemset (pad, ch, R_MIN (sz, sizeof (pad)));\n\tif (sz < sizeof (pad)) {\n\t\tpad[sz] = 0;\n\t}\n\tpad[sizeof(pad) - 1] = 0;\n\treturn pad;\n}\n\nR_API char *r_str_repeat(const char *ch, int sz) {\n\tint i;\n\tif (sz < 0) {\n\t\tsz = 0;\n\t}\n\tif (sz == 0) {\n\t\treturn strdup (\"\");\n\t}\n\tRStrBuf *buf = r_strbuf_new (ch);\n\tfor (i = 1; i < sz; i++) {\n\t\tr_strbuf_append (buf, ch);\n\t}\n\treturn r_strbuf_drain (buf);\n}\n\nR_API char *r_str_between(const char *cmt, const char *prefix, const char *suffix) {\n\tchar *c0, *c1;\n\tif (!cmt || !prefix || !suffix || !*cmt) {\n\t\treturn NULL;\n\t}\n\tc0 = strstr (cmt, prefix);\n\tif (c0) {\n\t\tc1 = strstr (c0 + strlen (prefix), suffix);\n\t\tif (c1) {\n\t\t\treturn r_str_ndup (c0 + strlen (prefix), (c1 - c0 - strlen (prefix)));\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API bool r_str_startswith(const char *str, const char *needle) {\n\tr_return_val_if_fail (str && needle, false);\n\tif (str == needle) {\n\t\treturn true;\n\t}\n\treturn !strncmp (str, needle, strlen (needle));\n}\n\nR_API bool r_str_endswith(const char *str, const char *needle) {\n\tr_return_val_if_fail (str && needle, false);\n\tif (!*needle) {\n\t\treturn true;\n\t}\n\tint slen = strlen (str);\n\tint nlen = strlen (needle);\n\tif (!slen || !nlen || slen < nlen) {\n\t\treturn false;\n\t}\n\treturn !strcmp (str + (slen - nlen), needle);\n}\n\n// Splits the string <str> by string <c> and returns the result in a list.\nR_API RList *r_str_split_list(char *str, const char *c, int n)  {\n\tr_return_val_if_fail (str && c, NULL);\n\tRList *lst = r_list_newf (NULL);\n\tchar *aux = str;\n\tint i = 0;\n\tchar  *e = aux;\n\tfor (;e;) {\n\t\te = strstr (aux, c);\n\t\tif (n > 0) {\n\t\t\tif (++i > n) {\n\t\t\t\tr_list_append (lst, aux);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (e) {\n\t\t\t*e++ =  0;\n\t\t}\n\t\tr_str_trim (aux);\n\t\tr_list_append (lst, aux);\n\t\taux = e;\n\t}\n\treturn lst;\n}\n\nR_API RList *r_str_split_duplist(const char *_str, const char *c) {\n\tr_return_val_if_fail (_str && c, NULL);\n\tRList *lst = r_list_newf (free);\n\tchar *str = strdup (_str);\n\tchar *aux = str;\n\tsize_t clen = strlen (c);\n\twhile (aux) {\n\t\tchar *next = strstr (aux, c);\n\t\tif (next) {\n\t\t\t*next = '\\0';\n\t\t\tnext += clen;\n\t\t}\n\t\tr_str_trim (aux);\n\t\tr_list_append (lst, strdup (aux));\n\t\taux = next;\n\t}\n\tfree (str);\n\treturn lst;\n}\n\nR_API int *r_str_split_lines(char *str, int *count) {\n\tint i;\n\tint lines = 0;\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tint *indexes = NULL;\n\t// count lines\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '\\n') {\n\t\t\tlines++;\n\t\t}\n\t}\n\t// allocate and set indexes\n\tindexes = calloc (sizeof (int), lines + 1);\n\tif (!indexes) {\n\t\treturn NULL;\n\t}\n\tint line = 0;\n\tindexes[line++] = 0;\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '\\n') {\n\t\t\tstr[i] = 0;\n\t\t\tindexes[line++] = i + 1;\n\t\t}\n\t}\n\tif (count) {\n\t\t*count = line;\n\t}\n\treturn indexes;\n}\n\nR_API bool r_str_isnumber(const char *str) {\n\tif (!str || !*str) {\n\t\treturn false;\n\t}\n\tbool isnum = IS_DIGIT (*str) || *str == '-';\n\twhile (isnum && *++str) {\n\t\tif (!IS_DIGIT (*str)) {\n\t\t\tisnum = false;\n\t\t}\n\t}\n\treturn isnum;\n}\n\n/* TODO: optimize to start searching by the end of the string */\nR_API const char *r_str_last(const char *str, const char *ch) {\n\tchar *ptr, *end = NULL;\n\tif (!str || !ch) {\n\t\treturn NULL;\n\t}\n\tdo {\n\t\tptr = strstr (str, ch);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tend = ptr;\n\t\tstr = ptr + 1;\n\t} while (true);\n\treturn end;\n}\n\n// copies the WHOLE string but check n against non color code chars only.\nstatic int strncpy_with_color_codes(char *s1, char *s2, int n) {\n\tint i = 0, j = 0;\n\tint count = 0;\n\twhile (s2[j] && count < n) {\n\t\t// detect (consecutive) color codes\n\t\twhile (s2[j] == 0x1b) {\n\t\t\t// copy till 'm'\n\t\t\twhile (s2[j] && s2[j] != 'm') {\n\t\t\t\ts1[i++] = s2[j++];\n\t\t\t}\n\t\t\t// copy 'm'\n\t\t\tif (s2[j]) {\n\t\t\t\ts1[i++] = s2[j++];\n\t\t\t}\n\t\t}\n\t\tif (s2[j]) {\n\t\t\ts1[i++] = s2[j++];\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic int strncmp_skip_color_codes(const char *s1, const char *s2, int n) {\n\tint i = 0, j = 0;\n\tint count = 0;\n\tfor (i = 0, j = 0; s1[i]  && s2[j] && count < n; i++, j++, count++) {\n\t\twhile (s1[i] == 0x1b) {\n\t\t\twhile (s1[i] && s1[i] != 'm') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s1[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\twhile (s2[j] == 0x1b) {\n\t\t\twhile (s2[j] && s2[j] != 'm') {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (s2[j]) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif (s1[i] != s2[j]) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (count < n && s1[i] != s2[j]) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic char *strchr_skip_color_codes(const char *s, int c) {\n\tint i = 0;\n\tfor (i = 0; s[i]; i++) {\n\t\twhile (s[i] && s[i] == 0x1b) {\n\t\t\twhile (s[i] && s[i] != 'm') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (!s[i] || s[i] == (char)c) {\n\t\t\treturn (char*)s + i;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// Global buffer to speed up colorizing performance\n\nR_API char* r_str_highlight(char *str, const char *word, const char *color, const char *color_reset) {\n\tif (!str || !*str) {\n\t\treturn NULL;\n\t}\n\tut32 i = 0, j = 0, to_copy;\n\tchar *start = str;\n\tut32 l_str = strlen (str);\n\tut32 l_reset = strlen (color_reset);\n\tut32 l_color = color? strlen (color): 0;\n\tif (!color) {\n\t\treturn strdup (str);\n\t}\n\tif (!word || !*word) {\n\t\treturn r_str_newf (\"%s%s%s\", color, str, color_reset);\n\t}\n\tut32 l_word = strlen (word);\n\t// XXX don't use static buffers\n\tchar o[1024] = {0};\n\twhile (start && (start < str + l_str)) {\n\t\tint copied = 0;\n\t\t// find first letter\n\t\tstart = strchr_skip_color_codes (str + i, *word);\n\t\tif (start) {\n\t\t\tto_copy = start - (str + i);\n\t\t\tif (to_copy + j + 1 > sizeof (o)) {\n\t\t\t\t// XXX. no limits\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (o + j, str + i, to_copy);\n\t\t\ti += to_copy;\n\t\t\tj += to_copy;\n\t\t\tif (!strncmp_skip_color_codes (start, word, l_word)) {\n\t\t\t\tif (j + strlen (color) >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (o + j, color);\n\t\t\t\tj += l_color;\n\t\t\t\tif (j + l_word >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcopied = strncpy_with_color_codes (o + j, str + i, l_word);\n\t\t\t\ti += copied;\n\t\t\t\tj += copied;\n\t\t\t\tif (j + strlen (color_reset) >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (o + j, color_reset);\n\t\t\t\tj += l_reset;\n\t\t\t} else {\n\t\t\t\to[j++] = str[i++];\n\t\t\t}\n\t\t} else {\n\t\t\tif (j + strlen (str + i) >= sizeof (o)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcpy (o + j, str + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn strdup (o);\n}\n\nR_API wchar_t* r_str_mb_to_wc_l(const char *buf, int len) {\n\twchar_t *res_buf = NULL;\n\tsize_t sz;\n\tbool fail = true;\n\n\tif (!buf || len <= 0) {\n\t\treturn NULL;\n\t}\n\tsz = mbstowcs (NULL, buf, len);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tres_buf = (wchar_t *)calloc (1, (sz + 1) * sizeof (wchar_t));\n\tif (!res_buf) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tsz = mbstowcs (res_buf, buf, sz + 1);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tfail = false;\nerr_r_str_mb_to_wc:\n\tif (fail) {\n\t\tR_FREE (res_buf);\n\t}\n\treturn res_buf;\n}\n\nR_API char* r_str_wc_to_mb_l(const wchar_t *buf, int len) {\n\tchar *res_buf = NULL;\n\tbool fail = true;\n\tsize_t sz;\n\n\tif (!buf || len <= 0) {\n\t\treturn NULL;\n\t}\n\tsz = wcstombs (NULL, buf, len);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tres_buf = (char *)calloc (1, (sz + 1) * sizeof (char));\n\tif (!res_buf) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tsz = wcstombs (res_buf, buf, sz + 1);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tfail = false;\nerr_r_str_wc_to_mb:\n\tif (fail) {\n\t\tR_FREE (res_buf);\n\t}\n\treturn res_buf;\n}\n\nR_API char* r_str_wc_to_mb(const wchar_t *buf) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\treturn r_str_wc_to_mb_l (buf, wcslen (buf));\n}\n\nR_API wchar_t* r_str_mb_to_wc(const char *buf) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\treturn r_str_mb_to_wc_l (buf, strlen (buf));\n}\n\nR_API char *r_str_from_ut64(ut64 val) {\n\tint i = 0;\n\tchar *v = (char *)&val;\n\tchar *str = (char *)calloc(1, 9);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\twhile (i < 8 && *v) {\n\t\tstr[i++] = *v++;\n\t}\n\treturn str;\n}\n\nR_API int r_snprintf(char *string, int len, const char *fmt, ...) {\n\tva_list ap;\n\tva_start (ap, fmt);\n\tint ret = vsnprintf (string, len, fmt, ap);\n\tstring[len - 1] = 0;\n\tva_end (ap);\n\treturn ret;\n}\n\n// Strips all the lines in str that contain key\nR_API void r_str_stripLine(char *str, const char *key) {\n\tsize_t i, j, klen, slen, off;\n\tconst char *ptr;\n\n\tif (!str || !key) {\n\t\treturn;\n\t}\n\tklen = strlen (key);\n\tslen = strlen (str);\n\n\tfor (i = 0; i < slen; ) {\n\t\tptr = (char*) r_mem_mem ((ut8*) str + i, slen - i, (ut8*) \"\\n\", 1);\n\t\tif (!ptr) {\n\t\t\tptr = (char*) r_mem_mem ((ut8*) str + i, slen - i, (ut8*) key, klen);\n\t\t\tif (ptr) {\n\t\t\t\tstr[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\toff = (size_t) (ptr - (str + i)) + 1;\n\n\t\tptr = (char*) r_mem_mem ((ut8*) str + i, off, (ut8*) key, klen);\n\t\tif (ptr) {\n\t\t\tfor (j = i; j < slen - off + 1; j++) {\n\t\t\t\tstr[j] = str[j + off];\n\t\t\t}\n\t\t\tslen -= off;\n\t\t} else {\n\t\t\ti += off;\n\t\t}\n\t}\n}\n\nR_API char *r_str_list_join(RList *str, const char *sep) {\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tconst char *p;\n\twhile ((p = r_list_pop_head (str))) {\n\t\tif (r_strbuf_length (sb) != 0) {\n\t\t\tr_strbuf_append (sb, sep);\n\t\t}\n\t\tr_strbuf_append (sb, p);\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\n/* return the number of arguments expected as extra arguments */\nR_API int r_str_fmtargs(const char *fmt) {\n\tint n = 0;\n\twhile (*fmt) {\n\t\tif (*fmt == '%') {\n\t\t\tif (fmt[1] == '*') {\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t\tfmt++;\n\t}\n\treturn n;\n}\n\n// str-bool\n\n// Returns \"true\" or \"false\" as a string given an input integer. The returned\n// value is consistent with C's definition of 0 is false, and all other values\n// are true.\nR_API const char *r_str_bool(int b) {\n\treturn b? \"true\": \"false\";\n}\n\nR_API bool r_str_is_true(const char *s) {\n\treturn !r_str_casecmp (\"yes\", s)\n\t\t|| !r_str_casecmp (\"on\", s)\n\t\t|| !r_str_casecmp (\"true\", s)\n\t\t|| !r_str_casecmp (\"1\", s);\n}\n\nR_API bool r_str_is_false(const char *s) {\n\treturn !r_str_casecmp (\"no\", s)\n\t\t|| !r_str_casecmp (\"off\", s)\n\t\t|| !r_str_casecmp (\"false\", s)\n\t\t|| !r_str_casecmp (\"0\", s)\n\t\t|| !*s;\n}\n\nR_API bool r_str_is_bool(const char *val) {\n\treturn r_str_is_true (val) || r_str_is_false (val);\n}\n\nR_API char *r_str_nextword(char *s, char ch) {\n\tchar *p = strchr (s, ch);\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\t*p++ = 0;\n\treturn p;\n}\n\nR_API char *r_str_scale(const char *s, int w, int h) {\n\t// count lines and rows in (s) string\n\t// compute how many lines we should remove or combine\n\t// return a string containing\n\t// for now this function is ascii only (no utf8 or ansi escapes)\n\tRListIter *iter;\n\tchar *line;\n\tchar *str = strdup (s);\n\tRList *lines = r_str_split_list (str, \"\\n\", 0);\n\tint i, j;\n\tint rows = 0;\n\tint maxcol = 0;\n\n\trows = r_list_length (lines);\n\tr_list_foreach (lines, iter, line) {\n\t\tmaxcol = R_MAX (strlen (line), maxcol);\n\t}\n\n\tRList *out = r_list_newf (free);\n\n\tint curline = -1;\n\tchar *linetext = (char*)r_str_pad (' ', w);\n\tfor (i = 0; i < h; i++) {\n\t\tint zoomedline = i * ((float)rows / h);\n\t\tconst char *srcline = r_list_get_n (lines, zoomedline);\n\t\tint cols = strlen (srcline);\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tint zoomedcol = j * ( (float)cols / w);\n\t\t\tlinetext[j] = srcline[zoomedcol];\n\t\t}\n\t\tif (curline != zoomedline) {\n\t\t\tr_list_append (out, strdup (linetext));\n\t\t\tcurline = zoomedline;\n\t\t}\n\t\tmemset (linetext, ' ', w);\n\t}\n\tfree (str);\n\treturn r_str_list_join (out, \"\\n\");\n}\n\nR_API const char *r_str_str_xy(const char *s, const char *word, const char *prev, int *x, int *y) {\n\tr_return_val_if_fail (s && word && x && y, NULL);\n\tr_return_val_if_fail (word[0] != '\\0' && word[0] != '\\n', NULL);\n\tconst char *src = prev ? prev + 1 : s;\n\tconst char *d = strstr (src, word);\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tconst char *q;\n\tfor (q = prev ? prev : s; q < d; q++) {\n\t\tif (*q == '\\n') {\n\t\t\t(*y)++;\n\t\t\t*x = 0;\n\n\t\t} else {\n\t\t\t(*x)++;\n\t\t}\n\t}\n\treturn d;\n}\n\n// version.c\n#include <r_userconf.h>\n#include <r_util.h>\n\n#ifndef R2_GITTAP\n#define R2_GITTAP \"\"\n#endif\n\n#ifndef R2_GITTIP\n#define R2_GITTIP \"\"\n#endif\n\n#ifndef R2_BIRTH\n#define R2_BIRTH \"unknown\"\n#endif\n\nR_API char *r_str_version(const char *program) {\n\tchar *s = r_str_newf (\"%s \"R2_VERSION\" %d @ \"\n\t\t\tR_SYS_OS\"-\"\n\t\t\tR_SYS_ARCH\"-%d git.%s\\n\",\n\t\t\tprogram, R2_VERSION_COMMIT,\n\t\t\t(R_SYS_BITS & 8)? 64: 32,\n\t\t\t*R2_GITTAP ? R2_GITTAP: \"\");\n\tif (*R2_GITTIP) {\n\t\ts = r_str_appendf (s, \"commit: \"R2_GITTIP\" build: \"R2_BIRTH);\n\t}\n\treturn s;\n}\n", "/* radare - LGPL - Copyright 2009-2020 - pancake */\n\n#if __linux__\n#include <time.h>\n#endif\n\n#include <r_userconf.h>\n#include <stdlib.h>\n#include <string.h>\n#if defined(__NetBSD__)\n# include <sys/param.h>\n# if __NetBSD_Prereq__(7,0,0)\n#  define NETBSD_WITH_BACKTRACE\n# endif\n#endif\n#if defined(__FreeBSD__)\n# include <sys/param.h>\n# include <sys/sysctl.h>\n# if __FreeBSD_version >= 1000000\n#  define FREEBSD_WITH_BACKTRACE\n# endif\n#endif\n#include <sys/types.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n\nstatic char** env = NULL;\n\n#if (__linux__ && __GNU_LIBRARY__) || defined(NETBSD_WITH_BACKTRACE) || \\\n  defined(FREEBSD_WITH_BACKTRACE) || __DragonFly__\n# include <execinfo.h>\n#endif\n#if __APPLE__\n#include <errno.h>\n#ifdef __MAC_10_8\n#define HAVE_ENVIRON 1\n#else\n#define HAVE_ENVIRON 0\n#endif\n\n#if HAVE_ENVIRON\n#include <execinfo.h>\n#endif\n// iOS don't have this we can't hardcode\n// #include <crt_externs.h>\nextern char ***_NSGetEnviron(void);\n# ifndef PROC_PIDPATHINFO_MAXSIZE\n#  define PROC_PIDPATHINFO_MAXSIZE 1024\nint proc_pidpath(int pid, void * buffer, ut32 buffersize);\n//#  include <libproc.h>\n# endif\n#endif\n#if __UNIX__\n# include <sys/utsname.h>\n# include <sys/wait.h>\n# include <sys/stat.h>\n# include <errno.h>\n# include <signal.h>\nextern char **environ;\n\n#ifdef __HAIKU__\n# define Sleep sleep\n#endif\n#endif\n#if __WINDOWS__\n# include <io.h>\n# include <winbase.h>\n# include <signal.h>\n#define TMP_BUFSIZE\t4096\n#ifdef _MSC_VER\n#include <psapi.h>\n#include <process.h>  // to allow getpid under windows msvc compilation\n#include <direct.h>  // to allow getcwd under windows msvc compilation\n#endif\n#endif\n\nR_LIB_VERSION(r_util);\n\n#ifdef __x86_64__\n# ifdef _MSC_VER\n#  define R_SYS_ASM_START_ROP() \\\n\t eprintf (\"r_sys_run_rop: Unsupported arch\\n\");\n# else\n#  define R_SYS_ASM_START_ROP() \\\n\t __asm__ __volatile__ (\"leaq %0, %%rsp; ret\" \\\n\t\t\t\t: \\\n\t\t\t\t: \"m\" (*bufptr));\n# endif\n#elif __i386__\n# ifdef _MSC_VER\n#  define R_SYS_ASM_START_ROP() \\\n\t__asm \\\n\t{ \\\n\t\t__asm lea esp, bufptr\\\n\t\t__asm ret\\\n\t}\n# else\n#  define R_SYS_ASM_START_ROP() \\\n\t__asm__ __volatile__ (\"leal %0, %%esp; ret\" \\\n\t\t\t\t: \\\n\t\t\t\t: \"m\" (*bufptr));\n# endif\n#else\n# define R_SYS_ASM_START_ROP() \\\n\teprintf (\"r_sys_run_rop: Unsupported arch\\n\");\n#endif\n\nstatic const struct {const char* name; ut64 bit;} arch_bit_array[] = {\n    {\"x86\", R_SYS_ARCH_X86},\n    {\"arm\", R_SYS_ARCH_ARM},\n    {\"ppc\", R_SYS_ARCH_PPC},\n    {\"m68k\", R_SYS_ARCH_M68K},\n    {\"java\", R_SYS_ARCH_JAVA},\n    {\"mips\", R_SYS_ARCH_MIPS},\n    {\"sparc\", R_SYS_ARCH_SPARC},\n    {\"xap\", R_SYS_ARCH_XAP},\n    {\"tms320\", R_SYS_ARCH_TMS320},\n    {\"msil\", R_SYS_ARCH_MSIL},\n    {\"objd\", R_SYS_ARCH_OBJD},\n    {\"bf\", R_SYS_ARCH_BF},\n    {\"sh\", R_SYS_ARCH_SH},\n    {\"avr\", R_SYS_ARCH_AVR},\n    {\"dalvik\", R_SYS_ARCH_DALVIK},\n    {\"z80\", R_SYS_ARCH_Z80},\n    {\"arc\", R_SYS_ARCH_ARC},\n    {\"i8080\", R_SYS_ARCH_I8080},\n    {\"rar\", R_SYS_ARCH_RAR},\n    {\"lm32\", R_SYS_ARCH_LM32},\n    {\"v850\", R_SYS_ARCH_V850},\n    {NULL, 0}\n};\n\nR_API int r_sys_fork() {\n#if HAVE_FORK\n#if __WINDOWS__\n\treturn -1;\n#else\n\treturn fork ();\n#endif\n#else\n\treturn -1;\n#endif\n}\n\n#if HAVE_SIGACTION\nR_API int r_sys_sigaction(int *sig, void (*handler) (int)) {\n\tstruct sigaction sigact = { };\n\tint ret, i;\n\n\tif (!sig) {\n\t\treturn -EINVAL;\n\t}\n\n\tsigact.sa_handler = handler;\n\tsigemptyset (&sigact.sa_mask);\n\n\tfor (i = 0; sig[i] != 0; i++) {\n\t\tsigaddset (&sigact.sa_mask, sig[i]);\n\t}\n\n\tfor (i = 0; sig[i] != 0; i++) {\n\t\tret = sigaction (sig[i], &sigact, NULL);\n\t\tif (ret) {\n\t\t\teprintf (\"Failed to set signal handler for signal '%d': %s\\n\", sig[i], strerror(errno));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#else\nR_API int r_sys_sigaction(int *sig, void (*handler) (int)) {\n\tint ret, i;\n\n\tif (!sig) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; sig[i] != 0; i++) {\n\t\tret = signal (sig[i], handler);\n\t\tif (ret == SIG_ERR) {\n\t\t\teprintf (\"Failed to set signal handler for signal '%d': %s\\n\", sig[i], strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nR_API int r_sys_signal(int sig, void (*handler) (int)) {\n\tint s[2] = { sig, 0 };\n\treturn r_sys_sigaction (s, handler);\n}\n\nR_API void r_sys_exit(int status, bool nocleanup) {\n\tif (nocleanup) {\n\t\t_exit (status);\n\t} else {\n\t\texit (status);\n\t}\n}\n\n/* TODO: import stuff from bininfo/p/bininfo_addr2line */\n/* TODO: check endianness issues here */\nR_API ut64 r_sys_now(void) {\n\tut64 ret;\n\tstruct timeval now;\n\tgettimeofday (&now, NULL);\n\tret = now.tv_sec;\n\tret <<= 20;\n\tret |= now.tv_usec;\n\t//(sizeof (now.tv_sec) == 4\n\treturn ret;\n}\n\nR_API int r_sys_truncate(const char *file, int sz) {\n#if __WINDOWS__\n\tint fd = r_sandbox_open (file, O_RDWR, 0644);\n\tif (fd == -1) {\n\t\treturn false;\n\t}\n#ifdef _MSC_VER\n\tint r = _chsize (fd, sz);\n#else\n\tint r = ftruncate (fd, sz);\n#endif\n\tif (r != 0) {\n\t\teprintf (\"Could not resize '%s' file\\n\", file);\n\t\tclose (fd);\n\t\treturn false;\n\t}\n\tclose (fd);\n\treturn true;\n#else\n\tif (r_sandbox_enable (0)) {\n\t\treturn false;\n\t}\n\treturn truncate (file, sz) == 0;\n#endif\n}\n\nR_API RList *r_sys_dir(const char *path) {\n\tRList *list = NULL;\n#if __WINDOWS__\n\tWIN32_FIND_DATAW entry;\n\tchar *cfname;\n\tHANDLE fh = r_sandbox_opendir (path, &entry);\n\tif (fh == INVALID_HANDLE_VALUE) {\n\t\t//IFDGB eprintf (\"Cannot open directory %ls\\n\", wcpath);\n\t\treturn list;\n\t}\n\tlist = r_list_newf (free);\n\tif (list) {\n\t\tdo {\n\t\t\tif ((cfname = r_utf16_to_utf8 (entry.cFileName))) {\n\t\t\t\tr_list_append (list, strdup (cfname));\n\t\t\t\tfree (cfname);\n\t\t\t}\n\t\t} while (FindNextFileW (fh, &entry));\n\t}\n\tFindClose (fh);\n#else\n\tstruct dirent *entry;\n\tDIR *dir = r_sandbox_opendir (path);\n\tif (dir) {\n\t\tlist = r_list_new ();\n\t\tif (list) {\n\t\t\tlist->free = free;\n\t\t\twhile ((entry = readdir (dir))) {\n\t\t\t\tr_list_append (list, strdup (entry->d_name));\n\t\t\t}\n\t\t}\n\t\tclosedir (dir);\n\t}\n#endif\n\treturn list;\n}\n\nR_API char *r_sys_cmd_strf(const char *fmt, ...) {\n\tchar *ret, cmd[4096];\n\tva_list ap;\n\tva_start (ap, fmt);\n\tvsnprintf (cmd, sizeof (cmd), fmt, ap);\n\tret = r_sys_cmd_str (cmd, NULL, NULL);\n\tva_end (ap);\n\treturn ret;\n}\n\n#ifdef __MAC_10_7\n#define APPLE_WITH_BACKTRACE 1\n#endif\n#ifdef __IPHONE_4_0\n#define APPLE_WITH_BACKTRACE 1\n#endif\n\n#if (__linux__ && __GNU_LIBRARY__) || (__APPLE__ && APPLE_WITH_BACKTRACE) || \\\n  defined(NETBSD_WITH_BACKTRACE) || defined(FREEBSD_WITH_BACKTRACE) || \\\n  __DragonFly__\n#define HAVE_BACKTRACE 1\n#endif\n\nR_API void r_sys_backtrace(void) {\n#ifdef HAVE_BACKTRACE\n\tvoid *array[10];\n\tsize_t size = backtrace (array, 10);\n\teprintf (\"Backtrace %zd stack frames.\\n\", size);\n\tbacktrace_symbols_fd (array, size, 2);\n#elif __APPLE__\n\tvoid **fp = (void **) __builtin_frame_address (0);\n\tvoid *saved_pc = __builtin_return_address (0);\n\tvoid *saved_fp = __builtin_frame_address (1);\n\tint depth = 0;\n\n\tprintf (\"[%d] pc == %p fp == %p\\n\", depth++, saved_pc, saved_fp);\n\tfp = saved_fp;\n\twhile (fp) {\n\t\tsaved_fp = *fp;\n\t\tfp = saved_fp;\n\t\tif (!*fp) {\n\t\t\tbreak;\n\t\t}\n\t\tsaved_pc = *(fp + 2);\n\t\tprintf (\"[%d] pc == %p fp == %p\\n\", depth++, saved_pc, saved_fp);\n\t}\n#else\n#ifdef _MSC_VER\n#pragma message (\"TODO: r_sys_bt : unimplemented\")\n#else\n#warning TODO: r_sys_bt : unimplemented\n#endif\n#endif\n}\n\nR_API int r_sys_sleep(int secs) {\n#if HAS_CLOCK_NANOSLEEP\n\tstruct timespec rqtp;\n\trqtp.tv_sec = secs;\n\trqtp.tv_nsec = 0;\n\treturn clock_nanosleep (CLOCK_MONOTONIC, 0, &rqtp, NULL);\n#elif __UNIX__\n\treturn sleep (secs);\n#else\n\tSleep (secs * 1000); // W32\n\treturn 0;\n#endif\n}\n\nR_API int r_sys_usleep(int usecs) {\n#if HAS_CLOCK_NANOSLEEP\n\tstruct timespec rqtp;\n\trqtp.tv_sec = usecs / 1000000;\n\trqtp.tv_nsec = (usecs - (rqtp.tv_sec * 1000000)) * 1000;\n\treturn clock_nanosleep (CLOCK_MONOTONIC, 0, &rqtp, NULL);\n#elif __UNIX__\n\treturn usleep (usecs);\n#else\n\t// w32 api uses milliseconds\n\tusecs /= 1000;\n\tSleep (usecs); // W32\n\treturn 0;\n#endif\n}\n\nR_API int r_sys_clearenv(void) {\n#if __UNIX__\n#if __APPLE__ && !HAVE_ENVIRON\n\t/* do nothing */\n\tif (!env) {\n\t\tenv = r_sys_get_environ ();\n\t\treturn 0;\n\t}\n\tif (env) {\n\t\tchar **e = env;\n\t\twhile (*e) {\n\t\t\t*e++ = NULL;\n\t\t}\n\t}\n#else\n\tif (!environ) {\n\t\treturn 0;\n\t}\n\twhile (*environ) {\n\t\t*environ++ = NULL;\n\t}\n#endif\n\treturn 0;\n#else\n#ifdef _MSC_VER\n#pragma message (\"r_sys_clearenv : unimplemented for this platform\")\n#else\n#warning r_sys_clearenv : unimplemented for this platform\n#endif\n\treturn 0;\n#endif\n}\n\nR_API int r_sys_setenv(const char *key, const char *value) {\n\tif (!key) {\n\t\treturn 0;\n\t}\n#if __UNIX__\n\tif (!value) {\n\t\tunsetenv (key);\n\t\treturn 0;\n\t}\n\treturn setenv (key, value, 1);\n#elif __WINDOWS__\n\tLPTSTR key_ = r_sys_conv_utf8_to_win (key);\n\tLPTSTR value_ = r_sys_conv_utf8_to_win (value);\n\tint ret = SetEnvironmentVariable (key_, value_);\n\tif (!ret) {\n\t\tr_sys_perror (\"r_sys_setenv/SetEnvironmentVariable\");\n\t}\n\tfree (key_);\n\tfree (value_);\n\treturn ret ? 0 : -1;\n#else\n#warning r_sys_setenv : unimplemented for this platform\n\treturn 0;\n#endif\n}\n\n#if __UNIX__\nstatic char *crash_handler_cmd = NULL;\n\nstatic void signal_handler(int signum) {\n\tchar cmd[1024];\n\tif (!crash_handler_cmd) {\n\t\treturn;\n\t}\n\tsnprintf (cmd, sizeof(cmd) - 1, crash_handler_cmd, getpid ());\n\tr_sys_backtrace ();\n\texit (r_sys_cmd (cmd));\n}\n\nstatic int checkcmd(const char *c) {\n\tchar oc = 0;\n\tfor (;*c;c++) {\n\t\tif (oc == '%') {\n\t\t\tif (*c != 'd' && *c != '%') {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\toc = *c;\n\t}\n\treturn 1;\n}\n#endif\n\nR_API int r_sys_crash_handler(const char *cmd) {\n#ifndef __WINDOWS__\n\tint sig[] = { SIGINT, SIGSEGV, SIGBUS, SIGQUIT, SIGHUP, 0 };\n\n\tif (!checkcmd (cmd)) {\n\t\treturn false;\n\t}\n#ifdef HAVE_BACKTRACE\n\tvoid *array[1];\n\t/* call this outside of the signal handler to init it safely */\n\tbacktrace (array, 1);\n#endif\n\n\tfree (crash_handler_cmd);\n\tcrash_handler_cmd = strdup (cmd);\n\n\tr_sys_sigaction (sig, signal_handler);\n#else\n#pragma message (\"r_sys_crash_handler : unimplemented for this platform\")\n#endif\n\treturn true;\n}\n\nR_API char *r_sys_getenv(const char *key) {\n#if __WINDOWS__\n\tDWORD dwRet;\n\tLPTSTR envbuf = NULL, key_ = NULL, tmp_ptr;\n\tchar *val = NULL;\n\n\tif (!key) {\n\t\treturn NULL;\n\t}\n\tenvbuf = (LPTSTR)malloc (sizeof (TCHAR) * TMP_BUFSIZE);\n\tif (!envbuf) {\n\t\tgoto err_r_sys_get_env;\n\t}\n\tkey_ = r_sys_conv_utf8_to_win (key);\n\tdwRet = GetEnvironmentVariable (key_, envbuf, TMP_BUFSIZE);\n\tif (dwRet == 0) {\n\t\tif (GetLastError () == ERROR_ENVVAR_NOT_FOUND) {\n\t\t\tgoto err_r_sys_get_env;\n\t\t}\n\t} else if (TMP_BUFSIZE < dwRet) {\n\t\ttmp_ptr = (LPTSTR)realloc (envbuf, dwRet * sizeof (TCHAR));\n\t\tif (!tmp_ptr) {\n\t\t\tgoto err_r_sys_get_env;\n\t\t}\n\t\tenvbuf = tmp_ptr;\n\t\tdwRet = GetEnvironmentVariable (key_, envbuf, dwRet);\n\t\tif (!dwRet) {\n\t\t\tgoto err_r_sys_get_env;\n\t\t}\n\t}\n\tval = r_sys_conv_win_to_utf8_l (envbuf, (int)dwRet);\nerr_r_sys_get_env:\n\tfree (key_);\n\tfree (envbuf);\n\treturn val;\n#else\n\tchar *b;\n\tif (!key) {\n\t\treturn NULL;\n\t}\n\tb = getenv (key);\n\treturn b? strdup (b): NULL;\n#endif\n}\n\nR_API bool r_sys_getenv_asbool(const char *key) {\n\tchar *env = r_sys_getenv (key);\n\tconst bool res = (env && *env == '1');\n\tfree (env);\n\treturn res;\n}\n\nR_API char *r_sys_getdir(void) {\n#if __WINDOWS__\n\treturn _getcwd (NULL, 0);\n#else\n\treturn getcwd (NULL, 0);\n#endif\n}\n\nR_API int r_sys_chdir(const char *s) {\n\treturn r_sandbox_chdir (s)==0;\n}\n\nR_API bool r_sys_aslr(int val) {\n\tbool ret = true;\n#if __linux__\n\tconst char *rva = \"/proc/sys/kernel/randomize_va_space\";\n\tchar buf[3] = {0};\n\tsnprintf(buf, sizeof (buf), \"%d\\n\", val != 0 ? 2 : 0);\n\tint fd = r_sandbox_open (rva, O_WRONLY, 0644);\n\tif (fd != -1) {\n\t\tif (r_sandbox_write (fd, (ut8 *)buf, sizeof (buf)) != sizeof (buf)) {\n\t\t\teprintf (\"Failed to set RVA\\n\");\n\t\t\tret = false;\n\t\t}\n\t\tclose (fd);\n\t}\n#elif __FreeBSD__ && __FreeBSD_version >= 1300000\n\tsize_t vlen = sizeof (val);\n\tif (sysctlbyname (\"kern.elf32.aslr.enable\", NULL, 0, &val, vlen) == -1) {\n\t\teprintf (\"Failed to set RVA 32 bits\\n\");\n\t\treturn false;\n\t}\n\n#if __LP64__\n\tif (sysctlbyname (\"kern.elf64.aslr.enable\", NULL, 0, &val, vlen) == -1) {\n\t\teprintf (\"Failed to set RVA 64 bits\\n\");\n\t\tret = false;\n\t}\n#endif\n#endif\n\treturn ret;\n}\n\nR_API int r_sys_thp_mode(void) {\n#if __linux__\n\tconst char *thp = \"/sys/kernel/mm/transparent_hugepage/enabled\";\n\tint ret = 0;\n\tchar *val = r_file_slurp (thp, NULL);\n\tif (val) {\n\t\tif (strstr (val, \"[madvise]\")) {\n\t\t\tret = 1;\n\t\t} else if (strstr (val, \"[always]\")) {\n\t\t\tret = 2;\n\t\t}\n\t\tfree (val);\n\t}\n\n\treturn ret;\n#else\n  return 0;\n#endif\n}\n\n#if __UNIX__\nR_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {\n\tchar *mysterr = NULL;\n\tif (!sterr) {\n\t\tsterr = &mysterr;\n\t}\n\tchar buffer[1024], *outputptr = NULL;\n\tchar *inputptr = (char *)input;\n\tint pid, bytes = 0, status;\n\tint sh_in[2], sh_out[2], sh_err[2];\n\n\tif (len) {\n\t\t*len = 0;\n\t}\n\tif (pipe (sh_in)) {\n\t\treturn false;\n\t}\n\tif (output) {\n\t\tif (pipe (sh_out)) {\n\t\t\tclose (sh_in[0]);\n\t\t\tclose (sh_in[1]);\n\t\t\tclose (sh_out[0]);\n\t\t\tclose (sh_out[1]);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (pipe (sh_err)) {\n\t\tclose (sh_in[0]);\n\t\tclose (sh_in[1]);\n\t\treturn false;\n\t}\n\n\tswitch ((pid = r_sys_fork ())) {\n\tcase -1:\n\t\treturn false;\n\tcase 0:\n\t\tdup2 (sh_in[0], 0);\n\t\tclose (sh_in[0]);\n\t\tclose (sh_in[1]);\n\t\tif (output) {\n\t\t\tdup2 (sh_out[1], 1);\n\t\t\tclose (sh_out[0]);\n\t\t\tclose (sh_out[1]);\n\t\t}\n\t\tif (sterr) {\n\t\t\tdup2 (sh_err[1], 2);\n\t\t} else {\n\t\t\tclose (2);\n\t\t}\n\t\tclose (sh_err[0]);\n\t\tclose (sh_err[1]);\n\t\texit (r_sandbox_system (cmd, 0));\n\tdefault:\n\t\toutputptr = strdup (\"\");\n\t\tif (!outputptr) {\n\t\t\treturn false;\n\t\t}\n\t\tif (sterr) {\n\t\t\t*sterr = strdup (\"\");\n\t\t\tif (!*sterr) {\n\t\t\t\tfree (outputptr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (output) {\n\t\t\tclose (sh_out[1]);\n\t\t}\n\t\tclose (sh_err[1]);\n\t\tclose (sh_in[0]);\n\t\tif (!inputptr || !*inputptr) {\n\t\t\tclose (sh_in[1]);\n\t\t}\n\t\t// we should handle broken pipes somehow better\n\t\tr_sys_signal (SIGPIPE, SIG_IGN);\n\t\tfor (;;) {\n\t\t\tfd_set rfds, wfds;\n\t\t\tint nfd;\n\t\t\tFD_ZERO (&rfds);\n\t\t\tFD_ZERO (&wfds);\n\t\t\tif (output) {\n\t\t\t\tFD_SET (sh_out[0], &rfds);\n\t\t\t}\n\t\t\tif (sterr) {\n\t\t\t\tFD_SET (sh_err[0], &rfds);\n\t\t\t}\n\t\t\tif (inputptr && *inputptr) {\n\t\t\t\tFD_SET (sh_in[1], &wfds);\n\t\t\t}\n\t\t\tmemset (buffer, 0, sizeof (buffer));\n\t\t\tnfd = select (sh_err[0] + 1, &rfds, &wfds, NULL, NULL);\n\t\t\tif (nfd < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (output && FD_ISSET (sh_out[0], &rfds)) {\n\t\t\t\tif (!(bytes = read (sh_out[0], buffer, sizeof (buffer)-1))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuffer[sizeof (buffer) - 1] = '\\0';\n\t\t\t\tif (len) {\n\t\t\t\t\t*len += bytes;\n\t\t\t\t}\n\t\t\t\toutputptr = r_str_append (outputptr, buffer);\n\t\t\t} else if (FD_ISSET (sh_err[0], &rfds) && sterr) {\n\t\t\t\tif (!read (sh_err[0], buffer, sizeof (buffer)-1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuffer[sizeof (buffer) - 1] = '\\0';\n\t\t\t\t*sterr = r_str_append (*sterr, buffer);\n\t\t\t} else if (FD_ISSET (sh_in[1], &wfds) && inputptr && *inputptr) {\n\t\t\t\tint inputptr_len = strlen (inputptr);\n\t\t\t\tbytes = write (sh_in[1], inputptr, inputptr_len);\n\t\t\t\tif (bytes != inputptr_len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinputptr += bytes;\n\t\t\t\tif (!*inputptr) {\n\t\t\t\t\tclose (sh_in[1]);\n\t\t\t\t\t/* If neither stdout nor stderr should be captured,\n\t\t\t\t\t * abort now - nothing more to do for select(). */\n\t\t\t\t\tif (!output && !sterr) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (output) {\n\t\t\tclose (sh_out[0]);\n\t\t}\n\t\tclose (sh_err[0]);\n\t\tclose (sh_in[1]);\n\t\twaitpid (pid, &status, 0);\n\t\tbool ret = true;\n\t\tif (status) {\n\t\t\t// char *escmd = r_str_escape (cmd);\n\t\t\t// eprintf (\"error code %d (%s): %s\\n\", WEXITSTATUS (status), escmd, *sterr);\n\t\t\t// eprintf (\"(%s)\\n\", output);\n\t\t\t// eprintf (\"%s: failed command '%s'\\n\", __func__, escmd);\n\t\t\t// free (escmd);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (output) {\n\t\t\t*output = outputptr;\n\t\t} else {\n\t\t\tfree (outputptr);\n\t\t}\n\t\treturn ret;\n\t}\n\treturn false;\n}\n#elif __WINDOWS__\nR_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {\n\treturn r_sys_cmd_str_full_w32 (cmd, input, output, len, sterr);\n}\n#else\nR_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {\n\teprintf (\"r_sys_cmd_str: not yet implemented for this platform\\n\");\n\treturn false;\n}\n#endif\n\nR_API int r_sys_cmdf(const char *fmt, ...) {\n\tint ret;\n\tchar cmd[4096];\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvsnprintf (cmd, sizeof (cmd), fmt, ap);\n\tret = r_sys_cmd (cmd);\n\tva_end (ap);\n\treturn ret;\n}\n\nR_API int r_sys_cmdbg (const char *str) {\n#if __UNIX__\n\tint ret, pid = r_sys_fork ();\n\tif (pid == -1) {\n\t\treturn -1;\n\t}\n\tif (pid) {\n\t\treturn pid;\n\t}\n\tret = r_sandbox_system (str, 0);\n\teprintf (\"{exit: %d, pid: %d, cmd: \\\"%s\\\"}\", ret, pid, str);\n\texit (0);\n\treturn -1;\n#else\n#ifdef _MSC_VER\n#pragma message (\"r_sys_cmdbg is not implemented for this platform\")\n#else\n#warning r_sys_cmdbg is not implemented for this platform\n#endif\n\treturn -1;\n#endif\n}\n\nR_API int r_sys_cmd(const char *str) {\n\tif (r_sandbox_enable (0)) {\n\t\treturn false;\n\t}\n\treturn r_sandbox_system (str, 1);\n}\n\nR_API char *r_sys_cmd_str(const char *cmd, const char *input, int *len) {\n\tchar *output = NULL;\n\tif (r_sys_cmd_str_full (cmd, input, &output, len, NULL)) {\n\t\treturn output;\n\t}\n\tfree (output);\n\treturn NULL;\n}\n\nR_API bool r_sys_mkdir(const char *dir) {\n\tbool ret;\n\n\tif (r_sandbox_enable (0)) {\n\t\treturn false;\n\t}\n#if __WINDOWS__\n\tLPTSTR dir_ = r_sys_conv_utf8_to_win (dir);\n\n\tret = CreateDirectory (dir_, NULL) != 0;\n\tfree (dir_);\n#else\n\tret = mkdir (dir, 0755) != -1;\n#endif\n\treturn ret;\n}\n\nR_API bool r_sys_mkdirp(const char *dir) {\n\tbool ret = true;\n\tchar slash = R_SYS_DIR[0];\n\tchar *path = strdup (dir), *ptr = path;\n\tif (!path) {\n\t\teprintf (\"r_sys_mkdirp: Unable to allocate memory\\n\");\n\t\treturn false;\n\t}\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __WINDOWS__\n\t{\n\t\tchar *p = strstr (ptr, \":\\\\\");\n\t\tif (p) {\n\t\t\tptr = p + 2;\n\t\t}\n\t}\n#endif\n\tfor (;;) {\n\t\t// find next slash\n\t\tfor (; *ptr; ptr++) {\n\t\t\tif (*ptr == '/' || *ptr == '\\\\') {\n\t\t\t\tslash = *ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\tfree (path);\n\t\t\treturn false;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\tret = false;\n\t}\n\tfree (path);\n\treturn ret;\n}\n\nR_API void r_sys_perror_str(const char *fun) {\n#if __UNIX__\n#pragma push_macro(\"perror\")\n#undef perror\n\tperror (fun);\n#pragma pop_macro(\"perror\")\n#elif __WINDOWS__\n\tLPTSTR lpMsgBuf;\n\tDWORD dw = GetLastError();\n\n\tif (FormatMessage ( FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\t\t\tFORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\tFORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\tNULL,\n\t\t\tdw,\n\t\t\tMAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t(LPTSTR)&lpMsgBuf,\n\t\t\t0, NULL )) {\n\t\tchar *err = r_sys_conv_win_to_utf8 (lpMsgBuf);\n\t\tif (err) {\n\t\t\teprintf (\"%s: %s\\n\", fun, err);\n\t\t\tfree (err);\n\t\t}\n\t\tLocalFree (lpMsgBuf);\n\t} else {\n\t\teprintf (\"%s\\n\", fun);\n\t}\n#endif\n}\n\nR_API bool r_sys_arch_match(const char *archstr, const char *arch) {\n\tchar *ptr;\n\tif (!archstr || !arch || !*archstr || !*arch) {\n\t\treturn true;\n\t}\n\tif (!strcmp (archstr, \"*\") || !strcmp (archstr, \"any\")) {\n\t\treturn true;\n\t}\n\tif (!strcmp (archstr, arch)) {\n\t\treturn true;\n\t}\n\tif ((ptr = strstr (archstr, arch))) {\n\t\tchar p = ptr[strlen (arch)];\n\t\tif (!p || p==',') {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API int r_sys_arch_id(const char *arch) {\n\tint i;\n\tfor (i = 0; arch_bit_array[i].name; i++) {\n\t\tif (!strcmp (arch, arch_bit_array[i].name)) {\n\t\t\treturn arch_bit_array[i].bit;\n\t\t}\n\t}\n\treturn 0;\n}\n\nR_API const char *r_sys_arch_str(int arch) {\n\tint i;\n\tfor (i = 0; arch_bit_array[i].name; i++) {\n\t\tif (arch & arch_bit_array[i].bit) {\n\t\t\treturn arch_bit_array[i].name;\n\t\t}\n\t}\n\treturn \"none\";\n}\n\n#define USE_FORK 0\nR_API int r_sys_run(const ut8 *buf, int len) {\n\tconst int sz = 4096;\n\tint pdelta, ret, (*cb)();\n#if USE_FORK\n\tint st, pid;\n#endif\n// TODO: define R_SYS_ALIGN_FORWARD in r_util.h\n\tut8 *ptr, *p = malloc ((sz + len) << 1);\n\tptr = p;\n\tpdelta = ((size_t)(p)) & (4096 - 1);\n\tif (pdelta) {\n\t\tptr += (4096 - pdelta);\n\t}\n\tif (!ptr || !buf) {\n\t\teprintf (\"r_sys_run: Cannot run empty buffer\\n\");\n\t\tfree (p);\n\t\treturn false;\n\t}\n\tmemcpy (ptr, buf, len);\n\tr_mem_protect (ptr, sz, \"rx\");\n\t//r_mem_protect (ptr, sz, \"rwx\"); // try, ignore if fail\n\tcb = (int (*)())ptr;\n#if USE_FORK\n#if __UNIX__\n\tpid = r_sys_fork ();\n#else\n\tpid = -1;\n#endif\n\tif (pid < 0) {\n\t\treturn cb ();\n\t}\n\tif (!pid) {\n\t\tret = cb ();\n\t\texit (ret);\n\t\treturn ret;\n\t}\n\tst = 0;\n\twaitpid (pid, &st, 0);\n\tif (WIFSIGNALED (st)) {\n\t\tint num = WTERMSIG(st);\n\t\teprintf (\"Got signal %d\\n\", num);\n\t\tret = num;\n\t} else {\n\t\tret = WEXITSTATUS (st);\n\t}\n#else\n\tret = (*cb) ();\n#endif\n\tfree (p);\n\treturn ret;\n}\n\nR_API int r_sys_run_rop(const ut8 *buf, int len) {\n#if USE_FORK\n\tint st;\n#endif\n\t// TODO: define R_SYS_ALIGN_FORWARD in r_util.h\n\tut8 *bufptr = malloc (len);\n\tif (!bufptr) {\n\t\teprintf (\"r_sys_run_rop: Cannot allocate buffer\\n\");\n\t\treturn false;\n\t}\n\n\tif (!buf) {\n\t\teprintf (\"r_sys_run_rop: Cannot execute empty rop chain\\n\");\n\t\tfree (bufptr);\n\t\treturn false;\n\t}\n\tmemcpy (bufptr, buf, len);\n#if USE_FORK\n#if __UNIX__\n\tpid_t pid = r_sys_fork ();\n#else\n\tpid = -1;\n#endif\n\tif (pid < 0) {\n\t\tR_SYS_ASM_START_ROP ();\n\t} else {\n\t\tR_SYS_ASM_START_ROP ();\n\t\texit (0);\n                return 0;\n\t}\n\tst = 0;\n\tif (waitpid (pid, &st, 0) == -1) {\n            eprintf (\"r_sys_run_rop: waitpid failed\\n\");\n            free (bufptr);\n            return -1;\n        }\n\tif (WIFSIGNALED (st)) {\n\t\tint num = WTERMSIG (st);\n\t\teprintf (\"Got signal %d\\n\", num);\n\t\tret = num;\n\t} else {\n\t\tret = WEXITSTATUS (st);\n\t}\n#else\n\tR_SYS_ASM_START_ROP ();\n#endif\n\tfree (bufptr);\n\treturn 0;\n}\n\nR_API bool r_is_heap (void *p) {\n\tvoid *q = malloc (8);\n\tut64 mask = UT64_MAX;\n\tut64 addr = (ut64)(size_t)q;\n\taddr >>= 16;\n\taddr <<= 16;\n\tmask >>= 16;\n\tmask <<= 16;\n\tfree (q);\n\treturn (((ut64)(size_t)p) == mask);\n}\n\nR_API char *r_sys_pid_to_path(int pid) {\n#if __WINDOWS__\n\t// TODO: add maximum path length support\n\tHANDLE processHandle;\n\tconst DWORD maxlength = MAX_PATH;\n\tTCHAR filename[MAX_PATH];\n\tchar *result = NULL;\n\n\tprocessHandle = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);\n\tif (!processHandle) {\n\t\teprintf (\"r_sys_pid_to_path: Cannot open process.\\n\");\n\t\treturn NULL;\n\t}\n\tDWORD length = GetModuleFileNameEx (processHandle, NULL, filename, maxlength);\n\tif (length == 0) {\n\t\t// Upon failure fallback to GetProcessImageFileName\n\t\tlength = GetProcessImageFileName (processHandle, filename, maxlength);\n\t\tCloseHandle (processHandle);\n\t\tif (length == 0) {\n\t\t\teprintf (\"r_sys_pid_to_path: Error calling GetProcessImageFileName\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t// Convert NT path to win32 path\n\t\tchar *name = r_sys_conv_win_to_utf8 (filename);\n\t\tif (!name) {\n\t\t\teprintf (\"r_sys_pid_to_path: Error converting to utf8\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tchar *tmp = strchr (name + 1, '\\\\');\n\t\tif (!tmp) {\n\t\t\tfree (name);\n\t\t\teprintf (\"r_sys_pid_to_path: Malformed NT path\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\ttmp = strchr (tmp + 1, '\\\\');\n\t\tif (!tmp) {\n\t\t\tfree (name);\n\t\t\teprintf (\"r_sys_pid_to_path: Malformed NT path\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlength = tmp - name;\n\t\ttmp = malloc (length + 1);\n\t\tif (!tmp) {\n\t\t\tfree (name);\n\t\t\teprintf (\"r_sys_pid_to_path: Error allocating memory\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tstrncpy (tmp, name, length);\n\t\ttmp[length] = '\\0';\n\t\tTCHAR device[MAX_PATH];\n\t\tfor (TCHAR drv[] = TEXT(\"A:\"); drv[0] <= TEXT('Z'); drv[0]++) {\n\t\t\tif (QueryDosDevice (drv, device, maxlength) > 0) {\n\t\t\t\tchar *dvc = r_sys_conv_win_to_utf8 (device);\n\t\t\t\tif (!dvc) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tfree (tmp);\n\t\t\t\t\teprintf (\"r_sys_pid_to_path: Error converting to utf8\\n\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (tmp, dvc)) {\n\t\t\t\t\tfree (tmp);\n\t\t\t\t\tfree (dvc);\n\t\t\t\t\tchar *d = r_sys_conv_win_to_utf8 (drv);\n\t\t\t\t\tif (!d) {\n\t\t\t\t\t\tfree (name);\n\t\t\t\t\t\teprintf (\"r_sys_pid_to_path: Error converting to utf8\\n\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\ttmp = r_str_newf (\"%s%s\", d, &name[length]);\n\t\t\t\t\tfree (d);\n\t\t\t\t\tif (!tmp) {\n\t\t\t\t\t\tfree (name);\n\t\t\t\t\t\teprintf (\"r_sys_pid_to_path: Error calling r_str_newf\\n\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tresult = strdup (tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree (dvc);\n\t\t\t}\n\t\t}\n\t\tfree (name);\n\t\tfree (tmp);\n\t} else {\n\t\tCloseHandle (processHandle);\n\t\tresult = r_sys_conv_win_to_utf8 (filename);\n\t}\n\treturn result;\n#elif __APPLE__\n#if __POWERPC__\n#warning TODO getpidproc\n\treturn NULL;\n#else\n\tchar pathbuf[PROC_PIDPATHINFO_MAXSIZE];\n\tpathbuf[0] = 0;\n\tint ret = proc_pidpath (pid, pathbuf, sizeof (pathbuf));\n\tif (ret <= 0) {\n\t\treturn NULL;\n\t}\n\treturn strdup (pathbuf);\n#endif\n#else\n\tint ret;\n#if __FreeBSD__\n\tchar pathbuf[PATH_MAX];\n\tsize_t pathbufl = sizeof (pathbuf);\n\tint mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, pid};\n\tret = sysctl (mib, 4, pathbuf, &pathbufl, NULL, 0);\n\tif (ret != 0) {\n\t\treturn NULL;\n\t}\n#else\n\tchar buf[128], pathbuf[1024];\n\tsnprintf (buf, sizeof (buf), \"/proc/%d/exe\", pid);\n\tret = readlink (buf, pathbuf, sizeof (pathbuf)-1);\n\tif (ret < 1) {\n\t\treturn NULL;\n\t}\n\tpathbuf[ret] = 0;\n#endif\n\treturn strdup (pathbuf);\n#endif\n}\n\n// TODO: rename to r_sys_env_init()\nR_API char **r_sys_get_environ () {\n#if __APPLE__ && !HAVE_ENVIRON\n\tenv = *_NSGetEnviron();\n#else\n\tenv = environ;\n#endif\n\t// return environ if available??\n\tif (!env) {\n\t\tenv = r_lib_dl_sym (NULL, \"environ\");\n\t}\n\treturn env;\n}\n\nR_API void r_sys_set_environ (char **e) {\n\tenv = e;\n}\n\nR_API char *r_sys_whoami (char *buf) {\n\tchar _buf[32];\n\tint pid = getpid ();\n\tint hasbuf = (buf)? 1: 0;\n\tif (!hasbuf) {\n\t\tbuf = _buf;\n\t}\n\tsprintf (buf, \"pid%d\", pid);\n\treturn hasbuf? buf: strdup (buf);\n}\n\nR_API int r_sys_getpid() {\n#if __UNIX__\n\treturn getpid ();\n#elif __WINDOWS__\n\treturn GetCurrentProcessId();\n#else\n#warning r_sys_getpid not implemented for this platform\n\treturn -1;\n#endif\n}\n\nR_API bool r_sys_tts(const char *txt, bool bg) {\n\tint i;\n\tr_return_val_if_fail (txt, false);\n\tconst char *says[] = {\n\t\t\"say\", \"termux-tts-speak\", NULL\n\t};\n\tfor (i = 0; says[i]; i++) {\n\t\tchar *sayPath = r_file_path (says[i]);\n\t\tif (sayPath) {\n\t\t\tchar *line = r_str_replace (strdup (txt), \"'\", \"\\\"\", 1);\n\t\t\tr_sys_cmdf (\"\\\"%s\\\" '%s'%s\", sayPath, line, bg? \" &\": \"\");\n\t\t\tfree (line);\n\t\t\tfree (sayPath);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API const char *r_sys_prefix(const char *pfx) {\n\tstatic char *prefix = NULL;\n\tif (!prefix) {\n#if __WINDOWS__\n\t\tprefix = r_sys_get_src_dir_w32 ();\n\t\tif (!prefix) {\n\t\t\tprefix = strdup (R2_PREFIX);\n\t\t}\n#else\n\t\tprefix = strdup (R2_PREFIX);\n#endif\n\t}\n\tif (pfx) {\n\t\tfree (prefix);\n\t\tprefix = strdup (pfx);\n\t}\n\treturn prefix;\n}\n\nR_API RSysInfo *r_sys_info(void) {\n#if __UNIX__\n\tstruct utsname un = {{0}};\n\tif (uname (&un) != -1) {\n\t\tRSysInfo *si = R_NEW0 (RSysInfo);\n\t\tif (si) {\n\t\t\tsi->sysname  = strdup (un.sysname);\n\t\t\tsi->nodename = strdup (un.nodename);\n\t\t\tsi->release  = strdup (un.release);\n\t\t\tsi->version  = strdup (un.version);\n\t\t\tsi->machine  = strdup (un.machine);\n\t\t\treturn si;\n\t\t}\n\t}\n#elif __WINDOWS__\n\tHKEY key;\n\tDWORD type;\n\tDWORD size;\n\tDWORD major;\n\tDWORD minor;\n\tchar tmp[256] = {0};\n\tRSysInfo *si = R_NEW0 (RSysInfo);\n\tif (!si) {\n\t\treturn NULL;\n\t}\n\t\n\tif (RegOpenKeyExA (HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\", 0,\n\t\tKEY_QUERY_VALUE, &key) != ERROR_SUCCESS) {\n\t\tr_sys_perror (\"r_sys_info/RegOpenKeyExA\");\n\t\tr_sys_info_free (si);\n\t\treturn NULL;\n\t}\n\n\tsize = sizeof (tmp);\n\tif (RegQueryValueExA (key, \"ProductName\", NULL, &type,\n\t\t(LPBYTE)&tmp, &size) != ERROR_SUCCESS\n\t\t|| type != REG_SZ) {\n\t\tgoto beach;\n\t}\n\tsi->sysname = strdup (tmp);\n\n\tsize = sizeof (major);\n\tif (RegQueryValueExA (key, \"CurrentMajorVersionNumber\", NULL, &type,\n\t\t(LPBYTE)&major, &size) != ERROR_SUCCESS\n\t\t|| type != REG_DWORD) {\n\t\tgoto beach;\n\t}\n\tsize = sizeof (minor);\n\tif (RegQueryValueExA (key, \"CurrentMinorVersionNumber\", NULL, &type,\n\t\t(LPBYTE)&minor, &size) != ERROR_SUCCESS\n\t\t|| type != REG_DWORD) {\n\t\tgoto beach;\n\t}\n\n\tsize = sizeof (tmp);\n\tif (RegQueryValueExA (key, \"CurrentBuild\", NULL, &type,\n\t\t(LPBYTE)&tmp, &size) != ERROR_SUCCESS\n\t\t|| type != REG_SZ) {\n\t\tgoto beach;\n\t}\n\tsi->version = r_str_newf (\"%d.%d.%s\", major, minor, tmp);\n\n\tsize = sizeof (tmp);\n\tif (RegQueryValueExA (key, \"ReleaseId\", NULL, &type,\n\t\t(LPBYTE)tmp, &size) != ERROR_SUCCESS\n\t\t|| type != REG_SZ) {\n\t\tgoto beach;\n\t}\n\tsi->release = strdup (tmp);\nbeach:\n\tRegCloseKey (key);\n\treturn si;\n#endif\n\treturn NULL;\n}\n\nR_API void r_sys_info_free(RSysInfo *si) {\n\tfree (si->sysname);\n\tfree (si->nodename);\n\tfree (si->release);\n\tfree (si->version);\n\tfree (si->machine);\n\tfree (si);\n}\n", "project('radare2', 'c', license: 'LGPL3', meson_version: '>=0.50.1')\n\npy3_exe = import('python').find_installation('python3')\ngit_exe = find_program('git', required: false)\npkgconfig_mod = import('pkgconfig')\n\n# Get r2 version\nr2_version = 'unknown-error'\nr2_version_major = 0\nr2_version_minor = 0\nr2_version_patch = 0\nr2_version_number = 0\nr = run_command(py3_exe, 'sys/version.py', '--full-version')\nif r.returncode() == 0\n  vers = r.stdout().strip().split('\\n')\n  r2_version = vers[0]\n  r2_version_major = vers[1]\n  r2_version_minor = vers[2]\n  r2_version_patch = vers[3]\n  r2_version_number = vers[4]\n  if host_machine.system() == 'darwin'\n    r2_version = r2_version.split('-')[0]\n  endif\nelse\n  message('Cannot find project version with sys/version.py')\nendif\n\nrepo = '.'\nif meson.is_subproject()\n  repo = meson.current_source_dir()\n  if host_machine.system() == 'windows'\n    py_cmd = 'print(__import__(\"os\").readlink(r\"@0@\"))'.format(repo)\n    py_cmd = run_command(py3_exe, '-c', py_cmd)\n    if py_cmd.returncode() == 0\n      repo = py_cmd.stdout().strip()\n      message('r2 real path: ' + repo)\n    endif\n  endif\nendif\n\n# by default, not version commit is used\nversion_commit = '0'\n\ngittap = ''\ngittip = 'unknown'\n\nif git_exe.found()\n  # Get version_commit\n  git_rev_list = run_command(git_exe, '-C', repo, 'rev-list', '--all', '--count')\n  if git_rev_list.returncode() == 0\n    version_commit = git_rev_list.stdout().strip()\n  endif\n\n  # Get gittap\n  git_describe = run_command(git_exe, '-C', repo, 'describe', '--tags', '--match', '[0-9]*')\n  if git_describe.returncode() == 0\n    gittap = git_describe.stdout().strip()\n  endif\n\n  # Get gittip\n  git_rev_parse = run_command(git_exe, '-C', repo, 'rev-parse', 'HEAD')\n  if git_rev_parse.returncode() == 0\n    gittip = git_rev_parse.stdout().strip()\n  endif\nendif\n\nif get_option('r2_version_commit') != ''\n  version_commit = get_option('r2_version_commit')\nendif\n\nif get_option('r2_gittap') != ''\n  gittap = get_option('r2_gittap')\nendif\n# gittap is used for the version of each r_ library\n# in case it has not been set (e.g. a release tarball) set it\nif gittap == ''\n  gittap = r2_version\nendif\n\nif get_option('r2_gittip') != ''\n  gittip = get_option('r2_gittip')\nendif\n\n# Get current date\nif host_machine.system() == 'windows'\n  r2birth = run_command('cmd', '/c', 'echo %date%__%time%')\nelse\n  r2birth = run_command('date', '+%Y-%m-%d__%H:%M:%S')\nendif\nif r2birth.returncode() != 0\n  r2birth = ''\nelse\n  r2birth = r2birth.stdout().strip()\nendif\n\nr2_libversion = host_machine.system() == 'windows' ? '' : r2_version\nmessage('r2 lib version: ' + r2_libversion)\n\n# system dependencies\ncc = meson.get_compiler('c')\n# required for linux\nldl = cc.find_library('dl', required: false)\npth = dependency('threads', required: false)\nutl = cc.find_library('util', required: false)\nif host_machine.system() == 'sunos'\n  # workaround for Solaris until https://github.com/mesonbuild/meson/issues/4328 is fixed\n  mth = declare_dependency(link_args: '-lm')\nelse\n  mth = cc.find_library('m', required: false)\nendif\n\nplatform_deps = []\nplatform_inc = ['.', 'libr/include']\nif host_machine.system() == 'windows'\n  platform_deps = [cc.find_library('ws2_32'), cc.find_library('psapi')]\nendif\nplatform_inc = include_directories(platform_inc)\n\nif get_option('static_runtime')\n  if cc.get_id() == 'msvc'\n    add_project_arguments('/MT', language: 'c')\n  endif\nendif\n\nif cc.get_id() == 'clang-cl'\n  add_project_arguments('-D__STDC__=1', language: 'c')\n  add_project_arguments('-D_CRT_DECLARE_NONSTDC_NAMES ', language: 'c')\n  add_project_arguments('-D_CRT_SECURE_NO_WARNINGS', language: 'c')\n  add_project_arguments('-D_CRT_NONSTDC_NO_DEPRECATE', language: 'c')\nendif\n\nif get_option('default_library') == 'shared'\n  if host_machine.system() != 'windows' or cc.get_id()!='msvc' and cc.get_id()!='clang-cl'\n    add_project_arguments('-fvisibility=hidden', language: 'c')\n  endif\nendif\n\nlibrary_cflags = ['-DR2_PLUGIN_INCORE=1']\n\nif host_machine.system() == 'windows'\n  r2_prefix = '.'\n  r2_libdir = 'lib'\n  r2_incdir = 'include'\n  r2_datdir = 'share'\n\n  opts1 = [\n    'r2_libdir',\n    'r2_incdir',\n    'r2_datdir'\n  ]\n  foreach opt : opts1\n    val = get_option(opt)\n    if val != ''\n      set_variable(opt, val)\n    endif\n  endforeach\n\n  r2_wwwroot = join_paths(r2_datdir, 'www')\n  r2_sdb = join_paths(r2_datdir)\n  r2_zigns = join_paths(r2_datdir, 'zigns')\n  r2_themes = join_paths(r2_datdir, 'cons')\n  r2_fortunes = join_paths(r2_datdir, 'doc')\n  r2_flags = join_paths(r2_datdir, 'flag')\n  r2_hud = join_paths(r2_datdir, 'hud')\n\n  opts2 = [\n    'r2_wwwroot',\n    'r2_sdb',\n    'r2_zigns',\n    'r2_themes',\n    'r2_fortunes',\n    'r2_flags',\n    'r2_hud'\n  ]\n  foreach opt : opts2\n    val = get_option(opt)\n    if val != ''\n      set_variable(opt, val)\n    endif\n  endforeach\n\n  opts3 = [\n    'r2_plugins',\n    'r2_extras',\n    'r2_bindings'\n  ]\n  r2_plugins = join_paths(r2_libdir, 'plugins')\n  r2_extras = join_paths(r2_libdir, 'extras')\n  r2_bindings = join_paths(r2_libdir, 'bindings')\n\n  foreach opt : opts1 + opts2 + opts3\n    val = get_variable(opt)\n    val = '\\\\\\\\'.join(val.split('/'))\n    set_variable(opt, val)\n  endforeach\nelse\n  r2_prefix = get_option('prefix')\n  r2_libdir = get_option('libdir')\n  r2_incdir = join_paths(get_option('includedir'), 'libr')\n  r2_datdir = get_option('datadir')\n  r2_datdir_r2 = join_paths(r2_datdir, 'radare2')\n  r2_wwwroot = join_paths(r2_datdir_r2, r2_version, 'www')\n  r2_sdb = join_paths(r2_datdir_r2, r2_version)\n  r2_zigns = join_paths(r2_datdir_r2, r2_version, 'zigns')\n  r2_themes = join_paths(r2_datdir_r2, r2_version, 'cons')\n  r2_fortunes = join_paths(r2_datdir, 'doc', 'radare2')\n  r2_flags = join_paths(r2_datdir_r2, r2_version, 'flag')\n  r2_hud = join_paths(r2_datdir_r2, r2_version, 'hud')\n  r2_plugins = join_paths(r2_libdir, 'radare2', r2_version)\n  r2_extras = join_paths(r2_libdir, 'radare2-extras', r2_version)\n  r2_bindings = join_paths(r2_libdir, 'radare2-bindings', r2_version)\nendif\n\nr2_zsh_compdir = join_paths(r2_datdir, 'zsh', 'site-functions')\n\n# load plugin configuration\nsubdir('libr')\n\nconf_data = configuration_data()\nconf_data.set('plugins_core', '&r_core_plugin_' + ', &r_core_plugin_'.join(core_plugins) + ', 0')\nconf_data.set('plugins_anal', '&r_anal_plugin_' + ', &r_anal_plugin_'.join(anal_plugins) + ', 0')\nconf_data.set('plugins_asm', '&r_asm_plugin_' + ', &r_asm_plugin_'.join(asm_plugins) + ', 0')\nconf_data.set('plugins_bp', '&r_bp_plugin_' + ', &r_bp_plugin_'.join(bp_plugins) + ', 0')\nconf_data.set('plugins_bin', '&r_bin_plugin_' + ', &r_bin_plugin_'.join(bin_plugins) + ', 0')\nconf_data.set('plugins_bin_ldr', '&r_bin_ldr_plugin_' + ', &r_bin_ldr_plugin_'.join(bin_ldr_plugins) + ', 0')\nconf_data.set('plugins_bin_xtr', '&r_bin_xtr_plugin_' + ', &r_bin_xtr_plugin_'.join(bin_xtr_plugins) + ', 0')\nconf_data.set('plugins_crypto', '&r_crypto_plugin_' + ', &r_crypto_plugin_'.join(crypto_plugins) + ', 0')\nconf_data.set('plugins_io', '&r_io_plugin_' + ', &r_io_plugin_'.join(io_plugins) + ', 0')\nconf_data.set('plugins_fs', '&r_fs_plugin_' + ', &r_fs_plugin_'.join(fs_plugins) + ', 0')\nconf_data.set('plugins_debug', '&r_debug_plugin_' + ', &r_debug_plugin_'.join(debug_plugins) + ', 0')\nconf_data.set('plugins_egg', '&r_egg_plugin_' + ', &r_egg_plugin_'.join(egg_plugins) + ', 0')\nconf_data.set('plugins_lang', '&r_lang_plugin_' + ', &r_lang_plugin_'.join(lang_plugins) + ', 0')\nconf_data.set('plugins_parse', '&r_parse_plugin_' + ', &r_parse_plugin_'.join(parse_plugins) + ', 0')\nconfig_h = configure_file(\n  input: 'libr/config.h.in',\n  output: 'config.h',\n  configuration: conf_data\n)\n\n# handle magic library\nsys_magic = cc.find_library('magic', required: false)\nuse_syslib_magic = false\n\nif sys_magic.found() and get_option('use_sys_magic')\n  use_syslib_magic = true\nendif\n\n# handle xxhash library\nsys_xxhash = dependency('xxhash', required: false)\nuse_sys_xxhash = false\nif not sys_xxhash.found()\n  sys_xxhash = cc.find_library('xxhash', required: false)\nendif\n\nif sys_xxhash.found() and get_option('use_sys_xxhash')\n  message('Using system xxhash library')\n  use_sys_xxhash = true\nelse\n  message('Using bundled xxhash library')\nendif\n\n# handle openssl library\nsys_openssl = dependency('openssl', required: false)\nuse_sys_openssl = false\nif sys_openssl.found() and get_option('use_sys_openssl')\n  message('Using system openssl library')\n  use_sys_openssl = true\nelse\n  message('Using bundled openssl code')\nendif\n\n# handle libuv library\nif get_option('use_libuv')\n  libuv_dep = dependency('libuv', version: '>=1.0.0', required: false)\n  use_libuv = libuv_dep.found()\n  if not libuv_dep.found()\n    warning('use_libuv option was set to true, but libuv was not found.')\n  endif\nelse\n  use_libuv = false\nendif\n\nif use_libuv\n  message('Using libuv')\nelse\n  message('Not using libuv, thus using fallback server implementations')\nendif\n\nhas_debugger = get_option('debugger')\nhave_ptrace = not ['windows', 'cygwin', 'sunos'].contains(host_machine.system())\nuse_ptrace_wrap = ['linux'].contains(host_machine.system())\n\nhave_ptrace = have_ptrace and has_debugger\nuse_ptrace_wrap = use_ptrace_wrap and has_debugger\n\nmessage('HAVE_PTRACE: @0@'.format(have_ptrace))\nmessage('USE_PTRACE_WRAP: @0@'.format(use_ptrace_wrap))\n\nchecks_level = get_option('checks_level')\nif checks_level == 9999\n  if get_option('buildtype') == 'release'\n    checks_level = 1\n  else\n    checks_level = 2\n  endif\nendif\n\nmessage('R2_CHECKS_LEVEL: @0@'.format(checks_level))\n\nuserconf = configuration_data()\nuserconf.set('R_CHECKS_LEVEL', checks_level)\nuserconf.set10('HAVE_LIB_MAGIC', sys_magic.found())\nuserconf.set10('USE_LIB_MAGIC', use_syslib_magic)\nuserconf.set10('HAVE_LIB_XXHASH', sys_xxhash.found())\nuserconf.set10('USE_LIB_XXHASH', use_sys_xxhash)\nuserconf.set10('DEBUGGER', has_debugger)\nuserconf.set('PREFIX', r2_prefix)\nif host_machine.system() == 'windows'\n  userconf.set('LIBDIR', r2_libdir)\n  userconf.set('INCLUDEDIR', r2_incdir)\n  userconf.set('DATADIR_R2', r2_datdir)\n  userconf.set10('HAVE_JEMALLOC', false)\nelse\n  userconf.set('LIBDIR', join_paths(r2_prefix, r2_libdir))\n  userconf.set('INCLUDEDIR', join_paths(r2_prefix, r2_incdir))\n  userconf.set('DATADIR_R2', r2_datdir_r2)\n  userconf.set10('HAVE_JEMALLOC', true)\nendif\nuserconf.set('DATADIR', join_paths(r2_prefix, r2_datdir))\nuserconf.set('WWWROOT', join_paths(r2_prefix, r2_wwwroot))\nuserconf.set('SDB', r2_sdb)\nuserconf.set('ZIGNS', r2_zigns)\nuserconf.set('THEMES', r2_themes)\nuserconf.set('FORTUNES', r2_fortunes)\nuserconf.set('FLAGS', r2_flags)\nuserconf.set('HUD', r2_hud)\nuserconf.set('PLUGINS', r2_plugins)\nuserconf.set('EXTRAS', r2_extras)\nuserconf.set('BINDINGS', r2_bindings)\nuserconf.set10('HAVE_OPENSSL', use_sys_openssl)\nuserconf.set10('HAVE_LIBUV', use_libuv)\nuserconf.set10('HAVE_FORK', true)\nuserconf.set10('HAVE_PTRACE', have_ptrace)\nuserconf.set10('USE_PTRACE_WRAP', use_ptrace_wrap)\nuserconf.set10('WITH_GPL', true)\nok = cc.has_header_symbol('sys/personality.h', 'ADDR_NO_RANDOMIZE')\nuserconf.set10('HAVE_DECL_ADDR_NO_RANDOMIZE', ok)\n\nforeach item : [\n    ['arc4random_uniform', '#include <stdlib.h>'],\n    ['explicit_bzero', '#include <string.h>'],\n    ['explicit_memset', '#include <string.h>'],\n    ['clock_nanosleep', '#include <time.h>'],\n    ['sigaction', '#include <signal.h>']\n  ]\n  func = item[0]\n  ok = cc.has_function(func, prefix: item[1])\n  userconf.set10('HAVE_@0@'.format(func.to_upper()), ok)\nendforeach\n\nr_userconf_h = configure_file(\n  input: 'libr/include/r_userconf.h.acr',\n  output: 'r_userconf.h',\n  configuration: userconf,\n  install_dir: join_paths(r2_incdir)\n)\n\nversionconf = configuration_data()\nversionconf.set('MESON_VERSION', meson.version())\nversionconf.set('VERSIONCOMMIT', version_commit)\nversionconf.set('R2_VERSION_MAJOR', r2_version_major)\nversionconf.set('R2_VERSION_MINOR', r2_version_minor)\nversionconf.set('R2_VERSION_PATCH', r2_version_patch)\nversionconf.set('R2_VERSION_NUMBER', r2_version_number)\nversionconf.set('R2_VERSION', r2_version)\nversionconf.set('R2_GITTAP', gittap)\nversionconf.set('R2_GITTIP', gittip)\nversionconf.set('R2_BIRTH', r2birth)\nr_version_h = configure_file(\n  input: 'libr/include/r_version.h.in',\n  output: 'r_version.h',\n  configuration: versionconf,\n  install_dir: join_paths(r2_incdir)\n)\n\n# Copy missing header\nrun_command(py3_exe, '-c', '__import__(\"shutil\").copyfile(\"shlr/spp/config.def.h\", \"shlr/spp/config.h\")')\n\npcconf = configuration_data()\npcconf.set('PREFIX', get_option('prefix'))\npcconf.set('LIBDIR', join_paths(get_option('prefix'), get_option('libdir')))\npcconf.set('VERSION', r2_version)\nlibr_pc = configure_file(\n  input: 'libr/libr.pc.acr',\n  output: 'libr.pc',\n  configuration: pcconf,\n  install_dir: join_paths(get_option('libdir'), 'pkgconfig')\n)\n\nsubdir('shlr')\n\nsubdir('libr/util')\nsubdir('libr/hash')\nsubdir('libr/crypto')\nsubdir('libr/socket')\nsubdir('libr/cons')\nsubdir('shlr/gdb')\nsubdir('libr/io')\nsubdir('libr/bp')\nsubdir('libr/syscall')\nsubdir('libr/search')\nsubdir('libr/magic')\nsubdir('libr/flag')\nsubdir('libr/reg')\nsubdir('libr/bin')\nsubdir('libr/config')\nsubdir('libr/parse')\nsubdir('libr/lang')\nsubdir('libr/asm')\nsubdir('libr/anal')\nsubdir('libr/egg')\nsubdir('libr/fs')\nsubdir('libr/debug')\nsubdir('libr/core')\n\nsubdir('libr/anal/d')\nsubdir('libr/asm/d')\nsubdir('libr/bin/d')\nsubdir('libr/syscall/d')\nsubdir('libr/cons/d')\nsubdir('libr/magic/d')\nsubdir('libr/flag/d')\nsubdir('libr/main')\n\nif not meson.is_subproject()\n  rpath = get_option('local') and get_option('default_library') == 'shared' ? '$ORIGIN/../' + get_option('libdir') : ''\n  subdir('binr/rahash2')\n  subdir('binr/rarun2')\n  subdir('binr/rasm2')\n  subdir('binr/rabin2')\n  subdir('binr/radare2')\n  subdir('binr/ragg2')\n  subdir('binr/r2agent')\n  subdir('binr/radiff2')\n  subdir('binr/rafind2')\n  subdir('binr/rasign2')\n  subdir('binr/rax2')\n  subdir('binr/r2pm')\n  subdir('binr/r2r')\nelse\n  libr2_dep = declare_dependency(\n    dependencies: [\n      r_anal_dep,\n      r_asm_dep,\n      r_bin_dep,\n      r_bp_dep,\n      r_config_dep,\n      r_cons_dep,\n      r_core_dep,\n      r_main_dep,\n      r_crypto_dep,\n      r_debug_dep,\n      r_egg_dep,\n      r_flag_dep,\n      r_fs_dep,\n      r_hash_dep,\n      r_io_dep,\n      r_lang_dep,\n      r_magic_dep,\n      r_parse_dep,\n      r_reg_dep,\n      r_search_dep,\n      r_socket_dep,\n      r_syscall_dep,\n      r_util_dep\n    ],\n    include_directories: include_directories('.', 'libr/include'),\n    version: r2_version\n  )\nendif\n\nif get_option('use_webui')\n  install_subdir('shlr/www',\n    install_dir: r2_wwwroot,\n    strip_directory: true\n  )\nendif\n\nsubdir('test/unit')\n\ninstall_data(\n  'doc/fortunes.creepy',\n  'doc/fortunes.fun',\n  'doc/fortunes.nsfw',\n  'doc/fortunes.tips',\n  install_dir: r2_fortunes\n)\n\ninstall_man(\n  'man/r2agent.1',\n  'man/r2-docker.1',\n  'man/r2pm.1',\n  'man/rabin2.1',\n  'man/radare2.1',\n  'man/radiff2.1',\n  'man/rafind2.1',\n  'man/ragg2.1',\n  'man/rahash2.1',\n  'man/rarun2.1',\n  'man/rasm2.1',\n  'man/rax2.1',\n  'man/esil.7'\n)\n\ninstall_data('doc/hud',\n  install_dir: r2_hud,\n  rename: 'main'\n)\n\ninstall_data(\n  'doc/zsh/_r2',\n  'doc/zsh/_rabin2',\n  'doc/zsh/_radiff2',\n  'doc/zsh/_rafind2',\n  'doc/zsh/_ragg2',\n  'doc/zsh/_rahash2',\n  'doc/zsh/_rasm2',\n  'doc/zsh/_rax2',\n  install_dir: r2_zsh_compdir\n)\n", "/* sdb - MIT - Copyright 2013-2018 - pancake */\n\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include \"sdb.h\"\n\n#if __SDB_WINDOWS__\n\n#if UNICODE\n\nstatic wchar_t *r_utf8_to_utf16_l (const char *cstring, int len) {\n\tif (!cstring || !len || len < -1) {\n\t\treturn NULL;\n\t}\n\twchar_t *rutf16 = NULL;\n\tint wcsize;\n\n\tif ((wcsize = MultiByteToWideChar (CP_UTF8, 0, cstring, len, NULL, 0))) {\n\t\twcsize += 1;\n\t\tif ((rutf16 = (wchar_t *) calloc (wcsize, sizeof (wchar_t)))) {\n\t\t\tMultiByteToWideChar (CP_UTF8, 0, cstring, len, rutf16, wcsize);\n\t\t\tif (len != -1) {\n\t\t\t\trutf16[wcsize - 1] = L'\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn rutf16;\n}\n\n#define r_sys_conv_utf8_to_utf16(buf) r_utf8_to_utf16_l ((buf), -1)\n\nstatic bool r_sys_mkdir(const char *path) {\n\tLPTSTR path_ = r_sys_conv_utf8_to_utf16 (path);\n\tbool ret = CreateDirectory (path_, NULL);\n\n\tfree (path_);\n\treturn ret;\n}\n#else\n#define r_sys_conv_utf8_to_utf16(buf) strdup (buf)\n#define r_sys_mkdir(x) CreateDirectory (x, NULL)\n#endif\n#ifndef ERROR_ALREADY_EXISTS\n#define ERROR_ALREADY_EXISTS 183\n#endif\n#define r_sys_mkdir_failed() (GetLastError () != 183)\n#else\n#define r_sys_mkdir(x) (mkdir (x,0755)!=-1)\n#define r_sys_mkdir_failed() (errno != EEXIST)\n#endif\n\nstatic inline int r_sys_mkdirp(char *dir) {\n\tint ret = 1;\n\tconst char slash = DIRSEP;\n\tchar *path = dir;\n\tchar *ptr = path;\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __SDB_WINDOWS__\n\tchar *p = strstr (ptr, \":\\\\\");\n\tif (p) {\n\t\tptr = p + 2;\n\t}\n#endif\n\twhile ((ptr = strchr (ptr, slash))) {\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\t*ptr = slash;\n\t\t\treturn 0;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\treturn ret;\n}\n\nSDB_API bool sdb_disk_create(Sdb* s) {\n\tint nlen;\n\tchar *str;\n\tconst char *dir;\n\tif (!s || s->fdump >= 0) {\n\t\treturn false; // cannot re-create\n\t}\n\tif (!s->dir && s->name) {\n\t\ts->dir = strdup (s->name);\n\t}\n\tdir = s->dir ? s->dir : \"./\";\n\tR_FREE (s->ndump);\n\tnlen = strlen (dir);\n\tstr = malloc (nlen + 5);\n\tif (!str) {\n\t\treturn false;\n\t}\n\tmemcpy (str, dir, nlen + 1);\n\tr_sys_mkdirp (str);\n\tmemcpy (str + nlen, \".tmp\", 5);\n\tif (s->fdump != -1) {\n\t\tclose (s->fdump);\n\t}\n#if __SDB_WINDOWS__ && UNICODE\n\twchar_t *wstr = r_sys_conv_utf8_to_utf16 (str);\n\tif (wstr) {\n\t\ts->fdump = _wopen (wstr, O_BINARY | O_RDWR | O_CREAT | O_TRUNC, SDB_MODE);\n\t\tfree (wstr);\n\t} else {\n\t\ts->fdump = -1;\n\t}\n#else\n\ts->fdump = open (str, O_BINARY | O_RDWR | O_CREAT | O_TRUNC, SDB_MODE);\n#endif\n\tif (s->fdump == -1) {\n\t\teprintf (\"sdb: Cannot open '%s' for writing.\\n\", str);\n\t\tfree (str);\n\t\treturn false;\n\t}\n\tcdb_make_start (&s->m, s->fdump);\n\ts->ndump = str;\n\treturn true;\n}\n\nSDB_API int sdb_disk_insert(Sdb* s, const char *key, const char *val) {\n\tstruct cdb_make *c = &s->m;\n\tif (!key || !val) {\n\t\treturn 0;\n\t}\n\t//if (!*val) return 0; //undefine variable if no value\n\treturn cdb_make_add (c, key, strlen (key), val, strlen (val));\n}\n\n#define IFRET(x) if (x) ret = 0\nSDB_API bool sdb_disk_finish (Sdb* s) {\n\tbool reopen = false, ret = true;\n\tIFRET (!cdb_make_finish (&s->m));\n#if USE_MMAN\n\tIFRET (fsync (s->fdump));\n#endif\n\tIFRET (close (s->fdump));\n\ts->fdump = -1;\n\t// close current fd to avoid sharing violations\n\tif (s->fd != -1) {\n\t\tclose (s->fd);\n\t\ts->fd = -1;\n\t\treopen = true;\n\t}\n#if __SDB_WINDOWS__\n\tLPTSTR ndump_ = r_sys_conv_utf8_to_utf16 (s->ndump);\n\tLPTSTR dir_ = r_sys_conv_utf8_to_utf16 (s->dir);\n\n\tif (MoveFileEx (ndump_, dir_, MOVEFILE_REPLACE_EXISTING)) {\n\t\t//eprintf (\"Error 0x%02x\\n\", GetLastError ());\n\t}\n\tfree (ndump_);\n\tfree (dir_);\n#else\n\tif (s->ndump && s->dir) {\n\t\tIFRET (rename (s->ndump, s->dir));\n\t}\n#endif\n\tfree (s->ndump);\n\ts->ndump = NULL;\n\t// reopen if was open before\n\treopen = true; // always reopen if possible\n\tif (reopen) {\n\t\tint rr = sdb_open (s, s->dir);\n\t\tif (ret && rr < 0) {\n\t\t\tret = false;\n\t\t}\n\t\tcdb_init (&s->db, s->fd);\n\t}\n\treturn ret;\n}\n\nSDB_API bool sdb_disk_unlink (Sdb *s) {\n\treturn (s->dir && *(s->dir) && unlink (s->dir) != -1);\n}\n", "NAME=PDB downloader check\nFILE=bins/pdb/user32.dll\nCMDS=!!rabin2 -PP ${R2_FILE} ~PDB\nEXPECT=<<EOF\nPDB \"user32.pdb\" download success\nEOF\nRUN\n\nNAME=find structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao R2_TEST_STRUCT\nEXPECT=<<EOF\nR2_TEST_STRUCT\nEOF\nRUN\n\nNAME=find union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao R2_TEST_UNION\nEXPECT=<<EOF\nR2_TEST_UNION\nEOF\nRUN\n\nNAME=find enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao R2_TEST_ENUM\nEXPECT=<<EOF\nR2_TEST_ENUM\nEOF\nRUN\n\nNAME=member1 offset of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_struct_var_1 | grep -ao 0x0\nEXPECT=<<EOF\n0x0\nEOF\nRUN\n\nNAME=member2 offset of structure R2_TEST_STRUCT\n\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_struct_var_2 | grep -ao 0x4\nEXPECT=<<EOF\n0x4\nEOF\nRUN\n\nNAME=member1 name of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao r2_struct_var_1\nEXPECT=<<EOF\nr2_struct_var_1\nEOF\nRUN\n\nNAME=member2 name of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao r2_struct_var_2\nEXPECT=<<EOF\nr2_struct_var_2\nEOF\nRUN\n\nNAME=member1 type of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_struct_var_1 | grep -ao long\nEXPECT=<<EOF\nlong\nEOF\nRUN\n\nNAME=member2 type of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_struct_var_2 | grep -ao short\nEXPECT=<<EOF\nshort\nEOF\nRUN\n\nNAME=check size of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao 0x8\nEXPECT=<<EOF\n0x8\nEOF\nRUN\n\nNAME=member1 offset of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_union_var_1 | grep -ao 0x0\nEXPECT=<<EOF\n0x0\nEOF\nRUN\n\nNAME=member2 offset of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_union_var_2 | grep -ao 0x0\nEXPECT=<<EOF\n0x0\nEOF\nRUN\n\nNAME=member1 name of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao r2_union_var_1\nEXPECT=<<EOF\nr2_union_var_1\nEOF\nRUN\n\nNAME=member2 name of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao r2_union_var_2\nEXPECT=<<EOF\nr2_union_var_2\nEOF\nRUN\n\nNAME=member1 type of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_union_var_1 | grep -ao long\nEXPECT=<<EOF\nlong\nEOF\nRUN\n\nNAME=member2 type of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_union_var_2 | grep -ao double\nEXPECT=<<EOF\ndouble\nEOF\nRUN\n\nNAME=check size of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep R2_TEST_UNION | grep -ao 0x8\nEXPECT=<<EOF\n0x8\nEOF\nRUN\n\nNAME=member1 value of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep eENUM1_R2 | grep -ao 0x10\nEXPECT=<<EOF\n0x10\nEOF\nRUN\n\nNAME=member2 value of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep eENUM2_R2 | grep -ao 0x20\nEXPECT=<<EOF\n0x20\nEOF\nRUN\n\nNAME=member3 vlue of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep eENUM_R2_MAX | grep -ao 0x21\nEXPECT=<<EOF\n0x21\nEOF\nRUN\n\nNAME=member1 name of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao eENUM1_R2\nEXPECT=<<EOF\neENUM1_R2\neENUM1_R2\nEOF\nRUN\n\nNAME=member2 name of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao eENUM2_R2\nEXPECT=<<EOF\neENUM2_R2\neENUM2_R2\nEOF\nRUN\n\nNAME=member3 name of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao eENUM_R2_MAX\nEXPECT=<<EOF\neENUM_R2_MAX\neENUM_R2_MAX\nEOF\nRUN\n\nNAME=check size of union R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep R2_TEST_ENUM | grep -ao 0x0\nEXPECT=<<EOF\n0x0\nEOF\nRUN\n\nNAME=enumerate export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao R2_TEST_ENUM\nEXPECT=<<EOF\nR2_TEST_ENUM\nEOF\nRUN\n\nNAME=enumerate value1 export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao eENUM1_R2=0x10\nEXPECT=<<EOF\neENUM1_R2=0x10\nEOF\nRUN\n\nNAME=enumerate value2 export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao eENUM2_R2=0x20\nEXPECT=<<EOF\neENUM2_R2=0x20\nEOF\nRUN\n\nNAME=enumerate value3 export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao eENUM_R2_MAX=0x21\nEXPECT=<<EOF\neENUM_R2_MAX=0x21\nEOF\nRUN\n\nNAME=redirection test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao _unnamed_tag_ | head -n1\nEXPECT=<<EOF\n_unnamed_tag_\nEOF\nRUN\n\nNAME=struct export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao R2_TEST_STRUCT\nEXPECT=<<EOF\nR2_TEST_STRUCT\nEOF\nRUN\n\nNAME=struct export command\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao pf\nEXPECT=<<EOF\npf\nEOF\nRUN\n\nNAME=struct export types\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao iw\nEXPECT=<<EOF\niw\nEOF\nRUN\n\nNAME=struct export name1\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao r2_struct_var_1\nEXPECT=<<EOF\nr2_struct_var_1\nEOF\nRUN\n\nNAME=struct export name2\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao r2_struct_var_2\nEXPECT=<<EOF\nr2_struct_var_2\nEOF\nRUN\n\nNAME=GUID CHECK\nFILE=bins/pdb/user32.dll\nCMDS=!rabin2 -I ${R2_FILE} | grep -ao 15F778B3671D4EFDBDCDE79905308B792\nEXPECT=<<EOF\n15F778B3671D4EFDBDCDE79905308B792\nEOF\nRUN\n", "#include <r_util.h>\n#include \"minunit.h\"\n\n//TODO test r_str_chop_path\n\nbool test_r_str_replace_char_once(void) {\n\tchar* str = strdup (\"hello world\");\n\t(void) r_str_replace_char_once (str, 'l', 'x');\n\tmu_assert_streq (str, \"hexlo world\", \"error, replace char once failed\");\n\tfree (str);\n\tmu_end;\n}\n\nbool test_r_str_replace(void) {\n\t// infinite loop test\n\tchar *str = r_str_replace (strdup (\"hello world\"), \"hell\", \"ihell\", 0);\n\tmu_assert_streq (str, \"ihello world\", \"error, replace char multi failed\");\n\tfree (str);\n\n\tstr = r_str_replace (strdup (\"hello world\"), \"hell\", \"ihell\", 1);\n\tmu_assert_streq (str, \"ihello world\", \"error, replace char multi failed\");\n\tfree (str);\n\n\tstr = r_str_replace (strdup (\"hello world\"), \"hello\", \"\", 1);\n\tmu_assert_streq (str, \" world\", \"error, replace char multi failed\");\n\tfree (str);\n\n\tstr = r_str_replace (strdup (\"hello world\"), \"h\", \"hello\", 0);\n\tmu_assert_streq (str, \"helloello world\", \"error, replace char multi failed\");\n\tfree (str);\n\n\tstr = r_str_replace (strdup (\"hello horld\"), \"h\", \"hello\", 1);\n\tmu_assert_streq (str, \"helloello helloorld\", \"error, replace char multi failed\");\n\tfree (str);\n\tstr = r_str_replace (strdup (\"hello horld\"), \"h\", \"hello\", 0);\n\tmu_assert_streq (str, \"helloello horld\", \"error, replace char multi failed\");\n\tfree (str);\n\tmu_end;\n}\n\nbool test_r_str_replace_char(void) {\n\tchar* str = strdup (\"hello world\");\n\t(void) r_str_replace_char (str, 'l', 'x');\n\tmu_assert_streq (str, \"hexxo worxd\", \"error, replace char multi failed\");\n\tfree (str);\n\tmu_end;\n}\n\n//TODO test r_str_bits\n\nbool test_r_str_bits64(void) {\n\tchar buf[65];\n\t(void)r_str_bits64 (buf, 0);\n\tmu_assert_streq (buf, \"00000000\", \"binary of 0\");\n\t(void)r_str_bits64 (buf, 1);\n\tmu_assert_streq (buf, \"00000001\", \"binary of 1\");\n\t(void)r_str_bits64 (buf, 2);\n\tmu_assert_streq (buf, \"00000010\", \"binary of 2\");\n\tmu_end;\n}\n\n//TODO test r_str_bits_from_string\n\nbool test_r_str_rwx(void) {\n\tint rwx = r_str_rwx (\"rwx\");\n\tint rw =  r_str_rwx (\"rw-\");\n\tint rx = r_str_rwx (\"rx\");\n\tint none = r_str_rwx (\"---\");\n\tint number = r_str_rwx (\"999\");\n\tint rx_number = r_str_rwx (\"5\");\n\tint rwx_number = r_str_rwx (\"7\");\n\tmu_assert_eq (rwx, 7, \"rwx\");\n\tmu_assert_eq (rw, 6, \"rw\");\n\tmu_assert_eq (rx, 5, \"rx\");\n\tmu_assert_eq (none, 0, \"no permissions\");\n\tmu_assert_eq (number, 0, \"large input number string\");\n\tmu_assert_eq (rx_number, 5, \"rx number\");\n\tmu_assert_eq (rwx_number, 7, \"rwx number\");\n\tmu_end;\n}\n\n//TODO test r_str_binstr2bin\n\nbool test_r_str_rwx_i(void) {\n\tconst char* rwx = r_str_rwx_i (7);\n\tconst char* rw = r_str_rwx_i (6);\n\tconst char* rx = r_str_rwx_i (5);\n\tconst char* invalid_mode = r_str_rwx_i (898);\n\tconst char* invalid_mode_neg = r_str_rwx_i (-10);\n\tmu_assert_streq (rwx, \"rwx\", \"rwx = 7 mode\");\n\tmu_assert_streq (rw, \"rw-\", \"rw = 6 mode\");\n\tmu_assert_streq (rx, \"r-x\", \"rx = 5 mode\");\n\tmu_assert_streq (invalid_mode, \"---\", \"invalid permissions mode\");\n\tmu_assert_streq (invalid_mode_neg, \"---\", \"invalid permissions mode (negative value)\");\n\tmu_end;\n}\n\nbool test_r_str_trim(void) {\n\t//  1\n\tconst char* one = r_str_trim_head_ro (\"  hello  \");\n\tmu_assert_streq (one, \"hello  \", \"one\");\n\t//  2\n\tchar* two = strdup (\"  hello  \");\n\tr_str_trim_head (two);\n\tmu_assert_streq (two, \"hello  \", \"two\");\n\tr_str_trim (two);\n\t//  2\n\tmu_assert_streq (two, \"hello\", \"three\");\n\tfree (two);\n\tmu_end;\n}\n//TODO find a way to test r_str_home.\n\nbool test_r_str_bool(void) {\n\tconst char* one = r_str_bool(1);\n\tconst char* zero = r_str_bool(0);\n\tconst char* fifty = r_str_bool(50);\n\tconst char* negative = r_str_bool(-1);\n\tmu_assert_streq (one, \"true\", \"one\");\n\tmu_assert_streq (zero, \"false\", \"zero\");\n\tmu_assert_streq (fifty, \"true\", \"large positive value\");\n\tmu_assert_streq (negative, \"true\", \"negative number\");\n\tmu_end;\n}\n\nbool test_r_str_case(void) {\n\tchar* str1_mixedcase = strdup (\"mIxEdCaSe\");\n\tchar* str2_mixedcase = strdup (\"mIxEdCaSe\");\n\tr_str_case (str1_mixedcase, true /*upcase*/);\n\tr_str_case (str2_mixedcase, false /*downcase*/);\n\tmu_assert_streq (str1_mixedcase, \"MIXEDCASE\", \"upcase\");\n\tmu_assert_streq (str2_mixedcase, \"mixedcase\", \"downcase\");\n\tchar* non_alphanum_1 = strdup (\"c00lstring!\");\n\tchar* non_alphanum_2 = strdup (\"c00lstrinG!\");\n\tr_str_case (non_alphanum_1, true /*upcase*/);\n\tr_str_case (non_alphanum_2, false /*downcase*/);\n\tmu_assert_streq (non_alphanum_1, \"C00LSTRING!\", \"upcase, nonalpanum\");\n\tmu_assert_streq (non_alphanum_2, \"c00lstring!\", \"downcase, nonalpanum\");\n\tfree (str1_mixedcase);\n\tfree (str2_mixedcase);\n\tfree (non_alphanum_1);\n\tfree (non_alphanum_2);\n\tmu_end;\n}\n\n//TODO test r_str_hash64, r_str_hash\n//TODO test r_str_delta (WTF!)\n\nbool test_r_str_split(void) {\n\tchar* hi = strdup (\"hello world\");\n\tint r = r_str_split (hi, ' ');\n\tmu_assert_eq (r, 2, \"split on space\");\n\tchar* hello = hi;\n\tchar* world = hi + 6;\n\tmu_assert_streq (hello, \"hello\", \"first string in split\");\n\tmu_assert_streq (world, \"world\", \"second string in split\");\n\tfree (hi);\n\tmu_end;\n}\n\nbool test_r_str_tokenize(void) {\n\t//XXX r_str_word0 doesn't work on \"hello      world\" to\n\t// tokenize into [\"hello\", \"world\"]\n\tchar* hi = strdup (\"hello world\");\n\tint r = r_str_word_set0 (hi);\n\tmu_assert_eq (r, 2, \"tokenize hello world\");\n\tconst char* hello = r_str_word_get0 (hi, 0);\n\tconst char* world = r_str_word_get0 (hi, 1);\n\tmu_assert_streq (hello, \"hello\", \"first string in split\");\n\tmu_assert_streq (world, \"world\", \"second string in split\");\n\tfree (hi);\n\tmu_end;\n}\n\nbool test_r_str_char_count(void) {\n\tmu_assert_eq (r_str_char_count (\"poop\", 'p'), 2, \"number of p in poop\");\n\tmu_end;\n}\n\nbool test_r_str_word_count(void) {\n\tmu_assert_eq (r_str_word_count (\"let's test\\nradare2 \\t libraries!\"), 4,\n\t\t\t\t\"words in a string\");\n\tmu_end;\n}\n\nbool test_r_str_ichr(void) {\n\tchar* test = \"rrrrrradare2\";\n\tchar* out = r_str_ichr (test, 'r');\n\tmu_assert_streq (out, \"adare2\",\n\t\t\t\"string after the first non-r character in rrrrrradare2\");\n\tmu_end;\n}\n\nbool test_r_str_lchr(void) {\n\tconst char* test = \"radare2\";\n\tconst char* out = r_str_lchr (test, 'r');\n\tmu_assert_streq (out, \"re2\", \"pointer to last r in radare2\");\n\tmu_end;\n}\n\nbool test_r_sub_str_lchr(void) {\n\tconst char* test = \"raddddare2d\";\n\tconst char* out = r_sub_str_lchr (test, 1, 8, 'd');\n\tmu_assert_streq (out, \"dare2d\", \"pointer to last d in range in radddddare2d\");\n\tmu_end;\n}\n\nbool test_r_sub_str_rchr(void) {\n\tconst char* test = \"raddddare2d\";\n\tconst char* out = r_sub_str_rchr (test, 1, 8, 'd');\n\tmu_assert_streq (out, \"ddddare2d\", \"pointer to first d in range in radddddare2d\");\n\tmu_end;\n}\n\nbool test_r_str_rchr(void) {\n\tconst char* test = \"raddddare2d\";\n\tconst char* out = r_str_rchr (test, NULL, '2');\n\tmu_assert_streq (out, \"2d\", \"pointer to last p in range in raddddare2d\");\n\tout = r_str_rchr (test, NULL, 'p');\n\tif (out) {\n\t\tmu_assert (\"non NULL value returned\", 0);\n\t}\n\tout = test + 9;\n\tout = r_str_rchr (test, out, 'd');\n\tmu_assert_streq (out, \"dare2d\", \"pointer to last d in range in raddddare2d\");\n\tout = test + strlen (test);\n\tout = r_str_rchr (test, out, 'p');\n\tif (out) {\n\t\tmu_assert (\"non NULL value of out\", 0);\n\t}\n\tmu_end;\n}\n\nbool test_r_str_ansi_len(void) {\n\tint len;\n\n\tlen = r_str_ansi_len (\"radare2\");\n\tmu_assert_eq (len, 7, \"len(ascii only)\");\n\n\tlen = r_str_ansi_len (\"r\\x1b[38;2;208;80;0madare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with m)\");\n\n\tlen = r_str_ansi_len (\"r\\x1b[0Jadare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with J)\");\n\n\tlen = r_str_ansi_len (\"r\\x1b[42;42Hadare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with H)\");\n\n\tlen = r_str_ansi_len (\"r\\xc3\\xa4\"\"dare2\");\n\tmu_assert_eq (len, 8, \"len(ascii + 2 byte utf-8 counted as 2 chars)\");\n\n\tlen = r_str_ansi_len (\"radar\\xe2\\x82\\xac\"\"2\");\n\tmu_assert_eq (len, 9, \"len(ascii + 3 byte utf-8 counted as 3 chars)\");\n\n\tlen = r_str_ansi_len (\"radar\\xf0\\x9d\\x84\\x9e\"\"2\");\n\tmu_assert_eq (len, 10, \"len(ascii + 4 byte utf-8 counted as 4 chars)\");\n\n\tmu_end;\n}\n\nbool test_r_str_len_utf8_ansi(void) {\n\tint len;\n\n\tlen = r_str_len_utf8_ansi (\"radare2\");\n\tmu_assert_eq (len, 7, \"len(ascii only)\");\n\n\tlen = r_str_len_utf8_ansi (\"r\\x1b[38;2;208;80;0madare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with m)\");\n\n\tlen = r_str_len_utf8_ansi (\"r\\x1b[0Jadare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with J)\");\n\n\tlen = r_str_len_utf8_ansi (\"r\\x1b[42;42Hadare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with H)\");\n\n\tlen = r_str_len_utf8_ansi (\"r\\xc3\\xa4\"\"dare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + 2 byte utf-8 counted as 1 char)\");\n\n\tlen = r_str_len_utf8_ansi (\"radar\\xe2\\x82\\xac\"\"2\");\n\tmu_assert_eq (len, 7, \"len(ascii + 3 byte utf-8 counted as 1 char)\");\n\n\tlen = r_str_len_utf8_ansi (\"radar\\xf0\\x9d\\x84\\x9e\"\"2\");\n\tmu_assert_eq (len, 7, \"len(ascii + 4 byte utf-8 counted as 1 char)\");\n\n\tmu_end;\n}\n\nbool test_r_str_utf8_charsize(void) {\n\tchar s[16] = \"\\x61\\xc3\\xa1\\xe6\\x97\\xa5\\xf0\\x9f\\x91\\x8c\\xf0\\x9f\\x91\\x8c\\x8c\"; // a\u00e1\u65e5\ud83d\udc4c\n\tint sz;\n\n\tsz = r_str_utf8_charsize (s);\n\tmu_assert_eq (sz, 1, \"1 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize (s + 1);\n\tmu_assert_eq (sz, 2, \"2 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize (s + 3);\n\tmu_assert_eq (sz, 3, \"3 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize (s + 6);\n\tmu_assert_eq (sz, 4, \"4 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize (s + 10);\n\tmu_assert_eq (sz, 0, \"Malformed UTF-8\");\n\n\tmu_end;\n}\n\nbool test_r_str_utf8_charsize_prev(void) {\n\tchar s[16] = \"\\x61\\xc3\\xa1\\xe6\\x97\\xa5\\xf0\\x9f\\x91\\x8c\\xf0\\x9f\\x91\\x8c\\x8c\"; // a\u00e1\u65e5\ud83d\udc4c\n\tint sz;\n\n\tsz = r_str_utf8_charsize_last (s);\n\tmu_assert_eq (sz, 0, \"Malformed UTF-8\");\n\n\tsz = r_str_utf8_charsize_prev (s + 10, 10);\n\tmu_assert_eq (sz, 4, \"4 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize_prev (s + 6, 6);\n\tmu_assert_eq (sz, 3, \"3 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize_prev (s + 3, 3);\n\tmu_assert_eq (sz, 2, \"2 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize_prev (s + 1, 1);\n\tmu_assert_eq (sz, 1, \"1 byte UTF-8\");\n\n\tmu_end;\n}\n\nbool test_r_str_sanitize_sdb_key(void) {\n\tchar *s = r_str_sanitize_sdb_key(\"rada.re2<is>::Cool\");\n\tmu_assert_streq (s, \"rada_re2_is_::Cool\", \"sanitize\");\n\tfree (s);\n\tmu_end;\n}\n\nbool test_r_str_unescape(void) {\n\tchar buf[] = \"Hello\\\\x31World\\\\n\";\n\tr_str_unescape (buf);\n\tmu_assert_streq (buf, \"Hello1World\\n\", \"unescaped\");\n\tmu_end;\n}\n\nbool test_r_str_newf(void) {\n\tchar *a = r_str_newf (\"hello\");\n\tmu_assert_streq (a, \"hello\", \"oops\");\n\tfree (a);\n\n\ta = r_str_newf (\"%s/%s\", \"hello\", \"world\");\n\tmu_assert_streq (a, \"hello/world\", \"oops\");\n\tfree (a);\n\n\ta = r_str_newf (\"%s/%s\", \"hello\", \"world\");\n\ta = r_str_appendf (a, \"..%s/%s\", \"cow\", \"low\");\n\ta = r_str_appendf (a, \"PWN\");\n\tmu_assert_streq (a, \"hello/world..cow/lowPWN\", \"oops\");\n\tfree (a);\n\tmu_end;\n}\n\nbool test_r_str_constpool(void) {\n\tRStrConstPool pool;\n\tbool s = r_str_constpool_init (&pool);\n\tmu_assert (\"pool init success\", s);\n\n\tconst char *a_ref = \"deliverance\";\n\tconst char *a_pooled = r_str_constpool_get (&pool, a_ref);\n\tmu_assert_ptrneq (a_pooled, a_ref, \"pooled != ref\");\n\tmu_assert_streq (a_pooled, a_ref, \"pooled == ref (strcmp)\");\n\tconst char *a_pooled2 = r_str_constpool_get (&pool, a_ref);\n\tmu_assert_ptreq (a_pooled2, a_pooled, \"same on re-get\");\n\tchar *a_ref_cpy = strdup (a_ref);\n\ta_pooled2 = r_str_constpool_get (&pool, a_ref_cpy);\n\tfree (a_ref_cpy);\n\tmu_assert_ptreq (a_pooled2, a_pooled, \"same on re-get with different ptr\");\n\n\tconst char *b_ref = \"damnation\";\n\tconst char *b_pooled = r_str_constpool_get (&pool, b_ref);\n\tmu_assert_ptrneq (b_pooled, b_ref, \"pooled != ref (second)\");\n\tmu_assert_streq (b_pooled, b_ref, \"pooled == ref (strcmp, second)\");\n\n\tr_str_constpool_fini (&pool);\n\tmu_end;\n}\n\nbool test_r_str_format_msvc_argv() {\n\t// Examples from http://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES\n\tconst char *a = \"CallMePancake\";\n\tchar *str = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"CallMePancake\", \"no escaping\");\n\tfree (str);\n\n\ta = \"Call Me Pancake\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"\\\"Call Me Pancake\\\"\", \"just quoting\");\n\tfree (str);\n\n\ta = \"CallMe\\\"Pancake\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"CallMe\\\\\\\"Pancake\", \"just escaping\");\n\tfree (str);\n\n\ta = \"CallMePancake\\\\\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"CallMePancake\\\\\", \"no escaping of backslashes\");\n\tfree (str);\n\n\ta = \"Call Me Pancake\\\\\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"\\\"Call Me Pancake\\\\\\\\\\\"\", \"escaping of backslashes before closing quote\");\n\tfree (str);\n\n\ta = \"CallMe\\\\\\\"Pancake\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"CallMe\\\\\\\\\\\\\\\"Pancake\", \"escaping of backslashes before literal quote\");\n\tfree (str);\n\n\ta = \"Call Me\\\\\\\"Pancake\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"\\\"Call Me\\\\\\\\\\\\\\\"Pancake\\\"\", \"escaping of backslashes before literal quote in quote\");\n\tfree (str);\n\n\tconst char *args[] = { \"rm\", \"-rf\", \"\\\\\"};\n\tstr = r_str_format_msvc_argv (3, args);\n\tmu_assert_streq (str, \"rm -rf \\\\\", \"multiple args\");\n\tfree (str);\n\n\tmu_end;\n}\n\nbool test_r_str_str_xy(void) {\n\tchar *canvas = \"Hello World\\n\"\n\t\t\"This World is World\\n\"\n\t\t\"World is Hello\\n\";\n\tint x = 0, y = 0;\n\tconst char *next = r_str_str_xy (canvas, \"World\", NULL, &x, &y);\n\tmu_assert_eq (x, 6, \"x of first occurrence\");\n\tmu_assert_eq (y, 0, \"y of first occurrence\");\n\tnext = r_str_str_xy (canvas, \"World\", next, &x, &y);\n\tmu_assert_eq (x, 5, \"x of second occurrence\");\n\tmu_assert_eq (y, 1, \"y of second occurrence\");\n\tnext = r_str_str_xy (canvas, \"World\", next, &x, &y);\n\tmu_assert_eq (x, 14, \"x of third occurrence\");\n\tmu_assert_eq (y, 1, \"y of third occurrence\");\n\tnext = r_str_str_xy (canvas, \"World\", next, &x, &y);\n\tmu_assert_eq (x, 0, \"x of fourth occurrence\");\n\tmu_assert_eq (y, 2, \"y of fourth occurrence\");\n\tnext = r_str_str_xy (canvas, \"World\", next, &x, &y);\n\tmu_assert_null (next, \"no more occurences\");\n\tmu_end;\n}\n\nbool all_tests () {\n\tmu_run_test (test_r_str_newf);\n\tmu_run_test (test_r_str_replace_char_once);\n\tmu_run_test (test_r_str_replace_char);\n\tmu_run_test (test_r_str_replace);\n\tmu_run_test (test_r_str_bits64);\n\tmu_run_test (test_r_str_rwx);\n\tmu_run_test (test_r_str_rwx_i);\n\tmu_run_test (test_r_str_bool);\n\tmu_run_test (test_r_str_trim);\n\tmu_run_test (test_r_str_case);\n\tmu_run_test (test_r_str_split);\n\tmu_run_test (test_r_str_tokenize);\n\tmu_run_test (test_r_str_char_count);\n\tmu_run_test (test_r_str_word_count);\n\tmu_run_test (test_r_str_ichr);\n\tmu_run_test (test_r_str_lchr);\n\tmu_run_test (test_r_sub_str_lchr);\n\tmu_run_test (test_r_sub_str_rchr);\n\tmu_run_test (test_r_str_rchr);\n\tmu_run_test (test_r_str_ansi_len);\n\tmu_run_test (test_r_str_len_utf8_ansi);\n\tmu_run_test (test_r_str_utf8_charsize);\n\tmu_run_test (test_r_str_utf8_charsize_prev);\n\tmu_run_test (test_r_str_sanitize_sdb_key);\n\tmu_run_test (test_r_str_unescape);\n\tmu_run_test (test_r_str_constpool);\n\tmu_run_test (test_r_str_format_msvc_argv);\n\tmu_run_test (test_r_str_str_xy);\n\treturn tests_passed != tests_run;\n}\n\nint main(int argc, char **argv) {\n\treturn all_tests();\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2014-2017 - inisider */\n\n#include <string.h>\n#include <r_util.h>\n#include <r_core.h>\n#include \"pdb_downloader.h\"\n\nstatic bool checkExtract() {\n#if __WINDOWS__\n\tif (r_sys_cmd (\"expand -? >nul\") != 0) {\n\t\treturn false;\n\t}\n#else\n\tif (r_sys_cmd (\"cabextract -v > /dev/null\") != 0) {\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nstatic bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {\n\tchar *dir = r_str_newf (\"%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid);\n\tif (!r_sys_mkdirp (dir)) {\n\t\tfree (dir);\n\t\treturn false;\n\t}\n\tchar *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);\n\tint len;\n\tchar *file_buf = r_socket_http_get (url, NULL, &len);\n\tfree (url);\n\tif (!len || R_STR_ISEMPTY (file_buf)) {\n\t\tfree (dir);\n\t\tfree (file_buf);\n\t\treturn false;\n\t}\n\tchar *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);\n\tFILE *f = fopen (path, \"wb\");\n\tif (f) {\n\t\tfwrite (file_buf, sizeof (char), (size_t)len, f);\n\t\tfclose (f);\n\t}\n\tfree (dir);\n\tfree (path);\n\tfree (file_buf);\n\treturn true;\n}\n\nstatic int download(struct SPDBDownloader *pd) {\n\tSPDBDownloaderOpt *opt = pd->opt;\n\tint res = 0;\n\tint cmd_ret;\n\n\tif (!opt->dbg_file || !*opt->dbg_file) {\n\t\t// no pdb debug file\n\t\treturn 0;\n\t}\n\n\tchar *abspath_to_file = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid, R_SYS_DIR,\n\t\topt->dbg_file);\n\n\tif (r_file_exists (abspath_to_file)) {\n\t\teprintf (\"File already downloaded.\\n\");\n\t\tfree (abspath_to_file);\n\t\treturn 1;\n\t}\n\n\tif (checkExtract () || opt->extract == 0) {\n\t\tchar *extractor_cmd = NULL;\n\t\tchar *archive_name = strdup (opt->dbg_file);\n\t\tarchive_name[strlen (archive_name) - 1] = '_';\n\t\tchar *abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\t\topt->symbol_store_path, R_SYS_DIR,\n\t\t\topt->dbg_file, R_SYS_DIR,\n\t\t\topt->guid, R_SYS_DIR,\n\t\t\tarchive_name);\n\n\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n\t\tchar *abs_arch_esc = r_str_escape_sh (abspath_to_archive);\n#if __WINDOWS__\n\t\tchar *abs_file_esc = r_str_escape_sh (abspath_to_file);\n\t\t// expand %1 %2\n\t\t// %1 - absolute path to archive\n\t\t// %2 - absolute path to file that will be dearchive\n\t\textractor_cmd = r_str_newf (\"expand \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_file_esc);\n\t\tfree (abs_file_esc);\n#else\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\tchar *abs_dir_esc = r_str_escape_sh (abspath_to_dir);\n\t\t// cabextract -d %1 %2\n\t\t// %1 - path to directory where to extract all files from cab archive\n\t\t// %2 - absolute path to cab archive\n\t\textractor_cmd = r_str_newf (\"cabextract -d \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_dir_esc);\n\t\tfree (abs_dir_esc);\n\t\tfree (abspath_to_dir);\n#endif\n\t\tfree (abs_arch_esc);\n\t\tres = download_and_write (opt, archive_name);\n\n\t\tif (opt->extract > 0 && res) {\n\t\t\teprintf (\"Attempting to decompress pdb\\n\");\n\t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n\t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tr_file_rm (abspath_to_archive);\n\t\t}\n\t\tfree (archive_name);\n\t\tfree (abspath_to_archive);\n\t}\n\tif (res == 0) {\n\t\teprintf (\"Falling back to uncompressed pdb\\n\");\n\t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n\t\tres = download_and_write (opt, opt->dbg_file);\n\t}\n\tfree (abspath_to_file);\n\treturn res;\n}\n\nvoid init_pdb_downloader(SPDBDownloaderOpt *opt, SPDBDownloader *pd) {\n\tpd->opt = R_NEW0 (SPDBDownloaderOpt);\n\tif (!pd->opt) {\n\t\tpd->download = 0;\n\t\teprintf (\"Cannot allocate memory for SPDBDownloaderOpt.\\n\");\n\t\treturn;\n\t}\n\tpd->opt->dbg_file = strdup (opt->dbg_file);\n\tpd->opt->guid = strdup (opt->guid);\n\tpd->opt->symbol_server = strdup (opt->symbol_server);\n\tpd->opt->user_agent = strdup (opt->user_agent);\n\tpd->opt->symbol_store_path = strdup (opt->symbol_store_path);\n\tpd->opt->extract = opt->extract;\n\tpd->download = download;\n}\n\nvoid deinit_pdb_downloader(SPDBDownloader *pd) {\n\tR_FREE (pd->opt->dbg_file);\n\tR_FREE (pd->opt->guid);\n\tR_FREE (pd->opt->symbol_server);\n\tR_FREE (pd->opt->user_agent);\n\tR_FREE (pd->opt->symbol_store_path);\n\tR_FREE (pd->opt);\n\tpd->download = 0;\n}\n\nstatic bool is_valid_guid(const char *guid) {\n\tif (!guid) {\n\t\treturn false;\n\t}\n\tsize_t i;\n\tfor (i = 0; guid[i]; i++) {\n\t\tif (!isxdigit (guid[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn i >= 33; // len of GUID and age\n}\n\nint r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n\tint ret;\n\tSPDBDownloaderOpt opt;\n\tSPDBDownloader pdb_downloader;\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\n\tif (!info || !info->debug_file_name) {\n\t\teprintf (\"Can't find debug filename\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!is_valid_guid (info->guid)) {\n\t\teprintf (\"Invalid GUID for file\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!options || !options->symbol_server || !options->user_agent) {\n\t\teprintf (\"Can't retrieve pdb configurations\\n\");\n\t\treturn 1;\n\t}\n\n\topt.dbg_file = (char*) r_file_basename (info->debug_file_name);\n\topt.guid = info->guid;\n\topt.symbol_server = options->symbol_server;\n\topt.user_agent = options->user_agent;\n\topt.symbol_store_path = options->symbol_store_path;\n\topt.extract = options->extract;\n\n\tinit_pdb_downloader (&opt, &pdb_downloader);\n\tret = pdb_downloader.download ? pdb_downloader.download (&pdb_downloader) : 0;\n\tif (isradjson && actions_done) {\n\t\tprintf (\"%s\\\"pdb\\\":{\\\"file\\\":\\\"%s\\\",\\\"download\\\":%s}\",\n\t\t        *actions_done ? \",\" : \"\", opt.dbg_file, ret ? \"true\" : \"false\");\n\t} else {\n\t\tprintf (\"PDB \\\"%s\\\" download %s\\n\",\n\t\t        opt.dbg_file, ret ? \"success\" : \"failed\");\n\t}\n\tif (actions_done) {\n\t\t(*actions_done)++;\n\t}\n\tdeinit_pdb_downloader (&pdb_downloader);\n\n\treturn 0;\n}\n", "# config.mk.tail\n\nLIBR:=$(abspath $(dir $(lastword $(MAKEFILE_LIST))))\n# neat???!? trick to support path with spaces\nnull:=\nSPACE:=$(null) $(null)\n\nifeq ($(LIBR),)\nifeq ($(R2DIR),)\n$(error ERROR: Cannot find R2DIR. Please define this variable)\nelse\nLIBR=$(R2DIR)/libr\nMSVC=$(R2DIR)/msvc\nendif\nendif\n\nSHLR:=$(LIBR)/../shlr\n\n#include $(LIBR)/../config-user.mk\ninclude $(LIBR)/../global.mk\ninclude $(LIBR)/../mk/${COMPILER}.mk\n\nCFLAGS+=${CFLAGS_APPEND}\nCFLAGS+=${CPPFLAGS}\n\nifeq (1,1)\n#$(WITHPIC),1)\nLINK+=$(subst r_,-L$(LIBR)/,$(DEPS))\nLINK+=$(subst r_,-lr_,$(DEPS))\nLINK+=$(subst r_,-L$(LIBR)/,$(BINDEPS))\nLINK+=$(subst r_,-lr_,$(BINDEPS))\nCFLAGS+=${PIC_CFLAGS}\nLINK+=${PIC_CFLAGS}\nelse\nifneq ($(DEPS),)\nLINK+=$(shell echo ${DEPS} | sed -e 's:r_\\([^ ]\\+\\):$(LIBR)/\\1/libr_\\1.${EXT_AR}:g')\nendif\nendif\n\n# Compiler: see mk/gcc.mk\n# CC CFLAGS CC_LIB CC_AR LINK\n\n# Debug\nifneq ($(OSTYPE),mingw32)\nCFLAGS+=-g\nendif\nCFLAGS+=-Wall\n\n# libgmp\nifeq (${HAVE_LIB_GMP},1)\nCFLAGS+=-DHAVE_LIB_GMP=1\nBN_LIBS=-lgmp\nendif\n\n# open-ssl\nifeq (${HAVE_LIB_SSL},1)\nBN_LIBS=${SSL_LDFLAGS}\nendif\n\n#both of these need ssl includes\nifneq (,$(filter r_socket r_util,$(BINDEPS)))\nifeq (${HAVE_LIB_SSL},1)\nCFLAGS+=${SSL_CFLAGS}\nendif\nendif\n\n# XXX do it in configure stage\nOSTYPE?=gnulinux\nifeq (${OSTYPE},auto)\n_UNAME=$(shell uname)\nifeq ($(_UNAME),Darwin)\nOSTYPE=darwin\nelse\nOSTYPE=gnulinux\nendif\nendif\nifeq (${OSTYPE},openbsd)\nOSTYPE=bsd\nendif\nifeq (${OSTYPE},netbsd)\nOSTYPE=bsd\nendif\nifeq (${OSTYPE},freebsd)\nOSTYPE=bsd\nendif\nifeq (${OSTYPE},dragonfly)\nOSTYPE=bsd\nendif\nifeq (${OSTYPE},bitrig)\nOSTYPE=bsd\nendif\n# Output\nifeq (${OSTYPE},windows)\nCFLAGS+=-D__WINDOWS__=1\nEXT_AR=lib\nEXT_SO=dll\nEXT_EXE=.exe\nTH_LIBS=\nendif\nifeq (${OSTYPE},bsd)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=-lpthread\nendif\nifeq (${OSTYPE},qnx)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=\nendif\nifeq (${OSTYPE},gnulinux)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=-lpthread\nendif\nifeq (${OSTYPE},haiku)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=\nendif\nifeq (${OSTYPE},darwin)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=dylib\nEXT_EXE=\nifeq ($(shell uname -p),arm)\n# iOS\nTH_LIBS=\nelse\n# OSX\nTH_LIBS=-lpthread\nendif\nendif\nifeq (${OSTYPE},android)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=\nendif\nifeq (${OSTYPE},solaris)\nCFLAGS+=-D__UNIX__=1\nEXT_AR=a\nEXT_SO=so\nEXT_EXE=\nTH_LIBS=\nendif\n\nifeq (${EXT_SO},)\nmain:\n\t@echo\n\t@echo \"OSTYPE: ${OSTYPE}\"\n\t@echo ERROR: Unknown platform\n\t@echo\n\t@exit 1\nendif\n\nLIB=lib${NAME}\nLIBAR=${LIB}.${EXT_AR}\nLIBSO=${LIB}.${EXT_SO}\nifeq (${OSTYPE},android)\nlibname=-shared -o $1.${EXT_SO}\nelse\nifeq (${OSTYPE},windows)\nlibname=-shared -o $1.${EXT_SO}\nelse\nifeq (${OSTYPE},darwin)\nifeq (${HAVE_LIBVERSION},1)\nlibname=-dynamiclib -o $1.${EXT_SO} ${LDFLAGS_SONAME}$1.${LIBVERSION}.${EXT_SO}\nelse\nlibname=-dynamiclib -o $1.${EXT_SO}\nendif\nelse\nifeq (${HAVE_LIBVERSION},1)\nlibname=-shared -o $1.${EXT_SO} ${LDFLAGS_SONAME}$1.${EXT_SO}.${LIBVERSION}\nelse\nlibname=-shared -o $1.${EXT_SO}\nendif\nendif\nendif\nendif\n\nifeq ($(OSTYPE),darwin)\nlibname-version = $(subst ${EXT_SO},$(2).${EXT_SO},$(1))\nelse\nlibname-version = $(1).$(2)\nendif\n\nlibpath-to-name = $(word 2,$(subst /, ,$(1)))\nlibpath-to-name-version = $(call libname-version,$(call libpath-to-name,$(1)),$(2))\n\n# -- singleton\nendif\n", "#ifndef R2_SOCKET_H\n#define R2_SOCKET_H\n\n#include \"r_types.h\"\n#include \"r_bind.h\"\n#include \"r_list.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nR_LIB_VERSION_HEADER (r_socket);\n\n#if __UNIX__\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <poll.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#endif\n\n#if HAVE_LIB_SSL\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n#if __UNIX__\n#include <netinet/tcp.h>\n#endif\n\n/* For the Mingw-W64 toolchain */\n#ifndef MSG_DONTWAIT\n#define MSG_DONTWAIT 0\n#endif\n#ifndef SD_BOTH\n#define SD_RECEIVE  0\n#define SD_SEND 1\n#define SD_BOTH 2\n#endif\n\n#if _MSC_VER\n#define R_INVALID_SOCKET INVALID_SOCKET\n#else\n#define R_INVALID_SOCKET -1\n#endif\n\ntypedef struct {\n\tint child;\n#if __WINDOWS__\n\tHANDLE pipe;\n#else\n\tint input[2];\n\tint output[2];\n#endif\n\tRCoreBind coreb;\n} R2Pipe;\n\ntypedef struct r_socket_t {\n#ifdef _MSC_VER\n\tSOCKET fd;\n#else\n\tint fd;\n#endif\n\tbool is_ssl;\n\tint proto;\n\tint local;\t// TODO: merge ssl with local -> flags/options\n\tint port;\n\tstruct sockaddr_in sa;\n#if HAVE_LIB_SSL\n\tSSL_CTX *ctx;\n\tSSL *sfd;\n\tBIO *bio;\n#endif\n} RSocket;\n\ntypedef struct r_socket_http_options {\n\tRList *authtokens;\n\tbool accept_timeout;\n\tint timeout;\n\tbool httpauth;\n} RSocketHTTPOptions;\n\n\n#define R_SOCKET_PROTO_TCP IPPROTO_TCP\n#define R_SOCKET_PROTO_UDP IPPROTO_UDP\n#define R_SOCKET_PROTO_UNIX 0x1337\n\n#ifdef R_API\nR_API RSocket *r_socket_new_from_fd(int fd);\nR_API RSocket *r_socket_new(bool is_ssl);\nR_API bool r_socket_spawn(RSocket *s, const char *cmd, unsigned int timeout);\nR_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout);\nR_API int r_socket_connect_serial(RSocket *sock, const char *path, int speed, int parity);\n#define r_socket_connect_tcp(a, b, c, d) r_socket_connect (a, b, c, R_SOCKET_PROTO_TCP, d)\n#define r_socket_connect_udp(a, b, c, d) r_socket_connect (a, b, c, R_SOCKET_PROTO_UDP, d)\n#if __UNIX__\n#define r_socket_connect_unix(a, b) r_socket_connect (a, b, b, R_SOCKET_PROTO_UNIX, 0)\n#else\n#define r_socket_connect_unix(a, b) (false)\n#endif\nR_API bool r_socket_listen(RSocket *s, const char *port, const char *certfile);\nR_API int r_socket_port_by_name(const char *name);\nR_API int r_socket_close_fd(RSocket *s);\nR_API int r_socket_close(RSocket *s);\nR_API int r_socket_free(RSocket *s);\nR_API RSocket *r_socket_accept(RSocket *s);\nR_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout);\nR_API int r_socket_block_time(RSocket *s, int block, int sec, int usec);\nR_API int r_socket_flush(RSocket *s);\nR_API int r_socket_ready(RSocket *s, int secs, int usecs);\nR_API char *r_socket_to_string(RSocket *s);\nR_API int r_socket_write(RSocket *s, void *buf, int len);\nR_API int r_socket_puts(RSocket *s, char *buf);\nR_API void r_socket_printf(RSocket *s, const char *fmt, ...);\nR_API int r_socket_read(RSocket *s, ut8 *read, int len);\nR_API int r_socket_read_block(RSocket *s, unsigned char *buf, int len);\nR_API int r_socket_gets(RSocket *s, char *buf, int size);\nR_API ut8 *r_socket_slurp(RSocket *s, int *len);\nR_API bool r_socket_is_connected(RSocket *);\n\n/* process */\ntypedef struct r_socket_proc_t {\n\tint fd0[2];\n\tint fd1[2];\n\tint pid;\n} RSocketProc;\n\nR_API RSocketProc *r_socket_proc_open(char *const argv[]);\nR_API int r_socket_proc_close(RSocketProc *sp);\nR_API int r_socket_proc_read(RSocketProc *sp, unsigned char *buf, int len);\nR_API int r_socket_proc_gets(RSocketProc *sp, char *buf, int size);\nR_API int r_socket_proc_write(RSocketProc *sp, void *buf, int len);\nR_API void r_socket_proc_printf(RSocketProc *sp, const char *fmt, ...);\nR_API int r_socket_proc_ready(RSocketProc *sp, int secs, int usecs);\n\n/* HTTP */\nR_API char *r_socket_http_get(const char *url, int *code, int *rlen);\nR_API char *r_socket_http_post(const char *url, const char *data, int *code, int *rlen);\nR_API void r_socket_http_server_set_breaked(bool *b);\n\ntypedef struct r_socket_http_request {\n\tRSocket *s;\n\tchar *path;\n\tchar *host;\n\tchar *agent;\n\tchar *method;\n\tchar *referer;\n\tut8 *data;\n\tint data_length;\n\tbool auth;\n} RSocketHTTPRequest;\n\nR_API RSocketHTTPRequest *r_socket_http_accept(RSocket *s, RSocketHTTPOptions *so);\nR_API void r_socket_http_response(RSocketHTTPRequest *rs, int code, const char *out, int x, const char *headers);\nR_API void r_socket_http_close(RSocketHTTPRequest *rs);\nR_API ut8 *r_socket_http_handle_upload(const ut8 *str, int len, int *olen);\n\ntypedef int (*rap_server_open)(void *user, const char *file, int flg, int mode);\ntypedef int (*rap_server_seek)(void *user, ut64 offset, int whence);\ntypedef int (*rap_server_read)(void *user, ut8 *buf, int len);\ntypedef int (*rap_server_write)(void *user, ut8 *buf, int len);\ntypedef char *(*rap_server_cmd)(void *user, const char *command);\ntypedef int (*rap_server_close)(void *user, int fd);\n\nenum {\n\tRAP_PACKET_OPEN = 1,\n\tRAP_PACKET_READ = 2,\n\tRAP_PACKET_WRITE = 3,\n\tRAP_PACKET_SEEK = 4,\n\tRAP_PACKET_CLOSE = 5,\n\t// system was deprecated in slot 6,\n\tRAP_PACKET_CMD = 7,\n\tRAP_PACKET_REPLY = 0x80,\n\tRAP_PACKET_MAX = 4096\n};\n\ntypedef struct r_socket_rap_server_t {\n\tRSocket *fd;\n\tchar *port;\n\tut8 buf[RAP_PACKET_MAX + 32];\t// This should be used as a static buffer for everything done by the server\n\trap_server_open open;\n\trap_server_seek seek;\n\trap_server_read read;\n\trap_server_write write;\n\trap_server_cmd system;\n\trap_server_cmd cmd;\n\trap_server_close close;\n\tvoid *user;\t// Always first arg for callbacks\n} RSocketRapServer;\n\nR_API RSocketRapServer *r_socket_rap_server_new(bool is_ssl, const char *port);\nR_API RSocketRapServer *r_socket_rap_server_create(const char *pathname);\nR_API void r_socket_rap_server_free(RSocketRapServer *rap_s);\nR_API bool r_socket_rap_server_listen(RSocketRapServer *rap_s, const char *certfile);\nR_API RSocket *r_socket_rap_server_accept(RSocketRapServer *rap_s);\nR_API bool r_socket_rap_server_continue(RSocketRapServer *rap_s);\n\n/* rap client */\nR_API int r_socket_rap_client_open(RSocket *s, const char *file, int rw);\nR_API char *r_socket_rap_client_command(RSocket *s, const char *cmd, RCoreBind *c);\nR_API int r_socket_rap_client_write(RSocket *s, const ut8 *buf, int count);\nR_API int r_socket_rap_client_read(RSocket *s, ut8 *buf, int count);\nR_API int r_socket_rap_client_seek(RSocket *s, ut64 offset, int whence);\n\n/* run.c */\n#define R_RUN_PROFILE_NARGS 512\ntypedef struct r_run_profile_t {\n\tchar *_args[R_RUN_PROFILE_NARGS];\n\tint _argc;\n\tchar *_system;\n\tchar *_program;\n\tchar *_runlib;\n\tchar *_runlib_fcn;\n\tchar *_stdio;\n\tchar *_stdin;\n\tchar *_stdout;\n\tchar *_stderr;\n\tchar *_chgdir;\n\tchar *_chroot;\n\tchar *_libpath;\n\tchar *_preload;\n\tint _bits;\n\tint _pid;\n\tchar *_pidfile;\n\tint _r2preload;\n\tint _docore;\n\tint _dofork;\n\tint _dodebug;\n\tint _aslr;\n\tint _maxstack;\n\tint _maxproc;\n\tint _maxfd;\n\tint _r2sleep;\n\tint _execve;\n\tchar *_setuid;\n\tchar *_seteuid;\n\tchar *_setgid;\n\tchar *_setegid;\n\tchar *_input;\n\tchar *_connect;\n\tchar *_listen;\n\tint _pty;\n\tint _timeout;\n\tint _timeout_sig;\n\tint _nice;\n} RRunProfile;\n\nR_API RRunProfile *r_run_new(const char *str);\nR_API bool r_run_parse(RRunProfile *pf, const char *profile);\nR_API void r_run_free(RRunProfile *r);\nR_API bool r_run_parseline(RRunProfile *p, const char *b);\nR_API const char *r_run_help(void);\nR_API int r_run_config_env(RRunProfile *p);\nR_API int r_run_start(RRunProfile *p);\nR_API void r_run_reset(RRunProfile *p);\nR_API int r_run_parsefile(RRunProfile *p, const char *b);\n\n/* rapipe */\nR_API R2Pipe *rap_open(const char *cmd);\nR_API R2Pipe *rap_open_corebind(RCoreBind *coreb);\nR_API int rap_close(R2Pipe *rap);\n\nR_API char *rap_cmd(R2Pipe *rap, const char *str);\nR_API char *rap_cmdf(R2Pipe *rap, const char *fmt, ...);\n\nR_API int rap_write(R2Pipe *rap, const char *str);\nR_API char *rap_read(R2Pipe *rap);\n\nR_API int r2pipe_write(R2Pipe *r2pipe, const char *str);\nR_API char *r2pipe_read(R2Pipe *r2pipe);\nR_API int r2pipe_close(R2Pipe *r2pipe);\nR_API R2Pipe *r2pipe_open_corebind(RCoreBind *coreb);\nR_API R2Pipe *r2pipe_open(const char *cmd);\nR_API R2Pipe *r2pipe_open_dl(const char *file);\nR_API char *r2pipe_cmd(R2Pipe *r2pipe, const char *str);\nR_API char *r2pipe_cmdf(R2Pipe *r2pipe, const char *fmt, ...);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "#ifndef R2_TYPES_H\n#define R2_TYPES_H\n\n#undef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n\n// defines like IS_DIGIT, etc'\n#include \"r_util/r_str_util.h\"\n#include <r_userconf.h>\n#include <stddef.h>\n#include <assert.h>\n\n// TODO: fix this to make it crosscompile-friendly: R_SYS_OSTYPE ?\n/* operating system */\n#undef __BSD__\n#undef __KFBSD__\n#undef __UNIX__\n#undef __WINDOWS__\n\n#define R_MODE_PRINT 0x000\n#define R_MODE_RADARE 0x001\n#define R_MODE_SET 0x002\n#define R_MODE_SIMPLE 0x004\n#define R_MODE_JSON 0x008\n#define R_MODE_ARRAY 0x010\n#define R_MODE_SIMPLEST 0x020\n#define R_MODE_CLASSDUMP 0x040\n#define R_MODE_EQUAL 0x080\n\n#define R_IN /* do not use, implicit */\n#define R_OUT /* parameter is written, not read */\n#define R_INOUT /* parameter is read and written */\n#define R_OWN /* pointer ownership is transferred */\n#define R_BORROW /* pointer ownership is not transferred, it must not be freed by the receiver */\n#define R_NONNULL /* pointer can not be null */\n#define R_NULLABLE /* pointer can be null */\n#define R_DEPRECATE /* should not be used in new code and should/will be removed in the future */\n#define R_IFNULL(x) /* default value for the pointer when null */\n#ifdef __GNUC__\n#define R_UNUSED __attribute__((__unused__))\n#else\n#define R_UNUSED /* unused */\n#endif\n\n#ifdef R_NEW\n#undef R_NEW\n#endif\n\n#ifdef R_NEW0\n#undef R_NEW0\n#endif\n\n#ifdef R_FREE\n#undef R_FREE\n#endif\n\n#ifdef R_NEWCOPY\n#undef R_NEWCOPY\n#endif\n\n// used in debug, io, bin, anal, ...\n#define R_PERM_R\t4\n#define R_PERM_W\t2\n#define R_PERM_X\t1\n#define R_PERM_RW\t(R_PERM_R|R_PERM_W)\n#define R_PERM_RX\t(R_PERM_R|R_PERM_X)\n#define R_PERM_RWX\t(R_PERM_R|R_PERM_W|R_PERM_X)\n#define R_PERM_WX\t(R_PERM_W|R_PERM_X)\n#define R_PERM_SHAR\t8\n#define R_PERM_PRIV\t16\n#define R_PERM_ACCESS\t32\n#define R_PERM_CREAT\t64\n\n// HACK to fix capstone-android-mips build\n#undef mips\n#define mips mips\n\n#if defined(__powerpc) || defined(__powerpc__)\n#undef __POWERPC__\n#define __POWERPC__ 1\n#endif\n\n#if __IPHONE_8_0 && TARGET_OS_IPHONE\n#define LIBC_HAVE_SYSTEM 0\n#else\n#define LIBC_HAVE_SYSTEM 1\n#endif\n\n#if APPLE_SDK_IPHONEOS || APPLE_SDK_APPLETVOS || APPLE_SDK_WATCHOS || APPLE_SDK_APPLETVSIMULATOR || APPLE_SDK_WATCHSIMULATOR\n#define LIBC_HAVE_PTRACE 0\n#else\n#define LIBC_HAVE_PTRACE 1\n#endif\n\n#if HAVE_FORK\n#define LIBC_HAVE_FORK 1\n#else\n#define LIBC_HAVE_FORK 0\n#endif\n\n#if defined(__OpenBSD__)\n#include <sys/param.h>\n#undef MAXCOMLEN\t/* redefined in zipint.h */\n#endif\n\n/* release >= 5.9 */\n#if __OpenBSD__ && OpenBSD >= 201605\n#define LIBC_HAVE_PLEDGE 1\n#else\n#define LIBC_HAVE_PLEDGE 0\n#endif\n\n#ifdef __GNUC__\n#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_ ## x\n#else\n#  define UNUSED_FUNCTION(x) UNUSED_ ## x\n#endif\n\n#ifdef __EMSCRIPTEN__\n# define __UNIX__ 1\n#endif\n\n#ifdef __HAIKU__\n# define __UNIX__ 1\n#endif\n\n#if defined (__FreeBSD__) || defined (__FreeBSD_kernel__)\n#define __KFBSD__ 1\n#else\n#define __KFBSD__ 0\n#endif\n\n#ifdef _MSC_VER\n  #define restrict\n  #define strcasecmp stricmp\n  #define strncasecmp strnicmp\n  #define __WINDOWS__ 1\n\n  #include <time.h>\n  static inline struct tm *gmtime_r(const time_t *t, struct tm *r) { return (gmtime_s(r, t))? NULL : r; }\n#endif\n\n#if defined(EMSCRIPTEN) || defined(__linux__) || defined(__APPLE__) || defined(__GNU__) || defined(__ANDROID__) || defined(__QNX__) || defined(__sun)\n  #define __BSD__ 0\n  #define __UNIX__ 1\n#endif\n#if __KFBSD__ || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)\n  #define __BSD__ 1\n  #define __UNIX__ 1\n#endif\n#if __WINDOWS__ || _WIN32\n  #ifdef _MSC_VER\n  /* Must be included before windows.h */\n  #include <winsock2.h>\n  #include <ws2tcpip.h>\n  #ifndef WIN32_LEAN_AND_MEAN\n  #define WIN32_LEAN_AND_MEAN\n  #endif\n  #endif\n  typedef int socklen_t;\n  #undef USE_SOCKETS\n  #define __WINDOWS__ 1\n  #undef __UNIX__\n  #undef __BSD__\n#endif\n#if __WINDOWS__ || _WIN32\n  #define __addr_t_defined\n  #include <windows.h>\n#endif\n\n#if defined(__APPLE__) && (__arm__ || __arm64__ || __aarch64__)\n#define TARGET_OS_IPHONE 1\n#else\n#define TARGET_OS_IPHONE 0\n#endif\n\n#ifdef __GNUC__\n  #define FUNC_ATTR_MALLOC __attribute__((malloc))\n  #define FUNC_ATTR_ALLOC_SIZE(x) __attribute__((alloc_size(x)))\n  #define FUNC_ATTR_ALLOC_SIZE_PROD(x,y) __attribute__((alloc_size(x,y)))\n  #define FUNC_ATTR_ALLOC_ALIGN(x) __attribute__((alloc_align(x)))\n  #define FUNC_ATTR_PURE __attribute__ ((pure))\n  #define FUNC_ATTR_CONST __attribute__((const))\n  #define FUNC_ATTR_USED __attribute__((used))\n  #define FUNC_ATTR_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n  #define FUNC_ATTR_ALWAYS_INLINE __attribute__((always_inline))\n\n  #ifdef __clang__\n    // clang only\n  #elif defined(__INTEL_COMPILER)\n    // intel only\n  #else\n    // gcc only\n  #endif\n#else\n  #define FUNC_ATTR_MALLOC\n  #define FUNC_ATTR_ALLOC_SIZE(x)\n  #define FUNC_ATTR_ALLOC_SIZE_PROD(x,y)\n  #define FUNC_ATTR_ALLOC_ALIGN(x)\n  #define FUNC_ATTR_PURE\n  #define FUNC_ATTR_CONST\n  #define FUNC_ATTR_USED\n  #define FUNC_ATTR_WARN_UNUSED_RESULT\n  #define FUNC_ATTR_ALWAYS_INLINE\n#endif\n\n#include <r_types_base.h>\n\n#undef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#undef _GNU_SOURCE\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <fcntl.h> /* for O_RDONLY */\n#include <r_endian.h> /* needs size_t */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define TODO(x) eprintf(__func__\"  \" x)\n\n// TODO: FS or R_SYS_DIR ??\n#undef FS\n#if __WINDOWS__\n#define FS \"\\\\\"\n#define R_SYS_DIR \"\\\\\"\n#define R_SYS_ENVSEP \";\"\n#define R_SYS_HOME \"USERPROFILE\"\n#define R_SYS_TMP \"TEMP\"\n#else\n#define FS \"/\"\n#define R_SYS_DIR \"/\"\n#define R_SYS_ENVSEP \":\"\n#define R_SYS_HOME \"HOME\"\n#define R_SYS_TMP \"TMPDIR\"\n#endif\n\n#define R_JOIN_2_PATHS(p1, p2) p1 R_SYS_DIR p2\n#define R_JOIN_3_PATHS(p1, p2, p3) p1 R_SYS_DIR p2 R_SYS_DIR p3\n#define R_JOIN_4_PATHS(p1, p2, p3, p4) p1 R_SYS_DIR p2 R_SYS_DIR p3 R_SYS_DIR p4\n#define R_JOIN_5_PATHS(p1, p2, p3, p4, p5) p1 R_SYS_DIR p2 R_SYS_DIR p3 R_SYS_DIR p4 R_SYS_DIR p5\n\n#ifndef __packed\n#define __packed __attribute__((__packed__))\n#endif\n\ntypedef int (*PrintfCallback)(const char *str, ...);\n\n/* compile-time introspection helpers */\n#define CTO(y,z) ((size_t) &((y*)0)->z)\n#define CTA(x,y,z) (x+CTO(y,z))\n#define CTI(x,y,z) (*((size_t*)(CTA(x,y,z))))\n#define CTS(x,y,z,t,v) {t* _=(t*)CTA(x,y,z);*_=v;}\n\n#ifdef R_IPI\n#undef R_IPI\n#endif\n\n#define R_IPI\n\n#ifdef R_HEAP\n#undef R_HEAP\n#endif\n#define R_HEAP\n\n#ifdef R_API\n#undef R_API\n#endif\n#if R_SWIG\n  #define R_API export\n#elif R_INLINE\n  #define R_API inline\n#else\n  #if defined(__GNUC__) && __GNUC__ >= 4\n    #define R_API __attribute__((visibility(\"default\")))\n  #elif defined(_MSC_VER)\n    #define R_API __declspec(dllexport)\n  #else\n    #define R_API\n  #endif\n#endif\n\n#define R_LIB_VERSION_HEADER(x) \\\nR_API const char *x##_version(void)\n#define R_LIB_VERSION(x) \\\nR_API const char *x##_version() { return \"\" R2_GITTAP; }\n\n#define BITS2BYTES(x) (((x)/8)+(((x)%8)?1:0))\n#define ZERO_FILL(x) memset (&x, 0, sizeof (x))\n#define R_NEWS0(x,y) (x*)calloc(y,sizeof(x))\n#define R_NEWS(x,y) (x*)malloc(sizeof(x)*(y))\n#define R_NEW0(x) (x*)calloc(1,sizeof(x))\n#define R_NEW(x) (x*)malloc(sizeof(x))\n#define R_NEWCOPY(x,y) (x*)r_new_copy(sizeof(x), y)\n\nstatic inline void *r_new_copy(int size, void *data) {\n\tvoid *a = malloc(size);\n\tif (a) {\n\t\tmemcpy (a, data, size);\n\t}\n\treturn a;\n}\n// TODO: Make R_NEW_COPY be 1 arg, not two\n#define R_NEW_COPY(x,y) x=(void*)malloc(sizeof(y));memcpy(x,y,sizeof(y))\n#define R_MEM_ALIGN(x) ((void *)(size_t)(((ut64)(size_t)x) & 0xfffffffffffff000LL))\n#define R_ARRAY_SIZE(x) (sizeof (x) / sizeof ((x)[0]))\n#define R_PTR_MOVE(d,s) d=s;s=NULL;\n\n#define R_PTR_ALIGN(v,t) \\\n\t((char *)(((size_t)(v) ) \\\n\t& ~(t - 1)))\n#define R_PTR_ALIGN_NEXT(v,t) \\\n\t((char *)(((size_t)(v) + (t - 1)) \\\n\t& ~(t - 1)))\n\n#define R_BIT_SET(x,y) (((ut8*)x)[y>>4] |= (1<<(y&0xf)))\n#define R_BIT_UNSET(x,y) (((ut8*)x)[y>>4] &= ~(1<<(y&0xf)))\n#define R_BIT_TOGGLE(x, y) ( R_BIT_CHK (x, y) ? \\\n\t\tR_BIT_UNSET (x, y): R_BIT_SET (x, y))\n\n//#define R_BIT_CHK(x,y) ((((const ut8*)x)[y>>4] & (1<<(y&0xf))))\n#define R_BIT_CHK(x,y) (*(x) & (1<<(y)))\n\n/* try for C99, but provide backwards compatibility */\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\n#define __func__ __FUNCTION__\n#endif\n\n#define PERROR_WITH_FILELINE 0\n\n#if PERROR_WITH_FILELINE\n/* make error messages useful by prepending file, line, and function name */\n#define _perror(str,file,line,func) \\\n  { \\\n\t  char buf[256]; \\\n\t  snprintf(buf,sizeof(buf),\"[%s:%d %s] %s\",file,line,func,str); \\\n\t  r_sys_perror_str(buf); \\\n  }\n#define perror(x) _perror(x,__FILE__,__LINE__,__func__)\n#define r_sys_perror(x) _perror(x,__FILE__,__LINE__,__func__)\n#else\n#define r_sys_perror(x) r_sys_perror_str(x);\n#endif\n\n#if __UNIX__\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/time.h>\n#endif\n\n#ifndef HAVE_EPRINTF\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define HAVE_EPRINTF 1\n#endif\n\n#ifndef typeof\n#define typeof(arg) __typeof__(arg)\n#endif\n\n#if 1\n#define r_offsetof(type, member) offsetof(type, member)\n#else\n#if __SDB_WINDOWS__\n#define r_offsetof(type, member) ((unsigned long) (ut64)&((type*)0)->member)\n#else\n#define r_offsetof(type, member) ((unsigned long) &((type*)0)->member)\n#endif\n#endif\n\n#define R_BETWEEN(x,y,z) (((y)>=(x)) && ((y)<=(z)))\n#define R_ROUND(x,y) ((x)%(y))?(x)+((y)-((x)%(y))):(x)\n#define R_DIM(x,y,z) (((x)<(y))?(y):((x)>(z))?(z):(x))\n#ifndef R_MAX_DEFINED\n#define R_MAX(x,y) (((x)>(y))?(x):(y))\n#define R_MAX_DEFINED\n#endif\n#ifndef R_MIN_DEFINED\n#define R_MIN(x,y) (((x)>(y))?(y):(x))\n#define R_MIN_DEFINED\n#endif\n#define R_ABS(x) (((x)<0)?-(x):(x))\n#define R_BTW(x,y,z) (((x)>=(y))&&((y)<=(z)))?y:x\n\n#define R_FREE(x) { free((void *)x); x = NULL; }\n\n#if __WINDOWS__\n#define HAVE_REGEXP 0\n#else\n#define HAVE_REGEXP 1\n#endif\n\n#if __WINDOWS__\n#define PFMT64x \"I64x\"\n#define PFMT64d \"I64d\"\n#define PFMT64u \"I64u\"\n#define PFMT64o \"I64o\"\n#define PFMTSZx \"Ix\"\n#define PFMTSZd \"Id\"\n#define PFMTSZu \"Iu\"\n#define PFMTSZo \"Io\"\n#define LDBLFMT \"f\"\n#define HHXFMT  \"x\"\n#else\n#define PFMT64x \"llx\"\n#define PFMT64d \"lld\"\n#define PFMT64u \"llu\"\n#define PFMT64o \"llo\"\n#define PFMTSZx \"zx\"\n#define PFMTSZd \"zd\"\n#define PFMTSZu \"zu\"\n#define PFMTSZo \"zo\"\n#define LDBLFMT \"Lf\"\n#define HHXFMT  \"hhx\"\n#endif\n\n#define PFMT32x \"x\"\n#define PFMT32d \"d\"\n#define PFMT32u \"u\"\n#define PFMT32o \"o\"\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#if __APPLE__\n# if __i386__\n# define R_SYS_BASE ((ut64)0x1000)\n# elif __x86_64__\n# define R_SYS_BASE ((ut64)0x100000000)\n# else\n# define R_SYS_BASE ((ut64)0x1000)\n# endif\n#elif __WINDOWS__\n# define R_SYS_BASE ((ut64)0x01001000)\n#else // linux, bsd, ...\n# if __arm__ || __arm64__\n# define R_SYS_BASE ((ut64)0x4000)\n# else\n# define R_SYS_BASE ((ut64)0x8048000)\n# endif\n#endif\n\n/* arch */\n#if __i386__\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 0\n#elif __EMSCRIPTEN__\n#define R_SYS_ARCH \"wasm\"\n#define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n#define R_SYS_ENDIAN 0\n#elif __x86_64__\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n#define R_SYS_ENDIAN 0\n#elif __POWERPC__\n# define R_SYS_ARCH \"ppc\"\n# ifdef __powerpc64__\n#  define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n# else\n#  define R_SYS_BITS R_SYS_BITS_32\n# endif\n# if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#  define R_SYS_ENDIAN 0\n# else\n#  define R_SYS_ENDIAN 1\n# endif\n#elif __arm__\n#define R_SYS_ARCH \"arm\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 0\n#elif __arm64__ || __aarch64__\n#define R_SYS_ARCH \"arm\"\n#define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n#define R_SYS_ENDIAN 0\n#elif __arc__\n#define R_SYS_ARCH \"arc\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 0\n#elif __s390x__\n#define R_SYS_ARCH \"sysz\"\n#define R_SYS_BITS R_SYS_BITS_64\n#define R_SYS_ENDIAN 1\n#elif __sparc__\n#define R_SYS_ARCH \"sparc\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 1\n#elif __mips__\n#define R_SYS_ARCH \"mips\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 1\n#elif __EMSCRIPTEN__\n/* we should default to wasm when ready */\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS R_SYS_BITS_32\n#elif __riscv__ || __riscv\n# define R_SYS_ARCH \"riscv\"\n# define R_SYS_ENDIAN 0\n# if __riscv_xlen == 32\n#  define R_SYS_BITS R_SYS_BITS_32\n# else\n#  define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n# endif\n#else\n#ifdef _MSC_VER\n#ifdef _WIN64\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS (R_SYS_BITS_32 | R_SYS_BITS_64)\n#define R_SYS_ENDIAN 0\n#define __x86_64__ 1\n#else\n#define R_SYS_ARCH \"x86\"\n#define R_SYS_BITS (R_SYS_BITS_32)\n#define __i386__ 1\n#define R_SYS_ENDIAN 0\n#endif\n#else\n#define R_SYS_ARCH \"unknown\"\n#define R_SYS_BITS R_SYS_BITS_32\n#define R_SYS_ENDIAN 0\n#endif\n#endif\n\n#define R_SYS_ENDIAN_NONE 0\n#define R_SYS_ENDIAN_LITTLE 1\n#define R_SYS_ENDIAN_BIG 2\n#define R_SYS_ENDIAN_BI 3\n\nenum {\n\tR_SYS_ARCH_NONE = 0,\n\tR_SYS_ARCH_X86 = 0x1,\n\tR_SYS_ARCH_ARM = 0x2,\n\tR_SYS_ARCH_PPC = 0x4,\n\tR_SYS_ARCH_M68K = 0x8,\n\tR_SYS_ARCH_JAVA = 0x10,\n\tR_SYS_ARCH_MIPS = 0x20,\n\tR_SYS_ARCH_SPARC = 0x40,\n\tR_SYS_ARCH_XAP = 0x80,\n\tR_SYS_ARCH_MSIL = 0x100,\n\tR_SYS_ARCH_OBJD = 0x200,\n\tR_SYS_ARCH_BF = 0x400,\n\tR_SYS_ARCH_SH = 0x800,\n\tR_SYS_ARCH_AVR = 0x1000,\n\tR_SYS_ARCH_DALVIK = 0x2000,\n\tR_SYS_ARCH_Z80 = 0x4000,\n\tR_SYS_ARCH_ARC = 0x8000,\n\tR_SYS_ARCH_I8080 = 0x10000,\n\tR_SYS_ARCH_RAR = 0x20000,\n\tR_SYS_ARCH_8051 = 0x40000,\n\tR_SYS_ARCH_TMS320 = 0x80000,\n\tR_SYS_ARCH_EBC = 0x100000,\n\tR_SYS_ARCH_H8300 = 0x200000,\n\tR_SYS_ARCH_CR16 = 0x400000,\n\tR_SYS_ARCH_V850 = 0x800000,\n\tR_SYS_ARCH_SYSZ = 0x1000000,\n\tR_SYS_ARCH_XCORE = 0x2000000,\n\tR_SYS_ARCH_PROPELLER = 0x4000000,\n\tR_SYS_ARCH_MSP430 = 0x8000000LL, // 1<<27\n\tR_SYS_ARCH_CRIS =  0x10000000LL, // 1<<28\n\tR_SYS_ARCH_HPPA =  0x20000000LL, // 1<<29\n\tR_SYS_ARCH_V810 =  0x40000000LL, // 1<<30\n\tR_SYS_ARCH_LM32 =  0x80000000LL, // 1<<31\n};\n\n#if HAVE_CLOCK_NANOSLEEP && CLOCK_MONOTONIC && (__linux__ || (__FreeBSD__ && __FreeBSD_version >= 1101000) || (__NetBSD__ && __NetBSD_Version__ >= 700000000))\n#define HAS_CLOCK_NANOSLEEP 1\n#else\n#define HAS_CLOCK_NANOSLEEP 0\n#endif\n\n/* os */\n#if defined (__QNX__)\n#define R_SYS_OS \"qnx\"\n//#elif TARGET_OS_IPHONE\n//#define R_SYS_OS \"ios\"\n#elif defined (__APPLE__)\n#define R_SYS_OS \"darwin\"\n#elif defined (__linux__)\n#define R_SYS_OS \"linux\"\n#elif defined (__WINDOWS__)\n#define R_SYS_OS \"windows\"\n#elif defined (__NetBSD__ )\n#define R_SYS_OS \"netbsd\"\n#elif defined (__OpenBSD__)\n#define R_SYS_OS \"openbsd\"\n#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)\n#define R_SYS_OS \"freebsd\"\n#else\n#define R_SYS_OS \"unknown\"\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic inline void r_run_call1(void *fcn, void *arg1) {\n\t((void (*)(void *))(fcn))(arg1);\n}\n\nstatic inline void r_run_call2(void *fcn, void *arg1, void *arg2) {\n\t((void (*)(void *, void *))(fcn))(arg1, arg2);\n}\n\nstatic inline void r_run_call3(void *fcn, void *arg1, void *arg2, void *arg3) {\n\t((void (*)(void *, void *, void *))(fcn))(arg1, arg2, arg3);\n}\n\nstatic inline void r_run_call4(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4) {\n\t((void (*)(void *, void *, void *, void *))(fcn))(arg1, arg2, arg3, arg4);\n}\n\nstatic inline void r_run_call5(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5) {\n\t((void (*)(void *, void *, void *, void *, void *))(fcn))(arg1, arg2, arg3, arg4, arg5);\n}\n\nstatic inline void r_run_call6(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6) {\n\t((void (*)(void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6);\n}\n\nstatic inline void r_run_call7(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6, void *arg7) {\n\t((void (*)(void *, void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n}\n\nstatic inline void r_run_call8(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6, void *arg7, void *arg8) {\n\t((void (*)(void *, void *, void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n}\n\nstatic inline void r_run_call9(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6, void *arg7, void *arg8, void *arg9) {\n\t((void (*)(void *, void *, void *, void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n}\n\nstatic inline void r_run_call10(void *fcn, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5,\n\tvoid *arg6, void *arg7, void *arg8, void *arg9, void *arg10) {\n\t((void (*)(void *, void *, void *, void *, void *, void *, void *, void *, void *, void *))(fcn))\n\t\t(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);\n}\n\n#ifndef container_of\n# ifdef _MSC_VER\n#  define container_of(ptr, type, member) ((type *)((char *)(ptr) - offsetof(type, member)))\n# else\n#  define container_of(ptr, type, member) ((type *)((char *)(__typeof__(((type *)0)->member) *){ptr} - offsetof(type, member)))\n# endif\n#endif\n\n// reference counter\ntypedef int RRef;\n\n#define R_REF_NAME refcount\n#define r_ref(x) x->R_REF_NAME++;\n#define r_ref_init(x) x->R_REF_NAME = 1\n#define r_unref(x,f) { assert (x->R_REF_NAME> 0); if (!--(x->R_REF_NAME)) { f(x); } }\n\n#define R_REF_TYPE RRef R_REF_NAME\n#define R_REF_FUNCTIONS(s, n) \\\nstatic inline void n##_ref(s *x) { x->R_REF_NAME++; } \\\nstatic inline void n##_unref(s *x) { r_unref (x, n##_free); }\n\n#endif // R2_TYPES_H\n", "#ifndef R_STR_H\n#define R_STR_H\n\n#include <wchar.h>\n#include \"r_str_util.h\"\n#include \"r_list.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n\tR_STRING_ENC_LATIN1 = 'a',\n\tR_STRING_ENC_UTF8 = '8',\n\tR_STRING_ENC_UTF16LE = 'u',\n\tR_STRING_ENC_UTF32LE = 'U',\n\tR_STRING_ENC_UTF16BE = 'b',\n\tR_STRING_ENC_UTF32BE = 'B',\n\tR_STRING_ENC_GUESS = 'g',\n} RStrEnc;\n\ntypedef int (*RStrRangeCallback) (void *, int);\n\n#define R_STR_ISEMPTY(x) (!(x) || !*(x))\n#define R_STR_ISNOTEMPTY(x) ((x) && *(x))\n#define R_STR_DUP(x) ((x) ? strdup ((x)) : NULL)\n#define r_str_array(x,y) ((y>=0 && y<(sizeof(x)/sizeof(*x)))?x[y]:\"\")\nR_API char *r_str_repeat(const char *ch, int sz);\nR_API const char *r_str_pad(const char ch, int len);\nR_API const char *r_str_rstr(const char *base, const char *p);\nR_API const char *r_strstr_ansi (const char *a, const char *b);\nR_API const char *r_str_rchr(const char *base, const char *p, int ch);\nR_API const char *r_str_closer_chr(const char *b, const char *s);\nR_API int r_str_bounds(const char *str, int *h);\nR_API char *r_str_crop(const char *str, unsigned int x, unsigned int y, unsigned int x2, unsigned int y2);\nR_API char *r_str_scale(const char *r, int w, int h);\nR_API bool r_str_range_in(const char *r, ut64 addr);\nR_API size_t r_str_len_utf8(const char *s);\nR_API size_t r_str_len_utf8_ansi(const char *str);\nR_API size_t r_str_len_utf8char(const char *s, int left);\nR_API size_t r_str_utf8_charsize(const char *str);\nR_API size_t r_str_utf8_charsize_prev(const char *str, int prev_len);\nR_API size_t r_str_utf8_charsize_last(const char *str);\nR_API void r_str_filter_zeroline(char *str, int len);\nR_API size_t r_str_utf8_codepoint(const char *s, size_t left);\nR_API bool r_str_char_fullwidth(const char *s, size_t left);\nR_API int r_str_write(int fd, const char *b);\nR_API void r_str_ncpy(char *dst, const char *src, size_t n);\nR_API void r_str_sanitize(char *c);\nR_API char *r_str_sanitize_sdb_key(const char *s);\nR_API const char *r_str_casestr(const char *a, const char *b);\nR_API const char *r_str_firstbut(const char *s, char ch, const char *but);\nR_API const char *r_str_lastbut(const char *s, char ch, const char *but);\nR_API int r_str_split(char *str, char ch);\nR_API RList *r_str_split_list(char *str, const char *c, int n);\nR_API RList *r_str_split_duplist(const char *str, const char *c);\nR_API int *r_str_split_lines(char *str, int *count);\nR_API char* r_str_replace(char *str, const char *key, const char *val, int g);\nR_API char *r_str_replace_icase(char *str, const char *key, const char *val, int g, int keep_case);\nR_API char *r_str_replace_in(char *str, ut32 sz, const char *key, const char *val, int g);\n#define r_str_cpy(x,y) memmove(x,y,strlen(y)+1);\nR_API int r_str_bits(char *strout, const ut8 *buf, int len, const char *bitz);\nR_API int r_str_bits64(char *strout, ut64 in);\nR_API ut64 r_str_bits_from_string(const char *buf, const char *bitz);\nR_API int r_str_rwx(const char *str);\nR_API int r_str_replace_ch(char *s, char a, char b, bool g);\nR_API int r_str_replace_char(char *s, int a, int b);\nR_API int r_str_replace_char_once(char *s, int a, int b);\nR_API void r_str_remove_char(char *str, char c);\nR_API const char *r_str_rwx_i(int rwx);\nR_API int r_str_fmtargs(const char *fmt);\nR_API char *r_str_arg_escape(const char *arg);\nR_API int r_str_arg_unescape(char *arg);\nR_API char **r_str_argv(const char *str, int *_argc);\nR_API void r_str_argv_free(char **argv);\nR_API char *r_str_new(const char *str);\nR_API int r_snprintf (char *string, int len, const char *fmt, ...);\nR_API bool r_str_is_ascii(const char *str);\nR_API char *r_str_nextword(char *s, char ch);\nR_API bool r_str_is_printable(const char *str);\nR_API bool r_str_is_printable_limited(const char *str, int size);\nR_API bool r_str_is_printable_incl_newlines(const char *str);\nR_API char *r_str_appendlen(char *ptr, const char *string, int slen);\nR_API char *r_str_newf(const char *fmt, ...);\nR_API char *r_str_newlen(const char *str, int len);\nR_API const char *r_str_sysbits(const int v);\nR_API char *r_str_trunc_ellipsis(const char *str, int len);\nR_API const char *r_str_bool(int b);\nR_API bool r_str_is_true(const char *s);\nR_API bool r_str_is_false(const char *s);\nR_API bool r_str_is_bool(const char *val);\nR_API const char *r_str_ansi_chrn(const char *str, size_t n);\nR_API size_t r_str_ansi_len(const char *str);\nR_API size_t r_str_ansi_nlen(const char *str, size_t len);\nR_API int r_str_ansi_trim(char *str, int str_len, int n);\nR_API int r_str_ansi_filter(char *str, char **out, int **cposs, int len);\nR_API char *r_str_ansi_crop(const char *str, unsigned int x, unsigned int y, unsigned int x2, unsigned int y2);\nR_API int r_str_word_count(const char *string);\nR_API int r_str_char_count(const char *string, char ch);\nR_API char *r_str_word_get0set(char *stra, int stralen, int idx, const char *newstr, int *newlen);\nR_API int r_str_word_set0(char *str);\nR_API int r_str_word_set0_stack(char *str);\nR_API const char *r_str_word_get0(const char *str, int idx);\nR_API char *r_str_word_get_first(const char *string);\nR_API void r_str_trim(char *str);\nR_API char *r_str_trim_dup(const char *str);\nR_API char *r_str_trim_lines(char *str);\nR_API void r_str_trim_head(char *str);\nR_API const char *r_str_trim_head_ro(const char *str);\nR_API const char *r_str_trim_head_wp(const char *str);\nR_API void r_str_trim_tail(char *str);\nR_API ut32 r_str_hash(const char *str);\nR_API ut64 r_str_hash64(const char *str);\nR_API char *r_str_trim_nc(char *str);\nR_API const char *r_str_nstr(const char *from, const char *to, int size);\nR_API const char *r_str_lchr(const char *str, char chr);\nR_API const char *r_sub_str_lchr(const char *str, int start, int end, char chr);\nR_API const char *r_sub_str_rchr(const char *str, int start, int end, char chr);\nR_API char *r_str_ichr(char *str, char chr);\nR_API bool r_str_ccmp(const char *dst, const char *orig, int ch);\nR_API bool r_str_cmp_list(const char *list, const char *item, char sep);\nR_API int r_str_cmp(const char *dst, const char *orig, int len);\nR_API int r_str_casecmp(const char *dst, const char *orig);\nR_API int r_str_ncasecmp(const char *dst, const char *orig, size_t n);\nR_API int r_str_ccpy(char *dst, char *orig, int ch);\nR_API const char *r_str_get(const char *str);\nR_API const char *r_str_get2(const char *str);\nR_API char *r_str_ndup(const char *ptr, int len);\nR_API char *r_str_dup(char *ptr, const char *string);\nR_API int r_str_inject(char *begin, char *end, char *str, int maxlen);\nR_API int r_str_delta(char *p, char a, char b);\nR_API void r_str_filter(char *str, int len);\nR_API const char * r_str_tok(const char *str1, const char b, size_t len);\nR_API wchar_t *r_str_mb_to_wc(const char *buf);\nR_API char *r_str_wc_to_mb(const wchar_t *buf);\nR_API wchar_t *r_str_mb_to_wc_l(const char *buf, int len);\nR_API char *r_str_wc_to_mb_l(const wchar_t *buf, int len);\nR_API const char *r_str_str_xy(const char *s, const char *word, const char *prev, int *x, int *y);\n\ntypedef void(*str_operation)(char *c);\n\nR_API int r_str_do_until_token(str_operation op, char *str, const char tok);\n\nR_API void r_str_reverse(char *str);\nR_API int r_str_re_match(const char *str, const char *reg);\nR_API int r_str_re_replace(const char *str, const char *reg, const char *sub);\nR_API int r_str_path_unescape(char *path);\nR_API char *r_str_path_escape(const char *path);\nR_API int r_str_unescape(char *buf);\nR_API char *r_str_escape(const char *buf);\nR_API char *r_str_escape_sh(const char *buf);\nR_API char *r_str_escape_dot(const char *buf);\nR_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors);\nR_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash);\nR_API char *r_str_escape_utf8_keep_printable(const char *buf, bool show_asciidot, bool esc_bslash); // like escape_utf8 but leaves valid \\uXXXX chars directly in utf-8\nR_API char *r_str_escape_utf16le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash);\nR_API char *r_str_escape_utf32le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash);\nR_API char *r_str_escape_utf16be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash);\nR_API char *r_str_escape_utf32be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash);\nR_API void r_str_byte_escape(const char *p, char **dst, int dot_nl, bool default_dot, bool esc_bslash);\nR_API char *r_str_format_msvc_argv(size_t argc, const char **argv);\nR_API void r_str_uri_decode(char *buf);\nR_API char *r_str_uri_encode(const char *buf);\nR_API char *r_str_utf16_decode(const ut8 *s, int len);\nR_API int r_str_utf16_to_utf8(ut8 *dst, int len_dst, const ut8 *src, int len_src, int little_endian);\nR_API char *r_str_utf16_encode(const char *s, int len);\nR_API char *r_str_escape_utf8_for_json(const char *s, int len);\nR_API char *r_str_home(const char *str);\nR_API char *r_str_r2_prefix(const char *str);\nR_API size_t r_str_nlen(const char *s, int n);\nR_API size_t r_str_nlen_w(const char *s, int n);\nR_API size_t r_wstr_clen(const char *s);\nR_API char *r_str_prepend(char *ptr, const char *string);\nR_API char *r_str_prefix_all(const char *s, const char *pfx);\nR_API char *r_str_append(char *ptr, const char *string);\nR_API char *r_str_append_owned(char *ptr, char *string);\nR_API char *r_str_appendf(char *ptr, const char *fmt, ...);\nR_API char *r_str_appendch(char *x, char y);\nR_API void r_str_case(char *str, bool up);\nR_API void r_str_trim_path(char *s);\nR_API ut8 r_str_contains_macro(const char *input_value);\nR_API void r_str_truncate_cmd(char *string);\nR_API char* r_str_replace_thunked(char *str, char *clean, int *thunk, int clen,\n\t\t\t\t  const char *key, const char *val, int g);\nR_API bool r_str_glob(const char *str, const char *glob);\nR_API int r_str_binstr2bin(const char *str, ut8 *out, int outlen);\nR_API char *r_str_between(const char *str, const char *prefix, const char *suffix);\nR_API bool r_str_startswith(const char *str, const char *needle);\nR_API bool r_str_endswith(const char *str, const char *needle);\nR_API bool r_str_isnumber (const char *str);\nR_API const char *r_str_last (const char *in, const char *ch);\nR_API char* r_str_highlight(char *str, const char *word, const char *color, const char *color_reset);\nR_API char *r_qrcode_gen(const ut8 *text, int len, bool utf8, bool inverted);\nR_API char *r_str_from_ut64(ut64 val);\nR_API void r_str_stripLine(char *str, const char *key);\nR_API char *r_str_list_join(RList *str, const char *sep);\n\nR_API const char *r_str_sep(const char *base, const char *sep);\nR_API const char *r_str_rsep(const char *base, const char *p, const char *sep);\nR_API char *r_str_donut(int size);\nR_API char *r_str_version(const char *program);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //  R_STR_H\n", "/* radare - LGPL - Copyright 2006-2019 - pancake */\n\n/* must be included first because of winsock2.h and windows.h */\n#include <r_socket.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <errno.h>\n\n#if EMSCRIPTEN\n#define NETWORK_DISABLED 1\n#else\n#define NETWORK_DISABLED 0\n#endif\n\n#define D if(0)\n\nR_LIB_VERSION(r_socket);\n\n\n#if NETWORK_DISABLED\n/* no network */\nR_API RSocket *r_socket_new (bool is_ssl) {\n\treturn NULL;\n}\nR_API bool r_socket_is_connected (RSocket *s) {\n\treturn false;\n}\nR_API bool r_socket_connect (RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\treturn false;\n}\nR_API bool r_socket_spawn (RSocket *s, const char *cmd, unsigned int timeout) {\n\treturn -1;\n}\nR_API int r_socket_close_fd (RSocket *s) {\n\treturn -1;\n}\nR_API int r_socket_close (RSocket *s) {\n\treturn -1;\n}\nR_API int r_socket_free (RSocket *s) {\n\treturn -1;\n}\nR_API int r_socket_port_by_name(const char *name) {\n\treturn -1;\n}\nR_API bool r_socket_listen (RSocket *s, const char *port, const char *certfile) {\n\treturn false;\n}\nR_API RSocket *r_socket_accept(RSocket *s) {\n\treturn NULL;\n}\nR_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\treturn NULL;\n}\nR_API int r_socket_block_time (RSocket *s, int block, int sec, int usec) {\n\treturn -1;\n}\nR_API int r_socket_flush(RSocket *s) {\n\treturn -1;\n}\nR_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n\treturn -1;\n}\nR_API char *r_socket_to_string(RSocket *s) {\n\treturn NULL;\n}\nR_API int r_socket_write(RSocket *s, void *buf, int len) {\n\treturn -1;\n}\nR_API int r_socket_puts(RSocket *s, char *buf) {\n\treturn -1;\n}\nR_API void r_socket_printf(RSocket *s, const char *fmt, ...) {\n\t/* nothing here */\n}\nR_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\treturn -1;\n}\nR_API int r_socket_read_block(RSocket *s, unsigned char *buf, int len) {\n\treturn -1;\n}\nR_API int r_socket_gets(RSocket *s, char *buf,\tint size) {\n\treturn -1;\n}\nR_API RSocket *r_socket_new_from_fd (int fd) {\n\treturn NULL;\n}\nR_API ut8* r_socket_slurp(RSocket *s, int *len) {\n\treturn NULL;\n}\n#else\n\n#if 0\nwinsock api notes\n=================\nclose: closes the socket without flushing the data\nWSACleanup: closes all network connections\n#endif\n#define BUFFER_SIZE 4096\n\nR_API bool r_socket_is_connected(RSocket *s) {\n#if __WINDOWS__\n\tchar buf[2];\n\tr_socket_block_time (s, 0, 0, 0);\n#ifdef _MSC_VER\n\tint ret = recv (s->fd, (char*)&buf, 1, MSG_PEEK);\n#else\n\tssize_t ret = recv (s->fd, (char*)&buf, 1, MSG_PEEK);\n#endif\n\tr_socket_block_time (s, 1, 0, 0);\n\treturn ret == 1;\n#else\n\tint error = 0;\n\tsocklen_t len = sizeof (error);\n\tint ret = getsockopt (s->fd, SOL_SOCKET, SO_ERROR, &error, &len);\n\tif (ret != 0) {\n\t\tperror (\"getsockopt\");\n\t\treturn false;\n\t}\n\tif (error != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n#endif\n}\n\n#if __UNIX__\nstatic bool __connect_unix(RSocket *s, const char *file) {\n\tstruct sockaddr_un addr;\n\tint sock = socket (PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tfree (s);\n\t\treturn false;\n\t}\n\t// TODO: set socket options\n\taddr.sun_family = AF_UNIX;\n\tstrncpy (addr.sun_path, file, sizeof (addr.sun_path)-1);\n\n\tif (connect (sock, (struct sockaddr *)&addr, sizeof(addr))==-1) {\n\t\tclose (sock);\n\t\tfree (s);\n\t\treturn false;\n\t}\n\ts->fd = sock;\n\ts->is_ssl = false;\n\treturn true;\n}\n\nstatic bool __listen_unix (RSocket *s, const char *file) {\n\tstruct sockaddr_un unix_name;\n\tint sock = socket (PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\treturn false;\n\t}\n\t// TODO: set socket options\n\tunix_name.sun_family = AF_UNIX;\n\tstrncpy (unix_name.sun_path, file, sizeof (unix_name.sun_path)-1);\n\n\t/* just to make sure there is no other socket file */\n\tunlink (unix_name.sun_path);\n\n\tif (bind (sock, (struct sockaddr *) &unix_name, sizeof (unix_name)) < 0) {\n\t\tclose (sock);\n\t\treturn false;\n\t}\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n\n\t/* change permissions */\n\tif (chmod (unix_name.sun_path, 0777) != 0) {\n\t\tclose (sock);\n\t\treturn false;\n\t}\n\tif (listen (sock, 1)) {\n\t\tclose (sock);\n\t\treturn false;\n\t}\n\ts->fd = sock;\n\treturn true;\n}\n#endif\n\nR_API RSocket *r_socket_new(bool is_ssl) {\n\tRSocket *s = R_NEW0 (RSocket);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->is_ssl = is_ssl;\n\ts->port = 0;\n#if __UNIX_\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\ts->local = 0;\n\ts->fd = R_INVALID_SOCKET;\n#if HAVE_LIB_SSL\n\tif (is_ssl) {\n\t\ts->sfd = NULL;\n\t\ts->ctx = NULL;\n\t\ts->bio = NULL;\n#if OPENSSL_VERSION_NUMBER < 0x1010000fL\n\t\tif (!SSL_library_init ()) {\n\t\t\tr_socket_free (s);\n\t\t\treturn NULL;\n\t\t}\n\t\tSSL_load_error_strings ();\n#endif\n\t}\n#endif\n\treturn s;\n}\n\nR_API bool r_socket_spawn(RSocket *s, const char *cmd, unsigned int timeout) {\n\t// XXX TODO: dont use sockets, we can achieve the same with pipes\n\tconst int port = 2000 + r_num_rand (2000);\n\tint childPid = r_sys_fork ();\n\tif (childPid == 0) {\n\t\tchar *a = r_str_replace (strdup (cmd), \"\\\\\", \"\\\\\\\\\", true);\n\t\tint res = r_sys_cmdf (\"rarun2 system=\\\"%s\\\" listen=%d\", a, port);\n\t\tfree (a);\n#if 0\n\t\t// TODO: use the api\n\t\tchar *profile = r_str_newf (\n\t\t\t\t\"system=%s\\n\"\n\t\t\t\t\"listen=%d\\n\", cmd, port);\n\t\tRRunProfile *rp = r_run_new (profile);\n\t\tr_run_start (rp);\n\t\tr_run_free (rp);\n\t\tfree (profile);\n#endif\n\t\tif (res != 0) {\n\t\t\teprintf (\"r_socket_spawn: rarun2 failed\\n\");\n\t\t\texit (1);\n\t\t}\n\t\teprintf (\"r_socket_spawn: %s is dead\\n\", cmd);\n\t\texit (0);\n\t}\n\tr_sys_sleep (1);\n\tr_sys_usleep (timeout);\n\n\tchar aport[32];\n\tsprintf (aport, \"%d\", port);\n\t// redirect stdin/stdout/stderr\n\tbool sock = r_socket_connect (s, \"127.0.0.1\", aport, R_SOCKET_PROTO_TCP, 2000);\n\tif (!sock) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tr_sys_sleep (4);\n\tr_sys_usleep (timeout);\n\n\tint status = 0;\n\tint ret = waitpid (childPid, &status, WNOHANG);\n\tif (ret != 0) {\n\t\tr_socket_close (s);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nR_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\tr_return_val_if_fail (s, false);\n#if __WINDOWS__\n#define gai_strerror gai_strerrorA\n\tstruct sockaddr_in sa;\n\tWSADATA wsadata;\n\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n#endif\n\tint ret;\n\tstruct addrinfo hints = { 0 };\n\tstruct addrinfo *res, *rp;\n\tif (!proto) {\n\t\tproto = R_SOCKET_PROTO_TCP;\n\t}\n#if __UNIX__\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\tif (proto == R_SOCKET_PROTO_UNIX) {\n#if __UNIX__\n\t\tif (!__connect_unix (s, host)) {\n\t\t\treturn false;\n\t\t}\n#endif\n\t} else {\n\t\thints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */\n\t\thints.ai_protocol = proto;\n\t\tint gai = getaddrinfo (host, port, &hints, &res);\n\t\tif (gai != 0) {\n\t\t\teprintf (\"r_socket_connect: Error in getaddrinfo: %s (%s:%s)\\n\",\n\t\t\t\tgai_strerror (gai), host, port);\n\t\t\treturn false;\n\t\t}\n\t\tfor (rp = res; rp != NULL; rp = rp->ai_next) {\n\t\t\tint flag = 1;\n\n\t\t\ts->fd = socket (rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n\t\t\tif (s->fd == -1) {\n\t\t\t\tperror (\"socket\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = setsockopt (s->fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof (flag));\n\t\t\tif (ret < 0) {\n\t\t\t\tperror (\"setsockopt\");\n\t\t\t\tclose (s->fd);\n\t\t\t\ts->fd = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tr_socket_block_time (s, 0, 0, 0);\n\t\t\tret = connect (s->fd, rp->ai_addr, rp->ai_addrlen);\n\n\t\t\tif (ret == 0) {\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (errno == EINPROGRESS) {\n\t\t\t\tstruct timeval tv = {timeout, 0};\n\t\t\t\tfd_set wfds;\n\t\t\t\tFD_ZERO (&wfds);\n\t\t\t\tFD_SET (s->fd, &wfds);\n\n\t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n\t\t\t\t\tif (r_socket_is_connected (s)) {\n\t\t\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t\t\tgoto success;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tperror (\"connect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t}\n\t\tfreeaddrinfo (res);\n\t\tif (!rp) {\n\t\t\teprintf (\"Could not resolve address '%s' or failed to connect\\n\", host);\n\t\t\treturn false;\n\t\t}\n\t}\nsuccess:\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_close (s);\n\t\t\treturn false;\n\t\t}\n\t\ts->sfd = SSL_new (s->ctx);\n\t\tSSL_set_fd (s->sfd, s->fd);\n\t\tint ret = SSL_connect (s->sfd);\n\t\tif (ret != 1) {\n\t\t\tint error = SSL_get_error (s->sfd, ret);\n\t\t\tint tries = 10;\n\t\t\twhile (tries && ret && (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\tstruct timeval tv = {1, 0};\n\t\t\t\tfd_set rfds, wfds;\n\t\t\t\tFD_ZERO (&rfds);\n\t\t\t\tFD_ZERO (&wfds);\n\t\t\t\tif (error == SSL_ERROR_WANT_READ) {\n\t\t\t\t\tFD_SET (s->fd, &rfds);\n\t\t\t\t} else {\n\t\t\t\t\tFD_SET (s->fd, &wfds);\n\t\t\t\t}\n\t\t\t\tif ((ret = select (s->fd + 1, &rfds, &wfds, NULL, &tv)) < 1) {\n\t\t\t\t\tr_socket_close (s);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tret = SSL_connect (s->sfd);\n\t\t\t\tif (ret == 1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\terror = SSL_get_error (s->sfd, ret);\n\t\t\t\ttries--;\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\treturn true;\n}\n\n/* close the file descriptor associated with the RSocket s */\nR_API int r_socket_close_fd(RSocket *s) {\n#ifdef _MSC_VER\n\treturn s->fd != INVALID_SOCKET ? closesocket (s->fd) : false;\n#else\n\treturn s->fd != -1 ? close (s->fd) : false;\n#endif\n}\n\n/* shutdown the socket and close the file descriptor */\nR_API int r_socket_close(RSocket *s) {\n\tint ret = false;\n\tif (!s) {\n\t\treturn false;\n\t}\n\tif (s->fd != R_INVALID_SOCKET) {\n#if __UNIX__\n\t\tshutdown (s->fd, SHUT_RDWR);\n#endif\n#if __WINDOWS__\n\t\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms740481(v=vs.85).aspx\n\t\tshutdown (s->fd, SD_SEND);\n\t\tif (r_socket_ready (s, 0, 250)) {\n\t\t\tdo {\n\t\t\t\tchar buf = 0;\n\t\t\t\tret = recv (s->fd, &buf, 1, 0);\n\t\t\t} while (ret != 0 && ret != SOCKET_ERROR);\n\t\t}\n\t\tret = closesocket (s->fd);\n#else\n\t\tret = close (s->fd);\n#endif\n\t\ts->fd = R_INVALID_SOCKET;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl && s->sfd) {\n\t\tSSL_free (s->sfd);\n\t\ts->sfd = NULL;\n\t}\n#endif\n\treturn ret;\n}\n\n/* shutdown the socket, close the file descriptor and free the RSocket */\nR_API int r_socket_free(RSocket *s) {\n\tint res = r_socket_close (s);\n#if HAVE_LIB_SSL\n\tif (s && s->is_ssl) {\n\t\tif (s->sfd) {\n\t\t\tSSL_free (s->sfd);\n\t\t}\n\t\tif (s->ctx) {\n\t\t\tSSL_CTX_free (s->ctx);\n\t\t}\n\t}\n#endif\n\tfree (s);\n\treturn res;\n}\n\nR_API int r_socket_port_by_name(const char *name) {\n\tstruct servent *p = getservbyname (name, \"tcp\");\n\treturn (p && p->s_port) ? ntohs (p->s_port) : r_num_get (NULL, name);\n}\n\nR_API bool r_socket_listen(RSocket *s, const char *port, const char *certfile) {\n\tint optval = 1;\n\tint ret;\n\tstruct linger linger = { 0 };\n\n\tif (s->proto == R_SOCKET_PROTO_UNIX) {\n#if __UNIX__\n\t\treturn __listen_unix (s, port);\n#endif\n\t\treturn false;\n\t}\n\n\tif (r_sandbox_enable (0)) {\n\t\treturn false;\n\t}\n#if __WINDOWS__\n\tWSADATA wsadata;\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n#endif\n\tif ((s->fd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) == R_INVALID_SOCKET) {\n\t\treturn false;\n\t}\n\n\tlinger.l_onoff = 1;\n\tlinger.l_linger = 1;\n\tret = setsockopt (s->fd, SOL_SOCKET, SO_LINGER, (void*)&linger, sizeof (linger));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n\t{ // fix close after write bug //\n\tint x = 1500; // FORCE MTU\n\tret = setsockopt (s->fd, SOL_SOCKET, SO_SNDBUF, (void*)&x, sizeof (int));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n\t}\n\tret = setsockopt (s->fd, SOL_SOCKET, SO_REUSEADDR, (void*)&optval, sizeof optval);\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n\n\tmemset (&s->sa, 0, sizeof (s->sa));\n\ts->sa.sin_family = AF_INET;\n\ts->sa.sin_addr.s_addr = htonl (s->local? INADDR_LOOPBACK: INADDR_ANY);\n\ts->port = r_socket_port_by_name (port);\n\tif (s->port < 1) {\n\t\treturn false;\n\t}\n\ts->sa.sin_port = htons (s->port); // TODO honor etc/services\n\tif (bind (s->fd, (struct sockaddr *)&s->sa, sizeof (s->sa)) < 0) {\n\t\tr_sys_perror (\"bind\");\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n#if __UNIX__\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\tif (listen (s->fd, 32) < 0) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\tif (!SSL_CTX_use_certificate_chain_file (s->ctx, certfile)) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\tif (!SSL_CTX_use_PrivateKey_file (s->ctx, certfile, SSL_FILETYPE_PEM)) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\tSSL_CTX_set_verify_depth (s->ctx, 1);\n\t}\n#endif\n\treturn true;\n}\n\nR_API RSocket *r_socket_accept(RSocket *s) {\n\tRSocket *sock;\n\tsocklen_t salen = sizeof (s->sa);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tsock = R_NEW0 (RSocket);\n\tif (!sock) {\n\t\treturn NULL;\n\t}\n\t//signal (SIGPIPE, SIG_DFL);\n\tsock->fd = accept (s->fd, (struct sockaddr *)&s->sa, &salen);\n\tif (sock->fd == R_INVALID_SOCKET) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\t// not just a timeout\n\t\t\tr_sys_perror (\"accept\");\n\t\t}\n\t\tfree (sock);\n\t\treturn NULL;\n\t}\n#if HAVE_LIB_SSL\n\tsock->is_ssl = s->is_ssl;\n\tif (sock->is_ssl) {\n\t\tsock->sfd = NULL;\n\t\tsock->ctx = NULL;\n\t\tsock->bio = NULL;\n\t\tBIO *sbio = BIO_new_socket (sock->fd, BIO_NOCLOSE);\n\t\tsock->sfd = SSL_new (s->ctx);\n\t\tSSL_set_bio (sock->sfd, sbio, sbio);\n\t\tif (SSL_accept (sock->sfd) <= 0) {\n\t\t\tr_socket_free (sock);\n\t\t\treturn NULL;\n\t\t}\n\t\tsock->bio = BIO_new (BIO_f_buffer ());\n\t\tsbio = BIO_new (BIO_f_ssl ());\n\t\tBIO_set_ssl (sbio, sock->sfd, BIO_CLOSE);\n\t\tBIO_push (sock->bio, sbio);\n\t}\n#else\n\tsock->is_ssl = 0;\n#endif\n\treturn sock;\n}\n\nR_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\tfd_set read_fds;\n\tfd_set except_fds;\n\n\tFD_ZERO (&read_fds);\n\tFD_SET (s->fd, &read_fds);\n\n\tFD_ZERO (&except_fds);\n\tFD_SET (s->fd, &except_fds);\n\n\tstruct timeval t = {timeout, 0};\n\n\tint r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);\n\tif(r < 0) {\n\t\tperror (\"select\");\n\t} else if (r > 0 && FD_ISSET (s->fd, &read_fds)) {\n\t\treturn r_socket_accept (s);\n\t}\n\n\treturn NULL;\n}\n\n// Only applies to read in UNIX\nR_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {sec, usec};\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_socket_flush(RSocket *s) {\n#if HAVE_LIB_SSL\n\tif (s->is_ssl && s->bio) {\n\t\treturn BIO_flush (s->bio);\n\t}\n#endif\n\treturn true;\n}\n\n/* waits secs until new data is received.\t  */\n/* returns -1 on error, 0 is false, 1 is true */\nR_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n\tfd_set rfds;\n\tstruct timeval tv = {secs, usecs};\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n}\n\nR_API char *r_socket_to_string(RSocket *s) {\n#if __WINDOWS__\n\treturn r_str_newf (\"fd%d\", (int)(size_t)s->fd);\n#elif __UNIX__\n\tchar *str = NULL;\n\tstruct sockaddr sa;\n\tsocklen_t sl = sizeof (sa);\n\tmemset (&sa, 0, sizeof (sa));\n\tif (!getpeername (s->fd, &sa, &sl)) {\n\t\tstruct sockaddr_in *sain = (struct sockaddr_in*) &sa;\n\t\tut8 *a = (ut8*) &(sain->sin_addr);\n\t\tif ((str = malloc (32))) {\n\t\t\tsprintf (str, \"%d.%d.%d.%d:%d\",\n\t\t\t\ta[0], a[1], a[2], a[3], ntohs (sain->sin_port));\n\t\t}\n\t} else {\n\t\teprintf (\"getperrname: failed\\n\"); //r_sys_perror (\"getpeername\");\n\t}\n\treturn str;\n#else\n\treturn NULL;\n#endif\n}\n\n/* Read/Write functions */\nR_API int r_socket_write(RSocket *s, void *buf, int len) {\n\tD { eprintf (\"WRITE \"); int i; ut8 *b = buf; for (i = 0; i<len; i++) { eprintf (\"%02x \", b[i]); } eprintf (\"\\n\"); }\n\tint ret, delta = 0;\n#if __UNIX__\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\tfor (;;) {\n\t\tint b = 1500; //65536; // Use MTU 1500?\n\t\tif (b > len) {\n\t\t\tb = len;\n\t\t}\n#if HAVE_LIB_SSL\n\t\tif (s->is_ssl) {\n\t\t\tif (s->bio) {\n\t\t\t\tret = BIO_write (s->bio, buf+delta, b);\n\t\t\t} else {\n\t\t\t\tret = SSL_write (s->sfd, buf + delta, b);\n\t\t\t}\n\t\t} else\n#endif\n\t\t{\n\t\t\tret = send (s->fd, (char *)buf+delta, b, 0);\n\t\t}\n\t\t//if (ret == 0) return -1;\n\t\tif (ret < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == len) {\n\t\t\treturn len;\n\t\t}\n\t\tdelta += ret;\n\t\tlen -= ret;\n\t}\n\treturn (ret == -1)? -1 : delta;\n}\n\nR_API int r_socket_puts(RSocket *s, char *buf) {\n\treturn r_socket_write (s, buf, strlen (buf));\n}\n\nR_API void r_socket_printf(RSocket *s, const char *fmt, ...) {\n\tchar buf[BUFFER_SIZE];\n\tva_list ap;\n\tif (s->fd != R_INVALID_SOCKET) {\n\t\tva_start (ap, fmt);\n\t\tvsnprintf (buf, BUFFER_SIZE, fmt, ap);\n\t\tr_socket_write (s, buf, strlen (buf));\n\t\tva_end (ap);\n\t}\n}\n\nR_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\tif (!s) {\n\t\treturn -1;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\tif (s->bio) {\n\t\t\treturn BIO_read (s->bio, buf, len);\n\t\t}\n\t\treturn SSL_read (s->sfd, buf, len);\n\t}\n#endif\n\t// int r = read (s->fd, buf, len);\n\tint r = recv (s->fd, buf, len, 0);\n\tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n\treturn r;\n}\n\nR_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {\n\tint ret = 0;\n\tfor (ret = 0; ret < len; ) {\n\t\tint r = r_socket_read (s, buf + ret, len - ret);\n\t\tif (r == -1) {\n#if HAVE_LIB_SSL\n\t\t\tif (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {\n\t\t\t\tif (r_socket_ready (s, 1, 0) == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tif (r < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tret += r;\n\t}\n\treturn ret;\n}\n\nR_API int r_socket_gets(RSocket *s, char *buf,\tint size) {\n\tint i = 0;\n\tint ret = 0;\n\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\twhile (i < size) {\n\t\tret = r_socket_read (s, (ut8 *)buf + i, 1);\n\t\tif (ret == 0) {\n\t\t\tif (i > 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tr_socket_close (s);\n\t\t\treturn i == 0? -1: i;\n\t\t}\n\t\tif (buf[i] == '\\r' || buf[i] == '\\n') {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t\ti += ret;\n\t}\n\tbuf[i] = '\\0';\n\treturn i;\n}\n\nR_API RSocket *r_socket_new_from_fd(int fd) {\n\tRSocket *s = R_NEW0 (RSocket);\n\tif (s) {\n\t\ts->fd = fd;\n\t}\n\treturn s;\n}\n\nR_API ut8* r_socket_slurp(RSocket *s, int *len) {\n\tint blockSize = 4096;\n\tut8 *ptr, *buf = malloc (blockSize);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tint copied = 0;\n\tif (len) {\n\t\t*len = 0;\n\t}\n\tfor (;;) {\n\t\tint rc = r_socket_read (s, buf + copied, blockSize);\n\t\tif (rc > 0) {\n\t\t\tcopied += rc;\n\t\t}\n\t\tptr = realloc (buf, copied + blockSize);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf = ptr;\n\t\tif (rc < 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (copied == 0) {\n\t\tR_FREE (buf);\n\t}\n\tif (len) {\n\t\t*len = copied;\n\t}\n\treturn buf;\n}\n\n#endif // EMSCRIPTEN\n", "/* radare - LGPL - Copyright 2011-2020 - pancake */\n\n#include <r_socket.h>\n#include <r_util.h>\n\n#if __WINDOWS__\n#include <WinInet.h>\n#endif\n\n#define SOCKET_HTTP_MAX_HEADER_LENGTH 0x2000\n#define SOCKET_HTTP_MAX_REDIRECTS 5\n\nstatic size_t socket_slurp(RSocket *s, RBuffer *buf) {\n\tsize_t i;\n\tif (r_socket_ready (s, 1, 0) != 1) {\n\t\treturn 0;\n\t}\n\tr_socket_block_time (s, 1, 0, 1000);\n\tfor (i = 0; i < SOCKET_HTTP_MAX_HEADER_LENGTH; i += 1) {\n\t\tut8 c;\n\t\tint olen = r_socket_read_block (s, &c, 1);\n\t\tif (olen != 1) {\n\t\t\tr_buf_append_bytes (buf, (ut8 *)\"\", 1);\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_append_bytes (buf, &c, 1);\n\t}\n\treturn i;\n}\n\nstatic char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections);\n\nstatic char *socket_http_answer(RSocket *s, int *code, int *rlen, ut32 redirections) {\n\tr_return_val_if_fail (s, NULL);\n\tconst char *p;\n\tint ret, len = 0, delta = 0;\n\tchar *dn;\n\tRBuffer *b = r_buf_new ();\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tchar *res = NULL;\n\tsize_t olen = socket_slurp (s, b);\n\tchar *buf = malloc (olen + 1);\n\tif (!buf) {\n\t\tgoto exit;\n\t}\n\tr_buf_read_at (b, 0, (ut8 *)buf, olen);\n\tbuf[olen] = 0;\n\tif ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {\n\t\tdelta += 2;\n\t} else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {\n\t\tdelta += 4;\n\t} else {\n\t\tgoto exit;\n\t}\n\n\tolen -= delta;\n\t*dn = 0; // chop headers\n\n\t/* Follow redirects */\n\tp = r_str_casestr (buf, \"Location:\");\n\tif (p) {\n\t\tif (!redirections) {\n\t\t\teprintf (\"Too many redirects\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tp += strlen (\"Location:\");\n\t\tchar *end_url = strchr (p, '\\n');\n\t\tif (end_url) {\n\t\t\tint url_len = end_url - p;\n\t\t\tchar *url = r_str_ndup (p, url_len);\n\t\t\tr_str_trim (url);\n\t\t\tres = socket_http_get_recursive (url, code, rlen, --redirections);\n\t\t\tfree (url);\n\t\t\tlen = *rlen;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\t/* Parse Len */\n\tp = r_str_casestr (buf, \"Content-Length: \");\n\tif (p) {\n\t\tlen = atoi (p + 16);\n\t} else {\n\t\tlen = olen - (dn - buf);\n\t}\n\tif (len > 0) {\n\t\tif (len > olen) {\n\t\t\tres = malloc (len + 2);\n\t\t\tif (!res) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tolen -= dn - buf;\n\t\t\tmemcpy (res, dn + delta, olen);\n\t\t\tdo {\n\t\t\t\tret = r_socket_read_block (s, (ut8*) res + olen, len - olen);\n\t\t\t\tif (ret < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tolen += ret;\n\t\t\t} while (olen < len);\n\t\t\tres[len] = 0;\n\t\t} else {\n\t\t\tres = malloc (len + 1);\n\t\t\tif (res) {\n\t\t\t\tmemcpy (res, dn + delta, len);\n\t\t\t\tres[len] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = NULL;\n\t}\nexit:\n\tfree (buf);\n\tr_buf_free (b);\n\tr_socket_close (s);\n\tif (rlen) {\n\t\t*rlen = len;\n\t}\n\treturn res;\n}\n\n#if __WINDOWS__\nstatic char *http_get_w32(const char *url, int *code, int *rlen) {\n\tHINTERNET hInternet = InternetOpenA (\"radare2 \"R2_VERSION, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\n\tif (!hInternet) {\n\t\tr_sys_perror (\"InternetOpenA\");\n\t\treturn NULL;\n\t}\n\tHINTERNET hOpenUrl = InternetOpenUrlA (hInternet, url, NULL, 0, 0, 0);\n\tif (!hOpenUrl) {\n\t\tr_sys_perror (\"InternetOpenUrlA\");\n\t\tInternetCloseHandle (hInternet);\n\t\treturn NULL;\n\t}\n\n\tchar *ret = NULL;\n\tsize_t read_sz = 0x100000;\n\tDWORD r = 0, w = 0;\n\tbool res = true;\n\tdo {\n\t\tw += r;\n\t\tif (!res && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tread_sz *= 2;\n\t\t}\n\t\tchar *tmp = realloc (ret, read_sz + w);\n\t\tif (!tmp) {\n\t\t\tR_FREE (ret);\n\t\t\tgoto exit;\n\t\t}\n\t\tret = tmp;\n\t} while (!(res = InternetReadFile (hOpenUrl, ret + w, read_sz, &r)) || r);\n\n\tif (w) {\n\t\tchar *tmp = realloc (ret, (size_t)w + 1);\n\t\tif (tmp) {\n\t\t\tret = tmp;\n\t\t\tret[w] = 0;\n\t\t} else {\n\t\t\tR_FREE (ret);\n\t\t}\n\t} else {\n\t\tR_FREE (ret);\n\t}\n\nexit:\n\tif (rlen) {\n\t\t*rlen = w;\n\t}\n\tif (code && w) {\n\t\t*code = 200;\n\t}\n\tInternetCloseHandle (hInternet);\n\tInternetCloseHandle (hOpenUrl);\n\treturn ret;\n}\n#endif\n\nstatic char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections) {\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (!R_STR_ISEMPTY (curl_env) && atoi (curl_env)) {\n\t\tint len;\n\t\tchar *escaped_url = r_str_escape_sh (url);\n\t\tchar *command = r_str_newf (\"curl -sfL -o - \\\"%s\\\"\", escaped_url);\n\t\tchar *res = r_sys_cmd_str (command, NULL, &len);\n\t\tfree (escaped_url);\n\t\tfree (command);\n\t\tfree (curl_env);\n\t\tif (!res) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = len;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tfree (curl_env);\n#if __WINDOWS__\n\treturn http_get_w32 (url, code, rlen);\n#else\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https://\");\n#if !HAVE_LIB_SSL\n\tif (ssl) {\n\t\teprintf (\"Tried to get '%s', but SSL support is disabled, set R2_CURL=1 to use curl\\n\", url);\n\t\treturn NULL;\n\t}\n#endif\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\thost = strstr (uri, \"://\");\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: */*\\r\\n\"\n\t\t\t\t\"Host: %s:%s\\r\\n\"\n\t\t\t\t\"\\r\\n\", path, host, port);\n\t\tresponse = socket_http_answer (s, code, rlen, redirections);\n\t} else {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tresponse = NULL;\n\t}\n\tfree (uri);\n\tr_socket_free (s);\n\treturn response;\n#endif\n}\n\nR_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n\treturn socket_http_get_recursive (url, code, rlen, SOCKET_HTTP_MAX_REDIRECTS);\n}\n\nR_API char *r_socket_http_post(const char *url, const char *data, int *code, int *rlen) {\n\tRSocket *s;\n\tbool ssl = r_str_startswith (url, \"https://\");\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\n\tchar *host = strstr (uri, \"://\");\n\tif (!host) {\n\t\tfree (uri);\n\t\tprintf (\"Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tchar *port = strchr (host, ':');\n\tif (!port) {\n\t\tport = (ssl)? \"443\": \"80\";\n\t} else {\n\t\t*port++ = 0;\n\t}\n\tchar *path = strchr (host, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\tprintf (\"Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (!r_socket_connect_tcp (s, host, port, 0)) {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\t/* Send */\n\tr_socket_printf (s,\n\t\t\t\"POST /%s HTTP/1.0\\r\\n\"\n\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\"Accept: */*\\r\\n\"\n\t\t\t\"Host: %s\\r\\n\"\n\t\t\t\"Content-Length: %i\\r\\n\"\n\t\t\t\"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n\t\t\t\"\\r\\n\", path, host, (int)strlen (data));\n\tfree (uri);\n\tr_socket_write (s, (void *)data, strlen (data));\n\treturn socket_http_answer (s, code, rlen, 0);\n}\n\n#if TEST\nvoid main () {\n\tint ret;\n\tchar *p = r_socket_http_post (\"http://www.radare.org/y/index.php\", \"a=b\", &ret);\n\tprintf (\"%s\\n\", p);\n}\n#endif\n", "/* radare - LGPL - Copyright 2007-2019 - pancake */\n\n#include \"r_types.h\"\n#include \"r_util.h\"\n#include \"r_cons.h\"\n#include \"r_bin.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdarg.h>\n\n/* stable code */\nstatic const char *nullstr = \"\";\nstatic const char *nullstr_c = \"(null)\";\nstatic const char *rwxstr[] = {\n\t[0] = \"---\",\n\t[1] = \"--x\",\n\t[2] = \"-w-\",\n\t[3] = \"-wx\",\n\t[4] = \"r--\",\n\t[5] = \"r-x\",\n\t[6] = \"rw-\",\n\t[7] = \"rwx\",\n\n\t[8] = \"---\",\n\t[9] = \"--x\",\n\t[10] = \"-w-\",\n\t[11] = \"-wx\",\n\t[12] = \"r--\",\n\t[13] = \"r-x\",\n\t[14] = \"rw-\",\n\t[15] = \"rwx\",\n};\n\nR_API int r_str_casecmp(const char *s1, const char *s2) {\n#ifdef _MSC_VER\n\treturn stricmp (s1, s2);\n#else\n\treturn strcasecmp (s1, s2);\n#endif\n}\n\nR_API int r_str_ncasecmp(const char *s1, const char *s2, size_t n) {\n#ifdef _MSC_VER\n\treturn _strnicmp (s1, s2, n);\n#else\n\treturn strncasecmp (s1, s2, n);\n#endif\n}\n\n// GOOD\n// In-place replace the first instance of the character a, with the character b.\nR_API int r_str_replace_ch(char *s, char a, char b, bool global) {\n\tint ret = 0;\n\tchar *o = s;\n\tif (!s || a == b) {\n\t\treturn 0;\n\t}\n\tfor (; *o; s++, o++) {\n\t\tif (*o == a) {\n\t\t\tret++;\n\t\t\tif (b) {\n\t\t\t\t*s = b;\n\t\t\t} else {\n\t\t\t\t/* remove char */\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tif (!global) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\t*s = *o;\n\t\t}\n\t}\n\t*s = 0;\n\treturn ret;\n}\n\nR_API int r_str_replace_char_once(char *s, int a, int b) {\n\treturn r_str_replace_ch (s, a, b, false);\n}\n\nR_API int r_str_replace_char(char *s, int a, int b) {\n\treturn r_str_replace_ch (s, a, b, true);\n}\n\nR_API void r_str_remove_char(char *str, char c) {\n\twhile (*str) {\n\t\tif (*str == c) {\n\t\t\tmemmove (str, str + 1, strlen (str + 1) + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tstr++;\n\t}\n}\n\nR_API void r_str_reverse(char *str) {\n\tint i, len = strlen (str);\n\tint half = len / 2;\n\tfor (i = 0; i < half; i++) {\n\t\tchar ch = str[i];\n\t\tstr[i] = str[len - i - 1];\n\t\tstr[len - i - 1] = ch;\n\t}\n}\n\n// TODO: do not use toupper.. must support modes to also append lowercase chars like in r1\n// TODO: this functions needs some stabilization\nR_API int r_str_bits(char *strout, const ut8 *buf, int len, const char *bitz) {\n\tint i, j, idx;\n\tif (bitz) {\n\t\tfor (i = j = 0; i<len && (!bitz||bitz[i]); i++) {\n\t\t\tif (i > 0 && (i % 8) == 0) {\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t\tif (*buf & (1 << (i % 8))) {\n\t\t\t\tstrout[j++] = toupper ((const ut8)bitz[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = j = 0; i < len; i++) {\n\t\t\tidx = (i / 8);\n\t\t\tint bit = 7 - (i % 8);\n\t\t\tstrout[j++] = (buf[idx] & (1 << bit))? '1' : '0';\n\t\t}\n\t}\n\tstrout[j] = 0;\n\treturn j;\n}\n\nR_API const char *r_str_sysbits(const int v) {\n\tswitch (v) {\n\tcase R_SYS_BITS_8: return \"8\";\n\tcase R_SYS_BITS_16: return \"16\";\n\tcase R_SYS_BITS_32: return \"32\";\n\tcase R_SYS_BITS_64: return \"64\";\n\tcase R_SYS_BITS_16 | R_SYS_BITS_32: return \"16,32\";\n\tcase R_SYS_BITS_16 | R_SYS_BITS_32 | R_SYS_BITS_64: return \"16,32,64\";\n\tcase R_SYS_BITS_32 | R_SYS_BITS_64: return \"32,64\";\n\t}\n\treturn \"?\";\n}\n\n// In-place trims a bitstring to groups of 8 bits.\n// For example, the bitstring 1000000000000000 will not be modified, but the\n// bitstring 0000000001000000 will be changed to 01000000.\nstatic void trimbits(char *b) {\n\tconst int len = strlen (b);\n\tchar *one = strchr (b, '1');\n\tint pos = one ? (int)(size_t)(one - b) : len - 1;\n\tpos = (pos / 8) * 8;\n\tmemmove (b, b + pos, len - pos + 1);\n}\n\n// Set 'strout' to the binary representation of the input value.\n// strout must be a char array of 65 or greater.\n// The string is then trimmed using the \"trimbits\" function above.\nR_API int r_str_bits64(char* strout, ut64 in) {\n\tint i, bit, count = 0;\n\tcount = 0;\n\tfor (i = (sizeof (in) * 8) - 1; i >= 0; i--) {\n\t\tbit = in >> i;\n\t\tif (bit & 1) {\n\t\t\tstrout[count] = '1';\n\t\t} else {\n\t\t\tstrout[count] = '0';\n\t\t}\n\t\tcount++;\n\t}\n\tstrout[count] = '\\0';\n\t/* trim by 8 bits */\n\ttrimbits (strout);\n\treturn count;\n}\n\n/**\n * function: r_str_bits_from_num\n *\n */\nR_API ut64 r_str_bits_from_string(const char *buf, const char *bitz) {\n\tut64 out = 0LL;\n\t/* return the numeric value associated to a string (rflags) */\n\tfor (; *buf; buf++) {\n\t\tchar *ch = strchr (bitz, toupper ((const unsigned char)*buf));\n\t\tif (!ch) {\n\t\t\tch = strchr (bitz, tolower ((const unsigned char)*buf));\n\t\t}\n\t\tif (ch) {\n\t\t\tint bit = (int)(size_t)(ch - bitz);\n\t\t\tout |= (ut64)(1LL << bit);\n\t\t} else {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t}\n\treturn out;\n}\n\nR_API int r_str_binstr2bin(const char *str, ut8 *out, int outlen) {\n\tint n, i, j, k, ret, len;\n\tlen = strlen (str);\n\tfor (n = i = 0; i < len; i += 8) {\n\t\tret = 0;\n\t\twhile (str[i]==' ') {\n\t\t\tstr++;\n\t\t}\n\t\tif (i + 7 < len) {\n\t\t\tfor (k = 0, j = i + 7; j >= i; j--, k++) {\n\t\t\t\t// INVERSE for (k=0,j=i; j<i+8; j++,k++) {\n\t\t\t\tif (str[j] == ' ') {\n\t\t\t\t\t//k--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//\t\tprintf (\"---> j=%d (%c) (%02x)\\n\", j, str[j], str[j]);\n\t\t\t\tif (str[j] == '1') {\n\t\t\t\t\tret|=1 << k;\n\t\t\t\t} else if (str[j] != '0') {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tprintf (\"-======> %02x\\n\", ret);\n\t\tout[n++] = ret;\n\t\tif (n == outlen) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn n;\n}\n\n// Returns the permissions as in integer given an input in the form of rwx, rx,\n// etc.\nR_API int r_str_rwx(const char *str) {\n\tint ret = atoi (str);\n\tif (!ret) {\n\t\tret |= strchr (str, 'm') ? 16 : 0;\n\t\tret |= strchr (str, 'r') ? 4 : 0;\n\t\tret |= strchr (str, 'w') ? 2 : 0;\n\t\tret |= strchr (str, 'x') ? 1 : 0;\n\t} else if (ret < 0 || ret >= R_ARRAY_SIZE (rwxstr)) {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n// Returns the string representation of the permission of the inputted integer.\nR_API const char *r_str_rwx_i(int rwx) {\n\tif (rwx < 0 || rwx >= R_ARRAY_SIZE (rwxstr)) {\n\t\trwx = 0;\n\t}\n\treturn rwxstr[rwx % 24]; // 15 for srwx\n}\n\n// If up is true, upcase all characters in the string, otherwise downcase all\n// characters in the string.\nR_API void r_str_case(char *str, bool up) {\n\tif (up) {\n\t\tchar oc = 0;\n\t\tfor (; *str; oc = *str++) {\n\t\t\t*str = (*str=='x' && oc=='0') ? 'x': toupper ((int)(ut8)*str);\n\t\t}\n\t} else {\n\t\tfor (; *str; str++) {\n\t\t\t*str = tolower ((int)(ut8)*str);\n\t\t}\n\t}\n}\n\nR_API char *r_str_home(const char *str) {\n\tchar *dst, *home = r_sys_getenv (R_SYS_HOME);\n\tsize_t length;\n\tif (!home) {\n\t\thome = r_file_tmpdir ();\n\t\tif (!home) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tlength = strlen (home) + 1;\n\tif (str) {\n\t\tlength += strlen (R_SYS_DIR) + strlen (str);\n\t}\n\tdst = (char *)malloc (length);\n\tif (!dst) {\n\t\tgoto fail;\n\t}\n\tint home_len = strlen (home);\n\tmemcpy (dst, home, home_len + 1);\n\tif (str) {\n\t\tdst[home_len] = R_SYS_DIR[0];\n\t\tstrcpy (dst + home_len + 1, str);\n\t}\nfail:\n\tfree (home);\n\treturn dst;\n}\n\nR_API char *r_str_r2_prefix(const char *str) {\n\treturn r_str_newf (\"%s%s%s\", r_sys_prefix (NULL), R_SYS_DIR, str);\n}\n\n// Compute a 64 bit DJB hash of a string.\nR_API ut64 r_str_hash64(const char *s) {\n\tut64 len, h = 5381;\n\tif (!s) {\n\t\treturn 0;\n\t}\n\tfor (len = strlen (s); len > 0; len--) {\n\t\th = (h ^ (h << 5)) ^ *s++;\n\t}\n\treturn h;\n}\n\n// Compute a 32bit DJB hash of a string.\nR_API ut32 r_str_hash(const char *s) {\n\treturn (ut32) r_str_hash64 (s);\n}\n\nR_API int r_str_delta(char *p, char a, char b) {\n\tchar *_a = strchr (p, a);\n\tchar *_b = strchr (p, b);\n\treturn (!_a || !_b)? 0 : (_a - _b);\n}\n\n// In-place split string using ch as a delimiter. Replaces all instances of ch\n// with a null byte. Returns the number of split strings. For example\n// r_str_split(\"hello world\", ' ') will replace the space with '\\0' and\n// return 2.\nR_API int r_str_split(char *str, char ch) {\n\tint i;\n\tchar *p;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\t/* TODO: sync with r1 code */\n\tfor (i = 1, p = str; *p; p++) {\n\t\tif (*p == ch) {\n\t\t\ti++;\n\t\t\t*p = '\\0';\n\t\t} // s/ /\\0/g\n\t}\n\treturn i;\n}\n\n// Convert a string into an array of string separated by \\0\n// And the last by \\0\\0\n// Separates by words and skip spaces.\n// Returns the number of tokens that the string is tokenized into.\nR_API int r_str_word_set0(char *str) {\n\tint i, quote = 0;\n\tchar *p;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; str[i] && str[i + 1]; i++) {\n\t\tif (i > 0 && str[i-1] == ' ' && str[i] == ' ') {\n\t\t\tint len = strlen (str + i);\n\t\t\tmemmove (str + i, str + i + 1, len);\n\t\t\ti--;\n\t\t}\n\t}\n\tif (str[i] == ' ') {\n\t\tstr[i] = 0;\n\t}\n\tfor (i = 1, p = str; *p; p++) {\n\t\tif (*p == '\\\"') {\n\t\t\tif (quote) {\n\t\t\t\tquote = 0;\n\t\t\t\t*p = '\\0';\n\t\t\t\t// FIX: i++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tquote = 1;\n\t\t\t\tmemmove (p, p + 1, strlen (p + 1) + 1);\n\t\t\t}\n\t\t}\n\t\tif (quote) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ' ') {\n\t\t\tchar *q = p - 1;\n\t\t\tif (p > str && (*q == '\\\\' || !*q)) {\n\t\t\t\tmemmove (p, p + 1, strlen (p + 1) + 1);\n\t\t\t\tif (*q == '\\\\') {\n\t\t\t\t\t*q = ' ';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp--;\n\t\t\t}\n\t\t\ti++;\n\t\t\t*p = '\\0';\n\t\t} // s/ /\\0/g\n\t}\n\treturn i;\n}\n\nR_API int r_str_word_set0_stack(char *str) {\n\tint i;\n\tchar *p, *q;\n\tRStack *s;\n\tvoid *pop;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; str[i] && str[i+1]; i++) {\n\t\tif (i > 0 && str[i - 1] == ' ' && str[i] == ' ') {\n\t\t\tmemmove (str + i, str + i + 1, strlen (str + i));\n\t\t\ti--;\n\t\t}\n\t\tif (i == 0 && str[i] == ' ') {\n\t\t\tmemmove (str + i, str + i + 1, strlen (str + i));\n\t\t}\n\t}\n\tif (str[i] == ' ') {\n\t\tstr[i] = 0;\n\t}\n\ts = r_stack_new (5); //Some random number\n\tfor (i = 1, p = str; *p; p++) {\n\t\tq = p - 1;\n\t\tif (p > str && (*q == '\\\\')) {\n\t\t\tmemmove (q, p, strlen (p) + 1);\n\t\t\tp--;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (*p) {\n\t\tcase '(':\n\t\tcase '{':\n\t\tcase '[':\n\t\t\tr_stack_push (s, (void *)p);\n\t\t\tcontinue;\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tpop = r_stack_pop (s);\n\t\t\tif (pop && *(char *)pop != *p) {\n\t\t\t\tr_stack_push (s, pop);\n\t\t\t\tr_stack_push (s, (void *)p);\n\t\t\t} else if (!pop) {\n\t\t\t\tr_stack_push (s, (void *)p);\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase ')':\n\t\tcase '}':\n\t\tcase ']':\n\t\t\tpop = r_stack_pop (s);\n\t\t\tif (pop) {\n\t\t\t\tif ((*(char *)pop == '(' && *p == ')') ||\n\t\t\t\t\t(*(char *)pop == '{' && *p == '}') ||\n\t\t\t\t\t(*(char *)pop == '[' && *p == ']')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tif (p > str && !*q) {\n\t\t\t\tmemmove (p, p+1, strlen (p + 1) + 1);\n\t\t\t\tif (*q == '\\\\') {\n\t\t\t\t\t*q = ' ';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tif (r_stack_is_empty (s)) {\n\t\t\t\ti++;\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_stack_free (s);\n\treturn i;\n}\n\nR_API char *r_str_word_get0set(char *stra, int stralen, int idx, const char *newstr, int *newlen) {\n\tchar *p = NULL;\n\tchar *out;\n\tint alen, blen, nlen;\n\tif (!stra && !newstr) {\n\t\treturn NULL;\n\t}\n\tif (stra) {\n\t\tp = (char *)r_str_word_get0 (stra, idx);\n\t}\n\tif (!p) {\n\t\tint nslen = strlen (newstr);\n\t\tout = malloc (nslen + 1);\n\t\tif (!out) {\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy (out, newstr);\n\t\tout[nslen] = 0;\n\t\tif (newlen) {\n\t\t\t*newlen = nslen;\n\t\t}\n\t\treturn out;\n\t}\n\talen = (size_t)(p - stra);\n\tblen = stralen - ((alen + strlen (p)) + 1);\n\tif (blen < 0) {\n\t\tblen = 0;\n\t}\n\tnlen = alen + blen + strlen (newstr);\n\tout = malloc (nlen + 2);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\tif (alen > 0) {\n\t\tmemcpy (out, stra, alen);\n\t}\n\tmemcpy (out + alen, newstr, strlen (newstr) + 1);\n\tif (blen > 0) {\n\t\tmemcpy (out + alen + strlen (newstr) + 1, p + strlen (p) + 1, blen + 1);\n\t}\n\tout[nlen + 1] = 0;\n\tif (newlen) {\n\t\t*newlen = nlen + ((blen == 0)? 1 : 0);\n\t}\n\treturn out;\n}\n\n// Get the idx'th entry of a tokenized string.\n// XXX: Warning! this function is UNSAFE, check that the string has, at least,\n// idx+1 tokens.\nR_API const char *r_str_word_get0(const char *str, int idx) {\n\tint i;\n\tconst char *ptr = str;\n\tif (!ptr || idx < 0 /* prevent crashes with negative index */) {\n\t\treturn (char *)nullstr;\n\t}\n\tfor (i = 0; i != idx; i++) {\n\t\tptr += strlen (ptr) + 1;\n\t}\n\treturn ptr;\n}\n\n// Return the number of times that the character ch appears in the string.\nR_API int r_str_char_count(const char *string, char ch) {\n\tint i, count = 0;\n\tfor (i = 0; string[i]; i++) {\n\t\tif (string[i] == ch) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n// Counts the number of words (separated by separator characters: newlines, tabs,\n// return, space). See r_util.h for more details of the IS_SEPARATOR macro.\nR_API int r_str_word_count(const char *string) {\n\tconst char *text, *tmp;\n\tint word;\n\n\tfor (text = tmp = string; *text && IS_SEPARATOR (*text); text++) {\n\t\t;\n\t}\n\tfor (word = 0; *text; word++) {\n\t\tfor (; *text && !IS_SEPARATOR (*text); text++) {\n\t\t\t;\n\t\t}\n\t\tfor (tmp = text; *text && IS_SEPARATOR (*text); text++) {\n\t\t\t;\n\t\t}\n\t}\n\treturn word;\n}\n\n// Returns a pointer to the first instance of a character that isn't chr in a\n// string.\n// TODO: make this const-correct.\n// XXX if the string is only made up of chr, then the pointer will just point to\n// a null byte!\nR_API char *r_str_ichr(char *str, char chr) {\n\twhile (*str == chr) {\n\t\tstr++;\n\t}\n\treturn str;\n}\n\n// Returns a pointer to the last instance of the character chr in the input\n// string.\nR_API const char *r_str_lchr(const char *str, char chr) {\n\tif (str) {\n\t\tint len = strlen (str);\n\t\tfor (; len >= 0; len--) {\n\t\t\tif (str[len] == chr) {\n\t\t\t\treturn str + len;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* find the last char chr in the substring str[start:end] with end not included */\nR_API const char *r_sub_str_lchr(const char *str, int start, int end, char chr) {\n\tdo {\n\t\tend--;\n\t} while (str[end] != chr && end >= start);\n\treturn str[end] == chr ? &str[end] : NULL;\n}\n\n/* find the first char chr in the substring str[start:end] with end not included */\nR_API const char *r_sub_str_rchr(const char *str, int start, int end, char chr) {\n\twhile (str[start] != chr && start < end) {\n\t\tstart++;\n\t}\n\treturn str[start] == chr ? str + start : NULL;\n}\n\nR_API const char *r_str_sep(const char *base, const char *sep) {\n\tint i;\n\twhile (*base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*base == sep[i]) {\n\t\t\t\treturn base;\n\t\t\t}\n\t\t}\n\t\tbase++;\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_rsep(const char *base, const char *p, const char *sep) {\n\tint i;\n\twhile (p >= base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*p == sep[i]) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\tp--;\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_rstr(const char *base, const char *p) {\n\tchar *s = strdup (base);\n\tchar *k = strdup (p);\n\tr_str_reverse (s);\n\tr_str_reverse (k);\n\tchar *q = strstr (s, k);\n\tconst char *r = NULL;\n\tif (q) {\n\t\tr = base + strlen (base) - (q - s) - strlen (p);\n\t}\n\tfree (s);\n\tfree (k);\n\treturn r;\n}\n\nR_API const char *r_str_rchr(const char *base, const char *p, int ch) {\n\tr_return_val_if_fail (base, NULL);\n\tif (!p) {\n\t\tp = base + strlen (base);\n\t}\n\tfor (; p >= base; p--) {\n\t\tif (ch == *p) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (p >= base) ? p: NULL;\n}\n\nR_API const char *r_str_nstr(const char *s, const char *find, int slen) {\n\tchar c, sc;\n\tsize_t len;\n\n\tif ((c = *find++) != '\\0') {\n\t\tlen = strlen (find);\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tif (slen-- < 1 || !(sc = *s++)) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} while (sc != c);\n\t\t\tif (len > slen) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} while (strncmp (s, find, len) != 0);\n\t\ts--;\n\t}\n\treturn (char *)s;\n}\n\n// Returns a new heap-allocated copy of str.\n// XXX what's the diff with r_str_dup ?\nR_API char *r_str_new(const char *str) {\n\treturn str? strdup (str): NULL;\n}\n\n// Returns a new heap-allocated copy of str, sets str[len] to '\\0'.\n// If the input str is longer than len, it will be truncated.\nR_API char *r_str_newlen(const char *str, int len) {\n\tif (len < 1) {\n\t\treturn NULL;\n\t}\n\tchar *buf = malloc (len + 1);\n\tif (buf) {\n\t\tmemcpy (buf, str, len);\n\t\tbuf[len] = 0;\n\t}\n\treturn buf;\n}\n\nR_API char *r_str_trunc_ellipsis(const char *str, int len) {\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tif (strlen (str) < len) {\n\t\treturn strdup (str);\n\t}\n\tchar *buf = r_str_newlen (str, len);\n\tif (buf && len > 4) {\n\t\tstrcpy (buf + len - 4, \"...\");\n\t}\n\treturn buf;\n}\n\nR_API char *r_str_newf(const char *fmt, ...) {\n\tva_list ap, ap2;\n\n\tva_start (ap, fmt);\n\tif (!strchr (fmt, '%')) {\n\t\tva_end (ap);\n\t\treturn strdup (fmt);\n\t}\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t}\n\tva_end (ap2);\n\tva_end (ap);\n\treturn p;\n}\n\n// Secure string copy with null terminator (like strlcpy or strscpy but ours\nR_API void r_str_ncpy(char *dst, const char *src, size_t n) {\n\tint i;\n\n\t// do not do anything if n is 0\n\tif (n == 0) {\n\t\treturn;\n\t}\n\n\tn--;\n\tfor (i = 0; src[i] && n > 0; i++, n--) {\n\t\tdst[i] = src[i];\n\t}\n\tdst[i] = 0;\n}\n\n/* memccmp(\"foo.bar\", \"foo.cow, '.') == 0 */\n// Returns 1 if src and dst are equal up until the first instance of ch in src.\nR_API bool r_str_ccmp(const char *dst, const char *src, int ch) {\n\tint i;\n\tfor (i = 0; src[i] && src[i] != ch; i++) {\n\t\tif (dst[i] != src[i]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// Returns true if item is in sep-separated list\nR_API bool r_str_cmp_list(const char *list, const char *item, char sep) {\n\tif (!list || !item) {\n\t\treturn false;\n\t}\n\tint i = 0, j = 0;\n\tfor (; list[i] && list[i] != sep; i++, j++) {\n\t\tif (item[j] != list[i]) {\n\t\t\twhile (list[i] && list[i] != sep) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (!list[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tj = -1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn true;\n}\n\n// like strncmp, but checking for null pointers\nR_API int r_str_cmp(const char *a, const char *b, int len) {\n\tif ((a == b) || (!a && !b)) {\n\t\treturn 0;\n\t}\n\tif (!a && b) {\n\t\treturn -1;\n\t}\n\tif (a && !b) {\n\t\treturn 1;\n\t}\n\tif (len < 0) {\n\t\treturn strcmp (a, b);\n\t}\n\treturn strncmp (a, b, len);\n}\n\n// Copies all characters from src to dst up until the character 'ch'.\nR_API int r_str_ccpy(char *dst, char *src, int ch) {\n\tint i;\n\tfor (i = 0; src[i] && src[i] != ch; i++) {\n\t\tdst[i] = src[i];\n\t}\n\tdst[i] = '\\0';\n\treturn i;\n}\n\nR_API char *r_str_word_get_first(const char *text) {\n\tfor (; *text && IS_SEPARATOR (*text); text++) {\n\t\t;\n\t}\n\treturn strdup (text);\n}\n\nR_API const char *r_str_get(const char *str) {\n\treturn str? str: nullstr_c;\n}\n\nR_API const char *r_str_get2(const char *str) {\n\treturn str? str: nullstr;\n}\n\nR_API char *r_str_ndup(const char *ptr, int len) {\n\tif (len < 0) {\n\t\treturn NULL;\n\t}\n\tchar *out = malloc (len + 1);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\tstrncpy (out, ptr, len);\n\tout[len] = 0;\n\treturn out;\n}\n\n// TODO: deprecate?\nR_API char *r_str_dup(char *ptr, const char *string) {\n\tfree (ptr);\n\treturn r_str_new (string);\n}\n\nR_API char *r_str_prepend(char *ptr, const char *string) {\n\tint slen, plen;\n\tif (!ptr) {\n\t\treturn strdup (string);\n\t}\n\tplen = strlen (ptr);\n\tslen = strlen (string);\n\tptr = realloc (ptr, slen + plen + 1);\n\tif (!ptr) {\n\t\treturn NULL;\n\t}\n\tmemmove (ptr + slen, ptr, plen + 1);\n\tmemmove (ptr, string, slen);\n\treturn ptr;\n}\n\nR_API char *r_str_appendlen(char *ptr, const char *string, int slen) {\n\tchar *msg = r_str_newlen (string, slen);\n\tchar *ret = r_str_append (ptr, msg);\n\tfree (msg);\n\treturn ret;\n}\n\nR_API char *r_str_append_owned(char *ptr, char *string) {\n\tif (!ptr) {\n\t\treturn string;\n\t}\n\tchar *r = r_str_append(ptr, string);\n\tfree (string);\n\treturn r;\n}\n/*\n * first argument must be allocated\n * return: the pointer ptr resized to string size.\n */\nR_API char *r_str_append(char *ptr, const char *string) {\n\tif (string && !ptr) {\n\t\treturn strdup (string);\n\t}\n\tif (!string) {\n\t\treturn ptr;\n\t}\n\tint plen = strlen (ptr);\n\tint slen = strlen (string);\n\tchar *newptr = realloc (ptr, slen + plen + 1);\n\tif (!newptr) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tptr = newptr;\n\tmemcpy (ptr + plen, string, slen + 1);\n\treturn ptr;\n}\n\nR_API char *r_str_appendf(char *ptr, const char *fmt, ...) {\n\tva_list ap, ap2;\n\n\tva_start (ap, fmt);\n\tif (!strchr (fmt, '%')) {\n\t\tva_end (ap);\n\t\treturn r_str_append (ptr, fmt);\n\t}\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t\tptr = r_str_append (ptr, p);\n\t\tfree (p);\n\t}\n\tva_end (ap2);\n\tva_end (ap);\n\treturn ptr;\n}\n\nR_API char *r_str_appendch(char *x, char y) {\n\tchar b[2] = { y, 0 };\n\treturn r_str_append (x, b);\n}\n\nR_API char* r_str_replace(char *str, const char *key, const char *val, int g) {\n\tif (g == 'i') {\n\t\treturn r_str_replace_icase (str, key, val, g, true);\n\t}\n\tr_return_val_if_fail (str && key && val, NULL);\n\n\tint off, i, slen;\n\tchar *newstr, *p = str;\n\tint klen = strlen (key);\n\tint vlen = strlen (val);\n\tif (klen == 1 && vlen < 2) {\n\t\tr_str_replace_char (str, *key, *val);\n\t\treturn str;\n\t}\n\tif (klen == vlen && !strcmp (key, val)) {\n\t\treturn str;\n\t}\n\tslen = strlen (str);\n\tchar *q = str;\n\tfor (;;) {\n\t\tp = strstr (q, key);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\toff = (int)(size_t)(p - str);\n\t\tif (vlen != klen) {\n\t\t\tint tlen = slen - (off + klen);\n\t\t\tslen += vlen - klen;\n\t\t\tif (vlen > klen) {\n\t\t\t\tnewstr = realloc (str, slen + 1);\n\t\t\t\tif (!newstr) {\n\t\t\t\t\teprintf (\"realloc fail\\n\");\n\t\t\t\t\tR_FREE (str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr = newstr;\n\t\t\t}\n\t\t\tp = str + off;\n\t\t\tmemmove (p + vlen, p + klen, tlen + 1);\n\t\t}\n\t\tmemcpy (p, val, vlen);\n\t\ti = off + vlen;\n\t\tq = str + i;\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API char *r_str_replace_icase(char *str, const char *key, const char *val, int g, int keep_case) {\n\tr_return_val_if_fail (str && key && val, NULL);\n\n\tint off, i, klen, vlen, slen;\n\tchar *newstr, *p = str;\n\tklen = strlen (key);\n\tvlen = strlen (val);\n\n\tslen = strlen (str);\n\tfor (i = 0; i < slen;) {\n\t\tp = (char *)r_str_casestr (str + i, key);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\toff = (int)(size_t) (p - str);\n\t\tif (vlen != klen) {\n\t\t\tint tlen = slen - (off + klen);\n\t\t\tslen += vlen - klen;\n\t\t\tif (vlen > klen) {\n\t\t\t\tnewstr = realloc (str, slen + 1);\n\t\t\t\tif (!newstr) {\n\t\t\t\t\tgoto alloc_fail;\n\t\t\t\t}\n\t\t\t\tstr = newstr;\n\t\t\t}\n\t\t\tp = str + off;\n\t\t\tmemmove (p + vlen, p + klen, tlen + 1);\n\t\t}\n\n\t\tif (keep_case) {\n\t\t\tchar *tmp_val = strdup (val);\n\t\t\tchar *str_case = r_str_ndup (p, klen);\n\t\t\tif (!tmp_val || !str_case) {\n\t\t\t\tfree (tmp_val);\n\t\t\t\tfree (str_case);\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\ttmp_val = r_str_replace_icase (tmp_val, key, str_case, 0, 0);\n\t\t\tfree (str_case);\n\t\t\tif (!tmp_val) {\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tmemcpy (p, tmp_val, vlen);\n\t\t\tfree (tmp_val);\n\t\t} else {\n\t\t\tmemcpy (p, val, vlen);\n\t\t}\n\n\t\ti = off + vlen;\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n\nalloc_fail:\n\teprintf (\"alloc fail\\n\");\n\tfree (str);\n\treturn NULL;\n}\n\n/* replace the key in str with val.\n *\n * str - input string\n * clean - input string cleaned of ANSI chars\n * thunk - array of integers that map each char of the clean string into the\n *         position in the str string\n * clen  - number of elements in thunk\n * key   - string to find in the clean string\n * val   - string that replaces key in the str string\n * g     - if true, replace all occurrences of key\n *\n * It returns a pointer to the modified string */\nR_API char* r_str_replace_thunked(char *str, char *clean, int *thunk, int clen,\n\t\t\t\t  const char *key, const char *val, int g) {\n\tint i, klen, vlen, slen, delta = 0, bias;\n\tchar *newstr, *scnd, *p = clean, *str_p;\n\n\tif (!str || !key || !val || !clean || !thunk) {\n\t\treturn NULL;\n\t}\n\tklen = strlen (key);\n\tvlen = strlen (val);\n\tif (klen == vlen && !strcmp (key, val)) {\n\t\treturn str;\n\t}\n\tslen = strlen (str) + 1;\n\n\tfor (i = 0; i < clen; ) {\n\t\tp = (char *)r_mem_mem (\n\t\t\t(const ut8*)clean + i, clen - i,\n\t\t\t(const ut8*)key, klen);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\ti = (int)(size_t)(p - clean);\n\t\t/* as the original string changes size during replacement\n\t\t * we need delta to keep track of it*/\n\t\tstr_p = str + thunk[i] + delta;\n\n\t\tint newo = thunk[i + klen] - thunk[i];\n\t\tr_str_ansi_filter (str_p, NULL, NULL, newo);\n\t\tscnd = strdup (str_p + newo);\n\t\tbias = vlen - newo;\n\n\t\tslen += bias;\n\t\t// HACK: this 32 avoids overwrites wtf\n\t\tnewstr = realloc (str, slen + klen);\n\t\tif (!newstr) {\n\t\t\teprintf (\"realloc fail\\n\");\n\t\t\tR_FREE (str);\n\t\t\tfree (scnd);\n\t\t\tbreak;\n\t\t}\n\t\tstr = newstr;\n\t\tstr_p = str + thunk[i] + delta;\n\t\tmemcpy (str_p, val, vlen);\n\t\tmemcpy (str_p + vlen, scnd, strlen (scnd) + 1);\n\t\ti += klen;\n\t\tdelta += bias;\n\t\tfree (scnd);\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API char *r_str_replace_in(char *str, ut32 sz, const char *key, const char *val, int g) {\n\tif (!str || !key || !val) {\n\t\treturn NULL;\n\t}\n\tchar *heaped = r_str_replace (strdup (str), key, val, g);\n\tif (heaped) {\n\t\tstrncpy (str, heaped, sz);\n\t\tfree (heaped);\n\t}\n\treturn str;\n}\n\nR_API int r_str_unescape(char *buf) {\n\tunsigned char ch = 0, ch2 = 0;\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; buf[i]; i++) {\n\t\tif (buf[i] != '\\\\') {\n\t\t\tcontinue;\n\t\t}\n\t\tint esc_seq_len = 2;\n\t\tswitch (buf[i + 1]) {\n\t\tcase 'e':\n\t\t\tbuf[i] = 0x1b;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tbuf[i] = '\\\\';\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tbuf[i] = 0x0d;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tbuf[i] = 0x0a;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tbuf[i] = 0x07;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbuf[i] = 0x08;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbuf[i] = 0x09;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tbuf[i] = 0x0b;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tbuf[i] = 0x0c;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\terr = ch2 = ch = 0;\n\t\t\tif (!buf[i + 2] || !buf[i + 3]) {\n\t\t\t\teprintf (\"Unexpected end of string.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\terr |= r_hex_to_byte (&ch,  buf[i + 2]);\n\t\t\terr |= r_hex_to_byte (&ch2, buf[i + 3]);\n\t\t\tif (err) {\n\t\t\t\teprintf (\"Error: Non-hexadecimal chars in input.\\n\");\n\t\t\t\treturn 0; // -1?\n\t\t\t}\n\t\t\tbuf[i] = (ch << 4) + ch2;\n\t\t\tesc_seq_len = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (IS_OCTAL (buf[i + 1])) {\n\t\t\t\tint num_digits = 1;\n\t\t\t\tbuf[i] = buf[i + 1] - '0';\n\t\t\t\tif (IS_OCTAL (buf[i + 2])) {\n\t\t\t\t\tnum_digits++;\n\t\t\t\t\tbuf[i] = (ut8)buf[i] * 8 + (buf[i + 2] - '0');\n\t\t\t\t\tif (IS_OCTAL (buf[i + 3])) {\n\t\t\t\t\t\tnum_digits++;\n\t\t\t\t\t\tbuf[i] = (ut8)buf[i] * 8 + (buf[i + 3] - '0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tesc_seq_len = 1 + num_digits;\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: Unknown escape sequence.\\n\");\n\t\t\t\treturn 0; // -1?\n\t\t\t}\n\t\t}\n\t\tmemmove (buf + i + 1, buf + i + esc_seq_len, strlen (buf + i + esc_seq_len) + 1);\n\t}\n\treturn i;\n}\n\nR_API void r_str_sanitize(char *c) {\n\tchar *d = c;\n\tif (d)  {\n\t\tfor (; *d; c++, d++) {\n\t\t\tswitch (*d) {\n\t\t\tcase '`':\n\t\t\tcase '$':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '~':\n\t\t\tcase '|':\n\t\t\tcase ';':\n\t\t\tcase '#':\n\t\t\tcase '@':\n\t\t\tcase '&':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\t\t*c = '_';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API char *r_str_sanitize_sdb_key(const char *s) {\n\tif (!s || !*s) {\n\t\treturn NULL;\n\t}\n\tsize_t len = strlen (s);\n\tchar *ret = malloc (len + 1);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tchar *cur = ret;\n\twhile (len > 0) {\n\t\tchar c = *s;\n\t\tif (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z') && !(c >= '0' && c <= '9')\n\t\t\t&& c != '_' && c != ':') {\n\t\t\tc = '_';\n\t\t}\n\t\t*cur = c;\n\t\ts++;\n\t\tcur++;\n\t\tlen--;\n\t}\n\t*cur = '\\0';\n\treturn ret;\n}\n\nR_API void r_str_byte_escape(const char *p, char **dst, int dot_nl, bool default_dot, bool esc_bslash) {\n\tchar *q = *dst;\n\tswitch (*p) {\n\tcase '\\n':\n\t\t*q++ = '\\\\';\n\t\t*q++ = dot_nl ? 'l' : 'n';\n\t\tbreak;\n\tcase '\\r':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'r';\n\t\tbreak;\n\tcase '\\\\':\n\t\t*q++ = '\\\\';\n\t\tif (esc_bslash) {\n\t\t\t*q++ = '\\\\';\n\t\t}\n\t\tbreak;\n\tcase '\\t':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 't';\n\t\tbreak;\n\tcase '\"' :\n\t\t*q++ = '\\\\';\n\t\t*q++ = '\"';\n\t\tbreak;\n\tcase '\\f':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'f';\n\t\tbreak;\n\tcase '\\b':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'b';\n\t\tbreak;\n\tcase '\\v':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'v';\n\t\tbreak;\n\tcase '\\a':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'a';\n\t\tbreak;\n\tdefault:\n\t\t/* Outside the ASCII printable range */\n\t\tif (!IS_PRINTABLE (*p)) {\n\t\t\tif (default_dot) {\n\t\t\t\t*q++ = '.';\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'x';\n\t\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\t}\n\t\t} else {\n\t\t\t*q++ = *p;\n\t\t}\n\t}\n\t*dst = q;\n}\n\n/* Internal function. dot_nl specifies whether to convert \\n into the\n * graphiz-compatible newline \\l */\nstatic char *r_str_escape_(const char *buf, int dot_nl, bool parse_esc_seq, bool ign_esc_seq, bool show_asciidot, bool esc_bslash) {\n\tr_return_val_if_fail (buf, NULL);\n\n\t/* Worst case scenario, we convert every byte to a single-char escape\n\t * (e.g. \\n) if show_asciidot, or \\xhh if !show_asciidot */\n\tchar *new_buf = malloc (1 + strlen (buf) * (show_asciidot ? 2 : 4));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase 0x1b: // ESC\n\t\t\tif (parse_esc_seq) {\n\t\t\t\tconst char *start_seq = p;\n\t\t\t\tp++;\n\t\t\t\t/* Parse the ANSI code (only the graphic mode\n\t\t\t\t * set ones are supported) */\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tfor (p++; *p != 'm'; p++) {\n\t\t\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ign_esc_seq) {\n\t\t\t\t\t\tmemcpy (q, start_seq, p - start_seq + 1);\n\t\t\t\t\t\tq += (p - start_seq + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tr_str_byte_escape (p, &q, dot_nl, show_asciidot, esc_bslash);\n\t\t}\n\t\tp++;\n\t}\nout:\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape(const char *buf) {\n\treturn r_str_escape_ (buf, false, true, true, false, true);\n}\n\n// Return MUST BE surrounded by double-quotes\nR_API char *r_str_escape_sh(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n#if __UNIX__\n\t\tcase '$':\n\t\tcase '`':\n#endif\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = '\\\\';\n\t\t\t/* FALLTHRU */\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_dot(const char *buf) {\n\treturn r_str_escape_ (buf, true, true, true, false, true);\n}\n\nR_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors) {\n\treturn r_str_escape_ (buf, false, colors, !colors, show_asciidot, esc_bslash);\n}\n\nstatic char *r_str_escape_utf(const char *buf, int buf_size, RStrEnc enc, bool show_asciidot, bool esc_bslash, bool keep_printable) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tswitch (enc) {\n\tcase R_STRING_ENC_UTF16LE:\n\tcase R_STRING_ENC_UTF16BE:\n\tcase R_STRING_ENC_UTF32LE:\n\tcase R_STRING_ENC_UTF32BE:\n\t\tif (buf_size < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (enc == R_STRING_ENC_UTF16LE || enc == R_STRING_ENC_UTF16BE) {\n\t\t\tend = (char *)r_mem_mem_aligned ((ut8 *)buf, buf_size, (ut8 *)\"\\0\\0\", 2, 2);\n\t\t} else {\n\t\t\tend = (char *)r_mem_mem_aligned ((ut8 *)buf, buf_size, (ut8 *)\"\\0\\0\\0\\0\", 4, 4);\n\t\t}\n\t\tif (!end) {\n\t\t\tend = buf + buf_size - 1; /* TODO: handle overlong strings properly */\n\t\t}\n\t\tlen = end - buf;\n\t\tbreak;\n\tdefault:\n\t\tlen = strlen (buf);\n\t\tend = buf + len;\n\t}\n\t/* Worst case scenario, we convert every byte to \\xhh */\n\tnew_buf = malloc (1 + (len * 4));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tswitch (enc) {\n\t\tcase R_STRING_ENC_UTF16LE:\n\t\tcase R_STRING_ENC_UTF16BE:\n\t\tcase R_STRING_ENC_UTF32LE:\n\t\tcase R_STRING_ENC_UTF32BE:\n\t\t\tif (enc == R_STRING_ENC_UTF16LE || enc == R_STRING_ENC_UTF16BE) {\n\t\t\t\tch_bytes = r_utf16_decode ((ut8 *)p, end - p, &ch, enc == R_STRING_ENC_UTF16BE);\n\t\t\t} else {\n\t\t\t\tch_bytes = r_utf32_decode ((ut8 *)p, end - p, &ch, enc == R_STRING_ENC_UTF32BE);\n\t\t\t}\n\t\t\tif (ch_bytes == 0) {\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\t\tif (ch_bytes == 0) {\n\t\t\t\tch_bytes = 1;\n\t\t\t}\n\t\t}\n\t\tif (show_asciidot && !IS_PRINTABLE(ch)) {\n\t\t\t*q++ = '.';\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (keep_printable) {\n\t\t\t\tq += r_utf8_encode ((ut8 *)q, ch);\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = ch_bytes == 4 ? 'U' : 'u';\n\t\t\t\tfor (i = ch_bytes == 4 ? 6 : 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint offset = enc == R_STRING_ENC_UTF16BE ? 1 : enc == R_STRING_ENC_UTF32BE ? 3 : 0;\n\t\t\tr_str_byte_escape (p + offset, &q, false, false, esc_bslash);\n\t\t}\n\t\tswitch (enc) {\n\t\tcase R_STRING_ENC_UTF16LE:\n\t\tcase R_STRING_ENC_UTF16BE:\n\t\t\tp += ch_bytes < 2 ? 2 : ch_bytes;\n\t\t\tbreak;\n\t\tcase R_STRING_ENC_UTF32LE:\n\t\tcase R_STRING_ENC_UTF32BE:\n\t\t\tp += 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp += ch_bytes;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, -1, R_STRING_ENC_UTF8, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf8_keep_printable(const char *buf, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, -1, R_STRING_ENC_UTF8, show_asciidot, esc_bslash, true);\n}\n\nR_API char *r_str_escape_utf16le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF16LE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf32le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF32LE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf16be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF16BE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf32be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF32BE, show_asciidot, esc_bslash, false);\n}\n\n// JSON has special escaping requirements\n// TODO: merge with r_str_escape_utf() and r_str_byte_escape() using RStrEsc\nR_API char *r_str_escape_utf8_for_json(const char *buf, int buf_size) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tlen = buf_size < 0 ? strlen (buf) : buf_size;\n\tend = buf + len;\n\t/* Worst case scenario, we convert every byte to \\u00hh */\n\tnew_buf = malloc (1 + (len * 6));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\tif (ch_bytes == 1) {\n\t\t\tswitch (*p) {\n\t\t\tcase '\\n':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'n';\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'r';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\tbreak;\n#if 0\n\t\t\tcase '/': /* has 2-char esc seq in JSON spec, but escaping is optional */\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '/';\n\t\t\t\tbreak;\n#endif\n\t\t\tcase '\\t':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 't';\n\t\t\t\tbreak;\n\t\t\tcase '\"' :\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\"';\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'f';\n\t\t\t\tbreak;\n\t\t\tcase '\\b':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'b';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!IS_PRINTABLE (*p)) {\n\t\t\t\t\t*q++ = '\\\\';\n\t\t\t\t\t*q++ = 'u';\n\t\t\t\t\t*q++ = '0';\n\t\t\t\t\t*q++ = '0';\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\t\t} else {\n\t\t\t\t\t*q++ = *p;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes == 4) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRune high, low;\n\t\t\t\tch -= 0x10000;\n\t\t\t\thigh = 0xd800 + (ch >> 10 & 0x3ff);\n\t\t\t\tlow = 0xdc00 + (ch & 0x3ff);\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // ch_bytes == 0\n\t\t\t// Outside JSON spec, but apparently no better\n\t\t\t// alternative if need to reconstruct the original string\n\t\t\t*q++ = '\\\\';\n\t\t\t*q++ = 'x';\n\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\tch_bytes = 1;\n\t\t}\n\t\tp += ch_bytes;\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\n// http://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES\n// https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?redirectedfrom=MSDN&view=vs-2019#parsing-c-command-line-arguments\nR_API char *r_str_format_msvc_argv(size_t argc, const char **argv) {\n\tRStrBuf sb;\n\tr_strbuf_init (&sb);\n\n\tsize_t i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i > 0) {\n\t\t\tr_strbuf_append (&sb, \" \");\n\t\t}\n\t\tconst char *arg = argv[i];\n\t\tbool must_escape = strchr (arg, '\\\"') != NULL;\n\t\tbool must_quote = strpbrk (arg, \" \\t\") != NULL || !*arg;\n\t\tif (!must_escape && must_quote && *arg && arg[strlen (arg) - 1] == '\\\\') {\n\t\t\t// if the last char is a bs and we would quote it, we must also escape\n\t\t\tmust_escape = true;\n\t\t}\n\t\tif (must_quote) {\n\t\t\tr_strbuf_append (&sb, \"\\\"\");\n\t\t}\n\t\tif (must_escape) {\n\t\t\tsize_t bs_count = 0; // bullshit counter\n\t\t\tfor (; *arg; arg++) {\n\t\t\t\tswitch (*arg) {\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tfor (; bs_count; bs_count--) {\n\t\t\t\t\t\t// backslashes must be escaped iff they precede a \"\n\t\t\t\t\t\t// so just duplicate the number of backslashes already printed\n\t\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t\t}\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tbs_count++;\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbs_count = 0;\n\t\t\t\t\tr_strbuf_append_n (&sb, arg, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (must_quote) {\n\t\t\t\t// there will be a quote after this so we have to escape bs here as well\n\t\t\t\tfor (; bs_count; bs_count--) {\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_strbuf_append (&sb, arg);\n\t\t}\n\t\tif (must_quote) {\n\t\t\tr_strbuf_append (&sb, \"\\\"\");\n\t\t}\n\t}\n\n\treturn r_strbuf_drain_nofree (&sb);\n}\n\nstatic size_t __str_ansi_length(char const *str) {\n\tsize_t i = 1;\n\tif (str[0] == 0x1b) {\n\t\tif (str[1] == '[') {\n\t\t\ti++;\n\t\t\twhile (str[i] && str[i] != 'J' && str[i] != 'm' && str[i] != 'H' && str[i] != 'K') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (str[1] == '#') {\n\t\t\twhile (str[i] && str[i] != 'q') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (str[i]) {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\n/* ansi helpers */\nR_API size_t r_str_ansi_nlen(const char *str, size_t slen) {\n\tsize_t i = 0, len = 0;\n\tif (slen > 0) {\n\t\twhile (str[i] && i < slen) {\n\t\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\t\tif (chlen == 1) {\n\t\t\t\tlen ++;\n\t\t\t}\n\t\t\ti += chlen;\n\t\t}\n\t\treturn len > 0 ? len: 1;\n\t}\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen == 1) {\n\t\t\tlen ++;\n\t\t}\n\t\ti += chlen;\n\t}\n\treturn len > 0 ? len: 1;\n}\n\nR_API size_t r_str_ansi_len(const char *str) {\n\treturn r_str_ansi_nlen (str, 0);\n}\n\nR_API size_t r_str_nlen(const char *str, int n) {\n\tsize_t len = 0;\n\tif (str) {\n\t\twhile (*str && n > 0) {\n\t\t\tlen++;\n\t\t\tstr++;\n\t\t\tn--;\n\t\t}\n\t}\n\treturn len;\n}\n\n//to handle wide string as well\n//XXX can be error prone\nR_API size_t r_str_nlen_w(const char *str, int n) {\n\tsize_t len = 0;\n\tif (str) {\n\t\twhile (*str && n > 0) {\n\t\t\tlen++;\n\t\t\tstr++;\n\t\t\tif (!*str) {\n\t\t\t\t//handle wide strings\n\t\t\t \t//xx00yy00bb00\n\t\t\t\tif (n - 2 > 0) {\n\t\t\t\t\tif (str[2]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t}\n\treturn len;\n}\n\nR_API bool r_str_is_ascii(const char *str) {\n\tconst ut8 *ptr;\n\tfor (ptr = (const ut8 *)str; *ptr; ptr++) {\n\t\tif (*ptr > 0x7f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable(const char *str) {\n\twhile (*str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\treturn false;\n\t\t}\n\t\tstr++;\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable_limited(const char *str, int size) {\n\twhile (size > 0 && *str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\treturn false;\n\t\t}\n\t\tstr++;\n\t\tsize--;\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable_incl_newlines(const char *str) {\n\twhile (*str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\tif (*str != '\\r' && *str != '\\n' && *str != '\\t') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tstr++;\n\t}\n\treturn true;\n}\n\n// Length in chars of a wide string (find better name?)\nR_API size_t r_wstr_clen(const char *s) {\n\tsize_t len = 0;\n\tif (!*s++) {\n\t\treturn 0;\n\t}\n\twhile (*s++ || *s++) {\n\t\tlen++;\n\t}\n\treturn len + 1;\n}\n\nR_API const char *r_str_ansi_chrn(const char *str, size_t n) {\n\tint len, i, li;\n\tfor (li = i = len = 0; str[i] && (n != len); i++) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\ti += chlen - 1;\n\t\t} else {\n\t\t\tif ((str[i] & 0xc0) != 0x80) {\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tli = i;\n\t\t}\n\t}\n\treturn str + li;\n}\n\n/*\n * filter out ansi CSI shit in-place!.\n * str - input string,\n * out - if not NULL write a pointer to the original string there,\n * cposs - if not NULL write a pointer to thunk array there\n * (*cposs)[i] is the offset of the out[i] in str\n * len - length of str\n *\n * it returns the number of normal characters found in str\n */\nR_API int r_str_ansi_filter(char *str, char **out, int **cposs, int len) {\n\tint i, j, *cps;\n\n\tif (len == 0) {\n\t\treturn 0;\n\t}\n\tif (len < 0) {\n\t\tlen = strlen (str);\n\t}\n\tchar *tmp = malloc (len + 1);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\tmemcpy (tmp, str, len + 1);\n\tcps = calloc (len + 1, sizeof (int));\n\tif (!cps) {\n\t\tfree (tmp);\n\t\treturn -1;\n\t}\n\n\tfor (i = j = 0; i < len; i++) {\n\t\tif (tmp[i] == 0x1b) {\n\t\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\t\tif (chlen > 1) {\n\t\t\t\ti += chlen;\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else {\n\t\t\tstr[j] = tmp[i];\n\t\t\tcps[j] = i;\n\t\t\tj++;\n\t\t}\n\t}\n\tstr[j] = tmp[i];\n\n\tif (out) {\n\t\t*out = tmp;\n\t} else {\n\t\tfree (tmp);\n\t}\n\n\tif (cposs) {\n\t\t*cposs = cps;\n\t} else {\n\t\tfree (cps);\n\t}\n\n\treturn j;\n}\n\nR_API char *r_str_ansi_crop(const char *str, ut32 x, ut32 y, ut32 x2, ut32 y2) {\n\tchar *r, *r_end, *ret;\n\tconst char *s, *s_start;\n\tsize_t r_len, str_len = 0, nr_of_lines = 0;\n\tut32 ch = 0, cw = 0;\n\tif (x2 <= x || y2 <= y || !str) {\n\t\treturn strdup (\"\");\n\t}\n\ts = s_start = str;\n\twhile (*s) {\n\t\tstr_len++;\n\t\tif (*s == '\\n') {\n\t\t\tnr_of_lines++;\n\t\t}\n\t\ts++;\n\t}\n\tr_len = str_len + nr_of_lines * strlen (Color_RESET) + 1;\n\tr = ret = malloc (r_len);\n\tif (!r) {\n\t\treturn NULL;\n\t}\n\tr_end = r + r_len;\n\twhile (*str) {\n\t\t/* crop height */\n\t\tif (ch >= y2) {\n\t\t\tr--;\n\t\t\tbreak;\n\t\t}\n\t\tif (*str == '\\n') {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\tconst char *reset = Color_RESET \"\\n\";\n\t\t\t\tif (strlen (reset) < (r_end - r)) {\n\t\t\t\t\tconst int reset_length = strlen (reset);\n\t\t\t\t\tmemcpy (r, reset, reset_length + 1);\n\t\t\t\t\tr += reset_length;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr++;\n\t\t\tch++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\tif ((*str & 0xc0) == 0x80) {\n\t\t\t\t\tif (cw > x) {\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r_str_char_fullwidth (str, str_len - (str - s_start))) {\n\t\t\t\t\tcw++;\n\t\t\t\t\tif (cw == x) {\n\t\t\t\t\t\t*r++ = ' ';\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*str == 0x1b && *(str + 1) == '[') {\n\t\t\t\t\tconst char *ptr = str;\n\t\t\t\t\tif ((r_end - r) > 2) {\n\t\t\t\t\t\t/* copy 0x1b and [ */\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t\tfor (ptr = str; *ptr && *ptr != 'J' && *ptr != 'm' && *ptr != 'H'; ptr++) {\n\t\t\t\t\t\t\t*r++ = *ptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*r++ = *ptr++;\n\t\t\t\t\t}\n\t\t\t\t\tstr = ptr;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (cw >= x && cw < x2) {\n\t\t\t\t\t*r++ = *str;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* skip until newline */\n\t\t\tif (cw >= x2) {\n\t\t\t\twhile (*str && *str != '\\n') {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tcw++;\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\nR_API size_t r_str_utf8_codepoint(const char* s, size_t left) {\n\tif ((*s & 0x80) != 0x80) {\n\t\treturn 0;\n\t} else if ((*s & 0xe0) == 0xc0 && left >= 1) {\n\t\treturn ((*s & 0x1f) << 6) + (*(s + 1) & 0x3f);\n\t} else if ((*s & 0xf0) == 0xe0 && left >= 2) {\n\t\treturn ((*s & 0xf) << 12) + ((*(s + 1) & 0x3f) << 6) + (*(s + 2) & 0x3f);\n\t} else if ((*s & 0xf8) == 0xf0 && left >= 3) {\n\t\treturn ((*s & 0x7) << 18) + ((*(s + 1) & 0x3f) << 12) + ((*(s + 2) & 0x3f) << 6) + (*(s + 3) & 0x3f);\n\t}\n\treturn 0;\n}\n\nR_API bool r_str_char_fullwidth (const char* s, size_t left) {\n\tsize_t codepoint = r_str_utf8_codepoint (s, left);\n\treturn (codepoint >= 0x1100 &&\n\t\t (codepoint <= 0x115f ||                  /* Hangul Jamo init. consonants */\n\t\t\t  codepoint == 0x2329 || codepoint == 0x232a ||\n\t\t (R_BETWEEN (0x2e80, codepoint, 0xa4cf)\n\t\t\t&& codepoint != 0x303f) ||        /* CJK ... Yi */\n\t\t R_BETWEEN (0xac00, codepoint, 0xd7a3) || /* Hangul Syllables */\n\t\t R_BETWEEN (0xf900, codepoint, 0xfaff) || /* CJK Compatibility Ideographs */\n\t\t R_BETWEEN (0xfe10, codepoint, 0xfe19) || /* Vertical forms */\n\t\t R_BETWEEN (0xfe30, codepoint, 0xfe6f) || /* CJK Compatibility Forms */\n\t\t R_BETWEEN (0xff00, codepoint, 0xff60) || /* Fullwidth Forms */\n\t\t R_BETWEEN (0xffe0, codepoint, 0xffe6) ||\n\t\t R_BETWEEN (0x20000, codepoint, 0x2fffd) ||\n\t\t R_BETWEEN (0x30000, codepoint, 0x3fffd)));\n\n}\n\n/**\n * Returns size in bytes of the utf8 char\n * Returns 1 in case of ASCII\n * str - Pointer to buffer\n */\nR_API size_t r_str_utf8_charsize(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\tsize_t size = 0;\n\tsize_t length = strlen (str);\n\twhile (size < length && size < 5) {\n\t\tsize++;\n\t\tif ((str[size] & 0xc0) != 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size < 5 ? size : 0;\n}\n\n/**\n * Returns size in bytes of the utf8 char previous to str\n * Returns 1 in case of ASCII\n * str - Pointer to leading utf8 char\n * prev_len - Length in bytes of the buffer until str\n */\nR_API size_t r_str_utf8_charsize_prev(const char *str, int prev_len) {\n\tr_return_val_if_fail (str, 0);\n\tint pos = 0;\n\tsize_t size = 0, minsize = R_MIN (5, prev_len);\n\twhile (size < minsize) {\n\t\tsize++;\n\t\tif ((str[--pos] & 0xc0) != 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size < 5 ? size : 0;\n}\n\n/**\n * Returns size in bytes of the last utf8 char of the string\n * Returns 1 in case of ASCII\n * str - Pointer to buffer\n */\nR_API size_t r_str_utf8_charsize_last(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\tsize_t len = strlen (str);\n\treturn r_str_utf8_charsize_prev (str + len, len);\n}\n\nR_API void r_str_filter_zeroline(char *str, int len) {\n\tint i;\n\tfor (i = 0; i < len && str[i]; i++) {\n\t\tif (str[i] == '\\n' || str[i] == '\\r') {\n\t\t\tbreak;\n\t\t}\n\t\tif (!IS_PRINTABLE (str[i])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr[i] = 0;\n}\n\nR_API void r_str_filter(char *str, int len) {\n\tsize_t i;\n\tif (len < 1) {\n\t\tlen = strlen (str);\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (!IS_PRINTABLE (str[i])) {\n\t\t\tstr[i] = '.';\n\t\t}\n\t}\n}\n\nR_API bool r_str_glob(const char* str, const char *glob) {\n        const char* cp = NULL, *mp = NULL;\n        if (!glob || !strcmp (glob, \"*\")) {\n                return true;\n        }\n        if (!strchr (glob, '*')) {\n                if (*glob == '^') {\n                        glob++;\n                        while (*str) {\n                                if (*glob != *str) {\n                                        return false;\n                                }\n                                if (!*++glob) {\n                                        return true;\n                                }\n                                str++;\n                        }\n                } else {\n                        return strstr (str, glob) != NULL;\n                }\n        }\n        if (*glob == '^') {\n                glob++;\n        }\n        while (*str && (*glob != '*')) {\n                if (*glob != *str) {\n                        return false;\n                }\n                glob++;\n                str++;\n        }\n        while (*str) {\n                if (*glob == '*') {\n                        if (!*++glob) {\n                                return true;\n                        }\n                        mp = glob;\n                        cp = str + 1;\n                } else if (*glob == *str) {\n                        glob++;\n                        str++;\n                } else {\n                        glob = mp;\n                        str = cp++;\n                }\n        }\n        while (*glob == '*') {\n                ++glob;\n        }\n        return (*glob == '\\x00');\n}\n\n// Escape the string arg so that it is parsed as a single argument by r_str_argv\nR_API char *r_str_arg_escape(const char *arg) {\n\tchar *str;\n\tint dest_i = 0, src_i = 0;\n\tif (!arg) {\n\t\treturn NULL;\n\t}\n\tstr = malloc ((2 * strlen (arg) + 1) * sizeof (char)); // Worse case when every character need to be escaped\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tfor (src_i = 0; arg[src_i] != '\\0'; src_i++) {\n\t\tchar c = arg[src_i];\n\t\tswitch (c) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase ' ':\n\t\t\tstr[dest_i++] = '\\\\';\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr[dest_i] = '\\0';\n\treturn realloc (str, (strlen(str)+1) * sizeof (char));\n}\n\n// Unescape the string arg to its original format\nR_API int r_str_arg_unescape(char *arg) {\n\tint dest_i = 0, src_i = 0;\n\tif (!arg) {\n\t\treturn 0;\n\t}\n\tfor (src_i = 0; arg[src_i] != '\\0'; src_i++) {\n\t\tchar c = arg[src_i];\n\t\tif (c == '\\\\') {\n\t\t\tif (arg[++src_i] == '\\0') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ[dest_i++] = arg[src_i];\n\t\t} else {\n\t\t\targ[dest_i++] = c;\n\t\t}\n\t}\n\targ[dest_i] = '\\0';\n\treturn dest_i;\n}\n\nR_API char *r_str_path_escape(const char *path) {\n\tchar *str;\n\tint dest_i = 0, src_i = 0;\n\n\tif (!path) {\n\t\treturn NULL;\n\t}\n\t// Worst case when every character need to be escaped\n\tstr = malloc ((2 * strlen (path) + 1) * sizeof (char));\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\n\tfor (src_i = 0; path[src_i] != '\\0'; src_i++) {\n\t\tchar c = path[src_i];\n\t\tswitch (c) {\n\t\tcase ' ':\n\t\t\tstr[dest_i++] = '\\\\';\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstr[dest_i] = '\\0';\n\treturn realloc (str, (strlen (str) + 1) * sizeof (char));\n}\n\nR_API int r_str_path_unescape(char *path) {\n\tint i;\n\n\tfor (i = 0; path[i]; i++) {\n\t\tif (path[i] != '\\\\') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (path[i + 1] == ' ') {\n\t\t\tpath[i] = ' ';\n\t\t\tmemmove (path + i + 1, path + i + 2, strlen (path + i + 2) + 1);\n\t\t}\n\t}\n\n\treturn i;\n}\n\nR_API char **r_str_argv(const char *cmdline, int *_argc) {\n\tint argc = 0;\n\tint argv_len = 128; // Begin with that, argv will reallocated if necessary\n\tchar *args; // Working buffer for writing unescaped args\n\tint cmdline_current = 0; // Current character index in _cmdline\n\tint args_current = 0; // Current character index in  args\n\tint arg_begin = 0; // Index of the first character of the current argument in args\n\n\tif (!cmdline) {\n\t\treturn NULL;\n\t}\n\n\tchar **argv = malloc (argv_len * sizeof (char *));\n\tif (!argv) {\n\t\treturn NULL;\n\t}\n\targs = malloc (128 + strlen (cmdline) * sizeof (char)); // Unescaped args will be shorter, so strlen (cmdline) will be enough\n\tif (!args) {\n\t\tfree (argv);\n\t\treturn NULL;\n\t}\n\tdo {\n\t\t// States for parsing args\n\t\tint escaped = 0;\n\t\tint singlequoted = 0;\n\t\tint doublequoted = 0;\n\n\t\t// Seek the beginning of next argument (skip whitespaces)\n\t\twhile (cmdline[cmdline_current] != '\\0' && IS_WHITECHAR (cmdline[cmdline_current])) {\n\t\t\tcmdline_current++;\n\t\t}\n\n\t\tif (cmdline[cmdline_current] == '\\0') {\n\t\t\tbreak; // No more arguments\n\t\t}\n\t\t// Read the argument\n\t\twhile (1) {\n\t\t\tchar c = cmdline[cmdline_current];\n\t\t\tint end_of_current_arg = 0;\n\t\t\tif (escaped) {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\'':\n\t\t\t\tcase '\"':\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\\\':\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t}\n\t\t\t\tescaped = 0;\n\t\t\t} else {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (doublequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsinglequoted = !singlequoted;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tif (singlequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoublequoted = !doublequoted;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ' ':\n\t\t\t\t\tif (singlequoted || doublequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\n\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (end_of_current_arg) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcmdline_current++;\n\t\t}\n\t\targs[args_current++] = '\\0';\n\t\targv[argc++] = strdup (&args[arg_begin]);\n\t\tif (argc >= argv_len) {\n\t\t\targv_len *= 2;\n\t\t\tchar **tmp = realloc (argv, argv_len * sizeof (char *));\n\t\t\tif (!tmp) {\n\t\t\t\tfree (args);\n\t\t\t\tfree (argv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\targv = tmp;\n\t\t}\n\t\targ_begin = args_current;\n\t} while (cmdline[cmdline_current++] != '\\0');\n\targv[argc] = NULL;\n\tchar **tmp = realloc (argv, (argc + 1) * sizeof (char *));\n\tif (tmp) {\n\t\targv = tmp;\n\t} else {\n\t\tfree (argv);\n\t\targv = NULL;\n\t}\n\tif (_argc) {\n\t\t*_argc = argc;\n\t}\n\tfree (args);\n\treturn argv;\n}\n\nR_API void r_str_argv_free(char **argv) {\n\tint argc = 0;\n\tif (!argv) {\n\t\treturn;\n\t}\n\twhile (argv[argc]) {\n\t\tfree (argv[argc++]);\n\t}\n\tfree (argv);\n}\n\nR_API const char *r_str_firstbut(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn strchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\teprintf (\"r_str_firstbut: but string too long\\n\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_lastbut(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p, *lp = NULL;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn r_str_lchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\teprintf (\"r_str_lastbut: but string too long\\n\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\tlp = p;\n\t\t}\n\t}\n\treturn lp;\n}\n\n// Must be merged inside strlen\nR_API size_t r_str_len_utf8char(const char *s, int left) {\n\tsize_t i = 1;\n\twhile (s[i] && (!left || i<left)) {\n\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\ti++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nR_API size_t r_str_len_utf8(const char *s) {\n\tsize_t i = 0, j = 0, fullwidths = 0;\n\twhile (s[i]) {\n\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\tj++;\n\t\t\tif (r_str_char_fullwidth (s + i, 4)) {\n\t\t\t\tfullwidths++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn j + fullwidths;\n}\n\nR_API size_t r_str_len_utf8_ansi(const char *str) {\n\tint i = 0, len = 0, fullwidths = 0;\n\twhile (str[i]) {\n\t\tchar ch = str[i];\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\ti += chlen - 1;\n\t\t} else if ((ch & 0xc0) != 0x80) { // utf8\n\t\t\tlen++;\n\t\t\tif (r_str_char_fullwidth (str + i, 4)) {\n\t\t\t\tfullwidths++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn len + fullwidths;\n}\n\n// XXX must find across the ansi tags, as well as support utf8\nR_API const char *r_strstr_ansi(const char *a, const char *b) {\n\tconst char *ch, *p = a;\n\tdo {\n\t\tch = strchr (p, '\\x1b');\n\t\tif (ch) {\n\t\t\tconst char *v = r_str_nstr (p, b, ch - p);\n\t\t\tif (v) {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tp = ch + __str_ansi_length (ch);\n\t\t}\n\t} while (ch);\n\treturn strstr (p, b);\n}\n\nR_API const char *r_str_casestr(const char *a, const char *b) {\n\t// That's a GNUism that works in many places.. but we don't want it\n\t// return strcasestr (a, b);\n\tsize_t hay_len = strlen (a);\n\tsize_t needle_len = strlen (b);\n\tif (!hay_len || !needle_len) {\n\t\treturn NULL;\n\t}\n\twhile (hay_len >= needle_len) {\n\t\tif (!r_str_ncasecmp (a, b, needle_len)) {\n\t\t\treturn (const char *) a;\n\t\t}\n\t\ta++;\n\t\thay_len--;\n\t}\n\treturn NULL;\n}\n\nR_API int r_str_write(int fd, const char *b) {\n\treturn write (fd, b, strlen (b));\n}\n\nR_API void r_str_range_foreach(const char *r, RStrRangeCallback cb, void *u) {\n\tconst char *p = r;\n\tfor (; *r; r++) {\n\t\tif (*r == ',') {\n\t\t\tcb (u, atoi (p));\n\t\t\tp = r + 1;\n\t\t}\n\t\tif (*r == '-') {\n\t\t\tif (p != r) {\n\t\t\t\tint from = atoi (p);\n\t\t\t\tint to = atoi (r + 1);\n\t\t\t\tfor (; from <= to; from++) {\n\t\t\t\t\tcb (u, from);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"Invalid range\\n\");\n\t\t\t}\n\t\t\tfor (r++; *r && *r != ',' && *r != '-'; r++) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\tif (*p) {\n\t\tcb (u, atoi (p));\n\t}\n}\n\nR_API bool r_str_range_in(const char *r, ut64 addr) {\n\tconst char *p = r;\n\tut64 min = UT64_MAX;\n\tut64 max = 0;\n\tif (!r) {\n\t\treturn false;\n\t}\n\tfor (; *r; r++) {\n\t\tif (*r == ',') {\n\t\t\tif (max == 0) {\n\t\t\t\tif (addr == r_num_get (NULL, p)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (addr >= min && addr <= r_num_get (NULL, p)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = r + 1;\n\t\t}\n\t\tif (*r == '-') {\n\t\t\tif (p != r) {\n\t\t\t\tut64 from = r_num_get (NULL, p);\n\t\t\t\tut64 to = r_num_get (NULL, r + 1);\n\t\t\t\tif (addr >= from && addr <= to) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"Invalid range\\n\");\n\t\t\t}\n\t\t\tfor (r++; *r && *r != ',' && *r != '-'; r++) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\tif (*p) {\n\t\tif (addr == r_num_get (NULL, p)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// convert from html escaped sequence \"foo%20bar\" to \"foo bar\"\n// TODO: find better name.. unencode? decode\nR_API void r_str_uri_decode(char *s) {\n\tint n;\n\tchar *d;\n\tfor (d = s; *s; s++, d++) {\n\t\tif (*s == '%') {\n\t\t\tsscanf (s + 1, \"%02x\", &n);\n\t\t\t*d = n;\n\t\t\ts += 2;\n\t\t} else {\n\t\t\t*d = *s;\n\t\t}\n\t}\n\t*d = 0;\n}\n\nR_API char *r_str_uri_encode(const char *s) {\n\tchar ch[4], *d, *od;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tod = d = malloc (1 + (strlen (s) * 4));\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tfor (; *s; s++) {\n\t\tif((*s>='0' && *s<='9')\n\t\t|| (*s>='a' && *s<='z')\n\t\t|| (*s>='A' && *s<='Z')) {\n\t\t\t*d++ = *s;\n\t\t} else {\n\t\t\t*d++ = '%';\n\t\t\tsnprintf (ch, sizeof (ch), \"%02x\", 0xff & ((ut8)*s));\n\t\t\t*d++ = ch[0];\n\t\t\t*d++ = ch[1];\n\t\t}\n\t}\n\t*d = 0;\n\tchar *trimDown = realloc (od, strlen (od) + 1); // FIT\n\treturn trimDown? trimDown: od;\n}\n\nR_API int r_str_utf16_to_utf8(ut8 *dst, int len_dst, const ut8 *src, int len_src, int little_endian) {\n\tut8 *outstart = dst;\n\tut8 *outend = dst + len_dst;\n\tut16 *in = (ut16*)src;\n\tut16 *inend;\n\tut32 c, d, inlen;\n\tut8 *tmp;\n\tint bits;\n\n\tif ((len_src % 2) == 1) {\n\t\tlen_src--;\n\t}\n\tinlen = len_src / 2;\n\tinend = in + inlen;\n\twhile ((in < inend) && (dst - outstart + 5 < len_dst)) {\n\t\tif (little_endian) {\n\t\t\tc = *in++;\n\t\t} else {\n\t\t\ttmp = (ut8*) in;\n\t\t\tc = *tmp++;\n\t\t\tif (!c && !*tmp) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = c | (((ut32)*tmp) << 8);\n\t\t\tin++;\n\t\t}\n\t\tif ((c & 0xFC00) == 0xD800) {    /* surrogates */\n\t\t\tif (in >= inend) {           /* (in > inend) shouldn't happens */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (little_endian) {\n\t\t\t\td = *in++;\n\t\t\t} else {\n\t\t\t\ttmp = (ut8*) in;\n\t\t\t\td = *tmp++;\n\t\t\t\td = d | (((ut32)*tmp) << 8);\n\t\t\t\tin++;\n\t\t\t}\n\t\t\tif ((d & 0xFC00) == 0xDC00) {\n\t\t\t\tc &= 0x03FF;\n\t\t\t\tc <<= 10;\n\t\t\t\tc |= d & 0x03FF;\n\t\t\t\tc += 0x10000;\n\t\t\t} else {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\t/* assertion: c is a single UTF-4 value */\n\t\tif (dst >= outend) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c < 0x80) {\n\t\t\t*dst++ =  c; bits= -6;\n\t\t} else if (c < 0x800) {\n\t\t\t*dst++ = ((c >> 6) & 0x1F) | 0xC0;\n\t\t\tbits =  0;\n\t\t} else if (c < 0x10000) {\n\t\t\t*dst++ = ((c >> 12) & 0x0F) | 0xE0;\n\t\t\tbits =  6;\n\t\t} else {\n\t\t\t*dst++ = ((c >> 18) & 0x07) | 0xF0;\n\t\t\tbits = 12;\n\t\t}\n\n\t\tfor (; bits >= 0; bits -= 6) {\n\t\t\tif (dst >= outend) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*dst++ = ((c >> bits) & 0x3F) | 0x80;\n\t\t}\n\t}\n\tlen_dst = dst - outstart;\n\treturn len_dst;\n}\n\nR_API char *r_str_utf16_decode(const ut8 *s, int len) {\n\tint i = 0;\n\tint j = 0;\n\tchar *result = NULL;\n\tint count_unicode = 0;\n\tint count_ascii = 0;\n\tint lenresult = 0;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len && (s[i] || s[i+1]); i += 2) {\n\t\tif (!s[i+1] && 0x20 <= s[i] && s[i] <= 0x7E) {\n\t\t\t++count_ascii;\n\t\t} else {\n\t\t\t++count_unicode;\n\t\t}\n\t}\n\tlenresult = 1 + count_ascii + count_unicode * 6; // len(\"\\\\uXXXX\") = 6\n\tif (!(result = calloc (1 + count_ascii + count_unicode * 6, 1))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len && j < lenresult && (s[i] || s[i+1]); i += 2) {\n\t\tif (!s[i+1] && IS_PRINTABLE(s[i])) {\n\t\t\tresult[j++] = s[i];\n\t\t} else {\n\t\t\tj += snprintf (&result[j], lenresult - j, \"\\\\u%.2\"HHXFMT\"%.2\"HHXFMT\"\", s[i], s[i+1]);\n\t\t}\n\t}\n\treturn result;\n}\n\n// TODO: kill this completely, it makes no sense:\nR_API char *r_str_utf16_encode(const char *s, int len) {\n\tint i;\n\tchar ch[4], *d, *od, *tmp;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tif (len < 0) {\n\t\tlen = strlen (s);\n\t}\n\tif ((len * 7) + 1 < len) {\n\t\treturn NULL;\n\t}\n\tod = d = malloc (1 + (len * 7));\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len; s++, i++) {\n\t\tif (*s == '\\\\') {\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = '\\\\';\n\t\t} else if (*s == '\"') {\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = '\"';\n\t\t} else if ((*s >= 0x20) && (*s <= 126)) {\n\t\t\t*d++ = *s;\n\t\t} else {\n\t\t\t*d++ = '\\\\';\n\t\t\t//\t*d++ = '\\\\';\n\t\t\t*d++ = 'u';\n\t\t\t*d++ = '0';\n\t\t\t*d++ = '0';\n\t\t\tsnprintf (ch, sizeof (ch), \"%02x\", 0xff & ((ut8)*s));\n\t\t\t*d++ = ch[0];\n\t\t\t*d++ = ch[1];\n\t\t}\n\t}\n\t*d = 0;\n\ttmp = realloc (od, strlen (od) + 1); // FIT\n\tif (!tmp) {\n\t\tfree (od);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nR_API char *r_str_prefix_all(const char *s, const char *pfx) {\n\tconst char *os = s;\n\tchar *p;\n\tint newlines = 1;\n\tint len = 0;\n\tint pfx_len = 0;\n\n\tif (!s) {\n\t\treturn strdup (pfx);\n\t}\n\tif (!pfx) {\n\t\treturn strdup (s);\n\t}\n\tlen = strlen (s);\n\tpfx_len = strlen (pfx);\n\tfor (os = s; *os; os++)  {\n\t\tif (*os == '\\n') {\n\t\t\tnewlines++;\n\t\t}\n\t}\n\tchar *o = malloc (len + (pfx_len * newlines) + 1);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tmemcpy (o, pfx, pfx_len);\n\tfor (p = o + pfx_len; *s; s++) {\n\t\t*p++ = *s;\n\t\tif (*s == '\\n' && s[1]) {\n\t\t\tmemcpy (p, pfx, pfx_len);\n\t\t\tp += pfx_len;\n\t\t}\n\t}\n\t*p = 0;\n\treturn o;\n}\n\n#define HASCH(x) strchr (input_value,x)\n#define CAST (void*)(size_t)\nR_API ut8 r_str_contains_macro(const char *input_value) {\n\tchar *has_tilde = input_value ? HASCH('~') : NULL,\n\t\t *has_bang = input_value ? HASCH('!') : NULL,\n\t\t *has_brace = input_value ? CAST(HASCH('[') || HASCH(']')) : NULL,\n\t\t *has_paren = input_value ? CAST(HASCH('(') || HASCH(')')) : NULL,\n\t\t *has_cbrace = input_value ? CAST(HASCH('{') || HASCH('}')) : NULL,\n\t\t *has_qmark = input_value ? HASCH('?') : NULL,\n\t\t *has_colon = input_value ? HASCH(':') : NULL,\n\t\t *has_at = input_value ? strchr (input_value, '@') : NULL;\n\n\treturn has_tilde || has_bang || has_brace || has_cbrace || has_qmark \\\n\t\t|| has_paren || has_colon || has_at;\n}\n\nR_API void r_str_truncate_cmd(char *string) {\n\tut32 pos = 0;\n\tif (string && *string) {\n\t\tut32 sz = strlen (string);\n\t\tfor (pos = 0; pos < sz; pos++) {\n\t\t\tswitch (string[pos]) {\n\t\t\tcase '!':\n\t\t\tcase ':':\n\t\t\tcase ';':\n\t\t\tcase '@':\n\t\t\tcase '~':\n\t\t\tcase '(':\n\t\t\tcase '[':\n\t\t\tcase '{':\n\t\t\tcase '?':\n\t\t\t\tstring[pos] = '\\0';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API const char *r_str_closer_chr(const char *b, const char *s) {\n\tconst char *a;\n\twhile (*b) {\n\t\tfor (a = s; *a; a++) {\n\t\t\tif (*b == *a) {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t\tb++;\n\t}\n\treturn NULL;\n}\n\nR_API int r_str_bounds(const char *_str, int *h) {\n\tconst char *str, *ptr;\n\tint W = 0, H = 0;\n\tint cw = 0;\n\n\tif (_str) {\n\t\tptr = str = _str;\n\t\twhile (*str) {\n\t\t\tif (*str == '\\n') {\n\t\t\t\tH++;\n\t\t\t\tcw = r_str_ansi_nlen (ptr, (size_t)(str - ptr));\n\t\t\t\tif (cw > W) {\n\t\t\t\t\tW = cw;\n\t\t\t\t}\n\t\t\t\tcw = 0;\n\t\t\t\tptr = str + 1;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tcw++;\n\t\t}\n\t\tif (*str == '\\n') {// skip last newline\n\t\t\tH--;\n\t\t}\n\t\tif (h) {\n\t\t\t*h = H;\n\t\t}\n\t}\n\treturn W;\n}\n\n/* crop a string like it is in a rectangle with the upper-left corner at (x, y)\n * coordinates and the bottom-right corner at (x2, y2) coordinates. The result\n * is a newly allocated string, that should be deallocated by the user */\nR_API char *r_str_crop(const char *str, unsigned int x, unsigned int y,\n\t\tunsigned int x2, unsigned int y2) {\n\tchar *r, *ret;\n\tunsigned int ch = 0, cw = 0;\n\tif (x2 < 1 || y2 < 1 || !str) {\n\t\treturn strdup (\"\");\n\t}\n\tr = ret = strdup (str);\n\twhile (*str) {\n\t\t/* crop height */\n\t\tif (ch >= y2) {\n\t\t\tr--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*str == '\\n') {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\t*r++ = *str;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tch++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (ch >= y && ch < y2 && cw >= x && cw < x2) {\n\t\t\t\t*r++ = *str;\n\t\t\t}\n\t\t\t/* crop width */\n\t\t\t/* skip until newline */\n\t\t\tif (cw >= x2) {\n\t\t\t\twhile (*str && *str != '\\n') {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tcw++;\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\nR_API const char * r_str_tok(const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p || !*p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p == b) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == len) {\n\t\tp = NULL;\n\t}\n\treturn p;\n}\n\nR_API int r_str_do_until_token(str_operation op, char *str, const char tok) {\n\tint ret;\n\tif (!str) {\n\t\treturn -1;\n\t}\n\tif (!op) {\n\t\tfor (ret = 0; (str[ret] != tok) && str[ret]; ret++) {\n\t\t\t//empty body\n\t\t}\n\t} else {\n\t\tfor (ret = 0; (str[ret] != tok) && str[ret]; ret++) {\n\t\t\top (str + ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API const char *r_str_pad(const char ch, int sz) {\n\tstatic char pad[1024];\n\tif (sz < 0) {\n\t\tsz = 0;\n\t}\n\tmemset (pad, ch, R_MIN (sz, sizeof (pad)));\n\tif (sz < sizeof (pad)) {\n\t\tpad[sz] = 0;\n\t}\n\tpad[sizeof(pad) - 1] = 0;\n\treturn pad;\n}\n\nR_API char *r_str_repeat(const char *ch, int sz) {\n\tint i;\n\tif (sz < 0) {\n\t\tsz = 0;\n\t}\n\tif (sz == 0) {\n\t\treturn strdup (\"\");\n\t}\n\tRStrBuf *buf = r_strbuf_new (ch);\n\tfor (i = 1; i < sz; i++) {\n\t\tr_strbuf_append (buf, ch);\n\t}\n\treturn r_strbuf_drain (buf);\n}\n\nR_API char *r_str_between(const char *cmt, const char *prefix, const char *suffix) {\n\tchar *c0, *c1;\n\tif (!cmt || !prefix || !suffix || !*cmt) {\n\t\treturn NULL;\n\t}\n\tc0 = strstr (cmt, prefix);\n\tif (c0) {\n\t\tc1 = strstr (c0 + strlen (prefix), suffix);\n\t\tif (c1) {\n\t\t\treturn r_str_ndup (c0 + strlen (prefix), (c1 - c0 - strlen (prefix)));\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API bool r_str_startswith(const char *str, const char *needle) {\n\tr_return_val_if_fail (str && needle, false);\n\tif (str == needle) {\n\t\treturn true;\n\t}\n\treturn !strncmp (str, needle, strlen (needle));\n}\n\nR_API bool r_str_endswith(const char *str, const char *needle) {\n\tr_return_val_if_fail (str && needle, false);\n\tif (!*needle) {\n\t\treturn true;\n\t}\n\tint slen = strlen (str);\n\tint nlen = strlen (needle);\n\tif (!slen || !nlen || slen < nlen) {\n\t\treturn false;\n\t}\n\treturn !strcmp (str + (slen - nlen), needle);\n}\n\n// Splits the string <str> by string <c> and returns the result in a list.\nR_API RList *r_str_split_list(char *str, const char *c, int n)  {\n\tr_return_val_if_fail (str && c, NULL);\n\tRList *lst = r_list_newf (NULL);\n\tchar *aux = str;\n\tint i = 0;\n\tchar  *e = aux;\n\tfor (;e;) {\n\t\te = strstr (aux, c);\n\t\tif (n > 0) {\n\t\t\tif (++i > n) {\n\t\t\t\tr_list_append (lst, aux);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (e) {\n\t\t\t*e++ =  0;\n\t\t}\n\t\tr_str_trim (aux);\n\t\tr_list_append (lst, aux);\n\t\taux = e;\n\t}\n\treturn lst;\n}\n\nR_API RList *r_str_split_duplist(const char *_str, const char *c) {\n\tr_return_val_if_fail (_str && c, NULL);\n\tRList *lst = r_list_newf (free);\n\tchar *str = strdup (_str);\n\tchar *aux = str;\n\tsize_t clen = strlen (c);\n\twhile (aux) {\n\t\tchar *next = strstr (aux, c);\n\t\tif (next) {\n\t\t\t*next = '\\0';\n\t\t\tnext += clen;\n\t\t}\n\t\tr_str_trim (aux);\n\t\tr_list_append (lst, strdup (aux));\n\t\taux = next;\n\t}\n\tfree (str);\n\treturn lst;\n}\n\nR_API int *r_str_split_lines(char *str, int *count) {\n\tint i;\n\tint lines = 0;\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tint *indexes = NULL;\n\t// count lines\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '\\n') {\n\t\t\tlines++;\n\t\t}\n\t}\n\t// allocate and set indexes\n\tindexes = calloc (sizeof (int), lines + 1);\n\tif (!indexes) {\n\t\treturn NULL;\n\t}\n\tint line = 0;\n\tindexes[line++] = 0;\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '\\n') {\n\t\t\tstr[i] = 0;\n\t\t\tindexes[line++] = i + 1;\n\t\t}\n\t}\n\tif (count) {\n\t\t*count = line;\n\t}\n\treturn indexes;\n}\n\nR_API bool r_str_isnumber(const char *str) {\n\tif (!str || !*str) {\n\t\treturn false;\n\t}\n\tbool isnum = IS_DIGIT (*str) || *str == '-';\n\twhile (isnum && *++str) {\n\t\tif (!IS_DIGIT (*str)) {\n\t\t\tisnum = false;\n\t\t}\n\t}\n\treturn isnum;\n}\n\n/* TODO: optimize to start searching by the end of the string */\nR_API const char *r_str_last(const char *str, const char *ch) {\n\tchar *ptr, *end = NULL;\n\tif (!str || !ch) {\n\t\treturn NULL;\n\t}\n\tdo {\n\t\tptr = strstr (str, ch);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tend = ptr;\n\t\tstr = ptr + 1;\n\t} while (true);\n\treturn end;\n}\n\n// copies the WHOLE string but check n against non color code chars only.\nstatic int strncpy_with_color_codes(char *s1, char *s2, int n) {\n\tint i = 0, j = 0;\n\tint count = 0;\n\twhile (s2[j] && count < n) {\n\t\t// detect (consecutive) color codes\n\t\twhile (s2[j] == 0x1b) {\n\t\t\t// copy till 'm'\n\t\t\twhile (s2[j] && s2[j] != 'm') {\n\t\t\t\ts1[i++] = s2[j++];\n\t\t\t}\n\t\t\t// copy 'm'\n\t\t\tif (s2[j]) {\n\t\t\t\ts1[i++] = s2[j++];\n\t\t\t}\n\t\t}\n\t\tif (s2[j]) {\n\t\t\ts1[i++] = s2[j++];\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic int strncmp_skip_color_codes(const char *s1, const char *s2, int n) {\n\tint i = 0, j = 0;\n\tint count = 0;\n\tfor (i = 0, j = 0; s1[i]  && s2[j] && count < n; i++, j++, count++) {\n\t\twhile (s1[i] == 0x1b) {\n\t\t\twhile (s1[i] && s1[i] != 'm') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s1[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\twhile (s2[j] == 0x1b) {\n\t\t\twhile (s2[j] && s2[j] != 'm') {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (s2[j]) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif (s1[i] != s2[j]) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (count < n && s1[i] != s2[j]) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic char *strchr_skip_color_codes(const char *s, int c) {\n\tint i = 0;\n\tfor (i = 0; s[i]; i++) {\n\t\twhile (s[i] && s[i] == 0x1b) {\n\t\t\twhile (s[i] && s[i] != 'm') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (!s[i] || s[i] == (char)c) {\n\t\t\treturn (char*)s + i;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// Global buffer to speed up colorizing performance\n\nR_API char* r_str_highlight(char *str, const char *word, const char *color, const char *color_reset) {\n\tif (!str || !*str) {\n\t\treturn NULL;\n\t}\n\tut32 i = 0, j = 0, to_copy;\n\tchar *start = str;\n\tut32 l_str = strlen (str);\n\tut32 l_reset = strlen (color_reset);\n\tut32 l_color = color? strlen (color): 0;\n\tif (!color) {\n\t\treturn strdup (str);\n\t}\n\tif (!word || !*word) {\n\t\treturn r_str_newf (\"%s%s%s\", color, str, color_reset);\n\t}\n\tut32 l_word = strlen (word);\n\t// XXX don't use static buffers\n\tchar o[1024] = {0};\n\twhile (start && (start < str + l_str)) {\n\t\tint copied = 0;\n\t\t// find first letter\n\t\tstart = strchr_skip_color_codes (str + i, *word);\n\t\tif (start) {\n\t\t\tto_copy = start - (str + i);\n\t\t\tif (to_copy + j + 1 > sizeof (o)) {\n\t\t\t\t// XXX. no limits\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (o + j, str + i, to_copy);\n\t\t\ti += to_copy;\n\t\t\tj += to_copy;\n\t\t\tif (!strncmp_skip_color_codes (start, word, l_word)) {\n\t\t\t\tif (j + strlen (color) >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (o + j, color);\n\t\t\t\tj += l_color;\n\t\t\t\tif (j + l_word >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcopied = strncpy_with_color_codes (o + j, str + i, l_word);\n\t\t\t\ti += copied;\n\t\t\t\tj += copied;\n\t\t\t\tif (j + strlen (color_reset) >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (o + j, color_reset);\n\t\t\t\tj += l_reset;\n\t\t\t} else {\n\t\t\t\to[j++] = str[i++];\n\t\t\t}\n\t\t} else {\n\t\t\tif (j + strlen (str + i) >= sizeof (o)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcpy (o + j, str + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn strdup (o);\n}\n\nR_API wchar_t* r_str_mb_to_wc_l(const char *buf, int len) {\n\twchar_t *res_buf = NULL;\n\tsize_t sz;\n\tbool fail = true;\n\n\tif (!buf || len <= 0) {\n\t\treturn NULL;\n\t}\n\tsz = mbstowcs (NULL, buf, len);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tres_buf = (wchar_t *)calloc (1, (sz + 1) * sizeof (wchar_t));\n\tif (!res_buf) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tsz = mbstowcs (res_buf, buf, sz + 1);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tfail = false;\nerr_r_str_mb_to_wc:\n\tif (fail) {\n\t\tR_FREE (res_buf);\n\t}\n\treturn res_buf;\n}\n\nR_API char* r_str_wc_to_mb_l(const wchar_t *buf, int len) {\n\tchar *res_buf = NULL;\n\tbool fail = true;\n\tsize_t sz;\n\n\tif (!buf || len <= 0) {\n\t\treturn NULL;\n\t}\n\tsz = wcstombs (NULL, buf, len);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tres_buf = (char *)calloc (1, (sz + 1) * sizeof (char));\n\tif (!res_buf) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tsz = wcstombs (res_buf, buf, sz + 1);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tfail = false;\nerr_r_str_wc_to_mb:\n\tif (fail) {\n\t\tR_FREE (res_buf);\n\t}\n\treturn res_buf;\n}\n\nR_API char* r_str_wc_to_mb(const wchar_t *buf) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\treturn r_str_wc_to_mb_l (buf, wcslen (buf));\n}\n\nR_API wchar_t* r_str_mb_to_wc(const char *buf) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\treturn r_str_mb_to_wc_l (buf, strlen (buf));\n}\n\nR_API char *r_str_from_ut64(ut64 val) {\n\tint i = 0;\n\tchar *v = (char *)&val;\n\tchar *str = (char *)calloc(1, 9);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\twhile (i < 8 && *v) {\n\t\tstr[i++] = *v++;\n\t}\n\treturn str;\n}\n\nR_API int r_snprintf(char *string, int len, const char *fmt, ...) {\n\tva_list ap;\n\tva_start (ap, fmt);\n\tint ret = vsnprintf (string, len, fmt, ap);\n\tstring[len - 1] = 0;\n\tva_end (ap);\n\treturn ret;\n}\n\n// Strips all the lines in str that contain key\nR_API void r_str_stripLine(char *str, const char *key) {\n\tsize_t i, j, klen, slen, off;\n\tconst char *ptr;\n\n\tif (!str || !key) {\n\t\treturn;\n\t}\n\tklen = strlen (key);\n\tslen = strlen (str);\n\n\tfor (i = 0; i < slen; ) {\n\t\tptr = (char*) r_mem_mem ((ut8*) str + i, slen - i, (ut8*) \"\\n\", 1);\n\t\tif (!ptr) {\n\t\t\tptr = (char*) r_mem_mem ((ut8*) str + i, slen - i, (ut8*) key, klen);\n\t\t\tif (ptr) {\n\t\t\t\tstr[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\toff = (size_t) (ptr - (str + i)) + 1;\n\n\t\tptr = (char*) r_mem_mem ((ut8*) str + i, off, (ut8*) key, klen);\n\t\tif (ptr) {\n\t\t\tfor (j = i; j < slen - off + 1; j++) {\n\t\t\t\tstr[j] = str[j + off];\n\t\t\t}\n\t\t\tslen -= off;\n\t\t} else {\n\t\t\ti += off;\n\t\t}\n\t}\n}\n\nR_API char *r_str_list_join(RList *str, const char *sep) {\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tconst char *p;\n\twhile ((p = r_list_pop_head (str))) {\n\t\tif (r_strbuf_length (sb) != 0) {\n\t\t\tr_strbuf_append (sb, sep);\n\t\t}\n\t\tr_strbuf_append (sb, p);\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\n/* return the number of arguments expected as extra arguments */\nR_API int r_str_fmtargs(const char *fmt) {\n\tint n = 0;\n\twhile (*fmt) {\n\t\tif (*fmt == '%') {\n\t\t\tif (fmt[1] == '*') {\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t\tfmt++;\n\t}\n\treturn n;\n}\n\n// str-bool\n\n// Returns \"true\" or \"false\" as a string given an input integer. The returned\n// value is consistent with C's definition of 0 is false, and all other values\n// are true.\nR_API const char *r_str_bool(int b) {\n\treturn b? \"true\": \"false\";\n}\n\nR_API bool r_str_is_true(const char *s) {\n\treturn !r_str_casecmp (\"yes\", s)\n\t\t|| !r_str_casecmp (\"on\", s)\n\t\t|| !r_str_casecmp (\"true\", s)\n\t\t|| !r_str_casecmp (\"1\", s);\n}\n\nR_API bool r_str_is_false(const char *s) {\n\treturn !r_str_casecmp (\"no\", s)\n\t\t|| !r_str_casecmp (\"off\", s)\n\t\t|| !r_str_casecmp (\"false\", s)\n\t\t|| !r_str_casecmp (\"0\", s)\n\t\t|| !*s;\n}\n\nR_API bool r_str_is_bool(const char *val) {\n\treturn r_str_is_true (val) || r_str_is_false (val);\n}\n\nR_API char *r_str_nextword(char *s, char ch) {\n\tchar *p = strchr (s, ch);\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\t*p++ = 0;\n\treturn p;\n}\n\nR_API char *r_str_scale(const char *s, int w, int h) {\n\t// count lines and rows in (s) string\n\t// compute how many lines we should remove or combine\n\t// return a string containing\n\t// for now this function is ascii only (no utf8 or ansi escapes)\n\tRListIter *iter;\n\tchar *line;\n\tchar *str = strdup (s);\n\tRList *lines = r_str_split_list (str, \"\\n\", 0);\n\tint i, j;\n\tint rows = 0;\n\tint maxcol = 0;\n\n\trows = r_list_length (lines);\n\tr_list_foreach (lines, iter, line) {\n\t\tmaxcol = R_MAX (strlen (line), maxcol);\n\t}\n\n\tRList *out = r_list_newf (free);\n\n\tint curline = -1;\n\tchar *linetext = (char*)r_str_pad (' ', w);\n\tfor (i = 0; i < h; i++) {\n\t\tint zoomedline = i * ((float)rows / h);\n\t\tconst char *srcline = r_list_get_n (lines, zoomedline);\n\t\tint cols = strlen (srcline);\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tint zoomedcol = j * ( (float)cols / w);\n\t\t\tlinetext[j] = srcline[zoomedcol];\n\t\t}\n\t\tif (curline != zoomedline) {\n\t\t\tr_list_append (out, strdup (linetext));\n\t\t\tcurline = zoomedline;\n\t\t}\n\t\tmemset (linetext, ' ', w);\n\t}\n\tfree (str);\n\treturn r_str_list_join (out, \"\\n\");\n}\n\nR_API const char *r_str_str_xy(const char *s, const char *word, const char *prev, int *x, int *y) {\n\tr_return_val_if_fail (s && word && x && y, NULL);\n\tr_return_val_if_fail (word[0] != '\\0' && word[0] != '\\n', NULL);\n\tconst char *src = prev ? prev + 1 : s;\n\tconst char *d = strstr (src, word);\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tconst char *q;\n\tfor (q = prev ? prev : s; q < d; q++) {\n\t\tif (*q == '\\n') {\n\t\t\t(*y)++;\n\t\t\t*x = 0;\n\n\t\t} else {\n\t\t\t(*x)++;\n\t\t}\n\t}\n\treturn d;\n}\n\n// version.c\n#include <r_userconf.h>\n#include <r_util.h>\n\n#ifndef R2_GITTAP\n#define R2_GITTAP \"\"\n#endif\n\n#ifndef R2_GITTIP\n#define R2_GITTIP \"\"\n#endif\n\n#ifndef R2_BIRTH\n#define R2_BIRTH \"unknown\"\n#endif\n\nR_API char *r_str_version(const char *program) {\n\tchar *s = r_str_newf (\"%s \"R2_VERSION\" %d @ \"\n\t\t\tR_SYS_OS\"-\"\n\t\t\tR_SYS_ARCH\"-%d git.%s\\n\",\n\t\t\tprogram, R2_VERSION_COMMIT,\n\t\t\t(R_SYS_BITS & 8)? 64: 32,\n\t\t\t*R2_GITTAP ? R2_GITTAP: \"\");\n\tif (*R2_GITTIP) {\n\t\ts = r_str_appendf (s, \"commit: \"R2_GITTIP\" build: \"R2_BIRTH);\n\t}\n\treturn s;\n}\n", "/* radare - LGPL - Copyright 2009-2020 - pancake */\n\n#if __linux__\n#include <time.h>\n#endif\n\n#include <r_userconf.h>\n#include <stdlib.h>\n#include <string.h>\n#if defined(__NetBSD__)\n# include <sys/param.h>\n# if __NetBSD_Prereq__(7,0,0)\n#  define NETBSD_WITH_BACKTRACE\n# endif\n#endif\n#if defined(__FreeBSD__)\n# include <sys/param.h>\n# include <sys/sysctl.h>\n# if __FreeBSD_version >= 1000000\n#  define FREEBSD_WITH_BACKTRACE\n# endif\n#endif\n#include <sys/types.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n\nstatic char** env = NULL;\n\n#if (__linux__ && __GNU_LIBRARY__) || defined(NETBSD_WITH_BACKTRACE) || \\\n  defined(FREEBSD_WITH_BACKTRACE) || __DragonFly__\n# include <execinfo.h>\n#endif\n#if __APPLE__\n#include <errno.h>\n#ifdef __MAC_10_8\n#define HAVE_ENVIRON 1\n#else\n#define HAVE_ENVIRON 0\n#endif\n\n#if HAVE_ENVIRON\n#include <execinfo.h>\n#endif\n// iOS don't have this we can't hardcode\n// #include <crt_externs.h>\nextern char ***_NSGetEnviron(void);\n# ifndef PROC_PIDPATHINFO_MAXSIZE\n#  define PROC_PIDPATHINFO_MAXSIZE 1024\nint proc_pidpath(int pid, void * buffer, ut32 buffersize);\n//#  include <libproc.h>\n# endif\n#endif\n#if __UNIX__\n# include <sys/utsname.h>\n# include <sys/wait.h>\n# include <sys/stat.h>\n# include <errno.h>\n# include <signal.h>\nextern char **environ;\n\n#ifdef __HAIKU__\n# define Sleep sleep\n#endif\n#endif\n#if __WINDOWS__\n# include <io.h>\n# include <winbase.h>\n# include <signal.h>\n#define TMP_BUFSIZE\t4096\n#ifdef _MSC_VER\n#include <psapi.h>\n#include <process.h>  // to allow getpid under windows msvc compilation\n#include <direct.h>  // to allow getcwd under windows msvc compilation\n#endif\n#endif\n\nR_LIB_VERSION(r_util);\n\n#ifdef __x86_64__\n# ifdef _MSC_VER\n#  define R_SYS_ASM_START_ROP() \\\n\t eprintf (\"r_sys_run_rop: Unsupported arch\\n\");\n# else\n#  define R_SYS_ASM_START_ROP() \\\n\t __asm__ __volatile__ (\"leaq %0, %%rsp; ret\" \\\n\t\t\t\t: \\\n\t\t\t\t: \"m\" (*bufptr));\n# endif\n#elif __i386__\n# ifdef _MSC_VER\n#  define R_SYS_ASM_START_ROP() \\\n\t__asm \\\n\t{ \\\n\t\t__asm lea esp, bufptr\\\n\t\t__asm ret\\\n\t}\n# else\n#  define R_SYS_ASM_START_ROP() \\\n\t__asm__ __volatile__ (\"leal %0, %%esp; ret\" \\\n\t\t\t\t: \\\n\t\t\t\t: \"m\" (*bufptr));\n# endif\n#else\n# define R_SYS_ASM_START_ROP() \\\n\teprintf (\"r_sys_run_rop: Unsupported arch\\n\");\n#endif\n\nstatic const struct {const char* name; ut64 bit;} arch_bit_array[] = {\n    {\"x86\", R_SYS_ARCH_X86},\n    {\"arm\", R_SYS_ARCH_ARM},\n    {\"ppc\", R_SYS_ARCH_PPC},\n    {\"m68k\", R_SYS_ARCH_M68K},\n    {\"java\", R_SYS_ARCH_JAVA},\n    {\"mips\", R_SYS_ARCH_MIPS},\n    {\"sparc\", R_SYS_ARCH_SPARC},\n    {\"xap\", R_SYS_ARCH_XAP},\n    {\"tms320\", R_SYS_ARCH_TMS320},\n    {\"msil\", R_SYS_ARCH_MSIL},\n    {\"objd\", R_SYS_ARCH_OBJD},\n    {\"bf\", R_SYS_ARCH_BF},\n    {\"sh\", R_SYS_ARCH_SH},\n    {\"avr\", R_SYS_ARCH_AVR},\n    {\"dalvik\", R_SYS_ARCH_DALVIK},\n    {\"z80\", R_SYS_ARCH_Z80},\n    {\"arc\", R_SYS_ARCH_ARC},\n    {\"i8080\", R_SYS_ARCH_I8080},\n    {\"rar\", R_SYS_ARCH_RAR},\n    {\"lm32\", R_SYS_ARCH_LM32},\n    {\"v850\", R_SYS_ARCH_V850},\n    {NULL, 0}\n};\n\nR_API int r_sys_fork() {\n#if HAVE_FORK\n#if __WINDOWS__\n\treturn -1;\n#else\n\treturn fork ();\n#endif\n#else\n\treturn -1;\n#endif\n}\n\n#if HAVE_SIGACTION\nR_API int r_sys_sigaction(int *sig, void (*handler) (int)) {\n\tstruct sigaction sigact = { };\n\tint ret, i;\n\n\tif (!sig) {\n\t\treturn -EINVAL;\n\t}\n\n\tsigact.sa_handler = handler;\n\tsigemptyset (&sigact.sa_mask);\n\n\tfor (i = 0; sig[i] != 0; i++) {\n\t\tsigaddset (&sigact.sa_mask, sig[i]);\n\t}\n\n\tfor (i = 0; sig[i] != 0; i++) {\n\t\tret = sigaction (sig[i], &sigact, NULL);\n\t\tif (ret) {\n\t\t\teprintf (\"Failed to set signal handler for signal '%d': %s\\n\", sig[i], strerror(errno));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#else\nR_API int r_sys_sigaction(int *sig, void (*handler) (int)) {\n\tint ret, i;\n\n\tif (!sig) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; sig[i] != 0; i++) {\n\t\tret = signal (sig[i], handler);\n\t\tif (ret == SIG_ERR) {\n\t\t\teprintf (\"Failed to set signal handler for signal '%d': %s\\n\", sig[i], strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nR_API int r_sys_signal(int sig, void (*handler) (int)) {\n\tint s[2] = { sig, 0 };\n\treturn r_sys_sigaction (s, handler);\n}\n\nR_API void r_sys_exit(int status, bool nocleanup) {\n\tif (nocleanup) {\n\t\t_exit (status);\n\t} else {\n\t\texit (status);\n\t}\n}\n\n/* TODO: import stuff from bininfo/p/bininfo_addr2line */\n/* TODO: check endianness issues here */\nR_API ut64 r_sys_now(void) {\n\tut64 ret;\n\tstruct timeval now;\n\tgettimeofday (&now, NULL);\n\tret = now.tv_sec;\n\tret <<= 20;\n\tret |= now.tv_usec;\n\t//(sizeof (now.tv_sec) == 4\n\treturn ret;\n}\n\nR_API int r_sys_truncate(const char *file, int sz) {\n#if __WINDOWS__\n\tint fd = r_sandbox_open (file, O_RDWR, 0644);\n\tif (fd == -1) {\n\t\treturn false;\n\t}\n#ifdef _MSC_VER\n\tint r = _chsize (fd, sz);\n#else\n\tint r = ftruncate (fd, sz);\n#endif\n\tif (r != 0) {\n\t\teprintf (\"Could not resize '%s' file\\n\", file);\n\t\tclose (fd);\n\t\treturn false;\n\t}\n\tclose (fd);\n\treturn true;\n#else\n\tif (r_sandbox_enable (0)) {\n\t\treturn false;\n\t}\n\treturn truncate (file, sz) == 0;\n#endif\n}\n\nR_API RList *r_sys_dir(const char *path) {\n\tRList *list = NULL;\n#if __WINDOWS__\n\tWIN32_FIND_DATAW entry;\n\tchar *cfname;\n\tHANDLE fh = r_sandbox_opendir (path, &entry);\n\tif (fh == INVALID_HANDLE_VALUE) {\n\t\t//IFDGB eprintf (\"Cannot open directory %ls\\n\", wcpath);\n\t\treturn list;\n\t}\n\tlist = r_list_newf (free);\n\tif (list) {\n\t\tdo {\n\t\t\tif ((cfname = r_utf16_to_utf8 (entry.cFileName))) {\n\t\t\t\tr_list_append (list, strdup (cfname));\n\t\t\t\tfree (cfname);\n\t\t\t}\n\t\t} while (FindNextFileW (fh, &entry));\n\t}\n\tFindClose (fh);\n#else\n\tstruct dirent *entry;\n\tDIR *dir = r_sandbox_opendir (path);\n\tif (dir) {\n\t\tlist = r_list_new ();\n\t\tif (list) {\n\t\t\tlist->free = free;\n\t\t\twhile ((entry = readdir (dir))) {\n\t\t\t\tr_list_append (list, strdup (entry->d_name));\n\t\t\t}\n\t\t}\n\t\tclosedir (dir);\n\t}\n#endif\n\treturn list;\n}\n\nR_API char *r_sys_cmd_strf(const char *fmt, ...) {\n\tchar *ret, cmd[4096];\n\tva_list ap;\n\tva_start (ap, fmt);\n\tvsnprintf (cmd, sizeof (cmd), fmt, ap);\n\tret = r_sys_cmd_str (cmd, NULL, NULL);\n\tva_end (ap);\n\treturn ret;\n}\n\n#ifdef __MAC_10_7\n#define APPLE_WITH_BACKTRACE 1\n#endif\n#ifdef __IPHONE_4_0\n#define APPLE_WITH_BACKTRACE 1\n#endif\n\n#if (__linux__ && __GNU_LIBRARY__) || (__APPLE__ && APPLE_WITH_BACKTRACE) || \\\n  defined(NETBSD_WITH_BACKTRACE) || defined(FREEBSD_WITH_BACKTRACE) || \\\n  __DragonFly__\n#define HAVE_BACKTRACE 1\n#endif\n\nR_API void r_sys_backtrace(void) {\n#ifdef HAVE_BACKTRACE\n\tvoid *array[10];\n\tsize_t size = backtrace (array, 10);\n\teprintf (\"Backtrace %zd stack frames.\\n\", size);\n\tbacktrace_symbols_fd (array, size, 2);\n#elif __APPLE__\n\tvoid **fp = (void **) __builtin_frame_address (0);\n\tvoid *saved_pc = __builtin_return_address (0);\n\tvoid *saved_fp = __builtin_frame_address (1);\n\tint depth = 0;\n\n\tprintf (\"[%d] pc == %p fp == %p\\n\", depth++, saved_pc, saved_fp);\n\tfp = saved_fp;\n\twhile (fp) {\n\t\tsaved_fp = *fp;\n\t\tfp = saved_fp;\n\t\tif (!*fp) {\n\t\t\tbreak;\n\t\t}\n\t\tsaved_pc = *(fp + 2);\n\t\tprintf (\"[%d] pc == %p fp == %p\\n\", depth++, saved_pc, saved_fp);\n\t}\n#else\n#ifdef _MSC_VER\n#pragma message (\"TODO: r_sys_bt : unimplemented\")\n#else\n#warning TODO: r_sys_bt : unimplemented\n#endif\n#endif\n}\n\nR_API int r_sys_sleep(int secs) {\n#if HAS_CLOCK_NANOSLEEP\n\tstruct timespec rqtp;\n\trqtp.tv_sec = secs;\n\trqtp.tv_nsec = 0;\n\treturn clock_nanosleep (CLOCK_MONOTONIC, 0, &rqtp, NULL);\n#elif __UNIX__\n\treturn sleep (secs);\n#else\n\tSleep (secs * 1000); // W32\n\treturn 0;\n#endif\n}\n\nR_API int r_sys_usleep(int usecs) {\n#if HAS_CLOCK_NANOSLEEP\n\tstruct timespec rqtp;\n\trqtp.tv_sec = usecs / 1000000;\n\trqtp.tv_nsec = (usecs - (rqtp.tv_sec * 1000000)) * 1000;\n\treturn clock_nanosleep (CLOCK_MONOTONIC, 0, &rqtp, NULL);\n#elif __UNIX__\n\treturn usleep (usecs);\n#else\n\t// w32 api uses milliseconds\n\tusecs /= 1000;\n\tSleep (usecs); // W32\n\treturn 0;\n#endif\n}\n\nR_API int r_sys_clearenv(void) {\n#if __UNIX__\n#if __APPLE__ && !HAVE_ENVIRON\n\t/* do nothing */\n\tif (!env) {\n\t\tenv = r_sys_get_environ ();\n\t\treturn 0;\n\t}\n\tif (env) {\n\t\tchar **e = env;\n\t\twhile (*e) {\n\t\t\t*e++ = NULL;\n\t\t}\n\t}\n#else\n\tif (!environ) {\n\t\treturn 0;\n\t}\n\twhile (*environ) {\n\t\t*environ++ = NULL;\n\t}\n#endif\n\treturn 0;\n#else\n#ifdef _MSC_VER\n#pragma message (\"r_sys_clearenv : unimplemented for this platform\")\n#else\n#warning r_sys_clearenv : unimplemented for this platform\n#endif\n\treturn 0;\n#endif\n}\n\nR_API int r_sys_setenv(const char *key, const char *value) {\n\tif (!key) {\n\t\treturn 0;\n\t}\n#if __UNIX__\n\tif (!value) {\n\t\tunsetenv (key);\n\t\treturn 0;\n\t}\n\treturn setenv (key, value, 1);\n#elif __WINDOWS__\n\tLPTSTR key_ = r_sys_conv_utf8_to_win (key);\n\tLPTSTR value_ = r_sys_conv_utf8_to_win (value);\n\tint ret = SetEnvironmentVariable (key_, value_);\n\tif (!ret) {\n\t\tr_sys_perror (\"r_sys_setenv/SetEnvironmentVariable\");\n\t}\n\tfree (key_);\n\tfree (value_);\n\treturn ret ? 0 : -1;\n#else\n#warning r_sys_setenv : unimplemented for this platform\n\treturn 0;\n#endif\n}\n\n#if __UNIX__\nstatic char *crash_handler_cmd = NULL;\n\nstatic void signal_handler(int signum) {\n\tchar cmd[1024];\n\tif (!crash_handler_cmd) {\n\t\treturn;\n\t}\n\tsnprintf (cmd, sizeof(cmd) - 1, crash_handler_cmd, getpid ());\n\tr_sys_backtrace ();\n\texit (r_sys_cmd (cmd));\n}\n\nstatic int checkcmd(const char *c) {\n\tchar oc = 0;\n\tfor (;*c;c++) {\n\t\tif (oc == '%') {\n\t\t\tif (*c != 'd' && *c != '%') {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\toc = *c;\n\t}\n\treturn 1;\n}\n#endif\n\nR_API int r_sys_crash_handler(const char *cmd) {\n#ifndef __WINDOWS__\n\tint sig[] = { SIGINT, SIGSEGV, SIGBUS, SIGQUIT, SIGHUP, 0 };\n\n\tif (!checkcmd (cmd)) {\n\t\treturn false;\n\t}\n#ifdef HAVE_BACKTRACE\n\tvoid *array[1];\n\t/* call this outside of the signal handler to init it safely */\n\tbacktrace (array, 1);\n#endif\n\n\tfree (crash_handler_cmd);\n\tcrash_handler_cmd = strdup (cmd);\n\n\tr_sys_sigaction (sig, signal_handler);\n#else\n#pragma message (\"r_sys_crash_handler : unimplemented for this platform\")\n#endif\n\treturn true;\n}\n\nR_API char *r_sys_getenv(const char *key) {\n#if __WINDOWS__\n\tDWORD dwRet;\n\tLPTSTR envbuf = NULL, key_ = NULL, tmp_ptr;\n\tchar *val = NULL;\n\n\tif (!key) {\n\t\treturn NULL;\n\t}\n\tenvbuf = (LPTSTR)malloc (sizeof (TCHAR) * TMP_BUFSIZE);\n\tif (!envbuf) {\n\t\tgoto err_r_sys_get_env;\n\t}\n\tkey_ = r_sys_conv_utf8_to_win (key);\n\tdwRet = GetEnvironmentVariable (key_, envbuf, TMP_BUFSIZE);\n\tif (dwRet == 0) {\n\t\tif (GetLastError () == ERROR_ENVVAR_NOT_FOUND) {\n\t\t\tgoto err_r_sys_get_env;\n\t\t}\n\t} else if (TMP_BUFSIZE < dwRet) {\n\t\ttmp_ptr = (LPTSTR)realloc (envbuf, dwRet * sizeof (TCHAR));\n\t\tif (!tmp_ptr) {\n\t\t\tgoto err_r_sys_get_env;\n\t\t}\n\t\tenvbuf = tmp_ptr;\n\t\tdwRet = GetEnvironmentVariable (key_, envbuf, dwRet);\n\t\tif (!dwRet) {\n\t\t\tgoto err_r_sys_get_env;\n\t\t}\n\t}\n\tval = r_sys_conv_win_to_utf8_l (envbuf, (int)dwRet);\nerr_r_sys_get_env:\n\tfree (key_);\n\tfree (envbuf);\n\treturn val;\n#else\n\tchar *b;\n\tif (!key) {\n\t\treturn NULL;\n\t}\n\tb = getenv (key);\n\treturn b? strdup (b): NULL;\n#endif\n}\n\nR_API bool r_sys_getenv_asbool(const char *key) {\n\tchar *env = r_sys_getenv (key);\n\tconst bool res = (env && *env == '1');\n\tfree (env);\n\treturn res;\n}\n\nR_API char *r_sys_getdir(void) {\n#if __WINDOWS__\n\treturn _getcwd (NULL, 0);\n#else\n\treturn getcwd (NULL, 0);\n#endif\n}\n\nR_API int r_sys_chdir(const char *s) {\n\treturn r_sandbox_chdir (s)==0;\n}\n\nR_API bool r_sys_aslr(int val) {\n\tbool ret = true;\n#if __linux__\n\tconst char *rva = \"/proc/sys/kernel/randomize_va_space\";\n\tchar buf[3] = {0};\n\tsnprintf(buf, sizeof (buf), \"%d\\n\", val != 0 ? 2 : 0);\n\tint fd = r_sandbox_open (rva, O_WRONLY, 0644);\n\tif (fd != -1) {\n\t\tif (r_sandbox_write (fd, (ut8 *)buf, sizeof (buf)) != sizeof (buf)) {\n\t\t\teprintf (\"Failed to set RVA\\n\");\n\t\t\tret = false;\n\t\t}\n\t\tclose (fd);\n\t}\n#elif __FreeBSD__ && __FreeBSD_version >= 1300000\n\tsize_t vlen = sizeof (val);\n\tif (sysctlbyname (\"kern.elf32.aslr.enable\", NULL, 0, &val, vlen) == -1) {\n\t\teprintf (\"Failed to set RVA 32 bits\\n\");\n\t\treturn false;\n\t}\n\n#if __LP64__\n\tif (sysctlbyname (\"kern.elf64.aslr.enable\", NULL, 0, &val, vlen) == -1) {\n\t\teprintf (\"Failed to set RVA 64 bits\\n\");\n\t\tret = false;\n\t}\n#endif\n#endif\n\treturn ret;\n}\n\nR_API int r_sys_thp_mode(void) {\n#if __linux__\n\tconst char *thp = \"/sys/kernel/mm/transparent_hugepage/enabled\";\n\tint ret = 0;\n\tchar *val = r_file_slurp (thp, NULL);\n\tif (val) {\n\t\tif (strstr (val, \"[madvise]\")) {\n\t\t\tret = 1;\n\t\t} else if (strstr (val, \"[always]\")) {\n\t\t\tret = 2;\n\t\t}\n\t\tfree (val);\n\t}\n\n\treturn ret;\n#else\n  return 0;\n#endif\n}\n\n#if __UNIX__\nR_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {\n\tchar *mysterr = NULL;\n\tif (!sterr) {\n\t\tsterr = &mysterr;\n\t}\n\tchar buffer[1024], *outputptr = NULL;\n\tchar *inputptr = (char *)input;\n\tint pid, bytes = 0, status;\n\tint sh_in[2], sh_out[2], sh_err[2];\n\n\tif (len) {\n\t\t*len = 0;\n\t}\n\tif (pipe (sh_in)) {\n\t\treturn false;\n\t}\n\tif (output) {\n\t\tif (pipe (sh_out)) {\n\t\t\tclose (sh_in[0]);\n\t\t\tclose (sh_in[1]);\n\t\t\tclose (sh_out[0]);\n\t\t\tclose (sh_out[1]);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (pipe (sh_err)) {\n\t\tclose (sh_in[0]);\n\t\tclose (sh_in[1]);\n\t\treturn false;\n\t}\n\n\tswitch ((pid = r_sys_fork ())) {\n\tcase -1:\n\t\treturn false;\n\tcase 0:\n\t\tdup2 (sh_in[0], 0);\n\t\tclose (sh_in[0]);\n\t\tclose (sh_in[1]);\n\t\tif (output) {\n\t\t\tdup2 (sh_out[1], 1);\n\t\t\tclose (sh_out[0]);\n\t\t\tclose (sh_out[1]);\n\t\t}\n\t\tif (sterr) {\n\t\t\tdup2 (sh_err[1], 2);\n\t\t} else {\n\t\t\tclose (2);\n\t\t}\n\t\tclose (sh_err[0]);\n\t\tclose (sh_err[1]);\n\t\texit (r_sandbox_system (cmd, 0));\n\tdefault:\n\t\toutputptr = strdup (\"\");\n\t\tif (!outputptr) {\n\t\t\treturn false;\n\t\t}\n\t\tif (sterr) {\n\t\t\t*sterr = strdup (\"\");\n\t\t\tif (!*sterr) {\n\t\t\t\tfree (outputptr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (output) {\n\t\t\tclose (sh_out[1]);\n\t\t}\n\t\tclose (sh_err[1]);\n\t\tclose (sh_in[0]);\n\t\tif (!inputptr || !*inputptr) {\n\t\t\tclose (sh_in[1]);\n\t\t}\n\t\t// we should handle broken pipes somehow better\n\t\tr_sys_signal (SIGPIPE, SIG_IGN);\n\t\tsize_t err_len = 0, out_len = 0;\n\t\tfor (;;) {\n\t\t\tfd_set rfds, wfds;\n\t\t\tint nfd;\n\t\t\tFD_ZERO (&rfds);\n\t\t\tFD_ZERO (&wfds);\n\t\t\tif (output) {\n\t\t\t\tFD_SET (sh_out[0], &rfds);\n\t\t\t}\n\t\t\tif (sterr) {\n\t\t\t\tFD_SET (sh_err[0], &rfds);\n\t\t\t}\n\t\t\tif (inputptr && *inputptr) {\n\t\t\t\tFD_SET (sh_in[1], &wfds);\n\t\t\t}\n\t\t\tmemset (buffer, 0, sizeof (buffer));\n\t\t\tnfd = select (sh_err[0] + 1, &rfds, &wfds, NULL, NULL);\n\t\t\tif (nfd < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (output && FD_ISSET (sh_out[0], &rfds)) {\n\t\t\t\tif ((bytes = read (sh_out[0], buffer, sizeof (buffer))) < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *tmp = realloc (outputptr, out_len + bytes + 1);\n\t\t\t\tif (!tmp) {\n\t\t\t\t\tR_FREE (outputptr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toutputptr = tmp;\n\t\t\t\tmemcpy (outputptr + out_len, buffer, bytes);\n\t\t\t\tout_len += bytes;\n\t\t\t} else if (FD_ISSET (sh_err[0], &rfds) && sterr) {\n\t\t\t\tif ((bytes = read (sh_err[0], buffer, sizeof (buffer))) < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *tmp = realloc (*sterr, err_len + bytes + 1);\n\t\t\t\tif (!tmp) {\n\t\t\t\t\tR_FREE (*sterr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*sterr = tmp;\n\t\t\t\tmemcpy (*sterr + err_len, buffer, bytes);\n\t\t\t\terr_len += bytes;\n\t\t\t} else if (FD_ISSET (sh_in[1], &wfds) && inputptr && *inputptr) {\n\t\t\t\tint inputptr_len = strlen (inputptr);\n\t\t\t\tbytes = write (sh_in[1], inputptr, inputptr_len);\n\t\t\t\tif (bytes != inputptr_len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinputptr += bytes;\n\t\t\t\tif (!*inputptr) {\n\t\t\t\t\tclose (sh_in[1]);\n\t\t\t\t\t/* If neither stdout nor stderr should be captured,\n\t\t\t\t\t * abort now - nothing more to do for select(). */\n\t\t\t\t\tif (!output && !sterr) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (output) {\n\t\t\tclose (sh_out[0]);\n\t\t}\n\t\tclose (sh_err[0]);\n\t\tclose (sh_in[1]);\n\t\twaitpid (pid, &status, 0);\n\t\tbool ret = true;\n\t\tif (status) {\n\t\t\t// char *escmd = r_str_escape (cmd);\n\t\t\t// eprintf (\"error code %d (%s): %s\\n\", WEXITSTATUS (status), escmd, *sterr);\n\t\t\t// eprintf (\"(%s)\\n\", output);\n\t\t\t// eprintf (\"%s: failed command '%s'\\n\", __func__, escmd);\n\t\t\t// free (escmd);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (len) {\n\t\t\t*len = out_len;\n\t\t}\n\t\tif (*sterr) {\n\t\t\t(*sterr)[err_len] = 0;\n\t\t}\n\t\tif (outputptr) {\n\t\t\toutputptr[out_len] = 0;\n\t\t}\n\t\tif (output) {\n\t\t\t*output = outputptr;\n\t\t} else {\n\t\t\tfree (outputptr);\n\t\t}\n\t\treturn ret;\n\t}\n\treturn false;\n}\n#elif __WINDOWS__\nR_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {\n\treturn r_sys_cmd_str_full_w32 (cmd, input, output, len, sterr);\n}\n#else\nR_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {\n\teprintf (\"r_sys_cmd_str: not yet implemented for this platform\\n\");\n\treturn false;\n}\n#endif\n\nR_API int r_sys_cmdf(const char *fmt, ...) {\n\tint ret;\n\tchar cmd[4096];\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvsnprintf (cmd, sizeof (cmd), fmt, ap);\n\tret = r_sys_cmd (cmd);\n\tva_end (ap);\n\treturn ret;\n}\n\nR_API int r_sys_cmdbg (const char *str) {\n#if __UNIX__\n\tint ret, pid = r_sys_fork ();\n\tif (pid == -1) {\n\t\treturn -1;\n\t}\n\tif (pid) {\n\t\treturn pid;\n\t}\n\tret = r_sandbox_system (str, 0);\n\teprintf (\"{exit: %d, pid: %d, cmd: \\\"%s\\\"}\", ret, pid, str);\n\texit (0);\n\treturn -1;\n#else\n#ifdef _MSC_VER\n#pragma message (\"r_sys_cmdbg is not implemented for this platform\")\n#else\n#warning r_sys_cmdbg is not implemented for this platform\n#endif\n\treturn -1;\n#endif\n}\n\nR_API int r_sys_cmd(const char *str) {\n\tif (r_sandbox_enable (0)) {\n\t\treturn false;\n\t}\n\treturn r_sandbox_system (str, 1);\n}\n\nR_API char *r_sys_cmd_str(const char *cmd, const char *input, int *len) {\n\tchar *output = NULL;\n\tif (r_sys_cmd_str_full (cmd, input, &output, len, NULL)) {\n\t\treturn output;\n\t}\n\tfree (output);\n\treturn NULL;\n}\n\nR_API bool r_sys_mkdir(const char *dir) {\n\tbool ret;\n\n\tif (r_sandbox_enable (0)) {\n\t\treturn false;\n\t}\n#if __WINDOWS__\n\tLPTSTR dir_ = r_sys_conv_utf8_to_win (dir);\n\n\tret = CreateDirectory (dir_, NULL) != 0;\n\tfree (dir_);\n#else\n\tret = mkdir (dir, 0755) != -1;\n#endif\n\treturn ret;\n}\n\nR_API bool r_sys_mkdirp(const char *dir) {\n\tbool ret = true;\n\tchar slash = R_SYS_DIR[0];\n\tchar *path = strdup (dir), *ptr = path;\n\tif (!path) {\n\t\teprintf (\"r_sys_mkdirp: Unable to allocate memory\\n\");\n\t\treturn false;\n\t}\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __WINDOWS__\n\t{\n\t\tchar *p = strstr (ptr, \":\\\\\");\n\t\tif (p) {\n\t\t\tptr = p + 3;\n\t\t}\n\t}\n#endif\n\tfor (;;) {\n\t\t// find next slash\n\t\tfor (; *ptr; ptr++) {\n\t\t\tif (*ptr == '/' || *ptr == '\\\\') {\n\t\t\t\tslash = *ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\tfree (path);\n\t\t\treturn false;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\tret = false;\n\t}\n\tfree (path);\n\treturn ret;\n}\n\nR_API void r_sys_perror_str(const char *fun) {\n#if __UNIX__\n#pragma push_macro(\"perror\")\n#undef perror\n\tperror (fun);\n#pragma pop_macro(\"perror\")\n#elif __WINDOWS__\n\tLPTSTR lpMsgBuf;\n\tDWORD dw = GetLastError();\n\n\tif (FormatMessage ( FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\t\t\tFORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\tFORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\tNULL,\n\t\t\tdw,\n\t\t\tMAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t(LPTSTR)&lpMsgBuf,\n\t\t\t0, NULL )) {\n\t\tchar *err = r_sys_conv_win_to_utf8 (lpMsgBuf);\n\t\tif (err) {\n\t\t\teprintf (\"%s: %s\\n\", fun, err);\n\t\t\tfree (err);\n\t\t}\n\t\tLocalFree (lpMsgBuf);\n\t} else {\n\t\teprintf (\"%s\\n\", fun);\n\t}\n#endif\n}\n\nR_API bool r_sys_arch_match(const char *archstr, const char *arch) {\n\tchar *ptr;\n\tif (!archstr || !arch || !*archstr || !*arch) {\n\t\treturn true;\n\t}\n\tif (!strcmp (archstr, \"*\") || !strcmp (archstr, \"any\")) {\n\t\treturn true;\n\t}\n\tif (!strcmp (archstr, arch)) {\n\t\treturn true;\n\t}\n\tif ((ptr = strstr (archstr, arch))) {\n\t\tchar p = ptr[strlen (arch)];\n\t\tif (!p || p==',') {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API int r_sys_arch_id(const char *arch) {\n\tint i;\n\tfor (i = 0; arch_bit_array[i].name; i++) {\n\t\tif (!strcmp (arch, arch_bit_array[i].name)) {\n\t\t\treturn arch_bit_array[i].bit;\n\t\t}\n\t}\n\treturn 0;\n}\n\nR_API const char *r_sys_arch_str(int arch) {\n\tint i;\n\tfor (i = 0; arch_bit_array[i].name; i++) {\n\t\tif (arch & arch_bit_array[i].bit) {\n\t\t\treturn arch_bit_array[i].name;\n\t\t}\n\t}\n\treturn \"none\";\n}\n\n#define USE_FORK 0\nR_API int r_sys_run(const ut8 *buf, int len) {\n\tconst int sz = 4096;\n\tint pdelta, ret, (*cb)();\n#if USE_FORK\n\tint st, pid;\n#endif\n// TODO: define R_SYS_ALIGN_FORWARD in r_util.h\n\tut8 *ptr, *p = malloc ((sz + len) << 1);\n\tptr = p;\n\tpdelta = ((size_t)(p)) & (4096 - 1);\n\tif (pdelta) {\n\t\tptr += (4096 - pdelta);\n\t}\n\tif (!ptr || !buf) {\n\t\teprintf (\"r_sys_run: Cannot run empty buffer\\n\");\n\t\tfree (p);\n\t\treturn false;\n\t}\n\tmemcpy (ptr, buf, len);\n\tr_mem_protect (ptr, sz, \"rx\");\n\t//r_mem_protect (ptr, sz, \"rwx\"); // try, ignore if fail\n\tcb = (int (*)())ptr;\n#if USE_FORK\n#if __UNIX__\n\tpid = r_sys_fork ();\n#else\n\tpid = -1;\n#endif\n\tif (pid < 0) {\n\t\treturn cb ();\n\t}\n\tif (!pid) {\n\t\tret = cb ();\n\t\texit (ret);\n\t\treturn ret;\n\t}\n\tst = 0;\n\twaitpid (pid, &st, 0);\n\tif (WIFSIGNALED (st)) {\n\t\tint num = WTERMSIG(st);\n\t\teprintf (\"Got signal %d\\n\", num);\n\t\tret = num;\n\t} else {\n\t\tret = WEXITSTATUS (st);\n\t}\n#else\n\tret = (*cb) ();\n#endif\n\tfree (p);\n\treturn ret;\n}\n\nR_API int r_sys_run_rop(const ut8 *buf, int len) {\n#if USE_FORK\n\tint st;\n#endif\n\t// TODO: define R_SYS_ALIGN_FORWARD in r_util.h\n\tut8 *bufptr = malloc (len);\n\tif (!bufptr) {\n\t\teprintf (\"r_sys_run_rop: Cannot allocate buffer\\n\");\n\t\treturn false;\n\t}\n\n\tif (!buf) {\n\t\teprintf (\"r_sys_run_rop: Cannot execute empty rop chain\\n\");\n\t\tfree (bufptr);\n\t\treturn false;\n\t}\n\tmemcpy (bufptr, buf, len);\n#if USE_FORK\n#if __UNIX__\n\tpid_t pid = r_sys_fork ();\n#else\n\tpid = -1;\n#endif\n\tif (pid < 0) {\n\t\tR_SYS_ASM_START_ROP ();\n\t} else {\n\t\tR_SYS_ASM_START_ROP ();\n\t\texit (0);\n                return 0;\n\t}\n\tst = 0;\n\tif (waitpid (pid, &st, 0) == -1) {\n            eprintf (\"r_sys_run_rop: waitpid failed\\n\");\n            free (bufptr);\n            return -1;\n        }\n\tif (WIFSIGNALED (st)) {\n\t\tint num = WTERMSIG (st);\n\t\teprintf (\"Got signal %d\\n\", num);\n\t\tret = num;\n\t} else {\n\t\tret = WEXITSTATUS (st);\n\t}\n#else\n\tR_SYS_ASM_START_ROP ();\n#endif\n\tfree (bufptr);\n\treturn 0;\n}\n\nR_API bool r_is_heap (void *p) {\n\tvoid *q = malloc (8);\n\tut64 mask = UT64_MAX;\n\tut64 addr = (ut64)(size_t)q;\n\taddr >>= 16;\n\taddr <<= 16;\n\tmask >>= 16;\n\tmask <<= 16;\n\tfree (q);\n\treturn (((ut64)(size_t)p) == mask);\n}\n\nR_API char *r_sys_pid_to_path(int pid) {\n#if __WINDOWS__\n\t// TODO: add maximum path length support\n\tHANDLE processHandle;\n\tconst DWORD maxlength = MAX_PATH;\n\tTCHAR filename[MAX_PATH];\n\tchar *result = NULL;\n\n\tprocessHandle = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);\n\tif (!processHandle) {\n\t\teprintf (\"r_sys_pid_to_path: Cannot open process.\\n\");\n\t\treturn NULL;\n\t}\n\tDWORD length = GetModuleFileNameEx (processHandle, NULL, filename, maxlength);\n\tif (length == 0) {\n\t\t// Upon failure fallback to GetProcessImageFileName\n\t\tlength = GetProcessImageFileName (processHandle, filename, maxlength);\n\t\tCloseHandle (processHandle);\n\t\tif (length == 0) {\n\t\t\teprintf (\"r_sys_pid_to_path: Error calling GetProcessImageFileName\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t// Convert NT path to win32 path\n\t\tchar *name = r_sys_conv_win_to_utf8 (filename);\n\t\tif (!name) {\n\t\t\teprintf (\"r_sys_pid_to_path: Error converting to utf8\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tchar *tmp = strchr (name + 1, '\\\\');\n\t\tif (!tmp) {\n\t\t\tfree (name);\n\t\t\teprintf (\"r_sys_pid_to_path: Malformed NT path\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\ttmp = strchr (tmp + 1, '\\\\');\n\t\tif (!tmp) {\n\t\t\tfree (name);\n\t\t\teprintf (\"r_sys_pid_to_path: Malformed NT path\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlength = tmp - name;\n\t\ttmp = malloc (length + 1);\n\t\tif (!tmp) {\n\t\t\tfree (name);\n\t\t\teprintf (\"r_sys_pid_to_path: Error allocating memory\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tstrncpy (tmp, name, length);\n\t\ttmp[length] = '\\0';\n\t\tTCHAR device[MAX_PATH];\n\t\tfor (TCHAR drv[] = TEXT(\"A:\"); drv[0] <= TEXT('Z'); drv[0]++) {\n\t\t\tif (QueryDosDevice (drv, device, maxlength) > 0) {\n\t\t\t\tchar *dvc = r_sys_conv_win_to_utf8 (device);\n\t\t\t\tif (!dvc) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tfree (tmp);\n\t\t\t\t\teprintf (\"r_sys_pid_to_path: Error converting to utf8\\n\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (tmp, dvc)) {\n\t\t\t\t\tfree (tmp);\n\t\t\t\t\tfree (dvc);\n\t\t\t\t\tchar *d = r_sys_conv_win_to_utf8 (drv);\n\t\t\t\t\tif (!d) {\n\t\t\t\t\t\tfree (name);\n\t\t\t\t\t\teprintf (\"r_sys_pid_to_path: Error converting to utf8\\n\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\ttmp = r_str_newf (\"%s%s\", d, &name[length]);\n\t\t\t\t\tfree (d);\n\t\t\t\t\tif (!tmp) {\n\t\t\t\t\t\tfree (name);\n\t\t\t\t\t\teprintf (\"r_sys_pid_to_path: Error calling r_str_newf\\n\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tresult = strdup (tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree (dvc);\n\t\t\t}\n\t\t}\n\t\tfree (name);\n\t\tfree (tmp);\n\t} else {\n\t\tCloseHandle (processHandle);\n\t\tresult = r_sys_conv_win_to_utf8 (filename);\n\t}\n\treturn result;\n#elif __APPLE__\n#if __POWERPC__\n#warning TODO getpidproc\n\treturn NULL;\n#else\n\tchar pathbuf[PROC_PIDPATHINFO_MAXSIZE];\n\tpathbuf[0] = 0;\n\tint ret = proc_pidpath (pid, pathbuf, sizeof (pathbuf));\n\tif (ret <= 0) {\n\t\treturn NULL;\n\t}\n\treturn strdup (pathbuf);\n#endif\n#else\n\tint ret;\n#if __FreeBSD__\n\tchar pathbuf[PATH_MAX];\n\tsize_t pathbufl = sizeof (pathbuf);\n\tint mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, pid};\n\tret = sysctl (mib, 4, pathbuf, &pathbufl, NULL, 0);\n\tif (ret != 0) {\n\t\treturn NULL;\n\t}\n#else\n\tchar buf[128], pathbuf[1024];\n\tsnprintf (buf, sizeof (buf), \"/proc/%d/exe\", pid);\n\tret = readlink (buf, pathbuf, sizeof (pathbuf)-1);\n\tif (ret < 1) {\n\t\treturn NULL;\n\t}\n\tpathbuf[ret] = 0;\n#endif\n\treturn strdup (pathbuf);\n#endif\n}\n\n// TODO: rename to r_sys_env_init()\nR_API char **r_sys_get_environ () {\n#if __APPLE__ && !HAVE_ENVIRON\n\tenv = *_NSGetEnviron();\n#else\n\tenv = environ;\n#endif\n\t// return environ if available??\n\tif (!env) {\n\t\tenv = r_lib_dl_sym (NULL, \"environ\");\n\t}\n\treturn env;\n}\n\nR_API void r_sys_set_environ (char **e) {\n\tenv = e;\n}\n\nR_API char *r_sys_whoami (char *buf) {\n\tchar _buf[32];\n\tint pid = getpid ();\n\tint hasbuf = (buf)? 1: 0;\n\tif (!hasbuf) {\n\t\tbuf = _buf;\n\t}\n\tsprintf (buf, \"pid%d\", pid);\n\treturn hasbuf? buf: strdup (buf);\n}\n\nR_API int r_sys_getpid() {\n#if __UNIX__\n\treturn getpid ();\n#elif __WINDOWS__\n\treturn GetCurrentProcessId();\n#else\n#warning r_sys_getpid not implemented for this platform\n\treturn -1;\n#endif\n}\n\nR_API bool r_sys_tts(const char *txt, bool bg) {\n\tint i;\n\tr_return_val_if_fail (txt, false);\n\tconst char *says[] = {\n\t\t\"say\", \"termux-tts-speak\", NULL\n\t};\n\tfor (i = 0; says[i]; i++) {\n\t\tchar *sayPath = r_file_path (says[i]);\n\t\tif (sayPath) {\n\t\t\tchar *line = r_str_replace (strdup (txt), \"'\", \"\\\"\", 1);\n\t\t\tr_sys_cmdf (\"\\\"%s\\\" '%s'%s\", sayPath, line, bg? \" &\": \"\");\n\t\t\tfree (line);\n\t\t\tfree (sayPath);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API const char *r_sys_prefix(const char *pfx) {\n\tstatic char *prefix = NULL;\n\tif (!prefix) {\n#if __WINDOWS__\n\t\tprefix = r_sys_get_src_dir_w32 ();\n\t\tif (!prefix) {\n\t\t\tprefix = strdup (R2_PREFIX);\n\t\t}\n#else\n\t\tprefix = strdup (R2_PREFIX);\n#endif\n\t}\n\tif (pfx) {\n\t\tfree (prefix);\n\t\tprefix = strdup (pfx);\n\t}\n\treturn prefix;\n}\n\nR_API RSysInfo *r_sys_info(void) {\n#if __UNIX__\n\tstruct utsname un = {{0}};\n\tif (uname (&un) != -1) {\n\t\tRSysInfo *si = R_NEW0 (RSysInfo);\n\t\tif (si) {\n\t\t\tsi->sysname  = strdup (un.sysname);\n\t\t\tsi->nodename = strdup (un.nodename);\n\t\t\tsi->release  = strdup (un.release);\n\t\t\tsi->version  = strdup (un.version);\n\t\t\tsi->machine  = strdup (un.machine);\n\t\t\treturn si;\n\t\t}\n\t}\n#elif __WINDOWS__\n\tHKEY key;\n\tDWORD type;\n\tDWORD size;\n\tDWORD major;\n\tDWORD minor;\n\tchar tmp[256] = {0};\n\tRSysInfo *si = R_NEW0 (RSysInfo);\n\tif (!si) {\n\t\treturn NULL;\n\t}\n\t\n\tif (RegOpenKeyExA (HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\", 0,\n\t\tKEY_QUERY_VALUE, &key) != ERROR_SUCCESS) {\n\t\tr_sys_perror (\"r_sys_info/RegOpenKeyExA\");\n\t\tr_sys_info_free (si);\n\t\treturn NULL;\n\t}\n\n\tsize = sizeof (tmp);\n\tif (RegQueryValueExA (key, \"ProductName\", NULL, &type,\n\t\t(LPBYTE)&tmp, &size) != ERROR_SUCCESS\n\t\t|| type != REG_SZ) {\n\t\tgoto beach;\n\t}\n\tsi->sysname = strdup (tmp);\n\n\tsize = sizeof (major);\n\tif (RegQueryValueExA (key, \"CurrentMajorVersionNumber\", NULL, &type,\n\t\t(LPBYTE)&major, &size) != ERROR_SUCCESS\n\t\t|| type != REG_DWORD) {\n\t\tgoto beach;\n\t}\n\tsize = sizeof (minor);\n\tif (RegQueryValueExA (key, \"CurrentMinorVersionNumber\", NULL, &type,\n\t\t(LPBYTE)&minor, &size) != ERROR_SUCCESS\n\t\t|| type != REG_DWORD) {\n\t\tgoto beach;\n\t}\n\n\tsize = sizeof (tmp);\n\tif (RegQueryValueExA (key, \"CurrentBuild\", NULL, &type,\n\t\t(LPBYTE)&tmp, &size) != ERROR_SUCCESS\n\t\t|| type != REG_SZ) {\n\t\tgoto beach;\n\t}\n\tsi->version = r_str_newf (\"%d.%d.%s\", major, minor, tmp);\n\n\tsize = sizeof (tmp);\n\tif (RegQueryValueExA (key, \"ReleaseId\", NULL, &type,\n\t\t(LPBYTE)tmp, &size) != ERROR_SUCCESS\n\t\t|| type != REG_SZ) {\n\t\tgoto beach;\n\t}\n\tsi->release = strdup (tmp);\nbeach:\n\tRegCloseKey (key);\n\treturn si;\n#endif\n\treturn NULL;\n}\n\nR_API void r_sys_info_free(RSysInfo *si) {\n\tfree (si->sysname);\n\tfree (si->nodename);\n\tfree (si->release);\n\tfree (si->version);\n\tfree (si->machine);\n\tfree (si);\n}\n", "project('radare2', 'c', license: 'LGPL3', meson_version: '>=0.50.1')\n\npy3_exe = import('python').find_installation('python3')\ngit_exe = find_program('git', required: false)\npkgconfig_mod = import('pkgconfig')\n\n# Get r2 version\nr2_version = 'unknown-error'\nr2_version_major = 0\nr2_version_minor = 0\nr2_version_patch = 0\nr2_version_number = 0\nr = run_command(py3_exe, 'sys/version.py', '--full-version')\nif r.returncode() == 0\n  vers = r.stdout().strip().split('\\n')\n  r2_version = vers[0]\n  r2_version_major = vers[1]\n  r2_version_minor = vers[2]\n  r2_version_patch = vers[3]\n  r2_version_number = vers[4]\n  if host_machine.system() == 'darwin'\n    r2_version = r2_version.split('-')[0]\n  endif\nelse\n  message('Cannot find project version with sys/version.py')\nendif\n\nrepo = '.'\nif meson.is_subproject()\n  repo = meson.current_source_dir()\n  if host_machine.system() == 'windows'\n    py_cmd = 'print(__import__(\"os\").readlink(r\"@0@\"))'.format(repo)\n    py_cmd = run_command(py3_exe, '-c', py_cmd)\n    if py_cmd.returncode() == 0\n      repo = py_cmd.stdout().strip()\n      message('r2 real path: ' + repo)\n    endif\n  endif\nendif\n\n# by default, not version commit is used\nversion_commit = '0'\n\ngittap = ''\ngittip = 'unknown'\n\nif git_exe.found()\n  # Get version_commit\n  git_rev_list = run_command(git_exe, '-C', repo, 'rev-list', '--all', '--count')\n  if git_rev_list.returncode() == 0\n    version_commit = git_rev_list.stdout().strip()\n  endif\n\n  # Get gittap\n  git_describe = run_command(git_exe, '-C', repo, 'describe', '--tags', '--match', '[0-9]*')\n  if git_describe.returncode() == 0\n    gittap = git_describe.stdout().strip()\n  endif\n\n  # Get gittip\n  git_rev_parse = run_command(git_exe, '-C', repo, 'rev-parse', 'HEAD')\n  if git_rev_parse.returncode() == 0\n    gittip = git_rev_parse.stdout().strip()\n  endif\nendif\n\nif get_option('r2_version_commit') != ''\n  version_commit = get_option('r2_version_commit')\nendif\n\nif get_option('r2_gittap') != ''\n  gittap = get_option('r2_gittap')\nendif\n# gittap is used for the version of each r_ library\n# in case it has not been set (e.g. a release tarball) set it\nif gittap == ''\n  gittap = r2_version\nendif\n\nif get_option('r2_gittip') != ''\n  gittip = get_option('r2_gittip')\nendif\n\n# Get current date\nif host_machine.system() == 'windows'\n  r2birth = run_command('cmd', '/c', 'echo %date%__%time%')\nelse\n  r2birth = run_command('date', '+%Y-%m-%d__%H:%M:%S')\nendif\nif r2birth.returncode() != 0\n  r2birth = ''\nelse\n  r2birth = r2birth.stdout().strip()\nendif\n\nr2_libversion = host_machine.system() == 'windows' ? '' : r2_version\nmessage('r2 lib version: ' + r2_libversion)\n\n# system dependencies\ncc = meson.get_compiler('c')\n# required for linux\nldl = cc.find_library('dl', required: false)\npth = dependency('threads', required: false)\nutl = cc.find_library('util', required: false)\nif host_machine.system() == 'sunos'\n  # workaround for Solaris until https://github.com/mesonbuild/meson/issues/4328 is fixed\n  mth = declare_dependency(link_args: '-lm')\nelse\n  mth = cc.find_library('m', required: false)\nendif\n\nplatform_deps = []\nplatform_inc = ['.', 'libr/include']\nif host_machine.system() == 'windows'\n  platform_deps = [cc.find_library('ws2_32'), cc.find_library('wininet'), cc.find_library('psapi')]\nendif\nplatform_inc = include_directories(platform_inc)\n\nif get_option('static_runtime')\n  if cc.get_id() == 'msvc'\n    add_project_arguments('/MT', language: 'c')\n  endif\nendif\n\nif cc.get_id() == 'clang-cl'\n  add_project_arguments('-D__STDC__=1', language: 'c')\n  add_project_arguments('-D_CRT_DECLARE_NONSTDC_NAMES ', language: 'c')\n  add_project_arguments('-D_CRT_SECURE_NO_WARNINGS', language: 'c')\n  add_project_arguments('-D_CRT_NONSTDC_NO_DEPRECATE', language: 'c')\nendif\n\nif get_option('default_library') == 'shared'\n  if host_machine.system() != 'windows' or cc.get_id()!='msvc' and cc.get_id()!='clang-cl'\n    add_project_arguments('-fvisibility=hidden', language: 'c')\n  endif\nendif\n\nlibrary_cflags = ['-DR2_PLUGIN_INCORE=1']\n\nif host_machine.system() == 'windows'\n  r2_prefix = '.'\n  r2_libdir = 'lib'\n  r2_incdir = 'include'\n  r2_datdir = 'share'\n\n  opts1 = [\n    'r2_libdir',\n    'r2_incdir',\n    'r2_datdir'\n  ]\n  foreach opt : opts1\n    val = get_option(opt)\n    if val != ''\n      set_variable(opt, val)\n    endif\n  endforeach\n\n  r2_wwwroot = join_paths(r2_datdir, 'www')\n  r2_sdb = join_paths(r2_datdir)\n  r2_zigns = join_paths(r2_datdir, 'zigns')\n  r2_themes = join_paths(r2_datdir, 'cons')\n  r2_fortunes = join_paths(r2_datdir, 'doc')\n  r2_flags = join_paths(r2_datdir, 'flag')\n  r2_hud = join_paths(r2_datdir, 'hud')\n\n  opts2 = [\n    'r2_wwwroot',\n    'r2_sdb',\n    'r2_zigns',\n    'r2_themes',\n    'r2_fortunes',\n    'r2_flags',\n    'r2_hud'\n  ]\n  foreach opt : opts2\n    val = get_option(opt)\n    if val != ''\n      set_variable(opt, val)\n    endif\n  endforeach\n\n  opts3 = [\n    'r2_plugins',\n    'r2_extras',\n    'r2_bindings'\n  ]\n  r2_plugins = join_paths(r2_libdir, 'plugins')\n  r2_extras = join_paths(r2_libdir, 'extras')\n  r2_bindings = join_paths(r2_libdir, 'bindings')\n\n  foreach opt : opts1 + opts2 + opts3\n    val = get_variable(opt)\n    val = '\\\\\\\\'.join(val.split('/'))\n    set_variable(opt, val)\n  endforeach\nelse\n  r2_prefix = get_option('prefix')\n  r2_libdir = get_option('libdir')\n  r2_incdir = join_paths(get_option('includedir'), 'libr')\n  r2_datdir = get_option('datadir')\n  r2_datdir_r2 = join_paths(r2_datdir, 'radare2')\n  r2_wwwroot = join_paths(r2_datdir_r2, r2_version, 'www')\n  r2_sdb = join_paths(r2_datdir_r2, r2_version)\n  r2_zigns = join_paths(r2_datdir_r2, r2_version, 'zigns')\n  r2_themes = join_paths(r2_datdir_r2, r2_version, 'cons')\n  r2_fortunes = join_paths(r2_datdir, 'doc', 'radare2')\n  r2_flags = join_paths(r2_datdir_r2, r2_version, 'flag')\n  r2_hud = join_paths(r2_datdir_r2, r2_version, 'hud')\n  r2_plugins = join_paths(r2_libdir, 'radare2', r2_version)\n  r2_extras = join_paths(r2_libdir, 'radare2-extras', r2_version)\n  r2_bindings = join_paths(r2_libdir, 'radare2-bindings', r2_version)\nendif\n\nr2_zsh_compdir = join_paths(r2_datdir, 'zsh', 'site-functions')\n\n# load plugin configuration\nsubdir('libr')\n\nconf_data = configuration_data()\nconf_data.set('plugins_core', '&r_core_plugin_' + ', &r_core_plugin_'.join(core_plugins) + ', 0')\nconf_data.set('plugins_anal', '&r_anal_plugin_' + ', &r_anal_plugin_'.join(anal_plugins) + ', 0')\nconf_data.set('plugins_asm', '&r_asm_plugin_' + ', &r_asm_plugin_'.join(asm_plugins) + ', 0')\nconf_data.set('plugins_bp', '&r_bp_plugin_' + ', &r_bp_plugin_'.join(bp_plugins) + ', 0')\nconf_data.set('plugins_bin', '&r_bin_plugin_' + ', &r_bin_plugin_'.join(bin_plugins) + ', 0')\nconf_data.set('plugins_bin_ldr', '&r_bin_ldr_plugin_' + ', &r_bin_ldr_plugin_'.join(bin_ldr_plugins) + ', 0')\nconf_data.set('plugins_bin_xtr', '&r_bin_xtr_plugin_' + ', &r_bin_xtr_plugin_'.join(bin_xtr_plugins) + ', 0')\nconf_data.set('plugins_crypto', '&r_crypto_plugin_' + ', &r_crypto_plugin_'.join(crypto_plugins) + ', 0')\nconf_data.set('plugins_io', '&r_io_plugin_' + ', &r_io_plugin_'.join(io_plugins) + ', 0')\nconf_data.set('plugins_fs', '&r_fs_plugin_' + ', &r_fs_plugin_'.join(fs_plugins) + ', 0')\nconf_data.set('plugins_debug', '&r_debug_plugin_' + ', &r_debug_plugin_'.join(debug_plugins) + ', 0')\nconf_data.set('plugins_egg', '&r_egg_plugin_' + ', &r_egg_plugin_'.join(egg_plugins) + ', 0')\nconf_data.set('plugins_lang', '&r_lang_plugin_' + ', &r_lang_plugin_'.join(lang_plugins) + ', 0')\nconf_data.set('plugins_parse', '&r_parse_plugin_' + ', &r_parse_plugin_'.join(parse_plugins) + ', 0')\nconfig_h = configure_file(\n  input: 'libr/config.h.in',\n  output: 'config.h',\n  configuration: conf_data\n)\n\n# handle magic library\nsys_magic = cc.find_library('magic', required: false)\nuse_syslib_magic = false\n\nif sys_magic.found() and get_option('use_sys_magic')\n  use_syslib_magic = true\nendif\n\n# handle xxhash library\nsys_xxhash = dependency('xxhash', required: false)\nuse_sys_xxhash = false\nif not sys_xxhash.found()\n  sys_xxhash = cc.find_library('xxhash', required: false)\nendif\n\nif sys_xxhash.found() and get_option('use_sys_xxhash')\n  message('Using system xxhash library')\n  use_sys_xxhash = true\nelse\n  message('Using bundled xxhash library')\nendif\n\n# handle openssl library\nsys_openssl = dependency('openssl', required: false)\nuse_sys_openssl = false\nif sys_openssl.found() and get_option('use_sys_openssl')\n  message('Using system openssl library')\n  use_sys_openssl = true\nelse\n  message('Using bundled openssl code')\nendif\n\n# handle libuv library\nif get_option('use_libuv')\n  libuv_dep = dependency('libuv', version: '>=1.0.0', required: false)\n  use_libuv = libuv_dep.found()\n  if not libuv_dep.found()\n    warning('use_libuv option was set to true, but libuv was not found.')\n  endif\nelse\n  use_libuv = false\nendif\n\nif use_libuv\n  message('Using libuv')\nelse\n  message('Not using libuv, thus using fallback server implementations')\nendif\n\nhas_debugger = get_option('debugger')\nhave_ptrace = not ['windows', 'cygwin', 'sunos'].contains(host_machine.system())\nuse_ptrace_wrap = ['linux'].contains(host_machine.system())\n\nhave_ptrace = have_ptrace and has_debugger\nuse_ptrace_wrap = use_ptrace_wrap and has_debugger\n\nmessage('HAVE_PTRACE: @0@'.format(have_ptrace))\nmessage('USE_PTRACE_WRAP: @0@'.format(use_ptrace_wrap))\n\nchecks_level = get_option('checks_level')\nif checks_level == 9999\n  if get_option('buildtype') == 'release'\n    checks_level = 1\n  else\n    checks_level = 2\n  endif\nendif\n\nmessage('R2_CHECKS_LEVEL: @0@'.format(checks_level))\n\nuserconf = configuration_data()\nuserconf.set('R_CHECKS_LEVEL', checks_level)\nuserconf.set10('HAVE_LIB_MAGIC', sys_magic.found())\nuserconf.set10('USE_LIB_MAGIC', use_syslib_magic)\nuserconf.set10('HAVE_LIB_XXHASH', sys_xxhash.found())\nuserconf.set10('USE_LIB_XXHASH', use_sys_xxhash)\nuserconf.set10('DEBUGGER', has_debugger)\nuserconf.set('PREFIX', r2_prefix)\nif host_machine.system() == 'windows'\n  userconf.set('LIBDIR', r2_libdir)\n  userconf.set('INCLUDEDIR', r2_incdir)\n  userconf.set('DATADIR_R2', r2_datdir)\n  userconf.set10('HAVE_JEMALLOC', false)\nelse\n  userconf.set('LIBDIR', join_paths(r2_prefix, r2_libdir))\n  userconf.set('INCLUDEDIR', join_paths(r2_prefix, r2_incdir))\n  userconf.set('DATADIR_R2', r2_datdir_r2)\n  userconf.set10('HAVE_JEMALLOC', true)\nendif\nuserconf.set('DATADIR', join_paths(r2_prefix, r2_datdir))\nuserconf.set('WWWROOT', join_paths(r2_prefix, r2_wwwroot))\nuserconf.set('SDB', r2_sdb)\nuserconf.set('ZIGNS', r2_zigns)\nuserconf.set('THEMES', r2_themes)\nuserconf.set('FORTUNES', r2_fortunes)\nuserconf.set('FLAGS', r2_flags)\nuserconf.set('HUD', r2_hud)\nuserconf.set('PLUGINS', r2_plugins)\nuserconf.set('EXTRAS', r2_extras)\nuserconf.set('BINDINGS', r2_bindings)\nuserconf.set10('HAVE_OPENSSL', use_sys_openssl)\nuserconf.set10('HAVE_LIBUV', use_libuv)\nuserconf.set10('HAVE_FORK', true)\nuserconf.set10('HAVE_PTRACE', have_ptrace)\nuserconf.set10('USE_PTRACE_WRAP', use_ptrace_wrap)\nuserconf.set10('WITH_GPL', true)\nok = cc.has_header_symbol('sys/personality.h', 'ADDR_NO_RANDOMIZE')\nuserconf.set10('HAVE_DECL_ADDR_NO_RANDOMIZE', ok)\n\nforeach item : [\n    ['arc4random_uniform', '#include <stdlib.h>'],\n    ['explicit_bzero', '#include <string.h>'],\n    ['explicit_memset', '#include <string.h>'],\n    ['clock_nanosleep', '#include <time.h>'],\n    ['sigaction', '#include <signal.h>']\n  ]\n  func = item[0]\n  ok = cc.has_function(func, prefix: item[1])\n  userconf.set10('HAVE_@0@'.format(func.to_upper()), ok)\nendforeach\n\nr_userconf_h = configure_file(\n  input: 'libr/include/r_userconf.h.acr',\n  output: 'r_userconf.h',\n  configuration: userconf,\n  install_dir: join_paths(r2_incdir)\n)\n\nversionconf = configuration_data()\nversionconf.set('MESON_VERSION', meson.version())\nversionconf.set('VERSIONCOMMIT', version_commit)\nversionconf.set('R2_VERSION_MAJOR', r2_version_major)\nversionconf.set('R2_VERSION_MINOR', r2_version_minor)\nversionconf.set('R2_VERSION_PATCH', r2_version_patch)\nversionconf.set('R2_VERSION_NUMBER', r2_version_number)\nversionconf.set('R2_VERSION', r2_version)\nversionconf.set('R2_GITTAP', gittap)\nversionconf.set('R2_GITTIP', gittip)\nversionconf.set('R2_BIRTH', r2birth)\nr_version_h = configure_file(\n  input: 'libr/include/r_version.h.in',\n  output: 'r_version.h',\n  configuration: versionconf,\n  install_dir: join_paths(r2_incdir)\n)\n\n# Copy missing header\nrun_command(py3_exe, '-c', '__import__(\"shutil\").copyfile(\"shlr/spp/config.def.h\", \"shlr/spp/config.h\")')\n\npcconf = configuration_data()\npcconf.set('PREFIX', get_option('prefix'))\npcconf.set('LIBDIR', join_paths(get_option('prefix'), get_option('libdir')))\npcconf.set('VERSION', r2_version)\nlibr_pc = configure_file(\n  input: 'libr/libr.pc.acr',\n  output: 'libr.pc',\n  configuration: pcconf,\n  install_dir: join_paths(get_option('libdir'), 'pkgconfig')\n)\n\nsubdir('shlr')\n\nsubdir('libr/util')\nsubdir('libr/hash')\nsubdir('libr/crypto')\nsubdir('libr/socket')\nsubdir('libr/cons')\nsubdir('shlr/gdb')\nsubdir('libr/io')\nsubdir('libr/bp')\nsubdir('libr/syscall')\nsubdir('libr/search')\nsubdir('libr/magic')\nsubdir('libr/flag')\nsubdir('libr/reg')\nsubdir('libr/bin')\nsubdir('libr/config')\nsubdir('libr/parse')\nsubdir('libr/lang')\nsubdir('libr/asm')\nsubdir('libr/anal')\nsubdir('libr/egg')\nsubdir('libr/fs')\nsubdir('libr/debug')\nsubdir('libr/core')\n\nsubdir('libr/anal/d')\nsubdir('libr/asm/d')\nsubdir('libr/bin/d')\nsubdir('libr/syscall/d')\nsubdir('libr/cons/d')\nsubdir('libr/magic/d')\nsubdir('libr/flag/d')\nsubdir('libr/main')\n\nif not meson.is_subproject()\n  rpath = get_option('local') and get_option('default_library') == 'shared' ? '$ORIGIN/../' + get_option('libdir') : ''\n  subdir('binr/rahash2')\n  subdir('binr/rarun2')\n  subdir('binr/rasm2')\n  subdir('binr/rabin2')\n  subdir('binr/radare2')\n  subdir('binr/ragg2')\n  subdir('binr/r2agent')\n  subdir('binr/radiff2')\n  subdir('binr/rafind2')\n  subdir('binr/rasign2')\n  subdir('binr/rax2')\n  subdir('binr/r2pm')\n  subdir('binr/r2r')\nelse\n  libr2_dep = declare_dependency(\n    dependencies: [\n      r_anal_dep,\n      r_asm_dep,\n      r_bin_dep,\n      r_bp_dep,\n      r_config_dep,\n      r_cons_dep,\n      r_core_dep,\n      r_main_dep,\n      r_crypto_dep,\n      r_debug_dep,\n      r_egg_dep,\n      r_flag_dep,\n      r_fs_dep,\n      r_hash_dep,\n      r_io_dep,\n      r_lang_dep,\n      r_magic_dep,\n      r_parse_dep,\n      r_reg_dep,\n      r_search_dep,\n      r_socket_dep,\n      r_syscall_dep,\n      r_util_dep\n    ],\n    include_directories: include_directories('.', 'libr/include'),\n    version: r2_version\n  )\nendif\n\nif get_option('use_webui')\n  install_subdir('shlr/www',\n    install_dir: r2_wwwroot,\n    strip_directory: true\n  )\nendif\n\nsubdir('test/unit')\n\ninstall_data(\n  'doc/fortunes.creepy',\n  'doc/fortunes.fun',\n  'doc/fortunes.nsfw',\n  'doc/fortunes.tips',\n  install_dir: r2_fortunes\n)\n\ninstall_man(\n  'man/r2agent.1',\n  'man/r2-docker.1',\n  'man/r2pm.1',\n  'man/rabin2.1',\n  'man/radare2.1',\n  'man/radiff2.1',\n  'man/rafind2.1',\n  'man/ragg2.1',\n  'man/rahash2.1',\n  'man/rarun2.1',\n  'man/rasm2.1',\n  'man/rax2.1',\n  'man/esil.7'\n)\n\ninstall_data('doc/hud',\n  install_dir: r2_hud,\n  rename: 'main'\n)\n\ninstall_data(\n  'doc/zsh/_r2',\n  'doc/zsh/_rabin2',\n  'doc/zsh/_radiff2',\n  'doc/zsh/_rafind2',\n  'doc/zsh/_ragg2',\n  'doc/zsh/_rahash2',\n  'doc/zsh/_rasm2',\n  'doc/zsh/_rax2',\n  install_dir: r2_zsh_compdir\n)\n", "/* sdb - MIT - Copyright 2013-2018 - pancake */\n\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include \"sdb.h\"\n\n#if __SDB_WINDOWS__\n\n#if UNICODE\n\nstatic wchar_t *r_utf8_to_utf16_l (const char *cstring, int len) {\n\tif (!cstring || !len || len < -1) {\n\t\treturn NULL;\n\t}\n\twchar_t *rutf16 = NULL;\n\tint wcsize;\n\n\tif ((wcsize = MultiByteToWideChar (CP_UTF8, 0, cstring, len, NULL, 0))) {\n\t\twcsize += 1;\n\t\tif ((rutf16 = (wchar_t *) calloc (wcsize, sizeof (wchar_t)))) {\n\t\t\tMultiByteToWideChar (CP_UTF8, 0, cstring, len, rutf16, wcsize);\n\t\t\tif (len != -1) {\n\t\t\t\trutf16[wcsize - 1] = L'\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn rutf16;\n}\n\n#define r_sys_conv_utf8_to_utf16(buf) r_utf8_to_utf16_l ((buf), -1)\n\nstatic bool r_sys_mkdir(const char *path) {\n\tLPTSTR path_ = r_sys_conv_utf8_to_utf16 (path);\n\tbool ret = CreateDirectory (path_, NULL);\n\n\tfree (path_);\n\treturn ret;\n}\n#else\n#define r_sys_conv_utf8_to_utf16(buf) strdup (buf)\n#define r_sys_mkdir(x) CreateDirectory (x, NULL)\n#endif\n#ifndef ERROR_ALREADY_EXISTS\n#define ERROR_ALREADY_EXISTS 183\n#endif\n#define r_sys_mkdir_failed() (GetLastError () != 183)\n#else\n#define r_sys_mkdir(x) (mkdir (x,0755)!=-1)\n#define r_sys_mkdir_failed() (errno != EEXIST)\n#endif\n\nstatic inline int r_sys_mkdirp(char *dir) {\n\tint ret = 1;\n\tconst char slash = DIRSEP;\n\tchar *path = dir;\n\tchar *ptr = path;\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __SDB_WINDOWS__\n\tchar *p = strstr (ptr, \":\\\\\");\n\tif (p) {\n\t\tptr = p + 3;\n\t}\n#endif\n\twhile ((ptr = strchr (ptr, slash))) {\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\t*ptr = slash;\n\t\t\treturn 0;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\treturn ret;\n}\n\nSDB_API bool sdb_disk_create(Sdb* s) {\n\tint nlen;\n\tchar *str;\n\tconst char *dir;\n\tif (!s || s->fdump >= 0) {\n\t\treturn false; // cannot re-create\n\t}\n\tif (!s->dir && s->name) {\n\t\ts->dir = strdup (s->name);\n\t}\n\tdir = s->dir ? s->dir : \"./\";\n\tR_FREE (s->ndump);\n\tnlen = strlen (dir);\n\tstr = malloc (nlen + 5);\n\tif (!str) {\n\t\treturn false;\n\t}\n\tmemcpy (str, dir, nlen + 1);\n\tr_sys_mkdirp (str);\n\tmemcpy (str + nlen, \".tmp\", 5);\n\tif (s->fdump != -1) {\n\t\tclose (s->fdump);\n\t}\n#if __SDB_WINDOWS__ && UNICODE\n\twchar_t *wstr = r_sys_conv_utf8_to_utf16 (str);\n\tif (wstr) {\n\t\ts->fdump = _wopen (wstr, O_BINARY | O_RDWR | O_CREAT | O_TRUNC, SDB_MODE);\n\t\tfree (wstr);\n\t} else {\n\t\ts->fdump = -1;\n\t}\n#else\n\ts->fdump = open (str, O_BINARY | O_RDWR | O_CREAT | O_TRUNC, SDB_MODE);\n#endif\n\tif (s->fdump == -1) {\n\t\teprintf (\"sdb: Cannot open '%s' for writing.\\n\", str);\n\t\tfree (str);\n\t\treturn false;\n\t}\n\tcdb_make_start (&s->m, s->fdump);\n\ts->ndump = str;\n\treturn true;\n}\n\nSDB_API int sdb_disk_insert(Sdb* s, const char *key, const char *val) {\n\tstruct cdb_make *c = &s->m;\n\tif (!key || !val) {\n\t\treturn 0;\n\t}\n\t//if (!*val) return 0; //undefine variable if no value\n\treturn cdb_make_add (c, key, strlen (key), val, strlen (val));\n}\n\n#define IFRET(x) if (x) ret = 0\nSDB_API bool sdb_disk_finish (Sdb* s) {\n\tbool reopen = false, ret = true;\n\tIFRET (!cdb_make_finish (&s->m));\n#if USE_MMAN\n\tIFRET (fsync (s->fdump));\n#endif\n\tIFRET (close (s->fdump));\n\ts->fdump = -1;\n\t// close current fd to avoid sharing violations\n\tif (s->fd != -1) {\n\t\tclose (s->fd);\n\t\ts->fd = -1;\n\t\treopen = true;\n\t}\n#if __SDB_WINDOWS__\n\tLPTSTR ndump_ = r_sys_conv_utf8_to_utf16 (s->ndump);\n\tLPTSTR dir_ = r_sys_conv_utf8_to_utf16 (s->dir);\n\n\tif (MoveFileEx (ndump_, dir_, MOVEFILE_REPLACE_EXISTING)) {\n\t\t//eprintf (\"Error 0x%02x\\n\", GetLastError ());\n\t}\n\tfree (ndump_);\n\tfree (dir_);\n#else\n\tif (s->ndump && s->dir) {\n\t\tIFRET (rename (s->ndump, s->dir));\n\t}\n#endif\n\tfree (s->ndump);\n\ts->ndump = NULL;\n\t// reopen if was open before\n\treopen = true; // always reopen if possible\n\tif (reopen) {\n\t\tint rr = sdb_open (s, s->dir);\n\t\tif (ret && rr < 0) {\n\t\t\tret = false;\n\t\t}\n\t\tcdb_init (&s->db, s->fd);\n\t}\n\treturn ret;\n}\n\nSDB_API bool sdb_disk_unlink (Sdb *s) {\n\treturn (s->dir && *(s->dir) && unlink (s->dir) != -1);\n}\n", "NAME=PDB downloader check\nFILE=bins/pdb/user32.dll\nCMDS=<<EOF\n%R2_CURL=1\n!!rabin2 -PP ${R2_FILE} ~PDB\nEOF\nEXPECT=<<EOF\nPDB \"user32.pdb\" download success\nEOF\nRUN\n\nNAME=find structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao R2_TEST_STRUCT\nEXPECT=<<EOF\nR2_TEST_STRUCT\nEOF\nRUN\n\nNAME=find union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao R2_TEST_UNION\nEXPECT=<<EOF\nR2_TEST_UNION\nEOF\nRUN\n\nNAME=find enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao R2_TEST_ENUM\nEXPECT=<<EOF\nR2_TEST_ENUM\nEOF\nRUN\n\nNAME=member1 offset of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_struct_var_1 | grep -ao 0x0\nEXPECT=<<EOF\n0x0\nEOF\nRUN\n\nNAME=member2 offset of structure R2_TEST_STRUCT\n\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_struct_var_2 | grep -ao 0x4\nEXPECT=<<EOF\n0x4\nEOF\nRUN\n\nNAME=member1 name of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao r2_struct_var_1\nEXPECT=<<EOF\nr2_struct_var_1\nEOF\nRUN\n\nNAME=member2 name of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao r2_struct_var_2\nEXPECT=<<EOF\nr2_struct_var_2\nEOF\nRUN\n\nNAME=member1 type of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_struct_var_1 | grep -ao long\nEXPECT=<<EOF\nlong\nEOF\nRUN\n\nNAME=member2 type of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_struct_var_2 | grep -ao short\nEXPECT=<<EOF\nshort\nEOF\nRUN\n\nNAME=check size of structure R2_TEST_STRUCT\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao 0x8\nEXPECT=<<EOF\n0x8\nEOF\nRUN\n\nNAME=member1 offset of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_union_var_1 | grep -ao 0x0\nEXPECT=<<EOF\n0x0\nEOF\nRUN\n\nNAME=member2 offset of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_union_var_2 | grep -ao 0x0\nEXPECT=<<EOF\n0x0\nEOF\nRUN\n\nNAME=member1 name of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao r2_union_var_1\nEXPECT=<<EOF\nr2_union_var_1\nEOF\nRUN\n\nNAME=member2 name of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao r2_union_var_2\nEXPECT=<<EOF\nr2_union_var_2\nEOF\nRUN\n\nNAME=member1 type of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_union_var_1 | grep -ao long\nEXPECT=<<EOF\nlong\nEOF\nRUN\n\nNAME=member2 type of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep r2_union_var_2 | grep -ao double\nEXPECT=<<EOF\ndouble\nEOF\nRUN\n\nNAME=check size of union R2_TEST_UNION\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep R2_TEST_UNION | grep -ao 0x8\nEXPECT=<<EOF\n0x8\nEOF\nRUN\n\nNAME=member1 value of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep eENUM1_R2 | grep -ao 0x10\nEXPECT=<<EOF\n0x10\nEOF\nRUN\n\nNAME=member2 value of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep eENUM2_R2 | grep -ao 0x20\nEXPECT=<<EOF\n0x20\nEOF\nRUN\n\nNAME=member3 vlue of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep eENUM_R2_MAX | grep -ao 0x21\nEXPECT=<<EOF\n0x21\nEOF\nRUN\n\nNAME=member1 name of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao eENUM1_R2\nEXPECT=<<EOF\neENUM1_R2\neENUM1_R2\nEOF\nRUN\n\nNAME=member2 name of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao eENUM2_R2\nEXPECT=<<EOF\neENUM2_R2\neENUM2_R2\nEOF\nRUN\n\nNAME=member3 name of enum R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep -ao eENUM_R2_MAX\nEXPECT=<<EOF\neENUM_R2_MAX\neENUM_R2_MAX\nEOF\nRUN\n\nNAME=check size of union R2_TEST_ENUM\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -P ${R2_FILE} | grep R2_TEST_ENUM | grep -ao 0x0\nEXPECT=<<EOF\n0x0\nEOF\nRUN\n\nNAME=enumerate export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao R2_TEST_ENUM\nEXPECT=<<EOF\nR2_TEST_ENUM\nEOF\nRUN\n\nNAME=enumerate value1 export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao eENUM1_R2=0x10\nEXPECT=<<EOF\neENUM1_R2=0x10\nEOF\nRUN\n\nNAME=enumerate value2 export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao eENUM2_R2=0x20\nEXPECT=<<EOF\neENUM2_R2=0x20\nEOF\nRUN\n\nNAME=enumerate value3 export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao eENUM_R2_MAX=0x21\nEXPECT=<<EOF\neENUM_R2_MAX=0x21\nEOF\nRUN\n\nNAME=redirection test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao _unnamed_tag_ | head -n1\nEXPECT=<<EOF\n_unnamed_tag_\nEOF\nRUN\n\nNAME=struct export test\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep -ao R2_TEST_STRUCT\nEXPECT=<<EOF\nR2_TEST_STRUCT\nEOF\nRUN\n\nNAME=struct export command\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao pf\nEXPECT=<<EOF\npf\nEOF\nRUN\n\nNAME=struct export types\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao iw\nEXPECT=<<EOF\niw\nEOF\nRUN\n\nNAME=struct export name1\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao r2_struct_var_1\nEXPECT=<<EOF\nr2_struct_var_1\nEOF\nRUN\n\nNAME=struct export name2\nFILE=bins/pdb/Project1.pdb\nCMDS=!rabin2 -Pr ${R2_FILE} | grep R2_TEST_STRUCT | grep -ao r2_struct_var_2\nEXPECT=<<EOF\nr2_struct_var_2\nEOF\nRUN\n\nNAME=GUID CHECK\nFILE=bins/pdb/user32.dll\nCMDS=!rabin2 -I ${R2_FILE} | grep -ao 15F778B3671D4EFDBDCDE79905308B792\nEXPECT=<<EOF\n15F778B3671D4EFDBDCDE79905308B792\nEOF\nRUN\n", "#include <r_util.h>\n#include \"minunit.h\"\n\n//TODO test r_str_chop_path\n\nbool test_r_str_replace_char_once(void) {\n\tchar* str = strdup (\"hello world\");\n\t(void) r_str_replace_char_once (str, 'l', 'x');\n\tmu_assert_streq (str, \"hexlo world\", \"error, replace char once failed\");\n\tfree (str);\n\tmu_end;\n}\n\nbool test_r_str_replace(void) {\n\t// infinite loop test\n\tchar *str = r_str_replace (strdup (\"hello world\"), \"hell\", \"ihell\", 0);\n\tmu_assert_streq (str, \"ihello world\", \"error, replace char multi failed\");\n\tfree (str);\n\n\tstr = r_str_replace (strdup (\"hello world\"), \"hell\", \"ihell\", 1);\n\tmu_assert_streq (str, \"ihello world\", \"error, replace char multi failed\");\n\tfree (str);\n\n\tstr = r_str_replace (strdup (\"hello world\"), \"hello\", \"\", 1);\n\tmu_assert_streq (str, \" world\", \"error, replace char multi failed\");\n\tfree (str);\n\n\tstr = r_str_replace (strdup (\"hello world\"), \"h\", \"hello\", 0);\n\tmu_assert_streq (str, \"helloello world\", \"error, replace char multi failed\");\n\tfree (str);\n\n\tstr = r_str_replace (strdup (\"hello horld\"), \"h\", \"hello\", 1);\n\tmu_assert_streq (str, \"helloello helloorld\", \"error, replace char multi failed\");\n\tfree (str);\n\tstr = r_str_replace (strdup (\"hello horld\"), \"h\", \"hello\", 0);\n\tmu_assert_streq (str, \"helloello horld\", \"error, replace char multi failed\");\n\tfree (str);\n\tmu_end;\n}\n\nbool test_r_str_replace_char(void) {\n\tchar* str = strdup (\"hello world\");\n\t(void) r_str_replace_char (str, 'l', 'x');\n\tmu_assert_streq (str, \"hexxo worxd\", \"error, replace char multi failed\");\n\tfree (str);\n\tmu_end;\n}\n\n//TODO test r_str_bits\n\nbool test_r_str_bits64(void) {\n\tchar buf[65];\n\t(void)r_str_bits64 (buf, 0);\n\tmu_assert_streq (buf, \"00000000\", \"binary of 0\");\n\t(void)r_str_bits64 (buf, 1);\n\tmu_assert_streq (buf, \"00000001\", \"binary of 1\");\n\t(void)r_str_bits64 (buf, 2);\n\tmu_assert_streq (buf, \"00000010\", \"binary of 2\");\n\tmu_end;\n}\n\n//TODO test r_str_bits_from_string\n\nbool test_r_str_rwx(void) {\n\tint rwx = r_str_rwx (\"rwx\");\n\tint rw =  r_str_rwx (\"rw-\");\n\tint rx = r_str_rwx (\"rx\");\n\tint none = r_str_rwx (\"---\");\n\tint number = r_str_rwx (\"999\");\n\tint rx_number = r_str_rwx (\"5\");\n\tint rwx_number = r_str_rwx (\"7\");\n\tmu_assert_eq (rwx, 7, \"rwx\");\n\tmu_assert_eq (rw, 6, \"rw\");\n\tmu_assert_eq (rx, 5, \"rx\");\n\tmu_assert_eq (none, 0, \"no permissions\");\n\tmu_assert_eq (number, 0, \"large input number string\");\n\tmu_assert_eq (rx_number, 5, \"rx number\");\n\tmu_assert_eq (rwx_number, 7, \"rwx number\");\n\tmu_end;\n}\n\n//TODO test r_str_binstr2bin\n\nbool test_r_str_rwx_i(void) {\n\tconst char* rwx = r_str_rwx_i (7);\n\tconst char* rw = r_str_rwx_i (6);\n\tconst char* rx = r_str_rwx_i (5);\n\tconst char* invalid_mode = r_str_rwx_i (898);\n\tconst char* invalid_mode_neg = r_str_rwx_i (-10);\n\tmu_assert_streq (rwx, \"rwx\", \"rwx = 7 mode\");\n\tmu_assert_streq (rw, \"rw-\", \"rw = 6 mode\");\n\tmu_assert_streq (rx, \"r-x\", \"rx = 5 mode\");\n\tmu_assert_streq (invalid_mode, \"---\", \"invalid permissions mode\");\n\tmu_assert_streq (invalid_mode_neg, \"---\", \"invalid permissions mode (negative value)\");\n\tmu_end;\n}\n\nbool test_r_str_trim(void) {\n\t//  1\n\tconst char* one = r_str_trim_head_ro (\"  hello  \");\n\tmu_assert_streq (one, \"hello  \", \"one\");\n\t//  2\n\tchar* two = strdup (\"  hello  \");\n\tr_str_trim_head (two);\n\tmu_assert_streq (two, \"hello  \", \"two\");\n\tr_str_trim (two);\n\t//  2\n\tmu_assert_streq (two, \"hello\", \"three\");\n\tfree (two);\n\tmu_end;\n}\n//TODO find a way to test r_str_home.\n\nbool test_r_str_bool(void) {\n\tconst char* one = r_str_bool(1);\n\tconst char* zero = r_str_bool(0);\n\tconst char* fifty = r_str_bool(50);\n\tconst char* negative = r_str_bool(-1);\n\tmu_assert_streq (one, \"true\", \"one\");\n\tmu_assert_streq (zero, \"false\", \"zero\");\n\tmu_assert_streq (fifty, \"true\", \"large positive value\");\n\tmu_assert_streq (negative, \"true\", \"negative number\");\n\tmu_end;\n}\n\nbool test_r_str_case(void) {\n\tchar* str1_mixedcase = strdup (\"mIxEdCaSe\");\n\tchar* str2_mixedcase = strdup (\"mIxEdCaSe\");\n\tr_str_case (str1_mixedcase, true /*upcase*/);\n\tr_str_case (str2_mixedcase, false /*downcase*/);\n\tmu_assert_streq (str1_mixedcase, \"MIXEDCASE\", \"upcase\");\n\tmu_assert_streq (str2_mixedcase, \"mixedcase\", \"downcase\");\n\tchar* non_alphanum_1 = strdup (\"c00lstring!\");\n\tchar* non_alphanum_2 = strdup (\"c00lstrinG!\");\n\tr_str_case (non_alphanum_1, true /*upcase*/);\n\tr_str_case (non_alphanum_2, false /*downcase*/);\n\tmu_assert_streq (non_alphanum_1, \"C00LSTRING!\", \"upcase, nonalpanum\");\n\tmu_assert_streq (non_alphanum_2, \"c00lstring!\", \"downcase, nonalpanum\");\n\tfree (str1_mixedcase);\n\tfree (str2_mixedcase);\n\tfree (non_alphanum_1);\n\tfree (non_alphanum_2);\n\tmu_end;\n}\n\n//TODO test r_str_hash64, r_str_hash\n//TODO test r_str_delta (WTF!)\n\nbool test_r_str_split(void) {\n\tchar* hi = strdup (\"hello world\");\n\tint r = r_str_split (hi, ' ');\n\tmu_assert_eq (r, 2, \"split on space\");\n\tchar* hello = hi;\n\tchar* world = hi + 6;\n\tmu_assert_streq (hello, \"hello\", \"first string in split\");\n\tmu_assert_streq (world, \"world\", \"second string in split\");\n\tfree (hi);\n\tmu_end;\n}\n\nbool test_r_str_tokenize(void) {\n\t//XXX r_str_word0 doesn't work on \"hello      world\" to\n\t// tokenize into [\"hello\", \"world\"]\n\tchar* hi = strdup (\"hello world\");\n\tint r = r_str_word_set0 (hi);\n\tmu_assert_eq (r, 2, \"tokenize hello world\");\n\tconst char* hello = r_str_word_get0 (hi, 0);\n\tconst char* world = r_str_word_get0 (hi, 1);\n\tmu_assert_streq (hello, \"hello\", \"first string in split\");\n\tmu_assert_streq (world, \"world\", \"second string in split\");\n\tfree (hi);\n\tmu_end;\n}\n\nbool test_r_str_char_count(void) {\n\tmu_assert_eq (r_str_char_count (\"poop\", 'p'), 2, \"number of p in poop\");\n\tmu_end;\n}\n\nbool test_r_str_word_count(void) {\n\tmu_assert_eq (r_str_word_count (\"let's test\\nradare2 \\t libraries!\"), 4,\n\t\t\t\t\"words in a string\");\n\tmu_end;\n}\n\nbool test_r_str_ichr(void) {\n\tchar* test = \"rrrrrradare2\";\n\tchar* out = r_str_ichr (test, 'r');\n\tmu_assert_streq (out, \"adare2\",\n\t\t\t\"string after the first non-r character in rrrrrradare2\");\n\tmu_end;\n}\n\nbool test_r_str_lchr(void) {\n\tconst char* test = \"radare2\";\n\tconst char* out = r_str_lchr (test, 'r');\n\tmu_assert_streq (out, \"re2\", \"pointer to last r in radare2\");\n\tmu_end;\n}\n\nbool test_r_sub_str_lchr(void) {\n\tconst char* test = \"raddddare2d\";\n\tconst char* out = r_sub_str_lchr (test, 1, 8, 'd');\n\tmu_assert_streq (out, \"dare2d\", \"pointer to last d in range in radddddare2d\");\n\tmu_end;\n}\n\nbool test_r_sub_str_rchr(void) {\n\tconst char* test = \"raddddare2d\";\n\tconst char* out = r_sub_str_rchr (test, 1, 8, 'd');\n\tmu_assert_streq (out, \"ddddare2d\", \"pointer to first d in range in radddddare2d\");\n\tmu_end;\n}\n\nbool test_r_str_rchr(void) {\n\tconst char* test = \"raddddare2d\";\n\tconst char* out = r_str_rchr (test, NULL, '2');\n\tmu_assert_streq (out, \"2d\", \"pointer to last p in range in raddddare2d\");\n\tout = r_str_rchr (test, NULL, 'p');\n\tif (out) {\n\t\tmu_assert (\"non NULL value returned\", 0);\n\t}\n\tout = test + 9;\n\tout = r_str_rchr (test, out, 'd');\n\tmu_assert_streq (out, \"dare2d\", \"pointer to last d in range in raddddare2d\");\n\tout = test + strlen (test);\n\tout = r_str_rchr (test, out, 'p');\n\tif (out) {\n\t\tmu_assert (\"non NULL value of out\", 0);\n\t}\n\tmu_end;\n}\n\nbool test_r_str_ansi_len(void) {\n\tint len;\n\n\tlen = r_str_ansi_len (\"radare2\");\n\tmu_assert_eq (len, 7, \"len(ascii only)\");\n\n\tlen = r_str_ansi_len (\"r\\x1b[38;2;208;80;0madare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with m)\");\n\n\tlen = r_str_ansi_len (\"r\\x1b[0Jadare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with J)\");\n\n\tlen = r_str_ansi_len (\"r\\x1b[42;42Hadare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with H)\");\n\n\tlen = r_str_ansi_len (\"r\\xc3\\xa4\"\"dare2\");\n\tmu_assert_eq (len, 8, \"len(ascii + 2 byte utf-8 counted as 2 chars)\");\n\n\tlen = r_str_ansi_len (\"radar\\xe2\\x82\\xac\"\"2\");\n\tmu_assert_eq (len, 9, \"len(ascii + 3 byte utf-8 counted as 3 chars)\");\n\n\tlen = r_str_ansi_len (\"radar\\xf0\\x9d\\x84\\x9e\"\"2\");\n\tmu_assert_eq (len, 10, \"len(ascii + 4 byte utf-8 counted as 4 chars)\");\n\n\tmu_end;\n}\n\nbool test_r_str_len_utf8_ansi(void) {\n\tint len;\n\n\tlen = r_str_len_utf8_ansi (\"radare2\");\n\tmu_assert_eq (len, 7, \"len(ascii only)\");\n\n\tlen = r_str_len_utf8_ansi (\"r\\x1b[38;2;208;80;0madare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with m)\");\n\n\tlen = r_str_len_utf8_ansi (\"r\\x1b[0Jadare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with J)\");\n\n\tlen = r_str_len_utf8_ansi (\"r\\x1b[42;42Hadare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + ansi ending with H)\");\n\n\tlen = r_str_len_utf8_ansi (\"r\\xc3\\xa4\"\"dare2\");\n\tmu_assert_eq (len, 7, \"len(ascii + 2 byte utf-8 counted as 1 char)\");\n\n\tlen = r_str_len_utf8_ansi (\"radar\\xe2\\x82\\xac\"\"2\");\n\tmu_assert_eq (len, 7, \"len(ascii + 3 byte utf-8 counted as 1 char)\");\n\n\tlen = r_str_len_utf8_ansi (\"radar\\xf0\\x9d\\x84\\x9e\"\"2\");\n\tmu_assert_eq (len, 7, \"len(ascii + 4 byte utf-8 counted as 1 char)\");\n\n\tmu_end;\n}\n\nbool test_r_str_utf8_charsize(void) {\n\tchar s[16] = \"\\x61\\xc3\\xa1\\xe6\\x97\\xa5\\xf0\\x9f\\x91\\x8c\\xf0\\x9f\\x91\\x8c\\x8c\"; // a\u00e1\u65e5\ud83d\udc4c\n\tint sz;\n\n\tsz = r_str_utf8_charsize (s);\n\tmu_assert_eq (sz, 1, \"1 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize (s + 1);\n\tmu_assert_eq (sz, 2, \"2 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize (s + 3);\n\tmu_assert_eq (sz, 3, \"3 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize (s + 6);\n\tmu_assert_eq (sz, 4, \"4 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize (s + 10);\n\tmu_assert_eq (sz, 0, \"Malformed UTF-8\");\n\n\tmu_end;\n}\n\nbool test_r_str_utf8_charsize_prev(void) {\n\tchar s[16] = \"\\x61\\xc3\\xa1\\xe6\\x97\\xa5\\xf0\\x9f\\x91\\x8c\\xf0\\x9f\\x91\\x8c\\x8c\"; // a\u00e1\u65e5\ud83d\udc4c\n\tint sz;\n\n\tsz = r_str_utf8_charsize_last (s);\n\tmu_assert_eq (sz, 0, \"Malformed UTF-8\");\n\n\tsz = r_str_utf8_charsize_prev (s + 10, 10);\n\tmu_assert_eq (sz, 4, \"4 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize_prev (s + 6, 6);\n\tmu_assert_eq (sz, 3, \"3 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize_prev (s + 3, 3);\n\tmu_assert_eq (sz, 2, \"2 byte UTF-8\");\n\n\tsz = r_str_utf8_charsize_prev (s + 1, 1);\n\tmu_assert_eq (sz, 1, \"1 byte UTF-8\");\n\n\tmu_end;\n}\n\nbool test_r_str_sanitize_sdb_key(void) {\n\tchar *s = r_str_sanitize_sdb_key(\"rada.re2<is>::Cool\");\n\tmu_assert_streq (s, \"rada_re2_is_::Cool\", \"sanitize\");\n\tfree (s);\n\tmu_end;\n}\n\nbool test_r_str_escape_sh(void) {\n\tchar *escaped = r_str_escape_sh (\"Hello, \\\"World\\\"\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\"World\\\\\\\"\", \"escaped \\\"double quotes\\\"\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, \\\\World\\\\\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\\World\\\\\\\\\", \"escaped backspace\");\n\tfree (escaped);\n#if __UNIX__\n\tescaped = r_str_escape_sh (\"Hello, $(World)\");\n\tmu_assert_streq (escaped, \"Hello, \\\\$(World)\", \"escaped $(command)\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, `World`\");\n\tmu_assert_streq (escaped, \"Hello, \\\\`World\\\\`\", \"escaped `command`\");\n\tfree (escaped);\n#endif\n\tmu_end;\n}\n\nbool test_r_str_unescape(void) {\n\tchar buf[] = \"Hello\\\\x31World\\\\n\";\n\tr_str_unescape (buf);\n\tmu_assert_streq (buf, \"Hello1World\\n\", \"unescaped\");\n\tmu_end;\n}\n\nbool test_r_str_newf(void) {\n\tchar *a = r_str_newf (\"hello\");\n\tmu_assert_streq (a, \"hello\", \"oops\");\n\tfree (a);\n\n\ta = r_str_newf (\"%s/%s\", \"hello\", \"world\");\n\tmu_assert_streq (a, \"hello/world\", \"oops\");\n\tfree (a);\n\n\ta = r_str_newf (\"%s/%s\", \"hello\", \"world\");\n\ta = r_str_appendf (a, \"..%s/%s\", \"cow\", \"low\");\n\ta = r_str_appendf (a, \"PWN\");\n\tmu_assert_streq (a, \"hello/world..cow/lowPWN\", \"oops\");\n\tfree (a);\n\tmu_end;\n}\n\nbool test_r_str_constpool(void) {\n\tRStrConstPool pool;\n\tbool s = r_str_constpool_init (&pool);\n\tmu_assert (\"pool init success\", s);\n\n\tconst char *a_ref = \"deliverance\";\n\tconst char *a_pooled = r_str_constpool_get (&pool, a_ref);\n\tmu_assert_ptrneq (a_pooled, a_ref, \"pooled != ref\");\n\tmu_assert_streq (a_pooled, a_ref, \"pooled == ref (strcmp)\");\n\tconst char *a_pooled2 = r_str_constpool_get (&pool, a_ref);\n\tmu_assert_ptreq (a_pooled2, a_pooled, \"same on re-get\");\n\tchar *a_ref_cpy = strdup (a_ref);\n\ta_pooled2 = r_str_constpool_get (&pool, a_ref_cpy);\n\tfree (a_ref_cpy);\n\tmu_assert_ptreq (a_pooled2, a_pooled, \"same on re-get with different ptr\");\n\n\tconst char *b_ref = \"damnation\";\n\tconst char *b_pooled = r_str_constpool_get (&pool, b_ref);\n\tmu_assert_ptrneq (b_pooled, b_ref, \"pooled != ref (second)\");\n\tmu_assert_streq (b_pooled, b_ref, \"pooled == ref (strcmp, second)\");\n\n\tr_str_constpool_fini (&pool);\n\tmu_end;\n}\n\nbool test_r_str_format_msvc_argv() {\n\t// Examples from http://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES\n\tconst char *a = \"CallMePancake\";\n\tchar *str = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"CallMePancake\", \"no escaping\");\n\tfree (str);\n\n\ta = \"Call Me Pancake\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"\\\"Call Me Pancake\\\"\", \"just quoting\");\n\tfree (str);\n\n\ta = \"CallMe\\\"Pancake\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"CallMe\\\\\\\"Pancake\", \"just escaping\");\n\tfree (str);\n\n\ta = \"CallMePancake\\\\\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"CallMePancake\\\\\", \"no escaping of backslashes\");\n\tfree (str);\n\n\ta = \"Call Me Pancake\\\\\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"\\\"Call Me Pancake\\\\\\\\\\\"\", \"escaping of backslashes before closing quote\");\n\tfree (str);\n\n\ta = \"CallMe\\\\\\\"Pancake\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"CallMe\\\\\\\\\\\\\\\"Pancake\", \"escaping of backslashes before literal quote\");\n\tfree (str);\n\n\ta = \"Call Me\\\\\\\"Pancake\";\n\tstr = r_str_format_msvc_argv (1, &a);\n\tmu_assert_streq (str, \"\\\"Call Me\\\\\\\\\\\\\\\"Pancake\\\"\", \"escaping of backslashes before literal quote in quote\");\n\tfree (str);\n\n\tconst char *args[] = { \"rm\", \"-rf\", \"\\\\\"};\n\tstr = r_str_format_msvc_argv (3, args);\n\tmu_assert_streq (str, \"rm -rf \\\\\", \"multiple args\");\n\tfree (str);\n\n\tmu_end;\n}\n\nbool test_r_str_str_xy(void) {\n\tchar *canvas = \"Hello World\\n\"\n\t\t\"This World is World\\n\"\n\t\t\"World is Hello\\n\";\n\tint x = 0, y = 0;\n\tconst char *next = r_str_str_xy (canvas, \"World\", NULL, &x, &y);\n\tmu_assert_eq (x, 6, \"x of first occurrence\");\n\tmu_assert_eq (y, 0, \"y of first occurrence\");\n\tnext = r_str_str_xy (canvas, \"World\", next, &x, &y);\n\tmu_assert_eq (x, 5, \"x of second occurrence\");\n\tmu_assert_eq (y, 1, \"y of second occurrence\");\n\tnext = r_str_str_xy (canvas, \"World\", next, &x, &y);\n\tmu_assert_eq (x, 14, \"x of third occurrence\");\n\tmu_assert_eq (y, 1, \"y of third occurrence\");\n\tnext = r_str_str_xy (canvas, \"World\", next, &x, &y);\n\tmu_assert_eq (x, 0, \"x of fourth occurrence\");\n\tmu_assert_eq (y, 2, \"y of fourth occurrence\");\n\tnext = r_str_str_xy (canvas, \"World\", next, &x, &y);\n\tmu_assert_null (next, \"no more occurences\");\n\tmu_end;\n}\n\nbool all_tests () {\n\tmu_run_test (test_r_str_newf);\n\tmu_run_test (test_r_str_replace_char_once);\n\tmu_run_test (test_r_str_replace_char);\n\tmu_run_test (test_r_str_replace);\n\tmu_run_test (test_r_str_bits64);\n\tmu_run_test (test_r_str_rwx);\n\tmu_run_test (test_r_str_rwx_i);\n\tmu_run_test (test_r_str_bool);\n\tmu_run_test (test_r_str_trim);\n\tmu_run_test (test_r_str_case);\n\tmu_run_test (test_r_str_split);\n\tmu_run_test (test_r_str_tokenize);\n\tmu_run_test (test_r_str_char_count);\n\tmu_run_test (test_r_str_word_count);\n\tmu_run_test (test_r_str_ichr);\n\tmu_run_test (test_r_str_lchr);\n\tmu_run_test (test_r_sub_str_lchr);\n\tmu_run_test (test_r_sub_str_rchr);\n\tmu_run_test (test_r_str_rchr);\n\tmu_run_test (test_r_str_ansi_len);\n\tmu_run_test (test_r_str_len_utf8_ansi);\n\tmu_run_test (test_r_str_utf8_charsize);\n\tmu_run_test (test_r_str_utf8_charsize_prev);\n\tmu_run_test (test_r_str_sanitize_sdb_key);\n\tmu_run_test (test_r_str_escape_sh);\n\tmu_run_test (test_r_str_unescape);\n\tmu_run_test (test_r_str_constpool);\n\tmu_run_test (test_r_str_format_msvc_argv);\n\tmu_run_test (test_r_str_str_xy);\n\treturn tests_passed != tests_run;\n}\n\nint main(int argc, char **argv) {\n\treturn all_tests();\n}\n"], "filenames": ["libr/bin/pdb/pdb_downloader.c", "libr/config.mk.tail", "libr/include/r_socket.h", "libr/include/r_types.h", "libr/include/r_util/r_str.h", "libr/socket/socket.c", "libr/socket/socket_http.c", "libr/util/str.c", "libr/util/sys.c", "meson.build", "shlr/sdb/src/disk.c", "test/db/formats/pdb", "test/unit/test_str.c"], "buggy_code_start_loc": [21, 54, 3, 154, 150, 262, 6, 1351, 662, 115, 67, 3, 335], "buggy_code_end_loc": [201, 54, 8, 154, 150, 818, 210, 1351, 833, 116, 68, 4, 479], "fixing_code_start_loc": [21, 55, 2, 155, 151, 263, 6, 1352, 663, 115, 67, 3, 336], "fixing_code_end_loc": [177, 60, 2, 156, 152, 768, 325, 1380, 852, 116, 68, 7, 499], "type": "CWE-78", "message": "In radare2 before version 4.5.0, malformed PDB file names in the PDB server path cause shell injection. To trigger the problem it's required to open the executable in radare2 and run idpd to trigger the download. The shell code will execute, and will create a file called pwned in the current directory.", "other": {"cve": {"id": "CVE-2020-15121", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-20T18:15:12.187", "lastModified": "2022-01-04T16:33:05.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In radare2 before version 4.5.0, malformed PDB file names in the PDB server path cause shell injection. To trigger the problem it's required to open the executable in radare2 and run idpd to trigger the download. The shell code will execute, and will create a file called pwned in the current directory."}, {"lang": "es", "value": "En radare2 versiones anteriores a 4.5.0, los nombres de archivo PDB malformado en la ruta del servidor PDB causa una inyecci\u00f3n de shell. Para desencadenar el problema, se requiere abrir el ejecutable en radare2 y ejecutar idpd para desencadenar la descarga. El c\u00f3digo de shell ser\u00e1 ejecutado y crear\u00e1 un archivo llamado pwned en el directorio actual"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.5.0", "matchCriteriaId": "C2252909-1FFD-484D-AC5B-6227CD4FB1BA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/issues/16945", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/pull/16966", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/security/advisories/GHSA-r552-vp94-9358", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MWC7KNBETYE5MK6VIUU26LUIISIFGSBZ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YE77P5RSE2T7JHEKMWF2ARTSJGMPXCFY/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9"}}