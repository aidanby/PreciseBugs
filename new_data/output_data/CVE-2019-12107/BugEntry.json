{"buggy_code": ["/* $Id: upnpevents.c,v 1.39 2018/03/12 22:41:54 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * (c) 2008-2018 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdio.h>\n#include <string.h>\n#include <syslog.h>\n#include <sys/queue.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include \"config.h\"\n#if defined(LIB_UUID)\n/* as found on linux */\n#include <uuid/uuid.h>\n#elif defined(BSD_UUID)\n#include <uuid.h>\n#endif /* LIB_UUID / BSD_UUID */\n#include \"upnpevents.h\"\n#include \"miniupnpdpath.h\"\n#include \"upnpglobalvars.h\"\n#include \"upnpdescgen.h\"\n#include \"upnputils.h\"\n\n#ifdef ENABLE_EVENTS\n/*enum subscriber_service_enum {\n EWanCFG = 1,\n EWanIPC,\n EL3F\n};*/\n\n/* stuctures definitions */\nstruct subscriber {\n\tLIST_ENTRY(subscriber) entries;\n\tstruct upnp_event_notify * notify;\n\ttime_t timeout;\n\tuint32_t seq;\n\tenum subscriber_service_enum service;\n\tchar uuid[42];\n\tchar callback[];\n};\n\nstruct upnp_event_notify {\n\tLIST_ENTRY(upnp_event_notify) entries;\n    int s;  /* socket */\n    enum { ECreated=1,\n\t       EConnecting,\n\t       ESending,\n\t       EWaitingForResponse,\n\t       EFinished,\n\t       EError } state;\n    struct subscriber * sub;\n    char * buffer;\n    int buffersize;\n\tint tosend;\n    int sent;\n\tconst char * path;\n#ifdef ENABLE_IPV6\n\tint ipv6;\n\tchar addrstr[48];\n#else\n\tchar addrstr[16];\n#endif\n\tchar portstr[8];\n};\n\n/* prototypes */\nstatic void\nupnp_event_create_notify(struct subscriber * sub);\n\n/* Subscriber list */\nLIST_HEAD(listhead, subscriber) subscriberlist = { NULL };\n\n/* notify list */\nLIST_HEAD(listheadnotif, upnp_event_notify) notifylist = { NULL };\n\n/* create a new subscriber */\nstatic struct subscriber *\nnewSubscriber(const char * eventurl, const char * callback, int callbacklen)\n{\n\tstruct subscriber * tmp;\n\tif(!eventurl || !callback || !callbacklen)\n\t\treturn NULL;\n\ttmp = calloc(1, sizeof(struct subscriber)+callbacklen+1);\n\tif(!tmp)\n\t\treturn NULL;\n\tif(strcmp(eventurl, WANCFG_EVENTURL)==0)\n\t\ttmp->service = EWanCFG;\n\telse if(strcmp(eventurl, WANIPC_EVENTURL)==0)\n\t\ttmp->service = EWanIPC;\n#ifdef ENABLE_L3F_SERVICE\n\telse if(strcmp(eventurl, L3F_EVENTURL)==0)\n\t\ttmp->service = EL3F;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\telse if(strcmp(eventurl, WANIP6FC_EVENTURL)==0)\n\t\ttmp->service = E6FC;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\telse if(strcmp(eventurl, DP_EVENTURL)==0)\n\t\ttmp->service = EDP;\n#endif\n\telse {\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\tmemcpy(tmp->callback, callback, callbacklen);\n\ttmp->callback[callbacklen] = '\\0';\n#if defined(LIB_UUID)\n\t{\n\t\tuuid_t uuid;\n\t\tuuid_generate(uuid);\n\t\tmemcpy(tmp->uuid, \"uuid:\", 5);\n\t\tuuid_unparse(uuid, tmp->uuid + 5);\n\t}\n#elif defined(BSD_UUID)\n\t{\n\t\tuuid_t uuid;\n\t\tuint32_t status;\n\t\tuuid_create(&uuid, &status);\n\t\tif(status != uuid_s_ok) {\n\t\t\tsyslog(LOG_ERR, \"uuid_create() failed (%u)\", status);\n\t\t} else {\n\t\t\tchar * uuid_str;\n\t\t\tuuid_to_string(&uuid, &uuid_str, &status);\n\t\t\tif(status != uuid_s_ok) {\n\t\t\t\tsyslog(LOG_ERR, \"uuid_to_string() failed (%u)\", status);\n\t\t\t} else {\n\t\t\t\tif(strlen(uuid_str) != 36) {\n\t\t\t\t\tsyslog(LOG_ERR, \"uuid_to_string() returned %s\", uuid_str);\n\t\t\t\t\tstatus = (uint32_t)-1;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(tmp->uuid, \"uuid:\", 5);\n\t\t\t\t\tmemcpy(tmp->uuid + 5, uuid_str, 36);\n\t\t\t\t\ttmp->uuid[sizeof(tmp->uuid)-1] = '\\0';\n\t\t\t\t}\n\t\t\t\tfree(uuid_str);\n\t\t\t}\n\t\t}\n\t\tif(status != uuid_s_ok) {\n\t\t\t/* make a dummy uuid */\n\t\t\tstrncpy(tmp->uuid, uuidvalue_igd, sizeof(tmp->uuid));\n\t\t\ttmp->uuid[sizeof(tmp->uuid)-1] = '\\0';\n\t\t\tsnprintf(tmp->uuid+sizeof(tmp->uuid)-5, 5, \"%04lx\", random() & 0xffff);\n\t\t}\n\t}\n#else\n\t/* make a dummy uuid */\n\tstrncpy(tmp->uuid, uuidvalue_igd, sizeof(tmp->uuid));\n\ttmp->uuid[sizeof(tmp->uuid)-1] = '\\0';\n\tsnprintf(tmp->uuid+sizeof(tmp->uuid)-5, 5, \"%04lx\", random() & 0xffff);\n#endif\n\treturn tmp;\n}\n\n/* creates a new subscriber and adds it to the subscriber list\n * also initiate 1st notify\n * TODO : add a check on the number of subscriber in order to\n * prevent memory overflow... */\nconst char *\nupnpevents_addSubscriber(const char * eventurl,\n                         const char * callback, int callbacklen,\n                         int timeout)\n{\n\tstruct subscriber * tmp;\n\t/*static char uuid[42];*/\n\t/* \"uuid:00000000-0000-0000-0000-000000000000\"; 5+36+1=42bytes */\n\tsyslog(LOG_DEBUG, \"addSubscriber(%s, %.*s, %d)\",\n\t       eventurl, callbacklen, callback, timeout);\n\t/*strncpy(uuid, uuidvalue, sizeof(uuid));\n\tuuid[sizeof(uuid)-1] = '\\0';*/\n\ttmp = newSubscriber(eventurl, callback, callbacklen);\n\tif(!tmp)\n\t\treturn NULL;\n\tif(timeout)\n\t\ttmp->timeout = upnp_time() + timeout;\n\tLIST_INSERT_HEAD(&subscriberlist, tmp, entries);\n\tupnp_event_create_notify(tmp);\n\treturn tmp->uuid;\n}\n\n/* renew a subscription (update the timeout) */\nconst char *\nupnpevents_renewSubscription(const char * sid, int sidlen, int timeout)\n{\n\tstruct subscriber * sub;\n\tfor(sub = subscriberlist.lh_first; sub != NULL; sub = sub->entries.le_next) {\n\t\tif((sidlen == 41) && (memcmp(sid, sub->uuid, 41) == 0)) {\n#ifdef UPNP_STRICT\n\t\t\t/* check if the subscription already timeouted */\n\t\t\tif(sub->timeout && upnp_time() > sub->timeout)\n\t\t\t\tcontinue;\n#endif\n\t\t\tsub->timeout = (timeout ? upnp_time() + timeout : 0);\n\t\t\treturn sub->uuid;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint\nupnpevents_removeSubscriber(const char * sid, int sidlen)\n{\n\tstruct subscriber * sub;\n\tif(!sid)\n\t\treturn -1;\n\tfor(sub = subscriberlist.lh_first; sub != NULL; sub = sub->entries.le_next) {\n\t\tif((sidlen == 41) && (memcmp(sid, sub->uuid, 41) == 0)) {\n\t\t\tif(sub->notify) {\n\t\t\t\tsub->notify->sub = NULL;\n\t\t\t}\n\t\t\tLIST_REMOVE(sub, entries);\n\t\t\tfree(sub);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* notifies all subscriber of a number of port mapping change\n * or external ip address change */\nvoid\nupnp_event_var_change_notify(enum subscriber_service_enum service)\n{\n\tstruct subscriber * sub;\n\tfor(sub = subscriberlist.lh_first; sub != NULL; sub = sub->entries.le_next) {\n\t\tif(sub->service == service && sub->notify == NULL)\n\t\t\tupnp_event_create_notify(sub);\n\t}\n}\n\n/* create and add the notify object to the list */\nstatic void\nupnp_event_create_notify(struct subscriber * sub)\n{\n\tstruct upnp_event_notify * obj;\n\t/*struct timeval sock_timeout;*/\n\n\tobj = calloc(1, sizeof(struct upnp_event_notify));\n\tif(!obj) {\n\t\tsyslog(LOG_ERR, \"%s: calloc(): %m\", \"upnp_event_create_notify\");\n\t\treturn;\n\t}\n\tobj->sub = sub;\n\tobj->state = ECreated;\n#ifdef ENABLE_IPV6\n\tobj->s = socket((obj->sub->callback[7] == '[') ? PF_INET6 : PF_INET,\n\t                SOCK_STREAM, 0);\n#else\n\tobj->s = socket(PF_INET, SOCK_STREAM, 0);\n#endif\n\tif(obj->s<0) {\n\t\tsyslog(LOG_ERR, \"%s: socket(): %m\", \"upnp_event_create_notify\");\n\t\tgoto error;\n\t}\n#if 0 /* does not work for non blocking connect() */\n\t/* set timeout to 3 seconds */\n\tsock_timeout.tv_sec = 3;\n\tsock_timeout.tv_usec = 0;\n\tif(setsockopt(obj->s, SOL_SOCKET, SO_RCVTIMEO, &sock_timeout, sizeof(struct timeval)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(SO_RCVTIMEO): %m\",\n\t\t       \"upnp_event_create_notify\");\n\t}\n\tsock_timeout.tv_sec = 3;\n\tsock_timeout.tv_usec = 0;\n\tif(setsockopt(obj->s, SOL_SOCKET, SO_SNDTIMEO, &sock_timeout, sizeof(struct timeval)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(SO_SNDTIMEO): %m\",\n\t\t       \"upnp_event_create_notify\");\n\t}\n#endif\n\t/* set socket non blocking */\n\tif(!set_non_blocking(obj->s)) {\n\t\tsyslog(LOG_ERR, \"%s: set_non_blocking(): %m\",\n\t\t       \"upnp_event_create_notify\");\n\t\tgoto error;\n\t}\n\tif(sub)\n\t\tsub->notify = obj;\n\tLIST_INSERT_HEAD(&notifylist, obj, entries);\n\treturn;\nerror:\n\tif(obj->s >= 0)\n\t\tclose(obj->s);\n\tfree(obj);\n}\n\nstatic void\nupnp_event_notify_connect(struct upnp_event_notify * obj)\n{\n\tunsigned int i;\n\tconst char * p;\n\tunsigned short port;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n#else\n\tstruct sockaddr_in addr;\n\tsocklen_t addrlen;\n#endif\n\n\tif(!obj)\n\t\treturn;\n\tmemset(&addr, 0, sizeof(addr));\n\ti = 0;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tp = obj->sub->callback;\n\tp += 7;\t/* http:// */\n#ifdef ENABLE_IPV6\n\tif(*p == '[') {\t/* ip v6 */\n\t\tobj->addrstr[i++] = '[';\n\t\tp++;\n\t\tobj->ipv6 = 1;\n\t\twhile(*p != ']' && i < (sizeof(obj->addrstr)-1))\n\t\t\tobj->addrstr[i++] = *(p++);\n\t\tif(*p == ']')\n\t\t\tp++;\n\t\tif(i < (sizeof(obj->addrstr)-1))\n\t\t\tobj->addrstr[i++] = ']';\n\t} else {\n#endif\n\t\twhile(*p != '/' && *p != ':' && i < (sizeof(obj->addrstr)-1))\n\t\t\tobj->addrstr[i++] = *(p++);\n#ifdef ENABLE_IPV6\n\t}\n#endif\n\tobj->addrstr[i] = '\\0';\n\tif(*p == ':') {\n\t\tobj->portstr[0] = *p;\n\t\ti = 1;\n\t\tp++;\n\t\tport = (unsigned short)atoi(p);\n\t\twhile(*p != '/') {\n\t\t\tif(i<7) obj->portstr[i++] = *p;\n\t\t\tp++;\n\t\t}\n\t\tobj->portstr[i] = 0;\n\t} else {\n\t\tport = 80;\n\t\tobj->portstr[0] = '\\0';\n\t}\n\tobj->path = p;\n#ifdef ENABLE_IPV6\n\tif(obj->ipv6) {\n\t\tchar addrstr_tmp[48];\n\t\tstruct sockaddr_in6 * sa = (struct sockaddr_in6 *)&addr;\n\t\tsa->sin6_family = AF_INET6;\n\t\ti = (int)strlen(obj->addrstr);\n\t\tif(i > 2) {\n\t\t\ti -= 2;\n\t\t\tmemcpy(addrstr_tmp, obj->addrstr + 1, i);\n\t\t\taddrstr_tmp[i] = '\\0';\n\t\t\tinet_pton(AF_INET6, addrstr_tmp, &(sa->sin6_addr));\n\t\t}\n\t\tsa->sin6_port = htons(port);\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t} else {\n\t\tstruct sockaddr_in * sa = (struct sockaddr_in *)&addr;\n\t\tsa->sin_family = AF_INET;\n\t\tinet_pton(AF_INET, obj->addrstr, &(sa->sin_addr));\n\t\tsa->sin_port = htons(port);\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t}\n#else\n\taddr.sin_family = AF_INET;\n\tinet_aton(obj->addrstr, &addr.sin_addr);\n\taddr.sin_port = htons(port);\n\taddrlen = sizeof(struct sockaddr_in);\n#endif\n\tsyslog(LOG_DEBUG, \"%s: '%s' %hu '%s'\", \"upnp_event_notify_connect\",\n\t       obj->addrstr, port, obj->path);\n\tobj->state = EConnecting;\n\tif(connect(obj->s, (struct sockaddr *)&addr, addrlen) < 0) {\n\t\tif(errno != EINPROGRESS && errno != EWOULDBLOCK) {\n\t\t\tsyslog(LOG_ERR, \"%s: connect(%d, %s, %u): %m\",\n\t\t\t       \"upnp_event_notify_connect\", obj->s,\n\t\t\t       obj->addrstr, addrlen);\n\t\t\tobj->state = EError;\n\t\t}\n\t}\n}\n\nstatic void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t/* UDA v1.0 */\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t/* UDA v1.1 or later */\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n\t\t}\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}\n\nstatic void upnp_event_send(struct upnp_event_notify * obj)\n{\n\tint i;\n\n\tsyslog(LOG_DEBUG, \"%s: sending event notify message to %s%s\",\n\t       \"upnp_event_send\", obj->addrstr, obj->portstr);\n\tsyslog(LOG_DEBUG, \"%s: msg: %s\",\n\t       \"upnp_event_send\", obj->buffer + obj->sent);\n\ti = send(obj->s, obj->buffer + obj->sent, obj->tosend - obj->sent, 0);\n\tif(i<0) {\n\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR) {\n\t\t\tsyslog(LOG_NOTICE, \"%s: send(%s%s): %m\", \"upnp_event_send\",\n\t\t\t       obj->addrstr, obj->portstr);\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* EAGAIN or EWOULDBLOCK or EINTR : no data sent */\n\t\t\ti = 0;\n\t\t}\n\t}\n\tif(i != (obj->tosend - obj->sent))\n\t\tsyslog(LOG_NOTICE, \"%s: %d bytes send out of %d\",\n\t\t       \"upnp_event_send\", i, obj->tosend - obj->sent);\n\tobj->sent += i;\n\tif(obj->sent == obj->tosend)\n\t\tobj->state = EWaitingForResponse;\n}\n\nstatic void upnp_event_recv(struct upnp_event_notify * obj)\n{\n\tint n;\n\tn = recv(obj->s, obj->buffer, obj->buffersize, 0);\n\tif(n<0) {\n\t\tif(errno != EAGAIN &&\n\t\t   errno != EWOULDBLOCK &&\n\t\t   errno != EINTR) {\n\t\t\tsyslog(LOG_ERR, \"%s: recv(): %m\", \"upnp_event_recv\");\n\t\t\tobj->state = EError;\n\t\t}\n\t\treturn;\n\t}\n\tsyslog(LOG_DEBUG, \"%s: (%dbytes) %.*s\", \"upnp_event_recv\",\n\t       n, n, obj->buffer);\n\t/* TODO : do something with the data recevied ?\n\t * right now, n (number of bytes received) is ignored\n\t * We may need to recv() more bytes. */\n\tobj->state = EFinished;\n\tif(obj->sub)\n\t\tobj->sub->seq++;\n}\n\nstatic void\nupnp_event_process_notify(struct upnp_event_notify * obj)\n{\n\tint err;\n\tsocklen_t len;\n\tswitch(obj->state) {\n\tcase EConnecting:\n\t\t/* now connected or failed to connect */\n\t\tlen = sizeof(err);\n\t\tif(getsockopt(obj->s, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: getsockopt: %m\", \"upnp_event_process_notify\");\n\t\t\tobj->state = EError;\n\t\t\tbreak;\n\t\t}\n\t\tif(err != 0) {\n\t\t\terrno = err;\n\t\t\tsyslog(LOG_WARNING, \"%s: connect(%s%s): %m\",\n\t\t\t       \"upnp_event_process_notify\",\n\t\t\t       obj->addrstr, obj->portstr);\n\t\t\tobj->state = EError;\n\t\t\tbreak;\n\t\t}\n\t\tupnp_event_prepare(obj);\n\t\tif(obj->state == ESending)\n\t\t\tupnp_event_send(obj);\n\t\tbreak;\n\tcase ESending:\n\t\tupnp_event_send(obj);\n\t\tbreak;\n\tcase EWaitingForResponse:\n\t\tupnp_event_recv(obj);\n\t\tbreak;\n\tcase EFinished:\n\t\tclose(obj->s);\n\t\tobj->s = -1;\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_ERR, \"%s: unknown state\", \"upnp_event_process_notify\");\n\t}\n}\n\nvoid upnpevents_selectfds(fd_set *readset, fd_set *writeset, int * max_fd)\n{\n\tstruct upnp_event_notify * obj;\n\tfor(obj = notifylist.lh_first; obj != NULL; obj = obj->entries.le_next) {\n\t\tsyslog(LOG_DEBUG, \"upnpevents_selectfds: %p %d %d\",\n\t\t       obj, obj->state, obj->s);\n\t\tif(obj->s >= 0) {\n\t\t\tswitch(obj->state) {\n\t\t\tcase ECreated:\n\t\t\t\tupnp_event_notify_connect(obj);\n\t\t\t\tif(obj->state != EConnecting)\n\t\t\t\t\tbreak;\n\t\t\tcase EConnecting:\n\t\t\tcase ESending:\n\t\t\t\tFD_SET(obj->s, writeset);\n\t\t\t\tif(obj->s > *max_fd)\n\t\t\t\t\t*max_fd = obj->s;\n\t\t\t\tbreak;\n\t\t\tcase EWaitingForResponse:\n\t\t\t\tFD_SET(obj->s, readset);\n\t\t\t\tif(obj->s > *max_fd)\n\t\t\t\t\t*max_fd = obj->s;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid upnpevents_processfds(fd_set *readset, fd_set *writeset)\n{\n\tstruct upnp_event_notify * obj;\n\tstruct upnp_event_notify * next;\n\tstruct subscriber * sub;\n\tstruct subscriber * subnext;\n\ttime_t curtime;\n\tfor(obj = notifylist.lh_first; obj != NULL; obj = obj->entries.le_next) {\n\t\tsyslog(LOG_DEBUG, \"%s: %p %d %d %d %d\",\n\t\t       \"upnpevents_processfds\", obj, obj->state, obj->s,\n\t\t       FD_ISSET(obj->s, readset), FD_ISSET(obj->s, writeset));\n\t\tif(obj->s >= 0) {\n\t\t\tif(FD_ISSET(obj->s, readset) || FD_ISSET(obj->s, writeset))\n\t\t\t\tupnp_event_process_notify(obj);\n\t\t}\n\t}\n\tobj = notifylist.lh_first;\n\twhile(obj != NULL) {\n\t\tnext = obj->entries.le_next;\n\t\tif(obj->state == EError || obj->state == EFinished) {\n\t\t\tif(obj->s >= 0) {\n\t\t\t\tclose(obj->s);\n\t\t\t}\n\t\t\tif(obj->sub)\n\t\t\t\tobj->sub->notify = NULL;\n\t\t\t/* remove also the subscriber from the list if there was an error */\n\t\t\tif(obj->state == EError && obj->sub) {\n\t\t\t\tsyslog(LOG_ERR, \"%s: %p, remove subscriber %s after an ERROR cb: %s\",\n\t\t\t\t       \"upnpevents_processfds\", obj, obj->sub->uuid, obj->sub->callback);\n\t\t\t\tLIST_REMOVE(obj->sub, entries);\n\t\t\t\tfree(obj->sub);\n\t\t\t}\n\t\t\tif(obj->buffer) {\n\t\t\t\tfree(obj->buffer);\n\t\t\t}\n\t\t\tLIST_REMOVE(obj, entries);\n\t\t\tfree(obj);\n\t\t}\n\t\tobj = next;\n\t}\n\t/* remove timeouted subscribers */\n\tcurtime = upnp_time();\n\tfor(sub = subscriberlist.lh_first; sub != NULL; ) {\n\t\tsubnext = sub->entries.le_next;\n\t\tif(sub->timeout && curtime > sub->timeout && sub->notify == NULL) {\n\t\t\tsyslog(LOG_INFO, \"subscriber timeouted : %u > %u SID=%s\",\n\t\t\t       (unsigned)curtime, (unsigned)sub->timeout, sub->uuid);\n\t\t\tLIST_REMOVE(sub, entries);\n\t\t\tfree(sub);\n\t\t}\n\t\tsub = subnext;\n\t}\n}\n\n#ifdef USE_MINIUPNPDCTL\nvoid write_events_details(int s) {\n\tint n;\n\tchar buff[80];\n\tstruct upnp_event_notify * obj;\n\tstruct subscriber * sub;\n\twrite(s, \"Events details :\\n\", 17);\n\tfor(obj = notifylist.lh_first; obj != NULL; obj = obj->entries.le_next) {\n\t\tn = snprintf(buff, sizeof(buff), \" %p sub=%p state=%d s=%d\\n\",\n\t\t             obj, obj->sub, obj->state, obj->s);\n\t\twrite(s, buff, n);\n\t}\n\twrite(s, \"Subscribers :\\n\", 14);\n\tfor(sub = subscriberlist.lh_first; sub != NULL; sub = sub->entries.le_next) {\n\t\tn = snprintf(buff, sizeof(buff), \" %p timeout=%d seq=%u service=%d\\n\",\n\t\t             sub, (int)sub->timeout, sub->seq, sub->service);\n\t\twrite(s, buff, n);\n\t\tn = snprintf(buff, sizeof(buff), \"   notify=%p %s\\n\",\n\t\t             sub->notify, sub->uuid);\n\t\twrite(s, buff, n);\n\t\tn = snprintf(buff, sizeof(buff), \"   %s\\n\",\n\t\t             sub->callback);\n\t\twrite(s, buff, n);\n\t}\n}\n#endif\n\n#endif\n\n"], "fixing_code": ["/* $Id: upnpevents.c,v 1.39 2018/03/12 22:41:54 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * (c) 2008-2018 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdio.h>\n#include <string.h>\n#include <syslog.h>\n#include <sys/queue.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include \"config.h\"\n#if defined(LIB_UUID)\n/* as found on linux */\n#include <uuid/uuid.h>\n#elif defined(BSD_UUID)\n#include <uuid.h>\n#endif /* LIB_UUID / BSD_UUID */\n#include \"upnpevents.h\"\n#include \"miniupnpdpath.h\"\n#include \"upnpglobalvars.h\"\n#include \"upnpdescgen.h\"\n#include \"upnputils.h\"\n\n#ifdef ENABLE_EVENTS\n/*enum subscriber_service_enum {\n EWanCFG = 1,\n EWanIPC,\n EL3F\n};*/\n\n/* stuctures definitions */\nstruct subscriber {\n\tLIST_ENTRY(subscriber) entries;\n\tstruct upnp_event_notify * notify;\n\ttime_t timeout;\n\tuint32_t seq;\n\tenum subscriber_service_enum service;\n\tchar uuid[42];\n\tchar callback[];\n};\n\nstruct upnp_event_notify {\n\tLIST_ENTRY(upnp_event_notify) entries;\n    int s;  /* socket */\n    enum { ECreated=1,\n\t       EConnecting,\n\t       ESending,\n\t       EWaitingForResponse,\n\t       EFinished,\n\t       EError } state;\n    struct subscriber * sub;\n    char * buffer;\n    int buffersize;\n\tint tosend;\n    int sent;\n\tconst char * path;\n#ifdef ENABLE_IPV6\n\tint ipv6;\n\tchar addrstr[48];\n#else\n\tchar addrstr[16];\n#endif\n\tchar portstr[8];\n};\n\n/* prototypes */\nstatic void\nupnp_event_create_notify(struct subscriber * sub);\n\n/* Subscriber list */\nLIST_HEAD(listhead, subscriber) subscriberlist = { NULL };\n\n/* notify list */\nLIST_HEAD(listheadnotif, upnp_event_notify) notifylist = { NULL };\n\n/* create a new subscriber */\nstatic struct subscriber *\nnewSubscriber(const char * eventurl, const char * callback, int callbacklen)\n{\n\tstruct subscriber * tmp;\n\tif(!eventurl || !callback || !callbacklen)\n\t\treturn NULL;\n\ttmp = calloc(1, sizeof(struct subscriber)+callbacklen+1);\n\tif(!tmp)\n\t\treturn NULL;\n\tif(strcmp(eventurl, WANCFG_EVENTURL)==0)\n\t\ttmp->service = EWanCFG;\n\telse if(strcmp(eventurl, WANIPC_EVENTURL)==0)\n\t\ttmp->service = EWanIPC;\n#ifdef ENABLE_L3F_SERVICE\n\telse if(strcmp(eventurl, L3F_EVENTURL)==0)\n\t\ttmp->service = EL3F;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\telse if(strcmp(eventurl, WANIP6FC_EVENTURL)==0)\n\t\ttmp->service = E6FC;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\telse if(strcmp(eventurl, DP_EVENTURL)==0)\n\t\ttmp->service = EDP;\n#endif\n\telse {\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\tmemcpy(tmp->callback, callback, callbacklen);\n\ttmp->callback[callbacklen] = '\\0';\n#if defined(LIB_UUID)\n\t{\n\t\tuuid_t uuid;\n\t\tuuid_generate(uuid);\n\t\tmemcpy(tmp->uuid, \"uuid:\", 5);\n\t\tuuid_unparse(uuid, tmp->uuid + 5);\n\t}\n#elif defined(BSD_UUID)\n\t{\n\t\tuuid_t uuid;\n\t\tuint32_t status;\n\t\tuuid_create(&uuid, &status);\n\t\tif(status != uuid_s_ok) {\n\t\t\tsyslog(LOG_ERR, \"uuid_create() failed (%u)\", status);\n\t\t} else {\n\t\t\tchar * uuid_str;\n\t\t\tuuid_to_string(&uuid, &uuid_str, &status);\n\t\t\tif(status != uuid_s_ok) {\n\t\t\t\tsyslog(LOG_ERR, \"uuid_to_string() failed (%u)\", status);\n\t\t\t} else {\n\t\t\t\tif(strlen(uuid_str) != 36) {\n\t\t\t\t\tsyslog(LOG_ERR, \"uuid_to_string() returned %s\", uuid_str);\n\t\t\t\t\tstatus = (uint32_t)-1;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(tmp->uuid, \"uuid:\", 5);\n\t\t\t\t\tmemcpy(tmp->uuid + 5, uuid_str, 36);\n\t\t\t\t\ttmp->uuid[sizeof(tmp->uuid)-1] = '\\0';\n\t\t\t\t}\n\t\t\t\tfree(uuid_str);\n\t\t\t}\n\t\t}\n\t\tif(status != uuid_s_ok) {\n\t\t\t/* make a dummy uuid */\n\t\t\tstrncpy(tmp->uuid, uuidvalue_igd, sizeof(tmp->uuid));\n\t\t\ttmp->uuid[sizeof(tmp->uuid)-1] = '\\0';\n\t\t\tsnprintf(tmp->uuid+sizeof(tmp->uuid)-5, 5, \"%04lx\", random() & 0xffff);\n\t\t}\n\t}\n#else\n\t/* make a dummy uuid */\n\tstrncpy(tmp->uuid, uuidvalue_igd, sizeof(tmp->uuid));\n\ttmp->uuid[sizeof(tmp->uuid)-1] = '\\0';\n\tsnprintf(tmp->uuid+sizeof(tmp->uuid)-5, 5, \"%04lx\", random() & 0xffff);\n#endif\n\treturn tmp;\n}\n\n/* creates a new subscriber and adds it to the subscriber list\n * also initiate 1st notify\n * TODO : add a check on the number of subscriber in order to\n * prevent memory overflow... */\nconst char *\nupnpevents_addSubscriber(const char * eventurl,\n                         const char * callback, int callbacklen,\n                         int timeout)\n{\n\tstruct subscriber * tmp;\n\t/*static char uuid[42];*/\n\t/* \"uuid:00000000-0000-0000-0000-000000000000\"; 5+36+1=42bytes */\n\tsyslog(LOG_DEBUG, \"addSubscriber(%s, %.*s, %d)\",\n\t       eventurl, callbacklen, callback, timeout);\n\t/*strncpy(uuid, uuidvalue, sizeof(uuid));\n\tuuid[sizeof(uuid)-1] = '\\0';*/\n\ttmp = newSubscriber(eventurl, callback, callbacklen);\n\tif(!tmp)\n\t\treturn NULL;\n\tif(timeout)\n\t\ttmp->timeout = upnp_time() + timeout;\n\tLIST_INSERT_HEAD(&subscriberlist, tmp, entries);\n\tupnp_event_create_notify(tmp);\n\treturn tmp->uuid;\n}\n\n/* renew a subscription (update the timeout) */\nconst char *\nupnpevents_renewSubscription(const char * sid, int sidlen, int timeout)\n{\n\tstruct subscriber * sub;\n\tfor(sub = subscriberlist.lh_first; sub != NULL; sub = sub->entries.le_next) {\n\t\tif((sidlen == 41) && (memcmp(sid, sub->uuid, 41) == 0)) {\n#ifdef UPNP_STRICT\n\t\t\t/* check if the subscription already timeouted */\n\t\t\tif(sub->timeout && upnp_time() > sub->timeout)\n\t\t\t\tcontinue;\n#endif\n\t\t\tsub->timeout = (timeout ? upnp_time() + timeout : 0);\n\t\t\treturn sub->uuid;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint\nupnpevents_removeSubscriber(const char * sid, int sidlen)\n{\n\tstruct subscriber * sub;\n\tif(!sid)\n\t\treturn -1;\n\tfor(sub = subscriberlist.lh_first; sub != NULL; sub = sub->entries.le_next) {\n\t\tif((sidlen == 41) && (memcmp(sid, sub->uuid, 41) == 0)) {\n\t\t\tif(sub->notify) {\n\t\t\t\tsub->notify->sub = NULL;\n\t\t\t}\n\t\t\tLIST_REMOVE(sub, entries);\n\t\t\tfree(sub);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* notifies all subscriber of a number of port mapping change\n * or external ip address change */\nvoid\nupnp_event_var_change_notify(enum subscriber_service_enum service)\n{\n\tstruct subscriber * sub;\n\tfor(sub = subscriberlist.lh_first; sub != NULL; sub = sub->entries.le_next) {\n\t\tif(sub->service == service && sub->notify == NULL)\n\t\t\tupnp_event_create_notify(sub);\n\t}\n}\n\n/* create and add the notify object to the list */\nstatic void\nupnp_event_create_notify(struct subscriber * sub)\n{\n\tstruct upnp_event_notify * obj;\n\t/*struct timeval sock_timeout;*/\n\n\tobj = calloc(1, sizeof(struct upnp_event_notify));\n\tif(!obj) {\n\t\tsyslog(LOG_ERR, \"%s: calloc(): %m\", \"upnp_event_create_notify\");\n\t\treturn;\n\t}\n\tobj->sub = sub;\n\tobj->state = ECreated;\n#ifdef ENABLE_IPV6\n\tobj->s = socket((obj->sub->callback[7] == '[') ? PF_INET6 : PF_INET,\n\t                SOCK_STREAM, 0);\n#else\n\tobj->s = socket(PF_INET, SOCK_STREAM, 0);\n#endif\n\tif(obj->s<0) {\n\t\tsyslog(LOG_ERR, \"%s: socket(): %m\", \"upnp_event_create_notify\");\n\t\tgoto error;\n\t}\n#if 0 /* does not work for non blocking connect() */\n\t/* set timeout to 3 seconds */\n\tsock_timeout.tv_sec = 3;\n\tsock_timeout.tv_usec = 0;\n\tif(setsockopt(obj->s, SOL_SOCKET, SO_RCVTIMEO, &sock_timeout, sizeof(struct timeval)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(SO_RCVTIMEO): %m\",\n\t\t       \"upnp_event_create_notify\");\n\t}\n\tsock_timeout.tv_sec = 3;\n\tsock_timeout.tv_usec = 0;\n\tif(setsockopt(obj->s, SOL_SOCKET, SO_SNDTIMEO, &sock_timeout, sizeof(struct timeval)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(SO_SNDTIMEO): %m\",\n\t\t       \"upnp_event_create_notify\");\n\t}\n#endif\n\t/* set socket non blocking */\n\tif(!set_non_blocking(obj->s)) {\n\t\tsyslog(LOG_ERR, \"%s: set_non_blocking(): %m\",\n\t\t       \"upnp_event_create_notify\");\n\t\tgoto error;\n\t}\n\tif(sub)\n\t\tsub->notify = obj;\n\tLIST_INSERT_HEAD(&notifylist, obj, entries);\n\treturn;\nerror:\n\tif(obj->s >= 0)\n\t\tclose(obj->s);\n\tfree(obj);\n}\n\nstatic void\nupnp_event_notify_connect(struct upnp_event_notify * obj)\n{\n\tunsigned int i;\n\tconst char * p;\n\tunsigned short port;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n#else\n\tstruct sockaddr_in addr;\n\tsocklen_t addrlen;\n#endif\n\n\tif(!obj)\n\t\treturn;\n\tmemset(&addr, 0, sizeof(addr));\n\ti = 0;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tp = obj->sub->callback;\n\tp += 7;\t/* http:// */\n#ifdef ENABLE_IPV6\n\tif(*p == '[') {\t/* ip v6 */\n\t\tobj->addrstr[i++] = '[';\n\t\tp++;\n\t\tobj->ipv6 = 1;\n\t\twhile(*p != ']' && i < (sizeof(obj->addrstr)-1))\n\t\t\tobj->addrstr[i++] = *(p++);\n\t\tif(*p == ']')\n\t\t\tp++;\n\t\tif(i < (sizeof(obj->addrstr)-1))\n\t\t\tobj->addrstr[i++] = ']';\n\t} else {\n#endif\n\t\twhile(*p != '/' && *p != ':' && i < (sizeof(obj->addrstr)-1))\n\t\t\tobj->addrstr[i++] = *(p++);\n#ifdef ENABLE_IPV6\n\t}\n#endif\n\tobj->addrstr[i] = '\\0';\n\tif(*p == ':') {\n\t\tobj->portstr[0] = *p;\n\t\ti = 1;\n\t\tp++;\n\t\tport = (unsigned short)atoi(p);\n\t\twhile(*p != '/') {\n\t\t\tif(i<7) obj->portstr[i++] = *p;\n\t\t\tp++;\n\t\t}\n\t\tobj->portstr[i] = 0;\n\t} else {\n\t\tport = 80;\n\t\tobj->portstr[0] = '\\0';\n\t}\n\tobj->path = p;\n#ifdef ENABLE_IPV6\n\tif(obj->ipv6) {\n\t\tchar addrstr_tmp[48];\n\t\tstruct sockaddr_in6 * sa = (struct sockaddr_in6 *)&addr;\n\t\tsa->sin6_family = AF_INET6;\n\t\ti = (int)strlen(obj->addrstr);\n\t\tif(i > 2) {\n\t\t\ti -= 2;\n\t\t\tmemcpy(addrstr_tmp, obj->addrstr + 1, i);\n\t\t\taddrstr_tmp[i] = '\\0';\n\t\t\tinet_pton(AF_INET6, addrstr_tmp, &(sa->sin6_addr));\n\t\t}\n\t\tsa->sin6_port = htons(port);\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t} else {\n\t\tstruct sockaddr_in * sa = (struct sockaddr_in *)&addr;\n\t\tsa->sin_family = AF_INET;\n\t\tinet_pton(AF_INET, obj->addrstr, &(sa->sin_addr));\n\t\tsa->sin_port = htons(port);\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t}\n#else\n\taddr.sin_family = AF_INET;\n\tinet_aton(obj->addrstr, &addr.sin_addr);\n\taddr.sin_port = htons(port);\n\taddrlen = sizeof(struct sockaddr_in);\n#endif\n\tsyslog(LOG_DEBUG, \"%s: '%s' %hu '%s'\", \"upnp_event_notify_connect\",\n\t       obj->addrstr, port, obj->path);\n\tobj->state = EConnecting;\n\tif(connect(obj->s, (struct sockaddr *)&addr, addrlen) < 0) {\n\t\tif(errno != EINPROGRESS && errno != EWOULDBLOCK) {\n\t\t\tsyslog(LOG_ERR, \"%s: connect(%d, %s, %u): %m\",\n\t\t\t       \"upnp_event_notify_connect\", obj->s,\n\t\t\t       obj->addrstr, addrlen);\n\t\t\tobj->state = EError;\n\t\t}\n\t}\n}\n\nstatic void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t/* UDA v1.0 */\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t/* UDA v1.1 or later */\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tfor (;;) {\n\t\tobj->buffer = malloc(obj->buffersize);\n\t\tif(!obj->buffer) {\n\t\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t}\n\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t\t                       obj->sub->uuid, obj->sub->seq,\n\t\t                       l, xml);\n\t\tif (obj->tosend < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t} else if (obj->tosend < obj->buffersize) {\n\t\t\tbreak; /* the buffer was large enough */\n\t\t}\n\t\t/* Try again with a buffer big enough */\n\t\tfree(obj->buffer);\n\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */\n\t}\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}\n\nstatic void upnp_event_send(struct upnp_event_notify * obj)\n{\n\tint i;\n\n\tsyslog(LOG_DEBUG, \"%s: sending event notify message to %s%s\",\n\t       \"upnp_event_send\", obj->addrstr, obj->portstr);\n\tsyslog(LOG_DEBUG, \"%s: msg: %s\",\n\t       \"upnp_event_send\", obj->buffer + obj->sent);\n\ti = send(obj->s, obj->buffer + obj->sent, obj->tosend - obj->sent, 0);\n\tif(i<0) {\n\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR) {\n\t\t\tsyslog(LOG_NOTICE, \"%s: send(%s%s): %m\", \"upnp_event_send\",\n\t\t\t       obj->addrstr, obj->portstr);\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* EAGAIN or EWOULDBLOCK or EINTR : no data sent */\n\t\t\ti = 0;\n\t\t}\n\t}\n\tif(i != (obj->tosend - obj->sent))\n\t\tsyslog(LOG_NOTICE, \"%s: %d bytes send out of %d\",\n\t\t       \"upnp_event_send\", i, obj->tosend - obj->sent);\n\tobj->sent += i;\n\tif(obj->sent == obj->tosend)\n\t\tobj->state = EWaitingForResponse;\n}\n\nstatic void upnp_event_recv(struct upnp_event_notify * obj)\n{\n\tint n;\n\tn = recv(obj->s, obj->buffer, obj->buffersize, 0);\n\tif(n<0) {\n\t\tif(errno != EAGAIN &&\n\t\t   errno != EWOULDBLOCK &&\n\t\t   errno != EINTR) {\n\t\t\tsyslog(LOG_ERR, \"%s: recv(): %m\", \"upnp_event_recv\");\n\t\t\tobj->state = EError;\n\t\t}\n\t\treturn;\n\t}\n\tsyslog(LOG_DEBUG, \"%s: (%dbytes) %.*s\", \"upnp_event_recv\",\n\t       n, n, obj->buffer);\n\t/* TODO : do something with the data recevied ?\n\t * right now, n (number of bytes received) is ignored\n\t * We may need to recv() more bytes. */\n\tobj->state = EFinished;\n\tif(obj->sub)\n\t\tobj->sub->seq++;\n}\n\nstatic void\nupnp_event_process_notify(struct upnp_event_notify * obj)\n{\n\tint err;\n\tsocklen_t len;\n\tswitch(obj->state) {\n\tcase EConnecting:\n\t\t/* now connected or failed to connect */\n\t\tlen = sizeof(err);\n\t\tif(getsockopt(obj->s, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: getsockopt: %m\", \"upnp_event_process_notify\");\n\t\t\tobj->state = EError;\n\t\t\tbreak;\n\t\t}\n\t\tif(err != 0) {\n\t\t\terrno = err;\n\t\t\tsyslog(LOG_WARNING, \"%s: connect(%s%s): %m\",\n\t\t\t       \"upnp_event_process_notify\",\n\t\t\t       obj->addrstr, obj->portstr);\n\t\t\tobj->state = EError;\n\t\t\tbreak;\n\t\t}\n\t\tupnp_event_prepare(obj);\n\t\tif(obj->state == ESending)\n\t\t\tupnp_event_send(obj);\n\t\tbreak;\n\tcase ESending:\n\t\tupnp_event_send(obj);\n\t\tbreak;\n\tcase EWaitingForResponse:\n\t\tupnp_event_recv(obj);\n\t\tbreak;\n\tcase EFinished:\n\t\tclose(obj->s);\n\t\tobj->s = -1;\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_ERR, \"%s: unknown state\", \"upnp_event_process_notify\");\n\t}\n}\n\nvoid upnpevents_selectfds(fd_set *readset, fd_set *writeset, int * max_fd)\n{\n\tstruct upnp_event_notify * obj;\n\tfor(obj = notifylist.lh_first; obj != NULL; obj = obj->entries.le_next) {\n\t\tsyslog(LOG_DEBUG, \"upnpevents_selectfds: %p %d %d\",\n\t\t       obj, obj->state, obj->s);\n\t\tif(obj->s >= 0) {\n\t\t\tswitch(obj->state) {\n\t\t\tcase ECreated:\n\t\t\t\tupnp_event_notify_connect(obj);\n\t\t\t\tif(obj->state != EConnecting)\n\t\t\t\t\tbreak;\n\t\t\tcase EConnecting:\n\t\t\tcase ESending:\n\t\t\t\tFD_SET(obj->s, writeset);\n\t\t\t\tif(obj->s > *max_fd)\n\t\t\t\t\t*max_fd = obj->s;\n\t\t\t\tbreak;\n\t\t\tcase EWaitingForResponse:\n\t\t\t\tFD_SET(obj->s, readset);\n\t\t\t\tif(obj->s > *max_fd)\n\t\t\t\t\t*max_fd = obj->s;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid upnpevents_processfds(fd_set *readset, fd_set *writeset)\n{\n\tstruct upnp_event_notify * obj;\n\tstruct upnp_event_notify * next;\n\tstruct subscriber * sub;\n\tstruct subscriber * subnext;\n\ttime_t curtime;\n\tfor(obj = notifylist.lh_first; obj != NULL; obj = obj->entries.le_next) {\n\t\tsyslog(LOG_DEBUG, \"%s: %p %d %d %d %d\",\n\t\t       \"upnpevents_processfds\", obj, obj->state, obj->s,\n\t\t       FD_ISSET(obj->s, readset), FD_ISSET(obj->s, writeset));\n\t\tif(obj->s >= 0) {\n\t\t\tif(FD_ISSET(obj->s, readset) || FD_ISSET(obj->s, writeset))\n\t\t\t\tupnp_event_process_notify(obj);\n\t\t}\n\t}\n\tobj = notifylist.lh_first;\n\twhile(obj != NULL) {\n\t\tnext = obj->entries.le_next;\n\t\tif(obj->state == EError || obj->state == EFinished) {\n\t\t\tif(obj->s >= 0) {\n\t\t\t\tclose(obj->s);\n\t\t\t}\n\t\t\tif(obj->sub)\n\t\t\t\tobj->sub->notify = NULL;\n\t\t\t/* remove also the subscriber from the list if there was an error */\n\t\t\tif(obj->state == EError && obj->sub) {\n\t\t\t\tsyslog(LOG_ERR, \"%s: %p, remove subscriber %s after an ERROR cb: %s\",\n\t\t\t\t       \"upnpevents_processfds\", obj, obj->sub->uuid, obj->sub->callback);\n\t\t\t\tLIST_REMOVE(obj->sub, entries);\n\t\t\t\tfree(obj->sub);\n\t\t\t}\n\t\t\tif(obj->buffer) {\n\t\t\t\tfree(obj->buffer);\n\t\t\t}\n\t\t\tLIST_REMOVE(obj, entries);\n\t\t\tfree(obj);\n\t\t}\n\t\tobj = next;\n\t}\n\t/* remove timeouted subscribers */\n\tcurtime = upnp_time();\n\tfor(sub = subscriberlist.lh_first; sub != NULL; ) {\n\t\tsubnext = sub->entries.le_next;\n\t\tif(sub->timeout && curtime > sub->timeout && sub->notify == NULL) {\n\t\t\tsyslog(LOG_INFO, \"subscriber timeouted : %u > %u SID=%s\",\n\t\t\t       (unsigned)curtime, (unsigned)sub->timeout, sub->uuid);\n\t\t\tLIST_REMOVE(sub, entries);\n\t\t\tfree(sub);\n\t\t}\n\t\tsub = subnext;\n\t}\n}\n\n#ifdef USE_MINIUPNPDCTL\nvoid write_events_details(int s) {\n\tint n;\n\tchar buff[80];\n\tstruct upnp_event_notify * obj;\n\tstruct subscriber * sub;\n\twrite(s, \"Events details :\\n\", 17);\n\tfor(obj = notifylist.lh_first; obj != NULL; obj = obj->entries.le_next) {\n\t\tn = snprintf(buff, sizeof(buff), \" %p sub=%p state=%d s=%d\\n\",\n\t\t             obj, obj->sub, obj->state, obj->s);\n\t\twrite(s, buff, n);\n\t}\n\twrite(s, \"Subscribers :\\n\", 14);\n\tfor(sub = subscriberlist.lh_first; sub != NULL; sub = sub->entries.le_next) {\n\t\tn = snprintf(buff, sizeof(buff), \" %p timeout=%d seq=%u service=%d\\n\",\n\t\t             sub, (int)sub->timeout, sub->seq, sub->service);\n\t\twrite(s, buff, n);\n\t\tn = snprintf(buff, sizeof(buff), \"   notify=%p %s\\n\",\n\t\t             sub->notify, sub->uuid);\n\t\twrite(s, buff, n);\n\t\tn = snprintf(buff, sizeof(buff), \"   %s\\n\",\n\t\t             sub->callback);\n\t\twrite(s, buff, n);\n\t}\n}\n#endif\n\n#endif\n\n"], "filenames": ["miniupnpd/upnpevents.c"], "buggy_code_start_loc": [446], "buggy_code_end_loc": [459], "fixing_code_start_loc": [446], "fixing_code_end_loc": [474], "type": "CWE-252", "message": "The upnp_event_prepare function in upnpevents.c in MiniUPnP MiniUPnPd through 2.1 allows a remote attacker to leak information from the heap due to improper validation of an snprintf return value.", "other": {"cve": {"id": "CVE-2019-12107", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-15T23:29:00.510", "lastModified": "2020-09-28T20:15:12.703", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The upnp_event_prepare function in upnpevents.c in MiniUPnP MiniUPnPd through 2.1 allows a remote attacker to leak information from the heap due to improper validation of an snprintf return value."}, {"lang": "es", "value": "La funci\u00f3n upnp_event_prepare en el archivo upnpevents.c en MiniUPnP MiniUPnPd hasta la versi\u00f3n 2.1, permite a un atacante remoto filtrar informaci\u00f3n desde la pila debido a la validaci\u00f3n inapropiada de un valor de retorno snprintf."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-252"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp.free:miniupnpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1", "matchCriteriaId": "24BD83A5-9532-4534-9F9C-17C8AF7E94BB"}]}]}], "references": [{"url": "https://github.com/miniupnp/miniupnp/commit/bec6ccec63cadc95655721bc0e1dd49dac759d94", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00045.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4542-1/", "source": "cve@mitre.org"}, {"url": "https://www.vdoo.com/blog/security-issues-discovered-in-miniupnp", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/miniupnp/miniupnp/commit/bec6ccec63cadc95655721bc0e1dd49dac759d94"}}