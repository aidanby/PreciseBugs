{"buggy_code": ["/******************************************************************************\n *  bwm-ng handle cmdline and config file options                             *\n *                                                                            *\n *  for more info read README.                                                *\n *                                                                            *\n *  This program is free software; you can redistribute it and/or modify      *\n *  it under the terms of the GNU General Public License as published by      *\n *  the Free Software Foundation; either version 2 of the License, or         *\n *  (at your option) any later version.                                       *\n *                                                                            *\n *  This program is distributed in the hope that it will be useful,           *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n *  GNU General Public License for more details.                              *\n *                                                                            *\n *  You should have received a copy of the GNU General Public License         *\n *  along with this program; if not, write to the Free Software               *\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA *\n *                                                                            *\n *****************************************************************************/\n\n#define EXTERN \n#include \"global_vars.h\"\n#include \"options.h\"\n\n#ifdef CONFIG_FILE\nstatic char* getToken(char** str, const char* delims);\nchar *trim_whitespace(char *str);\nint read_config(const char *config_file);\n#endif\nstatic inline int str2output_unit(char *optarg);\n#if EXTENDED_STATS\nstatic inline int str2output_type(char *optarg);\n#endif\nstatic inline int str2out_method(char *optarg);\nstatic inline int str2in_method(char *optarg);\n\n#ifdef CONFIG_FILE\n /******************************************************************************\n * This is a replacement for strsep which is not portable (missing on Solaris).\n */\nstatic char* getToken(char** str, const char* delims) {\n    char* token;\n\n    if (*str==NULL) {\n        /* No more tokens */\n        return NULL;\n    }\n\n    token=*str;\n    while (**str!='\\0') {\n        if (strchr(delims,**str)!=NULL) {\n            **str='\\0';\n            (*str)++;\n            return token;\n        }\n        (*str)++;\n    }\n    /* There is no other token */\n    *str=NULL;\n    return token;\n}\n/******************************************************************************/\n#endif\n\nstatic inline int str2output_unit(char *optarg) {\n    if (optarg) {\n        if (!strcasecmp(optarg,\"bytes\")) return BYTES_OUT;\n        if (!strcasecmp(optarg,\"bits\")) return BITS_OUT;\n        if (!strcasecmp(optarg,\"packets\")) return PACKETS_OUT;\n        if (!strcasecmp(optarg,\"errors\")) return ERRORS_OUT;\n    }\n    return BYTES_OUT;\n}\n\n#if EXTENDED_STATS\nstatic inline int str2output_type(char *optarg) {\n    if (optarg) {\n        if (!strcasecmp(optarg,\"rate\")) return RATE_OUT;\n        if (!strcasecmp(optarg,\"max\")) return MAX_OUT;\n        if (!strcasecmp(optarg,\"sum\")) return SUM_OUT;\n        if (!strcasecmp(optarg,\"avg\")) return AVG_OUT;\n    }\n    return RATE_OUT;\n}\n#endif  \n\nstatic inline int str2out_method(char *optarg) {\n    if (optarg) {\n        if (!strcasecmp(optarg,\"plain\")) return PLAIN_OUT;\n#ifdef HAVE_CURSES\n            else\n        if (!strcasecmp(optarg,\"curses\")) return CURSES_OUT;\n\t    else\n        if (!strcasecmp(optarg,\"curses2\")) return CURSES2_OUT;\n#endif\n#ifdef CSV\n            else\n        if (!strcasecmp(optarg,\"csv\")) return CSV_OUT;\n#endif\n#ifdef HTML\n        else\n        if (!strcasecmp(optarg,\"html\")) return HTML_OUT;\n#endif\n    }\n    return -1;\n}\n\n\nstatic inline int str2in_method(char *optarg) {\n    if (optarg) {\n#ifdef PROC_NET_DEV\n        if (!strcasecmp(optarg,\"proc\")) return PROC_IN;\n#endif\n#ifdef NETSTAT\n        if (!strcasecmp(optarg,\"netstat\")) return NETSTAT_IN;\n#endif\n#ifdef LIBSTATGRAB\n        if (!strcasecmp(optarg,\"libstat\") || !strcasecmp(optarg,\"statgrab\") || !strcasecmp(optarg,\"libstatgrab\")) return LIBSTAT_IN;\n\t\t  if (!strcasecmp(optarg,\"libstatdisk\")) return LIBSTATDISK_IN;\n#endif\n#ifdef GETIFADDRS\n        if (!strcasecmp(optarg,\"getifaddrs\")) return GETIFADDRS_IN;\n#endif\n#if DEVSTAT_IN\n\t\t  if (!strcasecmp(optarg,\"devstat\")) return DEVSTAT_IN;\n#endif\n#ifdef SYSCTL\n        if (!strcasecmp(optarg,\"sysctl\")) return SYSCTL_IN;\n#endif\n#if SYSCTLDISK_IN\n\t\t  if (!strcasecmp(optarg,\"sysctldisk\")) return SYSCTLDISK_IN;\n#endif\n#ifdef PROC_DISKSTATS\n\t\t  if (!strcasecmp(optarg,\"disk\")) return DISKLINUX_IN;\n#endif\t\t  \n#ifdef WIN32\n\t\t  if (!strcasecmp(optarg,\"win32\")) return WIN32_IN;\n#endif\t\t\t  \n#ifdef HAVE_LIBKSTAT\n\t\t\tif (!strcasecmp(optarg,\"kstat\")) return KSTAT_IN;\n\t\t\tif (!strcasecmp(optarg,\"kstatdisk\")) return KSTATDISK_IN;\n#endif \n#if IOSERVICE_IN\n\t\t\tif (!strcasecmp(optarg,\"ioservice\")) return IOSERVICE_IN;\n#endif\n    }\n    return -1;\n}\n\n\n#ifdef CONFIG_FILE\nchar *trim_whitespace(char *str) {\nchar *dud = str;\nint i;\n\n   /* beginning whitespace first */\n   while( (int)*dud && isspace((int)*dud) )\n      ++dud;\n   /* now trailing whitespace */\n   i = strlen(dud) - 1;\n   while( i>=0 && isspace((int)dud[i]) )\n      --i;\n   dud[i+1] = 0;\n   return dud;\n}\n\n\nint read_config(const char *config_file) {\nFILE *fp;\nchar *buffer;\nchar *token, *value;\n\n  if (config_file==NULL) return -1;\n\n  if( (fp = fopen( config_file, \"r\" ) ) == NULL ) {\n     return -1;\n  }\n\n  buffer = (char*)malloc( sizeof(char) * 4096 );\n\n  while( fgets( buffer, 4096, fp ) ) {\n    value = trim_whitespace( buffer );\n    token = getToken( &value, \"=\" );\n    if( token == NULL )  /* ignore this line if there isn't a token/value pair */\n        continue;\n    token = trim_whitespace( token );\n\n    if( strcasecmp( token, \"TIMEOUT\" ) == 0 ) {\n        if (value && atol(value)>0) { delay=atol(value); }\n#ifdef PROC_NET_DEV\n    } else if( strcasecmp( token, \"PROCFILE\" ) == 0 ) {\n        if (value && (strlen(value)<PATH_MAX)) strcpy(PROC_FILE,value);\n#endif\n#ifdef PROC_DISKSTATS\n    } else if( strcasecmp( token, \"DISKSTATSFILE\" ) == 0 ) {\n        if (value && (strlen(value)<PATH_MAX)) strcpy(PROC_DISKSTATS_FILE,value);\t\t  \n    } else if( strcasecmp( token, \"PARTITIONSFILE\" ) == 0 ) {\n        if (value && (strlen(value)<PATH_MAX)) strcpy(PROC_PARTITIONS_FILE,value);\t\t  \n#endif\n#if ALLOW_NETSTATPATH\n#ifdef NETSTAT\n    } else if( strcasecmp( token, \"NETSTAT\" ) == 0 ) {\n        if (value && (strlen(value)<PATH_MAX)) strcpy(NETSTAT_FILE,value);\n#endif\n#endif\n    } else if( strcasecmp( token, \"INPUT\" ) == 0 ) {\n        if (value) input_method=str2in_method(value);\n\t } else if( strcasecmp( token, \"ANSIOUT\" ) == 0 ) {\n\t\t if (value) ansi_output=value[0]=='0' ? 0 : 1;\n    } else if( strcasecmp( token, \"DYNAMIC\" ) == 0 ) {\n        if (value) dynamic=value[0]=='0' ? 0 : 1;\n    } else if( strcasecmp( token, \"UNIT\" ) == 0 ) {\n        if (value) output_unit=str2output_unit(value);\n#if EXTENDED_STATS\n    } else if( strcasecmp( token, \"TYPE\" ) == 0 ) {\n        if (value) output_type=str2output_type(value);\n    } else if( strcasecmp( token, \"AVGLENGTH\" ) == 0 ) {\n        if (value) avg_length=atoi(value)*1000;\n#endif        \n    } else if( strcasecmp( token, \"ALLIF\" ) == 0 ) {\n        if (value) show_all_if=value[0];\n    } else if( strcasecmp( token, \"INTERFACES\" ) == 0 ) {\n        if (value) iface_list=(char *)strdup(value);\n    } else if( strcasecmp( token, \"OUTPUT\" ) == 0 ) {\n        if (value) output_method=str2out_method(value);\n#ifdef CSV\n    } else if( strcasecmp( token, \"CSVCHAR\" ) == 0 ) {\n        if (value) csv_char=value[0];\n#endif\n#if CSV || HTML\n    } else if( strcasecmp( token, \"OUTFILE\" ) == 0 ) {\n        if (value) { \n            if (out_file) fclose(out_file);\n            out_file=fopen(value,\"a\"); \n            if (!out_file) deinit(1, \"failed to open outfile\\n\");\n            if (out_file_path) free(out_file_path);\n            out_file_path=(char *)strdup(value);\n        }\n#endif\n    } else if( strcasecmp( token, \"COUNT\" ) == 0 ) {\n        if (value) output_count=atol(value);\n    } else if( strcasecmp( token, \"DAEMON\" ) == 0 ) {\n        if (value) daemonize=value[0]=='0' ? 0 : 1;\n    } else if( strcasecmp( token, \"SUMHIDDEN\" ) == 0 ) {\n        if (value) sumhidden=value[0]=='0' ? 0 : 1;\n#if IOSERVICE_IN\n\t } else if( strcasecmp( token, \"LONGDISKNAMES\" ) == 0) {\n\t\t if (value) long_darwin_disk_names=value[0]=='0' ? 0 : 1;\n#endif\n#ifdef HTML\n    } else if( strcasecmp( token, \"HTMLREFRESH\" ) == 0 ) {\n        if (value && atol(value)>0) { html_refresh=atol(value); }\n    } else if( strcasecmp( token, \"HTMLHEADER\" ) == 0 ) {\n        if (value) html_header=value[0]=='0' ? 0 : 1;\n#endif\n    }\n  }\n  free(buffer);\n  fclose(fp);\n\n return 0;\n}\n#endif\n\n\n\nvoid get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\"netstat\",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if EXTENDED_STATS        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef CSV\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef HTML\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                            sumhidden=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\"a\"); \n                    if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}\n\n"], "fixing_code": ["/******************************************************************************\n *  bwm-ng handle cmdline and config file options                             *\n *                                                                            *\n *  for more info read README.                                                *\n *                                                                            *\n *  This program is free software; you can redistribute it and/or modify      *\n *  it under the terms of the GNU General Public License as published by      *\n *  the Free Software Foundation; either version 2 of the License, or         *\n *  (at your option) any later version.                                       *\n *                                                                            *\n *  This program is distributed in the hope that it will be useful,           *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of            *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *\n *  GNU General Public License for more details.                              *\n *                                                                            *\n *  You should have received a copy of the GNU General Public License         *\n *  along with this program; if not, write to the Free Software               *\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA *\n *                                                                            *\n *****************************************************************************/\n\n#define EXTERN \n#include \"global_vars.h\"\n#include \"options.h\"\n\n#ifdef CONFIG_FILE\nstatic char* getToken(char** str, const char* delims);\nchar *trim_whitespace(char *str);\nint read_config(const char *config_file);\n#endif\nstatic inline int str2output_unit(char *optarg);\n#if EXTENDED_STATS\nstatic inline int str2output_type(char *optarg);\n#endif\nstatic inline int str2out_method(char *optarg);\nstatic inline int str2in_method(char *optarg);\n\n#ifdef CONFIG_FILE\n /******************************************************************************\n * This is a replacement for strsep which is not portable (missing on Solaris).\n */\nstatic char* getToken(char** str, const char* delims) {\n    char* token;\n\n    if (*str==NULL) {\n        /* No more tokens */\n        return NULL;\n    }\n\n    token=*str;\n    while (**str!='\\0') {\n        if (strchr(delims,**str)!=NULL) {\n            **str='\\0';\n            (*str)++;\n            return token;\n        }\n        (*str)++;\n    }\n    /* There is no other token */\n    *str=NULL;\n    return token;\n}\n/******************************************************************************/\n#endif\n\nstatic inline int str2output_unit(char *optarg) {\n    if (optarg) {\n        if (!strcasecmp(optarg,\"bytes\")) return BYTES_OUT;\n        if (!strcasecmp(optarg,\"bits\")) return BITS_OUT;\n        if (!strcasecmp(optarg,\"packets\")) return PACKETS_OUT;\n        if (!strcasecmp(optarg,\"errors\")) return ERRORS_OUT;\n    }\n    return BYTES_OUT;\n}\n\n#if EXTENDED_STATS\nstatic inline int str2output_type(char *optarg) {\n    if (optarg) {\n        if (!strcasecmp(optarg,\"rate\")) return RATE_OUT;\n        if (!strcasecmp(optarg,\"max\")) return MAX_OUT;\n        if (!strcasecmp(optarg,\"sum\")) return SUM_OUT;\n        if (!strcasecmp(optarg,\"avg\")) return AVG_OUT;\n    }\n    return RATE_OUT;\n}\n#endif  \n\nstatic inline int str2out_method(char *optarg) {\n    if (optarg) {\n        if (!strcasecmp(optarg,\"plain\")) return PLAIN_OUT;\n#ifdef HAVE_CURSES\n            else\n        if (!strcasecmp(optarg,\"curses\")) return CURSES_OUT;\n\t    else\n        if (!strcasecmp(optarg,\"curses2\")) return CURSES2_OUT;\n#endif\n#ifdef CSV\n            else\n        if (!strcasecmp(optarg,\"csv\")) return CSV_OUT;\n#endif\n#ifdef HTML\n        else\n        if (!strcasecmp(optarg,\"html\")) return HTML_OUT;\n#endif\n    }\n    return -1;\n}\n\n\nstatic inline int str2in_method(char *optarg) {\n    if (optarg) {\n#ifdef PROC_NET_DEV\n        if (!strcasecmp(optarg,\"proc\")) return PROC_IN;\n#endif\n#ifdef NETSTAT\n        if (!strcasecmp(optarg,\"netstat\")) return NETSTAT_IN;\n#endif\n#ifdef LIBSTATGRAB\n        if (!strcasecmp(optarg,\"libstat\") || !strcasecmp(optarg,\"statgrab\") || !strcasecmp(optarg,\"libstatgrab\")) return LIBSTAT_IN;\n\t\t  if (!strcasecmp(optarg,\"libstatdisk\")) return LIBSTATDISK_IN;\n#endif\n#ifdef GETIFADDRS\n        if (!strcasecmp(optarg,\"getifaddrs\")) return GETIFADDRS_IN;\n#endif\n#if DEVSTAT_IN\n\t\t  if (!strcasecmp(optarg,\"devstat\")) return DEVSTAT_IN;\n#endif\n#ifdef SYSCTL\n        if (!strcasecmp(optarg,\"sysctl\")) return SYSCTL_IN;\n#endif\n#if SYSCTLDISK_IN\n\t\t  if (!strcasecmp(optarg,\"sysctldisk\")) return SYSCTLDISK_IN;\n#endif\n#ifdef PROC_DISKSTATS\n\t\t  if (!strcasecmp(optarg,\"disk\")) return DISKLINUX_IN;\n#endif\t\t  \n#ifdef WIN32\n\t\t  if (!strcasecmp(optarg,\"win32\")) return WIN32_IN;\n#endif\t\t\t  \n#ifdef HAVE_LIBKSTAT\n\t\t\tif (!strcasecmp(optarg,\"kstat\")) return KSTAT_IN;\n\t\t\tif (!strcasecmp(optarg,\"kstatdisk\")) return KSTATDISK_IN;\n#endif \n#if IOSERVICE_IN\n\t\t\tif (!strcasecmp(optarg,\"ioservice\")) return IOSERVICE_IN;\n#endif\n    }\n    return -1;\n}\n\n\n#ifdef CONFIG_FILE\nchar *trim_whitespace(char *str) {\nchar *dud = str;\nint i;\n\n   /* beginning whitespace first */\n   while( (int)*dud && isspace((int)*dud) )\n      ++dud;\n   /* now trailing whitespace */\n   i = strlen(dud) - 1;\n   while( i>=0 && isspace((int)dud[i]) )\n      --i;\n   dud[i+1] = 0;\n   return dud;\n}\n\n\nint read_config(const char *config_file) {\nFILE *fp;\nchar *buffer;\nchar *token, *value;\n\n  if (config_file==NULL) return -1;\n\n  if( (fp = fopen( config_file, \"r\" ) ) == NULL ) {\n     return -1;\n  }\n\n  buffer = (char*)malloc( sizeof(char) * 4096 );\n\n  while( fgets( buffer, 4096, fp ) ) {\n    value = trim_whitespace( buffer );\n    token = getToken( &value, \"=\" );\n    if( token == NULL )  /* ignore this line if there isn't a token/value pair */\n        continue;\n    token = trim_whitespace( token );\n\n    if( strcasecmp( token, \"TIMEOUT\" ) == 0 ) {\n        if (value && atol(value)>0) { delay=atol(value); }\n#ifdef PROC_NET_DEV\n    } else if( strcasecmp( token, \"PROCFILE\" ) == 0 ) {\n        if (value && (strlen(value)<PATH_MAX)) strcpy(PROC_FILE,value);\n#endif\n#ifdef PROC_DISKSTATS\n    } else if( strcasecmp( token, \"DISKSTATSFILE\" ) == 0 ) {\n        if (value && (strlen(value)<PATH_MAX)) strcpy(PROC_DISKSTATS_FILE,value);\t\t  \n    } else if( strcasecmp( token, \"PARTITIONSFILE\" ) == 0 ) {\n        if (value && (strlen(value)<PATH_MAX)) strcpy(PROC_PARTITIONS_FILE,value);\t\t  \n#endif\n#if ALLOW_NETSTATPATH\n#ifdef NETSTAT\n    } else if( strcasecmp( token, \"NETSTAT\" ) == 0 ) {\n        if (value && (strlen(value)<PATH_MAX)) strcpy(NETSTAT_FILE,value);\n#endif\n#endif\n    } else if( strcasecmp( token, \"INPUT\" ) == 0 ) {\n        if (value) input_method=str2in_method(value);\n\t } else if( strcasecmp( token, \"ANSIOUT\" ) == 0 ) {\n\t\t if (value) ansi_output=value[0]=='0' ? 0 : 1;\n    } else if( strcasecmp( token, \"DYNAMIC\" ) == 0 ) {\n        if (value) dynamic=value[0]=='0' ? 0 : 1;\n    } else if( strcasecmp( token, \"UNIT\" ) == 0 ) {\n        if (value) output_unit=str2output_unit(value);\n#if EXTENDED_STATS\n    } else if( strcasecmp( token, \"TYPE\" ) == 0 ) {\n        if (value) output_type=str2output_type(value);\n    } else if( strcasecmp( token, \"AVGLENGTH\" ) == 0 ) {\n        if (value) avg_length=atoi(value)*1000;\n#endif        \n    } else if( strcasecmp( token, \"ALLIF\" ) == 0 ) {\n        if (value) show_all_if=value[0];\n    } else if( strcasecmp( token, \"INTERFACES\" ) == 0 ) {\n        if (value) iface_list=(char *)strdup(value);\n    } else if( strcasecmp( token, \"OUTPUT\" ) == 0 ) {\n        if (value) output_method=str2out_method(value);\n#ifdef CSV\n    } else if( strcasecmp( token, \"CSVCHAR\" ) == 0 ) {\n        if (value) csv_char=value[0];\n#endif\n#if CSV || HTML\n    } else if( strcasecmp( token, \"OUTFILE\" ) == 0 ) {\n        if (value) { \n            if (out_file) fclose(out_file);\n            out_file=fopen(value,\"a\"); \n            if (!out_file) deinit(1, \"failed to open outfile\\n\");\n            if (out_file_path) free(out_file_path);\n            out_file_path=(char *)strdup(value);\n        }\n#endif\n    } else if( strcasecmp( token, \"COUNT\" ) == 0 ) {\n        if (value) output_count=atol(value);\n    } else if( strcasecmp( token, \"DAEMON\" ) == 0 ) {\n        if (value) daemonize=value[0]=='0' ? 0 : 1;\n    } else if( strcasecmp( token, \"SUMHIDDEN\" ) == 0 ) {\n        if (value) sumhidden=value[0]=='0' ? 0 : 1;\n#if IOSERVICE_IN\n\t } else if( strcasecmp( token, \"LONGDISKNAMES\" ) == 0) {\n\t\t if (value) long_darwin_disk_names=value[0]=='0' ? 0 : 1;\n#endif\n#ifdef HTML\n    } else if( strcasecmp( token, \"HTMLREFRESH\" ) == 0 ) {\n        if (value && atol(value)>0) { html_refresh=atol(value); }\n    } else if( strcasecmp( token, \"HTMLHEADER\" ) == 0 ) {\n        if (value) html_header=value[0]=='0' ? 0 : 1;\n#endif\n    }\n  }\n  free(buffer);\n  fclose(fp);\n\n return 0;\n}\n#endif\n\n\n\nvoid get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\"netstat\",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if EXTENDED_STATS        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef CSV\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef HTML\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            if(!str) {\n              printf(\"Fatal: failed to allocate %zu bytes.\\n\", strlen(pwd_entry->pw_dir)+14);\n              exit(EXIT_FAILURE);\n            }\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                            sumhidden=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\"a\"); \n                    if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}\n\n"], "filenames": ["src/options.c"], "buggy_code_start_loc": [337], "buggy_code_end_loc": [337], "fixing_code_start_loc": [338], "fixing_code_end_loc": [342], "type": "CWE-476", "message": "An issue was discovered in in bwm-ng v0.6.2. An arbitrary null write exists in get_cmdln_options() function in src/options.c.", "other": {"cve": {"id": "CVE-2022-1341", "sourceIdentifier": "secalert@redhat.com", "published": "2022-04-18T17:15:16.440", "lastModified": "2022-04-27T03:14:52.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in in bwm-ng v0.6.2. An arbitrary null write exists in get_cmdln_options() function in src/options.c."}, {"lang": "es", "value": "Se ha detectado un problema en bwm-ng versi\u00f3n v0.6.2. Se presenta una escritura nula arbitraria en la funci\u00f3n get_cmdln_options() en el archivo src/options.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bwm-ng_project:bwm-ng:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "89AE42EB-83E6-49A5-8A39-E4E88777C1E6"}]}]}], "references": [{"url": "https://github.com/vgropp/bwm-ng/commit/9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vgropp/bwm-ng/issues/26", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vgropp/bwm-ng/commit/9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17"}}