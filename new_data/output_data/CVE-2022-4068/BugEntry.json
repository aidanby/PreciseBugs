{"buggy_code": ["<?php\n/**\n * UserController.php\n *\n * -Description-\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * @link       https://www.librenms.org\n *\n * @copyright  2018 Tony Murray\n * @author     Tony Murray <murraytony@gmail.com>\n */\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests\\StoreUserRequest;\nuse App\\Http\\Requests\\UpdateUserRequest;\nuse App\\Models\\AuthLog;\nuse App\\Models\\Dashboard;\nuse App\\Models\\User;\nuse App\\Models\\UserPref;\nuse Auth;\nuse Flasher\\Prime\\FlasherInterface;\nuse Illuminate\\Support\\Str;\nuse LibreNMS\\Authentication\\LegacyAuth;\nuse LibreNMS\\Config;\nuse URL;\n\nclass UserController extends Controller\n{\n    public function __construct()\n    {\n        $this->middleware('deny-demo');\n    }\n\n    /**\n     * Display a listing of the resource.\n     *\n     * @return \\Illuminate\\View\\View\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function index()\n    {\n        $this->authorize('manage', User::class);\n\n        return view('user.index', [\n            'users' => User::with('preferences')->orderBy('username')->get(),\n            'multiauth' => User::query()->distinct('auth_type')->count('auth_type') > 1,\n        ]);\n    }\n\n    /**\n     * Show the form for creating a new resource.\n     *\n     * @return \\Illuminate\\View\\View\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function create()\n    {\n        $this->authorize('create', User::class);\n\n        $tmp_user = new User;\n        $tmp_user->can_modify_passwd = (int) LegacyAuth::get()->canUpdatePasswords(); // default to true for new users\n\n        return view('user.create', [\n            'user' => $tmp_user,\n            'dashboard' => null,\n            'dashboards' => Dashboard::allAvailable($tmp_user)->get(),\n        ]);\n    }\n\n    /**\n     * Store a newly created resource in storage.\n     *\n     * @param  StoreUserRequest  $request\n     * @return \\Illuminate\\Http\\RedirectResponse\n     */\n    public function store(StoreUserRequest $request, FlasherInterface $flasher)\n    {\n        $user = $request->only(['username', 'realname', 'email', 'descr', 'level', 'can_modify_passwd']);\n        $user['auth_type'] = LegacyAuth::getType();\n        $user['can_modify_passwd'] = $request->get('can_modify_passwd'); // checkboxes are missing when unchecked\n\n        $user = User::create($user);\n\n        $user->setPassword($request->new_password);\n        $user->auth_id = (string) LegacyAuth::get()->getUserid($user->username) ?: $user->user_id;\n        $this->updateDashboard($user, $request->get('dashboard'));\n\n        if ($user->save()) {\n            $flasher->addSuccess(__('User :username created', ['username' => $user->username]));\n\n            return redirect(route('users.index'));\n        }\n\n        $flasher->addError(__('Failed to create user'));\n\n        return redirect()->back();\n    }\n\n    /**\n     * Display the specified resource.\n     *\n     * @param  User  $user\n     * @return string\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function show(User $user)\n    {\n        $this->authorize('view', $user);\n\n        return $user->username;\n    }\n\n    /**\n     * Show the form for editing the specified resource.\n     *\n     * @param  User  $user\n     * @return \\Illuminate\\View\\View\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function edit(User $user)\n    {\n        $this->authorize('update', $user);\n\n        $data = [\n            'user' => $user,\n            'dashboard' => UserPref::getPref($user, 'dashboard'),\n            'dashboards' => Dashboard::allAvailable($user)->get(),\n        ];\n\n        if (Config::get('twofactor')) {\n            $lockout_time = Config::get('twofactor_lock');\n            $twofactor = UserPref::getPref($user, 'twofactor');\n            $data['twofactor_enabled'] = isset($twofactor['key']);\n\n            // if enabled and 3 or more failures\n            $last_failure = isset($twofactor['last']) ? (time() - $twofactor['last']) : 0;\n            $data['twofactor_locked'] = isset($twofactor['fails']) && $twofactor['fails'] >= 3 && (! $lockout_time || $last_failure < $lockout_time);\n        }\n\n        return view('user.edit', $data);\n    }\n\n    /**\n     * Update the specified resource in storage.\n     *\n     * @param  UpdateUserRequest  $request\n     * @param  User  $user\n     * @return \\Illuminate\\Http\\RedirectResponse\n     */\n    public function update(UpdateUserRequest $request, User $user, FlasherInterface $flasher)\n    {\n        if ($request->get('new_password') && $user->canSetPassword($request->user())) {\n            $user->setPassword($request->new_password);\n            /** @var User $current_user */\n            $current_user = Auth::user();\n            Auth::setUser($user); // make sure new password is loaded, can only logout other sessions for the active user\n            Auth::logoutOtherDevices($request->new_password);\n\n            // when setting the password on another account, restore back to the user's account.\n            if ($current_user->user_id !== $user->user_id) {\n                Auth::setUser($current_user);\n            }\n        }\n\n        $user->fill($request->all());\n\n        if ($request->has('dashboard') && $this->updateDashboard($user, $request->get('dashboard'))) {\n            $flasher->addSuccess(__('Updated dashboard for :username', ['username' => $user->username]));\n        }\n\n        if ($user->save()) {\n            $flasher->addSuccess(__('User :username updated', ['username' => $user->username]));\n\n            return redirect(route(Str::contains(URL::previous(), 'preferences') ? 'preferences.index' : 'users.index'));\n        }\n\n        $flasher->addError(__('Failed to update user :username', ['username' => $user->username]));\n\n        return redirect()->back();\n    }\n\n    /**\n     * Remove the specified resource from storage.\n     *\n     * @param  User  $user\n     * @return \\Illuminate\\Http\\JsonResponse\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function destroy(User $user)\n    {\n        $this->authorize('delete', $user);\n\n        $user->delete();\n\n        return response()->json(__('User :username deleted.', ['username' => $user->username]));\n    }\n\n    /**\n     * @param  User  $user\n     * @param  mixed  $dashboard\n     * @return bool\n     */\n    protected function updateDashboard(User $user, $dashboard)\n    {\n        if ($dashboard) {\n            $existing = UserPref::getPref($user, 'dashboard');\n            if ($dashboard != $existing) {\n                UserPref::setPref($user, 'dashboard', $dashboard);\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public function authlog()\n    {\n        $this->authorize('manage', User::class);\n\n        return view('user.authlog', [\n            'authlog' => AuthLog::orderBy('datetime', 'DESC')->get(),\n        ]);\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests;\n\nuse Hash;\nuse Illuminate\\Foundation\\Http\\FormRequest;\nuse LibreNMS\\Config;\n\nclass UpdateUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        if ($this->user()->isAdmin()) {\n            return true;\n        }\n\n        $user = $this->route('user');\n        if ($user && $this->user()->can('update', $user)) {\n            // normal users cannot edit their level or ability to modify a password\n            unset($this['level'], $this['can_modify_passwd']);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'realname' => 'nullable|max:64|alpha_space',\n            'email' => 'nullable|email|max:64',\n            'descr' => 'nullable|max:30|alpha_space',\n            'level' => 'int',\n            'old_password' => 'nullable|string',\n            'new_password' => 'nullable|confirmed|min:' . Config::get('password.min_length', 8),\n            'new_password_confirmation' => 'nullable|same:new_password',\n            'dashboard' => 'int',\n        ];\n    }\n\n    /**\n     * Configure the validator instance.\n     *\n     * @param  \\Illuminate\\Validation\\Validator  $validator\n     * @return void\n     */\n    public function withValidator($validator)\n    {\n        $validator->after(function ($validator) {\n            // if not an admin and new_password is set, check old password matches\n            if (! $this->user()->isAdmin()) {\n                if ($this->has('new_password')) {\n                    if ($this->has('old_password')) {\n                        $user = $this->route('user');\n                        if ($user && ! Hash::check($this->old_password, $user->password)) {\n                            $validator->errors()->add('old_password', __('Existing password did not match'));\n                        }\n                    } else {\n                        $validator->errors()->add('old_password', __('The :attribute field is required.', ['attribute' => 'old_password']));\n                    }\n                }\n            }\n        });\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * UserController.php\n *\n * -Description-\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * @link       https://www.librenms.org\n *\n * @copyright  2018 Tony Murray\n * @author     Tony Murray <murraytony@gmail.com>\n */\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests\\StoreUserRequest;\nuse App\\Http\\Requests\\UpdateUserRequest;\nuse App\\Models\\AuthLog;\nuse App\\Models\\Dashboard;\nuse App\\Models\\User;\nuse App\\Models\\UserPref;\nuse Auth;\nuse Flasher\\Prime\\FlasherInterface;\nuse Illuminate\\Support\\Str;\nuse LibreNMS\\Authentication\\LegacyAuth;\nuse LibreNMS\\Config;\nuse URL;\n\nclass UserController extends Controller\n{\n    public function __construct()\n    {\n        $this->middleware('deny-demo');\n    }\n\n    /**\n     * Display a listing of the resource.\n     *\n     * @return \\Illuminate\\View\\View\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function index()\n    {\n        $this->authorize('manage', User::class);\n\n        return view('user.index', [\n            'users' => User::with('preferences')->orderBy('username')->get(),\n            'multiauth' => User::query()->distinct('auth_type')->count('auth_type') > 1,\n        ]);\n    }\n\n    /**\n     * Show the form for creating a new resource.\n     *\n     * @return \\Illuminate\\View\\View\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function create()\n    {\n        $this->authorize('create', User::class);\n\n        $tmp_user = new User;\n        $tmp_user->can_modify_passwd = (int) LegacyAuth::get()->canUpdatePasswords(); // default to true for new users\n\n        return view('user.create', [\n            'user' => $tmp_user,\n            'dashboard' => null,\n            'dashboards' => Dashboard::allAvailable($tmp_user)->get(),\n        ]);\n    }\n\n    /**\n     * Store a newly created resource in storage.\n     *\n     * @param  StoreUserRequest  $request\n     * @return \\Illuminate\\Http\\RedirectResponse\n     */\n    public function store(StoreUserRequest $request, FlasherInterface $flasher)\n    {\n        $user = $request->only(['username', 'realname', 'email', 'descr', 'level', 'can_modify_passwd']);\n        $user['auth_type'] = LegacyAuth::getType();\n        $user['can_modify_passwd'] = $request->get('can_modify_passwd'); // checkboxes are missing when unchecked\n\n        $user = User::create($user);\n\n        $user->setPassword($request->new_password);\n        $user->auth_id = (string) LegacyAuth::get()->getUserid($user->username) ?: $user->user_id;\n        $this->updateDashboard($user, $request->get('dashboard'));\n\n        if ($user->save()) {\n            $flasher->addSuccess(__('User :username created', ['username' => $user->username]));\n\n            return redirect(route('users.index'));\n        }\n\n        $flasher->addError(__('Failed to create user'));\n\n        return redirect()->back();\n    }\n\n    /**\n     * Display the specified resource.\n     *\n     * @param  User  $user\n     * @return string\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function show(User $user)\n    {\n        $this->authorize('view', $user);\n\n        return $user->username;\n    }\n\n    /**\n     * Show the form for editing the specified resource.\n     *\n     * @param  User  $user\n     * @return \\Illuminate\\View\\View\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function edit(User $user)\n    {\n        $this->authorize('update', $user);\n\n        $data = [\n            'user' => $user,\n            'dashboard' => UserPref::getPref($user, 'dashboard'),\n            'dashboards' => Dashboard::allAvailable($user)->get(),\n        ];\n\n        if (Config::get('twofactor')) {\n            $lockout_time = Config::get('twofactor_lock');\n            $twofactor = UserPref::getPref($user, 'twofactor');\n            $data['twofactor_enabled'] = isset($twofactor['key']);\n\n            // if enabled and 3 or more failures\n            $last_failure = isset($twofactor['last']) ? (time() - $twofactor['last']) : 0;\n            $data['twofactor_locked'] = isset($twofactor['fails']) && $twofactor['fails'] >= 3 && (! $lockout_time || $last_failure < $lockout_time);\n        }\n\n        return view('user.edit', $data);\n    }\n\n    /**\n     * Update the specified resource in storage.\n     *\n     * @param  UpdateUserRequest  $request\n     * @param  User  $user\n     * @return \\Illuminate\\Http\\RedirectResponse\n     */\n    public function update(UpdateUserRequest $request, User $user, FlasherInterface $flasher)\n    {\n        if ($request->get('new_password') && $user->canSetPassword($request->user())) {\n            $user->setPassword($request->new_password);\n            /** @var User $current_user */\n            $current_user = Auth::user();\n            Auth::setUser($user); // make sure new password is loaded, can only logout other sessions for the active user\n            Auth::logoutOtherDevices($request->new_password);\n\n            // when setting the password on another account, restore back to the user's account.\n            if ($current_user->user_id !== $user->user_id) {\n                Auth::setUser($current_user);\n            }\n        }\n\n        $user->fill($request->validated());\n\n        if ($request->has('dashboard') && $this->updateDashboard($user, $request->get('dashboard'))) {\n            $flasher->addSuccess(__('Updated dashboard for :username', ['username' => $user->username]));\n        }\n\n        if ($user->save()) {\n            $flasher->addSuccess(__('User :username updated', ['username' => $user->username]));\n\n            return redirect(route(Str::contains(URL::previous(), 'preferences') ? 'preferences.index' : 'users.index'));\n        }\n\n        $flasher->addError(__('Failed to update user :username', ['username' => $user->username]));\n\n        return redirect()->back();\n    }\n\n    /**\n     * Remove the specified resource from storage.\n     *\n     * @param  User  $user\n     * @return \\Illuminate\\Http\\JsonResponse\n     *\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function destroy(User $user)\n    {\n        $this->authorize('delete', $user);\n\n        $user->delete();\n\n        return response()->json(__('User :username deleted.', ['username' => $user->username]));\n    }\n\n    /**\n     * @param  User  $user\n     * @param  mixed  $dashboard\n     * @return bool\n     */\n    protected function updateDashboard(User $user, $dashboard)\n    {\n        if ($dashboard) {\n            $existing = UserPref::getPref($user, 'dashboard');\n            if ($dashboard != $existing) {\n                UserPref::setPref($user, 'dashboard', $dashboard);\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public function authlog()\n    {\n        $this->authorize('manage', User::class);\n\n        return view('user.authlog', [\n            'authlog' => AuthLog::orderBy('datetime', 'DESC')->get(),\n        ]);\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests;\n\nuse Hash;\nuse Illuminate\\Foundation\\Http\\FormRequest;\nuse LibreNMS\\Config;\n\nclass UpdateUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        if ($this->user()->isAdmin()) {\n            return true;\n        }\n\n        $user = $this->route('user');\n        if ($user && $this->user()->can('update', $user)) {\n            // normal users cannot edit their level or ability to modify a password\n            unset($this['level'], $this['can_modify_passwd']);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        if ($this->user()->isAdmin()) {\n            return [\n                'realname' => 'nullable|max:64|alpha_space',\n                'email' => 'nullable|email|max:64',\n                'descr' => 'nullable|max:30|alpha_space',\n                'new_password' => 'nullable|confirmed|min:' . Config::get('password.min_length', 8),\n                'new_password_confirmation' => 'nullable|same:new_password',\n                'dashboard' => 'int',\n                'level' => 'int',\n                'enabled' => 'nullable',\n                'can_modify_passwd' => 'nullable',\n            ];\n        }\n\n        return [\n            'realname' => 'nullable|max:64|alpha_space',\n            'email' => 'nullable|email|max:64',\n            'descr' => 'nullable|max:30|alpha_space',\n            'old_password' => 'nullable|string',\n            'new_password' => 'nullable|confirmed|min:' . Config::get('password.min_length', 8),\n            'new_password_confirmation' => 'nullable|same:new_password',\n            'dashboard' => 'int',\n        ];\n    }\n\n    /**\n     * Configure the validator instance.\n     *\n     * @param  \\Illuminate\\Validation\\Validator  $validator\n     * @return void\n     */\n    public function withValidator($validator)\n    {\n        $validator->after(function ($validator) {\n            // if not an admin and new_password is set, check old password matches\n            if (! $this->user()->isAdmin()) {\n                if ($this->has('new_password')) {\n                    if ($this->has('old_password')) {\n                        $user = $this->route('user');\n                        if ($user && ! Hash::check($this->old_password, $user->password)) {\n                            $validator->errors()->add('old_password', __('Existing password did not match'));\n                        }\n                    } else {\n                        $validator->errors()->add('old_password', __('The :attribute field is required.', ['attribute' => 'old_password']));\n                    }\n                }\n            }\n        });\n    }\n}\n"], "filenames": ["app/Http/Controllers/UserController.php", "app/Http/Requests/UpdateUserRequest.php"], "buggy_code_start_loc": [183, 39], "buggy_code_end_loc": [184, 45], "fixing_code_start_loc": [183, 40], "fixing_code_end_loc": [184, 57], "type": "CWE-79", "message": "A user is able to enable their own account if it was disabled by an admin while the user still holds a valid session. Moreover, the username is not properly sanitized in the admin user overview. This enables an XSS attack that enables an attacker with a low privilege user to execute arbitrary JavaScript in the context of an admin's account.", "other": {"cve": {"id": "CVE-2022-4068", "sourceIdentifier": "security@huntr.dev", "published": "2022-11-20T05:15:12.183", "lastModified": "2022-11-29T13:37:36.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A user is able to enable their own account if it was disabled by an admin while the user still holds a valid session. Moreover, the username is not properly sanitized in the admin user overview. This enables an XSS attack that enables an attacker with a low privilege user to execute arbitrary JavaScript in the context of an admin's account."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-915"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:librenms:librenms:*:*:*:*:*:*:*:*", "versionEndExcluding": "22.10.0", "matchCriteriaId": "99D1C2AF-9BBB-4F7D-9FC3-4A645F7C284D"}]}]}], "references": [{"url": "https://github.com/librenms/librenms/commit/09a2977adb8bc4b1db116c725d661160c930d3a1", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/becfecc4-22a6-4f94-bf83-d6030b625fdc", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/librenms/librenms/commit/09a2977adb8bc4b1db116c725d661160c930d3a1"}}