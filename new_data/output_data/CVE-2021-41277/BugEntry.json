{"buggy_code": ["(ns metabase.api.geojson\n  (:require [clojure.java.io :as io]\n            [compojure.core :refer [GET]]\n            [metabase.api.common :as api]\n            [metabase.models.setting :as setting :refer [defsetting]]\n            [metabase.util.i18n :as ui18n :refer [deferred-tru tru]]\n            [metabase.util.schema :as su]\n            [ring.util.codec :as rc]\n            [ring.util.response :as rr]\n            [schema.core :as s])\n  (:import java.net.URL\n           org.apache.commons.io.input.ReaderInputStream))\n\n(def ^:private CustomGeoJSON\n  {s/Keyword {:name                     su/NonBlankString\n              :url                      su/NonBlankString\n              :region_key               (s/maybe s/Str)\n              :region_name              (s/maybe s/Str)\n              (s/optional-key :builtin) s/Bool}})\n\n(def ^:private ^:const builtin-geojson\n  {:us_states       {:name        \"United States\"\n                     :url         \"app/assets/geojson/us-states.json\"\n                     :region_key  \"STATE\"\n                     :region_name \"NAME\"\n                     :builtin     true}\n   :world_countries {:name        \"World\"\n                     :url         \"app/assets/geojson/world.json\"\n                     :region_key  \"ISO_A2\"\n                     :region_name \"NAME\"\n                     :builtin     true}})\n\n(defn-  invalid-location-msg []\n  (str (tru \"Invalid GeoJSON file location: must either start with http:// or https:// or be a relative path to a file on the classpath.\")\n       \" \"\n       (tru \"URLs referring to hosts that supply internal hosting metadata are prohibited.\")))\n\n(def ^:private invalid-hosts\n  #{\"169.254.169.254\" ; internal metadata for AWS, OpenStack, and Azure\n    \"metadata.google.internal\" ; internal metadata for GCP\n    })\n\n(defn- valid-host?\n  [^URL url]\n  (not (invalid-hosts (.getHost url))))\n\n(defn- valid-protocol?\n  [^URL url]\n  (#{\"http\" \"https\"} (.getProtocol url)))\n\n(defn- valid-url?\n  [url-string]\n  (try\n    (let [url (URL. url-string)]\n      (and (valid-host? url)\n           (valid-protocol? url)))\n    (catch Throwable e\n      (throw (ex-info (invalid-location-msg) {:status-code 400, :url url-string} e)))))\n\n(defn- valid-geojson-url?\n  [geojson]\n  (every? (fn [[_ {:keys [url]}]]\n            (or\n             (io/resource url)\n             (valid-url? url)))\n          geojson))\n\n(defn- validate-geojson\n  \"Throws a 400 if the supplied `geojson` is poorly structured or has an illegal URL/path\"\n  [geojson]\n  (try\n    (s/validate CustomGeoJSON geojson)\n    (catch Throwable e\n      (throw (ex-info (tru \"Invalid custom GeoJSON\") {:status-code 400} e))))\n  (or (valid-geojson-url? geojson)\n      (throw (ex-info (invalid-location-msg) {:status-code 400}))))\n\n(defsetting custom-geojson\n  (deferred-tru \"JSON containing information about custom GeoJSON files for use in map visualizations instead of the default US State or World GeoJSON.\")\n  :type    :json\n  :default {}\n  :getter  (fn [] (merge (setting/get-json :custom-geojson) builtin-geojson))\n  :setter  (fn [new-value]\n             (when new-value\n               (validate-geojson new-value))\n             (setting/set-json! :custom-geojson new-value))\n  :visibility :public)\n\n(api/defendpoint-async GET \"/:key\"\n  \"Fetch a custom GeoJSON file as defined in the `custom-geojson` setting. (This just acts as a simple proxy for the\n  file specified for `key`).\"\n  [{{:keys [key]} :params} respond raise]\n  {key su/NonBlankString}\n  (if-let [url (get-in (custom-geojson) [(keyword key) :url])]\n    (try\n      (with-open [reader (io/reader (or (io/resource url)\n                                        url))\n                  is     (ReaderInputStream. reader)]\n        (respond (-> (rr/response is)\n                     (rr/content-type \"application/json\"))))\n      (catch Throwable e\n        (raise (ex-info (tru \"GeoJSON URL failed to load\") {:status-code 400}))))\n    (raise (ex-info (tru \"Invalid custom GeoJSON key: {0}\" key) {:status-code 400}))))\n\n(api/defendpoint-async GET \"/\"\n  \"Load a custom GeoJSON file based on a URL or file path provided as a query parameter.\n  This behaves similarly to /api/geojson/:key but doesn't require the custom map to be saved to the DB first.\"\n  [{{:keys [url]} :params} respond raise]\n  {url su/NonBlankString}\n  (let [decoded-url (rc/url-decode url)]\n    (or (io/resource decoded-url)\n        (valid-url? decoded-url))\n    (try\n      (with-open [reader (io/reader (or (io/resource decoded-url)\n                                        decoded-url))\n                  is     (ReaderInputStream. reader)]\n        (respond (-> (rr/response is)\n                     (rr/content-type \"application/json\"))))\n      (catch Throwable e\n        (raise (ex-info (tru \"GeoJSON URL failed to load\") {:status-code 400}))))))\n\n(api/define-routes)\n", "(ns metabase.api.geojson-test\n  (:require [clojure.test :refer :all]\n            [metabase.api.geojson :as geojson-api]\n            [metabase.http-client :as client]\n            [metabase.server.middleware.security :as mw.security]\n            [metabase.test :as mt]\n            [metabase.util :as u]\n            [schema.core :as s]))\n\n(def ^:private ^String test-geojson-url\n  \"URL of a GeoJSON file used for test purposes.\"\n  \"https://raw.githubusercontent.com/metabase/metabase/master/test_resources/test.geojson\")\n\n(def ^:private ^String test-broken-geojson-url\n  \"URL of a GeoJSON file that is a valid URL but which cannot be connected to.\"\n  \"https://raw.githubusercontent.com/metabase/metabase/master/test_resources/broken.geojson\")\n\n(def ^:private test-custom-geojson\n  {:middle-earth {:name        \"Middle Earth\"\n                  :url         test-geojson-url\n                  :builtin     true\n                  :region_key  nil\n                  :region_name nil}})\n\n(def ^:private test-broken-custom-geojson\n  {:middle-earth {:name        \"Middle Earth\"\n                  :url         test-broken-geojson-url\n                  :builtin     true\n                  :region_key  nil\n                  :region_name nil}})\n\n(deftest geojson-schema-test\n  (is (= true\n         (boolean (s/validate @#'geojson-api/CustomGeoJSON test-custom-geojson)))))\n\n(deftest validate-geojson-test\n  (testing \"It validates URLs and files appropriately\"\n    (let [examples {;; Prohibited hosts (see explanation in source file)\n                    \"metadata.google.internal\"                 false\n                    \"https://metadata.google.internal\"         false\n                    \"//metadata.google.internal\"               false\n                    \"169.254.169.254\"                          false\n                    \"http://169.254.169.254/secret-stuff.json\" false\n                    ;; Prohibited protocols\n                    \"ftp://example.com/rivendell.json\"         false\n                    \"example.com/rivendell.json\"               false\n                    ;; Acceptable URLs\n                    \"http://example.com/\"                      true\n                    \"https://example.com/\"                     true\n                    \"http://example.com/rivendell.json\"        true\n                    ;; Resources (files on classpath) are valid\n                    \"c3p0.properties\"                          true\n                    ;; Other files are not\n                    \"./README.md\"                              false\n                    \"file:///tmp\"                              false\n                    ;; Nonsense is invalid\n                    \"rasta@metabase.com\"                       false\n                    \"\"                                         false\n                    \"Tom Bombadil\"                             false}\n          valid?   #'geojson-api/validate-geojson]\n      (doseq [[url should-pass?] examples]\n        (let [geojson {:deadb33f {:name        \"Rivendell\"\n                                  :url         url\n                                  :region_key  nil\n                                  :region_name nil}}]\n          (if should-pass?\n            (is (valid? geojson) url)\n            (is (thrown? clojure.lang.ExceptionInfo (valid? geojson)) url)))))))\n\n(deftest update-endpoint-test\n  (testing \"PUT /api/setting/custom-geojson\"\n    (testing \"test that we can set the value of geojson-api/custom-geojson via the normal routes\"\n      (is (= (merge @#'geojson-api/builtin-geojson test-custom-geojson)\n             ;; try this up to 3 times since Circle's outbound connections likes to randomly stop working\n             (u/auto-retry 3\n               ;; bind a temporary value so it will get set back to its old value here after the API calls are done\n               ;; stomping all over it\n               (mt/with-temporary-setting-values [custom-geojson nil]\n                 ((mt/user->client :crowberto) :put 204 \"setting/custom-geojson\" {:value test-custom-geojson})\n                 ((mt/user->client :crowberto) :get 200 \"setting/custom-geojson\"))))))\n    (testing \"passing in an invalid URL\" ; see above validation test\n      (is (= (str \"Invalid GeoJSON file location: must either start with http:// or https:// or be a relative path to a file on the classpath. \"\n                  \"URLs referring to hosts that supply internal hosting metadata are prohibited.\")\n             ((mt/user->client :crowberto) :put 400 \"setting/custom-geojson\"\n              {:value {:mordor (assoc (first (vals test-custom-geojson))\n                                      :url \"ftp://example.com\")}}))))\n    (testing \"it accepts resources\"\n      (let [resource-geojson {(first (keys test-custom-geojson))\n                              (assoc (first (vals test-custom-geojson))\n                                     :url \"c3p0.properties\")}]\n        (is (= (merge @#'geojson-api/builtin-geojson resource-geojson)\n               (u/auto-retry 3\n                 (mt/with-temporary-setting-values [custom-geojson nil]\n                   ((mt/user->client :crowberto) :put 204 \"setting/custom-geojson\"\n                    {:value resource-geojson})\n                   ((mt/user->client :crowberto) :get 200 \"setting/custom-geojson\")))))))))\n\n(deftest url-proxy-endpoint-test\n  (testing \"GET /api/geojson\"\n    (testing \"test the endpoint that fetches JSON files given a URL\"\n      (is (= {:type        \"Point\"\n              :coordinates [37.77986 -122.429]}\n             ((mt/user->client :rasta) :get 200 \"geojson\" :url test-geojson-url))))\n    (testing \"error is returned if URL connection fails\"\n      (is (= \"GeoJSON URL failed to load\"\n             ((mt/user->client :rasta) :get 400 \"geojson\" :url test-broken-geojson-url))))))\n\n(deftest key-proxy-endpoint-test\n  (testing \"GET /api/geojson/:key\"\n    (mt/with-temporary-setting-values [custom-geojson test-custom-geojson]\n      (testing \"test the endpoint that fetches JSON files given a GeoJSON key\"\n        (is (= {:type        \"Point\"\n                :coordinates [37.77986 -122.429]}\n               ((mt/user->client :rasta) :get 200 \"geojson/middle-earth\"))))\n      (testing \"response should not include the usual cache-busting headers\"\n        (is (= (#'mw.security/cache-far-future-headers)\n               (select-keys (:headers (client/client-full-response :get 200 \"geojson/middle-earth\"))\n                            (keys (#'mw.security/cache-prevention-headers))))))\n      (testing \"should be able to fetch the GeoJSON even if you aren't logged in\"\n        (is (= {:type        \"Point\"\n                :coordinates [37.77986 -122.429]}\n               (client/client :get 200 \"geojson/middle-earth\"))))\n        (testing \"try fetching an invalid key; should fail\"\n          (is (= \"Invalid custom GeoJSON key: invalid-key\"\n                 ((mt/user->client :rasta) :get 400 \"geojson/invalid-key\")))))\n    (mt/with-temporary-setting-values [custom-geojson test-broken-custom-geojson]\n      (testing \"fetching a broken URL should fail\"\n        (is (= \"GeoJSON URL failed to load\"\n               ((mt/user->client :rasta) :get 400 \"geojson/middle-earth\")))))))\n"], "fixing_code": ["(ns metabase.api.geojson\n  (:require [clojure.java.io :as io]\n            [compojure.core :refer [GET]]\n            [metabase.api.common :as api]\n            [metabase.models.setting :as setting :refer [defsetting]]\n            [metabase.util.i18n :as ui18n :refer [deferred-tru tru]]\n            [metabase.util.schema :as su]\n            [ring.util.codec :as rc]\n            [ring.util.response :as rr]\n            [schema.core :as s])\n  (:import java.net.URL\n           org.apache.commons.io.input.ReaderInputStream))\n\n(def ^:private CustomGeoJSON\n  {s/Keyword {:name                     su/NonBlankString\n              :url                      su/NonBlankString\n              :region_key               (s/maybe s/Str)\n              :region_name              (s/maybe s/Str)\n              (s/optional-key :builtin) s/Bool}})\n\n(def ^:private ^:const builtin-geojson\n  {:us_states       {:name        \"United States\"\n                     :url         \"app/assets/geojson/us-states.json\"\n                     :region_key  \"STATE\"\n                     :region_name \"NAME\"\n                     :builtin     true}\n   :world_countries {:name        \"World\"\n                     :url         \"app/assets/geojson/world.json\"\n                     :region_key  \"ISO_A2\"\n                     :region_name \"NAME\"\n                     :builtin     true}})\n\n(defn-  invalid-location-msg []\n  (str (tru \"Invalid GeoJSON file location: must either start with http:// or https:// or be a relative path to a file on the classpath.\")\n       \" \"\n       (tru \"URLs referring to hosts that supply internal hosting metadata are prohibited.\")))\n\n(def ^:private invalid-hosts\n  #{\"169.254.169.254\" ; internal metadata for AWS, OpenStack, and Azure\n    \"metadata.google.internal\" ; internal metadata for GCP\n    })\n\n(defn- valid-host?\n  [^URL url]\n  (not (invalid-hosts (.getHost url))))\n\n(defn- valid-protocol?\n  [^URL url]\n  (#{\"http\" \"https\"} (.getProtocol url)))\n\n(defn- valid-url?\n  [url-string]\n  (try\n    (let [url (URL. url-string)]\n      (and (valid-host? url)\n           (valid-protocol? url)))\n    (catch Throwable e\n      (throw (ex-info (invalid-location-msg) {:status-code 400, :url url-string} e)))))\n\n(defn- valid-geojson-url?\n  [url]\n  (or (io/resource url)\n      (valid-url? url)))\n\n(defn- valid-geojson-urls?\n  [geojson]\n  (every? (fn [[_ {:keys [url]}]] (valid-geojson-url? url))\n          geojson))\n\n(defn- validate-geojson\n  \"Throws a 400 if the supplied `geojson` is poorly structured or has an illegal URL/path\"\n  [geojson]\n  (try\n    (s/validate CustomGeoJSON geojson)\n    (catch Throwable e\n      (throw (ex-info (tru \"Invalid custom GeoJSON\") {:status-code 400} e))))\n  (or (valid-geojson-urls? geojson)\n      (throw (ex-info (invalid-location-msg) {:status-code 400}))))\n\n(defsetting custom-geojson\n  (deferred-tru \"JSON containing information about custom GeoJSON files for use in map visualizations instead of the default US State or World GeoJSON.\")\n  :type    :json\n  :default {}\n  :getter  (fn [] (merge (setting/get-json :custom-geojson) builtin-geojson))\n  :setter  (fn [new-value]\n             (when new-value\n               (validate-geojson new-value))\n             (setting/set-json! :custom-geojson new-value))\n  :visibility :public)\n\n(api/defendpoint-async GET \"/:key\"\n  \"Fetch a custom GeoJSON file as defined in the `custom-geojson` setting. (This just acts as a simple proxy for the\n  file specified for `key`).\"\n  [{{:keys [key]} :params} respond raise]\n  {key su/NonBlankString}\n  (if-let [url (get-in (custom-geojson) [(keyword key) :url])]\n    (try\n      (with-open [reader (io/reader (or (io/resource url)\n                                        url))\n                  is     (ReaderInputStream. reader)]\n        (respond (-> (rr/response is)\n                     (rr/content-type \"application/json\"))))\n      (catch Throwable e\n        (raise (ex-info (tru \"GeoJSON URL failed to load\") {:status-code 400}))))\n    (raise (ex-info (tru \"Invalid custom GeoJSON key: {0}\" key) {:status-code 400}))))\n\n(api/defendpoint-async GET \"/\"\n  \"Load a custom GeoJSON file based on a URL or file path provided as a query parameter.\n  This behaves similarly to /api/geojson/:key but doesn't require the custom map to be saved to the DB first.\"\n  [{{:keys [url]} :params} respond raise]\n  {url su/NonBlankString}\n  (api/check-superuser)\n  (let [decoded-url (rc/url-decode url)]\n    (when-not (valid-geojson-url? decoded-url)\n      (raise (ex-info (invalid-location-msg) {:status-code 400})))\n    (try\n      (with-open [reader (io/reader (or (io/resource decoded-url)\n                                        decoded-url))\n                  is     (ReaderInputStream. reader)]\n        (respond (-> (rr/response is)\n                     (rr/content-type \"application/json\"))))\n      (catch Throwable e\n        (raise (ex-info (tru \"GeoJSON URL failed to load\") {:status-code 400}))))))\n\n(api/define-routes)\n", "(ns metabase.api.geojson-test\n  (:require [clojure.test :refer :all]\n            [metabase.api.geojson :as geojson-api]\n            [metabase.http-client :as client]\n            [metabase.server.middleware.security :as mw.security]\n            [metabase.test :as mt]\n            [metabase.util :as u]\n            [schema.core :as s]))\n\n(def ^:private ^String test-geojson-url\n  \"URL of a GeoJSON file used for test purposes.\"\n  \"https://raw.githubusercontent.com/metabase/metabase/master/test_resources/test.geojson\")\n\n(def ^:private ^String test-broken-geojson-url\n  \"URL of a GeoJSON file that is a valid URL but which cannot be connected to.\"\n  \"https://raw.githubusercontent.com/metabase/metabase/master/test_resources/broken.geojson\")\n\n(def ^:private test-custom-geojson\n  {:middle-earth {:name        \"Middle Earth\"\n                  :url         test-geojson-url\n                  :builtin     true\n                  :region_key  nil\n                  :region_name nil}})\n\n(def ^:private test-broken-custom-geojson\n  {:middle-earth {:name        \"Middle Earth\"\n                  :url         test-broken-geojson-url\n                  :builtin     true\n                  :region_key  nil\n                  :region_name nil}})\n\n(deftest geojson-schema-test\n  (is (= true\n         (boolean (s/validate @#'geojson-api/CustomGeoJSON test-custom-geojson)))))\n\n(deftest validate-geojson-test\n  (testing \"It validates URLs and files appropriately\"\n    (let [examples {;; Prohibited hosts (see explanation in source file)\n                    \"metadata.google.internal\"                 false\n                    \"https://metadata.google.internal\"         false\n                    \"//metadata.google.internal\"               false\n                    \"169.254.169.254\"                          false\n                    \"http://169.254.169.254/secret-stuff.json\" false\n                    ;; Prohibited protocols\n                    \"ftp://example.com/rivendell.json\"         false\n                    \"example.com/rivendell.json\"               false\n                    ;; Acceptable URLs\n                    \"http://example.com/\"                      true\n                    \"https://example.com/\"                     true\n                    \"http://example.com/rivendell.json\"        true\n                    ;; Resources (files on classpath) are valid\n                    \"c3p0.properties\"                          true\n                    ;; Other files are not\n                    \"./README.md\"                              false\n                    \"file:///tmp\"                              false\n                    ;; Nonsense is invalid\n                    \"rasta@metabase.com\"                       false\n                    \"\"                                         false\n                    \"Tom Bombadil\"                             false}\n          valid?   #'geojson-api/validate-geojson]\n      (doseq [[url should-pass?] examples]\n        (let [geojson {:deadb33f {:name        \"Rivendell\"\n                                  :url         url\n                                  :region_key  nil\n                                  :region_name nil}}]\n          (if should-pass?\n            (is (valid? geojson) url)\n            (is (thrown? clojure.lang.ExceptionInfo (valid? geojson)) url)))))))\n\n(deftest update-endpoint-test\n  (testing \"PUT /api/setting/custom-geojson\"\n    (testing \"test that we can set the value of geojson-api/custom-geojson via the normal routes\"\n      (is (= (merge @#'geojson-api/builtin-geojson test-custom-geojson)\n             ;; try this up to 3 times since Circle's outbound connections likes to randomly stop working\n             (u/auto-retry 3\n               ;; bind a temporary value so it will get set back to its old value here after the API calls are done\n               ;; stomping all over it\n               (mt/with-temporary-setting-values [custom-geojson nil]\n                 ((mt/user->client :crowberto) :put 204 \"setting/custom-geojson\" {:value test-custom-geojson})\n                 ((mt/user->client :crowberto) :get 200 \"setting/custom-geojson\"))))))\n    (testing \"passing in an invalid URL\" ; see above validation test\n      (is (= (str \"Invalid GeoJSON file location: must either start with http:// or https:// or be a relative path to a file on the classpath. \"\n                  \"URLs referring to hosts that supply internal hosting metadata are prohibited.\")\n             ((mt/user->client :crowberto) :put 400 \"setting/custom-geojson\"\n              {:value {:mordor (assoc (first (vals test-custom-geojson))\n                                      :url \"ftp://example.com\")}}))))\n    (testing \"it accepts resources\"\n      (let [resource-geojson {(first (keys test-custom-geojson))\n                              (assoc (first (vals test-custom-geojson))\n                                     :url \"c3p0.properties\")}]\n        (is (= (merge @#'geojson-api/builtin-geojson resource-geojson)\n               (u/auto-retry 3\n                 (mt/with-temporary-setting-values [custom-geojson nil]\n                   ((mt/user->client :crowberto) :put 204 \"setting/custom-geojson\"\n                    {:value resource-geojson})\n                   ((mt/user->client :crowberto) :get 200 \"setting/custom-geojson\")))))))))\n\n(deftest url-proxy-endpoint-test\n  (testing \"GET /api/geojson\"\n    (testing \"test the endpoint that fetches JSON files given a URL\"\n      (is (= {:type        \"Point\"\n              :coordinates [37.77986 -122.429]}\n             ((mt/user->client :crowberto) :get 200 \"geojson\" :url test-geojson-url))))\n    (testing \"error is returned if URL connection fails\"\n      (is (= \"GeoJSON URL failed to load\"\n             ((mt/user->client :crowberto) :get 400 \"geojson\" :url test-broken-geojson-url))))\n    (testing \"error is returned if URL is invalid\"\n      (is (= (str \"Invalid GeoJSON file location: must either start with http:// or https:// or be a relative path to \"\n                  \"a file on the classpath. URLs referring to hosts that supply internal hosting metadata are \"\n                  \"prohibited.\")\n             ((mt/user->client :crowberto) :get 400 \"geojson\" :url \"file://tmp\"))))\n    (testing \"cannot be called by non-admins\"\n      (is (= \"You don't have permissions to do that.\"\n             ((mt/user->client :rasta) :get 403 \"geojson\" :url test-geojson-url))))))\n\n(deftest key-proxy-endpoint-test\n  (testing \"GET /api/geojson/:key\"\n    (mt/with-temporary-setting-values [custom-geojson test-custom-geojson]\n      (testing \"test the endpoint that fetches JSON files given a GeoJSON key\"\n        (is (= {:type        \"Point\"\n                :coordinates [37.77986 -122.429]}\n               ((mt/user->client :rasta) :get 200 \"geojson/middle-earth\"))))\n      (testing \"response should not include the usual cache-busting headers\"\n        (is (= (#'mw.security/cache-far-future-headers)\n               (select-keys (:headers (client/client-full-response :get 200 \"geojson/middle-earth\"))\n                            (keys (#'mw.security/cache-prevention-headers))))))\n      (testing \"should be able to fetch the GeoJSON even if you aren't logged in\"\n        (is (= {:type        \"Point\"\n                :coordinates [37.77986 -122.429]}\n               (client/client :get 200 \"geojson/middle-earth\"))))\n      (testing \"try fetching an invalid key; should fail\"\n        (is (= \"Invalid custom GeoJSON key: invalid-key\"\n               ((mt/user->client :rasta) :get 400 \"geojson/invalid-key\")))))\n    (mt/with-temporary-setting-values [custom-geojson test-broken-custom-geojson]\n      (testing \"fetching a broken URL should fail\"\n        (is (= \"GeoJSON URL failed to load\"\n               ((mt/user->client :rasta) :get 400 \"geojson/middle-earth\")))))))\n"], "filenames": ["src/metabase/api/geojson.clj", "test/metabase/api/geojson_test.clj"], "buggy_code_start_loc": [60, 103], "buggy_code_end_loc": [113, 126], "fixing_code_start_loc": [61, 103], "fixing_code_end_loc": [116, 134], "type": "CWE-20", "message": "Metabase is an open source data analytics platform. In affected versions a security issue has been discovered with the custom GeoJSON map (`admin->settings->maps->custom maps->add a map`) support and potential local file inclusion (including environment variables). URLs were not validated prior to being loaded. This issue is fixed in a new maintenance release (0.40.5 and 1.40.5), and any subsequent release after that. If you\u00e2\u20ac\u2122re unable to upgrade immediately, you can mitigate this by including rules in your reverse proxy or load balancer or WAF to provide a validation filter before the application.", "other": {"cve": {"id": "CVE-2021-41277", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-17T20:15:10.587", "lastModified": "2021-11-23T14:48:23.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Metabase is an open source data analytics platform. In affected versions a security issue has been discovered with the custom GeoJSON map (`admin->settings->maps->custom maps->add a map`) support and potential local file inclusion (including environment variables). URLs were not validated prior to being loaded. This issue is fixed in a new maintenance release (0.40.5 and 1.40.5), and any subsequent release after that. If you\u00e2\u20ac\u2122re unable to upgrade immediately, you can mitigate this by including rules in your reverse proxy or load balancer or WAF to provide a validation filter before the application."}, {"lang": "es", "value": "Metabase es una plataforma de an\u00e1lisis de datos de c\u00f3digo abierto. En las versiones afectadas se ha detectado un problema de seguridad con el soporte de mapas GeoJSON personalizados (\"admin-&gt;settings-&gt;maps-&gt;custom maps-&gt;add a map\") y la posible inclusi\u00f3n de archivos locales (incluyendo variables de entorno). Las URLs no se comprueban antes de ser cargadas. Este problema se ha corregido en una nueva versi\u00f3n de mantenimiento (0.40.5 y 1.40.5), y en cualquier otra versi\u00f3n posterior. Si no puede actualizar inmediatamente, puede mitigar esto incluyendo reglas en su proxy inverso o balanceador de carga o WAF para proporcionar un filtro de comprobaci\u00f3n antes de la aplicaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:0.40.0:-:*:*:*:*:*:*", "matchCriteriaId": "1549F956-E3E4-4868-B6FB-CA07B2E73F03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:0.40.1:*:*:*:*:*:*:*", "matchCriteriaId": "E86449C9-BFB0-46A1-936E-00463B7DF91B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:0.40.2:*:*:*:*:*:*:*", "matchCriteriaId": "CA25627C-2B1B-4F65-A887-43F20883CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:0.40.3:*:*:*:*:*:*:*", "matchCriteriaId": "69FEE724-5FF7-4B76-9A1E-32874F4B3DB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:0.40.4:*:*:*:*:*:*:*", "matchCriteriaId": "B1BE1760-C696-4F2E-BD5F-92EB7613E2BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:1.40.0:-:*:*:*:*:*:*", "matchCriteriaId": "61DD04AC-FEF1-490F-B8C3-4588C49AF891"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:1.40.1:*:*:*:*:*:*:*", "matchCriteriaId": "A083C7A3-B12B-42A2-9246-99E36477A185"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:1.40.2:*:*:*:*:*:*:*", "matchCriteriaId": "3D3F5567-F5D8-4967-A698-1FECCEF20338"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:1.40.3:*:*:*:*:*:*:*", "matchCriteriaId": "75422374-9799-4EFE-B02C-1ADD694B8106"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:1.40.4:*:*:*:*:*:*:*", "matchCriteriaId": "38156036-9D92-4E91-AABD-DD37E12C5E9A"}]}]}], "references": [{"url": "https://github.com/metabase/metabase/commit/042a36e49574c749f944e19cf80360fd3dc322f0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/metabase/metabase/security/advisories/GHSA-w73v-6p7p-fpfr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/metabase/metabase/commit/042a36e49574c749f944e19cf80360fd3dc322f0"}}