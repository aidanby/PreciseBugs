{"buggy_code": ["#!/usr/bin/python\n\"\"\"\nSpellchecker\n\nURI: http://www.w3.org/2002/01/spellchecker\nMaintainer: dom@w3.org\n\nSee also a version that features recursive checking:\nhttp://www.w3.org/mid/1ce6d0230912160806x1ee6f25dgafc73865140b239e@mail.gmail.com\n\nShare and Enjoy. Open Source license:\nCopyright (c) 2001-2005 W3C (MIT, ERCIM, Keio)\nhttp://www.w3.org/Consortium/Legal/2002/copyright-software-20021231\n$Id$\n branched from v 1.46\n\"\"\"\n\nimport os\nimport cgi\nimport sys\nimport string\nimport urlparse\nimport popen2\n\ncustomized_dico=\"/usr/local/share/aspell/w3c.dat\"\nlanguages = {\"en_US\":\"English\",\"fr\":\"French\"}\ndef format_option(a,b,c):\n        if a:\n                selected=\"\"\n                if a==c:\n                        selected=\" selected='selected'\"\n                return \"<option value='%s'%s>%s</option>\" % (a,selected,b)\n\ndef concat(a,b):\n        return a+b\n\n\nPage1 =\"\"\"Content-Type:text/html; charset=utf-8\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en-US\" lang=\"en-US\">\n<head>\n  %s\n  <title>W3C Spell Checker %s</title>\n  <link rel=\"stylesheet\" href=\"http://www.w3.org/Stylesheets/base\"/>\n  <link rel=\"stylesheet\" href=\"http://www.w3.org/2001/11/results\"/>\n  <style type=\"text/css\">\n   ul.suggestions { height:5em; overflow:auto; width:10em;}\n   \n  </style>\n</head>\n\n<body>\n<p><a href=\"http://www.w3.org\"><img src=\"http://www.w3.org/Icons/w3c_home\" alt=\"W3C\"/></a></p>\n\n<h1>W3C Spell Checker %s</h1>\n\n<h2>Status</h2>\n<p>This tool allows you to check the spelling of a web page. It currently only supports English and French.</p>\n\n<h2>Usage</h2>\n<form action=\"\" method=\"get\"><p><label>URI of the document to be checked:<input type=\"text\" value=\"%s\" name=\"uri\"/></label><br />\n<label>Language of the document: <select name=\"lang\">%s</select><br />\n<label>Presents possible corrections: <input type=\"checkbox\" name=\"suggest\"%s /></label><br />\n<input type=\"submit\" value=\"Get results\"/></p></form>\n\"\"\"\n\nPage2 = \"\"\"\n<h2>See also</h2>\n<ul>\n<li><a href=\"http://www.w3.org/QA/Tools\">the QA Toolbox</a></li>\n</ul>\n\n<h2>References</h2>\n<ul>\n<li><a href=\"http://aspell.sourceforge.net\">Aspell</a> is used in the back-end</li>\n<li>The front-end is coded in <a href=\"http://www.python.org\">Python</a></li>\n</ul>\n<h2>Known bugs and limitations</h2>\n<ul>\n<li>Doesn't handle language switching on the <code>lang</code> and <code>xml:lang</code> attributes</li>\n<li>Doesn't check textual attributes (e.g. <code>title</code>, <code>alt</code>)</li>\n</ul>\n<hr/>\n<address><a href=\"http://www.w3.org/People/Dom/\">Dominique Haza&euml;l-Massieux</a><br/>\nLast Modified: $Date$\n</address>\n</body>\n</html>\n\"\"\"\n\ndef format(fp,suggest):\n\tline = fp.readline()\n\twords = {}\n\tcount = 0\n\twhile line!=\"\":\n\t\tif line!=\"\\n\" and line !=\"*\\n\" and line[0]!=\"@\":\n\t\t\tline = line[:-1]\n\t\t\tparts = string.split(line,\": \")\n\t\t\tfields = string.split(parts[0],\" \")\n\t\t\tif fields[0]==\"&\":\n\t\t\t\tvalues = string.split(parts[1],\", \")\n\t\t\t\tif (not words.has_key(fields[1])):\n\t\t\t\t\twords[fields[1]]=values\n\t\t\telif fields[0]==\"#\":\n\t\t\t\tif (not words.has_key(fields[1])):\n\t\t\t\t\twords[fields[1]]=[]\n\t\telif line==\"\\n\":\n\t\t\tcount = count + 1\n\t\tline = fp.readline()\n\toffsets = {}\n\tcount = 0\n\tif len(words):\n                keys = words.keys()\n                keys.sort()\n\t\tprint \"<form action=\\\"http://www.w3.org/Team/update_dictionary\\\" method=\\\"post\\\"><ol>\"\n\t\tfor error in keys:\n\t\t\tprint \"<li>\\\"<span class='no'>%s</span>\\\" (<input type=\\\"checkbox\\\" name=\\\"list[]\\\" value=\\\"%s\\\"/> add to the dictionary)\" % (error,error)\n\n\t\t\tif len(words[error]) and suggest:\n\t\t\t\tprint \"; suggestions:<ul class='suggestions'>\"\n\t\t\t\tfor option in words[error]:\n\t\t\t\t\tprint \"<li>%s</li>\" % option\n\t\t\t\tprint \"</ul>\"\t\t\t\t\n\t\t\tprint \"</li>\"\n\t\tprint \"</ol><p><label><input type=\\\"submit\\\" value=\\\"Update dictionary\\\"/> (W3C Comm Team only)</label></p></form>\"\n\telse:\n\t\tprint \"<p><span class='yes'>No errors</span> found.</p>\"\n\nif __name__ == '__main__':\n\tif  os.environ.has_key('SCRIPT_NAME'):\n\t\tfields = cgi.FieldStorage()\n\t\turi =\"\" \n\t\turi_text =\"\"\n\t\turi_text1=\"\"\n\t\tsuggest=0\n\t\tsuggest_txt=''\n\t\tif fields.has_key('uri'):\n\t\t\turi = fields['uri'].value\n                elif fields.has_key('referrer') and os.environ.has_key('HTTP_REFERER'):\n                        uri = os.environ['HTTP_REFERER']\n                if uri:\n\t\t\turi_text1=\"for %s\" % (cgi.escape(uri))\n\t\t\turi_text=\" for <a href=\\\"%s\\\">%s</a>\" %(cgi.escape(uri),cgi.escape(uri))\n                lang = \"en_US\"\n                if fields.has_key('lang') and fields['lang'].value in languages.keys():\n                        lang=fields['lang'].value\n                languages_options = reduce(concat,map(format_option,languages.keys(),languages.values(),[lang for x in languages.keys()]))\n\n\t\tif fields.has_key('suggest'):\n\t\t\tif fields['suggest'].value=='on':\n\t\t\t\tsuggest=1\n\t\t\t\tsuggest_txt=\" checked='checked'\"\n\t\tif uri:\n\t\t\timport http_auth\n\t\t\turl_opener = http_auth.ProxyAuthURLopener()\n\t\t\ttry:\n\t\t\t\tfp = url_opener.open(uri)\n\t\t\texcept IOError as e:\n\t\t\t\turl_opener.error = \"I/O error: %s %s\" % (e.errno,e.strerror)\n\t\t\t\tfp = None\n\t\t\tprint Page1 % ('<meta name=\"ROBOTS\" content=\"NOINDEX,NOFOLLOW\"/>',uri_text1,uri_text,cgi.escape(uri),languages_options,suggest_txt)\n\t\t\tif fp:\n                                personal = \"--personal=%s\" % customized_dico\n                                if lang!=\"en_US\":\n                                        personal = \"\"\n                                headers = fp.info()\n                                charset_opt = \"\"\n                                if headers.has_key('Content-Type'):\n                                        contentType = cgi.parse_header(headers[\"Content-Type\"])\n                                        if contentType[1].has_key('charset'):\n                                                charset_opt = \"-assume_charset=%s\" % contentType[1]['charset']\n\t        \t\tcommand = \"/usr/bin/lynx  %s -cfg=/usr/local/lib/lynx.cfg -nolist -dump -stdin|/usr/bin/aspell --encoding=utf-8 --lang %s -a %s --sug-mode=fast\" % (charset_opt,lang,personal)\n\n        \t                (piperfd,pipewfd,pipeErr) = popen2.popen3(command)\n\n\t\t\t\tpipewfd.write(fp.read())\n\t\t\t\tfp.close()\n\t\t\t\tpipewfd.close()\n\t\t\t\t# Need to find a way to display any errors if relevant\n\t\t\t\tprocessingErrors=\"\"\n\t\t\t\tif (processingErrors):\n\t\t\t\t\tprint \"<p>The following error occurred when trying to process your request :</p><pre class='no'>\"\n\t\t\t\t\tprint \"</pre>\"\n\t\t\t\t\tpipeErr.close()\n\t\t\t\tif (piperfd):\n\t\t\t\t\tprint \"<h2>Errors found in the page</h2>\"\n\t\t\t\t\tformat(piperfd,suggest)\n\t\t\t\t\tpiperfd.close()\n\t\t\telse:\n\t\t\t\tprint \"<p><span class='no'>Unable to read</span> <a href='%s'>%s</a> (%s). Sorry, check the URI.</p>\" % (cgi.escape(uri),cgi.escape(uri), url_opener.error)\n\t\telse:\n\t\t\tprint Page1 % ('',uri_text1,uri_text,cgi.escape(uri),languages_options,suggest_txt)\n\t\tprint Page2\n\n\n\n"], "fixing_code": ["#!/usr/bin/python\n\"\"\"\nSpellchecker\n\nURI: http://www.w3.org/2002/01/spellchecker\nMaintainer: dom@w3.org\n\nSee also a version that features recursive checking:\nhttp://www.w3.org/mid/1ce6d0230912160806x1ee6f25dgafc73865140b239e@mail.gmail.com\n\nShare and Enjoy. Open Source license:\nCopyright (c) 2001-2005 W3C (MIT, ERCIM, Keio)\nhttp://www.w3.org/Consortium/Legal/2002/copyright-software-20021231\n$Id$\n branched from v 1.46\n\"\"\"\n\nimport cgi\nimport checkremote\nimport http_auth\nimport os\nimport sys\nimport urlparse\n\nfrom cleanhtml import *\nfrom subprocess import Popen, PIPE\n\nlanguages = {\"en_US\":\"English\",\"fr\":\"French\"}\ndef format_option(a,b,c):\n        if a:\n                selected=\"\"\n                if a==c:\n                        selected=\" selected='selected'\"\n                return clean_format(\"<option value='%s'%s>%s</option>\",\n                                    a, selected, b)\n\nPage1 =\"\"\"Content-Type:text/html; charset=utf-8\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en-US\" lang=\"en-US\">\n<head>\n  %s\n  <title>W3C Spell Checker %s</title>\n  <link rel=\"stylesheet\" href=\"http://www.w3.org/Stylesheets/base\"/>\n  <link rel=\"stylesheet\" href=\"http://www.w3.org/2001/11/results\"/>\n  <style type=\"text/css\">\n   ul.suggestions { height:5em; overflow:auto; width:10em;}\n   \n  </style>\n</head>\n\n<body>\n<p><a href=\"http://www.w3.org\"><img src=\"http://www.w3.org/Icons/w3c_home\" alt=\"W3C\"/></a></p>\n\n<h1>W3C Spell Checker %s</h1>\n\n<h2>Status</h2>\n<p>This tool allows you to check the spelling of a web page. It currently only supports English and French.</p>\n\n<h2>Usage</h2>\n<form action=\"\" method=\"get\"><p><label>URI of the document to be checked:<input type=\"text\" value=\"%s\" name=\"uri\"/></label><br />\n<label>Language of the document: <select name=\"lang\">%s</select><br />\n<label>Presents possible corrections: <input type=\"checkbox\" name=\"suggest\"%s /></label><br />\n<input type=\"submit\" value=\"Get results\"/></p></form>\n\"\"\"\n\nPage2 = \"\"\"\n<h2>See also</h2>\n<ul>\n<li><a href=\"http://www.w3.org/QA/Tools\">the QA Toolbox</a></li>\n</ul>\n\n<h2>References</h2>\n<ul>\n<li><a href=\"http://aspell.sourceforge.net\">Aspell</a> is used in the back-end</li>\n<li>The front-end is coded in <a href=\"http://www.python.org\">Python</a></li>\n</ul>\n<h2>Known bugs and limitations</h2>\n<ul>\n<li>Doesn't handle language switching on the <code>lang</code> and <code>xml:lang</code> attributes</li>\n<li>Doesn't check textual attributes (e.g. <code>title</code>, <code>alt</code>)</li>\n</ul>\n<hr/>\n<address><a href=\"http://www.w3.org/People/Dom/\">Dominique Haza&euml;l-Massieux</a><br/>\nLast Modified: $Date$\n</address>\n</body>\n</html>\n\"\"\"\n\ndef format(fp,suggest):\n\twords = {}\n        for line in fp:\n                line = line.rstrip('\\n')\n\t\tif line and line != \"*\" and line[0] != \"@\":\n\t\t\tparts = line.split(': ')\n\t\t\tfields = parts[0].split()\n                        if fields[1] in words:\n                                continue\n\t\t\telif fields[0]==\"&\":\n                                words[fields[1]] = parts[1].split(\", \")\n\t\t\telif fields[0]==\"#\":\n                                words[fields[1]] = []\n\tif not words:\n\t\tprint \"<p><span class='yes'>No errors</span> found.</p>\"\n                return\n        for error in sorted(words):\n                clean_print(\"<li>\\\"<span class='no'>%s</span>\\\"\", error)\n                if words[error] and suggest:\n                        print \"; suggestions:<ul class='suggestions'>\"\n                        for option in words[error]:\n                                clean_print(\"<li>%s</li>\", option)\n                        print \"</ul>\"\t\t\t\t\n                print \"</li>\"\n\ndef getLangSetup(fields):\n        lang = fields.getfirst('lang')\n        if lang not in languages:\n                lang = 'en_US'\n        lang_opts = ''.join(format_option(code, languages[code], lang)\n                            for code in languages)\n        return lang, lang_opts\n\ndef getSuggestSetup(fields):\n        if fields.getfirst('suggest') == 'on':\n                return True, \" checked='checked'\"\n        return False, \"\"\n\ndef getURI(fields):\n        uri = fields.getfirst('uri')\n        if (not uri) and ('referrer' in fields):\n                uri = os.environ.get('HTTP_REFERER')\n        return uri\n\nif __name__ == '__main__':\n        fields = cgi.FieldStorage()\n        lang, languages_options = getLangSetup(fields)\n        suggest, suggest_txt = getSuggestSetup(fields)\n        uri = getURI(fields)\n        if not uri:\n                print Page1 % ('', '', '', clean_str(uri), languages_options,\n                               suggest_txt)\n                print Page2\n                sys.exit()\n\n        uri_text1 = clean_format(\"for %s\", uri)\n        uri_text = clean_format(\" for <a href=\\\"%s\\\">%s</a>\", uri, uri)\n        print Page1 % ('<meta name=\"ROBOTS\" content=\"NOINDEX,NOFOLLOW\"/>',\n                       uri_text1, uri_text, clean_str(uri), languages_options,\n                       suggest_txt)\n\n        url_opener = http_auth.ProxyAuthURLopener()\n        try:\n                fp = url_opener.open(uri)\n        except IOError as e:\n                url_opener.error = \"I/O error: %s %s\" % (e.errno,e.strerror)\n                fp = None\n        if fp is None:\n                clean_print(\"<p><span class='no'>Unable to read</span> <a href='%s'>%s</a> (%s). Sorry, check the URI.</p>\", uri, uri, url_opener.error)\n                print Page2\n                sys.exit()\n\n        headers = fp.info()\n        lynx_cmd = ['/usr/bin/lynx', '-cfg=/usr/local/lib/lynx.cfg', '-nolist',\n                    '-dump', '-stdin']\n        if headers.has_key('Content-Type'):\n                contentType = cgi.parse_header(headers['Content-Type'])\n                if contentType[1].has_key('charset'):\n                        lynx_cmd.append('-assume_charset=%s' %\n                                        contentType[1]['charset'])\n\n        lynx_proc = Popen(lynx_cmd, stdin=fp, stdout=PIPE)\n        aspell_proc = Popen(['/usr/bin/aspell', '-a', '--encoding=utf-8',\n                             '--sug-mode=fast', '--lang', lang],\n                            stdin=lynx_proc.stdout, stdout=PIPE)\n        lynx_proc.wait()\n        lynx_proc.stdout.close()\n        print \"<h2>Errors found in the page</h2>\"\n        format(aspell_proc.stdout, suggest)\n        aspell_proc.stdout.close()\n        print Page2\n"], "filenames": ["spellchecker"], "buggy_code_start_loc": [17], "buggy_code_end_loc": [201], "fixing_code_start_loc": [18], "fixing_code_end_loc": [185], "type": "CWE-79", "message": "A vulnerability was found in w3c online-spellchecker-py up to 20140130. It has been rated as problematic. This issue affects some unknown processing of the file spellchecker. The manipulation leads to cross site scripting. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The identifier of the patch is d6c21fd8187c5db2a50425ff80694149e75d722e. It is recommended to apply a patch to fix this issue. The identifier VDB-248849 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2014-125108", "sourceIdentifier": "cna@vuldb.com", "published": "2023-12-23T17:15:07.773", "lastModified": "2024-02-29T01:14:38.183", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability was found in w3c online-spellchecker-py up to 20140130. It has been rated as problematic. This issue affects some unknown processing of the file spellchecker. The manipulation leads to cross site scripting. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The identifier of the patch is d6c21fd8187c5db2a50425ff80694149e75d722e. It is recommended to apply a patch to fix this issue. The identifier VDB-248849 was assigned to this vulnerability."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad en w3c online-spellchecker-py hasta 20140130. Se ha calificado como problem\u00e1tica. Este problema afecta un procesamiento desconocido del corrector ortogr\u00e1fico de archivos. La manipulaci\u00f3n conduce a cross site scripting. El ataque puede iniciarse de forma remota. La complejidad de un ataque es bastante alta. Se sabe que la explotaci\u00f3n es dif\u00edcil. El identificador del parche es d6c21fd8187c5db2a50425ff80694149e75d722e. Se recomienda aplicar un parche para solucionar este problema. A esta vulnerabilidad se le asign\u00f3 el identificador VDB-248849."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:w3:spell_checker:*:*:*:*:*:*:*:*", "versionEndExcluding": "2014-01-31", "matchCriteriaId": "ECC53122-2509-47E6-BCDD-F8C72E93D7C7"}]}]}], "references": [{"url": "https://github.com/w3c/online-spellchecker-py/commit/d6c21fd8187c5db2a50425ff80694149e75d722e", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://vuldb.com/?ctiid.248849", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.248849", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/w3c/online-spellchecker-py/commit/d6c21fd8187c5db2a50425ff80694149e75d722e"}}