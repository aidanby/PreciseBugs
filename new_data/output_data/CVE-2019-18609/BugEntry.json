{"buggy_code": ["/*\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MIT\n *\n * Portions created by Alan Antonuk are Copyright (c) 2012-2014\n * Alan Antonuk. All Rights Reserved.\n *\n * Portions created by VMware are Copyright (c) 2007-2012 VMware, Inc.\n * All Rights Reserved.\n *\n * Portions created by Tony Garnock-Jones are Copyright (c) 2009-2010\n * VMware, Inc. and Tony Garnock-Jones. All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * ***** END LICENSE BLOCK *****\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"amqp_private.h\"\n#include \"amqp_tcp_socket.h\"\n#include \"amqp_time.h\"\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef AMQP_INITIAL_FRAME_POOL_PAGE_SIZE\n#define AMQP_INITIAL_FRAME_POOL_PAGE_SIZE 65536\n#endif\n\n#ifndef AMQP_INITIAL_INBOUND_SOCK_BUFFER_SIZE\n#define AMQP_INITIAL_INBOUND_SOCK_BUFFER_SIZE 131072\n#endif\n\n#ifndef AMQP_DEFAULT_LOGIN_TIMEOUT_SEC\n#define AMQP_DEFAULT_LOGIN_TIMEOUT_SEC 12\n#endif\n\n#define ENFORCE_STATE(statevec, statenum)                                   \\\n  {                                                                         \\\n    amqp_connection_state_t _check_state = (statevec);                      \\\n    amqp_connection_state_enum _wanted_state = (statenum);                  \\\n    if (_check_state->state != _wanted_state)                               \\\n      amqp_abort(                                                           \\\n          \"Programming error: invalid AMQP connection state: expected %d, \" \\\n          \"got %d\",                                                         \\\n          _wanted_state, _check_state->state);                              \\\n  }\n\namqp_connection_state_t amqp_new_connection(void) {\n  int res;\n  amqp_connection_state_t state = (amqp_connection_state_t)calloc(\n      1, sizeof(struct amqp_connection_state_t_));\n\n  if (state == NULL) {\n    return NULL;\n  }\n\n  res = amqp_tune_connection(state, 0, AMQP_INITIAL_FRAME_POOL_PAGE_SIZE, 0);\n  if (0 != res) {\n    goto out_nomem;\n  }\n\n  state->inbound_buffer.bytes = state->header_buffer;\n  state->inbound_buffer.len = sizeof(state->header_buffer);\n\n  state->state = CONNECTION_STATE_INITIAL;\n  /* the server protocol version response is 8 bytes, which conveniently\n     is also the minimum frame size */\n  state->target_size = 8;\n\n  state->sock_inbound_buffer.len = AMQP_INITIAL_INBOUND_SOCK_BUFFER_SIZE;\n  state->sock_inbound_buffer.bytes =\n      malloc(AMQP_INITIAL_INBOUND_SOCK_BUFFER_SIZE);\n  if (state->sock_inbound_buffer.bytes == NULL) {\n    goto out_nomem;\n  }\n\n  init_amqp_pool(&state->properties_pool, 512);\n\n  /* Use address of the internal_handshake_timeout object by default. */\n  state->internal_handshake_timeout.tv_sec = AMQP_DEFAULT_LOGIN_TIMEOUT_SEC;\n  state->internal_handshake_timeout.tv_usec = 0;\n  state->handshake_timeout = &state->internal_handshake_timeout;\n\n  return state;\n\nout_nomem:\n  free(state->sock_inbound_buffer.bytes);\n  free(state);\n  return NULL;\n}\n\nint amqp_get_sockfd(amqp_connection_state_t state) {\n  return state->socket ? amqp_socket_get_sockfd(state->socket) : -1;\n}\n\nvoid amqp_set_sockfd(amqp_connection_state_t state, int sockfd) {\n  amqp_socket_t *socket = amqp_tcp_socket_new(state);\n  if (!socket) {\n    amqp_abort(\"%s\", strerror(errno));\n  }\n  amqp_tcp_socket_set_sockfd(socket, sockfd);\n}\n\nvoid amqp_set_socket(amqp_connection_state_t state, amqp_socket_t *socket) {\n  amqp_socket_delete(state->socket);\n  state->socket = socket;\n}\n\namqp_socket_t *amqp_get_socket(amqp_connection_state_t state) {\n  return state->socket;\n}\n\nint amqp_tune_connection(amqp_connection_state_t state, int channel_max,\n                         int frame_max, int heartbeat) {\n  void *newbuf;\n  int res;\n\n  ENFORCE_STATE(state, CONNECTION_STATE_IDLE);\n\n  state->channel_max = channel_max;\n  state->frame_max = frame_max;\n\n  state->heartbeat = heartbeat;\n  if (0 > state->heartbeat) {\n    state->heartbeat = 0;\n  }\n\n  res = amqp_time_s_from_now(&state->next_send_heartbeat,\n                             amqp_heartbeat_send(state));\n  if (AMQP_STATUS_OK != res) {\n    return res;\n  }\n  res = amqp_time_s_from_now(&state->next_recv_heartbeat,\n                             amqp_heartbeat_recv(state));\n  if (AMQP_STATUS_OK != res) {\n    return res;\n  }\n\n  state->outbound_buffer.len = frame_max;\n  newbuf = realloc(state->outbound_buffer.bytes, frame_max);\n  if (newbuf == NULL) {\n    return AMQP_STATUS_NO_MEMORY;\n  }\n  state->outbound_buffer.bytes = newbuf;\n\n  return AMQP_STATUS_OK;\n}\n\nint amqp_get_channel_max(amqp_connection_state_t state) {\n  return state->channel_max;\n}\n\nint amqp_get_frame_max(amqp_connection_state_t state) {\n  return state->frame_max;\n}\n\nint amqp_get_heartbeat(amqp_connection_state_t state) {\n  return state->heartbeat;\n}\n\nint amqp_destroy_connection(amqp_connection_state_t state) {\n  int status = AMQP_STATUS_OK;\n  if (state) {\n    int i;\n    for (i = 0; i < POOL_TABLE_SIZE; ++i) {\n      amqp_pool_table_entry_t *entry = state->pool_table[i];\n      while (NULL != entry) {\n        amqp_pool_table_entry_t *todelete = entry;\n        empty_amqp_pool(&entry->pool);\n        entry = entry->next;\n        free(todelete);\n      }\n    }\n\n    free(state->outbound_buffer.bytes);\n    free(state->sock_inbound_buffer.bytes);\n    amqp_socket_delete(state->socket);\n    empty_amqp_pool(&state->properties_pool);\n    free(state);\n  }\n  return status;\n}\n\nstatic void return_to_idle(amqp_connection_state_t state) {\n  state->inbound_buffer.len = sizeof(state->header_buffer);\n  state->inbound_buffer.bytes = state->header_buffer;\n  state->inbound_offset = 0;\n  state->target_size = HEADER_SIZE;\n  state->state = CONNECTION_STATE_IDLE;\n}\n\nstatic size_t consume_data(amqp_connection_state_t state,\n                           amqp_bytes_t *received_data) {\n  /* how much data is available and will fit? */\n  size_t bytes_consumed = state->target_size - state->inbound_offset;\n  if (received_data->len < bytes_consumed) {\n    bytes_consumed = received_data->len;\n  }\n\n  memcpy(amqp_offset(state->inbound_buffer.bytes, state->inbound_offset),\n         received_data->bytes, bytes_consumed);\n  state->inbound_offset += bytes_consumed;\n  received_data->bytes = amqp_offset(received_data->bytes, bytes_consumed);\n  received_data->len -= bytes_consumed;\n\n  return bytes_consumed;\n}\n\nint amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      /* frame length is 3 bytes in */\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      state->target_size =\n          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;\n\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}\n\namqp_boolean_t amqp_release_buffers_ok(amqp_connection_state_t state) {\n  return (state->state == CONNECTION_STATE_IDLE);\n}\n\nvoid amqp_release_buffers(amqp_connection_state_t state) {\n  int i;\n  ENFORCE_STATE(state, CONNECTION_STATE_IDLE);\n\n  for (i = 0; i < POOL_TABLE_SIZE; ++i) {\n    amqp_pool_table_entry_t *entry = state->pool_table[i];\n\n    for (; NULL != entry; entry = entry->next) {\n      amqp_maybe_release_buffers_on_channel(state, entry->channel);\n    }\n  }\n}\n\nvoid amqp_maybe_release_buffers(amqp_connection_state_t state) {\n  if (amqp_release_buffers_ok(state)) {\n    amqp_release_buffers(state);\n  }\n}\n\nvoid amqp_maybe_release_buffers_on_channel(amqp_connection_state_t state,\n                                           amqp_channel_t channel) {\n  amqp_link_t *queued_link;\n  amqp_pool_t *pool;\n  if (CONNECTION_STATE_IDLE != state->state) {\n    return;\n  }\n\n  queued_link = state->first_queued_frame;\n\n  while (NULL != queued_link) {\n    amqp_frame_t *frame = queued_link->data;\n    if (channel == frame->channel) {\n      return;\n    }\n\n    queued_link = queued_link->next;\n  }\n\n  pool = amqp_get_channel_pool(state, channel);\n\n  if (pool != NULL) {\n    recycle_amqp_pool(pool);\n  }\n}\n\nstatic int amqp_frame_to_bytes(const amqp_frame_t *frame, amqp_bytes_t buffer,\n                               amqp_bytes_t *encoded) {\n  void *out_frame = buffer.bytes;\n  size_t out_frame_len;\n  int res;\n\n  amqp_e8(frame->frame_type, amqp_offset(out_frame, 0));\n  amqp_e16(frame->channel, amqp_offset(out_frame, 1));\n\n  switch (frame->frame_type) {\n    case AMQP_FRAME_BODY: {\n      const amqp_bytes_t *body = &frame->payload.body_fragment;\n\n      memcpy(amqp_offset(out_frame, HEADER_SIZE), body->bytes, body->len);\n\n      out_frame_len = body->len;\n      break;\n    }\n    case AMQP_FRAME_METHOD: {\n      amqp_bytes_t method_encoded;\n\n      amqp_e32(frame->payload.method.id, amqp_offset(out_frame, HEADER_SIZE));\n\n      method_encoded.bytes = amqp_offset(out_frame, HEADER_SIZE + 4);\n      method_encoded.len = buffer.len - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n      res = amqp_encode_method(frame->payload.method.id,\n                               frame->payload.method.decoded, method_encoded);\n      if (res < 0) {\n        return res;\n      }\n\n      out_frame_len = res + 4;\n      break;\n    }\n\n    case AMQP_FRAME_HEADER: {\n      amqp_bytes_t properties_encoded;\n\n      amqp_e16(frame->payload.properties.class_id,\n               amqp_offset(out_frame, HEADER_SIZE));\n      amqp_e16(0, amqp_offset(out_frame, HEADER_SIZE + 2)); /* \"weight\" */\n      amqp_e64(frame->payload.properties.body_size,\n               amqp_offset(out_frame, HEADER_SIZE + 4));\n\n      properties_encoded.bytes = amqp_offset(out_frame, HEADER_SIZE + 12);\n      properties_encoded.len = buffer.len - HEADER_SIZE - 12 - FOOTER_SIZE;\n\n      res = amqp_encode_properties(frame->payload.properties.class_id,\n                                   frame->payload.properties.decoded,\n                                   properties_encoded);\n      if (res < 0) {\n        return res;\n      }\n\n      out_frame_len = res + 12;\n      break;\n    }\n\n    case AMQP_FRAME_HEARTBEAT:\n      out_frame_len = 0;\n      break;\n\n    default:\n      return AMQP_STATUS_INVALID_PARAMETER;\n  }\n\n  amqp_e32((uint32_t)out_frame_len, amqp_offset(out_frame, 3));\n  amqp_e8(AMQP_FRAME_END, amqp_offset(out_frame, HEADER_SIZE + out_frame_len));\n\n  encoded->bytes = out_frame;\n  encoded->len = out_frame_len + HEADER_SIZE + FOOTER_SIZE;\n\n  return AMQP_STATUS_OK;\n}\n\nint amqp_send_frame(amqp_connection_state_t state, const amqp_frame_t *frame) {\n  return amqp_send_frame_inner(state, frame, AMQP_SF_NONE,\n                               amqp_time_infinite());\n}\n\nint amqp_send_frame_inner(amqp_connection_state_t state,\n                          const amqp_frame_t *frame, int flags,\n                          amqp_time_t deadline) {\n  int res;\n  ssize_t sent;\n  amqp_bytes_t encoded;\n  amqp_time_t next_timeout;\n\n  /* TODO: if the AMQP_SF_MORE socket optimization can be shown to work\n   * correctly, then this could be un-done so that body-frames are sent as 3\n   * send calls, getting rid of the copy of the body content, some testing\n   * would need to be done to see if this would actually a win for performance.\n   * */\n  res = amqp_frame_to_bytes(frame, state->outbound_buffer, &encoded);\n  if (AMQP_STATUS_OK != res) {\n    return res;\n  }\n\nstart_send:\n\n  next_timeout = amqp_time_first(deadline, state->next_recv_heartbeat);\n\n  sent = amqp_try_send(state, encoded.bytes, encoded.len, next_timeout, flags);\n  if (0 > sent) {\n    return (int)sent;\n  }\n\n  /* A partial send has occurred, because of a heartbeat timeout (so try recv\n   * something) or common timeout (so return AMQP_STATUS_TIMEOUT) */\n  if ((ssize_t)encoded.len != sent) {\n    if (amqp_time_equal(next_timeout, deadline)) {\n      /* timeout of method was received, so return from method*/\n      return AMQP_STATUS_TIMEOUT;\n    }\n\n    res = amqp_try_recv(state);\n\n    if (AMQP_STATUS_TIMEOUT == res) {\n      return AMQP_STATUS_HEARTBEAT_TIMEOUT;\n    } else if (AMQP_STATUS_OK != res) {\n      return res;\n    }\n\n    encoded.bytes = (uint8_t *)encoded.bytes + sent;\n    encoded.len -= sent;\n    goto start_send;\n  }\n\n  res = amqp_time_s_from_now(&state->next_send_heartbeat,\n                             amqp_heartbeat_send(state));\n  return res;\n}\n\namqp_table_t *amqp_get_server_properties(amqp_connection_state_t state) {\n  return &state->server_properties;\n}\n\namqp_table_t *amqp_get_client_properties(amqp_connection_state_t state) {\n  return &state->client_properties;\n}\n"], "fixing_code": ["/*\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MIT\n *\n * Portions created by Alan Antonuk are Copyright (c) 2012-2014\n * Alan Antonuk. All Rights Reserved.\n *\n * Portions created by VMware are Copyright (c) 2007-2012 VMware, Inc.\n * All Rights Reserved.\n *\n * Portions created by Tony Garnock-Jones are Copyright (c) 2009-2010\n * VMware, Inc. and Tony Garnock-Jones. All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * ***** END LICENSE BLOCK *****\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"amqp_private.h\"\n#include \"amqp_tcp_socket.h\"\n#include \"amqp_time.h\"\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef AMQP_INITIAL_FRAME_POOL_PAGE_SIZE\n#define AMQP_INITIAL_FRAME_POOL_PAGE_SIZE 65536\n#endif\n\n#ifndef AMQP_INITIAL_INBOUND_SOCK_BUFFER_SIZE\n#define AMQP_INITIAL_INBOUND_SOCK_BUFFER_SIZE 131072\n#endif\n\n#ifndef AMQP_DEFAULT_LOGIN_TIMEOUT_SEC\n#define AMQP_DEFAULT_LOGIN_TIMEOUT_SEC 12\n#endif\n\n#define ENFORCE_STATE(statevec, statenum)                                   \\\n  {                                                                         \\\n    amqp_connection_state_t _check_state = (statevec);                      \\\n    amqp_connection_state_enum _wanted_state = (statenum);                  \\\n    if (_check_state->state != _wanted_state)                               \\\n      amqp_abort(                                                           \\\n          \"Programming error: invalid AMQP connection state: expected %d, \" \\\n          \"got %d\",                                                         \\\n          _wanted_state, _check_state->state);                              \\\n  }\n\namqp_connection_state_t amqp_new_connection(void) {\n  int res;\n  amqp_connection_state_t state = (amqp_connection_state_t)calloc(\n      1, sizeof(struct amqp_connection_state_t_));\n\n  if (state == NULL) {\n    return NULL;\n  }\n\n  res = amqp_tune_connection(state, 0, AMQP_INITIAL_FRAME_POOL_PAGE_SIZE, 0);\n  if (0 != res) {\n    goto out_nomem;\n  }\n\n  state->inbound_buffer.bytes = state->header_buffer;\n  state->inbound_buffer.len = sizeof(state->header_buffer);\n\n  state->state = CONNECTION_STATE_INITIAL;\n  /* the server protocol version response is 8 bytes, which conveniently\n     is also the minimum frame size */\n  state->target_size = 8;\n\n  state->sock_inbound_buffer.len = AMQP_INITIAL_INBOUND_SOCK_BUFFER_SIZE;\n  state->sock_inbound_buffer.bytes =\n      malloc(AMQP_INITIAL_INBOUND_SOCK_BUFFER_SIZE);\n  if (state->sock_inbound_buffer.bytes == NULL) {\n    goto out_nomem;\n  }\n\n  init_amqp_pool(&state->properties_pool, 512);\n\n  /* Use address of the internal_handshake_timeout object by default. */\n  state->internal_handshake_timeout.tv_sec = AMQP_DEFAULT_LOGIN_TIMEOUT_SEC;\n  state->internal_handshake_timeout.tv_usec = 0;\n  state->handshake_timeout = &state->internal_handshake_timeout;\n\n  return state;\n\nout_nomem:\n  free(state->sock_inbound_buffer.bytes);\n  free(state);\n  return NULL;\n}\n\nint amqp_get_sockfd(amqp_connection_state_t state) {\n  return state->socket ? amqp_socket_get_sockfd(state->socket) : -1;\n}\n\nvoid amqp_set_sockfd(amqp_connection_state_t state, int sockfd) {\n  amqp_socket_t *socket = amqp_tcp_socket_new(state);\n  if (!socket) {\n    amqp_abort(\"%s\", strerror(errno));\n  }\n  amqp_tcp_socket_set_sockfd(socket, sockfd);\n}\n\nvoid amqp_set_socket(amqp_connection_state_t state, amqp_socket_t *socket) {\n  amqp_socket_delete(state->socket);\n  state->socket = socket;\n}\n\namqp_socket_t *amqp_get_socket(amqp_connection_state_t state) {\n  return state->socket;\n}\n\nint amqp_tune_connection(amqp_connection_state_t state, int channel_max,\n                         int frame_max, int heartbeat) {\n  void *newbuf;\n  int res;\n\n  ENFORCE_STATE(state, CONNECTION_STATE_IDLE);\n\n  state->channel_max = channel_max;\n  state->frame_max = frame_max;\n\n  state->heartbeat = heartbeat;\n  if (0 > state->heartbeat) {\n    state->heartbeat = 0;\n  }\n\n  res = amqp_time_s_from_now(&state->next_send_heartbeat,\n                             amqp_heartbeat_send(state));\n  if (AMQP_STATUS_OK != res) {\n    return res;\n  }\n  res = amqp_time_s_from_now(&state->next_recv_heartbeat,\n                             amqp_heartbeat_recv(state));\n  if (AMQP_STATUS_OK != res) {\n    return res;\n  }\n\n  state->outbound_buffer.len = frame_max;\n  newbuf = realloc(state->outbound_buffer.bytes, frame_max);\n  if (newbuf == NULL) {\n    return AMQP_STATUS_NO_MEMORY;\n  }\n  state->outbound_buffer.bytes = newbuf;\n\n  return AMQP_STATUS_OK;\n}\n\nint amqp_get_channel_max(amqp_connection_state_t state) {\n  return state->channel_max;\n}\n\nint amqp_get_frame_max(amqp_connection_state_t state) {\n  return state->frame_max;\n}\n\nint amqp_get_heartbeat(amqp_connection_state_t state) {\n  return state->heartbeat;\n}\n\nint amqp_destroy_connection(amqp_connection_state_t state) {\n  int status = AMQP_STATUS_OK;\n  if (state) {\n    int i;\n    for (i = 0; i < POOL_TABLE_SIZE; ++i) {\n      amqp_pool_table_entry_t *entry = state->pool_table[i];\n      while (NULL != entry) {\n        amqp_pool_table_entry_t *todelete = entry;\n        empty_amqp_pool(&entry->pool);\n        entry = entry->next;\n        free(todelete);\n      }\n    }\n\n    free(state->outbound_buffer.bytes);\n    free(state->sock_inbound_buffer.bytes);\n    amqp_socket_delete(state->socket);\n    empty_amqp_pool(&state->properties_pool);\n    free(state);\n  }\n  return status;\n}\n\nstatic void return_to_idle(amqp_connection_state_t state) {\n  state->inbound_buffer.len = sizeof(state->header_buffer);\n  state->inbound_buffer.bytes = state->header_buffer;\n  state->inbound_offset = 0;\n  state->target_size = HEADER_SIZE;\n  state->state = CONNECTION_STATE_IDLE;\n}\n\nstatic size_t consume_data(amqp_connection_state_t state,\n                           amqp_bytes_t *received_data) {\n  /* how much data is available and will fit? */\n  size_t bytes_consumed = state->target_size - state->inbound_offset;\n  if (received_data->len < bytes_consumed) {\n    bytes_consumed = received_data->len;\n  }\n\n  memcpy(amqp_offset(state->inbound_buffer.bytes, state->inbound_offset),\n         received_data->bytes, bytes_consumed);\n  state->inbound_offset += bytes_consumed;\n  received_data->bytes = amqp_offset(received_data->bytes, bytes_consumed);\n  received_data->len -= bytes_consumed;\n\n  return bytes_consumed;\n}\n\nint amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      uint32_t frame_size;\n\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      /* frame length is 3 bytes in */\n      frame_size = amqp_d32(amqp_offset(raw_frame, 3));\n      /* To prevent the target_size calculation below from overflowing, check\n       * that the stated frame_size is smaller than a signed 32-bit. Given\n       * the library only allows configuring frame_max as an int32_t, and\n       * frame_size is uint32_t, the math below is safe from overflow. */\n      if (frame_size >= INT32_MAX) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}\n\namqp_boolean_t amqp_release_buffers_ok(amqp_connection_state_t state) {\n  return (state->state == CONNECTION_STATE_IDLE);\n}\n\nvoid amqp_release_buffers(amqp_connection_state_t state) {\n  int i;\n  ENFORCE_STATE(state, CONNECTION_STATE_IDLE);\n\n  for (i = 0; i < POOL_TABLE_SIZE; ++i) {\n    amqp_pool_table_entry_t *entry = state->pool_table[i];\n\n    for (; NULL != entry; entry = entry->next) {\n      amqp_maybe_release_buffers_on_channel(state, entry->channel);\n    }\n  }\n}\n\nvoid amqp_maybe_release_buffers(amqp_connection_state_t state) {\n  if (amqp_release_buffers_ok(state)) {\n    amqp_release_buffers(state);\n  }\n}\n\nvoid amqp_maybe_release_buffers_on_channel(amqp_connection_state_t state,\n                                           amqp_channel_t channel) {\n  amqp_link_t *queued_link;\n  amqp_pool_t *pool;\n  if (CONNECTION_STATE_IDLE != state->state) {\n    return;\n  }\n\n  queued_link = state->first_queued_frame;\n\n  while (NULL != queued_link) {\n    amqp_frame_t *frame = queued_link->data;\n    if (channel == frame->channel) {\n      return;\n    }\n\n    queued_link = queued_link->next;\n  }\n\n  pool = amqp_get_channel_pool(state, channel);\n\n  if (pool != NULL) {\n    recycle_amqp_pool(pool);\n  }\n}\n\nstatic int amqp_frame_to_bytes(const amqp_frame_t *frame, amqp_bytes_t buffer,\n                               amqp_bytes_t *encoded) {\n  void *out_frame = buffer.bytes;\n  size_t out_frame_len;\n  int res;\n\n  amqp_e8(frame->frame_type, amqp_offset(out_frame, 0));\n  amqp_e16(frame->channel, amqp_offset(out_frame, 1));\n\n  switch (frame->frame_type) {\n    case AMQP_FRAME_BODY: {\n      const amqp_bytes_t *body = &frame->payload.body_fragment;\n\n      memcpy(amqp_offset(out_frame, HEADER_SIZE), body->bytes, body->len);\n\n      out_frame_len = body->len;\n      break;\n    }\n    case AMQP_FRAME_METHOD: {\n      amqp_bytes_t method_encoded;\n\n      amqp_e32(frame->payload.method.id, amqp_offset(out_frame, HEADER_SIZE));\n\n      method_encoded.bytes = amqp_offset(out_frame, HEADER_SIZE + 4);\n      method_encoded.len = buffer.len - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n      res = amqp_encode_method(frame->payload.method.id,\n                               frame->payload.method.decoded, method_encoded);\n      if (res < 0) {\n        return res;\n      }\n\n      out_frame_len = res + 4;\n      break;\n    }\n\n    case AMQP_FRAME_HEADER: {\n      amqp_bytes_t properties_encoded;\n\n      amqp_e16(frame->payload.properties.class_id,\n               amqp_offset(out_frame, HEADER_SIZE));\n      amqp_e16(0, amqp_offset(out_frame, HEADER_SIZE + 2)); /* \"weight\" */\n      amqp_e64(frame->payload.properties.body_size,\n               amqp_offset(out_frame, HEADER_SIZE + 4));\n\n      properties_encoded.bytes = amqp_offset(out_frame, HEADER_SIZE + 12);\n      properties_encoded.len = buffer.len - HEADER_SIZE - 12 - FOOTER_SIZE;\n\n      res = amqp_encode_properties(frame->payload.properties.class_id,\n                                   frame->payload.properties.decoded,\n                                   properties_encoded);\n      if (res < 0) {\n        return res;\n      }\n\n      out_frame_len = res + 12;\n      break;\n    }\n\n    case AMQP_FRAME_HEARTBEAT:\n      out_frame_len = 0;\n      break;\n\n    default:\n      return AMQP_STATUS_INVALID_PARAMETER;\n  }\n\n  amqp_e32((uint32_t)out_frame_len, amqp_offset(out_frame, 3));\n  amqp_e8(AMQP_FRAME_END, amqp_offset(out_frame, HEADER_SIZE + out_frame_len));\n\n  encoded->bytes = out_frame;\n  encoded->len = out_frame_len + HEADER_SIZE + FOOTER_SIZE;\n\n  return AMQP_STATUS_OK;\n}\n\nint amqp_send_frame(amqp_connection_state_t state, const amqp_frame_t *frame) {\n  return amqp_send_frame_inner(state, frame, AMQP_SF_NONE,\n                               amqp_time_infinite());\n}\n\nint amqp_send_frame_inner(amqp_connection_state_t state,\n                          const amqp_frame_t *frame, int flags,\n                          amqp_time_t deadline) {\n  int res;\n  ssize_t sent;\n  amqp_bytes_t encoded;\n  amqp_time_t next_timeout;\n\n  /* TODO: if the AMQP_SF_MORE socket optimization can be shown to work\n   * correctly, then this could be un-done so that body-frames are sent as 3\n   * send calls, getting rid of the copy of the body content, some testing\n   * would need to be done to see if this would actually a win for performance.\n   * */\n  res = amqp_frame_to_bytes(frame, state->outbound_buffer, &encoded);\n  if (AMQP_STATUS_OK != res) {\n    return res;\n  }\n\nstart_send:\n\n  next_timeout = amqp_time_first(deadline, state->next_recv_heartbeat);\n\n  sent = amqp_try_send(state, encoded.bytes, encoded.len, next_timeout, flags);\n  if (0 > sent) {\n    return (int)sent;\n  }\n\n  /* A partial send has occurred, because of a heartbeat timeout (so try recv\n   * something) or common timeout (so return AMQP_STATUS_TIMEOUT) */\n  if ((ssize_t)encoded.len != sent) {\n    if (amqp_time_equal(next_timeout, deadline)) {\n      /* timeout of method was received, so return from method*/\n      return AMQP_STATUS_TIMEOUT;\n    }\n\n    res = amqp_try_recv(state);\n\n    if (AMQP_STATUS_TIMEOUT == res) {\n      return AMQP_STATUS_HEARTBEAT_TIMEOUT;\n    } else if (AMQP_STATUS_OK != res) {\n      return res;\n    }\n\n    encoded.bytes = (uint8_t *)encoded.bytes + sent;\n    encoded.len -= sent;\n    goto start_send;\n  }\n\n  res = amqp_time_s_from_now(&state->next_send_heartbeat,\n                             amqp_heartbeat_send(state));\n  return res;\n}\n\namqp_table_t *amqp_get_server_properties(amqp_connection_state_t state) {\n  return &state->server_properties;\n}\n\namqp_table_t *amqp_get_client_properties(amqp_connection_state_t state) {\n  return &state->client_properties;\n}\n"], "filenames": ["librabbitmq/amqp_connection.c"], "buggy_code_start_loc": [289], "buggy_code_end_loc": [296], "fixing_code_start_loc": [290], "fixing_code_end_loc": [305], "type": "CWE-787", "message": "An issue was discovered in amqp_handle_input in amqp_connection.c in rabbitmq-c 0.9.0. There is an integer overflow that leads to heap memory corruption in the handling of CONNECTION_STATE_HEADER. A rogue server could return a malicious frame header that leads to a smaller target_size value than needed. This condition is then carried on to a memcpy function that copies too much data into a heap buffer.", "other": {"cve": {"id": "CVE-2019-18609", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-01T22:15:10.897", "lastModified": "2022-01-01T20:06:16.380", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in amqp_handle_input in amqp_connection.c in rabbitmq-c 0.9.0. There is an integer overflow that leads to heap memory corruption in the handling of CONNECTION_STATE_HEADER. A rogue server could return a malicious frame header that leads to a smaller target_size value than needed. This condition is then carried on to a memcpy function that copies too much data into a heap buffer."}, {"lang": "es", "value": "Se detect\u00f3 un problema en la funci\u00f3n amqp_handle_input en el archivo amqp_connection.c en rabbitmq-c versi\u00f3n 0.9.0. Se presenta un desbordamiento de enteros que conlleva a una corrupci\u00f3n de memoria de la pila en el manejo de CONNECTION_STATE_HEADER. Un servidor no autorizado podr\u00eda devolver un encabezado de trama malicioso que conlleva a un valor  de target_size m\u00e1s peque\u00f1o de lo necesario. Esta condici\u00f3n se transfiere a una funci\u00f3n memcpy que copia demasiados datos en un b\u00fafer de la pila."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rabbitmq-c_project:rabbitmq-c:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.10.0", "matchCriteriaId": "671B8F76-8180-4799-A7A1-6ED718EC49EF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://github.com/alanxz/rabbitmq-c/blob/master/ChangeLog.md", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/alanxz/rabbitmq-c/commit/fc85be7123050b91b054e45b91c78d3241a5047a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/12/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WA7CPNVYMF6OQNIYNLWUY6U2GTKFOKH3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XQER6XTKYMHNQR7QTHW7DJAH645WQROU/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://news.ycombinator.com/item?id=21681976", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4214-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4214-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/alanxz/rabbitmq-c/commit/fc85be7123050b91b054e45b91c78d3241a5047a"}}