{"buggy_code": ["/* Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"jcontext.h\"\n#include \"ecma-alloc.h\"\n#include \"ecma-array-object.h\"\n#include \"ecma-builtins.h\"\n#include \"ecma-builtin-helpers.h\"\n#include \"ecma-exceptions.h\"\n#include \"ecma-function-object.h\"\n#include \"ecma-gc.h\"\n#include \"ecma-helpers.h\"\n#include \"ecma-iterator-object.h\"\n#include \"ecma-container-object.h\"\n#include \"ecma-property-hashmap.h\"\n#include \"ecma-objects.h\"\n\n#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)\n\n/** \\addtogroup ecma ECMA\n * @{\n *\n * \\addtogroup \\addtogroup ecmamaphelpers ECMA builtin Map/Set helper functions\n * @{\n */\n\n/**\n * Create a new internal buffer.\n *\n * Note:\n *   The first element of the collection tracks the size of the buffer.\n *   ECMA_VALUE_EMPTY values are not calculated into the size.\n *\n * @return pointer to the internal buffer\n */\nstatic inline ecma_collection_t *\necma_op_create_internal_buffer (void)\n{\n  ecma_collection_t *collection_p = ecma_new_collection ();\n  ecma_collection_push_back (collection_p, (ecma_value_t) 0);\n\n  return collection_p;\n} /* ecma_op_create_internal_buffer */\n\n/**\n * Append values to the internal buffer.\n */\nstatic void\necma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */\n\n/**\n * Update the value of a given entry.\n */\nstatic inline void\necma_op_internal_buffer_update (ecma_value_t *entry_p, /**< entry pointer */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (entry_p != NULL);\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_free_value_if_not_object (((ecma_container_pair_t *) entry_p)->value);\n\n    ((ecma_container_pair_t *) entry_p)->value = ecma_copy_value_if_not_object (value_arg);\n  }\n} /* ecma_op_internal_buffer_update */\n\n/**\n * Delete element from the internal buffer.\n */\nstatic void\necma_op_internal_buffer_delete (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_container_pair_t *entry_p, /**< entry pointer */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n  JERRY_ASSERT (entry_p != NULL);\n\n  ecma_free_value_if_not_object (entry_p->key);\n  entry_p->key = ECMA_VALUE_EMPTY;\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_free_value_if_not_object (entry_p->value);\n    entry_p->value = ECMA_VALUE_EMPTY;\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) - 1);\n} /* ecma_op_internal_buffer_delete */\n\n/**\n * Find an entry in the collection.\n *\n * @return pointer to the appropriate entry.\n */\nstatic ecma_value_t *\necma_op_internal_buffer_find (ecma_collection_t *container_p, /**< internal container pointer */\n                              ecma_value_t key_arg, /**< key argument */\n                              lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  uint8_t entry_size = ecma_op_container_entry_size (lit_id);\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += entry_size)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_op_same_value_zero (*entry_p, key_arg))\n    {\n      return entry_p;\n    }\n  }\n\n  return NULL;\n} /* ecma_op_internal_buffer_find */\n\n/**\n * Get the value that belongs to the key.\n *\n * Note: in case of Set containers, the values are the same as the keys.\n *\n * @return ecma value\n */\nstatic ecma_value_t\necma_op_container_get_value (ecma_value_t *entry_p, /**< entry (key) pointer */\n                             lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (entry_p != NULL);\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    return ((ecma_container_pair_t *) entry_p)->value;\n  }\n\n  return *entry_p;\n} /* ecma_op_container_get_value */\n\n/**\n * Get the size (in ecma_value_t) of the stored entries.\n *\n * @return size of the entries.\n */\nuint8_t\necma_op_container_entry_size (lit_magic_string_id_t lit_id) /**< class id */\n{\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    return ECMA_CONTAINER_PAIR_SIZE;\n  }\n\n  return ECMA_CONTAINER_VALUE_SIZE;\n} /* ecma_op_container_entry_size */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n/**\n * Release the entries in the WeakSet container.\n */\nstatic void\necma_op_container_free_weakset_entries (ecma_object_t *object_p, /**< object pointer */\n                                        ecma_collection_t *container_p) /** internal buffer pointer */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      continue;\n    }\n\n    ecma_op_container_unref_weak (ecma_get_object_from_value (*entry_p), ecma_make_object_value (object_p));\n    ecma_op_container_remove_weak_entry (object_p, *entry_p);\n\n    *entry_p = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_weakset_entries */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n/**\n * Release the entries in the WeakMap container.\n */\nstatic void\necma_op_container_free_weakmap_entries (ecma_object_t *object_p, /**< object pointer */\n                                        ecma_collection_t *container_p) /**< internal buffer pointer */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)\n  {\n    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);\n\n    if (ecma_is_value_empty (entry_p->key))\n    {\n      continue;\n    }\n\n    ecma_op_container_unref_weak (ecma_get_object_from_value (entry_p->key), ecma_make_object_value (object_p));\n    ecma_op_container_remove_weak_entry (object_p, entry_p->key);\n\n    ecma_free_value_if_not_object (entry_p->value);\n\n    entry_p->key = ECMA_VALUE_EMPTY;\n    entry_p->value = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_weakmap_entries */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n/**\n * Release the entries in the Set container.\n */\nstatic void\necma_op_container_free_set_entries (ecma_collection_t *container_p)\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      continue;\n    }\n\n    ecma_free_value_if_not_object (*entry_p);\n    *entry_p = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_set_entries */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n/**\n * Release the entries in the Map container.\n */\nstatic void\necma_op_container_free_map_entries (ecma_collection_t *container_p)\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)\n  {\n    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);\n\n    if (ecma_is_value_empty (entry_p->key))\n    {\n      continue;\n    }\n\n    ecma_free_value_if_not_object (entry_p->key);\n    ecma_free_value_if_not_object (entry_p->value);\n\n    entry_p->key = ECMA_VALUE_EMPTY;\n    entry_p->value = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_map_entries */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n\n/**\n * Release the internal buffer and the stored entries.\n */\nvoid\necma_op_container_free_entries (ecma_object_t *object_p) /**< collection object pointer */\n{\n  JERRY_ASSERT (object_p != NULL);\n\n  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  switch (map_object_p->u.class_prop.class_id)\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n    case LIT_MAGIC_STRING_WEAKSET_UL:\n    {\n      ecma_op_container_free_weakset_entries (object_p, container_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n    case LIT_MAGIC_STRING_WEAKMAP_UL:\n    {\n      ecma_op_container_free_weakmap_entries (object_p, container_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n    case LIT_MAGIC_STRING_SET_UL:\n    {\n      ecma_op_container_free_set_entries (container_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n    case LIT_MAGIC_STRING_MAP_UL:\n    {\n      ecma_op_container_free_map_entries (container_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n    default:\n    {\n      break;\n    }\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, 0);\n} /* ecma_op_container_free_entries */\n\n/**\n * Handle calling [[Construct]] of built-in Map/Set like objects\n *\n * @return ecma value\n */\necma_value_t\necma_op_container_create (const ecma_value_t *arguments_list_p, /**< arguments list */\n                          ecma_length_t arguments_list_len, /**< number of arguments */\n                          lit_magic_string_id_t lit_id, /**< internal class id */\n                          ecma_builtin_id_t proto_id) /**< prototype builtin id */\n{\n  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);\n  JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_MAP_UL\n                || lit_id == LIT_MAGIC_STRING_SET_UL\n                || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL\n                || lit_id == LIT_MAGIC_STRING_WEAKSET_UL);\n  JERRY_ASSERT (JERRY_CONTEXT (current_new_target) != NULL);\n\n  ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target), proto_id);\n\n  if (JERRY_UNLIKELY (proto_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ecma_op_create_internal_buffer ();\n  ecma_object_t *object_p  = ecma_create_object (proto_p,\n                                                 sizeof (ecma_extended_object_t),\n                                                 ECMA_OBJECT_TYPE_CLASS);\n  ecma_deref_object (proto_p);\n  ecma_extended_object_t *map_obj_p = (ecma_extended_object_t *) object_p;\n  map_obj_p->u.class_prop.extra_info = ECMA_CONTAINER_FLAGS_EMPTY;\n  map_obj_p->u.class_prop.class_id = (uint16_t) lit_id;\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)\n  {\n    map_obj_p->u.class_prop.extra_info |= ECMA_CONTAINER_FLAGS_WEAK;\n  }\n\n  ECMA_SET_INTERNAL_VALUE_POINTER (map_obj_p->u.class_prop.u.value, container_p);\n\n  ecma_value_t set_value = ecma_make_object_value (object_p);\n  ecma_value_t result = set_value;\n\n#if ENABLED (JERRY_ES2015)\n  if (arguments_list_len == 0)\n  {\n    return result;\n  }\n\n  ecma_value_t iterable = arguments_list_p[0];\n\n  if (ecma_is_value_undefined (iterable) || ecma_is_value_null (iterable))\n  {\n    return result;\n  }\n\n  lit_magic_string_id_t adder_string_id;\n  if (lit_id == LIT_MAGIC_STRING_MAP_UL || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL)\n  {\n    adder_string_id = LIT_MAGIC_STRING_SET;\n  }\n  else\n  {\n    adder_string_id = LIT_MAGIC_STRING_ADD;\n  }\n\n  result = ecma_op_object_get_by_magic_id (object_p, adder_string_id);\n  if (ECMA_IS_VALUE_ERROR (result))\n  {\n    goto cleanup_object;\n  }\n\n  if (!ecma_op_is_callable (result))\n  {\n    ecma_free_value (result);\n    result = ecma_raise_type_error (ECMA_ERR_MSG (\"add/set function is not callable.\"));\n    goto cleanup_object;\n  }\n\n  ecma_object_t *adder_func_p = ecma_get_object_from_value (result);\n\n  result = ecma_op_get_iterator (iterable, ECMA_VALUE_EMPTY);\n\n  if (ECMA_IS_VALUE_ERROR (result))\n  {\n    goto cleanup_adder;\n  }\n\n  const ecma_value_t iter = result;\n\n  while (true)\n  {\n    result = ecma_op_iterator_step (iter);\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      goto cleanup_iter;\n    }\n\n    if (ecma_is_value_false (result))\n    {\n      break;\n    }\n\n    const ecma_value_t next = result;\n    result = ecma_op_iterator_value (next);\n    ecma_free_value (next);\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      goto cleanup_iter;\n    }\n\n    if (lit_id == LIT_MAGIC_STRING_SET_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)\n    {\n      const ecma_value_t value = result;\n\n      ecma_value_t arguments[] = { value };\n      result = ecma_op_function_call (adder_func_p, set_value, arguments, 1);\n\n      ecma_free_value (value);\n    }\n    else\n    {\n      if (!ecma_is_value_object (result))\n      {\n        ecma_free_value (result);\n        ecma_raise_type_error (ECMA_ERR_MSG (\"Iterator value is not an object.\"));\n        result = ecma_op_iterator_close (iter);\n        JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));\n        goto cleanup_iter;\n      }\n\n      ecma_object_t *next_object_p = ecma_get_object_from_value (result);\n\n      result = ecma_op_object_get_by_uint32_index (next_object_p, 0);\n\n      if (ECMA_IS_VALUE_ERROR (result))\n      {\n        ecma_deref_object (next_object_p);\n        ecma_op_iterator_close (iter);\n        goto cleanup_iter;\n      }\n\n      const ecma_value_t key = result;\n\n      result = ecma_op_object_get_by_uint32_index (next_object_p, 1);\n\n      if (ECMA_IS_VALUE_ERROR (result))\n      {\n        ecma_deref_object (next_object_p);\n        ecma_free_value (key);\n        ecma_op_iterator_close (iter);\n        goto cleanup_iter;\n      }\n\n      const ecma_value_t value = result;\n      ecma_value_t arguments[] = { key, value };\n      result = ecma_op_function_call (adder_func_p, set_value, arguments, 2);\n\n      ecma_free_value (key);\n      ecma_free_value (value);\n      ecma_deref_object (next_object_p);\n    }\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      ecma_op_iterator_close (iter);\n      goto cleanup_iter;\n    }\n\n    ecma_free_value (result);\n  }\n\n  ecma_free_value (iter);\n  ecma_deref_object (adder_func_p);\n  return ecma_make_object_value (object_p);\n\ncleanup_iter:\n  ecma_free_value (iter);\ncleanup_adder:\n  ecma_deref_object (adder_func_p);\ncleanup_object:\n  ecma_deref_object (object_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return result;\n} /* ecma_op_container_create */\n\n/**\n * Get Map/Set object pointer\n *\n * Note:\n *   If the function returns with NULL, the error object has\n *   already set, and the caller must return with ECMA_VALUE_ERROR\n *\n * @return pointer to the Map/Set if this_arg is a valid Map/Set object\n *         NULL otherwise\n */\nstatic ecma_extended_object_t *\necma_op_container_get_object (ecma_value_t this_arg, /**< this argument */\n                              lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  if (ecma_is_value_object (this_arg))\n  {\n    ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) ecma_get_object_from_value (this_arg);\n\n    if (ecma_get_object_type ((ecma_object_t *) map_object_p) == ECMA_OBJECT_TYPE_CLASS\n        && map_object_p->u.class_prop.class_id == lit_id)\n    {\n      return map_object_p;\n    }\n  }\n\n#if ENABLED (JERRY_ERROR_MESSAGES)\n  ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,\n                                         \"Expected a % object.\",\n                                         ecma_make_string_value (ecma_get_magic_string (lit_id)));\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n  ecma_raise_type_error (NULL);\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n\n  return NULL;\n} /* ecma_op_container_get_object */\n\n/**\n * Returns with the size of the Map/Set object.\n *\n * @return size of the Map/Set object as ecma-value.\n */\necma_value_t\necma_op_container_size (ecma_value_t this_arg, /**< this argument */\n                        lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  return ecma_make_uint32_value (ECMA_CONTAINER_GET_SIZE (container_p));\n} /* ecma_op_container_size */\n\n/**\n * The generic Map/WeakMap prototype object's 'get' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_get (ecma_value_t this_arg, /**< this argument */\n                       ecma_value_t key_arg, /**< key argument */\n                       lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL && !ecma_is_value_object (key_arg))\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  if (entry_p == NULL)\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  return ecma_copy_value (((ecma_container_pair_t *) entry_p)->value);\n} /* ecma_op_container_get */\n\n/**\n * The generic Map/Set prototype object's 'has' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_has (ecma_value_t this_arg, /**< this argument */\n                       ecma_value_t key_arg, /**< key argument */\n                       lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) || ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n  if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0\n      && !ecma_is_value_object (key_arg))\n  {\n    return ECMA_VALUE_FALSE;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n\n  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  return ecma_make_boolean_value (entry_p != NULL);\n} /* ecma_op_container_has */\n\n/**\n * Set a weak reference from a container to a key object\n */\nstatic void\necma_op_container_set_weak (ecma_object_t *const key_p, /**< key object */\n                            ecma_extended_object_t *const container_p) /**< container */\n{\n  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (key_p)))\n  {\n    ecma_fast_array_convert_to_normal (key_p);\n  }\n\n  ecma_string_t *weak_refs_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);\n  ecma_property_t *property_p = ecma_find_named_property (key_p, weak_refs_string_p);\n  ecma_collection_t *refs_p;\n\n  if (property_p == NULL)\n  {\n    ecma_property_value_t *value_p = ecma_create_named_data_property (key_p,\n                                                                      weak_refs_string_p,\n                                                                      ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                                      &property_p);\n    ECMA_CONVERT_DATA_PROPERTY_TO_INTERNAL_PROPERTY (property_p);\n    refs_p = ecma_new_collection ();\n    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, refs_p);\n  }\n  else\n  {\n    refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, (ECMA_PROPERTY_VALUE_PTR (property_p)->value));\n  }\n\n  const ecma_value_t container_value = ecma_make_object_value ((ecma_object_t *) container_p);\n  for (uint32_t i = 0; i < refs_p->item_count; i++)\n  {\n    if (ecma_is_value_empty (refs_p->buffer_p[i]))\n    {\n      refs_p->buffer_p[i] = container_value;\n      return;\n    }\n  }\n\n  ecma_collection_push_back (refs_p, container_value);\n} /* ecma_op_container_set_weak */\n\n/**\n * Helper method for the Map.prototype.set and Set.prototype.add methods to swap the sign of the given value if needed\n *\n * See also:\n *          ECMA-262 v6, 23.2.3.1 step 6\n *          ECMA-262 v6, 23.1.3.9 step 6\n *\n * @return ecma value\n */\nstatic ecma_value_t\necma_op_container_set_noramlize_zero (ecma_value_t this_arg) /*< this arg */\n{\n  if (ecma_is_value_number (this_arg))\n  {\n    ecma_number_t number_value = ecma_get_number_from_value (this_arg);\n\n    if (JERRY_UNLIKELY (ecma_number_is_zero (number_value) && ecma_number_is_negative (number_value)))\n    {\n      return ecma_make_integer_value (0);\n    }\n  }\n\n  return this_arg;\n} /* ecma_op_container_set_noramlize_zero */\n\n/**\n * The generic Map prototype object's 'set' and Set prototype object's 'add' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_set (ecma_value_t this_arg, /**< this argument */\n                       ecma_value_t key_arg, /**< key argument */\n                       ecma_value_t value_arg, /**< value argument */\n                       lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n  if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0\n      && !ecma_is_value_object (key_arg))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Key must be an object\"));\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  if (entry_p == NULL)\n  {\n    ecma_op_internal_buffer_append (container_p,\n                                    ecma_op_container_set_noramlize_zero (key_arg),\n                                    value_arg,\n                                    lit_id);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n    if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0)\n    {\n      ecma_object_t *key_p = ecma_get_object_from_value (key_arg);\n      ecma_op_container_set_weak (key_p, map_object_p);\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n  }\n  else\n  {\n    ecma_op_internal_buffer_update (entry_p, ecma_op_container_set_noramlize_zero (value_arg), lit_id);\n  }\n\n  ecma_ref_object ((ecma_object_t *) map_object_p);\n  return this_arg;\n} /* ecma_op_container_set */\n\n/**\n * The generic Map/Set prototype object's 'forEach' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_foreach (ecma_value_t this_arg, /**< this argument */\n                           ecma_value_t predicate, /**< callback function */\n                           ecma_value_t predicate_this_arg, /**< this argument for\n                                                             *   invoke predicate */\n                           lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  if (!ecma_op_is_callable (predicate))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Callback function is not callable.\"));\n  }\n\n  JERRY_ASSERT (ecma_is_value_object (predicate));\n  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);\n  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  uint8_t entry_size = ecma_op_container_entry_size (lit_id);\n\n  for (uint32_t i = 0; i < ECMA_CONTAINER_ENTRY_COUNT (container_p); i += entry_size)\n  {\n    ecma_value_t *entry_p = ECMA_CONTAINER_START (container_p) + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      continue;\n    }\n\n    ecma_value_t key_arg = *entry_p;\n    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);\n\n    ecma_value_t call_args[] = { value_arg, key_arg, this_arg };\n    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);\n\n    if (ECMA_IS_VALUE_ERROR (call_value))\n    {\n      ret_value = call_value;\n      break;\n    }\n\n    ecma_free_value (call_value);\n  }\n\n  return ret_value;\n} /* ecma_op_container_foreach */\n\n/**\n * The Map/Set prototype object's 'clear' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_clear (ecma_value_t this_arg, /**< this argument */\n                         lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_op_container_free_entries ((ecma_object_t *) map_object_p);\n\n  return ECMA_VALUE_UNDEFINED;\n} /* ecma_op_container_clear */\n\n/**\n * The generic Map/Set prototype object's 'delete' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_delete (ecma_value_t this_arg, /**< this argument */\n                          ecma_value_t key_arg, /**< key argument */\n                          lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  if (entry_p == NULL)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);\n  return ECMA_VALUE_TRUE;\n} /* ecma_op_container_delete */\n\n/**\n * The generic WeakMap/WeakSet prototype object's 'delete' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_delete_weak (ecma_value_t this_arg, /**< this argument */\n                               ecma_value_t key_arg, /**< key argument */\n                               lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  if (!ecma_is_value_object (key_arg))\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  if (entry_p == NULL)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);\n\n  ecma_object_t *key_object_p = ecma_get_object_from_value (key_arg);\n  ecma_op_container_unref_weak (key_object_p, ecma_make_object_value ((ecma_object_t *) map_object_p));\n\n  return ECMA_VALUE_TRUE;\n} /* ecma_op_container_delete_weak */\n\n/**\n * Helper function to remove a weak reference to an object.\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\nvoid\necma_op_container_unref_weak (ecma_object_t *object_p, /**< this argument */\n                              ecma_value_t ref_holder) /**< key argument */\n{\n  ecma_string_t *weak_refs_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, weak_refs_string_p);\n  JERRY_ASSERT (property_p != NULL);\n\n  ecma_collection_t *refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                               ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n  for (uint32_t i = 0; i < refs_p->item_count; i++)\n  {\n    if (refs_p->buffer_p[i] == ref_holder)\n    {\n      refs_p->buffer_p[i] = ECMA_VALUE_EMPTY;\n      break;\n    }\n  }\n} /* ecma_op_container_unref_weak */\n\n/**\n * Helper function to remove a key/value pair from a weak container object\n */\nvoid\necma_op_container_remove_weak_entry (ecma_object_t *object_p, /**< internal container object */\n                                     ecma_value_t key_arg) /**< key */\n{\n  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, map_object_p->u.class_prop.class_id);\n\n  JERRY_ASSERT (entry_p != NULL);\n\n  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, map_object_p->u.class_prop.class_id);\n} /* ecma_op_container_remove_weak_entry */\n\n#if ENABLED (JERRY_ES2015)\n\n/**\n * The Create{Set, Map}Iterator Abstract operation\n *\n * See also:\n *          ECMA-262 v6, 23.1.5.1\n *          ECMA-262 v6, 23.2.5.1\n *\n * Note:\n *     Returned value must be freed with ecma_free_value.\n *\n * @return Map/Set iterator object, if success\n *         error - otherwise\n */\necma_value_t\necma_op_container_create_iterator (ecma_value_t this_arg, /**< this argument */\n                                   uint8_t type, /**< any combination of\n                                                  *   ecma_iterator_type_t bits */\n                                   lit_magic_string_id_t lit_id, /**< internal class id */\n                                   ecma_builtin_id_t proto_id, /**< prototype builtin id */\n                                   ecma_pseudo_array_type_t iterator_type) /**< type of the iterator */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  return ecma_op_create_iterator_object (this_arg,\n                                         ecma_builtin_get (proto_id),\n                                         (uint8_t) iterator_type,\n                                         type);\n} /* ecma_op_container_create_iterator */\n\n/**\n * Get the index of the iterator object.\n *\n * @return index of the iterator.\n */\nstatic uint32_t\necma_op_iterator_get_index (ecma_object_t *iter_obj_p)  /**< iterator object pointer */\n{\n  uint32_t index = ((ecma_extended_object_t *) iter_obj_p)->u.pseudo_array.u1.iterator_index;\n\n  if (JERRY_UNLIKELY (index == ECMA_ITERATOR_INDEX_LIMIT))\n  {\n    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);\n    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);\n    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n    return (uint32_t) (ecma_get_number_from_value (value_p->value));\n  }\n\n  return index;\n} /* ecma_op_iterator_get_index */\n\n/**\n * Set the index of the iterator object.\n */\nstatic void\necma_op_iterator_set_index (ecma_object_t *iter_obj_p, /**< iterator object pointer */\n                            uint32_t index) /* iterator index to set */\n{\n  if (JERRY_UNLIKELY (index >= ECMA_ITERATOR_INDEX_LIMIT))\n  {\n    /* After the ECMA_ITERATOR_INDEX_LIMIT limit is reached the [[%Iterator%NextIndex]]\n       property is stored as an internal property */\n    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);\n    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);\n    ecma_property_value_t *value_p;\n\n    if (property_p == NULL)\n    {\n      value_p = ecma_create_named_data_property (iter_obj_p, prop_name_p, ECMA_PROPERTY_FLAG_WRITABLE, &property_p);\n      value_p->value = ecma_make_uint32_value (index);\n    }\n    else\n    {\n      value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n      value_p->value = ecma_make_uint32_value (index);\n    }\n  }\n  else\n  {\n    ((ecma_extended_object_t *) iter_obj_p)->u.pseudo_array.u1.iterator_index = (uint16_t) index;\n  }\n} /* ecma_op_iterator_set_index */\n\n/**\n * The %{Set, Map}IteratorPrototype% object's 'next' routine\n *\n * See also:\n *          ECMA-262 v6, 23.1.5.2.1\n *          ECMA-262 v6, 23.2.5.2.1\n *\n * Note:\n *     Returned value must be freed with ecma_free_value.\n *\n * @return iterator result object, if success\n *         error - otherwise\n */\necma_value_t\necma_op_container_iterator_next (ecma_value_t this_val, /**< this argument */\n                                 ecma_pseudo_array_type_t iterator_type) /**< type of the iterator */\n{\n  if (!ecma_is_value_object (this_val))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not an object.\"));\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (this_val);\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_PSEUDO_ARRAY\n      || ext_obj_p->u.pseudo_array.type != iterator_type)\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not an iterator.\"));\n  }\n\n  ecma_value_t iterated_value = ext_obj_p->u.pseudo_array.u2.iterated_value;\n\n  if (ecma_is_value_empty (iterated_value))\n  {\n    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);\n  }\n\n  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));\n  lit_magic_string_id_t lit_id = map_object_p->u.class_prop.class_id;\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  uint32_t index = ecma_op_iterator_get_index (obj_p);\n\n  if (index == entry_count)\n  {\n    ext_obj_p->u.pseudo_array.u2.iterated_value = ECMA_VALUE_EMPTY;\n\n    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);\n  }\n\n  uint8_t entry_size = ecma_op_container_entry_size (lit_id);\n  uint8_t iterator_kind = ext_obj_p->u.pseudo_array.extra_info;\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;\n\n  for (uint32_t i = index; i < entry_count; i += entry_size)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      if (i == (entry_count - entry_size))\n      {\n        ret_value = ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);\n        break;\n      }\n\n      continue;\n    }\n\n    ecma_op_iterator_set_index (obj_p, i + entry_size);\n\n    ecma_value_t key_arg = *entry_p;\n    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);\n\n    if (iterator_kind == ECMA_ITERATOR_KEYS)\n    {\n      ret_value = ecma_create_iter_result_object (key_arg, ECMA_VALUE_FALSE);\n    }\n    else if (iterator_kind == ECMA_ITERATOR_VALUES)\n    {\n      ret_value = ecma_create_iter_result_object (value_arg, ECMA_VALUE_FALSE);\n    }\n    else\n    {\n      JERRY_ASSERT (iterator_kind == ECMA_ITERATOR_KEYS_VALUES);\n\n      ecma_value_t entry_array_value;\n      entry_array_value = ecma_create_array_from_iter_element (value_arg, key_arg);\n\n      ret_value = ecma_create_iter_result_object (entry_array_value, ECMA_VALUE_FALSE);\n      ecma_free_value (entry_array_value);\n    }\n\n    break;\n  }\n\n  return ret_value;\n} /* ecma_op_container_iterator_next */\n\n#endif /* ENABLED (JERRY_ES2015) */\n\n/**\n * @}\n * @}\n */\n\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */\n"], "fixing_code": ["/* Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"jcontext.h\"\n#include \"ecma-alloc.h\"\n#include \"ecma-array-object.h\"\n#include \"ecma-builtins.h\"\n#include \"ecma-builtin-helpers.h\"\n#include \"ecma-exceptions.h\"\n#include \"ecma-function-object.h\"\n#include \"ecma-gc.h\"\n#include \"ecma-helpers.h\"\n#include \"ecma-iterator-object.h\"\n#include \"ecma-container-object.h\"\n#include \"ecma-property-hashmap.h\"\n#include \"ecma-objects.h\"\n\n#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)\n\n/** \\addtogroup ecma ECMA\n * @{\n *\n * \\addtogroup \\addtogroup ecmamaphelpers ECMA builtin Map/Set helper functions\n * @{\n */\n\n/**\n * Create a new internal buffer.\n *\n * Note:\n *   The first element of the collection tracks the size of the buffer.\n *   ECMA_VALUE_EMPTY values are not calculated into the size.\n *\n * @return pointer to the internal buffer\n */\nstatic inline ecma_collection_t *\necma_op_create_internal_buffer (void)\n{\n  ecma_collection_t *collection_p = ecma_new_collection ();\n  ecma_collection_push_back (collection_p, (ecma_value_t) 0);\n\n  return collection_p;\n} /* ecma_op_create_internal_buffer */\n\n/**\n * Append values to the internal buffer.\n */\nstatic void\necma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_value_t values[] = { ecma_copy_value_if_not_object (key_arg), ecma_copy_value_if_not_object (value_arg) };\n    ecma_collection_append (container_p, values, 2);\n  }\n  else\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */\n\n/**\n * Update the value of a given entry.\n */\nstatic inline void\necma_op_internal_buffer_update (ecma_value_t *entry_p, /**< entry pointer */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (entry_p != NULL);\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_free_value_if_not_object (((ecma_container_pair_t *) entry_p)->value);\n\n    ((ecma_container_pair_t *) entry_p)->value = ecma_copy_value_if_not_object (value_arg);\n  }\n} /* ecma_op_internal_buffer_update */\n\n/**\n * Delete element from the internal buffer.\n */\nstatic void\necma_op_internal_buffer_delete (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_container_pair_t *entry_p, /**< entry pointer */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n  JERRY_ASSERT (entry_p != NULL);\n\n  ecma_free_value_if_not_object (entry_p->key);\n  entry_p->key = ECMA_VALUE_EMPTY;\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_free_value_if_not_object (entry_p->value);\n    entry_p->value = ECMA_VALUE_EMPTY;\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) - 1);\n} /* ecma_op_internal_buffer_delete */\n\n/**\n * Find an entry in the collection.\n *\n * @return pointer to the appropriate entry.\n */\nstatic ecma_value_t *\necma_op_internal_buffer_find (ecma_collection_t *container_p, /**< internal container pointer */\n                              ecma_value_t key_arg, /**< key argument */\n                              lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  uint8_t entry_size = ecma_op_container_entry_size (lit_id);\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += entry_size)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_op_same_value_zero (*entry_p, key_arg))\n    {\n      return entry_p;\n    }\n  }\n\n  return NULL;\n} /* ecma_op_internal_buffer_find */\n\n/**\n * Get the value that belongs to the key.\n *\n * Note: in case of Set containers, the values are the same as the keys.\n *\n * @return ecma value\n */\nstatic ecma_value_t\necma_op_container_get_value (ecma_value_t *entry_p, /**< entry (key) pointer */\n                             lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (entry_p != NULL);\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    return ((ecma_container_pair_t *) entry_p)->value;\n  }\n\n  return *entry_p;\n} /* ecma_op_container_get_value */\n\n/**\n * Get the size (in ecma_value_t) of the stored entries.\n *\n * @return size of the entries.\n */\nuint8_t\necma_op_container_entry_size (lit_magic_string_id_t lit_id) /**< class id */\n{\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    return ECMA_CONTAINER_PAIR_SIZE;\n  }\n\n  return ECMA_CONTAINER_VALUE_SIZE;\n} /* ecma_op_container_entry_size */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n/**\n * Release the entries in the WeakSet container.\n */\nstatic void\necma_op_container_free_weakset_entries (ecma_object_t *object_p, /**< object pointer */\n                                        ecma_collection_t *container_p) /** internal buffer pointer */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      continue;\n    }\n\n    ecma_op_container_unref_weak (ecma_get_object_from_value (*entry_p), ecma_make_object_value (object_p));\n    ecma_op_container_remove_weak_entry (object_p, *entry_p);\n\n    *entry_p = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_weakset_entries */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n/**\n * Release the entries in the WeakMap container.\n */\nstatic void\necma_op_container_free_weakmap_entries (ecma_object_t *object_p, /**< object pointer */\n                                        ecma_collection_t *container_p) /**< internal buffer pointer */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)\n  {\n    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);\n\n    if (ecma_is_value_empty (entry_p->key))\n    {\n      continue;\n    }\n\n    ecma_op_container_unref_weak (ecma_get_object_from_value (entry_p->key), ecma_make_object_value (object_p));\n    ecma_op_container_remove_weak_entry (object_p, entry_p->key);\n\n    ecma_free_value_if_not_object (entry_p->value);\n\n    entry_p->key = ECMA_VALUE_EMPTY;\n    entry_p->value = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_weakmap_entries */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n/**\n * Release the entries in the Set container.\n */\nstatic void\necma_op_container_free_set_entries (ecma_collection_t *container_p)\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      continue;\n    }\n\n    ecma_free_value_if_not_object (*entry_p);\n    *entry_p = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_set_entries */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n/**\n * Release the entries in the Map container.\n */\nstatic void\necma_op_container_free_map_entries (ecma_collection_t *container_p)\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n\n  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)\n  {\n    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);\n\n    if (ecma_is_value_empty (entry_p->key))\n    {\n      continue;\n    }\n\n    ecma_free_value_if_not_object (entry_p->key);\n    ecma_free_value_if_not_object (entry_p->value);\n\n    entry_p->key = ECMA_VALUE_EMPTY;\n    entry_p->value = ECMA_VALUE_EMPTY;\n  }\n} /* ecma_op_container_free_map_entries */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n\n/**\n * Release the internal buffer and the stored entries.\n */\nvoid\necma_op_container_free_entries (ecma_object_t *object_p) /**< collection object pointer */\n{\n  JERRY_ASSERT (object_p != NULL);\n\n  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  switch (map_object_p->u.class_prop.class_id)\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n    case LIT_MAGIC_STRING_WEAKSET_UL:\n    {\n      ecma_op_container_free_weakset_entries (object_p, container_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n    case LIT_MAGIC_STRING_WEAKMAP_UL:\n    {\n      ecma_op_container_free_weakmap_entries (object_p, container_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n    case LIT_MAGIC_STRING_SET_UL:\n    {\n      ecma_op_container_free_set_entries (container_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n    case LIT_MAGIC_STRING_MAP_UL:\n    {\n      ecma_op_container_free_map_entries (container_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n    default:\n    {\n      break;\n    }\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, 0);\n} /* ecma_op_container_free_entries */\n\n/**\n * Handle calling [[Construct]] of built-in Map/Set like objects\n *\n * @return ecma value\n */\necma_value_t\necma_op_container_create (const ecma_value_t *arguments_list_p, /**< arguments list */\n                          ecma_length_t arguments_list_len, /**< number of arguments */\n                          lit_magic_string_id_t lit_id, /**< internal class id */\n                          ecma_builtin_id_t proto_id) /**< prototype builtin id */\n{\n  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);\n  JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_MAP_UL\n                || lit_id == LIT_MAGIC_STRING_SET_UL\n                || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL\n                || lit_id == LIT_MAGIC_STRING_WEAKSET_UL);\n  JERRY_ASSERT (JERRY_CONTEXT (current_new_target) != NULL);\n\n  ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target), proto_id);\n\n  if (JERRY_UNLIKELY (proto_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ecma_op_create_internal_buffer ();\n  ecma_object_t *object_p  = ecma_create_object (proto_p,\n                                                 sizeof (ecma_extended_object_t),\n                                                 ECMA_OBJECT_TYPE_CLASS);\n  ecma_deref_object (proto_p);\n  ecma_extended_object_t *map_obj_p = (ecma_extended_object_t *) object_p;\n  map_obj_p->u.class_prop.extra_info = ECMA_CONTAINER_FLAGS_EMPTY;\n  map_obj_p->u.class_prop.class_id = (uint16_t) lit_id;\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)\n  {\n    map_obj_p->u.class_prop.extra_info |= ECMA_CONTAINER_FLAGS_WEAK;\n  }\n\n  ECMA_SET_INTERNAL_VALUE_POINTER (map_obj_p->u.class_prop.u.value, container_p);\n\n  ecma_value_t set_value = ecma_make_object_value (object_p);\n  ecma_value_t result = set_value;\n\n#if ENABLED (JERRY_ES2015)\n  if (arguments_list_len == 0)\n  {\n    return result;\n  }\n\n  ecma_value_t iterable = arguments_list_p[0];\n\n  if (ecma_is_value_undefined (iterable) || ecma_is_value_null (iterable))\n  {\n    return result;\n  }\n\n  lit_magic_string_id_t adder_string_id;\n  if (lit_id == LIT_MAGIC_STRING_MAP_UL || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL)\n  {\n    adder_string_id = LIT_MAGIC_STRING_SET;\n  }\n  else\n  {\n    adder_string_id = LIT_MAGIC_STRING_ADD;\n  }\n\n  result = ecma_op_object_get_by_magic_id (object_p, adder_string_id);\n  if (ECMA_IS_VALUE_ERROR (result))\n  {\n    goto cleanup_object;\n  }\n\n  if (!ecma_op_is_callable (result))\n  {\n    ecma_free_value (result);\n    result = ecma_raise_type_error (ECMA_ERR_MSG (\"add/set function is not callable.\"));\n    goto cleanup_object;\n  }\n\n  ecma_object_t *adder_func_p = ecma_get_object_from_value (result);\n\n  result = ecma_op_get_iterator (iterable, ECMA_VALUE_EMPTY);\n\n  if (ECMA_IS_VALUE_ERROR (result))\n  {\n    goto cleanup_adder;\n  }\n\n  const ecma_value_t iter = result;\n\n  while (true)\n  {\n    result = ecma_op_iterator_step (iter);\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      goto cleanup_iter;\n    }\n\n    if (ecma_is_value_false (result))\n    {\n      break;\n    }\n\n    const ecma_value_t next = result;\n    result = ecma_op_iterator_value (next);\n    ecma_free_value (next);\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      goto cleanup_iter;\n    }\n\n    if (lit_id == LIT_MAGIC_STRING_SET_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)\n    {\n      const ecma_value_t value = result;\n\n      ecma_value_t arguments[] = { value };\n      result = ecma_op_function_call (adder_func_p, set_value, arguments, 1);\n\n      ecma_free_value (value);\n    }\n    else\n    {\n      if (!ecma_is_value_object (result))\n      {\n        ecma_free_value (result);\n        ecma_raise_type_error (ECMA_ERR_MSG (\"Iterator value is not an object.\"));\n        result = ecma_op_iterator_close (iter);\n        JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));\n        goto cleanup_iter;\n      }\n\n      ecma_object_t *next_object_p = ecma_get_object_from_value (result);\n\n      result = ecma_op_object_get_by_uint32_index (next_object_p, 0);\n\n      if (ECMA_IS_VALUE_ERROR (result))\n      {\n        ecma_deref_object (next_object_p);\n        ecma_op_iterator_close (iter);\n        goto cleanup_iter;\n      }\n\n      const ecma_value_t key = result;\n\n      result = ecma_op_object_get_by_uint32_index (next_object_p, 1);\n\n      if (ECMA_IS_VALUE_ERROR (result))\n      {\n        ecma_deref_object (next_object_p);\n        ecma_free_value (key);\n        ecma_op_iterator_close (iter);\n        goto cleanup_iter;\n      }\n\n      const ecma_value_t value = result;\n      ecma_value_t arguments[] = { key, value };\n      result = ecma_op_function_call (adder_func_p, set_value, arguments, 2);\n\n      ecma_free_value (key);\n      ecma_free_value (value);\n      ecma_deref_object (next_object_p);\n    }\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      ecma_op_iterator_close (iter);\n      goto cleanup_iter;\n    }\n\n    ecma_free_value (result);\n  }\n\n  ecma_free_value (iter);\n  ecma_deref_object (adder_func_p);\n  return ecma_make_object_value (object_p);\n\ncleanup_iter:\n  ecma_free_value (iter);\ncleanup_adder:\n  ecma_deref_object (adder_func_p);\ncleanup_object:\n  ecma_deref_object (object_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return result;\n} /* ecma_op_container_create */\n\n/**\n * Get Map/Set object pointer\n *\n * Note:\n *   If the function returns with NULL, the error object has\n *   already set, and the caller must return with ECMA_VALUE_ERROR\n *\n * @return pointer to the Map/Set if this_arg is a valid Map/Set object\n *         NULL otherwise\n */\nstatic ecma_extended_object_t *\necma_op_container_get_object (ecma_value_t this_arg, /**< this argument */\n                              lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  if (ecma_is_value_object (this_arg))\n  {\n    ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) ecma_get_object_from_value (this_arg);\n\n    if (ecma_get_object_type ((ecma_object_t *) map_object_p) == ECMA_OBJECT_TYPE_CLASS\n        && map_object_p->u.class_prop.class_id == lit_id)\n    {\n      return map_object_p;\n    }\n  }\n\n#if ENABLED (JERRY_ERROR_MESSAGES)\n  ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,\n                                         \"Expected a % object.\",\n                                         ecma_make_string_value (ecma_get_magic_string (lit_id)));\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n  ecma_raise_type_error (NULL);\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n\n  return NULL;\n} /* ecma_op_container_get_object */\n\n/**\n * Returns with the size of the Map/Set object.\n *\n * @return size of the Map/Set object as ecma-value.\n */\necma_value_t\necma_op_container_size (ecma_value_t this_arg, /**< this argument */\n                        lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  return ecma_make_uint32_value (ECMA_CONTAINER_GET_SIZE (container_p));\n} /* ecma_op_container_size */\n\n/**\n * The generic Map/WeakMap prototype object's 'get' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_get (ecma_value_t this_arg, /**< this argument */\n                       ecma_value_t key_arg, /**< key argument */\n                       lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL && !ecma_is_value_object (key_arg))\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  if (entry_p == NULL)\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  return ecma_copy_value (((ecma_container_pair_t *) entry_p)->value);\n} /* ecma_op_container_get */\n\n/**\n * The generic Map/Set prototype object's 'has' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_has (ecma_value_t this_arg, /**< this argument */\n                       ecma_value_t key_arg, /**< key argument */\n                       lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) || ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n  if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0\n      && !ecma_is_value_object (key_arg))\n  {\n    return ECMA_VALUE_FALSE;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n\n  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  return ecma_make_boolean_value (entry_p != NULL);\n} /* ecma_op_container_has */\n\n/**\n * Set a weak reference from a container to a key object\n */\nstatic void\necma_op_container_set_weak (ecma_object_t *const key_p, /**< key object */\n                            ecma_extended_object_t *const container_p) /**< container */\n{\n  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (key_p)))\n  {\n    ecma_fast_array_convert_to_normal (key_p);\n  }\n\n  ecma_string_t *weak_refs_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);\n  ecma_property_t *property_p = ecma_find_named_property (key_p, weak_refs_string_p);\n  ecma_collection_t *refs_p;\n\n  if (property_p == NULL)\n  {\n    ecma_property_value_t *value_p = ecma_create_named_data_property (key_p,\n                                                                      weak_refs_string_p,\n                                                                      ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                                      &property_p);\n    ECMA_CONVERT_DATA_PROPERTY_TO_INTERNAL_PROPERTY (property_p);\n    refs_p = ecma_new_collection ();\n    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, refs_p);\n  }\n  else\n  {\n    refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, (ECMA_PROPERTY_VALUE_PTR (property_p)->value));\n  }\n\n  const ecma_value_t container_value = ecma_make_object_value ((ecma_object_t *) container_p);\n  for (uint32_t i = 0; i < refs_p->item_count; i++)\n  {\n    if (ecma_is_value_empty (refs_p->buffer_p[i]))\n    {\n      refs_p->buffer_p[i] = container_value;\n      return;\n    }\n  }\n\n  ecma_collection_push_back (refs_p, container_value);\n} /* ecma_op_container_set_weak */\n\n/**\n * Helper method for the Map.prototype.set and Set.prototype.add methods to swap the sign of the given value if needed\n *\n * See also:\n *          ECMA-262 v6, 23.2.3.1 step 6\n *          ECMA-262 v6, 23.1.3.9 step 6\n *\n * @return ecma value\n */\nstatic ecma_value_t\necma_op_container_set_noramlize_zero (ecma_value_t this_arg) /*< this arg */\n{\n  if (ecma_is_value_number (this_arg))\n  {\n    ecma_number_t number_value = ecma_get_number_from_value (this_arg);\n\n    if (JERRY_UNLIKELY (ecma_number_is_zero (number_value) && ecma_number_is_negative (number_value)))\n    {\n      return ecma_make_integer_value (0);\n    }\n  }\n\n  return this_arg;\n} /* ecma_op_container_set_noramlize_zero */\n\n/**\n * The generic Map prototype object's 'set' and Set prototype object's 'add' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_set (ecma_value_t this_arg, /**< this argument */\n                       ecma_value_t key_arg, /**< key argument */\n                       ecma_value_t value_arg, /**< value argument */\n                       lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n  if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0\n      && !ecma_is_value_object (key_arg))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Key must be an object\"));\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  if (entry_p == NULL)\n  {\n    ecma_op_internal_buffer_append (container_p,\n                                    ecma_op_container_set_noramlize_zero (key_arg),\n                                    value_arg,\n                                    lit_id);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n    if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0)\n    {\n      ecma_object_t *key_p = ecma_get_object_from_value (key_arg);\n      ecma_op_container_set_weak (key_p, map_object_p);\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n  }\n  else\n  {\n    ecma_op_internal_buffer_update (entry_p, ecma_op_container_set_noramlize_zero (value_arg), lit_id);\n  }\n\n  ecma_ref_object ((ecma_object_t *) map_object_p);\n  return this_arg;\n} /* ecma_op_container_set */\n\n/**\n * The generic Map/Set prototype object's 'forEach' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_foreach (ecma_value_t this_arg, /**< this argument */\n                           ecma_value_t predicate, /**< callback function */\n                           ecma_value_t predicate_this_arg, /**< this argument for\n                                                             *   invoke predicate */\n                           lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  if (!ecma_op_is_callable (predicate))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Callback function is not callable.\"));\n  }\n\n  JERRY_ASSERT (ecma_is_value_object (predicate));\n  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);\n  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  uint8_t entry_size = ecma_op_container_entry_size (lit_id);\n\n  for (uint32_t i = 0; i < ECMA_CONTAINER_ENTRY_COUNT (container_p); i += entry_size)\n  {\n    ecma_value_t *entry_p = ECMA_CONTAINER_START (container_p) + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      continue;\n    }\n\n    ecma_value_t key_arg = *entry_p;\n    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);\n\n    ecma_value_t call_args[] = { value_arg, key_arg, this_arg };\n    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);\n\n    if (ECMA_IS_VALUE_ERROR (call_value))\n    {\n      ret_value = call_value;\n      break;\n    }\n\n    ecma_free_value (call_value);\n  }\n\n  return ret_value;\n} /* ecma_op_container_foreach */\n\n/**\n * The Map/Set prototype object's 'clear' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_clear (ecma_value_t this_arg, /**< this argument */\n                         lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_op_container_free_entries ((ecma_object_t *) map_object_p);\n\n  return ECMA_VALUE_UNDEFINED;\n} /* ecma_op_container_clear */\n\n/**\n * The generic Map/Set prototype object's 'delete' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_delete (ecma_value_t this_arg, /**< this argument */\n                          ecma_value_t key_arg, /**< key argument */\n                          lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  if (entry_p == NULL)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);\n  return ECMA_VALUE_TRUE;\n} /* ecma_op_container_delete */\n\n/**\n * The generic WeakMap/WeakSet prototype object's 'delete' routine\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\necma_value_t\necma_op_container_delete_weak (ecma_value_t this_arg, /**< this argument */\n                               ecma_value_t key_arg, /**< key argument */\n                               lit_magic_string_id_t lit_id) /**< internal class id */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  if (!ecma_is_value_object (key_arg))\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);\n\n  if (entry_p == NULL)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);\n\n  ecma_object_t *key_object_p = ecma_get_object_from_value (key_arg);\n  ecma_op_container_unref_weak (key_object_p, ecma_make_object_value ((ecma_object_t *) map_object_p));\n\n  return ECMA_VALUE_TRUE;\n} /* ecma_op_container_delete_weak */\n\n/**\n * Helper function to remove a weak reference to an object.\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\nvoid\necma_op_container_unref_weak (ecma_object_t *object_p, /**< this argument */\n                              ecma_value_t ref_holder) /**< key argument */\n{\n  ecma_string_t *weak_refs_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, weak_refs_string_p);\n  JERRY_ASSERT (property_p != NULL);\n\n  ecma_collection_t *refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                               ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n  for (uint32_t i = 0; i < refs_p->item_count; i++)\n  {\n    if (refs_p->buffer_p[i] == ref_holder)\n    {\n      refs_p->buffer_p[i] = ECMA_VALUE_EMPTY;\n      break;\n    }\n  }\n} /* ecma_op_container_unref_weak */\n\n/**\n * Helper function to remove a key/value pair from a weak container object\n */\nvoid\necma_op_container_remove_weak_entry (ecma_object_t *object_p, /**< internal container object */\n                                     ecma_value_t key_arg) /**< key */\n{\n  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n\n  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, map_object_p->u.class_prop.class_id);\n\n  JERRY_ASSERT (entry_p != NULL);\n\n  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, map_object_p->u.class_prop.class_id);\n} /* ecma_op_container_remove_weak_entry */\n\n#if ENABLED (JERRY_ES2015)\n\n/**\n * The Create{Set, Map}Iterator Abstract operation\n *\n * See also:\n *          ECMA-262 v6, 23.1.5.1\n *          ECMA-262 v6, 23.2.5.1\n *\n * Note:\n *     Returned value must be freed with ecma_free_value.\n *\n * @return Map/Set iterator object, if success\n *         error - otherwise\n */\necma_value_t\necma_op_container_create_iterator (ecma_value_t this_arg, /**< this argument */\n                                   uint8_t type, /**< any combination of\n                                                  *   ecma_iterator_type_t bits */\n                                   lit_magic_string_id_t lit_id, /**< internal class id */\n                                   ecma_builtin_id_t proto_id, /**< prototype builtin id */\n                                   ecma_pseudo_array_type_t iterator_type) /**< type of the iterator */\n{\n  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);\n\n  if (map_object_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  return ecma_op_create_iterator_object (this_arg,\n                                         ecma_builtin_get (proto_id),\n                                         (uint8_t) iterator_type,\n                                         type);\n} /* ecma_op_container_create_iterator */\n\n/**\n * Get the index of the iterator object.\n *\n * @return index of the iterator.\n */\nstatic uint32_t\necma_op_iterator_get_index (ecma_object_t *iter_obj_p)  /**< iterator object pointer */\n{\n  uint32_t index = ((ecma_extended_object_t *) iter_obj_p)->u.pseudo_array.u1.iterator_index;\n\n  if (JERRY_UNLIKELY (index == ECMA_ITERATOR_INDEX_LIMIT))\n  {\n    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);\n    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);\n    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n    return (uint32_t) (ecma_get_number_from_value (value_p->value));\n  }\n\n  return index;\n} /* ecma_op_iterator_get_index */\n\n/**\n * Set the index of the iterator object.\n */\nstatic void\necma_op_iterator_set_index (ecma_object_t *iter_obj_p, /**< iterator object pointer */\n                            uint32_t index) /* iterator index to set */\n{\n  if (JERRY_UNLIKELY (index >= ECMA_ITERATOR_INDEX_LIMIT))\n  {\n    /* After the ECMA_ITERATOR_INDEX_LIMIT limit is reached the [[%Iterator%NextIndex]]\n       property is stored as an internal property */\n    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);\n    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);\n    ecma_property_value_t *value_p;\n\n    if (property_p == NULL)\n    {\n      value_p = ecma_create_named_data_property (iter_obj_p, prop_name_p, ECMA_PROPERTY_FLAG_WRITABLE, &property_p);\n      value_p->value = ecma_make_uint32_value (index);\n    }\n    else\n    {\n      value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n      value_p->value = ecma_make_uint32_value (index);\n    }\n  }\n  else\n  {\n    ((ecma_extended_object_t *) iter_obj_p)->u.pseudo_array.u1.iterator_index = (uint16_t) index;\n  }\n} /* ecma_op_iterator_set_index */\n\n/**\n * The %{Set, Map}IteratorPrototype% object's 'next' routine\n *\n * See also:\n *          ECMA-262 v6, 23.1.5.2.1\n *          ECMA-262 v6, 23.2.5.2.1\n *\n * Note:\n *     Returned value must be freed with ecma_free_value.\n *\n * @return iterator result object, if success\n *         error - otherwise\n */\necma_value_t\necma_op_container_iterator_next (ecma_value_t this_val, /**< this argument */\n                                 ecma_pseudo_array_type_t iterator_type) /**< type of the iterator */\n{\n  if (!ecma_is_value_object (this_val))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not an object.\"));\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (this_val);\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_PSEUDO_ARRAY\n      || ext_obj_p->u.pseudo_array.type != iterator_type)\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not an iterator.\"));\n  }\n\n  ecma_value_t iterated_value = ext_obj_p->u.pseudo_array.u2.iterated_value;\n\n  if (ecma_is_value_empty (iterated_value))\n  {\n    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);\n  }\n\n  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));\n  lit_magic_string_id_t lit_id = map_object_p->u.class_prop.class_id;\n\n  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                    map_object_p->u.class_prop.u.value);\n  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);\n  uint32_t index = ecma_op_iterator_get_index (obj_p);\n\n  if (index == entry_count)\n  {\n    ext_obj_p->u.pseudo_array.u2.iterated_value = ECMA_VALUE_EMPTY;\n\n    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);\n  }\n\n  uint8_t entry_size = ecma_op_container_entry_size (lit_id);\n  uint8_t iterator_kind = ext_obj_p->u.pseudo_array.extra_info;\n  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);\n  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;\n\n  for (uint32_t i = index; i < entry_count; i += entry_size)\n  {\n    ecma_value_t *entry_p = start_p + i;\n\n    if (ecma_is_value_empty (*entry_p))\n    {\n      if (i == (entry_count - entry_size))\n      {\n        ret_value = ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);\n        break;\n      }\n\n      continue;\n    }\n\n    ecma_op_iterator_set_index (obj_p, i + entry_size);\n\n    ecma_value_t key_arg = *entry_p;\n    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);\n\n    if (iterator_kind == ECMA_ITERATOR_KEYS)\n    {\n      ret_value = ecma_create_iter_result_object (key_arg, ECMA_VALUE_FALSE);\n    }\n    else if (iterator_kind == ECMA_ITERATOR_VALUES)\n    {\n      ret_value = ecma_create_iter_result_object (value_arg, ECMA_VALUE_FALSE);\n    }\n    else\n    {\n      JERRY_ASSERT (iterator_kind == ECMA_ITERATOR_KEYS_VALUES);\n\n      ecma_value_t entry_array_value;\n      entry_array_value = ecma_create_array_from_iter_element (value_arg, key_arg);\n\n      ret_value = ecma_create_iter_result_object (entry_array_value, ECMA_VALUE_FALSE);\n      ecma_free_value (entry_array_value);\n    }\n\n    break;\n  }\n\n  return ret_value;\n} /* ecma_op_container_iterator_next */\n\n#endif /* ENABLED (JERRY_ES2015) */\n\n/**\n * @}\n * @}\n */\n\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */\n"], "filenames": ["jerry-core/ecma/operations/ecma-container-object.c"], "buggy_code_start_loc": [67], "buggy_code_end_loc": [72], "fixing_code_start_loc": [66], "fixing_code_end_loc": [75], "type": "CWE-125", "message": "An issue was discovered in ecma/operations/ecma-container-object.c in JerryScript 2.2.0. Operations with key/value pairs did not consider the case where garbage collection is triggered after the key operation but before the value operation, as demonstrated by improper read access to memory in ecma_gc_set_object_visited in ecma/base/ecma-gc.c.", "other": {"cve": {"id": "CVE-2020-14163", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-15T21:15:10.553", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ecma/operations/ecma-container-object.c in JerryScript 2.2.0. Operations with key/value pairs did not consider the case where garbage collection is triggered after the key operation but before the value operation, as demonstrated by improper read access to memory in ecma_gc_set_object_visited in ecma/base/ecma-gc.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el archivo ecma/operations/ecma-container-object.c en JerryScript versi\u00f3n 2.2.0. Las operaciones con pares key/value no consideraron el caso donde el proceso garbage collection es activado despu\u00e9s de la operaci\u00f3n key pero antes de la operaci\u00f3n value, como es demostrado por el acceso de lectura inapropiado a la memoria en la funci\u00f3n ecma_gc_set_object_visited en el archivo ecma/base/ecma-gc.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jerryscript:jerryscript:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "88EBD351-0E34-480A-906A-603AC3920FBF"}]}]}], "references": [{"url": "https://github.com/jerryscript-project/jerryscript/commit/c2b662170245a16f46ce02eae68815c325d99821", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/jerryscript-project/jerryscript/issues/3804", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jerryscript-project/jerryscript/commit/c2b662170245a16f46ce02eae68815c325d99821"}}