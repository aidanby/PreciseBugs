{"buggy_code": ["parameters:\n    # Intention string used by the CSRF protection in REST context.\n    ezpublish_rest.csrf_token_intention: rest\n\n    # URI part that all REST routes begin with. By this a REST request is recognized.\n    ezpublish_rest.path_prefix: /api/ezp/v2\n\n    ezsettings.default.rest_root_resources:\n        content:\n            mediaType: ''\n            href: 'router.generate(\"ezpublish_rest_createContent\")'\n        contentByRemoteId:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_redirectContent\", {remoteId: \"{remoteId}\"})'\n        contentTypes:\n            mediaType: 'ContentTypeInfoList'\n            href: 'router.generate(\"ezpublish_rest_listContentTypes\")'\n        contentTypeByIdentifier:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_listContentTypes\", {identifier: \"{identifier}\"})'\n        contentTypeGroups:\n            mediaType: 'ContentTypeGroupList'\n            href: 'router.generate(\"ezpublish_rest_createContentTypeGroup\")'\n        contentTypeGroupByIdentifier:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_loadContentTypeGroupList\", {identifier: \"{identifier}\"})'\n        users:\n            mediaType: 'UserRefList'\n            href: 'router.generate(\"ezpublish_rest_loadUsers\")'\n        usersByRoleId:\n            mediaType: 'UserRefList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadUsers\", {roleId: \"{roleId}\"})'\n        usersByRemoteId:\n            mediaType: 'UserRefList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadUsers\", {remoteId: \"{remoteId}\"})'\n        usersByEmail:\n            mediaType: 'UserRefList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadUsers\", {email: \"{email}\"})'\n        usersByLogin:\n            mediaType: 'UserRefList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadUsers\", {login: \"{login}\"})'\n        roles:\n            mediaType: 'RoleList'\n            href: 'router.generate(\"ezpublish_rest_listRoles\")'\n        rootLocation:\n            mediaType: 'Location'\n            href: 'router.generate(\"ezpublish_rest_loadLocation\", {locationPath: \"1/2\"})'\n        rootUserGroup:\n            mediaType: 'UserGroup'\n            href: 'router.generate(\"ezpublish_rest_loadUserGroup\", {groupPath: \"1/5\"})'\n        rootMediaFolder:\n            mediaType: 'Location'\n            href: 'router.generate(\"ezpublish_rest_loadLocation\", {locationPath: \"1/43\"})'\n        locationByRemoteId:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_redirectLocation\", {remoteId: \"{remoteId}\"})'\n        locationByPath:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_redirectLocation\", {locationPath: \"{locationPath}\"})'\n        trash:\n            mediaType: 'Trash'\n            href: 'router.generate(\"ezpublish_rest_loadTrashItems\")'\n        sections:\n            mediaType: 'SectionList'\n            href: 'router.generate(\"ezpublish_rest_listSections\")'\n        views:\n            mediaType: 'RefList'\n            href: 'router.generate(\"ezpublish_rest_views_create\")'\n        objectStateGroups:\n            mediaType: 'ObjectStateGroupList'\n            href: 'router.generate(\"ezpublish_rest_loadObjectStateGroups\")'\n        objectStates:\n            mediaType: 'ObjectStateList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadObjectStates\", {objectStateGroupId: \"{objectStateGroupId}\"})'\n        globalUrlAliases:\n            mediaType: 'UrlAliasRefList'\n            href: 'router.generate(\"ezpublish_rest_listGlobalURLAliases\")'\n        urlWildcards:\n            mediaType: 'UrlWildcardList'\n            href: 'router.generate(\"ezpublish_rest_listURLWildcards\")'\n        createSession:\n            mediaType: 'UserSession'\n            href: 'router.generate(\"ezpublish_rest_createSession\")'\n        refreshSession:\n            mediaType: 'UserSession'\n            href: 'templateRouter.generate(\"ezpublish_rest_refreshSession\", {sessionId: \"{sessionId}\"})'\n", "parameters:\n    ezpublish_rest.security.authentication.listener.session.class: eZ\\Publish\\Core\\REST\\Server\\Security\\RestAuthenticator\n    ezpublish_rest.security.authentication.logout_handler.class: eZ\\Publish\\Core\\REST\\Server\\Security\\RestLogoutHandler\n\n    ezpublish_rest.security.csrf.token_manager.class: eZ\\Publish\\Core\\REST\\Server\\Security\\CsrfTokenManager\nservices:\n    # Following service will be aliased at compile time to \"ezpublish_rest.session_authenticator\" by the Security factory.\n    ezpublish_rest.security.authentication.listener.session:\n        class: \"%ezpublish_rest.security.authentication.listener.session.class%\"\n        arguments:\n            - \"@security.token_storage\"\n            - \"@security.authentication.manager\"\n            - ~ # Will be replaced at compile time by security provider key\n            - \"@event_dispatcher\"\n            - \"@ezpublish.config.resolver\"\n            - \"@session.storage\"\n            - \"@?logger\"\n        abstract: true\n\n    ezpublish_rest.security.authentication.logout_handler:\n        class: \"%ezpublish_rest.security.authentication.logout_handler.class%\"\n        arguments:\n            - '@ezpublish.config.resolver'\n\n    ezpublish_rest.security.csrf.token_manager:\n        class: '%ezpublish_rest.security.csrf.token_manager.class%'\n        arguments:\n            - '@?security.csrf.token_generator'\n            - '@?security.csrf.token_storage'\n            - '@?request_stack'\n", "<?php\n\n/**\n * @copyright Copyright (C) eZ Systems AS. All rights reserved.\n * @license For full copyright and license information view LICENSE file distributed with this source code.\n */\nnamespace eZ\\Publish\\Core\\REST\\Server\\Controller;\n\nuse eZ\\Publish\\Core\\Base\\Exceptions\\UnauthorizedException;\nuse eZ\\Publish\\Core\\MVC\\Symfony\\Security\\Authentication\\AuthenticatorInterface;\nuse eZ\\Publish\\Core\\REST\\Common\\Exceptions\\NotFoundException;\nuse eZ\\Publish\\Core\\REST\\Common\\Message;\nuse eZ\\Publish\\Core\\REST\\Server\\Controller;\nuse eZ\\Publish\\Core\\REST\\Server\\Values;\nuse eZ\\Publish\\Core\\REST\\Server\\Exceptions;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Security\\Csrf\\CsrfToken;\nuse eZ\\Publish\\Core\\REST\\Server\\Security\\CsrfTokenManager;\nuse Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Csrf\\TokenStorage\\TokenStorageInterface;\n\nclass SessionController extends Controller\n{\n    /** @var \\eZ\\Publish\\Core\\MVC\\Symfony\\Security\\Authentication\\AuthenticatorInterface */\n    private $authenticator;\n\n    /** @var \\eZ\\Publish\\Core\\REST\\Server\\Security\\CsrfTokenManager */\n    private $csrfTokenManager;\n\n    /** @var string */\n    private $csrfTokenIntention;\n\n    public function __construct(\n        AuthenticatorInterface $authenticator,\n        $tokenIntention,\n        CsrfTokenManager $csrfTokenManager = null,\n        TokenStorageInterface $csrfTokenStorage = null\n    ) {\n        $this->authenticator = $authenticator;\n        $this->csrfTokenIntention = $tokenIntention;\n        $this->csrfTokenManager = $csrfTokenManager;\n    }\n\n    /**\n     * Creates a new session based on the credentials provided as POST parameters.\n     *\n     * @throws \\eZ\\Publish\\Core\\Base\\Exceptions\\UnauthorizedException If the login or password are incorrect or invalid CSRF\n     *\n     * @return Values\\UserSession|Values\\Conflict\n     */\n    public function createSessionAction(Request $request)\n    {\n        /** @var $sessionInput \\eZ\\Publish\\Core\\REST\\Server\\Values\\SessionInput */\n        $sessionInput = $this->inputDispatcher->parse(\n            new Message(\n                ['Content-Type' => $request->headers->get('Content-Type')],\n                $request->getContent()\n            )\n        );\n        $request->attributes->set('username', $sessionInput->login);\n        $request->attributes->set('password', $sessionInput->password);\n\n        try {\n            $session = $request->getSession();\n            if ($session->isStarted() && $this->hasStoredCsrfToken()) {\n                $this->checkCsrfToken($request);\n            }\n\n            $token = $this->authenticator->authenticate($request);\n            $csrfToken = $this->getCsrfToken();\n\n            return new Values\\UserSession(\n                $token->getUser()->getAPIUser(),\n                $session->getName(),\n                $session->getId(),\n                $csrfToken,\n                !$token->hasAttribute('isFromSession')\n            );\n        } catch (Exceptions\\UserConflictException $e) {\n            // Already logged in with another user, this will be converted to HTTP status 409\n            return new Values\\Conflict();\n        } catch (AuthenticationException $e) {\n            $this->authenticator->logout($request);\n            throw new UnauthorizedException('Invalid login or password', $request->getPathInfo());\n        } catch (AccessDeniedException $e) {\n            $this->authenticator->logout($request);\n            throw new UnauthorizedException($e->getMessage(), $request->getPathInfo());\n        }\n    }\n\n    /**\n     * Refresh given session.\n     *\n     * @param string $sessionId\n     *\n     * @throws \\eZ\\Publish\\Core\\REST\\Common\\Exceptions\\NotFoundException\n     *\n     * @return \\eZ\\Publish\\Core\\REST\\Server\\Values\\UserSession\n     */\n    public function refreshSessionAction($sessionId, Request $request)\n    {\n        $session = $request->getSession();\n\n        if ($session === null || !$session->isStarted() || $session->getId() != $sessionId || !$this->hasStoredCsrfToken()) {\n            $response = $this->authenticator->logout($request);\n            $response->setStatusCode(404);\n\n            return $response;\n        }\n\n        $this->checkCsrfToken($request);\n\n        return new Values\\UserSession(\n            $this->repository->getCurrentUser(),\n            $session->getName(),\n            $session->getId(),\n            $request->headers->get('X-CSRF-Token'),\n            false\n        );\n    }\n\n    /**\n     * Deletes given session.\n     *\n     * @param string $sessionId\n     *\n     * @return Values\\DeletedUserSession\n     *\n     * @throws NotFoundException\n     */\n    public function deleteSessionAction($sessionId, Request $request)\n    {\n        /** @var $session \\Symfony\\Component\\HttpFoundation\\Session\\Session */\n        $session = $request->getSession();\n        if (!$session->isStarted() || $session->getId() != $sessionId || !$this->hasStoredCsrfToken()) {\n            $response = $this->authenticator->logout($request);\n            $response->setStatusCode(404);\n\n            return $response;\n        }\n\n        $this->checkCsrfToken($request);\n\n        return new Values\\DeletedUserSession($this->authenticator->logout($request));\n    }\n\n    /**\n     * Tests if a CSRF token is stored.\n     *\n     * @return bool\n     */\n    private function hasStoredCsrfToken()\n    {\n        if ($this->csrfTokenManager === null) {\n            return true;\n        }\n\n        return $this->csrfTokenManager->hasToken($this->csrfTokenIntention);\n    }\n\n    /**\n     * Checks the presence / validity of the CSRF token.\n     *\n     * @param Request $request\n     *\n     * @throws UnauthorizedException if the token is missing or invalid.\n     */\n    private function checkCsrfToken(Request $request)\n    {\n        if ($this->csrfTokenManager === null) {\n            return;\n        }\n\n        $exception = new UnauthorizedException(\n            'Missing or invalid CSRF token',\n            $request->getMethod() . ' ' . $request->getPathInfo()\n        );\n\n        if (!$request->headers->has('X-CSRF-Token')) {\n            throw $exception;\n        }\n\n        $csrfToken = new CsrfToken(\n            $this->csrfTokenIntention,\n            $request->headers->get('X-CSRF-Token')\n        );\n\n        if (!$this->csrfTokenManager->isTokenValid($csrfToken)) {\n            throw $exception;\n        }\n    }\n\n    /**\n     * Returns the csrf token for REST. The token is generated if it doesn't exist.\n     *\n     * @return string The csrf token, or an empty string if csrf check is disabled.\n     */\n    private function getCsrfToken()\n    {\n        if ($this->csrfTokenManager === null) {\n            return '';\n        }\n\n        return $this->csrfTokenManager->getToken($this->csrfTokenIntention)->getValue();\n    }\n}\n", "<?php\n\n/**\n * @copyright Copyright (C) eZ Systems AS. All rights reserved.\n * @license For full copyright and license information view LICENSE file distributed with this source code.\n */\nnamespace eZ\\Publish\\Core\\REST\\Server\\Security;\n\nuse eZ\\Publish\\Core\\MVC\\ConfigResolverInterface;\nuse eZ\\Publish\\Core\\MVC\\Symfony\\Security\\Authentication\\AuthenticatorInterface;\nuse eZ\\Publish\\Core\\MVC\\Symfony\\Security\\UserInterface as EzUser;\nuse eZ\\Publish\\Core\\REST\\Server\\Exceptions\\InvalidUserTypeException;\nuse eZ\\Publish\\Core\\REST\\Server\\Exceptions\\UserConflictException;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Storage\\SessionStorageInterface;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken;\nuse Symfony\\Component\\Security\\Core\\Exception\\TokenNotFoundException;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\InteractiveLoginEvent;\nuse Symfony\\Component\\Security\\Http\\Firewall\\ListenerInterface;\nuse Symfony\\Component\\Security\\Http\\Logout\\LogoutHandlerInterface;\nuse Symfony\\Component\\Security\\Http\\Logout\\SessionLogoutHandler;\nuse Symfony\\Component\\Security\\Http\\SecurityEvents;\n\n/**\n * Authenticator for REST API, mainly used for session based authentication (session creation resource).\n *\n * Implements \\Symfony\\Component\\Security\\Http\\Firewall\\ListenerInterface to be able to receive the provider key\n * (firewall identifier from configuration).\n */\nclass RestAuthenticator implements ListenerInterface, AuthenticatorInterface\n{\n    /** @var \\Psr\\Log\\LoggerInterface */\n    private $logger;\n\n    /** @var \\Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface */\n    private $authenticationManager;\n    /** @var string */\n    private $providerKey;\n\n    /** @var \\Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface */\n    private $tokenStorage;\n\n    /** @var \\Symfony\\Component\\EventDispatcher\\EventDispatcherInterface */\n    private $dispatcher;\n\n    /** @var \\eZ\\Publish\\Core\\MVC\\ConfigResolverInterface */\n    private $configResolver;\n\n    /** @var \\Symfony\\Component\\HttpFoundation\\Session\\Storage\\SessionStorageInterface */\n    private $sessionStorage;\n\n    /** @var \\Symfony\\Component\\Security\\Http\\Logout\\LogoutHandlerInterface[] */\n    private $logoutHandlers = [];\n\n    public function __construct(\n        TokenStorageInterface $tokenStorage,\n        AuthenticationManagerInterface $authenticationManager,\n        $providerKey,\n        EventDispatcherInterface $dispatcher,\n        ConfigResolverInterface $configResolver,\n        SessionStorageInterface $sessionStorage,\n        LoggerInterface $logger = null\n    ) {\n        $this->tokenStorage = $tokenStorage;\n        $this->authenticationManager = $authenticationManager;\n        $this->providerKey = $providerKey;\n        $this->dispatcher = $dispatcher;\n        $this->configResolver = $configResolver;\n        $this->sessionStorage = $sessionStorage;\n        $this->logger = $logger;\n    }\n\n    /**\n     * Doesn't do anything as we don't use this service with main Firewall listener.\n     *\n     * @param \\Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent $event\n     */\n    public function handle(GetResponseEvent $event)\n    {\n        return;\n    }\n\n    public function authenticate(Request $request)\n    {\n        // If a token already exists and username is the same as the one we request authentication for,\n        // then return it and mark it as coming from session.\n        $previousToken = $this->tokenStorage->getToken();\n        if (\n            $previousToken instanceof TokenInterface\n            && $previousToken->getUsername() === $request->attributes->get('username')\n        ) {\n            $previousToken->setAttribute('isFromSession', true);\n\n            return $previousToken;\n        }\n\n        $token = $this->attemptAuthentication($request);\n        if (!$token instanceof TokenInterface) {\n            if ($this->logger) {\n                $this->logger->error('REST: No token could be found in SecurityContext');\n            }\n\n            throw new TokenNotFoundException();\n        }\n\n        $this->tokenStorage->setToken($token);\n        $this->dispatcher->dispatch(\n            SecurityEvents::INTERACTIVE_LOGIN,\n            new InteractiveLoginEvent($request, $token)\n        );\n\n        // Re-fetch token from SecurityContext since an INTERACTIVE_LOGIN listener might have changed it\n        // i.e. when using multiple user providers.\n        // @see \\eZ\\Publish\\Core\\MVC\\Symfony\\Security\\EventListener\\SecurityListener::onInteractiveLogin()\n        $token = $this->tokenStorage->getToken();\n        $user = $token->getUser();\n        if (!$user instanceof EzUser) {\n            if ($this->logger) {\n                $this->logger->error('REST: Authenticated user must be eZ\\Publish\\Core\\MVC\\Symfony\\Security\\User, got ' . is_string($user) ? $user : get_class($user));\n            }\n\n            $e = new InvalidUserTypeException('Authenticated user is not an eZ User.');\n            $e->setToken($token);\n            throw $e;\n        }\n\n        // Check if newly logged in user differs from previous one.\n        if ($this->isUserConflict($user, $previousToken)) {\n            $this->tokenStorage->setToken($previousToken);\n            throw new UserConflictException();\n        }\n\n        return $token;\n    }\n\n    /**\n     * @param \\Symfony\\Component\\HttpFoundation\\Request $request\n     *\n     * @return \\Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface\n     */\n    private function attemptAuthentication(Request $request)\n    {\n        return $this->authenticationManager->authenticate(\n            new UsernamePasswordToken(\n                $request->attributes->get('username'),\n                $request->attributes->get('password'),\n                $this->providerKey\n            )\n        );\n    }\n\n    /**\n     * Checks if newly matched user is conflicting with previously non-anonymous logged in user, if any.\n     *\n     * @param EzUser $user\n     * @param TokenInterface $previousToken\n     *\n     * @return bool\n     */\n    private function isUserConflict(EzUser $user, TokenInterface $previousToken = null)\n    {\n        if ($previousToken === null || !$previousToken instanceof UsernamePasswordToken) {\n            return false;\n        }\n\n        $previousUser = $previousToken->getUser();\n        if (!$previousUser instanceof EzUser) {\n            return false;\n        }\n\n        $wasAnonymous = $previousUser->getAPIUser()->getUserId() == $this->configResolver->getParameter('anonymous_user_id');\n        // TODO: isEqualTo is not on the interface\n        return !$wasAnonymous && !$user->isEqualTo($previousUser);\n    }\n\n    public function addLogoutHandler(LogoutHandlerInterface $handler)\n    {\n        $this->logoutHandlers[] = $handler;\n    }\n\n    public function logout(Request $request)\n    {\n        $response = new Response();\n\n        // Manually clear the session through session storage.\n        // Session::invalidate() is not called on purpose, to avoid unwanted session migration that would imply\n        // generation of a new session id.\n        // REST logout must indeed clear the session cookie.\n        // See \\eZ\\Publish\\Core\\REST\\Server\\Security\\RestLogoutHandler\n        $this->sessionStorage->clear();\n\n        $token = $this->tokenStorage->getToken();\n        foreach ($this->logoutHandlers as $handler) {\n            // Explicitly ignore SessionLogoutHandler as we do session invalidation manually here,\n            // through the session storage, to avoid unwanted session migration.\n            if ($handler instanceof SessionLogoutHandler) {\n                continue;\n            }\n\n            $handler->logout($request, $response, $token);\n        }\n\n        return $response;\n    }\n}\n"], "fixing_code": ["parameters:\n    # Intention string used by the CSRF protection in REST context.\n    ezpublish_rest.csrf_token_intention: rest\n\n    # URI part that all REST routes begin with. By this a REST request is recognized.\n    ezpublish_rest.path_prefix: /api/ezp/v2\n\n    ezsettings.default.rest_root_resources:\n        content:\n            mediaType: ''\n            href: 'router.generate(\"ezpublish_rest_createContent\")'\n        contentByRemoteId:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_redirectContent\", {remoteId: \"{remoteId}\"})'\n        contentTypes:\n            mediaType: 'ContentTypeInfoList'\n            href: 'router.generate(\"ezpublish_rest_listContentTypes\")'\n        contentTypeByIdentifier:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_listContentTypes\", {identifier: \"{identifier}\"})'\n        contentTypeGroups:\n            mediaType: 'ContentTypeGroupList'\n            href: 'router.generate(\"ezpublish_rest_createContentTypeGroup\")'\n        contentTypeGroupByIdentifier:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_loadContentTypeGroupList\", {identifier: \"{identifier}\"})'\n        users:\n            mediaType: 'UserRefList'\n            href: 'router.generate(\"ezpublish_rest_loadUsers\")'\n        usersByRoleId:\n            mediaType: 'UserRefList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadUsers\", {roleId: \"{roleId}\"})'\n        usersByRemoteId:\n            mediaType: 'UserRefList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadUsers\", {remoteId: \"{remoteId}\"})'\n        usersByEmail:\n            mediaType: 'UserRefList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadUsers\", {email: \"{email}\"})'\n        usersByLogin:\n            mediaType: 'UserRefList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadUsers\", {login: \"{login}\"})'\n        roles:\n            mediaType: 'RoleList'\n            href: 'router.generate(\"ezpublish_rest_listRoles\")'\n        rootLocation:\n            mediaType: 'Location'\n            href: 'router.generate(\"ezpublish_rest_loadLocation\", {locationPath: \"1/2\"})'\n        rootUserGroup:\n            mediaType: 'UserGroup'\n            href: 'router.generate(\"ezpublish_rest_loadUserGroup\", {groupPath: \"1/5\"})'\n        rootMediaFolder:\n            mediaType: 'Location'\n            href: 'router.generate(\"ezpublish_rest_loadLocation\", {locationPath: \"1/43\"})'\n        locationByRemoteId:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_redirectLocation\", {remoteId: \"{remoteId}\"})'\n        locationByPath:\n            mediaType: ''\n            href: 'templateRouter.generate(\"ezpublish_rest_redirectLocation\", {locationPath: \"{locationPath}\"})'\n        trash:\n            mediaType: 'Trash'\n            href: 'router.generate(\"ezpublish_rest_loadTrashItems\")'\n        sections:\n            mediaType: 'SectionList'\n            href: 'router.generate(\"ezpublish_rest_listSections\")'\n        views:\n            mediaType: 'RefList'\n            href: 'router.generate(\"ezpublish_rest_views_create\")'\n        objectStateGroups:\n            mediaType: 'ObjectStateGroupList'\n            href: 'router.generate(\"ezpublish_rest_loadObjectStateGroups\")'\n        objectStates:\n            mediaType: 'ObjectStateList'\n            href: 'templateRouter.generate(\"ezpublish_rest_loadObjectStates\", {objectStateGroupId: \"{objectStateGroupId}\"})'\n        globalUrlAliases:\n            mediaType: 'UrlAliasRefList'\n            href: 'router.generate(\"ezpublish_rest_listGlobalURLAliases\")'\n        urlWildcards:\n            mediaType: 'UrlWildcardList'\n            href: 'router.generate(\"ezpublish_rest_listURLWildcards\")'\n        createSession:\n            mediaType: 'UserSession'\n            href: 'router.generate(\"ezpublish_rest_createSession\")'\n        refreshSession:\n            mediaType: 'UserSession'\n            href: 'templateRouter.generate(\"ezpublish_rest_refreshSession\", {sessionId: \"{sessionId}\"})'\n\n    # Boundary times in microseconds which the authentication check will be delayed by.\n    ezpublish_rest.authentication_min_delay_time: 30000\n    ezpublish_rest.authentication_max_delay_time: 500000", "parameters:\n    ezpublish_rest.security.authentication.listener.session.class: eZ\\Publish\\Core\\REST\\Server\\Security\\RestAuthenticator\n    ezpublish_rest.security.authentication.logout_handler.class: eZ\\Publish\\Core\\REST\\Server\\Security\\RestLogoutHandler\n\n    ezpublish_rest.security.csrf.token_manager.class: eZ\\Publish\\Core\\REST\\Server\\Security\\CsrfTokenManager\nservices:\n    # Following service will be aliased at compile time to \"ezpublish_rest.session_authenticator\" by the Security factory.\n    ezpublish_rest.security.authentication.listener.session:\n        class: \"%ezpublish_rest.security.authentication.listener.session.class%\"\n        arguments:\n            - \"@security.token_storage\"\n            - \"@security.authentication.manager\"\n            - ~ # Will be replaced at compile time by security provider key\n            - \"@event_dispatcher\"\n            - \"@ezpublish.config.resolver\"\n            - \"@session.storage\"\n            - \"@?logger\"\n            - \"%ezpublish_rest.authentication_min_delay_time%\"\n            - \"%ezpublish_rest.authentication_max_delay_time%\"\n        abstract: true\n\n    ezpublish_rest.security.authentication.logout_handler:\n        class: \"%ezpublish_rest.security.authentication.logout_handler.class%\"\n        arguments:\n            - '@ezpublish.config.resolver'\n\n    ezpublish_rest.security.csrf.token_manager:\n        class: '%ezpublish_rest.security.csrf.token_manager.class%'\n        arguments:\n            - '@?security.csrf.token_generator'\n            - '@?security.csrf.token_storage'\n            - '@?request_stack'\n", "<?php\n\n/**\n * @copyright Copyright (C) eZ Systems AS. All rights reserved.\n * @license For full copyright and license information view LICENSE file distributed with this source code.\n */\nnamespace eZ\\Publish\\Core\\REST\\Server\\Controller;\n\nuse eZ\\Publish\\Core\\Base\\Exceptions\\UnauthorizedException;\nuse eZ\\Publish\\Core\\MVC\\Symfony\\Security\\Authentication\\AuthenticatorInterface;\nuse eZ\\Publish\\Core\\REST\\Common\\Exceptions\\NotFoundException;\nuse eZ\\Publish\\Core\\REST\\Common\\Message;\nuse eZ\\Publish\\Core\\REST\\Server\\Controller;\nuse eZ\\Publish\\Core\\REST\\Server\\Values;\nuse eZ\\Publish\\Core\\REST\\Server\\Exceptions;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Security\\Csrf\\CsrfToken;\nuse eZ\\Publish\\Core\\REST\\Server\\Security\\CsrfTokenManager;\nuse Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Csrf\\TokenStorage\\TokenStorageInterface;\n\nclass SessionController extends Controller\n{\n    /** @var \\eZ\\Publish\\Core\\MVC\\Symfony\\Security\\Authentication\\AuthenticatorInterface */\n    private $authenticator;\n\n    /** @var \\eZ\\Publish\\Core\\REST\\Server\\Security\\CsrfTokenManager */\n    private $csrfTokenManager;\n\n    /** @var string */\n    private $csrfTokenIntention;\n\n    public function __construct(\n        AuthenticatorInterface $authenticator,\n        $tokenIntention,\n        CsrfTokenManager $csrfTokenManager = null,\n        TokenStorageInterface $csrfTokenStorage = null\n    ) {\n        $this->authenticator = $authenticator;\n        $this->csrfTokenIntention = $tokenIntention;\n        $this->csrfTokenManager = $csrfTokenManager;\n    }\n\n    /**\n     * Creates a new session based on the credentials provided as POST parameters.\n     *\n     * @throws \\eZ\\Publish\\Core\\Base\\Exceptions\\UnauthorizedException If the login or password are incorrect or invalid CSRF\n     *\n     * @return Values\\UserSession|Values\\Conflict\n     */\n    public function createSessionAction(Request $request)\n    {\n        /** @var $sessionInput \\eZ\\Publish\\Core\\REST\\Server\\Values\\SessionInput */\n        $sessionInput = $this->inputDispatcher->parse(\n            new Message(\n                ['Content-Type' => $request->headers->get('Content-Type')],\n                $request->getContent()\n            )\n        );\n        $request->attributes->set('username', $sessionInput->login);\n        $request->attributes->set('password', (string) $sessionInput->password);\n\n        try {\n            $session = $request->getSession();\n            if ($session->isStarted() && $this->hasStoredCsrfToken()) {\n                $this->checkCsrfToken($request);\n            }\n\n            $token = $this->authenticator->authenticate($request);\n            $csrfToken = $this->getCsrfToken();\n\n            return new Values\\UserSession(\n                $token->getUser()->getAPIUser(),\n                $session->getName(),\n                $session->getId(),\n                $csrfToken,\n                !$token->hasAttribute('isFromSession')\n            );\n        } catch (Exceptions\\UserConflictException $e) {\n            // Already logged in with another user, this will be converted to HTTP status 409\n            return new Values\\Conflict();\n        } catch (AuthenticationException $e) {\n            $this->authenticator->logout($request);\n            throw new UnauthorizedException('Invalid login or password', $request->getPathInfo());\n        } catch (AccessDeniedException $e) {\n            $this->authenticator->logout($request);\n            throw new UnauthorizedException($e->getMessage(), $request->getPathInfo());\n        }\n    }\n\n    /**\n     * Refresh given session.\n     *\n     * @param string $sessionId\n     *\n     * @throws \\eZ\\Publish\\Core\\REST\\Common\\Exceptions\\NotFoundException\n     *\n     * @return \\eZ\\Publish\\Core\\REST\\Server\\Values\\UserSession\n     */\n    public function refreshSessionAction($sessionId, Request $request)\n    {\n        $session = $request->getSession();\n\n        if ($session === null || !$session->isStarted() || $session->getId() != $sessionId || !$this->hasStoredCsrfToken()) {\n            $response = $this->authenticator->logout($request);\n            $response->setStatusCode(404);\n\n            return $response;\n        }\n\n        $this->checkCsrfToken($request);\n\n        return new Values\\UserSession(\n            $this->repository->getCurrentUser(),\n            $session->getName(),\n            $session->getId(),\n            $request->headers->get('X-CSRF-Token'),\n            false\n        );\n    }\n\n    /**\n     * Deletes given session.\n     *\n     * @param string $sessionId\n     *\n     * @return Values\\DeletedUserSession\n     *\n     * @throws NotFoundException\n     */\n    public function deleteSessionAction($sessionId, Request $request)\n    {\n        /** @var $session \\Symfony\\Component\\HttpFoundation\\Session\\Session */\n        $session = $request->getSession();\n        if (!$session->isStarted() || $session->getId() != $sessionId || !$this->hasStoredCsrfToken()) {\n            $response = $this->authenticator->logout($request);\n            $response->setStatusCode(404);\n\n            return $response;\n        }\n\n        $this->checkCsrfToken($request);\n\n        return new Values\\DeletedUserSession($this->authenticator->logout($request));\n    }\n\n    /**\n     * Tests if a CSRF token is stored.\n     *\n     * @return bool\n     */\n    private function hasStoredCsrfToken()\n    {\n        if ($this->csrfTokenManager === null) {\n            return true;\n        }\n\n        return $this->csrfTokenManager->hasToken($this->csrfTokenIntention);\n    }\n\n    /**\n     * Checks the presence / validity of the CSRF token.\n     *\n     * @param Request $request\n     *\n     * @throws UnauthorizedException if the token is missing or invalid.\n     */\n    private function checkCsrfToken(Request $request)\n    {\n        if ($this->csrfTokenManager === null) {\n            return;\n        }\n\n        $exception = new UnauthorizedException(\n            'Missing or invalid CSRF token',\n            $request->getMethod() . ' ' . $request->getPathInfo()\n        );\n\n        if (!$request->headers->has('X-CSRF-Token')) {\n            throw $exception;\n        }\n\n        $csrfToken = new CsrfToken(\n            $this->csrfTokenIntention,\n            $request->headers->get('X-CSRF-Token')\n        );\n\n        if (!$this->csrfTokenManager->isTokenValid($csrfToken)) {\n            throw $exception;\n        }\n    }\n\n    /**\n     * Returns the csrf token for REST. The token is generated if it doesn't exist.\n     *\n     * @return string The csrf token, or an empty string if csrf check is disabled.\n     */\n    private function getCsrfToken()\n    {\n        if ($this->csrfTokenManager === null) {\n            return '';\n        }\n\n        return $this->csrfTokenManager->getToken($this->csrfTokenIntention)->getValue();\n    }\n}\n", "<?php\n\n/**\n * @copyright Copyright (C) eZ Systems AS. All rights reserved.\n * @license For full copyright and license information view LICENSE file distributed with this source code.\n */\nnamespace eZ\\Publish\\Core\\REST\\Server\\Security;\n\nuse eZ\\Publish\\Core\\MVC\\ConfigResolverInterface;\nuse eZ\\Publish\\Core\\MVC\\Symfony\\Security\\Authentication\\AuthenticatorInterface;\nuse eZ\\Publish\\Core\\MVC\\Symfony\\Security\\UserInterface as EzUser;\nuse eZ\\Publish\\Core\\REST\\Server\\Exceptions\\InvalidUserTypeException;\nuse eZ\\Publish\\Core\\REST\\Server\\Exceptions\\UserConflictException;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Storage\\SessionStorageInterface;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken;\nuse Symfony\\Component\\Security\\Core\\Exception\\TokenNotFoundException;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\InteractiveLoginEvent;\nuse Symfony\\Component\\Security\\Http\\Firewall\\ListenerInterface;\nuse Symfony\\Component\\Security\\Http\\Logout\\LogoutHandlerInterface;\nuse Symfony\\Component\\Security\\Http\\Logout\\SessionLogoutHandler;\nuse Symfony\\Component\\Security\\Http\\SecurityEvents;\n\n/**\n * Authenticator for REST API, mainly used for session based authentication (session creation resource).\n *\n * Implements \\Symfony\\Component\\Security\\Http\\Firewall\\ListenerInterface to be able to receive the provider key\n * (firewall identifier from configuration).\n */\nclass RestAuthenticator implements ListenerInterface, AuthenticatorInterface\n{\n    const DEFAULT_MIN_SLEEP_VALUE = 30000;\n\n    const DEFAULT_MAX_SLEEP_VALUE = 500000;\n\n    /** @var \\Psr\\Log\\LoggerInterface */\n    private $logger;\n\n    /** @var \\Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface */\n    private $authenticationManager;\n    /** @var string */\n    private $providerKey;\n\n    /** @var \\Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface */\n    private $tokenStorage;\n\n    /** @var \\Symfony\\Component\\EventDispatcher\\EventDispatcherInterface */\n    private $dispatcher;\n\n    /** @var \\eZ\\Publish\\Core\\MVC\\ConfigResolverInterface */\n    private $configResolver;\n\n    /** @var \\Symfony\\Component\\HttpFoundation\\Session\\Storage\\SessionStorageInterface */\n    private $sessionStorage;\n\n    /** @var \\Symfony\\Component\\Security\\Http\\Logout\\LogoutHandlerInterface[] */\n    private $logoutHandlers = [];\n\n    /**\n     * @var int|null\n     */\n    private $minSleepTime;\n\n    /**\n     * @var int|null\n     */\n    private $maxSleepTime;\n\n    public function __construct(\n        TokenStorageInterface $tokenStorage,\n        AuthenticationManagerInterface $authenticationManager,\n        $providerKey,\n        EventDispatcherInterface $dispatcher,\n        ConfigResolverInterface $configResolver,\n        SessionStorageInterface $sessionStorage,\n        LoggerInterface $logger = null,\n        $minSleepTime = self::DEFAULT_MIN_SLEEP_VALUE,\n        $maxSleepTime = self::DEFAULT_MAX_SLEEP_VALUE\n    ) {\n        $this->tokenStorage = $tokenStorage;\n        $this->authenticationManager = $authenticationManager;\n        $this->providerKey = $providerKey;\n        $this->dispatcher = $dispatcher;\n        $this->configResolver = $configResolver;\n        $this->sessionStorage = $sessionStorage;\n        $this->logger = $logger;\n        $this->minSleepTime = !is_int($minSleepTime) ? self::DEFAULT_MIN_SLEEP_VALUE : $minSleepTime;\n        $this->maxSleepTime = !is_int($maxSleepTime) ? self::DEFAULT_MAX_SLEEP_VALUE : $maxSleepTime;\n    }\n\n    /**\n     * Doesn't do anything as we don't use this service with main Firewall listener.\n     *\n     * @param \\Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent $event\n     */\n    public function handle(GetResponseEvent $event)\n    {\n        return;\n    }\n\n    public function authenticate(Request $request)\n    {\n        usleep(random_int($this->minSleepTime, $this->maxSleepTime));\n\n        // If a token already exists and username is the same as the one we request authentication for,\n        // then return it and mark it as coming from session.\n        $previousToken = $this->tokenStorage->getToken();\n        if (\n            $previousToken instanceof TokenInterface\n            && $previousToken->getUsername() === $request->attributes->get('username')\n        ) {\n            $previousToken->setAttribute('isFromSession', true);\n\n            return $previousToken;\n        }\n\n        $token = $this->attemptAuthentication($request);\n        if (!$token instanceof TokenInterface) {\n            if ($this->logger) {\n                $this->logger->error('REST: No token could be found in SecurityContext');\n            }\n\n            throw new TokenNotFoundException();\n        }\n\n        $this->tokenStorage->setToken($token);\n        $this->dispatcher->dispatch(\n            SecurityEvents::INTERACTIVE_LOGIN,\n            new InteractiveLoginEvent($request, $token)\n        );\n\n        // Re-fetch token from SecurityContext since an INTERACTIVE_LOGIN listener might have changed it\n        // i.e. when using multiple user providers.\n        // @see \\eZ\\Publish\\Core\\MVC\\Symfony\\Security\\EventListener\\SecurityListener::onInteractiveLogin()\n        $token = $this->tokenStorage->getToken();\n        $user = $token->getUser();\n        if (!$user instanceof EzUser) {\n            if ($this->logger) {\n                $this->logger->error('REST: Authenticated user must be eZ\\Publish\\Core\\MVC\\Symfony\\Security\\User, got ' . is_string($user) ? $user : get_class($user));\n            }\n\n            $e = new InvalidUserTypeException('Authenticated user is not an eZ User.');\n            $e->setToken($token);\n            throw $e;\n        }\n\n        // Check if newly logged in user differs from previous one.\n        if ($this->isUserConflict($user, $previousToken)) {\n            $this->tokenStorage->setToken($previousToken);\n            throw new UserConflictException();\n        }\n\n        return $token;\n    }\n\n    /**\n     * @param \\Symfony\\Component\\HttpFoundation\\Request $request\n     *\n     * @return \\Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface\n     */\n    private function attemptAuthentication(Request $request)\n    {\n        return $this->authenticationManager->authenticate(\n            new UsernamePasswordToken(\n                $request->attributes->get('username'),\n                $request->attributes->get('password'),\n                $this->providerKey\n            )\n        );\n    }\n\n    /**\n     * Checks if newly matched user is conflicting with previously non-anonymous logged in user, if any.\n     *\n     * @param EzUser $user\n     * @param TokenInterface $previousToken\n     *\n     * @return bool\n     */\n    private function isUserConflict(EzUser $user, TokenInterface $previousToken = null)\n    {\n        if ($previousToken === null || !$previousToken instanceof UsernamePasswordToken) {\n            return false;\n        }\n\n        $previousUser = $previousToken->getUser();\n        if (!$previousUser instanceof EzUser) {\n            return false;\n        }\n\n        $wasAnonymous = $previousUser->getAPIUser()->getUserId() == $this->configResolver->getParameter('anonymous_user_id');\n        // TODO: isEqualTo is not on the interface\n        return !$wasAnonymous && !$user->isEqualTo($previousUser);\n    }\n\n    public function addLogoutHandler(LogoutHandlerInterface $handler)\n    {\n        $this->logoutHandlers[] = $handler;\n    }\n\n    public function logout(Request $request)\n    {\n        $response = new Response();\n\n        // Manually clear the session through session storage.\n        // Session::invalidate() is not called on purpose, to avoid unwanted session migration that would imply\n        // generation of a new session id.\n        // REST logout must indeed clear the session cookie.\n        // See \\eZ\\Publish\\Core\\REST\\Server\\Security\\RestLogoutHandler\n        $this->sessionStorage->clear();\n\n        $token = $this->tokenStorage->getToken();\n        foreach ($this->logoutHandlers as $handler) {\n            // Explicitly ignore SessionLogoutHandler as we do session invalidation manually here,\n            // through the session storage, to avoid unwanted session migration.\n            if ($handler instanceof SessionLogoutHandler) {\n                continue;\n            }\n\n            $handler->logout($request, $response, $token);\n        }\n\n        return $response;\n    }\n}\n"], "filenames": ["eZ/Bundle/EzPublishRestBundle/Resources/config/default_settings.yml", "eZ/Bundle/EzPublishRestBundle/Resources/config/security.yml", "eZ/Publish/Core/REST/Server/Controller/SessionController.php", "eZ/Publish/Core/REST/Server/Security/RestAuthenticator.php"], "buggy_code_start_loc": [86, 17, 62, 38], "buggy_code_end_loc": [86, 17, 63, 91], "fixing_code_start_loc": [87, 18, 62, 39], "fixing_code_end_loc": [91, 20, 63, 112], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in eZ Publish Ibexa Kernel before 7.5.15.1. The /user/sessions endpoint can be abused to determine account existence.", "other": {"cve": {"id": "CVE-2021-46876", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-12T05:15:11.667", "lastModified": "2023-03-16T18:16:08.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in eZ Publish Ibexa Kernel before 7.5.15.1. The /user/sessions endpoint can be abused to determine account existence."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:ibexa:ez_platform_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.13.0", "versionEndExcluding": "6.13.8.1", "matchCriteriaId": "8D5472C5-EE58-482A-ADE4-BBB88926B151"}, {"vulnerable": true, "criteria": "cpe:2.3:o:ibexa:ez_platform_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.5.0", "versionEndExcluding": "7.5.15.1", "matchCriteriaId": "1A805C9F-9CF9-48EA-89BA-06BA45E9106A"}]}]}], "references": [{"url": "https://github.com/ezsystems/ezpublish-kernel/commit/b496f073c3f03707d3531a6941dc098b84e3cbed", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ezsystems/ezpublish-kernel/security/advisories/GHSA-gmrf-99gw-vvwj", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ezsystems/ezpublish-kernel/commit/b496f073c3f03707d3531a6941dc098b84e3cbed"}}