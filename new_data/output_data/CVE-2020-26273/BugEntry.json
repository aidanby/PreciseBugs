{"buggy_code": ["/**\n * Copyright (c) 2014-present, The osquery authors\n *\n * This source code is licensed as defined by the LICENSE file found in the\n * root directory of this source tree.\n *\n * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)\n */\n\n#include \"osquery/sql/sqlite_util.h\"\n#include \"osquery/sql/virtual_table.h\"\n\n#include <osquery/core/plugins/sql.h>\n\n#include <osquery/utils/conversions/castvariant.h>\n\n#include <osquery/core/core.h>\n#include <osquery/core/flags.h>\n#include <osquery/logger/logger.h>\n#include <osquery/registry/registry_factory.h>\n#include <osquery/sql/sql.h>\n\n#include <osquery/utils/conversions/split.h>\n\n#include <boost/lexical_cast.hpp>\n\nnamespace osquery {\n\nFLAG(string,\n     disable_tables,\n     \"\",\n     \"Comma-delimited list of table names to be disabled\");\n\nFLAG(string,\n     enable_tables,\n     \"\",\n     \"Comma-delimited list of table names to be enabled\");\n\nFLAG(string, nullvalue, \"\", \"Set string for NULL values, default ''\");\n\nusing OpReg = QueryPlanner::Opcode::Register;\n\nusing SQLiteDBInstanceRef = std::shared_ptr<SQLiteDBInstance>;\n\n/**\n * @brief A map of SQLite status codes to their corresponding message string\n *\n * Details of this map are defined at: http://www.sqlite.org/c3ref/c_abort.html\n */\n// clang-format off\nconst std::map<int, std::string> kSQLiteReturnCodes = {\n    {0, \"SQLITE_OK\"},        {1, \"SQLITE_ERROR\"},       {2, \"SQLITE_INTERNAL\"},\n    {3, \"SQLITE_PERM\"},      {4, \"SQLITE_ABORT\"},       {5, \"SQLITE_BUSY\"},\n    {6, \"SQLITE_LOCKED\"},    {7, \"SQLITE_NOMEM\"},       {8, \"SQLITE_READONLY\"},\n    {9, \"SQLITE_INTERRUPT\"}, {10, \"SQLITE_IOERR\"},      {11, \"SQLITE_CORRUPT\"},\n    {12, \"SQLITE_NOTFOUND\"}, {13, \"SQLITE_FULL\"},       {14, \"SQLITE_CANTOPEN\"},\n    {15, \"SQLITE_PROTOCOL\"}, {16, \"SQLITE_EMPTY\"},      {17, \"SQLITE_SCHEMA\"},\n    {18, \"SQLITE_TOOBIG\"},   {19, \"SQLITE_CONSTRAINT\"}, {20, \"SQLITE_MISMATCH\"},\n    {21, \"SQLITE_MISUSE\"},   {22, \"SQLITE_NOLFS\"},      {23, \"SQLITE_AUTH\"},\n    {24, \"SQLITE_FORMAT\"},   {25, \"SQLITE_RANGE\"},      {26, \"SQLITE_NOTADB\"},\n    {27, \"SQLITE_NOTICE\"},   {28, \"SQLITE_WARNING\"},    {100, \"SQLITE_ROW\"},\n    {101, \"SQLITE_DONE\"},\n};\n\nconst std::map<std::string, std::string> kMemoryDBSettings = {\n    {\"synchronous\", \"OFF\"},      {\"count_changes\", \"OFF\"},\n    {\"default_temp_store\", \"0\"}, {\"auto_vacuum\", \"FULL\"},\n    {\"journal_mode\", \"OFF\"},     {\"cache_size\", \"0\"},\n    {\"page_count\", \"0\"},\n};\n// clang-format on\n\n#define OpComparator(x)                                                        \\\n  { x, QueryPlanner::Opcode(OpReg::P2, INTEGER_TYPE) }\n#define Arithmetic(x)                                                          \\\n  { x, QueryPlanner::Opcode(OpReg::P3, BIGINT_TYPE) }\n\n/**\n * @brief A map from opcode to pair of result register and resultant type.\n *\n * For most opcodes we can deduce a column type based on an interred input\n * to the opcode \"function\". These come in a few sets, arithmetic operators,\n * comparators, aggregates, and copies.\n */\nconst std::map<std::string, QueryPlanner::Opcode> kSQLOpcodes = {\n    {\"Concat\", QueryPlanner::Opcode(OpReg::P3, TEXT_TYPE)},\n    {\"AggStep\", QueryPlanner::Opcode(OpReg::P3, BIGINT_TYPE)},\n    {\"AggStep0\", QueryPlanner::Opcode(OpReg::P3, BIGINT_TYPE)},\n    {\"Integer\", QueryPlanner::Opcode(OpReg::P2, INTEGER_TYPE)},\n    {\"Int64\", QueryPlanner::Opcode(OpReg::P2, BIGINT_TYPE)},\n    {\"String\", QueryPlanner::Opcode(OpReg::P2, TEXT_TYPE)},\n    {\"String8\", QueryPlanner::Opcode(OpReg::P2, TEXT_TYPE)},\n    {\"Or\", QueryPlanner::Opcode(OpReg::P3, INTEGER_TYPE)},\n    {\"And\", QueryPlanner::Opcode(OpReg::P3, INTEGER_TYPE)},\n\n    // Arithmetic yields a BIGINT for safety.\n    Arithmetic(\"BitAnd\"),\n    Arithmetic(\"BitOr\"),\n    Arithmetic(\"ShiftLeft\"),\n    Arithmetic(\"ShiftRight\"),\n    Arithmetic(\"Add\"),\n    Arithmetic(\"Subtract\"),\n    Arithmetic(\"Multiply\"),\n    Arithmetic(\"Divide\"),\n    Arithmetic(\"Remainder\"),\n\n    // Comparators result in booleans and are treated as INTEGERs.\n    OpComparator(\"Not\"),\n    OpComparator(\"IsNull\"),\n    OpComparator(\"NotNull\"),\n    OpComparator(\"Ne\"),\n    OpComparator(\"Eq\"),\n    OpComparator(\"Gt\"),\n    OpComparator(\"Le\"),\n    OpComparator(\"Lt\"),\n    OpComparator(\"Ge\"),\n    OpComparator(\"IfNeg\"),\n    OpComparator(\"IfNotZero\"),\n};\n\nRecursiveMutex SQLiteDBInstance::kPrimaryAttachMutex;\n\n/// The SQLiteSQLPlugin implements the \"sql\" registry for internal/core.\nclass SQLiteSQLPlugin : public SQLPlugin {\n public:\n  /// Execute SQL and store results.\n  Status query(const std::string& query,\n               QueryData& results,\n               bool use_cache) const override;\n\n  /// Introspect, explain, the suspected types selected in an SQL statement.\n  Status getQueryColumns(const std::string& query,\n                         TableColumns& columns) const override;\n\n  /// Similar to getQueryColumns but return the scanned tables.\n  Status getQueryTables(const std::string& query,\n                        std::vector<std::string>& tables) const override;\n\n  /// Create a SQLite module and attach (CREATE).\n  Status attach(const std::string& name) override;\n\n  /// Detach a virtual table (DROP).\n  Status detach(const std::string& name) override;\n};\n\n/// SQL provider for osquery internal/core.\nREGISTER_INTERNAL(SQLiteSQLPlugin, \"sql\", \"sql\");\n\nstd::string getStringForSQLiteReturnCode(int code) {\n  if (kSQLiteReturnCodes.find(code) != kSQLiteReturnCodes.end()) {\n    return kSQLiteReturnCodes.at(code);\n  } else {\n    std::ostringstream s;\n    s << \"Error: \" << code << \" is not a valid SQLite result code\";\n    return s.str();\n  }\n}\n\nStatus SQLiteSQLPlugin::query(const std::string& query,\n                              QueryData& results,\n                              bool use_cache) const {\n  auto dbc = SQLiteDBManager::get();\n  dbc->useCache(use_cache);\n  auto result = queryInternal(query, results, dbc);\n  dbc->clearAffectedTables();\n  return result;\n}\n\nStatus SQLiteSQLPlugin::getQueryColumns(const std::string& query,\n                                        TableColumns& columns) const {\n  auto dbc = SQLiteDBManager::get();\n  return getQueryColumnsInternal(query, columns, dbc);\n}\n\nStatus SQLiteSQLPlugin::getQueryTables(const std::string& query,\n                                       std::vector<std::string>& tables) const {\n  auto dbc = SQLiteDBManager::get();\n  QueryPlanner planner(query, dbc);\n  tables = planner.tables();\n  return Status(0);\n}\n\nSQLInternal::SQLInternal(const std::string& query, bool use_cache) {\n  auto dbc = SQLiteDBManager::get();\n  dbc->useCache(use_cache);\n  status_ = queryInternal(query, resultsTyped_, dbc);\n\n  // One of the advantages of using SQLInternal (aside from the Registry-bypass)\n  // is the ability to \"deep-inspect\" the table attributes and actions.\n  event_based_ = (dbc->getAttributes() & TableAttributes::EVENT_BASED) != 0;\n\n  dbc->clearAffectedTables();\n}\n\nQueryDataTyped& SQLInternal::rowsTyped() {\n  return resultsTyped_;\n}\n\nconst Status& SQLInternal::getStatus() const {\n  return status_;\n}\n\nbool SQLInternal::eventBased() const {\n  return event_based_;\n}\n\n// Temporary:  I'm going to move this from sql.cpp to here in change immediately\n// following since this is the only place we actually use it (breaking up to\n// make CRs smaller)\nextern void escapeNonPrintableBytesEx(std::string& str);\n\nclass StringEscaperVisitor : public boost::static_visitor<> {\n public:\n  void operator()(long long& i) const { // NO-OP\n  }\n\n  void operator()(double& d) const { // NO-OP\n  }\n\n  void operator()(std::string& str) const {\n    escapeNonPrintableBytesEx(str);\n  }\n};\n\nvoid SQLInternal::escapeResults() {\n  StringEscaperVisitor visitor;\n  for (auto& rowTyped : resultsTyped_) {\n    for (auto& column : rowTyped) {\n      boost::apply_visitor(visitor, column.second);\n    }\n  }\n}\n\nStatus SQLiteSQLPlugin::attach(const std::string& name) {\n  PluginResponse response;\n  auto status =\n      Registry::call(\"table\", name, {{\"action\", \"columns\"}}, response);\n  if (!status.ok()) {\n    return status;\n  }\n\n  bool is_extension = true;\n  auto statement = columnDefinition(response, false, is_extension);\n\n  // Attach requests occurring via the plugin/registry APIs must act on the\n  // primary database. To allow this, getConnection can explicitly request the\n  // primary instance and avoid the contention decisions.\n  auto dbc = SQLiteDBManager::getConnection(true);\n\n  // Attach as an extension, allowing read/write tables\n  return attachTableInternal(name, statement, dbc, is_extension);\n}\n\nStatus SQLiteSQLPlugin::detach(const std::string& name) {\n  // Detach requests occurring via the plugin/registry APIs must act on the\n  // primary database. To allow this, getConnection can explicitly request the\n  // primary instance and avoid the contention decisions.\n  auto dbc = SQLiteDBManager::getConnection(true);\n  return detachTableInternal(name, dbc);\n}\n\nSQLiteDBInstance::SQLiteDBInstance(sqlite3*& db, Mutex& mtx)\n    : db_(db), lock_(mtx, boost::try_to_lock) {\n  if (lock_.owns_lock()) {\n    primary_ = true;\n  } else {\n    db_ = nullptr;\n    VLOG(1) << \"DBManager contention: opening transient SQLite database\";\n    init();\n  }\n}\n\nstatic inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\":memory:\", &db);\n\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"PRAGMA \" + setting.first + \"=\" + setting.second + \"; \";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n\n  // Register function extensions.\n  registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n}\n\nvoid SQLiteDBInstance::init() {\n  primary_ = false;\n  openOptimized(db_);\n}\n\nvoid SQLiteDBInstance::useCache(bool use_cache) {\n  use_cache_ = use_cache;\n}\n\nbool SQLiteDBInstance::useCache() const {\n  return use_cache_;\n}\n\nRecursiveLock SQLiteDBInstance::attachLock() const {\n  if (isPrimary()) {\n    return RecursiveLock(kPrimaryAttachMutex);\n  }\n  return RecursiveLock(attach_mutex_);\n}\n\nvoid SQLiteDBInstance::addAffectedTable(\n    std::shared_ptr<VirtualTableContent> table) {\n  // An xFilter/scan was requested for this virtual table.\n  affected_tables_.insert(std::make_pair(table->name, std::move(table)));\n}\n\nbool SQLiteDBInstance::tableCalled(VirtualTableContent const& table) {\n  return (affected_tables_.count(table.name) > 0);\n}\n\nTableAttributes SQLiteDBInstance::getAttributes() const {\n  const SQLiteDBInstance* rdbc = this;\n  if (isPrimary() && !managed_) {\n    // Similarly to clearAffectedTables, the connection may be forwarded.\n    rdbc = SQLiteDBManager::getConnection(true).get();\n  }\n\n  TableAttributes attributes = TableAttributes::NONE;\n  for (const auto& table : rdbc->affected_tables_) {\n    attributes = table.second->attributes | attributes;\n  }\n  return attributes;\n}\n\nvoid SQLiteDBInstance::clearAffectedTables() {\n  if (isPrimary() && !managed_) {\n    // A primary instance must forward clear requests to the DB manager's\n    // 'connection' instance. This is a temporary primary instance.\n    SQLiteDBManager::getConnection(true)->clearAffectedTables();\n    return;\n  }\n\n  for (const auto& table : affected_tables_) {\n    table.second->constraints.clear();\n    table.second->cache.clear();\n    table.second->colsUsed.clear();\n    table.second->colsUsedBitsets.clear();\n  }\n  // Since the affected tables are cleared, there are no more affected tables.\n  // There is no concept of compounding tables between queries.\n  affected_tables_.clear();\n  use_cache_ = false;\n}\n\nSQLiteDBInstance::~SQLiteDBInstance() {\n  if (!isPrimary() && db_ != nullptr) {\n    sqlite3_close(db_);\n  } else {\n    db_ = nullptr;\n  }\n}\n\nSQLiteDBManager::SQLiteDBManager() : db_(nullptr) {\n  sqlite3_soft_heap_limit64(1);\n  setDisabledTables(Flag::getValue(\"disable_tables\"));\n  setEnabledTables(Flag::getValue(\"enable_tables\"));\n}\n\nbool SQLiteDBManager::isDisabled(const std::string& table_name) {\n  bool disabled_set = !Flag::isDefault(\"disable_tables\");\n  bool enabled_set = !Flag::isDefault(\"enable_tables\");\n  if (!disabled_set && !enabled_set) {\n    // We have zero enabled tables and zero disabled tables.\n    // As a result, no tables are disabled.\n    return false;\n  }\n  const auto& element_disabled = instance().disabled_tables_.find(table_name);\n  const auto& element_enabled = instance().enabled_tables_.find(table_name);\n  bool table_disabled = (element_disabled != instance().disabled_tables_.end());\n  bool table_enabled = (element_enabled != instance().enabled_tables_.end());\n\n  if (table_disabled) {\n    return true;\n  }\n\n  if (table_enabled && disabled_set && !table_disabled) {\n    return false;\n  }\n\n  if (table_enabled && !disabled_set) {\n    return false;\n  }\n\n  if (enabled_set && !table_enabled) {\n    return true;\n  }\n\n  if (disabled_set && !table_disabled) {\n    return false;\n  }\n\n  return true;\n}\n\nvoid SQLiteDBManager::resetPrimary() {\n  auto& self = instance();\n\n  WriteLock connection_lock(self.mutex_);\n  self.connection_.reset();\n\n  {\n    WriteLock create_lock(self.create_mutex_);\n    sqlite3_close(self.db_);\n    self.db_ = nullptr;\n  }\n}\n\nvoid SQLiteDBManager::setDisabledTables(const std::string& list) {\n  const auto& tables = split(list, \",\");\n  disabled_tables_ =\n      std::unordered_set<std::string>(tables.begin(), tables.end());\n}\n\nvoid SQLiteDBManager::setEnabledTables(const std::string& list) {\n  const auto& tables = split(list, \",\");\n  enabled_tables_ =\n      std::unordered_set<std::string>(tables.begin(), tables.end());\n}\n\nSQLiteDBInstanceRef SQLiteDBManager::getUnique() {\n  auto instance = std::make_shared<SQLiteDBInstance>();\n  attachVirtualTables(instance);\n  return instance;\n}\n\nSQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n\n  if (self.db_ == nullptr) {\n    // Create primary SQLite DB instance.\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n\n  // Internal usage may request the primary connection explicitly.\n  if (primary) {\n    return self.connection_;\n  }\n\n  // Create a 'database connection' for the managed database instance.\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}\n\nSQLiteDBManager::~SQLiteDBManager() {\n  connection_ = nullptr;\n  if (db_ != nullptr) {\n    sqlite3_close(db_);\n    db_ = nullptr;\n  }\n}\n\nQueryPlanner::QueryPlanner(const std::string& query,\n                           const SQLiteDBInstanceRef& instance) {\n  QueryData plan;\n  queryInternal(\"EXPLAIN QUERY PLAN \" + query, plan, instance);\n  queryInternal(\"EXPLAIN \" + query, program_, instance);\n\n  for (const auto& row : plan) {\n    auto details = osquery::split(row.at(\"detail\"));\n    if (details.size() > 2 && details[0] == \"SCAN\") {\n      tables_.push_back(details[2]);\n    }\n  }\n}\n\nStatus QueryPlanner::applyTypes(TableColumns& columns) {\n  std::map<size_t, ColumnType> column_types;\n  for (const auto& row : program_) {\n    if (row.at(\"opcode\") == \"ResultRow\") {\n      // The column parsing is finished.\n      auto k = boost::lexical_cast<size_t>(row.at(\"p1\"));\n      for (const auto& type : column_types) {\n        if (type.first - k < columns.size()) {\n          std::get<1>(columns[type.first - k]) = type.second;\n        }\n      }\n    }\n\n    if (row.at(\"opcode\") == \"Copy\") {\n      // Copy P1 -> P1 + P3 into P2 -> P2 + P3.\n      auto from = boost::lexical_cast<size_t>(row.at(\"p1\"));\n      auto to = boost::lexical_cast<size_t>(row.at(\"p2\"));\n      auto size = boost::lexical_cast<size_t>(row.at(\"p3\"));\n      for (size_t i = 0; i <= size; i++) {\n        if (column_types.count(from + i)) {\n          column_types[to + i] = std::move(column_types[from + i]);\n          column_types.erase(from + i);\n        }\n      }\n    } else if (row.at(\"opcode\") == \"Cast\") {\n      auto value = boost::lexical_cast<size_t>(row.at(\"p1\"));\n      auto to = boost::lexical_cast<size_t>(row.at(\"p2\"));\n      switch (to) {\n      case 'A': // BLOB\n        column_types[value] = BLOB_TYPE;\n        break;\n      case 'B': // TEXT\n        column_types[value] = TEXT_TYPE;\n        break;\n      case 'C': // NUMERIC\n        // We don't exactly have an equivalent to NUMERIC (which includes such\n        // things as DATETIME and DECIMAL\n        column_types[value] = UNKNOWN_TYPE;\n        break;\n      case 'D': // INTEGER\n        column_types[value] = BIGINT_TYPE;\n        break;\n      case 'E': // REAL\n        column_types[value] = DOUBLE_TYPE;\n        break;\n      default:\n        column_types[value] = UNKNOWN_TYPE;\n        break;\n      }\n    }\n\n    if (kSQLOpcodes.count(row.at(\"opcode\"))) {\n      const auto& op = kSQLOpcodes.at(row.at(\"opcode\"));\n      auto k = boost::lexical_cast<size_t>(row.at(Opcode::regString(op.reg)));\n      column_types[k] = op.type;\n    }\n  }\n\n  return Status(0);\n}\n\n// Wrapper for legacy method until all uses can be replaced\nStatus queryInternal(const std::string& query,\n                     QueryData& results,\n                     const SQLiteDBInstanceRef& instance) {\n  QueryDataTyped typedResults;\n  Status status = queryInternal(query, typedResults, instance);\n  if (status.ok()) {\n    results.reserve(typedResults.size());\n    for (const auto& row : typedResults) {\n      Row r;\n      for (const auto& col : row) {\n        r[col.first] = castVariant(col.second);\n      }\n      results.push_back(std::move(r));\n    }\n  }\n  return status;\n}\n\nStatus readRows(sqlite3_stmt* prepared_statement,\n                QueryDataTyped& results,\n                const SQLiteDBInstanceRef& instance) {\n  // Do nothing with a null prepared_statement (eg, if the sql was just\n  // whitespace)\n  if (prepared_statement == nullptr) {\n    return Status::success();\n  }\n  int rc = sqlite3_step(prepared_statement);\n  /* if we have a result set row... */\n  if (SQLITE_ROW == rc) {\n    // First collect the column names\n    int num_columns = sqlite3_column_count(prepared_statement);\n    std::vector<std::string> colNames;\n    colNames.reserve(num_columns);\n    for (int i = 0; i < num_columns; i++) {\n      colNames.push_back(sqlite3_column_name(prepared_statement, i));\n    }\n\n    do {\n      RowTyped row;\n      for (int i = 0; i < num_columns; i++) {\n        switch (sqlite3_column_type(prepared_statement, i)) {\n        case SQLITE_INTEGER:\n          row[colNames[i]] = static_cast<long long>(\n              sqlite3_column_int64(prepared_statement, i));\n          break;\n        case SQLITE_FLOAT:\n          row[colNames[i]] = sqlite3_column_double(prepared_statement, i);\n          break;\n        case SQLITE_NULL:\n          row[colNames[i]] = FLAGS_nullvalue;\n          break;\n        default:\n          // Everything else (SQLITE_TEXT, SQLITE3_TEXT, SQLITE_BLOB) is\n          // obtained/conveyed as text/string\n          row[colNames[i]] = std::string(reinterpret_cast<const char*>(\n              sqlite3_column_text(prepared_statement, i)));\n        }\n      }\n      results.push_back(std::move(row));\n      rc = sqlite3_step(prepared_statement);\n    } while (SQLITE_ROW == rc);\n  }\n  if (rc != SQLITE_DONE) {\n    auto s = Status::failure(sqlite3_errmsg(instance->db()));\n    sqlite3_finalize(prepared_statement);\n    return s;\n  }\n\n  rc = sqlite3_finalize(prepared_statement);\n  if (rc != SQLITE_OK) {\n    return Status::failure(sqlite3_errmsg(instance->db()));\n  }\n\n  return Status::success();\n}\n\nStatus queryInternal(const std::string& query,\n                     QueryDataTyped& results,\n                     const SQLiteDBInstanceRef& instance) {\n  sqlite3_stmt* prepared_statement{nullptr}; /* Statement to execute. */\n\n  int rc = SQLITE_OK; /* Return Code */\n  const char* leftover_sql = nullptr; /* Tail of unprocessed SQL */\n  const char* sql = query.c_str(); /* SQL to be processed */\n\n  /* The big while loop.  One iteration per statement */\n  while ((sql[0] != '\\0') && (SQLITE_OK == rc)) {\n    const auto lock = instance->attachLock();\n\n    // Trim leading whitespace\n    while (isspace(sql[0])) {\n      sql++;\n    }\n    rc = sqlite3_prepare_v2(\n        instance->db(), sql, -1, &prepared_statement, &leftover_sql);\n    if (rc != SQLITE_OK) {\n      Status s = Status::failure(sqlite3_errmsg(instance->db()));\n      sqlite3_finalize(prepared_statement);\n      return s;\n    }\n\n    Status s = readRows(prepared_statement, results, instance);\n    if (!s.ok()) {\n      return s;\n    }\n\n    sql = leftover_sql;\n  } /* end while */\n  sqlite3_db_release_memory(instance->db());\n  return Status::success();\n}\n\nStatus getQueryColumnsInternal(const std::string& q,\n                               TableColumns& columns,\n                               const SQLiteDBInstanceRef& instance) {\n  Status status = Status();\n  TableColumns results;\n  {\n    auto lock = instance->attachLock();\n\n    // Turn the query into a prepared statement\n    sqlite3_stmt* stmt{nullptr};\n    auto rc = sqlite3_prepare_v2(instance->db(),\n                                 q.c_str(),\n                                 static_cast<int>(q.length() + 1),\n                                 &stmt,\n                                 nullptr);\n    if (rc != SQLITE_OK || stmt == nullptr) {\n      auto s = Status::failure(sqlite3_errmsg(instance->db()));\n      if (stmt != nullptr) {\n        sqlite3_finalize(stmt);\n      }\n      return s;\n    }\n\n    // Get column count\n    auto num_columns = sqlite3_column_count(stmt);\n    results.reserve(num_columns);\n\n    // Get column names and types\n    bool unknown_type = false;\n    for (int i = 0; i < num_columns; ++i) {\n      auto col_name = sqlite3_column_name(stmt, i);\n      auto col_type = sqlite3_column_decltype(stmt, i);\n\n      if (col_name == nullptr) {\n        status = Status(1, \"Could not get column type\");\n        break;\n      }\n\n      if (col_type == nullptr) {\n        // Types are only returned for table columns (not expressions).\n        col_type = \"UNKNOWN\";\n        unknown_type = true;\n      }\n      results.push_back(std::make_tuple(\n          col_name, columnTypeName(col_type), ColumnOptions::DEFAULT));\n    }\n\n    // An unknown type means we have to parse the plan and SQLite opcodes.\n    if (unknown_type) {\n      QueryPlanner planner(q, instance);\n      planner.applyTypes(results);\n    }\n    sqlite3_finalize(stmt);\n  }\n\n  if (status.ok()) {\n    columns = std::move(results);\n  }\n\n  return status;\n}\n} // namespace osquery\n", "/**\n * Copyright (c) 2014-present, The osquery authors\n *\n * This source code is licensed as defined by the LICENSE file found in the\n * root directory of this source tree.\n *\n * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)\n */\n\n#pragma once\n\n#include <atomic>\n#include <map>\n#include <mutex>\n#include <unordered_set>\n\n#include <sqlite3.h>\n\n#include <boost/filesystem.hpp>\n#include <boost/noncopyable.hpp>\n\n#include <osquery/sql/sql.h>\n\n#include <osquery/utils/mutex.h>\n\n#include <gtest/gtest_prod.h>\n\n#define SQLITE_SOFT_HEAP_LIMIT (5 * 1024 * 1024)\n\nnamespace osquery {\n\nclass SQLiteDBManager;\n\n/**\n * @brief An RAII wrapper around an `sqlite3` object.\n *\n * The SQLiteDBInstance is also \"smart\" in that it may unlock access to a\n * managed `sqlite3` resource. If there's no contention then only a single\n * database is needed during the life of an osquery tool.\n *\n * If there is resource contention (multiple threads want access to the SQLite\n * abstraction layer), then the SQLiteDBManager will provide a transient\n * SQLiteDBInstance.\n */\nclass SQLiteDBInstance : private boost::noncopyable {\n public:\n  SQLiteDBInstance() {\n    init();\n  }\n  SQLiteDBInstance(sqlite3*& db, Mutex& mtx);\n  ~SQLiteDBInstance();\n\n  /// Check if the instance is the osquery primary.\n  bool isPrimary() const {\n    return primary_;\n  }\n\n  /// Generate a new 'transient' connection.\n  void init();\n\n  /**\n   * @brief Accessor to the internal `sqlite3` object, do not store references\n   * to the object within osquery code.\n   */\n  sqlite3* db() const {\n    return db_;\n  }\n\n  /// Allow a virtual table implementation to record use/access of a table.\n  void addAffectedTable(std::shared_ptr<VirtualTableContent> table);\n\n  /// Clear per-query state of a table affected by the use of this instance.\n  void clearAffectedTables();\n\n  /// Check if a virtual table had been called already.\n  bool tableCalled(VirtualTableContent const& table);\n\n  /// Request that virtual tables use a warm cache for their results.\n  void useCache(bool use_cache);\n\n  /// Check if the query requested use of the warm query cache.\n  bool useCache() const;\n\n  /// Lock the database for attaching virtual tables.\n  RecursiveLock attachLock() const;\n\n private:\n  /// Handle the primary/forwarding requests for table attribute accesses.\n  TableAttributes getAttributes() const;\n\n private:\n  /// An opaque constructor only used by the DBManager.\n  explicit SQLiteDBInstance(sqlite3* db)\n      : primary_(true), managed_(true), db_(db) {}\n\n private:\n  /// Introspection into the database pointer, primary means managed.\n  bool primary_{false};\n\n  /// Track whether this instance is managed internally by the DB manager.\n  bool managed_{false};\n\n  /// True if this query should bypass table cache.\n  bool use_cache_{false};\n\n  /// Either the managed primary database or an ephemeral instance.\n  sqlite3* db_{nullptr};\n\n  /**\n   * @brief An attempted unique lock on the manager's primary database mutex.\n   *\n   * This lock is not always acquired. If it is then this instance has locked\n   * access to the 'primary' SQLite database.\n   */\n  WriteLock lock_;\n\n  /**\n   * @brief A mutex protecting access to this instance's SQLite database.\n   *\n   * Attaching, and other access, can occur async from the registry APIs.\n   *\n   * If a database is primary then the static attach mutex is used.\n   */\n  mutable RecursiveMutex attach_mutex_;\n\n  /// See attach_mutex_ but used for the primary database.\n  static RecursiveMutex kPrimaryAttachMutex;\n\n  /// Vector of tables that need their constraints cleared after execution.\n  std::map<std::string, std::shared_ptr<VirtualTableContent>> affected_tables_;\n\n private:\n  friend class SQLiteDBManager;\n  friend class SQLInternal;\n\n private:\n  FRIEND_TEST(SQLiteUtilTests, test_affected_tables);\n};\n\nusing SQLiteDBInstanceRef = std::shared_ptr<SQLiteDBInstance>;\n\n/**\n * @brief osquery internal SQLite DB abstraction resource management.\n *\n * The SQLiteDBManager should be the ONLY method for accessing SQLite resources.\n * The manager provides an abstraction to manage internal SQLite memory and\n * resources as well as provide optimization around resource access.\n */\nclass SQLiteDBManager : private boost::noncopyable {\n public:\n  static SQLiteDBManager& instance() {\n    static SQLiteDBManager instance;\n    return instance;\n  }\n\n  /**\n   * @brief Return a fully configured `sqlite3` database object wrapper.\n   *\n   * An osquery database is basically just a SQLite3 database with several\n   * virtual tables attached. This method is the main abstraction for accessing\n   * SQLite3 databases within osquery.\n   *\n   * A RAII wrapper around the `sqlite3` database will manage attaching tables\n   * and freeing resources when the instance (connection per-say) goes out of\n   * scope. Using the SQLiteDBManager will also try to optimize the number of\n   * `sqlite3` databases in use by managing a single global instance and\n   * returning resource-safe transient databases if there's access contention.\n   *\n   * Note: osquery::initOsquery must be called before calling `get` in order\n   * for virtual tables to be registered.\n   *\n   * @return a SQLiteDBInstance with all virtual tables attached.\n   */\n  static SQLiteDBInstanceRef get() {\n    return getConnection();\n  }\n\n  /// See `get` but always return a transient DB connection (for testing).\n  static SQLiteDBInstanceRef getUnique();\n\n  /**\n   * @brief Reset the primary database connection.\n   *\n   * Over time it may be helpful to remove SQLite's arena.\n   * We can periodically close and re-initialize and connect virtual tables.\n   */\n  static void resetPrimary();\n\n  /**\n   * @brief Check if `table_name` is disabled.\n   *\n   * `table_name` is disabled if it's in the list of tables passed in to the\n   * `--disable_tables` flag or if the `--enable_tables` flag is set and\n   * `table_name` is not specified.\n   *\n   * @param The name of the Table to check.\n   * @return If `table_name` is disabled.\n   */\n  static bool isDisabled(const std::string& table_name);\n\n protected:\n  SQLiteDBManager();\n  virtual ~SQLiteDBManager();\n\n public:\n  SQLiteDBManager(SQLiteDBManager const&) = delete;\n  SQLiteDBManager& operator=(SQLiteDBManager const&) = delete;\n\n private:\n  /// Primary (managed) sqlite3 database.\n  sqlite3* db_{nullptr};\n\n  /// The primary connection maintains an opaque instance.\n  SQLiteDBInstanceRef connection_{nullptr};\n\n  /// Mutex and lock around sqlite3 access.\n  Mutex mutex_;\n\n  /// A write mutex for initializing the primary database.\n  Mutex create_mutex_;\n\n  /// Member variable to hold set of disabled tables.\n  std::unordered_set<std::string> disabled_tables_;\n\n  /// Member variable to hold set of enabled tables.\n  std::unordered_set<std::string> enabled_tables_;\n\n  /// Parse a comma-delimited set of tables names, passed in as a flag.\n  void setDisabledTables(const std::string& s);\n\n  /// Parse a comma-delimited set of tables names, passed in as a flag.\n  void setEnabledTables(const std::string& s);\n\n  /// Request a connection, optionally request the primary connection.\n  static SQLiteDBInstanceRef getConnection(bool primary = false);\n\n private:\n  friend class SQLiteDBInstance;\n  friend class SQLiteSQLPlugin;\n};\n\n/**\n * @brief A barebones query planner based on SQLite explain statement results.\n *\n * The query planner issues two EXPLAIN queries to the internal SQLite instance\n * to determine a table scan plan and execution program.\n *\n * It is mildly expensive to run a query planner since most data is TEXT type\n * and requires string tokenization and lexical casting. Only run a planner\n * once per new query and only when needed (aka an unusable expression).\n */\nclass QueryPlanner : private boost::noncopyable {\n public:\n  explicit QueryPlanner(const std::string& query)\n      : QueryPlanner(query, SQLiteDBManager::get()) {}\n  QueryPlanner(const std::string& query, const SQLiteDBInstanceRef& instance);\n  ~QueryPlanner() {}\n\n public:\n  /**\n   * @brief Scan the plan and program for opcodes that infer types.\n   *\n   * This allows column type inference based on column expressions. The query\n   * column introspection may use a QueryPlanner to apply types to the unknown\n   * columns (which are usually expressions).\n   *\n   * @param column an ordered set of columns to fill in type information.\n   * @return success if all columns types were found, otherwise false.\n   */\n  Status applyTypes(TableColumns& columns);\n\n  /// Get the list of tables filtered by this query.\n  std::vector<std::string> tables() const {\n    return tables_;\n  }\n\n  /**\n   * @brief A helper structure to represent an opcode's result and type.\n   *\n   * An opcode can be defined by a register and type, for the sake of the\n   * only known use case of resultant type determination.\n   */\n  struct Opcode {\n    enum Register {\n      P1 = 0,\n      P2,\n      P3,\n    };\n\n    Register reg;\n    ColumnType type;\n\n   public:\n    Opcode(Register r, ColumnType t) : reg(r), type(t) {}\n\n    /// Return a register as its column string name.\n    static std::string regString(Register r) {\n      static std::vector<std::string> regs = {\"p1\", \"p2\", \"p3\"};\n      return regs[r];\n    }\n  };\n\n private:\n  /// The results of EXPLAIN q.\n  QueryData program_;\n  /// The order of tables scanned.\n  std::vector<std::string> tables_;\n};\n\n/// Specific SQLite opcodes that change column/expression type.\nextern const std::map<std::string, QueryPlanner::Opcode> kSQLOpcodes;\n\n/**\n * @brief SQLite Internal: Execute a query on a specific database\n *\n * If you need to use a different database, other than the osquery default,\n * use this method and pass along a pointer to a SQLite3 database. This is\n * useful for testing.\n *\n * @param q the query to execute\n * @param results The QueryDataTyped vector to emit rows on query success.\n * @param db the SQLite3 database to execute query q against\n *\n * @return A status indicating SQL query results.\n */\nStatus queryInternal(const std::string& q,\n                     QueryDataTyped& results,\n                     const SQLiteDBInstanceRef& instance);\n\n/**\n * @brief SQLite Internal: Execute a query on a specific database\n *\n * If you need to use a different database, other than the osquery default,\n * use this method and pass along a pointer to a SQLite3 database. This is\n * useful for testing.\n *\n * @param q the query to execute\n * @param results The QueryData struct to emit row on query success.\n * @param db the SQLite3 database to execute query q against\n *\n * @return A status indicating SQL query results.\n */\nStatus queryInternal(const std::string& q,\n                     QueryData& results,\n                     const SQLiteDBInstanceRef& instance);\n\n/**\n * @brief SQLite Intern: Analyze a query, providing information about the\n * result columns\n *\n * This function asks SQLite to determine what the names and types are of the\n * result columns of the provided query. Only table columns (not expressions or\n * subqueries) can have their types determined. Types that are not determined\n * are indicated with the string \"UNKNOWN\".\n *\n * @param q the query to analyze\n * @param columns the vector to fill with column information\n * @param db the SQLite3 database to perform the analysis on\n *\n * @return status indicating success or failure of the operation\n */\nStatus getQueryColumnsInternal(const std::string& q,\n                               TableColumns& columns,\n                               const SQLiteDBInstanceRef& instance);\n\n/**\n * @brief SQLInternal: like SQL, but backed by internal calls, and deals\n * with QueryDataTyped results.\n */\nclass SQLInternal : private only_movable {\n public:\n  /**\n   * @brief Instantiate an instance of the class with an internal query.\n   *\n   * @param query An osquery SQL query.\n   * @param use_cache [optional] Set true to use the query cache.\n   */\n  explicit SQLInternal(const std::string& query, bool use_cache = false);\n\n public:\n  /**\n   * @brief Const accessor for the rows returned by the query.\n   *\n   * @return A QueryDataTyped object of the query results.\n   */\n  QueryDataTyped& rowsTyped();\n\n  const Status& getStatus() const;\n\n  /**\n   * @brief Check if the SQL query's results use event-based tables.\n   *\n   * Higher level SQL facilities, like the scheduler, may act differently when\n   * the results of a query (including a JOIN) are event-based. For example,\n   * it does not make sense to perform set difference checks for an\n   * always-append result set.\n   *\n   * All the tables used in the query will be checked. The TableAttributes of\n   * each will be ORed and if any include EVENT_BASED, this will return true.\n   */\n  bool eventBased() const;\n\n  /// ASCII escape the results of the query.\n  void escapeResults();\n\n private:\n  /// The internal member which holds the typed results of the query.\n  QueryDataTyped resultsTyped_;\n\n  /// The internal member which holds the status of the query.\n  Status status_;\n  /// Before completing the execution, store a check for EVENT_BASED.\n  bool event_based_{false};\n};\n\n/**\n * @brief Get a string representation of a SQLite return code.\n */\nstd::string getStringForSQLiteReturnCode(int code);\n\n/**\n * @brief Accumulate rows from an SQLite exec into a QueryData struct.\n *\n * The callback for populating a std::vector<Row> set of results. \"argument\"\n * should be a non-const reference to a std::vector<Row>.\n */\nint queryDataCallback(void* argument, int argc, char* argv[], char* column[]);\n\n/**\n * @brief Register math-related 'custom' functions.\n */\nvoid registerMathExtensions(sqlite3* db);\n\n/**\n * @brief Register string-related 'custom' functions.\n */\nvoid registerStringExtensions(sqlite3* db);\n\n/**\n * @brief Register hashing-related 'custom' functions.\n */\nvoid registerHashingExtensions(sqlite3* db);\n\n/**\n * @brief Register osquery operation 'custom' functions.\n */\nvoid registerOperationExtensions(sqlite3* db);\n\n/**\n * @brief Register encoding-related 'custom' functions.\n */\nvoid registerEncodingExtensions(sqlite3* db);\n\n/**\n * @brief Register filesystem-related 'custom' functions.\n */\nvoid registerFilesystemExtensions(sqlite3* db);\n\n/**\n * @brief Generate the data for auto-constructed sqlite tables\n *\n * When auto-constructed sqlite tables are queried, this function\n * generated the resulting QueryData\n *\n * @param sqlite_db Path to the sqlite_db\n * @param sqlite_query The query you want to run against the SQLite database\n * @param columns The columns that you want out of the sqlite query results\n * @param results The TableRows data structure that will hold the returned rows\n */\nStatus genTableRowsForSqliteTable(const boost::filesystem::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking = true);\n\n/**\n * @brief Detect journal_mode of d SQLite database file\n *\n * Returns a Status, if successful contains the journal mode as message\n *\n * @param sqlite_db Path to the sqlite_db\n */\nStatus getSqliteJournalMode(const boost::filesystem::path& sqlite_db);\n} // namespace osquery\n", "/**\n * Copyright (c) 2014-present, The osquery authors\n *\n * This source code is licensed as defined by the LICENSE file found in the\n * root directory of this source tree.\n *\n * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)\n */\n\n#include <osquery/core/core.h>\n#include <osquery/core/flags.h>\n#include <osquery/core/system.h>\n#include <osquery/registry/registry_interface.h>\n#include <osquery/sql/sql.h>\n#include <osquery/sql/sqlite_util.h>\n#include <osquery/sql/tests/sql_test_utils.h>\n#include <osquery/utils/info/platform_type.h>\n\n#include <gtest/gtest.h>\n\n#include <boost/lexical_cast.hpp>\n#include <boost/variant.hpp>\n\nnamespace osquery {\nclass SQLiteUtilTests : public testing::Test {\n public:\n  void SetUp() override {\n    platformSetup();\n    registryAndPluginInit();\n    Flag::updateValue(\"enable_tables\",\n                      \"test_table,time,process_events,osquery_info,file,users,\"\n                      \"curl,fake_table\");\n    Flag::updateValue(\"disable_tables\", \"fake_table\");\n  }\n};\n\nstd::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30) primary key, age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n\n  return dbc;\n}\n\nTEST_F(SQLiteUtilTests, test_zero_as_float_doesnt_convert_to_int) {\n  auto sql = SQL(\"SELECT 0.0 as zero\");\n  EXPECT_TRUE(sql.ok());\n  EXPECT_EQ(sql.rows().size(), 1U);\n  Row r;\n  r[\"zero\"] = \"0.0\";\n  EXPECT_EQ(sql.rows()[0], r);\n}\n\nTEST_F(SQLiteUtilTests, test_precision_is_maintained) {\n  auto sql = SQL(\"SELECT 0.123456789 as high_precision, 0.12 as low_precision\");\n  EXPECT_TRUE(sql.ok());\n  EXPECT_EQ(sql.rows().size(), 1U);\n  Row r;\n  r[\"high_precision\"] = \"0.123456789\";\n  r[\"low_precision\"] = \"0.12\";\n  EXPECT_EQ(sql.rows()[0], r);\n}\n\nTEST_F(SQLiteUtilTests, test_simple_query_execution) {\n  // Access to the internal SQL implementation is only available in core.\n  auto sql = SQL(\"SELECT * FROM time\");\n  EXPECT_TRUE(sql.ok());\n  EXPECT_EQ(sql.rows().size(), 1U);\n}\n\nTEST_F(SQLiteUtilTests, test_sqlite_instance_manager) {\n  auto dbc1 = SQLiteDBManager::get();\n  auto dbc2 = SQLiteDBManager::get();\n  EXPECT_NE(dbc1->db(), dbc2->db());\n  EXPECT_EQ(dbc1->db(), dbc1->db());\n}\n\nTEST_F(SQLiteUtilTests, test_sqlite_instance) {\n  // Don't do this at home kids.\n  // Keep a copy of the internal DB and let the SQLiteDBInstance go oos.\n  auto internal_db = SQLiteDBManager::get()->db();\n  // Compare the internal DB to another request with no SQLiteDBInstances\n  // in scope, meaning the primary will be returned.\n  EXPECT_EQ(internal_db, SQLiteDBManager::get()->db());\n}\n\nTEST_F(SQLiteUtilTests, test_reset) {\n  auto internal_db = SQLiteDBManager::get()->db();\n  ASSERT_NE(nullptr, internal_db);\n\n  sqlite3_exec(internal_db,\n               \"create view test_view as select 'test';\",\n               nullptr,\n               nullptr,\n               nullptr);\n\n  SQLiteDBManager::resetPrimary();\n  auto instance = SQLiteDBManager::get();\n\n  QueryDataTyped results;\n  queryInternal(\"select * from test_view\", results, instance);\n\n  // Assume the internal (primary) database we reset and recreated.\n  EXPECT_EQ(results.size(), 0U);\n}\n\nTEST_F(SQLiteUtilTests, test_direct_query_execution) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(kTestQuery, results, dbc);\n  EXPECT_TRUE(status.ok());\n  EXPECT_EQ(results, getTestDBExpectedResults());\n}\n\nTEST_F(SQLiteUtilTests, test_aggregate_query) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(kTestQuery, results, dbc);\n  EXPECT_TRUE(status.ok());\n  EXPECT_EQ(results, getTestDBExpectedResults());\n}\n\nTEST_F(SQLiteUtilTests, test_no_results_query) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(\n      \"select * from test_table where username=\\\"A_NON_EXISTENT_NAME\\\"\",\n      results,\n      dbc);\n  EXPECT_TRUE(status.ok());\n}\n\nTEST_F(SQLiteUtilTests, test_whitespace_query) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(\"     \", results, dbc);\n  EXPECT_TRUE(status.ok());\n}\n\nTEST_F(SQLiteUtilTests, test_whitespace_then_nonwhitespace_query) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(\"     ; select * from time  \", results, dbc);\n  EXPECT_TRUE(status.ok());\n}\n\nTEST_F(SQLiteUtilTests, test_get_test_db_result_stream) {\n  auto dbc = getTestDBC();\n  auto results = getTestDBResultStream();\n  for (auto r : results) {\n    char* err_char = nullptr;\n    sqlite3_exec(dbc->db(), (r.first).c_str(), nullptr, nullptr, &err_char);\n    EXPECT_TRUE(err_char == nullptr);\n    if (err_char != nullptr) {\n      sqlite3_free(err_char);\n      ASSERT_TRUE(false);\n    }\n\n    QueryDataTyped expected;\n    auto status = queryInternal(kTestQuery, expected, dbc);\n    EXPECT_EQ(expected, r.second);\n  }\n}\n\nTEST_F(SQLiteUtilTests, test_affected_tables) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(\"SELECT * FROM time\", results, dbc);\n\n  // Since the table scanned from \"time\", it should be recorded as affected.\n  EXPECT_EQ(dbc->affected_tables_.count(\"time\"), 1U);\n  dbc->clearAffectedTables();\n  EXPECT_EQ(dbc->affected_tables_.size(), 0U);\n}\n\nTEST_F(SQLiteUtilTests, test_table_attributes_event_based) {\n  {\n    SQLInternal sql_internal(\"select * from process_events\");\n    if (!isPlatform(PlatformType::TYPE_WINDOWS)) {\n      EXPECT_TRUE(sql_internal.getStatus().ok());\n      EXPECT_TRUE(sql_internal.eventBased());\n    }\n  }\n\n  {\n    SQLInternal sql_internal(\"select * from time\");\n    EXPECT_TRUE(sql_internal.getStatus().ok());\n    EXPECT_FALSE(sql_internal.eventBased());\n  }\n}\n\nTEST_F(SQLiteUtilTests, test_get_query_columns) {\n  auto dbc = getTestDBC();\n  TableColumns results;\n\n  std::string query = \"SELECT seconds, version FROM time JOIN osquery_info\";\n  auto status = getQueryColumnsInternal(query, results, dbc);\n  ASSERT_TRUE(status.ok());\n  ASSERT_EQ(2U, results.size());\n  EXPECT_EQ(std::make_tuple(\n                std::string(\"seconds\"), INTEGER_TYPE, ColumnOptions::DEFAULT),\n            results[0]);\n  EXPECT_EQ(std::make_tuple(\n                std::string(\"version\"), TEXT_TYPE, ColumnOptions::DEFAULT),\n            results[1]);\n\n  query = \"SELECT * FROM foo\";\n  status = getQueryColumnsInternal(query, results, dbc);\n  ASSERT_FALSE(status.ok());\n}\n\nTEST_F(SQLiteUtilTests, test_get_query_tables_failed) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  EXPECT_FALSE(queryInternal(\"SELECT * FROM file\", results, dbc).ok());\n}\n\nTEST_F(SQLiteUtilTests, test_get_query_tables) {\n  std::string query =\n      \"SELECT * FROM time, osquery_info, (SELECT * FROM users) ff GROUP BY pid\";\n  std::vector<std::string> tables;\n  auto status = getQueryTables(query, tables);\n  EXPECT_TRUE(status.ok());\n\n  std::vector<std::string> expected = {\"time\", \"osquery_info\", \"users\"};\n  EXPECT_EQ(expected, tables);\n}\n\nTEST_F(SQLiteUtilTests, test_get_query_tables_required) {\n  std::string query =\n      \"SELECT * FROM time, osquery_info, (SELECT * FROM file where path = \"\n      \"'osquery') ff GROUP BY pid\";\n  std::vector<std::string> tables;\n  auto status = getQueryTables(query, tables);\n  EXPECT_TRUE(status.ok());\n\n  std::vector<std::string> expected = {\"time\", \"osquery_info\", \"file\"};\n  EXPECT_EQ(expected, tables);\n}\n\nstd::vector<ColumnType> getTypes(const TableColumns& columns) {\n  std::vector<ColumnType> types;\n  for (const auto& col : columns) {\n    types.push_back(std::get<1>(col));\n  }\n  return types;\n}\n\nTEST_F(SQLiteUtilTests, test_query_planner) {\n  using TypeList = std::vector<ColumnType>;\n\n  auto dbc = getTestDBC();\n  TableColumns columns;\n\n  std::string query = \"select path, path from file\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query = \"select path, path from file where path in ('osquery', 'noquery')\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE, TEXT_TYPE}));\n\n  query = \"select path, seconds from file, time where path LIKE 'osquery'\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE, INTEGER_TYPE}));\n\n  query = \"select path || path from file\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query = \"select path || path from file where path = 'osquery'\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE}));\n\n  query = \"select seconds, path || path from file, time \";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query =\n      \"select seconds, path || path from file, time where path in ('osquery')\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({INTEGER_TYPE, TEXT_TYPE}));\n\n  query = \"select seconds, seconds from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({INTEGER_TYPE, INTEGER_TYPE}));\n\n  query = \"select count(*) from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BIGINT_TYPE}));\n\n  query = \"select count(*), count(seconds), seconds from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns),\n            TypeList({BIGINT_TYPE, BIGINT_TYPE, INTEGER_TYPE}));\n\n  query = \"select 1, 'path', path from file\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query = \"select 1, 'path', path from file where path = 'os'\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({INTEGER_TYPE, TEXT_TYPE, TEXT_TYPE}));\n\n  query = \"select weekday, day, count(*), seconds from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns),\n            TypeList({TEXT_TYPE, INTEGER_TYPE, BIGINT_TYPE, INTEGER_TYPE}));\n\n  query = \"select seconds + 1 from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BIGINT_TYPE}));\n\n  query = \"select seconds * seconds from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BIGINT_TYPE}));\n\n  query = \"select seconds > 1, seconds, count(seconds) from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns),\n            TypeList({INTEGER_TYPE, INTEGER_TYPE, BIGINT_TYPE}));\n\n  query =\n      \"select f1.*, seconds, f2.directory from (select path || path from file) \"\n      \"f1, file as f2, time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query =\n      \"select f1.*, seconds, f2.directory from (select path || path from file) \"\n      \"f1, file as f2, time where path in ('query', 'query')\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query =\n      \"select f1.*, seconds, f2.directory from (select path || path from file \"\n      \"where path = 'query') \"\n      \"f1, file as f2, time where path in ('query', 'query')\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE, INTEGER_TYPE, TEXT_TYPE}));\n\n  query = \"select CAST(seconds AS INTEGER) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BIGINT_TYPE}));\n\n  query = \"select CAST(seconds AS TEXT) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE}));\n\n  query = \"select CAST(seconds AS REAL) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({DOUBLE_TYPE}));\n\n  query = \"select CAST(seconds AS BOOLEAN) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({UNKNOWN_TYPE}));\n\n  query = \"select CAST(seconds AS DATETIME) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({UNKNOWN_TYPE}));\n\n  query = \"select CAST(seconds AS BLOB) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BLOB_TYPE}));\n\n  query = \"select url, round_trip_time, response_code from curl\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query =\n      \"select url, round_trip_time, response_code from curl where url = \"\n      \"'https://github.com/osquery/osquery'\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns),\n            TypeList({TEXT_TYPE, BIGINT_TYPE, INTEGER_TYPE}));\n}\n\nusing TypeMap = std::map<std::string, ColumnType>;\n\n// Using ColumnType enum just labeling in test_column_type_determination)\nclass type_picker_visitor : public boost::static_visitor<ColumnType> {\n public:\n  ColumnType operator()(const long long& i) const {\n    return INTEGER_TYPE;\n  }\n\n  ColumnType operator()(const std::string& str) const {\n    return TEXT_TYPE;\n  }\n\n  ColumnType operator()(const double& d) const {\n    return DOUBLE_TYPE;\n  }\n};\n\nvoid testTypesExpected(std::string query, TypeMap expectedTypes) {\n  auto dbc = getTestDBC();\n  QueryDataTyped typedResults;\n  queryInternal(query, typedResults, dbc);\n  for (const auto& row : typedResults) {\n    for (const auto& col : row) {\n      if (expectedTypes.count(col.first)) {\n        EXPECT_EQ(boost::apply_visitor(type_picker_visitor(), col.second),\n                  expectedTypes[col.first])\n            << \" These are the integer values of actual/expected ColumnType \"\n               \"(resp) of \"\n            << col.first << \" for query: \" << query;\n      } else {\n        FAIL() << \"Found no expected type for \" << col.first\n               << \" in test of column types for query \" << query;\n      }\n    }\n  }\n}\n\nTEST_F(SQLiteUtilTests, test_column_type_determination) {\n  // Correct identification of text and ints\n  testTypesExpected(\"select path, inode from file where path like '%'\",\n                    TypeMap({{\"path\", TEXT_TYPE}, {\"inode\", INTEGER_TYPE}}));\n  // Correctly treating BLOBs as text\n  testTypesExpected(\"select CAST(seconds AS BLOB) as seconds FROM time\",\n                    TypeMap({{\"seconds\", TEXT_TYPE}}));\n  // Correctly treating ints cast as double as doubles\n  testTypesExpected(\"select CAST(seconds AS DOUBLE) as seconds FROM time\",\n                    TypeMap({{\"seconds\", DOUBLE_TYPE}}));\n  // Correctly treating bools as ints\n  testTypesExpected(\"select CAST(seconds AS BOOLEAN) as seconds FROM time\",\n                    TypeMap({{\"seconds\", INTEGER_TYPE}}));\n  // Correctly recognizing values from columns declared double as double, even\n  // if they happen to have integer value.  And also test multi-statement\n  // queries.\n  testTypesExpected(\n      \"CREATE TABLE test_types_table (username varchar(30) primary key, age \"\n      \"double);INSERT INTO test_types_table VALUES (\\\"mike\\\", 23); SELECT age \"\n      \"from test_types_table\",\n      TypeMap({{\"age\", DOUBLE_TYPE}}));\n}\n\nTEST_F(SQLiteUtilTests, test_enable) {\n  // Shadow is not in enable_tables.\n  ASSERT_TRUE(SQLiteDBManager::isDisabled(\"shadow\"));\n  // Users is explicitely in enable_tables.\n  ASSERT_FALSE(SQLiteDBManager::isDisabled(\"users\"));\n  // Fake_table is explicitely in enabled_tables and\n  // disable_tables, it should be disabled.\n  ASSERT_TRUE(SQLiteDBManager::isDisabled(\"fake_table\"));\n}\n\n} // namespace osquery\n", "/**\n * Copyright (c) 2014-present, The osquery authors\n *\n * This source code is licensed as defined by the LICENSE file found in the\n * root directory of this source tree.\n *\n * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)\n */\n\n#include <boost/algorithm/string.hpp>\n\n#include <osquery/core/core.h>\n#include <osquery/filesystem/filesystem.h>\n#include <osquery/logger/logger.h>\n#include <osquery/sql/sql.h>\n\n#include <osquery/utils/info/platform_type.h>\n\n#include \"osquery/sql/dynamic_table_row.h\"\n#include \"osquery/sql/sqlite_util.h\"\n\nnamespace fs = boost::filesystem;\n\nnamespace osquery {\n\nconst char* getSystemVFS(bool respect_locking) {\n  if (respect_locking) {\n    return nullptr;\n  }\n  if (isPlatform(PlatformType::TYPE_POSIX)) {\n    return \"unix-none\";\n  } else if (isPlatform(PlatformType::TYPE_WINDOWS)) {\n    return \"win32-none\";\n  }\n  return nullptr;\n}\n\nStatus genSqliteTableRow(sqlite3_stmt* stmt,\n                         TableRows& qd,\n                         const fs::path& sqlite_db) {\n  auto r = make_table_row();\n  for (int i = 0; i < sqlite3_column_count(stmt); ++i) {\n    auto column_name = std::string(sqlite3_column_name(stmt, i));\n    auto column_type = sqlite3_column_type(stmt, i);\n    switch (column_type) {\n    case SQLITE_BLOB:\n    case SQLITE_TEXT: {\n      auto text_value = sqlite3_column_text(stmt, i);\n      if (text_value != nullptr) {\n        r[column_name] = std::string(reinterpret_cast<const char*>(text_value));\n      }\n      break;\n    }\n    case SQLITE_FLOAT: {\n      auto float_value = sqlite3_column_double(stmt, i);\n      r[column_name] = DOUBLE(float_value);\n      break;\n    }\n    case SQLITE_INTEGER: {\n      auto int_value = sqlite3_column_int64(stmt, i);\n      r[column_name] = INTEGER(int_value);\n      break;\n    }\n    }\n  }\n  if (r.count(\"path\") > 0) {\n    LOG(WARNING) << \"ATC Table: Row contains a defined path key, omitting the \"\n                    \"implicit one\";\n  } else {\n    r[\"path\"] = sqlite_db.string();\n  }\n  qd.push_back(std::move(r));\n  return Status::success();\n}\n\nStatus genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"Database path does not exist\");\n  }\n\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"Cannot open specified database: \"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"Could not open database\");\n  }\n\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"ATC table: Could not prepare database at path: \" << sqlite_db;\n    return Status(rc, \"Could not prepare database\");\n  }\n\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n\n  // Close handles and free memory\n  sqlite3_finalize(stmt);\n  sqlite3_close(db);\n\n  return Status{};\n}\n\nStatus getSqliteJournalMode(const fs::path& sqlite_db) {\n  TableRows result;\n  auto status = genTableRowsForSqliteTable(\n      sqlite_db, \"PRAGMA journal_mode;\", result, true);\n  if (!status.ok()) {\n    return status;\n  }\n  if (result.empty()) {\n    VLOG(1) << \"PRAGMA query returned empty results\";\n    return Status(1, \"Could not retrieve journal mode\");\n  }\n  auto resultmap = static_cast<Row>(*result[0]);\n  if (resultmap.find(\"journal_mode\") == resultmap.end()) {\n    VLOG(1) << \"journal_mode not found PRAGMA query results\";\n    return Status(1, \"Could not retrieve journal mode\");\n  }\n  return Status(Status::kSuccessCode,\n                boost::algorithm::to_lower_copy(resultmap[\"journal_mode\"]));\n}\n\n} // namespace osquery\n"], "fixing_code": ["/**\n * Copyright (c) 2014-present, The osquery authors\n *\n * This source code is licensed as defined by the LICENSE file found in the\n * root directory of this source tree.\n *\n * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)\n */\n\n#include \"osquery/sql/sqlite_util.h\"\n#include \"osquery/sql/virtual_table.h\"\n\n#include <osquery/core/plugins/sql.h>\n\n#include <osquery/utils/conversions/castvariant.h>\n\n#include <osquery/core/core.h>\n#include <osquery/core/flags.h>\n#include <osquery/core/shutdown.h>\n#include <osquery/logger/logger.h>\n#include <osquery/registry/registry_factory.h>\n#include <osquery/sql/sql.h>\n\n#include <osquery/utils/conversions/split.h>\n\n#include <boost/lexical_cast.hpp>\n\nnamespace osquery {\n\nFLAG(string,\n     disable_tables,\n     \"\",\n     \"Comma-delimited list of table names to be disabled\");\n\nFLAG(string,\n     enable_tables,\n     \"\",\n     \"Comma-delimited list of table names to be enabled\");\n\nFLAG(string, nullvalue, \"\", \"Set string for NULL values, default ''\");\n\nusing OpReg = QueryPlanner::Opcode::Register;\n\nusing SQLiteDBInstanceRef = std::shared_ptr<SQLiteDBInstance>;\n\n/**\n * @brief A map of SQLite status codes to their corresponding message string\n *\n * Details of this map are defined at: http://www.sqlite.org/c3ref/c_abort.html\n */\n// clang-format off\nconst std::map<int, std::string> kSQLiteReturnCodes = {\n    {0, \"SQLITE_OK\"},        {1, \"SQLITE_ERROR\"},       {2, \"SQLITE_INTERNAL\"},\n    {3, \"SQLITE_PERM\"},      {4, \"SQLITE_ABORT\"},       {5, \"SQLITE_BUSY\"},\n    {6, \"SQLITE_LOCKED\"},    {7, \"SQLITE_NOMEM\"},       {8, \"SQLITE_READONLY\"},\n    {9, \"SQLITE_INTERRUPT\"}, {10, \"SQLITE_IOERR\"},      {11, \"SQLITE_CORRUPT\"},\n    {12, \"SQLITE_NOTFOUND\"}, {13, \"SQLITE_FULL\"},       {14, \"SQLITE_CANTOPEN\"},\n    {15, \"SQLITE_PROTOCOL\"}, {16, \"SQLITE_EMPTY\"},      {17, \"SQLITE_SCHEMA\"},\n    {18, \"SQLITE_TOOBIG\"},   {19, \"SQLITE_CONSTRAINT\"}, {20, \"SQLITE_MISMATCH\"},\n    {21, \"SQLITE_MISUSE\"},   {22, \"SQLITE_NOLFS\"},      {23, \"SQLITE_AUTH\"},\n    {24, \"SQLITE_FORMAT\"},   {25, \"SQLITE_RANGE\"},      {26, \"SQLITE_NOTADB\"},\n    {27, \"SQLITE_NOTICE\"},   {28, \"SQLITE_WARNING\"},    {100, \"SQLITE_ROW\"},\n    {101, \"SQLITE_DONE\"},\n};\n\nconst std::map<std::string, std::string> kMemoryDBSettings = {\n    {\"synchronous\", \"OFF\"},      {\"count_changes\", \"OFF\"},\n    {\"default_temp_store\", \"0\"}, {\"auto_vacuum\", \"FULL\"},\n    {\"journal_mode\", \"OFF\"},     {\"cache_size\", \"0\"},\n    {\"page_count\", \"0\"},\n};\n// clang-format on\n\n#define OpComparator(x)                                                        \\\n  { x, QueryPlanner::Opcode(OpReg::P2, INTEGER_TYPE) }\n#define Arithmetic(x)                                                          \\\n  { x, QueryPlanner::Opcode(OpReg::P3, BIGINT_TYPE) }\n\n/**\n * @brief A map from opcode to pair of result register and resultant type.\n *\n * For most opcodes we can deduce a column type based on an interred input\n * to the opcode \"function\". These come in a few sets, arithmetic operators,\n * comparators, aggregates, and copies.\n */\nconst std::map<std::string, QueryPlanner::Opcode> kSQLOpcodes = {\n    {\"Concat\", QueryPlanner::Opcode(OpReg::P3, TEXT_TYPE)},\n    {\"AggStep\", QueryPlanner::Opcode(OpReg::P3, BIGINT_TYPE)},\n    {\"AggStep0\", QueryPlanner::Opcode(OpReg::P3, BIGINT_TYPE)},\n    {\"Integer\", QueryPlanner::Opcode(OpReg::P2, INTEGER_TYPE)},\n    {\"Int64\", QueryPlanner::Opcode(OpReg::P2, BIGINT_TYPE)},\n    {\"String\", QueryPlanner::Opcode(OpReg::P2, TEXT_TYPE)},\n    {\"String8\", QueryPlanner::Opcode(OpReg::P2, TEXT_TYPE)},\n    {\"Or\", QueryPlanner::Opcode(OpReg::P3, INTEGER_TYPE)},\n    {\"And\", QueryPlanner::Opcode(OpReg::P3, INTEGER_TYPE)},\n\n    // Arithmetic yields a BIGINT for safety.\n    Arithmetic(\"BitAnd\"),\n    Arithmetic(\"BitOr\"),\n    Arithmetic(\"ShiftLeft\"),\n    Arithmetic(\"ShiftRight\"),\n    Arithmetic(\"Add\"),\n    Arithmetic(\"Subtract\"),\n    Arithmetic(\"Multiply\"),\n    Arithmetic(\"Divide\"),\n    Arithmetic(\"Remainder\"),\n\n    // Comparators result in booleans and are treated as INTEGERs.\n    OpComparator(\"Not\"),\n    OpComparator(\"IsNull\"),\n    OpComparator(\"NotNull\"),\n    OpComparator(\"Ne\"),\n    OpComparator(\"Eq\"),\n    OpComparator(\"Gt\"),\n    OpComparator(\"Le\"),\n    OpComparator(\"Lt\"),\n    OpComparator(\"Ge\"),\n    OpComparator(\"IfNeg\"),\n    OpComparator(\"IfNotZero\"),\n};\n\nRecursiveMutex SQLiteDBInstance::kPrimaryAttachMutex;\n\n/// The SQLiteSQLPlugin implements the \"sql\" registry for internal/core.\nclass SQLiteSQLPlugin : public SQLPlugin {\n public:\n  /// Execute SQL and store results.\n  Status query(const std::string& query,\n               QueryData& results,\n               bool use_cache) const override;\n\n  /// Introspect, explain, the suspected types selected in an SQL statement.\n  Status getQueryColumns(const std::string& query,\n                         TableColumns& columns) const override;\n\n  /// Similar to getQueryColumns but return the scanned tables.\n  Status getQueryTables(const std::string& query,\n                        std::vector<std::string>& tables) const override;\n\n  /// Create a SQLite module and attach (CREATE).\n  Status attach(const std::string& name) override;\n\n  /// Detach a virtual table (DROP).\n  Status detach(const std::string& name) override;\n};\n\n/// SQL provider for osquery internal/core.\nREGISTER_INTERNAL(SQLiteSQLPlugin, \"sql\", \"sql\");\n\nstd::string getStringForSQLiteReturnCode(int code) {\n  if (kSQLiteReturnCodes.find(code) != kSQLiteReturnCodes.end()) {\n    return kSQLiteReturnCodes.at(code);\n  } else {\n    std::ostringstream s;\n    s << \"Error: \" << code << \" is not a valid SQLite result code\";\n    return s.str();\n  }\n}\n\nStatus SQLiteSQLPlugin::query(const std::string& query,\n                              QueryData& results,\n                              bool use_cache) const {\n  auto dbc = SQLiteDBManager::get();\n  dbc->useCache(use_cache);\n  auto result = queryInternal(query, results, dbc);\n  dbc->clearAffectedTables();\n  return result;\n}\n\nStatus SQLiteSQLPlugin::getQueryColumns(const std::string& query,\n                                        TableColumns& columns) const {\n  auto dbc = SQLiteDBManager::get();\n  return getQueryColumnsInternal(query, columns, dbc);\n}\n\nStatus SQLiteSQLPlugin::getQueryTables(const std::string& query,\n                                       std::vector<std::string>& tables) const {\n  auto dbc = SQLiteDBManager::get();\n  QueryPlanner planner(query, dbc);\n  tables = planner.tables();\n  return Status(0);\n}\n\nSQLInternal::SQLInternal(const std::string& query, bool use_cache) {\n  auto dbc = SQLiteDBManager::get();\n  dbc->useCache(use_cache);\n  status_ = queryInternal(query, resultsTyped_, dbc);\n\n  // One of the advantages of using SQLInternal (aside from the Registry-bypass)\n  // is the ability to \"deep-inspect\" the table attributes and actions.\n  event_based_ = (dbc->getAttributes() & TableAttributes::EVENT_BASED) != 0;\n\n  dbc->clearAffectedTables();\n}\n\nQueryDataTyped& SQLInternal::rowsTyped() {\n  return resultsTyped_;\n}\n\nconst Status& SQLInternal::getStatus() const {\n  return status_;\n}\n\nbool SQLInternal::eventBased() const {\n  return event_based_;\n}\n\n// Temporary:  I'm going to move this from sql.cpp to here in change immediately\n// following since this is the only place we actually use it (breaking up to\n// make CRs smaller)\nextern void escapeNonPrintableBytesEx(std::string& str);\n\nclass StringEscaperVisitor : public boost::static_visitor<> {\n public:\n  void operator()(long long& i) const { // NO-OP\n  }\n\n  void operator()(double& d) const { // NO-OP\n  }\n\n  void operator()(std::string& str) const {\n    escapeNonPrintableBytesEx(str);\n  }\n};\n\nvoid SQLInternal::escapeResults() {\n  StringEscaperVisitor visitor;\n  for (auto& rowTyped : resultsTyped_) {\n    for (auto& column : rowTyped) {\n      boost::apply_visitor(visitor, column.second);\n    }\n  }\n}\n\nStatus SQLiteSQLPlugin::attach(const std::string& name) {\n  PluginResponse response;\n  auto status =\n      Registry::call(\"table\", name, {{\"action\", \"columns\"}}, response);\n  if (!status.ok()) {\n    return status;\n  }\n\n  bool is_extension = true;\n  auto statement = columnDefinition(response, false, is_extension);\n\n  // Attach requests occurring via the plugin/registry APIs must act on the\n  // primary database. To allow this, getConnection can explicitly request the\n  // primary instance and avoid the contention decisions.\n  auto dbc = SQLiteDBManager::getConnection(true);\n\n  // Attach as an extension, allowing read/write tables\n  return attachTableInternal(name, statement, dbc, is_extension);\n}\n\nStatus SQLiteSQLPlugin::detach(const std::string& name) {\n  // Detach requests occurring via the plugin/registry APIs must act on the\n  // primary database. To allow this, getConnection can explicitly request the\n  // primary instance and avoid the contention decisions.\n  auto dbc = SQLiteDBManager::getConnection(true);\n  return detachTableInternal(name, dbc);\n}\n\nSQLiteDBInstance::SQLiteDBInstance(sqlite3*& db, Mutex& mtx)\n    : db_(db), lock_(mtx, boost::try_to_lock) {\n  if (lock_.owns_lock()) {\n    primary_ = true;\n  } else {\n    db_ = nullptr;\n    VLOG(1) << \"DBManager contention: opening transient SQLite database\";\n    init();\n  }\n}\n\n// This function is called by SQLite when a statement is prepared and we use\n// it to allowlist specific actions.\nint sqliteAuthorizer(void* userData,\n                     int code,\n                     const char* arg3,\n                     const char* arg4,\n                     const char* arg5,\n                     const char* arg6) {\n  if (kAllowedSQLiteActionCodes.count(code) > 0) {\n    return SQLITE_OK;\n  }\n  LOG(ERROR) << \"Authorizer denied action \" << code << \" \"\n             << (arg3 ? arg3 : \"null\") << \" \" << (arg4 ? arg4 : \"null\") << \" \"\n             << (arg5 ? arg5 : \"null\") << \" \" << (arg6 ? arg6 : \"null\");\n  return SQLITE_DENY;\n}\n\nstatic inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\":memory:\", &db);\n\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"PRAGMA \" + setting.first + \"=\" + setting.second + \"; \";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n\n  // Register function extensions.\n  registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n\n  auto rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    LOG(ERROR) << \"Failed to set sqlite authorizer: \" << sqlite3_errmsg(db);\n    requestShutdown(rc);\n  }\n}\n\nvoid SQLiteDBInstance::init() {\n  primary_ = false;\n  openOptimized(db_);\n}\n\nvoid SQLiteDBInstance::useCache(bool use_cache) {\n  use_cache_ = use_cache;\n}\n\nbool SQLiteDBInstance::useCache() const {\n  return use_cache_;\n}\n\nRecursiveLock SQLiteDBInstance::attachLock() const {\n  if (isPrimary()) {\n    return RecursiveLock(kPrimaryAttachMutex);\n  }\n  return RecursiveLock(attach_mutex_);\n}\n\nvoid SQLiteDBInstance::addAffectedTable(\n    std::shared_ptr<VirtualTableContent> table) {\n  // An xFilter/scan was requested for this virtual table.\n  affected_tables_.insert(std::make_pair(table->name, std::move(table)));\n}\n\nbool SQLiteDBInstance::tableCalled(VirtualTableContent const& table) {\n  return (affected_tables_.count(table.name) > 0);\n}\n\nTableAttributes SQLiteDBInstance::getAttributes() const {\n  const SQLiteDBInstance* rdbc = this;\n  if (isPrimary() && !managed_) {\n    // Similarly to clearAffectedTables, the connection may be forwarded.\n    rdbc = SQLiteDBManager::getConnection(true).get();\n  }\n\n  TableAttributes attributes = TableAttributes::NONE;\n  for (const auto& table : rdbc->affected_tables_) {\n    attributes = table.second->attributes | attributes;\n  }\n  return attributes;\n}\n\nvoid SQLiteDBInstance::clearAffectedTables() {\n  if (isPrimary() && !managed_) {\n    // A primary instance must forward clear requests to the DB manager's\n    // 'connection' instance. This is a temporary primary instance.\n    SQLiteDBManager::getConnection(true)->clearAffectedTables();\n    return;\n  }\n\n  for (const auto& table : affected_tables_) {\n    table.second->constraints.clear();\n    table.second->cache.clear();\n    table.second->colsUsed.clear();\n    table.second->colsUsedBitsets.clear();\n  }\n  // Since the affected tables are cleared, there are no more affected tables.\n  // There is no concept of compounding tables between queries.\n  affected_tables_.clear();\n  use_cache_ = false;\n}\n\nSQLiteDBInstance::~SQLiteDBInstance() {\n  if (!isPrimary() && db_ != nullptr) {\n    sqlite3_close(db_);\n  } else {\n    db_ = nullptr;\n  }\n}\n\nSQLiteDBManager::SQLiteDBManager() : db_(nullptr) {\n  sqlite3_soft_heap_limit64(1);\n  setDisabledTables(Flag::getValue(\"disable_tables\"));\n  setEnabledTables(Flag::getValue(\"enable_tables\"));\n}\n\nbool SQLiteDBManager::isDisabled(const std::string& table_name) {\n  bool disabled_set = !Flag::isDefault(\"disable_tables\");\n  bool enabled_set = !Flag::isDefault(\"enable_tables\");\n  if (!disabled_set && !enabled_set) {\n    // We have zero enabled tables and zero disabled tables.\n    // As a result, no tables are disabled.\n    return false;\n  }\n  const auto& element_disabled = instance().disabled_tables_.find(table_name);\n  const auto& element_enabled = instance().enabled_tables_.find(table_name);\n  bool table_disabled = (element_disabled != instance().disabled_tables_.end());\n  bool table_enabled = (element_enabled != instance().enabled_tables_.end());\n\n  if (table_disabled) {\n    return true;\n  }\n\n  if (table_enabled && disabled_set && !table_disabled) {\n    return false;\n  }\n\n  if (table_enabled && !disabled_set) {\n    return false;\n  }\n\n  if (enabled_set && !table_enabled) {\n    return true;\n  }\n\n  if (disabled_set && !table_disabled) {\n    return false;\n  }\n\n  return true;\n}\n\nvoid SQLiteDBManager::resetPrimary() {\n  auto& self = instance();\n\n  WriteLock connection_lock(self.mutex_);\n  self.connection_.reset();\n\n  {\n    WriteLock create_lock(self.create_mutex_);\n    sqlite3_close(self.db_);\n    self.db_ = nullptr;\n  }\n}\n\nvoid SQLiteDBManager::setDisabledTables(const std::string& list) {\n  const auto& tables = split(list, \",\");\n  disabled_tables_ =\n      std::unordered_set<std::string>(tables.begin(), tables.end());\n}\n\nvoid SQLiteDBManager::setEnabledTables(const std::string& list) {\n  const auto& tables = split(list, \",\");\n  enabled_tables_ =\n      std::unordered_set<std::string>(tables.begin(), tables.end());\n}\n\nSQLiteDBInstanceRef SQLiteDBManager::getUnique() {\n  auto instance = std::make_shared<SQLiteDBInstance>();\n  attachVirtualTables(instance);\n  return instance;\n}\n\nSQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n\n  if (self.db_ == nullptr) {\n    // Create primary SQLite DB instance.\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n\n  // Internal usage may request the primary connection explicitly.\n  if (primary) {\n    return self.connection_;\n  }\n\n  // Create a 'database connection' for the managed database instance.\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n\n  return instance;\n}\n\nSQLiteDBManager::~SQLiteDBManager() {\n  connection_ = nullptr;\n  if (db_ != nullptr) {\n    sqlite3_close(db_);\n    db_ = nullptr;\n  }\n}\n\nQueryPlanner::QueryPlanner(const std::string& query,\n                           const SQLiteDBInstanceRef& instance) {\n  QueryData plan;\n  queryInternal(\"EXPLAIN QUERY PLAN \" + query, plan, instance);\n  queryInternal(\"EXPLAIN \" + query, program_, instance);\n\n  for (const auto& row : plan) {\n    auto details = osquery::split(row.at(\"detail\"));\n    if (details.size() > 2 && details[0] == \"SCAN\") {\n      tables_.push_back(details[2]);\n    }\n  }\n}\n\nStatus QueryPlanner::applyTypes(TableColumns& columns) {\n  std::map<size_t, ColumnType> column_types;\n  for (const auto& row : program_) {\n    if (row.at(\"opcode\") == \"ResultRow\") {\n      // The column parsing is finished.\n      auto k = boost::lexical_cast<size_t>(row.at(\"p1\"));\n      for (const auto& type : column_types) {\n        if (type.first - k < columns.size()) {\n          std::get<1>(columns[type.first - k]) = type.second;\n        }\n      }\n    }\n\n    if (row.at(\"opcode\") == \"Copy\") {\n      // Copy P1 -> P1 + P3 into P2 -> P2 + P3.\n      auto from = boost::lexical_cast<size_t>(row.at(\"p1\"));\n      auto to = boost::lexical_cast<size_t>(row.at(\"p2\"));\n      auto size = boost::lexical_cast<size_t>(row.at(\"p3\"));\n      for (size_t i = 0; i <= size; i++) {\n        if (column_types.count(from + i)) {\n          column_types[to + i] = std::move(column_types[from + i]);\n          column_types.erase(from + i);\n        }\n      }\n    } else if (row.at(\"opcode\") == \"Cast\") {\n      auto value = boost::lexical_cast<size_t>(row.at(\"p1\"));\n      auto to = boost::lexical_cast<size_t>(row.at(\"p2\"));\n      switch (to) {\n      case 'A': // BLOB\n        column_types[value] = BLOB_TYPE;\n        break;\n      case 'B': // TEXT\n        column_types[value] = TEXT_TYPE;\n        break;\n      case 'C': // NUMERIC\n        // We don't exactly have an equivalent to NUMERIC (which includes such\n        // things as DATETIME and DECIMAL\n        column_types[value] = UNKNOWN_TYPE;\n        break;\n      case 'D': // INTEGER\n        column_types[value] = BIGINT_TYPE;\n        break;\n      case 'E': // REAL\n        column_types[value] = DOUBLE_TYPE;\n        break;\n      default:\n        column_types[value] = UNKNOWN_TYPE;\n        break;\n      }\n    }\n\n    if (kSQLOpcodes.count(row.at(\"opcode\"))) {\n      const auto& op = kSQLOpcodes.at(row.at(\"opcode\"));\n      auto k = boost::lexical_cast<size_t>(row.at(Opcode::regString(op.reg)));\n      column_types[k] = op.type;\n    }\n  }\n\n  return Status(0);\n}\n\n// Wrapper for legacy method until all uses can be replaced\nStatus queryInternal(const std::string& query,\n                     QueryData& results,\n                     const SQLiteDBInstanceRef& instance) {\n  QueryDataTyped typedResults;\n  Status status = queryInternal(query, typedResults, instance);\n  if (status.ok()) {\n    results.reserve(typedResults.size());\n    for (const auto& row : typedResults) {\n      Row r;\n      for (const auto& col : row) {\n        r[col.first] = castVariant(col.second);\n      }\n      results.push_back(std::move(r));\n    }\n  }\n  return status;\n}\n\nStatus readRows(sqlite3_stmt* prepared_statement,\n                QueryDataTyped& results,\n                const SQLiteDBInstanceRef& instance) {\n  // Do nothing with a null prepared_statement (eg, if the sql was just\n  // whitespace)\n  if (prepared_statement == nullptr) {\n    return Status::success();\n  }\n  int rc = sqlite3_step(prepared_statement);\n  /* if we have a result set row... */\n  if (SQLITE_ROW == rc) {\n    // First collect the column names\n    int num_columns = sqlite3_column_count(prepared_statement);\n    std::vector<std::string> colNames;\n    colNames.reserve(num_columns);\n    for (int i = 0; i < num_columns; i++) {\n      colNames.push_back(sqlite3_column_name(prepared_statement, i));\n    }\n\n    do {\n      RowTyped row;\n      for (int i = 0; i < num_columns; i++) {\n        switch (sqlite3_column_type(prepared_statement, i)) {\n        case SQLITE_INTEGER:\n          row[colNames[i]] = static_cast<long long>(\n              sqlite3_column_int64(prepared_statement, i));\n          break;\n        case SQLITE_FLOAT:\n          row[colNames[i]] = sqlite3_column_double(prepared_statement, i);\n          break;\n        case SQLITE_NULL:\n          row[colNames[i]] = FLAGS_nullvalue;\n          break;\n        default:\n          // Everything else (SQLITE_TEXT, SQLITE3_TEXT, SQLITE_BLOB) is\n          // obtained/conveyed as text/string\n          row[colNames[i]] = std::string(reinterpret_cast<const char*>(\n              sqlite3_column_text(prepared_statement, i)));\n        }\n      }\n      results.push_back(std::move(row));\n      rc = sqlite3_step(prepared_statement);\n    } while (SQLITE_ROW == rc);\n  }\n  if (rc != SQLITE_DONE) {\n    auto s = Status::failure(sqlite3_errmsg(instance->db()));\n    sqlite3_finalize(prepared_statement);\n    return s;\n  }\n\n  rc = sqlite3_finalize(prepared_statement);\n  if (rc != SQLITE_OK) {\n    return Status::failure(sqlite3_errmsg(instance->db()));\n  }\n\n  return Status::success();\n}\n\nStatus queryInternal(const std::string& query,\n                     QueryDataTyped& results,\n                     const SQLiteDBInstanceRef& instance) {\n  sqlite3_stmt* prepared_statement{nullptr}; /* Statement to execute. */\n\n  int rc = SQLITE_OK; /* Return Code */\n  const char* leftover_sql = nullptr; /* Tail of unprocessed SQL */\n  const char* sql = query.c_str(); /* SQL to be processed */\n\n  /* The big while loop.  One iteration per statement */\n  while ((sql[0] != '\\0') && (SQLITE_OK == rc)) {\n    const auto lock = instance->attachLock();\n\n    // Trim leading whitespace\n    while (isspace(sql[0])) {\n      sql++;\n    }\n    rc = sqlite3_prepare_v2(\n        instance->db(), sql, -1, &prepared_statement, &leftover_sql);\n    if (rc != SQLITE_OK) {\n      Status s = Status::failure(sqlite3_errmsg(instance->db()));\n      sqlite3_finalize(prepared_statement);\n      return s;\n    }\n\n    Status s = readRows(prepared_statement, results, instance);\n    if (!s.ok()) {\n      return s;\n    }\n\n    sql = leftover_sql;\n  } /* end while */\n  sqlite3_db_release_memory(instance->db());\n  return Status::success();\n}\n\nStatus getQueryColumnsInternal(const std::string& q,\n                               TableColumns& columns,\n                               const SQLiteDBInstanceRef& instance) {\n  Status status = Status();\n  TableColumns results;\n  {\n    auto lock = instance->attachLock();\n\n    // Turn the query into a prepared statement\n    sqlite3_stmt* stmt{nullptr};\n    auto rc = sqlite3_prepare_v2(instance->db(),\n                                 q.c_str(),\n                                 static_cast<int>(q.length() + 1),\n                                 &stmt,\n                                 nullptr);\n    if (rc != SQLITE_OK || stmt == nullptr) {\n      auto s = Status::failure(sqlite3_errmsg(instance->db()));\n      if (stmt != nullptr) {\n        sqlite3_finalize(stmt);\n      }\n      return s;\n    }\n\n    // Get column count\n    auto num_columns = sqlite3_column_count(stmt);\n    results.reserve(num_columns);\n\n    // Get column names and types\n    bool unknown_type = false;\n    for (int i = 0; i < num_columns; ++i) {\n      auto col_name = sqlite3_column_name(stmt, i);\n      auto col_type = sqlite3_column_decltype(stmt, i);\n\n      if (col_name == nullptr) {\n        status = Status(1, \"Could not get column type\");\n        break;\n      }\n\n      if (col_type == nullptr) {\n        // Types are only returned for table columns (not expressions).\n        col_type = \"UNKNOWN\";\n        unknown_type = true;\n      }\n      results.push_back(std::make_tuple(\n          col_name, columnTypeName(col_type), ColumnOptions::DEFAULT));\n    }\n\n    // An unknown type means we have to parse the plan and SQLite opcodes.\n    if (unknown_type) {\n      QueryPlanner planner(q, instance);\n      planner.applyTypes(results);\n    }\n    sqlite3_finalize(stmt);\n  }\n\n  if (status.ok()) {\n    columns = std::move(results);\n  }\n\n  return status;\n}\n} // namespace osquery\n", "/**\n * Copyright (c) 2014-present, The osquery authors\n *\n * This source code is licensed as defined by the LICENSE file found in the\n * root directory of this source tree.\n *\n * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)\n */\n\n#pragma once\n\n#include <atomic>\n#include <map>\n#include <mutex>\n#include <unordered_set>\n\n#include <sqlite3.h>\n\n#include <boost/filesystem.hpp>\n#include <boost/noncopyable.hpp>\n\n#include <osquery/sql/sql.h>\n\n#include <osquery/utils/mutex.h>\n\n#include <gtest/gtest_prod.h>\n\n#define SQLITE_SOFT_HEAP_LIMIT (5 * 1024 * 1024)\n\nnamespace osquery {\n\nint sqliteAuthorizer(void* userData,\n                     int code,\n                     const char* arg3,\n                     const char* arg4,\n                     const char* arg5,\n                     const char* arg6);\n\n// Allowlist of SQLite actions. Any action not in this set is denied. See\n// possible values in https://sqlite.org/c3ref/c_alter_table.html.\n// ** Never allow SQLITE_ATTACH ** as it can be used to write arbitrary files.\nconst std::unordered_set<int> kAllowedSQLiteActionCodes = {\n    // Enable basic functionality\n    SQLITE_READ,\n    SQLITE_SELECT,\n\n    // Some extensions implement writeable tables\n    SQLITE_INSERT,\n    SQLITE_UPDATE,\n    SQLITE_DELETE,\n\n    // Allow virtual tables to be attached\n    SQLITE_CREATE_VTABLE,\n    SQLITE_DROP_VTABLE,\n\n    // Users may sometimes want to create tables and views\n    SQLITE_CREATE_VIEW,\n    SQLITE_DROP_VIEW,\n    SQLITE_CREATE_TABLE,\n    SQLITE_DROP_TABLE,\n    SQLITE_CREATE_TEMP_TABLE,\n    SQLITE_DROP_TEMP_TABLE,\n    SQLITE_CREATE_TEMP_VIEW,\n    SQLITE_DROP_TEMP_VIEW,\n\n    // Required to allow calling functions in SQL\n    SQLITE_FUNCTION,\n\n    // Required for recursive queries\n    SQLITE_RECURSIVE,\n};\n\nclass SQLiteDBManager;\n\n/**\n * @brief An RAII wrapper around an `sqlite3` object.\n *\n * The SQLiteDBInstance is also \"smart\" in that it may unlock access to a\n * managed `sqlite3` resource. If there's no contention then only a single\n * database is needed during the life of an osquery tool.\n *\n * If there is resource contention (multiple threads want access to the SQLite\n * abstraction layer), then the SQLiteDBManager will provide a transient\n * SQLiteDBInstance.\n */\nclass SQLiteDBInstance : private boost::noncopyable {\n public:\n  SQLiteDBInstance() {\n    init();\n  }\n  SQLiteDBInstance(sqlite3*& db, Mutex& mtx);\n  ~SQLiteDBInstance();\n\n  /// Check if the instance is the osquery primary.\n  bool isPrimary() const {\n    return primary_;\n  }\n\n  /// Generate a new 'transient' connection.\n  void init();\n\n  /**\n   * @brief Accessor to the internal `sqlite3` object, do not store references\n   * to the object within osquery code.\n   */\n  sqlite3* db() const {\n    return db_;\n  }\n\n  /// Allow a virtual table implementation to record use/access of a table.\n  void addAffectedTable(std::shared_ptr<VirtualTableContent> table);\n\n  /// Clear per-query state of a table affected by the use of this instance.\n  void clearAffectedTables();\n\n  /// Check if a virtual table had been called already.\n  bool tableCalled(VirtualTableContent const& table);\n\n  /// Request that virtual tables use a warm cache for their results.\n  void useCache(bool use_cache);\n\n  /// Check if the query requested use of the warm query cache.\n  bool useCache() const;\n\n  /// Lock the database for attaching virtual tables.\n  RecursiveLock attachLock() const;\n\n private:\n  /// Handle the primary/forwarding requests for table attribute accesses.\n  TableAttributes getAttributes() const;\n\n private:\n  /// An opaque constructor only used by the DBManager.\n  explicit SQLiteDBInstance(sqlite3* db)\n      : primary_(true), managed_(true), db_(db) {}\n\n private:\n  /// Introspection into the database pointer, primary means managed.\n  bool primary_{false};\n\n  /// Track whether this instance is managed internally by the DB manager.\n  bool managed_{false};\n\n  /// True if this query should bypass table cache.\n  bool use_cache_{false};\n\n  /// Either the managed primary database or an ephemeral instance.\n  sqlite3* db_{nullptr};\n\n  /**\n   * @brief An attempted unique lock on the manager's primary database mutex.\n   *\n   * This lock is not always acquired. If it is then this instance has locked\n   * access to the 'primary' SQLite database.\n   */\n  WriteLock lock_;\n\n  /**\n   * @brief A mutex protecting access to this instance's SQLite database.\n   *\n   * Attaching, and other access, can occur async from the registry APIs.\n   *\n   * If a database is primary then the static attach mutex is used.\n   */\n  mutable RecursiveMutex attach_mutex_;\n\n  /// See attach_mutex_ but used for the primary database.\n  static RecursiveMutex kPrimaryAttachMutex;\n\n  /// Vector of tables that need their constraints cleared after execution.\n  std::map<std::string, std::shared_ptr<VirtualTableContent>> affected_tables_;\n\n private:\n  friend class SQLiteDBManager;\n  friend class SQLInternal;\n\n private:\n  FRIEND_TEST(SQLiteUtilTests, test_affected_tables);\n};\n\nusing SQLiteDBInstanceRef = std::shared_ptr<SQLiteDBInstance>;\n\n/**\n * @brief osquery internal SQLite DB abstraction resource management.\n *\n * The SQLiteDBManager should be the ONLY method for accessing SQLite resources.\n * The manager provides an abstraction to manage internal SQLite memory and\n * resources as well as provide optimization around resource access.\n */\nclass SQLiteDBManager : private boost::noncopyable {\n public:\n  static SQLiteDBManager& instance() {\n    static SQLiteDBManager instance;\n    return instance;\n  }\n\n  /**\n   * @brief Return a fully configured `sqlite3` database object wrapper.\n   *\n   * An osquery database is basically just a SQLite3 database with several\n   * virtual tables attached. This method is the main abstraction for accessing\n   * SQLite3 databases within osquery.\n   *\n   * A RAII wrapper around the `sqlite3` database will manage attaching tables\n   * and freeing resources when the instance (connection per-say) goes out of\n   * scope. Using the SQLiteDBManager will also try to optimize the number of\n   * `sqlite3` databases in use by managing a single global instance and\n   * returning resource-safe transient databases if there's access contention.\n   *\n   * Note: osquery::initOsquery must be called before calling `get` in order\n   * for virtual tables to be registered.\n   *\n   * @return a SQLiteDBInstance with all virtual tables attached.\n   */\n  static SQLiteDBInstanceRef get() {\n    return getConnection();\n  }\n\n  /// See `get` but always return a transient DB connection (for testing).\n  static SQLiteDBInstanceRef getUnique();\n\n  /**\n   * @brief Reset the primary database connection.\n   *\n   * Over time it may be helpful to remove SQLite's arena.\n   * We can periodically close and re-initialize and connect virtual tables.\n   */\n  static void resetPrimary();\n\n  /**\n   * @brief Check if `table_name` is disabled.\n   *\n   * `table_name` is disabled if it's in the list of tables passed in to the\n   * `--disable_tables` flag or if the `--enable_tables` flag is set and\n   * `table_name` is not specified.\n   *\n   * @param The name of the Table to check.\n   * @return If `table_name` is disabled.\n   */\n  static bool isDisabled(const std::string& table_name);\n\n protected:\n  SQLiteDBManager();\n  virtual ~SQLiteDBManager();\n\n public:\n  SQLiteDBManager(SQLiteDBManager const&) = delete;\n  SQLiteDBManager& operator=(SQLiteDBManager const&) = delete;\n\n private:\n  /// Primary (managed) sqlite3 database.\n  sqlite3* db_{nullptr};\n\n  /// The primary connection maintains an opaque instance.\n  SQLiteDBInstanceRef connection_{nullptr};\n\n  /// Mutex and lock around sqlite3 access.\n  Mutex mutex_;\n\n  /// A write mutex for initializing the primary database.\n  Mutex create_mutex_;\n\n  /// Member variable to hold set of disabled tables.\n  std::unordered_set<std::string> disabled_tables_;\n\n  /// Member variable to hold set of enabled tables.\n  std::unordered_set<std::string> enabled_tables_;\n\n  /// Parse a comma-delimited set of tables names, passed in as a flag.\n  void setDisabledTables(const std::string& s);\n\n  /// Parse a comma-delimited set of tables names, passed in as a flag.\n  void setEnabledTables(const std::string& s);\n\n  /// Request a connection, optionally request the primary connection.\n  static SQLiteDBInstanceRef getConnection(bool primary = false);\n\n private:\n  friend class SQLiteDBInstance;\n  friend class SQLiteSQLPlugin;\n};\n\n/**\n * @brief A barebones query planner based on SQLite explain statement results.\n *\n * The query planner issues two EXPLAIN queries to the internal SQLite instance\n * to determine a table scan plan and execution program.\n *\n * It is mildly expensive to run a query planner since most data is TEXT type\n * and requires string tokenization and lexical casting. Only run a planner\n * once per new query and only when needed (aka an unusable expression).\n */\nclass QueryPlanner : private boost::noncopyable {\n public:\n  explicit QueryPlanner(const std::string& query)\n      : QueryPlanner(query, SQLiteDBManager::get()) {}\n  QueryPlanner(const std::string& query, const SQLiteDBInstanceRef& instance);\n  ~QueryPlanner() {}\n\n public:\n  /**\n   * @brief Scan the plan and program for opcodes that infer types.\n   *\n   * This allows column type inference based on column expressions. The query\n   * column introspection may use a QueryPlanner to apply types to the unknown\n   * columns (which are usually expressions).\n   *\n   * @param column an ordered set of columns to fill in type information.\n   * @return success if all columns types were found, otherwise false.\n   */\n  Status applyTypes(TableColumns& columns);\n\n  /// Get the list of tables filtered by this query.\n  std::vector<std::string> tables() const {\n    return tables_;\n  }\n\n  /**\n   * @brief A helper structure to represent an opcode's result and type.\n   *\n   * An opcode can be defined by a register and type, for the sake of the\n   * only known use case of resultant type determination.\n   */\n  struct Opcode {\n    enum Register {\n      P1 = 0,\n      P2,\n      P3,\n    };\n\n    Register reg;\n    ColumnType type;\n\n   public:\n    Opcode(Register r, ColumnType t) : reg(r), type(t) {}\n\n    /// Return a register as its column string name.\n    static std::string regString(Register r) {\n      static std::vector<std::string> regs = {\"p1\", \"p2\", \"p3\"};\n      return regs[r];\n    }\n  };\n\n private:\n  /// The results of EXPLAIN q.\n  QueryData program_;\n  /// The order of tables scanned.\n  std::vector<std::string> tables_;\n};\n\n/// Specific SQLite opcodes that change column/expression type.\nextern const std::map<std::string, QueryPlanner::Opcode> kSQLOpcodes;\n\n/**\n * @brief SQLite Internal: Execute a query on a specific database\n *\n * If you need to use a different database, other than the osquery default,\n * use this method and pass along a pointer to a SQLite3 database. This is\n * useful for testing.\n *\n * @param q the query to execute\n * @param results The QueryDataTyped vector to emit rows on query success.\n * @param db the SQLite3 database to execute query q against\n *\n * @return A status indicating SQL query results.\n */\nStatus queryInternal(const std::string& q,\n                     QueryDataTyped& results,\n                     const SQLiteDBInstanceRef& instance);\n\n/**\n * @brief SQLite Internal: Execute a query on a specific database\n *\n * If you need to use a different database, other than the osquery default,\n * use this method and pass along a pointer to a SQLite3 database. This is\n * useful for testing.\n *\n * @param q the query to execute\n * @param results The QueryData struct to emit row on query success.\n * @param db the SQLite3 database to execute query q against\n *\n * @return A status indicating SQL query results.\n */\nStatus queryInternal(const std::string& q,\n                     QueryData& results,\n                     const SQLiteDBInstanceRef& instance);\n\n/**\n * @brief SQLite Intern: Analyze a query, providing information about the\n * result columns\n *\n * This function asks SQLite to determine what the names and types are of the\n * result columns of the provided query. Only table columns (not expressions or\n * subqueries) can have their types determined. Types that are not determined\n * are indicated with the string \"UNKNOWN\".\n *\n * @param q the query to analyze\n * @param columns the vector to fill with column information\n * @param db the SQLite3 database to perform the analysis on\n *\n * @return status indicating success or failure of the operation\n */\nStatus getQueryColumnsInternal(const std::string& q,\n                               TableColumns& columns,\n                               const SQLiteDBInstanceRef& instance);\n\n/**\n * @brief SQLInternal: like SQL, but backed by internal calls, and deals\n * with QueryDataTyped results.\n */\nclass SQLInternal : private only_movable {\n public:\n  /**\n   * @brief Instantiate an instance of the class with an internal query.\n   *\n   * @param query An osquery SQL query.\n   * @param use_cache [optional] Set true to use the query cache.\n   */\n  explicit SQLInternal(const std::string& query, bool use_cache = false);\n\n public:\n  /**\n   * @brief Const accessor for the rows returned by the query.\n   *\n   * @return A QueryDataTyped object of the query results.\n   */\n  QueryDataTyped& rowsTyped();\n\n  const Status& getStatus() const;\n\n  /**\n   * @brief Check if the SQL query's results use event-based tables.\n   *\n   * Higher level SQL facilities, like the scheduler, may act differently when\n   * the results of a query (including a JOIN) are event-based. For example,\n   * it does not make sense to perform set difference checks for an\n   * always-append result set.\n   *\n   * All the tables used in the query will be checked. The TableAttributes of\n   * each will be ORed and if any include EVENT_BASED, this will return true.\n   */\n  bool eventBased() const;\n\n  /// ASCII escape the results of the query.\n  void escapeResults();\n\n private:\n  /// The internal member which holds the typed results of the query.\n  QueryDataTyped resultsTyped_;\n\n  /// The internal member which holds the status of the query.\n  Status status_;\n  /// Before completing the execution, store a check for EVENT_BASED.\n  bool event_based_{false};\n};\n\n/**\n * @brief Get a string representation of a SQLite return code.\n */\nstd::string getStringForSQLiteReturnCode(int code);\n\n/**\n * @brief Accumulate rows from an SQLite exec into a QueryData struct.\n *\n * The callback for populating a std::vector<Row> set of results. \"argument\"\n * should be a non-const reference to a std::vector<Row>.\n */\nint queryDataCallback(void* argument, int argc, char* argv[], char* column[]);\n\n/**\n * @brief Register math-related 'custom' functions.\n */\nvoid registerMathExtensions(sqlite3* db);\n\n/**\n * @brief Register string-related 'custom' functions.\n */\nvoid registerStringExtensions(sqlite3* db);\n\n/**\n * @brief Register hashing-related 'custom' functions.\n */\nvoid registerHashingExtensions(sqlite3* db);\n\n/**\n * @brief Register osquery operation 'custom' functions.\n */\nvoid registerOperationExtensions(sqlite3* db);\n\n/**\n * @brief Register encoding-related 'custom' functions.\n */\nvoid registerEncodingExtensions(sqlite3* db);\n\n/**\n * @brief Register filesystem-related 'custom' functions.\n */\nvoid registerFilesystemExtensions(sqlite3* db);\n\n/**\n * @brief Generate the data for auto-constructed sqlite tables\n *\n * When auto-constructed sqlite tables are queried, this function\n * generated the resulting QueryData\n *\n * @param sqlite_db Path to the sqlite_db\n * @param sqlite_query The query you want to run against the SQLite database\n * @param columns The columns that you want out of the sqlite query results\n * @param results The TableRows data structure that will hold the returned rows\n */\nStatus genTableRowsForSqliteTable(const boost::filesystem::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking = true);\n\n/**\n * @brief Detect journal_mode of d SQLite database file\n *\n * Returns a Status, if successful contains the journal mode as message\n *\n * @param sqlite_db Path to the sqlite_db\n */\nStatus getSqliteJournalMode(const boost::filesystem::path& sqlite_db);\n} // namespace osquery\n", "/**\n * Copyright (c) 2014-present, The osquery authors\n *\n * This source code is licensed as defined by the LICENSE file found in the\n * root directory of this source tree.\n *\n * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)\n */\n\n#include <osquery/core/core.h>\n#include <osquery/core/flags.h>\n#include <osquery/core/system.h>\n#include <osquery/registry/registry_interface.h>\n#include <osquery/sql/sql.h>\n#include <osquery/sql/sqlite_util.h>\n#include <osquery/sql/tests/sql_test_utils.h>\n#include <osquery/utils/info/platform_type.h>\n\n#include <gtest/gtest.h>\n\n#include <boost/lexical_cast.hpp>\n#include <boost/variant.hpp>\n\nnamespace osquery {\nclass SQLiteUtilTests : public testing::Test {\n public:\n  void SetUp() override {\n    platformSetup();\n    registryAndPluginInit();\n    Flag::updateValue(\"enable_tables\",\n                      \"test_table,time,process_events,osquery_info,file,users,\"\n                      \"curl,fake_table\");\n    Flag::updateValue(\"disable_tables\", \"fake_table\");\n  }\n};\n\nstd::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30), age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n\n  return dbc;\n}\n\nTEST_F(SQLiteUtilTests, test_zero_as_float_doesnt_convert_to_int) {\n  auto sql = SQL(\"SELECT 0.0 as zero\");\n  EXPECT_TRUE(sql.ok());\n  EXPECT_EQ(sql.rows().size(), 1U);\n  Row r;\n  r[\"zero\"] = \"0.0\";\n  EXPECT_EQ(sql.rows()[0], r);\n}\n\nTEST_F(SQLiteUtilTests, test_precision_is_maintained) {\n  auto sql = SQL(\"SELECT 0.123456789 as high_precision, 0.12 as low_precision\");\n  EXPECT_TRUE(sql.ok());\n  EXPECT_EQ(sql.rows().size(), 1U);\n  Row r;\n  r[\"high_precision\"] = \"0.123456789\";\n  r[\"low_precision\"] = \"0.12\";\n  EXPECT_EQ(sql.rows()[0], r);\n}\n\nTEST_F(SQLiteUtilTests, test_simple_query_execution) {\n  // Access to the internal SQL implementation is only available in core.\n  auto sql = SQL(\"SELECT * FROM time\");\n  EXPECT_TRUE(sql.ok());\n  EXPECT_EQ(sql.rows().size(), 1U);\n}\n\nTEST_F(SQLiteUtilTests, test_sqlite_instance_manager) {\n  auto dbc1 = SQLiteDBManager::get();\n  auto dbc2 = SQLiteDBManager::get();\n  EXPECT_NE(dbc1->db(), dbc2->db());\n  EXPECT_EQ(dbc1->db(), dbc1->db());\n}\n\nTEST_F(SQLiteUtilTests, test_sqlite_instance) {\n  // Don't do this at home kids.\n  // Keep a copy of the internal DB and let the SQLiteDBInstance go oos.\n  auto internal_db = SQLiteDBManager::get()->db();\n  // Compare the internal DB to another request with no SQLiteDBInstances\n  // in scope, meaning the primary will be returned.\n  EXPECT_EQ(internal_db, SQLiteDBManager::get()->db());\n}\n\nTEST_F(SQLiteUtilTests, test_reset) {\n  auto internal_db = SQLiteDBManager::get()->db();\n  ASSERT_NE(nullptr, internal_db);\n\n  sqlite3_exec(internal_db,\n               \"create view test_view as select 'test';\",\n               nullptr,\n               nullptr,\n               nullptr);\n\n  SQLiteDBManager::resetPrimary();\n  auto instance = SQLiteDBManager::get();\n\n  QueryDataTyped results;\n  queryInternal(\"select * from test_view\", results, instance);\n\n  // Assume the internal (primary) database we reset and recreated.\n  EXPECT_EQ(results.size(), 0U);\n}\n\nTEST_F(SQLiteUtilTests, test_direct_query_execution) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(kTestQuery, results, dbc);\n  EXPECT_TRUE(status.ok());\n  EXPECT_EQ(results, getTestDBExpectedResults());\n}\n\nTEST_F(SQLiteUtilTests, test_aggregate_query) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(kTestQuery, results, dbc);\n  EXPECT_TRUE(status.ok());\n  EXPECT_EQ(results, getTestDBExpectedResults());\n}\n\nTEST_F(SQLiteUtilTests, test_no_results_query) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(\n      \"select * from test_table where username=\\\"A_NON_EXISTENT_NAME\\\"\",\n      results,\n      dbc);\n  EXPECT_TRUE(status.ok());\n}\n\nTEST_F(SQLiteUtilTests, test_whitespace_query) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(\"     \", results, dbc);\n  EXPECT_TRUE(status.ok());\n}\n\nTEST_F(SQLiteUtilTests, test_whitespace_then_nonwhitespace_query) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(\"     ; select * from time  \", results, dbc);\n  EXPECT_TRUE(status.ok());\n}\n\nTEST_F(SQLiteUtilTests, test_get_test_db_result_stream) {\n  auto dbc = getTestDBC();\n  auto results = getTestDBResultStream();\n  for (auto r : results) {\n    char* err_char = nullptr;\n    sqlite3_exec(dbc->db(), (r.first).c_str(), nullptr, nullptr, &err_char);\n    EXPECT_TRUE(err_char == nullptr);\n    if (err_char != nullptr) {\n      sqlite3_free(err_char);\n      ASSERT_TRUE(false);\n    }\n\n    QueryDataTyped expected;\n    auto status = queryInternal(kTestQuery, expected, dbc);\n    EXPECT_EQ(expected, r.second);\n  }\n}\n\nTEST_F(SQLiteUtilTests, test_affected_tables) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  auto status = queryInternal(\"SELECT * FROM time\", results, dbc);\n\n  // Since the table scanned from \"time\", it should be recorded as affected.\n  EXPECT_EQ(dbc->affected_tables_.count(\"time\"), 1U);\n  dbc->clearAffectedTables();\n  EXPECT_EQ(dbc->affected_tables_.size(), 0U);\n}\n\nTEST_F(SQLiteUtilTests, test_table_attributes_event_based) {\n  {\n    SQLInternal sql_internal(\"select * from process_events\");\n    if (!isPlatform(PlatformType::TYPE_WINDOWS)) {\n      EXPECT_TRUE(sql_internal.getStatus().ok());\n      EXPECT_TRUE(sql_internal.eventBased());\n    }\n  }\n\n  {\n    SQLInternal sql_internal(\"select * from time\");\n    EXPECT_TRUE(sql_internal.getStatus().ok());\n    EXPECT_FALSE(sql_internal.eventBased());\n  }\n}\n\nTEST_F(SQLiteUtilTests, test_get_query_columns) {\n  auto dbc = getTestDBC();\n  TableColumns results;\n\n  std::string query = \"SELECT seconds, version FROM time JOIN osquery_info\";\n  auto status = getQueryColumnsInternal(query, results, dbc);\n  ASSERT_TRUE(status.ok());\n  ASSERT_EQ(2U, results.size());\n  EXPECT_EQ(std::make_tuple(\n                std::string(\"seconds\"), INTEGER_TYPE, ColumnOptions::DEFAULT),\n            results[0]);\n  EXPECT_EQ(std::make_tuple(\n                std::string(\"version\"), TEXT_TYPE, ColumnOptions::DEFAULT),\n            results[1]);\n\n  query = \"SELECT * FROM foo\";\n  status = getQueryColumnsInternal(query, results, dbc);\n  ASSERT_FALSE(status.ok());\n}\n\nTEST_F(SQLiteUtilTests, test_get_query_tables_failed) {\n  auto dbc = getTestDBC();\n  QueryDataTyped results;\n  EXPECT_FALSE(queryInternal(\"SELECT * FROM file\", results, dbc).ok());\n}\n\nTEST_F(SQLiteUtilTests, test_get_query_tables) {\n  std::string query =\n      \"SELECT * FROM time, osquery_info, (SELECT * FROM users) ff GROUP BY pid\";\n  std::vector<std::string> tables;\n  auto status = getQueryTables(query, tables);\n  EXPECT_TRUE(status.ok());\n\n  std::vector<std::string> expected = {\"time\", \"osquery_info\", \"users\"};\n  EXPECT_EQ(expected, tables);\n}\n\nTEST_F(SQLiteUtilTests, test_get_query_tables_required) {\n  std::string query =\n      \"SELECT * FROM time, osquery_info, (SELECT * FROM file where path = \"\n      \"'osquery') ff GROUP BY pid\";\n  std::vector<std::string> tables;\n  auto status = getQueryTables(query, tables);\n  EXPECT_TRUE(status.ok());\n\n  std::vector<std::string> expected = {\"time\", \"osquery_info\", \"file\"};\n  EXPECT_EQ(expected, tables);\n}\n\nstd::vector<ColumnType> getTypes(const TableColumns& columns) {\n  std::vector<ColumnType> types;\n  for (const auto& col : columns) {\n    types.push_back(std::get<1>(col));\n  }\n  return types;\n}\n\nTEST_F(SQLiteUtilTests, test_query_planner) {\n  using TypeList = std::vector<ColumnType>;\n\n  auto dbc = getTestDBC();\n  TableColumns columns;\n\n  std::string query = \"select path, path from file\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query = \"select path, path from file where path in ('osquery', 'noquery')\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE, TEXT_TYPE}));\n\n  query = \"select path, seconds from file, time where path LIKE 'osquery'\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE, INTEGER_TYPE}));\n\n  query = \"select path || path from file\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query = \"select path || path from file where path = 'osquery'\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE}));\n\n  query = \"select seconds, path || path from file, time \";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query =\n      \"select seconds, path || path from file, time where path in ('osquery')\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({INTEGER_TYPE, TEXT_TYPE}));\n\n  query = \"select seconds, seconds from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({INTEGER_TYPE, INTEGER_TYPE}));\n\n  query = \"select count(*) from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BIGINT_TYPE}));\n\n  query = \"select count(*), count(seconds), seconds from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns),\n            TypeList({BIGINT_TYPE, BIGINT_TYPE, INTEGER_TYPE}));\n\n  query = \"select 1, 'path', path from file\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query = \"select 1, 'path', path from file where path = 'os'\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({INTEGER_TYPE, TEXT_TYPE, TEXT_TYPE}));\n\n  query = \"select weekday, day, count(*), seconds from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns),\n            TypeList({TEXT_TYPE, INTEGER_TYPE, BIGINT_TYPE, INTEGER_TYPE}));\n\n  query = \"select seconds + 1 from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BIGINT_TYPE}));\n\n  query = \"select seconds * seconds from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BIGINT_TYPE}));\n\n  query = \"select seconds > 1, seconds, count(seconds) from time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns),\n            TypeList({INTEGER_TYPE, INTEGER_TYPE, BIGINT_TYPE}));\n\n  query =\n      \"select f1.*, seconds, f2.directory from (select path || path from file) \"\n      \"f1, file as f2, time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query =\n      \"select f1.*, seconds, f2.directory from (select path || path from file) \"\n      \"f1, file as f2, time where path in ('query', 'query')\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query =\n      \"select f1.*, seconds, f2.directory from (select path || path from file \"\n      \"where path = 'query') \"\n      \"f1, file as f2, time where path in ('query', 'query')\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE, INTEGER_TYPE, TEXT_TYPE}));\n\n  query = \"select CAST(seconds AS INTEGER) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BIGINT_TYPE}));\n\n  query = \"select CAST(seconds AS TEXT) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({TEXT_TYPE}));\n\n  query = \"select CAST(seconds AS REAL) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({DOUBLE_TYPE}));\n\n  query = \"select CAST(seconds AS BOOLEAN) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({UNKNOWN_TYPE}));\n\n  query = \"select CAST(seconds AS DATETIME) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({UNKNOWN_TYPE}));\n\n  query = \"select CAST(seconds AS BLOB) FROM time\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns), TypeList({BLOB_TYPE}));\n\n  query = \"select url, round_trip_time, response_code from curl\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n\n  query =\n      \"select url, round_trip_time, response_code from curl where url = \"\n      \"'https://github.com/osquery/osquery'\";\n  EXPECT_TRUE(getQueryColumnsInternal(query, columns, dbc).ok());\n  EXPECT_EQ(getTypes(columns),\n            TypeList({TEXT_TYPE, BIGINT_TYPE, INTEGER_TYPE}));\n}\n\nusing TypeMap = std::map<std::string, ColumnType>;\n\n// Using ColumnType enum just labeling in test_column_type_determination)\nclass type_picker_visitor : public boost::static_visitor<ColumnType> {\n public:\n  ColumnType operator()(const long long& i) const {\n    return INTEGER_TYPE;\n  }\n\n  ColumnType operator()(const std::string& str) const {\n    return TEXT_TYPE;\n  }\n\n  ColumnType operator()(const double& d) const {\n    return DOUBLE_TYPE;\n  }\n};\n\nvoid testTypesExpected(std::string query, TypeMap expectedTypes) {\n  auto dbc = getTestDBC();\n  QueryDataTyped typedResults;\n  queryInternal(query, typedResults, dbc);\n  for (const auto& row : typedResults) {\n    for (const auto& col : row) {\n      if (expectedTypes.count(col.first)) {\n        EXPECT_EQ(boost::apply_visitor(type_picker_visitor(), col.second),\n                  expectedTypes[col.first])\n            << \" These are the integer values of actual/expected ColumnType \"\n               \"(resp) of \"\n            << col.first << \" for query: \" << query;\n      } else {\n        FAIL() << \"Found no expected type for \" << col.first\n               << \" in test of column types for query \" << query;\n      }\n    }\n  }\n}\n\nTEST_F(SQLiteUtilTests, test_column_type_determination) {\n  // Correct identification of text and ints\n  testTypesExpected(\"select path, inode from file where path like '%'\",\n                    TypeMap({{\"path\", TEXT_TYPE}, {\"inode\", INTEGER_TYPE}}));\n  // Correctly treating BLOBs as text\n  testTypesExpected(\"select CAST(seconds AS BLOB) as seconds FROM time\",\n                    TypeMap({{\"seconds\", TEXT_TYPE}}));\n  // Correctly treating ints cast as double as doubles\n  testTypesExpected(\"select CAST(seconds AS DOUBLE) as seconds FROM time\",\n                    TypeMap({{\"seconds\", DOUBLE_TYPE}}));\n  // Correctly treating bools as ints\n  testTypesExpected(\"select CAST(seconds AS BOOLEAN) as seconds FROM time\",\n                    TypeMap({{\"seconds\", INTEGER_TYPE}}));\n  // Correctly recognizing values from columns declared double as double, even\n  // if they happen to have integer value.  And also test multi-statement\n  // queries.\n  testTypesExpected(\n      \"CREATE TABLE test_types_table (username varchar(30), age \"\n      \"double);INSERT INTO test_types_table VALUES (\\\"mike\\\", 23); SELECT age \"\n      \"from test_types_table\",\n      TypeMap({{\"age\", DOUBLE_TYPE}}));\n}\n\nTEST_F(SQLiteUtilTests, test_enable) {\n  // Shadow is not in enable_tables.\n  ASSERT_TRUE(SQLiteDBManager::isDisabled(\"shadow\"));\n  // Users is explicitely in enable_tables.\n  ASSERT_FALSE(SQLiteDBManager::isDisabled(\"users\"));\n  // Fake_table is explicitely in enabled_tables and\n  // disable_tables, it should be disabled.\n  ASSERT_TRUE(SQLiteDBManager::isDisabled(\"fake_table\"));\n}\n\nTEST_F(SQLiteUtilTests, test_sqlite_authorizer) {\n  auto rc = sqliteAuthorizer(\n      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_DENY, rc);\n\n  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_DENY, rc);\n\n  rc = sqliteAuthorizer(\n      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_OK, rc);\n}\n\n} // namespace osquery\n", "/**\n * Copyright (c) 2014-present, The osquery authors\n *\n * This source code is licensed as defined by the LICENSE file found in the\n * root directory of this source tree.\n *\n * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)\n */\n\n#include <boost/algorithm/string.hpp>\n\n#include <osquery/core/core.h>\n#include <osquery/filesystem/filesystem.h>\n#include <osquery/logger/logger.h>\n#include <osquery/sql/sql.h>\n\n#include <osquery/utils/info/platform_type.h>\n\n#include \"osquery/sql/dynamic_table_row.h\"\n#include \"osquery/sql/sqlite_util.h\"\n\nnamespace fs = boost::filesystem;\n\nnamespace osquery {\n\nconst char* getSystemVFS(bool respect_locking) {\n  if (respect_locking) {\n    return nullptr;\n  }\n  if (isPlatform(PlatformType::TYPE_POSIX)) {\n    return \"unix-none\";\n  } else if (isPlatform(PlatformType::TYPE_WINDOWS)) {\n    return \"win32-none\";\n  }\n  return nullptr;\n}\n\nStatus genSqliteTableRow(sqlite3_stmt* stmt,\n                         TableRows& qd,\n                         const fs::path& sqlite_db) {\n  auto r = make_table_row();\n  for (int i = 0; i < sqlite3_column_count(stmt); ++i) {\n    auto column_name = std::string(sqlite3_column_name(stmt, i));\n    auto column_type = sqlite3_column_type(stmt, i);\n    switch (column_type) {\n    case SQLITE_BLOB:\n    case SQLITE_TEXT: {\n      auto text_value = sqlite3_column_text(stmt, i);\n      if (text_value != nullptr) {\n        r[column_name] = std::string(reinterpret_cast<const char*>(text_value));\n      }\n      break;\n    }\n    case SQLITE_FLOAT: {\n      auto float_value = sqlite3_column_double(stmt, i);\n      r[column_name] = DOUBLE(float_value);\n      break;\n    }\n    case SQLITE_INTEGER: {\n      auto int_value = sqlite3_column_int64(stmt, i);\n      r[column_name] = INTEGER(int_value);\n      break;\n    }\n    }\n  }\n  if (r.count(\"path\") > 0) {\n    LOG(WARNING) << \"ATC Table: Row contains a defined path key, omitting the \"\n                    \"implicit one\";\n  } else {\n    r[\"path\"] = sqlite_db.string();\n  }\n  qd.push_back(std::move(r));\n  return Status::success();\n}\n\nStatus genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"Database path does not exist\");\n  }\n\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"Cannot open specified database: \"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"Could not open database\");\n  }\n\n  rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    auto errMsg =\n        std::string(\"Failed to set sqlite authorizer: \") + sqlite3_errmsg(db);\n    return Status(1, errMsg);\n  }\n\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"ATC table: Could not prepare database at path: \" << sqlite_db;\n    return Status(rc, \"Could not prepare database\");\n  }\n\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n\n  // Close handles and free memory\n  sqlite3_finalize(stmt);\n  sqlite3_close(db);\n\n  return Status{};\n}\n\nStatus getSqliteJournalMode(const fs::path& sqlite_db) {\n  TableRows result;\n  auto status = genTableRowsForSqliteTable(\n      sqlite_db, \"PRAGMA journal_mode;\", result, true);\n  if (!status.ok()) {\n    return status;\n  }\n  if (result.empty()) {\n    VLOG(1) << \"PRAGMA query returned empty results\";\n    return Status(1, \"Could not retrieve journal mode\");\n  }\n  auto resultmap = static_cast<Row>(*result[0]);\n  if (resultmap.find(\"journal_mode\") == resultmap.end()) {\n    VLOG(1) << \"journal_mode not found PRAGMA query results\";\n    return Status(1, \"Could not retrieve journal mode\");\n  }\n  return Status(Status::kSuccessCode,\n                boost::algorithm::to_lower_copy(resultmap[\"journal_mode\"]));\n}\n\n} // namespace osquery\n"], "filenames": ["osquery/sql/sqlite_util.cpp", "osquery/sql/sqlite_util.h", "osquery/sql/tests/sqlite_util_tests.cpp", "osquery/sql/virtual_sqlite_table.cpp"], "buggy_code_start_loc": [18, 30, 38, 98], "buggy_code_end_loc": [460, 30, 452, 98], "fixing_code_start_loc": [19, 31, 39, 99], "fixing_code_end_loc": [486, 72, 467, 107], "type": "CWE-77", "message": "osquery is a SQL powered operating system instrumentation, monitoring, and analytics framework. In osquery before version 4.6.0, by using sqlite's ATTACH verb, someone with administrative access to osquery can cause reads and writes to arbitrary sqlite databases on disk. This _does_ allow arbitrary files to be created, but they will be sqlite databases. It does not appear to allow existing non-sqlite files to be overwritten. This has been patched in osquery 4.6.0. There are several mitigating factors and possible workarounds. In some deployments, the people with access to these interfaces may be considered administrators. In some deployments, configuration is managed by a central tool. This tool can filter for the `ATTACH` keyword. osquery can be run as non-root user. Because this also limits the desired access levels, this requires deployment specific testing and configuration.", "other": {"cve": {"id": "CVE-2020-26273", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-16T02:15:13.037", "lastModified": "2020-12-18T15:59:43.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "osquery is a SQL powered operating system instrumentation, monitoring, and analytics framework. In osquery before version 4.6.0, by using sqlite's ATTACH verb, someone with administrative access to osquery can cause reads and writes to arbitrary sqlite databases on disk. This _does_ allow arbitrary files to be created, but they will be sqlite databases. It does not appear to allow existing non-sqlite files to be overwritten. This has been patched in osquery 4.6.0. There are several mitigating factors and possible workarounds. In some deployments, the people with access to these interfaces may be considered administrators. In some deployments, configuration is managed by a central tool. This tool can filter for the `ATTACH` keyword. osquery can be run as non-root user. Because this also limits the desired access levels, this requires deployment specific testing and configuration."}, {"lang": "es", "value": "osquery es un framework de instrumentaci\u00f3n, monitoreo y an\u00e1lisis del sistema operativo basado en SQL.&#xa0;En osquery versiones anteriores a 4.6.0, al usar el verbo ATTACH de sqlite, alguien con acceso administrativo a osquery puede causar lecturas y escrituras en bases de datos sqlite arbitrarias sobre el disco.&#xa0;Este _does_ permite que archivos arbitrarios sean creados, pero ser\u00e1n bases de datos sqlite.&#xa0;No parece permitir que se sobrescriban los archivos existentes que no son sqlite.&#xa0;Esto ha sido parcheado en osquery versi\u00f3n 4.6.0.&#xa0;Se presentan varios factores atenuantes y posibles soluciones.&#xa0;En algunas implementaciones, las personas con acceso a estas interfaces pueden considerarse administradores.&#xa0;En algunas implementaciones, la configuraci\u00f3n es administrada por una herramienta central.&#xa0;Esta herramienta puede filtrar por la palabra clave \"ATTACH\".&#xa0;osquery puede ser ejecutado como usuario no root.&#xa0;Porque esto tambi\u00e9n limita los niveles de acceso deseados, esto requiere pruebas y configuraci\u00f3n espec\u00edfica de la implementaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.0, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.0, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:osquery:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.6.0", "matchCriteriaId": "EFC05C69-965B-4F5A-B25C-F8CDBF5002ED"}]}]}], "references": [{"url": "https://github.com/osquery/osquery/commit/c3f9a3dae22d43ed3b4f6a403cbf89da4cba7c3c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/osquery/osquery/releases/tag/4.6.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/osquery/osquery/security/advisories/GHSA-4g56-2482-x7q8", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/SQLite%20Injection.md#remote-command-execution-using-sqlite-command---load_extension", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/osquery/osquery/commit/c3f9a3dae22d43ed3b4f6a403cbf89da4cba7c3c"}}