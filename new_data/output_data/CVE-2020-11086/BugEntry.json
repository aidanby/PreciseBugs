{"buggy_code": ["/**\n * WinPR: Windows Portable Runtime\n * NTLM Security Package (Compute)\n *\n * Copyright 2011-2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n\n#include <winpr/crt.h>\n#include <winpr/sam.h>\n#include <winpr/ntlm.h>\n#include <winpr/print.h>\n#include <winpr/crypto.h>\n#include <winpr/sysinfo.h>\n\n#include \"ntlm_compute.h\"\n\n#include \"../../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\n\nconst char LM_MAGIC[] = \"KGS!@#$%\";\n\nstatic const char NTLM_CLIENT_SIGN_MAGIC[] =\n    \"session key to client-to-server signing key magic constant\";\nstatic const char NTLM_SERVER_SIGN_MAGIC[] =\n    \"session key to server-to-client signing key magic constant\";\nstatic const char NTLM_CLIENT_SEAL_MAGIC[] =\n    \"session key to client-to-server sealing key magic constant\";\nstatic const char NTLM_SERVER_SEAL_MAGIC[] =\n    \"session key to server-to-client sealing key magic constant\";\n\nstatic const BYTE NTLM_NULL_BUFFER[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n/**\n * Populate VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nvoid ntlm_get_version_info(NTLM_VERSION_INFO* versionInfo)\n{\n\tOSVERSIONINFOA osVersionInfo;\n\tosVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);\n\tGetVersionExA(&osVersionInfo);\n\tversionInfo->ProductMajorVersion = (UINT8)osVersionInfo.dwMajorVersion;\n\tversionInfo->ProductMinorVersion = (UINT8)osVersionInfo.dwMinorVersion;\n\tversionInfo->ProductBuild = (UINT16)osVersionInfo.dwBuildNumber;\n\tZeroMemory(versionInfo->Reserved, sizeof(versionInfo->Reserved));\n\tversionInfo->NTLMRevisionCurrent = NTLMSSP_REVISION_W2K3;\n}\n\n/**\n * Read VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nint ntlm_read_version_info(wStream* s, NTLM_VERSION_INFO* versionInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Read_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Read_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Read(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Read_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n\treturn 1;\n}\n\n/**\n * Write VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nvoid ntlm_write_version_info(wStream* s, NTLM_VERSION_INFO* versionInfo)\n{\n\tStream_Write_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Write_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Write_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Write(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Write_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n}\n\n/**\n * Print VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nvoid ntlm_print_version_info(NTLM_VERSION_INFO* versionInfo)\n{\n\tWLog_INFO(TAG, \"VERSION ={\");\n\tWLog_INFO(TAG, \"\\tProductMajorVersion: %\" PRIu8 \"\", versionInfo->ProductMajorVersion);\n\tWLog_INFO(TAG, \"\\tProductMinorVersion: %\" PRIu8 \"\", versionInfo->ProductMinorVersion);\n\tWLog_INFO(TAG, \"\\tProductBuild: %\" PRIu16 \"\", versionInfo->ProductBuild);\n\tWLog_INFO(TAG, \"\\tReserved: 0x%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"\", versionInfo->Reserved[0],\n\t          versionInfo->Reserved[1], versionInfo->Reserved[2]);\n\tWLog_INFO(TAG, \"\\tNTLMRevisionCurrent: 0x%02\" PRIX8 \"\", versionInfo->NTLMRevisionCurrent);\n}\n\nstatic int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}\n\nstatic int ntlm_write_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tULONG length;\n\tStream_Write_UINT8(s, challenge->RespType);\n\tStream_Write_UINT8(s, challenge->HiRespType);\n\tStream_Write_UINT16(s, challenge->Reserved1);\n\tStream_Write_UINT32(s, challenge->Reserved2);\n\tStream_Write(s, challenge->Timestamp, 8);\n\tStream_Write(s, challenge->ClientChallenge, 8);\n\tStream_Write_UINT32(s, challenge->Reserved3);\n\tlength = ntlm_av_pair_list_length(challenge->AvPairs, challenge->cbAvPairs);\n\tStream_Write(s, challenge->AvPairs, length);\n\treturn 1;\n}\n\nint ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n\nint ntlm_write_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tStream_Write(s, response->Response, 16);\n\treturn ntlm_write_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n\n/**\n * Get current time, in tenths of microseconds since midnight of January 1, 1601.\n * @param[out] timestamp 64-bit little-endian timestamp\n */\n\nvoid ntlm_current_time(BYTE* timestamp)\n{\n\tFILETIME filetime;\n\tULARGE_INTEGER time64;\n\tGetSystemTimeAsFileTime(&filetime);\n\ttime64.u.LowPart = filetime.dwLowDateTime;\n\ttime64.u.HighPart = filetime.dwHighDateTime;\n\tCopyMemory(timestamp, &(time64.QuadPart), 8);\n}\n\n/**\n * Generate timestamp for AUTHENTICATE_MESSAGE.\n * @param NTLM context\n */\n\nvoid ntlm_generate_timestamp(NTLM_CONTEXT* context)\n{\n\tif (memcmp(context->ChallengeTimestamp, NTLM_NULL_BUFFER, 8) != 0)\n\t\tCopyMemory(context->Timestamp, context->ChallengeTimestamp, 8);\n\telse\n\t\tntlm_current_time(context->Timestamp);\n}\n\nstatic int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tWINPR_SAM* sam;\n\tWINPR_SAM_ENTRY* entry;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tsam = SamOpen(context->SamFile, TRUE);\n\n\tif (!sam)\n\t\treturn -1;\n\n\tentry = SamLookupUserW(\n\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2);\n\n\tif (entry)\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_DBG(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t\tSamFreeEntry(sam, entry);\n\t\tSamClose(sam);\n\t\treturn 1;\n\t}\n\n\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\t                       credentials->identity.UserLength * 2, NULL, 0);\n\n\tif (entry)\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_DBG(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t\tSamFreeEntry(sam, entry);\n\t\tSamClose(sam);\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\tSamClose(sam);\n\t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\");\n\t\treturn 0;\n\t}\n\n\tSamClose(sam);\n\treturn 1;\n}\n\nstatic int ntlm_convert_password_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tint status;\n\tint i, hn, ln;\n\tchar* PasswordHash = NULL;\n\tUINT32 PasswordHashLength = 0;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\t/* Password contains a password hash of length (PasswordLength -\n\t * SSPI_CREDENTIALS_HASH_LENGTH_OFFSET) */\n\tPasswordHashLength = credentials->identity.PasswordLength - SSPI_CREDENTIALS_HASH_LENGTH_OFFSET;\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (LPCWSTR)credentials->identity.Password,\n\t                            PasswordHashLength, &PasswordHash, 0, NULL, NULL);\n\n\tif (status <= 0)\n\t\treturn -1;\n\n\tCharUpperBuffA(PasswordHash, PasswordHashLength);\n\n\tfor (i = 0; i < 32; i += 2)\n\t{\n\t\thn = PasswordHash[i] > '9' ? PasswordHash[i] - 'A' + 10 : PasswordHash[i] - '0';\n\t\tln = PasswordHash[i + 1] > '9' ? PasswordHash[i + 1] - 'A' + 10 : PasswordHash[i + 1] - '0';\n\t\thash[i / 2] = (hn << 4) | ln;\n\t}\n\n\tfree(PasswordHash);\n\treturn 1;\n}\n\nstatic int ntlm_compute_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n#ifdef WITH_DEBUG_NTLM\n\n\tif (credentials)\n\t{\n\t\tWLog_DBG(TAG, \"Password (length = %\" PRIu32 \")\", credentials->identity.PasswordLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.Password,\n\t\t              credentials->identity.PasswordLength * 2);\n\t\tWLog_DBG(TAG, \"Username (length = %\" PRIu32 \")\", credentials->identity.UserLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.User,\n\t\t              credentials->identity.UserLength * 2);\n\t\tWLog_DBG(TAG, \"Domain (length = %\" PRIu32 \")\", credentials->identity.DomainLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.Domain,\n\t\t              credentials->identity.DomainLength * 2);\n\t}\n\telse\n\t\tWLog_DBG(TAG, \"Strange, NTLM_CONTEXT is missing valid credentials...\");\n\n\tWLog_DBG(TAG, \"Workstation (length = %\" PRIu16 \")\", context->Workstation.Length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)context->Workstation.Buffer, context->Workstation.Length);\n\tWLog_DBG(TAG, \"NTOWFv2, NTLMv2 Hash\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH);\n#endif\n\n\tif (memcmp(context->NtlmV2Hash, NTLM_NULL_BUFFER, 16) != 0)\n\t\treturn 1;\n\n\tif (!credentials)\n\t\treturn -1;\n\telse if (memcmp(context->NtlmHash, NTLM_NULL_BUFFER, 16) != 0)\n\t{\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.PasswordLength > SSPI_CREDENTIALS_HASH_LENGTH_OFFSET)\n\t{\n\t\t/* Special case for WinPR: password hash */\n\t\tif (ntlm_convert_password_hash(context, context->NtlmHash) < 0)\n\t\t\treturn -1;\n\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.Password)\n\t{\n\t\tNTOWFv2W((LPWSTR)credentials->identity.Password, credentials->identity.PasswordLength * 2,\n\t\t         (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t\t         (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2,\n\t\t         (BYTE*)hash);\n\t}\n\telse if (context->HashCallback)\n\t{\n\t\tint ret;\n\t\tSecBuffer proofValue, micValue;\n\n\t\tif (ntlm_computeProofValue(context, &proofValue) != SEC_E_OK)\n\t\t\treturn -1;\n\n\t\tif (ntlm_computeMicValue(context, &micValue) != SEC_E_OK)\n\t\t{\n\t\t\tsspi_SecBufferFree(&proofValue);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = context->HashCallback(context->HashCallbackArg, &credentials->identity, &proofValue,\n\t\t                            context->EncryptedRandomSessionKey,\n\t\t                            (&context->AUTHENTICATE_MESSAGE)->MessageIntegrityCheck,\n\t\t                            &micValue, hash);\n\t\tsspi_SecBufferFree(&proofValue);\n\t\tsspi_SecBufferFree(&micValue);\n\t\treturn ret ? 1 : -1;\n\t}\n\telse if (context->UseSamFileDatabase)\n\t{\n\t\treturn ntlm_fetch_ntlm_v2_hash(context, hash);\n\t}\n\n\treturn 1;\n}\n\nint ntlm_compute_lm_v2_response(NTLM_CONTEXT* context)\n{\n\tBYTE* response;\n\tBYTE value[WINPR_MD5_DIGEST_LENGTH];\n\n\tif (context->LmCompatibilityLevel < 2)\n\t{\n\t\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\t\treturn -1;\n\n\t\tZeroMemory(context->LmChallengeResponse.pvBuffer, 24);\n\t\treturn 1;\n\t}\n\n\t/* Compute the NTLMv2 hash */\n\n\tif (ntlm_compute_ntlm_v2_hash(context, context->NtlmV2Hash) < 0)\n\t\treturn -1;\n\n\t/* Concatenate the server and client challenges */\n\tCopyMemory(value, context->ServerChallenge, 8);\n\tCopyMemory(&value[8], context->ClientChallenge, 8);\n\n\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\treturn -1;\n\n\tresponse = (BYTE*)context->LmChallengeResponse.pvBuffer;\n\t/* Compute the HMAC-MD5 hash of the resulting value using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (void*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH, (BYTE*)value,\n\t           WINPR_MD5_DIGEST_LENGTH, (BYTE*)response, WINPR_MD5_DIGEST_LENGTH);\n\t/* Concatenate the resulting HMAC-MD5 hash and the client challenge, giving us the LMv2 response\n\t * (24 bytes) */\n\tCopyMemory(&response[16], context->ClientChallenge, 8);\n\treturn 1;\n}\n\n/**\n * Compute NTLMv2 Response.\n * NTLMv2_RESPONSE @msdn{cc236653}\n * NTLMv2 Authentication @msdn{cc236700}\n * @param NTLM context\n */\n\nint ntlm_compute_ntlm_v2_response(NTLM_CONTEXT* context)\n{\n\tBYTE* blob;\n\tSecBuffer ntlm_v2_temp = { 0 };\n\tSecBuffer ntlm_v2_temp_chal = { 0 };\n\tPSecBuffer TargetInfo = &context->ChallengeTargetInfo;\n\tint ret = -1;\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp, TargetInfo->cbBuffer + 28))\n\t\tgoto exit;\n\n\tZeroMemory(ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\tblob = (BYTE*)ntlm_v2_temp.pvBuffer;\n\n\t/* Compute the NTLMv2 hash */\n\tif (ntlm_compute_ntlm_v2_hash(context, (BYTE*)context->NtlmV2Hash) < 0)\n\t\tgoto exit;\n\n\t/* Construct temp */\n\tblob[0] = 1; /* RespType (1 byte) */\n\tblob[1] = 1; /* HighRespType (1 byte) */\n\t/* Reserved1 (2 bytes) */\n\t/* Reserved2 (4 bytes) */\n\tCopyMemory(&blob[8], context->Timestamp, 8);        /* Timestamp (8 bytes) */\n\tCopyMemory(&blob[16], context->ClientChallenge, 8); /* ClientChallenge (8 bytes) */\n\t/* Reserved3 (4 bytes) */\n\tCopyMemory(&blob[28], TargetInfo->pvBuffer, TargetInfo->cbBuffer);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NTLMv2 Response Temp Blob\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n#endif\n\n\t/* Concatenate server challenge with temp */\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp_chal, ntlm_v2_temp.cbBuffer + 8))\n\t\tgoto exit;\n\n\tblob = (BYTE*)ntlm_v2_temp_chal.pvBuffer;\n\tCopyMemory(blob, context->ServerChallenge, 8);\n\tCopyMemory(&blob[8], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           (BYTE*)ntlm_v2_temp_chal.pvBuffer, ntlm_v2_temp_chal.cbBuffer,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\n\t/* NtChallengeResponse, Concatenate NTProofStr with temp */\n\n\tif (!sspi_SecBufferAlloc(&context->NtChallengeResponse, ntlm_v2_temp.cbBuffer + 16))\n\t\tgoto exit;\n\n\tblob = (BYTE*)context->NtChallengeResponse.pvBuffer;\n\tCopyMemory(blob, context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&blob[16], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\t/* Compute SessionBaseKey, the HMAC-MD5 hash of NTProofStr using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH, context->SessionBaseKey,\n\t           WINPR_MD5_DIGEST_LENGTH);\n\tret = 1;\nexit:\n\tsspi_SecBufferFree(&ntlm_v2_temp);\n\tsspi_SecBufferFree(&ntlm_v2_temp_chal);\n\treturn ret;\n}\n\n/**\n * Encrypt the given plain text using RC4 and the given key.\n * @param key RC4 key\n * @param length text length\n * @param plaintext plain text\n * @param ciphertext cipher text\n */\n\nvoid ntlm_rc4k(BYTE* key, int length, BYTE* plaintext, BYTE* ciphertext)\n{\n\tWINPR_RC4_CTX* rc4 = winpr_RC4_New(key, 16);\n\n\tif (rc4)\n\t{\n\t\twinpr_RC4_Update(rc4, length, plaintext, ciphertext);\n\t\twinpr_RC4_Free(rc4);\n\t}\n}\n\n/**\n * Generate client challenge (8-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_client_challenge(NTLM_CONTEXT* context)\n{\n\t/* ClientChallenge is used in computation of LMv2 and NTLMv2 responses */\n\tif (memcmp(context->ClientChallenge, NTLM_NULL_BUFFER, 8) == 0)\n\t\twinpr_RAND(context->ClientChallenge, 8);\n}\n\n/**\n * Generate server challenge (8-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_server_challenge(NTLM_CONTEXT* context)\n{\n\tif (memcmp(context->ServerChallenge, NTLM_NULL_BUFFER, 8) == 0)\n\t\twinpr_RAND(context->ServerChallenge, 8);\n}\n\n/**\n * Generate KeyExchangeKey (the 128-bit SessionBaseKey).\n * @msdn{cc236710}\n * @param NTLM context\n */\n\nvoid ntlm_generate_key_exchange_key(NTLM_CONTEXT* context)\n{\n\t/* In NTLMv2, KeyExchangeKey is the 128-bit SessionBaseKey */\n\tCopyMemory(context->KeyExchangeKey, context->SessionBaseKey, 16);\n}\n\n/**\n * Generate RandomSessionKey (16-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_random_session_key(NTLM_CONTEXT* context)\n{\n\twinpr_RAND(context->RandomSessionKey, 16);\n}\n\n/**\n * Generate ExportedSessionKey (the RandomSessionKey, exported)\n * @param NTLM context\n */\n\nvoid ntlm_generate_exported_session_key(NTLM_CONTEXT* context)\n{\n\tCopyMemory(context->ExportedSessionKey, context->RandomSessionKey, 16);\n}\n\n/**\n * Encrypt RandomSessionKey (RC4-encrypted RandomSessionKey, using KeyExchangeKey as the key).\n * @param NTLM context\n */\n\nvoid ntlm_encrypt_random_session_key(NTLM_CONTEXT* context)\n{\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\tntlm_rc4k(context->KeyExchangeKey, 16, context->RandomSessionKey,\n\t          context->EncryptedRandomSessionKey);\n}\n\n/**\n * Decrypt RandomSessionKey (RC4-encrypted RandomSessionKey, using KeyExchangeKey as the key).\n * @param NTLM context\n */\n\nvoid ntlm_decrypt_random_session_key(NTLM_CONTEXT* context)\n{\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\n\t/**\n\t * \tif (NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t * \t\tSet RandomSessionKey to RC4K(KeyExchangeKey,\n\t * AUTHENTICATE_MESSAGE.EncryptedRandomSessionKey) else Set RandomSessionKey to KeyExchangeKey\n\t */\n\tif (context->NegotiateKeyExchange)\n\t\tntlm_rc4k(context->KeyExchangeKey, 16, context->EncryptedRandomSessionKey,\n\t\t          context->RandomSessionKey);\n\telse\n\t\tCopyMemory(context->RandomSessionKey, context->KeyExchangeKey, 16);\n}\n\n/**\n * Generate signing key.\n * @msdn{cc236711}\n * @param exported_session_key ExportedSessionKey\n * @param sign_magic Sign magic string\n * @param signing_key Destination signing key\n */\n\nstatic int ntlm_generate_signing_key(BYTE* exported_session_key, PSecBuffer sign_magic,\n                                     BYTE* signing_key)\n{\n\tint length;\n\tBYTE* value;\n\tlength = WINPR_MD5_DIGEST_LENGTH + sign_magic->cbBuffer;\n\tvalue = (BYTE*)malloc(length);\n\n\tif (!value)\n\t\treturn -1;\n\n\t/* Concatenate ExportedSessionKey with sign magic */\n\tCopyMemory(value, exported_session_key, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&value[WINPR_MD5_DIGEST_LENGTH], sign_magic->pvBuffer, sign_magic->cbBuffer);\n\n\tif (!winpr_Digest(WINPR_MD_MD5, value, length, signing_key, WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\tfree(value);\n\t\treturn -1;\n\t}\n\n\tfree(value);\n\treturn 1;\n}\n\n/**\n * Generate client signing key (ClientSigningKey).\n * @msdn{cc236711}\n * @param NTLM context\n */\n\nvoid ntlm_generate_client_signing_key(NTLM_CONTEXT* context)\n{\n\tSecBuffer signMagic;\n\tsignMagic.pvBuffer = (void*)NTLM_CLIENT_SIGN_MAGIC;\n\tsignMagic.cbBuffer = sizeof(NTLM_CLIENT_SIGN_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &signMagic, context->ClientSigningKey);\n}\n\n/**\n * Generate server signing key (ServerSigningKey).\n * @msdn{cc236711}\n * @param NTLM context\n */\n\nvoid ntlm_generate_server_signing_key(NTLM_CONTEXT* context)\n{\n\tSecBuffer signMagic;\n\tsignMagic.pvBuffer = (void*)NTLM_SERVER_SIGN_MAGIC;\n\tsignMagic.cbBuffer = sizeof(NTLM_SERVER_SIGN_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &signMagic, context->ServerSigningKey);\n}\n\n/**\n * Generate sealing key.\n * @msdn{cc236712}\n * @param exported_session_key ExportedSessionKey\n * @param seal_magic Seal magic string\n * @param sealing_key Destination sealing key\n */\n\nstatic int ntlm_generate_sealing_key(BYTE* exported_session_key, PSecBuffer seal_magic,\n                                     BYTE* sealing_key)\n{\n\tBYTE* p;\n\tSecBuffer buffer;\n\n\tif (!sspi_SecBufferAlloc(&buffer, WINPR_MD5_DIGEST_LENGTH + seal_magic->cbBuffer))\n\t\treturn -1;\n\n\tp = (BYTE*)buffer.pvBuffer;\n\t/* Concatenate ExportedSessionKey with seal magic */\n\tCopyMemory(p, exported_session_key, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&p[WINPR_MD5_DIGEST_LENGTH], seal_magic->pvBuffer, seal_magic->cbBuffer);\n\n\tif (!winpr_Digest(WINPR_MD_MD5, buffer.pvBuffer, buffer.cbBuffer, sealing_key,\n\t                  WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\tsspi_SecBufferFree(&buffer);\n\t\treturn -1;\n\t}\n\n\tsspi_SecBufferFree(&buffer);\n\treturn 1;\n}\n\n/**\n * Generate client sealing key (ClientSealingKey).\n * @msdn{cc236712}\n * @param NTLM context\n */\n\nvoid ntlm_generate_client_sealing_key(NTLM_CONTEXT* context)\n{\n\tSecBuffer sealMagic;\n\tsealMagic.pvBuffer = (void*)NTLM_CLIENT_SEAL_MAGIC;\n\tsealMagic.cbBuffer = sizeof(NTLM_CLIENT_SEAL_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic, context->ClientSealingKey);\n}\n\n/**\n * Generate server sealing key (ServerSealingKey).\n * @msdn{cc236712}\n * @param NTLM context\n */\n\nvoid ntlm_generate_server_sealing_key(NTLM_CONTEXT* context)\n{\n\tSecBuffer sealMagic;\n\tsealMagic.pvBuffer = (void*)NTLM_SERVER_SEAL_MAGIC;\n\tsealMagic.cbBuffer = sizeof(NTLM_SERVER_SEAL_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic, context->ServerSealingKey);\n}\n\n/**\n * Initialize RC4 stream cipher states for sealing.\n * @param NTLM context\n */\n\nvoid ntlm_init_rc4_seal_states(NTLM_CONTEXT* context)\n{\n\tif (context->server)\n\t{\n\t\tcontext->SendSigningKey = context->ServerSigningKey;\n\t\tcontext->RecvSigningKey = context->ClientSigningKey;\n\t\tcontext->SendSealingKey = context->ClientSealingKey;\n\t\tcontext->RecvSealingKey = context->ServerSealingKey;\n\t\tcontext->SendRc4Seal = winpr_RC4_New(context->ServerSealingKey, 16);\n\t\tcontext->RecvRc4Seal = winpr_RC4_New(context->ClientSealingKey, 16);\n\t}\n\telse\n\t{\n\t\tcontext->SendSigningKey = context->ClientSigningKey;\n\t\tcontext->RecvSigningKey = context->ServerSigningKey;\n\t\tcontext->SendSealingKey = context->ServerSealingKey;\n\t\tcontext->RecvSealingKey = context->ClientSealingKey;\n\t\tcontext->SendRc4Seal = winpr_RC4_New(context->ClientSealingKey, 16);\n\t\tcontext->RecvRc4Seal = winpr_RC4_New(context->ServerSealingKey, 16);\n\t}\n}\n\nvoid ntlm_compute_message_integrity_check(NTLM_CONTEXT* context, BYTE* mic, UINT32 size)\n{\n\t/*\n\t * Compute the HMAC-MD5 hash of ConcatenationOf(NEGOTIATE_MESSAGE,\n\t * CHALLENGE_MESSAGE, AUTHENTICATE_MESSAGE) using the ExportedSessionKey\n\t */\n\tWINPR_HMAC_CTX* hmac = winpr_HMAC_New();\n\tassert(size >= WINPR_MD5_DIGEST_LENGTH);\n\n\tif (!hmac)\n\t\treturn;\n\n\tif (winpr_HMAC_Init(hmac, WINPR_MD_MD5, context->ExportedSessionKey, WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->NegotiateMessage.pvBuffer,\n\t\t                  context->NegotiateMessage.cbBuffer);\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->ChallengeMessage.pvBuffer,\n\t\t                  context->ChallengeMessage.cbBuffer);\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->AuthenticateMessage.pvBuffer,\n\t\t                  context->AuthenticateMessage.cbBuffer);\n\t\twinpr_HMAC_Final(hmac, mic, WINPR_MD5_DIGEST_LENGTH);\n\t}\n\n\twinpr_HMAC_Free(hmac);\n}\n"], "fixing_code": ["/**\n * WinPR: Windows Portable Runtime\n * NTLM Security Package (Compute)\n *\n * Copyright 2011-2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n\n#include <winpr/crt.h>\n#include <winpr/sam.h>\n#include <winpr/ntlm.h>\n#include <winpr/print.h>\n#include <winpr/crypto.h>\n#include <winpr/sysinfo.h>\n\n#include \"ntlm_compute.h\"\n\n#include \"../../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\n\nconst char LM_MAGIC[] = \"KGS!@#$%\";\n\nstatic const char NTLM_CLIENT_SIGN_MAGIC[] =\n    \"session key to client-to-server signing key magic constant\";\nstatic const char NTLM_SERVER_SIGN_MAGIC[] =\n    \"session key to server-to-client signing key magic constant\";\nstatic const char NTLM_CLIENT_SEAL_MAGIC[] =\n    \"session key to client-to-server sealing key magic constant\";\nstatic const char NTLM_SERVER_SEAL_MAGIC[] =\n    \"session key to server-to-client sealing key magic constant\";\n\nstatic const BYTE NTLM_NULL_BUFFER[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n/**\n * Populate VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nvoid ntlm_get_version_info(NTLM_VERSION_INFO* versionInfo)\n{\n\tOSVERSIONINFOA osVersionInfo;\n\tosVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);\n\tGetVersionExA(&osVersionInfo);\n\tversionInfo->ProductMajorVersion = (UINT8)osVersionInfo.dwMajorVersion;\n\tversionInfo->ProductMinorVersion = (UINT8)osVersionInfo.dwMinorVersion;\n\tversionInfo->ProductBuild = (UINT16)osVersionInfo.dwBuildNumber;\n\tZeroMemory(versionInfo->Reserved, sizeof(versionInfo->Reserved));\n\tversionInfo->NTLMRevisionCurrent = NTLMSSP_REVISION_W2K3;\n}\n\n/**\n * Read VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nint ntlm_read_version_info(wStream* s, NTLM_VERSION_INFO* versionInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Read_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Read_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Read(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Read_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n\treturn 1;\n}\n\n/**\n * Write VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nvoid ntlm_write_version_info(wStream* s, NTLM_VERSION_INFO* versionInfo)\n{\n\tStream_Write_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Write_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Write_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Write(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Write_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n}\n\n/**\n * Print VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nvoid ntlm_print_version_info(NTLM_VERSION_INFO* versionInfo)\n{\n\tWLog_INFO(TAG, \"VERSION ={\");\n\tWLog_INFO(TAG, \"\\tProductMajorVersion: %\" PRIu8 \"\", versionInfo->ProductMajorVersion);\n\tWLog_INFO(TAG, \"\\tProductMinorVersion: %\" PRIu8 \"\", versionInfo->ProductMinorVersion);\n\tWLog_INFO(TAG, \"\\tProductBuild: %\" PRIu16 \"\", versionInfo->ProductBuild);\n\tWLog_INFO(TAG, \"\\tReserved: 0x%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"\", versionInfo->Reserved[0],\n\t          versionInfo->Reserved[1], versionInfo->Reserved[2]);\n\tWLog_INFO(TAG, \"\\tNTLMRevisionCurrent: 0x%02\" PRIX8 \"\", versionInfo->NTLMRevisionCurrent);\n}\n\nstatic int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tif (Stream_GetRemainingLength(s) < 28)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}\n\nstatic int ntlm_write_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tULONG length;\n\tStream_Write_UINT8(s, challenge->RespType);\n\tStream_Write_UINT8(s, challenge->HiRespType);\n\tStream_Write_UINT16(s, challenge->Reserved1);\n\tStream_Write_UINT32(s, challenge->Reserved2);\n\tStream_Write(s, challenge->Timestamp, 8);\n\tStream_Write(s, challenge->ClientChallenge, 8);\n\tStream_Write_UINT32(s, challenge->Reserved3);\n\tlength = ntlm_av_pair_list_length(challenge->AvPairs, challenge->cbAvPairs);\n\tStream_Write(s, challenge->AvPairs, length);\n\treturn 1;\n}\n\nint ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn -1;\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n\nint ntlm_write_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tStream_Write(s, response->Response, 16);\n\treturn ntlm_write_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n\n/**\n * Get current time, in tenths of microseconds since midnight of January 1, 1601.\n * @param[out] timestamp 64-bit little-endian timestamp\n */\n\nvoid ntlm_current_time(BYTE* timestamp)\n{\n\tFILETIME filetime;\n\tULARGE_INTEGER time64;\n\tGetSystemTimeAsFileTime(&filetime);\n\ttime64.u.LowPart = filetime.dwLowDateTime;\n\ttime64.u.HighPart = filetime.dwHighDateTime;\n\tCopyMemory(timestamp, &(time64.QuadPart), 8);\n}\n\n/**\n * Generate timestamp for AUTHENTICATE_MESSAGE.\n * @param NTLM context\n */\n\nvoid ntlm_generate_timestamp(NTLM_CONTEXT* context)\n{\n\tif (memcmp(context->ChallengeTimestamp, NTLM_NULL_BUFFER, 8) != 0)\n\t\tCopyMemory(context->Timestamp, context->ChallengeTimestamp, 8);\n\telse\n\t\tntlm_current_time(context->Timestamp);\n}\n\nstatic int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tWINPR_SAM* sam;\n\tWINPR_SAM_ENTRY* entry;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tsam = SamOpen(context->SamFile, TRUE);\n\n\tif (!sam)\n\t\treturn -1;\n\n\tentry = SamLookupUserW(\n\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2);\n\n\tif (entry)\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_DBG(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t\tSamFreeEntry(sam, entry);\n\t\tSamClose(sam);\n\t\treturn 1;\n\t}\n\n\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\t                       credentials->identity.UserLength * 2, NULL, 0);\n\n\tif (entry)\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_DBG(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t\tSamFreeEntry(sam, entry);\n\t\tSamClose(sam);\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\tSamClose(sam);\n\t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\");\n\t\treturn 0;\n\t}\n\n\tSamClose(sam);\n\treturn 1;\n}\n\nstatic int ntlm_convert_password_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tint status;\n\tint i, hn, ln;\n\tchar* PasswordHash = NULL;\n\tUINT32 PasswordHashLength = 0;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\t/* Password contains a password hash of length (PasswordLength -\n\t * SSPI_CREDENTIALS_HASH_LENGTH_OFFSET) */\n\tPasswordHashLength = credentials->identity.PasswordLength - SSPI_CREDENTIALS_HASH_LENGTH_OFFSET;\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (LPCWSTR)credentials->identity.Password,\n\t                            PasswordHashLength, &PasswordHash, 0, NULL, NULL);\n\n\tif (status <= 0)\n\t\treturn -1;\n\n\tCharUpperBuffA(PasswordHash, PasswordHashLength);\n\n\tfor (i = 0; i < 32; i += 2)\n\t{\n\t\thn = PasswordHash[i] > '9' ? PasswordHash[i] - 'A' + 10 : PasswordHash[i] - '0';\n\t\tln = PasswordHash[i + 1] > '9' ? PasswordHash[i + 1] - 'A' + 10 : PasswordHash[i + 1] - '0';\n\t\thash[i / 2] = (hn << 4) | ln;\n\t}\n\n\tfree(PasswordHash);\n\treturn 1;\n}\n\nstatic int ntlm_compute_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n#ifdef WITH_DEBUG_NTLM\n\n\tif (credentials)\n\t{\n\t\tWLog_DBG(TAG, \"Password (length = %\" PRIu32 \")\", credentials->identity.PasswordLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.Password,\n\t\t              credentials->identity.PasswordLength * 2);\n\t\tWLog_DBG(TAG, \"Username (length = %\" PRIu32 \")\", credentials->identity.UserLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.User,\n\t\t              credentials->identity.UserLength * 2);\n\t\tWLog_DBG(TAG, \"Domain (length = %\" PRIu32 \")\", credentials->identity.DomainLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.Domain,\n\t\t              credentials->identity.DomainLength * 2);\n\t}\n\telse\n\t\tWLog_DBG(TAG, \"Strange, NTLM_CONTEXT is missing valid credentials...\");\n\n\tWLog_DBG(TAG, \"Workstation (length = %\" PRIu16 \")\", context->Workstation.Length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)context->Workstation.Buffer, context->Workstation.Length);\n\tWLog_DBG(TAG, \"NTOWFv2, NTLMv2 Hash\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH);\n#endif\n\n\tif (memcmp(context->NtlmV2Hash, NTLM_NULL_BUFFER, 16) != 0)\n\t\treturn 1;\n\n\tif (!credentials)\n\t\treturn -1;\n\telse if (memcmp(context->NtlmHash, NTLM_NULL_BUFFER, 16) != 0)\n\t{\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.PasswordLength > SSPI_CREDENTIALS_HASH_LENGTH_OFFSET)\n\t{\n\t\t/* Special case for WinPR: password hash */\n\t\tif (ntlm_convert_password_hash(context, context->NtlmHash) < 0)\n\t\t\treturn -1;\n\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.Password)\n\t{\n\t\tNTOWFv2W((LPWSTR)credentials->identity.Password, credentials->identity.PasswordLength * 2,\n\t\t         (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t\t         (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2,\n\t\t         (BYTE*)hash);\n\t}\n\telse if (context->HashCallback)\n\t{\n\t\tint ret;\n\t\tSecBuffer proofValue, micValue;\n\n\t\tif (ntlm_computeProofValue(context, &proofValue) != SEC_E_OK)\n\t\t\treturn -1;\n\n\t\tif (ntlm_computeMicValue(context, &micValue) != SEC_E_OK)\n\t\t{\n\t\t\tsspi_SecBufferFree(&proofValue);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = context->HashCallback(context->HashCallbackArg, &credentials->identity, &proofValue,\n\t\t                            context->EncryptedRandomSessionKey,\n\t\t                            (&context->AUTHENTICATE_MESSAGE)->MessageIntegrityCheck,\n\t\t                            &micValue, hash);\n\t\tsspi_SecBufferFree(&proofValue);\n\t\tsspi_SecBufferFree(&micValue);\n\t\treturn ret ? 1 : -1;\n\t}\n\telse if (context->UseSamFileDatabase)\n\t{\n\t\treturn ntlm_fetch_ntlm_v2_hash(context, hash);\n\t}\n\n\treturn 1;\n}\n\nint ntlm_compute_lm_v2_response(NTLM_CONTEXT* context)\n{\n\tBYTE* response;\n\tBYTE value[WINPR_MD5_DIGEST_LENGTH];\n\n\tif (context->LmCompatibilityLevel < 2)\n\t{\n\t\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\t\treturn -1;\n\n\t\tZeroMemory(context->LmChallengeResponse.pvBuffer, 24);\n\t\treturn 1;\n\t}\n\n\t/* Compute the NTLMv2 hash */\n\n\tif (ntlm_compute_ntlm_v2_hash(context, context->NtlmV2Hash) < 0)\n\t\treturn -1;\n\n\t/* Concatenate the server and client challenges */\n\tCopyMemory(value, context->ServerChallenge, 8);\n\tCopyMemory(&value[8], context->ClientChallenge, 8);\n\n\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\treturn -1;\n\n\tresponse = (BYTE*)context->LmChallengeResponse.pvBuffer;\n\t/* Compute the HMAC-MD5 hash of the resulting value using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (void*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH, (BYTE*)value,\n\t           WINPR_MD5_DIGEST_LENGTH, (BYTE*)response, WINPR_MD5_DIGEST_LENGTH);\n\t/* Concatenate the resulting HMAC-MD5 hash and the client challenge, giving us the LMv2 response\n\t * (24 bytes) */\n\tCopyMemory(&response[16], context->ClientChallenge, 8);\n\treturn 1;\n}\n\n/**\n * Compute NTLMv2 Response.\n * NTLMv2_RESPONSE @msdn{cc236653}\n * NTLMv2 Authentication @msdn{cc236700}\n * @param NTLM context\n */\n\nint ntlm_compute_ntlm_v2_response(NTLM_CONTEXT* context)\n{\n\tBYTE* blob;\n\tSecBuffer ntlm_v2_temp = { 0 };\n\tSecBuffer ntlm_v2_temp_chal = { 0 };\n\tPSecBuffer TargetInfo = &context->ChallengeTargetInfo;\n\tint ret = -1;\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp, TargetInfo->cbBuffer + 28))\n\t\tgoto exit;\n\n\tZeroMemory(ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\tblob = (BYTE*)ntlm_v2_temp.pvBuffer;\n\n\t/* Compute the NTLMv2 hash */\n\tif (ntlm_compute_ntlm_v2_hash(context, (BYTE*)context->NtlmV2Hash) < 0)\n\t\tgoto exit;\n\n\t/* Construct temp */\n\tblob[0] = 1; /* RespType (1 byte) */\n\tblob[1] = 1; /* HighRespType (1 byte) */\n\t/* Reserved1 (2 bytes) */\n\t/* Reserved2 (4 bytes) */\n\tCopyMemory(&blob[8], context->Timestamp, 8);        /* Timestamp (8 bytes) */\n\tCopyMemory(&blob[16], context->ClientChallenge, 8); /* ClientChallenge (8 bytes) */\n\t/* Reserved3 (4 bytes) */\n\tCopyMemory(&blob[28], TargetInfo->pvBuffer, TargetInfo->cbBuffer);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NTLMv2 Response Temp Blob\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n#endif\n\n\t/* Concatenate server challenge with temp */\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp_chal, ntlm_v2_temp.cbBuffer + 8))\n\t\tgoto exit;\n\n\tblob = (BYTE*)ntlm_v2_temp_chal.pvBuffer;\n\tCopyMemory(blob, context->ServerChallenge, 8);\n\tCopyMemory(&blob[8], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           (BYTE*)ntlm_v2_temp_chal.pvBuffer, ntlm_v2_temp_chal.cbBuffer,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\n\t/* NtChallengeResponse, Concatenate NTProofStr with temp */\n\n\tif (!sspi_SecBufferAlloc(&context->NtChallengeResponse, ntlm_v2_temp.cbBuffer + 16))\n\t\tgoto exit;\n\n\tblob = (BYTE*)context->NtChallengeResponse.pvBuffer;\n\tCopyMemory(blob, context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&blob[16], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\t/* Compute SessionBaseKey, the HMAC-MD5 hash of NTProofStr using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH, context->SessionBaseKey,\n\t           WINPR_MD5_DIGEST_LENGTH);\n\tret = 1;\nexit:\n\tsspi_SecBufferFree(&ntlm_v2_temp);\n\tsspi_SecBufferFree(&ntlm_v2_temp_chal);\n\treturn ret;\n}\n\n/**\n * Encrypt the given plain text using RC4 and the given key.\n * @param key RC4 key\n * @param length text length\n * @param plaintext plain text\n * @param ciphertext cipher text\n */\n\nvoid ntlm_rc4k(BYTE* key, int length, BYTE* plaintext, BYTE* ciphertext)\n{\n\tWINPR_RC4_CTX* rc4 = winpr_RC4_New(key, 16);\n\n\tif (rc4)\n\t{\n\t\twinpr_RC4_Update(rc4, length, plaintext, ciphertext);\n\t\twinpr_RC4_Free(rc4);\n\t}\n}\n\n/**\n * Generate client challenge (8-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_client_challenge(NTLM_CONTEXT* context)\n{\n\t/* ClientChallenge is used in computation of LMv2 and NTLMv2 responses */\n\tif (memcmp(context->ClientChallenge, NTLM_NULL_BUFFER, 8) == 0)\n\t\twinpr_RAND(context->ClientChallenge, 8);\n}\n\n/**\n * Generate server challenge (8-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_server_challenge(NTLM_CONTEXT* context)\n{\n\tif (memcmp(context->ServerChallenge, NTLM_NULL_BUFFER, 8) == 0)\n\t\twinpr_RAND(context->ServerChallenge, 8);\n}\n\n/**\n * Generate KeyExchangeKey (the 128-bit SessionBaseKey).\n * @msdn{cc236710}\n * @param NTLM context\n */\n\nvoid ntlm_generate_key_exchange_key(NTLM_CONTEXT* context)\n{\n\t/* In NTLMv2, KeyExchangeKey is the 128-bit SessionBaseKey */\n\tCopyMemory(context->KeyExchangeKey, context->SessionBaseKey, 16);\n}\n\n/**\n * Generate RandomSessionKey (16-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_random_session_key(NTLM_CONTEXT* context)\n{\n\twinpr_RAND(context->RandomSessionKey, 16);\n}\n\n/**\n * Generate ExportedSessionKey (the RandomSessionKey, exported)\n * @param NTLM context\n */\n\nvoid ntlm_generate_exported_session_key(NTLM_CONTEXT* context)\n{\n\tCopyMemory(context->ExportedSessionKey, context->RandomSessionKey, 16);\n}\n\n/**\n * Encrypt RandomSessionKey (RC4-encrypted RandomSessionKey, using KeyExchangeKey as the key).\n * @param NTLM context\n */\n\nvoid ntlm_encrypt_random_session_key(NTLM_CONTEXT* context)\n{\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\tntlm_rc4k(context->KeyExchangeKey, 16, context->RandomSessionKey,\n\t          context->EncryptedRandomSessionKey);\n}\n\n/**\n * Decrypt RandomSessionKey (RC4-encrypted RandomSessionKey, using KeyExchangeKey as the key).\n * @param NTLM context\n */\n\nvoid ntlm_decrypt_random_session_key(NTLM_CONTEXT* context)\n{\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\n\t/**\n\t * \tif (NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t * \t\tSet RandomSessionKey to RC4K(KeyExchangeKey,\n\t * AUTHENTICATE_MESSAGE.EncryptedRandomSessionKey) else Set RandomSessionKey to KeyExchangeKey\n\t */\n\tif (context->NegotiateKeyExchange)\n\t\tntlm_rc4k(context->KeyExchangeKey, 16, context->EncryptedRandomSessionKey,\n\t\t          context->RandomSessionKey);\n\telse\n\t\tCopyMemory(context->RandomSessionKey, context->KeyExchangeKey, 16);\n}\n\n/**\n * Generate signing key.\n * @msdn{cc236711}\n * @param exported_session_key ExportedSessionKey\n * @param sign_magic Sign magic string\n * @param signing_key Destination signing key\n */\n\nstatic int ntlm_generate_signing_key(BYTE* exported_session_key, PSecBuffer sign_magic,\n                                     BYTE* signing_key)\n{\n\tint length;\n\tBYTE* value;\n\tlength = WINPR_MD5_DIGEST_LENGTH + sign_magic->cbBuffer;\n\tvalue = (BYTE*)malloc(length);\n\n\tif (!value)\n\t\treturn -1;\n\n\t/* Concatenate ExportedSessionKey with sign magic */\n\tCopyMemory(value, exported_session_key, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&value[WINPR_MD5_DIGEST_LENGTH], sign_magic->pvBuffer, sign_magic->cbBuffer);\n\n\tif (!winpr_Digest(WINPR_MD_MD5, value, length, signing_key, WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\tfree(value);\n\t\treturn -1;\n\t}\n\n\tfree(value);\n\treturn 1;\n}\n\n/**\n * Generate client signing key (ClientSigningKey).\n * @msdn{cc236711}\n * @param NTLM context\n */\n\nvoid ntlm_generate_client_signing_key(NTLM_CONTEXT* context)\n{\n\tSecBuffer signMagic;\n\tsignMagic.pvBuffer = (void*)NTLM_CLIENT_SIGN_MAGIC;\n\tsignMagic.cbBuffer = sizeof(NTLM_CLIENT_SIGN_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &signMagic, context->ClientSigningKey);\n}\n\n/**\n * Generate server signing key (ServerSigningKey).\n * @msdn{cc236711}\n * @param NTLM context\n */\n\nvoid ntlm_generate_server_signing_key(NTLM_CONTEXT* context)\n{\n\tSecBuffer signMagic;\n\tsignMagic.pvBuffer = (void*)NTLM_SERVER_SIGN_MAGIC;\n\tsignMagic.cbBuffer = sizeof(NTLM_SERVER_SIGN_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &signMagic, context->ServerSigningKey);\n}\n\n/**\n * Generate sealing key.\n * @msdn{cc236712}\n * @param exported_session_key ExportedSessionKey\n * @param seal_magic Seal magic string\n * @param sealing_key Destination sealing key\n */\n\nstatic int ntlm_generate_sealing_key(BYTE* exported_session_key, PSecBuffer seal_magic,\n                                     BYTE* sealing_key)\n{\n\tBYTE* p;\n\tSecBuffer buffer;\n\n\tif (!sspi_SecBufferAlloc(&buffer, WINPR_MD5_DIGEST_LENGTH + seal_magic->cbBuffer))\n\t\treturn -1;\n\n\tp = (BYTE*)buffer.pvBuffer;\n\t/* Concatenate ExportedSessionKey with seal magic */\n\tCopyMemory(p, exported_session_key, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&p[WINPR_MD5_DIGEST_LENGTH], seal_magic->pvBuffer, seal_magic->cbBuffer);\n\n\tif (!winpr_Digest(WINPR_MD_MD5, buffer.pvBuffer, buffer.cbBuffer, sealing_key,\n\t                  WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\tsspi_SecBufferFree(&buffer);\n\t\treturn -1;\n\t}\n\n\tsspi_SecBufferFree(&buffer);\n\treturn 1;\n}\n\n/**\n * Generate client sealing key (ClientSealingKey).\n * @msdn{cc236712}\n * @param NTLM context\n */\n\nvoid ntlm_generate_client_sealing_key(NTLM_CONTEXT* context)\n{\n\tSecBuffer sealMagic;\n\tsealMagic.pvBuffer = (void*)NTLM_CLIENT_SEAL_MAGIC;\n\tsealMagic.cbBuffer = sizeof(NTLM_CLIENT_SEAL_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic, context->ClientSealingKey);\n}\n\n/**\n * Generate server sealing key (ServerSealingKey).\n * @msdn{cc236712}\n * @param NTLM context\n */\n\nvoid ntlm_generate_server_sealing_key(NTLM_CONTEXT* context)\n{\n\tSecBuffer sealMagic;\n\tsealMagic.pvBuffer = (void*)NTLM_SERVER_SEAL_MAGIC;\n\tsealMagic.cbBuffer = sizeof(NTLM_SERVER_SEAL_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic, context->ServerSealingKey);\n}\n\n/**\n * Initialize RC4 stream cipher states for sealing.\n * @param NTLM context\n */\n\nvoid ntlm_init_rc4_seal_states(NTLM_CONTEXT* context)\n{\n\tif (context->server)\n\t{\n\t\tcontext->SendSigningKey = context->ServerSigningKey;\n\t\tcontext->RecvSigningKey = context->ClientSigningKey;\n\t\tcontext->SendSealingKey = context->ClientSealingKey;\n\t\tcontext->RecvSealingKey = context->ServerSealingKey;\n\t\tcontext->SendRc4Seal = winpr_RC4_New(context->ServerSealingKey, 16);\n\t\tcontext->RecvRc4Seal = winpr_RC4_New(context->ClientSealingKey, 16);\n\t}\n\telse\n\t{\n\t\tcontext->SendSigningKey = context->ClientSigningKey;\n\t\tcontext->RecvSigningKey = context->ServerSigningKey;\n\t\tcontext->SendSealingKey = context->ServerSealingKey;\n\t\tcontext->RecvSealingKey = context->ClientSealingKey;\n\t\tcontext->SendRc4Seal = winpr_RC4_New(context->ClientSealingKey, 16);\n\t\tcontext->RecvRc4Seal = winpr_RC4_New(context->ServerSealingKey, 16);\n\t}\n}\n\nvoid ntlm_compute_message_integrity_check(NTLM_CONTEXT* context, BYTE* mic, UINT32 size)\n{\n\t/*\n\t * Compute the HMAC-MD5 hash of ConcatenationOf(NEGOTIATE_MESSAGE,\n\t * CHALLENGE_MESSAGE, AUTHENTICATE_MESSAGE) using the ExportedSessionKey\n\t */\n\tWINPR_HMAC_CTX* hmac = winpr_HMAC_New();\n\tassert(size >= WINPR_MD5_DIGEST_LENGTH);\n\n\tif (!hmac)\n\t\treturn;\n\n\tif (winpr_HMAC_Init(hmac, WINPR_MD_MD5, context->ExportedSessionKey, WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->NegotiateMessage.pvBuffer,\n\t\t                  context->NegotiateMessage.cbBuffer);\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->ChallengeMessage.pvBuffer,\n\t\t                  context->ChallengeMessage.cbBuffer);\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->AuthenticateMessage.pvBuffer,\n\t\t                  context->AuthenticateMessage.cbBuffer);\n\t\twinpr_HMAC_Final(hmac, mic, WINPR_MD5_DIGEST_LENGTH);\n\t}\n\n\twinpr_HMAC_Free(hmac);\n}\n"], "filenames": ["winpr/libwinpr/sspi/NTLM/ntlm_compute.c"], "buggy_code_start_loc": [126], "buggy_code_end_loc": [165], "fixing_code_start_loc": [127], "fixing_code_end_loc": [171], "type": "CWE-125", "message": "In FreeRDP less than or equal to 2.0.0, there is an out-of-bound read in ntlm_read_ntlm_v2_client_challenge that reads up to 28 bytes out-of-bound to an internal structure. This has been fixed in 2.1.0.", "other": {"cve": {"id": "CVE-2020-11086", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-29T20:15:10.767", "lastModified": "2022-07-19T11:20:12.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP less than or equal to 2.0.0, there is an out-of-bound read in ntlm_read_ntlm_v2_client_challenge that reads up to 28 bytes out-of-bound to an internal structure. This has been fixed in 2.1.0."}, {"lang": "es", "value": "En FreeRDP versiones anteriores o iguales a 2.0.0, se presenta una lectura fuera de l\u00edmites en la funci\u00f3n ntlm_read_ntlm_v2_client_challenge que lee hasta 28 bytes fuera del l\u00edmite en una estructura interna. Esto ha sido corregido en la versi\u00f3n 2.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "5C5F8D57-1D22-42B4-9E08-9131F7BE8FA5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/c098f21fdaadca57ff649eee1674f6cc321a2ec4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-fg8v-w34r-c974", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/c098f21fdaadca57ff649eee1674f6cc321a2ec4"}}