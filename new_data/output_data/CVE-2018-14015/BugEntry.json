{"buggy_code": ["/* radare - LGPL - Copyright 2012-2017 - pancake, Fedor Sakharov */\n\n#define D0 if(1)\n#define D1 if(1)\n\n#include <errno.h>\n\n#define DWARF_DUMP 0\n\n#if DWARF_DUMP\n#define DBGFD stdout\n#else\n#define DBGFD NULL\n#endif\n\n#include <r_bin.h>\n#include <r_bin_dwarf.h>\n#include <r_core.h>\n\n#define STANDARD_OPERAND_COUNT_DWARF2 9\n#define STANDARD_OPERAND_COUNT_DWARF3 12\n#define R_BIN_DWARF_INFO 1\n\n#define READ(x,y) ((x + sizeof (y) < buf_end)? *((y*)x): 0); x += sizeof (y)\n\nstatic const char *dwarf_tag_name_encodings[] = {\n\t[DW_TAG_array_type] = \"DW_TAG_array_type\",\n\t[DW_TAG_class_type] = \"DW_TAG_class_type\",\n\t[DW_TAG_entry_point] = \"DW_TAG_entry_point\",\n\t[DW_TAG_enumeration_type] = \"DW_TAG_enumeration_type\",\n\t[DW_TAG_formal_parameter] = \"DW_TAG_formal_parameter\",\n\t[DW_TAG_imported_declaration] = \"DW_TAG_imported_declaration\",\n\t[DW_TAG_label] = \"DW_TAG_label\",\n\t[DW_TAG_lexical_block] = \"DW_TAG_lexical_block\",\n\t[DW_TAG_member] = \"DW_TAG_member\",\n\t[DW_TAG_pointer_type] = \"DW_TAG_pointer_type\",\n\t[DW_TAG_reference_type] = \"DW_TAG_reference_type\",\n\t[DW_TAG_compile_unit] = \"DW_TAG_compile_unit\",\n\t[DW_TAG_string_type] = \"DW_TAG_string_type\",\n\t[DW_TAG_structure_type] = \"DW_TAG_structure_type\",\n\t[DW_TAG_subroutine_type] = \"DW_TAG_subroutine_type\",\n\t[DW_TAG_typedef] = \"DW_TAG_typedef\",\n\t[DW_TAG_union_type] = \"DW_TAG_union_type\",\n\t[DW_TAG_unspecified_parameters] = \"DW_TAG_unspecified_parameters\",\n\t[DW_TAG_variant] = \"DW_TAG_variant\",\n\t[DW_TAG_common_block] = \"DW_TAG_common_block\",\n\t[DW_TAG_common_inclusion] = \"DW_TAG_common_inclusion\",\n\t[DW_TAG_inheritance] = \"DW_TAG_inheritance\",\n\t[DW_TAG_inlined_subroutine] = \"DW_TAG_inlined_subroutine\",\n\t[DW_TAG_module] = \"DW_TAG_module\",\n\t[DW_TAG_ptr_to_member_type] = \"DW_TAG_ptr_to_member_type\",\n\t[DW_TAG_set_type] = \"DW_TAG_set_type\",\n\t[DW_TAG_subrange_type] = \"DW_TAG_subrange_type\",\n\t[DW_TAG_with_stmt] = \"DW_TAG_with_stmt\",\n\t[DW_TAG_access_declaration] = \"DW_TAG_access_declaration\",\n\t[DW_TAG_base_type] = \"DW_TAG_base_type\",\n\t[DW_TAG_catch_block] = \"DW_TAG_catch_block\",\n\t[DW_TAG_const_type] = \"DW_TAG_const_type\",\n\t[DW_TAG_constant] = \"DW_TAG_constant\",\n\t[DW_TAG_enumerator] = \"DW_TAG_enumerator\",\n\t[DW_TAG_file_type] = \"DW_TAG_file_type\",\n\t[DW_TAG_friend] = \"DW_TAG_friend\",\n\t[DW_TAG_namelist] = \"DW_TAG_namelist\",\n\t[DW_TAG_namelist_item] = \"DW_TAG_namelist_item\",\n\t[DW_TAG_packed_type] = \"DW_TAG_packed_type\",\n\t[DW_TAG_subprogram] = \"DW_TAG_subprogram\",\n\t[DW_TAG_template_type_param] = \"DW_TAG_template_type_param\",\n\t[DW_TAG_template_value_param] = \"DW_TAG_template_value_param\",\n\t[DW_TAG_template_alias] = \"DW_TAG_template_alias\",\n\t[DW_TAG_thrown_type] = \"DW_TAG_thrown_type\",\n\t[DW_TAG_try_block] = \"DW_TAG_try_block\",\n\t[DW_TAG_variant_part] = \"DW_TAG_variant_part\",\n\t[DW_TAG_variable] = \"DW_TAG_variable\",\n\t[DW_TAG_volatile_type] = \"DW_TAG_volatile_type\"\n};\n\nstatic const char *dwarf_attr_encodings[] = {\n\t[DW_AT_sibling] = \"DW_AT_siblings\",\n\t[DW_AT_location] = \"DW_AT_location\",\n\t[DW_AT_name] = \"DW_AT_name\",\n\t[DW_AT_ordering] = \"DW_AT_ordering\",\n\t[DW_AT_byte_size] = \"DW_AT_byte_size\",\n\t[DW_AT_bit_size] = \"DW_AT_bit_size\",\n\t[DW_AT_stmt_list] = \"DW_AT_stmt_list\",\n\t[DW_AT_low_pc] = \"DW_AT_low_pc\",\n\t[DW_AT_high_pc] = \"DW_AT_high_pc\",\n\t[DW_AT_language] = \"DW_AT_language\",\n\t[DW_AT_discr] = \"DW_AT_discr\",\n\t[DW_AT_discr_value] = \"DW_AT_discr_value\",\n\t[DW_AT_visibility] = \"DW_AT_visibility\",\n\t[DW_AT_import] = \"DW_AT_import\",\n\t[DW_AT_string_length] = \"DW_AT_string_length\",\n\t[DW_AT_common_reference] = \"DW_AT_common_reference\",\n\t[DW_AT_comp_dir] = \"DW_AT_comp_dir\",\n\t[DW_AT_const_value] = \"DW_AT_const_value\",\n\t[DW_AT_containing_type] = \"DW_AT_containig_type\",\n\t[DW_AT_default_value] = \"DW_AT_default_value\",\n\t[DW_AT_inline] = \"DW_AT_inline\",\n\t[DW_AT_is_optional] = \"DW_AT_is_optional\",\n\t[DW_AT_lower_bound] = \"DW_AT_lower_bound\",\n\t[DW_AT_producer] = \"DW_AT_producer\",\n\t[DW_AT_prototyped] = \"DW_AT_prototyped\",\n\t[DW_AT_return_addr] = \"DW_AT_return_addr\",\n\t[DW_AT_start_scope] = \"DW_AT_start_scope\",\n\t[DW_AT_stride_size] = \"DW_AT_stride_size\",\n\t[DW_AT_upper_bound] = \"DW_AT_upper_bound\",\n\t[DW_AT_abstract_origin] = \"DW_AT_abstract_origin\",\n\t[DW_AT_accessibility] = \"DW_AT_accessibility\",\n\t[DW_AT_address_class] = \"DW_AT_address_class\",\n\t[DW_AT_artificial] = \"DW_AT_artificial\",\n\t[DW_AT_base_types] = \"DW_AT_base_types\",\n\t[DW_AT_calling_convention] = \"DW_AT_calling_convention\",\n\t[DW_AT_count] = \"DW_AT_count\",\n\t[DW_AT_data_member_location] = \"DW_AT_data_member_location\",\n\t[DW_AT_decl_column] = \"DW_AT_decl_column\",\n\t[DW_AT_decl_file] = \"DW_AT_decl_file\",\n\t[DW_AT_decl_line] = \"DW_AT_decl_line\",\n\t[DW_AT_declaration] = \"DW_AT_declaration\",\n\t[DW_AT_discr_list] = \"DW_AT_discr_list\",\n\t[DW_AT_encoding] = \"DW_AT_encoding\",\n\t[DW_AT_external] = \"DW_AT_external\",\n\t[DW_AT_frame_base] = \"DW_AT_frame_base\",\n\t[DW_AT_friend] = \"DW_AT_friend\",\n\t[DW_AT_identifier_case] = \"DW_AT_identifier_case\",\n\t[DW_AT_macro_info] = \"DW_AT_macro_info\",\n\t[DW_AT_namelist_item] = \"DW_AT_namelist_item\",\n\t[DW_AT_priority] = \"DW_AT_priority\",\n\t[DW_AT_segment] = \"DW_AT_segment\",\n\t[DW_AT_specification] = \"DW_AT_specification\",\n\t[DW_AT_static_link] = \"DW_AT_static_link\",\n\t[DW_AT_type] = \"DW_AT_type\",\n\t[DW_AT_use_location] = \"DW_AT_use_location\",\n\t[DW_AT_variable_parameter] = \"DW_AT_variable_parameter\",\n\t[DW_AT_virtuality] = \"DW_AT_virtuality\",\n\t[DW_AT_vtable_elem_location] = \"DW_AT_vtable_elem_location\"\n};\n\nstatic const char *dwarf_attr_form_encodings[] = {\n\t[DW_FORM_addr] = \"DW_FORM_addr\",\n\t[DW_FORM_block2] = \"DW_FORM_block2\",\n\t[DW_FORM_block4] = \"DW_FORM_block4\",\n\t[DW_FORM_data2] = \"DW_FORM_data2\",\n\t[DW_FORM_data4] = \"DW_FORM_data4\",\n\t[DW_FORM_data8] = \"DW_FORM_data8\",\n\t[DW_FORM_string] = \"DW_FORM_string\",\n\t[DW_FORM_block] = \"DW_FORM_block\",\n\t[DW_FORM_block1] = \"DW_FORM_block1\",\n\t[DW_FORM_data1] = \"DW_FORM_data1\",\n\t[DW_FORM_flag] = \"DW_FORM_flag\",\n\t[DW_FORM_sdata] = \"DW_FORM_sdata\",\n\t[DW_FORM_strp] = \"DW_FORM_strp\",\n\t[DW_FORM_udata] = \"DW_FORM_udata\",\n\t[DW_FORM_ref_addr] = \"DW_FORM_ref_addr\",\n\t[DW_FORM_ref1] = \"DW_FORM_ref1\",\n\t[DW_FORM_ref2] = \"DW_FORM_ref2\",\n\t[DW_FORM_ref4] = \"DW_FORM_ref4\",\n\t[DW_FORM_ref8] = \"DW_FORM_ref8\",\n\t[DW_FORM_ref_udata] = \"DW_FORM_ref_udata\",\n\t[DW_FORM_indirect] = \"DW_FORM_indirect\"\n};\n\nstatic const char *dwarf_langs[] = {\n\t[DW_LANG_C89] = \"C89\",\n\t[DW_LANG_C] = \"C\",\n\t[DW_LANG_Ada83] = \"Ada83\",\n\t[DW_LANG_C_plus_plus] = \"C++\",\n\t[DW_LANG_Cobol74] = \"Cobol74\",\n\t[DW_LANG_Cobol85] = \"Cobol85\",\n\t[DW_LANG_Fortran77] = \"Fortran77\",\n\t[DW_LANG_Fortran90] = \"Fortran90\",\n\t[DW_LANG_Pascal83] = \"Pascal83\",\n\t[DW_LANG_Modula2] = \"Modula2\",\n\t[DW_LANG_Java] = \"Java\",\n\t[DW_LANG_C99] = \"C99\",\n\t[DW_LANG_Ada95] = \"Ada95\",\n\t[DW_LANG_Fortran95] = \"Fortran95\",\n\t[DW_LANG_PLI] = \"PLI\",\n\t[DW_LANG_ObjC] = \"ObjC\",\n\t[DW_LANG_ObjC_plus_plus] = \"ObjC_plus_plus\",\n\t[DW_LANG_UPC] = \"UPC\",\n\t[DW_LANG_D] = \"D\",\n\t[DW_LANG_Python] = \"Python\",\n\t[DW_LANG_Rust] = \"Rust\",\n\t[DW_LANG_C11] = \"C11\",\n\t[DW_LANG_Swift] = \"Swift\",\n\t[DW_LANG_Julia] = \"Julia\",\n\t[DW_LANG_Dylan] = \"Dylan\",\n\t[DW_LANG_C_plus_plus_14] = \"C++14\",\n\t[DW_LANG_Fortran03] = \"Fortran03\",\n\t[DW_LANG_Fortran08] = \"Fortran08\"\n};\n\nstatic int add_sdb_include_dir(Sdb *s, const char *incl, int idx) {\n\tif (!s || !incl)\n\t\treturn false;\n\treturn sdb_array_set (s, \"includedirs\", idx, incl, 0);\n}\n\nstatic const ut8 *r_bin_dwarf_parse_lnp_header (\n\t\tRBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\t\tRBinDwarfLNPHeader *hdr, FILE *f, int mode) {\n\tint i;\n\tSdb *s;\n\tsize_t count;\n\tconst ut8 *tmp_buf = NULL;\n\n\tif (!hdr || !bf || !buf) return NULL;\n\n\thdr->unit_length.part1 = READ (buf, ut32);\n\tif (hdr->unit_length.part1 == DWARF_INIT_LEN_64) {\n\t\thdr->unit_length.part2 = READ (buf, ut32);\n\t}\n\n\ts = sdb_new (NULL, NULL, 0);\n\n\thdr->version = READ (buf, ut16);\n\n\tif (hdr->unit_length.part1 == DWARF_INIT_LEN_64) {\n\t\thdr->header_length = READ (buf, ut64);\n\t} else {\n\t\thdr->header_length = READ (buf, ut32);\n\t}\n\n\tif (buf_end-buf < 8) {\n\t\tsdb_free (s);\n\t\treturn NULL;\n\t}\n\thdr->min_inst_len = READ (buf, ut8);\n\t//hdr->max_ops_per_inst = READ (buf, ut8);\n\thdr->file_names = NULL;\n\thdr->default_is_stmt = READ (buf, ut8);\n\thdr->line_base = READ (buf, char);\n\thdr->line_range = READ (buf, ut8);\n\thdr->opcode_base = READ (buf, ut8);\n\n\tif (f) {\n\t\tfprintf (f, \"DWARF LINE HEADER\\n\");\n\t\tfprintf (f, \"  total_length: %d\\n\", hdr->unit_length.part1);\n\t\tfprintf (f, \"  version: %d\\n\", hdr->version);\n\t\tfprintf (f, \"  header_length: : %\"PFMT64d\"\\n\", hdr->header_length);\n\t\tfprintf (f, \"  mininstlen: %d\\n\", hdr->min_inst_len);\n\t\tfprintf (f, \"  is_stmt: %d\\n\", hdr->default_is_stmt);\n\t\tfprintf (f, \"  line_base: %d\\n\", hdr->line_base);\n\t\tfprintf (f, \"  line_range: %d\\n\", hdr->line_range);\n\t\tfprintf (f, \"  opcode_base: %d\\n\", hdr->opcode_base);\n\t}\n\n\tif (hdr->opcode_base>0) {\n\t\thdr->std_opcode_lengths = calloc(sizeof(ut8), hdr->opcode_base);\n\n\t\tfor (i = 1; i <= hdr->opcode_base - 1; i++) {\n\t\t\tif (buf+2>buf_end) break;\n\t\t\thdr->std_opcode_lengths[i] = READ (buf, ut8);\n\t\t\tif (f) {\n\t\t\t\tfprintf (f, \" op %d %d\\n\", i, hdr->std_opcode_lengths[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thdr->std_opcode_lengths = NULL;\n\t}\n\n\ti = 0;\n\twhile (buf+1 < buf_end) {\n\t\tint maxlen = R_MIN ((size_t)(buf_end-buf)-1, 0xfff);\n\t\tint len = r_str_nlen ((const char*)buf, maxlen);\n\t\tchar *str = r_str_ndup ((const char *)buf, len);\n\t\tif (len<1 || len >= 0xfff) {\n\t\t\tbuf += 1;\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (*str != '/' && *str != '.') {\n\t\t\t// no more paths in here\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (f) {\n\t\t\tfprintf (f, \"INCLUDEDIR (%s)\\n\", str);\n\t\t}\n\t\tadd_sdb_include_dir (s, str, i);\n\t\tfree (str);\n\t\ti++;\n\t\tbuf += len + 1;\n\t}\n\n\ttmp_buf = buf;\n\tcount = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (buf+1<buf_end) {\n\t\t\tconst char *filename = (const char *)buf;\n\t\t\tint maxlen = R_MIN ((size_t)(buf_end-buf-1), 0xfff);\n\t\t\tut64 id_idx, mod_time, file_len;\n\t\t\tsize_t namelen, len = r_str_nlen (filename, maxlen);\n\n\t\t\tif (!len) {\n\t\t\t\tbuf++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += len + 1;\n\t\t\tif (buf>=buf_end) { buf = NULL; goto beach; }\n\t\t\tbuf = r_uleb128 (buf, buf_end-buf, &id_idx);\n\t\t\tif (buf>=buf_end) { buf = NULL; goto beach; }\n\t\t\tbuf = r_uleb128 (buf, buf_end-buf, &mod_time);\n\t\t\tif (buf>=buf_end) { buf = NULL; goto beach; }\n\t\t\tbuf = r_uleb128 (buf, buf_end-buf, &file_len);\n\t\t\tif (buf>=buf_end) { buf = NULL; goto beach; }\n\n\t\t\tif (i) {\n\t\t\t\tchar *include_dir = NULL, *comp_dir = NULL;\n\t\t\t\tchar *allocated_id = NULL;\n\t\t\t\tif (id_idx > 0) {\n\t\t\t\t\tinclude_dir = sdb_array_get (s, \"includedirs\", id_idx - 1, 0);\n\t\t\t\t\tif (include_dir && include_dir[0] != '/') {\n\t\t\t\t\t\tcomp_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\t\tif (comp_dir) {\n\t\t\t\t\t\t\tallocated_id = calloc (1, strlen (comp_dir) +\n\t\t\t\t\t\t\t\t\tstrlen (include_dir) + 8);\n\t\t\t\t\t\t\tsnprintf (allocated_id, strlen (comp_dir) + strlen (include_dir) + 8,\n\t\t\t\t\t\t\t\t\t\"%s/%s/\", comp_dir, include_dir);\n\t\t\t\t\t\t\tinclude_dir = allocated_id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinclude_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\tif (!include_dir)\n\t\t\t\t\t\tinclude_dir = \"./\";\n\t\t\t\t}\n\n\t\t\t\tnamelen = len + (include_dir?strlen (include_dir):0) + 8;\n\n\t\t\t\tif (hdr->file_names) {\n\t\t\t\t\thdr->file_names[count].name = calloc (sizeof(char), namelen);\n\t\t\t\t\tsnprintf (hdr->file_names[count].name, namelen - 1,\n\t\t\t\t\t\t\"%s/%s\", include_dir? include_dir : \"\", filename);\n\t\t\t\t\thdr->file_names[count].name[namelen - 1] = '\\0';\n\t\t\t\t\tfree (allocated_id);\n\t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n\t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n\t\t\t\t\thdr->file_names[count].file_len = file_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (f && i) {\n\t\t\t\tfprintf (f, \"FILE (%s)\\n\", filename);\n\t\t\t\tfprintf (f, \"| dir idx %\"PFMT64d\"\\n\", id_idx);\n\t\t\t\tfprintf (f, \"| lastmod %\"PFMT64d\"\\n\", mod_time);\n\t\t\t\tfprintf (f, \"| filelen %\"PFMT64d\"\\n\", file_len);\n\t\t\t}\n\t\t}\n\t\tif (i == 0) {\n\t\t\tif (count>0) {\n\t\t\t\thdr->file_names = calloc(sizeof(file_entry), count);\n\t\t\t} else {\n\t\t\t\thdr->file_names = NULL;\n\t\t\t}\n\t\t\thdr->file_names_count = count;\n\t\t\tbuf = tmp_buf;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\nbeach:\n\tsdb_free (s);\n\n\treturn buf;\n}\n\nstatic inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, FILE *f, int mode) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tif (!s || !file)\n\t\treturn;\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\t// includedirs and properly check full paths\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tif (!f) {\n\t\t\tf = stdout;\n\t\t}\n\t\tfprintf (f, \"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\t/* THIS IS TOO SLOW */\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, offset, 16);\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}\n\nstatic const ut8* r_bin_dwarf_parse_ext_opcode(const RBin *a, const ut8 *obuf,\n\t\tsize_t len, const RBinDwarfLNPHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs, FILE *f, int mode) {\n\t// XXX - list is an unused parameter.\n\tconst ut8 *buf;\n\tconst ut8 *buf_end;\n\tut8 opcode;\n\tut64 addr;\n\tbuf = obuf;\n\tst64 op_len;\n\tRBinFile *binfile = a ? a->cur : NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\tut32 addr_size = o && o->info && o->info->bits ? o->info->bits / 8 : 4;\n\tconst char *filename;\n\n\tif (!binfile || !obuf || !hdr || !regs) return NULL;\n\n\tbuf = r_leb128 (buf, &op_len);\n\tbuf_end = buf+len;\n\topcode = *buf++;\n\n\tif (f) {\n\t\tfprintf (f, \"Extended opcode %d: \", opcode);\n\t}\n\n\tswitch (opcode) {\n\tcase DW_LNE_end_sequence:\n\t\tregs->end_sequence = DWARF_TRUE;\n\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline(binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\t\thdr->file_names[fnidx].name, regs->line, f, mode);\n\t\t\t}\n\t\t}\n\n\t\tif (f) {\n\t\t\tfprintf (f, \"End of Sequence\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_address:\n\t\tif (addr_size == 8) {\n\t\t\taddr = READ (buf, ut64);\n\t\t} else {\n\t\t\taddr = READ (buf, ut32);\n\t\t}\n\n\t\tregs->address = addr;\n\n\t\tif (f) {\n\t\t\tfprintf (f, \"set Address to 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_define_file:\n\t\tfilename = (const char*)buf;\n\n\t\tif (f) {\n\t\t\tfprintf (f, \"define_file\\n\");\n\t\t\tfprintf (f, \"filename %s\\n\", filename);\n\t\t}\n\n\t\tbuf += (strlen (filename) + 1);\n\t\tut64 dir_idx;\n\t\tif (buf+1 < buf_end)\n\t\t\tbuf = r_uleb128 (buf, ST32_MAX, &dir_idx);\n\t\tbreak;\n\tcase DW_LNE_set_discriminator:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tif (f) {\n\t\t\tfprintf (f, \"set Discriminator to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->discriminator = addr;\n\t\tbreak;\n\tdefault:\n\t\tif (f) {\n\t\t\tfprintf (f, \"Unexpeced opcode %d\\n\", opcode);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn buf;\n}\n\nstatic const ut8* r_bin_dwarf_parse_spec_opcode(\n\t\tconst RBin *a, const ut8 *obuf, size_t len,\n\t\tconst RBinDwarfLNPHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs,\n\t\tut8 opcode, FILE *f, int mode) {\n\t// XXX - list is not used\n\tconst ut8 *buf = obuf;\n\tut8 adj_opcode = 0;\n\tut64 advance_adr;\n\tRBinFile *binfile = a ? a->cur : NULL;\n\n\tif (!obuf || !hdr || !regs) {\n\t\treturn NULL;\n\t}\n\n\tadj_opcode = opcode - hdr->opcode_base;\n\tif (!hdr->line_range) {\n\t\t// line line-range information. move away\n\t\treturn NULL;\n\t}\n\tadvance_adr = adj_opcode / hdr->line_range;\n\tregs->address += advance_adr;\n\tregs->line += hdr->line_base + (adj_opcode % hdr->line_range);\n\tif (f) {\n\t\tfprintf (f, \"Special opcode %d: \", adj_opcode);\n\t\tfprintf (f, \"advance Address by %\"PFMT64d\" to %\"PFMT64x\" and Line by %d to %\"PFMT64d\"\\n\",\n\t\t\tadvance_adr, regs->address, hdr->line_base +\n\t\t\t(adj_opcode % hdr->line_range), regs->line);\n\t}\n\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\tint idx = regs->file -1;\n\t\tif (idx >= 0 && idx < hdr->file_names_count) {\n\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\thdr->file_names[idx].name,\n\t\t\t\t\tregs->line, f, mode);\n\t\t}\n\t}\n\tregs->basic_block = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->discriminator = 0;\n\n\treturn buf;\n}\n\nstatic const ut8* r_bin_dwarf_parse_std_opcode(\n\t\tconst RBin *a, const ut8 *obuf, size_t len,\n\t\tconst RBinDwarfLNPHeader *hdr, RBinDwarfSMRegisters *regs,\n\t\tut8 opcode, FILE *f, int mode) {\n\tconst ut8* buf = obuf;\n\tconst ut8* buf_end = obuf + len;\n\tut64 addr = 0LL;\n\tst64 sbuf;\n\tut8 adj_opcode;\n\tut64 op_advance;\n\tut16 operand;\n\tRBinFile *binfile = a ? a->cur : NULL;\n\n\tif (!binfile || !hdr || !regs || !obuf) {\n\t\treturn NULL;\n\t}\n\tswitch (opcode) {\n\tcase DW_LNS_copy:\n\t\tif (f) {\n\t\t\tfprintf (f, \"Copy\\n\");\n\t\t}\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo,\n\t\t\t\t\tregs->address,\n\t\t\t\t\thdr->file_names[fnidx].name,\n\t\t\t\t\tregs->line, f, mode);\n\t\t\t}\n\t\t}\n\t\tregs->basic_block = DWARF_FALSE;\n\t\tbreak;\n\tcase DW_LNS_advance_pc:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tregs->address += addr * hdr->min_inst_len;\n\t\tif (f) {\n\t\t\tfprintf (f, \"Advance PC by %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\taddr * hdr->min_inst_len, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_advance_line:\n\t\tbuf = r_leb128(buf, &sbuf);\n\t\tregs->line += sbuf;\n\t\tif (f) {\n\t\t\tfprintf (f, \"Advance line by %\"PFMT64d\", to %\"PFMT64d\"\\n\", sbuf, regs->line);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_file:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tif (f) {\n\t\t\tfprintf (f, \"Set file to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->file = addr;\n\t\tbreak;\n\tcase DW_LNS_set_column:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tif (f) {\n\t\t\tfprintf (f, \"Set column to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->column = addr;\n\t\tbreak;\n\tcase DW_LNS_negate_stmt:\n\t\tregs->is_stmt = regs->is_stmt ? DWARF_FALSE : DWARF_TRUE;\n\t\tif (f) {\n\t\t\tfprintf (f, \"Set is_stmt to %d\\n\", regs->is_stmt);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_basic_block:\n\t\tif (f) {\n\t\t\tfprintf (f, \"set_basic_block\\n\");\n\t\t}\n\t\tregs->basic_block = DWARF_TRUE;\n\t\tbreak;\n\tcase DW_LNS_const_add_pc:\n\t\tadj_opcode = 255 - hdr->opcode_base;\n\t\tif (hdr->line_range > 0) {\n\t\t\top_advance = adj_opcode / hdr->line_range;\n\t\t} else {\n\t\t\top_advance = 0;\n\t\t}\n\t\tregs->address += op_advance;\n\t\tif (f) {\n\t\t\tfprintf (f, \"Advance PC by constant %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\top_advance, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_fixed_advance_pc:\n\t\toperand = READ (buf, ut16);\n\t\tregs->address += operand;\n\t\tif (f) {\n\t\t\tfprintf (f,\"Fixed advance pc to %\"PFMT64d\"\\n\", regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_prologue_end:\n\t\tregs->prologue_end = ~0;\n\t\tif (f) {\n\t\t\tfprintf (f, \"set_prologue_end\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_epilogue_begin:\n\t\tregs->epilogue_begin = ~0;\n\t\tif (f) {\n\t\t\tfprintf (f, \"set_epilogue_begin\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_isa:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tregs->isa = addr;\n\t\tif (f) {\n\t\t\tfprintf (f, \"set_isa\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (f) {\n\t\t\tfprintf (f, \"Unexpected opcode\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\nstatic const ut8* r_bin_dwarf_parse_opcodes(const RBin *a, const ut8 *obuf,\n\t\tsize_t len, const RBinDwarfLNPHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs, FILE *f, int mode) {\n\tconst ut8 *buf, *buf_end;\n\tut8 opcode, ext_opcode;\n\n\tif (!a || !obuf || len < 8) {\n\t\treturn NULL;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\n\twhile (buf && buf + 1 < buf_end) {\n\t\topcode = *buf++;\n\t\tlen--;\n\t\tif (!opcode) {\n\t\t\text_opcode = *buf;\n\t\t\tbuf = r_bin_dwarf_parse_ext_opcode (a, buf, len, hdr, regs, f, mode);\n\t\t\tif (ext_opcode == DW_LNE_end_sequence) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (opcode >= hdr->opcode_base) {\n\t\t\tbuf = r_bin_dwarf_parse_spec_opcode (a, buf, len, hdr, regs, opcode, f, mode);\n\t\t} else {\n\t\t\tbuf = r_bin_dwarf_parse_std_opcode (a, buf, len, hdr, regs, opcode, f, mode);\n\t\t}\n\t\tlen = (int)(buf_end - buf);\n\t}\n\treturn buf;\n}\n\nstatic void r_bin_dwarf_set_regs_default (const RBinDwarfLNPHeader *hdr, RBinDwarfSMRegisters *regs) {\n\tregs->address = 0;\n\tregs->file = 1;\n\tregs->line = 1;\n\tregs->column = 0;\n\tregs->is_stmt = hdr->default_is_stmt;\n\tregs->basic_block = DWARF_FALSE;\n\tregs->end_sequence = DWARF_FALSE;\n}\n\nR_API int r_bin_dwarf_parse_line_raw2(const RBin *a, const ut8 *obuf,\n\t\t\t\t       size_t len, int mode) {\n\tRBinDwarfLNPHeader hdr = {{0}};\n\tconst ut8 *buf = NULL, *buf_tmp = NULL, *buf_end = NULL;\n\tRBinDwarfSMRegisters regs;\n\tint tmplen;\n\tFILE *f = NULL;\n\tRBinFile *binfile = a ? a->cur : NULL;\n\n\tif (!binfile || !obuf) {\n\t\treturn false;\n\t}\n\tif (mode == R_CORE_BIN_PRINT) {\n\t\tf = stdout;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\twhile (buf + 1 < buf_end) {\n\t\tbuf_tmp = buf;\n\t\tbuf = r_bin_dwarf_parse_lnp_header (a->cur, buf, buf_end, &hdr, f, mode);\n\t\tif (!buf) {\n\t\t\treturn false;\n\t\t}\n\t\tr_bin_dwarf_set_regs_default (&hdr, &regs);\n\t\ttmplen = (int)(buf_end - buf);\n\t\ttmplen = R_MIN (tmplen, 4 + hdr.unit_length.part1);\n\t\tif (tmplen < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!r_bin_dwarf_parse_opcodes (a, buf, tmplen, &hdr, &regs, f, mode)) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf = buf_tmp + tmplen;\n\t\tlen = (int)(buf_end - buf);\n\t}\n\treturn true;\n}\n\n#define READ_BUF(x,y) if (idx+sizeof(y)>=len) { return false;} \\\n\tx=*(y*)buf; idx+=sizeof(y);buf+=sizeof(y)\n\nR_API int r_bin_dwarf_parse_aranges_raw(const ut8 *obuf, int len, FILE *f) {\n\tut32 length, offset;\n\tut16 version;\n\tut32 debug_info_offset;\n\tut8 address_size, segment_size;\n\tconst ut8 *buf = obuf;\n\tint idx = 0;\n\n\tif (!buf || len< 4) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF (length, ut32);\n\tif (f) {\n\t\tprintf(\"parse_aranges\\n\");\n\t\tprintf(\"length 0x%x\\n\", length);\n\t}\n\n\tif (idx+12>=len)\n\t\treturn false;\n\n\tREAD_BUF (version, ut16);\n\tif (f) {\n\t\tprintf(\"Version %d\\n\", version);\n\t}\n\n\tREAD_BUF (debug_info_offset, ut32);\n\tif (f) {\n\t\tfprintf (f, \"Debug info offset %d\\n\", debug_info_offset);\n\t}\n\n\tREAD_BUF (address_size, ut8);\n\tif (f) {\n\t\tfprintf (f, \"address size %d\\n\", (int)address_size);\n\t}\n\n\tREAD_BUF (segment_size, ut8);\n\tif (f) {\n\t\tfprintf (f, \"segment size %d\\n\", (int)segment_size);\n\t}\n\n\toffset = segment_size + address_size * 2;\n\n\tif (offset) {\n\t\tut64 n = (((ut64) (size_t)buf / offset) + 1) * offset - ((ut64)(size_t)buf);\n\t\tif (idx+n>=len) {\n\t\t\treturn false;\n\t\t}\n\t\tbuf += n;\n\t\tidx += n;\n\t}\n\n\twhile ((buf - obuf) < len) {\n\t\tut64 adr, length;\n\t\tif ((idx+8)>=len) {\n\t\t\tbreak;\n\t\t}\n\t\tREAD_BUF (adr, ut64);\n\t\tREAD_BUF (length, ut64);\n\t\tif (f) printf(\"length 0x%\"PFMT64x\" address 0x%\"PFMT64x\"\\n\", length, adr);\n\t}\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_init_debug_info(RBinDwarfDebugInfo *inf) {\n\tif (!inf) {\n\t\treturn -1;\n\t}\n\tinf->comp_units = calloc (sizeof (RBinDwarfCompUnit), DEBUG_INFO_CAPACITY);\n\n\t// XXX - should we be using error codes?\n\tif (!inf->comp_units) {\n\t\treturn -ENOMEM;\n\t}\n\n\tinf->capacity = DEBUG_INFO_CAPACITY;\n\tinf->length = 0;\n\n\treturn true;\n}\n\nstatic int r_bin_dwarf_init_die(RBinDwarfDIE *die) {\n\tif (!die) {\n\t\treturn -EINVAL;\n\t}\n\tdie->attr_values = calloc (sizeof (RBinDwarfAttrValue), 8);\n\tif (!die->attr_values) {\n\t\treturn -ENOMEM;\n\t}\n\tdie->capacity = 8;\n\tdie->length = 0;\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_expand_die(RBinDwarfDIE* die) {\n\tRBinDwarfAttrValue *tmp = NULL;\n\tif (!die || die->capacity == 0) {\n\t\treturn -EINVAL;\n\t}\n\tif (die->capacity != die->length) {\n\t\treturn -EINVAL;\n\t}\n\ttmp = (RBinDwarfAttrValue*)realloc (die->attr_values,\n\t\t\tdie->capacity * 2 * sizeof (RBinDwarfAttrValue));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ((ut8*)tmp + die->capacity, 0, die->capacity);\n\tdie->attr_values = tmp;\n\tdie->capacity *= 2;\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_init_comp_unit(RBinDwarfCompUnit *cu) {\n\tif (!cu) {\n\t\treturn -EINVAL;\n\t}\n\tcu->dies = calloc (sizeof (RBinDwarfDIE), COMP_UNIT_CAPACITY);\n\tif (!cu->dies) {\n\t\treturn -ENOMEM;\n\t}\n\tcu->capacity = COMP_UNIT_CAPACITY;\n\tcu->length = 0;\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_expand_cu(RBinDwarfCompUnit *cu) {\n\tRBinDwarfDIE *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->length) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfDIE*)realloc(cu->dies,\n\t\t\tcu->capacity * 2 * sizeof(RBinDwarfDIE));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8*)tmp + cu->capacity, 0, cu->capacity);\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_init_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tif (!ad) {\n\t\treturn -EINVAL;\n\t}\n\tad->specs = calloc (sizeof( RBinDwarfAttrSpec), ABBREV_DECL_CAP);\n\n\tif (!ad->specs) {\n\t\treturn -ENOMEM;\n\t}\n\n\tad->capacity = ABBREV_DECL_CAP;\n\tad->length = 0;\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_expand_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tRBinDwarfAttrSpec *tmp;\n\n\tif (!ad || !ad->capacity || ad->capacity != ad->length) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAttrSpec*)realloc (ad->specs,\n\t\t\tad->capacity * 2 * sizeof (RBinDwarfAttrSpec));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8*)tmp + ad->capacity, 0, ad->capacity);\n\tad->specs = tmp;\n\tad->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_init_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tif (!da) {\n\t\treturn -EINVAL;\n\t}\n\tda->decls = calloc (sizeof (RBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n\tif (!da->decls) {\n\t\treturn -ENOMEM;\n\t}\n\tda->capacity = DEBUG_ABBREV_CAP;\n\tda->length = 0;\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_expand_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tRBinDwarfAbbrevDecl *tmp;\n\n\tif (!da || da->capacity == 0 || da->capacity != da->length) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAbbrevDecl*)realloc (da->decls,\n\t\t\tda->capacity * 2 * sizeof (RBinDwarfAbbrevDecl));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ((ut8*)tmp + da->capacity, 0, da->capacity);\n\n\tda->decls = tmp;\n\tda->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic void dump_r_bin_dwarf_debug_abbrev(FILE *f, RBinDwarfDebugAbbrev *da) {\n\tsize_t i, j;\n\tut64 attr_name, attr_form;\n\n\tif (!f || !da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->length; i++) {\n\t\tint declstag = da->decls[i].tag;\n\t\tfprintf (f, \"Abbreviation Code %\"PFMT64d\" \", da->decls[i].code);\n\t\tif (declstag>=0 && declstag < DW_TAG_LAST) {\n\t\t\tfprintf (f, \"Tag %s \", dwarf_tag_name_encodings[declstag]);\n\t\t}\n\t\tfprintf (f, \"[%s]\\n\", da->decls[i].has_children ?\n\t\t\t\t\"has children\" : \"no children\");\n\t\tfprintf (f, \"Offset 0x%\"PFMT64x\"\\n\", da->decls[i].offset);\n\n\t\tif (da->decls[i].specs) {\n\t\t\tfor (j = 0; j < da->decls[i].length; j++) {\n\t\t\t\tattr_name = da->decls[i].specs[j].attr_name;\n\t\t\t\tattr_form = da->decls[i].specs[j].attr_form;\n\t\t\t\tif (attr_name && attr_form &&\n\t\t\t\t\tattr_name <= DW_AT_vtable_elem_location &&\n\t\t\t\t\tattr_form <= DW_FORM_indirect) {\n\t\t\t\t\tfprintf (f, \"    %s %s\\n\",\n\t\t\t\t\t\t\tdwarf_attr_encodings[attr_name],\n\t\t\t\t\t\t\tdwarf_attr_form_encodings[attr_form]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_dwarf_free_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tsize_t i;\n\tif (!da) return;\n\tfor (i = 0; i < da->length; i++) {\n\t\tR_FREE (da->decls[i].specs);\n\t}\n\tR_FREE (da->decls);\n}\n\nstatic void r_bin_dwarf_free_attr_value(RBinDwarfAttrValue *val) {\n\tif (!val) {\n\t\treturn;\n\t}\n\tswitch (val->form) {\n\tcase DW_FORM_strp:\n\tcase DW_FORM_string:\n\t\tR_FREE (val->encoding.str_struct.string);\n\t\tbreak;\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tR_FREE (val->encoding.block.data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t};\n}\n\nstatic void r_bin_dwarf_free_die(RBinDwarfDIE *die) {\n\tsize_t i;\n\tif (!die) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < die->length; i++) {\n\t\tr_bin_dwarf_free_attr_value (&die->attr_values[i]);\n\t}\n\tR_FREE (die->attr_values);\n}\n\nstatic void r_bin_dwarf_free_comp_unit(RBinDwarfCompUnit *cu) {\n\tsize_t i;\n\tif (!cu) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < cu->length; i++) {\n\t\tif (cu->dies) {\n\t\t\tr_bin_dwarf_free_die (&cu->dies[i]);\n\t\t}\n\t}\n\tR_FREE (cu->dies);\n}\n\nstatic void r_bin_dwarf_free_debug_info (RBinDwarfDebugInfo *inf) {\n\tsize_t i;\n\tif (!inf) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->length; i++) {\n\t\tr_bin_dwarf_free_comp_unit (&inf->comp_units[i]);\n\t}\n\tR_FREE (inf->comp_units);\n}\n\nstatic void r_bin_dwarf_dump_attr_value(const RBinDwarfAttrValue *val, FILE *f) {\n\tsize_t i;\n\tif (!val || !f) {\n\t\treturn;\n\t}\n\tswitch (val->form) {\n\tcase DW_FORM_addr:\n\t\tfprintf (f, \"0x%\"PFMT64x\"\", val->encoding.address);\n\t\tbreak;\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tfprintf (f, \"%\"PFMT64u\" byte block:\", val->encoding.block.length);\n\t\tfor (i = 0; i < val->encoding.block.length; i++) {\n\t\t\tfprintf (f, \"%02x\", val->encoding.block.data[i]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\tcase DW_FORM_data2:\n\tcase DW_FORM_data4:\n\tcase DW_FORM_data8:\n\t\tfprintf (f, \"%\"PFMT64u\"\", val->encoding.data);\n\t\tif (val->name == DW_AT_language) {\n\t\t\tfprintf (f, \"   (%s)\", dwarf_langs[val->encoding.data]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_strp:\n\t\tfprintf (f, \"(indirect string, offset: 0x%\"PFMT64x\"): \",\n\t\t\t\tval->encoding.str_struct.offset);\n\tcase DW_FORM_string:\n\t\tif (val->encoding.str_struct.string) {\n\t\t\tfprintf (f, \"%s\", val->encoding.str_struct.string);\n\t\t} else {\n\t\t\tfprintf (f, \"No string found\");\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tfprintf (f, \"%u\", val->encoding.flag);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tfprintf (f, \"%\"PFMT64d\"\", val->encoding.sdata);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tfprintf (f, \"%\"PFMT64u\"\", val->encoding.data);\n\t\tbreak;\n\tcase DW_FORM_ref_addr:\n\t\tfprintf (f, \"<0x%\"PFMT64x\">\", val->encoding.reference);\n\t\tbreak;\n\tcase DW_FORM_ref1:\n\tcase DW_FORM_ref2:\n\tcase DW_FORM_ref4:\n\tcase DW_FORM_ref8:\n\t\tfprintf (f, \"<0x%\"PFMT64x\">\", val->encoding.reference);\n\t\tbreak;\n\tdefault:\n\t\tfprintf (f, \"Unknown attr value form %\"PFMT64d\"\\n\", val->form);\n\t};\n}\n\nstatic void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {\n\tsize_t i, j, k;\n\tRBinDwarfDIE *dies;\n\tRBinDwarfAttrValue *values;\n\tif (!inf || !f) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < inf->length; i++) {\n\t\tfprintf (f, \"  Compilation Unit @ offset 0x%\"PFMT64x\":\\n\", inf->comp_units [i].offset);\n\t\tfprintf (f, \"   Length:        0x%x\\n\", inf->comp_units [i].hdr.length);\n\t\tfprintf (f, \"   Version:       %d\\n\", inf->comp_units [i].hdr.version);\n\t\tfprintf (f, \"   Abbrev Offset: 0x%x\\n\", inf->comp_units [i].hdr.abbrev_offset);\n\t\tfprintf (f, \"   Pointer Size:  %d\\n\", inf->comp_units [i].hdr.pointer_size);\n\n\t\tdies = inf->comp_units[i].dies;\n\n\t\tfor (j = 0; j < inf->comp_units[i].length; j++) {\n\t\t\tfprintf (f, \"    Abbrev Number: %\"PFMT64u\" \", dies[j].abbrev_code);\n\n\t\t\tif (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&\n\t\t\t\t       dwarf_tag_name_encodings[dies[j].tag]) {\n\t\t\t\tfprintf (f, \"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tfprintf (f, \"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\n\t\t\tfor (k = 0; k < dies[j].length; k++) {\n\t\t\t\tif (!values[k].name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (values[k].name < DW_AT_vtable_elem_location &&\n\t\t\t\t\t\tdwarf_attr_encodings[values[k].name]) {\n\t\t\t\t\tfprintf (f, \"     %-18s : \", dwarf_attr_encodings[values[k].name]);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf (f, \"     TODO\\t\");\n\t\t\t\t}\n\t\t\t\tr_bin_dwarf_dump_attr_value (&values[k], f);\n\t\t\t\tfprintf (f, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrSpec *spec, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (!spec || !value || !hdr || !obuf || obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\tvalue->form = spec->attr_form;\n\tvalue->name = spec->attr_name;\n\tvalue->encoding.block.data = NULL;\n\tvalue->encoding.str_struct.string = NULL;\n\tvalue->encoding.str_struct.offset = 0;\n\n\tswitch (spec->attr_form) {\n\tcase DW_FORM_addr:\n\t\tswitch (hdr->pointer_size) {\n\t\tcase 1:\n\t\t\tvalue->encoding.address = READ (buf, ut8);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->encoding.address = READ (buf, ut16);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->encoding.address = READ (buf, ut32);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->encoding.address = READ (buf, ut64);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->pointer_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->encoding.block.length = READ (buf, ut16);\n\t\tif (value->encoding.block.length > 0) {\n\t\t\tvalue->encoding.block.data = calloc (sizeof(ut8), value->encoding.block.length);\n\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n\t\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->encoding.block.length = READ (buf, ut32);\n\t\tif (value->encoding.block.length > 0) {\n\t\t\tut8 *data = calloc (sizeof (ut8), value->encoding.block.length);\n\t\t\tif (data) {\n\t\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n\t\t\t\t\tdata[j] = READ (buf, ut8);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue->encoding.block.data = data;\n\t\t}\n\t\tbreak;\n#if 0\n// This causes segfaults to happen\n\tcase DW_FORM_data2:\n\t\tvalue->encoding.data = READ (buf, ut16);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->encoding.data = READ (buf, ut32);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->encoding.data = READ (buf, ut64);\n\t\tbreak;\n#endif\n\tcase DW_FORM_string:\n\t\tvalue->encoding.str_struct.string = *buf? strdup ((const char*)buf) : NULL;\n\t\tbuf += (strlen ((const char*)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->encoding.block.length);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length);\n\t\tif (value->encoding.block.data) {\n\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n\t\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->encoding.block.length = READ (buf, ut8);\n\t\tvalue->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length + 1);\n\t\tif (value->encoding.block.data) {\n\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n\t\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->encoding.flag = READ (buf, ut8);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tbuf = r_leb128 (buf, &value->encoding.sdata);\n\t\tbreak;\n\tcase DW_FORM_strp:\n\t\tvalue->encoding.str_struct.offset = READ (buf, ut32);\n\t\tif (debug_str && value->encoding.str_struct.offset < debug_str_len) {\n\t\t\tvalue->encoding.str_struct.string = strdup (\n\t\t\t\t(const char *)(debug_str +\n\t\t\t\t\tvalue->encoding.str_struct.offset));\n\t\t} else {\n\t\t\tvalue->encoding.str_struct.string = NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\t{\n\t\t\tut64 ndata = 0;\n\t\t\tconst ut8 *data = (const ut8*)&ndata;\n\t\t\tbuf = r_uleb128 (buf, R_MIN (sizeof (data), (size_t)(buf_end - buf)), &ndata);\n\t\t\tmemcpy (&value->encoding.data, data, sizeof (value->encoding.data));\n\t\t\tvalue->encoding.str_struct.string = NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_ref_addr:\n\t\tvalue->encoding.reference = READ (buf, ut64); // addr size of machine\n\t\tbreak;\n\tcase DW_FORM_ref1:\n\t\tvalue->encoding.reference = READ (buf, ut8);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->encoding.reference = READ (buf, ut16);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->encoding.reference = READ (buf, ut32);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->encoding.reference = READ (buf, ut64);\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->encoding.data = READ (buf, ut8);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\"PFMT64x\"\\n\", spec->attr_form);\n\t\tvalue->encoding.data = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\nstatic const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,\n\t\tRBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da,\n\t\tsize_t offset, const ut8 *debug_str, size_t debug_str_len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7);\n\tut64 abbr_code;\n\tsize_t i;\n\t\n\tif (cu->hdr.length > debug_str_len) {\n\t\t//avoid oob read\n\t\treturn NULL;\n\t}\n\twhile (buf && buf < buf_end && buf >= obuf) {\n\t\tif (cu->length && cu->capacity == cu->length) {\n\t\t\tr_bin_dwarf_expand_cu (cu);\n\t\t}\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code);\n\t\tif (abbr_code > da->length || !buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tr_bin_dwarf_init_die (&cu->dies[cu->length]);\n\t\tif (!abbr_code) {\n\t\t\tcu->dies[cu->length].abbrev_code = 0;\n\t\t\tcu->length++;\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu->dies[cu->length].abbrev_code = abbr_code;\n\t\tcu->dies[cu->length].tag = da->decls[abbr_code - 1].tag;\n\t\tabbr_code += offset;\n\n\t\tif (da->capacity < abbr_code) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < da->decls[abbr_code - 1].length; i++) {\n\t\t\tif (cu->dies[cu->length].length == cu->dies[cu->length].capacity) {\n\t\t\t\tr_bin_dwarf_expand_die (&cu->dies[cu->length]);\n\t\t\t}\n\t\t\tif (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) {\n\t\t\t\teprintf (\"Warning: malformed dwarf attribute capacity doesn't match length\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));\n\t\t\tbuf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,\n\t\t\t\t\t&da->decls[abbr_code - 1].specs[i],\n\t\t\t\t\t&cu->dies[cu->length].attr_values[i],\n\t\t\t\t\t&cu->hdr, debug_str, debug_str_len);\n\t\t\tif (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {\n\t\t\t\tconst char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string;\n\t\t\t\tsdb_set (s, \"DW_AT_comp_dir\", name, 0);\n\t\t\t}\n\t\t\tcu->dies[cu->length].length++;\n\t\t}\n\t\tcu->length++;\n\t}\n\treturn buf;\n}\n\nR_API int r_bin_dwarf_parse_info_raw(Sdb *s, RBinDwarfDebugAbbrev *da,\n\t\tconst ut8 *obuf, size_t len,\n\t\tconst ut8 *debug_str, size_t debug_str_len, int mode) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tsize_t k, offset = 0;\n\tint curr_unit = 0;\n\tRBinDwarfDebugInfo di = {0};\n\tRBinDwarfDebugInfo *inf = &di;\n\tbool ret = true;\n\n\tif (!da || !s || !obuf) {\n\t\treturn false;\n\t}\n\n\tif (r_bin_dwarf_init_debug_info (inf) < 0) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\twhile (buf < buf_end) {\n\t\tif (inf->length >= inf->capacity)\n\t\t\tbreak;\n\n\t\tif (r_bin_dwarf_init_comp_unit (&inf->comp_units[curr_unit]) < 0) {\n\t\t\tret = false;\n\t\t\tcurr_unit--;\n\t\t\tgoto out_debug_info;\n\t\t}\n\n\t\tinf->comp_units[curr_unit].offset = buf - obuf;\n\t\tinf->comp_units[curr_unit].hdr.pointer_size = 0;\n\t\tinf->comp_units[curr_unit].hdr.abbrev_offset = 0;\n\t\tinf->comp_units[curr_unit].hdr.length = READ (buf, ut32);\n\t\tinf->comp_units[curr_unit].hdr.version = READ (buf, ut16);\n\n\t\tif (inf->comp_units[curr_unit].hdr.version != 2) {\n//\t\t\teprintf (\"DWARF: version %d is not yet supported.\\n\",\n//\t\t\t\t\tinf->comp_units[curr_unit].hdr.version);\n\t\t\tret = false;\n\t\t\tgoto out_debug_info;\n\t\t}\n\t\tif (inf->comp_units[curr_unit].hdr.length > len) {\n\t\t\tret = false;\n\t\t\tgoto out_debug_info;\n\t\t}\n\n\t\tinf->comp_units[curr_unit].hdr.abbrev_offset = READ (buf, ut32);\n\t\tinf->comp_units[curr_unit].hdr.pointer_size = READ (buf, ut8);\n\t\tinf->length++;\n\n\t\t/* Linear search FIXME */\n\t\tif (da->decls->length >= da->capacity) {\n\t\t\teprintf (\"WARNING: malformed dwarf have not enough buckets for decls.\\n\");\n\t\t}\n\t\tconst int k_max = R_MIN (da->capacity, da->decls->length);\n\t\tfor (k = 0; k < k_max; k++) {\n\t\t\tif (da->decls[k].offset ==\n\t\t\t\tinf->comp_units[curr_unit].hdr.abbrev_offset) {\n\t\t\t\toffset = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbuf = r_bin_dwarf_parse_comp_unit (s, buf, &inf->comp_units[curr_unit],\n\t\t\tda, offset, debug_str, debug_str_len);\n\n\t\tif (!buf) {\n\t\t\tret = false;\n\t\t\tgoto out_debug_info;\n\t\t}\n\n\t\tcurr_unit++;\n\t}\n\n\tif (mode == R_CORE_BIN_PRINT) {\n\t\tr_bin_dwarf_dump_debug_info (NULL, inf);\n\t}\n\nout_debug_info:\n\tfor (; curr_unit >= 0; curr_unit--) {\n\t\tr_bin_dwarf_free_comp_unit (&inf->comp_units[curr_unit]);\n\t}\n\tr_bin_dwarf_free_debug_info (inf);\nout:\n\treturn ret;\n}\n\nstatic RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev_raw(const ut8 *obuf, size_t len, int mode) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, spec1, spec2, offset;\n\tut8 has_children;\n\tRBinDwarfAbbrevDecl *tmpdecl;\n\n\t// XXX - Set a suitable value here.\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *da = R_NEW0 (RBinDwarfDebugAbbrev);\n\n\tr_bin_dwarf_init_debug_abbrev (da);\n\n\twhile (buf && buf+1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp);\n\t\tif (!buf || !tmp) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->length == da->capacity) {\n\t\t\tr_bin_dwarf_expand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->length];\n\t\tr_bin_dwarf_init_abbrev_decl (tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ (buf, ut8);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->length == tmpdecl->capacity) {\n\t\t\t\tr_bin_dwarf_expand_abbrev_decl (tmpdecl);\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &spec1);\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &spec2);\n\t\t\ttmpdecl->specs[tmpdecl->length].attr_name = spec1;\n\t\t\ttmpdecl->specs[tmpdecl->length].attr_form = spec2;\n\t\t\ttmpdecl->length++;\n\t\t} while (spec1 && spec2);\n\n\t\tda->length++;\n\t}\n\n\tif (mode == R_CORE_BIN_PRINT) {\n\t\tdump_r_bin_dwarf_debug_abbrev (stdout, da);\n\t}\n\treturn da;\n}\n\nRBinSection *getsection(RBin *a, const char *sn) {\n\tRListIter *iter;\n\tRBinSection *section = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\n\tif ( o && o->sections) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (strstr (section->name, sn)) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API int r_bin_dwarf_parse_info(RBinDwarfDebugAbbrev *da, RBin *a, int mode) {\n\tut8 *buf, *debug_str_buf = 0;\n\tint len, debug_str_len = 0, ret;\n\tRBinSection *debug_str;\n\tRBinSection *section = getsection (a, \"debug_info\");\n\tRBinFile *binfile = a ? a->cur: NULL;\n\n\tif (binfile && section) {\n\t\tdebug_str = getsection (a, \"debug_str\");\n\t\tif (debug_str) {\n\t\t\tdebug_str_len = debug_str->size;\n\t\t\tdebug_str_buf = calloc (1, debug_str_len + 1);\n\t\t\tret = r_buf_read_at (binfile->buf, debug_str->paddr,\n\t\t\t\t\t     debug_str_buf, debug_str_len);\n\t\t\tif (!ret) {\n\t\t\t\tfree (debug_str_buf);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlen = section->size;\n\t\tif (len > (UT32_MAX >> 1) || len < 1) {\n\t\t\tfree (debug_str_buf);\n\t\t\treturn false;\n\t\t}\n\t\tbuf = calloc (1, len);\n\t\tif (!buf) {\n\t\t\tfree (debug_str_buf);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_buf_read_at (binfile->buf, section->paddr, buf, len)) {\n\t\t\tfree (debug_str_buf);\n\t\t\tfree (buf);\n\t\t\treturn false;\n\t\t}\n\t\tret = r_bin_dwarf_parse_info_raw (binfile->sdb_addrinfo, da, buf, len,\n\t\t\t\tdebug_str_buf, debug_str_len, mode);\n\t\tR_FREE (debug_str_buf);\n\t\tfree (buf);\n\t\treturn ret;\n\t}\n\treturn false;\n}\n\nstatic RBinDwarfRow *r_bin_dwarf_row_new (ut64 addr, const char *file, int line, int col) {\n\tRBinDwarfRow *row = R_NEW0 (RBinDwarfRow);\n\tif (!row) {\n\t\treturn NULL;\n\t}\n\trow->file = strdup (file);\n\trow->address = addr;\n\trow->line = line;\n\trow->column = 0;\n\treturn row;\n}\n\nstatic void r_bin_dwarf_row_free(void *p) {\n\tRBinDwarfRow *row = (RBinDwarfRow*)p;\n\tfree (row->file);\n\tfree (row);\n}\n\nR_API RList *r_bin_dwarf_parse_line(RBin *a, int mode) {\n\tut8 *buf;\n\tRList *list = NULL;\n\tint len, ret;\n\tRBinSection *section = getsection (a, \"debug_line\");\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len + 1);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (ret != len) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist = r_list_new (); // always return empty list wtf\n\t\tif (!list) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist->free = r_bin_dwarf_row_free;\n\t\tr_bin_dwarf_parse_line_raw2 (a, buf, len, mode);\n\t\t// k bin/cur/addrinfo/*\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tSdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tif (!strncmp (kv->key, \"0x\", 2)) {\n\t\t\t\tut64 addr;\n\t\t\t\tRBinDwarfRow *row;\n\t\t\t\tint line;\n\t\t\t\tchar *file = strdup (kv->value);\n\t\t\t\tif (!file) {\n\t\t\t\t\tfree (buf);\n\t\t\t\t\tls_free (ls);\n\t\t\t\t\tr_list_free (list);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tchar *tok = strchr (file, '|');\n\t\t\t\tif (tok) {\n\t\t\t\t\t*tok++ = 0;\n\t\t\t\t\tline = atoi (tok);\n\t\t\t\t\taddr = r_num_math (NULL, kv->key);\n\t\t\t\t\trow = r_bin_dwarf_row_new (addr, file, line, 0);\n\t\t\t\t\tr_list_append (list, row);\n\t\t\t\t}\n\t\t\t\tfree (file);\n\t\t\t}\n\t\t}\n\t\tls_free (ls);\n\t\tfree (buf);\n\t}\n\treturn list;\n}\n\nR_API RList *r_bin_dwarf_parse_aranges(RBin *a, int mode) {\n\tut8 *buf;\n\tint ret;\n\tsize_t len;\n\tRBinSection *section = getsection (a, \"debug_aranges\");\n\tRBinFile *binfile = a ? a->cur: NULL;\n\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1 || len > ST32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len);\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (!ret) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (mode == R_CORE_BIN_PRINT) {\n\t\t\tr_bin_dwarf_parse_aranges_raw (buf, len, stdout);\n\t\t} else {\n\t\t\tr_bin_dwarf_parse_aranges_raw (buf, len, DBGFD);\n\t\t}\n\t\tfree (buf);\n\t}\n\treturn NULL;\n}\n\nR_API RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev(RBin *a, int mode) {\n\tut8 *buf;\n\tsize_t len;\n\tRBinSection *section = getsection (a, \"debug_abbrev\");\n\tRBinDwarfDebugAbbrev *da = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tif (!section || !binfile) return NULL;\n\tif (section->size > binfile->size) {\n\t\treturn NULL;\n\t}\n\tlen = section->size;\n\tbuf = calloc (1,len);\n\tr_buf_read_at (binfile->buf, section->paddr, buf, len);\n\tda = r_bin_dwarf_parse_abbrev_raw (buf, len, mode);\n\tfree (buf);\n\treturn da;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2012-2017 - pancake, Fedor Sakharov */\n\n#define D0 if(1)\n#define D1 if(1)\n\n#include <errno.h>\n\n#define DWARF_DUMP 0\n\n#if DWARF_DUMP\n#define DBGFD stdout\n#else\n#define DBGFD NULL\n#endif\n\n#include <r_bin.h>\n#include <r_bin_dwarf.h>\n#include <r_core.h>\n\n#define STANDARD_OPERAND_COUNT_DWARF2 9\n#define STANDARD_OPERAND_COUNT_DWARF3 12\n#define R_BIN_DWARF_INFO 1\n\n#define READ(x,y) ((x + sizeof (y) < buf_end)? *((y*)x): 0); x += sizeof (y)\n\nstatic const char *dwarf_tag_name_encodings[] = {\n\t[DW_TAG_array_type] = \"DW_TAG_array_type\",\n\t[DW_TAG_class_type] = \"DW_TAG_class_type\",\n\t[DW_TAG_entry_point] = \"DW_TAG_entry_point\",\n\t[DW_TAG_enumeration_type] = \"DW_TAG_enumeration_type\",\n\t[DW_TAG_formal_parameter] = \"DW_TAG_formal_parameter\",\n\t[DW_TAG_imported_declaration] = \"DW_TAG_imported_declaration\",\n\t[DW_TAG_label] = \"DW_TAG_label\",\n\t[DW_TAG_lexical_block] = \"DW_TAG_lexical_block\",\n\t[DW_TAG_member] = \"DW_TAG_member\",\n\t[DW_TAG_pointer_type] = \"DW_TAG_pointer_type\",\n\t[DW_TAG_reference_type] = \"DW_TAG_reference_type\",\n\t[DW_TAG_compile_unit] = \"DW_TAG_compile_unit\",\n\t[DW_TAG_string_type] = \"DW_TAG_string_type\",\n\t[DW_TAG_structure_type] = \"DW_TAG_structure_type\",\n\t[DW_TAG_subroutine_type] = \"DW_TAG_subroutine_type\",\n\t[DW_TAG_typedef] = \"DW_TAG_typedef\",\n\t[DW_TAG_union_type] = \"DW_TAG_union_type\",\n\t[DW_TAG_unspecified_parameters] = \"DW_TAG_unspecified_parameters\",\n\t[DW_TAG_variant] = \"DW_TAG_variant\",\n\t[DW_TAG_common_block] = \"DW_TAG_common_block\",\n\t[DW_TAG_common_inclusion] = \"DW_TAG_common_inclusion\",\n\t[DW_TAG_inheritance] = \"DW_TAG_inheritance\",\n\t[DW_TAG_inlined_subroutine] = \"DW_TAG_inlined_subroutine\",\n\t[DW_TAG_module] = \"DW_TAG_module\",\n\t[DW_TAG_ptr_to_member_type] = \"DW_TAG_ptr_to_member_type\",\n\t[DW_TAG_set_type] = \"DW_TAG_set_type\",\n\t[DW_TAG_subrange_type] = \"DW_TAG_subrange_type\",\n\t[DW_TAG_with_stmt] = \"DW_TAG_with_stmt\",\n\t[DW_TAG_access_declaration] = \"DW_TAG_access_declaration\",\n\t[DW_TAG_base_type] = \"DW_TAG_base_type\",\n\t[DW_TAG_catch_block] = \"DW_TAG_catch_block\",\n\t[DW_TAG_const_type] = \"DW_TAG_const_type\",\n\t[DW_TAG_constant] = \"DW_TAG_constant\",\n\t[DW_TAG_enumerator] = \"DW_TAG_enumerator\",\n\t[DW_TAG_file_type] = \"DW_TAG_file_type\",\n\t[DW_TAG_friend] = \"DW_TAG_friend\",\n\t[DW_TAG_namelist] = \"DW_TAG_namelist\",\n\t[DW_TAG_namelist_item] = \"DW_TAG_namelist_item\",\n\t[DW_TAG_packed_type] = \"DW_TAG_packed_type\",\n\t[DW_TAG_subprogram] = \"DW_TAG_subprogram\",\n\t[DW_TAG_template_type_param] = \"DW_TAG_template_type_param\",\n\t[DW_TAG_template_value_param] = \"DW_TAG_template_value_param\",\n\t[DW_TAG_template_alias] = \"DW_TAG_template_alias\",\n\t[DW_TAG_thrown_type] = \"DW_TAG_thrown_type\",\n\t[DW_TAG_try_block] = \"DW_TAG_try_block\",\n\t[DW_TAG_variant_part] = \"DW_TAG_variant_part\",\n\t[DW_TAG_variable] = \"DW_TAG_variable\",\n\t[DW_TAG_volatile_type] = \"DW_TAG_volatile_type\"\n};\n\nstatic const char *dwarf_attr_encodings[] = {\n\t[DW_AT_sibling] = \"DW_AT_siblings\",\n\t[DW_AT_location] = \"DW_AT_location\",\n\t[DW_AT_name] = \"DW_AT_name\",\n\t[DW_AT_ordering] = \"DW_AT_ordering\",\n\t[DW_AT_byte_size] = \"DW_AT_byte_size\",\n\t[DW_AT_bit_size] = \"DW_AT_bit_size\",\n\t[DW_AT_stmt_list] = \"DW_AT_stmt_list\",\n\t[DW_AT_low_pc] = \"DW_AT_low_pc\",\n\t[DW_AT_high_pc] = \"DW_AT_high_pc\",\n\t[DW_AT_language] = \"DW_AT_language\",\n\t[DW_AT_discr] = \"DW_AT_discr\",\n\t[DW_AT_discr_value] = \"DW_AT_discr_value\",\n\t[DW_AT_visibility] = \"DW_AT_visibility\",\n\t[DW_AT_import] = \"DW_AT_import\",\n\t[DW_AT_string_length] = \"DW_AT_string_length\",\n\t[DW_AT_common_reference] = \"DW_AT_common_reference\",\n\t[DW_AT_comp_dir] = \"DW_AT_comp_dir\",\n\t[DW_AT_const_value] = \"DW_AT_const_value\",\n\t[DW_AT_containing_type] = \"DW_AT_containig_type\",\n\t[DW_AT_default_value] = \"DW_AT_default_value\",\n\t[DW_AT_inline] = \"DW_AT_inline\",\n\t[DW_AT_is_optional] = \"DW_AT_is_optional\",\n\t[DW_AT_lower_bound] = \"DW_AT_lower_bound\",\n\t[DW_AT_producer] = \"DW_AT_producer\",\n\t[DW_AT_prototyped] = \"DW_AT_prototyped\",\n\t[DW_AT_return_addr] = \"DW_AT_return_addr\",\n\t[DW_AT_start_scope] = \"DW_AT_start_scope\",\n\t[DW_AT_stride_size] = \"DW_AT_stride_size\",\n\t[DW_AT_upper_bound] = \"DW_AT_upper_bound\",\n\t[DW_AT_abstract_origin] = \"DW_AT_abstract_origin\",\n\t[DW_AT_accessibility] = \"DW_AT_accessibility\",\n\t[DW_AT_address_class] = \"DW_AT_address_class\",\n\t[DW_AT_artificial] = \"DW_AT_artificial\",\n\t[DW_AT_base_types] = \"DW_AT_base_types\",\n\t[DW_AT_calling_convention] = \"DW_AT_calling_convention\",\n\t[DW_AT_count] = \"DW_AT_count\",\n\t[DW_AT_data_member_location] = \"DW_AT_data_member_location\",\n\t[DW_AT_decl_column] = \"DW_AT_decl_column\",\n\t[DW_AT_decl_file] = \"DW_AT_decl_file\",\n\t[DW_AT_decl_line] = \"DW_AT_decl_line\",\n\t[DW_AT_declaration] = \"DW_AT_declaration\",\n\t[DW_AT_discr_list] = \"DW_AT_discr_list\",\n\t[DW_AT_encoding] = \"DW_AT_encoding\",\n\t[DW_AT_external] = \"DW_AT_external\",\n\t[DW_AT_frame_base] = \"DW_AT_frame_base\",\n\t[DW_AT_friend] = \"DW_AT_friend\",\n\t[DW_AT_identifier_case] = \"DW_AT_identifier_case\",\n\t[DW_AT_macro_info] = \"DW_AT_macro_info\",\n\t[DW_AT_namelist_item] = \"DW_AT_namelist_item\",\n\t[DW_AT_priority] = \"DW_AT_priority\",\n\t[DW_AT_segment] = \"DW_AT_segment\",\n\t[DW_AT_specification] = \"DW_AT_specification\",\n\t[DW_AT_static_link] = \"DW_AT_static_link\",\n\t[DW_AT_type] = \"DW_AT_type\",\n\t[DW_AT_use_location] = \"DW_AT_use_location\",\n\t[DW_AT_variable_parameter] = \"DW_AT_variable_parameter\",\n\t[DW_AT_virtuality] = \"DW_AT_virtuality\",\n\t[DW_AT_vtable_elem_location] = \"DW_AT_vtable_elem_location\"\n};\n\nstatic const char *dwarf_attr_form_encodings[] = {\n\t[DW_FORM_addr] = \"DW_FORM_addr\",\n\t[DW_FORM_block2] = \"DW_FORM_block2\",\n\t[DW_FORM_block4] = \"DW_FORM_block4\",\n\t[DW_FORM_data2] = \"DW_FORM_data2\",\n\t[DW_FORM_data4] = \"DW_FORM_data4\",\n\t[DW_FORM_data8] = \"DW_FORM_data8\",\n\t[DW_FORM_string] = \"DW_FORM_string\",\n\t[DW_FORM_block] = \"DW_FORM_block\",\n\t[DW_FORM_block1] = \"DW_FORM_block1\",\n\t[DW_FORM_data1] = \"DW_FORM_data1\",\n\t[DW_FORM_flag] = \"DW_FORM_flag\",\n\t[DW_FORM_sdata] = \"DW_FORM_sdata\",\n\t[DW_FORM_strp] = \"DW_FORM_strp\",\n\t[DW_FORM_udata] = \"DW_FORM_udata\",\n\t[DW_FORM_ref_addr] = \"DW_FORM_ref_addr\",\n\t[DW_FORM_ref1] = \"DW_FORM_ref1\",\n\t[DW_FORM_ref2] = \"DW_FORM_ref2\",\n\t[DW_FORM_ref4] = \"DW_FORM_ref4\",\n\t[DW_FORM_ref8] = \"DW_FORM_ref8\",\n\t[DW_FORM_ref_udata] = \"DW_FORM_ref_udata\",\n\t[DW_FORM_indirect] = \"DW_FORM_indirect\"\n};\n\nstatic const char *dwarf_langs[] = {\n\t[DW_LANG_C89] = \"C89\",\n\t[DW_LANG_C] = \"C\",\n\t[DW_LANG_Ada83] = \"Ada83\",\n\t[DW_LANG_C_plus_plus] = \"C++\",\n\t[DW_LANG_Cobol74] = \"Cobol74\",\n\t[DW_LANG_Cobol85] = \"Cobol85\",\n\t[DW_LANG_Fortran77] = \"Fortran77\",\n\t[DW_LANG_Fortran90] = \"Fortran90\",\n\t[DW_LANG_Pascal83] = \"Pascal83\",\n\t[DW_LANG_Modula2] = \"Modula2\",\n\t[DW_LANG_Java] = \"Java\",\n\t[DW_LANG_C99] = \"C99\",\n\t[DW_LANG_Ada95] = \"Ada95\",\n\t[DW_LANG_Fortran95] = \"Fortran95\",\n\t[DW_LANG_PLI] = \"PLI\",\n\t[DW_LANG_ObjC] = \"ObjC\",\n\t[DW_LANG_ObjC_plus_plus] = \"ObjC_plus_plus\",\n\t[DW_LANG_UPC] = \"UPC\",\n\t[DW_LANG_D] = \"D\",\n\t[DW_LANG_Python] = \"Python\",\n\t[DW_LANG_Rust] = \"Rust\",\n\t[DW_LANG_C11] = \"C11\",\n\t[DW_LANG_Swift] = \"Swift\",\n\t[DW_LANG_Julia] = \"Julia\",\n\t[DW_LANG_Dylan] = \"Dylan\",\n\t[DW_LANG_C_plus_plus_14] = \"C++14\",\n\t[DW_LANG_Fortran03] = \"Fortran03\",\n\t[DW_LANG_Fortran08] = \"Fortran08\"\n};\n\nstatic int add_sdb_include_dir(Sdb *s, const char *incl, int idx) {\n\tif (!s || !incl)\n\t\treturn false;\n\treturn sdb_array_set (s, \"includedirs\", idx, incl, 0);\n}\n\nstatic const ut8 *r_bin_dwarf_parse_lnp_header (\n\t\tRBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\t\tRBinDwarfLNPHeader *hdr, FILE *f, int mode) {\n\tint i;\n\tSdb *s;\n\tsize_t count;\n\tconst ut8 *tmp_buf = NULL;\n\n\tif (!hdr || !bf || !buf) return NULL;\n\n\thdr->unit_length.part1 = READ (buf, ut32);\n\tif (hdr->unit_length.part1 == DWARF_INIT_LEN_64) {\n\t\thdr->unit_length.part2 = READ (buf, ut32);\n\t}\n\n\ts = sdb_new (NULL, NULL, 0);\n\n\thdr->version = READ (buf, ut16);\n\n\tif (hdr->unit_length.part1 == DWARF_INIT_LEN_64) {\n\t\thdr->header_length = READ (buf, ut64);\n\t} else {\n\t\thdr->header_length = READ (buf, ut32);\n\t}\n\n\tif (buf_end-buf < 8) {\n\t\tsdb_free (s);\n\t\treturn NULL;\n\t}\n\thdr->min_inst_len = READ (buf, ut8);\n\t//hdr->max_ops_per_inst = READ (buf, ut8);\n\thdr->file_names = NULL;\n\thdr->default_is_stmt = READ (buf, ut8);\n\thdr->line_base = READ (buf, char);\n\thdr->line_range = READ (buf, ut8);\n\thdr->opcode_base = READ (buf, ut8);\n\n\tif (f) {\n\t\tfprintf (f, \"DWARF LINE HEADER\\n\");\n\t\tfprintf (f, \"  total_length: %d\\n\", hdr->unit_length.part1);\n\t\tfprintf (f, \"  version: %d\\n\", hdr->version);\n\t\tfprintf (f, \"  header_length: : %\"PFMT64d\"\\n\", hdr->header_length);\n\t\tfprintf (f, \"  mininstlen: %d\\n\", hdr->min_inst_len);\n\t\tfprintf (f, \"  is_stmt: %d\\n\", hdr->default_is_stmt);\n\t\tfprintf (f, \"  line_base: %d\\n\", hdr->line_base);\n\t\tfprintf (f, \"  line_range: %d\\n\", hdr->line_range);\n\t\tfprintf (f, \"  opcode_base: %d\\n\", hdr->opcode_base);\n\t}\n\n\tif (hdr->opcode_base>0) {\n\t\thdr->std_opcode_lengths = calloc(sizeof(ut8), hdr->opcode_base);\n\n\t\tfor (i = 1; i <= hdr->opcode_base - 1; i++) {\n\t\t\tif (buf+2>buf_end) break;\n\t\t\thdr->std_opcode_lengths[i] = READ (buf, ut8);\n\t\t\tif (f) {\n\t\t\t\tfprintf (f, \" op %d %d\\n\", i, hdr->std_opcode_lengths[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thdr->std_opcode_lengths = NULL;\n\t}\n\n\ti = 0;\n\twhile (buf+1 < buf_end) {\n\t\tint maxlen = R_MIN ((size_t)(buf_end-buf)-1, 0xfff);\n\t\tint len = r_str_nlen ((const char*)buf, maxlen);\n\t\tchar *str = r_str_ndup ((const char *)buf, len);\n\t\tif (len<1 || len >= 0xfff) {\n\t\t\tbuf += 1;\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (*str != '/' && *str != '.') {\n\t\t\t// no more paths in here\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (f) {\n\t\t\tfprintf (f, \"INCLUDEDIR (%s)\\n\", str);\n\t\t}\n\t\tadd_sdb_include_dir (s, str, i);\n\t\tfree (str);\n\t\ti++;\n\t\tbuf += len + 1;\n\t}\n\n\ttmp_buf = buf;\n\tcount = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (buf+1<buf_end) {\n\t\t\tconst char *filename = (const char *)buf;\n\t\t\tint maxlen = R_MIN ((size_t)(buf_end-buf-1), 0xfff);\n\t\t\tut64 id_idx, mod_time, file_len;\n\t\t\tsize_t namelen, len = r_str_nlen (filename, maxlen);\n\n\t\t\tif (!len) {\n\t\t\t\tbuf++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += len + 1;\n\t\t\tif (buf>=buf_end) { buf = NULL; goto beach; }\n\t\t\tbuf = r_uleb128 (buf, buf_end-buf, &id_idx);\n\t\t\tif (buf>=buf_end) { buf = NULL; goto beach; }\n\t\t\tbuf = r_uleb128 (buf, buf_end-buf, &mod_time);\n\t\t\tif (buf>=buf_end) { buf = NULL; goto beach; }\n\t\t\tbuf = r_uleb128 (buf, buf_end-buf, &file_len);\n\t\t\tif (buf>=buf_end) { buf = NULL; goto beach; }\n\n\t\t\tif (i) {\n\t\t\t\tchar *include_dir = NULL, *comp_dir = NULL;\n\t\t\t\tchar *allocated_id = NULL;\n\t\t\t\tif (id_idx > 0) {\n\t\t\t\t\tinclude_dir = sdb_array_get (s, \"includedirs\", id_idx - 1, 0);\n\t\t\t\t\tif (include_dir && include_dir[0] != '/') {\n\t\t\t\t\t\tcomp_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\t\tif (comp_dir) {\n\t\t\t\t\t\t\tallocated_id = calloc (1, strlen (comp_dir) +\n\t\t\t\t\t\t\t\t\tstrlen (include_dir) + 8);\n\t\t\t\t\t\t\tsnprintf (allocated_id, strlen (comp_dir) + strlen (include_dir) + 8,\n\t\t\t\t\t\t\t\t\t\"%s/%s/\", comp_dir, include_dir);\n\t\t\t\t\t\t\tinclude_dir = allocated_id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinclude_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\tif (!include_dir)\n\t\t\t\t\t\tinclude_dir = \"./\";\n\t\t\t\t}\n\n\t\t\t\tnamelen = len + (include_dir?strlen (include_dir):0) + 8;\n\n\t\t\t\tif (hdr->file_names) {\n\t\t\t\t\thdr->file_names[count].name = calloc (sizeof(char), namelen);\n\t\t\t\t\tsnprintf (hdr->file_names[count].name, namelen - 1,\n\t\t\t\t\t\t\"%s/%s\", include_dir? include_dir : \"\", filename);\n\t\t\t\t\thdr->file_names[count].name[namelen - 1] = '\\0';\n\t\t\t\t\tfree (allocated_id);\n\t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n\t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n\t\t\t\t\thdr->file_names[count].file_len = file_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (f && i) {\n\t\t\t\tfprintf (f, \"FILE (%s)\\n\", filename);\n\t\t\t\tfprintf (f, \"| dir idx %\"PFMT64d\"\\n\", id_idx);\n\t\t\t\tfprintf (f, \"| lastmod %\"PFMT64d\"\\n\", mod_time);\n\t\t\t\tfprintf (f, \"| filelen %\"PFMT64d\"\\n\", file_len);\n\t\t\t}\n\t\t}\n\t\tif (i == 0) {\n\t\t\tif (count>0) {\n\t\t\t\thdr->file_names = calloc(sizeof(file_entry), count);\n\t\t\t} else {\n\t\t\t\thdr->file_names = NULL;\n\t\t\t}\n\t\t\thdr->file_names_count = count;\n\t\t\tbuf = tmp_buf;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\nbeach:\n\tsdb_free (s);\n\n\treturn buf;\n}\n\nstatic inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, FILE *f, int mode) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tif (!s || !file)\n\t\treturn;\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\t// includedirs and properly check full paths\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tif (!f) {\n\t\t\tf = stdout;\n\t\t}\n\t\tfprintf (f, \"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\t/* THIS IS TOO SLOW */\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, offset, 16);\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}\n\nstatic const ut8* r_bin_dwarf_parse_ext_opcode(const RBin *a, const ut8 *obuf,\n\t\tsize_t len, const RBinDwarfLNPHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs, FILE *f, int mode) {\n\t// XXX - list is an unused parameter.\n\tconst ut8 *buf;\n\tconst ut8 *buf_end;\n\tut8 opcode;\n\tut64 addr;\n\tbuf = obuf;\n\tst64 op_len;\n\tRBinFile *binfile = a ? a->cur : NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\tut32 addr_size = o && o->info && o->info->bits ? o->info->bits / 8 : 4;\n\tconst char *filename;\n\n\tif (!binfile || !obuf || !hdr || !regs) return NULL;\n\n\tbuf = r_leb128 (buf, &op_len);\n\tbuf_end = buf+len;\n\topcode = *buf++;\n\n\tif (f) {\n\t\tfprintf (f, \"Extended opcode %d: \", opcode);\n\t}\n\n\tswitch (opcode) {\n\tcase DW_LNE_end_sequence:\n\t\tregs->end_sequence = DWARF_TRUE;\n\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline(binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\t\thdr->file_names[fnidx].name, regs->line, f, mode);\n\t\t\t}\n\t\t}\n\n\t\tif (f) {\n\t\t\tfprintf (f, \"End of Sequence\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_address:\n\t\tif (addr_size == 8) {\n\t\t\taddr = READ (buf, ut64);\n\t\t} else {\n\t\t\taddr = READ (buf, ut32);\n\t\t}\n\n\t\tregs->address = addr;\n\n\t\tif (f) {\n\t\t\tfprintf (f, \"set Address to 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_define_file:\n\t\tfilename = (const char*)buf;\n\n\t\tif (f) {\n\t\t\tfprintf (f, \"define_file\\n\");\n\t\t\tfprintf (f, \"filename %s\\n\", filename);\n\t\t}\n\n\t\tbuf += (strlen (filename) + 1);\n\t\tut64 dir_idx;\n\t\tif (buf+1 < buf_end)\n\t\t\tbuf = r_uleb128 (buf, ST32_MAX, &dir_idx);\n\t\tbreak;\n\tcase DW_LNE_set_discriminator:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tif (f) {\n\t\t\tfprintf (f, \"set Discriminator to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->discriminator = addr;\n\t\tbreak;\n\tdefault:\n\t\tif (f) {\n\t\t\tfprintf (f, \"Unexpeced opcode %d\\n\", opcode);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn buf;\n}\n\nstatic const ut8* r_bin_dwarf_parse_spec_opcode(\n\t\tconst RBin *a, const ut8 *obuf, size_t len,\n\t\tconst RBinDwarfLNPHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs,\n\t\tut8 opcode, FILE *f, int mode) {\n\t// XXX - list is not used\n\tconst ut8 *buf = obuf;\n\tut8 adj_opcode = 0;\n\tut64 advance_adr;\n\tRBinFile *binfile = a ? a->cur : NULL;\n\n\tif (!obuf || !hdr || !regs) {\n\t\treturn NULL;\n\t}\n\n\tadj_opcode = opcode - hdr->opcode_base;\n\tif (!hdr->line_range) {\n\t\t// line line-range information. move away\n\t\treturn NULL;\n\t}\n\tadvance_adr = adj_opcode / hdr->line_range;\n\tregs->address += advance_adr;\n\tregs->line += hdr->line_base + (adj_opcode % hdr->line_range);\n\tif (f) {\n\t\tfprintf (f, \"Special opcode %d: \", adj_opcode);\n\t\tfprintf (f, \"advance Address by %\"PFMT64d\" to %\"PFMT64x\" and Line by %d to %\"PFMT64d\"\\n\",\n\t\t\tadvance_adr, regs->address, hdr->line_base +\n\t\t\t(adj_opcode % hdr->line_range), regs->line);\n\t}\n\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\tint idx = regs->file -1;\n\t\tif (idx >= 0 && idx < hdr->file_names_count) {\n\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\thdr->file_names[idx].name,\n\t\t\t\t\tregs->line, f, mode);\n\t\t}\n\t}\n\tregs->basic_block = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->discriminator = 0;\n\n\treturn buf;\n}\n\nstatic const ut8* r_bin_dwarf_parse_std_opcode(\n\t\tconst RBin *a, const ut8 *obuf, size_t len,\n\t\tconst RBinDwarfLNPHeader *hdr, RBinDwarfSMRegisters *regs,\n\t\tut8 opcode, FILE *f, int mode) {\n\tconst ut8* buf = obuf;\n\tconst ut8* buf_end = obuf + len;\n\tut64 addr = 0LL;\n\tst64 sbuf;\n\tut8 adj_opcode;\n\tut64 op_advance;\n\tut16 operand;\n\tRBinFile *binfile = a ? a->cur : NULL;\n\n\tif (!binfile || !hdr || !regs || !obuf) {\n\t\treturn NULL;\n\t}\n\tswitch (opcode) {\n\tcase DW_LNS_copy:\n\t\tif (f) {\n\t\t\tfprintf (f, \"Copy\\n\");\n\t\t}\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo,\n\t\t\t\t\tregs->address,\n\t\t\t\t\thdr->file_names[fnidx].name,\n\t\t\t\t\tregs->line, f, mode);\n\t\t\t}\n\t\t}\n\t\tregs->basic_block = DWARF_FALSE;\n\t\tbreak;\n\tcase DW_LNS_advance_pc:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tregs->address += addr * hdr->min_inst_len;\n\t\tif (f) {\n\t\t\tfprintf (f, \"Advance PC by %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\taddr * hdr->min_inst_len, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_advance_line:\n\t\tbuf = r_leb128(buf, &sbuf);\n\t\tregs->line += sbuf;\n\t\tif (f) {\n\t\t\tfprintf (f, \"Advance line by %\"PFMT64d\", to %\"PFMT64d\"\\n\", sbuf, regs->line);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_file:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tif (f) {\n\t\t\tfprintf (f, \"Set file to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->file = addr;\n\t\tbreak;\n\tcase DW_LNS_set_column:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tif (f) {\n\t\t\tfprintf (f, \"Set column to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->column = addr;\n\t\tbreak;\n\tcase DW_LNS_negate_stmt:\n\t\tregs->is_stmt = regs->is_stmt ? DWARF_FALSE : DWARF_TRUE;\n\t\tif (f) {\n\t\t\tfprintf (f, \"Set is_stmt to %d\\n\", regs->is_stmt);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_basic_block:\n\t\tif (f) {\n\t\t\tfprintf (f, \"set_basic_block\\n\");\n\t\t}\n\t\tregs->basic_block = DWARF_TRUE;\n\t\tbreak;\n\tcase DW_LNS_const_add_pc:\n\t\tadj_opcode = 255 - hdr->opcode_base;\n\t\tif (hdr->line_range > 0) {\n\t\t\top_advance = adj_opcode / hdr->line_range;\n\t\t} else {\n\t\t\top_advance = 0;\n\t\t}\n\t\tregs->address += op_advance;\n\t\tif (f) {\n\t\t\tfprintf (f, \"Advance PC by constant %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\top_advance, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_fixed_advance_pc:\n\t\toperand = READ (buf, ut16);\n\t\tregs->address += operand;\n\t\tif (f) {\n\t\t\tfprintf (f,\"Fixed advance pc to %\"PFMT64d\"\\n\", regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_prologue_end:\n\t\tregs->prologue_end = ~0;\n\t\tif (f) {\n\t\t\tfprintf (f, \"set_prologue_end\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_epilogue_begin:\n\t\tregs->epilogue_begin = ~0;\n\t\tif (f) {\n\t\t\tfprintf (f, \"set_epilogue_begin\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_isa:\n\t\tbuf = r_uleb128 (buf, ST32_MAX, &addr);\n\t\tregs->isa = addr;\n\t\tif (f) {\n\t\t\tfprintf (f, \"set_isa\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (f) {\n\t\t\tfprintf (f, \"Unexpected opcode\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\nstatic const ut8* r_bin_dwarf_parse_opcodes(const RBin *a, const ut8 *obuf,\n\t\tsize_t len, const RBinDwarfLNPHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs, FILE *f, int mode) {\n\tconst ut8 *buf, *buf_end;\n\tut8 opcode, ext_opcode;\n\n\tif (!a || !obuf || len < 8) {\n\t\treturn NULL;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\n\twhile (buf && buf + 1 < buf_end) {\n\t\topcode = *buf++;\n\t\tlen--;\n\t\tif (!opcode) {\n\t\t\text_opcode = *buf;\n\t\t\tbuf = r_bin_dwarf_parse_ext_opcode (a, buf, len, hdr, regs, f, mode);\n\t\t\tif (ext_opcode == DW_LNE_end_sequence) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (opcode >= hdr->opcode_base) {\n\t\t\tbuf = r_bin_dwarf_parse_spec_opcode (a, buf, len, hdr, regs, opcode, f, mode);\n\t\t} else {\n\t\t\tbuf = r_bin_dwarf_parse_std_opcode (a, buf, len, hdr, regs, opcode, f, mode);\n\t\t}\n\t\tlen = (int)(buf_end - buf);\n\t}\n\treturn buf;\n}\n\nstatic void r_bin_dwarf_set_regs_default (const RBinDwarfLNPHeader *hdr, RBinDwarfSMRegisters *regs) {\n\tregs->address = 0;\n\tregs->file = 1;\n\tregs->line = 1;\n\tregs->column = 0;\n\tregs->is_stmt = hdr->default_is_stmt;\n\tregs->basic_block = DWARF_FALSE;\n\tregs->end_sequence = DWARF_FALSE;\n}\n\nR_API int r_bin_dwarf_parse_line_raw2(const RBin *a, const ut8 *obuf,\n\t\t\t\t       size_t len, int mode) {\n\tRBinDwarfLNPHeader hdr = {{0}};\n\tconst ut8 *buf = NULL, *buf_tmp = NULL, *buf_end = NULL;\n\tRBinDwarfSMRegisters regs;\n\tint tmplen;\n\tFILE *f = NULL;\n\tRBinFile *binfile = a ? a->cur : NULL;\n\n\tif (!binfile || !obuf) {\n\t\treturn false;\n\t}\n\tif (mode == R_CORE_BIN_PRINT) {\n\t\tf = stdout;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\twhile (buf + 1 < buf_end) {\n\t\tbuf_tmp = buf;\n\t\tbuf = r_bin_dwarf_parse_lnp_header (a->cur, buf, buf_end, &hdr, f, mode);\n\t\tif (!buf) {\n\t\t\treturn false;\n\t\t}\n\t\tr_bin_dwarf_set_regs_default (&hdr, &regs);\n\t\ttmplen = (int)(buf_end - buf);\n\t\ttmplen = R_MIN (tmplen, 4 + hdr.unit_length.part1);\n\t\tif (tmplen < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!r_bin_dwarf_parse_opcodes (a, buf, tmplen, &hdr, &regs, f, mode)) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf = buf_tmp + tmplen;\n\t\tlen = (int)(buf_end - buf);\n\t}\n\treturn true;\n}\n\n#define READ_BUF(x,y) if (idx+sizeof(y)>=len) { return false;} \\\n\tx=*(y*)buf; idx+=sizeof(y);buf+=sizeof(y)\n\nR_API int r_bin_dwarf_parse_aranges_raw(const ut8 *obuf, int len, FILE *f) {\n\tut32 length, offset;\n\tut16 version;\n\tut32 debug_info_offset;\n\tut8 address_size, segment_size;\n\tconst ut8 *buf = obuf;\n\tint idx = 0;\n\n\tif (!buf || len< 4) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF (length, ut32);\n\tif (f) {\n\t\tprintf(\"parse_aranges\\n\");\n\t\tprintf(\"length 0x%x\\n\", length);\n\t}\n\n\tif (idx+12>=len)\n\t\treturn false;\n\n\tREAD_BUF (version, ut16);\n\tif (f) {\n\t\tprintf(\"Version %d\\n\", version);\n\t}\n\n\tREAD_BUF (debug_info_offset, ut32);\n\tif (f) {\n\t\tfprintf (f, \"Debug info offset %d\\n\", debug_info_offset);\n\t}\n\n\tREAD_BUF (address_size, ut8);\n\tif (f) {\n\t\tfprintf (f, \"address size %d\\n\", (int)address_size);\n\t}\n\n\tREAD_BUF (segment_size, ut8);\n\tif (f) {\n\t\tfprintf (f, \"segment size %d\\n\", (int)segment_size);\n\t}\n\n\toffset = segment_size + address_size * 2;\n\n\tif (offset) {\n\t\tut64 n = (((ut64) (size_t)buf / offset) + 1) * offset - ((ut64)(size_t)buf);\n\t\tif (idx+n>=len) {\n\t\t\treturn false;\n\t\t}\n\t\tbuf += n;\n\t\tidx += n;\n\t}\n\n\twhile ((buf - obuf) < len) {\n\t\tut64 adr, length;\n\t\tif ((idx+8)>=len) {\n\t\t\tbreak;\n\t\t}\n\t\tREAD_BUF (adr, ut64);\n\t\tREAD_BUF (length, ut64);\n\t\tif (f) printf(\"length 0x%\"PFMT64x\" address 0x%\"PFMT64x\"\\n\", length, adr);\n\t}\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_init_debug_info(RBinDwarfDebugInfo *inf) {\n\tif (!inf) {\n\t\treturn -1;\n\t}\n\tinf->comp_units = calloc (sizeof (RBinDwarfCompUnit), DEBUG_INFO_CAPACITY);\n\n\t// XXX - should we be using error codes?\n\tif (!inf->comp_units) {\n\t\treturn -ENOMEM;\n\t}\n\n\tinf->capacity = DEBUG_INFO_CAPACITY;\n\tinf->length = 0;\n\n\treturn true;\n}\n\nstatic int r_bin_dwarf_init_die(RBinDwarfDIE *die) {\n\tif (!die) {\n\t\treturn -EINVAL;\n\t}\n\tdie->attr_values = calloc (sizeof (RBinDwarfAttrValue), 8);\n\tif (!die->attr_values) {\n\t\treturn -ENOMEM;\n\t}\n\tdie->capacity = 8;\n\tdie->length = 0;\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_expand_die(RBinDwarfDIE* die) {\n\tRBinDwarfAttrValue *tmp = NULL;\n\tif (!die || die->capacity == 0) {\n\t\treturn -EINVAL;\n\t}\n\tif (die->capacity != die->length) {\n\t\treturn -EINVAL;\n\t}\n\ttmp = (RBinDwarfAttrValue*)realloc (die->attr_values,\n\t\t\tdie->capacity * 2 * sizeof (RBinDwarfAttrValue));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ((ut8*)tmp + die->capacity, 0, die->capacity);\n\tdie->attr_values = tmp;\n\tdie->capacity *= 2;\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_init_comp_unit(RBinDwarfCompUnit *cu) {\n\tif (!cu) {\n\t\treturn -EINVAL;\n\t}\n\tcu->dies = calloc (sizeof (RBinDwarfDIE), COMP_UNIT_CAPACITY);\n\tif (!cu->dies) {\n\t\treturn -ENOMEM;\n\t}\n\tcu->capacity = COMP_UNIT_CAPACITY;\n\tcu->length = 0;\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_expand_cu(RBinDwarfCompUnit *cu) {\n\tRBinDwarfDIE *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->length) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfDIE*)realloc(cu->dies,\n\t\t\tcu->capacity * 2 * sizeof(RBinDwarfDIE));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8*)tmp + cu->capacity, 0, cu->capacity);\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_init_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tif (!ad) {\n\t\treturn -EINVAL;\n\t}\n\tad->specs = calloc (sizeof( RBinDwarfAttrSpec), ABBREV_DECL_CAP);\n\n\tif (!ad->specs) {\n\t\treturn -ENOMEM;\n\t}\n\n\tad->capacity = ABBREV_DECL_CAP;\n\tad->length = 0;\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_expand_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tRBinDwarfAttrSpec *tmp;\n\n\tif (!ad || !ad->capacity || ad->capacity != ad->length) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAttrSpec*)realloc (ad->specs,\n\t\t\tad->capacity * 2 * sizeof (RBinDwarfAttrSpec));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8*)tmp + ad->capacity, 0, ad->capacity);\n\tad->specs = tmp;\n\tad->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_init_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tif (!da) {\n\t\treturn -EINVAL;\n\t}\n\tda->decls = calloc (sizeof (RBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n\tif (!da->decls) {\n\t\treturn -ENOMEM;\n\t}\n\tda->capacity = DEBUG_ABBREV_CAP;\n\tda->length = 0;\n\n\treturn 0;\n}\n\nstatic int r_bin_dwarf_expand_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tRBinDwarfAbbrevDecl *tmp;\n\n\tif (!da || da->capacity == 0 || da->capacity != da->length) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAbbrevDecl*)realloc (da->decls,\n\t\t\tda->capacity * 2 * sizeof (RBinDwarfAbbrevDecl));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ((ut8*)tmp + da->capacity, 0, da->capacity);\n\n\tda->decls = tmp;\n\tda->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic void dump_r_bin_dwarf_debug_abbrev(FILE *f, RBinDwarfDebugAbbrev *da) {\n\tsize_t i, j;\n\tut64 attr_name, attr_form;\n\n\tif (!f || !da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->length; i++) {\n\t\tint declstag = da->decls[i].tag;\n\t\tfprintf (f, \"Abbreviation Code %\"PFMT64d\" \", da->decls[i].code);\n\t\tif (declstag>=0 && declstag < DW_TAG_LAST) {\n\t\t\tfprintf (f, \"Tag %s \", dwarf_tag_name_encodings[declstag]);\n\t\t}\n\t\tfprintf (f, \"[%s]\\n\", da->decls[i].has_children ?\n\t\t\t\t\"has children\" : \"no children\");\n\t\tfprintf (f, \"Offset 0x%\"PFMT64x\"\\n\", da->decls[i].offset);\n\n\t\tif (da->decls[i].specs) {\n\t\t\tfor (j = 0; j < da->decls[i].length; j++) {\n\t\t\t\tattr_name = da->decls[i].specs[j].attr_name;\n\t\t\t\tattr_form = da->decls[i].specs[j].attr_form;\n\t\t\t\tif (attr_name && attr_form &&\n\t\t\t\t\tattr_name <= DW_AT_vtable_elem_location &&\n\t\t\t\t\tattr_form <= DW_FORM_indirect) {\n\t\t\t\t\tfprintf (f, \"    %s %s\\n\",\n\t\t\t\t\t\t\tdwarf_attr_encodings[attr_name],\n\t\t\t\t\t\t\tdwarf_attr_form_encodings[attr_form]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_dwarf_free_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tsize_t i;\n\tif (!da) return;\n\tfor (i = 0; i < da->length; i++) {\n\t\tR_FREE (da->decls[i].specs);\n\t}\n\tR_FREE (da->decls);\n}\n\nstatic void r_bin_dwarf_free_attr_value(RBinDwarfAttrValue *val) {\n\tif (!val) {\n\t\treturn;\n\t}\n\tswitch (val->form) {\n\tcase DW_FORM_strp:\n\tcase DW_FORM_string:\n\t\tR_FREE (val->encoding.str_struct.string);\n\t\tbreak;\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tR_FREE (val->encoding.block.data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t};\n}\n\nstatic void r_bin_dwarf_free_die(RBinDwarfDIE *die) {\n\tsize_t i;\n\tif (!die) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < die->length; i++) {\n\t\tr_bin_dwarf_free_attr_value (&die->attr_values[i]);\n\t}\n\tR_FREE (die->attr_values);\n}\n\nstatic void r_bin_dwarf_free_comp_unit(RBinDwarfCompUnit *cu) {\n\tsize_t i;\n\tif (!cu) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < cu->length; i++) {\n\t\tif (cu->dies) {\n\t\t\tr_bin_dwarf_free_die (&cu->dies[i]);\n\t\t}\n\t}\n\tR_FREE (cu->dies);\n}\n\nstatic void r_bin_dwarf_free_debug_info (RBinDwarfDebugInfo *inf) {\n\tsize_t i;\n\tif (!inf) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->length; i++) {\n\t\tr_bin_dwarf_free_comp_unit (&inf->comp_units[i]);\n\t}\n\tR_FREE (inf->comp_units);\n}\n\nstatic void r_bin_dwarf_dump_attr_value(const RBinDwarfAttrValue *val, FILE *f) {\n\tsize_t i;\n\tif (!val || !f) {\n\t\treturn;\n\t}\n\tswitch (val->form) {\n\tcase DW_FORM_addr:\n\t\tfprintf (f, \"0x%\"PFMT64x\"\", val->encoding.address);\n\t\tbreak;\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tfprintf (f, \"%\"PFMT64u\" byte block:\", val->encoding.block.length);\n\t\tfor (i = 0; i < val->encoding.block.length; i++) {\n\t\t\tfprintf (f, \"%02x\", val->encoding.block.data[i]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\tcase DW_FORM_data2:\n\tcase DW_FORM_data4:\n\tcase DW_FORM_data8:\n\t\tfprintf (f, \"%\"PFMT64u\"\", val->encoding.data);\n\t\tif (val->name == DW_AT_language) {\n\t\t\tfprintf (f, \"   (%s)\", dwarf_langs[val->encoding.data]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_strp:\n\t\tfprintf (f, \"(indirect string, offset: 0x%\"PFMT64x\"): \",\n\t\t\t\tval->encoding.str_struct.offset);\n\tcase DW_FORM_string:\n\t\tif (val->encoding.str_struct.string) {\n\t\t\tfprintf (f, \"%s\", val->encoding.str_struct.string);\n\t\t} else {\n\t\t\tfprintf (f, \"No string found\");\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tfprintf (f, \"%u\", val->encoding.flag);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tfprintf (f, \"%\"PFMT64d\"\", val->encoding.sdata);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tfprintf (f, \"%\"PFMT64u\"\", val->encoding.data);\n\t\tbreak;\n\tcase DW_FORM_ref_addr:\n\t\tfprintf (f, \"<0x%\"PFMT64x\">\", val->encoding.reference);\n\t\tbreak;\n\tcase DW_FORM_ref1:\n\tcase DW_FORM_ref2:\n\tcase DW_FORM_ref4:\n\tcase DW_FORM_ref8:\n\t\tfprintf (f, \"<0x%\"PFMT64x\">\", val->encoding.reference);\n\t\tbreak;\n\tdefault:\n\t\tfprintf (f, \"Unknown attr value form %\"PFMT64d\"\\n\", val->form);\n\t};\n}\n\nstatic void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {\n\tsize_t i, j, k;\n\tRBinDwarfDIE *dies;\n\tRBinDwarfAttrValue *values;\n\tif (!inf || !f) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < inf->length; i++) {\n\t\tfprintf (f, \"  Compilation Unit @ offset 0x%\"PFMT64x\":\\n\", inf->comp_units [i].offset);\n\t\tfprintf (f, \"   Length:        0x%x\\n\", inf->comp_units [i].hdr.length);\n\t\tfprintf (f, \"   Version:       %d\\n\", inf->comp_units [i].hdr.version);\n\t\tfprintf (f, \"   Abbrev Offset: 0x%x\\n\", inf->comp_units [i].hdr.abbrev_offset);\n\t\tfprintf (f, \"   Pointer Size:  %d\\n\", inf->comp_units [i].hdr.pointer_size);\n\n\t\tdies = inf->comp_units[i].dies;\n\n\t\tfor (j = 0; j < inf->comp_units[i].length; j++) {\n\t\t\tfprintf (f, \"    Abbrev Number: %\"PFMT64u\" \", dies[j].abbrev_code);\n\n\t\t\tif (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&\n\t\t\t\t       dwarf_tag_name_encodings[dies[j].tag]) {\n\t\t\t\tfprintf (f, \"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tfprintf (f, \"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\n\t\t\tfor (k = 0; k < dies[j].length; k++) {\n\t\t\t\tif (!values[k].name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (values[k].name < DW_AT_vtable_elem_location &&\n\t\t\t\t\t\tdwarf_attr_encodings[values[k].name]) {\n\t\t\t\t\tfprintf (f, \"     %-18s : \", dwarf_attr_encodings[values[k].name]);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf (f, \"     TODO\\t\");\n\t\t\t\t}\n\t\t\t\tr_bin_dwarf_dump_attr_value (&values[k], f);\n\t\t\t\tfprintf (f, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrSpec *spec, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (!spec || !value || !hdr || !obuf || obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\tvalue->form = spec->attr_form;\n\tvalue->name = spec->attr_name;\n\tvalue->encoding.block.data = NULL;\n\tvalue->encoding.str_struct.string = NULL;\n\tvalue->encoding.str_struct.offset = 0;\n\n\tswitch (spec->attr_form) {\n\tcase DW_FORM_addr:\n\t\tswitch (hdr->pointer_size) {\n\t\tcase 1:\n\t\t\tvalue->encoding.address = READ (buf, ut8);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->encoding.address = READ (buf, ut16);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->encoding.address = READ (buf, ut32);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->encoding.address = READ (buf, ut64);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->pointer_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->encoding.block.length = READ (buf, ut16);\n\t\tif (value->encoding.block.length > 0) {\n\t\t\tvalue->encoding.block.data = calloc (sizeof(ut8), value->encoding.block.length);\n\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n\t\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->encoding.block.length = READ (buf, ut32);\n\t\tif (value->encoding.block.length > 0) {\n\t\t\tut8 *data = calloc (sizeof (ut8), value->encoding.block.length);\n\t\t\tif (data) {\n\t\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n\t\t\t\t\tdata[j] = READ (buf, ut8);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue->encoding.block.data = data;\n\t\t}\n\t\tbreak;\n#if 0\n// This causes segfaults to happen\n\tcase DW_FORM_data2:\n\t\tvalue->encoding.data = READ (buf, ut16);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->encoding.data = READ (buf, ut32);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->encoding.data = READ (buf, ut64);\n\t\tbreak;\n#endif\n\tcase DW_FORM_string:\n\t\tvalue->encoding.str_struct.string = *buf? strdup ((const char*)buf) : NULL;\n\t\tbuf += (strlen ((const char*)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->encoding.block.length);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length);\n\t\tif (value->encoding.block.data) {\n\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n\t\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->encoding.block.length = READ (buf, ut8);\n\t\tvalue->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length + 1);\n\t\tif (value->encoding.block.data) {\n\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n\t\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->encoding.flag = READ (buf, ut8);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tbuf = r_leb128 (buf, &value->encoding.sdata);\n\t\tbreak;\n\tcase DW_FORM_strp:\n\t\tvalue->encoding.str_struct.offset = READ (buf, ut32);\n\t\tif (debug_str && value->encoding.str_struct.offset < debug_str_len) {\n\t\t\tvalue->encoding.str_struct.string = strdup (\n\t\t\t\t(const char *)(debug_str +\n\t\t\t\t\tvalue->encoding.str_struct.offset));\n\t\t} else {\n\t\t\tvalue->encoding.str_struct.string = NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\t{\n\t\t\tut64 ndata = 0;\n\t\t\tconst ut8 *data = (const ut8*)&ndata;\n\t\t\tbuf = r_uleb128 (buf, R_MIN (sizeof (data), (size_t)(buf_end - buf)), &ndata);\n\t\t\tmemcpy (&value->encoding.data, data, sizeof (value->encoding.data));\n\t\t\tvalue->encoding.str_struct.string = NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_ref_addr:\n\t\tvalue->encoding.reference = READ (buf, ut64); // addr size of machine\n\t\tbreak;\n\tcase DW_FORM_ref1:\n\t\tvalue->encoding.reference = READ (buf, ut8);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->encoding.reference = READ (buf, ut16);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->encoding.reference = READ (buf, ut32);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->encoding.reference = READ (buf, ut64);\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->encoding.data = READ (buf, ut8);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\"PFMT64x\"\\n\", spec->attr_form);\n\t\tvalue->encoding.data = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\nstatic const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,\n\t\tRBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da,\n\t\tsize_t offset, const ut8 *debug_str, size_t debug_str_len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7);\n\tut64 abbr_code;\n\tsize_t i;\n\t\n\tif (cu->hdr.length > debug_str_len) {\n\t\t//avoid oob read\n\t\treturn NULL;\n\t}\n\twhile (buf && buf < buf_end && buf >= obuf) {\n\t\tif (cu->length && cu->capacity == cu->length) {\n\t\t\tr_bin_dwarf_expand_cu (cu);\n\t\t}\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code);\n\t\tif (abbr_code > da->length || !buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tr_bin_dwarf_init_die (&cu->dies[cu->length]);\n\t\tif (!abbr_code) {\n\t\t\tcu->dies[cu->length].abbrev_code = 0;\n\t\t\tcu->length++;\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu->dies[cu->length].abbrev_code = abbr_code;\n\t\tcu->dies[cu->length].tag = da->decls[abbr_code - 1].tag;\n\t\tabbr_code += offset;\n\n\t\tif (da->capacity < abbr_code) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < da->decls[abbr_code - 1].length; i++) {\n\t\t\tif (cu->dies[cu->length].length == cu->dies[cu->length].capacity) {\n\t\t\t\tr_bin_dwarf_expand_die (&cu->dies[cu->length]);\n\t\t\t}\n\t\t\tif (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) {\n\t\t\t\teprintf (\"Warning: malformed dwarf attribute capacity doesn't match length\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));\n\t\t\tbuf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,\n\t\t\t\t\t&da->decls[abbr_code - 1].specs[i],\n\t\t\t\t\t&cu->dies[cu->length].attr_values[i],\n\t\t\t\t\t&cu->hdr, debug_str, debug_str_len);\n\t\t\tif (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {\n\t\t\t\tconst char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string;\n\t\t\t\tif (name > 1024) { // solve some null derefs\n\t\t\t\t\tsdb_set (s, \"DW_AT_comp_dir\", name, 0);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid string pointer at %p\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcu->dies[cu->length].length++;\n\t\t}\n\t\tcu->length++;\n\t}\n\treturn buf;\n}\n\nR_API int r_bin_dwarf_parse_info_raw(Sdb *s, RBinDwarfDebugAbbrev *da,\n\t\tconst ut8 *obuf, size_t len,\n\t\tconst ut8 *debug_str, size_t debug_str_len, int mode) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tsize_t k, offset = 0;\n\tint curr_unit = 0;\n\tRBinDwarfDebugInfo di = {0};\n\tRBinDwarfDebugInfo *inf = &di;\n\tbool ret = true;\n\n\tif (!da || !s || !obuf) {\n\t\treturn false;\n\t}\n\n\tif (r_bin_dwarf_init_debug_info (inf) < 0) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\twhile (buf < buf_end) {\n\t\tif (inf->length >= inf->capacity)\n\t\t\tbreak;\n\n\t\tif (r_bin_dwarf_init_comp_unit (&inf->comp_units[curr_unit]) < 0) {\n\t\t\tret = false;\n\t\t\tcurr_unit--;\n\t\t\tgoto out_debug_info;\n\t\t}\n\n\t\tinf->comp_units[curr_unit].offset = buf - obuf;\n\t\tinf->comp_units[curr_unit].hdr.pointer_size = 0;\n\t\tinf->comp_units[curr_unit].hdr.abbrev_offset = 0;\n\t\tinf->comp_units[curr_unit].hdr.length = READ (buf, ut32);\n\t\tinf->comp_units[curr_unit].hdr.version = READ (buf, ut16);\n\n\t\tif (inf->comp_units[curr_unit].hdr.version != 2) {\n//\t\t\teprintf (\"DWARF: version %d is not yet supported.\\n\",\n//\t\t\t\t\tinf->comp_units[curr_unit].hdr.version);\n\t\t\tret = false;\n\t\t\tgoto out_debug_info;\n\t\t}\n\t\tif (inf->comp_units[curr_unit].hdr.length > len) {\n\t\t\tret = false;\n\t\t\tgoto out_debug_info;\n\t\t}\n\n\t\tinf->comp_units[curr_unit].hdr.abbrev_offset = READ (buf, ut32);\n\t\tinf->comp_units[curr_unit].hdr.pointer_size = READ (buf, ut8);\n\t\tinf->length++;\n\n\t\t/* Linear search FIXME */\n\t\tif (da->decls->length >= da->capacity) {\n\t\t\teprintf (\"WARNING: malformed dwarf have not enough buckets for decls.\\n\");\n\t\t}\n\t\tconst int k_max = R_MIN (da->capacity, da->decls->length);\n\t\tfor (k = 0; k < k_max; k++) {\n\t\t\tif (da->decls[k].offset ==\n\t\t\t\tinf->comp_units[curr_unit].hdr.abbrev_offset) {\n\t\t\t\toffset = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbuf = r_bin_dwarf_parse_comp_unit (s, buf, &inf->comp_units[curr_unit],\n\t\t\tda, offset, debug_str, debug_str_len);\n\n\t\tif (!buf) {\n\t\t\tret = false;\n\t\t\tgoto out_debug_info;\n\t\t}\n\n\t\tcurr_unit++;\n\t}\n\n\tif (mode == R_CORE_BIN_PRINT) {\n\t\tr_bin_dwarf_dump_debug_info (NULL, inf);\n\t}\n\nout_debug_info:\n\tfor (; curr_unit >= 0; curr_unit--) {\n\t\tr_bin_dwarf_free_comp_unit (&inf->comp_units[curr_unit]);\n\t}\n\tr_bin_dwarf_free_debug_info (inf);\nout:\n\treturn ret;\n}\n\nstatic RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev_raw(const ut8 *obuf, size_t len, int mode) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, spec1, spec2, offset;\n\tut8 has_children;\n\tRBinDwarfAbbrevDecl *tmpdecl;\n\n\t// XXX - Set a suitable value here.\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *da = R_NEW0 (RBinDwarfDebugAbbrev);\n\n\tr_bin_dwarf_init_debug_abbrev (da);\n\n\twhile (buf && buf+1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp);\n\t\tif (!buf || !tmp) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->length == da->capacity) {\n\t\t\tr_bin_dwarf_expand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->length];\n\t\tr_bin_dwarf_init_abbrev_decl (tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ (buf, ut8);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->length == tmpdecl->capacity) {\n\t\t\t\tr_bin_dwarf_expand_abbrev_decl (tmpdecl);\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &spec1);\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &spec2);\n\t\t\ttmpdecl->specs[tmpdecl->length].attr_name = spec1;\n\t\t\ttmpdecl->specs[tmpdecl->length].attr_form = spec2;\n\t\t\ttmpdecl->length++;\n\t\t} while (spec1 && spec2);\n\n\t\tda->length++;\n\t}\n\n\tif (mode == R_CORE_BIN_PRINT) {\n\t\tdump_r_bin_dwarf_debug_abbrev (stdout, da);\n\t}\n\treturn da;\n}\n\nRBinSection *getsection(RBin *a, const char *sn) {\n\tRListIter *iter;\n\tRBinSection *section = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\n\tif ( o && o->sections) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (strstr (section->name, sn)) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API int r_bin_dwarf_parse_info(RBinDwarfDebugAbbrev *da, RBin *a, int mode) {\n\tut8 *buf, *debug_str_buf = 0;\n\tint len, debug_str_len = 0, ret;\n\tRBinSection *debug_str;\n\tRBinSection *section = getsection (a, \"debug_info\");\n\tRBinFile *binfile = a ? a->cur: NULL;\n\n\tif (binfile && section) {\n\t\tdebug_str = getsection (a, \"debug_str\");\n\t\tif (debug_str) {\n\t\t\tdebug_str_len = debug_str->size;\n\t\t\tdebug_str_buf = calloc (1, debug_str_len + 1);\n\t\t\tret = r_buf_read_at (binfile->buf, debug_str->paddr,\n\t\t\t\t\t     debug_str_buf, debug_str_len);\n\t\t\tif (!ret) {\n\t\t\t\tfree (debug_str_buf);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlen = section->size;\n\t\tif (len > (UT32_MAX >> 1) || len < 1) {\n\t\t\tfree (debug_str_buf);\n\t\t\treturn false;\n\t\t}\n\t\tbuf = calloc (1, len);\n\t\tif (!buf) {\n\t\t\tfree (debug_str_buf);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_buf_read_at (binfile->buf, section->paddr, buf, len)) {\n\t\t\tfree (debug_str_buf);\n\t\t\tfree (buf);\n\t\t\treturn false;\n\t\t}\n\t\tret = r_bin_dwarf_parse_info_raw (binfile->sdb_addrinfo, da, buf, len,\n\t\t\t\tdebug_str_buf, debug_str_len, mode);\n\t\tR_FREE (debug_str_buf);\n\t\tfree (buf);\n\t\treturn ret;\n\t}\n\treturn false;\n}\n\nstatic RBinDwarfRow *r_bin_dwarf_row_new (ut64 addr, const char *file, int line, int col) {\n\tRBinDwarfRow *row = R_NEW0 (RBinDwarfRow);\n\tif (!row) {\n\t\treturn NULL;\n\t}\n\trow->file = strdup (file);\n\trow->address = addr;\n\trow->line = line;\n\trow->column = 0;\n\treturn row;\n}\n\nstatic void r_bin_dwarf_row_free(void *p) {\n\tRBinDwarfRow *row = (RBinDwarfRow*)p;\n\tfree (row->file);\n\tfree (row);\n}\n\nR_API RList *r_bin_dwarf_parse_line(RBin *a, int mode) {\n\tut8 *buf;\n\tRList *list = NULL;\n\tint len, ret;\n\tRBinSection *section = getsection (a, \"debug_line\");\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len + 1);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (ret != len) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist = r_list_new (); // always return empty list wtf\n\t\tif (!list) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist->free = r_bin_dwarf_row_free;\n\t\tr_bin_dwarf_parse_line_raw2 (a, buf, len, mode);\n\t\t// k bin/cur/addrinfo/*\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tSdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tif (!strncmp (kv->key, \"0x\", 2)) {\n\t\t\t\tut64 addr;\n\t\t\t\tRBinDwarfRow *row;\n\t\t\t\tint line;\n\t\t\t\tchar *file = strdup (kv->value);\n\t\t\t\tif (!file) {\n\t\t\t\t\tfree (buf);\n\t\t\t\t\tls_free (ls);\n\t\t\t\t\tr_list_free (list);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tchar *tok = strchr (file, '|');\n\t\t\t\tif (tok) {\n\t\t\t\t\t*tok++ = 0;\n\t\t\t\t\tline = atoi (tok);\n\t\t\t\t\taddr = r_num_math (NULL, kv->key);\n\t\t\t\t\trow = r_bin_dwarf_row_new (addr, file, line, 0);\n\t\t\t\t\tr_list_append (list, row);\n\t\t\t\t}\n\t\t\t\tfree (file);\n\t\t\t}\n\t\t}\n\t\tls_free (ls);\n\t\tfree (buf);\n\t}\n\treturn list;\n}\n\nR_API RList *r_bin_dwarf_parse_aranges(RBin *a, int mode) {\n\tut8 *buf;\n\tint ret;\n\tsize_t len;\n\tRBinSection *section = getsection (a, \"debug_aranges\");\n\tRBinFile *binfile = a ? a->cur: NULL;\n\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1 || len > ST32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len);\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (!ret) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (mode == R_CORE_BIN_PRINT) {\n\t\t\tr_bin_dwarf_parse_aranges_raw (buf, len, stdout);\n\t\t} else {\n\t\t\tr_bin_dwarf_parse_aranges_raw (buf, len, DBGFD);\n\t\t}\n\t\tfree (buf);\n\t}\n\treturn NULL;\n}\n\nR_API RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev(RBin *a, int mode) {\n\tut8 *buf;\n\tsize_t len;\n\tRBinSection *section = getsection (a, \"debug_abbrev\");\n\tRBinDwarfDebugAbbrev *da = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tif (!section || !binfile) return NULL;\n\tif (section->size > binfile->size) {\n\t\treturn NULL;\n\t}\n\tlen = section->size;\n\tbuf = calloc (1,len);\n\tr_buf_read_at (binfile->buf, section->paddr, buf, len);\n\tda = r_bin_dwarf_parse_abbrev_raw (buf, len, mode);\n\tfree (buf);\n\treturn da;\n}\n"], "filenames": ["libr/bin/dwarf.c"], "buggy_code_start_loc": [1364], "buggy_code_end_loc": [1365], "fixing_code_start_loc": [1364], "fixing_code_end_loc": [1369], "type": "CWE-119", "message": "The sdb_set_internal function in sdb.c in radare2 2.7.0 allows remote attackers to cause a denial of service (invalid read and application crash) via a crafted ELF file because of missing input validation in r_bin_dwarf_parse_comp_unit in libr/bin/dwarf.c.", "other": {"cve": {"id": "CVE-2018-14015", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-12T20:29:00.180", "lastModified": "2020-10-15T13:37:28.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The sdb_set_internal function in sdb.c in radare2 2.7.0 allows remote attackers to cause a denial of service (invalid read and application crash) via a crafted ELF file because of missing input validation in r_bin_dwarf_parse_comp_unit in libr/bin/dwarf.c."}, {"lang": "es", "value": "La funci\u00f3n sdb_set_internal en sdb.c en radare2 2.7.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura no v\u00e1lida y cierre inesperado de la aplicaci\u00f3n) mediante un archivo ELF manipulado debido a la falta validaci\u00f3n de entradas en r_bin_dwarf_parse_comp_unit en libr/bin/dwarf.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "693C6349-1A2D-48F3-A861-9E3F7832D174"}]}]}], "references": [{"url": "https://github.com/radare/radare2/issues/10465", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/commit/d37d2b858ac47f2f108034be0bcecadaddfbc8b3", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/d37d2b858ac47f2f108034be0bcecadaddfbc8b3"}}