{"buggy_code": ["# frozen_string_literal: true\n#\n# = net/imap.rb\n#\n# Copyright (C) 2000  Shugo Maeda <shugo@ruby-lang.org>\n#\n# This library is distributed under the terms of the Ruby license.\n# You can freely distribute/modify this library.\n#\n# Documentation: Shugo Maeda, with RDoc conversion and overview by William\n# Webber.\n#\n# See Net::IMAP for documentation.\n#\n\n\nrequire \"socket\"\nrequire \"monitor\"\nrequire \"digest/md5\"\nrequire \"strscan\"\nrequire_relative 'protocol'\nbegin\n  require \"openssl\"\nrescue LoadError\nend\n\nmodule Net\n\n  #\n  # Net::IMAP implements Internet Message Access Protocol (IMAP) client\n  # functionality.  The protocol is described in [IMAP].\n  #\n  # == IMAP Overview\n  #\n  # An IMAP client connects to a server, and then authenticates\n  # itself using either #authenticate() or #login().  Having\n  # authenticated itself, there is a range of commands\n  # available to it.  Most work with mailboxes, which may be\n  # arranged in an hierarchical namespace, and each of which\n  # contains zero or more messages.  How this is implemented on\n  # the server is implementation-dependent; on a UNIX server, it\n  # will frequently be implemented as files in mailbox format\n  # within a hierarchy of directories.\n  #\n  # To work on the messages within a mailbox, the client must\n  # first select that mailbox, using either #select() or (for\n  # read-only access) #examine().  Once the client has successfully\n  # selected a mailbox, they enter _selected_ state, and that\n  # mailbox becomes the _current_ mailbox, on which mail-item\n  # related commands implicitly operate.\n  #\n  # Messages have two sorts of identifiers: message sequence\n  # numbers and UIDs.\n  #\n  # Message sequence numbers number messages within a mailbox\n  # from 1 up to the number of items in the mailbox.  If a new\n  # message arrives during a session, it receives a sequence\n  # number equal to the new size of the mailbox.  If messages\n  # are expunged from the mailbox, remaining messages have their\n  # sequence numbers \"shuffled down\" to fill the gaps.\n  #\n  # UIDs, on the other hand, are permanently guaranteed not to\n  # identify another message within the same mailbox, even if\n  # the existing message is deleted.  UIDs are required to\n  # be assigned in ascending (but not necessarily sequential)\n  # order within a mailbox; this means that if a non-IMAP client\n  # rearranges the order of mailitems within a mailbox, the\n  # UIDs have to be reassigned.  An IMAP client thus cannot\n  # rearrange message orders.\n  #\n  # == Examples of Usage\n  #\n  # === List sender and subject of all recent messages in the default mailbox\n  #\n  #   imap = Net::IMAP.new('mail.example.com')\n  #   imap.authenticate('LOGIN', 'joe_user', 'joes_password')\n  #   imap.examine('INBOX')\n  #   imap.search([\"RECENT\"]).each do |message_id|\n  #     envelope = imap.fetch(message_id, \"ENVELOPE\")[0].attr[\"ENVELOPE\"]\n  #     puts \"#{envelope.from[0].name}: \\t#{envelope.subject}\"\n  #   end\n  #\n  # === Move all messages from April 2003 from \"Mail/sent-mail\" to \"Mail/sent-apr03\"\n  #\n  #   imap = Net::IMAP.new('mail.example.com')\n  #   imap.authenticate('LOGIN', 'joe_user', 'joes_password')\n  #   imap.select('Mail/sent-mail')\n  #   if not imap.list('Mail/', 'sent-apr03')\n  #     imap.create('Mail/sent-apr03')\n  #   end\n  #   imap.search([\"BEFORE\", \"30-Apr-2003\", \"SINCE\", \"1-Apr-2003\"]).each do |message_id|\n  #     imap.copy(message_id, \"Mail/sent-apr03\")\n  #     imap.store(message_id, \"+FLAGS\", [:Deleted])\n  #   end\n  #   imap.expunge\n  #\n  # == Thread Safety\n  #\n  # Net::IMAP supports concurrent threads. For example,\n  #\n  #   imap = Net::IMAP.new(\"imap.foo.net\", \"imap2\")\n  #   imap.authenticate(\"cram-md5\", \"bar\", \"password\")\n  #   imap.select(\"inbox\")\n  #   fetch_thread = Thread.start { imap.fetch(1..-1, \"UID\") }\n  #   search_result = imap.search([\"BODY\", \"hello\"])\n  #   fetch_result = fetch_thread.value\n  #   imap.disconnect\n  #\n  # This script invokes the FETCH command and the SEARCH command concurrently.\n  #\n  # == Errors\n  #\n  # An IMAP server can send three different types of responses to indicate\n  # failure:\n  #\n  # NO:: the attempted command could not be successfully completed.  For\n  #      instance, the username/password used for logging in are incorrect;\n  #      the selected mailbox does not exist; etc.\n  #\n  # BAD:: the request from the client does not follow the server's\n  #       understanding of the IMAP protocol.  This includes attempting\n  #       commands from the wrong client state; for instance, attempting\n  #       to perform a SEARCH command without having SELECTed a current\n  #       mailbox.  It can also signal an internal server\n  #       failure (such as a disk crash) has occurred.\n  #\n  # BYE:: the server is saying goodbye.  This can be part of a normal\n  #       logout sequence, and can be used as part of a login sequence\n  #       to indicate that the server is (for some reason) unwilling\n  #       to accept your connection.  As a response to any other command,\n  #       it indicates either that the server is shutting down, or that\n  #       the server is timing out the client connection due to inactivity.\n  #\n  # These three error response are represented by the errors\n  # Net::IMAP::NoResponseError, Net::IMAP::BadResponseError, and\n  # Net::IMAP::ByeResponseError, all of which are subclasses of\n  # Net::IMAP::ResponseError.  Essentially, all methods that involve\n  # sending a request to the server can generate one of these errors.\n  # Only the most pertinent instances have been documented below.\n  #\n  # Because the IMAP class uses Sockets for communication, its methods\n  # are also susceptible to the various errors that can occur when\n  # working with sockets.  These are generally represented as\n  # Errno errors.  For instance, any method that involves sending a\n  # request to the server and/or receiving a response from it could\n  # raise an Errno::EPIPE error if the network connection unexpectedly\n  # goes down.  See the socket(7), ip(7), tcp(7), socket(2), connect(2),\n  # and associated man pages.\n  #\n  # Finally, a Net::IMAP::DataFormatError is thrown if low-level data\n  # is found to be in an incorrect format (for instance, when converting\n  # between UTF-8 and UTF-16), and Net::IMAP::ResponseParseError is\n  # thrown if a server response is non-parseable.\n  #\n  #\n  # == References\n  #\n  # [[IMAP]]\n  #    M. Crispin, \"INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1\",\n  #    RFC 2060, December 1996.  (Note: since obsoleted by RFC 3501)\n  #\n  # [[LANGUAGE-TAGS]]\n  #    Alvestrand, H., \"Tags for the Identification of\n  #    Languages\", RFC 1766, March 1995.\n  #\n  # [[MD5]]\n  #    Myers, J., and M. Rose, \"The Content-MD5 Header Field\", RFC\n  #    1864, October 1995.\n  #\n  # [[MIME-IMB]]\n  #    Freed, N., and N. Borenstein, \"MIME (Multipurpose Internet\n  #    Mail Extensions) Part One: Format of Internet Message Bodies\", RFC\n  #    2045, November 1996.\n  #\n  # [[RFC-822]]\n  #    Crocker, D., \"Standard for the Format of ARPA Internet Text\n  #    Messages\", STD 11, RFC 822, University of Delaware, August 1982.\n  #\n  # [[RFC-2087]]\n  #    Myers, J., \"IMAP4 QUOTA extension\", RFC 2087, January 1997.\n  #\n  # [[RFC-2086]]\n  #    Myers, J., \"IMAP4 ACL extension\", RFC 2086, January 1997.\n  #\n  # [[RFC-2195]]\n  #    Klensin, J., Catoe, R., and Krumviede, P., \"IMAP/POP AUTHorize Extension\n  #    for Simple Challenge/Response\", RFC 2195, September 1997.\n  #\n  # [[SORT-THREAD-EXT]]\n  #    Crispin, M., \"INTERNET MESSAGE ACCESS PROTOCOL - SORT and THREAD\n  #    Extensions\", draft-ietf-imapext-sort, May 2003.\n  #\n  # [[OSSL]]\n  #    http://www.openssl.org\n  #\n  # [[RSSL]]\n  #    http://savannah.gnu.org/projects/rubypki\n  #\n  # [[UTF7]]\n  #    Goldsmith, D. and Davis, M., \"UTF-7: A Mail-Safe Transformation Format of\n  #    Unicode\", RFC 2152, May 1997.\n  #\n  class IMAP < Protocol\n    include MonitorMixin\n    if defined?(OpenSSL::SSL)\n      include OpenSSL\n      include SSL\n    end\n\n    #  Returns an initial greeting response from the server.\n    attr_reader :greeting\n\n    # Returns recorded untagged responses.  For example:\n    #\n    #   imap.select(\"inbox\")\n    #   p imap.responses[\"EXISTS\"][-1]\n    #   #=> 2\n    #   p imap.responses[\"UIDVALIDITY\"][-1]\n    #   #=> 968263756\n    attr_reader :responses\n\n    # Returns all response handlers.\n    attr_reader :response_handlers\n\n    # Seconds to wait until a connection is opened.\n    # If the IMAP object cannot open a connection within this time,\n    # it raises a Net::OpenTimeout exception. The default value is 30 seconds.\n    attr_reader :open_timeout\n\n    # The thread to receive exceptions.\n    attr_accessor :client_thread\n\n    # Flag indicating a message has been seen.\n    SEEN = :Seen\n\n    # Flag indicating a message has been answered.\n    ANSWERED = :Answered\n\n    # Flag indicating a message has been flagged for special or urgent\n    # attention.\n    FLAGGED = :Flagged\n\n    # Flag indicating a message has been marked for deletion.  This\n    # will occur when the mailbox is closed or expunged.\n    DELETED = :Deleted\n\n    # Flag indicating a message is only a draft or work-in-progress version.\n    DRAFT = :Draft\n\n    # Flag indicating that the message is \"recent,\" meaning that this\n    # session is the first session in which the client has been notified\n    # of this message.\n    RECENT = :Recent\n\n    # Flag indicating that a mailbox context name cannot contain\n    # children.\n    NOINFERIORS = :Noinferiors\n\n    # Flag indicating that a mailbox is not selected.\n    NOSELECT = :Noselect\n\n    # Flag indicating that a mailbox has been marked \"interesting\" by\n    # the server; this commonly indicates that the mailbox contains\n    # new messages.\n    MARKED = :Marked\n\n    # Flag indicating that the mailbox does not contains new messages.\n    UNMARKED = :Unmarked\n\n    # Returns the debug mode.\n    def self.debug\n      return @@debug\n    end\n\n    # Sets the debug mode.\n    def self.debug=(val)\n      return @@debug = val\n    end\n\n    # Returns the max number of flags interned to symbols.\n    def self.max_flag_count\n      return @@max_flag_count\n    end\n\n    # Sets the max number of flags interned to symbols.\n    def self.max_flag_count=(count)\n      @@max_flag_count = count\n    end\n\n    # Adds an authenticator for Net::IMAP#authenticate.  +auth_type+\n    # is the type of authentication this authenticator supports\n    # (for instance, \"LOGIN\").  The +authenticator+ is an object\n    # which defines a process() method to handle authentication with\n    # the server.  See Net::IMAP::LoginAuthenticator,\n    # Net::IMAP::CramMD5Authenticator, and Net::IMAP::DigestMD5Authenticator\n    # for examples.\n    #\n    #\n    # If +auth_type+ refers to an existing authenticator, it will be\n    # replaced by the new one.\n    def self.add_authenticator(auth_type, authenticator)\n      @@authenticators[auth_type] = authenticator\n    end\n\n    # The default port for IMAP connections, port 143\n    def self.default_port\n      return PORT\n    end\n\n    # The default port for IMAPS connections, port 993\n    def self.default_tls_port\n      return SSL_PORT\n    end\n\n    class << self\n      alias default_imap_port default_port\n      alias default_imaps_port default_tls_port\n      alias default_ssl_port default_tls_port\n    end\n\n    # Disconnects from the server.\n    def disconnect\n      return if disconnected?\n      begin\n        begin\n          # try to call SSL::SSLSocket#io.\n          @sock.io.shutdown\n        rescue NoMethodError\n          # @sock is not an SSL::SSLSocket.\n          @sock.shutdown\n        end\n      rescue Errno::ENOTCONN\n        # ignore `Errno::ENOTCONN: Socket is not connected' on some platforms.\n      rescue Exception => e\n        @receiver_thread.raise(e)\n      end\n      @receiver_thread.join\n      synchronize do\n        @sock.close\n      end\n      raise e if e\n    end\n\n    # Returns true if disconnected from the server.\n    def disconnected?\n      return @sock.closed?\n    end\n\n    # Sends a CAPABILITY command, and returns an array of\n    # capabilities that the server supports.  Each capability\n    # is a string.  See [IMAP] for a list of possible\n    # capabilities.\n    #\n    # Note that the Net::IMAP class does not modify its\n    # behaviour according to the capabilities of the server;\n    # it is up to the user of the class to ensure that\n    # a certain capability is supported by a server before\n    # using it.\n    def capability\n      synchronize do\n        send_command(\"CAPABILITY\")\n        return @responses.delete(\"CAPABILITY\")[-1]\n      end\n    end\n\n    # Sends a NOOP command to the server. It does nothing.\n    def noop\n      send_command(\"NOOP\")\n    end\n\n    # Sends a LOGOUT command to inform the server that the client is\n    # done with the connection.\n    def logout\n      send_command(\"LOGOUT\")\n    end\n\n    # Sends a STARTTLS command to start TLS session.\n    def starttls(options = {}, verify = true)\n      send_command(\"STARTTLS\") do |resp|\n        if resp.kind_of?(TaggedResponse) && resp.name == \"OK\"\n          begin\n            # for backward compatibility\n            certs = options.to_str\n            options = create_ssl_params(certs, verify)\n          rescue NoMethodError\n          end\n          start_tls_session(options)\n        end\n      end\n    end\n\n    # Sends an AUTHENTICATE command to authenticate the client.\n    # The +auth_type+ parameter is a string that represents\n    # the authentication mechanism to be used. Currently Net::IMAP\n    # supports the authentication mechanisms:\n    #\n    #   LOGIN:: login using cleartext user and password.\n    #   CRAM-MD5:: login with cleartext user and encrypted password\n    #              (see [RFC-2195] for a full description).  This\n    #              mechanism requires that the server have the user's\n    #              password stored in clear-text password.\n    #\n    # For both of these mechanisms, there should be two +args+: username\n    # and (cleartext) password.  A server may not support one or the other\n    # of these mechanisms; check #capability() for a capability of\n    # the form \"AUTH=LOGIN\" or \"AUTH=CRAM-MD5\".\n    #\n    # Authentication is done using the appropriate authenticator object:\n    # see @@authenticators for more information on plugging in your own\n    # authenticator.\n    #\n    # For example:\n    #\n    #    imap.authenticate('LOGIN', user, password)\n    #\n    # A Net::IMAP::NoResponseError is raised if authentication fails.\n    def authenticate(auth_type, *args)\n      auth_type = auth_type.upcase\n      unless @@authenticators.has_key?(auth_type)\n        raise ArgumentError,\n          format('unknown auth type - \"%s\"', auth_type)\n      end\n      authenticator = @@authenticators[auth_type].new(*args)\n      send_command(\"AUTHENTICATE\", auth_type) do |resp|\n        if resp.instance_of?(ContinuationRequest)\n          data = authenticator.process(resp.data.text.unpack(\"m\")[0])\n          s = [data].pack(\"m0\")\n          send_string_data(s)\n          put_string(CRLF)\n        end\n      end\n    end\n\n    # Sends a LOGIN command to identify the client and carries\n    # the plaintext +password+ authenticating this +user+.  Note\n    # that, unlike calling #authenticate() with an +auth_type+\n    # of \"LOGIN\", #login() does *not* use the login authenticator.\n    #\n    # A Net::IMAP::NoResponseError is raised if authentication fails.\n    def login(user, password)\n      send_command(\"LOGIN\", user, password)\n    end\n\n    # Sends a SELECT command to select a +mailbox+ so that messages\n    # in the +mailbox+ can be accessed.\n    #\n    # After you have selected a mailbox, you may retrieve the\n    # number of items in that mailbox from @responses[\"EXISTS\"][-1],\n    # and the number of recent messages from @responses[\"RECENT\"][-1].\n    # Note that these values can change if new messages arrive\n    # during a session; see #add_response_handler() for a way of\n    # detecting this event.\n    #\n    # A Net::IMAP::NoResponseError is raised if the mailbox does not\n    # exist or is for some reason non-selectable.\n    def select(mailbox)\n      synchronize do\n        @responses.clear\n        send_command(\"SELECT\", mailbox)\n      end\n    end\n\n    # Sends a EXAMINE command to select a +mailbox+ so that messages\n    # in the +mailbox+ can be accessed.  Behaves the same as #select(),\n    # except that the selected +mailbox+ is identified as read-only.\n    #\n    # A Net::IMAP::NoResponseError is raised if the mailbox does not\n    # exist or is for some reason non-examinable.\n    def examine(mailbox)\n      synchronize do\n        @responses.clear\n        send_command(\"EXAMINE\", mailbox)\n      end\n    end\n\n    # Sends a CREATE command to create a new +mailbox+.\n    #\n    # A Net::IMAP::NoResponseError is raised if a mailbox with that name\n    # cannot be created.\n    def create(mailbox)\n      send_command(\"CREATE\", mailbox)\n    end\n\n    # Sends a DELETE command to remove the +mailbox+.\n    #\n    # A Net::IMAP::NoResponseError is raised if a mailbox with that name\n    # cannot be deleted, either because it does not exist or because the\n    # client does not have permission to delete it.\n    def delete(mailbox)\n      send_command(\"DELETE\", mailbox)\n    end\n\n    # Sends a RENAME command to change the name of the +mailbox+ to\n    # +newname+.\n    #\n    # A Net::IMAP::NoResponseError is raised if a mailbox with the\n    # name +mailbox+ cannot be renamed to +newname+ for whatever\n    # reason; for instance, because +mailbox+ does not exist, or\n    # because there is already a mailbox with the name +newname+.\n    def rename(mailbox, newname)\n      send_command(\"RENAME\", mailbox, newname)\n    end\n\n    # Sends a SUBSCRIBE command to add the specified +mailbox+ name to\n    # the server's set of \"active\" or \"subscribed\" mailboxes as returned\n    # by #lsub().\n    #\n    # A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be\n    # subscribed to; for instance, because it does not exist.\n    def subscribe(mailbox)\n      send_command(\"SUBSCRIBE\", mailbox)\n    end\n\n    # Sends a UNSUBSCRIBE command to remove the specified +mailbox+ name\n    # from the server's set of \"active\" or \"subscribed\" mailboxes.\n    #\n    # A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be\n    # unsubscribed from; for instance, because the client is not currently\n    # subscribed to it.\n    def unsubscribe(mailbox)\n      send_command(\"UNSUBSCRIBE\", mailbox)\n    end\n\n    # Sends a LIST command, and returns a subset of names from\n    # the complete set of all names available to the client.\n    # +refname+ provides a context (for instance, a base directory\n    # in a directory-based mailbox hierarchy).  +mailbox+ specifies\n    # a mailbox or (via wildcards) mailboxes under that context.\n    # Two wildcards may be used in +mailbox+: '*', which matches\n    # all characters *including* the hierarchy delimiter (for instance,\n    # '/' on a UNIX-hosted directory-based mailbox hierarchy); and '%',\n    # which matches all characters *except* the hierarchy delimiter.\n    #\n    # If +refname+ is empty, +mailbox+ is used directly to determine\n    # which mailboxes to match.  If +mailbox+ is empty, the root\n    # name of +refname+ and the hierarchy delimiter are returned.\n    #\n    # The return value is an array of +Net::IMAP::MailboxList+. For example:\n    #\n    #   imap.create(\"foo/bar\")\n    #   imap.create(\"foo/baz\")\n    #   p imap.list(\"\", \"foo/%\")\n    #   #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim=\"/\", name=\"foo/\">, \\\\\n    #        #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim=\"/\", name=\"foo/bar\">, \\\\\n    #        #<Net::IMAP::MailboxList attr=[:Noinferiors], delim=\"/\", name=\"foo/baz\">]\n    def list(refname, mailbox)\n      synchronize do\n        send_command(\"LIST\", refname, mailbox)\n        return @responses.delete(\"LIST\")\n      end\n    end\n\n    # Sends a XLIST command, and returns a subset of names from\n    # the complete set of all names available to the client.\n    # +refname+ provides a context (for instance, a base directory\n    # in a directory-based mailbox hierarchy).  +mailbox+ specifies\n    # a mailbox or (via wildcards) mailboxes under that context.\n    # Two wildcards may be used in +mailbox+: '*', which matches\n    # all characters *including* the hierarchy delimiter (for instance,\n    # '/' on a UNIX-hosted directory-based mailbox hierarchy); and '%',\n    # which matches all characters *except* the hierarchy delimiter.\n    #\n    # If +refname+ is empty, +mailbox+ is used directly to determine\n    # which mailboxes to match.  If +mailbox+ is empty, the root\n    # name of +refname+ and the hierarchy delimiter are returned.\n    #\n    # The XLIST command is like the LIST command except that the flags\n    # returned refer to the function of the folder/mailbox, e.g. :Sent\n    #\n    # The return value is an array of +Net::IMAP::MailboxList+. For example:\n    #\n    #   imap.create(\"foo/bar\")\n    #   imap.create(\"foo/baz\")\n    #   p imap.xlist(\"\", \"foo/%\")\n    #   #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim=\"/\", name=\"foo/\">, \\\\\n    #        #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim=\"/\", name=\"foo/bar\">, \\\\\n    #        #<Net::IMAP::MailboxList attr=[:Noinferiors], delim=\"/\", name=\"foo/baz\">]\n    def xlist(refname, mailbox)\n      synchronize do\n        send_command(\"XLIST\", refname, mailbox)\n        return @responses.delete(\"XLIST\")\n      end\n    end\n\n    # Sends the GETQUOTAROOT command along with the specified +mailbox+.\n    # This command is generally available to both admin and user.\n    # If this mailbox exists, it returns an array containing objects of type\n    # Net::IMAP::MailboxQuotaRoot and Net::IMAP::MailboxQuota.\n    def getquotaroot(mailbox)\n      synchronize do\n        send_command(\"GETQUOTAROOT\", mailbox)\n        result = []\n        result.concat(@responses.delete(\"QUOTAROOT\"))\n        result.concat(@responses.delete(\"QUOTA\"))\n        return result\n      end\n    end\n\n    # Sends the GETQUOTA command along with specified +mailbox+.\n    # If this mailbox exists, then an array containing a\n    # Net::IMAP::MailboxQuota object is returned.  This\n    # command is generally only available to server admin.\n    def getquota(mailbox)\n      synchronize do\n        send_command(\"GETQUOTA\", mailbox)\n        return @responses.delete(\"QUOTA\")\n      end\n    end\n\n    # Sends a SETQUOTA command along with the specified +mailbox+ and\n    # +quota+.  If +quota+ is nil, then +quota+ will be unset for that\n    # mailbox.  Typically one needs to be logged in as a server admin\n    # for this to work.  The IMAP quota commands are described in\n    # [RFC-2087].\n    def setquota(mailbox, quota)\n      if quota.nil?\n        data = '()'\n      else\n        data = '(STORAGE ' + quota.to_s + ')'\n      end\n      send_command(\"SETQUOTA\", mailbox, RawData.new(data))\n    end\n\n    # Sends the SETACL command along with +mailbox+, +user+ and the\n    # +rights+ that user is to have on that mailbox.  If +rights+ is nil,\n    # then that user will be stripped of any rights to that mailbox.\n    # The IMAP ACL commands are described in [RFC-2086].\n    def setacl(mailbox, user, rights)\n      if rights.nil?\n        send_command(\"SETACL\", mailbox, user, \"\")\n      else\n        send_command(\"SETACL\", mailbox, user, rights)\n      end\n    end\n\n    # Send the GETACL command along with a specified +mailbox+.\n    # If this mailbox exists, an array containing objects of\n    # Net::IMAP::MailboxACLItem will be returned.\n    def getacl(mailbox)\n      synchronize do\n        send_command(\"GETACL\", mailbox)\n        return @responses.delete(\"ACL\")[-1]\n      end\n    end\n\n    # Sends a LSUB command, and returns a subset of names from the set\n    # of names that the user has declared as being \"active\" or\n    # \"subscribed.\"  +refname+ and +mailbox+ are interpreted as\n    # for #list().\n    # The return value is an array of +Net::IMAP::MailboxList+.\n    def lsub(refname, mailbox)\n      synchronize do\n        send_command(\"LSUB\", refname, mailbox)\n        return @responses.delete(\"LSUB\")\n      end\n    end\n\n    # Sends a STATUS command, and returns the status of the indicated\n    # +mailbox+. +attr+ is a list of one or more attributes whose\n    # statuses are to be requested.  Supported attributes include:\n    #\n    #   MESSAGES:: the number of messages in the mailbox.\n    #   RECENT:: the number of recent messages in the mailbox.\n    #   UNSEEN:: the number of unseen messages in the mailbox.\n    #\n    # The return value is a hash of attributes. For example:\n    #\n    #   p imap.status(\"inbox\", [\"MESSAGES\", \"RECENT\"])\n    #   #=> {\"RECENT\"=>0, \"MESSAGES\"=>44}\n    #\n    # A Net::IMAP::NoResponseError is raised if status values\n    # for +mailbox+ cannot be returned; for instance, because it\n    # does not exist.\n    def status(mailbox, attr)\n      synchronize do\n        send_command(\"STATUS\", mailbox, attr)\n        return @responses.delete(\"STATUS\")[-1].attr\n      end\n    end\n\n    # Sends a APPEND command to append the +message+ to the end of\n    # the +mailbox+. The optional +flags+ argument is an array of\n    # flags initially passed to the new message.  The optional\n    # +date_time+ argument specifies the creation time to assign to the\n    # new message; it defaults to the current time.\n    # For example:\n    #\n    #   imap.append(\"inbox\", <<EOF.gsub(/\\n/, \"\\r\\n\"), [:Seen], Time.now)\n    #   Subject: hello\n    #   From: shugo@ruby-lang.org\n    #   To: shugo@ruby-lang.org\n    #\n    #   hello world\n    #   EOF\n    #\n    # A Net::IMAP::NoResponseError is raised if the mailbox does\n    # not exist (it is not created automatically), or if the flags,\n    # date_time, or message arguments contain errors.\n    def append(mailbox, message, flags = nil, date_time = nil)\n      args = []\n      if flags\n        args.push(flags)\n      end\n      args.push(date_time) if date_time\n      args.push(Literal.new(message))\n      send_command(\"APPEND\", mailbox, *args)\n    end\n\n    # Sends a CHECK command to request a checkpoint of the currently\n    # selected mailbox.  This performs implementation-specific\n    # housekeeping; for instance, reconciling the mailbox's\n    # in-memory and on-disk state.\n    def check\n      send_command(\"CHECK\")\n    end\n\n    # Sends a CLOSE command to close the currently selected mailbox.\n    # The CLOSE command permanently removes from the mailbox all\n    # messages that have the \\Deleted flag set.\n    def close\n      send_command(\"CLOSE\")\n    end\n\n    # Sends a EXPUNGE command to permanently remove from the currently\n    # selected mailbox all messages that have the \\Deleted flag set.\n    def expunge\n      synchronize do\n        send_command(\"EXPUNGE\")\n        return @responses.delete(\"EXPUNGE\")\n      end\n    end\n\n    # Sends a SEARCH command to search the mailbox for messages that\n    # match the given searching criteria, and returns message sequence\n    # numbers.  +keys+ can either be a string holding the entire\n    # search string, or a single-dimension array of search keywords and\n    # arguments.  The following are some common search criteria;\n    # see [IMAP] section 6.4.4 for a full list.\n    #\n    # <message set>:: a set of message sequence numbers.  ',' indicates\n    #                 an interval, ':' indicates a range.  For instance,\n    #                 '2,10:12,15' means \"2,10,11,12,15\".\n    #\n    # BEFORE <date>:: messages with an internal date strictly before\n    #                 <date>.  The date argument has a format similar\n    #                 to 8-Aug-2002.\n    #\n    # BODY <string>:: messages that contain <string> within their body.\n    #\n    # CC <string>:: messages containing <string> in their CC field.\n    #\n    # FROM <string>:: messages that contain <string> in their FROM field.\n    #\n    # NEW:: messages with the \\Recent, but not the \\Seen, flag set.\n    #\n    # NOT <search-key>:: negate the following search key.\n    #\n    # OR <search-key> <search-key>:: \"or\" two search keys together.\n    #\n    # ON <date>:: messages with an internal date exactly equal to <date>,\n    #             which has a format similar to 8-Aug-2002.\n    #\n    # SINCE <date>:: messages with an internal date on or after <date>.\n    #\n    # SUBJECT <string>:: messages with <string> in their subject.\n    #\n    # TO <string>:: messages with <string> in their TO field.\n    #\n    # For example:\n    #\n    #   p imap.search([\"SUBJECT\", \"hello\", \"NOT\", \"NEW\"])\n    #   #=> [1, 6, 7, 8]\n    def search(keys, charset = nil)\n      return search_internal(\"SEARCH\", keys, charset)\n    end\n\n    # Similar to #search(), but returns unique identifiers.\n    def uid_search(keys, charset = nil)\n      return search_internal(\"UID SEARCH\", keys, charset)\n    end\n\n    # Sends a FETCH command to retrieve data associated with a message\n    # in the mailbox.\n    #\n    # The +set+ parameter is a number or a range between two numbers,\n    # or an array of those.  The number is a message sequence number,\n    # where -1 represents a '*' for use in range notation like 100..-1\n    # being interpreted as '100:*'.  Beware that the +exclude_end?+\n    # property of a Range object is ignored, and the contents of a\n    # range are independent of the order of the range endpoints as per\n    # the protocol specification, so 1...5, 5..1 and 5...1 are all\n    # equivalent to 1..5.\n    #\n    # +attr+ is a list of attributes to fetch; see the documentation\n    # for Net::IMAP::FetchData for a list of valid attributes.\n    #\n    # The return value is an array of Net::IMAP::FetchData or nil\n    # (instead of an empty array) if there is no matching message.\n    #\n    # For example:\n    #\n    #   p imap.fetch(6..8, \"UID\")\n    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={\"UID\"=>98}>, \\\\\n    #        #<Net::IMAP::FetchData seqno=7, attr={\"UID\"=>99}>, \\\\\n    #        #<Net::IMAP::FetchData seqno=8, attr={\"UID\"=>100}>]\n    #   p imap.fetch(6, \"BODY[HEADER.FIELDS (SUBJECT)]\")\n    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={\"BODY[HEADER.FIELDS (SUBJECT)]\"=>\"Subject: test\\r\\n\\r\\n\"}>]\n    #   data = imap.uid_fetch(98, [\"RFC822.SIZE\", \"INTERNALDATE\"])[0]\n    #   p data.seqno\n    #   #=> 6\n    #   p data.attr[\"RFC822.SIZE\"]\n    #   #=> 611\n    #   p data.attr[\"INTERNALDATE\"]\n    #   #=> \"12-Oct-2000 22:40:59 +0900\"\n    #   p data.attr[\"UID\"]\n    #   #=> 98\n    def fetch(set, attr, mod = nil)\n      return fetch_internal(\"FETCH\", set, attr, mod)\n    end\n\n    # Similar to #fetch(), but +set+ contains unique identifiers.\n    def uid_fetch(set, attr, mod = nil)\n      return fetch_internal(\"UID FETCH\", set, attr, mod)\n    end\n\n    # Sends a STORE command to alter data associated with messages\n    # in the mailbox, in particular their flags. The +set+ parameter\n    # is a number, an array of numbers, or a Range object. Each number\n    # is a message sequence number.  +attr+ is the name of a data item\n    # to store: 'FLAGS' will replace the message's flag list\n    # with the provided one, '+FLAGS' will add the provided flags,\n    # and '-FLAGS' will remove them.  +flags+ is a list of flags.\n    #\n    # The return value is an array of Net::IMAP::FetchData. For example:\n    #\n    #   p imap.store(6..8, \"+FLAGS\", [:Deleted])\n    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={\"FLAGS\"=>[:Seen, :Deleted]}>, \\\\\n    #        #<Net::IMAP::FetchData seqno=7, attr={\"FLAGS\"=>[:Seen, :Deleted]}>, \\\\\n    #        #<Net::IMAP::FetchData seqno=8, attr={\"FLAGS\"=>[:Seen, :Deleted]}>]\n    def store(set, attr, flags)\n      return store_internal(\"STORE\", set, attr, flags)\n    end\n\n    # Similar to #store(), but +set+ contains unique identifiers.\n    def uid_store(set, attr, flags)\n      return store_internal(\"UID STORE\", set, attr, flags)\n    end\n\n    # Sends a COPY command to copy the specified message(s) to the end\n    # of the specified destination +mailbox+. The +set+ parameter is\n    # a number, an array of numbers, or a Range object. The number is\n    # a message sequence number.\n    def copy(set, mailbox)\n      copy_internal(\"COPY\", set, mailbox)\n    end\n\n    # Similar to #copy(), but +set+ contains unique identifiers.\n    def uid_copy(set, mailbox)\n      copy_internal(\"UID COPY\", set, mailbox)\n    end\n\n    # Sends a MOVE command to move the specified message(s) to the end\n    # of the specified destination +mailbox+. The +set+ parameter is\n    # a number, an array of numbers, or a Range object. The number is\n    # a message sequence number.\n    # The IMAP MOVE extension is described in [RFC-6851].\n    def move(set, mailbox)\n      copy_internal(\"MOVE\", set, mailbox)\n    end\n\n    # Similar to #move(), but +set+ contains unique identifiers.\n    def uid_move(set, mailbox)\n      copy_internal(\"UID MOVE\", set, mailbox)\n    end\n\n    # Sends a SORT command to sort messages in the mailbox.\n    # Returns an array of message sequence numbers. For example:\n    #\n    #   p imap.sort([\"FROM\"], [\"ALL\"], \"US-ASCII\")\n    #   #=> [1, 2, 3, 5, 6, 7, 8, 4, 9]\n    #   p imap.sort([\"DATE\"], [\"SUBJECT\", \"hello\"], \"US-ASCII\")\n    #   #=> [6, 7, 8, 1]\n    #\n    # See [SORT-THREAD-EXT] for more details.\n    def sort(sort_keys, search_keys, charset)\n      return sort_internal(\"SORT\", sort_keys, search_keys, charset)\n    end\n\n    # Similar to #sort(), but returns an array of unique identifiers.\n    def uid_sort(sort_keys, search_keys, charset)\n      return sort_internal(\"UID SORT\", sort_keys, search_keys, charset)\n    end\n\n    # Adds a response handler. For example, to detect when\n    # the server sends a new EXISTS response (which normally\n    # indicates new messages being added to the mailbox),\n    # add the following handler after selecting the\n    # mailbox:\n    #\n    #   imap.add_response_handler { |resp|\n    #     if resp.kind_of?(Net::IMAP::UntaggedResponse) and resp.name == \"EXISTS\"\n    #       puts \"Mailbox now has #{resp.data} messages\"\n    #     end\n    #   }\n    #\n    def add_response_handler(handler = nil, &block)\n      raise ArgumentError, \"two Procs are passed\" if handler && block\n      @response_handlers.push(block || handler)\n    end\n\n    # Removes the response handler.\n    def remove_response_handler(handler)\n      @response_handlers.delete(handler)\n    end\n\n    # Similar to #search(), but returns message sequence numbers in threaded\n    # format, as a Net::IMAP::ThreadMember tree.  The supported algorithms\n    # are:\n    #\n    # ORDEREDSUBJECT:: split into single-level threads according to subject,\n    #                  ordered by date.\n    # REFERENCES:: split into threads by parent/child relationships determined\n    #              by which message is a reply to which.\n    #\n    # Unlike #search(), +charset+ is a required argument.  US-ASCII\n    # and UTF-8 are sample values.\n    #\n    # See [SORT-THREAD-EXT] for more details.\n    def thread(algorithm, search_keys, charset)\n      return thread_internal(\"THREAD\", algorithm, search_keys, charset)\n    end\n\n    # Similar to #thread(), but returns unique identifiers instead of\n    # message sequence numbers.\n    def uid_thread(algorithm, search_keys, charset)\n      return thread_internal(\"UID THREAD\", algorithm, search_keys, charset)\n    end\n\n    # Sends an IDLE command that waits for notifications of new or expunged\n    # messages.  Yields responses from the server during the IDLE.\n    #\n    # Use #idle_done() to leave IDLE.\n    #\n    # If +timeout+ is given, this method returns after +timeout+ seconds passed.\n    # +timeout+ can be used for keep-alive.  For example, the following code\n    # checks the connection for each 60 seconds.\n    #\n    #   loop do\n    #     imap.idle(60) do |res|\n    #       ...\n    #     end\n    #   end\n    def idle(timeout = nil, &response_handler)\n      raise LocalJumpError, \"no block given\" unless response_handler\n\n      response = nil\n\n      synchronize do\n        tag = Thread.current[:net_imap_tag] = generate_tag\n        put_string(\"#{tag} IDLE#{CRLF}\")\n\n        begin\n          add_response_handler(&response_handler)\n          @idle_done_cond = new_cond\n          @idle_done_cond.wait(timeout)\n          @idle_done_cond = nil\n          if @receiver_thread_terminating\n            raise @exception || Net::IMAP::Error.new(\"connection closed\")\n          end\n        ensure\n          unless @receiver_thread_terminating\n            remove_response_handler(response_handler)\n            put_string(\"DONE#{CRLF}\")\n            response = get_tagged_response(tag, \"IDLE\")\n          end\n        end\n      end\n\n      return response\n    end\n\n    # Leaves IDLE.\n    def idle_done\n      synchronize do\n        if @idle_done_cond.nil?\n          raise Net::IMAP::Error, \"not during IDLE\"\n        end\n        @idle_done_cond.signal\n      end\n    end\n\n    # Decode a string from modified UTF-7 format to UTF-8.\n    #\n    # UTF-7 is a 7-bit encoding of Unicode [UTF7].  IMAP uses a\n    # slightly modified version of this to encode mailbox names\n    # containing non-ASCII characters; see [IMAP] section 5.1.3.\n    #\n    # Net::IMAP does _not_ automatically encode and decode\n    # mailbox names to and from UTF-7.\n    def self.decode_utf7(s)\n      return s.gsub(/&([^-]+)?-/n) {\n        if $1\n          ($1.tr(\",\", \"/\") + \"===\").unpack1(\"m\").encode(Encoding::UTF_8, Encoding::UTF_16BE)\n        else\n          \"&\"\n        end\n      }\n    end\n\n    # Encode a string from UTF-8 format to modified UTF-7.\n    def self.encode_utf7(s)\n      return s.gsub(/(&)|[^\\x20-\\x7e]+/) {\n        if $1\n          \"&-\"\n        else\n          base64 = [$&.encode(Encoding::UTF_16BE)].pack(\"m0\")\n          \"&\" + base64.delete(\"=\").tr(\"/\", \",\") + \"-\"\n        end\n      }.force_encoding(\"ASCII-8BIT\")\n    end\n\n    # Formats +time+ as an IMAP-style date.\n    def self.format_date(time)\n      return time.strftime('%d-%b-%Y')\n    end\n\n    # Formats +time+ as an IMAP-style date-time.\n    def self.format_datetime(time)\n      return time.strftime('%d-%b-%Y %H:%M %z')\n    end\n\n    private\n\n    CRLF = \"\\r\\n\"      # :nodoc:\n    PORT = 143         # :nodoc:\n    SSL_PORT = 993   # :nodoc:\n\n    @@debug = false\n    @@authenticators = {}\n    @@max_flag_count = 10000\n\n    # :call-seq:\n    #    Net::IMAP.new(host, options = {})\n    #\n    # Creates a new Net::IMAP object and connects it to the specified\n    # +host+.\n    #\n    # +options+ is an option hash, each key of which is a symbol.\n    #\n    # The available options are:\n    #\n    # port::  Port number (default value is 143 for imap, or 993 for imaps)\n    # ssl::   If options[:ssl] is true, then an attempt will be made\n    #         to use SSL (now TLS) to connect to the server.  For this to work\n    #         OpenSSL [OSSL] and the Ruby OpenSSL [RSSL] extensions need to\n    #         be installed.\n    #         If options[:ssl] is a hash, it's passed to\n    #         OpenSSL::SSL::SSLContext#set_params as parameters.\n    # open_timeout:: Seconds to wait until a connection is opened\n    #\n    # The most common errors are:\n    #\n    # Errno::ECONNREFUSED:: Connection refused by +host+ or an intervening\n    #                       firewall.\n    # Errno::ETIMEDOUT:: Connection timed out (possibly due to packets\n    #                    being dropped by an intervening firewall).\n    # Errno::ENETUNREACH:: There is no route to that network.\n    # SocketError:: Hostname not known or other socket error.\n    # Net::IMAP::ByeResponseError:: The connected to the host was successful, but\n    #                               it immediately said goodbye.\n    def initialize(host, port_or_options = {},\n                   usessl = false, certs = nil, verify = true)\n      super()\n      @host = host\n      begin\n        options = port_or_options.to_hash\n      rescue NoMethodError\n        # for backward compatibility\n        options = {}\n        options[:port] = port_or_options\n        if usessl\n          options[:ssl] = create_ssl_params(certs, verify)\n        end\n      end\n      @port = options[:port] || (options[:ssl] ? SSL_PORT : PORT)\n      @tag_prefix = \"RUBY\"\n      @tagno = 0\n      @open_timeout = options[:open_timeout] || 30\n      @parser = ResponseParser.new\n      @sock = tcp_socket(@host, @port)\n      begin\n        if options[:ssl]\n          start_tls_session(options[:ssl])\n          @usessl = true\n        else\n          @usessl = false\n        end\n        @responses = Hash.new([].freeze)\n        @tagged_responses = {}\n        @response_handlers = []\n        @tagged_response_arrival = new_cond\n        @continued_command_tag = nil\n        @continuation_request_arrival = new_cond\n        @continuation_request_exception = nil\n        @idle_done_cond = nil\n        @logout_command_tag = nil\n        @debug_output_bol = true\n        @exception = nil\n\n        @greeting = get_response\n        if @greeting.nil?\n          raise Error, \"connection closed\"\n        end\n        if @greeting.name == \"BYE\"\n          raise ByeResponseError, @greeting\n        end\n\n        @client_thread = Thread.current\n        @receiver_thread = Thread.start {\n          begin\n            receive_responses\n          rescue Exception\n          end\n        }\n        @receiver_thread_terminating = false\n      rescue Exception\n        @sock.close\n        raise\n      end\n    end\n\n    def tcp_socket(host, port)\n      s = Socket.tcp(host, port, :connect_timeout => @open_timeout)\n      s.setsockopt(:SOL_SOCKET, :SO_KEEPALIVE, true)\n      s\n    rescue Errno::ETIMEDOUT\n      raise Net::OpenTimeout, \"Timeout to open TCP connection to \" +\n        \"#{host}:#{port} (exceeds #{@open_timeout} seconds)\"\n    end\n\n    def receive_responses\n      connection_closed = false\n      until connection_closed\n        synchronize do\n          @exception = nil\n        end\n        begin\n          resp = get_response\n        rescue Exception => e\n          synchronize do\n            @sock.close\n            @exception = e\n          end\n          break\n        end\n        unless resp\n          synchronize do\n            @exception = EOFError.new(\"end of file reached\")\n          end\n          break\n        end\n        begin\n          synchronize do\n            case resp\n            when TaggedResponse\n              @tagged_responses[resp.tag] = resp\n              @tagged_response_arrival.broadcast\n              case resp.tag\n              when @logout_command_tag\n                return\n              when @continued_command_tag\n                @continuation_request_exception =\n                  RESPONSE_ERRORS[resp.name].new(resp)\n                @continuation_request_arrival.signal\n              end\n            when UntaggedResponse\n              record_response(resp.name, resp.data)\n              if resp.data.instance_of?(ResponseText) &&\n                  (code = resp.data.code)\n                record_response(code.name, code.data)\n              end\n              if resp.name == \"BYE\" && @logout_command_tag.nil?\n                @sock.close\n                @exception = ByeResponseError.new(resp)\n                connection_closed = true\n              end\n            when ContinuationRequest\n              @continuation_request_arrival.signal\n            end\n            @response_handlers.each do |handler|\n              handler.call(resp)\n            end\n          end\n        rescue Exception => e\n          @exception = e\n          synchronize do\n            @tagged_response_arrival.broadcast\n            @continuation_request_arrival.broadcast\n          end\n        end\n      end\n      synchronize do\n        @receiver_thread_terminating = true\n        @tagged_response_arrival.broadcast\n        @continuation_request_arrival.broadcast\n        if @idle_done_cond\n          @idle_done_cond.signal\n        end\n      end\n    end\n\n    def get_tagged_response(tag, cmd)\n      until @tagged_responses.key?(tag)\n        raise @exception if @exception\n        @tagged_response_arrival.wait\n      end\n      resp = @tagged_responses.delete(tag)\n      case resp.name\n      when /\\A(?:NO)\\z/ni\n        raise NoResponseError, resp\n      when /\\A(?:BAD)\\z/ni\n        raise BadResponseError, resp\n      else\n        return resp\n      end\n    end\n\n    def get_response\n      buff = String.new\n      while true\n        s = @sock.gets(CRLF)\n        break unless s\n        buff.concat(s)\n        if /\\{(\\d+)\\}\\r\\n/n =~ s\n          s = @sock.read($1.to_i)\n          buff.concat(s)\n        else\n          break\n        end\n      end\n      return nil if buff.length == 0\n      if @@debug\n        $stderr.print(buff.gsub(/^/n, \"S: \"))\n      end\n      return @parser.parse(buff)\n    end\n\n    def record_response(name, data)\n      unless @responses.has_key?(name)\n        @responses[name] = []\n      end\n      @responses[name].push(data)\n    end\n\n    def send_command(cmd, *args, &block)\n      synchronize do\n        args.each do |i|\n          validate_data(i)\n        end\n        tag = generate_tag\n        put_string(tag + \" \" + cmd)\n        args.each do |i|\n          put_string(\" \")\n          send_data(i, tag)\n        end\n        put_string(CRLF)\n        if cmd == \"LOGOUT\"\n          @logout_command_tag = tag\n        end\n        if block\n          add_response_handler(&block)\n        end\n        begin\n          return get_tagged_response(tag, cmd)\n        ensure\n          if block\n            remove_response_handler(block)\n          end\n        end\n      end\n    end\n\n    def generate_tag\n      @tagno += 1\n      return format(\"%s%04d\", @tag_prefix, @tagno)\n    end\n\n    def put_string(str)\n      @sock.print(str)\n      if @@debug\n        if @debug_output_bol\n          $stderr.print(\"C: \")\n        end\n        $stderr.print(str.gsub(/\\n(?!\\z)/n, \"\\nC: \"))\n        if /\\r\\n\\z/n.match(str)\n          @debug_output_bol = true\n        else\n          @debug_output_bol = false\n        end\n      end\n    end\n\n    def validate_data(data)\n      case data\n      when nil\n      when String\n      when Integer\n        NumValidator.ensure_number(data)\n      when Array\n        if data[0] == 'CHANGEDSINCE'\n          NumValidator.ensure_mod_sequence_value(data[1])\n        else\n          data.each do |i|\n            validate_data(i)\n          end\n        end\n      when Time\n      when Symbol\n      else\n        data.validate\n      end\n    end\n\n    def send_data(data, tag = nil)\n      case data\n      when nil\n        put_string(\"NIL\")\n      when String\n        send_string_data(data, tag)\n      when Integer\n        send_number_data(data)\n      when Array\n        send_list_data(data, tag)\n      when Time\n        send_time_data(data)\n      when Symbol\n        send_symbol_data(data)\n      else\n        data.send_data(self, tag)\n      end\n    end\n\n    def send_string_data(str, tag = nil)\n      case str\n      when \"\"\n        put_string('\"\"')\n      when /[\\x80-\\xff\\r\\n]/n\n        # literal\n        send_literal(str, tag)\n      when /[(){ \\x00-\\x1f\\x7f%*\"\\\\]/n\n        # quoted string\n        send_quoted_string(str)\n      else\n        put_string(str)\n      end\n    end\n\n    def send_quoted_string(str)\n      put_string('\"' + str.gsub(/[\"\\\\]/n, \"\\\\\\\\\\\\&\") + '\"')\n    end\n\n    def send_literal(str, tag = nil)\n      synchronize do\n        put_string(\"{\" + str.bytesize.to_s + \"}\" + CRLF)\n        @continued_command_tag = tag\n        @continuation_request_exception = nil\n        begin\n          @continuation_request_arrival.wait\n          e = @continuation_request_exception || @exception\n          raise e if e\n          put_string(str)\n        ensure\n          @continued_command_tag = nil\n          @continuation_request_exception = nil\n        end\n      end\n    end\n\n    def send_number_data(num)\n      put_string(num.to_s)\n    end\n\n    def send_list_data(list, tag = nil)\n      put_string(\"(\")\n      first = true\n      list.each do |i|\n        if first\n          first = false\n        else\n          put_string(\" \")\n        end\n        send_data(i, tag)\n      end\n      put_string(\")\")\n    end\n\n    DATE_MONTH = %w(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)\n\n    def send_time_data(time)\n      t = time.dup.gmtime\n      s = format('\"%2d-%3s-%4d %02d:%02d:%02d +0000\"',\n                 t.day, DATE_MONTH[t.month - 1], t.year,\n                 t.hour, t.min, t.sec)\n      put_string(s)\n    end\n\n    def send_symbol_data(symbol)\n      put_string(\"\\\\\" + symbol.to_s)\n    end\n\n    def search_internal(cmd, keys, charset)\n      if keys.instance_of?(String)\n        keys = [RawData.new(keys)]\n      else\n        normalize_searching_criteria(keys)\n      end\n      synchronize do\n        if charset\n          send_command(cmd, \"CHARSET\", charset, *keys)\n        else\n          send_command(cmd, *keys)\n        end\n        return @responses.delete(\"SEARCH\")[-1]\n      end\n    end\n\n    def fetch_internal(cmd, set, attr, mod = nil)\n      case attr\n      when String then\n        attr = RawData.new(attr)\n      when Array then\n        attr = attr.map { |arg|\n          arg.is_a?(String) ? RawData.new(arg) : arg\n        }\n      end\n\n      synchronize do\n        @responses.delete(\"FETCH\")\n        if mod\n          send_command(cmd, MessageSet.new(set), attr, mod)\n        else\n          send_command(cmd, MessageSet.new(set), attr)\n        end\n        return @responses.delete(\"FETCH\")\n      end\n    end\n\n    def store_internal(cmd, set, attr, flags)\n      if attr.instance_of?(String)\n        attr = RawData.new(attr)\n      end\n      synchronize do\n        @responses.delete(\"FETCH\")\n        send_command(cmd, MessageSet.new(set), attr, flags)\n        return @responses.delete(\"FETCH\")\n      end\n    end\n\n    def copy_internal(cmd, set, mailbox)\n      send_command(cmd, MessageSet.new(set), mailbox)\n    end\n\n    def sort_internal(cmd, sort_keys, search_keys, charset)\n      if search_keys.instance_of?(String)\n        search_keys = [RawData.new(search_keys)]\n      else\n        normalize_searching_criteria(search_keys)\n      end\n      normalize_searching_criteria(search_keys)\n      synchronize do\n        send_command(cmd, sort_keys, charset, *search_keys)\n        return @responses.delete(\"SORT\")[-1]\n      end\n    end\n\n    def thread_internal(cmd, algorithm, search_keys, charset)\n      if search_keys.instance_of?(String)\n        search_keys = [RawData.new(search_keys)]\n      else\n        normalize_searching_criteria(search_keys)\n      end\n      normalize_searching_criteria(search_keys)\n      send_command(cmd, algorithm, charset, *search_keys)\n      return @responses.delete(\"THREAD\")[-1]\n    end\n\n    def normalize_searching_criteria(keys)\n      keys.collect! do |i|\n        case i\n        when -1, Range, Array\n          MessageSet.new(i)\n        else\n          i\n        end\n      end\n    end\n\n    def create_ssl_params(certs = nil, verify = true)\n      params = {}\n      if certs\n        if File.file?(certs)\n          params[:ca_file] = certs\n        elsif File.directory?(certs)\n          params[:ca_path] = certs\n        end\n      end\n      if verify\n        params[:verify_mode] = VERIFY_PEER\n      else\n        params[:verify_mode] = VERIFY_NONE\n      end\n      return params\n    end\n\n    def start_tls_session(params = {})\n      unless defined?(OpenSSL::SSL)\n        raise \"SSL extension not installed\"\n      end\n      if @sock.kind_of?(OpenSSL::SSL::SSLSocket)\n        raise RuntimeError, \"already using SSL\"\n      end\n      begin\n        params = params.to_hash\n      rescue NoMethodError\n        params = {}\n      end\n      context = SSLContext.new\n      context.set_params(params)\n      if defined?(VerifyCallbackProc)\n        context.verify_callback = VerifyCallbackProc\n      end\n      @sock = SSLSocket.new(@sock, context)\n      @sock.sync_close = true\n      @sock.hostname = @host if @sock.respond_to? :hostname=\n      ssl_socket_connect(@sock, @open_timeout)\n      if context.verify_mode != VERIFY_NONE\n        @sock.post_connection_check(@host)\n      end\n    end\n\n    class RawData # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:put_string, @data)\n      end\n\n      def validate\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n    end\n\n    class Atom # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:put_string, @data)\n      end\n\n      def validate\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n    end\n\n    class QuotedString # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:send_quoted_string, @data)\n      end\n\n      def validate\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n    end\n\n    class Literal # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:send_literal, @data, tag)\n      end\n\n      def validate\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n    end\n\n    class MessageSet # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:put_string, format_internal(@data))\n      end\n\n      def validate\n        validate_internal(@data)\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n\n      def format_internal(data)\n        case data\n        when \"*\"\n          return data\n        when Integer\n          if data == -1\n            return \"*\"\n          else\n            return data.to_s\n          end\n        when Range\n          return format_internal(data.first) +\n            \":\" + format_internal(data.last)\n        when Array\n          return data.collect {|i| format_internal(i)}.join(\",\")\n        when ThreadMember\n          return data.seqno.to_s +\n            \":\" + data.children.collect {|i| format_internal(i).join(\",\")}\n        end\n      end\n\n      def validate_internal(data)\n        case data\n        when \"*\"\n        when Integer\n          NumValidator.ensure_nz_number(data)\n        when Range\n        when Array\n          data.each do |i|\n            validate_internal(i)\n          end\n        when ThreadMember\n          data.children.each do |i|\n            validate_internal(i)\n          end\n        else\n          raise DataFormatError, data.inspect\n        end\n      end\n    end\n\n    # Common validators of number and nz_number types\n    module NumValidator # :nodoc\n      class << self\n        # Check is passed argument valid 'number' in RFC 3501 terminology\n        def valid_number?(num)\n          # [RFC 3501]\n          # number          = 1*DIGIT\n          #                    ; Unsigned 32-bit integer\n          #                    ; (0 <= n < 4,294,967,296)\n          num >= 0 && num < 4294967296\n        end\n\n        # Check is passed argument valid 'nz_number' in RFC 3501 terminology\n        def valid_nz_number?(num)\n          # [RFC 3501]\n          # nz-number       = digit-nz *DIGIT\n          #                    ; Non-zero unsigned 32-bit integer\n          #                    ; (0 < n < 4,294,967,296)\n          num != 0 && valid_number?(num)\n        end\n\n        # Check is passed argument valid 'mod_sequence_value' in RFC 4551 terminology\n        def valid_mod_sequence_value?(num)\n          # mod-sequence-value  = 1*DIGIT\n          #                        ; Positive unsigned 64-bit integer\n          #                        ; (mod-sequence)\n          #                        ; (1 <= n < 18,446,744,073,709,551,615)\n          num >= 1 && num < 18446744073709551615\n        end\n\n        # Ensure argument is 'number' or raise DataFormatError\n        def ensure_number(num)\n          return if valid_number?(num)\n\n          msg = \"number must be unsigned 32-bit integer: #{num}\"\n          raise DataFormatError, msg\n        end\n\n        # Ensure argument is 'nz_number' or raise DataFormatError\n        def ensure_nz_number(num)\n          return if valid_nz_number?(num)\n\n          msg = \"nz_number must be non-zero unsigned 32-bit integer: #{num}\"\n          raise DataFormatError, msg\n        end\n\n        # Ensure argument is 'mod_sequence_value' or raise DataFormatError\n        def ensure_mod_sequence_value(num)\n          return if valid_mod_sequence_value?(num)\n\n          msg = \"mod_sequence_value must be unsigned 64-bit integer: #{num}\"\n          raise DataFormatError, msg\n        end\n      end\n    end\n\n    # Net::IMAP::ContinuationRequest represents command continuation requests.\n    #\n    # The command continuation request response is indicated by a \"+\" token\n    # instead of a tag.  This form of response indicates that the server is\n    # ready to accept the continuation of a command from the client.  The\n    # remainder of this response is a line of text.\n    #\n    #   continue_req    ::= \"+\" SPACE (resp_text / base64)\n    #\n    # ==== Fields:\n    #\n    # data:: Returns the data (Net::IMAP::ResponseText).\n    #\n    # raw_data:: Returns the raw data string.\n    ContinuationRequest = Struct.new(:data, :raw_data)\n\n    # Net::IMAP::UntaggedResponse represents untagged responses.\n    #\n    # Data transmitted by the server to the client and status responses\n    # that do not indicate command completion are prefixed with the token\n    # \"*\", and are called untagged responses.\n    #\n    #   response_data   ::= \"*\" SPACE (resp_cond_state / resp_cond_bye /\n    #                       mailbox_data / message_data / capability_data)\n    #\n    # ==== Fields:\n    #\n    # name:: Returns the name, such as \"FLAGS\", \"LIST\", or \"FETCH\".\n    #\n    # data:: Returns the data such as an array of flag symbols,\n    #        a ((<Net::IMAP::MailboxList>)) object.\n    #\n    # raw_data:: Returns the raw data string.\n    UntaggedResponse = Struct.new(:name, :data, :raw_data)\n\n    # Net::IMAP::TaggedResponse represents tagged responses.\n    #\n    # The server completion result response indicates the success or\n    # failure of the operation.  It is tagged with the same tag as the\n    # client command which began the operation.\n    #\n    #   response_tagged ::= tag SPACE resp_cond_state CRLF\n    #\n    #   tag             ::= 1*<any ATOM_CHAR except \"+\">\n    #\n    #   resp_cond_state ::= (\"OK\" / \"NO\" / \"BAD\") SPACE resp_text\n    #\n    # ==== Fields:\n    #\n    # tag:: Returns the tag.\n    #\n    # name:: Returns the name, one of \"OK\", \"NO\", or \"BAD\".\n    #\n    # data:: Returns the data. See ((<Net::IMAP::ResponseText>)).\n    #\n    # raw_data:: Returns the raw data string.\n    #\n    TaggedResponse = Struct.new(:tag, :name, :data, :raw_data)\n\n    # Net::IMAP::ResponseText represents texts of responses.\n    # The text may be prefixed by the response code.\n    #\n    #   resp_text       ::= [\"[\" resp_text_code \"]\" SPACE] (text_mime2 / text)\n    #                       ;; text SHOULD NOT begin with \"[\" or \"=\"\n    #\n    # ==== Fields:\n    #\n    # code:: Returns the response code. See ((<Net::IMAP::ResponseCode>)).\n    #\n    # text:: Returns the text.\n    #\n    ResponseText = Struct.new(:code, :text)\n\n    # Net::IMAP::ResponseCode represents response codes.\n    #\n    #   resp_text_code  ::= \"ALERT\" / \"PARSE\" /\n    #                       \"PERMANENTFLAGS\" SPACE \"(\" #(flag / \"\\*\") \")\" /\n    #                       \"READ-ONLY\" / \"READ-WRITE\" / \"TRYCREATE\" /\n    #                       \"UIDVALIDITY\" SPACE nz_number /\n    #                       \"UNSEEN\" SPACE nz_number /\n    #                       atom [SPACE 1*<any TEXT_CHAR except \"]\">]\n    #\n    # ==== Fields:\n    #\n    # name:: Returns the name, such as \"ALERT\", \"PERMANENTFLAGS\", or \"UIDVALIDITY\".\n    #\n    # data:: Returns the data, if it exists.\n    #\n    ResponseCode = Struct.new(:name, :data)\n\n    # Net::IMAP::MailboxList represents contents of the LIST response.\n    #\n    #   mailbox_list    ::= \"(\" #(\"\\Marked\" / \"\\Noinferiors\" /\n    #                       \"\\Noselect\" / \"\\Unmarked\" / flag_extension) \")\"\n    #                       SPACE (<\"> QUOTED_CHAR <\"> / nil) SPACE mailbox\n    #\n    # ==== Fields:\n    #\n    # attr:: Returns the name attributes. Each name attribute is a symbol\n    #        capitalized by String#capitalize, such as :Noselect (not :NoSelect).\n    #\n    # delim:: Returns the hierarchy delimiter.\n    #\n    # name:: Returns the mailbox name.\n    #\n    MailboxList = Struct.new(:attr, :delim, :name)\n\n    # Net::IMAP::MailboxQuota represents contents of GETQUOTA response.\n    # This object can also be a response to GETQUOTAROOT.  In the syntax\n    # specification below, the delimiter used with the \"#\" construct is a\n    # single space (SPACE).\n    #\n    #    quota_list      ::= \"(\" #quota_resource \")\"\n    #\n    #    quota_resource  ::= atom SPACE number SPACE number\n    #\n    #    quota_response  ::= \"QUOTA\" SPACE astring SPACE quota_list\n    #\n    # ==== Fields:\n    #\n    # mailbox:: The mailbox with the associated quota.\n    #\n    # usage:: Current storage usage of the mailbox.\n    #\n    # quota:: Quota limit imposed on the mailbox.\n    #\n    MailboxQuota = Struct.new(:mailbox, :usage, :quota)\n\n    # Net::IMAP::MailboxQuotaRoot represents part of the GETQUOTAROOT\n    # response. (GETQUOTAROOT can also return Net::IMAP::MailboxQuota.)\n    #\n    #    quotaroot_response ::= \"QUOTAROOT\" SPACE astring *(SPACE astring)\n    #\n    # ==== Fields:\n    #\n    # mailbox:: The mailbox with the associated quota.\n    #\n    # quotaroots:: Zero or more quotaroots that affect the quota on the\n    #              specified mailbox.\n    #\n    MailboxQuotaRoot = Struct.new(:mailbox, :quotaroots)\n\n    # Net::IMAP::MailboxACLItem represents the response from GETACL.\n    #\n    #    acl_data        ::= \"ACL\" SPACE mailbox *(SPACE identifier SPACE rights)\n    #\n    #    identifier      ::= astring\n    #\n    #    rights          ::= astring\n    #\n    # ==== Fields:\n    #\n    # user:: Login name that has certain rights to the mailbox\n    #        that was specified with the getacl command.\n    #\n    # rights:: The access rights the indicated user has to the\n    #          mailbox.\n    #\n    MailboxACLItem = Struct.new(:user, :rights, :mailbox)\n\n    # Net::IMAP::StatusData represents the contents of the STATUS response.\n    #\n    # ==== Fields:\n    #\n    # mailbox:: Returns the mailbox name.\n    #\n    # attr:: Returns a hash. Each key is one of \"MESSAGES\", \"RECENT\", \"UIDNEXT\",\n    #        \"UIDVALIDITY\", \"UNSEEN\". Each value is a number.\n    #\n    StatusData = Struct.new(:mailbox, :attr)\n\n    # Net::IMAP::FetchData represents the contents of the FETCH response.\n    #\n    # ==== Fields:\n    #\n    # seqno:: Returns the message sequence number.\n    #         (Note: not the unique identifier, even for the UID command response.)\n    #\n    # attr:: Returns a hash. Each key is a data item name, and each value is\n    #        its value.\n    #\n    #        The current data items are:\n    #\n    #        [BODY]\n    #           A form of BODYSTRUCTURE without extension data.\n    #        [BODY[<section>]<<origin_octet>>]\n    #           A string expressing the body contents of the specified section.\n    #        [BODYSTRUCTURE]\n    #           An object that describes the [MIME-IMB] body structure of a message.\n    #           See Net::IMAP::BodyTypeBasic, Net::IMAP::BodyTypeText,\n    #           Net::IMAP::BodyTypeMessage, Net::IMAP::BodyTypeMultipart.\n    #        [ENVELOPE]\n    #           A Net::IMAP::Envelope object that describes the envelope\n    #           structure of a message.\n    #        [FLAGS]\n    #           A array of flag symbols that are set for this message. Flag symbols\n    #           are capitalized by String#capitalize.\n    #        [INTERNALDATE]\n    #           A string representing the internal date of the message.\n    #        [RFC822]\n    #           Equivalent to BODY[].\n    #        [RFC822.HEADER]\n    #           Equivalent to BODY.PEEK[HEADER].\n    #        [RFC822.SIZE]\n    #           A number expressing the [RFC-822] size of the message.\n    #        [RFC822.TEXT]\n    #           Equivalent to BODY[TEXT].\n    #        [UID]\n    #           A number expressing the unique identifier of the message.\n    #\n    FetchData = Struct.new(:seqno, :attr)\n\n    # Net::IMAP::Envelope represents envelope structures of messages.\n    #\n    # ==== Fields:\n    #\n    # date:: Returns a string that represents the date.\n    #\n    # subject:: Returns a string that represents the subject.\n    #\n    # from:: Returns an array of Net::IMAP::Address that represents the from.\n    #\n    # sender:: Returns an array of Net::IMAP::Address that represents the sender.\n    #\n    # reply_to:: Returns an array of Net::IMAP::Address that represents the reply-to.\n    #\n    # to:: Returns an array of Net::IMAP::Address that represents the to.\n    #\n    # cc:: Returns an array of Net::IMAP::Address that represents the cc.\n    #\n    # bcc:: Returns an array of Net::IMAP::Address that represents the bcc.\n    #\n    # in_reply_to:: Returns a string that represents the in-reply-to.\n    #\n    # message_id:: Returns a string that represents the message-id.\n    #\n    Envelope = Struct.new(:date, :subject, :from, :sender, :reply_to,\n                          :to, :cc, :bcc, :in_reply_to, :message_id)\n\n    #\n    # Net::IMAP::Address represents electronic mail addresses.\n    #\n    # ==== Fields:\n    #\n    # name:: Returns the phrase from [RFC-822] mailbox.\n    #\n    # route:: Returns the route from [RFC-822] route-addr.\n    #\n    # mailbox:: nil indicates end of [RFC-822] group.\n    #           If non-nil and host is nil, returns [RFC-822] group name.\n    #           Otherwise, returns [RFC-822] local-part.\n    #\n    # host:: nil indicates [RFC-822] group syntax.\n    #        Otherwise, returns [RFC-822] domain name.\n    #\n    Address = Struct.new(:name, :route, :mailbox, :host)\n\n    #\n    # Net::IMAP::ContentDisposition represents Content-Disposition fields.\n    #\n    # ==== Fields:\n    #\n    # dsp_type:: Returns the disposition type.\n    #\n    # param:: Returns a hash that represents parameters of the Content-Disposition\n    #         field.\n    #\n    ContentDisposition = Struct.new(:dsp_type, :param)\n\n    # Net::IMAP::ThreadMember represents a thread-node returned\n    # by Net::IMAP#thread.\n    #\n    # ==== Fields:\n    #\n    # seqno:: The sequence number of this message.\n    #\n    # children:: An array of Net::IMAP::ThreadMember objects for mail\n    #            items that are children of this in the thread.\n    #\n    ThreadMember = Struct.new(:seqno, :children)\n\n    # Net::IMAP::BodyTypeBasic represents basic body structures of messages.\n    #\n    # ==== Fields:\n    #\n    # media_type:: Returns the content media type name as defined in [MIME-IMB].\n    #\n    # subtype:: Returns the content subtype name as defined in [MIME-IMB].\n    #\n    # param:: Returns a hash that represents parameters as defined in [MIME-IMB].\n    #\n    # content_id:: Returns a string giving the content id as defined in [MIME-IMB].\n    #\n    # description:: Returns a string giving the content description as defined in\n    #               [MIME-IMB].\n    #\n    # encoding:: Returns a string giving the content transfer encoding as defined in\n    #            [MIME-IMB].\n    #\n    # size:: Returns a number giving the size of the body in octets.\n    #\n    # md5:: Returns a string giving the body MD5 value as defined in [MD5].\n    #\n    # disposition:: Returns a Net::IMAP::ContentDisposition object giving\n    #               the content disposition.\n    #\n    # language:: Returns a string or an array of strings giving the body\n    #            language value as defined in [LANGUAGE-TAGS].\n    #\n    # extension:: Returns extension data.\n    #\n    # multipart?:: Returns false.\n    #\n    class BodyTypeBasic < Struct.new(:media_type, :subtype,\n                                     :param, :content_id,\n                                     :description, :encoding, :size,\n                                     :md5, :disposition, :language,\n                                     :extension)\n      def multipart?\n        return false\n      end\n\n      # Obsolete: use +subtype+ instead.  Calling this will\n      # generate a warning message to +stderr+, then return\n      # the value of +subtype+.\n      def media_subtype\n        warn(\"media_subtype is obsolete, use subtype instead.\\n\", uplevel: 1)\n        return subtype\n      end\n    end\n\n    # Net::IMAP::BodyTypeText represents TEXT body structures of messages.\n    #\n    # ==== Fields:\n    #\n    # lines:: Returns the size of the body in text lines.\n    #\n    # And Net::IMAP::BodyTypeText has all fields of Net::IMAP::BodyTypeBasic.\n    #\n    class BodyTypeText < Struct.new(:media_type, :subtype,\n                                    :param, :content_id,\n                                    :description, :encoding, :size,\n                                    :lines,\n                                    :md5, :disposition, :language,\n                                    :extension)\n      def multipart?\n        return false\n      end\n\n      # Obsolete: use +subtype+ instead.  Calling this will\n      # generate a warning message to +stderr+, then return\n      # the value of +subtype+.\n      def media_subtype\n        warn(\"media_subtype is obsolete, use subtype instead.\\n\", uplevel: 1)\n        return subtype\n      end\n    end\n\n    # Net::IMAP::BodyTypeMessage represents MESSAGE/RFC822 body structures of messages.\n    #\n    # ==== Fields:\n    #\n    # envelope:: Returns a Net::IMAP::Envelope giving the envelope structure.\n    #\n    # body:: Returns an object giving the body structure.\n    #\n    # And Net::IMAP::BodyTypeMessage has all methods of Net::IMAP::BodyTypeText.\n    #\n    class BodyTypeMessage < Struct.new(:media_type, :subtype,\n                                       :param, :content_id,\n                                       :description, :encoding, :size,\n                                       :envelope, :body, :lines,\n                                       :md5, :disposition, :language,\n                                       :extension)\n      def multipart?\n        return false\n      end\n\n      # Obsolete: use +subtype+ instead.  Calling this will\n      # generate a warning message to +stderr+, then return\n      # the value of +subtype+.\n      def media_subtype\n        warn(\"media_subtype is obsolete, use subtype instead.\\n\", uplevel: 1)\n        return subtype\n      end\n    end\n\n    # Net::IMAP::BodyTypeAttachment represents attachment body structures\n    # of messages.\n    #\n    # ==== Fields:\n    #\n    # media_type:: Returns the content media type name.\n    #\n    # subtype:: Returns +nil+.\n    #\n    # param:: Returns a hash that represents parameters.\n    #\n    # multipart?:: Returns false.\n    #\n    class BodyTypeAttachment < Struct.new(:media_type, :subtype,\n                                          :param)\n      def multipart?\n        return false\n      end\n    end\n\n    # Net::IMAP::BodyTypeMultipart represents multipart body structures\n    # of messages.\n    #\n    # ==== Fields:\n    #\n    # media_type:: Returns the content media type name as defined in [MIME-IMB].\n    #\n    # subtype:: Returns the content subtype name as defined in [MIME-IMB].\n    #\n    # parts:: Returns multiple parts.\n    #\n    # param:: Returns a hash that represents parameters as defined in [MIME-IMB].\n    #\n    # disposition:: Returns a Net::IMAP::ContentDisposition object giving\n    #               the content disposition.\n    #\n    # language:: Returns a string or an array of strings giving the body\n    #            language value as defined in [LANGUAGE-TAGS].\n    #\n    # extension:: Returns extension data.\n    #\n    # multipart?:: Returns true.\n    #\n    class BodyTypeMultipart < Struct.new(:media_type, :subtype,\n                                         :parts,\n                                         :param, :disposition, :language,\n                                         :extension)\n      def multipart?\n        return true\n      end\n\n      # Obsolete: use +subtype+ instead.  Calling this will\n      # generate a warning message to +stderr+, then return\n      # the value of +subtype+.\n      def media_subtype\n        warn(\"media_subtype is obsolete, use subtype instead.\\n\", uplevel: 1)\n        return subtype\n      end\n    end\n\n    class BodyTypeExtension < Struct.new(:media_type, :subtype,\n                                         :params, :content_id,\n                                         :description, :encoding, :size)\n      def multipart?\n        return false\n      end\n    end\n\n    class ResponseParser # :nodoc:\n      def initialize\n        @str = nil\n        @pos = nil\n        @lex_state = nil\n        @token = nil\n        @flag_symbols = {}\n      end\n\n      def parse(str)\n        @str = str\n        @pos = 0\n        @lex_state = EXPR_BEG\n        @token = nil\n        return response\n      end\n\n      private\n\n      EXPR_BEG          = :EXPR_BEG\n      EXPR_DATA         = :EXPR_DATA\n      EXPR_TEXT         = :EXPR_TEXT\n      EXPR_RTEXT        = :EXPR_RTEXT\n      EXPR_CTEXT        = :EXPR_CTEXT\n\n      T_SPACE   = :SPACE\n      T_NIL     = :NIL\n      T_NUMBER  = :NUMBER\n      T_ATOM    = :ATOM\n      T_QUOTED  = :QUOTED\n      T_LPAR    = :LPAR\n      T_RPAR    = :RPAR\n      T_BSLASH  = :BSLASH\n      T_STAR    = :STAR\n      T_LBRA    = :LBRA\n      T_RBRA    = :RBRA\n      T_LITERAL = :LITERAL\n      T_PLUS    = :PLUS\n      T_PERCENT = :PERCENT\n      T_CRLF    = :CRLF\n      T_EOF     = :EOF\n      T_TEXT    = :TEXT\n\n      BEG_REGEXP = /\\G(?:\\\n(?# 1:  SPACE   )( +)|\\\n(?# 2:  NIL     )(NIL)(?=[\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\\\[\\]+])|\\\n(?# 3:  NUMBER  )(\\d+)(?=[\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\\\[\\]+])|\\\n(?# 4:  ATOM    )([^\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\\\[\\]+]+)|\\\n(?# 5:  QUOTED  )\"((?:[^\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\"|\\\n(?# 6:  LPAR    )(\\()|\\\n(?# 7:  RPAR    )(\\))|\\\n(?# 8:  BSLASH  )(\\\\)|\\\n(?# 9:  STAR    )(\\*)|\\\n(?# 10: LBRA    )(\\[)|\\\n(?# 11: RBRA    )(\\])|\\\n(?# 12: LITERAL )\\{(\\d+)\\}\\r\\n|\\\n(?# 13: PLUS    )(\\+)|\\\n(?# 14: PERCENT )(%)|\\\n(?# 15: CRLF    )(\\r\\n)|\\\n(?# 16: EOF     )(\\z))/ni\n\n      DATA_REGEXP = /\\G(?:\\\n(?# 1:  SPACE   )( )|\\\n(?# 2:  NIL     )(NIL)|\\\n(?# 3:  NUMBER  )(\\d+)|\\\n(?# 4:  QUOTED  )\"((?:[^\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\"|\\\n(?# 5:  LITERAL )\\{(\\d+)\\}\\r\\n|\\\n(?# 6:  LPAR    )(\\()|\\\n(?# 7:  RPAR    )(\\)))/ni\n\n      TEXT_REGEXP = /\\G(?:\\\n(?# 1:  TEXT    )([^\\x00\\r\\n]*))/ni\n\n      RTEXT_REGEXP = /\\G(?:\\\n(?# 1:  LBRA    )(\\[)|\\\n(?# 2:  TEXT    )([^\\x00\\r\\n]*))/ni\n\n      CTEXT_REGEXP = /\\G(?:\\\n(?# 1:  TEXT    )([^\\x00\\r\\n\\]]*))/ni\n\n      Token = Struct.new(:symbol, :value)\n\n      def response\n        token = lookahead\n        case token.symbol\n        when T_PLUS\n          result = continue_req\n        when T_STAR\n          result = response_untagged\n        else\n          result = response_tagged\n        end\n        while lookahead.symbol == T_SPACE\n          # Ignore trailing space for Microsoft Exchange Server\n          shift_token\n        end\n        match(T_CRLF)\n        match(T_EOF)\n        return result\n      end\n\n      def continue_req\n        match(T_PLUS)\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          return ContinuationRequest.new(resp_text, @str)\n        else\n          return ContinuationRequest.new(ResponseText.new(nil, \"\"), @str)\n        end\n      end\n\n      def response_untagged\n        match(T_STAR)\n        match(T_SPACE)\n        token = lookahead\n        if token.symbol == T_NUMBER\n          return numeric_response\n        elsif token.symbol == T_ATOM\n          case token.value\n          when /\\A(?:OK|NO|BAD|BYE|PREAUTH)\\z/ni\n            return response_cond\n          when /\\A(?:FLAGS)\\z/ni\n            return flags_response\n          when /\\A(?:LIST|LSUB|XLIST)\\z/ni\n            return list_response\n          when /\\A(?:QUOTA)\\z/ni\n            return getquota_response\n          when /\\A(?:QUOTAROOT)\\z/ni\n            return getquotaroot_response\n          when /\\A(?:ACL)\\z/ni\n            return getacl_response\n          when /\\A(?:SEARCH|SORT)\\z/ni\n            return search_response\n          when /\\A(?:THREAD)\\z/ni\n            return thread_response\n          when /\\A(?:STATUS)\\z/ni\n            return status_response\n          when /\\A(?:CAPABILITY)\\z/ni\n            return capability_response\n          else\n            return text_response\n          end\n        else\n          parse_error(\"unexpected token %s\", token.symbol)\n        end\n      end\n\n      def response_tagged\n        tag = atom\n        match(T_SPACE)\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return TaggedResponse.new(tag, name, resp_text, @str)\n      end\n\n      def response_cond\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return UntaggedResponse.new(name, resp_text, @str)\n      end\n\n      def numeric_response\n        n = number\n        match(T_SPACE)\n        token = match(T_ATOM)\n        name = token.value.upcase\n        case name\n        when \"EXISTS\", \"RECENT\", \"EXPUNGE\"\n          return UntaggedResponse.new(name, n, @str)\n        when \"FETCH\"\n          shift_token\n          match(T_SPACE)\n          data = FetchData.new(n, msg_att(n))\n          return UntaggedResponse.new(name, data, @str)\n        end\n      end\n\n      def msg_att(n)\n        match(T_LPAR)\n        attr = {}\n        while true\n          token = lookahead\n          case token.symbol\n          when T_RPAR\n            shift_token\n            break\n          when T_SPACE\n            shift_token\n            next\n          end\n          case token.value\n          when /\\A(?:ENVELOPE)\\z/ni\n            name, val = envelope_data\n          when /\\A(?:FLAGS)\\z/ni\n            name, val = flags_data\n          when /\\A(?:INTERNALDATE)\\z/ni\n            name, val = internaldate_data\n          when /\\A(?:RFC822(?:\\.HEADER|\\.TEXT)?)\\z/ni\n            name, val = rfc822_text\n          when /\\A(?:RFC822\\.SIZE)\\z/ni\n            name, val = rfc822_size\n          when /\\A(?:BODY(?:STRUCTURE)?)\\z/ni\n            name, val = body_data\n          when /\\A(?:UID)\\z/ni\n            name, val = uid_data\n          when /\\A(?:MODSEQ)\\z/ni\n            name, val = modseq_data\n          else\n            parse_error(\"unknown attribute `%s' for {%d}\", token.value, n)\n          end\n          attr[name] = val\n        end\n        return attr\n      end\n\n      def envelope_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return name, envelope\n      end\n\n      def envelope\n        @lex_state = EXPR_DATA\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          result = nil\n        else\n          match(T_LPAR)\n          date = nstring\n          match(T_SPACE)\n          subject = nstring\n          match(T_SPACE)\n          from = address_list\n          match(T_SPACE)\n          sender = address_list\n          match(T_SPACE)\n          reply_to = address_list\n          match(T_SPACE)\n          to = address_list\n          match(T_SPACE)\n          cc = address_list\n          match(T_SPACE)\n          bcc = address_list\n          match(T_SPACE)\n          in_reply_to = nstring\n          match(T_SPACE)\n          message_id = nstring\n          match(T_RPAR)\n          result = Envelope.new(date, subject, from, sender, reply_to,\n                                to, cc, bcc, in_reply_to, message_id)\n        end\n        @lex_state = EXPR_BEG\n        return result\n      end\n\n      def flags_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return name, flag_list\n      end\n\n      def internaldate_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        token = match(T_QUOTED)\n        return name, token.value\n      end\n\n      def rfc822_text\n        token = match(T_ATOM)\n        name = token.value.upcase\n        token = lookahead\n        if token.symbol == T_LBRA\n          shift_token\n          match(T_RBRA)\n        end\n        match(T_SPACE)\n        return name, nstring\n      end\n\n      def rfc822_size\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return name, number\n      end\n\n      def body_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          return name, body\n        end\n        name.concat(section)\n        token = lookahead\n        if token.symbol == T_ATOM\n          name.concat(token.value)\n          shift_token\n        end\n        match(T_SPACE)\n        data = nstring\n        return name, data\n      end\n\n      def body\n        @lex_state = EXPR_DATA\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          result = nil\n        else\n          match(T_LPAR)\n          token = lookahead\n          if token.symbol == T_LPAR\n            result = body_type_mpart\n          else\n            result = body_type_1part\n          end\n          match(T_RPAR)\n        end\n        @lex_state = EXPR_BEG\n        return result\n      end\n\n      def body_type_1part\n        token = lookahead\n        case token.value\n        when /\\A(?:TEXT)\\z/ni\n          return body_type_text\n        when /\\A(?:MESSAGE)\\z/ni\n          return body_type_msg\n        when /\\A(?:ATTACHMENT)\\z/ni\n          return body_type_attachment\n        when /\\A(?:MIXED)\\z/ni\n          return body_type_mixed\n        else\n          return body_type_basic\n        end\n      end\n\n      def body_type_basic\n        mtype, msubtype = media_type\n        token = lookahead\n        if token.symbol == T_RPAR\n          return BodyTypeBasic.new(mtype, msubtype)\n        end\n        match(T_SPACE)\n        param, content_id, desc, enc, size = body_fields\n        md5, disposition, language, extension = body_ext_1part\n        return BodyTypeBasic.new(mtype, msubtype,\n                                 param, content_id,\n                                 desc, enc, size,\n                                 md5, disposition, language, extension)\n      end\n\n      def body_type_text\n        mtype, msubtype = media_type\n        match(T_SPACE)\n        param, content_id, desc, enc, size = body_fields\n        match(T_SPACE)\n        lines = number\n        md5, disposition, language, extension = body_ext_1part\n        return BodyTypeText.new(mtype, msubtype,\n                                param, content_id,\n                                desc, enc, size,\n                                lines,\n                                md5, disposition, language, extension)\n      end\n\n      def body_type_msg\n        mtype, msubtype = media_type\n        match(T_SPACE)\n        param, content_id, desc, enc, size = body_fields\n\n        token = lookahead\n        if token.symbol == T_RPAR\n          # If this is not message/rfc822, we shouldn't apply the RFC822\n          # spec to it.  We should handle anything other than\n          # message/rfc822 using multipart extension data [rfc3501] (i.e.\n          # the data itself won't be returned, we would have to retrieve it\n          # with BODYSTRUCTURE instead of with BODY\n\n          # Also, sometimes a message/rfc822 is included as a large\n          # attachment instead of having all of the other details\n          # (e.g. attaching a .eml file to an email)\n          if msubtype == \"RFC822\"\n            return BodyTypeMessage.new(mtype, msubtype, param, content_id,\n                                       desc, enc, size, nil, nil, nil, nil,\n                                       nil, nil, nil)\n          else\n            return BodyTypeExtension.new(mtype, msubtype,\n                                         param, content_id,\n                                         desc, enc, size)\n          end\n        end\n\n        match(T_SPACE)\n        env = envelope\n        match(T_SPACE)\n        b = body\n        match(T_SPACE)\n        lines = number\n        md5, disposition, language, extension = body_ext_1part\n        return BodyTypeMessage.new(mtype, msubtype,\n                                   param, content_id,\n                                   desc, enc, size,\n                                   env, b, lines,\n                                   md5, disposition, language, extension)\n      end\n\n      def body_type_attachment\n        mtype = case_insensitive_string\n        match(T_SPACE)\n        param = body_fld_param\n        return BodyTypeAttachment.new(mtype, nil, param)\n      end\n\n      def body_type_mixed\n        mtype = \"MULTIPART\"\n        msubtype = case_insensitive_string\n        param, disposition, language, extension = body_ext_mpart\n        return BodyTypeBasic.new(mtype, msubtype, param, nil, nil, nil, nil, nil, disposition, language, extension)\n      end\n\n      def body_type_mpart\n        parts = []\n        while true\n          token = lookahead\n          if token.symbol == T_SPACE\n            shift_token\n            break\n          end\n          parts.push(body)\n        end\n        mtype = \"MULTIPART\"\n        msubtype = case_insensitive_string\n        param, disposition, language, extension = body_ext_mpart\n        return BodyTypeMultipart.new(mtype, msubtype, parts,\n                                     param, disposition, language,\n                                     extension)\n      end\n\n      def media_type\n        mtype = case_insensitive_string\n        token = lookahead\n        if token.symbol != T_SPACE\n          return mtype, nil\n        end\n        match(T_SPACE)\n        msubtype = case_insensitive_string\n        return mtype, msubtype\n      end\n\n      def body_fields\n        param = body_fld_param\n        match(T_SPACE)\n        content_id = nstring\n        match(T_SPACE)\n        desc = nstring\n        match(T_SPACE)\n        enc = case_insensitive_string\n        match(T_SPACE)\n        size = number\n        return param, content_id, desc, enc, size\n      end\n\n      def body_fld_param\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        match(T_LPAR)\n        param = {}\n        while true\n          token = lookahead\n          case token.symbol\n          when T_RPAR\n            shift_token\n            break\n          when T_SPACE\n            shift_token\n          end\n          name = case_insensitive_string\n          match(T_SPACE)\n          val = string\n          param[name] = val\n        end\n        return param\n      end\n\n      def body_ext_1part\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return nil\n        end\n        md5 = nstring\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return md5\n        end\n        disposition = body_fld_dsp\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return md5, disposition\n        end\n        language = body_fld_lang\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return md5, disposition, language\n        end\n\n        extension = body_extensions\n        return md5, disposition, language, extension\n      end\n\n      def body_ext_mpart\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return nil\n        end\n        param = body_fld_param\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return param\n        end\n        disposition = body_fld_dsp\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return param, disposition\n        end\n        language = body_fld_lang\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return param, disposition, language\n        end\n\n        extension = body_extensions\n        return param, disposition, language, extension\n      end\n\n      def body_fld_dsp\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        match(T_LPAR)\n        dsp_type = case_insensitive_string\n        match(T_SPACE)\n        param = body_fld_param\n        match(T_RPAR)\n        return ContentDisposition.new(dsp_type, param)\n      end\n\n      def body_fld_lang\n        token = lookahead\n        if token.symbol == T_LPAR\n          shift_token\n          result = []\n          while true\n            token = lookahead\n            case token.symbol\n            when T_RPAR\n              shift_token\n              return result\n            when T_SPACE\n              shift_token\n            end\n            result.push(case_insensitive_string)\n          end\n        else\n          lang = nstring\n          if lang\n            return lang.upcase\n          else\n            return lang\n          end\n        end\n      end\n\n      def body_extensions\n        result = []\n        while true\n          token = lookahead\n          case token.symbol\n          when T_RPAR\n            return result\n          when T_SPACE\n            shift_token\n          end\n          result.push(body_extension)\n        end\n      end\n\n      def body_extension\n        token = lookahead\n        case token.symbol\n        when T_LPAR\n          shift_token\n          result = body_extensions\n          match(T_RPAR)\n          return result\n        when T_NUMBER\n          return number\n        else\n          return nstring\n        end\n      end\n\n      def section\n        str = String.new\n        token = match(T_LBRA)\n        str.concat(token.value)\n        token = match(T_ATOM, T_NUMBER, T_RBRA)\n        if token.symbol == T_RBRA\n          str.concat(token.value)\n          return str\n        end\n        str.concat(token.value)\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          str.concat(token.value)\n          token = match(T_LPAR)\n          str.concat(token.value)\n          while true\n            token = lookahead\n            case token.symbol\n            when T_RPAR\n              str.concat(token.value)\n              shift_token\n              break\n            when T_SPACE\n              shift_token\n              str.concat(token.value)\n            end\n            str.concat(format_string(astring))\n          end\n        end\n        token = match(T_RBRA)\n        str.concat(token.value)\n        return str\n      end\n\n      def format_string(str)\n        case str\n        when \"\"\n          return '\"\"'\n        when /[\\x80-\\xff\\r\\n]/n\n          # literal\n          return \"{\" + str.bytesize.to_s + \"}\" + CRLF + str\n        when /[(){ \\x00-\\x1f\\x7f%*\"\\\\]/n\n          # quoted string\n          return '\"' + str.gsub(/[\"\\\\]/n, \"\\\\\\\\\\\\&\") + '\"'\n        else\n          # atom\n          return str\n        end\n      end\n\n      def uid_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return name, number\n      end\n\n      def modseq_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        match(T_LPAR)\n        modseq = number\n        match(T_RPAR)\n        return name, modseq\n      end\n\n      def text_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        @lex_state = EXPR_TEXT\n        token = match(T_TEXT)\n        @lex_state = EXPR_BEG\n        return UntaggedResponse.new(name, token.value)\n      end\n\n      def flags_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return UntaggedResponse.new(name, flag_list, @str)\n      end\n\n      def list_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return UntaggedResponse.new(name, mailbox_list, @str)\n      end\n\n      def mailbox_list\n        attr = flag_list\n        match(T_SPACE)\n        token = match(T_QUOTED, T_NIL)\n        if token.symbol == T_NIL\n          delim = nil\n        else\n          delim = token.value\n        end\n        match(T_SPACE)\n        name = astring\n        return MailboxList.new(attr, delim, name)\n      end\n\n      def getquota_response\n        # If quota never established, get back\n        # `NO Quota root does not exist'.\n        # If quota removed, get `()' after the\n        # folder spec with no mention of `STORAGE'.\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        mailbox = astring\n        match(T_SPACE)\n        match(T_LPAR)\n        token = lookahead\n        case token.symbol\n        when T_RPAR\n          shift_token\n          data = MailboxQuota.new(mailbox, nil, nil)\n          return UntaggedResponse.new(name, data, @str)\n        when T_ATOM\n          shift_token\n          match(T_SPACE)\n          token = match(T_NUMBER)\n          usage = token.value\n          match(T_SPACE)\n          token = match(T_NUMBER)\n          quota = token.value\n          match(T_RPAR)\n          data = MailboxQuota.new(mailbox, usage, quota)\n          return UntaggedResponse.new(name, data, @str)\n        else\n          parse_error(\"unexpected token %s\", token.symbol)\n        end\n      end\n\n      def getquotaroot_response\n        # Similar to getquota, but only admin can use getquota.\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        mailbox = astring\n        quotaroots = []\n        while true\n          token = lookahead\n          break unless token.symbol == T_SPACE\n          shift_token\n          quotaroots.push(astring)\n        end\n        data = MailboxQuotaRoot.new(mailbox, quotaroots)\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def getacl_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        mailbox = astring\n        data = []\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          while true\n            token = lookahead\n            case token.symbol\n            when T_CRLF\n              break\n            when T_SPACE\n              shift_token\n            end\n            user = astring\n            match(T_SPACE)\n            rights = astring\n            data.push(MailboxACLItem.new(user, rights, mailbox))\n          end\n        end\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def search_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          data = []\n          while true\n            token = lookahead\n            case token.symbol\n            when T_CRLF\n              break\n            when T_SPACE\n              shift_token\n            when T_NUMBER\n              data.push(number)\n            when T_LPAR\n              # TODO: include the MODSEQ value in a response\n              shift_token\n              match(T_ATOM)\n              match(T_SPACE)\n              match(T_NUMBER)\n              match(T_RPAR)\n            end\n          end\n        else\n          data = []\n        end\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def thread_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        token = lookahead\n\n        if token.symbol == T_SPACE\n          threads = []\n\n          while true\n            shift_token\n            token = lookahead\n\n            case token.symbol\n            when T_LPAR\n              threads << thread_branch(token)\n            when T_CRLF\n              break\n            end\n          end\n        else\n          # no member\n          threads = []\n        end\n\n        return UntaggedResponse.new(name, threads, @str)\n      end\n\n      def thread_branch(token)\n        rootmember = nil\n        lastmember = nil\n\n        while true\n          shift_token    # ignore first T_LPAR\n          token = lookahead\n\n          case token.symbol\n          when T_NUMBER\n            # new member\n            newmember = ThreadMember.new(number, [])\n            if rootmember.nil?\n              rootmember = newmember\n            else\n              lastmember.children << newmember\n            end\n            lastmember = newmember\n          when T_SPACE\n            # do nothing\n          when T_LPAR\n            if rootmember.nil?\n              # dummy member\n              lastmember = rootmember = ThreadMember.new(nil, [])\n            end\n\n            lastmember.children << thread_branch(token)\n          when T_RPAR\n            break\n          end\n        end\n\n        return rootmember\n      end\n\n      def status_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        mailbox = astring\n        match(T_SPACE)\n        match(T_LPAR)\n        attr = {}\n        while true\n          token = lookahead\n          case token.symbol\n          when T_RPAR\n            shift_token\n            break\n          when T_SPACE\n            shift_token\n          end\n          token = match(T_ATOM)\n          key = token.value.upcase\n          match(T_SPACE)\n          val = number\n          attr[key] = val\n        end\n        data = StatusData.new(mailbox, attr)\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def capability_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        data = []\n        while true\n          token = lookahead\n          case token.symbol\n          when T_CRLF\n            break\n          when T_SPACE\n            shift_token\n            next\n          end\n          data.push(atom.upcase)\n        end\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def resp_text\n        @lex_state = EXPR_RTEXT\n        token = lookahead\n        if token.symbol == T_LBRA\n          code = resp_text_code\n        else\n          code = nil\n        end\n        token = match(T_TEXT)\n        @lex_state = EXPR_BEG\n        return ResponseText.new(code, token.value)\n      end\n\n      def resp_text_code\n        @lex_state = EXPR_BEG\n        match(T_LBRA)\n        token = match(T_ATOM)\n        name = token.value.upcase\n        case name\n        when /\\A(?:ALERT|PARSE|READ-ONLY|READ-WRITE|TRYCREATE|NOMODSEQ)\\z/n\n          result = ResponseCode.new(name, nil)\n        when /\\A(?:PERMANENTFLAGS)\\z/n\n          match(T_SPACE)\n          result = ResponseCode.new(name, flag_list)\n        when /\\A(?:UIDVALIDITY|UIDNEXT|UNSEEN)\\z/n\n          match(T_SPACE)\n          result = ResponseCode.new(name, number)\n        else\n          token = lookahead\n          if token.symbol == T_SPACE\n            shift_token\n            @lex_state = EXPR_CTEXT\n            token = match(T_TEXT)\n            @lex_state = EXPR_BEG\n            result = ResponseCode.new(name, token.value)\n          else\n            result = ResponseCode.new(name, nil)\n          end\n        end\n        match(T_RBRA)\n        @lex_state = EXPR_RTEXT\n        return result\n      end\n\n      def address_list\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        else\n          result = []\n          match(T_LPAR)\n          while true\n            token = lookahead\n            case token.symbol\n            when T_RPAR\n              shift_token\n              break\n            when T_SPACE\n              shift_token\n            end\n            result.push(address)\n          end\n          return result\n        end\n      end\n\n      ADDRESS_REGEXP = /\\G\\\n(?# 1: NAME     )(?:NIL|\"((?:[^\\x80-\\xff\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\") \\\n(?# 2: ROUTE    )(?:NIL|\"((?:[^\\x80-\\xff\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\") \\\n(?# 3: MAILBOX  )(?:NIL|\"((?:[^\\x80-\\xff\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\") \\\n(?# 4: HOST     )(?:NIL|\"((?:[^\\x80-\\xff\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\")\\\n\\)/ni\n\n      def address\n        match(T_LPAR)\n        if @str.index(ADDRESS_REGEXP, @pos)\n          # address does not include literal.\n          @pos = $~.end(0)\n          name = $1\n          route = $2\n          mailbox = $3\n          host = $4\n          for s in [name, route, mailbox, host]\n            if s\n              s.gsub!(/\\\\([\"\\\\])/n, \"\\\\1\")\n            end\n          end\n        else\n          name = nstring\n          match(T_SPACE)\n          route = nstring\n          match(T_SPACE)\n          mailbox = nstring\n          match(T_SPACE)\n          host = nstring\n          match(T_RPAR)\n        end\n        return Address.new(name, route, mailbox, host)\n      end\n\n      FLAG_REGEXP = /\\\n(?# FLAG        )\\\\([^\\x80-\\xff(){ \\x00-\\x1f\\x7f%\"\\\\]+)|\\\n(?# ATOM        )([^\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\]+)/n\n\n      def flag_list\n        if @str.index(/\\(([^)]*)\\)/ni, @pos)\n          @pos = $~.end(0)\n          return $1.scan(FLAG_REGEXP).collect { |flag, atom|\n            if atom\n              atom\n            else\n              symbol = flag.capitalize.intern\n              @flag_symbols[symbol] = true\n              if @flag_symbols.length > IMAP.max_flag_count\n                raise FlagCountError, \"number of flag symbols exceeded\"\n              end\n              symbol\n            end\n          }\n        else\n          parse_error(\"invalid flag list\")\n        end\n      end\n\n      def nstring\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        else\n          return string\n        end\n      end\n\n      def astring\n        token = lookahead\n        if string_token?(token)\n          return string\n        else\n          return atom\n        end\n      end\n\n      def string\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        token = match(T_QUOTED, T_LITERAL)\n        return token.value\n      end\n\n      STRING_TOKENS = [T_QUOTED, T_LITERAL, T_NIL]\n\n      def string_token?(token)\n        return STRING_TOKENS.include?(token.symbol)\n      end\n\n      def case_insensitive_string\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        token = match(T_QUOTED, T_LITERAL)\n        return token.value.upcase\n      end\n\n      def atom\n        result = String.new\n        while true\n          token = lookahead\n          if atom_token?(token)\n            result.concat(token.value)\n            shift_token\n          else\n            if result.empty?\n              parse_error(\"unexpected token %s\", token.symbol)\n            else\n              return result\n            end\n          end\n        end\n      end\n\n      ATOM_TOKENS = [\n        T_ATOM,\n        T_NUMBER,\n        T_NIL,\n        T_LBRA,\n        T_RBRA,\n        T_PLUS\n      ]\n\n      def atom_token?(token)\n        return ATOM_TOKENS.include?(token.symbol)\n      end\n\n      def number\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        token = match(T_NUMBER)\n        return token.value.to_i\n      end\n\n      def nil_atom\n        match(T_NIL)\n        return nil\n      end\n\n      def match(*args)\n        token = lookahead\n        unless args.include?(token.symbol)\n          parse_error('unexpected token %s (expected %s)',\n                      token.symbol.id2name,\n                      args.collect {|i| i.id2name}.join(\" or \"))\n        end\n        shift_token\n        return token\n      end\n\n      def lookahead\n        unless @token\n          @token = next_token\n        end\n        return @token\n      end\n\n      def shift_token\n        @token = nil\n      end\n\n      def next_token\n        case @lex_state\n        when EXPR_BEG\n          if @str.index(BEG_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_SPACE, $+)\n            elsif $2\n              return Token.new(T_NIL, $+)\n            elsif $3\n              return Token.new(T_NUMBER, $+)\n            elsif $4\n              return Token.new(T_ATOM, $+)\n            elsif $5\n              return Token.new(T_QUOTED,\n                               $+.gsub(/\\\\([\"\\\\])/n, \"\\\\1\"))\n            elsif $6\n              return Token.new(T_LPAR, $+)\n            elsif $7\n              return Token.new(T_RPAR, $+)\n            elsif $8\n              return Token.new(T_BSLASH, $+)\n            elsif $9\n              return Token.new(T_STAR, $+)\n            elsif $10\n              return Token.new(T_LBRA, $+)\n            elsif $11\n              return Token.new(T_RBRA, $+)\n            elsif $12\n              len = $+.to_i\n              val = @str[@pos, len]\n              @pos += len\n              return Token.new(T_LITERAL, val)\n            elsif $13\n              return Token.new(T_PLUS, $+)\n            elsif $14\n              return Token.new(T_PERCENT, $+)\n            elsif $15\n              return Token.new(T_CRLF, $+)\n            elsif $16\n              return Token.new(T_EOF, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] BEG_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos)\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        when EXPR_DATA\n          if @str.index(DATA_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_SPACE, $+)\n            elsif $2\n              return Token.new(T_NIL, $+)\n            elsif $3\n              return Token.new(T_NUMBER, $+)\n            elsif $4\n              return Token.new(T_QUOTED,\n                               $+.gsub(/\\\\([\"\\\\])/n, \"\\\\1\"))\n            elsif $5\n              len = $+.to_i\n              val = @str[@pos, len]\n              @pos += len\n              return Token.new(T_LITERAL, val)\n            elsif $6\n              return Token.new(T_LPAR, $+)\n            elsif $7\n              return Token.new(T_RPAR, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] DATA_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos)\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        when EXPR_TEXT\n          if @str.index(TEXT_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_TEXT, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] TEXT_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos)\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        when EXPR_RTEXT\n          if @str.index(RTEXT_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_LBRA, $+)\n            elsif $2\n              return Token.new(T_TEXT, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] RTEXT_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos)\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        when EXPR_CTEXT\n          if @str.index(CTEXT_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_TEXT, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] CTEXT_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos) #/\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        else\n          parse_error(\"invalid @lex_state - %s\", @lex_state.inspect)\n        end\n      end\n\n      def parse_error(fmt, *args)\n        if IMAP.debug\n          $stderr.printf(\"@str: %s\\n\", @str.dump)\n          $stderr.printf(\"@pos: %d\\n\", @pos)\n          $stderr.printf(\"@lex_state: %s\\n\", @lex_state)\n          if @token\n            $stderr.printf(\"@token.symbol: %s\\n\", @token.symbol)\n            $stderr.printf(\"@token.value: %s\\n\", @token.value.inspect)\n          end\n        end\n        raise ResponseParseError, format(fmt, *args)\n      end\n    end\n\n    # Authenticator for the \"LOGIN\" authentication type.  See\n    # #authenticate().\n    class LoginAuthenticator\n      def process(data)\n        case @state\n        when STATE_USER\n          @state = STATE_PASSWORD\n          return @user\n        when STATE_PASSWORD\n          return @password\n        end\n      end\n\n      private\n\n      STATE_USER = :USER\n      STATE_PASSWORD = :PASSWORD\n\n      def initialize(user, password)\n        @user = user\n        @password = password\n        @state = STATE_USER\n      end\n    end\n    add_authenticator \"LOGIN\", LoginAuthenticator\n\n    # Authenticator for the \"PLAIN\" authentication type.  See\n    # #authenticate().\n    class PlainAuthenticator\n      def process(data)\n        return \"\\0#{@user}\\0#{@password}\"\n      end\n\n      private\n\n      def initialize(user, password)\n        @user = user\n        @password = password\n      end\n    end\n    add_authenticator \"PLAIN\", PlainAuthenticator\n\n    # Authenticator for the \"CRAM-MD5\" authentication type.  See\n    # #authenticate().\n    class CramMD5Authenticator\n      def process(challenge)\n        digest = hmac_md5(challenge, @password)\n        return @user + \" \" + digest\n      end\n\n      private\n\n      def initialize(user, password)\n        @user = user\n        @password = password\n      end\n\n      def hmac_md5(text, key)\n        if key.length > 64\n          key = Digest::MD5.digest(key)\n        end\n\n        k_ipad = key + \"\\0\" * (64 - key.length)\n        k_opad = key + \"\\0\" * (64 - key.length)\n        for i in 0..63\n          k_ipad[i] = (k_ipad[i].ord ^ 0x36).chr\n          k_opad[i] = (k_opad[i].ord ^ 0x5c).chr\n        end\n\n        digest = Digest::MD5.digest(k_ipad + text)\n\n        return Digest::MD5.hexdigest(k_opad + digest)\n      end\n    end\n    add_authenticator \"CRAM-MD5\", CramMD5Authenticator\n\n    # Authenticator for the \"DIGEST-MD5\" authentication type.  See\n    # #authenticate().\n    class DigestMD5Authenticator\n      def process(challenge)\n        case @stage\n        when STAGE_ONE\n          @stage = STAGE_TWO\n          sparams = {}\n          c = StringScanner.new(challenge)\n          while c.scan(/(?:\\s*,)?\\s*(\\w+)=(\"(?:[^\\\\\"]+|\\\\.)*\"|[^,]+)\\s*/)\n            k, v = c[1], c[2]\n            if v =~ /^\"(.*)\"$/\n              v = $1\n              if v =~ /,/\n                v = v.split(',')\n              end\n            end\n            sparams[k] = v\n          end\n\n          raise DataFormatError, \"Bad Challenge: '#{challenge}'\" unless c.rest.size == 0\n          raise Error, \"Server does not support auth (qop = #{sparams['qop'].join(',')})\" unless sparams['qop'].include?(\"auth\")\n\n          response = {\n            :nonce => sparams['nonce'],\n            :username => @user,\n            :realm => sparams['realm'],\n            :cnonce => Digest::MD5.hexdigest(\"%.15f:%.15f:%d\" % [Time.now.to_f, rand, Process.pid.to_s]),\n            :'digest-uri' => 'imap/' + sparams['realm'],\n            :qop => 'auth',\n            :maxbuf => 65535,\n            :nc => \"%08d\" % nc(sparams['nonce']),\n            :charset => sparams['charset'],\n          }\n\n          response[:authzid] = @authname unless @authname.nil?\n\n          # now, the real thing\n          a0 = Digest::MD5.digest( [ response.values_at(:username, :realm), @password ].join(':') )\n\n          a1 = [ a0, response.values_at(:nonce,:cnonce) ].join(':')\n          a1 << ':' + response[:authzid] unless response[:authzid].nil?\n\n          a2 = \"AUTHENTICATE:\" + response[:'digest-uri']\n          a2 << \":00000000000000000000000000000000\" if response[:qop] and response[:qop] =~ /^auth-(?:conf|int)$/\n\n          response[:response] = Digest::MD5.hexdigest(\n            [\n             Digest::MD5.hexdigest(a1),\n             response.values_at(:nonce, :nc, :cnonce, :qop),\n             Digest::MD5.hexdigest(a2)\n            ].join(':')\n          )\n\n          return response.keys.map {|key| qdval(key.to_s, response[key]) }.join(',')\n        when STAGE_TWO\n          @stage = nil\n          # if at the second stage, return an empty string\n          if challenge =~ /rspauth=/\n            return ''\n          else\n            raise ResponseParseError, challenge\n          end\n        else\n          raise ResponseParseError, challenge\n        end\n      end\n\n      def initialize(user, password, authname = nil)\n        @user, @password, @authname = user, password, authname\n        @nc, @stage = {}, STAGE_ONE\n      end\n\n      private\n\n      STAGE_ONE = :stage_one\n      STAGE_TWO = :stage_two\n\n      def nc(nonce)\n        if @nc.has_key? nonce\n          @nc[nonce] = @nc[nonce] + 1\n        else\n          @nc[nonce] = 1\n        end\n        return @nc[nonce]\n      end\n\n      # some responses need quoting\n      def qdval(k, v)\n        return if k.nil? or v.nil?\n        if %w\"username authzid realm nonce cnonce digest-uri qop\".include? k\n          v.gsub!(/([\\\\\"])/, \"\\\\\\1\")\n          return '%s=\"%s\"' % [k, v]\n        else\n          return '%s=%s' % [k, v]\n        end\n      end\n    end\n    add_authenticator \"DIGEST-MD5\", DigestMD5Authenticator\n\n    # Superclass of IMAP errors.\n    class Error < StandardError\n    end\n\n    # Error raised when data is in the incorrect format.\n    class DataFormatError < Error\n    end\n\n    # Error raised when a response from the server is non-parseable.\n    class ResponseParseError < Error\n    end\n\n    # Superclass of all errors used to encapsulate \"fail\" responses\n    # from the server.\n    class ResponseError < Error\n\n      # The response that caused this error\n      attr_accessor :response\n\n      def initialize(response)\n        @response = response\n\n        super @response.data.text\n      end\n\n    end\n\n    # Error raised upon a \"NO\" response from the server, indicating\n    # that the client command could not be completed successfully.\n    class NoResponseError < ResponseError\n    end\n\n    # Error raised upon a \"BAD\" response from the server, indicating\n    # that the client command violated the IMAP protocol, or an internal\n    # server failure has occurred.\n    class BadResponseError < ResponseError\n    end\n\n    # Error raised upon a \"BYE\" response from the server, indicating\n    # that the client is not being allowed to login, or has been timed\n    # out due to inactivity.\n    class ByeResponseError < ResponseError\n    end\n\n    RESPONSE_ERRORS = Hash.new(ResponseError)\n    RESPONSE_ERRORS[\"NO\"] = NoResponseError\n    RESPONSE_ERRORS[\"BAD\"] = BadResponseError\n\n    # Error raised when too many flags are interned to symbols.\n    class FlagCountError < Error\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"net/imap\"\nrequire \"test/unit\"\n\nclass IMAPTest < Test::Unit::TestCase\n  CA_FILE = File.expand_path(\"../fixtures/cacert.pem\", __dir__)\n  SERVER_KEY = File.expand_path(\"../fixtures/server.key\", __dir__)\n  SERVER_CERT = File.expand_path(\"../fixtures/server.crt\", __dir__)\n\n  def setup\n    @do_not_reverse_lookup = Socket.do_not_reverse_lookup\n    Socket.do_not_reverse_lookup = true\n    @threads = []\n  end\n\n  def teardown\n    if !@threads.empty?\n      assert_join_threads(@threads)\n    end\n  ensure\n    Socket.do_not_reverse_lookup = @do_not_reverse_lookup\n  end\n\n  def test_encode_utf7\n    assert_equal(\"foo\", Net::IMAP.encode_utf7(\"foo\"))\n    assert_equal(\"&-\", Net::IMAP.encode_utf7(\"&\"))\n\n    utf8 = \"\\357\\274\\241\\357\\274\\242\\357\\274\\243\".dup.force_encoding(\"UTF-8\")\n    s = Net::IMAP.encode_utf7(utf8)\n    assert_equal(\"&,yH,Iv8j-\", s)\n    s = Net::IMAP.encode_utf7(\"foo&#{utf8}-bar\".encode(\"EUC-JP\"))\n    assert_equal(\"foo&-&,yH,Iv8j--bar\", s)\n\n    utf8 = \"\\343\\201\\202&\".dup.force_encoding(\"UTF-8\")\n    s = Net::IMAP.encode_utf7(utf8)\n    assert_equal(\"&MEI-&-\", s)\n    s = Net::IMAP.encode_utf7(utf8.encode(\"EUC-JP\"))\n    assert_equal(\"&MEI-&-\", s)\n  end\n\n  def test_decode_utf7\n    assert_equal(\"&\", Net::IMAP.decode_utf7(\"&-\"))\n    assert_equal(\"&-\", Net::IMAP.decode_utf7(\"&--\"))\n\n    s = Net::IMAP.decode_utf7(\"&,yH,Iv8j-\")\n    utf8 = \"\\357\\274\\241\\357\\274\\242\\357\\274\\243\".dup.force_encoding(\"UTF-8\")\n    assert_equal(utf8, s)\n  end\n\n  def test_format_date\n    time = Time.mktime(2009, 7, 24)\n    s = Net::IMAP.format_date(time)\n    assert_equal(\"24-Jul-2009\", s)\n  end\n\n  def test_format_datetime\n    time = Time.mktime(2009, 7, 24, 1, 23, 45)\n    s = Net::IMAP.format_datetime(time)\n    assert_match(/\\A24-Jul-2009 01:23 [+\\-]\\d{4}\\z/, s)\n  end\n\n  if defined?(OpenSSL::SSL::SSLError)\n    def test_imaps_unknown_ca\n      assert_raise(OpenSSL::SSL::SSLError) do\n        imaps_test do |port|\n          begin\n            Net::IMAP.new(\"localhost\",\n                          :port => port,\n                          :ssl => true)\n          rescue SystemCallError\n            skip $!\n          end\n        end\n      end\n    end\n\n    def test_imaps_with_ca_file\n      assert_nothing_raised do\n        imaps_test do |port|\n          begin\n            Net::IMAP.new(\"localhost\",\n                          :port => port,\n                          :ssl => { :ca_file => CA_FILE })\n          rescue SystemCallError\n            skip $!\n          end\n        end\n      end\n    end\n\n    def test_imaps_verify_none\n      assert_nothing_raised do\n        imaps_test do |port|\n          Net::IMAP.new(server_addr,\n                        :port => port,\n                        :ssl => { :verify_mode => OpenSSL::SSL::VERIFY_NONE })\n        end\n      end\n    end\n\n    def test_imaps_post_connection_check\n      assert_raise(OpenSSL::SSL::SSLError) do\n        imaps_test do |port|\n          # server_addr is different from the hostname in the certificate,\n          # so the following code should raise a SSLError.\n          Net::IMAP.new(server_addr,\n                        :port => port,\n                        :ssl => { :ca_file => CA_FILE })\n        end\n      end\n    end\n  end\n\n  if defined?(OpenSSL::SSL)\n    def test_starttls\n      imap = nil\n      starttls_test do |port|\n        imap = Net::IMAP.new(\"localhost\", :port => port)\n        imap.starttls(:ca_file => CA_FILE)\n        imap\n      end\n    rescue SystemCallError\n      skip $!\n    ensure\n      if imap && !imap.disconnected?\n        imap.disconnect\n      end\n    end\n  end\n\n  def start_server\n    th = Thread.new do\n      yield\n    end\n    @threads << th\n    sleep 0.1 until th.stop?\n  end\n\n  def test_unexpected_eof\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n#       sock.print(\"* BYE terminating connection\\r\\n\")\n#       sock.print(\"RUBY0001 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(EOFError) do\n        imap.logout\n      end\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_idle\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"+ idling\\r\\n\")\n        sock.print(\"* 3 EXISTS\\r\\n\")\n        sock.print(\"* 2 EXPUNGE\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 OK IDLE terminated\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      responses = []\n      imap.idle do |res|\n        responses.push(res)\n        if res.name == \"EXPUNGE\"\n          imap.idle_done\n        end\n      end\n      assert_equal(3, responses.length)\n      assert_instance_of(Net::IMAP::ContinuationRequest, responses[0])\n      assert_equal(\"EXISTS\", responses[1].name)\n      assert_equal(3, responses[1].data)\n      assert_equal(\"EXPUNGE\", responses[2].name)\n      assert_equal(2, responses[2].data)\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0001 IDLE\\r\\n\", requests[0])\n      assert_equal(\"DONE\\r\\n\", requests[1])\n      imap.logout\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_exception_during_idle\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"+ idling\\r\\n\")\n        sock.print(\"* 3 EXISTS\\r\\n\")\n        sock.print(\"* 2 EXPUNGE\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 OK IDLE terminated\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      begin\n        th = Thread.current\n        m = Monitor.new\n        in_idle = false\n        exception_raised = false\n        c = m.new_cond\n        raiser = Thread.start do\n          m.synchronize do\n            until in_idle\n              c.wait(0.1)\n            end\n          end\n          th.raise(Interrupt)\n          m.synchronize do\n            exception_raised = true\n            c.signal\n          end\n        end\n        @threads << raiser\n        imap.idle do |res|\n          m.synchronize do\n            in_idle = true\n            c.signal\n            until exception_raised\n              c.wait(0.1)\n            end\n          end\n        end\n      rescue Interrupt\n      end\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0001 IDLE\\r\\n\", requests[0])\n      assert_equal(\"DONE\\r\\n\", requests[1])\n      imap.logout\n    ensure\n      imap.disconnect if imap\n      raiser.kill unless in_idle\n    end\n  end\n\n  def test_idle_done_not_during_idle\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(Net::IMAP::Error) do\n        imap.idle_done\n      end\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_idle_timeout\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"+ idling\\r\\n\")\n        sock.print(\"* 3 EXISTS\\r\\n\")\n        sock.print(\"* 2 EXPUNGE\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 OK IDLE terminated\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      responses = []\n      Thread.pass\n      imap.idle(0.2) do |res|\n        responses.push(res)\n      end\n      # There is no guarantee that this thread has received all the responses,\n      # so check the response length.\n      if responses.length > 0\n        assert_instance_of(Net::IMAP::ContinuationRequest, responses[0])\n        if responses.length > 1\n          assert_equal(\"EXISTS\", responses[1].name)\n          assert_equal(3, responses[1].data)\n          if responses.length > 2\n            assert_equal(\"EXPUNGE\", responses[2].name)\n            assert_equal(2, responses[2].data)\n          end\n        end\n      end\n      # Also, there is no guarantee that the server thread has stored\n      # all the requests into the array, so check the length.\n      if requests.length > 0\n        assert_equal(\"RUBY0001 IDLE\\r\\n\", requests[0])\n        if requests.length > 1\n          assert_equal(\"DONE\\r\\n\", requests[1])\n        end\n      end\n      imap.logout\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_unexpected_bye\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK Gimap ready for requests from 75.101.246.151 33if2752585qyk.26\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE System Error 33if2752585qyk.26\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(Net::IMAP::ByeResponseError) do\n        imap.login(\"user\", \"password\")\n      end\n    end\n  end\n\n  def test_exception_during_shutdown\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0001 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      imap.instance_eval do\n        def @sock.shutdown(*args)\n          super\n        ensure\n          raise \"error\"\n        end\n      end\n      imap.logout\n    ensure\n      assert_raise(RuntimeError) do\n        imap.disconnect\n      end\n    end\n  end\n\n  def test_connection_closed_during_idle\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    sock = nil\n    threads = []\n    started = false\n    threads << Thread.start do\n      started = true\n      begin\n        sock = server.accept\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"+ idling\\r\\n\")\n      rescue IOError # sock is closed by another thread\n      ensure\n        server.close\n      end\n    end\n    sleep 0.1 until started\n    threads << Thread.start do\n      imap = Net::IMAP.new(server_addr, :port => port)\n      begin\n        m = Monitor.new\n        in_idle = false\n        closed = false\n        c = m.new_cond\n        threads << Thread.start do\n          m.synchronize do\n            until in_idle\n              c.wait(0.1)\n            end\n          end\n          sock.close\n          m.synchronize do\n            closed = true\n            c.signal\n          end\n        end\n        assert_raise(EOFError) do\n          imap.idle do |res|\n            m.synchronize do\n              in_idle = true\n              c.signal\n              until closed\n                c.wait(0.1)\n              end\n            end\n          end\n        end\n        assert_equal(1, requests.length)\n        assert_equal(\"RUBY0001 IDLE\\r\\n\", requests[0])\n      ensure\n        imap.disconnect if imap\n      end\n    end\n    assert_join_threads(threads)\n  ensure\n    if sock && !sock.closed?\n      sock.close\n    end\n  end\n\n  def test_connection_closed_without_greeting\n    server = create_tcp_server\n    port = server.addr[1]\n    h = {'server before close': server.inspect} # inspect info before close\n    start_server do\n      begin\n        sock = server.accept\n        h[:sock_addr], h[:sock_peeraddr] = sock.addr, sock.peeraddr\n        sock.close\n      ensure\n        server.close\n      end\n    end\n    assert_raise(Net::IMAP::Error) do\n      #begin\n      Net::IMAP.new(server_addr, :port => port)\n      #rescue Net::IMAP::Error\n      #  raise Errno::EINVAL\n      #end\n    rescue Errno::EINVAL => e # for debug on OpenCSW\n      h.merge!({e: e, server: server, port: port, server_addr: server_addr})\n      raise(h.inspect)\n    end\n  end\n\n  def test_default_port\n    assert_equal(143, Net::IMAP.default_port)\n    assert_equal(143, Net::IMAP.default_imap_port)\n    assert_equal(993, Net::IMAP.default_tls_port)\n    assert_equal(993, Net::IMAP.default_ssl_port)\n    assert_equal(993, Net::IMAP.default_imaps_port)\n  end\n\n  def test_send_invalid_number\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0001 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0002 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0003 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0004 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0005 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", -1)\n      end\n      imap.send(:send_command, \"TEST\", 0)\n      imap.send(:send_command, \"TEST\", 4294967295)\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", 4294967296)\n      end\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(-1))\n      end\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(0))\n      end\n      imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(1))\n      imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(4294967295))\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(4294967296))\n      end\n      imap.logout\n    ensure\n      imap.disconnect\n    end\n  end\n\n  def test_send_literal\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    literal = nil\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        line = sock.gets\n        requests.push(line)\n        size = line.slice(/{(\\d+)}\\r\\n/, 1).to_i\n        sock.print(\"+ Ready for literal data\\r\\n\")\n        literal = sock.read(size)\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      imap.send(:send_command, \"TEST\", [\"\\xDE\\xAD\\xBE\\xEF\".b])\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0001 TEST ({4}\\r\\n\", requests[0])\n      assert_equal(\"\\xDE\\xAD\\xBE\\xEF\".b, literal)\n      assert_equal(\")\\r\\n\", requests[1])\n      imap.logout\n    ensure\n      imap.disconnect\n    end\n  end\n\n  def test_disconnect\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0001 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      imap.logout\n      imap.disconnect\n      assert_equal(true, imap.disconnected?)\n      imap.disconnect\n      assert_equal(true, imap.disconnected?)\n    ensure\n      imap.disconnect if imap && !imap.disconnected?\n    end\n  end\n\n  def test_append\n    server = create_tcp_server\n    port = server.addr[1]\n    mail = <<EOF.gsub(/\\n/, \"\\r\\n\")\nFrom: shugo@example.com\nTo: matz@example.com\nSubject: hello\n\nhello world\nEOF\n    requests = []\n    received_mail = nil\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        line = sock.gets\n        requests.push(line)\n        size = line.slice(/{(\\d+)}\\r\\n/, 1).to_i\n        sock.print(\"+ Ready for literal data\\r\\n\")\n        received_mail = sock.read(size)\n        sock.gets\n        sock.print(\"RUBY0001 OK APPEND completed\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      imap.append(\"INBOX\", mail)\n      assert_equal(1, requests.length)\n      assert_equal(\"RUBY0001 APPEND INBOX {#{mail.size}}\\r\\n\", requests[0])\n      assert_equal(mail, received_mail)\n      imap.logout\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0002 LOGOUT\\r\\n\", requests[1])\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_append_fail\n    server = create_tcp_server\n    port = server.addr[1]\n    mail = <<EOF.gsub(/\\n/, \"\\r\\n\")\nFrom: shugo@example.com\nTo: matz@example.com\nSubject: hello\n\nhello world\nEOF\n    requests = []\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 NO Mailbox doesn't exist\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(Net::IMAP::NoResponseError) do\n        imap.append(\"INBOX\", mail)\n      end\n      assert_equal(1, requests.length)\n      assert_equal(\"RUBY0001 APPEND INBOX {#{mail.size}}\\r\\n\", requests[0])\n      imap.logout\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0002 LOGOUT\\r\\n\", requests[1])\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  private\n\n  def imaps_test\n    server = create_tcp_server\n    port = server.addr[1]\n    ctx = OpenSSL::SSL::SSLContext.new\n    ctx.ca_file = CA_FILE\n    ctx.key = File.open(SERVER_KEY) { |f|\n      OpenSSL::PKey::RSA.new(f)\n    }\n    ctx.cert = File.open(SERVER_CERT) { |f|\n      OpenSSL::X509::Certificate.new(f)\n    }\n    ssl_server = OpenSSL::SSL::SSLServer.new(server, ctx)\n    started = false\n    ths = Thread.start do\n      Thread.current.report_on_exception = false # always join-ed\n      begin\n        started = true\n        sock = ssl_server.accept\n        begin\n          sock.print(\"* OK test server\\r\\n\")\n          sock.gets\n          sock.print(\"* BYE terminating connection\\r\\n\")\n          sock.print(\"RUBY0001 OK LOGOUT completed\\r\\n\")\n        ensure\n          sock.close\n        end\n      rescue Errno::EPIPE, Errno::ECONNRESET, Errno::ECONNABORTED\n      end\n    end\n    sleep 0.1 until started\n    begin\n      begin\n        imap = yield(port)\n        imap.logout\n      ensure\n        imap.disconnect if imap\n      end\n    ensure\n      ssl_server.close\n      ths.join\n    end\n  end\n\n  def starttls_test\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0001 OK completed\\r\\n\")\n        ctx = OpenSSL::SSL::SSLContext.new\n        ctx.ca_file = CA_FILE\n        ctx.key = File.open(SERVER_KEY) { |f|\n          OpenSSL::PKey::RSA.new(f)\n        }\n        ctx.cert = File.open(SERVER_CERT) { |f|\n          OpenSSL::X509::Certificate.new(f)\n        }\n        sock = OpenSSL::SSL::SSLSocket.new(sock, ctx)\n        sock.sync_close = true\n        sock.accept\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = yield(port)\n      imap.logout if !imap.disconnected?\n    ensure\n      imap.disconnect if imap && !imap.disconnected?\n    end\n  end\n\n  def create_tcp_server\n    return TCPServer.new(server_addr, 0)\n  end\n\n  def server_addr\n    Addrinfo.tcp(\"localhost\", 0).ip_address\n  end\nend\n", "# define RUBY_VERSION_MAJOR RUBY_API_VERSION_MAJOR\n# define RUBY_VERSION_MINOR RUBY_API_VERSION_MINOR\n#define RUBY_VERSION_TEENY 4\n#define RUBY_RELEASE_DATE RUBY_RELEASE_YEAR_STR\"-\"RUBY_RELEASE_MONTH_STR\"-\"RUBY_RELEASE_DAY_STR\n#define RUBY_PATCHLEVEL 190\n\n#define RUBY_RELEASE_YEAR 2021\n#define RUBY_RELEASE_MONTH 7\n#define RUBY_RELEASE_DAY 7\n\n#include \"ruby/version.h\"\n\n#ifndef TOKEN_PASTE\n#define TOKEN_PASTE(x,y) x##y\n#endif\n#define ONLY_ONE_DIGIT(x) TOKEN_PASTE(10,x) < 1000\n#define WITH_ZERO_PADDING(x) TOKEN_PASTE(0,x)\n#define RUBY_BIRTH_YEAR_STR STRINGIZE(RUBY_BIRTH_YEAR)\n#define RUBY_RELEASE_YEAR_STR STRINGIZE(RUBY_RELEASE_YEAR)\n#if ONLY_ONE_DIGIT(RUBY_RELEASE_MONTH)\n#define RUBY_RELEASE_MONTH_STR STRINGIZE(WITH_ZERO_PADDING(RUBY_RELEASE_MONTH))\n#else\n#define RUBY_RELEASE_MONTH_STR STRINGIZE(RUBY_RELEASE_MONTH)\n#endif\n#if ONLY_ONE_DIGIT(RUBY_RELEASE_DAY)\n#define RUBY_RELEASE_DAY_STR STRINGIZE(WITH_ZERO_PADDING(RUBY_RELEASE_DAY))\n#else\n#define RUBY_RELEASE_DAY_STR STRINGIZE(RUBY_RELEASE_DAY)\n#endif\n\n#if !defined RUBY_LIB_VERSION && defined RUBY_LIB_VERSION_STYLE\n# if RUBY_LIB_VERSION_STYLE == 3\n#   define RUBY_LIB_VERSION STRINGIZE(RUBY_API_VERSION_MAJOR)\".\"STRINGIZE(RUBY_API_VERSION_MINOR)\".\"STRINGIZE(RUBY_API_VERSION_TEENY)\n# elif RUBY_LIB_VERSION_STYLE == 2\n#   define RUBY_LIB_VERSION STRINGIZE(RUBY_API_VERSION_MAJOR)\".\"STRINGIZE(RUBY_API_VERSION_MINOR)\n# endif\n#endif\n\n#if RUBY_PATCHLEVEL == -1\n#define RUBY_PATCHLEVEL_STR \"dev\"\n#else\n#define RUBY_PATCHLEVEL_STR \"p\"STRINGIZE(RUBY_PATCHLEVEL)\n#endif\n\n#ifndef RUBY_REVISION\n# include \"revision.h\"\n#endif\n\n#ifdef RUBY_REVISION\n# if RUBY_PATCHLEVEL == -1\n#  ifndef RUBY_BRANCH_NAME\n#   define RUBY_BRANCH_NAME \"master\"\n#  endif\n#  define RUBY_REVISION_STR \" \"RUBY_BRANCH_NAME\" \"RUBY_REVISION\n# else\n#  define RUBY_REVISION_STR \" revision \"RUBY_REVISION\n# endif\n#else\n# define RUBY_REVISION \"HEAD\"\n# define RUBY_REVISION_STR \"\"\n#endif\n#if !defined RUBY_RELEASE_DATETIME || RUBY_PATCHLEVEL != -1\n# undef RUBY_RELEASE_DATETIME\n# define RUBY_RELEASE_DATETIME RUBY_RELEASE_DATE\n#endif\n\n# define RUBY_DESCRIPTION_WITH(opt) \\\n    \"ruby \"RUBY_VERSION\t\t    \\\n    RUBY_PATCHLEVEL_STR\t\t    \\\n    \" (\"RUBY_RELEASE_DATETIME\t    \\\n    RUBY_REVISION_STR\")\"opt\" \"\t    \\\n    \"[\"RUBY_PLATFORM\"]\"\n# define RUBY_COPYRIGHT\t\t    \\\n    \"ruby - Copyright (C) \"\t    \\\n    RUBY_BIRTH_YEAR_STR\"-\"   \\\n    RUBY_RELEASE_YEAR_STR\" \" \\\n    RUBY_AUTHOR\n"], "fixing_code": ["# frozen_string_literal: true\n#\n# = net/imap.rb\n#\n# Copyright (C) 2000  Shugo Maeda <shugo@ruby-lang.org>\n#\n# This library is distributed under the terms of the Ruby license.\n# You can freely distribute/modify this library.\n#\n# Documentation: Shugo Maeda, with RDoc conversion and overview by William\n# Webber.\n#\n# See Net::IMAP for documentation.\n#\n\n\nrequire \"socket\"\nrequire \"monitor\"\nrequire \"digest/md5\"\nrequire \"strscan\"\nrequire_relative 'protocol'\nbegin\n  require \"openssl\"\nrescue LoadError\nend\n\nmodule Net\n\n  #\n  # Net::IMAP implements Internet Message Access Protocol (IMAP) client\n  # functionality.  The protocol is described in [IMAP].\n  #\n  # == IMAP Overview\n  #\n  # An IMAP client connects to a server, and then authenticates\n  # itself using either #authenticate() or #login().  Having\n  # authenticated itself, there is a range of commands\n  # available to it.  Most work with mailboxes, which may be\n  # arranged in an hierarchical namespace, and each of which\n  # contains zero or more messages.  How this is implemented on\n  # the server is implementation-dependent; on a UNIX server, it\n  # will frequently be implemented as files in mailbox format\n  # within a hierarchy of directories.\n  #\n  # To work on the messages within a mailbox, the client must\n  # first select that mailbox, using either #select() or (for\n  # read-only access) #examine().  Once the client has successfully\n  # selected a mailbox, they enter _selected_ state, and that\n  # mailbox becomes the _current_ mailbox, on which mail-item\n  # related commands implicitly operate.\n  #\n  # Messages have two sorts of identifiers: message sequence\n  # numbers and UIDs.\n  #\n  # Message sequence numbers number messages within a mailbox\n  # from 1 up to the number of items in the mailbox.  If a new\n  # message arrives during a session, it receives a sequence\n  # number equal to the new size of the mailbox.  If messages\n  # are expunged from the mailbox, remaining messages have their\n  # sequence numbers \"shuffled down\" to fill the gaps.\n  #\n  # UIDs, on the other hand, are permanently guaranteed not to\n  # identify another message within the same mailbox, even if\n  # the existing message is deleted.  UIDs are required to\n  # be assigned in ascending (but not necessarily sequential)\n  # order within a mailbox; this means that if a non-IMAP client\n  # rearranges the order of mailitems within a mailbox, the\n  # UIDs have to be reassigned.  An IMAP client thus cannot\n  # rearrange message orders.\n  #\n  # == Examples of Usage\n  #\n  # === List sender and subject of all recent messages in the default mailbox\n  #\n  #   imap = Net::IMAP.new('mail.example.com')\n  #   imap.authenticate('LOGIN', 'joe_user', 'joes_password')\n  #   imap.examine('INBOX')\n  #   imap.search([\"RECENT\"]).each do |message_id|\n  #     envelope = imap.fetch(message_id, \"ENVELOPE\")[0].attr[\"ENVELOPE\"]\n  #     puts \"#{envelope.from[0].name}: \\t#{envelope.subject}\"\n  #   end\n  #\n  # === Move all messages from April 2003 from \"Mail/sent-mail\" to \"Mail/sent-apr03\"\n  #\n  #   imap = Net::IMAP.new('mail.example.com')\n  #   imap.authenticate('LOGIN', 'joe_user', 'joes_password')\n  #   imap.select('Mail/sent-mail')\n  #   if not imap.list('Mail/', 'sent-apr03')\n  #     imap.create('Mail/sent-apr03')\n  #   end\n  #   imap.search([\"BEFORE\", \"30-Apr-2003\", \"SINCE\", \"1-Apr-2003\"]).each do |message_id|\n  #     imap.copy(message_id, \"Mail/sent-apr03\")\n  #     imap.store(message_id, \"+FLAGS\", [:Deleted])\n  #   end\n  #   imap.expunge\n  #\n  # == Thread Safety\n  #\n  # Net::IMAP supports concurrent threads. For example,\n  #\n  #   imap = Net::IMAP.new(\"imap.foo.net\", \"imap2\")\n  #   imap.authenticate(\"cram-md5\", \"bar\", \"password\")\n  #   imap.select(\"inbox\")\n  #   fetch_thread = Thread.start { imap.fetch(1..-1, \"UID\") }\n  #   search_result = imap.search([\"BODY\", \"hello\"])\n  #   fetch_result = fetch_thread.value\n  #   imap.disconnect\n  #\n  # This script invokes the FETCH command and the SEARCH command concurrently.\n  #\n  # == Errors\n  #\n  # An IMAP server can send three different types of responses to indicate\n  # failure:\n  #\n  # NO:: the attempted command could not be successfully completed.  For\n  #      instance, the username/password used for logging in are incorrect;\n  #      the selected mailbox does not exist; etc.\n  #\n  # BAD:: the request from the client does not follow the server's\n  #       understanding of the IMAP protocol.  This includes attempting\n  #       commands from the wrong client state; for instance, attempting\n  #       to perform a SEARCH command without having SELECTed a current\n  #       mailbox.  It can also signal an internal server\n  #       failure (such as a disk crash) has occurred.\n  #\n  # BYE:: the server is saying goodbye.  This can be part of a normal\n  #       logout sequence, and can be used as part of a login sequence\n  #       to indicate that the server is (for some reason) unwilling\n  #       to accept your connection.  As a response to any other command,\n  #       it indicates either that the server is shutting down, or that\n  #       the server is timing out the client connection due to inactivity.\n  #\n  # These three error response are represented by the errors\n  # Net::IMAP::NoResponseError, Net::IMAP::BadResponseError, and\n  # Net::IMAP::ByeResponseError, all of which are subclasses of\n  # Net::IMAP::ResponseError.  Essentially, all methods that involve\n  # sending a request to the server can generate one of these errors.\n  # Only the most pertinent instances have been documented below.\n  #\n  # Because the IMAP class uses Sockets for communication, its methods\n  # are also susceptible to the various errors that can occur when\n  # working with sockets.  These are generally represented as\n  # Errno errors.  For instance, any method that involves sending a\n  # request to the server and/or receiving a response from it could\n  # raise an Errno::EPIPE error if the network connection unexpectedly\n  # goes down.  See the socket(7), ip(7), tcp(7), socket(2), connect(2),\n  # and associated man pages.\n  #\n  # Finally, a Net::IMAP::DataFormatError is thrown if low-level data\n  # is found to be in an incorrect format (for instance, when converting\n  # between UTF-8 and UTF-16), and Net::IMAP::ResponseParseError is\n  # thrown if a server response is non-parseable.\n  #\n  #\n  # == References\n  #\n  # [[IMAP]]\n  #    M. Crispin, \"INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1\",\n  #    RFC 2060, December 1996.  (Note: since obsoleted by RFC 3501)\n  #\n  # [[LANGUAGE-TAGS]]\n  #    Alvestrand, H., \"Tags for the Identification of\n  #    Languages\", RFC 1766, March 1995.\n  #\n  # [[MD5]]\n  #    Myers, J., and M. Rose, \"The Content-MD5 Header Field\", RFC\n  #    1864, October 1995.\n  #\n  # [[MIME-IMB]]\n  #    Freed, N., and N. Borenstein, \"MIME (Multipurpose Internet\n  #    Mail Extensions) Part One: Format of Internet Message Bodies\", RFC\n  #    2045, November 1996.\n  #\n  # [[RFC-822]]\n  #    Crocker, D., \"Standard for the Format of ARPA Internet Text\n  #    Messages\", STD 11, RFC 822, University of Delaware, August 1982.\n  #\n  # [[RFC-2087]]\n  #    Myers, J., \"IMAP4 QUOTA extension\", RFC 2087, January 1997.\n  #\n  # [[RFC-2086]]\n  #    Myers, J., \"IMAP4 ACL extension\", RFC 2086, January 1997.\n  #\n  # [[RFC-2195]]\n  #    Klensin, J., Catoe, R., and Krumviede, P., \"IMAP/POP AUTHorize Extension\n  #    for Simple Challenge/Response\", RFC 2195, September 1997.\n  #\n  # [[SORT-THREAD-EXT]]\n  #    Crispin, M., \"INTERNET MESSAGE ACCESS PROTOCOL - SORT and THREAD\n  #    Extensions\", draft-ietf-imapext-sort, May 2003.\n  #\n  # [[OSSL]]\n  #    http://www.openssl.org\n  #\n  # [[RSSL]]\n  #    http://savannah.gnu.org/projects/rubypki\n  #\n  # [[UTF7]]\n  #    Goldsmith, D. and Davis, M., \"UTF-7: A Mail-Safe Transformation Format of\n  #    Unicode\", RFC 2152, May 1997.\n  #\n  class IMAP < Protocol\n    include MonitorMixin\n    if defined?(OpenSSL::SSL)\n      include OpenSSL\n      include SSL\n    end\n\n    #  Returns an initial greeting response from the server.\n    attr_reader :greeting\n\n    # Returns recorded untagged responses.  For example:\n    #\n    #   imap.select(\"inbox\")\n    #   p imap.responses[\"EXISTS\"][-1]\n    #   #=> 2\n    #   p imap.responses[\"UIDVALIDITY\"][-1]\n    #   #=> 968263756\n    attr_reader :responses\n\n    # Returns all response handlers.\n    attr_reader :response_handlers\n\n    # Seconds to wait until a connection is opened.\n    # If the IMAP object cannot open a connection within this time,\n    # it raises a Net::OpenTimeout exception. The default value is 30 seconds.\n    attr_reader :open_timeout\n\n    # The thread to receive exceptions.\n    attr_accessor :client_thread\n\n    # Flag indicating a message has been seen.\n    SEEN = :Seen\n\n    # Flag indicating a message has been answered.\n    ANSWERED = :Answered\n\n    # Flag indicating a message has been flagged for special or urgent\n    # attention.\n    FLAGGED = :Flagged\n\n    # Flag indicating a message has been marked for deletion.  This\n    # will occur when the mailbox is closed or expunged.\n    DELETED = :Deleted\n\n    # Flag indicating a message is only a draft or work-in-progress version.\n    DRAFT = :Draft\n\n    # Flag indicating that the message is \"recent,\" meaning that this\n    # session is the first session in which the client has been notified\n    # of this message.\n    RECENT = :Recent\n\n    # Flag indicating that a mailbox context name cannot contain\n    # children.\n    NOINFERIORS = :Noinferiors\n\n    # Flag indicating that a mailbox is not selected.\n    NOSELECT = :Noselect\n\n    # Flag indicating that a mailbox has been marked \"interesting\" by\n    # the server; this commonly indicates that the mailbox contains\n    # new messages.\n    MARKED = :Marked\n\n    # Flag indicating that the mailbox does not contains new messages.\n    UNMARKED = :Unmarked\n\n    # Returns the debug mode.\n    def self.debug\n      return @@debug\n    end\n\n    # Sets the debug mode.\n    def self.debug=(val)\n      return @@debug = val\n    end\n\n    # Returns the max number of flags interned to symbols.\n    def self.max_flag_count\n      return @@max_flag_count\n    end\n\n    # Sets the max number of flags interned to symbols.\n    def self.max_flag_count=(count)\n      @@max_flag_count = count\n    end\n\n    # Adds an authenticator for Net::IMAP#authenticate.  +auth_type+\n    # is the type of authentication this authenticator supports\n    # (for instance, \"LOGIN\").  The +authenticator+ is an object\n    # which defines a process() method to handle authentication with\n    # the server.  See Net::IMAP::LoginAuthenticator,\n    # Net::IMAP::CramMD5Authenticator, and Net::IMAP::DigestMD5Authenticator\n    # for examples.\n    #\n    #\n    # If +auth_type+ refers to an existing authenticator, it will be\n    # replaced by the new one.\n    def self.add_authenticator(auth_type, authenticator)\n      @@authenticators[auth_type] = authenticator\n    end\n\n    # The default port for IMAP connections, port 143\n    def self.default_port\n      return PORT\n    end\n\n    # The default port for IMAPS connections, port 993\n    def self.default_tls_port\n      return SSL_PORT\n    end\n\n    class << self\n      alias default_imap_port default_port\n      alias default_imaps_port default_tls_port\n      alias default_ssl_port default_tls_port\n    end\n\n    # Disconnects from the server.\n    def disconnect\n      return if disconnected?\n      begin\n        begin\n          # try to call SSL::SSLSocket#io.\n          @sock.io.shutdown\n        rescue NoMethodError\n          # @sock is not an SSL::SSLSocket.\n          @sock.shutdown\n        end\n      rescue Errno::ENOTCONN\n        # ignore `Errno::ENOTCONN: Socket is not connected' on some platforms.\n      rescue Exception => e\n        @receiver_thread.raise(e)\n      end\n      @receiver_thread.join\n      synchronize do\n        @sock.close\n      end\n      raise e if e\n    end\n\n    # Returns true if disconnected from the server.\n    def disconnected?\n      return @sock.closed?\n    end\n\n    # Sends a CAPABILITY command, and returns an array of\n    # capabilities that the server supports.  Each capability\n    # is a string.  See [IMAP] for a list of possible\n    # capabilities.\n    #\n    # Note that the Net::IMAP class does not modify its\n    # behaviour according to the capabilities of the server;\n    # it is up to the user of the class to ensure that\n    # a certain capability is supported by a server before\n    # using it.\n    def capability\n      synchronize do\n        send_command(\"CAPABILITY\")\n        return @responses.delete(\"CAPABILITY\")[-1]\n      end\n    end\n\n    # Sends a NOOP command to the server. It does nothing.\n    def noop\n      send_command(\"NOOP\")\n    end\n\n    # Sends a LOGOUT command to inform the server that the client is\n    # done with the connection.\n    def logout\n      send_command(\"LOGOUT\")\n    end\n\n    # Sends a STARTTLS command to start TLS session.\n    def starttls(options = {}, verify = true)\n      send_command(\"STARTTLS\") do |resp|\n        if resp.kind_of?(TaggedResponse) && resp.name == \"OK\"\n          begin\n            # for backward compatibility\n            certs = options.to_str\n            options = create_ssl_params(certs, verify)\n          rescue NoMethodError\n          end\n          start_tls_session(options)\n        end\n      end\n    end\n\n    # Sends an AUTHENTICATE command to authenticate the client.\n    # The +auth_type+ parameter is a string that represents\n    # the authentication mechanism to be used. Currently Net::IMAP\n    # supports the authentication mechanisms:\n    #\n    #   LOGIN:: login using cleartext user and password.\n    #   CRAM-MD5:: login with cleartext user and encrypted password\n    #              (see [RFC-2195] for a full description).  This\n    #              mechanism requires that the server have the user's\n    #              password stored in clear-text password.\n    #\n    # For both of these mechanisms, there should be two +args+: username\n    # and (cleartext) password.  A server may not support one or the other\n    # of these mechanisms; check #capability() for a capability of\n    # the form \"AUTH=LOGIN\" or \"AUTH=CRAM-MD5\".\n    #\n    # Authentication is done using the appropriate authenticator object:\n    # see @@authenticators for more information on plugging in your own\n    # authenticator.\n    #\n    # For example:\n    #\n    #    imap.authenticate('LOGIN', user, password)\n    #\n    # A Net::IMAP::NoResponseError is raised if authentication fails.\n    def authenticate(auth_type, *args)\n      auth_type = auth_type.upcase\n      unless @@authenticators.has_key?(auth_type)\n        raise ArgumentError,\n          format('unknown auth type - \"%s\"', auth_type)\n      end\n      authenticator = @@authenticators[auth_type].new(*args)\n      send_command(\"AUTHENTICATE\", auth_type) do |resp|\n        if resp.instance_of?(ContinuationRequest)\n          data = authenticator.process(resp.data.text.unpack(\"m\")[0])\n          s = [data].pack(\"m0\")\n          send_string_data(s)\n          put_string(CRLF)\n        end\n      end\n    end\n\n    # Sends a LOGIN command to identify the client and carries\n    # the plaintext +password+ authenticating this +user+.  Note\n    # that, unlike calling #authenticate() with an +auth_type+\n    # of \"LOGIN\", #login() does *not* use the login authenticator.\n    #\n    # A Net::IMAP::NoResponseError is raised if authentication fails.\n    def login(user, password)\n      send_command(\"LOGIN\", user, password)\n    end\n\n    # Sends a SELECT command to select a +mailbox+ so that messages\n    # in the +mailbox+ can be accessed.\n    #\n    # After you have selected a mailbox, you may retrieve the\n    # number of items in that mailbox from @responses[\"EXISTS\"][-1],\n    # and the number of recent messages from @responses[\"RECENT\"][-1].\n    # Note that these values can change if new messages arrive\n    # during a session; see #add_response_handler() for a way of\n    # detecting this event.\n    #\n    # A Net::IMAP::NoResponseError is raised if the mailbox does not\n    # exist or is for some reason non-selectable.\n    def select(mailbox)\n      synchronize do\n        @responses.clear\n        send_command(\"SELECT\", mailbox)\n      end\n    end\n\n    # Sends a EXAMINE command to select a +mailbox+ so that messages\n    # in the +mailbox+ can be accessed.  Behaves the same as #select(),\n    # except that the selected +mailbox+ is identified as read-only.\n    #\n    # A Net::IMAP::NoResponseError is raised if the mailbox does not\n    # exist or is for some reason non-examinable.\n    def examine(mailbox)\n      synchronize do\n        @responses.clear\n        send_command(\"EXAMINE\", mailbox)\n      end\n    end\n\n    # Sends a CREATE command to create a new +mailbox+.\n    #\n    # A Net::IMAP::NoResponseError is raised if a mailbox with that name\n    # cannot be created.\n    def create(mailbox)\n      send_command(\"CREATE\", mailbox)\n    end\n\n    # Sends a DELETE command to remove the +mailbox+.\n    #\n    # A Net::IMAP::NoResponseError is raised if a mailbox with that name\n    # cannot be deleted, either because it does not exist or because the\n    # client does not have permission to delete it.\n    def delete(mailbox)\n      send_command(\"DELETE\", mailbox)\n    end\n\n    # Sends a RENAME command to change the name of the +mailbox+ to\n    # +newname+.\n    #\n    # A Net::IMAP::NoResponseError is raised if a mailbox with the\n    # name +mailbox+ cannot be renamed to +newname+ for whatever\n    # reason; for instance, because +mailbox+ does not exist, or\n    # because there is already a mailbox with the name +newname+.\n    def rename(mailbox, newname)\n      send_command(\"RENAME\", mailbox, newname)\n    end\n\n    # Sends a SUBSCRIBE command to add the specified +mailbox+ name to\n    # the server's set of \"active\" or \"subscribed\" mailboxes as returned\n    # by #lsub().\n    #\n    # A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be\n    # subscribed to; for instance, because it does not exist.\n    def subscribe(mailbox)\n      send_command(\"SUBSCRIBE\", mailbox)\n    end\n\n    # Sends a UNSUBSCRIBE command to remove the specified +mailbox+ name\n    # from the server's set of \"active\" or \"subscribed\" mailboxes.\n    #\n    # A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be\n    # unsubscribed from; for instance, because the client is not currently\n    # subscribed to it.\n    def unsubscribe(mailbox)\n      send_command(\"UNSUBSCRIBE\", mailbox)\n    end\n\n    # Sends a LIST command, and returns a subset of names from\n    # the complete set of all names available to the client.\n    # +refname+ provides a context (for instance, a base directory\n    # in a directory-based mailbox hierarchy).  +mailbox+ specifies\n    # a mailbox or (via wildcards) mailboxes under that context.\n    # Two wildcards may be used in +mailbox+: '*', which matches\n    # all characters *including* the hierarchy delimiter (for instance,\n    # '/' on a UNIX-hosted directory-based mailbox hierarchy); and '%',\n    # which matches all characters *except* the hierarchy delimiter.\n    #\n    # If +refname+ is empty, +mailbox+ is used directly to determine\n    # which mailboxes to match.  If +mailbox+ is empty, the root\n    # name of +refname+ and the hierarchy delimiter are returned.\n    #\n    # The return value is an array of +Net::IMAP::MailboxList+. For example:\n    #\n    #   imap.create(\"foo/bar\")\n    #   imap.create(\"foo/baz\")\n    #   p imap.list(\"\", \"foo/%\")\n    #   #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim=\"/\", name=\"foo/\">, \\\\\n    #        #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim=\"/\", name=\"foo/bar\">, \\\\\n    #        #<Net::IMAP::MailboxList attr=[:Noinferiors], delim=\"/\", name=\"foo/baz\">]\n    def list(refname, mailbox)\n      synchronize do\n        send_command(\"LIST\", refname, mailbox)\n        return @responses.delete(\"LIST\")\n      end\n    end\n\n    # Sends a XLIST command, and returns a subset of names from\n    # the complete set of all names available to the client.\n    # +refname+ provides a context (for instance, a base directory\n    # in a directory-based mailbox hierarchy).  +mailbox+ specifies\n    # a mailbox or (via wildcards) mailboxes under that context.\n    # Two wildcards may be used in +mailbox+: '*', which matches\n    # all characters *including* the hierarchy delimiter (for instance,\n    # '/' on a UNIX-hosted directory-based mailbox hierarchy); and '%',\n    # which matches all characters *except* the hierarchy delimiter.\n    #\n    # If +refname+ is empty, +mailbox+ is used directly to determine\n    # which mailboxes to match.  If +mailbox+ is empty, the root\n    # name of +refname+ and the hierarchy delimiter are returned.\n    #\n    # The XLIST command is like the LIST command except that the flags\n    # returned refer to the function of the folder/mailbox, e.g. :Sent\n    #\n    # The return value is an array of +Net::IMAP::MailboxList+. For example:\n    #\n    #   imap.create(\"foo/bar\")\n    #   imap.create(\"foo/baz\")\n    #   p imap.xlist(\"\", \"foo/%\")\n    #   #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim=\"/\", name=\"foo/\">, \\\\\n    #        #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim=\"/\", name=\"foo/bar\">, \\\\\n    #        #<Net::IMAP::MailboxList attr=[:Noinferiors], delim=\"/\", name=\"foo/baz\">]\n    def xlist(refname, mailbox)\n      synchronize do\n        send_command(\"XLIST\", refname, mailbox)\n        return @responses.delete(\"XLIST\")\n      end\n    end\n\n    # Sends the GETQUOTAROOT command along with the specified +mailbox+.\n    # This command is generally available to both admin and user.\n    # If this mailbox exists, it returns an array containing objects of type\n    # Net::IMAP::MailboxQuotaRoot and Net::IMAP::MailboxQuota.\n    def getquotaroot(mailbox)\n      synchronize do\n        send_command(\"GETQUOTAROOT\", mailbox)\n        result = []\n        result.concat(@responses.delete(\"QUOTAROOT\"))\n        result.concat(@responses.delete(\"QUOTA\"))\n        return result\n      end\n    end\n\n    # Sends the GETQUOTA command along with specified +mailbox+.\n    # If this mailbox exists, then an array containing a\n    # Net::IMAP::MailboxQuota object is returned.  This\n    # command is generally only available to server admin.\n    def getquota(mailbox)\n      synchronize do\n        send_command(\"GETQUOTA\", mailbox)\n        return @responses.delete(\"QUOTA\")\n      end\n    end\n\n    # Sends a SETQUOTA command along with the specified +mailbox+ and\n    # +quota+.  If +quota+ is nil, then +quota+ will be unset for that\n    # mailbox.  Typically one needs to be logged in as a server admin\n    # for this to work.  The IMAP quota commands are described in\n    # [RFC-2087].\n    def setquota(mailbox, quota)\n      if quota.nil?\n        data = '()'\n      else\n        data = '(STORAGE ' + quota.to_s + ')'\n      end\n      send_command(\"SETQUOTA\", mailbox, RawData.new(data))\n    end\n\n    # Sends the SETACL command along with +mailbox+, +user+ and the\n    # +rights+ that user is to have on that mailbox.  If +rights+ is nil,\n    # then that user will be stripped of any rights to that mailbox.\n    # The IMAP ACL commands are described in [RFC-2086].\n    def setacl(mailbox, user, rights)\n      if rights.nil?\n        send_command(\"SETACL\", mailbox, user, \"\")\n      else\n        send_command(\"SETACL\", mailbox, user, rights)\n      end\n    end\n\n    # Send the GETACL command along with a specified +mailbox+.\n    # If this mailbox exists, an array containing objects of\n    # Net::IMAP::MailboxACLItem will be returned.\n    def getacl(mailbox)\n      synchronize do\n        send_command(\"GETACL\", mailbox)\n        return @responses.delete(\"ACL\")[-1]\n      end\n    end\n\n    # Sends a LSUB command, and returns a subset of names from the set\n    # of names that the user has declared as being \"active\" or\n    # \"subscribed.\"  +refname+ and +mailbox+ are interpreted as\n    # for #list().\n    # The return value is an array of +Net::IMAP::MailboxList+.\n    def lsub(refname, mailbox)\n      synchronize do\n        send_command(\"LSUB\", refname, mailbox)\n        return @responses.delete(\"LSUB\")\n      end\n    end\n\n    # Sends a STATUS command, and returns the status of the indicated\n    # +mailbox+. +attr+ is a list of one or more attributes whose\n    # statuses are to be requested.  Supported attributes include:\n    #\n    #   MESSAGES:: the number of messages in the mailbox.\n    #   RECENT:: the number of recent messages in the mailbox.\n    #   UNSEEN:: the number of unseen messages in the mailbox.\n    #\n    # The return value is a hash of attributes. For example:\n    #\n    #   p imap.status(\"inbox\", [\"MESSAGES\", \"RECENT\"])\n    #   #=> {\"RECENT\"=>0, \"MESSAGES\"=>44}\n    #\n    # A Net::IMAP::NoResponseError is raised if status values\n    # for +mailbox+ cannot be returned; for instance, because it\n    # does not exist.\n    def status(mailbox, attr)\n      synchronize do\n        send_command(\"STATUS\", mailbox, attr)\n        return @responses.delete(\"STATUS\")[-1].attr\n      end\n    end\n\n    # Sends a APPEND command to append the +message+ to the end of\n    # the +mailbox+. The optional +flags+ argument is an array of\n    # flags initially passed to the new message.  The optional\n    # +date_time+ argument specifies the creation time to assign to the\n    # new message; it defaults to the current time.\n    # For example:\n    #\n    #   imap.append(\"inbox\", <<EOF.gsub(/\\n/, \"\\r\\n\"), [:Seen], Time.now)\n    #   Subject: hello\n    #   From: shugo@ruby-lang.org\n    #   To: shugo@ruby-lang.org\n    #\n    #   hello world\n    #   EOF\n    #\n    # A Net::IMAP::NoResponseError is raised if the mailbox does\n    # not exist (it is not created automatically), or if the flags,\n    # date_time, or message arguments contain errors.\n    def append(mailbox, message, flags = nil, date_time = nil)\n      args = []\n      if flags\n        args.push(flags)\n      end\n      args.push(date_time) if date_time\n      args.push(Literal.new(message))\n      send_command(\"APPEND\", mailbox, *args)\n    end\n\n    # Sends a CHECK command to request a checkpoint of the currently\n    # selected mailbox.  This performs implementation-specific\n    # housekeeping; for instance, reconciling the mailbox's\n    # in-memory and on-disk state.\n    def check\n      send_command(\"CHECK\")\n    end\n\n    # Sends a CLOSE command to close the currently selected mailbox.\n    # The CLOSE command permanently removes from the mailbox all\n    # messages that have the \\Deleted flag set.\n    def close\n      send_command(\"CLOSE\")\n    end\n\n    # Sends a EXPUNGE command to permanently remove from the currently\n    # selected mailbox all messages that have the \\Deleted flag set.\n    def expunge\n      synchronize do\n        send_command(\"EXPUNGE\")\n        return @responses.delete(\"EXPUNGE\")\n      end\n    end\n\n    # Sends a SEARCH command to search the mailbox for messages that\n    # match the given searching criteria, and returns message sequence\n    # numbers.  +keys+ can either be a string holding the entire\n    # search string, or a single-dimension array of search keywords and\n    # arguments.  The following are some common search criteria;\n    # see [IMAP] section 6.4.4 for a full list.\n    #\n    # <message set>:: a set of message sequence numbers.  ',' indicates\n    #                 an interval, ':' indicates a range.  For instance,\n    #                 '2,10:12,15' means \"2,10,11,12,15\".\n    #\n    # BEFORE <date>:: messages with an internal date strictly before\n    #                 <date>.  The date argument has a format similar\n    #                 to 8-Aug-2002.\n    #\n    # BODY <string>:: messages that contain <string> within their body.\n    #\n    # CC <string>:: messages containing <string> in their CC field.\n    #\n    # FROM <string>:: messages that contain <string> in their FROM field.\n    #\n    # NEW:: messages with the \\Recent, but not the \\Seen, flag set.\n    #\n    # NOT <search-key>:: negate the following search key.\n    #\n    # OR <search-key> <search-key>:: \"or\" two search keys together.\n    #\n    # ON <date>:: messages with an internal date exactly equal to <date>,\n    #             which has a format similar to 8-Aug-2002.\n    #\n    # SINCE <date>:: messages with an internal date on or after <date>.\n    #\n    # SUBJECT <string>:: messages with <string> in their subject.\n    #\n    # TO <string>:: messages with <string> in their TO field.\n    #\n    # For example:\n    #\n    #   p imap.search([\"SUBJECT\", \"hello\", \"NOT\", \"NEW\"])\n    #   #=> [1, 6, 7, 8]\n    def search(keys, charset = nil)\n      return search_internal(\"SEARCH\", keys, charset)\n    end\n\n    # Similar to #search(), but returns unique identifiers.\n    def uid_search(keys, charset = nil)\n      return search_internal(\"UID SEARCH\", keys, charset)\n    end\n\n    # Sends a FETCH command to retrieve data associated with a message\n    # in the mailbox.\n    #\n    # The +set+ parameter is a number or a range between two numbers,\n    # or an array of those.  The number is a message sequence number,\n    # where -1 represents a '*' for use in range notation like 100..-1\n    # being interpreted as '100:*'.  Beware that the +exclude_end?+\n    # property of a Range object is ignored, and the contents of a\n    # range are independent of the order of the range endpoints as per\n    # the protocol specification, so 1...5, 5..1 and 5...1 are all\n    # equivalent to 1..5.\n    #\n    # +attr+ is a list of attributes to fetch; see the documentation\n    # for Net::IMAP::FetchData for a list of valid attributes.\n    #\n    # The return value is an array of Net::IMAP::FetchData or nil\n    # (instead of an empty array) if there is no matching message.\n    #\n    # For example:\n    #\n    #   p imap.fetch(6..8, \"UID\")\n    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={\"UID\"=>98}>, \\\\\n    #        #<Net::IMAP::FetchData seqno=7, attr={\"UID\"=>99}>, \\\\\n    #        #<Net::IMAP::FetchData seqno=8, attr={\"UID\"=>100}>]\n    #   p imap.fetch(6, \"BODY[HEADER.FIELDS (SUBJECT)]\")\n    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={\"BODY[HEADER.FIELDS (SUBJECT)]\"=>\"Subject: test\\r\\n\\r\\n\"}>]\n    #   data = imap.uid_fetch(98, [\"RFC822.SIZE\", \"INTERNALDATE\"])[0]\n    #   p data.seqno\n    #   #=> 6\n    #   p data.attr[\"RFC822.SIZE\"]\n    #   #=> 611\n    #   p data.attr[\"INTERNALDATE\"]\n    #   #=> \"12-Oct-2000 22:40:59 +0900\"\n    #   p data.attr[\"UID\"]\n    #   #=> 98\n    def fetch(set, attr, mod = nil)\n      return fetch_internal(\"FETCH\", set, attr, mod)\n    end\n\n    # Similar to #fetch(), but +set+ contains unique identifiers.\n    def uid_fetch(set, attr, mod = nil)\n      return fetch_internal(\"UID FETCH\", set, attr, mod)\n    end\n\n    # Sends a STORE command to alter data associated with messages\n    # in the mailbox, in particular their flags. The +set+ parameter\n    # is a number, an array of numbers, or a Range object. Each number\n    # is a message sequence number.  +attr+ is the name of a data item\n    # to store: 'FLAGS' will replace the message's flag list\n    # with the provided one, '+FLAGS' will add the provided flags,\n    # and '-FLAGS' will remove them.  +flags+ is a list of flags.\n    #\n    # The return value is an array of Net::IMAP::FetchData. For example:\n    #\n    #   p imap.store(6..8, \"+FLAGS\", [:Deleted])\n    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={\"FLAGS\"=>[:Seen, :Deleted]}>, \\\\\n    #        #<Net::IMAP::FetchData seqno=7, attr={\"FLAGS\"=>[:Seen, :Deleted]}>, \\\\\n    #        #<Net::IMAP::FetchData seqno=8, attr={\"FLAGS\"=>[:Seen, :Deleted]}>]\n    def store(set, attr, flags)\n      return store_internal(\"STORE\", set, attr, flags)\n    end\n\n    # Similar to #store(), but +set+ contains unique identifiers.\n    def uid_store(set, attr, flags)\n      return store_internal(\"UID STORE\", set, attr, flags)\n    end\n\n    # Sends a COPY command to copy the specified message(s) to the end\n    # of the specified destination +mailbox+. The +set+ parameter is\n    # a number, an array of numbers, or a Range object. The number is\n    # a message sequence number.\n    def copy(set, mailbox)\n      copy_internal(\"COPY\", set, mailbox)\n    end\n\n    # Similar to #copy(), but +set+ contains unique identifiers.\n    def uid_copy(set, mailbox)\n      copy_internal(\"UID COPY\", set, mailbox)\n    end\n\n    # Sends a MOVE command to move the specified message(s) to the end\n    # of the specified destination +mailbox+. The +set+ parameter is\n    # a number, an array of numbers, or a Range object. The number is\n    # a message sequence number.\n    # The IMAP MOVE extension is described in [RFC-6851].\n    def move(set, mailbox)\n      copy_internal(\"MOVE\", set, mailbox)\n    end\n\n    # Similar to #move(), but +set+ contains unique identifiers.\n    def uid_move(set, mailbox)\n      copy_internal(\"UID MOVE\", set, mailbox)\n    end\n\n    # Sends a SORT command to sort messages in the mailbox.\n    # Returns an array of message sequence numbers. For example:\n    #\n    #   p imap.sort([\"FROM\"], [\"ALL\"], \"US-ASCII\")\n    #   #=> [1, 2, 3, 5, 6, 7, 8, 4, 9]\n    #   p imap.sort([\"DATE\"], [\"SUBJECT\", \"hello\"], \"US-ASCII\")\n    #   #=> [6, 7, 8, 1]\n    #\n    # See [SORT-THREAD-EXT] for more details.\n    def sort(sort_keys, search_keys, charset)\n      return sort_internal(\"SORT\", sort_keys, search_keys, charset)\n    end\n\n    # Similar to #sort(), but returns an array of unique identifiers.\n    def uid_sort(sort_keys, search_keys, charset)\n      return sort_internal(\"UID SORT\", sort_keys, search_keys, charset)\n    end\n\n    # Adds a response handler. For example, to detect when\n    # the server sends a new EXISTS response (which normally\n    # indicates new messages being added to the mailbox),\n    # add the following handler after selecting the\n    # mailbox:\n    #\n    #   imap.add_response_handler { |resp|\n    #     if resp.kind_of?(Net::IMAP::UntaggedResponse) and resp.name == \"EXISTS\"\n    #       puts \"Mailbox now has #{resp.data} messages\"\n    #     end\n    #   }\n    #\n    def add_response_handler(handler = nil, &block)\n      raise ArgumentError, \"two Procs are passed\" if handler && block\n      @response_handlers.push(block || handler)\n    end\n\n    # Removes the response handler.\n    def remove_response_handler(handler)\n      @response_handlers.delete(handler)\n    end\n\n    # Similar to #search(), but returns message sequence numbers in threaded\n    # format, as a Net::IMAP::ThreadMember tree.  The supported algorithms\n    # are:\n    #\n    # ORDEREDSUBJECT:: split into single-level threads according to subject,\n    #                  ordered by date.\n    # REFERENCES:: split into threads by parent/child relationships determined\n    #              by which message is a reply to which.\n    #\n    # Unlike #search(), +charset+ is a required argument.  US-ASCII\n    # and UTF-8 are sample values.\n    #\n    # See [SORT-THREAD-EXT] for more details.\n    def thread(algorithm, search_keys, charset)\n      return thread_internal(\"THREAD\", algorithm, search_keys, charset)\n    end\n\n    # Similar to #thread(), but returns unique identifiers instead of\n    # message sequence numbers.\n    def uid_thread(algorithm, search_keys, charset)\n      return thread_internal(\"UID THREAD\", algorithm, search_keys, charset)\n    end\n\n    # Sends an IDLE command that waits for notifications of new or expunged\n    # messages.  Yields responses from the server during the IDLE.\n    #\n    # Use #idle_done() to leave IDLE.\n    #\n    # If +timeout+ is given, this method returns after +timeout+ seconds passed.\n    # +timeout+ can be used for keep-alive.  For example, the following code\n    # checks the connection for each 60 seconds.\n    #\n    #   loop do\n    #     imap.idle(60) do |res|\n    #       ...\n    #     end\n    #   end\n    def idle(timeout = nil, &response_handler)\n      raise LocalJumpError, \"no block given\" unless response_handler\n\n      response = nil\n\n      synchronize do\n        tag = Thread.current[:net_imap_tag] = generate_tag\n        put_string(\"#{tag} IDLE#{CRLF}\")\n\n        begin\n          add_response_handler(&response_handler)\n          @idle_done_cond = new_cond\n          @idle_done_cond.wait(timeout)\n          @idle_done_cond = nil\n          if @receiver_thread_terminating\n            raise @exception || Net::IMAP::Error.new(\"connection closed\")\n          end\n        ensure\n          unless @receiver_thread_terminating\n            remove_response_handler(response_handler)\n            put_string(\"DONE#{CRLF}\")\n            response = get_tagged_response(tag, \"IDLE\")\n          end\n        end\n      end\n\n      return response\n    end\n\n    # Leaves IDLE.\n    def idle_done\n      synchronize do\n        if @idle_done_cond.nil?\n          raise Net::IMAP::Error, \"not during IDLE\"\n        end\n        @idle_done_cond.signal\n      end\n    end\n\n    # Decode a string from modified UTF-7 format to UTF-8.\n    #\n    # UTF-7 is a 7-bit encoding of Unicode [UTF7].  IMAP uses a\n    # slightly modified version of this to encode mailbox names\n    # containing non-ASCII characters; see [IMAP] section 5.1.3.\n    #\n    # Net::IMAP does _not_ automatically encode and decode\n    # mailbox names to and from UTF-7.\n    def self.decode_utf7(s)\n      return s.gsub(/&([^-]+)?-/n) {\n        if $1\n          ($1.tr(\",\", \"/\") + \"===\").unpack1(\"m\").encode(Encoding::UTF_8, Encoding::UTF_16BE)\n        else\n          \"&\"\n        end\n      }\n    end\n\n    # Encode a string from UTF-8 format to modified UTF-7.\n    def self.encode_utf7(s)\n      return s.gsub(/(&)|[^\\x20-\\x7e]+/) {\n        if $1\n          \"&-\"\n        else\n          base64 = [$&.encode(Encoding::UTF_16BE)].pack(\"m0\")\n          \"&\" + base64.delete(\"=\").tr(\"/\", \",\") + \"-\"\n        end\n      }.force_encoding(\"ASCII-8BIT\")\n    end\n\n    # Formats +time+ as an IMAP-style date.\n    def self.format_date(time)\n      return time.strftime('%d-%b-%Y')\n    end\n\n    # Formats +time+ as an IMAP-style date-time.\n    def self.format_datetime(time)\n      return time.strftime('%d-%b-%Y %H:%M %z')\n    end\n\n    private\n\n    CRLF = \"\\r\\n\"      # :nodoc:\n    PORT = 143         # :nodoc:\n    SSL_PORT = 993   # :nodoc:\n\n    @@debug = false\n    @@authenticators = {}\n    @@max_flag_count = 10000\n\n    # :call-seq:\n    #    Net::IMAP.new(host, options = {})\n    #\n    # Creates a new Net::IMAP object and connects it to the specified\n    # +host+.\n    #\n    # +options+ is an option hash, each key of which is a symbol.\n    #\n    # The available options are:\n    #\n    # port::  Port number (default value is 143 for imap, or 993 for imaps)\n    # ssl::   If options[:ssl] is true, then an attempt will be made\n    #         to use SSL (now TLS) to connect to the server.  For this to work\n    #         OpenSSL [OSSL] and the Ruby OpenSSL [RSSL] extensions need to\n    #         be installed.\n    #         If options[:ssl] is a hash, it's passed to\n    #         OpenSSL::SSL::SSLContext#set_params as parameters.\n    # open_timeout:: Seconds to wait until a connection is opened\n    #\n    # The most common errors are:\n    #\n    # Errno::ECONNREFUSED:: Connection refused by +host+ or an intervening\n    #                       firewall.\n    # Errno::ETIMEDOUT:: Connection timed out (possibly due to packets\n    #                    being dropped by an intervening firewall).\n    # Errno::ENETUNREACH:: There is no route to that network.\n    # SocketError:: Hostname not known or other socket error.\n    # Net::IMAP::ByeResponseError:: The connected to the host was successful, but\n    #                               it immediately said goodbye.\n    def initialize(host, port_or_options = {},\n                   usessl = false, certs = nil, verify = true)\n      super()\n      @host = host\n      begin\n        options = port_or_options.to_hash\n      rescue NoMethodError\n        # for backward compatibility\n        options = {}\n        options[:port] = port_or_options\n        if usessl\n          options[:ssl] = create_ssl_params(certs, verify)\n        end\n      end\n      @port = options[:port] || (options[:ssl] ? SSL_PORT : PORT)\n      @tag_prefix = \"RUBY\"\n      @tagno = 0\n      @open_timeout = options[:open_timeout] || 30\n      @parser = ResponseParser.new\n      @sock = tcp_socket(@host, @port)\n      begin\n        if options[:ssl]\n          start_tls_session(options[:ssl])\n          @usessl = true\n        else\n          @usessl = false\n        end\n        @responses = Hash.new([].freeze)\n        @tagged_responses = {}\n        @response_handlers = []\n        @tagged_response_arrival = new_cond\n        @continued_command_tag = nil\n        @continuation_request_arrival = new_cond\n        @continuation_request_exception = nil\n        @idle_done_cond = nil\n        @logout_command_tag = nil\n        @debug_output_bol = true\n        @exception = nil\n\n        @greeting = get_response\n        if @greeting.nil?\n          raise Error, \"connection closed\"\n        end\n        if @greeting.name == \"BYE\"\n          raise ByeResponseError, @greeting\n        end\n\n        @client_thread = Thread.current\n        @receiver_thread = Thread.start {\n          begin\n            receive_responses\n          rescue Exception\n          end\n        }\n        @receiver_thread_terminating = false\n      rescue Exception\n        @sock.close\n        raise\n      end\n    end\n\n    def tcp_socket(host, port)\n      s = Socket.tcp(host, port, :connect_timeout => @open_timeout)\n      s.setsockopt(:SOL_SOCKET, :SO_KEEPALIVE, true)\n      s\n    rescue Errno::ETIMEDOUT\n      raise Net::OpenTimeout, \"Timeout to open TCP connection to \" +\n        \"#{host}:#{port} (exceeds #{@open_timeout} seconds)\"\n    end\n\n    def receive_responses\n      connection_closed = false\n      until connection_closed\n        synchronize do\n          @exception = nil\n        end\n        begin\n          resp = get_response\n        rescue Exception => e\n          synchronize do\n            @sock.close\n            @exception = e\n          end\n          break\n        end\n        unless resp\n          synchronize do\n            @exception = EOFError.new(\"end of file reached\")\n          end\n          break\n        end\n        begin\n          synchronize do\n            case resp\n            when TaggedResponse\n              @tagged_responses[resp.tag] = resp\n              @tagged_response_arrival.broadcast\n              case resp.tag\n              when @logout_command_tag\n                return\n              when @continued_command_tag\n                @continuation_request_exception =\n                  RESPONSE_ERRORS[resp.name].new(resp)\n                @continuation_request_arrival.signal\n              end\n            when UntaggedResponse\n              record_response(resp.name, resp.data)\n              if resp.data.instance_of?(ResponseText) &&\n                  (code = resp.data.code)\n                record_response(code.name, code.data)\n              end\n              if resp.name == \"BYE\" && @logout_command_tag.nil?\n                @sock.close\n                @exception = ByeResponseError.new(resp)\n                connection_closed = true\n              end\n            when ContinuationRequest\n              @continuation_request_arrival.signal\n            end\n            @response_handlers.each do |handler|\n              handler.call(resp)\n            end\n          end\n        rescue Exception => e\n          @exception = e\n          synchronize do\n            @tagged_response_arrival.broadcast\n            @continuation_request_arrival.broadcast\n          end\n        end\n      end\n      synchronize do\n        @receiver_thread_terminating = true\n        @tagged_response_arrival.broadcast\n        @continuation_request_arrival.broadcast\n        if @idle_done_cond\n          @idle_done_cond.signal\n        end\n      end\n    end\n\n    def get_tagged_response(tag, cmd)\n      until @tagged_responses.key?(tag)\n        raise @exception if @exception\n        @tagged_response_arrival.wait\n      end\n      resp = @tagged_responses.delete(tag)\n      case resp.name\n      when /\\A(?:OK)\\z/ni\n        return resp\n      when /\\A(?:NO)\\z/ni\n        raise NoResponseError, resp\n      when /\\A(?:BAD)\\z/ni\n        raise BadResponseError, resp\n      else\n        raise UnknownResponseError, resp\n      end\n    end\n\n    def get_response\n      buff = String.new\n      while true\n        s = @sock.gets(CRLF)\n        break unless s\n        buff.concat(s)\n        if /\\{(\\d+)\\}\\r\\n/n =~ s\n          s = @sock.read($1.to_i)\n          buff.concat(s)\n        else\n          break\n        end\n      end\n      return nil if buff.length == 0\n      if @@debug\n        $stderr.print(buff.gsub(/^/n, \"S: \"))\n      end\n      return @parser.parse(buff)\n    end\n\n    def record_response(name, data)\n      unless @responses.has_key?(name)\n        @responses[name] = []\n      end\n      @responses[name].push(data)\n    end\n\n    def send_command(cmd, *args, &block)\n      synchronize do\n        args.each do |i|\n          validate_data(i)\n        end\n        tag = generate_tag\n        put_string(tag + \" \" + cmd)\n        args.each do |i|\n          put_string(\" \")\n          send_data(i, tag)\n        end\n        put_string(CRLF)\n        if cmd == \"LOGOUT\"\n          @logout_command_tag = tag\n        end\n        if block\n          add_response_handler(&block)\n        end\n        begin\n          return get_tagged_response(tag, cmd)\n        ensure\n          if block\n            remove_response_handler(block)\n          end\n        end\n      end\n    end\n\n    def generate_tag\n      @tagno += 1\n      return format(\"%s%04d\", @tag_prefix, @tagno)\n    end\n\n    def put_string(str)\n      @sock.print(str)\n      if @@debug\n        if @debug_output_bol\n          $stderr.print(\"C: \")\n        end\n        $stderr.print(str.gsub(/\\n(?!\\z)/n, \"\\nC: \"))\n        if /\\r\\n\\z/n.match(str)\n          @debug_output_bol = true\n        else\n          @debug_output_bol = false\n        end\n      end\n    end\n\n    def validate_data(data)\n      case data\n      when nil\n      when String\n      when Integer\n        NumValidator.ensure_number(data)\n      when Array\n        if data[0] == 'CHANGEDSINCE'\n          NumValidator.ensure_mod_sequence_value(data[1])\n        else\n          data.each do |i|\n            validate_data(i)\n          end\n        end\n      when Time\n      when Symbol\n      else\n        data.validate\n      end\n    end\n\n    def send_data(data, tag = nil)\n      case data\n      when nil\n        put_string(\"NIL\")\n      when String\n        send_string_data(data, tag)\n      when Integer\n        send_number_data(data)\n      when Array\n        send_list_data(data, tag)\n      when Time\n        send_time_data(data)\n      when Symbol\n        send_symbol_data(data)\n      else\n        data.send_data(self, tag)\n      end\n    end\n\n    def send_string_data(str, tag = nil)\n      case str\n      when \"\"\n        put_string('\"\"')\n      when /[\\x80-\\xff\\r\\n]/n\n        # literal\n        send_literal(str, tag)\n      when /[(){ \\x00-\\x1f\\x7f%*\"\\\\]/n\n        # quoted string\n        send_quoted_string(str)\n      else\n        put_string(str)\n      end\n    end\n\n    def send_quoted_string(str)\n      put_string('\"' + str.gsub(/[\"\\\\]/n, \"\\\\\\\\\\\\&\") + '\"')\n    end\n\n    def send_literal(str, tag = nil)\n      synchronize do\n        put_string(\"{\" + str.bytesize.to_s + \"}\" + CRLF)\n        @continued_command_tag = tag\n        @continuation_request_exception = nil\n        begin\n          @continuation_request_arrival.wait\n          e = @continuation_request_exception || @exception\n          raise e if e\n          put_string(str)\n        ensure\n          @continued_command_tag = nil\n          @continuation_request_exception = nil\n        end\n      end\n    end\n\n    def send_number_data(num)\n      put_string(num.to_s)\n    end\n\n    def send_list_data(list, tag = nil)\n      put_string(\"(\")\n      first = true\n      list.each do |i|\n        if first\n          first = false\n        else\n          put_string(\" \")\n        end\n        send_data(i, tag)\n      end\n      put_string(\")\")\n    end\n\n    DATE_MONTH = %w(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)\n\n    def send_time_data(time)\n      t = time.dup.gmtime\n      s = format('\"%2d-%3s-%4d %02d:%02d:%02d +0000\"',\n                 t.day, DATE_MONTH[t.month - 1], t.year,\n                 t.hour, t.min, t.sec)\n      put_string(s)\n    end\n\n    def send_symbol_data(symbol)\n      put_string(\"\\\\\" + symbol.to_s)\n    end\n\n    def search_internal(cmd, keys, charset)\n      if keys.instance_of?(String)\n        keys = [RawData.new(keys)]\n      else\n        normalize_searching_criteria(keys)\n      end\n      synchronize do\n        if charset\n          send_command(cmd, \"CHARSET\", charset, *keys)\n        else\n          send_command(cmd, *keys)\n        end\n        return @responses.delete(\"SEARCH\")[-1]\n      end\n    end\n\n    def fetch_internal(cmd, set, attr, mod = nil)\n      case attr\n      when String then\n        attr = RawData.new(attr)\n      when Array then\n        attr = attr.map { |arg|\n          arg.is_a?(String) ? RawData.new(arg) : arg\n        }\n      end\n\n      synchronize do\n        @responses.delete(\"FETCH\")\n        if mod\n          send_command(cmd, MessageSet.new(set), attr, mod)\n        else\n          send_command(cmd, MessageSet.new(set), attr)\n        end\n        return @responses.delete(\"FETCH\")\n      end\n    end\n\n    def store_internal(cmd, set, attr, flags)\n      if attr.instance_of?(String)\n        attr = RawData.new(attr)\n      end\n      synchronize do\n        @responses.delete(\"FETCH\")\n        send_command(cmd, MessageSet.new(set), attr, flags)\n        return @responses.delete(\"FETCH\")\n      end\n    end\n\n    def copy_internal(cmd, set, mailbox)\n      send_command(cmd, MessageSet.new(set), mailbox)\n    end\n\n    def sort_internal(cmd, sort_keys, search_keys, charset)\n      if search_keys.instance_of?(String)\n        search_keys = [RawData.new(search_keys)]\n      else\n        normalize_searching_criteria(search_keys)\n      end\n      normalize_searching_criteria(search_keys)\n      synchronize do\n        send_command(cmd, sort_keys, charset, *search_keys)\n        return @responses.delete(\"SORT\")[-1]\n      end\n    end\n\n    def thread_internal(cmd, algorithm, search_keys, charset)\n      if search_keys.instance_of?(String)\n        search_keys = [RawData.new(search_keys)]\n      else\n        normalize_searching_criteria(search_keys)\n      end\n      normalize_searching_criteria(search_keys)\n      send_command(cmd, algorithm, charset, *search_keys)\n      return @responses.delete(\"THREAD\")[-1]\n    end\n\n    def normalize_searching_criteria(keys)\n      keys.collect! do |i|\n        case i\n        when -1, Range, Array\n          MessageSet.new(i)\n        else\n          i\n        end\n      end\n    end\n\n    def create_ssl_params(certs = nil, verify = true)\n      params = {}\n      if certs\n        if File.file?(certs)\n          params[:ca_file] = certs\n        elsif File.directory?(certs)\n          params[:ca_path] = certs\n        end\n      end\n      if verify\n        params[:verify_mode] = VERIFY_PEER\n      else\n        params[:verify_mode] = VERIFY_NONE\n      end\n      return params\n    end\n\n    def start_tls_session(params = {})\n      unless defined?(OpenSSL::SSL)\n        raise \"SSL extension not installed\"\n      end\n      if @sock.kind_of?(OpenSSL::SSL::SSLSocket)\n        raise RuntimeError, \"already using SSL\"\n      end\n      begin\n        params = params.to_hash\n      rescue NoMethodError\n        params = {}\n      end\n      context = SSLContext.new\n      context.set_params(params)\n      if defined?(VerifyCallbackProc)\n        context.verify_callback = VerifyCallbackProc\n      end\n      @sock = SSLSocket.new(@sock, context)\n      @sock.sync_close = true\n      @sock.hostname = @host if @sock.respond_to? :hostname=\n      ssl_socket_connect(@sock, @open_timeout)\n      if context.verify_mode != VERIFY_NONE\n        @sock.post_connection_check(@host)\n      end\n    end\n\n    class RawData # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:put_string, @data)\n      end\n\n      def validate\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n    end\n\n    class Atom # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:put_string, @data)\n      end\n\n      def validate\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n    end\n\n    class QuotedString # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:send_quoted_string, @data)\n      end\n\n      def validate\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n    end\n\n    class Literal # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:send_literal, @data, tag)\n      end\n\n      def validate\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n    end\n\n    class MessageSet # :nodoc:\n      def send_data(imap, tag)\n        imap.send(:put_string, format_internal(@data))\n      end\n\n      def validate\n        validate_internal(@data)\n      end\n\n      private\n\n      def initialize(data)\n        @data = data\n      end\n\n      def format_internal(data)\n        case data\n        when \"*\"\n          return data\n        when Integer\n          if data == -1\n            return \"*\"\n          else\n            return data.to_s\n          end\n        when Range\n          return format_internal(data.first) +\n            \":\" + format_internal(data.last)\n        when Array\n          return data.collect {|i| format_internal(i)}.join(\",\")\n        when ThreadMember\n          return data.seqno.to_s +\n            \":\" + data.children.collect {|i| format_internal(i).join(\",\")}\n        end\n      end\n\n      def validate_internal(data)\n        case data\n        when \"*\"\n        when Integer\n          NumValidator.ensure_nz_number(data)\n        when Range\n        when Array\n          data.each do |i|\n            validate_internal(i)\n          end\n        when ThreadMember\n          data.children.each do |i|\n            validate_internal(i)\n          end\n        else\n          raise DataFormatError, data.inspect\n        end\n      end\n    end\n\n    # Common validators of number and nz_number types\n    module NumValidator # :nodoc\n      class << self\n        # Check is passed argument valid 'number' in RFC 3501 terminology\n        def valid_number?(num)\n          # [RFC 3501]\n          # number          = 1*DIGIT\n          #                    ; Unsigned 32-bit integer\n          #                    ; (0 <= n < 4,294,967,296)\n          num >= 0 && num < 4294967296\n        end\n\n        # Check is passed argument valid 'nz_number' in RFC 3501 terminology\n        def valid_nz_number?(num)\n          # [RFC 3501]\n          # nz-number       = digit-nz *DIGIT\n          #                    ; Non-zero unsigned 32-bit integer\n          #                    ; (0 < n < 4,294,967,296)\n          num != 0 && valid_number?(num)\n        end\n\n        # Check is passed argument valid 'mod_sequence_value' in RFC 4551 terminology\n        def valid_mod_sequence_value?(num)\n          # mod-sequence-value  = 1*DIGIT\n          #                        ; Positive unsigned 64-bit integer\n          #                        ; (mod-sequence)\n          #                        ; (1 <= n < 18,446,744,073,709,551,615)\n          num >= 1 && num < 18446744073709551615\n        end\n\n        # Ensure argument is 'number' or raise DataFormatError\n        def ensure_number(num)\n          return if valid_number?(num)\n\n          msg = \"number must be unsigned 32-bit integer: #{num}\"\n          raise DataFormatError, msg\n        end\n\n        # Ensure argument is 'nz_number' or raise DataFormatError\n        def ensure_nz_number(num)\n          return if valid_nz_number?(num)\n\n          msg = \"nz_number must be non-zero unsigned 32-bit integer: #{num}\"\n          raise DataFormatError, msg\n        end\n\n        # Ensure argument is 'mod_sequence_value' or raise DataFormatError\n        def ensure_mod_sequence_value(num)\n          return if valid_mod_sequence_value?(num)\n\n          msg = \"mod_sequence_value must be unsigned 64-bit integer: #{num}\"\n          raise DataFormatError, msg\n        end\n      end\n    end\n\n    # Net::IMAP::ContinuationRequest represents command continuation requests.\n    #\n    # The command continuation request response is indicated by a \"+\" token\n    # instead of a tag.  This form of response indicates that the server is\n    # ready to accept the continuation of a command from the client.  The\n    # remainder of this response is a line of text.\n    #\n    #   continue_req    ::= \"+\" SPACE (resp_text / base64)\n    #\n    # ==== Fields:\n    #\n    # data:: Returns the data (Net::IMAP::ResponseText).\n    #\n    # raw_data:: Returns the raw data string.\n    ContinuationRequest = Struct.new(:data, :raw_data)\n\n    # Net::IMAP::UntaggedResponse represents untagged responses.\n    #\n    # Data transmitted by the server to the client and status responses\n    # that do not indicate command completion are prefixed with the token\n    # \"*\", and are called untagged responses.\n    #\n    #   response_data   ::= \"*\" SPACE (resp_cond_state / resp_cond_bye /\n    #                       mailbox_data / message_data / capability_data)\n    #\n    # ==== Fields:\n    #\n    # name:: Returns the name, such as \"FLAGS\", \"LIST\", or \"FETCH\".\n    #\n    # data:: Returns the data such as an array of flag symbols,\n    #        a ((<Net::IMAP::MailboxList>)) object.\n    #\n    # raw_data:: Returns the raw data string.\n    UntaggedResponse = Struct.new(:name, :data, :raw_data)\n\n    # Net::IMAP::TaggedResponse represents tagged responses.\n    #\n    # The server completion result response indicates the success or\n    # failure of the operation.  It is tagged with the same tag as the\n    # client command which began the operation.\n    #\n    #   response_tagged ::= tag SPACE resp_cond_state CRLF\n    #\n    #   tag             ::= 1*<any ATOM_CHAR except \"+\">\n    #\n    #   resp_cond_state ::= (\"OK\" / \"NO\" / \"BAD\") SPACE resp_text\n    #\n    # ==== Fields:\n    #\n    # tag:: Returns the tag.\n    #\n    # name:: Returns the name, one of \"OK\", \"NO\", or \"BAD\".\n    #\n    # data:: Returns the data. See ((<Net::IMAP::ResponseText>)).\n    #\n    # raw_data:: Returns the raw data string.\n    #\n    TaggedResponse = Struct.new(:tag, :name, :data, :raw_data)\n\n    # Net::IMAP::ResponseText represents texts of responses.\n    # The text may be prefixed by the response code.\n    #\n    #   resp_text       ::= [\"[\" resp_text_code \"]\" SPACE] (text_mime2 / text)\n    #                       ;; text SHOULD NOT begin with \"[\" or \"=\"\n    #\n    # ==== Fields:\n    #\n    # code:: Returns the response code. See ((<Net::IMAP::ResponseCode>)).\n    #\n    # text:: Returns the text.\n    #\n    ResponseText = Struct.new(:code, :text)\n\n    # Net::IMAP::ResponseCode represents response codes.\n    #\n    #   resp_text_code  ::= \"ALERT\" / \"PARSE\" /\n    #                       \"PERMANENTFLAGS\" SPACE \"(\" #(flag / \"\\*\") \")\" /\n    #                       \"READ-ONLY\" / \"READ-WRITE\" / \"TRYCREATE\" /\n    #                       \"UIDVALIDITY\" SPACE nz_number /\n    #                       \"UNSEEN\" SPACE nz_number /\n    #                       atom [SPACE 1*<any TEXT_CHAR except \"]\">]\n    #\n    # ==== Fields:\n    #\n    # name:: Returns the name, such as \"ALERT\", \"PERMANENTFLAGS\", or \"UIDVALIDITY\".\n    #\n    # data:: Returns the data, if it exists.\n    #\n    ResponseCode = Struct.new(:name, :data)\n\n    # Net::IMAP::MailboxList represents contents of the LIST response.\n    #\n    #   mailbox_list    ::= \"(\" #(\"\\Marked\" / \"\\Noinferiors\" /\n    #                       \"\\Noselect\" / \"\\Unmarked\" / flag_extension) \")\"\n    #                       SPACE (<\"> QUOTED_CHAR <\"> / nil) SPACE mailbox\n    #\n    # ==== Fields:\n    #\n    # attr:: Returns the name attributes. Each name attribute is a symbol\n    #        capitalized by String#capitalize, such as :Noselect (not :NoSelect).\n    #\n    # delim:: Returns the hierarchy delimiter.\n    #\n    # name:: Returns the mailbox name.\n    #\n    MailboxList = Struct.new(:attr, :delim, :name)\n\n    # Net::IMAP::MailboxQuota represents contents of GETQUOTA response.\n    # This object can also be a response to GETQUOTAROOT.  In the syntax\n    # specification below, the delimiter used with the \"#\" construct is a\n    # single space (SPACE).\n    #\n    #    quota_list      ::= \"(\" #quota_resource \")\"\n    #\n    #    quota_resource  ::= atom SPACE number SPACE number\n    #\n    #    quota_response  ::= \"QUOTA\" SPACE astring SPACE quota_list\n    #\n    # ==== Fields:\n    #\n    # mailbox:: The mailbox with the associated quota.\n    #\n    # usage:: Current storage usage of the mailbox.\n    #\n    # quota:: Quota limit imposed on the mailbox.\n    #\n    MailboxQuota = Struct.new(:mailbox, :usage, :quota)\n\n    # Net::IMAP::MailboxQuotaRoot represents part of the GETQUOTAROOT\n    # response. (GETQUOTAROOT can also return Net::IMAP::MailboxQuota.)\n    #\n    #    quotaroot_response ::= \"QUOTAROOT\" SPACE astring *(SPACE astring)\n    #\n    # ==== Fields:\n    #\n    # mailbox:: The mailbox with the associated quota.\n    #\n    # quotaroots:: Zero or more quotaroots that affect the quota on the\n    #              specified mailbox.\n    #\n    MailboxQuotaRoot = Struct.new(:mailbox, :quotaroots)\n\n    # Net::IMAP::MailboxACLItem represents the response from GETACL.\n    #\n    #    acl_data        ::= \"ACL\" SPACE mailbox *(SPACE identifier SPACE rights)\n    #\n    #    identifier      ::= astring\n    #\n    #    rights          ::= astring\n    #\n    # ==== Fields:\n    #\n    # user:: Login name that has certain rights to the mailbox\n    #        that was specified with the getacl command.\n    #\n    # rights:: The access rights the indicated user has to the\n    #          mailbox.\n    #\n    MailboxACLItem = Struct.new(:user, :rights, :mailbox)\n\n    # Net::IMAP::StatusData represents the contents of the STATUS response.\n    #\n    # ==== Fields:\n    #\n    # mailbox:: Returns the mailbox name.\n    #\n    # attr:: Returns a hash. Each key is one of \"MESSAGES\", \"RECENT\", \"UIDNEXT\",\n    #        \"UIDVALIDITY\", \"UNSEEN\". Each value is a number.\n    #\n    StatusData = Struct.new(:mailbox, :attr)\n\n    # Net::IMAP::FetchData represents the contents of the FETCH response.\n    #\n    # ==== Fields:\n    #\n    # seqno:: Returns the message sequence number.\n    #         (Note: not the unique identifier, even for the UID command response.)\n    #\n    # attr:: Returns a hash. Each key is a data item name, and each value is\n    #        its value.\n    #\n    #        The current data items are:\n    #\n    #        [BODY]\n    #           A form of BODYSTRUCTURE without extension data.\n    #        [BODY[<section>]<<origin_octet>>]\n    #           A string expressing the body contents of the specified section.\n    #        [BODYSTRUCTURE]\n    #           An object that describes the [MIME-IMB] body structure of a message.\n    #           See Net::IMAP::BodyTypeBasic, Net::IMAP::BodyTypeText,\n    #           Net::IMAP::BodyTypeMessage, Net::IMAP::BodyTypeMultipart.\n    #        [ENVELOPE]\n    #           A Net::IMAP::Envelope object that describes the envelope\n    #           structure of a message.\n    #        [FLAGS]\n    #           A array of flag symbols that are set for this message. Flag symbols\n    #           are capitalized by String#capitalize.\n    #        [INTERNALDATE]\n    #           A string representing the internal date of the message.\n    #        [RFC822]\n    #           Equivalent to BODY[].\n    #        [RFC822.HEADER]\n    #           Equivalent to BODY.PEEK[HEADER].\n    #        [RFC822.SIZE]\n    #           A number expressing the [RFC-822] size of the message.\n    #        [RFC822.TEXT]\n    #           Equivalent to BODY[TEXT].\n    #        [UID]\n    #           A number expressing the unique identifier of the message.\n    #\n    FetchData = Struct.new(:seqno, :attr)\n\n    # Net::IMAP::Envelope represents envelope structures of messages.\n    #\n    # ==== Fields:\n    #\n    # date:: Returns a string that represents the date.\n    #\n    # subject:: Returns a string that represents the subject.\n    #\n    # from:: Returns an array of Net::IMAP::Address that represents the from.\n    #\n    # sender:: Returns an array of Net::IMAP::Address that represents the sender.\n    #\n    # reply_to:: Returns an array of Net::IMAP::Address that represents the reply-to.\n    #\n    # to:: Returns an array of Net::IMAP::Address that represents the to.\n    #\n    # cc:: Returns an array of Net::IMAP::Address that represents the cc.\n    #\n    # bcc:: Returns an array of Net::IMAP::Address that represents the bcc.\n    #\n    # in_reply_to:: Returns a string that represents the in-reply-to.\n    #\n    # message_id:: Returns a string that represents the message-id.\n    #\n    Envelope = Struct.new(:date, :subject, :from, :sender, :reply_to,\n                          :to, :cc, :bcc, :in_reply_to, :message_id)\n\n    #\n    # Net::IMAP::Address represents electronic mail addresses.\n    #\n    # ==== Fields:\n    #\n    # name:: Returns the phrase from [RFC-822] mailbox.\n    #\n    # route:: Returns the route from [RFC-822] route-addr.\n    #\n    # mailbox:: nil indicates end of [RFC-822] group.\n    #           If non-nil and host is nil, returns [RFC-822] group name.\n    #           Otherwise, returns [RFC-822] local-part.\n    #\n    # host:: nil indicates [RFC-822] group syntax.\n    #        Otherwise, returns [RFC-822] domain name.\n    #\n    Address = Struct.new(:name, :route, :mailbox, :host)\n\n    #\n    # Net::IMAP::ContentDisposition represents Content-Disposition fields.\n    #\n    # ==== Fields:\n    #\n    # dsp_type:: Returns the disposition type.\n    #\n    # param:: Returns a hash that represents parameters of the Content-Disposition\n    #         field.\n    #\n    ContentDisposition = Struct.new(:dsp_type, :param)\n\n    # Net::IMAP::ThreadMember represents a thread-node returned\n    # by Net::IMAP#thread.\n    #\n    # ==== Fields:\n    #\n    # seqno:: The sequence number of this message.\n    #\n    # children:: An array of Net::IMAP::ThreadMember objects for mail\n    #            items that are children of this in the thread.\n    #\n    ThreadMember = Struct.new(:seqno, :children)\n\n    # Net::IMAP::BodyTypeBasic represents basic body structures of messages.\n    #\n    # ==== Fields:\n    #\n    # media_type:: Returns the content media type name as defined in [MIME-IMB].\n    #\n    # subtype:: Returns the content subtype name as defined in [MIME-IMB].\n    #\n    # param:: Returns a hash that represents parameters as defined in [MIME-IMB].\n    #\n    # content_id:: Returns a string giving the content id as defined in [MIME-IMB].\n    #\n    # description:: Returns a string giving the content description as defined in\n    #               [MIME-IMB].\n    #\n    # encoding:: Returns a string giving the content transfer encoding as defined in\n    #            [MIME-IMB].\n    #\n    # size:: Returns a number giving the size of the body in octets.\n    #\n    # md5:: Returns a string giving the body MD5 value as defined in [MD5].\n    #\n    # disposition:: Returns a Net::IMAP::ContentDisposition object giving\n    #               the content disposition.\n    #\n    # language:: Returns a string or an array of strings giving the body\n    #            language value as defined in [LANGUAGE-TAGS].\n    #\n    # extension:: Returns extension data.\n    #\n    # multipart?:: Returns false.\n    #\n    class BodyTypeBasic < Struct.new(:media_type, :subtype,\n                                     :param, :content_id,\n                                     :description, :encoding, :size,\n                                     :md5, :disposition, :language,\n                                     :extension)\n      def multipart?\n        return false\n      end\n\n      # Obsolete: use +subtype+ instead.  Calling this will\n      # generate a warning message to +stderr+, then return\n      # the value of +subtype+.\n      def media_subtype\n        warn(\"media_subtype is obsolete, use subtype instead.\\n\", uplevel: 1)\n        return subtype\n      end\n    end\n\n    # Net::IMAP::BodyTypeText represents TEXT body structures of messages.\n    #\n    # ==== Fields:\n    #\n    # lines:: Returns the size of the body in text lines.\n    #\n    # And Net::IMAP::BodyTypeText has all fields of Net::IMAP::BodyTypeBasic.\n    #\n    class BodyTypeText < Struct.new(:media_type, :subtype,\n                                    :param, :content_id,\n                                    :description, :encoding, :size,\n                                    :lines,\n                                    :md5, :disposition, :language,\n                                    :extension)\n      def multipart?\n        return false\n      end\n\n      # Obsolete: use +subtype+ instead.  Calling this will\n      # generate a warning message to +stderr+, then return\n      # the value of +subtype+.\n      def media_subtype\n        warn(\"media_subtype is obsolete, use subtype instead.\\n\", uplevel: 1)\n        return subtype\n      end\n    end\n\n    # Net::IMAP::BodyTypeMessage represents MESSAGE/RFC822 body structures of messages.\n    #\n    # ==== Fields:\n    #\n    # envelope:: Returns a Net::IMAP::Envelope giving the envelope structure.\n    #\n    # body:: Returns an object giving the body structure.\n    #\n    # And Net::IMAP::BodyTypeMessage has all methods of Net::IMAP::BodyTypeText.\n    #\n    class BodyTypeMessage < Struct.new(:media_type, :subtype,\n                                       :param, :content_id,\n                                       :description, :encoding, :size,\n                                       :envelope, :body, :lines,\n                                       :md5, :disposition, :language,\n                                       :extension)\n      def multipart?\n        return false\n      end\n\n      # Obsolete: use +subtype+ instead.  Calling this will\n      # generate a warning message to +stderr+, then return\n      # the value of +subtype+.\n      def media_subtype\n        warn(\"media_subtype is obsolete, use subtype instead.\\n\", uplevel: 1)\n        return subtype\n      end\n    end\n\n    # Net::IMAP::BodyTypeAttachment represents attachment body structures\n    # of messages.\n    #\n    # ==== Fields:\n    #\n    # media_type:: Returns the content media type name.\n    #\n    # subtype:: Returns +nil+.\n    #\n    # param:: Returns a hash that represents parameters.\n    #\n    # multipart?:: Returns false.\n    #\n    class BodyTypeAttachment < Struct.new(:media_type, :subtype,\n                                          :param)\n      def multipart?\n        return false\n      end\n    end\n\n    # Net::IMAP::BodyTypeMultipart represents multipart body structures\n    # of messages.\n    #\n    # ==== Fields:\n    #\n    # media_type:: Returns the content media type name as defined in [MIME-IMB].\n    #\n    # subtype:: Returns the content subtype name as defined in [MIME-IMB].\n    #\n    # parts:: Returns multiple parts.\n    #\n    # param:: Returns a hash that represents parameters as defined in [MIME-IMB].\n    #\n    # disposition:: Returns a Net::IMAP::ContentDisposition object giving\n    #               the content disposition.\n    #\n    # language:: Returns a string or an array of strings giving the body\n    #            language value as defined in [LANGUAGE-TAGS].\n    #\n    # extension:: Returns extension data.\n    #\n    # multipart?:: Returns true.\n    #\n    class BodyTypeMultipart < Struct.new(:media_type, :subtype,\n                                         :parts,\n                                         :param, :disposition, :language,\n                                         :extension)\n      def multipart?\n        return true\n      end\n\n      # Obsolete: use +subtype+ instead.  Calling this will\n      # generate a warning message to +stderr+, then return\n      # the value of +subtype+.\n      def media_subtype\n        warn(\"media_subtype is obsolete, use subtype instead.\\n\", uplevel: 1)\n        return subtype\n      end\n    end\n\n    class BodyTypeExtension < Struct.new(:media_type, :subtype,\n                                         :params, :content_id,\n                                         :description, :encoding, :size)\n      def multipart?\n        return false\n      end\n    end\n\n    class ResponseParser # :nodoc:\n      def initialize\n        @str = nil\n        @pos = nil\n        @lex_state = nil\n        @token = nil\n        @flag_symbols = {}\n      end\n\n      def parse(str)\n        @str = str\n        @pos = 0\n        @lex_state = EXPR_BEG\n        @token = nil\n        return response\n      end\n\n      private\n\n      EXPR_BEG          = :EXPR_BEG\n      EXPR_DATA         = :EXPR_DATA\n      EXPR_TEXT         = :EXPR_TEXT\n      EXPR_RTEXT        = :EXPR_RTEXT\n      EXPR_CTEXT        = :EXPR_CTEXT\n\n      T_SPACE   = :SPACE\n      T_NIL     = :NIL\n      T_NUMBER  = :NUMBER\n      T_ATOM    = :ATOM\n      T_QUOTED  = :QUOTED\n      T_LPAR    = :LPAR\n      T_RPAR    = :RPAR\n      T_BSLASH  = :BSLASH\n      T_STAR    = :STAR\n      T_LBRA    = :LBRA\n      T_RBRA    = :RBRA\n      T_LITERAL = :LITERAL\n      T_PLUS    = :PLUS\n      T_PERCENT = :PERCENT\n      T_CRLF    = :CRLF\n      T_EOF     = :EOF\n      T_TEXT    = :TEXT\n\n      BEG_REGEXP = /\\G(?:\\\n(?# 1:  SPACE   )( +)|\\\n(?# 2:  NIL     )(NIL)(?=[\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\\\[\\]+])|\\\n(?# 3:  NUMBER  )(\\d+)(?=[\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\\\[\\]+])|\\\n(?# 4:  ATOM    )([^\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\\\[\\]+]+)|\\\n(?# 5:  QUOTED  )\"((?:[^\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\"|\\\n(?# 6:  LPAR    )(\\()|\\\n(?# 7:  RPAR    )(\\))|\\\n(?# 8:  BSLASH  )(\\\\)|\\\n(?# 9:  STAR    )(\\*)|\\\n(?# 10: LBRA    )(\\[)|\\\n(?# 11: RBRA    )(\\])|\\\n(?# 12: LITERAL )\\{(\\d+)\\}\\r\\n|\\\n(?# 13: PLUS    )(\\+)|\\\n(?# 14: PERCENT )(%)|\\\n(?# 15: CRLF    )(\\r\\n)|\\\n(?# 16: EOF     )(\\z))/ni\n\n      DATA_REGEXP = /\\G(?:\\\n(?# 1:  SPACE   )( )|\\\n(?# 2:  NIL     )(NIL)|\\\n(?# 3:  NUMBER  )(\\d+)|\\\n(?# 4:  QUOTED  )\"((?:[^\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\"|\\\n(?# 5:  LITERAL )\\{(\\d+)\\}\\r\\n|\\\n(?# 6:  LPAR    )(\\()|\\\n(?# 7:  RPAR    )(\\)))/ni\n\n      TEXT_REGEXP = /\\G(?:\\\n(?# 1:  TEXT    )([^\\x00\\r\\n]*))/ni\n\n      RTEXT_REGEXP = /\\G(?:\\\n(?# 1:  LBRA    )(\\[)|\\\n(?# 2:  TEXT    )([^\\x00\\r\\n]*))/ni\n\n      CTEXT_REGEXP = /\\G(?:\\\n(?# 1:  TEXT    )([^\\x00\\r\\n\\]]*))/ni\n\n      Token = Struct.new(:symbol, :value)\n\n      def response\n        token = lookahead\n        case token.symbol\n        when T_PLUS\n          result = continue_req\n        when T_STAR\n          result = response_untagged\n        else\n          result = response_tagged\n        end\n        while lookahead.symbol == T_SPACE\n          # Ignore trailing space for Microsoft Exchange Server\n          shift_token\n        end\n        match(T_CRLF)\n        match(T_EOF)\n        return result\n      end\n\n      def continue_req\n        match(T_PLUS)\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          return ContinuationRequest.new(resp_text, @str)\n        else\n          return ContinuationRequest.new(ResponseText.new(nil, \"\"), @str)\n        end\n      end\n\n      def response_untagged\n        match(T_STAR)\n        match(T_SPACE)\n        token = lookahead\n        if token.symbol == T_NUMBER\n          return numeric_response\n        elsif token.symbol == T_ATOM\n          case token.value\n          when /\\A(?:OK|NO|BAD|BYE|PREAUTH)\\z/ni\n            return response_cond\n          when /\\A(?:FLAGS)\\z/ni\n            return flags_response\n          when /\\A(?:LIST|LSUB|XLIST)\\z/ni\n            return list_response\n          when /\\A(?:QUOTA)\\z/ni\n            return getquota_response\n          when /\\A(?:QUOTAROOT)\\z/ni\n            return getquotaroot_response\n          when /\\A(?:ACL)\\z/ni\n            return getacl_response\n          when /\\A(?:SEARCH|SORT)\\z/ni\n            return search_response\n          when /\\A(?:THREAD)\\z/ni\n            return thread_response\n          when /\\A(?:STATUS)\\z/ni\n            return status_response\n          when /\\A(?:CAPABILITY)\\z/ni\n            return capability_response\n          else\n            return text_response\n          end\n        else\n          parse_error(\"unexpected token %s\", token.symbol)\n        end\n      end\n\n      def response_tagged\n        tag = atom\n        match(T_SPACE)\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return TaggedResponse.new(tag, name, resp_text, @str)\n      end\n\n      def response_cond\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return UntaggedResponse.new(name, resp_text, @str)\n      end\n\n      def numeric_response\n        n = number\n        match(T_SPACE)\n        token = match(T_ATOM)\n        name = token.value.upcase\n        case name\n        when \"EXISTS\", \"RECENT\", \"EXPUNGE\"\n          return UntaggedResponse.new(name, n, @str)\n        when \"FETCH\"\n          shift_token\n          match(T_SPACE)\n          data = FetchData.new(n, msg_att(n))\n          return UntaggedResponse.new(name, data, @str)\n        end\n      end\n\n      def msg_att(n)\n        match(T_LPAR)\n        attr = {}\n        while true\n          token = lookahead\n          case token.symbol\n          when T_RPAR\n            shift_token\n            break\n          when T_SPACE\n            shift_token\n            next\n          end\n          case token.value\n          when /\\A(?:ENVELOPE)\\z/ni\n            name, val = envelope_data\n          when /\\A(?:FLAGS)\\z/ni\n            name, val = flags_data\n          when /\\A(?:INTERNALDATE)\\z/ni\n            name, val = internaldate_data\n          when /\\A(?:RFC822(?:\\.HEADER|\\.TEXT)?)\\z/ni\n            name, val = rfc822_text\n          when /\\A(?:RFC822\\.SIZE)\\z/ni\n            name, val = rfc822_size\n          when /\\A(?:BODY(?:STRUCTURE)?)\\z/ni\n            name, val = body_data\n          when /\\A(?:UID)\\z/ni\n            name, val = uid_data\n          when /\\A(?:MODSEQ)\\z/ni\n            name, val = modseq_data\n          else\n            parse_error(\"unknown attribute `%s' for {%d}\", token.value, n)\n          end\n          attr[name] = val\n        end\n        return attr\n      end\n\n      def envelope_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return name, envelope\n      end\n\n      def envelope\n        @lex_state = EXPR_DATA\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          result = nil\n        else\n          match(T_LPAR)\n          date = nstring\n          match(T_SPACE)\n          subject = nstring\n          match(T_SPACE)\n          from = address_list\n          match(T_SPACE)\n          sender = address_list\n          match(T_SPACE)\n          reply_to = address_list\n          match(T_SPACE)\n          to = address_list\n          match(T_SPACE)\n          cc = address_list\n          match(T_SPACE)\n          bcc = address_list\n          match(T_SPACE)\n          in_reply_to = nstring\n          match(T_SPACE)\n          message_id = nstring\n          match(T_RPAR)\n          result = Envelope.new(date, subject, from, sender, reply_to,\n                                to, cc, bcc, in_reply_to, message_id)\n        end\n        @lex_state = EXPR_BEG\n        return result\n      end\n\n      def flags_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return name, flag_list\n      end\n\n      def internaldate_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        token = match(T_QUOTED)\n        return name, token.value\n      end\n\n      def rfc822_text\n        token = match(T_ATOM)\n        name = token.value.upcase\n        token = lookahead\n        if token.symbol == T_LBRA\n          shift_token\n          match(T_RBRA)\n        end\n        match(T_SPACE)\n        return name, nstring\n      end\n\n      def rfc822_size\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return name, number\n      end\n\n      def body_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          return name, body\n        end\n        name.concat(section)\n        token = lookahead\n        if token.symbol == T_ATOM\n          name.concat(token.value)\n          shift_token\n        end\n        match(T_SPACE)\n        data = nstring\n        return name, data\n      end\n\n      def body\n        @lex_state = EXPR_DATA\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          result = nil\n        else\n          match(T_LPAR)\n          token = lookahead\n          if token.symbol == T_LPAR\n            result = body_type_mpart\n          else\n            result = body_type_1part\n          end\n          match(T_RPAR)\n        end\n        @lex_state = EXPR_BEG\n        return result\n      end\n\n      def body_type_1part\n        token = lookahead\n        case token.value\n        when /\\A(?:TEXT)\\z/ni\n          return body_type_text\n        when /\\A(?:MESSAGE)\\z/ni\n          return body_type_msg\n        when /\\A(?:ATTACHMENT)\\z/ni\n          return body_type_attachment\n        when /\\A(?:MIXED)\\z/ni\n          return body_type_mixed\n        else\n          return body_type_basic\n        end\n      end\n\n      def body_type_basic\n        mtype, msubtype = media_type\n        token = lookahead\n        if token.symbol == T_RPAR\n          return BodyTypeBasic.new(mtype, msubtype)\n        end\n        match(T_SPACE)\n        param, content_id, desc, enc, size = body_fields\n        md5, disposition, language, extension = body_ext_1part\n        return BodyTypeBasic.new(mtype, msubtype,\n                                 param, content_id,\n                                 desc, enc, size,\n                                 md5, disposition, language, extension)\n      end\n\n      def body_type_text\n        mtype, msubtype = media_type\n        match(T_SPACE)\n        param, content_id, desc, enc, size = body_fields\n        match(T_SPACE)\n        lines = number\n        md5, disposition, language, extension = body_ext_1part\n        return BodyTypeText.new(mtype, msubtype,\n                                param, content_id,\n                                desc, enc, size,\n                                lines,\n                                md5, disposition, language, extension)\n      end\n\n      def body_type_msg\n        mtype, msubtype = media_type\n        match(T_SPACE)\n        param, content_id, desc, enc, size = body_fields\n\n        token = lookahead\n        if token.symbol == T_RPAR\n          # If this is not message/rfc822, we shouldn't apply the RFC822\n          # spec to it.  We should handle anything other than\n          # message/rfc822 using multipart extension data [rfc3501] (i.e.\n          # the data itself won't be returned, we would have to retrieve it\n          # with BODYSTRUCTURE instead of with BODY\n\n          # Also, sometimes a message/rfc822 is included as a large\n          # attachment instead of having all of the other details\n          # (e.g. attaching a .eml file to an email)\n          if msubtype == \"RFC822\"\n            return BodyTypeMessage.new(mtype, msubtype, param, content_id,\n                                       desc, enc, size, nil, nil, nil, nil,\n                                       nil, nil, nil)\n          else\n            return BodyTypeExtension.new(mtype, msubtype,\n                                         param, content_id,\n                                         desc, enc, size)\n          end\n        end\n\n        match(T_SPACE)\n        env = envelope\n        match(T_SPACE)\n        b = body\n        match(T_SPACE)\n        lines = number\n        md5, disposition, language, extension = body_ext_1part\n        return BodyTypeMessage.new(mtype, msubtype,\n                                   param, content_id,\n                                   desc, enc, size,\n                                   env, b, lines,\n                                   md5, disposition, language, extension)\n      end\n\n      def body_type_attachment\n        mtype = case_insensitive_string\n        match(T_SPACE)\n        param = body_fld_param\n        return BodyTypeAttachment.new(mtype, nil, param)\n      end\n\n      def body_type_mixed\n        mtype = \"MULTIPART\"\n        msubtype = case_insensitive_string\n        param, disposition, language, extension = body_ext_mpart\n        return BodyTypeBasic.new(mtype, msubtype, param, nil, nil, nil, nil, nil, disposition, language, extension)\n      end\n\n      def body_type_mpart\n        parts = []\n        while true\n          token = lookahead\n          if token.symbol == T_SPACE\n            shift_token\n            break\n          end\n          parts.push(body)\n        end\n        mtype = \"MULTIPART\"\n        msubtype = case_insensitive_string\n        param, disposition, language, extension = body_ext_mpart\n        return BodyTypeMultipart.new(mtype, msubtype, parts,\n                                     param, disposition, language,\n                                     extension)\n      end\n\n      def media_type\n        mtype = case_insensitive_string\n        token = lookahead\n        if token.symbol != T_SPACE\n          return mtype, nil\n        end\n        match(T_SPACE)\n        msubtype = case_insensitive_string\n        return mtype, msubtype\n      end\n\n      def body_fields\n        param = body_fld_param\n        match(T_SPACE)\n        content_id = nstring\n        match(T_SPACE)\n        desc = nstring\n        match(T_SPACE)\n        enc = case_insensitive_string\n        match(T_SPACE)\n        size = number\n        return param, content_id, desc, enc, size\n      end\n\n      def body_fld_param\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        match(T_LPAR)\n        param = {}\n        while true\n          token = lookahead\n          case token.symbol\n          when T_RPAR\n            shift_token\n            break\n          when T_SPACE\n            shift_token\n          end\n          name = case_insensitive_string\n          match(T_SPACE)\n          val = string\n          param[name] = val\n        end\n        return param\n      end\n\n      def body_ext_1part\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return nil\n        end\n        md5 = nstring\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return md5\n        end\n        disposition = body_fld_dsp\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return md5, disposition\n        end\n        language = body_fld_lang\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return md5, disposition, language\n        end\n\n        extension = body_extensions\n        return md5, disposition, language, extension\n      end\n\n      def body_ext_mpart\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return nil\n        end\n        param = body_fld_param\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return param\n        end\n        disposition = body_fld_dsp\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return param, disposition\n        end\n        language = body_fld_lang\n\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n        else\n          return param, disposition, language\n        end\n\n        extension = body_extensions\n        return param, disposition, language, extension\n      end\n\n      def body_fld_dsp\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        match(T_LPAR)\n        dsp_type = case_insensitive_string\n        match(T_SPACE)\n        param = body_fld_param\n        match(T_RPAR)\n        return ContentDisposition.new(dsp_type, param)\n      end\n\n      def body_fld_lang\n        token = lookahead\n        if token.symbol == T_LPAR\n          shift_token\n          result = []\n          while true\n            token = lookahead\n            case token.symbol\n            when T_RPAR\n              shift_token\n              return result\n            when T_SPACE\n              shift_token\n            end\n            result.push(case_insensitive_string)\n          end\n        else\n          lang = nstring\n          if lang\n            return lang.upcase\n          else\n            return lang\n          end\n        end\n      end\n\n      def body_extensions\n        result = []\n        while true\n          token = lookahead\n          case token.symbol\n          when T_RPAR\n            return result\n          when T_SPACE\n            shift_token\n          end\n          result.push(body_extension)\n        end\n      end\n\n      def body_extension\n        token = lookahead\n        case token.symbol\n        when T_LPAR\n          shift_token\n          result = body_extensions\n          match(T_RPAR)\n          return result\n        when T_NUMBER\n          return number\n        else\n          return nstring\n        end\n      end\n\n      def section\n        str = String.new\n        token = match(T_LBRA)\n        str.concat(token.value)\n        token = match(T_ATOM, T_NUMBER, T_RBRA)\n        if token.symbol == T_RBRA\n          str.concat(token.value)\n          return str\n        end\n        str.concat(token.value)\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          str.concat(token.value)\n          token = match(T_LPAR)\n          str.concat(token.value)\n          while true\n            token = lookahead\n            case token.symbol\n            when T_RPAR\n              str.concat(token.value)\n              shift_token\n              break\n            when T_SPACE\n              shift_token\n              str.concat(token.value)\n            end\n            str.concat(format_string(astring))\n          end\n        end\n        token = match(T_RBRA)\n        str.concat(token.value)\n        return str\n      end\n\n      def format_string(str)\n        case str\n        when \"\"\n          return '\"\"'\n        when /[\\x80-\\xff\\r\\n]/n\n          # literal\n          return \"{\" + str.bytesize.to_s + \"}\" + CRLF + str\n        when /[(){ \\x00-\\x1f\\x7f%*\"\\\\]/n\n          # quoted string\n          return '\"' + str.gsub(/[\"\\\\]/n, \"\\\\\\\\\\\\&\") + '\"'\n        else\n          # atom\n          return str\n        end\n      end\n\n      def uid_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return name, number\n      end\n\n      def modseq_data\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        match(T_LPAR)\n        modseq = number\n        match(T_RPAR)\n        return name, modseq\n      end\n\n      def text_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        @lex_state = EXPR_TEXT\n        token = match(T_TEXT)\n        @lex_state = EXPR_BEG\n        return UntaggedResponse.new(name, token.value)\n      end\n\n      def flags_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return UntaggedResponse.new(name, flag_list, @str)\n      end\n\n      def list_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        return UntaggedResponse.new(name, mailbox_list, @str)\n      end\n\n      def mailbox_list\n        attr = flag_list\n        match(T_SPACE)\n        token = match(T_QUOTED, T_NIL)\n        if token.symbol == T_NIL\n          delim = nil\n        else\n          delim = token.value\n        end\n        match(T_SPACE)\n        name = astring\n        return MailboxList.new(attr, delim, name)\n      end\n\n      def getquota_response\n        # If quota never established, get back\n        # `NO Quota root does not exist'.\n        # If quota removed, get `()' after the\n        # folder spec with no mention of `STORAGE'.\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        mailbox = astring\n        match(T_SPACE)\n        match(T_LPAR)\n        token = lookahead\n        case token.symbol\n        when T_RPAR\n          shift_token\n          data = MailboxQuota.new(mailbox, nil, nil)\n          return UntaggedResponse.new(name, data, @str)\n        when T_ATOM\n          shift_token\n          match(T_SPACE)\n          token = match(T_NUMBER)\n          usage = token.value\n          match(T_SPACE)\n          token = match(T_NUMBER)\n          quota = token.value\n          match(T_RPAR)\n          data = MailboxQuota.new(mailbox, usage, quota)\n          return UntaggedResponse.new(name, data, @str)\n        else\n          parse_error(\"unexpected token %s\", token.symbol)\n        end\n      end\n\n      def getquotaroot_response\n        # Similar to getquota, but only admin can use getquota.\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        mailbox = astring\n        quotaroots = []\n        while true\n          token = lookahead\n          break unless token.symbol == T_SPACE\n          shift_token\n          quotaroots.push(astring)\n        end\n        data = MailboxQuotaRoot.new(mailbox, quotaroots)\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def getacl_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        mailbox = astring\n        data = []\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          while true\n            token = lookahead\n            case token.symbol\n            when T_CRLF\n              break\n            when T_SPACE\n              shift_token\n            end\n            user = astring\n            match(T_SPACE)\n            rights = astring\n            data.push(MailboxACLItem.new(user, rights, mailbox))\n          end\n        end\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def search_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        token = lookahead\n        if token.symbol == T_SPACE\n          shift_token\n          data = []\n          while true\n            token = lookahead\n            case token.symbol\n            when T_CRLF\n              break\n            when T_SPACE\n              shift_token\n            when T_NUMBER\n              data.push(number)\n            when T_LPAR\n              # TODO: include the MODSEQ value in a response\n              shift_token\n              match(T_ATOM)\n              match(T_SPACE)\n              match(T_NUMBER)\n              match(T_RPAR)\n            end\n          end\n        else\n          data = []\n        end\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def thread_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        token = lookahead\n\n        if token.symbol == T_SPACE\n          threads = []\n\n          while true\n            shift_token\n            token = lookahead\n\n            case token.symbol\n            when T_LPAR\n              threads << thread_branch(token)\n            when T_CRLF\n              break\n            end\n          end\n        else\n          # no member\n          threads = []\n        end\n\n        return UntaggedResponse.new(name, threads, @str)\n      end\n\n      def thread_branch(token)\n        rootmember = nil\n        lastmember = nil\n\n        while true\n          shift_token    # ignore first T_LPAR\n          token = lookahead\n\n          case token.symbol\n          when T_NUMBER\n            # new member\n            newmember = ThreadMember.new(number, [])\n            if rootmember.nil?\n              rootmember = newmember\n            else\n              lastmember.children << newmember\n            end\n            lastmember = newmember\n          when T_SPACE\n            # do nothing\n          when T_LPAR\n            if rootmember.nil?\n              # dummy member\n              lastmember = rootmember = ThreadMember.new(nil, [])\n            end\n\n            lastmember.children << thread_branch(token)\n          when T_RPAR\n            break\n          end\n        end\n\n        return rootmember\n      end\n\n      def status_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        mailbox = astring\n        match(T_SPACE)\n        match(T_LPAR)\n        attr = {}\n        while true\n          token = lookahead\n          case token.symbol\n          when T_RPAR\n            shift_token\n            break\n          when T_SPACE\n            shift_token\n          end\n          token = match(T_ATOM)\n          key = token.value.upcase\n          match(T_SPACE)\n          val = number\n          attr[key] = val\n        end\n        data = StatusData.new(mailbox, attr)\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def capability_response\n        token = match(T_ATOM)\n        name = token.value.upcase\n        match(T_SPACE)\n        data = []\n        while true\n          token = lookahead\n          case token.symbol\n          when T_CRLF\n            break\n          when T_SPACE\n            shift_token\n            next\n          end\n          data.push(atom.upcase)\n        end\n        return UntaggedResponse.new(name, data, @str)\n      end\n\n      def resp_text\n        @lex_state = EXPR_RTEXT\n        token = lookahead\n        if token.symbol == T_LBRA\n          code = resp_text_code\n        else\n          code = nil\n        end\n        token = match(T_TEXT)\n        @lex_state = EXPR_BEG\n        return ResponseText.new(code, token.value)\n      end\n\n      def resp_text_code\n        @lex_state = EXPR_BEG\n        match(T_LBRA)\n        token = match(T_ATOM)\n        name = token.value.upcase\n        case name\n        when /\\A(?:ALERT|PARSE|READ-ONLY|READ-WRITE|TRYCREATE|NOMODSEQ)\\z/n\n          result = ResponseCode.new(name, nil)\n        when /\\A(?:PERMANENTFLAGS)\\z/n\n          match(T_SPACE)\n          result = ResponseCode.new(name, flag_list)\n        when /\\A(?:UIDVALIDITY|UIDNEXT|UNSEEN)\\z/n\n          match(T_SPACE)\n          result = ResponseCode.new(name, number)\n        else\n          token = lookahead\n          if token.symbol == T_SPACE\n            shift_token\n            @lex_state = EXPR_CTEXT\n            token = match(T_TEXT)\n            @lex_state = EXPR_BEG\n            result = ResponseCode.new(name, token.value)\n          else\n            result = ResponseCode.new(name, nil)\n          end\n        end\n        match(T_RBRA)\n        @lex_state = EXPR_RTEXT\n        return result\n      end\n\n      def address_list\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        else\n          result = []\n          match(T_LPAR)\n          while true\n            token = lookahead\n            case token.symbol\n            when T_RPAR\n              shift_token\n              break\n            when T_SPACE\n              shift_token\n            end\n            result.push(address)\n          end\n          return result\n        end\n      end\n\n      ADDRESS_REGEXP = /\\G\\\n(?# 1: NAME     )(?:NIL|\"((?:[^\\x80-\\xff\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\") \\\n(?# 2: ROUTE    )(?:NIL|\"((?:[^\\x80-\\xff\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\") \\\n(?# 3: MAILBOX  )(?:NIL|\"((?:[^\\x80-\\xff\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\") \\\n(?# 4: HOST     )(?:NIL|\"((?:[^\\x80-\\xff\\x00\\r\\n\"\\\\]|\\\\[\"\\\\])*)\")\\\n\\)/ni\n\n      def address\n        match(T_LPAR)\n        if @str.index(ADDRESS_REGEXP, @pos)\n          # address does not include literal.\n          @pos = $~.end(0)\n          name = $1\n          route = $2\n          mailbox = $3\n          host = $4\n          for s in [name, route, mailbox, host]\n            if s\n              s.gsub!(/\\\\([\"\\\\])/n, \"\\\\1\")\n            end\n          end\n        else\n          name = nstring\n          match(T_SPACE)\n          route = nstring\n          match(T_SPACE)\n          mailbox = nstring\n          match(T_SPACE)\n          host = nstring\n          match(T_RPAR)\n        end\n        return Address.new(name, route, mailbox, host)\n      end\n\n      FLAG_REGEXP = /\\\n(?# FLAG        )\\\\([^\\x80-\\xff(){ \\x00-\\x1f\\x7f%\"\\\\]+)|\\\n(?# ATOM        )([^\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\]+)/n\n\n      def flag_list\n        if @str.index(/\\(([^)]*)\\)/ni, @pos)\n          @pos = $~.end(0)\n          return $1.scan(FLAG_REGEXP).collect { |flag, atom|\n            if atom\n              atom\n            else\n              symbol = flag.capitalize.intern\n              @flag_symbols[symbol] = true\n              if @flag_symbols.length > IMAP.max_flag_count\n                raise FlagCountError, \"number of flag symbols exceeded\"\n              end\n              symbol\n            end\n          }\n        else\n          parse_error(\"invalid flag list\")\n        end\n      end\n\n      def nstring\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        else\n          return string\n        end\n      end\n\n      def astring\n        token = lookahead\n        if string_token?(token)\n          return string\n        else\n          return atom\n        end\n      end\n\n      def string\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        token = match(T_QUOTED, T_LITERAL)\n        return token.value\n      end\n\n      STRING_TOKENS = [T_QUOTED, T_LITERAL, T_NIL]\n\n      def string_token?(token)\n        return STRING_TOKENS.include?(token.symbol)\n      end\n\n      def case_insensitive_string\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        token = match(T_QUOTED, T_LITERAL)\n        return token.value.upcase\n      end\n\n      def atom\n        result = String.new\n        while true\n          token = lookahead\n          if atom_token?(token)\n            result.concat(token.value)\n            shift_token\n          else\n            if result.empty?\n              parse_error(\"unexpected token %s\", token.symbol)\n            else\n              return result\n            end\n          end\n        end\n      end\n\n      ATOM_TOKENS = [\n        T_ATOM,\n        T_NUMBER,\n        T_NIL,\n        T_LBRA,\n        T_RBRA,\n        T_PLUS\n      ]\n\n      def atom_token?(token)\n        return ATOM_TOKENS.include?(token.symbol)\n      end\n\n      def number\n        token = lookahead\n        if token.symbol == T_NIL\n          shift_token\n          return nil\n        end\n        token = match(T_NUMBER)\n        return token.value.to_i\n      end\n\n      def nil_atom\n        match(T_NIL)\n        return nil\n      end\n\n      def match(*args)\n        token = lookahead\n        unless args.include?(token.symbol)\n          parse_error('unexpected token %s (expected %s)',\n                      token.symbol.id2name,\n                      args.collect {|i| i.id2name}.join(\" or \"))\n        end\n        shift_token\n        return token\n      end\n\n      def lookahead\n        unless @token\n          @token = next_token\n        end\n        return @token\n      end\n\n      def shift_token\n        @token = nil\n      end\n\n      def next_token\n        case @lex_state\n        when EXPR_BEG\n          if @str.index(BEG_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_SPACE, $+)\n            elsif $2\n              return Token.new(T_NIL, $+)\n            elsif $3\n              return Token.new(T_NUMBER, $+)\n            elsif $4\n              return Token.new(T_ATOM, $+)\n            elsif $5\n              return Token.new(T_QUOTED,\n                               $+.gsub(/\\\\([\"\\\\])/n, \"\\\\1\"))\n            elsif $6\n              return Token.new(T_LPAR, $+)\n            elsif $7\n              return Token.new(T_RPAR, $+)\n            elsif $8\n              return Token.new(T_BSLASH, $+)\n            elsif $9\n              return Token.new(T_STAR, $+)\n            elsif $10\n              return Token.new(T_LBRA, $+)\n            elsif $11\n              return Token.new(T_RBRA, $+)\n            elsif $12\n              len = $+.to_i\n              val = @str[@pos, len]\n              @pos += len\n              return Token.new(T_LITERAL, val)\n            elsif $13\n              return Token.new(T_PLUS, $+)\n            elsif $14\n              return Token.new(T_PERCENT, $+)\n            elsif $15\n              return Token.new(T_CRLF, $+)\n            elsif $16\n              return Token.new(T_EOF, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] BEG_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos)\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        when EXPR_DATA\n          if @str.index(DATA_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_SPACE, $+)\n            elsif $2\n              return Token.new(T_NIL, $+)\n            elsif $3\n              return Token.new(T_NUMBER, $+)\n            elsif $4\n              return Token.new(T_QUOTED,\n                               $+.gsub(/\\\\([\"\\\\])/n, \"\\\\1\"))\n            elsif $5\n              len = $+.to_i\n              val = @str[@pos, len]\n              @pos += len\n              return Token.new(T_LITERAL, val)\n            elsif $6\n              return Token.new(T_LPAR, $+)\n            elsif $7\n              return Token.new(T_RPAR, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] DATA_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos)\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        when EXPR_TEXT\n          if @str.index(TEXT_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_TEXT, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] TEXT_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos)\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        when EXPR_RTEXT\n          if @str.index(RTEXT_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_LBRA, $+)\n            elsif $2\n              return Token.new(T_TEXT, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] RTEXT_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos)\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        when EXPR_CTEXT\n          if @str.index(CTEXT_REGEXP, @pos)\n            @pos = $~.end(0)\n            if $1\n              return Token.new(T_TEXT, $+)\n            else\n              parse_error(\"[Net::IMAP BUG] CTEXT_REGEXP is invalid\")\n            end\n          else\n            @str.index(/\\S*/n, @pos) #/\n            parse_error(\"unknown token - %s\", $&.dump)\n          end\n        else\n          parse_error(\"invalid @lex_state - %s\", @lex_state.inspect)\n        end\n      end\n\n      def parse_error(fmt, *args)\n        if IMAP.debug\n          $stderr.printf(\"@str: %s\\n\", @str.dump)\n          $stderr.printf(\"@pos: %d\\n\", @pos)\n          $stderr.printf(\"@lex_state: %s\\n\", @lex_state)\n          if @token\n            $stderr.printf(\"@token.symbol: %s\\n\", @token.symbol)\n            $stderr.printf(\"@token.value: %s\\n\", @token.value.inspect)\n          end\n        end\n        raise ResponseParseError, format(fmt, *args)\n      end\n    end\n\n    # Authenticator for the \"LOGIN\" authentication type.  See\n    # #authenticate().\n    class LoginAuthenticator\n      def process(data)\n        case @state\n        when STATE_USER\n          @state = STATE_PASSWORD\n          return @user\n        when STATE_PASSWORD\n          return @password\n        end\n      end\n\n      private\n\n      STATE_USER = :USER\n      STATE_PASSWORD = :PASSWORD\n\n      def initialize(user, password)\n        @user = user\n        @password = password\n        @state = STATE_USER\n      end\n    end\n    add_authenticator \"LOGIN\", LoginAuthenticator\n\n    # Authenticator for the \"PLAIN\" authentication type.  See\n    # #authenticate().\n    class PlainAuthenticator\n      def process(data)\n        return \"\\0#{@user}\\0#{@password}\"\n      end\n\n      private\n\n      def initialize(user, password)\n        @user = user\n        @password = password\n      end\n    end\n    add_authenticator \"PLAIN\", PlainAuthenticator\n\n    # Authenticator for the \"CRAM-MD5\" authentication type.  See\n    # #authenticate().\n    class CramMD5Authenticator\n      def process(challenge)\n        digest = hmac_md5(challenge, @password)\n        return @user + \" \" + digest\n      end\n\n      private\n\n      def initialize(user, password)\n        @user = user\n        @password = password\n      end\n\n      def hmac_md5(text, key)\n        if key.length > 64\n          key = Digest::MD5.digest(key)\n        end\n\n        k_ipad = key + \"\\0\" * (64 - key.length)\n        k_opad = key + \"\\0\" * (64 - key.length)\n        for i in 0..63\n          k_ipad[i] = (k_ipad[i].ord ^ 0x36).chr\n          k_opad[i] = (k_opad[i].ord ^ 0x5c).chr\n        end\n\n        digest = Digest::MD5.digest(k_ipad + text)\n\n        return Digest::MD5.hexdigest(k_opad + digest)\n      end\n    end\n    add_authenticator \"CRAM-MD5\", CramMD5Authenticator\n\n    # Authenticator for the \"DIGEST-MD5\" authentication type.  See\n    # #authenticate().\n    class DigestMD5Authenticator\n      def process(challenge)\n        case @stage\n        when STAGE_ONE\n          @stage = STAGE_TWO\n          sparams = {}\n          c = StringScanner.new(challenge)\n          while c.scan(/(?:\\s*,)?\\s*(\\w+)=(\"(?:[^\\\\\"]+|\\\\.)*\"|[^,]+)\\s*/)\n            k, v = c[1], c[2]\n            if v =~ /^\"(.*)\"$/\n              v = $1\n              if v =~ /,/\n                v = v.split(',')\n              end\n            end\n            sparams[k] = v\n          end\n\n          raise DataFormatError, \"Bad Challenge: '#{challenge}'\" unless c.rest.size == 0\n          raise Error, \"Server does not support auth (qop = #{sparams['qop'].join(',')})\" unless sparams['qop'].include?(\"auth\")\n\n          response = {\n            :nonce => sparams['nonce'],\n            :username => @user,\n            :realm => sparams['realm'],\n            :cnonce => Digest::MD5.hexdigest(\"%.15f:%.15f:%d\" % [Time.now.to_f, rand, Process.pid.to_s]),\n            :'digest-uri' => 'imap/' + sparams['realm'],\n            :qop => 'auth',\n            :maxbuf => 65535,\n            :nc => \"%08d\" % nc(sparams['nonce']),\n            :charset => sparams['charset'],\n          }\n\n          response[:authzid] = @authname unless @authname.nil?\n\n          # now, the real thing\n          a0 = Digest::MD5.digest( [ response.values_at(:username, :realm), @password ].join(':') )\n\n          a1 = [ a0, response.values_at(:nonce,:cnonce) ].join(':')\n          a1 << ':' + response[:authzid] unless response[:authzid].nil?\n\n          a2 = \"AUTHENTICATE:\" + response[:'digest-uri']\n          a2 << \":00000000000000000000000000000000\" if response[:qop] and response[:qop] =~ /^auth-(?:conf|int)$/\n\n          response[:response] = Digest::MD5.hexdigest(\n            [\n             Digest::MD5.hexdigest(a1),\n             response.values_at(:nonce, :nc, :cnonce, :qop),\n             Digest::MD5.hexdigest(a2)\n            ].join(':')\n          )\n\n          return response.keys.map {|key| qdval(key.to_s, response[key]) }.join(',')\n        when STAGE_TWO\n          @stage = nil\n          # if at the second stage, return an empty string\n          if challenge =~ /rspauth=/\n            return ''\n          else\n            raise ResponseParseError, challenge\n          end\n        else\n          raise ResponseParseError, challenge\n        end\n      end\n\n      def initialize(user, password, authname = nil)\n        @user, @password, @authname = user, password, authname\n        @nc, @stage = {}, STAGE_ONE\n      end\n\n      private\n\n      STAGE_ONE = :stage_one\n      STAGE_TWO = :stage_two\n\n      def nc(nonce)\n        if @nc.has_key? nonce\n          @nc[nonce] = @nc[nonce] + 1\n        else\n          @nc[nonce] = 1\n        end\n        return @nc[nonce]\n      end\n\n      # some responses need quoting\n      def qdval(k, v)\n        return if k.nil? or v.nil?\n        if %w\"username authzid realm nonce cnonce digest-uri qop\".include? k\n          v.gsub!(/([\\\\\"])/, \"\\\\\\1\")\n          return '%s=\"%s\"' % [k, v]\n        else\n          return '%s=%s' % [k, v]\n        end\n      end\n    end\n    add_authenticator \"DIGEST-MD5\", DigestMD5Authenticator\n\n    # Superclass of IMAP errors.\n    class Error < StandardError\n    end\n\n    # Error raised when data is in the incorrect format.\n    class DataFormatError < Error\n    end\n\n    # Error raised when a response from the server is non-parseable.\n    class ResponseParseError < Error\n    end\n\n    # Superclass of all errors used to encapsulate \"fail\" responses\n    # from the server.\n    class ResponseError < Error\n\n      # The response that caused this error\n      attr_accessor :response\n\n      def initialize(response)\n        @response = response\n\n        super @response.data.text\n      end\n\n    end\n\n    # Error raised upon a \"NO\" response from the server, indicating\n    # that the client command could not be completed successfully.\n    class NoResponseError < ResponseError\n    end\n\n    # Error raised upon a \"BAD\" response from the server, indicating\n    # that the client command violated the IMAP protocol, or an internal\n    # server failure has occurred.\n    class BadResponseError < ResponseError\n    end\n\n    # Error raised upon a \"BYE\" response from the server, indicating\n    # that the client is not being allowed to login, or has been timed\n    # out due to inactivity.\n    class ByeResponseError < ResponseError\n    end\n\n    # Error raised upon an unknown response from the server.\n    class UnknownResponseError < ResponseError\n    end\n\n    RESPONSE_ERRORS = Hash.new(ResponseError)\n    RESPONSE_ERRORS[\"NO\"] = NoResponseError\n    RESPONSE_ERRORS[\"BAD\"] = BadResponseError\n\n    # Error raised when too many flags are interned to symbols.\n    class FlagCountError < Error\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"net/imap\"\nrequire \"test/unit\"\n\nclass IMAPTest < Test::Unit::TestCase\n  CA_FILE = File.expand_path(\"../fixtures/cacert.pem\", __dir__)\n  SERVER_KEY = File.expand_path(\"../fixtures/server.key\", __dir__)\n  SERVER_CERT = File.expand_path(\"../fixtures/server.crt\", __dir__)\n\n  def setup\n    @do_not_reverse_lookup = Socket.do_not_reverse_lookup\n    Socket.do_not_reverse_lookup = true\n    @threads = []\n  end\n\n  def teardown\n    if !@threads.empty?\n      assert_join_threads(@threads)\n    end\n  ensure\n    Socket.do_not_reverse_lookup = @do_not_reverse_lookup\n  end\n\n  def test_encode_utf7\n    assert_equal(\"foo\", Net::IMAP.encode_utf7(\"foo\"))\n    assert_equal(\"&-\", Net::IMAP.encode_utf7(\"&\"))\n\n    utf8 = \"\\357\\274\\241\\357\\274\\242\\357\\274\\243\".dup.force_encoding(\"UTF-8\")\n    s = Net::IMAP.encode_utf7(utf8)\n    assert_equal(\"&,yH,Iv8j-\", s)\n    s = Net::IMAP.encode_utf7(\"foo&#{utf8}-bar\".encode(\"EUC-JP\"))\n    assert_equal(\"foo&-&,yH,Iv8j--bar\", s)\n\n    utf8 = \"\\343\\201\\202&\".dup.force_encoding(\"UTF-8\")\n    s = Net::IMAP.encode_utf7(utf8)\n    assert_equal(\"&MEI-&-\", s)\n    s = Net::IMAP.encode_utf7(utf8.encode(\"EUC-JP\"))\n    assert_equal(\"&MEI-&-\", s)\n  end\n\n  def test_decode_utf7\n    assert_equal(\"&\", Net::IMAP.decode_utf7(\"&-\"))\n    assert_equal(\"&-\", Net::IMAP.decode_utf7(\"&--\"))\n\n    s = Net::IMAP.decode_utf7(\"&,yH,Iv8j-\")\n    utf8 = \"\\357\\274\\241\\357\\274\\242\\357\\274\\243\".dup.force_encoding(\"UTF-8\")\n    assert_equal(utf8, s)\n  end\n\n  def test_format_date\n    time = Time.mktime(2009, 7, 24)\n    s = Net::IMAP.format_date(time)\n    assert_equal(\"24-Jul-2009\", s)\n  end\n\n  def test_format_datetime\n    time = Time.mktime(2009, 7, 24, 1, 23, 45)\n    s = Net::IMAP.format_datetime(time)\n    assert_match(/\\A24-Jul-2009 01:23 [+\\-]\\d{4}\\z/, s)\n  end\n\n  if defined?(OpenSSL::SSL::SSLError)\n    def test_imaps_unknown_ca\n      assert_raise(OpenSSL::SSL::SSLError) do\n        imaps_test do |port|\n          begin\n            Net::IMAP.new(\"localhost\",\n                          :port => port,\n                          :ssl => true)\n          rescue SystemCallError\n            skip $!\n          end\n        end\n      end\n    end\n\n    def test_imaps_with_ca_file\n      assert_nothing_raised do\n        imaps_test do |port|\n          begin\n            Net::IMAP.new(\"localhost\",\n                          :port => port,\n                          :ssl => { :ca_file => CA_FILE })\n          rescue SystemCallError\n            skip $!\n          end\n        end\n      end\n    end\n\n    def test_imaps_verify_none\n      assert_nothing_raised do\n        imaps_test do |port|\n          Net::IMAP.new(server_addr,\n                        :port => port,\n                        :ssl => { :verify_mode => OpenSSL::SSL::VERIFY_NONE })\n        end\n      end\n    end\n\n    def test_imaps_post_connection_check\n      assert_raise(OpenSSL::SSL::SSLError) do\n        imaps_test do |port|\n          # server_addr is different from the hostname in the certificate,\n          # so the following code should raise a SSLError.\n          Net::IMAP.new(server_addr,\n                        :port => port,\n                        :ssl => { :ca_file => CA_FILE })\n        end\n      end\n    end\n  end\n\n  if defined?(OpenSSL::SSL)\n    def test_starttls\n      imap = nil\n      starttls_test do |port|\n        imap = Net::IMAP.new(\"localhost\", :port => port)\n        imap.starttls(:ca_file => CA_FILE)\n        imap\n      end\n    rescue SystemCallError\n      skip $!\n    ensure\n      if imap && !imap.disconnected?\n        imap.disconnect\n      end\n    end\n\n    def test_starttls_stripping\n      starttls_stripping_test do |port|\n        imap = Net::IMAP.new(\"localhost\", :port => port)\n        assert_raise(Net::IMAP::UnknownResponseError) do\n          imap.starttls(:ca_file => CA_FILE)\n        end\n        imap\n      end\n    end\n  end\n\n  def start_server\n    th = Thread.new do\n      yield\n    end\n    @threads << th\n    sleep 0.1 until th.stop?\n  end\n\n  def test_unexpected_eof\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n#       sock.print(\"* BYE terminating connection\\r\\n\")\n#       sock.print(\"RUBY0001 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(EOFError) do\n        imap.logout\n      end\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_idle\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"+ idling\\r\\n\")\n        sock.print(\"* 3 EXISTS\\r\\n\")\n        sock.print(\"* 2 EXPUNGE\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 OK IDLE terminated\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      responses = []\n      imap.idle do |res|\n        responses.push(res)\n        if res.name == \"EXPUNGE\"\n          imap.idle_done\n        end\n      end\n      assert_equal(3, responses.length)\n      assert_instance_of(Net::IMAP::ContinuationRequest, responses[0])\n      assert_equal(\"EXISTS\", responses[1].name)\n      assert_equal(3, responses[1].data)\n      assert_equal(\"EXPUNGE\", responses[2].name)\n      assert_equal(2, responses[2].data)\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0001 IDLE\\r\\n\", requests[0])\n      assert_equal(\"DONE\\r\\n\", requests[1])\n      imap.logout\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_exception_during_idle\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"+ idling\\r\\n\")\n        sock.print(\"* 3 EXISTS\\r\\n\")\n        sock.print(\"* 2 EXPUNGE\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 OK IDLE terminated\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      begin\n        th = Thread.current\n        m = Monitor.new\n        in_idle = false\n        exception_raised = false\n        c = m.new_cond\n        raiser = Thread.start do\n          m.synchronize do\n            until in_idle\n              c.wait(0.1)\n            end\n          end\n          th.raise(Interrupt)\n          m.synchronize do\n            exception_raised = true\n            c.signal\n          end\n        end\n        @threads << raiser\n        imap.idle do |res|\n          m.synchronize do\n            in_idle = true\n            c.signal\n            until exception_raised\n              c.wait(0.1)\n            end\n          end\n        end\n      rescue Interrupt\n      end\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0001 IDLE\\r\\n\", requests[0])\n      assert_equal(\"DONE\\r\\n\", requests[1])\n      imap.logout\n    ensure\n      imap.disconnect if imap\n      raiser.kill unless in_idle\n    end\n  end\n\n  def test_idle_done_not_during_idle\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(Net::IMAP::Error) do\n        imap.idle_done\n      end\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_idle_timeout\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"+ idling\\r\\n\")\n        sock.print(\"* 3 EXISTS\\r\\n\")\n        sock.print(\"* 2 EXPUNGE\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 OK IDLE terminated\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      responses = []\n      Thread.pass\n      imap.idle(0.2) do |res|\n        responses.push(res)\n      end\n      # There is no guarantee that this thread has received all the responses,\n      # so check the response length.\n      if responses.length > 0\n        assert_instance_of(Net::IMAP::ContinuationRequest, responses[0])\n        if responses.length > 1\n          assert_equal(\"EXISTS\", responses[1].name)\n          assert_equal(3, responses[1].data)\n          if responses.length > 2\n            assert_equal(\"EXPUNGE\", responses[2].name)\n            assert_equal(2, responses[2].data)\n          end\n        end\n      end\n      # Also, there is no guarantee that the server thread has stored\n      # all the requests into the array, so check the length.\n      if requests.length > 0\n        assert_equal(\"RUBY0001 IDLE\\r\\n\", requests[0])\n        if requests.length > 1\n          assert_equal(\"DONE\\r\\n\", requests[1])\n        end\n      end\n      imap.logout\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_unexpected_bye\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK Gimap ready for requests from 75.101.246.151 33if2752585qyk.26\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE System Error 33if2752585qyk.26\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(Net::IMAP::ByeResponseError) do\n        imap.login(\"user\", \"password\")\n      end\n    end\n  end\n\n  def test_exception_during_shutdown\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0001 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      imap.instance_eval do\n        def @sock.shutdown(*args)\n          super\n        ensure\n          raise \"error\"\n        end\n      end\n      imap.logout\n    ensure\n      assert_raise(RuntimeError) do\n        imap.disconnect\n      end\n    end\n  end\n\n  def test_connection_closed_during_idle\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    sock = nil\n    threads = []\n    started = false\n    threads << Thread.start do\n      started = true\n      begin\n        sock = server.accept\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"+ idling\\r\\n\")\n      rescue IOError # sock is closed by another thread\n      ensure\n        server.close\n      end\n    end\n    sleep 0.1 until started\n    threads << Thread.start do\n      imap = Net::IMAP.new(server_addr, :port => port)\n      begin\n        m = Monitor.new\n        in_idle = false\n        closed = false\n        c = m.new_cond\n        threads << Thread.start do\n          m.synchronize do\n            until in_idle\n              c.wait(0.1)\n            end\n          end\n          sock.close\n          m.synchronize do\n            closed = true\n            c.signal\n          end\n        end\n        assert_raise(EOFError) do\n          imap.idle do |res|\n            m.synchronize do\n              in_idle = true\n              c.signal\n              until closed\n                c.wait(0.1)\n              end\n            end\n          end\n        end\n        assert_equal(1, requests.length)\n        assert_equal(\"RUBY0001 IDLE\\r\\n\", requests[0])\n      ensure\n        imap.disconnect if imap\n      end\n    end\n    assert_join_threads(threads)\n  ensure\n    if sock && !sock.closed?\n      sock.close\n    end\n  end\n\n  def test_connection_closed_without_greeting\n    server = create_tcp_server\n    port = server.addr[1]\n    h = {'server before close': server.inspect} # inspect info before close\n    start_server do\n      begin\n        sock = server.accept\n        h[:sock_addr], h[:sock_peeraddr] = sock.addr, sock.peeraddr\n        sock.close\n      ensure\n        server.close\n      end\n    end\n    assert_raise(Net::IMAP::Error) do\n      #begin\n      Net::IMAP.new(server_addr, :port => port)\n      #rescue Net::IMAP::Error\n      #  raise Errno::EINVAL\n      #end\n    rescue Errno::EINVAL => e # for debug on OpenCSW\n      h.merge!({e: e, server: server, port: port, server_addr: server_addr})\n      raise(h.inspect)\n    end\n  end\n\n  def test_default_port\n    assert_equal(143, Net::IMAP.default_port)\n    assert_equal(143, Net::IMAP.default_imap_port)\n    assert_equal(993, Net::IMAP.default_tls_port)\n    assert_equal(993, Net::IMAP.default_ssl_port)\n    assert_equal(993, Net::IMAP.default_imaps_port)\n  end\n\n  def test_send_invalid_number\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0001 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0002 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0003 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0004 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0005 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", -1)\n      end\n      imap.send(:send_command, \"TEST\", 0)\n      imap.send(:send_command, \"TEST\", 4294967295)\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", 4294967296)\n      end\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(-1))\n      end\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(0))\n      end\n      imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(1))\n      imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(4294967295))\n      assert_raise(Net::IMAP::DataFormatError) do\n        imap.send(:send_command, \"TEST\", Net::IMAP::MessageSet.new(4294967296))\n      end\n      imap.logout\n    ensure\n      imap.disconnect\n    end\n  end\n\n  def test_send_literal\n    server = create_tcp_server\n    port = server.addr[1]\n    requests = []\n    literal = nil\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        line = sock.gets\n        requests.push(line)\n        size = line.slice(/{(\\d+)}\\r\\n/, 1).to_i\n        sock.print(\"+ Ready for literal data\\r\\n\")\n        literal = sock.read(size)\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 OK TEST completed\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      imap.send(:send_command, \"TEST\", [\"\\xDE\\xAD\\xBE\\xEF\".b])\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0001 TEST ({4}\\r\\n\", requests[0])\n      assert_equal(\"\\xDE\\xAD\\xBE\\xEF\".b, literal)\n      assert_equal(\")\\r\\n\", requests[1])\n      imap.logout\n    ensure\n      imap.disconnect\n    end\n  end\n\n  def test_disconnect\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0001 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      imap.logout\n      imap.disconnect\n      assert_equal(true, imap.disconnected?)\n      imap.disconnect\n      assert_equal(true, imap.disconnected?)\n    ensure\n      imap.disconnect if imap && !imap.disconnected?\n    end\n  end\n\n  def test_append\n    server = create_tcp_server\n    port = server.addr[1]\n    mail = <<EOF.gsub(/\\n/, \"\\r\\n\")\nFrom: shugo@example.com\nTo: matz@example.com\nSubject: hello\n\nhello world\nEOF\n    requests = []\n    received_mail = nil\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        line = sock.gets\n        requests.push(line)\n        size = line.slice(/{(\\d+)}\\r\\n/, 1).to_i\n        sock.print(\"+ Ready for literal data\\r\\n\")\n        received_mail = sock.read(size)\n        sock.gets\n        sock.print(\"RUBY0001 OK APPEND completed\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      imap.append(\"INBOX\", mail)\n      assert_equal(1, requests.length)\n      assert_equal(\"RUBY0001 APPEND INBOX {#{mail.size}}\\r\\n\", requests[0])\n      assert_equal(mail, received_mail)\n      imap.logout\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0002 LOGOUT\\r\\n\", requests[1])\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  def test_append_fail\n    server = create_tcp_server\n    port = server.addr[1]\n    mail = <<EOF.gsub(/\\n/, \"\\r\\n\")\nFrom: shugo@example.com\nTo: matz@example.com\nSubject: hello\n\nhello world\nEOF\n    requests = []\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"RUBY0001 NO Mailbox doesn't exist\\r\\n\")\n        requests.push(sock.gets)\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n\n    begin\n      imap = Net::IMAP.new(server_addr, :port => port)\n      assert_raise(Net::IMAP::NoResponseError) do\n        imap.append(\"INBOX\", mail)\n      end\n      assert_equal(1, requests.length)\n      assert_equal(\"RUBY0001 APPEND INBOX {#{mail.size}}\\r\\n\", requests[0])\n      imap.logout\n      assert_equal(2, requests.length)\n      assert_equal(\"RUBY0002 LOGOUT\\r\\n\", requests[1])\n    ensure\n      imap.disconnect if imap\n    end\n  end\n\n  private\n\n  def imaps_test\n    server = create_tcp_server\n    port = server.addr[1]\n    ctx = OpenSSL::SSL::SSLContext.new\n    ctx.ca_file = CA_FILE\n    ctx.key = File.open(SERVER_KEY) { |f|\n      OpenSSL::PKey::RSA.new(f)\n    }\n    ctx.cert = File.open(SERVER_CERT) { |f|\n      OpenSSL::X509::Certificate.new(f)\n    }\n    ssl_server = OpenSSL::SSL::SSLServer.new(server, ctx)\n    started = false\n    ths = Thread.start do\n      Thread.current.report_on_exception = false # always join-ed\n      begin\n        started = true\n        sock = ssl_server.accept\n        begin\n          sock.print(\"* OK test server\\r\\n\")\n          sock.gets\n          sock.print(\"* BYE terminating connection\\r\\n\")\n          sock.print(\"RUBY0001 OK LOGOUT completed\\r\\n\")\n        ensure\n          sock.close\n        end\n      rescue Errno::EPIPE, Errno::ECONNRESET, Errno::ECONNABORTED\n      end\n    end\n    sleep 0.1 until started\n    begin\n      begin\n        imap = yield(port)\n        imap.logout\n      ensure\n        imap.disconnect if imap\n      end\n    ensure\n      ssl_server.close\n      ths.join\n    end\n  end\n\n  def starttls_test\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0001 OK completed\\r\\n\")\n        ctx = OpenSSL::SSL::SSLContext.new\n        ctx.ca_file = CA_FILE\n        ctx.key = File.open(SERVER_KEY) { |f|\n          OpenSSL::PKey::RSA.new(f)\n        }\n        ctx.cert = File.open(SERVER_CERT) { |f|\n          OpenSSL::X509::Certificate.new(f)\n        }\n        sock = OpenSSL::SSL::SSLSocket.new(sock, ctx)\n        sock.sync_close = true\n        sock.accept\n        sock.gets\n        sock.print(\"* BYE terminating connection\\r\\n\")\n        sock.print(\"RUBY0002 OK LOGOUT completed\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = yield(port)\n      imap.logout if !imap.disconnected?\n    ensure\n      imap.disconnect if imap && !imap.disconnected?\n    end\n  end\n\n  def starttls_stripping_test\n    server = create_tcp_server\n    port = server.addr[1]\n    start_server do\n      sock = server.accept\n      begin\n        sock.print(\"* OK test server\\r\\n\")\n        sock.gets\n        sock.print(\"RUBY0001 BUG unhandled command\\r\\n\")\n      ensure\n        sock.close\n        server.close\n      end\n    end\n    begin\n      imap = yield(port)\n    ensure\n      imap.disconnect if imap && !imap.disconnected?\n    end\n  end\n\n  def create_tcp_server\n    return TCPServer.new(server_addr, 0)\n  end\n\n  def server_addr\n    Addrinfo.tcp(\"localhost\", 0).ip_address\n  end\nend\n", "# define RUBY_VERSION_MAJOR RUBY_API_VERSION_MAJOR\n# define RUBY_VERSION_MINOR RUBY_API_VERSION_MINOR\n#define RUBY_VERSION_TEENY 4\n#define RUBY_RELEASE_DATE RUBY_RELEASE_YEAR_STR\"-\"RUBY_RELEASE_MONTH_STR\"-\"RUBY_RELEASE_DAY_STR\n#define RUBY_PATCHLEVEL 191\n\n#define RUBY_RELEASE_YEAR 2021\n#define RUBY_RELEASE_MONTH 7\n#define RUBY_RELEASE_DAY 7\n\n#include \"ruby/version.h\"\n\n#ifndef TOKEN_PASTE\n#define TOKEN_PASTE(x,y) x##y\n#endif\n#define ONLY_ONE_DIGIT(x) TOKEN_PASTE(10,x) < 1000\n#define WITH_ZERO_PADDING(x) TOKEN_PASTE(0,x)\n#define RUBY_BIRTH_YEAR_STR STRINGIZE(RUBY_BIRTH_YEAR)\n#define RUBY_RELEASE_YEAR_STR STRINGIZE(RUBY_RELEASE_YEAR)\n#if ONLY_ONE_DIGIT(RUBY_RELEASE_MONTH)\n#define RUBY_RELEASE_MONTH_STR STRINGIZE(WITH_ZERO_PADDING(RUBY_RELEASE_MONTH))\n#else\n#define RUBY_RELEASE_MONTH_STR STRINGIZE(RUBY_RELEASE_MONTH)\n#endif\n#if ONLY_ONE_DIGIT(RUBY_RELEASE_DAY)\n#define RUBY_RELEASE_DAY_STR STRINGIZE(WITH_ZERO_PADDING(RUBY_RELEASE_DAY))\n#else\n#define RUBY_RELEASE_DAY_STR STRINGIZE(RUBY_RELEASE_DAY)\n#endif\n\n#if !defined RUBY_LIB_VERSION && defined RUBY_LIB_VERSION_STYLE\n# if RUBY_LIB_VERSION_STYLE == 3\n#   define RUBY_LIB_VERSION STRINGIZE(RUBY_API_VERSION_MAJOR)\".\"STRINGIZE(RUBY_API_VERSION_MINOR)\".\"STRINGIZE(RUBY_API_VERSION_TEENY)\n# elif RUBY_LIB_VERSION_STYLE == 2\n#   define RUBY_LIB_VERSION STRINGIZE(RUBY_API_VERSION_MAJOR)\".\"STRINGIZE(RUBY_API_VERSION_MINOR)\n# endif\n#endif\n\n#if RUBY_PATCHLEVEL == -1\n#define RUBY_PATCHLEVEL_STR \"dev\"\n#else\n#define RUBY_PATCHLEVEL_STR \"p\"STRINGIZE(RUBY_PATCHLEVEL)\n#endif\n\n#ifndef RUBY_REVISION\n# include \"revision.h\"\n#endif\n\n#ifdef RUBY_REVISION\n# if RUBY_PATCHLEVEL == -1\n#  ifndef RUBY_BRANCH_NAME\n#   define RUBY_BRANCH_NAME \"master\"\n#  endif\n#  define RUBY_REVISION_STR \" \"RUBY_BRANCH_NAME\" \"RUBY_REVISION\n# else\n#  define RUBY_REVISION_STR \" revision \"RUBY_REVISION\n# endif\n#else\n# define RUBY_REVISION \"HEAD\"\n# define RUBY_REVISION_STR \"\"\n#endif\n#if !defined RUBY_RELEASE_DATETIME || RUBY_PATCHLEVEL != -1\n# undef RUBY_RELEASE_DATETIME\n# define RUBY_RELEASE_DATETIME RUBY_RELEASE_DATE\n#endif\n\n# define RUBY_DESCRIPTION_WITH(opt) \\\n    \"ruby \"RUBY_VERSION\t\t    \\\n    RUBY_PATCHLEVEL_STR\t\t    \\\n    \" (\"RUBY_RELEASE_DATETIME\t    \\\n    RUBY_REVISION_STR\")\"opt\" \"\t    \\\n    \"[\"RUBY_PLATFORM\"]\"\n# define RUBY_COPYRIGHT\t\t    \\\n    \"ruby - Copyright (C) \"\t    \\\n    RUBY_BIRTH_YEAR_STR\"-\"   \\\n    RUBY_RELEASE_YEAR_STR\" \" \\\n    RUBY_AUTHOR\n"], "filenames": ["lib/net/imap.rb", "test/net/imap/test_imap.rb", "version.h"], "buggy_code_start_loc": [1218, 127, 5], "buggy_code_end_loc": [3719, 786, 6], "fixing_code_start_loc": [1219, 128, 5], "fixing_code_end_loc": [3726, 818, 6], "type": "CWE-326", "message": "An issue was discovered in Ruby through 2.6.7, 2.7.x through 2.7.3, and 3.x through 3.0.1. Net::IMAP does not raise an exception when StartTLS fails with an an unknown response, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"", "other": {"cve": {"id": "CVE-2021-32066", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-01T19:15:07.697", "lastModified": "2023-04-30T23:15:45.157", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in Ruby through 2.6.7, 2.7.x through 2.7.3, and 3.x through 3.0.1. Net::IMAP does not raise an exception when StartTLS fails with an an unknown response, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\""}, {"lang": "es", "value": "Se ha detectado un problema en Ruby versiones hasta 2.6.7, versiones 2.7.x hasta 2.7.3, y versiones 3.x hasta 3.0.1. Net::IMAP no lanza una excepci\u00f3n cuando StartTLS falla con una respuesta desconocida, lo que podr\u00eda permitir a atacantes tipo man-in-the-middle omitir las protecciones TLS, al aprovechar una posici\u00f3n de red entre el cliente y el registro para bloquear el comando StartTLS, tambi\u00e9n se conoce como \"StartTLS stripping attack\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-326"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndIncluding": "2.6.7", "matchCriteriaId": "45D6E5FE-D60E-41D3-9FCA-00F8218377EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndIncluding": "2.7.3", "matchCriteriaId": "D29D5386-D306-4CB4-82EC-678319F0101D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndIncluding": "3.0.1", "matchCriteriaId": "528E25B8-22A4-4AAF-9582-76BCDF3705B5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jd_edwards_enterpriseone_tools:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.6.1", "matchCriteriaId": "D1298AA2-0103-4457-B260-F976B78468E7"}]}]}], "references": [{"url": "https://github.com/ruby/ruby/commit/a21a3b7d23704a01d34bd79d09dc37897e00922a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/1178562", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/10/msg00009.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/04/msg00033.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20210902-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.ruby-lang.org/en/news/2021/07/07/starttls-stripping-in-net-imap/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ruby/ruby/commit/a21a3b7d23704a01d34bd79d09dc37897e00922a"}}