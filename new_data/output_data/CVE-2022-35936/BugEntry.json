{"buggy_code": ["package keeper\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/cosmos/cosmos-sdk/store/prefix\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\tethermint \"github.com/evmos/ethermint/types\"\n\t\"github.com/evmos/ethermint/x/evm/statedb\"\n\t\"github.com/evmos/ethermint/x/evm/types\"\n)\n\nvar _ statedb.Keeper = &Keeper{}\n\n// ----------------------------------------------------------------------------\n// StateDB Keeper implementation\n// ----------------------------------------------------------------------------\n\n// GetAccount returns nil if account is not exist, returns error if it's not `EthAccountI`\nfunc (k *Keeper) GetAccount(ctx sdk.Context, addr common.Address) *statedb.Account {\n\tacct := k.GetAccountWithoutBalance(ctx, addr)\n\tif acct == nil {\n\t\treturn nil\n\t}\n\n\tacct.Balance = k.GetBalance(ctx, addr)\n\treturn acct\n}\n\n// GetState loads contract state from database, implements `statedb.Keeper` interface.\nfunc (k *Keeper) GetState(ctx sdk.Context, addr common.Address, key common.Hash) common.Hash {\n\tstore := prefix.NewStore(ctx.KVStore(k.storeKey), types.AddressStoragePrefix(addr))\n\n\tvalue := store.Get(key.Bytes())\n\tif len(value) == 0 {\n\t\treturn common.Hash{}\n\t}\n\n\treturn common.BytesToHash(value)\n}\n\n// GetCode loads contract code from database, implements `statedb.Keeper` interface.\nfunc (k *Keeper) GetCode(ctx sdk.Context, codeHash common.Hash) []byte {\n\tstore := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefixCode)\n\treturn store.Get(codeHash.Bytes())\n}\n\n// ForEachStorage iterate contract storage, callback return false to break early\nfunc (k *Keeper) ForEachStorage(ctx sdk.Context, addr common.Address, cb func(key, value common.Hash) bool) {\n\tstore := ctx.KVStore(k.storeKey)\n\tprefix := types.AddressStoragePrefix(addr)\n\n\titerator := sdk.KVStorePrefixIterator(store, prefix)\n\tdefer iterator.Close()\n\n\tfor ; iterator.Valid(); iterator.Next() {\n\t\tkey := common.BytesToHash(iterator.Key())\n\t\tvalue := common.BytesToHash(iterator.Value())\n\n\t\t// check if iteration stops\n\t\tif !cb(key, value) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// SetBalance update account's balance, compare with current balance first, then decide to mint or burn.\nfunc (k *Keeper) SetBalance(ctx sdk.Context, addr common.Address, amount *big.Int) error {\n\tcosmosAddr := sdk.AccAddress(addr.Bytes())\n\n\tparams := k.GetParams(ctx)\n\tcoin := k.bankKeeper.GetBalance(ctx, cosmosAddr, params.EvmDenom)\n\tbalance := coin.Amount.BigInt()\n\tdelta := new(big.Int).Sub(amount, balance)\n\tswitch delta.Sign() {\n\tcase 1:\n\t\t// mint\n\t\tcoins := sdk.NewCoins(sdk.NewCoin(params.EvmDenom, sdk.NewIntFromBigInt(delta)))\n\t\tif err := k.bankKeeper.MintCoins(ctx, types.ModuleName, coins); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, cosmosAddr, coins); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase -1:\n\t\t// burn\n\t\tcoins := sdk.NewCoins(sdk.NewCoin(params.EvmDenom, sdk.NewIntFromBigInt(new(big.Int).Neg(delta))))\n\t\tif err := k.bankKeeper.SendCoinsFromAccountToModule(ctx, cosmosAddr, types.ModuleName, coins); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := k.bankKeeper.BurnCoins(ctx, types.ModuleName, coins); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\t// not changed\n\t}\n\treturn nil\n}\n\n// SetAccount updates nonce/balance/codeHash together.\nfunc (k *Keeper) SetAccount(ctx sdk.Context, addr common.Address, account statedb.Account) error {\n\t// update account\n\tcosmosAddr := sdk.AccAddress(addr.Bytes())\n\tacct := k.accountKeeper.GetAccount(ctx, cosmosAddr)\n\tif acct == nil {\n\t\tacct = k.accountKeeper.NewAccountWithAddress(ctx, cosmosAddr)\n\t}\n\n\tif err := acct.SetSequence(account.Nonce); err != nil {\n\t\treturn err\n\t}\n\n\tcodeHash := common.BytesToHash(account.CodeHash)\n\n\tif ethAcct, ok := acct.(ethermint.EthAccountI); ok {\n\t\tif err := ethAcct.SetCodeHash(codeHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tk.accountKeeper.SetAccount(ctx, acct)\n\n\tif err := k.SetBalance(ctx, addr, account.Balance); err != nil {\n\t\treturn err\n\t}\n\n\tk.Logger(ctx).Debug(\n\t\t\"account updated\",\n\t\t\"ethereum-address\", addr.Hex(),\n\t\t\"nonce\", account.Nonce,\n\t\t\"codeHash\", codeHash.Hex(),\n\t\t\"balance\", account.Balance,\n\t)\n\treturn nil\n}\n\n// SetState update contract storage, delete if value is empty.\nfunc (k *Keeper) SetState(ctx sdk.Context, addr common.Address, key common.Hash, value []byte) {\n\tstore := prefix.NewStore(ctx.KVStore(k.storeKey), types.AddressStoragePrefix(addr))\n\taction := \"updated\"\n\tif len(value) == 0 {\n\t\tstore.Delete(key.Bytes())\n\t\taction = \"deleted\"\n\t} else {\n\t\tstore.Set(key.Bytes(), value)\n\t}\n\tk.Logger(ctx).Debug(\n\t\tfmt.Sprintf(\"state %s\", action),\n\t\t\"ethereum-address\", addr.Hex(),\n\t\t\"key\", key.Hex(),\n\t)\n}\n\n// SetCode set contract code, delete if code is empty.\nfunc (k *Keeper) SetCode(ctx sdk.Context, codeHash, code []byte) {\n\tstore := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefixCode)\n\n\t// store or delete code\n\taction := \"updated\"\n\tif len(code) == 0 {\n\t\tstore.Delete(codeHash)\n\t\taction = \"deleted\"\n\t} else {\n\t\tstore.Set(codeHash, code)\n\t}\n\tk.Logger(ctx).Debug(\n\t\tfmt.Sprintf(\"code %s\", action),\n\t\t\"code-hash\", common.BytesToHash(codeHash).Hex(),\n\t)\n}\n\n// DeleteAccount handles contract's suicide call:\n// - clear balance\n// - remove code\n// - remove states\n// - remove auth account\nfunc (k *Keeper) DeleteAccount(ctx sdk.Context, addr common.Address) error {\n\tcosmosAddr := sdk.AccAddress(addr.Bytes())\n\tacct := k.accountKeeper.GetAccount(ctx, cosmosAddr)\n\tif acct == nil {\n\t\treturn nil\n\t}\n\n\t// NOTE: only Ethereum accounts (contracts) can be selfdestructed\n\tethAcct, ok := acct.(ethermint.EthAccountI)\n\tif !ok {\n\t\treturn sdkerrors.Wrapf(types.ErrInvalidAccount, \"type %T, address %s\", acct, addr)\n\t}\n\n\t// clear balance\n\tif err := k.SetBalance(ctx, addr, new(big.Int)); err != nil {\n\t\treturn err\n\t}\n\n\t// remove code\n\tcodeHashBz := ethAcct.GetCodeHash().Bytes()\n\tif !bytes.Equal(codeHashBz, types.EmptyCodeHash) {\n\t\tk.SetCode(ctx, codeHashBz, nil)\n\t}\n\n\t// clear storage\n\tk.ForEachStorage(ctx, addr, func(key, _ common.Hash) bool {\n\t\tk.SetState(ctx, addr, key, nil)\n\t\treturn true\n\t})\n\n\t// remove auth account\n\tk.accountKeeper.RemoveAccount(ctx, acct)\n\n\tk.Logger(ctx).Debug(\n\t\t\"account suicided\",\n\t\t\"ethereum-address\", addr.Hex(),\n\t\t\"cosmos-address\", cosmosAddr.String(),\n\t)\n\n\treturn nil\n}\n", "package keeper_test\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n\n\tcodectypes \"github.com/cosmos/cosmos-sdk/codec/types\"\n\tcryptotypes \"github.com/cosmos/cosmos-sdk/crypto/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tauthsigning \"github.com/cosmos/cosmos-sdk/x/auth/signing\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/evmos/ethermint/tests\"\n\t\"github.com/evmos/ethermint/x/evm/statedb\"\n\t\"github.com/evmos/ethermint/x/evm/types\"\n)\n\nfunc (suite *KeeperTestSuite) TestCreateAccount() {\n\ttestCases := []struct {\n\t\tname     string\n\t\taddr     common.Address\n\t\tmalleate func(vm.StateDB, common.Address)\n\t\tcallback func(vm.StateDB, common.Address)\n\t}{\n\t\t{\n\t\t\t\"reset account (keep balance)\",\n\t\t\tsuite.address,\n\t\t\tfunc(vmdb vm.StateDB, addr common.Address) {\n\t\t\t\tvmdb.AddBalance(addr, big.NewInt(100))\n\t\t\t\tsuite.Require().NotZero(vmdb.GetBalance(addr).Int64())\n\t\t\t},\n\t\t\tfunc(vmdb vm.StateDB, addr common.Address) {\n\t\t\t\tsuite.Require().Equal(vmdb.GetBalance(addr).Int64(), int64(100))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"create account\",\n\t\t\ttests.GenerateAddress(),\n\t\t\tfunc(vmdb vm.StateDB, addr common.Address) {\n\t\t\t\tsuite.Require().False(vmdb.Exist(addr))\n\t\t\t},\n\t\t\tfunc(vmdb vm.StateDB, addr common.Address) {\n\t\t\t\tsuite.Require().True(vmdb.Exist(addr))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb, tc.addr)\n\t\t\tvmdb.CreateAccount(tc.addr)\n\t\t\ttc.callback(vmdb, tc.addr)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestAddBalance() {\n\ttestCases := []struct {\n\t\tname   string\n\t\tamount *big.Int\n\t\tisNoOp bool\n\t}{\n\t\t{\n\t\t\t\"positive amount\",\n\t\t\tbig.NewInt(100),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"zero amount\",\n\t\t\tbig.NewInt(0),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"negative amount\",\n\t\t\tbig.NewInt(-1),\n\t\t\tfalse, // seems to be consistent with go-ethereum's implementation\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tprev := vmdb.GetBalance(suite.address)\n\t\t\tvmdb.AddBalance(suite.address, tc.amount)\n\t\t\tpost := vmdb.GetBalance(suite.address)\n\n\t\t\tif tc.isNoOp {\n\t\t\t\tsuite.Require().Equal(prev.Int64(), post.Int64())\n\t\t\t} else {\n\t\t\t\tsuite.Require().Equal(new(big.Int).Add(prev, tc.amount).Int64(), post.Int64())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestSubBalance() {\n\ttestCases := []struct {\n\t\tname     string\n\t\tamount   *big.Int\n\t\tmalleate func(vm.StateDB)\n\t\tisNoOp   bool\n\t}{\n\t\t{\n\t\t\t\"positive amount, below zero\",\n\t\t\tbig.NewInt(100),\n\t\t\tfunc(vm.StateDB) {},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"positive amount, above zero\",\n\t\t\tbig.NewInt(50),\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.AddBalance(suite.address, big.NewInt(100))\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"zero amount\",\n\t\t\tbig.NewInt(0),\n\t\t\tfunc(vm.StateDB) {},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"negative amount\",\n\t\t\tbig.NewInt(-1),\n\t\t\tfunc(vm.StateDB) {},\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tprev := vmdb.GetBalance(suite.address)\n\t\t\tvmdb.SubBalance(suite.address, tc.amount)\n\t\t\tpost := vmdb.GetBalance(suite.address)\n\n\t\t\tif tc.isNoOp {\n\t\t\t\tsuite.Require().Equal(prev.Int64(), post.Int64())\n\t\t\t} else {\n\t\t\t\tsuite.Require().Equal(new(big.Int).Sub(prev, tc.amount).Int64(), post.Int64())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestGetNonce() {\n\ttestCases := []struct {\n\t\tname          string\n\t\taddress       common.Address\n\t\texpectedNonce uint64\n\t\tmalleate      func(vm.StateDB)\n\t}{\n\t\t{\n\t\t\t\"account not found\",\n\t\t\ttests.GenerateAddress(),\n\t\t\t0,\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t\t{\n\t\t\t\"existing account\",\n\t\t\tsuite.address,\n\t\t\t1,\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.SetNonce(suite.address, 1)\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tnonce := vmdb.GetNonce(tc.address)\n\t\t\tsuite.Require().Equal(tc.expectedNonce, nonce)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestSetNonce() {\n\ttestCases := []struct {\n\t\tname     string\n\t\taddress  common.Address\n\t\tnonce    uint64\n\t\tmalleate func()\n\t}{\n\t\t{\n\t\t\t\"new account\",\n\t\t\ttests.GenerateAddress(),\n\t\t\t10,\n\t\t\tfunc() {},\n\t\t},\n\t\t{\n\t\t\t\"existing account\",\n\t\t\tsuite.address,\n\t\t\t99,\n\t\t\tfunc() {},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tvmdb.SetNonce(tc.address, tc.nonce)\n\t\t\tnonce := vmdb.GetNonce(tc.address)\n\t\t\tsuite.Require().Equal(tc.nonce, nonce)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestGetCodeHash() {\n\taddr := tests.GenerateAddress()\n\tbaseAcc := &authtypes.BaseAccount{Address: sdk.AccAddress(addr.Bytes()).String()}\n\tsuite.app.AccountKeeper.SetAccount(suite.ctx, baseAcc)\n\n\ttestCases := []struct {\n\t\tname     string\n\t\taddress  common.Address\n\t\texpHash  common.Hash\n\t\tmalleate func(vm.StateDB)\n\t}{\n\t\t{\n\t\t\t\"account not found\",\n\t\t\ttests.GenerateAddress(),\n\t\t\tcommon.Hash{},\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t\t{\n\t\t\t\"account not EthAccount type, EmptyCodeHash\",\n\t\t\taddr,\n\t\t\tcommon.BytesToHash(types.EmptyCodeHash),\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t\t{\n\t\t\t\"existing account\",\n\t\t\tsuite.address,\n\t\t\tcrypto.Keccak256Hash([]byte(\"codeHash\")),\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.SetCode(suite.address, []byte(\"codeHash\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\thash := vmdb.GetCodeHash(tc.address)\n\t\t\tsuite.Require().Equal(tc.expHash, hash)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestSetCode() {\n\taddr := tests.GenerateAddress()\n\tbaseAcc := &authtypes.BaseAccount{Address: sdk.AccAddress(addr.Bytes()).String()}\n\tsuite.app.AccountKeeper.SetAccount(suite.ctx, baseAcc)\n\n\ttestCases := []struct {\n\t\tname    string\n\t\taddress common.Address\n\t\tcode    []byte\n\t\tisNoOp  bool\n\t}{\n\t\t{\n\t\t\t\"account not found\",\n\t\t\ttests.GenerateAddress(),\n\t\t\t[]byte(\"code\"),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"account not EthAccount type\",\n\t\t\taddr,\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"existing account\",\n\t\t\tsuite.address,\n\t\t\t[]byte(\"code\"),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"existing account, code deleted from store\",\n\t\t\tsuite.address,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tprev := vmdb.GetCode(tc.address)\n\t\t\tvmdb.SetCode(tc.address, tc.code)\n\t\t\tpost := vmdb.GetCode(tc.address)\n\n\t\t\tif tc.isNoOp {\n\t\t\t\tsuite.Require().Equal(prev, post)\n\t\t\t} else {\n\t\t\t\tsuite.Require().Equal(tc.code, post)\n\t\t\t}\n\n\t\t\tsuite.Require().Equal(len(post), vmdb.GetCodeSize(tc.address))\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestRefund() {\n\ttestCases := []struct {\n\t\tname      string\n\t\tmalleate  func(vm.StateDB)\n\t\texpRefund uint64\n\t\texpPanic  bool\n\t}{\n\t\t{\n\t\t\t\"success - add and subtract refund\",\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.AddRefund(11)\n\t\t\t},\n\t\t\t1,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"fail - subtract amount > current refund\",\n\t\t\tfunc(vm.StateDB) {\n\t\t\t},\n\t\t\t0,\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tif tc.expPanic {\n\t\t\t\tsuite.Require().Panics(func() { vmdb.SubRefund(10) })\n\t\t\t} else {\n\t\t\t\tvmdb.SubRefund(10)\n\t\t\t\tsuite.Require().Equal(tc.expRefund, vmdb.GetRefund())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestState() {\n\ttestCases := []struct {\n\t\tname       string\n\t\tkey, value common.Hash\n\t}{\n\t\t{\n\t\t\t\"set state - delete from store\",\n\t\t\tcommon.BytesToHash([]byte(\"key\")),\n\t\t\tcommon.Hash{},\n\t\t},\n\t\t{\n\t\t\t\"set state - update value\",\n\t\t\tcommon.BytesToHash([]byte(\"key\")),\n\t\t\tcommon.BytesToHash([]byte(\"value\")),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tvmdb.SetState(suite.address, tc.key, tc.value)\n\t\t\tvalue := vmdb.GetState(suite.address, tc.key)\n\t\t\tsuite.Require().Equal(tc.value, value)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestCommittedState() {\n\tsuite.SetupTest()\n\n\tkey := common.BytesToHash([]byte(\"key\"))\n\tvalue1 := common.BytesToHash([]byte(\"value1\"))\n\tvalue2 := common.BytesToHash([]byte(\"value2\"))\n\n\tvmdb := suite.StateDB()\n\tvmdb.SetState(suite.address, key, value1)\n\tvmdb.Commit()\n\n\tvmdb = suite.StateDB()\n\tvmdb.SetState(suite.address, key, value2)\n\ttmp := vmdb.GetState(suite.address, key)\n\tsuite.Require().Equal(value2, tmp)\n\ttmp = vmdb.GetCommittedState(suite.address, key)\n\tsuite.Require().Equal(value1, tmp)\n\tvmdb.Commit()\n\n\tvmdb = suite.StateDB()\n\ttmp = vmdb.GetCommittedState(suite.address, key)\n\tsuite.Require().Equal(value2, tmp)\n}\n\nfunc (suite *KeeperTestSuite) TestSuicide() {\n\tcode := []byte(\"code\")\n\tdb := suite.StateDB()\n\t// Add code to account\n\tdb.SetCode(suite.address, code)\n\tsuite.Require().Equal(code, db.GetCode(suite.address))\n\t// Add state to account\n\tfor i := 0; i < 5; i++ {\n\t\tdb.SetState(suite.address, common.BytesToHash([]byte(fmt.Sprintf(\"key%d\", i))), common.BytesToHash([]byte(fmt.Sprintf(\"value%d\", i))))\n\t}\n\n\tsuite.Require().NoError(db.Commit())\n\tdb = suite.StateDB()\n\n\t// Call Suicide\n\tsuite.Require().Equal(true, db.Suicide(suite.address))\n\n\t// Check suicided is marked\n\tsuite.Require().Equal(true, db.HasSuicided(suite.address))\n\n\tsuite.Require().NoError(db.Commit())\n\tdb = suite.StateDB()\n\n\t// Check code is deleted\n\tsuite.Require().Nil(db.GetCode(suite.address))\n\t// Check state is deleted\n\tvar storage types.Storage\n\tsuite.app.EvmKeeper.ForEachStorage(suite.ctx, suite.address, func(key, value common.Hash) bool {\n\t\tstorage = append(storage, types.NewState(key, value))\n\t\treturn true\n\t})\n\tsuite.Require().Equal(0, len(storage))\n\n\t// Check account is deleted\n\tsuite.Require().Equal(common.Hash{}, db.GetCodeHash(suite.address))\n}\n\nfunc (suite *KeeperTestSuite) TestExist() {\n\ttestCases := []struct {\n\t\tname     string\n\t\taddress  common.Address\n\t\tmalleate func(vm.StateDB)\n\t\texists   bool\n\t}{\n\t\t{\"success, account exists\", suite.address, func(vm.StateDB) {}, true},\n\t\t{\"success, has suicided\", suite.address, func(vmdb vm.StateDB) {\n\t\t\tvmdb.Suicide(suite.address)\n\t\t}, true},\n\t\t{\"success, account doesn't exist\", tests.GenerateAddress(), func(vm.StateDB) {}, false},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tsuite.Require().Equal(tc.exists, vmdb.Exist(tc.address))\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestEmpty() {\n\tsuite.SetupTest()\n\n\ttestCases := []struct {\n\t\tname     string\n\t\taddress  common.Address\n\t\tmalleate func(vm.StateDB)\n\t\tempty    bool\n\t}{\n\t\t{\"empty, account exists\", suite.address, func(vm.StateDB) {}, true},\n\t\t{\n\t\t\t\"not empty, positive balance\",\n\t\t\tsuite.address,\n\t\t\tfunc(vmdb vm.StateDB) { vmdb.AddBalance(suite.address, big.NewInt(100)) },\n\t\t\tfalse,\n\t\t},\n\t\t{\"empty, account doesn't exist\", tests.GenerateAddress(), func(vm.StateDB) {}, true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tsuite.Require().Equal(tc.empty, vmdb.Empty(tc.address))\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestSnapshot() {\n\tkey := common.BytesToHash([]byte(\"key\"))\n\tvalue1 := common.BytesToHash([]byte(\"value1\"))\n\tvalue2 := common.BytesToHash([]byte(\"value2\"))\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tmalleate func(vm.StateDB)\n\t}{\n\t\t{\"simple revert\", func(vmdb vm.StateDB) {\n\t\t\trevision := vmdb.Snapshot()\n\t\t\tsuite.Require().Zero(revision)\n\n\t\t\tvmdb.SetState(suite.address, key, value1)\n\t\t\tsuite.Require().Equal(value1, vmdb.GetState(suite.address, key))\n\n\t\t\tvmdb.RevertToSnapshot(revision)\n\n\t\t\t// reverted\n\t\t\tsuite.Require().Equal(common.Hash{}, vmdb.GetState(suite.address, key))\n\t\t}},\n\t\t{\"nested snapshot/revert\", func(vmdb vm.StateDB) {\n\t\t\trevision1 := vmdb.Snapshot()\n\t\t\tsuite.Require().Zero(revision1)\n\n\t\t\tvmdb.SetState(suite.address, key, value1)\n\n\t\t\trevision2 := vmdb.Snapshot()\n\n\t\t\tvmdb.SetState(suite.address, key, value2)\n\t\t\tsuite.Require().Equal(value2, vmdb.GetState(suite.address, key))\n\n\t\t\tvmdb.RevertToSnapshot(revision2)\n\t\t\tsuite.Require().Equal(value1, vmdb.GetState(suite.address, key))\n\n\t\t\tvmdb.RevertToSnapshot(revision1)\n\t\t\tsuite.Require().Equal(common.Hash{}, vmdb.GetState(suite.address, key))\n\t\t}},\n\t\t{\"jump revert\", func(vmdb vm.StateDB) {\n\t\t\trevision1 := vmdb.Snapshot()\n\t\t\tvmdb.SetState(suite.address, key, value1)\n\t\t\tvmdb.Snapshot()\n\t\t\tvmdb.SetState(suite.address, key, value2)\n\t\t\tvmdb.RevertToSnapshot(revision1)\n\t\t\tsuite.Require().Equal(common.Hash{}, vmdb.GetState(suite.address, key))\n\t\t}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tsuite.SetupTest()\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) CreateTestTx(msg *types.MsgEthereumTx, priv cryptotypes.PrivKey) authsigning.Tx {\n\toption, err := codectypes.NewAnyWithValue(&types.ExtensionOptionsEthereumTx{})\n\tsuite.Require().NoError(err)\n\n\ttxBuilder := suite.clientCtx.TxConfig.NewTxBuilder()\n\tbuilder, ok := txBuilder.(authtx.ExtensionOptionsTxBuilder)\n\tsuite.Require().True(ok)\n\n\tbuilder.SetExtensionOptions(option)\n\n\terr = msg.Sign(suite.ethSigner, tests.NewSigner(priv))\n\tsuite.Require().NoError(err)\n\n\terr = txBuilder.SetMsgs(msg)\n\tsuite.Require().NoError(err)\n\n\treturn txBuilder.GetTx()\n}\n\nfunc (suite *KeeperTestSuite) TestAddLog() {\n\taddr, privKey := tests.NewAddrKey()\n\tmsg := types.NewTx(big.NewInt(1), 0, &suite.address, big.NewInt(1), 100000, big.NewInt(1), nil, nil, []byte(\"test\"), nil)\n\tmsg.From = addr.Hex()\n\n\ttx := suite.CreateTestTx(msg, privKey)\n\tmsg, _ = tx.GetMsgs()[0].(*types.MsgEthereumTx)\n\ttxHash := msg.AsTransaction().Hash()\n\n\tmsg2 := types.NewTx(big.NewInt(1), 1, &suite.address, big.NewInt(1), 100000, big.NewInt(1), nil, nil, []byte(\"test\"), nil)\n\tmsg2.From = addr.Hex()\n\n\ttx2 := suite.CreateTestTx(msg2, privKey)\n\tmsg2, _ = tx2.GetMsgs()[0].(*types.MsgEthereumTx)\n\n\tmsg3 := types.NewTx(big.NewInt(1), 0, &suite.address, big.NewInt(1), 100000, nil, big.NewInt(1), big.NewInt(1), []byte(\"test\"), nil)\n\tmsg3.From = addr.Hex()\n\n\ttx3 := suite.CreateTestTx(msg3, privKey)\n\tmsg3, _ = tx3.GetMsgs()[0].(*types.MsgEthereumTx)\n\ttxHash3 := msg3.AsTransaction().Hash()\n\n\tmsg4 := types.NewTx(big.NewInt(1), 1, &suite.address, big.NewInt(1), 100000, nil, big.NewInt(1), big.NewInt(1), []byte(\"test\"), nil)\n\tmsg4.From = addr.Hex()\n\n\ttx4 := suite.CreateTestTx(msg4, privKey)\n\tmsg4, _ = tx4.GetMsgs()[0].(*types.MsgEthereumTx)\n\n\ttestCases := []struct {\n\t\tname        string\n\t\thash        common.Hash\n\t\tlog, expLog *ethtypes.Log // pre and post populating log fields\n\t\tmalleate    func(vm.StateDB)\n\t}{\n\t\t{\n\t\t\t\"tx hash from message\",\n\t\t\ttxHash,\n\t\t\t&ethtypes.Log{\n\t\t\t\tAddress: addr,\n\t\t\t\tTopics:  make([]common.Hash, 0),\n\t\t\t},\n\t\t\t&ethtypes.Log{\n\t\t\t\tAddress: addr,\n\t\t\t\tTxHash:  txHash,\n\t\t\t\tTopics:  make([]common.Hash, 0),\n\t\t\t},\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t\t{\n\t\t\t\"dynamicfee tx hash from message\",\n\t\t\ttxHash3,\n\t\t\t&ethtypes.Log{\n\t\t\t\tAddress: addr,\n\t\t\t\tTopics:  make([]common.Hash, 0),\n\t\t\t},\n\t\t\t&ethtypes.Log{\n\t\t\t\tAddress: addr,\n\t\t\t\tTxHash:  txHash3,\n\t\t\t\tTopics:  make([]common.Hash, 0),\n\t\t\t},\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tsuite.SetupTest()\n\t\t\tvmdb := statedb.New(suite.ctx, suite.app.EvmKeeper, statedb.NewTxConfig(\n\t\t\t\tcommon.BytesToHash(suite.ctx.HeaderHash().Bytes()),\n\t\t\t\ttc.hash,\n\t\t\t\t0, 0,\n\t\t\t))\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tvmdb.AddLog(tc.log)\n\t\t\tlogs := vmdb.Logs()\n\t\t\tsuite.Require().Equal(1, len(logs))\n\t\t\tsuite.Require().Equal(tc.expLog, logs[0])\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestPrepareAccessList() {\n\tdest := tests.GenerateAddress()\n\tprecompiles := []common.Address{tests.GenerateAddress(), tests.GenerateAddress()}\n\taccesses := ethtypes.AccessList{\n\t\t{Address: tests.GenerateAddress(), StorageKeys: []common.Hash{common.BytesToHash([]byte(\"key\"))}},\n\t\t{Address: tests.GenerateAddress(), StorageKeys: []common.Hash{common.BytesToHash([]byte(\"key1\"))}},\n\t}\n\n\tvmdb := suite.StateDB()\n\tvmdb.PrepareAccessList(suite.address, &dest, precompiles, accesses)\n\n\tsuite.Require().True(vmdb.AddressInAccessList(suite.address))\n\tsuite.Require().True(vmdb.AddressInAccessList(dest))\n\n\tfor _, precompile := range precompiles {\n\t\tsuite.Require().True(vmdb.AddressInAccessList(precompile))\n\t}\n\n\tfor _, access := range accesses {\n\t\tfor _, key := range access.StorageKeys {\n\t\t\taddrOK, slotOK := vmdb.SlotInAccessList(access.Address, key)\n\t\t\tsuite.Require().True(addrOK, access.Address.Hex())\n\t\t\tsuite.Require().True(slotOK, key.Hex())\n\t\t}\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestAddAddressToAccessList() {\n\ttestCases := []struct {\n\t\tname string\n\t\taddr common.Address\n\t}{\n\t\t{\"new address\", suite.address},\n\t\t{\"existing address\", suite.address},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tvmdb.AddAddressToAccessList(tc.addr)\n\t\t\taddrOk := vmdb.AddressInAccessList(tc.addr)\n\t\t\tsuite.Require().True(addrOk, tc.addr.Hex())\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) AddSlotToAccessList() {\n\ttestCases := []struct {\n\t\tname string\n\t\taddr common.Address\n\t\tslot common.Hash\n\t}{\n\t\t{\"new address and slot (1)\", tests.GenerateAddress(), common.BytesToHash([]byte(\"hash\"))},\n\t\t{\"new address and slot (2)\", suite.address, common.Hash{}},\n\t\t{\"existing address and slot\", suite.address, common.Hash{}},\n\t\t{\"existing address, new slot\", suite.address, common.BytesToHash([]byte(\"hash\"))},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tvmdb.AddSlotToAccessList(tc.addr, tc.slot)\n\t\t\taddrOk, slotOk := vmdb.SlotInAccessList(tc.addr, tc.slot)\n\t\t\tsuite.Require().True(addrOk, tc.addr.Hex())\n\t\t\tsuite.Require().True(slotOk, tc.slot.Hex())\n\t\t})\n\t}\n}\n\n// FIXME skip for now\nfunc (suite *KeeperTestSuite) _TestForEachStorage() {\n\tvar storage types.Storage\n\n\ttestCase := []struct {\n\t\tname      string\n\t\tmalleate  func(vm.StateDB)\n\t\tcallback  func(key, value common.Hash) (stop bool)\n\t\texpValues []common.Hash\n\t}{\n\t\t{\n\t\t\t\"aggregate state\",\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tfor i := 0; i < 5; i++ {\n\t\t\t\t\tvmdb.SetState(suite.address, common.BytesToHash([]byte(fmt.Sprintf(\"key%d\", i))), common.BytesToHash([]byte(fmt.Sprintf(\"value%d\", i))))\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunc(key, value common.Hash) bool {\n\t\t\t\tstorage = append(storage, types.NewState(key, value))\n\t\t\t\treturn true\n\t\t\t},\n\t\t\t[]common.Hash{\n\t\t\t\tcommon.BytesToHash([]byte(\"value0\")),\n\t\t\t\tcommon.BytesToHash([]byte(\"value1\")),\n\t\t\t\tcommon.BytesToHash([]byte(\"value2\")),\n\t\t\t\tcommon.BytesToHash([]byte(\"value3\")),\n\t\t\t\tcommon.BytesToHash([]byte(\"value4\")),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"filter state\",\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.SetState(suite.address, common.BytesToHash([]byte(\"key\")), common.BytesToHash([]byte(\"value\")))\n\t\t\t\tvmdb.SetState(suite.address, common.BytesToHash([]byte(\"filterkey\")), common.BytesToHash([]byte(\"filtervalue\")))\n\t\t\t},\n\t\t\tfunc(key, value common.Hash) bool {\n\t\t\t\tif value == common.BytesToHash([]byte(\"filtervalue\")) {\n\t\t\t\t\tstorage = append(storage, types.NewState(key, value))\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t},\n\t\t\t[]common.Hash{\n\t\t\t\tcommon.BytesToHash([]byte(\"filtervalue\")),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCase {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tsuite.SetupTest() // reset\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\terr := vmdb.ForEachStorage(suite.address, tc.callback)\n\t\t\tsuite.Require().NoError(err)\n\t\t\tsuite.Require().Equal(len(tc.expValues), len(storage), fmt.Sprintf(\"Expected values:\\n%v\\nStorage Values\\n%v\", tc.expValues, storage))\n\n\t\t\tvals := make([]common.Hash, len(storage))\n\t\t\tfor i := range storage {\n\t\t\t\tvals[i] = common.HexToHash(storage[i].Value)\n\t\t\t}\n\n\t\t\t// TODO: not sure why Equals fails\n\t\t\tsuite.Require().ElementsMatch(tc.expValues, vals)\n\t\t})\n\t\tstorage = types.Storage{}\n\t}\n}\n"], "fixing_code": ["package keeper\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/cosmos/cosmos-sdk/store/prefix\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\tethermint \"github.com/evmos/ethermint/types\"\n\t\"github.com/evmos/ethermint/x/evm/statedb\"\n\t\"github.com/evmos/ethermint/x/evm/types\"\n)\n\nvar _ statedb.Keeper = &Keeper{}\n\n// ----------------------------------------------------------------------------\n// StateDB Keeper implementation\n// ----------------------------------------------------------------------------\n\n// GetAccount returns nil if account is not exist, returns error if it's not `EthAccountI`\nfunc (k *Keeper) GetAccount(ctx sdk.Context, addr common.Address) *statedb.Account {\n\tacct := k.GetAccountWithoutBalance(ctx, addr)\n\tif acct == nil {\n\t\treturn nil\n\t}\n\n\tacct.Balance = k.GetBalance(ctx, addr)\n\treturn acct\n}\n\n// GetState loads contract state from database, implements `statedb.Keeper` interface.\nfunc (k *Keeper) GetState(ctx sdk.Context, addr common.Address, key common.Hash) common.Hash {\n\tstore := prefix.NewStore(ctx.KVStore(k.storeKey), types.AddressStoragePrefix(addr))\n\n\tvalue := store.Get(key.Bytes())\n\tif len(value) == 0 {\n\t\treturn common.Hash{}\n\t}\n\n\treturn common.BytesToHash(value)\n}\n\n// GetCode loads contract code from database, implements `statedb.Keeper` interface.\nfunc (k *Keeper) GetCode(ctx sdk.Context, codeHash common.Hash) []byte {\n\tstore := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefixCode)\n\treturn store.Get(codeHash.Bytes())\n}\n\n// ForEachStorage iterate contract storage, callback return false to break early\nfunc (k *Keeper) ForEachStorage(ctx sdk.Context, addr common.Address, cb func(key, value common.Hash) bool) {\n\tstore := ctx.KVStore(k.storeKey)\n\tprefix := types.AddressStoragePrefix(addr)\n\n\titerator := sdk.KVStorePrefixIterator(store, prefix)\n\tdefer iterator.Close()\n\n\tfor ; iterator.Valid(); iterator.Next() {\n\t\tkey := common.BytesToHash(iterator.Key())\n\t\tvalue := common.BytesToHash(iterator.Value())\n\n\t\t// check if iteration stops\n\t\tif !cb(key, value) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// SetBalance update account's balance, compare with current balance first, then decide to mint or burn.\nfunc (k *Keeper) SetBalance(ctx sdk.Context, addr common.Address, amount *big.Int) error {\n\tcosmosAddr := sdk.AccAddress(addr.Bytes())\n\n\tparams := k.GetParams(ctx)\n\tcoin := k.bankKeeper.GetBalance(ctx, cosmosAddr, params.EvmDenom)\n\tbalance := coin.Amount.BigInt()\n\tdelta := new(big.Int).Sub(amount, balance)\n\tswitch delta.Sign() {\n\tcase 1:\n\t\t// mint\n\t\tcoins := sdk.NewCoins(sdk.NewCoin(params.EvmDenom, sdk.NewIntFromBigInt(delta)))\n\t\tif err := k.bankKeeper.MintCoins(ctx, types.ModuleName, coins); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, cosmosAddr, coins); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase -1:\n\t\t// burn\n\t\tcoins := sdk.NewCoins(sdk.NewCoin(params.EvmDenom, sdk.NewIntFromBigInt(new(big.Int).Neg(delta))))\n\t\tif err := k.bankKeeper.SendCoinsFromAccountToModule(ctx, cosmosAddr, types.ModuleName, coins); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := k.bankKeeper.BurnCoins(ctx, types.ModuleName, coins); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\t// not changed\n\t}\n\treturn nil\n}\n\n// SetAccount updates nonce/balance/codeHash together.\nfunc (k *Keeper) SetAccount(ctx sdk.Context, addr common.Address, account statedb.Account) error {\n\t// update account\n\tcosmosAddr := sdk.AccAddress(addr.Bytes())\n\tacct := k.accountKeeper.GetAccount(ctx, cosmosAddr)\n\tif acct == nil {\n\t\tacct = k.accountKeeper.NewAccountWithAddress(ctx, cosmosAddr)\n\t}\n\n\tif err := acct.SetSequence(account.Nonce); err != nil {\n\t\treturn err\n\t}\n\n\tcodeHash := common.BytesToHash(account.CodeHash)\n\n\tif ethAcct, ok := acct.(ethermint.EthAccountI); ok {\n\t\tif err := ethAcct.SetCodeHash(codeHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tk.accountKeeper.SetAccount(ctx, acct)\n\n\tif err := k.SetBalance(ctx, addr, account.Balance); err != nil {\n\t\treturn err\n\t}\n\n\tk.Logger(ctx).Debug(\n\t\t\"account updated\",\n\t\t\"ethereum-address\", addr.Hex(),\n\t\t\"nonce\", account.Nonce,\n\t\t\"codeHash\", codeHash.Hex(),\n\t\t\"balance\", account.Balance,\n\t)\n\treturn nil\n}\n\n// SetState update contract storage, delete if value is empty.\nfunc (k *Keeper) SetState(ctx sdk.Context, addr common.Address, key common.Hash, value []byte) {\n\tstore := prefix.NewStore(ctx.KVStore(k.storeKey), types.AddressStoragePrefix(addr))\n\taction := \"updated\"\n\tif len(value) == 0 {\n\t\tstore.Delete(key.Bytes())\n\t\taction = \"deleted\"\n\t} else {\n\t\tstore.Set(key.Bytes(), value)\n\t}\n\tk.Logger(ctx).Debug(\n\t\tfmt.Sprintf(\"state %s\", action),\n\t\t\"ethereum-address\", addr.Hex(),\n\t\t\"key\", key.Hex(),\n\t)\n}\n\n// SetCode set contract code, delete if code is empty.\nfunc (k *Keeper) SetCode(ctx sdk.Context, codeHash, code []byte) {\n\tstore := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefixCode)\n\n\t// store or delete code\n\taction := \"updated\"\n\tif len(code) == 0 {\n\t\tstore.Delete(codeHash)\n\t\taction = \"deleted\"\n\t} else {\n\t\tstore.Set(codeHash, code)\n\t}\n\tk.Logger(ctx).Debug(\n\t\tfmt.Sprintf(\"code %s\", action),\n\t\t\"code-hash\", common.BytesToHash(codeHash).Hex(),\n\t)\n}\n\n// DeleteAccount handles contract's suicide call:\n// - clear balance\n// - remove code\n// - remove states\n// - remove auth account\nfunc (k *Keeper) DeleteAccount(ctx sdk.Context, addr common.Address) error {\n\tcosmosAddr := sdk.AccAddress(addr.Bytes())\n\tacct := k.accountKeeper.GetAccount(ctx, cosmosAddr)\n\tif acct == nil {\n\t\treturn nil\n\t}\n\n\t// NOTE: only Ethereum accounts (contracts) can be selfdestructed\n\t_, ok := acct.(ethermint.EthAccountI)\n\tif !ok {\n\t\treturn sdkerrors.Wrapf(types.ErrInvalidAccount, \"type %T, address %s\", acct, addr)\n\t}\n\n\t// clear balance\n\tif err := k.SetBalance(ctx, addr, new(big.Int)); err != nil {\n\t\treturn err\n\t}\n\n\t// clear storage\n\tk.ForEachStorage(ctx, addr, func(key, _ common.Hash) bool {\n\t\tk.SetState(ctx, addr, key, nil)\n\t\treturn true\n\t})\n\n\t// remove auth account\n\tk.accountKeeper.RemoveAccount(ctx, acct)\n\n\tk.Logger(ctx).Debug(\n\t\t\"account suicided\",\n\t\t\"ethereum-address\", addr.Hex(),\n\t\t\"cosmos-address\", cosmosAddr.String(),\n\t)\n\n\treturn nil\n}\n", "package keeper_test\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n\n\tcodectypes \"github.com/cosmos/cosmos-sdk/codec/types\"\n\tcryptotypes \"github.com/cosmos/cosmos-sdk/crypto/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tauthsigning \"github.com/cosmos/cosmos-sdk/x/auth/signing\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/evmos/ethermint/crypto/ethsecp256k1\"\n\t\"github.com/evmos/ethermint/tests\"\n\t\"github.com/evmos/ethermint/x/evm/statedb\"\n\t\"github.com/evmos/ethermint/x/evm/types\"\n)\n\nfunc (suite *KeeperTestSuite) TestCreateAccount() {\n\ttestCases := []struct {\n\t\tname     string\n\t\taddr     common.Address\n\t\tmalleate func(vm.StateDB, common.Address)\n\t\tcallback func(vm.StateDB, common.Address)\n\t}{\n\t\t{\n\t\t\t\"reset account (keep balance)\",\n\t\t\tsuite.address,\n\t\t\tfunc(vmdb vm.StateDB, addr common.Address) {\n\t\t\t\tvmdb.AddBalance(addr, big.NewInt(100))\n\t\t\t\tsuite.Require().NotZero(vmdb.GetBalance(addr).Int64())\n\t\t\t},\n\t\t\tfunc(vmdb vm.StateDB, addr common.Address) {\n\t\t\t\tsuite.Require().Equal(vmdb.GetBalance(addr).Int64(), int64(100))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"create account\",\n\t\t\ttests.GenerateAddress(),\n\t\t\tfunc(vmdb vm.StateDB, addr common.Address) {\n\t\t\t\tsuite.Require().False(vmdb.Exist(addr))\n\t\t\t},\n\t\t\tfunc(vmdb vm.StateDB, addr common.Address) {\n\t\t\t\tsuite.Require().True(vmdb.Exist(addr))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb, tc.addr)\n\t\t\tvmdb.CreateAccount(tc.addr)\n\t\t\ttc.callback(vmdb, tc.addr)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestAddBalance() {\n\ttestCases := []struct {\n\t\tname   string\n\t\tamount *big.Int\n\t\tisNoOp bool\n\t}{\n\t\t{\n\t\t\t\"positive amount\",\n\t\t\tbig.NewInt(100),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"zero amount\",\n\t\t\tbig.NewInt(0),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"negative amount\",\n\t\t\tbig.NewInt(-1),\n\t\t\tfalse, // seems to be consistent with go-ethereum's implementation\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tprev := vmdb.GetBalance(suite.address)\n\t\t\tvmdb.AddBalance(suite.address, tc.amount)\n\t\t\tpost := vmdb.GetBalance(suite.address)\n\n\t\t\tif tc.isNoOp {\n\t\t\t\tsuite.Require().Equal(prev.Int64(), post.Int64())\n\t\t\t} else {\n\t\t\t\tsuite.Require().Equal(new(big.Int).Add(prev, tc.amount).Int64(), post.Int64())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestSubBalance() {\n\ttestCases := []struct {\n\t\tname     string\n\t\tamount   *big.Int\n\t\tmalleate func(vm.StateDB)\n\t\tisNoOp   bool\n\t}{\n\t\t{\n\t\t\t\"positive amount, below zero\",\n\t\t\tbig.NewInt(100),\n\t\t\tfunc(vm.StateDB) {},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"positive amount, above zero\",\n\t\t\tbig.NewInt(50),\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.AddBalance(suite.address, big.NewInt(100))\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"zero amount\",\n\t\t\tbig.NewInt(0),\n\t\t\tfunc(vm.StateDB) {},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"negative amount\",\n\t\t\tbig.NewInt(-1),\n\t\t\tfunc(vm.StateDB) {},\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tprev := vmdb.GetBalance(suite.address)\n\t\t\tvmdb.SubBalance(suite.address, tc.amount)\n\t\t\tpost := vmdb.GetBalance(suite.address)\n\n\t\t\tif tc.isNoOp {\n\t\t\t\tsuite.Require().Equal(prev.Int64(), post.Int64())\n\t\t\t} else {\n\t\t\t\tsuite.Require().Equal(new(big.Int).Sub(prev, tc.amount).Int64(), post.Int64())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestGetNonce() {\n\ttestCases := []struct {\n\t\tname          string\n\t\taddress       common.Address\n\t\texpectedNonce uint64\n\t\tmalleate      func(vm.StateDB)\n\t}{\n\t\t{\n\t\t\t\"account not found\",\n\t\t\ttests.GenerateAddress(),\n\t\t\t0,\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t\t{\n\t\t\t\"existing account\",\n\t\t\tsuite.address,\n\t\t\t1,\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.SetNonce(suite.address, 1)\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tnonce := vmdb.GetNonce(tc.address)\n\t\t\tsuite.Require().Equal(tc.expectedNonce, nonce)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestSetNonce() {\n\ttestCases := []struct {\n\t\tname     string\n\t\taddress  common.Address\n\t\tnonce    uint64\n\t\tmalleate func()\n\t}{\n\t\t{\n\t\t\t\"new account\",\n\t\t\ttests.GenerateAddress(),\n\t\t\t10,\n\t\t\tfunc() {},\n\t\t},\n\t\t{\n\t\t\t\"existing account\",\n\t\t\tsuite.address,\n\t\t\t99,\n\t\t\tfunc() {},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tvmdb.SetNonce(tc.address, tc.nonce)\n\t\t\tnonce := vmdb.GetNonce(tc.address)\n\t\t\tsuite.Require().Equal(tc.nonce, nonce)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestGetCodeHash() {\n\taddr := tests.GenerateAddress()\n\tbaseAcc := &authtypes.BaseAccount{Address: sdk.AccAddress(addr.Bytes()).String()}\n\tsuite.app.AccountKeeper.SetAccount(suite.ctx, baseAcc)\n\n\ttestCases := []struct {\n\t\tname     string\n\t\taddress  common.Address\n\t\texpHash  common.Hash\n\t\tmalleate func(vm.StateDB)\n\t}{\n\t\t{\n\t\t\t\"account not found\",\n\t\t\ttests.GenerateAddress(),\n\t\t\tcommon.Hash{},\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t\t{\n\t\t\t\"account not EthAccount type, EmptyCodeHash\",\n\t\t\taddr,\n\t\t\tcommon.BytesToHash(types.EmptyCodeHash),\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t\t{\n\t\t\t\"existing account\",\n\t\t\tsuite.address,\n\t\t\tcrypto.Keccak256Hash([]byte(\"codeHash\")),\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.SetCode(suite.address, []byte(\"codeHash\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\thash := vmdb.GetCodeHash(tc.address)\n\t\t\tsuite.Require().Equal(tc.expHash, hash)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestSetCode() {\n\taddr := tests.GenerateAddress()\n\tbaseAcc := &authtypes.BaseAccount{Address: sdk.AccAddress(addr.Bytes()).String()}\n\tsuite.app.AccountKeeper.SetAccount(suite.ctx, baseAcc)\n\n\ttestCases := []struct {\n\t\tname    string\n\t\taddress common.Address\n\t\tcode    []byte\n\t\tisNoOp  bool\n\t}{\n\t\t{\n\t\t\t\"account not found\",\n\t\t\ttests.GenerateAddress(),\n\t\t\t[]byte(\"code\"),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"account not EthAccount type\",\n\t\t\taddr,\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"existing account\",\n\t\t\tsuite.address,\n\t\t\t[]byte(\"code\"),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"existing account, code deleted from store\",\n\t\t\tsuite.address,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tprev := vmdb.GetCode(tc.address)\n\t\t\tvmdb.SetCode(tc.address, tc.code)\n\t\t\tpost := vmdb.GetCode(tc.address)\n\n\t\t\tif tc.isNoOp {\n\t\t\t\tsuite.Require().Equal(prev, post)\n\t\t\t} else {\n\t\t\t\tsuite.Require().Equal(tc.code, post)\n\t\t\t}\n\n\t\t\tsuite.Require().Equal(len(post), vmdb.GetCodeSize(tc.address))\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestRefund() {\n\ttestCases := []struct {\n\t\tname      string\n\t\tmalleate  func(vm.StateDB)\n\t\texpRefund uint64\n\t\texpPanic  bool\n\t}{\n\t\t{\n\t\t\t\"success - add and subtract refund\",\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.AddRefund(11)\n\t\t\t},\n\t\t\t1,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"fail - subtract amount > current refund\",\n\t\t\tfunc(vm.StateDB) {\n\t\t\t},\n\t\t\t0,\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tif tc.expPanic {\n\t\t\t\tsuite.Require().Panics(func() { vmdb.SubRefund(10) })\n\t\t\t} else {\n\t\t\t\tvmdb.SubRefund(10)\n\t\t\t\tsuite.Require().Equal(tc.expRefund, vmdb.GetRefund())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestState() {\n\ttestCases := []struct {\n\t\tname       string\n\t\tkey, value common.Hash\n\t}{\n\t\t{\n\t\t\t\"set state - delete from store\",\n\t\t\tcommon.BytesToHash([]byte(\"key\")),\n\t\t\tcommon.Hash{},\n\t\t},\n\t\t{\n\t\t\t\"set state - update value\",\n\t\t\tcommon.BytesToHash([]byte(\"key\")),\n\t\t\tcommon.BytesToHash([]byte(\"value\")),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tvmdb.SetState(suite.address, tc.key, tc.value)\n\t\t\tvalue := vmdb.GetState(suite.address, tc.key)\n\t\t\tsuite.Require().Equal(tc.value, value)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestCommittedState() {\n\tsuite.SetupTest()\n\n\tkey := common.BytesToHash([]byte(\"key\"))\n\tvalue1 := common.BytesToHash([]byte(\"value1\"))\n\tvalue2 := common.BytesToHash([]byte(\"value2\"))\n\n\tvmdb := suite.StateDB()\n\tvmdb.SetState(suite.address, key, value1)\n\tvmdb.Commit()\n\n\tvmdb = suite.StateDB()\n\tvmdb.SetState(suite.address, key, value2)\n\ttmp := vmdb.GetState(suite.address, key)\n\tsuite.Require().Equal(value2, tmp)\n\ttmp = vmdb.GetCommittedState(suite.address, key)\n\tsuite.Require().Equal(value1, tmp)\n\tvmdb.Commit()\n\n\tvmdb = suite.StateDB()\n\ttmp = vmdb.GetCommittedState(suite.address, key)\n\tsuite.Require().Equal(value2, tmp)\n}\n\nfunc (suite *KeeperTestSuite) TestSuicide() {\n\tcode := []byte(\"code\")\n\tdb := suite.StateDB()\n\t// Add code to account\n\tdb.SetCode(suite.address, code)\n\tsuite.Require().Equal(code, db.GetCode(suite.address))\n\t// Add state to account\n\tfor i := 0; i < 5; i++ {\n\t\tdb.SetState(suite.address, common.BytesToHash([]byte(fmt.Sprintf(\"key%d\", i))), common.BytesToHash([]byte(fmt.Sprintf(\"value%d\", i))))\n\t}\n\n\tsuite.Require().NoError(db.Commit())\n\tdb = suite.StateDB()\n\n\t// Generate 2nd address\n\tprivkey, _ := ethsecp256k1.GenerateKey()\n\tkey, err := privkey.ToECDSA()\n\tsuite.Require().NoError(err)\n\taddr2 := crypto.PubkeyToAddress(key.PublicKey)\n\n\t// Add code and state to account 2\n\tdb.SetCode(addr2, code)\n\tsuite.Require().Equal(code, db.GetCode(addr2))\n\tfor i := 0; i < 5; i++ {\n\t\tdb.SetState(addr2, common.BytesToHash([]byte(fmt.Sprintf(\"key%d\", i))), common.BytesToHash([]byte(fmt.Sprintf(\"value%d\", i))))\n\t}\n\n\t// Call Suicide\n\tsuite.Require().Equal(true, db.Suicide(suite.address))\n\n\t// Check suicided is marked\n\tsuite.Require().Equal(true, db.HasSuicided(suite.address))\n\n\t// Commit state\n\tsuite.Require().NoError(db.Commit())\n\tdb = suite.StateDB()\n\n\t// Check code is deleted\n\tsuite.Require().Nil(db.GetCode(suite.address))\n\t// Check state is deleted\n\tvar storage types.Storage\n\tsuite.app.EvmKeeper.ForEachStorage(suite.ctx, suite.address, func(key, value common.Hash) bool {\n\t\tstorage = append(storage, types.NewState(key, value))\n\t\treturn true\n\t})\n\tsuite.Require().Equal(0, len(storage))\n\n\t// Check account is deleted\n\tsuite.Require().Equal(common.Hash{}, db.GetCodeHash(suite.address))\n\n\t// Check code is still present in addr2 and suicided is false\n\tsuite.Require().NotNil(db.GetCode(addr2))\n\tsuite.Require().Equal(false, db.HasSuicided(addr2))\n}\n\nfunc (suite *KeeperTestSuite) TestExist() {\n\ttestCases := []struct {\n\t\tname     string\n\t\taddress  common.Address\n\t\tmalleate func(vm.StateDB)\n\t\texists   bool\n\t}{\n\t\t{\"success, account exists\", suite.address, func(vm.StateDB) {}, true},\n\t\t{\"success, has suicided\", suite.address, func(vmdb vm.StateDB) {\n\t\t\tvmdb.Suicide(suite.address)\n\t\t}, true},\n\t\t{\"success, account doesn't exist\", tests.GenerateAddress(), func(vm.StateDB) {}, false},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tsuite.Require().Equal(tc.exists, vmdb.Exist(tc.address))\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestEmpty() {\n\tsuite.SetupTest()\n\n\ttestCases := []struct {\n\t\tname     string\n\t\taddress  common.Address\n\t\tmalleate func(vm.StateDB)\n\t\tempty    bool\n\t}{\n\t\t{\"empty, account exists\", suite.address, func(vm.StateDB) {}, true},\n\t\t{\n\t\t\t\"not empty, positive balance\",\n\t\t\tsuite.address,\n\t\t\tfunc(vmdb vm.StateDB) { vmdb.AddBalance(suite.address, big.NewInt(100)) },\n\t\t\tfalse,\n\t\t},\n\t\t{\"empty, account doesn't exist\", tests.GenerateAddress(), func(vm.StateDB) {}, true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tsuite.Require().Equal(tc.empty, vmdb.Empty(tc.address))\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestSnapshot() {\n\tkey := common.BytesToHash([]byte(\"key\"))\n\tvalue1 := common.BytesToHash([]byte(\"value1\"))\n\tvalue2 := common.BytesToHash([]byte(\"value2\"))\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tmalleate func(vm.StateDB)\n\t}{\n\t\t{\"simple revert\", func(vmdb vm.StateDB) {\n\t\t\trevision := vmdb.Snapshot()\n\t\t\tsuite.Require().Zero(revision)\n\n\t\t\tvmdb.SetState(suite.address, key, value1)\n\t\t\tsuite.Require().Equal(value1, vmdb.GetState(suite.address, key))\n\n\t\t\tvmdb.RevertToSnapshot(revision)\n\n\t\t\t// reverted\n\t\t\tsuite.Require().Equal(common.Hash{}, vmdb.GetState(suite.address, key))\n\t\t}},\n\t\t{\"nested snapshot/revert\", func(vmdb vm.StateDB) {\n\t\t\trevision1 := vmdb.Snapshot()\n\t\t\tsuite.Require().Zero(revision1)\n\n\t\t\tvmdb.SetState(suite.address, key, value1)\n\n\t\t\trevision2 := vmdb.Snapshot()\n\n\t\t\tvmdb.SetState(suite.address, key, value2)\n\t\t\tsuite.Require().Equal(value2, vmdb.GetState(suite.address, key))\n\n\t\t\tvmdb.RevertToSnapshot(revision2)\n\t\t\tsuite.Require().Equal(value1, vmdb.GetState(suite.address, key))\n\n\t\t\tvmdb.RevertToSnapshot(revision1)\n\t\t\tsuite.Require().Equal(common.Hash{}, vmdb.GetState(suite.address, key))\n\t\t}},\n\t\t{\"jump revert\", func(vmdb vm.StateDB) {\n\t\t\trevision1 := vmdb.Snapshot()\n\t\t\tvmdb.SetState(suite.address, key, value1)\n\t\t\tvmdb.Snapshot()\n\t\t\tvmdb.SetState(suite.address, key, value2)\n\t\t\tvmdb.RevertToSnapshot(revision1)\n\t\t\tsuite.Require().Equal(common.Hash{}, vmdb.GetState(suite.address, key))\n\t\t}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tsuite.SetupTest()\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) CreateTestTx(msg *types.MsgEthereumTx, priv cryptotypes.PrivKey) authsigning.Tx {\n\toption, err := codectypes.NewAnyWithValue(&types.ExtensionOptionsEthereumTx{})\n\tsuite.Require().NoError(err)\n\n\ttxBuilder := suite.clientCtx.TxConfig.NewTxBuilder()\n\tbuilder, ok := txBuilder.(authtx.ExtensionOptionsTxBuilder)\n\tsuite.Require().True(ok)\n\n\tbuilder.SetExtensionOptions(option)\n\n\terr = msg.Sign(suite.ethSigner, tests.NewSigner(priv))\n\tsuite.Require().NoError(err)\n\n\terr = txBuilder.SetMsgs(msg)\n\tsuite.Require().NoError(err)\n\n\treturn txBuilder.GetTx()\n}\n\nfunc (suite *KeeperTestSuite) TestAddLog() {\n\taddr, privKey := tests.NewAddrKey()\n\tmsg := types.NewTx(big.NewInt(1), 0, &suite.address, big.NewInt(1), 100000, big.NewInt(1), nil, nil, []byte(\"test\"), nil)\n\tmsg.From = addr.Hex()\n\n\ttx := suite.CreateTestTx(msg, privKey)\n\tmsg, _ = tx.GetMsgs()[0].(*types.MsgEthereumTx)\n\ttxHash := msg.AsTransaction().Hash()\n\n\tmsg2 := types.NewTx(big.NewInt(1), 1, &suite.address, big.NewInt(1), 100000, big.NewInt(1), nil, nil, []byte(\"test\"), nil)\n\tmsg2.From = addr.Hex()\n\n\ttx2 := suite.CreateTestTx(msg2, privKey)\n\tmsg2, _ = tx2.GetMsgs()[0].(*types.MsgEthereumTx)\n\n\tmsg3 := types.NewTx(big.NewInt(1), 0, &suite.address, big.NewInt(1), 100000, nil, big.NewInt(1), big.NewInt(1), []byte(\"test\"), nil)\n\tmsg3.From = addr.Hex()\n\n\ttx3 := suite.CreateTestTx(msg3, privKey)\n\tmsg3, _ = tx3.GetMsgs()[0].(*types.MsgEthereumTx)\n\ttxHash3 := msg3.AsTransaction().Hash()\n\n\tmsg4 := types.NewTx(big.NewInt(1), 1, &suite.address, big.NewInt(1), 100000, nil, big.NewInt(1), big.NewInt(1), []byte(\"test\"), nil)\n\tmsg4.From = addr.Hex()\n\n\ttx4 := suite.CreateTestTx(msg4, privKey)\n\tmsg4, _ = tx4.GetMsgs()[0].(*types.MsgEthereumTx)\n\n\ttestCases := []struct {\n\t\tname        string\n\t\thash        common.Hash\n\t\tlog, expLog *ethtypes.Log // pre and post populating log fields\n\t\tmalleate    func(vm.StateDB)\n\t}{\n\t\t{\n\t\t\t\"tx hash from message\",\n\t\t\ttxHash,\n\t\t\t&ethtypes.Log{\n\t\t\t\tAddress: addr,\n\t\t\t\tTopics:  make([]common.Hash, 0),\n\t\t\t},\n\t\t\t&ethtypes.Log{\n\t\t\t\tAddress: addr,\n\t\t\t\tTxHash:  txHash,\n\t\t\t\tTopics:  make([]common.Hash, 0),\n\t\t\t},\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t\t{\n\t\t\t\"dynamicfee tx hash from message\",\n\t\t\ttxHash3,\n\t\t\t&ethtypes.Log{\n\t\t\t\tAddress: addr,\n\t\t\t\tTopics:  make([]common.Hash, 0),\n\t\t\t},\n\t\t\t&ethtypes.Log{\n\t\t\t\tAddress: addr,\n\t\t\t\tTxHash:  txHash3,\n\t\t\t\tTopics:  make([]common.Hash, 0),\n\t\t\t},\n\t\t\tfunc(vm.StateDB) {},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tsuite.SetupTest()\n\t\t\tvmdb := statedb.New(suite.ctx, suite.app.EvmKeeper, statedb.NewTxConfig(\n\t\t\t\tcommon.BytesToHash(suite.ctx.HeaderHash().Bytes()),\n\t\t\t\ttc.hash,\n\t\t\t\t0, 0,\n\t\t\t))\n\t\t\ttc.malleate(vmdb)\n\n\t\t\tvmdb.AddLog(tc.log)\n\t\t\tlogs := vmdb.Logs()\n\t\t\tsuite.Require().Equal(1, len(logs))\n\t\t\tsuite.Require().Equal(tc.expLog, logs[0])\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestPrepareAccessList() {\n\tdest := tests.GenerateAddress()\n\tprecompiles := []common.Address{tests.GenerateAddress(), tests.GenerateAddress()}\n\taccesses := ethtypes.AccessList{\n\t\t{Address: tests.GenerateAddress(), StorageKeys: []common.Hash{common.BytesToHash([]byte(\"key\"))}},\n\t\t{Address: tests.GenerateAddress(), StorageKeys: []common.Hash{common.BytesToHash([]byte(\"key1\"))}},\n\t}\n\n\tvmdb := suite.StateDB()\n\tvmdb.PrepareAccessList(suite.address, &dest, precompiles, accesses)\n\n\tsuite.Require().True(vmdb.AddressInAccessList(suite.address))\n\tsuite.Require().True(vmdb.AddressInAccessList(dest))\n\n\tfor _, precompile := range precompiles {\n\t\tsuite.Require().True(vmdb.AddressInAccessList(precompile))\n\t}\n\n\tfor _, access := range accesses {\n\t\tfor _, key := range access.StorageKeys {\n\t\t\taddrOK, slotOK := vmdb.SlotInAccessList(access.Address, key)\n\t\t\tsuite.Require().True(addrOK, access.Address.Hex())\n\t\t\tsuite.Require().True(slotOK, key.Hex())\n\t\t}\n\t}\n}\n\nfunc (suite *KeeperTestSuite) TestAddAddressToAccessList() {\n\ttestCases := []struct {\n\t\tname string\n\t\taddr common.Address\n\t}{\n\t\t{\"new address\", suite.address},\n\t\t{\"existing address\", suite.address},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tvmdb.AddAddressToAccessList(tc.addr)\n\t\t\taddrOk := vmdb.AddressInAccessList(tc.addr)\n\t\t\tsuite.Require().True(addrOk, tc.addr.Hex())\n\t\t})\n\t}\n}\n\nfunc (suite *KeeperTestSuite) AddSlotToAccessList() {\n\ttestCases := []struct {\n\t\tname string\n\t\taddr common.Address\n\t\tslot common.Hash\n\t}{\n\t\t{\"new address and slot (1)\", tests.GenerateAddress(), common.BytesToHash([]byte(\"hash\"))},\n\t\t{\"new address and slot (2)\", suite.address, common.Hash{}},\n\t\t{\"existing address and slot\", suite.address, common.Hash{}},\n\t\t{\"existing address, new slot\", suite.address, common.BytesToHash([]byte(\"hash\"))},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tvmdb := suite.StateDB()\n\t\t\tvmdb.AddSlotToAccessList(tc.addr, tc.slot)\n\t\t\taddrOk, slotOk := vmdb.SlotInAccessList(tc.addr, tc.slot)\n\t\t\tsuite.Require().True(addrOk, tc.addr.Hex())\n\t\t\tsuite.Require().True(slotOk, tc.slot.Hex())\n\t\t})\n\t}\n}\n\n// FIXME skip for now\nfunc (suite *KeeperTestSuite) _TestForEachStorage() {\n\tvar storage types.Storage\n\n\ttestCase := []struct {\n\t\tname      string\n\t\tmalleate  func(vm.StateDB)\n\t\tcallback  func(key, value common.Hash) (stop bool)\n\t\texpValues []common.Hash\n\t}{\n\t\t{\n\t\t\t\"aggregate state\",\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tfor i := 0; i < 5; i++ {\n\t\t\t\t\tvmdb.SetState(suite.address, common.BytesToHash([]byte(fmt.Sprintf(\"key%d\", i))), common.BytesToHash([]byte(fmt.Sprintf(\"value%d\", i))))\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunc(key, value common.Hash) bool {\n\t\t\t\tstorage = append(storage, types.NewState(key, value))\n\t\t\t\treturn true\n\t\t\t},\n\t\t\t[]common.Hash{\n\t\t\t\tcommon.BytesToHash([]byte(\"value0\")),\n\t\t\t\tcommon.BytesToHash([]byte(\"value1\")),\n\t\t\t\tcommon.BytesToHash([]byte(\"value2\")),\n\t\t\t\tcommon.BytesToHash([]byte(\"value3\")),\n\t\t\t\tcommon.BytesToHash([]byte(\"value4\")),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"filter state\",\n\t\t\tfunc(vmdb vm.StateDB) {\n\t\t\t\tvmdb.SetState(suite.address, common.BytesToHash([]byte(\"key\")), common.BytesToHash([]byte(\"value\")))\n\t\t\t\tvmdb.SetState(suite.address, common.BytesToHash([]byte(\"filterkey\")), common.BytesToHash([]byte(\"filtervalue\")))\n\t\t\t},\n\t\t\tfunc(key, value common.Hash) bool {\n\t\t\t\tif value == common.BytesToHash([]byte(\"filtervalue\")) {\n\t\t\t\t\tstorage = append(storage, types.NewState(key, value))\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t},\n\t\t\t[]common.Hash{\n\t\t\t\tcommon.BytesToHash([]byte(\"filtervalue\")),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCase {\n\t\tsuite.Run(tc.name, func() {\n\t\t\tsuite.SetupTest() // reset\n\t\t\tvmdb := suite.StateDB()\n\t\t\ttc.malleate(vmdb)\n\n\t\t\terr := vmdb.ForEachStorage(suite.address, tc.callback)\n\t\t\tsuite.Require().NoError(err)\n\t\t\tsuite.Require().Equal(len(tc.expValues), len(storage), fmt.Sprintf(\"Expected values:\\n%v\\nStorage Values\\n%v\", tc.expValues, storage))\n\n\t\t\tvals := make([]common.Hash, len(storage))\n\t\t\tfor i := range storage {\n\t\t\t\tvals[i] = common.HexToHash(storage[i].Value)\n\t\t\t}\n\n\t\t\t// TODO: not sure why Equals fails\n\t\t\tsuite.Require().ElementsMatch(tc.expValues, vals)\n\t\t})\n\t\tstorage = types.Storage{}\n\t}\n}\n"], "filenames": ["x/evm/keeper/statedb.go", "x/evm/keeper/statedb_test.go"], "buggy_code_start_loc": [4, 17], "buggy_code_end_loc": [203, 443], "fixing_code_start_loc": [3, 18], "fixing_code_end_loc": [195, 463], "type": "CWE-668", "message": "Ethermint is an Ethereum library. In Ethermint running versions before `v0.17.2`, the contract `selfdestruct` invocation permanently removes the corresponding bytecode from the internal database storage. However, due to a bug in the `DeleteAccount`function, all contracts that used the identical bytecode (i.e shared the same `CodeHash`) will also stop working once one contract invokes `selfdestruct`, even though the other contracts did not invoke the `selfdestruct` OPCODE. This vulnerability has been patched in Ethermint version v0.18.0. The patch has state machine-breaking changes for applications using Ethermint, so a coordinated upgrade procedure is required. A workaround is available. If a contract is subject to DoS due to this issue, the user can redeploy the same contract, i.e. with identical bytecode, so that the original contract's code is recovered. The new contract deployment restores the `bytecode hash -> bytecode` entry in the internal state.", "other": {"cve": {"id": "CVE-2022-35936", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-05T13:15:08.137", "lastModified": "2022-08-13T00:59:12.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ethermint is an Ethereum library. In Ethermint running versions before `v0.17.2`, the contract `selfdestruct` invocation permanently removes the corresponding bytecode from the internal database storage. However, due to a bug in the `DeleteAccount`function, all contracts that used the identical bytecode (i.e shared the same `CodeHash`) will also stop working once one contract invokes `selfdestruct`, even though the other contracts did not invoke the `selfdestruct` OPCODE. This vulnerability has been patched in Ethermint version v0.18.0. The patch has state machine-breaking changes for applications using Ethermint, so a coordinated upgrade procedure is required. A workaround is available. If a contract is subject to DoS due to this issue, the user can redeploy the same contract, i.e. with identical bytecode, so that the original contract's code is recovered. The new contract deployment restores the `bytecode hash -> bytecode` entry in the internal state."}, {"lang": "es", "value": "Ethermint es una biblioteca de Ethereum. En las versiones de Ethermint anteriores a \"v0.17.2\", la invocaci\u00f3n del contrato \"selfdestruct\" elimina permanentemente el bytecode correspondiente del almacenamiento interno de la base de datos. Sin embargo, debido a un error en la funci\u00f3n \"DeleteAccount\", todos los contratos que usaban el mismo bytecode (es decir, compart\u00edan el mismo \"CodeHash\") tambi\u00e9n dejar\u00e1n de funcionar una vez que un contrato invoque \"selfdestruct\", aunque los dem\u00e1s contratos no hayan invocado el OPCODE \"selfdestruct\". Esta vulnerabilidad ha sido parcheada en Ethermint versi\u00f3n v0.18.0. El parche presenta cambios que rompen el estado de las aplicaciones que usan Ethermint, por lo que es requerido un procedimiento de actualizaci\u00f3n coordinado. Se presenta una mitigaci\u00f3n alternativa. Si un contrato es objeto de DoS debido a este problema, el usuario puede volver a desplegar el mismo contrato, es decir, con id\u00e9ntico bytecode, de modo que sea recuperado el c\u00f3digo del contrato original. El nuevo despliegue del contrato restaura la entrada \"bytecode hash -) bytecode\" en el estado interno"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:evmos:ethermint:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.18.0", "matchCriteriaId": "5715442E-55C7-4BFA-A571-0B2EEE375D93"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kava:kava:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.18.0", "matchCriteriaId": "A675E2F4-CA8D-4126-906B-B279839377C2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:crypto:cronos:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.7.0", "matchCriteriaId": "7F1D7275-5477-4026-83F6-AFFA244561A8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:evmos:evmos:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.0", "matchCriteriaId": "6F059647-951E-4EE7-A5F8-644353B214D4"}]}]}], "references": [{"url": "https://github.com/evmos/ethermint/blob/c9d42d667b753147977a725e98ed116c933c76cb/x/evm/keeper/statedb.go#L199-L203", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/evmos/ethermint/commit/144741832007a26dbe950512acbda4ed95b2a451", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/evmos/ethermint/security/advisories/GHSA-f92v-grc2-w2fg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/evmos/ethermint/commit/144741832007a26dbe950512acbda4ed95b2a451"}}