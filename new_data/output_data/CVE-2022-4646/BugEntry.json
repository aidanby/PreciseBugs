{"buggy_code": ["![Rdiffweb Banner](https://gitlab.com/ikus-soft/rdiffweb/-/raw/master/doc/_static/banner.png)\n\n<p align=\"center\">\n<strong>\n<a href=\"https://www.rdiffweb.org\">website</a>\n\u2022 <a href=\"https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/\">docs</a>\n\u2022 <a href=\"https://groups.google.com/d/forum/rdiffweb\">community</a>\n\u2022 <a href=\"https://rdiffweb-demo.ikus-soft.com/\">demo</a>\n</strong>\n</p>\n\n<p align=\"center\">\n<a href=\"LICENSE\"><img alt=\"License\" src=\"https://img.shields.io/github/license/ikus060/rdiffweb\"></a>\n<a href=\"https://gitlab.com/ikus-soft/rdiffweb/pipelines\"><img alt=\"Build\" src=\"https://gitlab.com/ikus-soft/rdiffweb/badges/master/pipeline.svg\"></a>\n<a href=\"https://sonar.ikus-soft.com/dashboard?id=rdiffweb\"><img alt=\"Quality Gate Minarca Client\" src=\"https://sonar.ikus-soft.com/api/project_badges/measure?project=rdiffweb&metric=alert_status\"></a>\n<a href=\"https://sonar.ikus-soft.com/dashboard?id=rdiffweb\"><img alt=\"Coverage\" src=\"https://sonar.ikus-soft.com/api/project_badges/measure?project=rdiffweb&metric=coverage\"></a>\n<a href=\"https://bestpractices.coreinfrastructure.org/projects/6583\"><img src=\"https://bestpractices.coreinfrastructure.org/projects/6583/badge\"></a>\n</p>\n\n<h1 align=\"center\">\nWelcome to Rdiffweb\n</h1>\n\nRdiffweb is a web application that allows you to view repositories generated\nby [rdiff-backup](https://rdiff-backup.net/). The purpose of this\napplication is to ease the management of backups and quickly restore your data\nwith a rich and powerful web interface.\n\nRdiffweb is written in Python and is released as open source project under the \nGNU GENERAL PUBLIC LICENSE (GPL). All source code and documentation are\nCopyright Rdiffweb contributors.\n\nRdiffweb is actively developed by [IKUS Soft](https://www.ikus-soft.com/)\nsince November 2014.\n\nThe Rdiffweb source code is hosted on [Gitlab](https://gitlab.com/ikus-soft/rdiffweb)\nand mirrored to [Github](https://github.com/ikus060/rdiffweb).\n\nThe Rdiffweb website is https://rdiffweb.org/.\n\n## Features\n\nWith its rich web interface Rdiffweb provide a notable list of features:\n\n* Browse your backup\n* Restore single file or multiple files as an archived\n* Users authentication via local database and LDAP\n* Users authorization\n* Email notification when backup is not successful\n* Configurable repository encoding\n* Configurable retention period\n* Backup statistics visualization using graphs\n* SSH Keys management\n* Disk quota visualization\n* File and folder deletion\n\n## Demo\n\nIf you quickly want to check how Rdiffweb is behaving, you may try our demo server hosted on:\n\n[https://rdiffweb-demo.ikus-soft.com/](https://rdiffweb-demo.ikus-soft.com/)\n\nUse the following credential to login:\n\n* Username: admin\n* Password: admin123\n\n## Installation & Docker usage\n\nFor detailed installation steps, read the [Installation documentation](https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/installation.html).\n\n## Current Build Status\n\n[![Build Status](https://gitlab.com/ikus-soft/rdiffweb/badges/master/pipeline.svg)](https://gitlab.com/ikus-soft/rdiffweb/pipelines)\n\n## Download\n\nYou should read the [Documentation](https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/index.html) to properly install Rdiffweb in your environment.\n\n**Docker**\n\n    docker pull ikus060/rdiffweb\n\n**Debian**\n\n    curl -L https://www.ikus-soft.com/archive/rdiffweb/public.key | apt-key add - \n    echo \"deb https://nexus.ikus-soft.com/repository/apt-release-bullseye/ bullseye main\" > /etc/apt/sources.list.d/rdiffweb.list\n    apt update\n    apt install rdiffweb\n\n**Pypi**\n\n    pip install rdiffweb\n\n## Support\n\n### Mailing list\n\nRdiffweb users should use the [Rdiffweb mailing list](https://groups.google.com/forum/#!forum/rdiffweb).\n\n### Bug Reports\n\nBug reports should be reported on the Rdiffweb Gitlab at https://gitlab.com/ikus-soft/rdiffweb/-/issues\n\n### Professional support\n\nProfessional support for Rdiffweb is available by contacting [IKUS Soft](https://www.ikus-soft.com/en/support/#form).\n\n# Changelog\n\n## Next Release - 2.5.4\n\n* Discard `X-Forwarded-Host` headers credit to [Anishka Shukla](https://github.com/anishkashukla)\n* Create proper symbolic link of chartkick.js on Ubuntu Jammy to fix loading of Charts in web interface\n\n## 2.5.3 (2022-12-05)\n\n* Add support for WTForms v3 to support Debian Bookworm\n* Fix strange behavior in access token management #247\n\n## 2.5.2 (2022-11-28)\n\n* Block repository access when user_root directory is empty or relative path [CVE-2022-4314](https://nvd.nist.gov/vuln/detail/CVE-2022-4314) credit to [neverjunior](https://github.com/neverjunior)\n* Replace admin password only when `--admin-password` option is provided #246\n* Invalidate browser cache for `logo`, `headerlogo` and `favicon` on restart #245\n\n## 2.5.1 (2022-11-11)\n\n* Add support for Ubuntu Kinetic #240\n* Disable filesize for deleted files to improve page loading #241\n\n## 2.5.0 (2022-11-09)\n\nThis next release focus on two-factor-authentication as a measure to increase security of user's account.\n\n* Store User's session information into database\n* Update ldap plugin to load additional attributes from LDAP server\n* Improve `/status` page error handling when `session_statistics` cannot be read\n* Add support for Ubuntu Jammy\n* Upgrade from Bootstrap v3 to v4 #204\n* Replace Fontello by Font-Awesome v4\n* Use CSS variables `var()` to customize themes using `--branding-X` options #239\n* Remove usage of Jquery.validate\n* Replace custom timsort by jquery DataTables #205\n* Add Active Session managements #203\n  * Active session should be visible in user's profiles\n  * Active session may be revoked by user\n  * Active session should be visible in administration view\n  * Action session may be revoke by administrator\n  * Show number of active users within the last 24 hours in dashboard\n* Handle migration of older Rdiffweb database by adding the missing `repos.Encoding`, `repos.keepdays` and `users.role` columns #185\n* Replace deprecated references of `disutils.spawn.find_executable()` by `shutil.which()` #208\n* Add two-factor authentication with email verification #201\n* Generate a new session on login and 2FA #220\n* Enforce permission on /etc/rdiffweb configuration folder\n* Enforce validation on fullname, username and email\n* Limit incorrect attempts to change the user's password to prevent brute force attacks #225 [CVE-2022-3273](https://nvd.nist.gov/vuln/detail/CVE-2022-3273) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce password policy new password cannot be set as new password [CVE-2022-3376](https://nvd.nist.gov/vuln/detail/CVE-2022-3376) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce better rate limit on login, mfa, password change and API [CVE-2022-3439](https://nvd.nist.gov/vuln/detail/CVE-2022-3439) [CVE-2022-3456](https://nvd.nist.gov/vuln/detail/CVE-2022-3456) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce 'Origin' validation [CVE-2022-3457](https://nvd.nist.gov/vuln/detail/CVE-2022-3457) credit to [Nithissh12](Nithissh12)\n* Define idle and absolute session timeout with agressive default to protect usage on public computer [CVE-2022-3327](https://nvd.nist.gov/vuln/detail/CVE-2022-3327) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Send email notification when enabling or disabling MFA [CVE-2022-3363](https://nvd.nist.gov/vuln/detail/CVE-2022-3363) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Use Argon2id to store password hash #231\n* Fixed plugin priorities to ensure that jobs are scheduled at each startup #232\n* Revoke previous user's sessions on password change [CVE-2022-3362](https://nvd.nist.gov/vuln/detail/CVE-2022-3362) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\nBreaking changes:\n\n* Drop Ubuntu Hirsute & Impish (End-of-life)\n* `session-dir` is deprecated and should be replace by `rate-limit-dir`. User's session are stored in database.\n* previous `.css` customization are not barkward compatible. Make usage of the `--branding-X` options.\n\n**Thanks to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172) with whom I collaborate to improve the security of this project.**\n\n## 2.4.10 (2022-10-03)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate path traversal vulnerability [CVE-2022-3389](https://nvd.nist.gov/vuln/detail/CVE-2022-3389) credit to [Hoang Van Hiep](https://www.linkedin.com/in/hiephv2410/)\n\n## 2.4.9 (2022-09-28)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Add `Cache-Control` and other security headers [CVE-2022-3292](https://nvd.nist.gov/vuln/detail/CVE-2022-3292) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce password policy using `password-score` based on [zxcvbn](https://github.com/dropbox/zxcvbn) [CVE-2022-3326](https://nvd.nist.gov/vuln/detail/CVE-2022-3326) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.4.8 (2022-09-26)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Clean-up invalid path on error page\n* Limit username field length [CVE-2022-3290](https://nvd.nist.gov/vuln/detail/CVE-2022-3290) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit user's email field length [CVE-2022-3272](https://nvd.nist.gov/vuln/detail/CVE-2022-3272) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit user's root directory field length [CVE-2022-3295](https://nvd.nist.gov/vuln/detail/CVE-2022-3295) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit SSH Key title field length [CVE-2022-3298](https://nvd.nist.gov/vuln/detail/CVE-2022-3298) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.4.7 (2002-09-21)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Generate a new session on login and 2FA #220 [CVE-2022-3269](https://nvd.nist.gov/vuln/detail/CVE-2022-3269) credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n* Mitigate CSRF on user's settings #221 [CVE-2022-3274](https://nvd.nist.gov/vuln/detail/CVE-2022-3274) credit to [irfansayyed](https://github.com/irfansayyed-github)\n\n## 2.4.6 (2022-09-20)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Support MarkupSafe<3 for Debian bookworm\n* Mitigate CSRF on user's notification settings #216 [CVE-2022-3233](https://nvd.nist.gov/vuln/detail/CVE-2022-3233) credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n* Mitigate CSRF on repository settings #217 [CVE-2022-3267](https://nvd.nist.gov/vuln/detail/CVE-2022-3267) credit to [irfansayyed](https://github.com/irfansayyed-github)\n* Use 'Secure' Attribute with Sensitive Cookie in HTTPS Session on HTTP Error #218 [CVE-2022-3174](https://nvd.nist.gov/vuln/detail/CVE-2022-3174) credit to [Chuu](https://github.com/uonghoangminhchau)\n\n## 2.4.5 (2002-09-16)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate CSRF on repository deletion and user deletion [CVE-2022-3232](https://nvd.nist.gov/vuln/detail/CVE-2022-3232) #214 #215 credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n\n## 2.4.4 (2002-09-15)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Use `X-Real-IP` to identify client IP address to mitigate Brute-Force attack #213\n\n## 2.4.3 (2022-09-14)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate CSRF in profile's SSH Keys [CVE-2022-3221](https://nvd.nist.gov/vuln/detail/CVE-2022-3221) #212 credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n\n## 2.4.2 (2022-09-12)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Use 'Secure' Attribute with Sensitive Cookie in HTTPS Session. [CVE-2022-3174](https://nvd.nist.gov/vuln/detail/CVE-2022-3174) #209 credit to [Chuu](https://github.com/uonghoangminhchau)\n* Avoid leakage of the stack trace in the default error page. [CVE-2022-3175](https://nvd.nist.gov/vuln/detail/CVE-2022-3175) #210 credit to [Chuu](https://github.com/uonghoangminhchau)\n* Enforce minimum and maximum password length [CVE-2022-3175](https://nvd.nist.gov/vuln/detail/CVE-2022-3179) #211 credit to [Chuu](https://github.com/uonghoangminhchau)\n\n## 2.4.1 (2022-09-08)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Add Clickjacking Defense [CVE-2022-3167](https://nvd.nist.gov/vuln/detail/CVE-2022-3167) credit to [tharunavula](https://github.com/tharunavula)\n* Drop Ubuntu Hirsute & Impish (End-of-life)\n\n## 2.4.0 (2022-06-21)\n\nThis new release brings a lot of improvement since the last version, multiple bug fixes\nto make the application stable. A couple of new features to improve the overall\nusability and a new security feature to block a brute force attack.\n\n* Add RateLimit to login page and API to mitigate robots attacks #167\n* Send email notification only if `email-sender` option is defined to avoid raising exception in logs #176\n* Support file restore cancellation without leaving `rdiffweb-restore` process in `<defunct>` state #174\n* Replace `python-ldap` by `ldap3` a pure python implementation to avoid dependencies on `sasl` and `ldap` binaries #186\n* Reffactor core module to allow better extendability and reusability #183\n* Add support for Debian Bookworm #180\n* Add support for Ubuntu Impish #175\n* Add rdiff-backup version to administration view\n* Run unit test during Debian build package\n* Refresh repository list automatically when required #188 #189\n* Fix error 500 displayed in status page #191\n* Improve repository browsing speed by minimizing the number of I/O call #192\n* Publish Docker image directly to DockerHub #144\n* Add REST API to manage sshkeys\n\nBreaking changes:\n\n* Ldap Password changes is not supported anymore.\n* Ldap Check Shadow expire config is not supported anymore. It should be replace by a custom filter.\n* Drop CentOS 7 and CentOS 8 support\n\n## 2.3.9 (2022-01-05)\n\nMaintenance release to fix minor issues\n\n* Improve date parsing for `backup.log` to avoid printing exception in logs #170\n* Return HTTP error 403 for invalid symlink to avoid returning a misleading HTTP 500 Server Error #168\n* Show a user friendly error message when trying to create a new user with an existing username #169\n* Handle repository without last-backup date during the notification process to ensure notifications are sent #171\n* Replace CherryPy `storage_type` by `storage_class` to avoid warning in logs\n* Update code to avoid deprecation warning where applicable\n* Add Flake8 validation to improve code quality\n* Remove Ubuntu Groovy support\n\n## 2.3.8 (2021-12-01)\n\n* Push all artefacts to nexus server including binaries and documentation\n* Fix `Chart.js` loading on Debian bullseye #164\n* Update installation steps documentation\n* Improve LDAP authentication to lookup entire directory\n* Fix usage of `--ldap-add-user-default-userroot` to avoid error related to wrong encoding\n* Improve authentication mechanics\n* Avoid raising an HTTP error 500 when login form receive invalid payload\n* Mitigate open redirect vulnerability in login form\n\n## 2.3.7 (2021-10-21)\n\n* To avoid backward compatibility issue, revert CSRF Token validation\n* Mitigate CSRF vulnerability using cookies with `SameSite=Lax`\n* Mitigate CSRF vulnerability by validating the `Origin` header when a form is submited\n* Improve usage of WTForm for all form validation\n* Update installation stepd for debian #162\n* Build Ubuntu packages and publish them to our APT repo\n\n## 2.3.6 (2021-10-20)\n\n* Broken build\n\n## 2.3.5 (2021-10-18)\n\n* Mitigate CSRF vulnerability to user, ssh and repo management with CSRF Token\n\n## 2.3.4 (2021-09-20)\n\n* Skip email notification if `email-host` configuration is not provided #157\n* Skip email notification when the new attribute value has the same value #159\n* USE LDAP `mail` attribute when creating new user from LDAP directory #156\n\n## 2.3.3 (2021-09-10)\n\n* Provide a new theme `blue` to match IKUS Soft colors #158\n\n## 2.3.2 (2021-09-07)\n\n* Automatically update user's repository list based on user's home directory\n\n## 2.3.1 (2021-07-14)\n\n* Update default `session-dir` location to `/var/lib/rdiffweb/session` to avoid using `/var/run` #148\n\n## 2.3.0 (2021-07-06)\n\n* Improve timezone handling to display date with local timezone using javascript #143\n* Improve charts by replacing d3js by chartkick #122\n* Replace the status view by something meaningful with chartkick #122\n* Provide Docker image with Rdiffweb `docker pull ikus060/rdiffweb` #55\n* Fix file and folder sorting #143\n\n## 2.2.0 (2021-05-11)\n\n* Debian package:\n  * Add rdiff-backup as dependencies to comply with Debian packaging rules\n  * Multiple other fixed to control files\n  * Use debhelper-compat (= 13)\n  * Use debhelper-compat (= 13)\n  * Run test during packaging\n  * Create default folder `/var/run/rdiffweb/sessions` to store user session\n* Use ConfigArgPare for configuration to support configuration file, environment variables and arguments to configure rdiffweb #114\n* Fix cache in localization module\n* Add `ldap-add-default-role` and `ldap-add-default-userroot` option to define default value for role and user root when creating user from LDAP #125\n* Support PostgreSQL database by replacing our storage layer by SQLAlchemy #126\n* Fix to retrieve user quota only for valid user_root #135\n* Add option `disable-ssh-keys` to disable SSH Key management\n* Use absolute URL everywhere\n* Add support for `X-Forwarded-For`, `X-Forwarded-proto` and other reverse proxy header when generating absolute URL\n* Drop Debian Stretch support\n* Implement a new background scheduler using apscheduler #82\n* Use background job to send email notification to avoid blocking web page loading #47\n* Use background job to delete repository to avoid blocking web page loading #48\n* Allow deleting a specific file or folder from the history using `rdiff-backup-delete` #128\n* Improve support for `session-dir` #131\n* Add option `admin-password` to define administrator password for better security\n* Improve performance of repository browsing\n* Add a new view to display logs of a specific repository\n* Allow downloading the log\n* Define a default limit to graph statistics to make it display faster\n* Fix `get-quota-cmd` option to properly return a value\n\n## 2.1.0 (2021-01-15)\n\n* Debian package: Remove dh-systemd from Debian build dependencies (https://bugs.debian.org/871312we)\n* Improve Quota management:\n  * `QuotaSetCmd`, `QuotaGetCmd` and `QuotaUsedCmd` options could be used to customize how to set the quota for your environment.\n  * Display user's quota in User View\n  * Display user's quota in Admin View\n  * Allow admin to update user quota from Admin View when `QuotaSetCmd` is defined.\n  * Allow admin to define user quota using human readable value (e.g.: GiB, TiB, etc.)\n  * Improve logging around quota management\n* Improve robustness when service is starting\n* Improve robustness when repository has wrong permission defined (e.g.: when some files not readable)\n* Add user id in Admin view\n* Replace `UserObject(1)` by the actual username in log file to improve debugging\n\n## 2.0.0 (2020-12-04)\n\n* Re-implement logic to update repositories views to remove duplicates and avoid nesting repo. #107\n* Handle elapsed time of days in the graph. Thanks [Nathaniel van Diepen](https://github.com/Eeems) contributions.\n* Rebrand all link to ikus-soft.com\n* Update documentation to install rdiffweb\n* Remove obsolete minify dependency\n* Drop support for python2\n* Provide null translation if translation catalogues are not found\n* Pass a LANG environment variable to rdiff-backup restore process to fix encoding issue #112\n* Remove obsolete python shebang\n* Remove execution bit (+x) on python modules\n* Provide `--help` and `--version` on `rdiffweb` executable\n* Improve cherrypy version detection\n* Do not update translation files (.mo) during build\n\n## 1.5.0 (2020-06-24)\n\nThis minor release introduce official support of rdiffweb on Debian Bullseye. It also includes some usability improvements.\n\n* Change formatting of Last Backup date for \"Updated 3 weeks ago\" to ease the readability\n* Add support for Debian Bullseye\n* Add support for Python 3.8 (#104)\n* Add warning in the users list view when a root directory is invalid (#30)\n* Add options to control search depthness (#1)\n* Print a warning in the log when the \"DefaultTheme\" value is not valid (#90)\n\n## 1.4.0 (2020-05-20)\n\nThanks to our sponsor, this release introduce a feature to have better control over the user's permission by defining 3 different levels of privilege: Admin, Maintainer and User. This addition allows you to have better control on what your users can or can't do.\n\n* Fix single repository discovery when a user's home is a rdiff-backup repository\n* [SPONSORED] Add a new setting at the user level to define the user's role. Admin,\n   Maintainer and User. Admin are allowed to do everything. Maintainer are\n   allow to browse and delete repo. Users are only allowed to browse. #94\n* Add \"Powered by\" in the web interface footer #91\n* Display a nice error message when trying to delete admin user #93\n* Introduce usage of wtforms and flash in admin users for better form validation. #96 #97\n* Update French translation\n\n## 1.3.2 (2020-04-23)\n\nThis minor releases fixed issues found while testing release 1.3.0.\n\n* Fix lookup of executable rdiff-backup and rdiffweb-restore to search in current virtualenv first\n* Fix repository view when multiple repo path are conflicting\n* Fix logging of rdiffweb-restore subprocess\n\n## 1.3.1 (2020-04-10)\n\nThis minor release enforces security of the password stored in rdiffweb database to make use of a better encryption using SSHA.\nOnly new passwords will make use of the SSHA scheme.\n\n* Enforce password encryption by using SSHA scheme #88\n\n## 1.3.0 (2020-04-07)\n\nThis release focuses on improving the restore of big archives. The download should be much faster to start. Major enhancement was made to offload the processing outside the web server. And all of this is still compatible with rdiff-backup v1.2.8 and the latest v2.0.0.\n\n* Restore file and folder in a subprocess to make the download start faster\n* Fix encoding of archive on Python3.6 (CentOS 7) by using PAX format\n* Add support to restore files and folders using rdiff-backup2\n* Remove obsolete dependencies `pysqlite2`\n* Fix issue creating duplicate entries of repository in the database\n\n## 1.2.2 (2020-03-05)\n\nThis release provides little improvement to the v1.2.x including official support of rdiff-backup v2.0.0.\n\n* Enhance the repository to invite users to refresh the repository when the view is empty.\n* Support rdiff-backup v2.0.0\n* Deprecate support for cherrypy 4, 5, 6 and 7\n* Improve loading of repository data (cache status and entries)\n* Restore compatibility with SQLite 3.7 (CentOS7)\n\nKnown issues:\n\n* Filename encoding in tar.gz and zip file might not be accurate if you are running Python 3.6 (CentOS7)\n\n## 1.2.1 (2020-02-08)\n\nLittle bug fix following the previous release\n\n* Fix 404 error when trying to access other users repo as admin\n* Fix logging format for cherrypy logs to matches rdiffweb format\n* Add log rotation by default\n\n## 1.2.0 (2020-01-30)\n\nThis release focus on improving the database layers for better extendability to add more type of data and to support more databases backend like postgresql in the near future.\n\n* Add explicit testing for Debian Stretch & Buster\n* Change the persistence layers\n  * Minimize number of SQL queries\n  * Add object lazy loading\n  * Add object data caching\n* Fix bugs with SQLite <= 3.16 (Debian Stretch)\n\n## 1.1.0 (2019-10-31)\n\nThis release focus on improving the admin area and building the fundation for repository access control list (ACL).\n\n* Update documentation from PDSL web site\n* Improve the navigation bar layout\n* Update the login page headline\n* Update jinja2 version to allow 2.10.x\n* Show server log in admin area\n* Reduce code smell\n* Add System information in admin area\n* Validate credential using local database before LDAP\n* Reffactoring templates macros\n* Enhance user's view search bar\n* Change repository URL to username/repopath\n* Add System information in admin area\n* Improve testcases\n* Clean-up obsolete code\n* Fix issue with captital case encoding name\n* Fix compilation of less files\n* Fix google font import\n\n## 1.0.3 (2019-10-04)\n\n* Removing the auto update repos\n\n## 1.0.2 (2019-10-01)\n\n* Create \"admin\" user if missing\n* Update french translation\n\n## 1.0.1 (2019-09-22)\n\n* Update installation documentation\n* Fix removal of SSH Key\n* Return meaningful error to the user trying to add an existing SSH key\n\n## 1.0.0 (2019-09-11)\n\n* Make repository removal more robust\n* Improve performance of librdiff\n* Add new RESTful api\n* Return the right HTTP 401 or 402 error code for authentication\n* Fix bug introduce by upgrade to Jinja2 + python3\n* Store ssh keys in database and disk\n* Add support for theme (default, orange)\n* Remove deprecated profiling code\n* Add disk usage support / quota\n* Add support of cherrypy v18\n* Drop support of cherrypy v3.2.2\n* Add wsgi entry point\n* Replace the plugins architecture to ease implementation\n* Numerous bug fixes\n\n## 0.10.9 (2019-05-22)\n\n* Better error handling when error.log file are not valid gzip file\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Mar 13, 2019\n\n@author: Patrik Dufresne\n\"\"\"\n\nimport datetime\n\nfrom parameterized import parameterized, parameterized_class\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import DbSession, SessionObject\n\n\nclass ControllerTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    default_config = {'HeaderName': 'MyTest'}\n\n    def test_headername(self):\n        \"\"\"\n        Check if the headername is used in the page.\n        \"\"\"\n        self.getPage(\"/\")\n        self.assertStatus('200 OK')\n        self.assertInBody('MyTest')\n\n    def test_proxy(self):\n        \"\"\"\n        Check if the headername is used in the page.\n        \"\"\"\n        self.getPage(\"/\", headers=[('Host', 'this.is.a.test.com')])\n        self.assertStatus('200 OK')\n        self.assertInBody('http://this.is.a.test.com/favicon.ico')\n\n    def test_proxy_https(self):\n        \"\"\"\n        Check if the headername is used in the page.\n        \"\"\"\n        self.getPage(\"/\", headers=[('Host', 'this.is.a.test.com'), ('X-Forwarded-Proto', 'https')])\n        self.assertStatus('200 OK')\n        self.assertInBody('https://this.is.a.test.com/favicon.ico')\n\n    @parameterized.expand(\n        [\n            '/favicon.ico',\n            '/default.css',\n            '/logo',\n            '/header_logo',\n            '/static/css/bootstrap.min.css',\n            '/static/css/font-awesome.min.css',\n            '/static/css/jquery.dataTables.min.css',\n            '/static/js/bootstrap.bundle.min.js',\n            '/static/js/jquery.dataTables.min.js',\n            '/static/js/jquery.min.js',\n            '/static/js/rdiffweb.js',\n        ]\n    )\n    def test_static_files(self, path):\n        \"\"\"\n        Check if the theme is properly configure.\n        \"\"\"\n        self.getPage('/logout')\n        self.getPage(path)\n        self.assertStatus(200)\n        # Test with invalid method.\n        self.getPage(path, method=\"POST\")\n        self.assertStatus(400)\n\n    def test_static_invalid_file(self):\n        \"\"\"\n        Check if the theme is properly configure.\n        \"\"\"\n        self.getPage(\"/static/invalid.css\")\n        self.assertStatus(400)\n\n    def test_path_traversal(self):\n        self.getPage('/static//../../test.txt')\n        self.assertStatus(403)\n\n\n@parameterized_class(\n    [\n        {\"default_config\": {'DefaultTheme': 'default'}, \"expect_color\": '#35979c'},\n        {\"default_config\": {'DefaultTheme': 'orange'}, \"expect_color\": '#dd4814'},\n        {\"default_config\": {'DefaultTheme': 'blue'}, \"expect_color\": '#153a58'},\n        {\"default_config\": {'link-color': '111'}, \"expect_color\": '#111'},\n        {\"default_config\": {'navbar-color': '222'}, \"expect_color\": '#222'},\n        {\"default_config\": {'font-family': 'Sans'}, \"expect_color\": 'Sans'},\n    ]\n)\nclass ControllerThemeTest(rdiffweb.test.WebCase):\n\n    default_config = {}\n\n    expect_color = ''\n\n    def test_static(self):\n        # Query css with uniq value to avoid caching.\n        self.getPage(\"/default.css\")\n        self.assertStatus('200 OK')\n        self.assertInBody(self.expect_color)\n\n\nclass ControllerSession(rdiffweb.test.WebCase):\n    def test_enrich_session_anonymous(self):\n        # When making a query to a page while unauthenticated\n        self.getPage('/', headers=[('User-Agent', 'test')])\n        # Then a session object is enriched\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertIsNotNone(session.get('ip_address'))\n        self.assertIsNotNone(session.get('user_agent'))\n        self.assertIsNotNone(session.get('access_time'))\n\n    def test_enrich_session_authenticated(self):\n        # When making a query to a page while unauthenticated\n        self.getPage(\n            '/login/',\n            method='POST',\n            headers=[('User-Agent', 'test')],\n            body={'login': self.USERNAME, 'password': self.PASSWORD},\n        )\n        # Then a session object is enriched\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertIsNotNone(session.get('ip_address'))\n        self.assertIsNotNone(session.get('user_agent'))\n        self.assertIsNotNone(session.get('access_time'))\n\n    def test_create_session(self):\n        # Given a server with no session.\n        self.assertEqual(0, len(SessionObject.query.all()))\n        # When querying a new page\n        self.getPage('/')\n        self.assertStatus(303)\n        # Then a new session get created\n        self.assertEqual(1, len(SessionObject.query.all()))\n        session = SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        self.assertIsNotNone(session)\n\n    def test_clean_up_session(self):\n        # Given a server with a session\n        self.getPage('/')\n        self.assertStatus(303)\n        self.assertEqual(1, len(SessionObject.query.all()))\n        # When this session get old\n        data = SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        data.expiration_time = datetime.datetime.now() - datetime.timedelta(seconds=1)\n        data.commit()\n        session = DbSession(id=self.session_id)\n        # Then the session get deleted by clean_up process\n        session.clean_up()\n        # Then session is deleted\n        data = SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        self.assertIsNone(data)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom unittest.mock import ANY, MagicMock\n\nimport cherrypy\nfrom parameterized import parameterized\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import UserObject\n\n\nclass AbstractAdminTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    def setUp(self):\n        super().setUp()\n        self._quota = {}\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)\n        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)\n        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n        self.listener.get_disk_quota.side_effect = self._load_quota\n        cherrypy.engine.subscribe('get_disk_quota', self.listener.get_disk_quota, priority=40)\n        self.listener.get_disk_usage.return_value = 0\n        cherrypy.engine.subscribe('get_disk_usage', self.listener.get_disk_usage, priority=40)\n        self.listener.set_disk_quota.side_effect = self._store_quota\n        cherrypy.engine.subscribe('set_disk_quota', self.listener.set_disk_quota, priority=40)\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)\n        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)\n        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        cherrypy.engine.unsubscribe('get_disk_quota', self.listener.get_disk_quota)\n        cherrypy.engine.unsubscribe('get_disk_usage', self.listener.get_disk_usage)\n        cherrypy.engine.unsubscribe('set_disk_quota', self.listener.set_disk_quota)\n        return super().tearDown()\n\n    def _store_quota(self, userobj, value):\n        self._quota[userobj.username] = value\n\n    def _load_quota(self, userobj):\n        return self._quota.get(userobj.username, 0)\n\n    def _add_user(self, username=None, email=None, password=None, user_root=None, role=None, mfa=None, fullname=None):\n        b = {}\n        b['action'] = 'add'\n        if username is not None:\n            b['username'] = username\n        if email is not None:\n            b['email'] = email\n        if password is not None:\n            b['password'] = password\n        if user_root is not None:\n            b['user_root'] = user_root\n        if role is not None:\n            b['role'] = str(role)\n        if mfa is not None:\n            b['mfa'] = str(mfa)\n        if fullname is not None:\n            b['fullname'] = str(fullname)\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def _edit_user(\n        self, username=None, email=None, password=None, user_root=None, role=None, disk_quota=None, mfa=None\n    ):\n        b = {}\n        b['action'] = 'edit'\n        if username is not None:\n            b['username'] = username\n        if email is not None:\n            b['email'] = email\n        if password is not None:\n            b['password'] = password\n        if user_root is not None:\n            b['user_root'] = user_root\n        if role is not None:\n            b['role'] = str(role)\n        if disk_quota is not None:\n            b['disk_quota'] = disk_quota\n        if mfa is not None:\n            b['mfa'] = str(mfa)\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def _delete_user(self, username='test1'):\n        b = {'action': 'delete', 'username': username}\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def test_add_user_with_role_admin(self):\n        # When trying to create a new user with role admin\n        self._add_user(\"admin_role\", \"admin_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.ADMIN_ROLE)\n        # Then page return success\n        self.assertStatus(200)\n        # Then database is updated\n        userobj = UserObject.get_user('admin_role')\n        self.assertEqual(UserObject.ADMIN_ROLE, userobj.role)\n        # Then notification was raised\n        self.listener.user_added.assert_called_once_with(userobj)\n\n    def test_add_user_with_role_maintainer(self):\n        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.MAINTAINER_ROLE)\n        self.assertStatus(200)\n        self.assertEqual(UserObject.MAINTAINER_ROLE, UserObject.get_user('maintainer_role').role)\n\n    def test_add_user_with_role_user(self):\n        self._add_user(\"user_role\", \"user_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        self.assertEqual(UserObject.USER_ROLE, UserObject.get_user('user_role').role)\n\n    def test_add_user_with_invalid_role(self):\n        # When trying to create a new user with an invalid role (admin instead of 0)\n        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", 'admin')\n        # Then an error message is displayed to the user\n        self.assertStatus(200)\n        self.assertInBody('Role: Invalid Choice: could not coerce')\n        # Then listener are not called\n        self.listener.user_added.assert_not_called()\n\n        # When trying to create a new user with an invalid role (-1)\n        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", -1)\n        # Then an error message is displayed to the user\n        self.assertStatus(200)\n        self.assertInBody('User Role: Not a valid choice')\n        # Then listener are not called\n        self.listener.user_added.assert_not_called()\n\n    def test_add_edit_delete(self):\n        #  Add user to be listed\n        self.listener.user_password_changed.reset_mock()\n        self._add_user(\n            \"test2\", \"test2@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE, mfa=UserObject.DISABLED_MFA\n        )\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"test2\")\n        self.assertInBody(\"test2@test.com\")\n        self.listener.user_added.assert_called_once()\n        self.listener.user_password_changed.assert_called_once()\n        self.listener.user_password_changed.reset_mock()\n        #  Update user\n        self._edit_user(\n            \"test2\", \"chaned@test.com\", \"new-password\", \"/tmp/\", UserObject.ADMIN_ROLE, mfa=UserObject.ENABLED_MFA\n        )\n        self.listener.user_attr_changed.assert_called()\n        self.listener.user_password_changed.assert_called_once()\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertInBody(\"test2\")\n        self.assertInBody(\"chaned@test.com\")\n        self.assertNotInBody(\"/home/\")\n        self.assertInBody(\"/tmp/\")\n\n        self._delete_user(\"test2\")\n        self.listener.user_deleted.assert_called()\n        self.assertStatus(200)\n        self.assertInBody(\"User account removed.\")\n        self.assertNotInBody(\"test2\")\n\n    @parameterized.expand(\n        [\n            # Invalid\n            ('evil.com', False),\n            ('http://test', False),\n            ('email@test.test', False),\n            ('/test/', False),\n            # Valid\n            ('My fullname', True),\n            ('Test Test', True),\n            ('\u00c9ric Terrien-Pascal', True),\n            (\"Tel'c\", True),\n        ]\n    )\n    def test_edit_fullname_with_special_character(self, new_fullname, expected_valid):\n        # Given an existing user\n        # When updating the user's fullname\n        self.getPage(\n            \"/admin/users/\",\n            method='POST',\n            body={'action': 'edit', 'username': self.USERNAME, 'fullname': new_fullname},\n        )\n        self.assertStatus(200)\n        if expected_valid:\n            self.assertInBody(\"User information modified successfully.\")\n            self.assertNotInBody(\"Fullname: Must not contain any special characters.\")\n        else:\n            self.assertNotInBody(\"User information modified successfully.\")\n            self.assertInBody(\"Fullname: Must not contain any special characters.\")\n\n    @parameterized.expand(\n        [\n            # Invalid\n            ('http://username', False),\n            ('username@test.test', False),\n            ('/username/', False),\n            # Valid\n            ('username.com', True),\n            ('admin_user', True),\n            ('test.test', True),\n            ('test-test', True),\n        ]\n    )\n    def test_add_user_with_special_character(self, new_username, expected_valid):\n        self._add_user(new_username, \"eric@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        if expected_valid:\n            self.assertInBody(\"User added successfully.\")\n            self.assertNotInBody(\"Username: Must not contain any special characters.\")\n        else:\n            self.assertNotInBody(\"User added successfully.\")\n            self.assertInBody(\"Username: Must not contain any special characters.\")\n\n    def test_add_user_with_empty_username(self):\n        \"\"\"\n        Verify failure trying to create user without username.\n        \"\"\"\n        self._add_user(\"\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        self.assertInBody(\"Username: This field is required.\")\n\n    def test_add_user_with_existing_username(self):\n        \"\"\"\n        Verify failure trying to add the same user.\n        \"\"\"\n        # Given a user named `test1`\n        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        # When trying to create a new user with the same name\n        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then the user list is displayed with an error message.\n        self.assertStatus(200)\n        self.assertInBody(\"User test1 already exists.\")\n\n    def test_add_user_with_invalid_root_directory(self):\n        \"\"\"\n        Verify failure to add a user with invalid root directory.\n        \"\"\"\n        try:\n            self._delete_user(\"test5\")\n        except Exception:\n            pass\n        self._add_user(\"test5\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")\n\n    def test_add_without_email(self):\n        #  Add user to be listed\n        self._add_user(\"test2\", None, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n\n    def test_add_without_user_root(self):\n        #  Add user to be listed\n        self._add_user(\"test6\", None, \"pr3j5Dwi\", None, UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n\n        user = UserObject.get_user('test6')\n        self.assertEqual('', user.user_root)\n\n    def test_add_with_username_too_long(self):\n        # Given a too long username\n        username = \"test2\" * 52\n        # When trying to create the user\n        self._add_user(username, None, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Username too long.\")\n\n    def test_add_with_email_too_long(self):\n        # Given a too long username\n        email = (\"test2\" * 50) + \"@test.com\"\n        # When trying to create the user\n        self._add_user(\"test2\", email, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Email too long.\")\n\n    def test_add_with_user_root_too_long(self):\n        # Given a too long user root\n        user_root = \"/temp/\" * 50\n        # When trying to create the user\n        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", user_root, UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Root directory too long.\")\n\n    def test_add_with_fullname_too_long(self):\n        # Given a too long user root\n        fullname = \"fullname\" * 50\n        # When trying to create the user\n        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE, fullname=fullname)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Fullname too long.\")\n\n    def test_delete_user_with_not_existing_username(self):\n        \"\"\"\n        Verify failure to delete invalid username.\n        \"\"\"\n        self._delete_user(\"test3\")\n        self.assertInBody(\"User doesn&#39;t exists!\")\n\n    def test_delete_our_self(self):\n        \"\"\"\n        Verify failure to delete our self.\n        \"\"\"\n        self._delete_user(self.USERNAME)\n        self.assertInBody(\"You cannot remove your own account!\")\n\n    def test_delete_user_admin(self):\n        \"\"\"\n        Verify failure to delete our self.\n        \"\"\"\n        # Create another admin user\n        self._add_user('admin2', '', 'pr3j5Dwi', '', UserObject.ADMIN_ROLE)\n        self.getPage(\"/logout\")\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        self._login('admin2', 'pr3j5Dwi')\n\n        # Try deleting admin user\n        self._delete_user(self.USERNAME)\n        self.assertStatus(200)\n        self.assertInBody(\"can&#39;t delete admin user\")\n\n    def test_delete_user_method_get(self):\n        # Given a user\n        user = UserObject.add_user('newuser')\n        user.commit()\n        # When trying to delete this user using method GET\n        self.getPage(\"/admin/users/?action=delete&username=newuser\", method='GET')\n        # Then page return without error\n        self.assertStatus(200)\n        # Then user is not deleted\n        self.assertIsNotNone(UserObject.get_user('newuser'))\n\n    def test_change_password_with_too_short(self):\n        self._edit_user(self.USERNAME, password='short')\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_too_long(self):\n        new_password = 'a' * 129\n        self._edit_user(self.USERNAME, password=new_password)\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_admin_password(self):\n        # Given rdiffweb is configured with admin-password option\n        self.app.cfg.admin_password = 'hardcoded'\n        try:\n            # When trying to update admin password\n            self._edit_user('admin', password='new-password')\n            # Then the form is refused with 200 OK with an error message.\n            self.assertStatus(200)\n            self.assertInBody(\"can&#39;t update admin-password defined in configuration file\")\n        finally:\n            self.app.cfg.admin_password = None\n\n    def test_edit_user_with_invalid_path(self):\n        \"\"\"\n        Verify failure trying to update user with invalid path.\n        \"\"\"\n        userobj = UserObject.add_user('test1')\n        userobj.commit()\n        self._edit_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", UserObject.USER_ROLE)\n        self.assertNotInBody(\"User added successfully.\")\n        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")\n\n    def test_list(self):\n        self.getPage(\"/admin/users/\")\n        self.assertInBody(\"Users\")\n        self.assertInBody(\"User management\")\n        self.assertInBody(\"Add user\")\n\n    def test_edit_user_with_not_existing_username(self):\n        \"\"\"\n        Verify failure trying to update invalid user.\n        \"\"\"\n        # Given an invalid username\n        username = 'invalid'\n        # When trying to edit the user\n        self._edit_user(username, \"test1@test.com\", \"test\", \"/var/invalid/\", UserObject.USER_ROLE)\n        # Then the user list is displayed with an error message\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot edit user `invalid`: user doesn&#39;t exists\")\n\n    def test_user_invalid_root(self):\n        # Change the user's root\n        user = UserObject.get_user(self.USERNAME)\n        user.user_root = \"/invalid\"\n        user.commit()\n        self.getPage(\"/admin/users\")\n        self.assertInBody(\"Root directory not accessible!\")\n\n        # Query the page by default\n        user = UserObject.get_user('admin')\n        user.user_root = \"/tmp/\"\n        user.commit()\n        self.getPage(\"/admin/users\")\n        self.assertNotInBody(\"Root directory not accessible!\")\n\n    def test_get_quota(self):\n        # Mock a quota.\n        self.listener.get_disk_quota.side_effect = None\n        self.listener.get_disk_quota.return_value = 654321\n        # When querying the user list\n        self.getPage(\"/admin/users/\")\n        self.assertStatus(200)\n        # Then get_disk_quota listenre is called\n        self.listener.get_disk_quota.assert_called()\n        # Then the quota value is displayed in human readable format\n        self.assertInBody(\"638.99 KiB\")\n        self.assertStatus(200)\n\n    def test_set_quota(self):\n        # When updating user quota.\n        self._edit_user(\"admin\", disk_quota='8765432')\n        # Then listenr get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_gib(self):\n        # When updating user quota\n        self._edit_user(\"admin\", disk_quota='1GiB')\n        # Then listern get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 1073741824)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_with_comma(self):\n        # When updating quota with comma value\n        self._edit_user(\"admin\", disk_quota='1,5 GiB')\n        # Then listner get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 1610612736)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_with_leading_dot(self):\n        # When updating quota with leading dot\n        self._edit_user(\"admin\", disk_quota='.5 GiB')\n        # Then listener get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 536870912)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_empty(self):\n        # When quota is not defined\n        self._edit_user(\"admin\", disk_quota='')\n        # Then listener is not called.\n        self.listener.set_disk_quota.assert_not_called()\n        # Then message is not displayed\n        self.assertStatus(200)\n\n    def test_set_quota_same_value(self):\n        # Given an exiting quota\n        self.listener.get_disk_quota.side_effect = None\n        self.listener.get_disk_quota.return_value = 1234567890\n        # When setting the quota value to the same value\n        self._edit_user(\"admin\", disk_quota='1.15 GiB')\n        #  Then listener is not called\n        self.listener.set_disk_quota.assert_not_called()\n        # Then message is not displayed\n        self.assertStatus(200)\n\n    def test_set_quota_unsupported(self):\n        # Given setting quota is not supported\n        self.listener.set_disk_quota.side_effect = None\n        self.listener.set_disk_quota.return_value = None\n        # When updating the quota\n        self._edit_user(\"admin\", disk_quota='8765432')\n        # Then\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)\n        self.assertInBody(\"Setting user&#39;s quota is not supported\")\n        self.assertStatus(200)\n\n    def test_edit_own_role(self):\n        # Given an administrator\n        # When trygin to update your own role\n        self._edit_user(username=self.USERNAME, role=UserObject.MAINTAINER_ROLE)\n        # Then an error is returned\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot edit your own role.\")\n\n    def test_edit_own_mfa(self):\n        # Given an administrator\n        # When trygin to update your own role\n        self._edit_user(username=self.USERNAME, mfa=UserObject.ENABLED_MFA)\n        # Then an error is returned\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot change your own two-factor authentication settings.\")\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Dec 26, 2015\n\n@author: Patrik Dufresne\n\"\"\"\nimport os\n\nfrom parameterized import parameterized, parameterized_class\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import DbSession, SessionObject, UserObject\nfrom rdiffweb.tools.auth_form import LOGIN_TIME, SESSION_KEY\n\n\nclass LoginPageTest(rdiffweb.test.WebCase):\n    def test_getpage(self):\n        # When making a query to a page while unauthenticated\n        self.getPage('/')\n        # Then user is redirected to login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # Then a session object is created without a username\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertIsNone(session.get(SESSION_KEY))\n\n    def test_login_success(self):\n        # Given an anonymous user\n        self.getPage('/')\n        prev_session_id = self.session_id\n        # Then user is redirected to /login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # When authenticating with valid credentials.\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        # Then a new session_id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Then a session object is created with a username\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertEqual('admin', session.get(SESSION_KEY))\n        self.assertIsNotNone(session.get(LOGIN_TIME))\n\n    def test_cookie_http_only(self):\n        # Given a request made to rdiffweb\n        # When receiving the response\n        self.getPage('/')\n        # Then the header contains Set-Cookie with HttpOnly\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('HttpOnly', cookie)\n\n    def test_login_with_plaintext(self):\n        \"\"\"\n        Requesting plain text without being authenticated should show the login form.\n        \"\"\"\n        # When querying root page without authentication\n        self.getPage('/', headers=[(\"Accept\", \"text/plain\")])\n        # Then user is redirected to /login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n\n    @parameterized.expand(\n        [\n            ('with_root', '/'),\n            ('with_browse_url', '/browse/admin/testcases/Revisions/'),\n            ('with_encoded_url', '/browse/admin/testcases/DIR%EF%BF%BD/'),\n            (\n                'with_broken_encoding',\n                '/restore/admin/testcases/Fichier%20avec%20non%20asci%20char%20%C9velyne%20M%E8re.txt/?date=1415221507',\n            ),\n            ('with_query_string', '/restore/admin/testcases/Revisions?date=1477434528'),\n            ('with_multiple_query_string', '/restore/admin/testcases/Revisions?date=1477434528&kind=tar.gz'),\n            ('with_admin', '/admin/'),\n        ]\n    )\n    def test_login(self, unused, original_url):\n        # Given an unauthenticated user\n        # Query the page without login-in\n        self.getPage(original_url)\n        # Then user is redirected to the login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # When authentication is successful\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        # Then user is redirected to original URL\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + original_url)\n        # Then cookie is not persistent\n        self.assertNotIn('expires', self.cookies[0][1])\n        self.assertNotIn('Max-Age', self.cookies[0][1])\n        # When requesting the original page\n        self.getPage(original_url)\n        # Then page return without error\n        self.assertStatus(200)\n\n    def test_getpage_with_redirect_post(self):\n        \"\"\"\n        Check encoding of redirect url when send using POST method.\n        \"\"\"\n        # When posting invalid credentials\n        b = {'login': 'admin', 'password': 'invalid', 'redirect': '/browse/' + self.REPO + '/DIR%EF%BF%BD/'}\n        self.getPage('/login/', method='POST', body=b)\n        # Then page return without HTTP Error\n        self.assertStatus('200 OK')\n        # Then page display an error\n        self.assertInBody('Invalid username or password.')\n        self.assertInBody('id=\"form-login\"')\n        # Then redirect URL is ignored\n        self.assertNotInBody('/browse/' + self.REPO + '/DIR%EF%BF%BD/\"')\n\n    def test_getpage_without_username(self):\n        \"\"\"\n        Check if error is raised when requesting /login without a username.\n        \"\"\"\n        self.getPage('/login/', method='GET')\n        self.assertStatus('200 OK')\n\n    def test_getpage_with_username_too_long(self):\n        b = {'login': 'admin' * 52, 'password': 'admin123'}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('200 OK')\n        self.assertInBody('Username too long.')\n\n    def test_getpage_with_empty_password(self):\n        \"\"\"\n        Check if authentication is failing without a password.\n        \"\"\"\n        b = {'login': 'admin', 'password': ''}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('200 OK')\n        self.assertInBody('This field is required.')\n\n    def test_getpage_with_invalid_url(self):\n        self.getPage('/login/kefuxian.mvc', method='GET')\n        self.assertStatus('303 See Other')\n\n    def test_post_with_invalid_url(self):\n        self.getPage('/login/kefuxian.mvc', method='POST')\n        self.assertStatus('303 See Other')\n\n    def test_login_twice(self):\n        # Given an authenticated user\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + \"/\")\n        self.getPage('/')\n        self.assertStatus(200)\n        self.assertInBody(self.USERNAME)\n        # Given another user\n        userobj = UserObject.add_user('otheruser', password='password')\n        userobj.commit()\n        # When trying to re-authenticated with login page\n        self.getPage('/login/', method='POST', body={'login': 'otheruser', 'password': 'password'})\n        # Then user is still authenticated with previous user\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + \"/\")\n        self.getPage('/')\n        self.assertStatus(200)\n        self.assertInBody(self.USERNAME)\n\n    def test_login_persistent(self):\n        # Given a user authenticated with persistent\n        self.getPage('/logout/')\n        self.assertStatus(303)\n        self.getPage(\n            '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}\n        )\n        self.assertStatus(303)\n        # Then a persistent cookie is return\n        self.assertIn('expires', self.cookies[0][1])\n        self.assertIn('Max-Age', self.cookies[0][1])\n        # Then a session is created with persistent flag\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertTrue(session['login_persistent'])\n        # Then session timeout is 30 days in future\n        self.assertAlmostEqual(session.timeout, 43200, delta=2)\n\n\nclass LoginPageWithWelcomeMsgTest(rdiffweb.test.WebCase):\n\n    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}\n\n    def test_getpage_default(self):\n        \"\"\"\n        Make sure the login page can be rendered without error.\n        \"\"\"\n        self.getPage('/login/', headers=[(\"Accept-Language\", \"it\")])\n        self.assertStatus('200 OK')\n        self.assertInBody('default message')\n\n    def test_getpage_french(self):\n        \"\"\"\n        Make sure the login page can be rendered without error.\n        \"\"\"\n        self.getPage('/login/', headers=[(\"Accept-Language\", \"fr\")])\n        self.assertStatus('200 OK')\n        self.assertInBody('french message')\n\n\nclass LoginPageWithHeaderName(rdiffweb.test.WebCase):\n\n    default_config = {'header-name': 'HEADER-NAME'}\n\n    def test_getpage_default(self):\n        # Given a custom header-name\n        # When querying the loging page\n        self.getPage('/login/')\n        # Then the page display the header-name\n        self.assertStatus('200 OK')\n        self.assertInBody('HEADER-NAME')\n\n\n@parameterized_class(\n    [\n        {\"default_config\": {'rate-limit': 5}},\n        {\"default_config\": {'rate-limit': 5, 'rate-limit-dir': '/tmp'}},\n    ]\n)\nclass LoginPageRateLimitTest(rdiffweb.test.WebCase):\n    def setUp(self):\n        if os.path.isfile('/tmp/ratelimit-127.0.0.1'):\n            os.unlink('/tmp/ratelimit-127.0.0.1')\n        if os.path.isfile('/tmp/ratelimit-127.0.0.1.-login'):\n            os.unlink('/tmp/ratelimit-127.0.0.1.-login')\n        return super().setUp()\n\n    def test_login_ratelimit(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page\n        for i in range(1, 5):\n            self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})\n            self.assertStatus(200)\n        # Then a 429 error (too many request) is return\n        self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})\n        self.assertStatus(429)\n\n\nclass LoginPageRateLimitTest2(rdiffweb.test.WebCase):\n\n    default_config = {'rate-limit': 5}\n\n    def test_login_ratelimit_forwarded_for(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page with different `X-Forwarded-For`\n        for i in range(1, 5):\n            self.getPage(\n                '/login/',\n                headers=[('X-Forwarded-For', '127.0.0.%s' % i)],\n                method='POST',\n                body={'login': 'invalid', 'password': 'invalid'},\n            )\n            self.assertStatus(200)\n        # Then original IP get blocked\n        self.getPage(\n            '/login/',\n            headers=[('X-Forwarded-For', '127.0.0.%s' % i)],\n            method='POST',\n            body={'login': 'invalid', 'password': 'invalid'},\n        )\n        self.assertStatus(429)\n\n\nclass LoginPageRateLimitTest3(rdiffweb.test.WebCase):\n    default_config = {'rate-limit': 5}\n\n    def test_login_ratelimit_real_ip(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page with different `X-Real-IP`\n        for i in range(1, 5):\n            self.getPage(\n                '/login/',\n                headers=[('X-Real-IP', '127.0.0.128')],\n                method='POST',\n                body={'login': 'invalid', 'password': 'invalid'},\n            )\n            self.assertStatus(200)\n        # Then the X-Real-IP get blocked\n        self.getPage(\n            '/login/',\n            headers=[('X-Real-IP', '127.0.0.128')],\n            method='POST',\n            body={'login': 'invalid', 'password': 'invalid'},\n        )\n        self.assertStatus(429)\n\n\nclass LogoutPageTest(rdiffweb.test.WebCase):\n    def test_getpage_without_login(self):\n        # Given an unauthenticated user\n        # When Accessing logout page directly\n        self.getPage('/logout')\n        # Then user is redirect to root '/'\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n\n    def test_getpage_with_login(self):\n        # Given an anonymous user\n        self.getPage('/')\n        prev_session_id = self.session_id\n        # Login\n        b = {'login': 'admin', 'password': 'admin123'}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('303 See Other')\n        # Then a new session id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        prev_session_id = self.session_id\n        # Get content of a page.\n        self.getPage(\"/prefs/general\")\n        self.assertStatus('200 OK')\n        # When logout\n        self.getPage('/logout')\n        # Then a new session id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected to root page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Get content of a page.\n        self.getPage(\"/prefs/general\")\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport datetime\nfrom unittest.mock import MagicMock\n\nimport cherrypy\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import DbSession, UserObject\n\n\nclass MfaPageTest(rdiffweb.test.WebCase):\n\n    # Authenticated by default.\n    login = True\n\n    def _get_code(self):\n        # Register an email listeer to capture email send\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('queue_mail', self.listener.queue_email, priority=50)\n        # Query MFA page to generate a code\n        self.getPage(\"/mfa/\")\n        self.assertStatus(200)\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n        # Extract code from email between <strong> and </strong>\n        self.listener.queue_email.assert_called_once()\n        message = self.listener.queue_email.call_args[1]['message']\n        return message.split('<strong>', 1)[1].split('</strong>')[0]\n\n    def setUp(self):\n        super().setUp()\n        # Enabled MFA for all test cases\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.mfa = UserObject.ENABLED_MFA\n        userobj.email = 'admin@example.com'\n        userobj.commit()\n\n    def test_get_without_login(self):\n        # Given an unauthenticated user\n        self.getPage(\"/logout\")\n        self.assertStatus(303)\n        # When requesting /mfa/\n        self.getPage(\"/mfa/\")\n        # Then user is redirected to /login/\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n\n    def test_get_with_mfa_disabled(self):\n        # Given an authenticated user with MFA Disable\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.mfa = UserObject.DISABLED_MFA\n        userobj.commit()\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        # When requesting /mfa/ page\n        self.getPage(\"/mfa/\")\n        # Then user is redirected to root page\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n\n    def test_get_with_user_without_email(self):\n        # Given an authenticated user without email.\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.email = ''\n        userobj.commit()\n        # When requesting /mfa/ page\n        self.getPage(\"/mfa/\")\n        # Then user is redirected to root page\n        self.assertStatus(200)\n        self.assertInBody(\n            \"Multi-factor authentication is enabled for your account, but your account does not have a valid email address to send the verification code to. Check your account settings with your administrator.\"\n        )\n\n    def test_get_with_trusted(self):\n        # Given an authenticated user with MFA enabled and already verified\n        session = DbSession(id=self.session_id)\n        session.load()\n        session['_auth_mfa_username'] = self.USERNAME\n        session['_auth_mfa_time'] = session.now()\n        session['_auth_mfa_trusted_ip_list'] = ['127.0.0.1']\n        session.save()\n        # When requesting /mfa/ page when we are already trusted\n        self.getPage(\"/mfa/\")\n        # Then user is redirected to root page\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n\n    def test_get_with_trusted_expired(self):\n        # Given an authenticated user with MFA enabled and already verified\n        session = DbSession(id=self.session_id)\n        session.load()\n        session['_auth_mfa_username'] = self.USERNAME\n        session['_auth_mfa_time'] = session.now() - datetime.timedelta(minutes=session.timeout)\n        session.save()\n        # When requesting /mfa/ page\n        self.getPage(\"/mfa/\")\n        # Then an email get send with a new code\n        self.assertStatus(200)\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_get_with_trusted_different_ip(self):\n        # Given an authenticated user with MFA enabled and already verified\n        session = DbSession(id=self.session_id)\n        session.load()\n        session['_auth_mfa_username'] = self.USERNAME\n        session['_auth_mfa_time'] = session.now()\n        session.save()\n        # When requesting /mfa/ page from a different ip\n        self.getPage(\"/mfa/\", headers=[('X-Forwarded-For', '10.255.14.23')])\n        # Then an email get send with a new code\n        self.assertStatus(200)\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_get_without_verified(self):\n        # Given an authenticated user With MFA enabled\n        # When requesting /mfa/ page\n        self.getPage(\"/mfa/\")\n        # Then an email get send with a new code\n        self.assertStatus(200)\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_verify_code_valid(self):\n        prev_session_id = self.session_id\n        # Given an authenticated user With MFA enabled\n        code = self._get_code()\n        # When sending a valid verification code\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})\n        # Then a new session_id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected to root page\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Then user has access\n        self.getPage(\"/\")\n        self.assertStatus(200)\n\n    def test_verify_code_invalid(self):\n        # Given an authenticated user With MFA enabled\n        # When sending an invalid verification code\n        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})\n        # Then an error get displayed to the user\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid verification code.\")\n\n    def test_verify_code_expired(self):\n        # Given an authenticated user With MFA enabled\n        code = self._get_code()\n        # When sending a valid verification code that expired\n        session = DbSession(id=self.session_id)\n        session.load()\n        session['_auth_mfa_code_time'] = session.now() - datetime.timedelta(minutes=session.timeout + 1)\n        session.save()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})\n        # Then a new code get generated.\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid verification code.\")\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_verify_code_invalid_after_3_tentative(self):\n        # Given an authenticated user With MFA\n        self._get_code()\n        # When user enter an invalid verification code 3 times\n        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})\n        self.assertStatus(200)\n        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})\n        self.assertStatus(200)\n        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})\n        # Then an error get displayed to the user\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid verification code.\")\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_resend_code(self):\n        # Given an authenticated user With MFA enabled with an existing code\n        self._get_code()\n        # When user request a new code\n        self.getPage(\"/mfa/\", method='POST', body={'resend_code': '1'})\n        # Then a new code is sent to the user by email\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_redirect_to_original_url(self):\n        # When querying a page that required mfa\n        self.getPage('/prefs/general')\n        # Then user is redirected to mfa page\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/mfa/')\n        # When providing verification code\n        code = self._get_code()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})\n        # Then user is redirected to original url\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')\n\n    def test_login_persistent_when_login_timout(self):\n        prev_session_id = self.session_id\n        # Given a user authenticated with MFA with \"login_persistent\"\n        code = self._get_code()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})\n        self.assertStatus(303)\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        self.assertNotEqual(prev_session_id, self.session_id)\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertTrue(session['login_persistent'])\n        # When the login_time expired (after 15 min)\n        session['login_time'] = session.now() - datetime.timedelta(minutes=15, seconds=1)\n        session.save()\n        # Then next query redirect user to same page (by mfa)\n        self.getPage(\"/prefs/general\")\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')\n        self.getPage(\"/prefs/general\")\n        # Then user is redirected to /login/ page (by auth_form)\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        prev_session_id = self.session_id\n        # When user enter valid username password\n        self.getPage(\"/login/\", method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected to original url\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        self.assertInBody('Repositories')\n\n    def test_login_persistent_when_mfa_timeout(self):\n        prev_session_id = self.session_id\n        # Given a user authenticated with MFA with \"login_persistent\"\n        code = self._get_code()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})\n        self.assertStatus(303)\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        self.assertNotEqual(prev_session_id, self.session_id)\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertTrue(session['login_persistent'])\n        # When the mfa verification timeout (after 30 days)\n        session['_auth_mfa_time'] = session.now() - datetime.timedelta(days=30, seconds=1)\n        session.save()\n        # Then next query redirect user to mfa page\n        self.getPage(\"/prefs/general\")\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/mfa/')\n        # When user enter valid code\n        code = self._get_code()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})\n        # Then user is redirected to original page.\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        self.assertInBody('Repositories')\n\n\nclass MfaPageWithWelcomeMsgTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}\n\n    def setUp(self):\n        super().setUp()\n        # Enabled MFA for all test cases\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.mfa = UserObject.ENABLED_MFA\n        userobj.email = 'admin@example.com'\n        userobj.commit()\n\n    def test_getpage_default(self):\n        # Given a user with MFA enabled\n        # When querying the mfa page\n        self.getPage('/mfa/', headers=[(\"Accept-Language\", \"it\")])\n        # Then page is return without error with the custom welcome message\n        self.assertStatus('200 OK')\n        self.assertInBody('default message')\n\n    def test_getpage_french(self):\n        # Given a user with MFA enabled\n        # When querying the mfa page in french\n        self.getPage('/mfa/', headers=[(\"Accept-Language\", \"fr\")])\n        # Then page is return without error with the custom welcome message in french\n        self.assertStatus('200 OK')\n        self.assertInBody('french message')\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Oct 20, 2021\n\n@author: Patrik Dufresne\n\"\"\"\nfrom parameterized import parameterized\n\nimport rdiffweb.test\n\n\nclass SecureHeadersTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    def test_cookie_samesite_lax(self):\n        # Given a request made to rdiffweb\n        # When receiving the response\n        self.getPage('/')\n        # Then the header contains Set-Cookie with SameSite=Lax\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('SameSite=Lax', cookie)\n\n    def test_cookie_samesite_lax_without_session(self):\n        # Given not a client sending no cookie\n        self.cookies = None\n        # When a query is made to a static path (without session)\n        self.getPage('/static/blue.css')\n        # Then Set-Cookie is not defined.\n        self.assertNoHeader('Set-Cookie')\n\n    def test_cookie_with_https(self):\n        # Given an https request made to rdiffweb\n        self.getPage('/', headers=[('X-Forwarded-Proto', 'https')])\n        # When receiving the response\n        self.assertStatus(200)\n        # Then the header contains Set-Cookie with Secure\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('Secure', cookie)\n\n    @parameterized.expand(\n        [\n            ('/invalid', 404),\n            ('/browse/invalid', 404),\n            ('/login', 301),\n            ('/logout', 303),\n        ]\n    )\n    def test_cookie_with_https_http_error(self, url, expected_error_code):\n        # Given an https request made to rdiffweb\n        self.getPage(url, headers=[('X-Forwarded-Proto', 'https')])\n        # When receiving the response\n        self.assertStatus(expected_error_code)\n        # Then the header contains Set-Cookie with Secure\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('Secure', cookie)\n\n    def test_cookie_with_http(self):\n        # Given an https request made to rdiffweb\n        self.getPage('/')\n        # When receiving the response\n        # Then the header contains Set-Cookie with Secure\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertNotIn('Secure', cookie)\n\n    def test_get_with_wrong_origin(self):\n        # Given a GET request made to rdiffweb\n        # When the request is made using a different origin\n        self.getPage('/', headers=[('Origin', 'http://www.examples.com')])\n        # Then the response status it 200 OK.\n        self.assertStatus(200)\n\n    def test_post_with_wrong_origin(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made using a different origin\n        self.getPage('/', headers=[('Origin', 'http://www.examples.com')], method='POST')\n        # Then the request is refused with 403 Forbiden\n        self.assertStatus(403)\n        self.assertInBody('Unexpected Origin header')\n\n    def test_post_with_prefixed_origin(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made using a different origin\n        base = 'http://%s:%s' % (self.HOST + 'anything.com', self.PORT)\n        self.getPage('/dashboard/', headers=[('Origin', base)], method='POST')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(403)\n        self.assertInBody('Unexpected Origin header')\n\n    def test_post_with_valid_origin(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made using a different origin\n        base = 'http://%s:%s' % (self.HOST, self.PORT)\n        self.getPage('/', headers=[('Origin', base)], method='POST')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n\n    def test_post_without_origin(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/', method='POST')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n\n    def test_clickjacking_defense(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('X-Frame-Options', 'DENY')\n\n    def test_no_cache(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('Cache-control', 'no-cache')\n        self.assertHeaderItemValue('Cache-control', 'no-store')\n        self.assertHeaderItemValue('Cache-control', 'must-revalidate')\n        self.assertHeaderItemValue('Cache-control', 'max-age=0')\n        self.assertHeaderItemValue('Pragma', 'no-cache')\n        self.assertHeaderItemValue('Expires', '0')\n\n    def test_no_cache_with_static(self):\n        self.getPage('/static/js/rdiffweb.js')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertNoHeader('Cache-control')\n        self.assertNoHeader('Pragma')\n        self.assertNoHeader('Expires')\n\n    def test_referrer_policy(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('Referrer-Policy', 'same-origin')\n\n    def test_nosniff(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('X-Content-Type-Options', 'nosniff')\n\n    def test_xss_protection(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('X-XSS-Protection', '1; mode=block')\n\n    def test_content_security_policy(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue(\n            'Content-Security-Policy',\n            \"default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'\",\n        )\n\n    def test_strict_transport_security(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/', headers=[('X-Forwarded-Proto', 'https')])\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')\n", "<!DOCTYPE html>\n<html lang=\"{{ lang[0:2] }}\">\n  <head>\n    {% block head %}\n      <title>\n        {% block title %}\n          {% if title %}{{ title }}{% endif %}\n        {% endblock title %}\n        - {{ header_name }}\n      </title>\n      <meta charset=\"utf-8\" />\n      <meta content=\"noindex\" name=\"robots\" />\n      <meta content=\"IE=edge\" http-equiv=\"X-UA-Compatible\" />\n      <meta content=\"width=device-width, initial-scale=1\" name=\"viewport\" />\n      <link href=\"{{ url_for('favicon.ico', v=cache_invalid) }}\"\n            rel=\"shortcut icon\"/>\n      <!-- Jquery -->\n      <script src=\"{{ url_for('/static/js/jquery.min.js') }}\"></script>\n      <!-- Bootstrap v4 -->\n      <script src=\"{{ url_for('/static/js/bootstrap.bundle.min.js') }}\"></script>\n      <link href=\"{{ url_for('/static/css/bootstrap.min.css') }}\"\n            rel=\"stylesheet\"\n            type=\"text/css\"/>\n      <!-- Fontawesome -->\n      <link href=\"{{ url_for('/static/css/font-awesome.min.css') }}\"\n            rel=\"stylesheet\"\n            type=\"text/css\"/>\n      <!-- JQuery Datatables -->\n      <script src=\"{{ url_for('/static/js/jquery.dataTables.min.js') }}\"></script>\n      <script src=\"{{ url_for('/static/js/dataTables.buttons.min.js') }}\"></script>\n      <script src=\"{{ url_for('/static/js/dataTables.responsive.min.js') }}\"></script>\n      <link href=\"{{ url_for('/static/css/jquery.dataTables.min.css') }}\"\n            rel=\"stylesheet\"\n            type=\"text/css\"/>\n      <link href=\"{{ url_for('/static/css/responsive.dataTables.min.css') }}\"\n            rel=\"stylesheet\"\n            type=\"text/css\"/>\n      <!-- Custom -->\n      <script src=\"{{ url_for('/static/js/rdiffweb.js') }}\"></script>\n      <link href=\"{{ url_for('/default.css') }}\" rel=\"stylesheet\" type=\"text/css\"/>\n    {% endblock head %}\n  </head>\n  <body class=\"d-flex flex-column\">\n    <!-- .navbar -->\n    {% if username %}\n      <nav class=\"navbar navbar-expand-lg navbar-dark bg-dark fixed-top\">\n        <div class=\"container\">\n          <a class=\"navbar-brand\" href=\"{{ url_for('/') }}\">\n            <img alt=\"{{ header_name }}\"\n                 class=\"mr-1\"\n                 height=\"36\"\n                 src=\"{{ url_for('/header_logo',v=cache_invalid) }}\"/>\n          </a>\n          <button aria-controls=\"navbarSupportedContent\"\n                  aria-expanded=\"false\"\n                  aria-label=\"{% trans %}Toggle navigation{% endtrans %}\"\n                  class=\"navbar-toggler\"\n                  data-target=\"#navbarSupportedContent\"\n                  data-toggle=\"collapse\"\n                  type=\"button\">\n            <span class=\"navbar-toggler-icon\"></span>\n          </button>\n          <div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\n            <ul class=\"navbar-nav mr-auto\">\n              <li class=\"nav-item{% if active_page=='repo' %} active{% endif %}\">\n                <a class=\"nav-link\" href=\"{{ url_for('/') }}\">{% trans %}Repositories{% endtrans %}</a>\n              </li>\n              <li class=\"nav-item{% if active_page=='status' %} active{% endif %}\">\n                <a class=\"nav-link\" href=\"{{ url_for('status') }}\">{% trans %}Status{% endtrans %}</a>\n              </li>\n              {% if is_admin %}\n                <li class=\"nav-item{% if active_page=='admin' %} active{% endif %}\">\n                  <a class=\"nav-link\" href=\"{{ url_for('admin') }}\">{% trans %}Admin area{% endtrans %}</a>\n                </li>\n              {% endif %}\n            </ul>\n            <ul class=\"navbar-nav\">\n              <li class=\"nav-item dropdown\">\n                <a aria-expanded=\"false\"\n                   class=\"nav-link dropdown-toggle\"\n                   data-toggle=\"dropdown\"\n                   href=\"#\"\n                   id=\"navbarDropdown\"\n                   role=\"button\">\n                  <i aria-hidden=\"true\" class=\"fa fa-user\"></i>\n                  {{ username }}\n                </a>\n                <div aria-labelledby=\"navbarDropdown\" class=\"dropdown-menu\">\n                  <h6 class=\"dropdown-header\">{% trans %}Signed in as{% endtrans %} {{ username }}</h6>\n                  <a class=\"dropdown-item\" href=\"{{ url_for('prefs', 'general') }}\">{% trans %}Edit profile{% endtrans %}</a>\n                  <a class=\"dropdown-item\" href=\"{{ url_for('prefs', 'notification') }}\">{% trans %}Notifications{% endtrans %}</a>\n                  <div class=\"dropdown-divider\"></div>\n                  <a class=\"dropdown-item\" href=\"{{ url_for('logout') }}\">Logout</a>\n                </div>\n              </li>\n            </ul>\n          </div>\n        </div>\n      </nav>\n    {% endif %}\n    {% block body %}\n    {% endblock body %}\n    <footer class=\"small text-center mt-auto\">\n      {% trans %}Powered by{% endtrans %} <a href=\"{{ footerurl }}\">{{ footername }}</a>\n    </footer>\n  </body>\n</html>\n", "{% extends 'login.html' %}\n{% block content %}\n  <div class=\"container mb-auto\">\n    <div class=\"row\">\n      <div class=\"offset-sm-3 col-sm-6\">\n        <form id=\"form-login\" role=\"form\" method=\"post\" action=\"{{ url_for() }}\">\n          <h2>{% trans %}Login Verification{% endtrans %}</h2>\n          {% include 'message.html' %}\n          <p>\n            {% trans %}Two-Factor Authentication is enabled for your account. To verify your account, you must enter the code that was sent to your email address.{% endtrans %}\n          </p>\n          {{ form }}\n        </form>\n        <a class=\"btn-link btn-sm btn-block text-center\"\n           href=\"{{ url_for('logout')}}\">\n          {% trans %}Login with a different account{% endtrans %}\n        </a>\n      </div>\n    </div>\n  </div>\n{% endblock %}\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Oct 14, 2015\n\nMock class for testing.\n\n@author: Patrik Dufresne <patrik@ikus-soft.com>\n\"\"\"\nimport json\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport time\nimport unittest\nimport unittest.mock\nfrom threading import Thread\nfrom urllib.parse import urlencode\n\nimport cherrypy\nimport pkg_resources\nfrom cherrypy.test import helper\n\nfrom rdiffweb.core.model import UserObject\nfrom rdiffweb.rdw_app import RdiffwebApp\n\n# For cherrypy8, we need to monkey patch Thread.isAlive\nThread.isAlive = Thread.is_alive\n\n\ndef create_testcases_repo(app):\n    \"\"\"Extract testcases.\"\"\"\n    # Extract 'testcases.tar.gz'\n    testcases = pkg_resources.resource_filename('rdiffweb.tests', 'testcases.tar.gz')  # @UndefinedVariable\n    new = str(tempfile.mkdtemp(prefix='rdiffweb_tests_'))\n    subprocess.check_call(['tar', '-zxf', testcases], cwd=new)\n    return new\n\n\nclass WebCase(helper.CPWebCase):\n    \"\"\"\n    Helper class for the rdiffweb test suite.\n    \"\"\"\n\n    REPO = 'testcases'\n\n    USERNAME = 'admin'\n\n    PASSWORD = 'admin123'\n\n    interactive = False\n\n    login = False\n\n    default_config = {}\n\n    app_class = RdiffwebApp\n\n    @classmethod\n    def setup_class(cls):\n        if cls is WebCase:\n            raise unittest.SkipTest(\"%s is an abstract base class\" % cls.__name__)\n        super().setup_class()\n        cls.do_gc_test = False\n\n    @classmethod\n    def teardown_class(cls):\n        super().teardown_class()\n        cherrypy.tools.db.drop_all()\n        if hasattr(cherrypy, '_cache'):\n            cherrypy._cache.clear()\n\n    @classmethod\n    def setup_server(cls):\n        # Allow defining a custom database uri for testing.\n        uri = os.environ.get(\n            'RDIFFWEB_TEST_DATABASE_URI', 'sqlite:///' + tempfile.gettempdir() + '/test_rdiffweb_data.db'\n        )\n        cls.default_config['database-uri'] = uri\n        # Disable rate-limit for testing.\n        if 'rate-limit' not in cls.default_config:\n            cls.default_config['rate-limit'] = -1\n        cfg = cls.app_class.parse_args(\n            args=[], config_file_contents='\\n'.join('%s=%s' % (k, v) for k, v in cls.default_config.items())\n        )\n        # Create Application\n        app = cls.app_class(cfg)\n        cherrypy.tree.mount(app)\n\n    def setUp(self):\n        helper.CPWebCase.setUp(self)\n        if hasattr(cherrypy, '_cache'):\n            cherrypy._cache.clear()\n        cherrypy.tools.db.drop_all()\n        cherrypy.tools.db.create_all()\n        # Create default admin\n        admin_user = UserObject.create_admin_user(self.USERNAME, self.PASSWORD)\n        admin_user.commit()\n        # Create testcases repo\n        self.testcases = create_testcases_repo(self.app)\n        if admin_user:\n            admin_user.user_root = self.testcases\n            admin_user.refresh_repos()\n            admin_user.commit()\n        # Login to web application.\n        if self.login:\n            self._login()\n\n    def tearDown(self):\n        if hasattr(self, 'testcases'):\n            shutil.rmtree(self.testcases)\n            delattr(self, 'testcases')\n        cherrypy.tools.db.drop_all()\n        if hasattr(cherrypy, '_cache'):\n            cherrypy._cache.clear()\n\n    @property\n    def app(self):\n        \"\"\"\n        Return reference to Rdiffweb application.\n        \"\"\"\n        return cherrypy.tree.apps['']\n\n    @property\n    def session(self):\n        return cherrypy.tools.db.get_session()\n\n    @property\n    def session_id(self):\n        if hasattr(self, 'cookies') and self.cookies:\n            for unused, value in self.cookies:\n                for part in value.split(';'):\n                    key, unused, value = part.partition('=')\n                    if key == 'session_id':\n                        return value\n\n    @property\n    def baseurl(self):\n        return 'http://%s:%s' % (self.HOST, self.PORT)\n\n    def getPage(self, url, headers=None, method=\"GET\", body=None, protocol=None):\n        if headers is None:\n            headers = []\n        # When body is a dict, send the data as form data.\n        if isinstance(body, dict) and method in ['POST', 'PUT']:\n            data = [(k.encode(encoding='latin1'), v.encode(encoding='utf-8')) for k, v in body.items()]\n            body = urlencode(data)\n        # Send back cookies if any\n        if hasattr(self, 'cookies') and self.cookies:\n            headers.extend(self.cookies)\n        # CherryPy ~8.9.1 is not handling absolute URL properly and web browser\n        # are usually not sending absolute URL either. So trim the base.\n        base = 'http://%s:%s' % (self.HOST, self.PORT)\n        if url.startswith(base):\n            url = url[len(base) :]\n        helper.CPWebCase.getPage(self, url, headers, method, body, protocol)\n\n    def getJson(self, *args, **kwargs):\n        self.getPage(*args, **kwargs)\n        self.assertStatus(200)\n        return json.loads(self.body.decode('utf8'))\n\n    def _login(self, username=USERNAME, password=PASSWORD):\n        self.getPage(\"/logout\")\n        self.getPage(\"/login/\", method='POST', body={'login': username, 'password': password})\n        self.assertStatus('303 See Other')\n\n    def wait_for_tasks(self):\n        time.sleep(1)\n        while len(cherrypy.scheduler.list_tasks()) or cherrypy.scheduler.is_job_running():\n            time.sleep(1)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport datetime\nimport time\nimport urllib.parse\n\nimport cherrypy\nfrom cherrypy.lib import httputil\n\nSESSION_KEY = '_cp_username'\nLOGIN_TIME = 'login_time'\nLOGIN_REDIRECT_URL = '_auth_form_redirect_url'\nLOGIN_PERSISTENT = 'login_persistent'\n\n\nclass CheckAuthForm(cherrypy.Tool):\n    def __init__(self, priority=73):\n        super().__init__(point='before_handler', callable=self.run, priority=priority)\n\n    def _is_login(self):\n        \"\"\"\n        Verify if the login expired and we need to prompt the user to authenticated again using either credentials and/or MFA.\n        \"\"\"\n        # Verify if current user exists\n        request = cherrypy.serving.request\n        if not getattr(request, 'currentuser', None):\n            return False\n\n        # Verify if session is enabled\n        sessions_on = request.config.get('tools.sessions.on', False)\n        if not sessions_on:\n            return False\n\n        # Verify session\n        # We don't need to verify the timeout value since expired session get deleted automatically.\n        session = cherrypy.session\n        return session.get(SESSION_KEY) is not None and session.get(LOGIN_TIME) is not None\n\n    def _get_redirect_url(self):\n        \"\"\"\n        Return the original URL the user browser before getting redirect to login.\n        \"\"\"\n        return cherrypy.session.get(LOGIN_REDIRECT_URL) or '/'\n\n    def _set_redirect_url(self):\n        # Keep reference to the current URL\n        request = cherrypy.serving.request\n        uri_encoding = getattr(request, 'uri_encoding', 'utf-8')\n        original_url = urllib.parse.quote(request.path_info, encoding=uri_encoding)\n        qs = request.query_string\n        new_url = cherrypy.url(original_url, qs=qs, base='')\n        cherrypy.session[LOGIN_REDIRECT_URL] = new_url\n\n    def _update_session_timeout(self, persistent_timeout=43200, absolute_timeout=30):\n        \"\"\"\n        Since we have multiple timeout value (idle, absolute and persistent) We need to update the session timeout and possibly the cookie timeout.\n        \"\"\"\n        persistent_timeout = cherrypy.request.config.get('tools.auth_form.persistent_timeout', 43200)\n        absolute_timeout = cherrypy.request.config.get('tools.auth_form.absolute_timeout', 30)\n        # If login is persistent, update the cookie max-age/expires\n        session = cherrypy.session\n        if session.get(LOGIN_PERSISTENT, False):\n            expiration = session[LOGIN_TIME] + datetime.timedelta(minutes=persistent_timeout)\n            session.timeout = int((expiration - session.now()).total_seconds() / 60)\n            cookie = cherrypy.serving.response.cookie\n            cookie['session_id']['max-age'] = session.timeout * 60\n            cookie['session_id']['expires'] = httputil.HTTPDate(time.time() + session.timeout * 60)\n        else:\n            session_idle_timeout = cherrypy.request.config.get('tools.sessions.timeout', 60)\n            expiration1 = session.now() + datetime.timedelta(minutes=session_idle_timeout)\n            expiration2 = session[LOGIN_TIME] + datetime.timedelta(minutes=absolute_timeout)\n            expiration = min(expiration1, expiration2)\n            session.timeout = int((expiration - session.now()).total_seconds() / 60)\n\n    def redirect_to_original_url(self):\n        # Redirect user to original URL\n        raise cherrypy.HTTPRedirect(self._get_redirect_url())\n\n    def run(self, login_url='/login/', logout_url='/logout', persistent_timeout=43200, absolute_timeout=30):\n        \"\"\"\n        A tool that verify if the session is associated to a user by tracking\n        a session key. If session is not authenticated, redirect user to login page.\n        \"\"\"\n        request = cherrypy.serving.request\n        # Skip execution of this tools when browsing the login page.\n        if request.path_info == login_url:\n            if self._is_login():\n                raise cherrypy.HTTPRedirect('/')\n            return\n\n        # Clear session when browsing /logout\n        if request.path_info == logout_url or request.path_info.startswith(logout_url):\n            self.logout()\n            raise cherrypy.HTTPRedirect('/')\n\n        # Check if login\n        if not self._is_login():\n            # Store original URL\n            self._set_redirect_url()\n            # And redirect to login page\n            raise cherrypy.HTTPRedirect(login_url)\n\n        self._update_session_timeout()\n\n    def login(self, username, persistent=False):\n        \"\"\"\n        Must be called by the page hanlder when the authentication is successful.\n        \"\"\"\n        # Store session data\n        cherrypy.session[LOGIN_PERSISTENT] = persistent\n        cherrypy.session[SESSION_KEY] = username\n        cherrypy.session[LOGIN_TIME] = cherrypy.session.now()\n        # Generate a new session id\n        cherrypy.session.regenerate()\n        # Update the session timeout\n        self._update_session_timeout()\n\n    def logout(self):\n        # Clear session date and generate a new session id\n        cherrypy.session.clear()\n        cherrypy.session.regenerate()\n\n\ncherrypy.tools.auth_form = CheckAuthForm()\n"], "fixing_code": ["![Rdiffweb Banner](https://gitlab.com/ikus-soft/rdiffweb/-/raw/master/doc/_static/banner.png)\n\n<p align=\"center\">\n<strong>\n<a href=\"https://www.rdiffweb.org\">website</a>\n\u2022 <a href=\"https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/\">docs</a>\n\u2022 <a href=\"https://groups.google.com/d/forum/rdiffweb\">community</a>\n\u2022 <a href=\"https://rdiffweb-demo.ikus-soft.com/\">demo</a>\n</strong>\n</p>\n\n<p align=\"center\">\n<a href=\"LICENSE\"><img alt=\"License\" src=\"https://img.shields.io/github/license/ikus060/rdiffweb\"></a>\n<a href=\"https://gitlab.com/ikus-soft/rdiffweb/pipelines\"><img alt=\"Build\" src=\"https://gitlab.com/ikus-soft/rdiffweb/badges/master/pipeline.svg\"></a>\n<a href=\"https://sonar.ikus-soft.com/dashboard?id=rdiffweb\"><img alt=\"Quality Gate Minarca Client\" src=\"https://sonar.ikus-soft.com/api/project_badges/measure?project=rdiffweb&metric=alert_status\"></a>\n<a href=\"https://sonar.ikus-soft.com/dashboard?id=rdiffweb\"><img alt=\"Coverage\" src=\"https://sonar.ikus-soft.com/api/project_badges/measure?project=rdiffweb&metric=coverage\"></a>\n<a href=\"https://bestpractices.coreinfrastructure.org/projects/6583\"><img src=\"https://bestpractices.coreinfrastructure.org/projects/6583/badge\"></a>\n</p>\n\n<h1 align=\"center\">\nWelcome to Rdiffweb\n</h1>\n\nRdiffweb is a web application that allows you to view repositories generated\nby [rdiff-backup](https://rdiff-backup.net/). The purpose of this\napplication is to ease the management of backups and quickly restore your data\nwith a rich and powerful web interface.\n\nRdiffweb is written in Python and is released as open source project under the \nGNU GENERAL PUBLIC LICENSE (GPL). All source code and documentation are\nCopyright Rdiffweb contributors.\n\nRdiffweb is actively developed by [IKUS Soft](https://www.ikus-soft.com/)\nsince November 2014.\n\nThe Rdiffweb source code is hosted on [Gitlab](https://gitlab.com/ikus-soft/rdiffweb)\nand mirrored to [Github](https://github.com/ikus060/rdiffweb).\n\nThe Rdiffweb website is https://rdiffweb.org/.\n\n## Features\n\nWith its rich web interface Rdiffweb provide a notable list of features:\n\n* Browse your backup\n* Restore single file or multiple files as an archived\n* Users authentication via local database and LDAP\n* Users authorization\n* Email notification when backup is not successful\n* Configurable repository encoding\n* Configurable retention period\n* Backup statistics visualization using graphs\n* SSH Keys management\n* Disk quota visualization\n* File and folder deletion\n\n## Demo\n\nIf you quickly want to check how Rdiffweb is behaving, you may try our demo server hosted on:\n\n[https://rdiffweb-demo.ikus-soft.com/](https://rdiffweb-demo.ikus-soft.com/)\n\nUse the following credential to login:\n\n* Username: admin\n* Password: admin123\n\n## Installation & Docker usage\n\nFor detailed installation steps, read the [Installation documentation](https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/installation.html).\n\n## Current Build Status\n\n[![Build Status](https://gitlab.com/ikus-soft/rdiffweb/badges/master/pipeline.svg)](https://gitlab.com/ikus-soft/rdiffweb/pipelines)\n\n## Download\n\nYou should read the [Documentation](https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/index.html) to properly install Rdiffweb in your environment.\n\n**Docker**\n\n    docker pull ikus060/rdiffweb\n\n**Debian**\n\n    curl -L https://www.ikus-soft.com/archive/rdiffweb/public.key | apt-key add - \n    echo \"deb https://nexus.ikus-soft.com/repository/apt-release-bullseye/ bullseye main\" > /etc/apt/sources.list.d/rdiffweb.list\n    apt update\n    apt install rdiffweb\n\n**Pypi**\n\n    pip install rdiffweb\n\n## Support\n\n### Mailing list\n\nRdiffweb users should use the [Rdiffweb mailing list](https://groups.google.com/forum/#!forum/rdiffweb).\n\n### Bug Reports\n\nBug reports should be reported on the Rdiffweb Gitlab at https://gitlab.com/ikus-soft/rdiffweb/-/issues\n\n### Professional support\n\nProfessional support for Rdiffweb is available by contacting [IKUS Soft](https://www.ikus-soft.com/en/support/#form).\n\n# Changelog\n\n## Next Release - 2.5.4\n\n* Discard `X-Forwarded-Host` headers credit to [Anishka Shukla](https://github.com/anishkashukla)\n* Create proper symbolic link of `chartkick.js` on Ubuntu Jammy to fix loading of Charts in web interface\n* Add CSRF verification on `/logout` credits to [reza.duty](https://rezaduty.me)\n\n## 2.5.3 (2022-12-05)\n\n* Add support for WTForms v3 to support Debian Bookworm\n* Fix strange behavior in access token management #247\n\n## 2.5.2 (2022-11-28)\n\n* Block repository access when user_root directory is empty or relative path [CVE-2022-4314](https://nvd.nist.gov/vuln/detail/CVE-2022-4314) credit to [neverjunior](https://github.com/neverjunior)\n* Replace admin password only when `--admin-password` option is provided #246\n* Invalidate browser cache for `logo`, `headerlogo` and `favicon` on restart #245\n\n## 2.5.1 (2022-11-11)\n\n* Add support for Ubuntu Kinetic #240\n* Disable filesize for deleted files to improve page loading #241\n\n## 2.5.0 (2022-11-09)\n\nThis next release focus on two-factor-authentication as a measure to increase security of user's account.\n\n* Store User's session information into database\n* Update ldap plugin to load additional attributes from LDAP server\n* Improve `/status` page error handling when `session_statistics` cannot be read\n* Add support for Ubuntu Jammy\n* Upgrade from Bootstrap v3 to v4 #204\n* Replace Fontello by Font-Awesome v4\n* Use CSS variables `var()` to customize themes using `--branding-X` options #239\n* Remove usage of Jquery.validate\n* Replace custom timsort by jquery DataTables #205\n* Add Active Session managements #203\n  * Active session should be visible in user's profiles\n  * Active session may be revoked by user\n  * Active session should be visible in administration view\n  * Action session may be revoke by administrator\n  * Show number of active users within the last 24 hours in dashboard\n* Handle migration of older Rdiffweb database by adding the missing `repos.Encoding`, `repos.keepdays` and `users.role` columns #185\n* Replace deprecated references of `disutils.spawn.find_executable()` by `shutil.which()` #208\n* Add two-factor authentication with email verification #201\n* Generate a new session on login and 2FA #220\n* Enforce permission on /etc/rdiffweb configuration folder\n* Enforce validation on fullname, username and email\n* Limit incorrect attempts to change the user's password to prevent brute force attacks #225 [CVE-2022-3273](https://nvd.nist.gov/vuln/detail/CVE-2022-3273) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce password policy new password cannot be set as new password [CVE-2022-3376](https://nvd.nist.gov/vuln/detail/CVE-2022-3376) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce better rate limit on login, mfa, password change and API [CVE-2022-3439](https://nvd.nist.gov/vuln/detail/CVE-2022-3439) [CVE-2022-3456](https://nvd.nist.gov/vuln/detail/CVE-2022-3456) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce 'Origin' validation [CVE-2022-3457](https://nvd.nist.gov/vuln/detail/CVE-2022-3457) credit to [Nithissh12](Nithissh12)\n* Define idle and absolute session timeout with agressive default to protect usage on public computer [CVE-2022-3327](https://nvd.nist.gov/vuln/detail/CVE-2022-3327) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Send email notification when enabling or disabling MFA [CVE-2022-3363](https://nvd.nist.gov/vuln/detail/CVE-2022-3363) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Use Argon2id to store password hash #231\n* Fixed plugin priorities to ensure that jobs are scheduled at each startup #232\n* Revoke previous user's sessions on password change [CVE-2022-3362](https://nvd.nist.gov/vuln/detail/CVE-2022-3362) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\nBreaking changes:\n\n* Drop Ubuntu Hirsute & Impish (End-of-life)\n* `session-dir` is deprecated and should be replace by `rate-limit-dir`. User's session are stored in database.\n* previous `.css` customization are not barkward compatible. Make usage of the `--branding-X` options.\n\n**Thanks to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172) with whom I collaborate to improve the security of this project.**\n\n## 2.4.10 (2022-10-03)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate path traversal vulnerability [CVE-2022-3389](https://nvd.nist.gov/vuln/detail/CVE-2022-3389) credit to [Hoang Van Hiep](https://www.linkedin.com/in/hiephv2410/)\n\n## 2.4.9 (2022-09-28)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Add `Cache-Control` and other security headers [CVE-2022-3292](https://nvd.nist.gov/vuln/detail/CVE-2022-3292) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce password policy using `password-score` based on [zxcvbn](https://github.com/dropbox/zxcvbn) [CVE-2022-3326](https://nvd.nist.gov/vuln/detail/CVE-2022-3326) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.4.8 (2022-09-26)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Clean-up invalid path on error page\n* Limit username field length [CVE-2022-3290](https://nvd.nist.gov/vuln/detail/CVE-2022-3290) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit user's email field length [CVE-2022-3272](https://nvd.nist.gov/vuln/detail/CVE-2022-3272) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit user's root directory field length [CVE-2022-3295](https://nvd.nist.gov/vuln/detail/CVE-2022-3295) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit SSH Key title field length [CVE-2022-3298](https://nvd.nist.gov/vuln/detail/CVE-2022-3298) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.4.7 (2002-09-21)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Generate a new session on login and 2FA #220 [CVE-2022-3269](https://nvd.nist.gov/vuln/detail/CVE-2022-3269) credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n* Mitigate CSRF on user's settings #221 [CVE-2022-3274](https://nvd.nist.gov/vuln/detail/CVE-2022-3274) credit to [irfansayyed](https://github.com/irfansayyed-github)\n\n## 2.4.6 (2022-09-20)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Support MarkupSafe<3 for Debian bookworm\n* Mitigate CSRF on user's notification settings #216 [CVE-2022-3233](https://nvd.nist.gov/vuln/detail/CVE-2022-3233) credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n* Mitigate CSRF on repository settings #217 [CVE-2022-3267](https://nvd.nist.gov/vuln/detail/CVE-2022-3267) credit to [irfansayyed](https://github.com/irfansayyed-github)\n* Use 'Secure' Attribute with Sensitive Cookie in HTTPS Session on HTTP Error #218 [CVE-2022-3174](https://nvd.nist.gov/vuln/detail/CVE-2022-3174) credit to [Chuu](https://github.com/uonghoangminhchau)\n\n## 2.4.5 (2002-09-16)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate CSRF on repository deletion and user deletion [CVE-2022-3232](https://nvd.nist.gov/vuln/detail/CVE-2022-3232) #214 #215 credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n\n## 2.4.4 (2002-09-15)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Use `X-Real-IP` to identify client IP address to mitigate Brute-Force attack #213\n\n## 2.4.3 (2022-09-14)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate CSRF in profile's SSH Keys [CVE-2022-3221](https://nvd.nist.gov/vuln/detail/CVE-2022-3221) #212 credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n\n## 2.4.2 (2022-09-12)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Use 'Secure' Attribute with Sensitive Cookie in HTTPS Session. [CVE-2022-3174](https://nvd.nist.gov/vuln/detail/CVE-2022-3174) #209 credit to [Chuu](https://github.com/uonghoangminhchau)\n* Avoid leakage of the stack trace in the default error page. [CVE-2022-3175](https://nvd.nist.gov/vuln/detail/CVE-2022-3175) #210 credit to [Chuu](https://github.com/uonghoangminhchau)\n* Enforce minimum and maximum password length [CVE-2022-3175](https://nvd.nist.gov/vuln/detail/CVE-2022-3179) #211 credit to [Chuu](https://github.com/uonghoangminhchau)\n\n## 2.4.1 (2022-09-08)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Add Clickjacking Defense [CVE-2022-3167](https://nvd.nist.gov/vuln/detail/CVE-2022-3167) credit to [tharunavula](https://github.com/tharunavula)\n* Drop Ubuntu Hirsute & Impish (End-of-life)\n\n## 2.4.0 (2022-06-21)\n\nThis new release brings a lot of improvement since the last version, multiple bug fixes\nto make the application stable. A couple of new features to improve the overall\nusability and a new security feature to block a brute force attack.\n\n* Add RateLimit to login page and API to mitigate robots attacks #167\n* Send email notification only if `email-sender` option is defined to avoid raising exception in logs #176\n* Support file restore cancellation without leaving `rdiffweb-restore` process in `<defunct>` state #174\n* Replace `python-ldap` by `ldap3` a pure python implementation to avoid dependencies on `sasl` and `ldap` binaries #186\n* Reffactor core module to allow better extendability and reusability #183\n* Add support for Debian Bookworm #180\n* Add support for Ubuntu Impish #175\n* Add rdiff-backup version to administration view\n* Run unit test during Debian build package\n* Refresh repository list automatically when required #188 #189\n* Fix error 500 displayed in status page #191\n* Improve repository browsing speed by minimizing the number of I/O call #192\n* Publish Docker image directly to DockerHub #144\n* Add REST API to manage sshkeys\n\nBreaking changes:\n\n* Ldap Password changes is not supported anymore.\n* Ldap Check Shadow expire config is not supported anymore. It should be replace by a custom filter.\n* Drop CentOS 7 and CentOS 8 support\n\n## 2.3.9 (2022-01-05)\n\nMaintenance release to fix minor issues\n\n* Improve date parsing for `backup.log` to avoid printing exception in logs #170\n* Return HTTP error 403 for invalid symlink to avoid returning a misleading HTTP 500 Server Error #168\n* Show a user friendly error message when trying to create a new user with an existing username #169\n* Handle repository without last-backup date during the notification process to ensure notifications are sent #171\n* Replace CherryPy `storage_type` by `storage_class` to avoid warning in logs\n* Update code to avoid deprecation warning where applicable\n* Add Flake8 validation to improve code quality\n* Remove Ubuntu Groovy support\n\n## 2.3.8 (2021-12-01)\n\n* Push all artefacts to nexus server including binaries and documentation\n* Fix `Chart.js` loading on Debian bullseye #164\n* Update installation steps documentation\n* Improve LDAP authentication to lookup entire directory\n* Fix usage of `--ldap-add-user-default-userroot` to avoid error related to wrong encoding\n* Improve authentication mechanics\n* Avoid raising an HTTP error 500 when login form receive invalid payload\n* Mitigate open redirect vulnerability in login form\n\n## 2.3.7 (2021-10-21)\n\n* To avoid backward compatibility issue, revert CSRF Token validation\n* Mitigate CSRF vulnerability using cookies with `SameSite=Lax`\n* Mitigate CSRF vulnerability by validating the `Origin` header when a form is submited\n* Improve usage of WTForm for all form validation\n* Update installation stepd for debian #162\n* Build Ubuntu packages and publish them to our APT repo\n\n## 2.3.6 (2021-10-20)\n\n* Broken build\n\n## 2.3.5 (2021-10-18)\n\n* Mitigate CSRF vulnerability to user, ssh and repo management with CSRF Token\n\n## 2.3.4 (2021-09-20)\n\n* Skip email notification if `email-host` configuration is not provided #157\n* Skip email notification when the new attribute value has the same value #159\n* USE LDAP `mail` attribute when creating new user from LDAP directory #156\n\n## 2.3.3 (2021-09-10)\n\n* Provide a new theme `blue` to match IKUS Soft colors #158\n\n## 2.3.2 (2021-09-07)\n\n* Automatically update user's repository list based on user's home directory\n\n## 2.3.1 (2021-07-14)\n\n* Update default `session-dir` location to `/var/lib/rdiffweb/session` to avoid using `/var/run` #148\n\n## 2.3.0 (2021-07-06)\n\n* Improve timezone handling to display date with local timezone using javascript #143\n* Improve charts by replacing d3js by chartkick #122\n* Replace the status view by something meaningful with chartkick #122\n* Provide Docker image with Rdiffweb `docker pull ikus060/rdiffweb` #55\n* Fix file and folder sorting #143\n\n## 2.2.0 (2021-05-11)\n\n* Debian package:\n  * Add rdiff-backup as dependencies to comply with Debian packaging rules\n  * Multiple other fixed to control files\n  * Use debhelper-compat (= 13)\n  * Use debhelper-compat (= 13)\n  * Run test during packaging\n  * Create default folder `/var/run/rdiffweb/sessions` to store user session\n* Use ConfigArgPare for configuration to support configuration file, environment variables and arguments to configure rdiffweb #114\n* Fix cache in localization module\n* Add `ldap-add-default-role` and `ldap-add-default-userroot` option to define default value for role and user root when creating user from LDAP #125\n* Support PostgreSQL database by replacing our storage layer by SQLAlchemy #126\n* Fix to retrieve user quota only for valid user_root #135\n* Add option `disable-ssh-keys` to disable SSH Key management\n* Use absolute URL everywhere\n* Add support for `X-Forwarded-For`, `X-Forwarded-proto` and other reverse proxy header when generating absolute URL\n* Drop Debian Stretch support\n* Implement a new background scheduler using apscheduler #82\n* Use background job to send email notification to avoid blocking web page loading #47\n* Use background job to delete repository to avoid blocking web page loading #48\n* Allow deleting a specific file or folder from the history using `rdiff-backup-delete` #128\n* Improve support for `session-dir` #131\n* Add option `admin-password` to define administrator password for better security\n* Improve performance of repository browsing\n* Add a new view to display logs of a specific repository\n* Allow downloading the log\n* Define a default limit to graph statistics to make it display faster\n* Fix `get-quota-cmd` option to properly return a value\n\n## 2.1.0 (2021-01-15)\n\n* Debian package: Remove dh-systemd from Debian build dependencies (https://bugs.debian.org/871312we)\n* Improve Quota management:\n  * `QuotaSetCmd`, `QuotaGetCmd` and `QuotaUsedCmd` options could be used to customize how to set the quota for your environment.\n  * Display user's quota in User View\n  * Display user's quota in Admin View\n  * Allow admin to update user quota from Admin View when `QuotaSetCmd` is defined.\n  * Allow admin to define user quota using human readable value (e.g.: GiB, TiB, etc.)\n  * Improve logging around quota management\n* Improve robustness when service is starting\n* Improve robustness when repository has wrong permission defined (e.g.: when some files not readable)\n* Add user id in Admin view\n* Replace `UserObject(1)` by the actual username in log file to improve debugging\n\n## 2.0.0 (2020-12-04)\n\n* Re-implement logic to update repositories views to remove duplicates and avoid nesting repo. #107\n* Handle elapsed time of days in the graph. Thanks [Nathaniel van Diepen](https://github.com/Eeems) contributions.\n* Rebrand all link to ikus-soft.com\n* Update documentation to install rdiffweb\n* Remove obsolete minify dependency\n* Drop support for python2\n* Provide null translation if translation catalogues are not found\n* Pass a LANG environment variable to rdiff-backup restore process to fix encoding issue #112\n* Remove obsolete python shebang\n* Remove execution bit (+x) on python modules\n* Provide `--help` and `--version` on `rdiffweb` executable\n* Improve cherrypy version detection\n* Do not update translation files (.mo) during build\n\n## 1.5.0 (2020-06-24)\n\nThis minor release introduce official support of rdiffweb on Debian Bullseye. It also includes some usability improvements.\n\n* Change formatting of Last Backup date for \"Updated 3 weeks ago\" to ease the readability\n* Add support for Debian Bullseye\n* Add support for Python 3.8 (#104)\n* Add warning in the users list view when a root directory is invalid (#30)\n* Add options to control search depthness (#1)\n* Print a warning in the log when the \"DefaultTheme\" value is not valid (#90)\n\n## 1.4.0 (2020-05-20)\n\nThanks to our sponsor, this release introduce a feature to have better control over the user's permission by defining 3 different levels of privilege: Admin, Maintainer and User. This addition allows you to have better control on what your users can or can't do.\n\n* Fix single repository discovery when a user's home is a rdiff-backup repository\n* [SPONSORED] Add a new setting at the user level to define the user's role. Admin,\n   Maintainer and User. Admin are allowed to do everything. Maintainer are\n   allow to browse and delete repo. Users are only allowed to browse. #94\n* Add \"Powered by\" in the web interface footer #91\n* Display a nice error message when trying to delete admin user #93\n* Introduce usage of wtforms and flash in admin users for better form validation. #96 #97\n* Update French translation\n\n## 1.3.2 (2020-04-23)\n\nThis minor releases fixed issues found while testing release 1.3.0.\n\n* Fix lookup of executable rdiff-backup and rdiffweb-restore to search in current virtualenv first\n* Fix repository view when multiple repo path are conflicting\n* Fix logging of rdiffweb-restore subprocess\n\n## 1.3.1 (2020-04-10)\n\nThis minor release enforces security of the password stored in rdiffweb database to make use of a better encryption using SSHA.\nOnly new passwords will make use of the SSHA scheme.\n\n* Enforce password encryption by using SSHA scheme #88\n\n## 1.3.0 (2020-04-07)\n\nThis release focuses on improving the restore of big archives. The download should be much faster to start. Major enhancement was made to offload the processing outside the web server. And all of this is still compatible with rdiff-backup v1.2.8 and the latest v2.0.0.\n\n* Restore file and folder in a subprocess to make the download start faster\n* Fix encoding of archive on Python3.6 (CentOS 7) by using PAX format\n* Add support to restore files and folders using rdiff-backup2\n* Remove obsolete dependencies `pysqlite2`\n* Fix issue creating duplicate entries of repository in the database\n\n## 1.2.2 (2020-03-05)\n\nThis release provides little improvement to the v1.2.x including official support of rdiff-backup v2.0.0.\n\n* Enhance the repository to invite users to refresh the repository when the view is empty.\n* Support rdiff-backup v2.0.0\n* Deprecate support for cherrypy 4, 5, 6 and 7\n* Improve loading of repository data (cache status and entries)\n* Restore compatibility with SQLite 3.7 (CentOS7)\n\nKnown issues:\n\n* Filename encoding in tar.gz and zip file might not be accurate if you are running Python 3.6 (CentOS7)\n\n## 1.2.1 (2020-02-08)\n\nLittle bug fix following the previous release\n\n* Fix 404 error when trying to access other users repo as admin\n* Fix logging format for cherrypy logs to matches rdiffweb format\n* Add log rotation by default\n\n## 1.2.0 (2020-01-30)\n\nThis release focus on improving the database layers for better extendability to add more type of data and to support more databases backend like postgresql in the near future.\n\n* Add explicit testing for Debian Stretch & Buster\n* Change the persistence layers\n  * Minimize number of SQL queries\n  * Add object lazy loading\n  * Add object data caching\n* Fix bugs with SQLite <= 3.16 (Debian Stretch)\n\n## 1.1.0 (2019-10-31)\n\nThis release focus on improving the admin area and building the fundation for repository access control list (ACL).\n\n* Update documentation from PDSL web site\n* Improve the navigation bar layout\n* Update the login page headline\n* Update jinja2 version to allow 2.10.x\n* Show server log in admin area\n* Reduce code smell\n* Add System information in admin area\n* Validate credential using local database before LDAP\n* Reffactoring templates macros\n* Enhance user's view search bar\n* Change repository URL to username/repopath\n* Add System information in admin area\n* Improve testcases\n* Clean-up obsolete code\n* Fix issue with captital case encoding name\n* Fix compilation of less files\n* Fix google font import\n\n## 1.0.3 (2019-10-04)\n\n* Removing the auto update repos\n\n## 1.0.2 (2019-10-01)\n\n* Create \"admin\" user if missing\n* Update french translation\n\n## 1.0.1 (2019-09-22)\n\n* Update installation documentation\n* Fix removal of SSH Key\n* Return meaningful error to the user trying to add an existing SSH key\n\n## 1.0.0 (2019-09-11)\n\n* Make repository removal more robust\n* Improve performance of librdiff\n* Add new RESTful api\n* Return the right HTTP 401 or 402 error code for authentication\n* Fix bug introduce by upgrade to Jinja2 + python3\n* Store ssh keys in database and disk\n* Add support for theme (default, orange)\n* Remove deprecated profiling code\n* Add disk usage support / quota\n* Add support of cherrypy v18\n* Drop support of cherrypy v3.2.2\n* Add wsgi entry point\n* Replace the plugins architecture to ease implementation\n* Numerous bug fixes\n\n## 0.10.9 (2019-05-22)\n\n* Better error handling when error.log file are not valid gzip file\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Mar 13, 2019\n\n@author: Patrik Dufresne\n\"\"\"\n\nimport datetime\n\nfrom parameterized import parameterized, parameterized_class\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import DbSession, SessionObject\n\n\nclass ControllerTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    default_config = {'HeaderName': 'MyTest'}\n\n    def test_headername(self):\n        \"\"\"\n        Check if the headername is used in the page.\n        \"\"\"\n        self.getPage(\"/\")\n        self.assertStatus('200 OK')\n        self.assertInBody('MyTest')\n\n    def test_proxy(self):\n        \"\"\"\n        Check if the headername is used in the page.\n        \"\"\"\n        self.getPage(\"/\", headers=[('Host', 'this.is.a.test.com')])\n        self.assertStatus('200 OK')\n        self.assertInBody('http://this.is.a.test.com/favicon.ico')\n\n    def test_proxy_https(self):\n        \"\"\"\n        Check if the headername is used in the page.\n        \"\"\"\n        self.getPage(\"/\", headers=[('Host', 'this.is.a.test.com'), ('X-Forwarded-Proto', 'https')])\n        self.assertStatus('200 OK')\n        self.assertInBody('https://this.is.a.test.com/favicon.ico')\n\n    @parameterized.expand(\n        [\n            '/favicon.ico',\n            '/default.css',\n            '/logo',\n            '/header_logo',\n            '/static/css/bootstrap.min.css',\n            '/static/css/font-awesome.min.css',\n            '/static/css/jquery.dataTables.min.css',\n            '/static/js/bootstrap.bundle.min.js',\n            '/static/js/jquery.dataTables.min.js',\n            '/static/js/jquery.min.js',\n            '/static/js/rdiffweb.js',\n        ]\n    )\n    def test_static_files(self, path):\n        \"\"\"\n        Check if the theme is properly configure.\n        \"\"\"\n        self.getPage('/logout', method=\"POST\")\n        self.getPage(path)\n        self.assertStatus(200)\n        # Test with invalid method.\n        self.getPage(path, method=\"POST\")\n        self.assertStatus(400)\n\n    def test_static_invalid_file(self):\n        \"\"\"\n        Check if the theme is properly configure.\n        \"\"\"\n        self.getPage(\"/static/invalid.css\")\n        self.assertStatus(400)\n\n    def test_path_traversal(self):\n        self.getPage('/static//../../test.txt')\n        self.assertStatus(403)\n\n\n@parameterized_class(\n    [\n        {\"default_config\": {'DefaultTheme': 'default'}, \"expect_color\": '#35979c'},\n        {\"default_config\": {'DefaultTheme': 'orange'}, \"expect_color\": '#dd4814'},\n        {\"default_config\": {'DefaultTheme': 'blue'}, \"expect_color\": '#153a58'},\n        {\"default_config\": {'link-color': '111'}, \"expect_color\": '#111'},\n        {\"default_config\": {'navbar-color': '222'}, \"expect_color\": '#222'},\n        {\"default_config\": {'font-family': 'Sans'}, \"expect_color\": 'Sans'},\n    ]\n)\nclass ControllerThemeTest(rdiffweb.test.WebCase):\n\n    default_config = {}\n\n    expect_color = ''\n\n    def test_static(self):\n        # Query css with uniq value to avoid caching.\n        self.getPage(\"/default.css\")\n        self.assertStatus('200 OK')\n        self.assertInBody(self.expect_color)\n\n\nclass ControllerSession(rdiffweb.test.WebCase):\n    def test_enrich_session_anonymous(self):\n        # When making a query to a page while unauthenticated\n        self.getPage('/', headers=[('User-Agent', 'test')])\n        # Then a session object is enriched\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertIsNotNone(session.get('ip_address'))\n        self.assertIsNotNone(session.get('user_agent'))\n        self.assertIsNotNone(session.get('access_time'))\n\n    def test_enrich_session_authenticated(self):\n        # When making a query to a page while unauthenticated\n        self.getPage(\n            '/login/',\n            method='POST',\n            headers=[('User-Agent', 'test')],\n            body={'login': self.USERNAME, 'password': self.PASSWORD},\n        )\n        # Then a session object is enriched\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertIsNotNone(session.get('ip_address'))\n        self.assertIsNotNone(session.get('user_agent'))\n        self.assertIsNotNone(session.get('access_time'))\n\n    def test_create_session(self):\n        # Given a server with no session.\n        self.assertEqual(0, len(SessionObject.query.all()))\n        # When querying a new page\n        self.getPage('/')\n        self.assertStatus(303)\n        # Then a new session get created\n        self.assertEqual(1, len(SessionObject.query.all()))\n        session = SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        self.assertIsNotNone(session)\n\n    def test_clean_up_session(self):\n        # Given a server with a session\n        self.getPage('/')\n        self.assertStatus(303)\n        self.assertEqual(1, len(SessionObject.query.all()))\n        # When this session get old\n        data = SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        data.expiration_time = datetime.datetime.now() - datetime.timedelta(seconds=1)\n        data.commit()\n        session = DbSession(id=self.session_id)\n        # Then the session get deleted by clean_up process\n        session.clean_up()\n        # Then session is deleted\n        data = SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        self.assertIsNone(data)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom unittest.mock import ANY, MagicMock\n\nimport cherrypy\nfrom parameterized import parameterized\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import UserObject\n\n\nclass AbstractAdminTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    def setUp(self):\n        super().setUp()\n        self._quota = {}\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)\n        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)\n        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n        self.listener.get_disk_quota.side_effect = self._load_quota\n        cherrypy.engine.subscribe('get_disk_quota', self.listener.get_disk_quota, priority=40)\n        self.listener.get_disk_usage.return_value = 0\n        cherrypy.engine.subscribe('get_disk_usage', self.listener.get_disk_usage, priority=40)\n        self.listener.set_disk_quota.side_effect = self._store_quota\n        cherrypy.engine.subscribe('set_disk_quota', self.listener.set_disk_quota, priority=40)\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)\n        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)\n        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        cherrypy.engine.unsubscribe('get_disk_quota', self.listener.get_disk_quota)\n        cherrypy.engine.unsubscribe('get_disk_usage', self.listener.get_disk_usage)\n        cherrypy.engine.unsubscribe('set_disk_quota', self.listener.set_disk_quota)\n        return super().tearDown()\n\n    def _store_quota(self, userobj, value):\n        self._quota[userobj.username] = value\n\n    def _load_quota(self, userobj):\n        return self._quota.get(userobj.username, 0)\n\n    def _add_user(self, username=None, email=None, password=None, user_root=None, role=None, mfa=None, fullname=None):\n        b = {}\n        b['action'] = 'add'\n        if username is not None:\n            b['username'] = username\n        if email is not None:\n            b['email'] = email\n        if password is not None:\n            b['password'] = password\n        if user_root is not None:\n            b['user_root'] = user_root\n        if role is not None:\n            b['role'] = str(role)\n        if mfa is not None:\n            b['mfa'] = str(mfa)\n        if fullname is not None:\n            b['fullname'] = str(fullname)\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def _edit_user(\n        self, username=None, email=None, password=None, user_root=None, role=None, disk_quota=None, mfa=None\n    ):\n        b = {}\n        b['action'] = 'edit'\n        if username is not None:\n            b['username'] = username\n        if email is not None:\n            b['email'] = email\n        if password is not None:\n            b['password'] = password\n        if user_root is not None:\n            b['user_root'] = user_root\n        if role is not None:\n            b['role'] = str(role)\n        if disk_quota is not None:\n            b['disk_quota'] = disk_quota\n        if mfa is not None:\n            b['mfa'] = str(mfa)\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def _delete_user(self, username='test1'):\n        b = {'action': 'delete', 'username': username}\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def test_add_user_with_role_admin(self):\n        # When trying to create a new user with role admin\n        self._add_user(\"admin_role\", \"admin_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.ADMIN_ROLE)\n        # Then page return success\n        self.assertStatus(200)\n        # Then database is updated\n        userobj = UserObject.get_user('admin_role')\n        self.assertEqual(UserObject.ADMIN_ROLE, userobj.role)\n        # Then notification was raised\n        self.listener.user_added.assert_called_once_with(userobj)\n\n    def test_add_user_with_role_maintainer(self):\n        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.MAINTAINER_ROLE)\n        self.assertStatus(200)\n        self.assertEqual(UserObject.MAINTAINER_ROLE, UserObject.get_user('maintainer_role').role)\n\n    def test_add_user_with_role_user(self):\n        self._add_user(\"user_role\", \"user_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        self.assertEqual(UserObject.USER_ROLE, UserObject.get_user('user_role').role)\n\n    def test_add_user_with_invalid_role(self):\n        # When trying to create a new user with an invalid role (admin instead of 0)\n        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", 'admin')\n        # Then an error message is displayed to the user\n        self.assertStatus(200)\n        self.assertInBody('Role: Invalid Choice: could not coerce')\n        # Then listener are not called\n        self.listener.user_added.assert_not_called()\n\n        # When trying to create a new user with an invalid role (-1)\n        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", -1)\n        # Then an error message is displayed to the user\n        self.assertStatus(200)\n        self.assertInBody('User Role: Not a valid choice')\n        # Then listener are not called\n        self.listener.user_added.assert_not_called()\n\n    def test_add_edit_delete(self):\n        #  Add user to be listed\n        self.listener.user_password_changed.reset_mock()\n        self._add_user(\n            \"test2\", \"test2@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE, mfa=UserObject.DISABLED_MFA\n        )\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"test2\")\n        self.assertInBody(\"test2@test.com\")\n        self.listener.user_added.assert_called_once()\n        self.listener.user_password_changed.assert_called_once()\n        self.listener.user_password_changed.reset_mock()\n        #  Update user\n        self._edit_user(\n            \"test2\", \"chaned@test.com\", \"new-password\", \"/tmp/\", UserObject.ADMIN_ROLE, mfa=UserObject.ENABLED_MFA\n        )\n        self.listener.user_attr_changed.assert_called()\n        self.listener.user_password_changed.assert_called_once()\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertInBody(\"test2\")\n        self.assertInBody(\"chaned@test.com\")\n        self.assertNotInBody(\"/home/\")\n        self.assertInBody(\"/tmp/\")\n\n        self._delete_user(\"test2\")\n        self.listener.user_deleted.assert_called()\n        self.assertStatus(200)\n        self.assertInBody(\"User account removed.\")\n        self.assertNotInBody(\"test2\")\n\n    @parameterized.expand(\n        [\n            # Invalid\n            ('evil.com', False),\n            ('http://test', False),\n            ('email@test.test', False),\n            ('/test/', False),\n            # Valid\n            ('My fullname', True),\n            ('Test Test', True),\n            ('\u00c9ric Terrien-Pascal', True),\n            (\"Tel'c\", True),\n        ]\n    )\n    def test_edit_fullname_with_special_character(self, new_fullname, expected_valid):\n        # Given an existing user\n        # When updating the user's fullname\n        self.getPage(\n            \"/admin/users/\",\n            method='POST',\n            body={'action': 'edit', 'username': self.USERNAME, 'fullname': new_fullname},\n        )\n        self.assertStatus(200)\n        if expected_valid:\n            self.assertInBody(\"User information modified successfully.\")\n            self.assertNotInBody(\"Fullname: Must not contain any special characters.\")\n        else:\n            self.assertNotInBody(\"User information modified successfully.\")\n            self.assertInBody(\"Fullname: Must not contain any special characters.\")\n\n    @parameterized.expand(\n        [\n            # Invalid\n            ('http://username', False),\n            ('username@test.test', False),\n            ('/username/', False),\n            # Valid\n            ('username.com', True),\n            ('admin_user', True),\n            ('test.test', True),\n            ('test-test', True),\n        ]\n    )\n    def test_add_user_with_special_character(self, new_username, expected_valid):\n        self._add_user(new_username, \"eric@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        if expected_valid:\n            self.assertInBody(\"User added successfully.\")\n            self.assertNotInBody(\"Username: Must not contain any special characters.\")\n        else:\n            self.assertNotInBody(\"User added successfully.\")\n            self.assertInBody(\"Username: Must not contain any special characters.\")\n\n    def test_add_user_with_empty_username(self):\n        \"\"\"\n        Verify failure trying to create user without username.\n        \"\"\"\n        self._add_user(\"\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        self.assertInBody(\"Username: This field is required.\")\n\n    def test_add_user_with_existing_username(self):\n        \"\"\"\n        Verify failure trying to add the same user.\n        \"\"\"\n        # Given a user named `test1`\n        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        # When trying to create a new user with the same name\n        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then the user list is displayed with an error message.\n        self.assertStatus(200)\n        self.assertInBody(\"User test1 already exists.\")\n\n    def test_add_user_with_invalid_root_directory(self):\n        \"\"\"\n        Verify failure to add a user with invalid root directory.\n        \"\"\"\n        try:\n            self._delete_user(\"test5\")\n        except Exception:\n            pass\n        self._add_user(\"test5\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")\n\n    def test_add_without_email(self):\n        #  Add user to be listed\n        self._add_user(\"test2\", None, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n\n    def test_add_without_user_root(self):\n        #  Add user to be listed\n        self._add_user(\"test6\", None, \"pr3j5Dwi\", None, UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n\n        user = UserObject.get_user('test6')\n        self.assertEqual('', user.user_root)\n\n    def test_add_with_username_too_long(self):\n        # Given a too long username\n        username = \"test2\" * 52\n        # When trying to create the user\n        self._add_user(username, None, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Username too long.\")\n\n    def test_add_with_email_too_long(self):\n        # Given a too long username\n        email = (\"test2\" * 50) + \"@test.com\"\n        # When trying to create the user\n        self._add_user(\"test2\", email, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Email too long.\")\n\n    def test_add_with_user_root_too_long(self):\n        # Given a too long user root\n        user_root = \"/temp/\" * 50\n        # When trying to create the user\n        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", user_root, UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Root directory too long.\")\n\n    def test_add_with_fullname_too_long(self):\n        # Given a too long user root\n        fullname = \"fullname\" * 50\n        # When trying to create the user\n        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE, fullname=fullname)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Fullname too long.\")\n\n    def test_delete_user_with_not_existing_username(self):\n        \"\"\"\n        Verify failure to delete invalid username.\n        \"\"\"\n        self._delete_user(\"test3\")\n        self.assertInBody(\"User doesn&#39;t exists!\")\n\n    def test_delete_our_self(self):\n        \"\"\"\n        Verify failure to delete our self.\n        \"\"\"\n        self._delete_user(self.USERNAME)\n        self.assertInBody(\"You cannot remove your own account!\")\n\n    def test_delete_user_admin(self):\n        \"\"\"\n        Verify failure to delete our self.\n        \"\"\"\n        # Create another admin user\n        self._add_user('admin2', '', 'pr3j5Dwi', '', UserObject.ADMIN_ROLE)\n        self.getPage(\"/logout\", method=\"POST\")\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        self._login('admin2', 'pr3j5Dwi')\n\n        # Try deleting admin user\n        self._delete_user(self.USERNAME)\n        self.assertStatus(200)\n        self.assertInBody(\"can&#39;t delete admin user\")\n\n    def test_delete_user_method_get(self):\n        # Given a user\n        user = UserObject.add_user('newuser')\n        user.commit()\n        # When trying to delete this user using method GET\n        self.getPage(\"/admin/users/?action=delete&username=newuser\", method='GET')\n        # Then page return without error\n        self.assertStatus(200)\n        # Then user is not deleted\n        self.assertIsNotNone(UserObject.get_user('newuser'))\n\n    def test_change_password_with_too_short(self):\n        self._edit_user(self.USERNAME, password='short')\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_too_long(self):\n        new_password = 'a' * 129\n        self._edit_user(self.USERNAME, password=new_password)\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_admin_password(self):\n        # Given rdiffweb is configured with admin-password option\n        self.app.cfg.admin_password = 'hardcoded'\n        try:\n            # When trying to update admin password\n            self._edit_user('admin', password='new-password')\n            # Then the form is refused with 200 OK with an error message.\n            self.assertStatus(200)\n            self.assertInBody(\"can&#39;t update admin-password defined in configuration file\")\n        finally:\n            self.app.cfg.admin_password = None\n\n    def test_edit_user_with_invalid_path(self):\n        \"\"\"\n        Verify failure trying to update user with invalid path.\n        \"\"\"\n        userobj = UserObject.add_user('test1')\n        userobj.commit()\n        self._edit_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", UserObject.USER_ROLE)\n        self.assertNotInBody(\"User added successfully.\")\n        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")\n\n    def test_list(self):\n        self.getPage(\"/admin/users/\")\n        self.assertInBody(\"Users\")\n        self.assertInBody(\"User management\")\n        self.assertInBody(\"Add user\")\n\n    def test_edit_user_with_not_existing_username(self):\n        \"\"\"\n        Verify failure trying to update invalid user.\n        \"\"\"\n        # Given an invalid username\n        username = 'invalid'\n        # When trying to edit the user\n        self._edit_user(username, \"test1@test.com\", \"test\", \"/var/invalid/\", UserObject.USER_ROLE)\n        # Then the user list is displayed with an error message\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot edit user `invalid`: user doesn&#39;t exists\")\n\n    def test_user_invalid_root(self):\n        # Change the user's root\n        user = UserObject.get_user(self.USERNAME)\n        user.user_root = \"/invalid\"\n        user.commit()\n        self.getPage(\"/admin/users\")\n        self.assertInBody(\"Root directory not accessible!\")\n\n        # Query the page by default\n        user = UserObject.get_user('admin')\n        user.user_root = \"/tmp/\"\n        user.commit()\n        self.getPage(\"/admin/users\")\n        self.assertNotInBody(\"Root directory not accessible!\")\n\n    def test_get_quota(self):\n        # Mock a quota.\n        self.listener.get_disk_quota.side_effect = None\n        self.listener.get_disk_quota.return_value = 654321\n        # When querying the user list\n        self.getPage(\"/admin/users/\")\n        self.assertStatus(200)\n        # Then get_disk_quota listenre is called\n        self.listener.get_disk_quota.assert_called()\n        # Then the quota value is displayed in human readable format\n        self.assertInBody(\"638.99 KiB\")\n        self.assertStatus(200)\n\n    def test_set_quota(self):\n        # When updating user quota.\n        self._edit_user(\"admin\", disk_quota='8765432')\n        # Then listenr get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_gib(self):\n        # When updating user quota\n        self._edit_user(\"admin\", disk_quota='1GiB')\n        # Then listern get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 1073741824)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_with_comma(self):\n        # When updating quota with comma value\n        self._edit_user(\"admin\", disk_quota='1,5 GiB')\n        # Then listner get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 1610612736)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_with_leading_dot(self):\n        # When updating quota with leading dot\n        self._edit_user(\"admin\", disk_quota='.5 GiB')\n        # Then listener get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 536870912)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_empty(self):\n        # When quota is not defined\n        self._edit_user(\"admin\", disk_quota='')\n        # Then listener is not called.\n        self.listener.set_disk_quota.assert_not_called()\n        # Then message is not displayed\n        self.assertStatus(200)\n\n    def test_set_quota_same_value(self):\n        # Given an exiting quota\n        self.listener.get_disk_quota.side_effect = None\n        self.listener.get_disk_quota.return_value = 1234567890\n        # When setting the quota value to the same value\n        self._edit_user(\"admin\", disk_quota='1.15 GiB')\n        #  Then listener is not called\n        self.listener.set_disk_quota.assert_not_called()\n        # Then message is not displayed\n        self.assertStatus(200)\n\n    def test_set_quota_unsupported(self):\n        # Given setting quota is not supported\n        self.listener.set_disk_quota.side_effect = None\n        self.listener.set_disk_quota.return_value = None\n        # When updating the quota\n        self._edit_user(\"admin\", disk_quota='8765432')\n        # Then\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)\n        self.assertInBody(\"Setting user&#39;s quota is not supported\")\n        self.assertStatus(200)\n\n    def test_edit_own_role(self):\n        # Given an administrator\n        # When trygin to update your own role\n        self._edit_user(username=self.USERNAME, role=UserObject.MAINTAINER_ROLE)\n        # Then an error is returned\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot edit your own role.\")\n\n    def test_edit_own_mfa(self):\n        # Given an administrator\n        # When trygin to update your own role\n        self._edit_user(username=self.USERNAME, mfa=UserObject.ENABLED_MFA)\n        # Then an error is returned\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot change your own two-factor authentication settings.\")\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Dec 26, 2015\n\n@author: Patrik Dufresne\n\"\"\"\nimport os\n\nfrom parameterized import parameterized, parameterized_class\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import DbSession, SessionObject, UserObject\nfrom rdiffweb.tools.auth_form import LOGIN_TIME, SESSION_KEY\n\n\nclass LoginPageTest(rdiffweb.test.WebCase):\n    def test_getpage(self):\n        # When making a query to a page while unauthenticated\n        self.getPage('/')\n        # Then user is redirected to login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # Then a session object is created without a username\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertIsNone(session.get(SESSION_KEY))\n\n    def test_login_success(self):\n        # Given an anonymous user\n        self.getPage('/')\n        prev_session_id = self.session_id\n        # Then user is redirected to /login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # When authenticating with valid credentials.\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        # Then a new session_id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Then a session object is created with a username\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertEqual('admin', session.get(SESSION_KEY))\n        self.assertIsNotNone(session.get(LOGIN_TIME))\n\n    def test_cookie_http_only(self):\n        # Given a request made to rdiffweb\n        # When receiving the response\n        self.getPage('/')\n        # Then the header contains Set-Cookie with HttpOnly\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('HttpOnly', cookie)\n\n    def test_login_with_plaintext(self):\n        \"\"\"\n        Requesting plain text without being authenticated should show the login form.\n        \"\"\"\n        # When querying root page without authentication\n        self.getPage('/', headers=[(\"Accept\", \"text/plain\")])\n        # Then user is redirected to /login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n\n    @parameterized.expand(\n        [\n            ('with_root', '/'),\n            ('with_browse_url', '/browse/admin/testcases/Revisions/'),\n            ('with_encoded_url', '/browse/admin/testcases/DIR%EF%BF%BD/'),\n            (\n                'with_broken_encoding',\n                '/restore/admin/testcases/Fichier%20avec%20non%20asci%20char%20%C9velyne%20M%E8re.txt/?date=1415221507',\n            ),\n            ('with_query_string', '/restore/admin/testcases/Revisions?date=1477434528'),\n            ('with_multiple_query_string', '/restore/admin/testcases/Revisions?date=1477434528&kind=tar.gz'),\n            ('with_admin', '/admin/'),\n        ]\n    )\n    def test_login(self, unused, original_url):\n        # Given an unauthenticated user\n        # Query the page without login-in\n        self.getPage(original_url)\n        # Then user is redirected to the login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # When authentication is successful\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        # Then user is redirected to original URL\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + original_url)\n        # Then cookie is not persistent\n        self.assertNotIn('expires', self.cookies[0][1])\n        self.assertNotIn('Max-Age', self.cookies[0][1])\n        # When requesting the original page\n        self.getPage(original_url)\n        # Then page return without error\n        self.assertStatus(200)\n\n    def test_getpage_with_redirect_post(self):\n        \"\"\"\n        Check encoding of redirect url when send using POST method.\n        \"\"\"\n        # When posting invalid credentials\n        b = {'login': 'admin', 'password': 'invalid', 'redirect': '/browse/' + self.REPO + '/DIR%EF%BF%BD/'}\n        self.getPage('/login/', method='POST', body=b)\n        # Then page return without HTTP Error\n        self.assertStatus('200 OK')\n        # Then page display an error\n        self.assertInBody('Invalid username or password.')\n        self.assertInBody('id=\"form-login\"')\n        # Then redirect URL is ignored\n        self.assertNotInBody('/browse/' + self.REPO + '/DIR%EF%BF%BD/\"')\n\n    def test_getpage_without_username(self):\n        \"\"\"\n        Check if error is raised when requesting /login without a username.\n        \"\"\"\n        self.getPage('/login/', method='GET')\n        self.assertStatus('200 OK')\n\n    def test_getpage_with_username_too_long(self):\n        b = {'login': 'admin' * 52, 'password': 'admin123'}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('200 OK')\n        self.assertInBody('Username too long.')\n\n    def test_getpage_with_empty_password(self):\n        \"\"\"\n        Check if authentication is failing without a password.\n        \"\"\"\n        b = {'login': 'admin', 'password': ''}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('200 OK')\n        self.assertInBody('This field is required.')\n\n    def test_getpage_with_invalid_url(self):\n        self.getPage('/login/kefuxian.mvc', method='GET')\n        self.assertStatus('303 See Other')\n\n    def test_post_with_invalid_url(self):\n        self.getPage('/login/kefuxian.mvc', method='POST')\n        self.assertStatus('303 See Other')\n\n    def test_login_twice(self):\n        # Given an authenticated user\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + \"/\")\n        self.getPage('/')\n        self.assertStatus(200)\n        self.assertInBody(self.USERNAME)\n        # Given another user\n        userobj = UserObject.add_user('otheruser', password='password')\n        userobj.commit()\n        # When trying to re-authenticated with login page\n        self.getPage('/login/', method='POST', body={'login': 'otheruser', 'password': 'password'})\n        # Then user is still authenticated with previous user\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + \"/\")\n        self.getPage('/')\n        self.assertStatus(200)\n        self.assertInBody(self.USERNAME)\n\n    def test_login_persistent(self):\n        # Given a user authenticated with persistent\n        self.getPage('/logout', method=\"POST\")\n        self.assertStatus(303)\n        self.getPage(\n            '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}\n        )\n        self.assertStatus(303)\n        # Then a persistent cookie is return\n        self.assertIn('expires', self.cookies[0][1])\n        self.assertIn('Max-Age', self.cookies[0][1])\n        # Then a session is created with persistent flag\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertTrue(session['login_persistent'])\n        # Then session timeout is 30 days in future\n        self.assertAlmostEqual(session.timeout, 43200, delta=2)\n\n\nclass LoginPageWithWelcomeMsgTest(rdiffweb.test.WebCase):\n\n    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}\n\n    def test_getpage_default(self):\n        \"\"\"\n        Make sure the login page can be rendered without error.\n        \"\"\"\n        self.getPage('/login/', headers=[(\"Accept-Language\", \"it\")])\n        self.assertStatus('200 OK')\n        self.assertInBody('default message')\n\n    def test_getpage_french(self):\n        \"\"\"\n        Make sure the login page can be rendered without error.\n        \"\"\"\n        self.getPage('/login/', headers=[(\"Accept-Language\", \"fr\")])\n        self.assertStatus('200 OK')\n        self.assertInBody('french message')\n\n\nclass LoginPageWithHeaderName(rdiffweb.test.WebCase):\n\n    default_config = {'header-name': 'HEADER-NAME'}\n\n    def test_getpage_default(self):\n        # Given a custom header-name\n        # When querying the loging page\n        self.getPage('/login/')\n        # Then the page display the header-name\n        self.assertStatus('200 OK')\n        self.assertInBody('HEADER-NAME')\n\n\n@parameterized_class(\n    [\n        {\"default_config\": {'rate-limit': 5}},\n        {\"default_config\": {'rate-limit': 5, 'rate-limit-dir': '/tmp'}},\n    ]\n)\nclass LoginPageRateLimitTest(rdiffweb.test.WebCase):\n    def setUp(self):\n        if os.path.isfile('/tmp/ratelimit-127.0.0.1'):\n            os.unlink('/tmp/ratelimit-127.0.0.1')\n        if os.path.isfile('/tmp/ratelimit-127.0.0.1.-login'):\n            os.unlink('/tmp/ratelimit-127.0.0.1.-login')\n        return super().setUp()\n\n    def test_login_ratelimit(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page\n        for i in range(1, 5):\n            self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})\n            self.assertStatus(200)\n        # Then a 429 error (too many request) is return\n        self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})\n        self.assertStatus(429)\n\n\nclass LoginPageRateLimitTest2(rdiffweb.test.WebCase):\n\n    default_config = {'rate-limit': 5}\n\n    def test_login_ratelimit_forwarded_for(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page with different `X-Forwarded-For`\n        for i in range(1, 5):\n            self.getPage(\n                '/login/',\n                headers=[('X-Forwarded-For', '127.0.0.%s' % i)],\n                method='POST',\n                body={'login': 'invalid', 'password': 'invalid'},\n            )\n            self.assertStatus(200)\n        # Then original IP get blocked\n        self.getPage(\n            '/login/',\n            headers=[('X-Forwarded-For', '127.0.0.%s' % i)],\n            method='POST',\n            body={'login': 'invalid', 'password': 'invalid'},\n        )\n        self.assertStatus(429)\n\n\nclass LoginPageRateLimitTest3(rdiffweb.test.WebCase):\n    default_config = {'rate-limit': 5}\n\n    def test_login_ratelimit_real_ip(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page with different `X-Real-IP`\n        for i in range(1, 5):\n            self.getPage(\n                '/login/',\n                headers=[('X-Real-IP', '127.0.0.128')],\n                method='POST',\n                body={'login': 'invalid', 'password': 'invalid'},\n            )\n            self.assertStatus(200)\n        # Then the X-Real-IP get blocked\n        self.getPage(\n            '/login/',\n            headers=[('X-Real-IP', '127.0.0.128')],\n            method='POST',\n            body={'login': 'invalid', 'password': 'invalid'},\n        )\n        self.assertStatus(429)\n\n\nclass LogoutPageTest(rdiffweb.test.WebCase):\n    def test_getpage_without_login(self):\n        # Given an unauthenticated user\n        # When Accessing logout page directly\n        self.getPage('/logout', method=\"POST\")\n        # Then user is redirect to root '/'\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n\n    def test_getpage_with_login(self):\n        # Given an anonymous user\n        self.getPage('/')\n        prev_session_id = self.session_id\n        # Login\n        b = {'login': 'admin', 'password': 'admin123'}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('303 See Other')\n        # Then a new session id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        prev_session_id = self.session_id\n        # Get content of a page.\n        self.getPage(\"/prefs/general\")\n        self.assertStatus('200 OK')\n        # When logout\n        self.getPage('/logout', method=\"POST\")\n        # Then a new session id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected to root page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Get content of a page.\n        self.getPage(\"/prefs/general\")\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport datetime\nfrom unittest.mock import MagicMock\n\nimport cherrypy\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import DbSession, UserObject\n\n\nclass MfaPageTest(rdiffweb.test.WebCase):\n\n    # Authenticated by default.\n    login = True\n\n    def _get_code(self):\n        # Register an email listeer to capture email send\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('queue_mail', self.listener.queue_email, priority=50)\n        # Query MFA page to generate a code\n        self.getPage(\"/mfa/\")\n        self.assertStatus(200)\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n        # Extract code from email between <strong> and </strong>\n        self.listener.queue_email.assert_called_once()\n        message = self.listener.queue_email.call_args[1]['message']\n        return message.split('<strong>', 1)[1].split('</strong>')[0]\n\n    def setUp(self):\n        super().setUp()\n        # Enabled MFA for all test cases\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.mfa = UserObject.ENABLED_MFA\n        userobj.email = 'admin@example.com'\n        userobj.commit()\n\n    def test_get_without_login(self):\n        # Given an unauthenticated user\n        self.getPage(\"/logout\", method=\"POST\")\n        self.assertStatus(303)\n        # When requesting /mfa/\n        self.getPage(\"/mfa/\")\n        # Then user is redirected to /login/\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n\n    def test_get_with_mfa_disabled(self):\n        # Given an authenticated user with MFA Disable\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.mfa = UserObject.DISABLED_MFA\n        userobj.commit()\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        # When requesting /mfa/ page\n        self.getPage(\"/mfa/\")\n        # Then user is redirected to root page\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n\n    def test_get_with_user_without_email(self):\n        # Given an authenticated user without email.\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.email = ''\n        userobj.commit()\n        # When requesting /mfa/ page\n        self.getPage(\"/mfa/\")\n        # Then user is redirected to root page\n        self.assertStatus(200)\n        self.assertInBody(\n            \"Multi-factor authentication is enabled for your account, but your account does not have a valid email address to send the verification code to. Check your account settings with your administrator.\"\n        )\n\n    def test_get_with_trusted(self):\n        # Given an authenticated user with MFA enabled and already verified\n        session = DbSession(id=self.session_id)\n        session.load()\n        session['_auth_mfa_username'] = self.USERNAME\n        session['_auth_mfa_time'] = session.now()\n        session['_auth_mfa_trusted_ip_list'] = ['127.0.0.1']\n        session.save()\n        # When requesting /mfa/ page when we are already trusted\n        self.getPage(\"/mfa/\")\n        # Then user is redirected to root page\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n\n    def test_get_with_trusted_expired(self):\n        # Given an authenticated user with MFA enabled and already verified\n        session = DbSession(id=self.session_id)\n        session.load()\n        session['_auth_mfa_username'] = self.USERNAME\n        session['_auth_mfa_time'] = session.now() - datetime.timedelta(minutes=session.timeout)\n        session.save()\n        # When requesting /mfa/ page\n        self.getPage(\"/mfa/\")\n        # Then an email get send with a new code\n        self.assertStatus(200)\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_get_with_trusted_different_ip(self):\n        # Given an authenticated user with MFA enabled and already verified\n        session = DbSession(id=self.session_id)\n        session.load()\n        session['_auth_mfa_username'] = self.USERNAME\n        session['_auth_mfa_time'] = session.now()\n        session.save()\n        # When requesting /mfa/ page from a different ip\n        self.getPage(\"/mfa/\", headers=[('X-Forwarded-For', '10.255.14.23')])\n        # Then an email get send with a new code\n        self.assertStatus(200)\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_get_without_verified(self):\n        # Given an authenticated user With MFA enabled\n        # When requesting /mfa/ page\n        self.getPage(\"/mfa/\")\n        # Then an email get send with a new code\n        self.assertStatus(200)\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_verify_code_valid(self):\n        prev_session_id = self.session_id\n        # Given an authenticated user With MFA enabled\n        code = self._get_code()\n        # When sending a valid verification code\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})\n        # Then a new session_id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected to root page\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Then user has access\n        self.getPage(\"/\")\n        self.assertStatus(200)\n\n    def test_verify_code_invalid(self):\n        # Given an authenticated user With MFA enabled\n        # When sending an invalid verification code\n        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})\n        # Then an error get displayed to the user\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid verification code.\")\n\n    def test_verify_code_expired(self):\n        # Given an authenticated user With MFA enabled\n        code = self._get_code()\n        # When sending a valid verification code that expired\n        session = DbSession(id=self.session_id)\n        session.load()\n        session['_auth_mfa_code_time'] = session.now() - datetime.timedelta(minutes=session.timeout + 1)\n        session.save()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})\n        # Then a new code get generated.\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid verification code.\")\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_verify_code_invalid_after_3_tentative(self):\n        # Given an authenticated user With MFA\n        self._get_code()\n        # When user enter an invalid verification code 3 times\n        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})\n        self.assertStatus(200)\n        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})\n        self.assertStatus(200)\n        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})\n        # Then an error get displayed to the user\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid verification code.\")\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_resend_code(self):\n        # Given an authenticated user With MFA enabled with an existing code\n        self._get_code()\n        # When user request a new code\n        self.getPage(\"/mfa/\", method='POST', body={'resend_code': '1'})\n        # Then a new code is sent to the user by email\n        self.assertInBody(\"A new verification code has been sent to your email.\")\n\n    def test_redirect_to_original_url(self):\n        # When querying a page that required mfa\n        self.getPage('/prefs/general')\n        # Then user is redirected to mfa page\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/mfa/')\n        # When providing verification code\n        code = self._get_code()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})\n        # Then user is redirected to original url\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')\n\n    def test_login_persistent_when_login_timout(self):\n        prev_session_id = self.session_id\n        # Given a user authenticated with MFA with \"login_persistent\"\n        code = self._get_code()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})\n        self.assertStatus(303)\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        self.assertNotEqual(prev_session_id, self.session_id)\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertTrue(session['login_persistent'])\n        # When the login_time expired (after 15 min)\n        session['login_time'] = session.now() - datetime.timedelta(minutes=15, seconds=1)\n        session.save()\n        # Then next query redirect user to same page (by mfa)\n        self.getPage(\"/prefs/general\")\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')\n        self.getPage(\"/prefs/general\")\n        # Then user is redirected to /login/ page (by auth_form)\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        prev_session_id = self.session_id\n        # When user enter valid username password\n        self.getPage(\"/login/\", method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected to original url\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        self.assertInBody('Repositories')\n\n    def test_login_persistent_when_mfa_timeout(self):\n        prev_session_id = self.session_id\n        # Given a user authenticated with MFA with \"login_persistent\"\n        code = self._get_code()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})\n        self.assertStatus(303)\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        self.assertNotEqual(prev_session_id, self.session_id)\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertTrue(session['login_persistent'])\n        # When the mfa verification timeout (after 30 days)\n        session['_auth_mfa_time'] = session.now() - datetime.timedelta(days=30, seconds=1)\n        session.save()\n        # Then next query redirect user to mfa page\n        self.getPage(\"/prefs/general\")\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/mfa/')\n        # When user enter valid code\n        code = self._get_code()\n        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})\n        # Then user is redirected to original page.\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')\n        self.getPage(\"/\")\n        self.assertStatus(200)\n        self.assertInBody('Repositories')\n\n\nclass MfaPageWithWelcomeMsgTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}\n\n    def setUp(self):\n        super().setUp()\n        # Enabled MFA for all test cases\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.mfa = UserObject.ENABLED_MFA\n        userobj.email = 'admin@example.com'\n        userobj.commit()\n\n    def test_getpage_default(self):\n        # Given a user with MFA enabled\n        # When querying the mfa page\n        self.getPage('/mfa/', headers=[(\"Accept-Language\", \"it\")])\n        # Then page is return without error with the custom welcome message\n        self.assertStatus('200 OK')\n        self.assertInBody('default message')\n\n    def test_getpage_french(self):\n        # Given a user with MFA enabled\n        # When querying the mfa page in french\n        self.getPage('/mfa/', headers=[(\"Accept-Language\", \"fr\")])\n        # Then page is return without error with the custom welcome message in french\n        self.assertStatus('200 OK')\n        self.assertInBody('french message')\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Oct 20, 2021\n\n@author: Patrik Dufresne\n\"\"\"\nfrom parameterized import parameterized\n\nimport rdiffweb.test\n\n\nclass SecureHeadersTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    def test_cookie_samesite_lax(self):\n        # Given a request made to rdiffweb\n        # When receiving the response\n        self.getPage('/')\n        # Then the header contains Set-Cookie with SameSite=Lax\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('SameSite=Lax', cookie)\n\n    def test_cookie_samesite_lax_without_session(self):\n        # Given not a client sending no cookie\n        self.cookies = None\n        # When a query is made to a static path (without session)\n        self.getPage('/static/blue.css')\n        # Then Set-Cookie is not defined.\n        self.assertNoHeader('Set-Cookie')\n\n    def test_cookie_with_https(self):\n        # Given an https request made to rdiffweb\n        self.getPage('/', headers=[('X-Forwarded-Proto', 'https')])\n        # When receiving the response\n        self.assertStatus(200)\n        # Then the header contains Set-Cookie with Secure\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('Secure', cookie)\n\n    @parameterized.expand(\n        [\n            ('/invalid', 404),\n            ('/browse/invalid', 404),\n            ('/login', 301),\n            ('/logout', 405),\n        ]\n    )\n    def test_cookie_with_https_http_error(self, url, expected_error_code):\n        # Given an https request made to rdiffweb\n        self.getPage(url, headers=[('X-Forwarded-Proto', 'https')])\n        # When receiving the response\n        self.assertStatus(expected_error_code)\n        # Then the header contains Set-Cookie with Secure\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('Secure', cookie)\n\n    def test_cookie_with_http(self):\n        # Given an https request made to rdiffweb\n        self.getPage('/')\n        # When receiving the response\n        # Then the header contains Set-Cookie with Secure\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertNotIn('Secure', cookie)\n\n    def test_get_with_wrong_origin(self):\n        # Given a GET request made to rdiffweb\n        # When the request is made using a different origin\n        self.getPage('/', headers=[('Origin', 'http://www.examples.com')])\n        # Then the response status it 200 OK.\n        self.assertStatus(200)\n\n    def test_post_with_wrong_origin(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made using a different origin\n        self.getPage('/', headers=[('Origin', 'http://www.examples.com')], method='POST')\n        # Then the request is refused with 403 Forbiden\n        self.assertStatus(403)\n        self.assertInBody('Unexpected Origin header')\n\n    def test_post_with_prefixed_origin(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made using a different origin\n        base = 'http://%s:%s' % (self.HOST + 'anything.com', self.PORT)\n        self.getPage('/dashboard/', headers=[('Origin', base)], method='POST')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(403)\n        self.assertInBody('Unexpected Origin header')\n\n    def test_post_with_valid_origin(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made using a different origin\n        base = 'http://%s:%s' % (self.HOST, self.PORT)\n        self.getPage('/', headers=[('Origin', base)], method='POST')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n\n    def test_post_without_origin(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/', method='POST')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n\n    def test_clickjacking_defense(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('X-Frame-Options', 'DENY')\n\n    def test_no_cache(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('Cache-control', 'no-cache')\n        self.assertHeaderItemValue('Cache-control', 'no-store')\n        self.assertHeaderItemValue('Cache-control', 'must-revalidate')\n        self.assertHeaderItemValue('Cache-control', 'max-age=0')\n        self.assertHeaderItemValue('Pragma', 'no-cache')\n        self.assertHeaderItemValue('Expires', '0')\n\n    def test_no_cache_with_static(self):\n        self.getPage('/static/js/rdiffweb.js')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertNoHeader('Cache-control')\n        self.assertNoHeader('Pragma')\n        self.assertNoHeader('Expires')\n\n    def test_referrer_policy(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('Referrer-Policy', 'same-origin')\n\n    def test_nosniff(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('X-Content-Type-Options', 'nosniff')\n\n    def test_xss_protection(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('X-XSS-Protection', '1; mode=block')\n\n    def test_content_security_policy(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/')\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue(\n            'Content-Security-Policy',\n            \"default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'\",\n        )\n\n    def test_strict_transport_security(self):\n        # Given a POST request made to rdiffweb\n        # When the request is made without an origin\n        self.getPage('/', headers=[('X-Forwarded-Proto', 'https')])\n        # Then the request is accepted with 200 OK\n        self.assertStatus(200)\n        self.assertHeaderItemValue('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')\n", "<!DOCTYPE html>\n<html lang=\"{{ lang[0:2] }}\">\n  <head>\n    {% block head %}\n      <title>\n        {% block title %}\n          {% if title %}{{ title }}{% endif %}\n        {% endblock title %}\n        - {{ header_name }}\n      </title>\n      <meta charset=\"utf-8\" />\n      <meta content=\"noindex\" name=\"robots\" />\n      <meta content=\"IE=edge\" http-equiv=\"X-UA-Compatible\" />\n      <meta content=\"width=device-width, initial-scale=1\" name=\"viewport\" />\n      <link href=\"{{ url_for('favicon.ico', v=cache_invalid) }}\"\n            rel=\"shortcut icon\"/>\n      <!-- Jquery -->\n      <script src=\"{{ url_for('/static/js/jquery.min.js') }}\"></script>\n      <!-- Bootstrap v4 -->\n      <script src=\"{{ url_for('/static/js/bootstrap.bundle.min.js') }}\"></script>\n      <link href=\"{{ url_for('/static/css/bootstrap.min.css') }}\"\n            rel=\"stylesheet\"\n            type=\"text/css\"/>\n      <!-- Fontawesome -->\n      <link href=\"{{ url_for('/static/css/font-awesome.min.css') }}\"\n            rel=\"stylesheet\"\n            type=\"text/css\"/>\n      <!-- JQuery Datatables -->\n      <script src=\"{{ url_for('/static/js/jquery.dataTables.min.js') }}\"></script>\n      <script src=\"{{ url_for('/static/js/dataTables.buttons.min.js') }}\"></script>\n      <script src=\"{{ url_for('/static/js/dataTables.responsive.min.js') }}\"></script>\n      <link href=\"{{ url_for('/static/css/jquery.dataTables.min.css') }}\"\n            rel=\"stylesheet\"\n            type=\"text/css\"/>\n      <link href=\"{{ url_for('/static/css/responsive.dataTables.min.css') }}\"\n            rel=\"stylesheet\"\n            type=\"text/css\"/>\n      <!-- Custom -->\n      <script src=\"{{ url_for('/static/js/rdiffweb.js') }}\"></script>\n      <link href=\"{{ url_for('/default.css') }}\" rel=\"stylesheet\" type=\"text/css\"/>\n    {% endblock head %}\n  </head>\n  <body class=\"d-flex flex-column\">\n    <!-- .navbar -->\n    {% if username %}\n      <nav class=\"navbar navbar-expand-lg navbar-dark bg-dark fixed-top\">\n        <div class=\"container\">\n          <a class=\"navbar-brand\" href=\"{{ url_for('/') }}\">\n            <img alt=\"{{ header_name }}\"\n                 class=\"mr-1\"\n                 height=\"36\"\n                 src=\"{{ url_for('/header_logo',v=cache_invalid) }}\"/>\n          </a>\n          <button aria-controls=\"navbarSupportedContent\"\n                  aria-expanded=\"false\"\n                  aria-label=\"{% trans %}Toggle navigation{% endtrans %}\"\n                  class=\"navbar-toggler\"\n                  data-target=\"#navbarSupportedContent\"\n                  data-toggle=\"collapse\"\n                  type=\"button\">\n            <span class=\"navbar-toggler-icon\"></span>\n          </button>\n          <div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\n            <ul class=\"navbar-nav mr-auto\">\n              <li class=\"nav-item{% if active_page=='repo' %} active{% endif %}\">\n                <a class=\"nav-link\" href=\"{{ url_for('/') }}\">{% trans %}Repositories{% endtrans %}</a>\n              </li>\n              <li class=\"nav-item{% if active_page=='status' %} active{% endif %}\">\n                <a class=\"nav-link\" href=\"{{ url_for('status') }}\">{% trans %}Status{% endtrans %}</a>\n              </li>\n              {% if is_admin %}\n                <li class=\"nav-item{% if active_page=='admin' %} active{% endif %}\">\n                  <a class=\"nav-link\" href=\"{{ url_for('admin') }}\">{% trans %}Admin area{% endtrans %}</a>\n                </li>\n              {% endif %}\n            </ul>\n            <ul class=\"navbar-nav\">\n              <li class=\"nav-item dropdown\">\n                <a aria-expanded=\"false\"\n                   class=\"nav-link dropdown-toggle\"\n                   data-toggle=\"dropdown\"\n                   href=\"#\"\n                   id=\"navbarDropdown\"\n                   role=\"button\">\n                  <i aria-hidden=\"true\" class=\"fa fa-user\"></i>\n                  {{ username }}\n                </a>\n                <form action=\"{{ url_for('logout') }}\" method=\"post\">\n                  <div aria-labelledby=\"navbarDropdown\" class=\"dropdown-menu\">\n                    <h6 class=\"dropdown-header\">{% trans %}Signed in as{% endtrans %} {{ username }}</h6>\n                    <a class=\"dropdown-item\" href=\"{{ url_for('prefs', 'general') }}\">{% trans %}Edit profile{% endtrans %}</a>\n                    <a class=\"dropdown-item\" href=\"{{ url_for('prefs', 'notification') }}\">{% trans %}Notifications{% endtrans %}</a>\n                    <div class=\"dropdown-divider\"></div>\n                    {# Logout button #}\n                    <button type=\"submit\" class=\"dropdown-item\">{% trans %}Logout{% endtrans %}</button>\n                  </div>\n                </form>\n              </li>\n            </ul>\n          </div>\n        </div>\n      </nav>\n    {% endif %}\n    {% block body %}\n    {% endblock body %}\n    <footer class=\"small text-center mt-auto\">\n      {% trans %}Powered by{% endtrans %} <a href=\"{{ footerurl }}\">{{ footername }}</a>\n    </footer>\n  </body>\n</html>\n", "{% extends 'login.html' %}\n{% block content %}\n  <div class=\"container mb-auto\">\n    <div class=\"row\">\n      <div class=\"offset-sm-3 col-sm-6\">\n        <form id=\"form-login\" role=\"form\" method=\"post\" action=\"{{ url_for() }}\">\n          <h2>{% trans %}Login Verification{% endtrans %}</h2>\n          {% include 'message.html' %}\n          <p>\n            {% trans %}Two-Factor Authentication is enabled for your account. To verify your account, you must enter the code that was sent to your email address.{% endtrans %}\n          </p>\n          {{ form }}\n        </form>\n        {# Logout button #}\n        <form action=\"{{ url_for('logout') }}\" method=\"post\">\n          <button type=\"submit\" class=\"btn btn-link btn-sm btn-block text-center\">\n            {% trans %}Login with a different account{% endtrans %}\n          </button>\n        </form>\n      </div>\n    </div>\n  </div>\n{% endblock %}\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Oct 14, 2015\n\nMock class for testing.\n\n@author: Patrik Dufresne <patrik@ikus-soft.com>\n\"\"\"\nimport json\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport time\nimport unittest\nimport unittest.mock\nfrom threading import Thread\nfrom urllib.parse import urlencode\n\nimport cherrypy\nimport pkg_resources\nfrom cherrypy.test import helper\n\nfrom rdiffweb.core.model import UserObject\nfrom rdiffweb.rdw_app import RdiffwebApp\n\n# For cherrypy8, we need to monkey patch Thread.isAlive\nThread.isAlive = Thread.is_alive\n\n\ndef create_testcases_repo(app):\n    \"\"\"Extract testcases.\"\"\"\n    # Extract 'testcases.tar.gz'\n    testcases = pkg_resources.resource_filename('rdiffweb.tests', 'testcases.tar.gz')  # @UndefinedVariable\n    new = str(tempfile.mkdtemp(prefix='rdiffweb_tests_'))\n    subprocess.check_call(['tar', '-zxf', testcases], cwd=new)\n    return new\n\n\nclass WebCase(helper.CPWebCase):\n    \"\"\"\n    Helper class for the rdiffweb test suite.\n    \"\"\"\n\n    REPO = 'testcases'\n\n    USERNAME = 'admin'\n\n    PASSWORD = 'admin123'\n\n    interactive = False\n\n    login = False\n\n    default_config = {}\n\n    app_class = RdiffwebApp\n\n    @classmethod\n    def setup_class(cls):\n        if cls is WebCase:\n            raise unittest.SkipTest(\"%s is an abstract base class\" % cls.__name__)\n        super().setup_class()\n        cls.do_gc_test = False\n\n    @classmethod\n    def teardown_class(cls):\n        super().teardown_class()\n        cherrypy.tools.db.drop_all()\n        if hasattr(cherrypy, '_cache'):\n            cherrypy._cache.clear()\n\n    @classmethod\n    def setup_server(cls):\n        # Allow defining a custom database uri for testing.\n        uri = os.environ.get(\n            'RDIFFWEB_TEST_DATABASE_URI', 'sqlite:///' + tempfile.gettempdir() + '/test_rdiffweb_data.db'\n        )\n        cls.default_config['database-uri'] = uri\n        # Disable rate-limit for testing.\n        if 'rate-limit' not in cls.default_config:\n            cls.default_config['rate-limit'] = -1\n        cfg = cls.app_class.parse_args(\n            args=[], config_file_contents='\\n'.join('%s=%s' % (k, v) for k, v in cls.default_config.items())\n        )\n        # Create Application\n        app = cls.app_class(cfg)\n        cherrypy.tree.mount(app)\n\n    def setUp(self):\n        helper.CPWebCase.setUp(self)\n        if hasattr(cherrypy, '_cache'):\n            cherrypy._cache.clear()\n        cherrypy.tools.db.drop_all()\n        cherrypy.tools.db.create_all()\n        # Create default admin\n        admin_user = UserObject.create_admin_user(self.USERNAME, self.PASSWORD)\n        admin_user.commit()\n        # Create testcases repo\n        self.testcases = create_testcases_repo(self.app)\n        if admin_user:\n            admin_user.user_root = self.testcases\n            admin_user.refresh_repos()\n            admin_user.commit()\n        # Login to web application.\n        if self.login:\n            self._login()\n\n    def tearDown(self):\n        if hasattr(self, 'testcases'):\n            shutil.rmtree(self.testcases)\n            delattr(self, 'testcases')\n        cherrypy.tools.db.drop_all()\n        if hasattr(cherrypy, '_cache'):\n            cherrypy._cache.clear()\n\n    @property\n    def app(self):\n        \"\"\"\n        Return reference to Rdiffweb application.\n        \"\"\"\n        return cherrypy.tree.apps['']\n\n    @property\n    def session(self):\n        return cherrypy.tools.db.get_session()\n\n    @property\n    def session_id(self):\n        if hasattr(self, 'cookies') and self.cookies:\n            for unused, value in self.cookies:\n                for part in value.split(';'):\n                    key, unused, value = part.partition('=')\n                    if key == 'session_id':\n                        return value\n\n    @property\n    def baseurl(self):\n        return 'http://%s:%s' % (self.HOST, self.PORT)\n\n    def getPage(self, url, headers=None, method=\"GET\", body=None, protocol=None):\n        if headers is None:\n            headers = []\n        # When body is a dict, send the data as form data.\n        if isinstance(body, dict) and method in ['POST', 'PUT']:\n            data = [(k.encode(encoding='latin1'), v.encode(encoding='utf-8')) for k, v in body.items()]\n            body = urlencode(data)\n        # Send back cookies if any\n        if hasattr(self, 'cookies') and self.cookies:\n            headers.extend(self.cookies)\n        # CherryPy ~8.9.1 is not handling absolute URL properly and web browser\n        # are usually not sending absolute URL either. So trim the base.\n        base = 'http://%s:%s' % (self.HOST, self.PORT)\n        if url.startswith(base):\n            url = url[len(base) :]\n        helper.CPWebCase.getPage(self, url, headers, method, body, protocol)\n\n    def getJson(self, *args, **kwargs):\n        self.getPage(*args, **kwargs)\n        self.assertStatus(200)\n        return json.loads(self.body.decode('utf8'))\n\n    def _login(self, username=USERNAME, password=PASSWORD):\n        self.getPage(\"/logout\", method=\"POST\")\n        self.getPage(\"/login/\", method='POST', body={'login': username, 'password': password})\n        self.assertStatus('303 See Other')\n\n    def wait_for_tasks(self):\n        time.sleep(1)\n        while len(cherrypy.scheduler.list_tasks()) or cherrypy.scheduler.is_job_running():\n            time.sleep(1)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport datetime\nimport time\nimport urllib.parse\n\nimport cherrypy\nfrom cherrypy.lib import httputil\n\nSESSION_KEY = '_cp_username'\nLOGIN_TIME = 'login_time'\nLOGIN_REDIRECT_URL = '_auth_form_redirect_url'\nLOGIN_PERSISTENT = 'login_persistent'\n\n\nclass CheckAuthForm(cherrypy.Tool):\n    def __init__(self, priority=73):\n        super().__init__(point='before_handler', callable=self.run, priority=priority)\n\n    def _is_login(self):\n        \"\"\"\n        Verify if the login expired and we need to prompt the user to authenticated again using either credentials and/or MFA.\n        \"\"\"\n        # Verify if current user exists\n        request = cherrypy.serving.request\n        if not getattr(request, 'currentuser', None):\n            return False\n\n        # Verify if session is enabled\n        sessions_on = request.config.get('tools.sessions.on', False)\n        if not sessions_on:\n            return False\n\n        # Verify session\n        # We don't need to verify the timeout value since expired session get deleted automatically.\n        session = cherrypy.session\n        return session.get(SESSION_KEY) is not None and session.get(LOGIN_TIME) is not None\n\n    def _get_redirect_url(self):\n        \"\"\"\n        Return the original URL the user browser before getting redirect to login.\n        \"\"\"\n        return cherrypy.session.get(LOGIN_REDIRECT_URL) or '/'\n\n    def _set_redirect_url(self):\n        # Keep reference to the current URL\n        request = cherrypy.serving.request\n        uri_encoding = getattr(request, 'uri_encoding', 'utf-8')\n        original_url = urllib.parse.quote(request.path_info, encoding=uri_encoding)\n        qs = request.query_string\n        new_url = cherrypy.url(original_url, qs=qs, base='')\n        cherrypy.session[LOGIN_REDIRECT_URL] = new_url\n\n    def _update_session_timeout(self, persistent_timeout=43200, absolute_timeout=30):\n        \"\"\"\n        Since we have multiple timeout value (idle, absolute and persistent) We need to update the session timeout and possibly the cookie timeout.\n        \"\"\"\n        persistent_timeout = cherrypy.request.config.get('tools.auth_form.persistent_timeout', 43200)\n        absolute_timeout = cherrypy.request.config.get('tools.auth_form.absolute_timeout', 30)\n        # If login is persistent, update the cookie max-age/expires\n        session = cherrypy.session\n        if session.get(LOGIN_PERSISTENT, False):\n            expiration = session[LOGIN_TIME] + datetime.timedelta(minutes=persistent_timeout)\n            session.timeout = int((expiration - session.now()).total_seconds() / 60)\n            cookie = cherrypy.serving.response.cookie\n            cookie['session_id']['max-age'] = session.timeout * 60\n            cookie['session_id']['expires'] = httputil.HTTPDate(time.time() + session.timeout * 60)\n        else:\n            session_idle_timeout = cherrypy.request.config.get('tools.sessions.timeout', 60)\n            expiration1 = session.now() + datetime.timedelta(minutes=session_idle_timeout)\n            expiration2 = session[LOGIN_TIME] + datetime.timedelta(minutes=absolute_timeout)\n            expiration = min(expiration1, expiration2)\n            session.timeout = int((expiration - session.now()).total_seconds() / 60)\n\n    def redirect_to_original_url(self):\n        # Redirect user to original URL\n        raise cherrypy.HTTPRedirect(self._get_redirect_url())\n\n    def run(self, login_url='/login/', logout_url='/logout', persistent_timeout=43200, absolute_timeout=30):\n        \"\"\"\n        A tool that verify if the session is associated to a user by tracking\n        a session key. If session is not authenticated, redirect user to login page.\n        \"\"\"\n        request = cherrypy.serving.request\n        # Skip execution of this tools when browsing the login page.\n        if request.path_info == login_url:\n            if self._is_login():\n                raise cherrypy.HTTPRedirect('/')\n            return\n\n        # Clear session when browsing /logout\n        if request.path_info == logout_url or request.path_info.startswith(logout_url):\n            if request.method != 'POST':\n                raise cherrypy.HTTPError(405)\n            self.logout()\n            raise cherrypy.HTTPRedirect('/')\n\n        # Check if login\n        if not self._is_login():\n            # Store original URL\n            self._set_redirect_url()\n            # And redirect to login page\n            raise cherrypy.HTTPRedirect(login_url)\n\n        self._update_session_timeout()\n\n    def login(self, username, persistent=False):\n        \"\"\"\n        Must be called by the page hanlder when the authentication is successful.\n        \"\"\"\n        # Store session data\n        cherrypy.session[LOGIN_PERSISTENT] = persistent\n        cherrypy.session[SESSION_KEY] = username\n        cherrypy.session[LOGIN_TIME] = cherrypy.session.now()\n        # Generate a new session id\n        cherrypy.session.regenerate()\n        # Update the session timeout\n        self._update_session_timeout()\n\n    def logout(self):\n        # Clear session date and generate a new session id\n        cherrypy.session.clear()\n        cherrypy.session.regenerate()\n\n\ncherrypy.tools.auth_form = CheckAuthForm()\n"], "filenames": ["README.md", "rdiffweb/controller/tests/test_controller.py", "rdiffweb/controller/tests/test_page_admin_users.py", "rdiffweb/controller/tests/test_page_login.py", "rdiffweb/controller/tests/test_page_mfa.py", "rdiffweb/controller/tests/test_secure_headers.py", "rdiffweb/templates/layout.html", "rdiffweb/templates/mfa.html", "rdiffweb/test.py", "rdiffweb/tools/auth_form.py"], "buggy_code_start_loc": [114, 80, 328, 186, 55, 61, 88, 14, 179, 106], "buggy_code_end_loc": [115, 81, 329, 336, 56, 62, 95, 18, 180, 106], "fixing_code_start_loc": [114, 80, 328, 186, 55, 61, 88, 14, 179, 107], "fixing_code_end_loc": [116, 81, 329, 336, 56, 62, 98, 20, 180, 109], "type": "CWE-352", "message": "Cross-Site Request Forgery (CSRF) in GitHub repository ikus060/rdiffweb prior to 2.5.4.", "other": {"cve": {"id": "CVE-2022-4646", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-22T02:15:08.243", "lastModified": "2022-12-29T15:03:41.677", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-Site Request Forgery (CSRF) in GitHub repository ikus060/rdiffweb prior to 2.5.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ikus-soft:rdiffweb:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.4", "matchCriteriaId": "7CD8A3B5-37E3-407C-BBF1-91E1FCCCE1C0"}]}]}], "references": [{"url": "https://github.com/ikus060/rdiffweb/commit/e6f0d8002129be90fe82fa3e3ea0a6942caba398", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/17bc1b0f-1f5c-432f-88e4-c9866ccf6e10", "source": "security@huntr.dev", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ikus060/rdiffweb/commit/e6f0d8002129be90fe82fa3e3ea0a6942caba398"}}