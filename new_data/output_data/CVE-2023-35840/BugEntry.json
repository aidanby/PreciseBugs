{"buggy_code": ["<?php\n\n// Implement similar functionality in PHP 5.2 or 5.3\n// http://php.net/manual/class.recursivecallbackfilteriterator.php#110974\nif (!class_exists('RecursiveCallbackFilterIterator', false)) {\n    class RecursiveCallbackFilterIterator extends RecursiveFilterIterator\n    {\n        private $callback;\n\n        public function __construct(RecursiveIterator $iterator, $callback)\n        {\n            $this->callback = $callback;\n            parent::__construct($iterator);\n        }\n\n        public function accept()\n        {\n            return call_user_func($this->callback, parent::current(), parent::key(), parent::getInnerIterator());\n        }\n\n        public function getChildren()\n        {\n            return new self($this->getInnerIterator()->getChildren(), $this->callback);\n        }\n    }\n}\n\n/**\n * elFinder driver for local filesystem.\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n **/\nclass elFinderVolumeLocalFileSystem extends elFinderVolumeDriver\n{\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'l';\n\n    /**\n     * Required to count total archive files size\n     *\n     * @var int\n     **/\n    protected $archiveSize = 0;\n\n    /**\n     * Is checking stat owner\n     *\n     * @var        boolean\n     */\n    protected $statOwner = false;\n\n    /**\n     * Path to quarantine directory\n     *\n     * @var string\n     */\n    private $quarantine;\n\n    /**\n     * Constructor\n     * Extend options with required fields\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct()\n    {\n        $this->options['alias'] = '';              // alias to replace root dir name\n        $this->options['dirMode'] = 0755;            // new dirs mode\n        $this->options['fileMode'] = 0644;            // new files mode\n        $this->options['rootCssClass'] = 'elfinder-navbar-root-local';\n        $this->options['followSymLinks'] = true;\n        $this->options['detectDirIcon'] = '';         // file name that is detected as a folder icon e.g. '.diricon.png'\n        $this->options['keepTimestamp'] = array('copy', 'move'); // keep timestamp at inner filesystem allowed 'copy', 'move' and 'upload'\n        $this->options['substituteImg'] = true;       // support substitute image with dim command\n        $this->options['statCorrector'] = null;       // callable to correct stat data `function(&$stat, $path, $statOwner, $volumeDriveInstance){}`\n        if (DIRECTORY_SEPARATOR === '/') {\n            // Linux\n            $this->options['acceptedName'] = '/^[^\\.\\/\\x00][^\\/\\x00]*$/';\n        } else {\n            // Windows\n            $this->options['acceptedName'] = '/^[^\\.\\/\\x00\\\\\\:*?\"<>|][^\\/\\x00\\\\\\:*?\"<>|]*$/';\n        }\n    }\n\n    /*********************************************************************/\n    /*                        INIT AND CONFIGURE                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     **/\n    protected function init()\n    {\n        // Normalize directory separator for windows\n        if (DIRECTORY_SEPARATOR !== '/') {\n            foreach (array('path', 'tmbPath', 'tmpPath', 'quarantine') as $key) {\n                if (!empty($this->options[$key])) {\n                    $this->options[$key] = str_replace('/', DIRECTORY_SEPARATOR, $this->options[$key]);\n                }\n            }\n            // PHP >= 7.1 Supports UTF-8 path on Windows\n            if (version_compare(PHP_VERSION, '7.1', '>=')) {\n                $this->options['encoding'] = '';\n                $this->options['locale'] = '';\n            }\n        }\n        if (!$cwd = getcwd()) {\n            return $this->setError('elFinder LocalVolumeDriver requires a result of getcwd().');\n        }\n        // detect systemRoot\n        if (!isset($this->options['systemRoot'])) {\n            if ($cwd[0] === DIRECTORY_SEPARATOR || $this->root[0] === DIRECTORY_SEPARATOR) {\n                $this->systemRoot = DIRECTORY_SEPARATOR;\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $this->root, $m)) {\n                $this->systemRoot = $m[1];\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $cwd, $m)) {\n                $this->systemRoot = $m[1];\n            }\n        }\n        $this->root = $this->getFullPath($this->root, $cwd);\n        if (!empty($this->options['startPath'])) {\n            $this->options['startPath'] = $this->getFullPath($this->options['startPath'], $this->root);\n        }\n\n        if (is_null($this->options['syncChkAsTs'])) {\n            $this->options['syncChkAsTs'] = true;\n        }\n        if (is_null($this->options['syncCheckFunc'])) {\n            $this->options['syncCheckFunc'] = array($this, 'localFileSystemInotify');\n        }\n        // check 'statCorrector'\n        if (empty($this->options['statCorrector']) || !is_callable($this->options['statCorrector'])) {\n            $this->options['statCorrector'] = null;\n        }\n\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        $hiddens = array();\n        $root = $this->stat($this->root);\n\n        // check thumbnails path\n        if (!empty($this->options['tmbPath'])) {\n            if (strpos($this->options['tmbPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['tmb'] = $this->options['tmbPath'];\n                $this->options['tmbPath'] = $this->_abspath($this->options['tmbPath']);\n            } else {\n                $this->options['tmbPath'] = $this->_normpath($this->options['tmbPath']);\n            }\n        }\n        // check temp path\n        if (!empty($this->options['tmpPath'])) {\n            if (strpos($this->options['tmpPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['temp'] = $this->options['tmpPath'];\n                $this->options['tmpPath'] = $this->_abspath($this->options['tmpPath']);\n            } else {\n                $this->options['tmpPath'] = $this->_normpath($this->options['tmpPath']);\n            }\n        }\n        // check quarantine path\n        $_quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if (strpos($this->options['quarantine'], DIRECTORY_SEPARATOR) === false) {\n                //$hiddens['quarantine'] = $this->options['quarantine'];\n                //$this->options['quarantine'] = $this->_abspath($this->options['quarantine']);\n                $_quarantine = $this->_abspath($this->options['quarantine']);\n                $this->options['quarantine'] = '';\n            } else {\n                $this->options['quarantine'] = $this->_normpath($this->options['quarantine']);\n            }\n        } else {\n            $_quarantine = $this->_abspath('.quarantine');\n        }\n        is_dir($_quarantine) && self::localRmdirRecursive($_quarantine);\n\n        parent::configure();\n\n        // check tmbPath\n        if (!$this->tmbPath && isset($hiddens['tmb'])) {\n            unset($hiddens['tmb']);\n        }\n\n        // if no thumbnails url - try detect it\n        if ($root['read'] && !$this->tmbURL && $this->URL) {\n            if (strpos($this->tmbPath, $this->root) === 0) {\n                $this->tmbURL = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($this->tmbPath, strlen($this->root) + 1));\n                if (preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n                    $this->tmbURL .= '/';\n                }\n            }\n        }\n\n        // set $this->tmp by options['tmpPath']\n        $this->tmp = '';\n        if (!empty($this->options['tmpPath'])) {\n            if ((is_dir($this->options['tmpPath']) || mkdir($this->options['tmpPath'], $this->options['dirMode'], true)) && is_writable($this->options['tmpPath'])) {\n                $this->tmp = $this->options['tmpPath'];\n            } else {\n                if (isset($hiddens['temp'])) {\n                    unset($hiddens['temp']);\n                }\n            }\n        }\n        if (!$this->tmp && ($tmp = elFinder::getStaticVar('commonTempPath'))) {\n            $this->tmp = $tmp;\n        }\n\n        // check quarantine dir\n        $this->quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if ((is_dir($this->options['quarantine']) || mkdir($this->options['quarantine'], $this->options['dirMode'], true)) && is_writable($this->options['quarantine'])) {\n                $this->quarantine = $this->options['quarantine'];\n            } else {\n                if (isset($hiddens['quarantine'])) {\n                    unset($hiddens['quarantine']);\n                }\n            }\n        } else if ($_path = elFinder::getCommonTempPath()) {\n            $this->quarantine = $_path;\n        }\n\n        if (!$this->quarantine) {\n            if (!$this->tmp) {\n                $this->archivers['extract'] = array();\n                $this->disabled[] = 'extract';\n            } else {\n                $this->quarantine = $this->tmp;\n            }\n        }\n\n        if ($hiddens) {\n            foreach ($hiddens as $hidden) {\n                $this->attributes[] = array(\n                    'pattern' => '~^' . preg_quote(DIRECTORY_SEPARATOR . $hidden, '~') . '$~',\n                    'read' => false,\n                    'write' => false,\n                    'locked' => true,\n                    'hidden' => true\n                );\n            }\n        }\n\n        if (!empty($this->options['keepTimestamp'])) {\n            $this->options['keepTimestamp'] = array_flip($this->options['keepTimestamp']);\n        }\n\n        $this->statOwner = (!empty($this->options['statOwner']));\n\n        // enable WinRemoveTailDots plugin on Windows server\n        if (DIRECTORY_SEPARATOR !== '/') {\n            if (!isset($this->options['plugin'])) {\n                $this->options['plugin'] = array();\n            }\n            $this->options['plugin']['WinRemoveTailDots'] = array('enable' => true);\n        }\n    }\n\n    /**\n     * Long pooling sync checker\n     * This function require server command `inotifywait`\n     * If `inotifywait` need full path, Please add `define('ELFINER_INOTIFYWAIT_PATH', '/PATH_TO/inotifywait');` into connector.php\n     *\n     * @param string $path\n     * @param int    $standby\n     * @param number $compare\n     *\n     * @return number|bool\n     * @throws elFinderAbortException\n     */\n    public function localFileSystemInotify($path, $standby, $compare)\n    {\n        if (isset($this->sessionCache['localFileSystemInotify_disable'])) {\n            return false;\n        }\n        $path = realpath($path);\n        $mtime = filemtime($path);\n        if (!$mtime) {\n            return false;\n        }\n        if ($mtime != $compare) {\n            return $mtime;\n        }\n        $inotifywait = defined('ELFINER_INOTIFYWAIT_PATH') ? ELFINER_INOTIFYWAIT_PATH : 'inotifywait';\n        $standby = max(1, intval($standby));\n        $cmd = $inotifywait . ' ' . escapeshellarg($path) . ' -t ' . $standby . ' -e moved_to,moved_from,move,close_write,delete,delete_self';\n        $this->procExec($cmd, $o, $r);\n        if ($r === 0) {\n            // changed\n            clearstatcache();\n            if (file_exists($path)) {\n                $mtime = filemtime($path); // error on busy?\n                return $mtime ? $mtime : time();\n            } else {\n                // target was removed\n                return 0;\n            }\n        } else if ($r === 2) {\n            // not changed (timeout)\n            return $compare;\n        }\n        // error\n        // cache to $_SESSION\n        $this->sessionCache['localFileSystemInotify_disable'] = true;\n        $this->session->set($this->id, $this->sessionCache);\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dirname($path)\n    {\n        return dirname($path);\n    }\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _basename($path)\n    {\n        return basename($path);\n    }\n\n    /**\n     * Join dir name and file name and retur full path\n     *\n     * @param  string $dir\n     * @param  string $name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _joinPath($dir, $name)\n    {\n        $dir = rtrim($dir, DIRECTORY_SEPARATOR);\n        $path = realpath($dir . DIRECTORY_SEPARATOR . $name);\n        // realpath() returns FALSE if the file does not exist\n        if ($path === false || strpos($path, $this->root) !== 0) {\n            if (DIRECTORY_SEPARATOR !== '/') {\n                $name = str_replace('/', DIRECTORY_SEPARATOR, $name);\n            }\n            // Directory traversal measures\n            if (strpos($name, '..' . DIRECTORY_SEPARATOR) !== false) {\n                $name = basename($name);\n            }\n            $path = $dir . DIRECTORY_SEPARATOR . $name;\n        }\n        return $path; \n    }\n\n    /**\n     * Return normalized path, this works the same as os.path.normpath() in Python\n     *\n     * @param  string $path path\n     *\n     * @return string\n     * @author Troex Nevelin\n     **/\n    protected function _normpath($path)\n    {\n        if (empty($path)) {\n            return '.';\n        }\n\n        $changeSep = (DIRECTORY_SEPARATOR !== '/');\n        if ($changeSep) {\n            $drive = '';\n            if (preg_match('/^([a-zA-Z]:)(.*)/', $path, $m)) {\n                $drive = $m[1];\n                $path = $m[2] ? $m[2] : '/';\n            }\n            $path = str_replace(DIRECTORY_SEPARATOR, '/', $path);\n        }\n\n        if (strpos($path, '/') === 0) {\n            $initial_slashes = true;\n        } else {\n            $initial_slashes = false;\n        }\n\n        if (($initial_slashes)\n            && (strpos($path, '//') === 0)\n            && (strpos($path, '///') === false)) {\n            $initial_slashes = 2;\n        }\n\n        $initial_slashes = (int)$initial_slashes;\n\n        $comps = explode('/', $path);\n        $new_comps = array();\n        foreach ($comps as $comp) {\n            if (in_array($comp, array('', '.'))) {\n                continue;\n            }\n\n            if (($comp != '..')\n                || (!$initial_slashes && !$new_comps)\n                || ($new_comps && (end($new_comps) == '..'))) {\n                array_push($new_comps, $comp);\n            } elseif ($new_comps) {\n                array_pop($new_comps);\n            }\n        }\n        $comps = $new_comps;\n        $path = implode('/', $comps);\n        if ($initial_slashes) {\n            $path = str_repeat('/', $initial_slashes) . $path;\n        }\n\n        if ($changeSep) {\n            $path = $drive . str_replace('/', DIRECTORY_SEPARATOR, $path);\n        }\n\n        return $path ? $path : '.';\n    }\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _relpath($path)\n    {\n        if ($path === $this->root) {\n            return '';\n        } else {\n            if (strpos($path, $this->root) === 0) {\n                return ltrim(substr($path, strlen($this->root)), DIRECTORY_SEPARATOR);\n            } else {\n                // for link\n                return $path;\n            }\n        }\n    }\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _abspath($path)\n    {\n        if ($path === DIRECTORY_SEPARATOR) {\n            return $this->root;\n        } else {\n            $path = $this->_normpath($path);\n            if (strpos($path, $this->systemRoot) === 0) {\n                return $path;\n            } else if (DIRECTORY_SEPARATOR !== '/' && preg_match('/^[a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . '/', $path)) {\n                return $path;\n            } else {\n                return $this->_joinPath($this->root, $path);\n            }\n        }\n    }\n\n    /**\n     * Return fake path started from root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _path($path)\n    {\n        return $this->rootName . ($path == $this->root ? '' : $this->separator . $this->_relpath($path));\n    }\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _inpath($path, $parent)\n    {\n        $cwd = getcwd();\n        $real_path = $this->getFullPath($path, $cwd);\n        $real_parent = $this->getFullPath($parent, $cwd);\n        if ($real_path && $real_parent) {\n            return $real_path === $real_parent || strpos($real_path, rtrim($real_parent, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR) === 0;\n        }\n        return false;\n    }\n\n\n\n    /***************** file stat ********************/\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _stat($path)\n    {\n        $stat = array();\n\n        if (!file_exists($path) && !is_link($path)) {\n            return $stat;\n        }\n\n        //Verifies the given path is the root or is inside the root. Prevents directory traveral.\n        if (!$this->_inpath($path, $this->root)) {\n            return $stat;\n        }\n\n        $stat['isowner'] = false;\n        $linkreadable = false;\n        if ($path != $this->root && is_link($path)) {\n            if (!$this->options['followSymLinks']) {\n                return array();\n            }\n            if (!($target = $this->readlink($path))\n                || $target == $path) {\n                if (is_null($target)) {\n                    $stat = array();\n                    return $stat;\n                } else {\n                    $stat['mime'] = 'symlink-broken';\n                    $target = readlink($path);\n                    $lstat = lstat($path);\n                    $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                    $linkreadable = !empty($ostat['isowner']);\n                }\n            }\n            $stat['alias'] = $this->_path($target);\n            $stat['target'] = $target;\n        }\n\n        $readable = is_readable($path);\n\n        if ($readable) {\n            $size = sprintf('%u', filesize($path));\n            $stat['ts'] = filemtime($path);\n            if ($this->statOwner) {\n                $fstat = stat($path);\n                $uid = $fstat['uid'];\n                $gid = $fstat['gid'];\n                $stat['perm'] = substr((string)decoct($fstat['mode']), -4);\n                $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n            }\n        }\n\n        if (($dir = is_dir($path)) && $this->options['detectDirIcon']) {\n            $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n            if ($this->URL && file_exists($favicon)) {\n                $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n            }\n        }\n\n        if (!isset($stat['mime'])) {\n            $stat['mime'] = $dir ? 'directory' : $this->mimetype($path);\n        }\n        //logical rights first\n        $stat['read'] = ($linkreadable || $readable) ? null : false;\n        $stat['write'] = is_writable($path) ? null : false;\n\n        if (is_null($stat['read'])) {\n            if ($dir) {\n                $stat['size'] = 0;\n            } else if (isset($size)) {\n                $stat['size'] = $size;\n            }\n        }\n\n        if ($this->options['statCorrector']) {\n            call_user_func_array($this->options['statCorrector'], array(&$stat, $path, $this->statOwner, $this));\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat `owner`, `group` and `isowner` by `uid` and `gid`\n     * Sub-fuction of _stat() and _scandir()\n     *\n     * @param integer $uid\n     * @param integer $gid\n     *\n     * @return array  stat\n     */\n    protected function getOwnerStat($uid, $gid)\n    {\n        static $names = null;\n        static $phpuid = null;\n\n        if (is_null($names)) {\n            $names = array('uid' => array(), 'gid' => array());\n        }\n        if (is_null($phpuid)) {\n            if (is_callable('posix_getuid')) {\n                $phpuid = posix_getuid();\n            } else {\n                $phpuid = 0;\n            }\n        }\n\n        $stat = array();\n\n        if ($uid) {\n            $stat['isowner'] = ($phpuid == $uid);\n            if (isset($names['uid'][$uid])) {\n                $stat['owner'] = $names['uid'][$uid];\n            } else if (is_callable('posix_getpwuid')) {\n                $pwuid = posix_getpwuid($uid);\n                $stat['owner'] = $names['uid'][$uid] = $pwuid['name'];\n            } else {\n                $stat['owner'] = $names['uid'][$uid] = $uid;\n            }\n        }\n        if ($gid) {\n            if (isset($names['gid'][$gid])) {\n                $stat['group'] = $names['gid'][$gid];\n            } else if (is_callable('posix_getgrgid')) {\n                $grgid = posix_getgrgid($gid);\n                $stat['group'] = $names['gid'][$gid] = $grgid['name'];\n            } else {\n                $stat['group'] = $names['gid'][$gid] = $gid;\n            }\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _subdirs($path)\n    {\n\n        $dirs = false;\n        if (is_dir($path) && is_readable($path)) {\n            if (class_exists('FilesystemIterator', false)) {\n                $dirItr = new ParentIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::SKIP_DOTS |\n                        FilesystemIterator::CURRENT_AS_SELF |\n                        (defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    )\n                );\n                $dirItr->rewind();\n                if ($dirItr->hasChildren()) {\n                    $dirs = true;\n                    $name = $dirItr->getSubPathName();\n                    while ($dirItr->valid()) {\n                        if (!$this->attr($path . DIRECTORY_SEPARATOR . $name, 'read', null, true)) {\n                            $dirs = false;\n                            $dirItr->next();\n                            $name = $dirItr->getSubPathName();\n                            continue;\n                        }\n                        $dirs = true;\n                        break;\n                    }\n                }\n            } else {\n                $path = strtr($path, array('[' => '\\\\[', ']' => '\\\\]', '*' => '\\\\*', '?' => '\\\\?'));\n                return (bool)glob(rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR);\n            }\n        }\n        return $dirs;\n    }\n\n    /**\n     * Return object width and height\n     * Usualy used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dimensions($path, $mime)\n    {\n        clearstatcache();\n        return strpos($mime, 'image') === 0 && is_readable($path) && filesize($path) && ($s = getimagesize($path)) !== false\n            ? $s[0] . 'x' . $s[1]\n            : false;\n    }\n    /******************** file/dir content *********************/\n\n    /**\n     * Return symlink target file\n     *\n     * @param  string $path link path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function readlink($path)\n    {\n        if (!($target = readlink($path))) {\n            return null;\n        }\n\n        if (strpos($target, $this->systemRoot) !== 0) {\n            $target = $this->_joinPath(dirname($path), $target);\n        }\n\n        if (!file_exists($target)) {\n            return false;\n        }\n\n        return $target;\n    }\n\n    /**\n     * Return files list in directory.\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _scandir($path)\n    {\n        elFinder::checkAborted();\n        $files = array();\n        $cache = array();\n        $dirWritable = is_writable($path);\n        $dirItr = array();\n        $followSymLinks = $this->options['followSymLinks'];\n        try {\n            $dirItr = new DirectoryIterator($path);\n        } catch (UnexpectedValueException $e) {\n        }\n\n        foreach ($dirItr as $file) {\n            try {\n                if ($file->isDot()) {\n                    continue;\n                }\n\n                $files[] = $fpath = $file->getPathname();\n\n                $br = false;\n                $stat = array();\n\n                $stat['isowner'] = false;\n                $linkreadable = false;\n                if ($file->isLink()) {\n                    if (!$followSymLinks) {\n                        continue;\n                    }\n                    if (!($target = $this->readlink($fpath))\n                        || $target == $fpath) {\n                        if (is_null($target)) {\n                            $stat = array();\n                            $br = true;\n                        } else {\n                            $_path = $fpath;\n                            $stat['mime'] = 'symlink-broken';\n                            $target = readlink($_path);\n                            $lstat = lstat($_path);\n                            $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                            $linkreadable = !empty($ostat['isowner']);\n                            $dir = false;\n                            $stat['alias'] = $this->_path($target);\n                            $stat['target'] = $target;\n                        }\n                    } else {\n                        $dir = is_dir($target);\n                        $stat['alias'] = $this->_path($target);\n                        $stat['target'] = $target;\n                        $stat['mime'] = $dir ? 'directory' : $this->mimetype($stat['alias']);\n                    }\n                } else {\n                    if (($dir = $file->isDir()) && $this->options['detectDirIcon']) {\n                        $path = $file->getPathname();\n                        $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n                        if ($this->URL && file_exists($favicon)) {\n                            $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n                        }\n                    }\n                    $stat['mime'] = $dir ? 'directory' : $this->mimetype($fpath);\n                }\n                $size = sprintf('%u', $file->getSize());\n                $stat['ts'] = $file->getMTime();\n                if (!$br) {\n                    if ($this->statOwner && !$linkreadable) {\n                        $uid = $file->getOwner();\n                        $gid = $file->getGroup();\n                        $stat['perm'] = substr((string)decoct($file->getPerms()), -4);\n                        $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n                    }\n\n                    //logical rights first\n                    $stat['read'] = ($linkreadable || $file->isReadable()) ? null : false;\n                    $stat['write'] = $file->isWritable() ? null : false;\n                    $stat['locked'] = $dirWritable ? null : true;\n\n                    if (is_null($stat['read'])) {\n                        $stat['size'] = $dir ? 0 : $size;\n                    }\n\n                    if ($this->options['statCorrector']) {\n                        call_user_func_array($this->options['statCorrector'], array(&$stat, $fpath, $this->statOwner, $this));\n                    }\n                }\n\n                $cache[] = array($fpath, $stat);\n            } catch (RuntimeException $e) {\n                continue;\n            }\n        }\n\n        if ($cache) {\n            $cache = $this->convEncOut($cache, false);\n            foreach ($cache as $d) {\n                $this->updateCache($d[0], $d[1]);\n            }\n        }\n\n        return $files;\n    }\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _fopen($path, $mode = 'rb')\n    {\n        return fopen($path, $mode);\n    }\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp file pointer\n     * @param string    $path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _fclose($fp, $path = '')\n    {\n        return (is_resource($fp) && fclose($fp));\n    }\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkdir($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (mkdir($path)) {\n            chmod($path, $this->options['dirMode']);\n            return $path;\n        }\n\n        return false;\n    }\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkfile($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (($fp = fopen($path, 'w'))) {\n            fclose($fp);\n            chmod($path, $this->options['fileMode']);\n            return $path;\n        }\n        return false;\n    }\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _symlink($source, $targetDir, $name)\n    {\n        return symlink($source, $this->_joinPath($targetDir, $name));\n    }\n\n    /**\n     * Copy file into another file\n     *\n     * @param  string $source    source file path\n     * @param  string $targetDir target directory path\n     * @param  string $name      new file name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _copy($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = copy($source, $target)) {\n            isset($this->options['keepTimestamp']['copy']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _move($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = rename($source, $target) ? $target : false) {\n            isset($this->options['keepTimestamp']['move']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _unlink($path)\n    {\n        return is_file($path) && unlink($path);\n    }\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _rmdir($path)\n    {\n        return rmdir($path);\n    }\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _save($fp, $dir, $name, $stat)\n    {\n        $path = $this->_joinPath($dir, $name);\n\n        $meta = stream_get_meta_data($fp);\n        $uri = isset($meta['uri']) ? $meta['uri'] : '';\n        if ($uri && !preg_match('#^[a-zA-Z0-9]+://#', $uri) && !is_link($uri)) {\n            fclose($fp);\n            $mtime = filemtime($uri);\n            $isCmdPaste = ($this->ARGS['cmd'] === 'paste');\n            $isCmdCopy = ($isCmdPaste && empty($this->ARGS['cut']));\n            if (($isCmdCopy || !rename($uri, $path)) && !copy($uri, $path)) {\n                return false;\n            }\n            // keep timestamp on upload\n            if ($mtime && $this->ARGS['cmd'] === 'upload') {\n                touch($path, isset($this->options['keepTimestamp']['upload']) ? $mtime : time());\n            }\n        } else {\n            if (file_put_contents($path, $fp, LOCK_EX) === false) {\n                return false;\n            }\n        }\n\n        chmod($path, $this->options['fileMode']);\n        return $path;\n    }\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _getContents($path)\n    {\n        return file_get_contents($path);\n    }\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _filePutContents($path, $content)\n    {\n        return (file_put_contents($path, $content, LOCK_EX) !== false);\n    }\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    protected function _checkArchivers()\n    {\n        $this->archivers = $this->getArchivers();\n        return;\n    }\n\n    /**\n     * chmod availability\n     *\n     * @param string $path\n     * @param string $mode\n     *\n     * @return bool\n     */\n    protected function _chmod($path, $mode)\n    {\n        $modeOct = is_string($mode) ? octdec($mode) : octdec(sprintf(\"%04o\", $mode));\n        return chmod($path, $modeOct);\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _findSymlinks($path)\n    {\n        return self::localFindSymlinks($path);\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path archive path\n     * @param  array  $arc  archiver command and arguments (same as in $this->archivers)\n     *\n     * @return array|string|boolean\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _extract($path, $arc)\n    {\n\n        if ($this->quarantine) {\n\n            $dir = $this->quarantine . DIRECTORY_SEPARATOR . md5(basename($path) . mt_rand());\n            $archive = (isset($arc['toSpec']) || $arc['cmd'] === 'phpfunction') ? '' : $dir . DIRECTORY_SEPARATOR . basename($path);\n\n            if (!mkdir($dir)) {\n                return false;\n            }\n\n            // insurance unexpected shutdown\n            register_shutdown_function(array($this, 'rmdirRecursive'), realpath($dir));\n\n            chmod($dir, 0777);\n\n            // copy in quarantine\n            if (!is_readable($path) || ($archive && !copy($path, $archive))) {\n                return false;\n            }\n\n            // extract in quarantine\n            try {\n                $this->unpackArchive($path, $arc, $archive ? true : $dir);\n            } catch(Exception $e) {\n                return $this->setError($e->getMessage());\n            }\n\n            // get files list\n            try {\n                $ls = self::localScandir($dir);\n            } catch (Exception $e) {\n                return false;\n            }\n\n            // no files - extract error ?\n            if (empty($ls)) {\n                return false;\n            }\n\n            $this->archiveSize = 0;\n\n            // find symlinks and check extracted items\n            $checkRes = $this->checkExtractItems($dir);\n            if ($checkRes['symlinks']) {\n                self::localRmdirRecursive($dir);\n                return $this->setError(array_merge($this->error, array(elFinder::ERROR_ARC_SYMLINKS)));\n            }\n            $this->archiveSize = $checkRes['totalSize'];\n            if ($checkRes['rmNames']) {\n                foreach ($checkRes['rmNames'] as $name) {\n                    $this->addError(elFinder::ERROR_SAVE, $name);\n                }\n            }\n\n            // check max files size\n            if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $this->archiveSize) {\n                $this->delTree($dir);\n                return $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n            }\n\n            $extractTo = $this->extractToNewdir; // 'auto', ture or false\n\n            // archive contains one item - extract in archive dir\n            $name = '';\n            $src = $dir . DIRECTORY_SEPARATOR . $ls[0];\n            if (($extractTo === 'auto' || !$extractTo) && count($ls) === 1 && is_file($src)) {\n                $name = $ls[0];\n            } else if ($extractTo === 'auto' || $extractTo) {\n                // for several files - create new directory\n                // create unique name for directory\n                $src = $dir;\n                $splits = elFinder::splitFileExtention(basename($path));\n                $name = $splits[0];\n                $test = dirname($path) . DIRECTORY_SEPARATOR . $name;\n                if (file_exists($test) || is_link($test)) {\n                    $name = $this->uniqueName(dirname($path), $name, '-', false);\n                }\n            }\n\n            if ($name !== '') {\n                $result = dirname($path) . DIRECTORY_SEPARATOR . $name;\n\n                if (!rename($src, $result)) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            } else {\n                $dstDir = dirname($path);\n                $result = array();\n                foreach ($ls as $name) {\n                    $target = $dstDir . DIRECTORY_SEPARATOR . $name;\n                    if (self::localMoveRecursive($dir . DIRECTORY_SEPARATOR . $name, $target, true, $this->options['copyJoin'])) {\n                        $result[] = $target;\n                    }\n                }\n                if (!$result) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            }\n\n            is_dir($dir) && $this->delTree($dir);\n\n            return (is_array($result) || file_exists($result)) ? $result : false;\n        }\n        //TODO: Add return statement here\n        return false;\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _archive($dir, $files, $name, $arc)\n    {\n        return $this->makeArchive($dir, $files, $name, $arc);\n    }\n\n    /******************** Over write functions *************************/\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        return $this->rmdirRecursive($localpath);\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array|boolean false\n     */\n    protected function isNameExists($path)\n    {\n        $exists = file_exists($this->convEncIn($path));\n        // restore locale\n        $this->convEncOut();\n        return $exists ? $this->stat($path) : false;\n    }\n\n    /******************** Over write (Optimized) functions *************************/\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        if (!empty($this->doSearchCurrentQuery['matchMethod']) || $this->encoding || !class_exists('FilesystemIterator', false)) {\n            // has custom match method or non UTF-8, use elFinderVolumeDriver::doSearch()\n            return parent::doSearch($path, $q, $mimes);\n        }\n\n        $result = array();\n\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n        elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n        $match = array();\n        try {\n            $iterator = new RecursiveIteratorIterator(\n                new RecursiveCallbackFilterIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::KEY_AS_PATHNAME |\n                        FilesystemIterator::SKIP_DOTS |\n                        ((defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') && $this->options['followSymLinks']) ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    ),\n                    array($this, 'localFileSystemSearchIteratorFilter')\n                ),\n                RecursiveIteratorIterator::SELF_FIRST,\n                RecursiveIteratorIterator::CATCH_GET_CHILD\n            );\n            foreach ($iterator as $key => $node) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($node->getPath)));\n                    break;\n                }\n                if ($node->isDir()) {\n                    if ($this->stripos($node->getFilename(), $q) !== false) {\n                        $match[] = $key;\n                    }\n                } else {\n                    $match[] = $key;\n                }\n            }\n        } catch (Exception $e) {\n        }\n\n        if ($match) {\n            foreach ($match as $p) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode(dirname($p))));\n                    break;\n                }\n\n                $stat = $this->stat($p);\n\n                if (!$stat) { // invalid links\n                    continue;\n                }\n\n                if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                    continue;\n                }\n\n                if ((!$mimes || $stat['mime'] !== 'directory')) {\n                    $stat['path'] = $this->path($stat['hash']);\n                    if ($this->URL && !isset($stat['url'])) {\n                        $_path = str_replace(DIRECTORY_SEPARATOR, '/', substr($p, strlen($this->root) + 1));\n                        $stat['url'] = $this->URL . str_replace('%2F', '/', rawurlencode($_path));\n                    }\n\n                    $result[] = $stat;\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /******************** Original local functions ************************\n     *\n     * @param $file\n     * @param $key\n     * @param $iterator\n     *\n     * @return bool\n     */\n\n    public function localFileSystemSearchIteratorFilter($file, $key, $iterator)\n    {\n        /* @var FilesystemIterator $file */\n        /* @var RecursiveDirectoryIterator $iterator */\n        $name = $file->getFilename();\n        if ($this->doSearchCurrentQuery['excludes']) {\n            foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                if ($this->stripos($name, $exclude) !== false) {\n                    return false;\n                }\n            }\n        }\n        if ($iterator->hasChildren()) {\n            if ($this->options['searchExDirReg'] && preg_match($this->options['searchExDirReg'], $key)) {\n                return false;\n            }\n            return (bool)$this->attr($key, 'read', null, true);\n        }\n        return ($this->stripos($name, $this->doSearchCurrentQuery['q']) === false) ? false : true;\n    }\n\n    /**\n     * Creates a symbolic link\n     *\n     * @param      string   $target  The target\n     * @param      string   $link    The link\n     *\n     * @return     boolean  ( result of symlink() )\n     */\n    protected function localFileSystemSymlink($target, $link)\n    {\n        $res = false;\n        $errlev = error_reporting();\n        error_reporting($errlev ^ E_WARNING);\n        if ($res = symlink(realpath($target), $link)) {\n            $res = is_readable($link);\n        }\n        error_reporting($errlev);\n        return $res;\n    }\n} // END class \n"], "fixing_code": ["<?php\n\n// Implement similar functionality in PHP 5.2 or 5.3\n// http://php.net/manual/class.recursivecallbackfilteriterator.php#110974\nif (!class_exists('RecursiveCallbackFilterIterator', false)) {\n    class RecursiveCallbackFilterIterator extends RecursiveFilterIterator\n    {\n        private $callback;\n\n        public function __construct(RecursiveIterator $iterator, $callback)\n        {\n            $this->callback = $callback;\n            parent::__construct($iterator);\n        }\n\n        public function accept()\n        {\n            return call_user_func($this->callback, parent::current(), parent::key(), parent::getInnerIterator());\n        }\n\n        public function getChildren()\n        {\n            return new self($this->getInnerIterator()->getChildren(), $this->callback);\n        }\n    }\n}\n\n/**\n * elFinder driver for local filesystem.\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n **/\nclass elFinderVolumeLocalFileSystem extends elFinderVolumeDriver\n{\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'l';\n\n    /**\n     * Required to count total archive files size\n     *\n     * @var int\n     **/\n    protected $archiveSize = 0;\n\n    /**\n     * Is checking stat owner\n     *\n     * @var        boolean\n     */\n    protected $statOwner = false;\n\n    /**\n     * Path to quarantine directory\n     *\n     * @var string\n     */\n    private $quarantine;\n\n    /**\n     * Constructor\n     * Extend options with required fields\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct()\n    {\n        $this->options['alias'] = '';              // alias to replace root dir name\n        $this->options['dirMode'] = 0755;            // new dirs mode\n        $this->options['fileMode'] = 0644;            // new files mode\n        $this->options['rootCssClass'] = 'elfinder-navbar-root-local';\n        $this->options['followSymLinks'] = true;\n        $this->options['detectDirIcon'] = '';         // file name that is detected as a folder icon e.g. '.diricon.png'\n        $this->options['keepTimestamp'] = array('copy', 'move'); // keep timestamp at inner filesystem allowed 'copy', 'move' and 'upload'\n        $this->options['substituteImg'] = true;       // support substitute image with dim command\n        $this->options['statCorrector'] = null;       // callable to correct stat data `function(&$stat, $path, $statOwner, $volumeDriveInstance){}`\n        if (DIRECTORY_SEPARATOR === '/') {\n            // Linux\n            $this->options['acceptedName'] = '/^[^\\.\\/\\x00][^\\/\\x00]*$/';\n        } else {\n            // Windows\n            $this->options['acceptedName'] = '/^[^\\.\\/\\x00\\\\\\:*?\"<>|][^\\/\\x00\\\\\\:*?\"<>|]*$/';\n        }\n    }\n\n    /*********************************************************************/\n    /*                        INIT AND CONFIGURE                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     **/\n    protected function init()\n    {\n        // Normalize directory separator for windows\n        if (DIRECTORY_SEPARATOR !== '/') {\n            foreach (array('path', 'tmbPath', 'tmpPath', 'quarantine') as $key) {\n                if (!empty($this->options[$key])) {\n                    $this->options[$key] = str_replace('/', DIRECTORY_SEPARATOR, $this->options[$key]);\n                }\n            }\n            // PHP >= 7.1 Supports UTF-8 path on Windows\n            if (version_compare(PHP_VERSION, '7.1', '>=')) {\n                $this->options['encoding'] = '';\n                $this->options['locale'] = '';\n            }\n        }\n        if (!$cwd = getcwd()) {\n            return $this->setError('elFinder LocalVolumeDriver requires a result of getcwd().');\n        }\n        // detect systemRoot\n        if (!isset($this->options['systemRoot'])) {\n            if ($cwd[0] === DIRECTORY_SEPARATOR || $this->root[0] === DIRECTORY_SEPARATOR) {\n                $this->systemRoot = DIRECTORY_SEPARATOR;\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $this->root, $m)) {\n                $this->systemRoot = $m[1];\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $cwd, $m)) {\n                $this->systemRoot = $m[1];\n            }\n        }\n        $this->root = $this->getFullPath($this->root, $cwd);\n        if (!empty($this->options['startPath'])) {\n            $this->options['startPath'] = $this->getFullPath($this->options['startPath'], $this->root);\n        }\n\n        if (is_null($this->options['syncChkAsTs'])) {\n            $this->options['syncChkAsTs'] = true;\n        }\n        if (is_null($this->options['syncCheckFunc'])) {\n            $this->options['syncCheckFunc'] = array($this, 'localFileSystemInotify');\n        }\n        // check 'statCorrector'\n        if (empty($this->options['statCorrector']) || !is_callable($this->options['statCorrector'])) {\n            $this->options['statCorrector'] = null;\n        }\n\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        $hiddens = array();\n        $root = $this->stat($this->root);\n\n        // check thumbnails path\n        if (!empty($this->options['tmbPath'])) {\n            if (strpos($this->options['tmbPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['tmb'] = $this->options['tmbPath'];\n                $this->options['tmbPath'] = $this->_abspath($this->options['tmbPath']);\n            } else {\n                $this->options['tmbPath'] = $this->_normpath($this->options['tmbPath']);\n            }\n        }\n        // check temp path\n        if (!empty($this->options['tmpPath'])) {\n            if (strpos($this->options['tmpPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['temp'] = $this->options['tmpPath'];\n                $this->options['tmpPath'] = $this->_abspath($this->options['tmpPath']);\n            } else {\n                $this->options['tmpPath'] = $this->_normpath($this->options['tmpPath']);\n            }\n        }\n        // check quarantine path\n        $_quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if (strpos($this->options['quarantine'], DIRECTORY_SEPARATOR) === false) {\n                //$hiddens['quarantine'] = $this->options['quarantine'];\n                //$this->options['quarantine'] = $this->_abspath($this->options['quarantine']);\n                $_quarantine = $this->_abspath($this->options['quarantine']);\n                $this->options['quarantine'] = '';\n            } else {\n                $this->options['quarantine'] = $this->_normpath($this->options['quarantine']);\n            }\n        } else {\n            $_quarantine = $this->_abspath('.quarantine');\n        }\n        is_dir($_quarantine) && self::localRmdirRecursive($_quarantine);\n\n        parent::configure();\n\n        // check tmbPath\n        if (!$this->tmbPath && isset($hiddens['tmb'])) {\n            unset($hiddens['tmb']);\n        }\n\n        // if no thumbnails url - try detect it\n        if ($root['read'] && !$this->tmbURL && $this->URL) {\n            if (strpos($this->tmbPath, $this->root) === 0) {\n                $this->tmbURL = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($this->tmbPath, strlen($this->root) + 1));\n                if (preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n                    $this->tmbURL .= '/';\n                }\n            }\n        }\n\n        // set $this->tmp by options['tmpPath']\n        $this->tmp = '';\n        if (!empty($this->options['tmpPath'])) {\n            if ((is_dir($this->options['tmpPath']) || mkdir($this->options['tmpPath'], $this->options['dirMode'], true)) && is_writable($this->options['tmpPath'])) {\n                $this->tmp = $this->options['tmpPath'];\n            } else {\n                if (isset($hiddens['temp'])) {\n                    unset($hiddens['temp']);\n                }\n            }\n        }\n        if (!$this->tmp && ($tmp = elFinder::getStaticVar('commonTempPath'))) {\n            $this->tmp = $tmp;\n        }\n\n        // check quarantine dir\n        $this->quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if ((is_dir($this->options['quarantine']) || mkdir($this->options['quarantine'], $this->options['dirMode'], true)) && is_writable($this->options['quarantine'])) {\n                $this->quarantine = $this->options['quarantine'];\n            } else {\n                if (isset($hiddens['quarantine'])) {\n                    unset($hiddens['quarantine']);\n                }\n            }\n        } else if ($_path = elFinder::getCommonTempPath()) {\n            $this->quarantine = $_path;\n        }\n\n        if (!$this->quarantine) {\n            if (!$this->tmp) {\n                $this->archivers['extract'] = array();\n                $this->disabled[] = 'extract';\n            } else {\n                $this->quarantine = $this->tmp;\n            }\n        }\n\n        if ($hiddens) {\n            foreach ($hiddens as $hidden) {\n                $this->attributes[] = array(\n                    'pattern' => '~^' . preg_quote(DIRECTORY_SEPARATOR . $hidden, '~') . '$~',\n                    'read' => false,\n                    'write' => false,\n                    'locked' => true,\n                    'hidden' => true\n                );\n            }\n        }\n\n        if (!empty($this->options['keepTimestamp'])) {\n            $this->options['keepTimestamp'] = array_flip($this->options['keepTimestamp']);\n        }\n\n        $this->statOwner = (!empty($this->options['statOwner']));\n\n        // enable WinRemoveTailDots plugin on Windows server\n        if (DIRECTORY_SEPARATOR !== '/') {\n            if (!isset($this->options['plugin'])) {\n                $this->options['plugin'] = array();\n            }\n            $this->options['plugin']['WinRemoveTailDots'] = array('enable' => true);\n        }\n    }\n\n    /**\n     * Long pooling sync checker\n     * This function require server command `inotifywait`\n     * If `inotifywait` need full path, Please add `define('ELFINER_INOTIFYWAIT_PATH', '/PATH_TO/inotifywait');` into connector.php\n     *\n     * @param string $path\n     * @param int    $standby\n     * @param number $compare\n     *\n     * @return number|bool\n     * @throws elFinderAbortException\n     */\n    public function localFileSystemInotify($path, $standby, $compare)\n    {\n        if (isset($this->sessionCache['localFileSystemInotify_disable'])) {\n            return false;\n        }\n        $path = realpath($path);\n        $mtime = filemtime($path);\n        if (!$mtime) {\n            return false;\n        }\n        if ($mtime != $compare) {\n            return $mtime;\n        }\n        $inotifywait = defined('ELFINER_INOTIFYWAIT_PATH') ? ELFINER_INOTIFYWAIT_PATH : 'inotifywait';\n        $standby = max(1, intval($standby));\n        $cmd = $inotifywait . ' ' . escapeshellarg($path) . ' -t ' . $standby . ' -e moved_to,moved_from,move,close_write,delete,delete_self';\n        $this->procExec($cmd, $o, $r);\n        if ($r === 0) {\n            // changed\n            clearstatcache();\n            if (file_exists($path)) {\n                $mtime = filemtime($path); // error on busy?\n                return $mtime ? $mtime : time();\n            } else {\n                // target was removed\n                return 0;\n            }\n        } else if ($r === 2) {\n            // not changed (timeout)\n            return $compare;\n        }\n        // error\n        // cache to $_SESSION\n        $this->sessionCache['localFileSystemInotify_disable'] = true;\n        $this->session->set($this->id, $this->sessionCache);\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dirname($path)\n    {\n        return dirname($path);\n    }\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _basename($path)\n    {\n        return basename($path);\n    }\n\n    /**\n     * Join dir name and file name and retur full path\n     *\n     * @param  string $dir\n     * @param  string $name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _joinPath($dir, $name)\n    {\n        $dir = rtrim($dir, DIRECTORY_SEPARATOR);\n        $path = realpath($dir . DIRECTORY_SEPARATOR . $name);\n        // realpath() returns FALSE if the file does not exist\n        if ($path === false || strpos($path, $this->root) !== 0) {\n            if (DIRECTORY_SEPARATOR !== '/') {\n                $dir = str_replace('/', DIRECTORY_SEPARATOR, $dir);\n                $name = str_replace('/', DIRECTORY_SEPARATOR, $name);\n            }\n            // Directory traversal measures\n            if (strpos($dir, '..' . DIRECTORY_SEPARATOR) !== false || substr($dir, -2) == '..') {\n                $dir = $this->root;\n            }\n            if (strpos($name, '..' . DIRECTORY_SEPARATOR) !== false) {\n                $name = basename($name);\n            }\n            $path = $dir . DIRECTORY_SEPARATOR . $name;\n        }\n        return $path; \n    }\n\n    /**\n     * Return normalized path, this works the same as os.path.normpath() in Python\n     *\n     * @param  string $path path\n     *\n     * @return string\n     * @author Troex Nevelin\n     **/\n    protected function _normpath($path)\n    {\n        if (empty($path)) {\n            return '.';\n        }\n\n        $changeSep = (DIRECTORY_SEPARATOR !== '/');\n        if ($changeSep) {\n            $drive = '';\n            if (preg_match('/^([a-zA-Z]:)(.*)/', $path, $m)) {\n                $drive = $m[1];\n                $path = $m[2] ? $m[2] : '/';\n            }\n            $path = str_replace(DIRECTORY_SEPARATOR, '/', $path);\n        }\n\n        if (strpos($path, '/') === 0) {\n            $initial_slashes = true;\n        } else {\n            $initial_slashes = false;\n        }\n\n        if (($initial_slashes)\n            && (strpos($path, '//') === 0)\n            && (strpos($path, '///') === false)) {\n            $initial_slashes = 2;\n        }\n\n        $initial_slashes = (int)$initial_slashes;\n\n        $comps = explode('/', $path);\n        $new_comps = array();\n        foreach ($comps as $comp) {\n            if (in_array($comp, array('', '.'))) {\n                continue;\n            }\n\n            if (($comp != '..')\n                || (!$initial_slashes && !$new_comps)\n                || ($new_comps && (end($new_comps) == '..'))) {\n                array_push($new_comps, $comp);\n            } elseif ($new_comps) {\n                array_pop($new_comps);\n            }\n        }\n        $comps = $new_comps;\n        $path = implode('/', $comps);\n        if ($initial_slashes) {\n            $path = str_repeat('/', $initial_slashes) . $path;\n        }\n\n        if ($changeSep) {\n            $path = $drive . str_replace('/', DIRECTORY_SEPARATOR, $path);\n        }\n\n        return $path ? $path : '.';\n    }\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _relpath($path)\n    {\n        if ($path === $this->root) {\n            return '';\n        } else {\n            if (strpos($path, $this->root) === 0) {\n                return ltrim(substr($path, strlen($this->root)), DIRECTORY_SEPARATOR);\n            } else {\n                // for link\n                return $path;\n            }\n        }\n    }\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _abspath($path)\n    {\n        if ($path === DIRECTORY_SEPARATOR) {\n            return $this->root;\n        } else {\n            $path = $this->_normpath($path);\n            if (strpos($path, $this->systemRoot) === 0) {\n                return $path;\n            } else if (DIRECTORY_SEPARATOR !== '/' && preg_match('/^[a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . '/', $path)) {\n                return $path;\n            } else {\n                return $this->_joinPath($this->root, $path);\n            }\n        }\n    }\n\n    /**\n     * Return fake path started from root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _path($path)\n    {\n        return $this->rootName . ($path == $this->root ? '' : $this->separator . $this->_relpath($path));\n    }\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _inpath($path, $parent)\n    {\n        $cwd = getcwd();\n        $real_path = $this->getFullPath($path, $cwd);\n        $real_parent = $this->getFullPath($parent, $cwd);\n        if ($real_path && $real_parent) {\n            return $real_path === $real_parent || strpos($real_path, rtrim($real_parent, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR) === 0;\n        }\n        return false;\n    }\n\n\n\n    /***************** file stat ********************/\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _stat($path)\n    {\n        $stat = array();\n\n        if (!file_exists($path) && !is_link($path)) {\n            return $stat;\n        }\n\n        //Verifies the given path is the root or is inside the root. Prevents directory traveral.\n        if (!$this->_inpath($path, $this->root)) {\n            return $stat;\n        }\n\n        $stat['isowner'] = false;\n        $linkreadable = false;\n        if ($path != $this->root && is_link($path)) {\n            if (!$this->options['followSymLinks']) {\n                return array();\n            }\n            if (!($target = $this->readlink($path))\n                || $target == $path) {\n                if (is_null($target)) {\n                    $stat = array();\n                    return $stat;\n                } else {\n                    $stat['mime'] = 'symlink-broken';\n                    $target = readlink($path);\n                    $lstat = lstat($path);\n                    $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                    $linkreadable = !empty($ostat['isowner']);\n                }\n            }\n            $stat['alias'] = $this->_path($target);\n            $stat['target'] = $target;\n        }\n\n        $readable = is_readable($path);\n\n        if ($readable) {\n            $size = sprintf('%u', filesize($path));\n            $stat['ts'] = filemtime($path);\n            if ($this->statOwner) {\n                $fstat = stat($path);\n                $uid = $fstat['uid'];\n                $gid = $fstat['gid'];\n                $stat['perm'] = substr((string)decoct($fstat['mode']), -4);\n                $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n            }\n        }\n\n        if (($dir = is_dir($path)) && $this->options['detectDirIcon']) {\n            $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n            if ($this->URL && file_exists($favicon)) {\n                $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n            }\n        }\n\n        if (!isset($stat['mime'])) {\n            $stat['mime'] = $dir ? 'directory' : $this->mimetype($path);\n        }\n        //logical rights first\n        $stat['read'] = ($linkreadable || $readable) ? null : false;\n        $stat['write'] = is_writable($path) ? null : false;\n\n        if (is_null($stat['read'])) {\n            if ($dir) {\n                $stat['size'] = 0;\n            } else if (isset($size)) {\n                $stat['size'] = $size;\n            }\n        }\n\n        if ($this->options['statCorrector']) {\n            call_user_func_array($this->options['statCorrector'], array(&$stat, $path, $this->statOwner, $this));\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat `owner`, `group` and `isowner` by `uid` and `gid`\n     * Sub-fuction of _stat() and _scandir()\n     *\n     * @param integer $uid\n     * @param integer $gid\n     *\n     * @return array  stat\n     */\n    protected function getOwnerStat($uid, $gid)\n    {\n        static $names = null;\n        static $phpuid = null;\n\n        if (is_null($names)) {\n            $names = array('uid' => array(), 'gid' => array());\n        }\n        if (is_null($phpuid)) {\n            if (is_callable('posix_getuid')) {\n                $phpuid = posix_getuid();\n            } else {\n                $phpuid = 0;\n            }\n        }\n\n        $stat = array();\n\n        if ($uid) {\n            $stat['isowner'] = ($phpuid == $uid);\n            if (isset($names['uid'][$uid])) {\n                $stat['owner'] = $names['uid'][$uid];\n            } else if (is_callable('posix_getpwuid')) {\n                $pwuid = posix_getpwuid($uid);\n                $stat['owner'] = $names['uid'][$uid] = $pwuid['name'];\n            } else {\n                $stat['owner'] = $names['uid'][$uid] = $uid;\n            }\n        }\n        if ($gid) {\n            if (isset($names['gid'][$gid])) {\n                $stat['group'] = $names['gid'][$gid];\n            } else if (is_callable('posix_getgrgid')) {\n                $grgid = posix_getgrgid($gid);\n                $stat['group'] = $names['gid'][$gid] = $grgid['name'];\n            } else {\n                $stat['group'] = $names['gid'][$gid] = $gid;\n            }\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _subdirs($path)\n    {\n\n        $dirs = false;\n        if (is_dir($path) && is_readable($path)) {\n            if (class_exists('FilesystemIterator', false)) {\n                $dirItr = new ParentIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::SKIP_DOTS |\n                        FilesystemIterator::CURRENT_AS_SELF |\n                        (defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    )\n                );\n                $dirItr->rewind();\n                if ($dirItr->hasChildren()) {\n                    $dirs = true;\n                    $name = $dirItr->getSubPathName();\n                    while ($dirItr->valid()) {\n                        if (!$this->attr($path . DIRECTORY_SEPARATOR . $name, 'read', null, true)) {\n                            $dirs = false;\n                            $dirItr->next();\n                            $name = $dirItr->getSubPathName();\n                            continue;\n                        }\n                        $dirs = true;\n                        break;\n                    }\n                }\n            } else {\n                $path = strtr($path, array('[' => '\\\\[', ']' => '\\\\]', '*' => '\\\\*', '?' => '\\\\?'));\n                return (bool)glob(rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR);\n            }\n        }\n        return $dirs;\n    }\n\n    /**\n     * Return object width and height\n     * Usualy used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dimensions($path, $mime)\n    {\n        clearstatcache();\n        return strpos($mime, 'image') === 0 && is_readable($path) && filesize($path) && ($s = getimagesize($path)) !== false\n            ? $s[0] . 'x' . $s[1]\n            : false;\n    }\n    /******************** file/dir content *********************/\n\n    /**\n     * Return symlink target file\n     *\n     * @param  string $path link path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function readlink($path)\n    {\n        if (!($target = readlink($path))) {\n            return null;\n        }\n\n        if (strpos($target, $this->systemRoot) !== 0) {\n            $target = $this->_joinPath(dirname($path), $target);\n        }\n\n        if (!file_exists($target)) {\n            return false;\n        }\n\n        return $target;\n    }\n\n    /**\n     * Return files list in directory.\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _scandir($path)\n    {\n        elFinder::checkAborted();\n        $files = array();\n        $cache = array();\n        $dirWritable = is_writable($path);\n        $dirItr = array();\n        $followSymLinks = $this->options['followSymLinks'];\n        try {\n            $dirItr = new DirectoryIterator($path);\n        } catch (UnexpectedValueException $e) {\n        }\n\n        foreach ($dirItr as $file) {\n            try {\n                if ($file->isDot()) {\n                    continue;\n                }\n\n                $files[] = $fpath = $file->getPathname();\n\n                $br = false;\n                $stat = array();\n\n                $stat['isowner'] = false;\n                $linkreadable = false;\n                if ($file->isLink()) {\n                    if (!$followSymLinks) {\n                        continue;\n                    }\n                    if (!($target = $this->readlink($fpath))\n                        || $target == $fpath) {\n                        if (is_null($target)) {\n                            $stat = array();\n                            $br = true;\n                        } else {\n                            $_path = $fpath;\n                            $stat['mime'] = 'symlink-broken';\n                            $target = readlink($_path);\n                            $lstat = lstat($_path);\n                            $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                            $linkreadable = !empty($ostat['isowner']);\n                            $dir = false;\n                            $stat['alias'] = $this->_path($target);\n                            $stat['target'] = $target;\n                        }\n                    } else {\n                        $dir = is_dir($target);\n                        $stat['alias'] = $this->_path($target);\n                        $stat['target'] = $target;\n                        $stat['mime'] = $dir ? 'directory' : $this->mimetype($stat['alias']);\n                    }\n                } else {\n                    if (($dir = $file->isDir()) && $this->options['detectDirIcon']) {\n                        $path = $file->getPathname();\n                        $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n                        if ($this->URL && file_exists($favicon)) {\n                            $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n                        }\n                    }\n                    $stat['mime'] = $dir ? 'directory' : $this->mimetype($fpath);\n                }\n                $size = sprintf('%u', $file->getSize());\n                $stat['ts'] = $file->getMTime();\n                if (!$br) {\n                    if ($this->statOwner && !$linkreadable) {\n                        $uid = $file->getOwner();\n                        $gid = $file->getGroup();\n                        $stat['perm'] = substr((string)decoct($file->getPerms()), -4);\n                        $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n                    }\n\n                    //logical rights first\n                    $stat['read'] = ($linkreadable || $file->isReadable()) ? null : false;\n                    $stat['write'] = $file->isWritable() ? null : false;\n                    $stat['locked'] = $dirWritable ? null : true;\n\n                    if (is_null($stat['read'])) {\n                        $stat['size'] = $dir ? 0 : $size;\n                    }\n\n                    if ($this->options['statCorrector']) {\n                        call_user_func_array($this->options['statCorrector'], array(&$stat, $fpath, $this->statOwner, $this));\n                    }\n                }\n\n                $cache[] = array($fpath, $stat);\n            } catch (RuntimeException $e) {\n                continue;\n            }\n        }\n\n        if ($cache) {\n            $cache = $this->convEncOut($cache, false);\n            foreach ($cache as $d) {\n                $this->updateCache($d[0], $d[1]);\n            }\n        }\n\n        return $files;\n    }\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _fopen($path, $mode = 'rb')\n    {\n        return fopen($path, $mode);\n    }\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp file pointer\n     * @param string    $path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _fclose($fp, $path = '')\n    {\n        return (is_resource($fp) && fclose($fp));\n    }\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkdir($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (mkdir($path)) {\n            chmod($path, $this->options['dirMode']);\n            return $path;\n        }\n\n        return false;\n    }\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkfile($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (($fp = fopen($path, 'w'))) {\n            fclose($fp);\n            chmod($path, $this->options['fileMode']);\n            return $path;\n        }\n        return false;\n    }\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _symlink($source, $targetDir, $name)\n    {\n        return symlink($source, $this->_joinPath($targetDir, $name));\n    }\n\n    /**\n     * Copy file into another file\n     *\n     * @param  string $source    source file path\n     * @param  string $targetDir target directory path\n     * @param  string $name      new file name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _copy($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = copy($source, $target)) {\n            isset($this->options['keepTimestamp']['copy']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _move($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = rename($source, $target) ? $target : false) {\n            isset($this->options['keepTimestamp']['move']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _unlink($path)\n    {\n        return is_file($path) && unlink($path);\n    }\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _rmdir($path)\n    {\n        return rmdir($path);\n    }\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _save($fp, $dir, $name, $stat)\n    {\n        $path = $this->_joinPath($dir, $name);\n\n        $meta = stream_get_meta_data($fp);\n        $uri = isset($meta['uri']) ? $meta['uri'] : '';\n        if ($uri && !preg_match('#^[a-zA-Z0-9]+://#', $uri) && !is_link($uri)) {\n            fclose($fp);\n            $mtime = filemtime($uri);\n            $isCmdPaste = ($this->ARGS['cmd'] === 'paste');\n            $isCmdCopy = ($isCmdPaste && empty($this->ARGS['cut']));\n            if (($isCmdCopy || !rename($uri, $path)) && !copy($uri, $path)) {\n                return false;\n            }\n            // keep timestamp on upload\n            if ($mtime && $this->ARGS['cmd'] === 'upload') {\n                touch($path, isset($this->options['keepTimestamp']['upload']) ? $mtime : time());\n            }\n        } else {\n            if (file_put_contents($path, $fp, LOCK_EX) === false) {\n                return false;\n            }\n        }\n\n        chmod($path, $this->options['fileMode']);\n        return $path;\n    }\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _getContents($path)\n    {\n        return file_get_contents($path);\n    }\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _filePutContents($path, $content)\n    {\n        return (file_put_contents($path, $content, LOCK_EX) !== false);\n    }\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    protected function _checkArchivers()\n    {\n        $this->archivers = $this->getArchivers();\n        return;\n    }\n\n    /**\n     * chmod availability\n     *\n     * @param string $path\n     * @param string $mode\n     *\n     * @return bool\n     */\n    protected function _chmod($path, $mode)\n    {\n        $modeOct = is_string($mode) ? octdec($mode) : octdec(sprintf(\"%04o\", $mode));\n        return chmod($path, $modeOct);\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _findSymlinks($path)\n    {\n        return self::localFindSymlinks($path);\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path archive path\n     * @param  array  $arc  archiver command and arguments (same as in $this->archivers)\n     *\n     * @return array|string|boolean\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _extract($path, $arc)\n    {\n\n        if ($this->quarantine) {\n\n            $dir = $this->quarantine . DIRECTORY_SEPARATOR . md5(basename($path) . mt_rand());\n            $archive = (isset($arc['toSpec']) || $arc['cmd'] === 'phpfunction') ? '' : $dir . DIRECTORY_SEPARATOR . basename($path);\n\n            if (!mkdir($dir)) {\n                return false;\n            }\n\n            // insurance unexpected shutdown\n            register_shutdown_function(array($this, 'rmdirRecursive'), realpath($dir));\n\n            chmod($dir, 0777);\n\n            // copy in quarantine\n            if (!is_readable($path) || ($archive && !copy($path, $archive))) {\n                return false;\n            }\n\n            // extract in quarantine\n            try {\n                $this->unpackArchive($path, $arc, $archive ? true : $dir);\n            } catch(Exception $e) {\n                return $this->setError($e->getMessage());\n            }\n\n            // get files list\n            try {\n                $ls = self::localScandir($dir);\n            } catch (Exception $e) {\n                return false;\n            }\n\n            // no files - extract error ?\n            if (empty($ls)) {\n                return false;\n            }\n\n            $this->archiveSize = 0;\n\n            // find symlinks and check extracted items\n            $checkRes = $this->checkExtractItems($dir);\n            if ($checkRes['symlinks']) {\n                self::localRmdirRecursive($dir);\n                return $this->setError(array_merge($this->error, array(elFinder::ERROR_ARC_SYMLINKS)));\n            }\n            $this->archiveSize = $checkRes['totalSize'];\n            if ($checkRes['rmNames']) {\n                foreach ($checkRes['rmNames'] as $name) {\n                    $this->addError(elFinder::ERROR_SAVE, $name);\n                }\n            }\n\n            // check max files size\n            if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $this->archiveSize) {\n                $this->delTree($dir);\n                return $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n            }\n\n            $extractTo = $this->extractToNewdir; // 'auto', ture or false\n\n            // archive contains one item - extract in archive dir\n            $name = '';\n            $src = $dir . DIRECTORY_SEPARATOR . $ls[0];\n            if (($extractTo === 'auto' || !$extractTo) && count($ls) === 1 && is_file($src)) {\n                $name = $ls[0];\n            } else if ($extractTo === 'auto' || $extractTo) {\n                // for several files - create new directory\n                // create unique name for directory\n                $src = $dir;\n                $splits = elFinder::splitFileExtention(basename($path));\n                $name = $splits[0];\n                $test = dirname($path) . DIRECTORY_SEPARATOR . $name;\n                if (file_exists($test) || is_link($test)) {\n                    $name = $this->uniqueName(dirname($path), $name, '-', false);\n                }\n            }\n\n            if ($name !== '') {\n                $result = dirname($path) . DIRECTORY_SEPARATOR . $name;\n\n                if (!rename($src, $result)) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            } else {\n                $dstDir = dirname($path);\n                $result = array();\n                foreach ($ls as $name) {\n                    $target = $dstDir . DIRECTORY_SEPARATOR . $name;\n                    if (self::localMoveRecursive($dir . DIRECTORY_SEPARATOR . $name, $target, true, $this->options['copyJoin'])) {\n                        $result[] = $target;\n                    }\n                }\n                if (!$result) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            }\n\n            is_dir($dir) && $this->delTree($dir);\n\n            return (is_array($result) || file_exists($result)) ? $result : false;\n        }\n        //TODO: Add return statement here\n        return false;\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _archive($dir, $files, $name, $arc)\n    {\n        return $this->makeArchive($dir, $files, $name, $arc);\n    }\n\n    /******************** Over write functions *************************/\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        return $this->rmdirRecursive($localpath);\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array|boolean false\n     */\n    protected function isNameExists($path)\n    {\n        $exists = file_exists($this->convEncIn($path));\n        // restore locale\n        $this->convEncOut();\n        return $exists ? $this->stat($path) : false;\n    }\n\n    /******************** Over write (Optimized) functions *************************/\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        if (!empty($this->doSearchCurrentQuery['matchMethod']) || $this->encoding || !class_exists('FilesystemIterator', false)) {\n            // has custom match method or non UTF-8, use elFinderVolumeDriver::doSearch()\n            return parent::doSearch($path, $q, $mimes);\n        }\n\n        $result = array();\n\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n        elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n        $match = array();\n        try {\n            $iterator = new RecursiveIteratorIterator(\n                new RecursiveCallbackFilterIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::KEY_AS_PATHNAME |\n                        FilesystemIterator::SKIP_DOTS |\n                        ((defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') && $this->options['followSymLinks']) ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    ),\n                    array($this, 'localFileSystemSearchIteratorFilter')\n                ),\n                RecursiveIteratorIterator::SELF_FIRST,\n                RecursiveIteratorIterator::CATCH_GET_CHILD\n            );\n            foreach ($iterator as $key => $node) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($node->getPath)));\n                    break;\n                }\n                if ($node->isDir()) {\n                    if ($this->stripos($node->getFilename(), $q) !== false) {\n                        $match[] = $key;\n                    }\n                } else {\n                    $match[] = $key;\n                }\n            }\n        } catch (Exception $e) {\n        }\n\n        if ($match) {\n            foreach ($match as $p) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode(dirname($p))));\n                    break;\n                }\n\n                $stat = $this->stat($p);\n\n                if (!$stat) { // invalid links\n                    continue;\n                }\n\n                if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                    continue;\n                }\n\n                if ((!$mimes || $stat['mime'] !== 'directory')) {\n                    $stat['path'] = $this->path($stat['hash']);\n                    if ($this->URL && !isset($stat['url'])) {\n                        $_path = str_replace(DIRECTORY_SEPARATOR, '/', substr($p, strlen($this->root) + 1));\n                        $stat['url'] = $this->URL . str_replace('%2F', '/', rawurlencode($_path));\n                    }\n\n                    $result[] = $stat;\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /******************** Original local functions ************************\n     *\n     * @param $file\n     * @param $key\n     * @param $iterator\n     *\n     * @return bool\n     */\n\n    public function localFileSystemSearchIteratorFilter($file, $key, $iterator)\n    {\n        /* @var FilesystemIterator $file */\n        /* @var RecursiveDirectoryIterator $iterator */\n        $name = $file->getFilename();\n        if ($this->doSearchCurrentQuery['excludes']) {\n            foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                if ($this->stripos($name, $exclude) !== false) {\n                    return false;\n                }\n            }\n        }\n        if ($iterator->hasChildren()) {\n            if ($this->options['searchExDirReg'] && preg_match($this->options['searchExDirReg'], $key)) {\n                return false;\n            }\n            return (bool)$this->attr($key, 'read', null, true);\n        }\n        return ($this->stripos($name, $this->doSearchCurrentQuery['q']) === false) ? false : true;\n    }\n\n    /**\n     * Creates a symbolic link\n     *\n     * @param      string   $target  The target\n     * @param      string   $link    The link\n     *\n     * @return     boolean  ( result of symlink() )\n     */\n    protected function localFileSystemSymlink($target, $link)\n    {\n        $res = false;\n        $errlev = error_reporting();\n        error_reporting($errlev ^ E_WARNING);\n        if ($res = symlink(realpath($target), $link)) {\n            $res = is_readable($link);\n        }\n        error_reporting($errlev);\n        return $res;\n    }\n} // END class \n"], "filenames": ["php/elFinderVolumeLocalFileSystem.class.php"], "buggy_code_start_loc": [375], "buggy_code_end_loc": [378], "fixing_code_start_loc": [376], "fixing_code_end_loc": [383], "type": "CWE-22", "message": "_joinPath in elFinderVolumeLocalFileSystem.class.php in elFinder before 2.1.62 allows path traversal in the PHP LocalVolumeDriver connector.", "other": {"cve": {"id": "CVE-2023-35840", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-19T01:15:08.710", "lastModified": "2023-06-26T18:24:34.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "_joinPath in elFinderVolumeLocalFileSystem.class.php in elFinder before 2.1.62 allows path traversal in the PHP LocalVolumeDriver connector."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:std42:elfinder:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.62", "matchCriteriaId": "32619FA7-1324-404D-BC77-979ECF235E40"}]}]}], "references": [{"url": "https://github.com/Studio-42/elFinder/commit/bb9aaa7b096a1b83f2f85657c43f12131ece2891", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/Studio-42/elFinder/security/advisories/GHSA-wm5g-p99q-66g4", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://github.com/afine-com/CVE-2023-35840", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/sectroyer/CVEs/tree/main/CVE-2023-35840", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Studio-42/elFinder/commit/bb9aaa7b096a1b83f2f85657c43f12131ece2891"}}