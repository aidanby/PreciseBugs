{"buggy_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n/*\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n#include \"xkbcomp-priv.h\"\n#include \"text.h\"\n#include \"expr.h\"\n#include \"action.h\"\n#include \"vmod.h\"\n#include \"include.h\"\n\nenum si_field {\n    SI_FIELD_VIRTUAL_MOD = (1 << 0),\n    SI_FIELD_ACTION = (1 << 1),\n    SI_FIELD_AUTO_REPEAT = (1 << 2),\n    SI_FIELD_LEVEL_ONE_ONLY = (1 << 3),\n};\n\ntypedef struct {\n    enum si_field defined;\n    enum merge_mode merge;\n\n    struct xkb_sym_interpret interp;\n} SymInterpInfo;\n\nenum led_field {\n    LED_FIELD_MODS = (1 << 0),\n    LED_FIELD_GROUPS = (1 << 1),\n    LED_FIELD_CTRLS = (1 << 2),\n};\n\ntypedef struct {\n    enum led_field defined;\n    enum merge_mode merge;\n\n    struct xkb_led led;\n} LedInfo;\n\ntypedef struct {\n    char *name;\n    int errorCount;\n    SymInterpInfo default_interp;\n    darray(SymInterpInfo) interps;\n    LedInfo default_led;\n    LedInfo leds[XKB_MAX_LEDS];\n    unsigned int num_leds;\n    ActionsInfo *actions;\n    struct xkb_mod_set mods;\n\n    struct xkb_context *ctx;\n} CompatInfo;\n\nstatic const char *\nsiText(SymInterpInfo *si, CompatInfo *info)\n{\n    char *buf = xkb_context_get_buffer(info->ctx, 128);\n\n    if (si == &info->default_interp)\n        return \"default\";\n\n    snprintf(buf, 128, \"%s+%s(%s)\",\n             KeysymText(info->ctx, si->interp.sym),\n             SIMatchText(si->interp.match),\n             ModMaskText(info->ctx, &info->mods, si->interp.mods));\n\n    return buf;\n}\n\nstatic inline bool\nReportSINotArray(CompatInfo *info, SymInterpInfo *si, const char *field)\n{\n    return ReportNotArray(info->ctx, \"symbol interpretation\", field,\n                          siText(si, info));\n}\n\nstatic inline bool\nReportSIBadType(CompatInfo *info, SymInterpInfo *si, const char *field,\n                const char *wanted)\n{\n    return ReportBadType(info->ctx, \"symbol interpretation\", field,\n                         siText(si, info), wanted);\n}\n\nstatic inline bool\nReportLedBadType(CompatInfo *info, LedInfo *ledi, const char *field,\n                 const char *wanted)\n{\n    return ReportBadType(info->ctx, \"indicator map\", field,\n                         xkb_atom_text(info->ctx, ledi->led.name),\n                         wanted);\n}\n\nstatic inline bool\nReportLedNotArray(CompatInfo *info, LedInfo *ledi, const char *field)\n{\n    return ReportNotArray(info->ctx, \"indicator map\", field,\n                          xkb_atom_text(info->ctx, ledi->led.name));\n}\n\nstatic void\nInitCompatInfo(CompatInfo *info, struct xkb_context *ctx,\n               ActionsInfo *actions, const struct xkb_mod_set *mods)\n{\n    memset(info, 0, sizeof(*info));\n    info->ctx = ctx;\n    info->actions = actions;\n    info->mods = *mods;\n    info->default_interp.merge = MERGE_OVERRIDE;\n    info->default_interp.interp.virtual_mod = XKB_MOD_INVALID;\n    info->default_led.merge = MERGE_OVERRIDE;\n}\n\nstatic void\nClearCompatInfo(CompatInfo *info)\n{\n    free(info->name);\n    darray_free(info->interps);\n}\n\nstatic SymInterpInfo *\nFindMatchingInterp(CompatInfo *info, SymInterpInfo *new)\n{\n    SymInterpInfo *old;\n\n    darray_foreach(old, info->interps)\n        if (old->interp.sym == new->interp.sym &&\n            old->interp.mods == new->interp.mods &&\n            old->interp.match == new->interp.match)\n            return old;\n\n    return NULL;\n}\n\nstatic bool\nUseNewInterpField(enum si_field field, SymInterpInfo *old, SymInterpInfo *new,\n                  bool report, enum si_field *collide)\n{\n    if (!(old->defined & field))\n        return true;\n\n    if (new->defined & field) {\n        if (report)\n            *collide |= field;\n\n        if (new->merge != MERGE_AUGMENT)\n            return true;\n    }\n\n    return false;\n}\n\nstatic bool\nAddInterp(CompatInfo *info, SymInterpInfo *new, bool same_file)\n{\n    SymInterpInfo *old = FindMatchingInterp(info, new);\n    if (old) {\n        const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n        const bool report = (same_file && verbosity > 0) || verbosity > 9;\n        enum si_field collide = 0;\n\n        if (new->merge == MERGE_REPLACE) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Multiple definitions for \\\"%s\\\"; \"\n                         \"Earlier interpretation ignored\\n\",\n                         siText(new, info));\n            *old = *new;\n            return true;\n        }\n\n        if (UseNewInterpField(SI_FIELD_VIRTUAL_MOD, old, new, report,\n                              &collide)) {\n            old->interp.virtual_mod = new->interp.virtual_mod;\n            old->defined |= SI_FIELD_VIRTUAL_MOD;\n        }\n        if (UseNewInterpField(SI_FIELD_ACTION, old, new, report,\n                              &collide)) {\n            old->interp.action = new->interp.action;\n            old->defined |= SI_FIELD_ACTION;\n        }\n        if (UseNewInterpField(SI_FIELD_AUTO_REPEAT, old, new, report,\n                              &collide)) {\n            old->interp.repeat = new->interp.repeat;\n            old->defined |= SI_FIELD_AUTO_REPEAT;\n        }\n        if (UseNewInterpField(SI_FIELD_LEVEL_ONE_ONLY, old, new, report,\n                              &collide)) {\n            old->interp.level_one_only = new->interp.level_one_only;\n            old->defined |= SI_FIELD_LEVEL_ONE_ONLY;\n        }\n\n        if (collide) {\n            log_warn(info->ctx,\n                     \"Multiple interpretations of \\\"%s\\\"; \"\n                     \"Using %s definition for duplicate fields\\n\",\n                     siText(new, info),\n                     (new->merge != MERGE_AUGMENT ? \"last\" : \"first\"));\n        }\n\n        return true;\n    }\n\n    darray_append(info->interps, *new);\n    return true;\n}\n\n/***====================================================================***/\n\nstatic bool\nResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}\n\n/***====================================================================***/\n\nstatic bool\nUseNewLEDField(enum led_field field, LedInfo *old, LedInfo *new,\n               bool report, enum led_field *collide)\n{\n    if (!(old->defined & field))\n        return true;\n\n    if (new->defined & field) {\n        if (report)\n            *collide |= field;\n\n        if (new->merge != MERGE_AUGMENT)\n            return true;\n    }\n\n    return false;\n}\n\nstatic bool\nAddLedMap(CompatInfo *info, LedInfo *new, bool same_file)\n{\n    enum led_field collide;\n    const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n    const bool report = (same_file && verbosity > 0) || verbosity > 9;\n\n    for (xkb_led_index_t i = 0; i < info->num_leds; i++) {\n        LedInfo *old = &info->leds[i];\n\n        if (old->led.name != new->led.name)\n            continue;\n\n        if (old->led.mods.mods == new->led.mods.mods &&\n            old->led.groups == new->led.groups &&\n            old->led.ctrls == new->led.ctrls &&\n            old->led.which_mods == new->led.which_mods &&\n            old->led.which_groups == new->led.which_groups) {\n            old->defined |= new->defined;\n            return true;\n        }\n\n        if (new->merge == MERGE_REPLACE) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Map for indicator %s redefined; \"\n                         \"Earlier definition ignored\\n\",\n                         xkb_atom_text(info->ctx, old->led.name));\n            *old = *new;\n            return true;\n        }\n\n        collide = 0;\n        if (UseNewLEDField(LED_FIELD_MODS, old, new, report, &collide)) {\n            old->led.which_mods = new->led.which_mods;\n            old->led.mods = new->led.mods;\n            old->defined |= LED_FIELD_MODS;\n        }\n        if (UseNewLEDField(LED_FIELD_GROUPS, old, new, report, &collide)) {\n            old->led.which_groups = new->led.which_groups;\n            old->led.groups = new->led.groups;\n            old->defined |= LED_FIELD_GROUPS;\n        }\n        if (UseNewLEDField(LED_FIELD_CTRLS, old, new, report, &collide)) {\n            old->led.ctrls = new->led.ctrls;\n            old->defined |= LED_FIELD_CTRLS;\n        }\n\n        if (collide) {\n            log_warn(info->ctx,\n                     \"Map for indicator %s redefined; \"\n                     \"Using %s definition for duplicate fields\\n\",\n                     xkb_atom_text(info->ctx, old->led.name),\n                     (new->merge == MERGE_AUGMENT ? \"first\" : \"last\"));\n        }\n\n        return true;\n    }\n\n    if (info->num_leds >= XKB_MAX_LEDS) {\n        log_err(info->ctx,\n                \"Too many LEDs defined (maximum %d)\\n\",\n                XKB_MAX_LEDS);\n        return false;\n    }\n    info->leds[info->num_leds++] = *new;\n    return true;\n}\n\nstatic void\nMergeIncludedCompatMaps(CompatInfo *into, CompatInfo *from,\n                        enum merge_mode merge)\n{\n    if (from->errorCount > 0) {\n        into->errorCount += from->errorCount;\n        return;\n    }\n\n    into->mods = from->mods;\n\n    if (into->name == NULL) {\n        into->name = from->name;\n        from->name = NULL;\n    }\n\n    if (darray_empty(into->interps)) {\n        into->interps = from->interps;\n        darray_init(from->interps);\n    }\n    else {\n        SymInterpInfo *si;\n        darray_foreach(si, from->interps) {\n            si->merge = (merge == MERGE_DEFAULT ? si->merge : merge);\n            if (!AddInterp(into, si, false))\n                into->errorCount++;\n        }\n    }\n\n    if (into->num_leds == 0) {\n        memcpy(into->leds, from->leds, sizeof(*from->leds) * from->num_leds);\n        into->num_leds = from->num_leds;\n        from->num_leds = 0;\n    }\n    else {\n        for (xkb_led_index_t i = 0; i < from->num_leds; i++) {\n            LedInfo *ledi = &from->leds[i];\n            ledi->merge = (merge == MERGE_DEFAULT ? ledi->merge : merge);\n            if (!AddLedMap(into, ledi, false))\n                into->errorCount++;\n        }\n    }\n}\n\nstatic void\nHandleCompatMapFile(CompatInfo *info, XkbFile *file, enum merge_mode merge);\n\nstatic bool\nHandleIncludeCompatMap(CompatInfo *info, IncludeStmt *include)\n{\n    CompatInfo included;\n\n    InitCompatInfo(&included, info->ctx, info->actions, &info->mods);\n    included.name = include->stmt;\n    include->stmt = NULL;\n\n    for (IncludeStmt *stmt = include; stmt; stmt = stmt->next_incl) {\n        CompatInfo next_incl;\n        XkbFile *file;\n\n        file = ProcessIncludeFile(info->ctx, stmt, FILE_TYPE_COMPAT);\n        if (!file) {\n            info->errorCount += 10;\n            ClearCompatInfo(&included);\n            return false;\n        }\n\n        InitCompatInfo(&next_incl, info->ctx, info->actions, &included.mods);\n        next_incl.default_interp = info->default_interp;\n        next_incl.default_interp.merge = stmt->merge;\n        next_incl.default_led = info->default_led;\n        next_incl.default_led.merge = stmt->merge;\n\n        HandleCompatMapFile(&next_incl, file, MERGE_OVERRIDE);\n\n        MergeIncludedCompatMaps(&included, &next_incl, stmt->merge);\n\n        ClearCompatInfo(&next_incl);\n        FreeXkbFile(file);\n    }\n\n    MergeIncludedCompatMaps(info, &included, include->merge);\n    ClearCompatInfo(&included);\n\n    return (info->errorCount == 0);\n}\n\nstatic bool\nSetInterpField(CompatInfo *info, SymInterpInfo *si, const char *field,\n               ExprDef *arrayNdx, ExprDef *value)\n{\n    xkb_mod_index_t ndx;\n\n    if (istreq(field, \"action\")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!HandleActionDef(info->ctx, info->actions, &info->mods,\n                             value, &si->interp.action))\n            return false;\n\n        si->defined |= SI_FIELD_ACTION;\n    }\n    else if (istreq(field, \"virtualmodifier\") ||\n             istreq(field, \"virtualmod\")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveMod(info->ctx, value, MOD_VIRT, &info->mods, &ndx))\n            return ReportSIBadType(info, si, field, \"virtual modifier\");\n\n        si->interp.virtual_mod = ndx;\n        si->defined |= SI_FIELD_VIRTUAL_MOD;\n    }\n    else if (istreq(field, \"repeat\")) {\n        bool set;\n\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveBoolean(info->ctx, value, &set))\n            return ReportSIBadType(info, si, field, \"boolean\");\n\n        si->interp.repeat = set;\n\n        si->defined |= SI_FIELD_AUTO_REPEAT;\n    }\n    else if (istreq(field, \"locking\")) {\n        log_dbg(info->ctx,\n                \"The \\\"locking\\\" field in symbol interpretation is unsupported; \"\n                \"Ignored\\n\");\n    }\n    else if (istreq(field, \"usemodmap\") ||\n             istreq(field, \"usemodmapmods\")) {\n        unsigned int val;\n\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveEnum(info->ctx, value, &val, useModMapValueNames))\n            return ReportSIBadType(info, si, field, \"level specification\");\n\n        si->interp.level_one_only = val;\n        si->defined |= SI_FIELD_LEVEL_ONE_ONLY;\n    }\n    else {\n        return ReportBadField(info->ctx, \"symbol interpretation\", field,\n                              siText(si, info));\n    }\n\n    return true;\n}\n\nstatic bool\nSetLedMapField(CompatInfo *info, LedInfo *ledi, const char *field,\n               ExprDef *arrayNdx, ExprDef *value)\n{\n    bool ok = true;\n\n    if (istreq(field, \"modifiers\") || istreq(field, \"mods\")) {\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveModMask(info->ctx, value, MOD_BOTH,\n                                &info->mods, &ledi->led.mods.mods))\n            return ReportLedBadType(info, ledi, field, \"modifier mask\");\n\n        ledi->defined |= LED_FIELD_MODS;\n    }\n    else if (istreq(field, \"groups\")) {\n        unsigned int mask;\n\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveMask(info->ctx, value, &mask, groupMaskNames))\n            return ReportLedBadType(info, ledi, field, \"group mask\");\n\n        ledi->led.groups = mask;\n        ledi->defined |= LED_FIELD_GROUPS;\n    }\n    else if (istreq(field, \"controls\") || istreq(field, \"ctrls\")) {\n        unsigned int mask;\n\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveMask(info->ctx, value, &mask, ctrlMaskNames))\n            return ReportLedBadType(info, ledi, field, \"controls mask\");\n\n        ledi->led.ctrls = mask;\n        ledi->defined |= LED_FIELD_CTRLS;\n    }\n    else if (istreq(field, \"allowexplicit\")) {\n        log_dbg(info->ctx,\n                \"The \\\"allowExplicit\\\" field in indicator statements is unsupported; \"\n                \"Ignored\\n\");\n    }\n    else if (istreq(field, \"whichmodstate\") ||\n             istreq(field, \"whichmodifierstate\")) {\n        unsigned int mask;\n\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveMask(info->ctx, value, &mask,\n                             modComponentMaskNames))\n            return ReportLedBadType(info, ledi, field,\n                                    \"mask of modifier state components\");\n\n        ledi->led.which_mods = mask;\n    }\n    else if (istreq(field, \"whichgroupstate\")) {\n        unsigned mask;\n\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveMask(info->ctx, value, &mask,\n                             groupComponentMaskNames))\n            return ReportLedBadType(info, ledi, field,\n                                    \"mask of group state components\");\n\n        ledi->led.which_groups = mask;\n    }\n    else if (istreq(field, \"driveskbd\") ||\n             istreq(field, \"driveskeyboard\") ||\n             istreq(field, \"leddriveskbd\") ||\n             istreq(field, \"leddriveskeyboard\") ||\n             istreq(field, \"indicatordriveskbd\") ||\n             istreq(field, \"indicatordriveskeyboard\")) {\n        log_dbg(info->ctx,\n                \"The \\\"%s\\\" field in indicator statements is unsupported; \"\n                \"Ignored\\n\", field);\n    }\n    else if (istreq(field, \"index\")) {\n        /* Users should see this, it might cause unexpected behavior. */\n        log_err(info->ctx,\n                \"The \\\"index\\\" field in indicator statements is unsupported; \"\n                \"Ignored\\n\");\n    }\n    else {\n        log_err(info->ctx,\n                \"Unknown field %s in map for %s indicator; \"\n                \"Definition ignored\\n\",\n                field, xkb_atom_text(info->ctx, ledi->led.name));\n        ok = false;\n    }\n\n    return ok;\n}\n\nstatic bool\nHandleGlobalVar(CompatInfo *info, VarDef *stmt)\n{\n    const char *elem, *field;\n    ExprDef *ndx;\n    bool ret;\n\n    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx))\n        ret = false;\n    else if (elem && istreq(elem, \"interpret\"))\n        ret = SetInterpField(info, &info->default_interp, field, ndx,\n                             stmt->value);\n    else if (elem && istreq(elem, \"indicator\"))\n        ret = SetLedMapField(info, &info->default_led, field, ndx,\n                             stmt->value);\n    else\n        ret = SetActionField(info->ctx, info->actions, &info->mods,\n                             elem, field, ndx, stmt->value);\n    return ret;\n}\n\nstatic bool\nHandleInterpBody(CompatInfo *info, VarDef *def, SymInterpInfo *si)\n{\n    bool ok = true;\n    const char *elem, *field;\n    ExprDef *arrayNdx;\n\n    for (; def; def = (VarDef *) def->common.next) {\n        if (def->name && def->name->expr.op == EXPR_FIELD_REF) {\n            log_err(info->ctx,\n                    \"Cannot set a global default value from within an interpret statement; \"\n                    \"Move statements to the global file scope\\n\");\n            ok = false;\n            continue;\n        }\n\n        ok = ExprResolveLhs(info->ctx, def->name, &elem, &field, &arrayNdx);\n        if (!ok)\n            continue;\n\n        ok = SetInterpField(info, si, field, arrayNdx, def->value);\n    }\n\n    return ok;\n}\n\nstatic bool\nHandleInterpDef(CompatInfo *info, InterpDef *def, enum merge_mode merge)\n{\n    enum xkb_match_operation pred;\n    xkb_mod_mask_t mods;\n    SymInterpInfo si;\n\n    if (!ResolveStateAndPredicate(def->match, &pred, &mods, info)) {\n        log_err(info->ctx,\n                \"Couldn't determine matching modifiers; \"\n                \"Symbol interpretation ignored\\n\");\n        return false;\n    }\n\n    si = info->default_interp;\n    si.merge = merge = (def->merge == MERGE_DEFAULT ? merge : def->merge);\n    si.interp.sym = def->sym;\n    si.interp.match = pred;\n    si.interp.mods = mods;\n\n    if (!HandleInterpBody(info, def->def, &si)) {\n        info->errorCount++;\n        return false;\n    }\n\n    if (!AddInterp(info, &si, true)) {\n        info->errorCount++;\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool\nHandleLedMapDef(CompatInfo *info, LedMapDef *def, enum merge_mode merge)\n{\n    LedInfo ledi;\n    VarDef *var;\n    bool ok;\n\n    if (def->merge != MERGE_DEFAULT)\n        merge = def->merge;\n\n    ledi = info->default_led;\n    ledi.merge = merge;\n    ledi.led.name = def->name;\n\n    ok = true;\n    for (var = def->body; var != NULL; var = (VarDef *) var->common.next) {\n        const char *elem, *field;\n        ExprDef *arrayNdx;\n        if (!ExprResolveLhs(info->ctx, var->name, &elem, &field, &arrayNdx)) {\n            ok = false;\n            continue;\n        }\n\n        if (elem) {\n            log_err(info->ctx,\n                    \"Cannot set defaults for \\\"%s\\\" element in indicator map; \"\n                    \"Assignment to %s.%s ignored\\n\", elem, elem, field);\n            ok = false;\n        }\n        else {\n            ok = SetLedMapField(info, &ledi, field, arrayNdx, var->value) && ok;\n        }\n    }\n\n    if (ok)\n        return AddLedMap(info, &ledi, true);\n\n    return false;\n}\n\nstatic void\nHandleCompatMapFile(CompatInfo *info, XkbFile *file, enum merge_mode merge)\n{\n    bool ok;\n\n    merge = (merge == MERGE_DEFAULT ? MERGE_AUGMENT : merge);\n\n    free(info->name);\n    info->name = strdup_safe(file->name);\n\n    for (ParseCommon *stmt = file->defs; stmt; stmt = stmt->next) {\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            ok = HandleIncludeCompatMap(info, (IncludeStmt *) stmt);\n            break;\n        case STMT_INTERP:\n            ok = HandleInterpDef(info, (InterpDef *) stmt, merge);\n            break;\n        case STMT_GROUP_COMPAT:\n            log_dbg(info->ctx,\n                    \"The \\\"group\\\" statement in compat is unsupported; \"\n                    \"Ignored\\n\");\n            ok = true;\n            break;\n        case STMT_LED_MAP:\n            ok = HandleLedMapDef(info, (LedMapDef *) stmt, merge);\n            break;\n        case STMT_VAR:\n            ok = HandleGlobalVar(info, (VarDef *) stmt);\n            break;\n        case STMT_VMOD:\n            ok = HandleVModDef(info->ctx, &info->mods, (VModDef *) stmt, merge);\n            break;\n        default:\n            log_err(info->ctx,\n                    \"Compat files may not include other types; \"\n                    \"Ignoring %s\\n\", stmt_type_to_string(stmt->type));\n            ok = false;\n            break;\n        }\n\n        if (!ok)\n            info->errorCount++;\n\n        if (info->errorCount > 10) {\n            log_err(info->ctx,\n                    \"Abandoning compatibility map \\\"%s\\\"\\n\", file->name);\n            break;\n        }\n    }\n}\n\n/* Temporary struct for CopyInterps. */\nstruct collect {\n    darray(struct xkb_sym_interpret) sym_interprets;\n};\n\nstatic void\nCopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,\n            struct collect *collect)\n{\n    SymInterpInfo *si;\n\n    darray_foreach(si, info->interps)\n        if (si->interp.match == pred &&\n            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)\n            darray_append(collect->sym_interprets, si->interp);\n}\n\nstatic void\nCopyLedMapDefsToKeymap(struct xkb_keymap *keymap, CompatInfo *info)\n{\n    for (xkb_led_index_t idx = 0; idx < info->num_leds; idx++) {\n        LedInfo *ledi = &info->leds[idx];\n        xkb_led_index_t i;\n        struct xkb_led *led;\n\n        /*\n         * Find the LED with the given name, if it was already declared\n         * in keycodes.\n         */\n        xkb_leds_enumerate(i, led, keymap)\n            if (led->name == ledi->led.name)\n                break;\n\n        /* Not previously declared; create it with next free index. */\n        if (i >= keymap->num_leds) {\n            log_dbg(keymap->ctx,\n                    \"Indicator name \\\"%s\\\" was not declared in the keycodes section; \"\n                    \"Adding new indicator\\n\",\n                    xkb_atom_text(keymap->ctx, ledi->led.name));\n\n            xkb_leds_enumerate(i, led, keymap)\n                if (led->name == XKB_ATOM_NONE)\n                    break;\n\n            if (i >= keymap->num_leds) {\n                /* Not place to put it; ignore. */\n                if (i >= XKB_MAX_LEDS) {\n                    log_err(keymap->ctx,\n                            \"Too many indicators (maximum is %d); \"\n                            \"Indicator name \\\"%s\\\" ignored\\n\",\n                            XKB_MAX_LEDS,\n                            xkb_atom_text(keymap->ctx, ledi->led.name));\n                    continue;\n                }\n\n                /* Add a new LED. */\n                led = &keymap->leds[keymap->num_leds++];\n            }\n        }\n\n        *led = ledi->led;\n        if (led->groups != 0 && led->which_groups == 0)\n            led->which_groups = XKB_STATE_LAYOUT_EFFECTIVE;\n        if (led->mods.mods != 0 && led->which_mods == 0)\n            led->which_mods = XKB_STATE_MODS_EFFECTIVE;\n    }\n}\n\nstatic bool\nCopyCompatToKeymap(struct xkb_keymap *keymap, CompatInfo *info)\n{\n    keymap->compat_section_name = strdup_safe(info->name);\n    XkbEscapeMapName(keymap->compat_section_name);\n\n    keymap->mods = info->mods;\n\n    if (!darray_empty(info->interps)) {\n        struct collect collect;\n        darray_init(collect.sym_interprets);\n\n        /* Most specific to least specific. */\n        CopyInterps(info, true, MATCH_EXACTLY, &collect);\n        CopyInterps(info, true, MATCH_ALL, &collect);\n        CopyInterps(info, true, MATCH_NONE, &collect);\n        CopyInterps(info, true, MATCH_ANY, &collect);\n        CopyInterps(info, true, MATCH_ANY_OR_NONE, &collect);\n        CopyInterps(info, false, MATCH_EXACTLY, &collect);\n        CopyInterps(info, false, MATCH_ALL, &collect);\n        CopyInterps(info, false, MATCH_NONE, &collect);\n        CopyInterps(info, false, MATCH_ANY, &collect);\n        CopyInterps(info, false, MATCH_ANY_OR_NONE, &collect);\n\n        darray_steal(collect.sym_interprets,\n                     &keymap->sym_interprets, &keymap->num_sym_interprets);\n    }\n\n    CopyLedMapDefsToKeymap(keymap, info);\n\n    return true;\n}\n\nbool\nCompileCompatMap(XkbFile *file, struct xkb_keymap *keymap,\n                 enum merge_mode merge)\n{\n    CompatInfo info;\n    ActionsInfo *actions;\n\n    actions = NewActionsInfo();\n    if (!actions)\n        return false;\n\n    InitCompatInfo(&info, keymap->ctx, actions, &keymap->mods);\n    info.default_interp.merge = merge;\n    info.default_led.merge = merge;\n\n    HandleCompatMapFile(&info, file, merge);\n    if (info.errorCount != 0)\n        goto err_info;\n\n    if (!CopyCompatToKeymap(keymap, &info))\n        goto err_info;\n\n    ClearCompatInfo(&info);\n    FreeActionsInfo(actions);\n    return true;\n\nerr_info:\n    ClearCompatInfo(&info);\n    FreeActionsInfo(actions);\n    return false;\n}\n"], "fixing_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n/*\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n#include \"xkbcomp-priv.h\"\n#include \"text.h\"\n#include \"expr.h\"\n#include \"action.h\"\n#include \"vmod.h\"\n#include \"include.h\"\n\nenum si_field {\n    SI_FIELD_VIRTUAL_MOD = (1 << 0),\n    SI_FIELD_ACTION = (1 << 1),\n    SI_FIELD_AUTO_REPEAT = (1 << 2),\n    SI_FIELD_LEVEL_ONE_ONLY = (1 << 3),\n};\n\ntypedef struct {\n    enum si_field defined;\n    enum merge_mode merge;\n\n    struct xkb_sym_interpret interp;\n} SymInterpInfo;\n\nenum led_field {\n    LED_FIELD_MODS = (1 << 0),\n    LED_FIELD_GROUPS = (1 << 1),\n    LED_FIELD_CTRLS = (1 << 2),\n};\n\ntypedef struct {\n    enum led_field defined;\n    enum merge_mode merge;\n\n    struct xkb_led led;\n} LedInfo;\n\ntypedef struct {\n    char *name;\n    int errorCount;\n    SymInterpInfo default_interp;\n    darray(SymInterpInfo) interps;\n    LedInfo default_led;\n    LedInfo leds[XKB_MAX_LEDS];\n    unsigned int num_leds;\n    ActionsInfo *actions;\n    struct xkb_mod_set mods;\n\n    struct xkb_context *ctx;\n} CompatInfo;\n\nstatic const char *\nsiText(SymInterpInfo *si, CompatInfo *info)\n{\n    char *buf = xkb_context_get_buffer(info->ctx, 128);\n\n    if (si == &info->default_interp)\n        return \"default\";\n\n    snprintf(buf, 128, \"%s+%s(%s)\",\n             KeysymText(info->ctx, si->interp.sym),\n             SIMatchText(si->interp.match),\n             ModMaskText(info->ctx, &info->mods, si->interp.mods));\n\n    return buf;\n}\n\nstatic inline bool\nReportSINotArray(CompatInfo *info, SymInterpInfo *si, const char *field)\n{\n    return ReportNotArray(info->ctx, \"symbol interpretation\", field,\n                          siText(si, info));\n}\n\nstatic inline bool\nReportSIBadType(CompatInfo *info, SymInterpInfo *si, const char *field,\n                const char *wanted)\n{\n    return ReportBadType(info->ctx, \"symbol interpretation\", field,\n                         siText(si, info), wanted);\n}\n\nstatic inline bool\nReportLedBadType(CompatInfo *info, LedInfo *ledi, const char *field,\n                 const char *wanted)\n{\n    return ReportBadType(info->ctx, \"indicator map\", field,\n                         xkb_atom_text(info->ctx, ledi->led.name),\n                         wanted);\n}\n\nstatic inline bool\nReportLedNotArray(CompatInfo *info, LedInfo *ledi, const char *field)\n{\n    return ReportNotArray(info->ctx, \"indicator map\", field,\n                          xkb_atom_text(info->ctx, ledi->led.name));\n}\n\nstatic void\nInitCompatInfo(CompatInfo *info, struct xkb_context *ctx,\n               ActionsInfo *actions, const struct xkb_mod_set *mods)\n{\n    memset(info, 0, sizeof(*info));\n    info->ctx = ctx;\n    info->actions = actions;\n    info->mods = *mods;\n    info->default_interp.merge = MERGE_OVERRIDE;\n    info->default_interp.interp.virtual_mod = XKB_MOD_INVALID;\n    info->default_led.merge = MERGE_OVERRIDE;\n}\n\nstatic void\nClearCompatInfo(CompatInfo *info)\n{\n    free(info->name);\n    darray_free(info->interps);\n}\n\nstatic SymInterpInfo *\nFindMatchingInterp(CompatInfo *info, SymInterpInfo *new)\n{\n    SymInterpInfo *old;\n\n    darray_foreach(old, info->interps)\n        if (old->interp.sym == new->interp.sym &&\n            old->interp.mods == new->interp.mods &&\n            old->interp.match == new->interp.match)\n            return old;\n\n    return NULL;\n}\n\nstatic bool\nUseNewInterpField(enum si_field field, SymInterpInfo *old, SymInterpInfo *new,\n                  bool report, enum si_field *collide)\n{\n    if (!(old->defined & field))\n        return true;\n\n    if (new->defined & field) {\n        if (report)\n            *collide |= field;\n\n        if (new->merge != MERGE_AUGMENT)\n            return true;\n    }\n\n    return false;\n}\n\nstatic bool\nAddInterp(CompatInfo *info, SymInterpInfo *new, bool same_file)\n{\n    SymInterpInfo *old = FindMatchingInterp(info, new);\n    if (old) {\n        const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n        const bool report = (same_file && verbosity > 0) || verbosity > 9;\n        enum si_field collide = 0;\n\n        if (new->merge == MERGE_REPLACE) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Multiple definitions for \\\"%s\\\"; \"\n                         \"Earlier interpretation ignored\\n\",\n                         siText(new, info));\n            *old = *new;\n            return true;\n        }\n\n        if (UseNewInterpField(SI_FIELD_VIRTUAL_MOD, old, new, report,\n                              &collide)) {\n            old->interp.virtual_mod = new->interp.virtual_mod;\n            old->defined |= SI_FIELD_VIRTUAL_MOD;\n        }\n        if (UseNewInterpField(SI_FIELD_ACTION, old, new, report,\n                              &collide)) {\n            old->interp.action = new->interp.action;\n            old->defined |= SI_FIELD_ACTION;\n        }\n        if (UseNewInterpField(SI_FIELD_AUTO_REPEAT, old, new, report,\n                              &collide)) {\n            old->interp.repeat = new->interp.repeat;\n            old->defined |= SI_FIELD_AUTO_REPEAT;\n        }\n        if (UseNewInterpField(SI_FIELD_LEVEL_ONE_ONLY, old, new, report,\n                              &collide)) {\n            old->interp.level_one_only = new->interp.level_one_only;\n            old->defined |= SI_FIELD_LEVEL_ONE_ONLY;\n        }\n\n        if (collide) {\n            log_warn(info->ctx,\n                     \"Multiple interpretations of \\\"%s\\\"; \"\n                     \"Using %s definition for duplicate fields\\n\",\n                     siText(new, info),\n                     (new->merge != MERGE_AUGMENT ? \"last\" : \"first\"));\n        }\n\n        return true;\n    }\n\n    darray_append(info->interps, *new);\n    return true;\n}\n\n/***====================================================================***/\n\nstatic bool\nResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n            !expr->action.args) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}\n\n/***====================================================================***/\n\nstatic bool\nUseNewLEDField(enum led_field field, LedInfo *old, LedInfo *new,\n               bool report, enum led_field *collide)\n{\n    if (!(old->defined & field))\n        return true;\n\n    if (new->defined & field) {\n        if (report)\n            *collide |= field;\n\n        if (new->merge != MERGE_AUGMENT)\n            return true;\n    }\n\n    return false;\n}\n\nstatic bool\nAddLedMap(CompatInfo *info, LedInfo *new, bool same_file)\n{\n    enum led_field collide;\n    const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n    const bool report = (same_file && verbosity > 0) || verbosity > 9;\n\n    for (xkb_led_index_t i = 0; i < info->num_leds; i++) {\n        LedInfo *old = &info->leds[i];\n\n        if (old->led.name != new->led.name)\n            continue;\n\n        if (old->led.mods.mods == new->led.mods.mods &&\n            old->led.groups == new->led.groups &&\n            old->led.ctrls == new->led.ctrls &&\n            old->led.which_mods == new->led.which_mods &&\n            old->led.which_groups == new->led.which_groups) {\n            old->defined |= new->defined;\n            return true;\n        }\n\n        if (new->merge == MERGE_REPLACE) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Map for indicator %s redefined; \"\n                         \"Earlier definition ignored\\n\",\n                         xkb_atom_text(info->ctx, old->led.name));\n            *old = *new;\n            return true;\n        }\n\n        collide = 0;\n        if (UseNewLEDField(LED_FIELD_MODS, old, new, report, &collide)) {\n            old->led.which_mods = new->led.which_mods;\n            old->led.mods = new->led.mods;\n            old->defined |= LED_FIELD_MODS;\n        }\n        if (UseNewLEDField(LED_FIELD_GROUPS, old, new, report, &collide)) {\n            old->led.which_groups = new->led.which_groups;\n            old->led.groups = new->led.groups;\n            old->defined |= LED_FIELD_GROUPS;\n        }\n        if (UseNewLEDField(LED_FIELD_CTRLS, old, new, report, &collide)) {\n            old->led.ctrls = new->led.ctrls;\n            old->defined |= LED_FIELD_CTRLS;\n        }\n\n        if (collide) {\n            log_warn(info->ctx,\n                     \"Map for indicator %s redefined; \"\n                     \"Using %s definition for duplicate fields\\n\",\n                     xkb_atom_text(info->ctx, old->led.name),\n                     (new->merge == MERGE_AUGMENT ? \"first\" : \"last\"));\n        }\n\n        return true;\n    }\n\n    if (info->num_leds >= XKB_MAX_LEDS) {\n        log_err(info->ctx,\n                \"Too many LEDs defined (maximum %d)\\n\",\n                XKB_MAX_LEDS);\n        return false;\n    }\n    info->leds[info->num_leds++] = *new;\n    return true;\n}\n\nstatic void\nMergeIncludedCompatMaps(CompatInfo *into, CompatInfo *from,\n                        enum merge_mode merge)\n{\n    if (from->errorCount > 0) {\n        into->errorCount += from->errorCount;\n        return;\n    }\n\n    into->mods = from->mods;\n\n    if (into->name == NULL) {\n        into->name = from->name;\n        from->name = NULL;\n    }\n\n    if (darray_empty(into->interps)) {\n        into->interps = from->interps;\n        darray_init(from->interps);\n    }\n    else {\n        SymInterpInfo *si;\n        darray_foreach(si, from->interps) {\n            si->merge = (merge == MERGE_DEFAULT ? si->merge : merge);\n            if (!AddInterp(into, si, false))\n                into->errorCount++;\n        }\n    }\n\n    if (into->num_leds == 0) {\n        memcpy(into->leds, from->leds, sizeof(*from->leds) * from->num_leds);\n        into->num_leds = from->num_leds;\n        from->num_leds = 0;\n    }\n    else {\n        for (xkb_led_index_t i = 0; i < from->num_leds; i++) {\n            LedInfo *ledi = &from->leds[i];\n            ledi->merge = (merge == MERGE_DEFAULT ? ledi->merge : merge);\n            if (!AddLedMap(into, ledi, false))\n                into->errorCount++;\n        }\n    }\n}\n\nstatic void\nHandleCompatMapFile(CompatInfo *info, XkbFile *file, enum merge_mode merge);\n\nstatic bool\nHandleIncludeCompatMap(CompatInfo *info, IncludeStmt *include)\n{\n    CompatInfo included;\n\n    InitCompatInfo(&included, info->ctx, info->actions, &info->mods);\n    included.name = include->stmt;\n    include->stmt = NULL;\n\n    for (IncludeStmt *stmt = include; stmt; stmt = stmt->next_incl) {\n        CompatInfo next_incl;\n        XkbFile *file;\n\n        file = ProcessIncludeFile(info->ctx, stmt, FILE_TYPE_COMPAT);\n        if (!file) {\n            info->errorCount += 10;\n            ClearCompatInfo(&included);\n            return false;\n        }\n\n        InitCompatInfo(&next_incl, info->ctx, info->actions, &included.mods);\n        next_incl.default_interp = info->default_interp;\n        next_incl.default_interp.merge = stmt->merge;\n        next_incl.default_led = info->default_led;\n        next_incl.default_led.merge = stmt->merge;\n\n        HandleCompatMapFile(&next_incl, file, MERGE_OVERRIDE);\n\n        MergeIncludedCompatMaps(&included, &next_incl, stmt->merge);\n\n        ClearCompatInfo(&next_incl);\n        FreeXkbFile(file);\n    }\n\n    MergeIncludedCompatMaps(info, &included, include->merge);\n    ClearCompatInfo(&included);\n\n    return (info->errorCount == 0);\n}\n\nstatic bool\nSetInterpField(CompatInfo *info, SymInterpInfo *si, const char *field,\n               ExprDef *arrayNdx, ExprDef *value)\n{\n    xkb_mod_index_t ndx;\n\n    if (istreq(field, \"action\")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!HandleActionDef(info->ctx, info->actions, &info->mods,\n                             value, &si->interp.action))\n            return false;\n\n        si->defined |= SI_FIELD_ACTION;\n    }\n    else if (istreq(field, \"virtualmodifier\") ||\n             istreq(field, \"virtualmod\")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveMod(info->ctx, value, MOD_VIRT, &info->mods, &ndx))\n            return ReportSIBadType(info, si, field, \"virtual modifier\");\n\n        si->interp.virtual_mod = ndx;\n        si->defined |= SI_FIELD_VIRTUAL_MOD;\n    }\n    else if (istreq(field, \"repeat\")) {\n        bool set;\n\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveBoolean(info->ctx, value, &set))\n            return ReportSIBadType(info, si, field, \"boolean\");\n\n        si->interp.repeat = set;\n\n        si->defined |= SI_FIELD_AUTO_REPEAT;\n    }\n    else if (istreq(field, \"locking\")) {\n        log_dbg(info->ctx,\n                \"The \\\"locking\\\" field in symbol interpretation is unsupported; \"\n                \"Ignored\\n\");\n    }\n    else if (istreq(field, \"usemodmap\") ||\n             istreq(field, \"usemodmapmods\")) {\n        unsigned int val;\n\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveEnum(info->ctx, value, &val, useModMapValueNames))\n            return ReportSIBadType(info, si, field, \"level specification\");\n\n        si->interp.level_one_only = val;\n        si->defined |= SI_FIELD_LEVEL_ONE_ONLY;\n    }\n    else {\n        return ReportBadField(info->ctx, \"symbol interpretation\", field,\n                              siText(si, info));\n    }\n\n    return true;\n}\n\nstatic bool\nSetLedMapField(CompatInfo *info, LedInfo *ledi, const char *field,\n               ExprDef *arrayNdx, ExprDef *value)\n{\n    bool ok = true;\n\n    if (istreq(field, \"modifiers\") || istreq(field, \"mods\")) {\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveModMask(info->ctx, value, MOD_BOTH,\n                                &info->mods, &ledi->led.mods.mods))\n            return ReportLedBadType(info, ledi, field, \"modifier mask\");\n\n        ledi->defined |= LED_FIELD_MODS;\n    }\n    else if (istreq(field, \"groups\")) {\n        unsigned int mask;\n\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveMask(info->ctx, value, &mask, groupMaskNames))\n            return ReportLedBadType(info, ledi, field, \"group mask\");\n\n        ledi->led.groups = mask;\n        ledi->defined |= LED_FIELD_GROUPS;\n    }\n    else if (istreq(field, \"controls\") || istreq(field, \"ctrls\")) {\n        unsigned int mask;\n\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveMask(info->ctx, value, &mask, ctrlMaskNames))\n            return ReportLedBadType(info, ledi, field, \"controls mask\");\n\n        ledi->led.ctrls = mask;\n        ledi->defined |= LED_FIELD_CTRLS;\n    }\n    else if (istreq(field, \"allowexplicit\")) {\n        log_dbg(info->ctx,\n                \"The \\\"allowExplicit\\\" field in indicator statements is unsupported; \"\n                \"Ignored\\n\");\n    }\n    else if (istreq(field, \"whichmodstate\") ||\n             istreq(field, \"whichmodifierstate\")) {\n        unsigned int mask;\n\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveMask(info->ctx, value, &mask,\n                             modComponentMaskNames))\n            return ReportLedBadType(info, ledi, field,\n                                    \"mask of modifier state components\");\n\n        ledi->led.which_mods = mask;\n    }\n    else if (istreq(field, \"whichgroupstate\")) {\n        unsigned mask;\n\n        if (arrayNdx)\n            return ReportLedNotArray(info, ledi, field);\n\n        if (!ExprResolveMask(info->ctx, value, &mask,\n                             groupComponentMaskNames))\n            return ReportLedBadType(info, ledi, field,\n                                    \"mask of group state components\");\n\n        ledi->led.which_groups = mask;\n    }\n    else if (istreq(field, \"driveskbd\") ||\n             istreq(field, \"driveskeyboard\") ||\n             istreq(field, \"leddriveskbd\") ||\n             istreq(field, \"leddriveskeyboard\") ||\n             istreq(field, \"indicatordriveskbd\") ||\n             istreq(field, \"indicatordriveskeyboard\")) {\n        log_dbg(info->ctx,\n                \"The \\\"%s\\\" field in indicator statements is unsupported; \"\n                \"Ignored\\n\", field);\n    }\n    else if (istreq(field, \"index\")) {\n        /* Users should see this, it might cause unexpected behavior. */\n        log_err(info->ctx,\n                \"The \\\"index\\\" field in indicator statements is unsupported; \"\n                \"Ignored\\n\");\n    }\n    else {\n        log_err(info->ctx,\n                \"Unknown field %s in map for %s indicator; \"\n                \"Definition ignored\\n\",\n                field, xkb_atom_text(info->ctx, ledi->led.name));\n        ok = false;\n    }\n\n    return ok;\n}\n\nstatic bool\nHandleGlobalVar(CompatInfo *info, VarDef *stmt)\n{\n    const char *elem, *field;\n    ExprDef *ndx;\n    bool ret;\n\n    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx))\n        ret = false;\n    else if (elem && istreq(elem, \"interpret\"))\n        ret = SetInterpField(info, &info->default_interp, field, ndx,\n                             stmt->value);\n    else if (elem && istreq(elem, \"indicator\"))\n        ret = SetLedMapField(info, &info->default_led, field, ndx,\n                             stmt->value);\n    else\n        ret = SetActionField(info->ctx, info->actions, &info->mods,\n                             elem, field, ndx, stmt->value);\n    return ret;\n}\n\nstatic bool\nHandleInterpBody(CompatInfo *info, VarDef *def, SymInterpInfo *si)\n{\n    bool ok = true;\n    const char *elem, *field;\n    ExprDef *arrayNdx;\n\n    for (; def; def = (VarDef *) def->common.next) {\n        if (def->name && def->name->expr.op == EXPR_FIELD_REF) {\n            log_err(info->ctx,\n                    \"Cannot set a global default value from within an interpret statement; \"\n                    \"Move statements to the global file scope\\n\");\n            ok = false;\n            continue;\n        }\n\n        ok = ExprResolveLhs(info->ctx, def->name, &elem, &field, &arrayNdx);\n        if (!ok)\n            continue;\n\n        ok = SetInterpField(info, si, field, arrayNdx, def->value);\n    }\n\n    return ok;\n}\n\nstatic bool\nHandleInterpDef(CompatInfo *info, InterpDef *def, enum merge_mode merge)\n{\n    enum xkb_match_operation pred;\n    xkb_mod_mask_t mods;\n    SymInterpInfo si;\n\n    if (!ResolveStateAndPredicate(def->match, &pred, &mods, info)) {\n        log_err(info->ctx,\n                \"Couldn't determine matching modifiers; \"\n                \"Symbol interpretation ignored\\n\");\n        return false;\n    }\n\n    si = info->default_interp;\n    si.merge = merge = (def->merge == MERGE_DEFAULT ? merge : def->merge);\n    si.interp.sym = def->sym;\n    si.interp.match = pred;\n    si.interp.mods = mods;\n\n    if (!HandleInterpBody(info, def->def, &si)) {\n        info->errorCount++;\n        return false;\n    }\n\n    if (!AddInterp(info, &si, true)) {\n        info->errorCount++;\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool\nHandleLedMapDef(CompatInfo *info, LedMapDef *def, enum merge_mode merge)\n{\n    LedInfo ledi;\n    VarDef *var;\n    bool ok;\n\n    if (def->merge != MERGE_DEFAULT)\n        merge = def->merge;\n\n    ledi = info->default_led;\n    ledi.merge = merge;\n    ledi.led.name = def->name;\n\n    ok = true;\n    for (var = def->body; var != NULL; var = (VarDef *) var->common.next) {\n        const char *elem, *field;\n        ExprDef *arrayNdx;\n        if (!ExprResolveLhs(info->ctx, var->name, &elem, &field, &arrayNdx)) {\n            ok = false;\n            continue;\n        }\n\n        if (elem) {\n            log_err(info->ctx,\n                    \"Cannot set defaults for \\\"%s\\\" element in indicator map; \"\n                    \"Assignment to %s.%s ignored\\n\", elem, elem, field);\n            ok = false;\n        }\n        else {\n            ok = SetLedMapField(info, &ledi, field, arrayNdx, var->value) && ok;\n        }\n    }\n\n    if (ok)\n        return AddLedMap(info, &ledi, true);\n\n    return false;\n}\n\nstatic void\nHandleCompatMapFile(CompatInfo *info, XkbFile *file, enum merge_mode merge)\n{\n    bool ok;\n\n    merge = (merge == MERGE_DEFAULT ? MERGE_AUGMENT : merge);\n\n    free(info->name);\n    info->name = strdup_safe(file->name);\n\n    for (ParseCommon *stmt = file->defs; stmt; stmt = stmt->next) {\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            ok = HandleIncludeCompatMap(info, (IncludeStmt *) stmt);\n            break;\n        case STMT_INTERP:\n            ok = HandleInterpDef(info, (InterpDef *) stmt, merge);\n            break;\n        case STMT_GROUP_COMPAT:\n            log_dbg(info->ctx,\n                    \"The \\\"group\\\" statement in compat is unsupported; \"\n                    \"Ignored\\n\");\n            ok = true;\n            break;\n        case STMT_LED_MAP:\n            ok = HandleLedMapDef(info, (LedMapDef *) stmt, merge);\n            break;\n        case STMT_VAR:\n            ok = HandleGlobalVar(info, (VarDef *) stmt);\n            break;\n        case STMT_VMOD:\n            ok = HandleVModDef(info->ctx, &info->mods, (VModDef *) stmt, merge);\n            break;\n        default:\n            log_err(info->ctx,\n                    \"Compat files may not include other types; \"\n                    \"Ignoring %s\\n\", stmt_type_to_string(stmt->type));\n            ok = false;\n            break;\n        }\n\n        if (!ok)\n            info->errorCount++;\n\n        if (info->errorCount > 10) {\n            log_err(info->ctx,\n                    \"Abandoning compatibility map \\\"%s\\\"\\n\", file->name);\n            break;\n        }\n    }\n}\n\n/* Temporary struct for CopyInterps. */\nstruct collect {\n    darray(struct xkb_sym_interpret) sym_interprets;\n};\n\nstatic void\nCopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,\n            struct collect *collect)\n{\n    SymInterpInfo *si;\n\n    darray_foreach(si, info->interps)\n        if (si->interp.match == pred &&\n            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)\n            darray_append(collect->sym_interprets, si->interp);\n}\n\nstatic void\nCopyLedMapDefsToKeymap(struct xkb_keymap *keymap, CompatInfo *info)\n{\n    for (xkb_led_index_t idx = 0; idx < info->num_leds; idx++) {\n        LedInfo *ledi = &info->leds[idx];\n        xkb_led_index_t i;\n        struct xkb_led *led;\n\n        /*\n         * Find the LED with the given name, if it was already declared\n         * in keycodes.\n         */\n        xkb_leds_enumerate(i, led, keymap)\n            if (led->name == ledi->led.name)\n                break;\n\n        /* Not previously declared; create it with next free index. */\n        if (i >= keymap->num_leds) {\n            log_dbg(keymap->ctx,\n                    \"Indicator name \\\"%s\\\" was not declared in the keycodes section; \"\n                    \"Adding new indicator\\n\",\n                    xkb_atom_text(keymap->ctx, ledi->led.name));\n\n            xkb_leds_enumerate(i, led, keymap)\n                if (led->name == XKB_ATOM_NONE)\n                    break;\n\n            if (i >= keymap->num_leds) {\n                /* Not place to put it; ignore. */\n                if (i >= XKB_MAX_LEDS) {\n                    log_err(keymap->ctx,\n                            \"Too many indicators (maximum is %d); \"\n                            \"Indicator name \\\"%s\\\" ignored\\n\",\n                            XKB_MAX_LEDS,\n                            xkb_atom_text(keymap->ctx, ledi->led.name));\n                    continue;\n                }\n\n                /* Add a new LED. */\n                led = &keymap->leds[keymap->num_leds++];\n            }\n        }\n\n        *led = ledi->led;\n        if (led->groups != 0 && led->which_groups == 0)\n            led->which_groups = XKB_STATE_LAYOUT_EFFECTIVE;\n        if (led->mods.mods != 0 && led->which_mods == 0)\n            led->which_mods = XKB_STATE_MODS_EFFECTIVE;\n    }\n}\n\nstatic bool\nCopyCompatToKeymap(struct xkb_keymap *keymap, CompatInfo *info)\n{\n    keymap->compat_section_name = strdup_safe(info->name);\n    XkbEscapeMapName(keymap->compat_section_name);\n\n    keymap->mods = info->mods;\n\n    if (!darray_empty(info->interps)) {\n        struct collect collect;\n        darray_init(collect.sym_interprets);\n\n        /* Most specific to least specific. */\n        CopyInterps(info, true, MATCH_EXACTLY, &collect);\n        CopyInterps(info, true, MATCH_ALL, &collect);\n        CopyInterps(info, true, MATCH_NONE, &collect);\n        CopyInterps(info, true, MATCH_ANY, &collect);\n        CopyInterps(info, true, MATCH_ANY_OR_NONE, &collect);\n        CopyInterps(info, false, MATCH_EXACTLY, &collect);\n        CopyInterps(info, false, MATCH_ALL, &collect);\n        CopyInterps(info, false, MATCH_NONE, &collect);\n        CopyInterps(info, false, MATCH_ANY, &collect);\n        CopyInterps(info, false, MATCH_ANY_OR_NONE, &collect);\n\n        darray_steal(collect.sym_interprets,\n                     &keymap->sym_interprets, &keymap->num_sym_interprets);\n    }\n\n    CopyLedMapDefsToKeymap(keymap, info);\n\n    return true;\n}\n\nbool\nCompileCompatMap(XkbFile *file, struct xkb_keymap *keymap,\n                 enum merge_mode merge)\n{\n    CompatInfo info;\n    ActionsInfo *actions;\n\n    actions = NewActionsInfo();\n    if (!actions)\n        return false;\n\n    InitCompatInfo(&info, keymap->ctx, actions, &keymap->mods);\n    info.default_interp.merge = merge;\n    info.default_led.merge = merge;\n\n    HandleCompatMapFile(&info, file, merge);\n    if (info.errorCount != 0)\n        goto err_info;\n\n    if (!CopyCompatToKeymap(keymap, &info))\n        goto err_info;\n\n    ClearCompatInfo(&info);\n    FreeActionsInfo(actions);\n    return true;\n\nerr_info:\n    ClearCompatInfo(&info);\n    FreeActionsInfo(actions);\n    return false;\n}\n"], "filenames": ["src/xkbcomp/compat.c"], "buggy_code_start_loc": [267], "buggy_code_end_loc": [268], "fixing_code_start_loc": [267], "fixing_code_end_loc": [269], "type": "CWE-476", "message": "Unchecked NULL pointer usage in ResolveStateAndPredicate in xkbcomp/compat.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with a no-op modmask expression.", "other": {"cve": {"id": "CVE-2018-15863", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-25T21:29:02.483", "lastModified": "2019-08-06T17:15:25.947", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Unchecked NULL pointer usage in ResolveStateAndPredicate in xkbcomp/compat.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with a no-op modmask expression."}, {"lang": "es", "value": "El uso de un puntero NULL no verificado en ResolveStateAndPredicate en xkbcomp/compat.c en xkbcommon, en versiones anteriores a la 0.8.2, podr\u00eda ser aprovechado por atacantes locales para provocar el cierre inesperado (desreferencia de puntero NULL) del analizador xkbcommon proporcionando un archivo keymap manipulado con una expresi\u00f3n modmask no-op."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:libxkbcommon:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8.1", "matchCriteriaId": "4B6764BA-E4C4-4657-B0B4-98C694C96632"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:xkbcommon:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8.1", "matchCriteriaId": "BEDDC322-0FA8-4907-A4E1-000BCCBECEFD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2079", "source": "cve@mitre.org"}, {"url": "https://github.com/xkbcommon/libxkbcommon/commit/96df3106d49438e442510c59acad306e94f3db4d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.freedesktop.org/archives/wayland-devel/2018-August/039243.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/96df3106d49438e442510c59acad306e94f3db4d"}}