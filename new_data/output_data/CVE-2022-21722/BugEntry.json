{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/rtcp.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/event.h>\n#include <pjmedia/rtcp_fb.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n#define THIS_FILE \"rtcp.c\"\n\n#define RTCP_SR   200\n#define RTCP_RR   201\n#define RTCP_SDES 202\n#define RTCP_BYE  203\n#define RTCP_XR   207\n\n/* RTCP Feedbacks */\n#define RTCP_RTPFB\t205\n#define RTCP_PSFB\t206\n\nenum {\n    RTCP_SDES_NULL  = 0,\n    RTCP_SDES_CNAME = 1,\n    RTCP_SDES_NAME  = 2,\n    RTCP_SDES_EMAIL = 3,\n    RTCP_SDES_PHONE = 4,\n    RTCP_SDES_LOC   = 5,\n    RTCP_SDES_TOOL  = 6,\n    RTCP_SDES_NOTE  = 7\n};\n\n#if PJ_HAS_HIGH_RES_TIMER==0\n#   error \"High resolution timer needs to be enabled\"\n#endif\n\n\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(3,x)\n#else\n#   define TRACE_(x)\t;\n#endif\n\n\n/*\n * Get NTP time.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_get_ntp_time(const pjmedia_rtcp_session *sess,\n\t\t\t\t\t      pjmedia_rtcp_ntp_rec *ntp)\n{\n/* Seconds between 1900-01-01 to 1970-01-01 */\n#define JAN_1970  (2208988800UL)\n    pj_timestamp ts;\n    pj_status_t status;\n\n    status = pj_get_timestamp(&ts);\n\n    /* Fill up the high 32bit part */\n    ntp->hi = (pj_uint32_t)((ts.u64 - sess->ts_base.u64) / sess->ts_freq.u64)\n\t      + sess->tv_base.sec + JAN_1970;\n\n    /* Calculate seconds fractions */\n    ts.u64 = (ts.u64 - sess->ts_base.u64) % sess->ts_freq.u64;\n    pj_assert(ts.u64 < sess->ts_freq.u64);\n    ts.u64 = (ts.u64 << 32) / sess->ts_freq.u64;\n\n    /* Fill up the low 32bit part */\n    ntp->lo = ts.u32.lo;\n\n\n#if (defined(PJ_WIN32) && PJ_WIN32!=0) || \\\n    (defined(PJ_WIN64) && PJ_WIN64!=0) || \\\n    (defined(PJ_WIN32_WINCE) && PJ_WIN32_WINCE!=0)\n\n    /* On Win32, since we use QueryPerformanceCounter() as the backend\n     * timestamp API, we need to protect against this bug:\n     *   Performance counter value may unexpectedly leap forward\n     *   http://support.microsoft.com/default.aspx?scid=KB;EN-US;Q274323\n     */\n    {\n\t/*\n\t * Compare elapsed time reported by timestamp with actual elapsed \n\t * time. If the difference is too excessive, then we use system\n\t * time instead.\n\t */\n\n\t/* MIN_DIFF needs to be large enough so that \"normal\" diff caused\n\t * by system activity or context switch doesn't trigger the time\n\t * correction.\n\t */\n\tenum { MIN_DIFF = 400 };\n\n\tpj_time_val ts_time, elapsed, diff;\n\n\tpj_gettimeofday(&elapsed);\n\n\tts_time.sec = ntp->hi - sess->tv_base.sec - JAN_1970;\n\tts_time.msec = (long)(ntp->lo * 1000.0 / 0xFFFFFFFF);\n\n\tPJ_TIME_VAL_SUB(elapsed, sess->tv_base);\n\n\tif (PJ_TIME_VAL_LT(ts_time, elapsed)) {\n\t    diff = elapsed;\n\t    PJ_TIME_VAL_SUB(diff, ts_time);\n\t} else {\n\t    diff = ts_time;\n\t    PJ_TIME_VAL_SUB(diff, elapsed);\n\t}\n\n\tif (PJ_TIME_VAL_MSEC(diff) >= MIN_DIFF) {\n\n\t    TRACE_((sess->name, \"RTCP NTP timestamp corrected by %d ms\",\n\t\t    PJ_TIME_VAL_MSEC(diff)));\n\n\n\t    ntp->hi = elapsed.sec + sess->tv_base.sec + JAN_1970;\n\t    ntp->lo = (elapsed.msec * 65536 / 1000) << 16;\n\t}\n\n    }\n#endif\n\n    return status;\n}\n\n\n/*\n * Initialize RTCP session setting.\n */\nPJ_DEF(void) pjmedia_rtcp_session_setting_default(\n\t\t\t\t    pjmedia_rtcp_session_setting *settings)\n{\n    pj_bzero(settings, sizeof(*settings));\n}\n\n\n/*\n * Initialize bidirectional RTCP statistics.\n *\n */\nPJ_DEF(void) pjmedia_rtcp_init_stat(pjmedia_rtcp_stat *stat)\n{\n    pj_time_val now;\n\n    pj_assert(stat);\n\n    pj_bzero(stat, sizeof(pjmedia_rtcp_stat));\n\n    pj_math_stat_init(&stat->rtt);\n    pj_math_stat_init(&stat->rx.loss_period);\n    pj_math_stat_init(&stat->rx.jitter);\n    pj_math_stat_init(&stat->tx.loss_period);\n    pj_math_stat_init(&stat->tx.jitter);\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_IPDV) && PJMEDIA_RTCP_STAT_HAS_IPDV!=0\n    pj_math_stat_init(&stat->rx_ipdv);\n#endif\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_RAW_JITTER) && PJMEDIA_RTCP_STAT_HAS_RAW_JITTER!=0\n    pj_math_stat_init(&stat->rx_raw_jitter);\n#endif\n\n    pj_gettimeofday(&now);\n    stat->start = now;\n}\n\n\n/*\n * Initialize RTCP session.\n */\nPJ_DEF(void) pjmedia_rtcp_init(pjmedia_rtcp_session *sess, \n\t\t\t       char *name,\n\t\t\t       unsigned clock_rate,\n\t\t\t       unsigned samples_per_frame,\n\t\t\t       pj_uint32_t ssrc)\n{\n    pjmedia_rtcp_session_setting settings;\n\n    pjmedia_rtcp_session_setting_default(&settings);\n    settings.name = name;\n    settings.clock_rate = clock_rate;\n    settings.samples_per_frame = samples_per_frame;\n    settings.ssrc = ssrc;\n\n    pjmedia_rtcp_init2(sess, &settings);\n}\n\n\n/*\n * Initialize RTCP session.\n */\nPJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n\t\t\t\t const pjmedia_rtcp_session_setting *settings)\n{\n    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;\n    pj_time_val now;\n    \n    /* Memset everything */\n    pj_bzero(sess, sizeof(pjmedia_rtcp_session));\n\n    /* Last RX timestamp in RTP packet */\n    sess->rtp_last_ts = (unsigned)-1;\n\n    /* Name */\n    sess->name = settings->name ? settings->name : (char*)THIS_FILE;\n\n    /* Set clock rate */\n    sess->clock_rate = settings->clock_rate;\n    sess->pkt_size = settings->samples_per_frame;\n\n    /* Init common RTCP SR header */\n    sr_pkt->common.version = 2;\n    sr_pkt->common.count = 1;\n    sr_pkt->common.pt = RTCP_SR;\n    sr_pkt->common.length = pj_htons(12);\n    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);\n    \n    /* Copy to RTCP RR header */\n    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n    sess->rtcp_rr_pkt.common.length = pj_htons(7);\n\n    /* Get time and timestamp base and frequency */\n    pj_gettimeofday(&now);\n    sess->tv_base = now;\n    pj_get_timestamp(&sess->ts_base);\n    pj_get_timestamp_freq(&sess->ts_freq);\n    sess->rtp_ts_base = settings->rtp_ts_base;\n\n    /* Initialize statistics states */\n    pjmedia_rtcp_init_stat(&sess->stat);\n\n    /* RR will be initialized on receipt of the first RTP packet. */\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_fini(pjmedia_rtcp_session *sess)\n{\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    pjmedia_rtcp_xr_fini(&sess->xr_session);\n#else\n    /* Nothing to do. */\n    PJ_UNUSED_ARG(sess);\n#endif\n}\n\nstatic void rtcp_init_seq(pjmedia_rtcp_session *sess)\n{\n    sess->received = 0;\n    sess->exp_prior = 0;\n    sess->rx_prior = 0;\n    sess->transit = 0;\n    sess->jitter = 0;\n}\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtp( pjmedia_rtcp_session *sess, \n\t\t\t\t  unsigned seq, \n\t\t\t\t  unsigned rtp_ts,\n\t\t\t\t  unsigned payload)\n{\n    pjmedia_rtcp_rx_rtp2(sess, seq, rtp_ts, payload, PJ_FALSE);\n}\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtp2(pjmedia_rtcp_session *sess, \n\t\t\t\t  unsigned seq, \n\t\t\t\t  unsigned rtp_ts,\n\t\t\t\t  unsigned payload,\n\t\t\t\t  pj_bool_t discarded)\n{   \n    pj_timestamp ts;\n    pj_uint32_t arrival;\n    pj_int32_t transit;\n    pjmedia_rtp_status seq_st;\n\n#if !defined(PJMEDIA_HAS_RTCP_XR) || (PJMEDIA_HAS_RTCP_XR == 0)\n    PJ_UNUSED_ARG(discarded);\n#endif\n\n    if (sess->stat.rx.pkt == 0) {\n\t/* Init sequence for the first time. */\n\tpjmedia_rtp_seq_init(&sess->seq_ctrl, (pj_uint16_t)seq);\n    } \n\n    sess->stat.rx.pkt++;\n    sess->stat.rx.bytes += payload;\n\n    /* Process the RTP packet. */\n    pjmedia_rtp_seq_update(&sess->seq_ctrl, (pj_uint16_t)seq, &seq_st);\n\n    if (seq_st.status.flag.restart) {\n\trtcp_init_seq(sess);\n    }\n    \n    if (seq_st.status.flag.dup) {\n\tsess->stat.rx.dup++;\n\tTRACE_((sess->name, \"Duplicate packet detected\"));\n    }\n\n    if (seq_st.status.flag.outorder && !seq_st.status.flag.probation) {\n\tsess->stat.rx.reorder++;\n\tTRACE_((sess->name, \"Out-of-order packet detected\"));\n    }\n\n    if (seq_st.status.flag.bad) {\n\tsess->stat.rx.discard++;\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\tpjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t       -1,\t\t\t\t /* lost    */\n\t\t\t       (seq_st.status.flag.dup? 1:0),\t /* dup     */\n\t\t\t       (!seq_st.status.flag.dup? 1:-1),  /* discard */\n\t\t\t       -1,\t\t\t\t /* jitter  */\n\t\t\t       -1, 0);\t\t\t\t /* toh\t    */\n#endif\n\n\tTRACE_((sess->name, \"Bad packet discarded\"));\n\treturn;\n    }\n\n    /* Only mark \"good\" packets */\n    ++sess->received;\n\n    /* Calculate loss periods. */\n    if (seq_st.diff > 1) {\n\tunsigned count = seq_st.diff - 1;\n\tunsigned period;\n\n\tperiod = count * sess->pkt_size * 1000 / sess->clock_rate;\n\tperiod *= 1000;\n\n\t/* Update packet lost. \n\t * The packet lost number will also be updated when we're sending\n\t * outbound RTCP RR.\n\t */\n\tsess->stat.rx.loss += (seq_st.diff - 1);\n\tTRACE_((sess->name, \"%d packet(s) lost\", seq_st.diff - 1));\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.rx.loss_period, period);\n    }\n\n\n    /*\n     * Calculate jitter only when sequence is good (see RFC 3550 section A.8),\n     * AND only when the timestamp is different than the last packet\n     * (see RTP FAQ).\n     */\n    if (seq_st.diff == 1 && rtp_ts != sess->rtp_last_ts) {\n\t/* Get arrival time and convert timestamp to samples */\n\tpj_get_timestamp(&ts);\n\tts.u64 = ts.u64 * sess->clock_rate / sess->ts_freq.u64;\n\tarrival = ts.u32.lo;\n\n\ttransit = arrival - rtp_ts;\n    \n\t/* Ignore the first N packets as they normally have bad jitter\n\t * due to other threads working to establish the call\n\t */\n\tif (sess->transit == 0 || \n\t    sess->received < PJMEDIA_RTCP_IGNORE_FIRST_PACKETS) \n\t{\n\t    sess->transit = transit;\n\t    sess->stat.rx.jitter.min = (unsigned)-1;\n\t} else {\n\t    pj_int32_t d;\n\t    pj_uint32_t jitter;\n\n\t    d = transit - sess->transit;\n\t    if (d < 0) \n\t\td = -d;\n\t    \n\t    sess->jitter += d - ((sess->jitter + 8) >> 4);\n\n\t    /* Update jitter stat */\n\t    jitter = sess->jitter >> 4;\n\t    \n\t    /* Convert jitter unit from samples to usec */\n\t    if (jitter < 4294)\n\t\tjitter = jitter * 1000000 / sess->clock_rate;\n\t    else {\n\t\tjitter = jitter * 1000 / sess->clock_rate;\n\t\tjitter *= 1000;\n\t    }\n\t    pj_math_stat_update(&sess->stat.rx.jitter, jitter);\n\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_RAW_JITTER) && PJMEDIA_RTCP_STAT_HAS_RAW_JITTER!=0\n\t    {\n\t\tpj_uint32_t raw_jitter;\n\n\t\t/* Convert raw jitter unit from samples to usec */\n\t\tif (d < 4294)\n\t\t    raw_jitter = d * 1000000 / sess->clock_rate;\n\t\telse {\n\t\t    raw_jitter = d * 1000 / sess->clock_rate;\n\t\t    raw_jitter *= 1000;\n\t\t}\n\t\t\n\t\t/* Update jitter stat */\n\t\tpj_math_stat_update(&sess->stat.rx_raw_jitter, raw_jitter);\n\t    }\n#endif\n\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_IPDV) && PJMEDIA_RTCP_STAT_HAS_IPDV!=0\n\t    {\n\t\tpj_int32_t ipdv;\n\n\t\tipdv = transit - sess->transit;\n\t\t/* Convert IPDV unit from samples to usec */\n\t\tif (ipdv > -2147 && ipdv < 2147)\n\t\t    ipdv = ipdv * 1000000 / (int)sess->clock_rate;\n\t\telse {\n\t\t    ipdv = ipdv * 1000 / (int)sess->clock_rate;\n\t\t    ipdv *= 1000;\n\t\t}\n\t\t\n\t\t/* Update jitter stat */\n\t\tpj_math_stat_update(&sess->stat.rx_ipdv, ipdv);\n\t    }\n#endif\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\t    pjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t\t   0,\t\t\t    /* lost    */\n\t\t\t\t   0,\t\t\t    /* dup     */\n\t\t\t\t   discarded,\t\t    /* discard */\n\t\t\t\t   (sess->jitter >> 4),\t    /* jitter  */\n\t\t\t\t   -1, 0);\t\t    /* toh     */\n#endif\n\n\t    /* Update session transit */\n\t    sess->transit = transit;\n\t}\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (seq_st.diff > 1) {\n\tint i;\n\n\t/* Report RTCP XR about packet losses */\n\tfor (i=seq_st.diff-1; i>0; --i) {\n\t    pjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq - i, \n\t\t\t\t   1,\t\t\t    /* lost    */\n\t\t\t\t   0,\t\t\t    /* dup     */\n\t\t\t\t   0,\t\t\t    /* discard */\n\t\t\t\t   -1,\t\t\t    /* jitter  */\n\t\t\t\t   -1, 0);\t\t    /* toh     */\n\t}\n\n\t/* Report RTCP XR this packet */\n\tpjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t       0,\t\t\t    /* lost    */\n\t\t\t       0,\t\t\t    /* dup     */\n\t\t\t       discarded,\t\t    /* discard */\n\t\t\t       -1,\t\t\t    /* jitter  */\n\t\t\t       -1, 0);\t\t\t    /* toh     */\n#endif\n    }\n\n    /* Update timestamp of last RX RTP packet */\n    sess->rtp_last_ts = rtp_ts;\n}\n\nPJ_DEF(void) pjmedia_rtcp_tx_rtp(pjmedia_rtcp_session *sess, \n\t\t\t\t unsigned bytes_payload_size)\n{\n    /* Update statistics */\n    sess->stat.tx.pkt++;\n    sess->stat.tx.bytes += bytes_payload_size;\n}\n\n\nstatic void parse_rtcp_report( pjmedia_rtcp_session *sess,\n\t\t\t       const void *pkt,\n\t\t\t       pj_size_t size)\n{\n    pjmedia_rtcp_common *common = (pjmedia_rtcp_common*) pkt;\n    const pjmedia_rtcp_rr *rr = NULL;\n    const pjmedia_rtcp_sr *sr = NULL;\n    pj_uint32_t last_loss, jitter_samp, jitter;\n\n    /* Parse RTCP */\n    if (common->pt == RTCP_SR) {\n\tsr = (pjmedia_rtcp_sr*) (((char*)pkt) + sizeof(pjmedia_rtcp_common));\n\tif (common->count > 0 && size >= (sizeof(pjmedia_rtcp_sr_pkt))) {\n\t    rr = (pjmedia_rtcp_rr*)(((char*)pkt) + (sizeof(pjmedia_rtcp_common)\n\t\t\t\t    + sizeof(pjmedia_rtcp_sr)));\n\t}\n    } else if (common->pt == RTCP_RR && common->count > 0) {\n\trr = (pjmedia_rtcp_rr*)(((char*)pkt) + sizeof(pjmedia_rtcp_common));\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (common->pt == RTCP_XR) {\n\tif (sess->xr_enabled)\n\t    pjmedia_rtcp_xr_rx_rtcp_xr(&sess->xr_session, pkt, size);\n\n\treturn;\n#endif\n    }\n\n\n    if (sr) {\n\t/* Save LSR from NTP timestamp of RTCP packet */\n\tsess->rx_lsr = ((pj_ntohl(sr->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(sr->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate SR arrival time for DLSR */\n\tpj_get_timestamp(&sess->rx_lsr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", \n\t\tsess->rx_lsr,\n\t\t(pj_uint32_t)(sess->rx_lsr_time.u64*65536/sess->ts_freq.u64)));\n    }\n\n\n    /* Nothing more to do if there's no RR packet */\n    if (rr == NULL)\n\treturn;\n\n\n    last_loss = sess->stat.tx.loss;\n\n    /* Get packet loss */\n    sess->stat.tx.loss = (rr->total_lost_2 << 16) +\n\t\t\t (rr->total_lost_1 << 8) +\n\t\t\t  rr->total_lost_0;\n\n    TRACE_((sess->name, \"Rx RTCP RR: total_lost_2=%x, 1=%x, 0=%x, lost=%d\", \n\t    (int)rr->total_lost_2,\n\t    (int)rr->total_lost_1,\n\t    (int)rr->total_lost_0,\n\t    sess->stat.tx.loss));\n    \n    /* We can't calculate the exact loss period for TX, so just give the\n     * best estimation.\n     */\n    if (sess->stat.tx.loss > last_loss) {\n\tunsigned period;\n\n\t/* Loss period in msec */\n\tperiod = (sess->stat.tx.loss - last_loss) * sess->pkt_size *\n\t\t 1000 / sess->clock_rate;\n\n\t/* Loss period in usec */\n\tperiod *= 1000;\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.tx.loss_period, period);\n    }\n\n    /* Get jitter value in usec */\n    jitter_samp = pj_ntohl(rr->jitter);\n    /* Calculate jitter in usec, avoiding overflows */\n    if (jitter_samp <= 4294)\n\tjitter = jitter_samp * 1000000 / sess->clock_rate;\n    else {\n\tjitter = jitter_samp * 1000 / sess->clock_rate;\n\tjitter *= 1000;\n    }\n\n    /* Update jitter statistics */\n    pj_math_stat_update(&sess->stat.tx.jitter, jitter);\n\n    /* Can only calculate if LSR and DLSR is present in RR */\n    if (rr->lsr && rr->dlsr) {\n\tpj_uint32_t lsr, now, dlsr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LSR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlsr = pj_ntohl(rr->lsr);\n\n\t/* DLSR is delay since LSR, also in 1/65536 resolution */\n\tdlsr = pj_ntohl(rr->dlsr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lsr-dlsr) */\n\teedelay = now - lsr - dlsr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP RR: lsr=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlsr, dlsr, dlsr/65536, (dlsr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lsr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlsr >= lsr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay > 30 * 1000 * 1000UL) {\n\n\t\tTRACE_((sess->name, \"RTT not making any sense, ignored..\"));\n\t\tgoto end_rtt_calc;\n\t    }\n\n#if defined(PJMEDIA_RTCP_NORMALIZE_FACTOR) && PJMEDIA_RTCP_NORMALIZE_FACTOR!=0\n\t    /* \"Normalize\" rtt value that is exceptionally high. For such\n\t     * values, \"normalize\" the rtt to be PJMEDIA_RTCP_NORMALIZE_FACTOR\n\t     * times the average value.\n\t     */\n\t    if (rtt > ((unsigned)sess->stat.rtt.mean *\n\t\t       PJMEDIA_RTCP_NORMALIZE_FACTOR) && sess->stat.rtt.n!=0)\n\t    {\n\t\tunsigned orig_rtt = rtt;\n\t\trtt = sess->stat.rtt.mean * PJMEDIA_RTCP_NORMALIZE_FACTOR;\n\t\tPJ_LOG(5,(sess->name,\n\t\t\t  \"RTT value %d usec is normalized to %d usec\",\n\t\t\t  orig_rtt, rtt));\n\t    }\n#endif\n\t    TRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\n\t    /* Update RTT stat */\n\t    pj_math_stat_update(&sess->stat.rtt, rtt);\n\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lsr=%p, now=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lsr, now, dlsr, dlsr/65536,\n\t\t\t\t   (dlsr%65536)*1000/65536,\n\t\t\t\t   dlsr-(now-lsr)));\n\t}\n    }\n\nend_rtt_calc:\n\n    pj_gettimeofday(&sess->stat.tx.update);\n    sess->stat.tx.update_cnt++;\n}\n\n\nstatic void parse_rtcp_sdes(pjmedia_rtcp_session *sess,\n\t\t\t    const void *pkt,\n\t\t\t    pj_size_t size)\n{\n    pjmedia_rtcp_sdes *sdes = &sess->stat.peer_sdes;\n    char *p, *p_end;\n    char *b, *b_end;\n\n    p = (char*)pkt + 8;\n    p_end = (char*)pkt + size;\n\n    pj_bzero(sdes, sizeof(*sdes));\n    b = sess->stat.peer_sdes_buf_;\n    b_end = b + sizeof(sess->stat.peer_sdes_buf_);\n\n    while (p < p_end) {\n\tpj_uint8_t sdes_type, sdes_len;\n\tpj_str_t sdes_value = {NULL, 0};\n\n\tsdes_type = *p++;\n\n\t/* Check for end of SDES item list */\n\tif (sdes_type == RTCP_SDES_NULL || p == p_end)\n\t    break;\n\n\tsdes_len = *p++;\n\n\t/* Check for corrupted SDES packet */\n\tif (p + sdes_len > p_end)\n\t    break;\n\n\t/* Get SDES item */\n\tif (b + sdes_len < b_end) {\n\t    pj_memcpy(b, p, sdes_len);\n\t    sdes_value.ptr = b;\n\t    sdes_value.slen = sdes_len;\n\t    b += sdes_len;\n\t} else {\n\t    /* Insufficient SDES buffer */\n\t    PJ_LOG(5, (sess->name,\n\t\t    \"Unsufficient buffer to save RTCP SDES type %d:%.*s\",\n\t\t    sdes_type, sdes_len, p));\n\t    p += sdes_len;\n\t    continue;\n\t}\n\n\tswitch (sdes_type) {\n\tcase RTCP_SDES_CNAME:\n\t    sdes->cname = sdes_value;\n\t    break;\n\tcase RTCP_SDES_NAME:\n\t    sdes->name = sdes_value;\n\t    break;\n\tcase RTCP_SDES_EMAIL:\n\t    sdes->email = sdes_value;\n\t    break;\n\tcase RTCP_SDES_PHONE:\n\t    sdes->phone = sdes_value;\n\t    break;\n\tcase RTCP_SDES_LOC:\n\t    sdes->loc = sdes_value;\n\t    break;\n\tcase RTCP_SDES_TOOL:\n\t    sdes->tool = sdes_value;\n\t    break;\n\tcase RTCP_SDES_NOTE:\n\t    sdes->note = sdes_value;\n\t    break;\n\tdefault:\n\t    TRACE_((sess->name, \"Received unknown RTCP SDES type %d:%.*s\",\n\t\t    sdes_type, sdes_value.slen, sdes_value.ptr));\n\t    break;\n\t}\n\n\tp += sdes_len;\n    }\n}\n\n\nstatic void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n\n    /* Check and get BYE reason */\n    if (size > 8) {\n    \t/* Make sure the BYE reason does not exceed:\n    \t * - the size of the available buffer\n    \t * - the declared reason's length\n    \t * - the actual packet size\n    \t */\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n        reason.slen = PJ_MIN(reason.slen, size-9);\n\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n\n    /* Just print RTCP BYE log */\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}\n\n\nstatic void parse_rtcp_fb(pjmedia_rtcp_session *sess,\n\t\t\t  const void *pkt,\n\t\t\t  pj_size_t size)\n{\n    unsigned cnt = 1;\n    pjmedia_rtcp_fb_nack nack[1];\n    //pjmedia_rtcp_fb_sli sli[1];\n    //pjmedia_rtcp_fb_rpsi rpsi;\n    pjmedia_event ev;\n    pj_timestamp ts_now;\n\n    pj_get_timestamp(&ts_now);\n\n    if (pjmedia_rtcp_fb_parse_nack(pkt, size, &cnt, nack)==PJ_SUCCESS)\n    {\n\tpjmedia_event_init(&ev, PJMEDIA_EVENT_RX_RTCP_FB, &ts_now, sess);\n\tev.data.rx_rtcp_fb.cap.type = PJMEDIA_RTCP_FB_NACK;\n\tev.data.rx_rtcp_fb.msg.nack = nack[0];\n\tpjmedia_event_publish(NULL, sess, &ev, 0);\n\n    } else if (pjmedia_rtcp_fb_parse_pli(pkt, size)==PJ_SUCCESS)\n    {\n\tpjmedia_event_init(&ev, PJMEDIA_EVENT_RX_RTCP_FB, &ts_now, sess);\n\tev.data.rx_rtcp_fb.cap.type = PJMEDIA_RTCP_FB_NACK;\n\tpj_strset2(&ev.data.rx_rtcp_fb.cap.param, (char*)\"pli\");\n\tpjmedia_event_publish(NULL, sess, &ev, 0);\n\n\t/*  For other FB type implementations later\n    } else if (pjmedia_rtcp_fb_parse_sli(pkt, size, &cnt, sli)==PJ_SUCCESS)\n    {\n    } else if (pjmedia_rtcp_fb_parse_rpsi(pkt, size, &rpsi)==PJ_SUCCESS)\n    {\n\t*/\n    } else {\n\t/* Ignore unknown RTCP Feedback */\n\tTRACE_((sess->name, \"Received unknown RTCP feedback\"));\n    }\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n\t\t\t\t   const void *pkt,\n\t\t\t\t   pj_size_t size)\n{\n    pj_uint8_t *p, *p_end;\n\n    p = (pj_uint8_t*)pkt;\n    p_end = p + size;\n    while (p < p_end) {\n\tpjmedia_rtcp_common *common = (pjmedia_rtcp_common*)p;\n\tunsigned len;\n\n\tlen = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;\n\tif (p + len > p_end)\n\t    break;\n\n\tswitch(common->pt) {\n\tcase RTCP_SR:\n\tcase RTCP_RR:\n\tcase RTCP_XR:\n\t    parse_rtcp_report(sess, p, len);\n\t    break;\n\tcase RTCP_SDES:\n\t    parse_rtcp_sdes(sess, p, len);\n\t    break;\n\tcase RTCP_BYE:\n\t    parse_rtcp_bye(sess, p, len);\n\t    break;\n\tcase RTCP_RTPFB:\n\tcase RTCP_PSFB:\n\t    parse_rtcp_fb(sess, p, len);\n\t    break;\n\tdefault:\n\t    /* Ignore unknown RTCP */\n\t    TRACE_((sess->name, \"Received unknown RTCP packet type=%d\",\n\t\t    common->pt));\n\t    break;\n\t}\n\n\tp += len;\n    }\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_build_rtcp(pjmedia_rtcp_session *sess, \n\t\t\t\t     void **ret_p_pkt, int *len)\n{\n    pj_uint32_t expected, expected_interval, received_interval, lost_interval;\n    pjmedia_rtcp_sr *sr;\n    pjmedia_rtcp_rr *rr;\n    pj_timestamp ts_now;\n    pjmedia_rtcp_ntp_rec ntp;\n\n    /* Get current NTP time. */\n    pj_get_timestamp(&ts_now);\n    pjmedia_rtcp_get_ntp_time(sess, &ntp);\n\n\n    /* See if we have transmitted RTP packets since last time we\n     * sent RTCP SR.\n     */\n    if (sess->stat.tx.pkt != pj_ntohl(sess->rtcp_sr_pkt.sr.sender_pcount)) {\n\tpj_time_val ts_time;\n\tpj_uint32_t rtp_ts;\n\n\t/* So we should send RTCP SR */\n\t*ret_p_pkt = (void*) &sess->rtcp_sr_pkt;\n\t*len = sizeof(pjmedia_rtcp_sr_pkt);\n\trr = &sess->rtcp_sr_pkt.rr;\n\tsr = &sess->rtcp_sr_pkt.sr;\n\n\t/* Update packet count */\n\tsr->sender_pcount = pj_htonl(sess->stat.tx.pkt);\n\n\t/* Update octets count */\n\tsr->sender_bcount = pj_htonl(sess->stat.tx.bytes);\n\n\t/* Fill in NTP timestamp in SR. */\n\tsr->ntp_sec = pj_htonl(ntp.hi);\n\tsr->ntp_frac = pj_htonl(ntp.lo);\n\n\t/* Fill in RTP timestamp (corresponds to NTP timestamp) in SR. */\n\tts_time.sec = ntp.hi - sess->tv_base.sec - JAN_1970;\n\tts_time.msec = (long)(ntp.lo * 1000.0 / 0xFFFFFFFF);\n\trtp_ts = sess->rtp_ts_base +\n\t\t (pj_uint32_t)(sess->clock_rate*ts_time.sec) +\n\t\t (pj_uint32_t)(sess->clock_rate*ts_time.msec/1000);\n\tsr->rtp_ts = pj_htonl(rtp_ts);\n\n\tTRACE_((sess->name, \"TX RTCP SR: ntp_ts=%p\", \n\t\t\t   ((ntp.hi & 0xFFFF) << 16) + ((ntp.lo & 0xFFFF0000) \n\t\t\t\t>> 16)));\n\n\n    } else {\n\t/* We should send RTCP RR then */\n\t*ret_p_pkt = (void*) &sess->rtcp_rr_pkt;\n\t*len = sizeof(pjmedia_rtcp_rr_pkt);\n\trr = &sess->rtcp_rr_pkt.rr;\n\tsr = NULL;\n    }\n    \n    /* SSRC and last_seq */\n    rr->ssrc = pj_htonl(sess->peer_ssrc);\n    rr->last_seq = (sess->seq_ctrl.cycles & 0xFFFF0000L);\n    /* Since this is an \"+=\" operation, make sure we update last_seq on\n     * both RR and SR.\n     */\n    sess->rtcp_sr_pkt.rr.last_seq += sess->seq_ctrl.max_seq;\n    sess->rtcp_rr_pkt.rr.last_seq += sess->seq_ctrl.max_seq;\n    rr->last_seq = pj_htonl(rr->last_seq);\n\n\n    /* Jitter */\n    rr->jitter = pj_htonl(sess->jitter >> 4);\n    \n    \n    /* Total lost. */\n    expected = pj_ntohl(rr->last_seq) - sess->seq_ctrl.base_seq;\n\n    /* This is bug: total lost already calculated on each incoming RTP!\n    if (expected >= sess->received)\n\tsess->stat.rx.loss = expected - sess->received;\n    else\n\tsess->stat.rx.loss = 0;\n    */\n\n    rr->total_lost_2 = (sess->stat.rx.loss >> 16) & 0xFF;\n    rr->total_lost_1 = (sess->stat.rx.loss >> 8) & 0xFF;\n    rr->total_lost_0 = (sess->stat.rx.loss & 0xFF);\n\n    /* Fraction lost calculation */\n    expected_interval = expected - sess->exp_prior;\n    sess->exp_prior = expected;\n    \n    received_interval = sess->received - sess->rx_prior;\n    sess->rx_prior = sess->received;\n    \n    if (expected_interval >= received_interval)\n\tlost_interval = expected_interval - received_interval;\n    else\n\tlost_interval = 0;\n    \n    if (expected_interval==0 || lost_interval == 0) {\n\trr->fract_lost = 0;\n    } else {\n\trr->fract_lost = (lost_interval << 8) / expected_interval;\n    }\n    \n    if (sess->rx_lsr_time.u64 == 0 || sess->rx_lsr == 0) {\n\trr->lsr = 0;\n\trr->dlsr = 0;\n    } else {\n\tpj_timestamp ts;\n\tpj_uint32_t lsr = sess->rx_lsr;\n\tpj_uint64_t lsr_time = sess->rx_lsr_time.u64;\n\tpj_uint32_t dlsr;\n\t\n\t/* Convert LSR time to 1/65536 seconds resolution */\n\tlsr_time = (lsr_time << 16) / sess->ts_freq.u64;\n\n\t/* Fill in LSR.\n\t   LSR is the middle 32bit of the last SR NTP time received.\n\t */\n\trr->lsr = pj_htonl(lsr);\n\t\n\t/* Fill in DLSR.\n\t   DLSR is Delay since Last SR, in 1/65536 seconds.\n\t */\n\tts.u64 = ts_now.u64;\n\n\t/* Convert interval to 1/65536 seconds value */\n\tts.u64 = (ts.u64 << 16) / sess->ts_freq.u64;\n\n\t/* Get DLSR */\n\tdlsr = (pj_uint32_t)(ts.u64 - lsr_time);\n\trr->dlsr = pj_htonl(dlsr);\n\n\tTRACE_((sess->name,\"Tx RTCP RR: lsr=%p, lsr_time=%p, now=%p, dlsr=%p\"\n\t\t\t   \"(%ds:%03dms)\",\n\t\t\t   lsr, \n\t\t\t   (pj_uint32_t)lsr_time,\n\t\t\t   (pj_uint32_t)ts.u64, \n\t\t\t   dlsr,\n\t\t\t   dlsr/65536,\n\t\t\t   (dlsr%65536)*1000/65536 ));\n    }\n    \n    /* Update counter */\n    pj_gettimeofday(&sess->stat.rx.update);\n    sess->stat.rx.update_cnt++;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_build_rtcp_sdes(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_sdes *sdes)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    pj_size_t len;\n\n    PJ_ASSERT_RETURN(session && buf && length && sdes, PJ_EINVAL);\n\n    /* Verify SDES item length */\n    if (sdes->cname.slen > 255 || sdes->name.slen  > 255 ||\n\tsdes->email.slen > 255 || sdes->phone.slen > 255 ||\n\tsdes->loc.slen   > 255 || sdes->tool.slen  > 255 ||\n\tsdes->note.slen  > 255)\n    {\n\treturn PJ_EINVAL;\n    }\n\n    /* Verify buffer length */\n    len = sizeof(*hdr);\n    if (sdes->cname.slen) len += sdes->cname.slen + 2;\n    if (sdes->name.slen)  len += sdes->name.slen  + 2;\n    if (sdes->email.slen) len += sdes->email.slen + 2;\n    if (sdes->phone.slen) len += sdes->phone.slen + 2;\n    if (sdes->loc.slen)   len += sdes->loc.slen   + 2;\n    if (sdes->tool.slen)  len += sdes->tool.slen  + 2;\n    if (sdes->note.slen)  len += sdes->note.slen  + 2;\n    len++; /* null termination */\n    len = ((len+3)/4) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP SDES header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_sr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_SDES;\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP SDES items */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n#define BUILD_SDES_ITEM(SDES_NAME, SDES_TYPE) \\\n    if (sdes->SDES_NAME.slen) { \\\n\t*p++ = SDES_TYPE; \\\n\t*p++ = (pj_uint8_t)sdes->SDES_NAME.slen; \\\n\tpj_memcpy(p, sdes->SDES_NAME.ptr, sdes->SDES_NAME.slen); \\\n\tp += sdes->SDES_NAME.slen; \\\n    }\n    BUILD_SDES_ITEM(cname, RTCP_SDES_CNAME);\n    BUILD_SDES_ITEM(name,  RTCP_SDES_NAME);\n    BUILD_SDES_ITEM(email, RTCP_SDES_EMAIL);\n    BUILD_SDES_ITEM(phone, RTCP_SDES_PHONE);\n    BUILD_SDES_ITEM(loc,   RTCP_SDES_LOC);\n    BUILD_SDES_ITEM(tool,  RTCP_SDES_TOOL);\n    BUILD_SDES_ITEM(note,  RTCP_SDES_NOTE);\n#undef BUILD_SDES_ITEM\n\n    /* Null termination */\n    *p++ = 0;\n\n    /* Pad to 32bit */\n    while ((p-(pj_uint8_t*)buf) % 4)\n\t*p++ = 0;\n\n    /* Finally */\n    pj_assert((int)len == p-(pj_uint8_t*)buf);\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_build_rtcp_bye(pjmedia_rtcp_session *session,\n\t\t\t\t\t\tvoid *buf,\n\t\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\t\tconst pj_str_t *reason)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    pj_size_t len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    /* Verify BYE reason length */\n    if (reason && reason->slen > 255)\n\treturn PJ_EINVAL;\n\n    /* Verify buffer length */\n    len = sizeof(*hdr);\n    if (reason && reason->slen) len += reason->slen + 1;\n    len = ((len+3)/4) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP BYE header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_sr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_BYE;\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Write RTCP BYE reason */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    if (reason && reason->slen) {\n\t*p++ = (pj_uint8_t)reason->slen;\n\tpj_memcpy(p, reason->ptr, reason->slen);\n\tp += reason->slen;\n    }\n\n    /* Pad to 32bit */\n    while ((p-(pj_uint8_t*)buf) % 4)\n\t*p++ = 0;\n\n    pj_assert((int)len == p-(pj_uint8_t*)buf);\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_enable_xr( pjmedia_rtcp_session *sess, \n\t\t\t\t\t    pj_bool_t enable)\n{\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\n    /* Check if request won't change anything */\n    if (!(enable ^ sess->xr_enabled))\n\treturn PJ_SUCCESS;\n\n    if (!enable) {\n\tsess->xr_enabled = PJ_FALSE;\n\treturn PJ_SUCCESS;\n    }\n\n    pjmedia_rtcp_xr_init(&sess->xr_session, sess, 0, 1);\n    sess->xr_enabled = PJ_TRUE;\n\n    return PJ_SUCCESS;\n\n#else\n\n    PJ_UNUSED_ARG(sess);\n    PJ_UNUSED_ARG(enable);\n    return PJ_ENOTSUP;\n\n#endif\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2018 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjmedia/rtcp_fb.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/vid_codec.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n#define THIS_FILE \"rtcp_fb.c\"\n\n#define RTCP_RTPFB\t205\n#define RTCP_PSFB\t206\n\n/*\n * Build an RTCP-FB Generic NACK packet.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB NACK header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_RTPFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB NACK FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;\n    }\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Build an RTCP-FB Picture Loss Indication (PLI) packet.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length)\n{\n    pjmedia_rtcp_common *hdr;\n    unsigned len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    len = 12;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB PLI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Build an RTCP-FB Slice Loss Indication (SLI) packet.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_sli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned sli_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && sli_cnt && sli, PJ_EINVAL);\n\n    len = (3 + sli_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB SLI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 2; /* FMT = 2 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB SLI FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\t*p++  = (pj_uint8_t)((sli[i].first >> 5) & 0xFF);   /* 8 MSB bits */\n\t*p    = (pj_uint8_t)((sli[i].first & 31) << 3);\t    /* 5 LSB bits */\n\t/* 'number' takes 13 bit */\n\t*p++ |= (pj_uint8_t)((sli[i].number >> 10) & 7);    /* 3 MSB bits */\n\t*p++  = (pj_uint8_t)((sli[i].number >> 2) & 0xFF);  /* 8 mid bits */\n\t*p    = (pj_uint8_t)((sli[i].number & 3) << 6);\t    /* 2 LSB bits */\n\t/* 'pict_id' takes 6 bit */\n\t*p++ |= (sli[i].pict_id & 63);\n    }\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Build an RTCP-FB Slice Loss Indication (SLI) packet.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned bitlen, padlen, len;\n\n    PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL);\n\n    bitlen = rpsi->rpsi_bit_len + 16;\n    padlen = (32 - (bitlen % 32)) % 32;\n    len = (3 + (bitlen+padlen)/32) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB RPSI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 3; /* FMT = 3 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB RPSI FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    /* PB (number of padding bits) */\n    *p++ = (pj_uint8_t)padlen;\n    /* Payload type */\n    *p++ = rpsi->pt & 0x7F;\n    /* RPSI bit string */\n    pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8);\n    p += rpsi->rpsi_bit_len/8;\n    if (rpsi->rpsi_bit_len % 8) {\n\t*p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8);\n    }\n    /* Zero padding */\n    if (padlen >= 8)\n\tpj_bzero(p, padlen/8);\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Initialize RTCP Feedback setting with default values.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_setting_default(\n\t\t\t\t\tpjmedia_rtcp_fb_setting *opt)\n{\n    pj_bzero(opt, sizeof(*opt));\n    opt->dont_use_avpf = PJ_TRUE;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void pjmedia_rtcp_fb_cap_dup(pj_pool_t *pool,\n\t\t\t\t    pjmedia_rtcp_fb_cap *dst,\n\t\t\t\t    const pjmedia_rtcp_fb_cap *src)\n{\n    pj_strdup(pool, &dst->codec_id, &src->codec_id);\n    dst->type = src->type;\n    pj_strdup(pool, &dst->type_name, &src->type_name);\n    pj_strdup(pool, &dst->param, &src->param);\n}\n\n\n/*\n * Duplicate RTCP Feedback setting.\n */\nPJ_DEF(void) pjmedia_rtcp_fb_setting_dup( pj_pool_t *pool,\n\t\t\t\t\t  pjmedia_rtcp_fb_setting *dst,\n\t\t\t\t\t  const pjmedia_rtcp_fb_setting *src)\n{\n    unsigned i;\n\n    pj_assert(pool && dst && src);\n\n    pj_memcpy(dst, src, sizeof(pjmedia_rtcp_fb_setting));\n    for (i = 0; i < src->cap_count; ++i) {\n\tpjmedia_rtcp_fb_cap_dup(pool, &dst->caps[i], &src->caps[i]);\n    }\n}\n\n\n/*\n * Duplicate RTCP Feedback info.\n */\nPJ_DEF(void) pjmedia_rtcp_fb_info_dup( pj_pool_t *pool,\n\t\t\t\t       pjmedia_rtcp_fb_info *dst,\n\t\t\t\t       const pjmedia_rtcp_fb_info *src)\n{\n    unsigned i;\n\n    pj_assert(pool && dst && src);\n\n    pj_memcpy(dst, src, sizeof(pjmedia_rtcp_fb_info));\n    for (i = 0; i < src->cap_count; ++i) {\n\tpjmedia_rtcp_fb_cap_dup(pool, &dst->caps[i], &src->caps[i]);\n    }\n}\n\n\n\nstruct rtcp_fb_type_name_t\n{\n    pjmedia_rtcp_fb_type     type;\n    const char\t\t    *name;\n} rtcp_fb_type_name[] =\n{\n    {PJMEDIA_RTCP_FB_ACK,\t\"ack\"},\n    {PJMEDIA_RTCP_FB_NACK,\t\"nack\"},\n    {PJMEDIA_RTCP_FB_TRR_INT,\t\"trr-int\"}\n};\n\n/* Generate a=rtcp-fb based on the specified PT & RTCP-FB capability */\nstatic pj_status_t add_sdp_attr_rtcp_fb( pj_pool_t *pool,\n\t\t\t\t\t const char *pt,\n\t\t\t\t\t const pjmedia_rtcp_fb_cap *cap,\n\t\t\t\t\t pjmedia_sdp_media *m)\n{\n    pjmedia_sdp_attr *a;\n    char tmp[128];\n    pj_str_t val;\n    pj_str_t type_name = {0};\n\n    if (cap->type < PJMEDIA_RTCP_FB_OTHER)\n\tpj_cstr(&type_name, rtcp_fb_type_name[cap->type].name);\n    else if (cap->type == PJMEDIA_RTCP_FB_OTHER)\n\ttype_name = cap->type_name;\n\n    if (type_name.slen == 0)\n\treturn PJ_EINVAL;\n\n    /* Generate RTCP FB param */\n    if (cap->param.slen) {\n\tpj_ansi_snprintf(tmp, sizeof(tmp), \"%s %.*s %.*s\", pt,\n\t\t\t (int)type_name.slen, type_name.ptr,\n\t\t\t (int)cap->param.slen, cap->param.ptr);\n    } else {\n\tpj_ansi_snprintf(tmp, sizeof(tmp), \"%s %.*s\", pt,\n\t\t\t (int)type_name.slen, type_name.ptr);\n    }\n    pj_strset2(&val, tmp);\n\n    /* Generate and add SDP attribute a=rtcp-fb */\n    a = pjmedia_sdp_attr_create(pool, \"rtcp-fb\", &val);\n    m->attr[m->attr_count++] = a;\n\n    return PJ_SUCCESS;\n}\n\n/* SDP codec info (ID and PT) */\ntypedef struct sdp_codec_info_t\n{\n    char\t id[32];\n    unsigned\t pt;\n} sdp_codec_info_t;\n\n\n/* Populate codec ID/name and PT in SDP */\nstatic pj_status_t get_codec_info_from_sdp(pjmedia_endpt *endpt,\n\t\t\t\t\t   const pjmedia_sdp_media *m,\n\t\t\t\t\t   unsigned *sci_cnt,\n\t\t\t\t\t   sdp_codec_info_t sci[])\n{\n    pjmedia_codec_mgr *codec_mgr;\n    unsigned j, cnt = 0;\n    pjmedia_type type = PJMEDIA_TYPE_UNKNOWN;\n    pj_status_t status;\n\n    type = pjmedia_get_type(&m->desc.media);\n    if (type != PJMEDIA_TYPE_AUDIO && type != PJMEDIA_TYPE_VIDEO)\n\treturn PJMEDIA_EUNSUPMEDIATYPE;\n\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    for (j = 0; j < m->desc.fmt_count && cnt < *sci_cnt; ++j) {\n\tunsigned pt = 0;\n\tpt = pj_strtoul(&m->desc.fmt[j]);\n\tif (pt < 96) {\n\t    if (type == PJMEDIA_TYPE_AUDIO) {\n\t\tconst pjmedia_codec_info *ci;\n\t\tstatus = pjmedia_codec_mgr_get_codec_info(codec_mgr, pt, &ci);\n\t\tif (status != PJ_SUCCESS)\n\t\t    continue;\n\n\t\tpjmedia_codec_info_to_id(ci, sci[cnt].id, sizeof(sci[0].id));\n\t    } else {\n#if defined(PJMEDIA_HAS_VIDEO) && (PJMEDIA_HAS_VIDEO != 0)\n\t\tconst pjmedia_vid_codec_info *ci;\n\t\tstatus = pjmedia_vid_codec_mgr_get_codec_info(NULL, pt, &ci);\n\t\tif (status != PJ_SUCCESS)\n\t\t    continue;\n\n\t\tpjmedia_vid_codec_info_to_id(ci, sci[cnt].id,\n\t\t\t\t\t     sizeof(sci[0].id));\n#else\n\t\tcontinue;\n#endif\n\t    }\n\t} else {\n\t    pjmedia_sdp_attr *a;\n\t    pjmedia_sdp_rtpmap r;\n\t    a = pjmedia_sdp_media_find_attr2(m, \"rtpmap\",\n\t\t\t\t\t     &m->desc.fmt[j]);\n\t    if (a == NULL)\n\t\tcontinue;\n\t    status = pjmedia_sdp_attr_get_rtpmap(a, &r);\n\t    if (status != PJ_SUCCESS)\n\t\tcontinue;\n\n\t    if (type == PJMEDIA_TYPE_AUDIO) {\n\t\t/* Audio codec id format: \"name/clock-rate/channel-count\" */\n\t\tif (r.param.slen) {\n\t\t    pj_ansi_snprintf(sci[cnt].id, sizeof(sci[0].id),\n\t\t\t\t     \"%.*s/%d/%.*s\",\n\t\t\t\t     (int)r.enc_name.slen, r.enc_name.ptr,\n\t\t\t\t     r.clock_rate,\n\t\t\t\t     (int)r.param.slen, r.param.ptr);\n\t\t} else {\n\t\t    pj_ansi_snprintf(sci[cnt].id, sizeof(sci[0].id),\n\t\t\t\t     \"%.*s/%d/1\",\n\t\t\t\t     (int)r.enc_name.slen, r.enc_name.ptr,\n\t\t\t\t     r.clock_rate);\n\t\t}\n\t    } else {\n\t\t/* Video codec id format: \"name/payload-type\" */\n\t\tpj_ansi_snprintf(sci[cnt].id, sizeof(sci[0].id),\n\t\t\t\t \"%.*s/%d\",\n\t\t\t\t (int)r.enc_name.slen, r.enc_name.ptr, pt);\n\t    }\n\t}\n\tsci[cnt++].pt = pt;\n    }\n    *sci_cnt = cnt;\n    \n    return PJ_SUCCESS;\n}\n\n/*\n * Encode RTCP Feedback specific information into the SDP according to\n * the provided RTCP Feedback setting.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_encode_sdp(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjmedia_endpt *endpt,\n\t\t\t\t    const pjmedia_rtcp_fb_setting *opt,\n\t\t\t\t    pjmedia_sdp_session *sdp_local,\n\t\t\t\t    unsigned med_idx,\n\t\t\t\t    const pjmedia_sdp_session *sdp_remote)\n{\n    pjmedia_sdp_media *m = sdp_local->media[med_idx];\n    unsigned i;\n    unsigned sci_cnt = 0;\n    sdp_codec_info_t sci[PJMEDIA_MAX_SDP_FMT];\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(sdp_remote);\n\n    PJ_ASSERT_RETURN(pool && endpt && opt && sdp_local, PJ_EINVAL);\n    PJ_ASSERT_RETURN(med_idx < sdp_local->media_count, PJ_EINVAL);\n\n    /* Add RTCP Feedback profile (AVPF), if configured to */\n    if (!opt->dont_use_avpf) {\n\tunsigned proto = pjmedia_sdp_transport_get_proto(&m->desc.transport);\n\tif (!PJMEDIA_TP_PROTO_HAS_FLAG(proto, PJMEDIA_TP_PROFILE_RTCP_FB)) {\n\t    pj_str_t new_tp;\n\t    pj_strdup_with_null(pool, &new_tp, &m->desc.transport);\n\t    new_tp.ptr[new_tp.slen++] = 'F';\n\t    m->desc.transport = new_tp;\n\t}\n    }\n\n    /* Add RTCP Feedback capability to SDP */\n    for (i = 0; i < opt->cap_count; ++i) {\n\tunsigned j;\n\n\t/* All codecs */\n\tif (pj_strcmp2(&opt->caps[i].codec_id, \"*\") == 0) {\n\t    status = add_sdp_attr_rtcp_fb(pool, \"*\", &opt->caps[i], m);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(3, (THIS_FILE, status,\n\t\t\t  \"Failed generating SDP a=rtcp-fb:*\"));\n\t    }\n\t    continue;\n\t}\n\n\t/* Specific codec */\n\tif (sci_cnt == 0) {\n\t    sci_cnt = PJ_ARRAY_SIZE(sci);\n\t    status = get_codec_info_from_sdp(endpt, m, &sci_cnt, sci);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(3, (THIS_FILE, status,\n\t\t\t  \"Failed populating codec info from SDP\"));\n\t\treturn status;\n\t    }\n\t}\n\n\tfor (j = 0; j < sci_cnt; ++j) {\n\t    if (pj_strnicmp2(&opt->caps[i].codec_id, sci[j].id,\n\t\t\t     opt->caps[i].codec_id.slen) == 0)\n\t    {\n\t\tchar tmp[4];\n\t\tsnprintf(tmp, sizeof(tmp), \"%d\", sci[j].pt);\n\t\tstatus = add_sdp_attr_rtcp_fb(pool, tmp, &opt->caps[i], m);\n\t\tif (status != PJ_SUCCESS) {\n\t\t    PJ_PERROR(3, (THIS_FILE, status,\n\t\t\t      \"Failed generating SDP a=rtcp-fb:%d (%s)\",\n\t\t\t      sci[j].pt, opt->caps[i].codec_id.ptr));\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (j == sci_cnt) {\n\t    /* Codec ID not found in SDP (perhaps better ignore this error\n\t     * as app may configure audio and video in single setting).\n\t     */\n\t    PJ_PERROR(6, (THIS_FILE, PJ_ENOTFOUND,\n\t\t      \"Failed generating SDP a=rtcp-fb for %s\",\n\t\t      opt->caps[i].codec_id.ptr));\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Decode RTCP Feedback specific information from SDP media.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_decode_sdp(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjmedia_endpt *endpt,\n\t\t\t\t    const void *opt,\n\t\t\t\t    const pjmedia_sdp_session *sdp,\n\t\t\t\t    unsigned med_idx,\n\t\t\t\t    pjmedia_rtcp_fb_info *info)\n{\n    return pjmedia_rtcp_fb_decode_sdp2(pool, endpt, opt, sdp, med_idx, -1,\n\t\t\t\t       info);\n}\n\n/*\n * Decode RTCP Feedback specific information from SDP media.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_decode_sdp2(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjmedia_endpt *endpt,\n\t\t\t\t    const void *opt,\n\t\t\t\t    const pjmedia_sdp_session *sdp,\n\t\t\t\t    unsigned med_idx,\n\t\t\t\t    int pt,\n\t\t\t\t    pjmedia_rtcp_fb_info *info)\n{\n    unsigned sci_cnt = PJMEDIA_MAX_SDP_FMT;\n    sdp_codec_info_t sci[PJMEDIA_MAX_SDP_FMT];\n    const pjmedia_sdp_media *m;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_UNUSED_ARG(opt);\n\n    PJ_ASSERT_RETURN(pool && endpt && opt==NULL && sdp, PJ_EINVAL);\n    PJ_ASSERT_RETURN(med_idx < sdp->media_count, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pt <= 127, PJ_EINVAL);\n\n    m = sdp->media[med_idx];\n    status = get_codec_info_from_sdp(endpt, m, &sci_cnt, sci);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pj_bzero(info, sizeof(*info));\n\n    /* Iterate all SDP attribute a=rtcp-fb in the SDP media */\n    for (i = 0; i < m->attr_count; ++i) {\n\tconst pjmedia_sdp_attr *a = m->attr[i];\n\tpj_str_t token;\n\tpj_ssize_t tok_idx;\n\tunsigned j;\n\tconst char *codec_id = NULL;\n\tpj_str_t type_name = {0};\n\tpjmedia_rtcp_fb_type type = PJMEDIA_RTCP_FB_OTHER;\n\n\t/* Skip non a=rtcp-fb */\n\tif (pj_strcmp2(&a->name, \"rtcp-fb\") != 0)\n\t    continue;\n\n\t/* Get PT */\n\ttok_idx = pj_strtok2(&a->value, \" \\t\", &token, 0);\n\tif (tok_idx == a->value.slen)\n\t    continue;\n\n\tif (pj_strcmp2(&token, \"*\") == 0) {\n\t    /* All codecs */\n\t    codec_id = \"*\";\n\t} else {\n\t    /* Specific PT/codec */\n\t    unsigned pt_ = (unsigned) pj_strtoul2(&token, NULL, 10);\n\t    for (j = 0; j < sci_cnt; ++j) {\n\t\t/* Check if payload type is valid and requested */\n\t\tif (pt_ == sci[j].pt && (pt < 0 || pt == (int)pt_)) {\n\t\t    codec_id = sci[j].id;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t/* Skip this a=rtcp-fb if PT is not recognized or not requested */\n\tif (!codec_id)\n\t    continue;\n\n\t/* Get RTCP-FB type */\n\ttok_idx = pj_strtok2(&a->value, \" \\t\", &token, tok_idx + token.slen);\n\tif (tok_idx == a->value.slen)\n\t    continue;\n\n\tfor (j = 0; j < PJ_ARRAY_SIZE(rtcp_fb_type_name); ++j) {\n\t    if (pj_strcmp2(&token, rtcp_fb_type_name[j].name) == 0) {\n\t\ttype = rtcp_fb_type_name[j].type;\n\t\tbreak;\n\t    }\n\t}\n\tif (type == PJMEDIA_RTCP_FB_OTHER)\n\t    type_name = token;\n\n\t/* Got all the mandatory fields, let's initialize RTCP-FB cap */\n\tpj_strdup2(pool, &info->caps[info->cap_count].codec_id, codec_id);\n\tinfo->caps[info->cap_count].type = type;\n\tif (type == PJMEDIA_RTCP_FB_OTHER)\n\t    pj_strdup(pool, &info->caps[info->cap_count].type_name, &type_name);\n\n\t/* Get RTCP-FB param */\n\ttok_idx = pj_strtok2(&a->value, \" \\t\", &token, tok_idx + token.slen);\n\tif (tok_idx != a->value.slen)\n\t    pj_strdup(pool, &info->caps[info->cap_count].param, &token);\n\n\t/* Next */\n\tif (++info->cap_count == PJMEDIA_RTCP_FB_MAX_CAP)\n\t    break;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check whether the specified payload contains RTCP feedback generic NACK\n * message, and parse the payload if it does.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *nack_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* Generic NACK uses pt==RTCP_RTPFB and FMT==1 */\n    if (hdr->pt != RTCP_RTPFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *nack_cnt = PJ_MIN(*nack_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *nack_cnt; ++i) {\n\tpj_uint16_t val;\n\n\tpj_memcpy(&val, p, 2);\n\tnack[i].pid = pj_ntohs(val);\n\tpj_memcpy(&val, p+2, 2);\n\tnack[i].blp = pj_ntohs(val);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check whether the specified payload contains RTCP feedback Picture Loss\n * Indication (PLI) message.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= 12, PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==1 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check whether the specified payload contains RTCP feedback Slice Loss\n * Indication (SLI) message, and parse the payload if it does.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==2 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t/* 'number' takes 13 bit */\n\tsli[i].number = ((p[1] & 0x07) << 10) +\n\t\t\t(p[2] << 2) +\n\t\t\t((p[3] & 0xC0) >> 6);\n\t/* 'pict_id' takes 6 bit */\n\tsli[i].pict_id = (p[3] & 0x3F);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check whether the specified payload contains RTCP feedback Reference\n * Picture Selection Indication (RPSI) message, and parse the payload\n * if it does.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/rtp.h>\n#include <pjmedia/errno.h>\n#include <pj/log.h>\n#include <pj/sock.h>\t/* pj_htonx, pj_htonx */\n#include <pj/assert.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n\n#define THIS_FILE   \"rtp.c\"\n\n#define RTP_VERSION\t2\n\n#define RTP_SEQ_MOD\t(1 << 16)\n#define MAX_DROPOUT \t((pj_int16_t)3000)\n#define MAX_MISORDER \t((pj_int16_t)100)\n#define MIN_SEQUENTIAL  ((pj_int16_t)2)\n\nstatic void pjmedia_rtp_seq_restart(pjmedia_rtp_seq_session *seq_ctrl, \n\t\t\t\t    pj_uint16_t seq);\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_session_init( pjmedia_rtp_session *ses,\n\t\t\t\t\t      int default_pt, \n\t\t\t\t\t      pj_uint32_t sender_ssrc )\n{\n    PJ_LOG(5, (THIS_FILE, \n\t       \"pjmedia_rtp_session_init: ses=%p, default_pt=%d, ssrc=0x%x\",\n\t       ses, default_pt, sender_ssrc));\n\n    /* Check RTP header packing. */\n    if (sizeof(struct pjmedia_rtp_hdr) != 12) {\n\tpj_assert(!\"Wrong RTP header packing!\");\n\treturn PJMEDIA_RTP_EINPACK;\n    }\n\n    /* If sender_ssrc is not specified, create from random value. */\n    if (sender_ssrc == 0 || sender_ssrc == (pj_uint32_t)-1) {\n\tsender_ssrc = pj_htonl(pj_rand());\n    } else {\n\tsender_ssrc = pj_htonl(sender_ssrc);\n    }\n\n    /* Initialize session. */\n    pj_bzero(ses, sizeof(*ses));\n\n    /* Initial sequence number SHOULD be random, according to RFC 3550. */\n    /* According to RFC 3711, it should be random within 2^15 bit */\n    ses->out_extseq = pj_rand() & 0x7FFF;\n    ses->peer_ssrc = 0;\n    \n    /* Build default header for outgoing RTP packet. */\n    ses->out_hdr.v = RTP_VERSION;\n    ses->out_hdr.p = 0;\n    ses->out_hdr.x = 0;\n    ses->out_hdr.cc = 0;\n    ses->out_hdr.m = 0;\n    ses->out_hdr.pt = (pj_uint8_t) default_pt;\n    ses->out_hdr.seq = (pj_uint16_t) pj_htons( (pj_uint16_t)ses->out_extseq );\n    ses->out_hdr.ts = 0;\n    ses->out_hdr.ssrc = sender_ssrc;\n\n    /* Keep some arguments as session defaults. */\n    ses->out_pt = (pj_uint16_t) default_pt;\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_rtp_session_init2( \n\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t    pjmedia_rtp_session_setting settings)\n{\n    pj_status_t status;\n    int\t\t pt = 0;\n    pj_uint32_t\t sender_ssrc = 0;\n\n    if (settings.flags & 1)\n\tpt = settings.default_pt;\n    if (settings.flags & 2)\n\tsender_ssrc = settings.sender_ssrc;\n\n    status = pjmedia_rtp_session_init(ses, pt, sender_ssrc);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    if (settings.flags & 4) {\n\tses->out_extseq = settings.seq;\n\tses->out_hdr.seq = pj_htons((pj_uint16_t)ses->out_extseq);\n    }\n    if (settings.flags & 8)\n\tses->out_hdr.ts = pj_htonl(settings.ts);\n    if (settings.flags & 16) {\n        ses->has_peer_ssrc = PJ_TRUE;\n\tses->peer_ssrc = settings.peer_ssrc;\n    }\n\n    PJ_LOG(5, (THIS_FILE,\n\t       \"pjmedia_rtp_session_init2: ses=%p, seq=%d, ts=%d, peer_ssrc=%d\",\n\t       ses, pj_ntohs(ses->out_hdr.seq), pj_ntohl(ses->out_hdr.ts),\n\t       ses->has_peer_ssrc? ses->peer_ssrc : 0));\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_encode_rtp( pjmedia_rtp_session *ses, \n\t\t\t\t\t    int pt, int m,\n\t\t\t\t\t    int payload_len, int ts_len,\n\t\t\t\t\t    const void **rtphdr, int *hdrlen )\n{\n    /* Update timestamp */\n    ses->out_hdr.ts = pj_htonl(pj_ntohl(ses->out_hdr.ts)+ts_len);\n\n    /* If payload_len is zero, bail out.\n     * This is a clock frame; we're not really transmitting anything.\n     */\n    if (payload_len == 0)\n\treturn PJ_SUCCESS;\n\n    /* Update session. */\n    ses->out_extseq++;\n\n    /* Create outgoing header. */\n    ses->out_hdr.pt = (pj_uint8_t) ((pt == -1) ? ses->out_pt : pt);\n    ses->out_hdr.m = (pj_uint16_t) m;\n    ses->out_hdr.seq = pj_htons( (pj_uint16_t) ses->out_extseq);\n\n    /* Return values */\n    *rtphdr = &ses->out_hdr;\n    *hdrlen = sizeof(pjmedia_rtp_hdr);\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp( pjmedia_rtp_session *ses, \n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    pjmedia_rtp_dec_hdr dec_hdr;\n\n    return pjmedia_rtp_decode_rtp2(ses, pkt, pkt_len, hdr, &dec_hdr, \n\t\t\t\t   payload, payloadlen);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n\n    PJ_UNUSED_ARG(ses);\n\n    /* Assume RTP header at the start of packet. We'll verify this later. */\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n\n    /* Check RTP header sanity. */\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n\n    /* Payload is located right after header plus CSRC */\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n\n    /* Decode RTP extension. */\n    if ((*hdr)->x) {\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n\n    /* Check that offset is less than packet size */\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n\n    /* Find and set payload. */\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n \n    /* Remove payload padding if any */\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(void) pjmedia_rtp_session_update( pjmedia_rtp_session *ses, \n\t\t\t\t\t const pjmedia_rtp_hdr *hdr,\n\t\t\t\t\t pjmedia_rtp_status *p_seq_st)\n{\n    pjmedia_rtp_session_update2(ses, hdr, p_seq_st, PJ_TRUE);\n}\n\nPJ_DEF(void) pjmedia_rtp_session_update2( pjmedia_rtp_session *ses, \n\t\t\t\t\t  const pjmedia_rtp_hdr *hdr,\n\t\t\t\t\t  pjmedia_rtp_status *p_seq_st,\n\t\t\t\t\t  pj_bool_t check_pt)\n{\n    pjmedia_rtp_status seq_st;\n\n    /* for now check_pt MUST be either PJ_TRUE or PJ_FALSE.\n     * In the future we might change check_pt from boolean to \n     * unsigned integer to accommodate more flags.\n     */\n    pj_assert(check_pt==PJ_TRUE || check_pt==PJ_FALSE);\n\n    /* Init status */\n    seq_st.status.value = 0;\n    seq_st.diff = 0;\n\n    /* Check SSRC. */\n    if (!ses->has_peer_ssrc && ses->peer_ssrc == 0)\n        ses->peer_ssrc = pj_ntohl(hdr->ssrc);\n\n    if (pj_ntohl(hdr->ssrc) != ses->peer_ssrc) {\n\tseq_st.status.flag.badssrc = 1;\n\tif (!ses->has_peer_ssrc)\n\t    ses->peer_ssrc = pj_ntohl(hdr->ssrc);\n    }\n\n    /* Check payload type. */\n    if (check_pt && hdr->pt != ses->out_pt) {\n\tif (p_seq_st) {\n\t    p_seq_st->status.value = seq_st.status.value;\n\t    p_seq_st->status.flag.bad = 1;\n\t    p_seq_st->status.flag.badpt = 1;\n\t}\n\treturn;\n    }\n\n    /* Initialize sequence number on first packet received. */\n    if (ses->received == 0)\n\tpjmedia_rtp_seq_init( &ses->seq_ctrl, pj_ntohs(hdr->seq) );\n\n    /* Check sequence number to see if remote session has been restarted. */\n    pjmedia_rtp_seq_update( &ses->seq_ctrl, pj_ntohs(hdr->seq), &seq_st);\n    if (seq_st.status.flag.restart) {\n\t++ses->received;\n\n    } else if (!seq_st.status.flag.bad) {\n\t++ses->received;\n    }\n\n    if (p_seq_st) {\n\tp_seq_st->status.value = seq_st.status.value;\n\tp_seq_st->diff = seq_st.diff;\n    }\n}\n\n\n\nvoid pjmedia_rtp_seq_restart(pjmedia_rtp_seq_session *sess, pj_uint16_t seq)\n{\n    sess->base_seq = seq;\n    sess->max_seq = seq;\n    sess->bad_seq = RTP_SEQ_MOD + 1;\n    sess->cycles = 0;\n}\n\n\nvoid pjmedia_rtp_seq_init(pjmedia_rtp_seq_session *sess, pj_uint16_t seq)\n{\n    pjmedia_rtp_seq_restart(sess, seq);\n\n    sess->max_seq = (pj_uint16_t) (seq - 1);\n    sess->probation = MIN_SEQUENTIAL;\n}\n\n\nvoid pjmedia_rtp_seq_update( pjmedia_rtp_seq_session *sess, \n\t\t\t     pj_uint16_t seq,\n\t\t\t     pjmedia_rtp_status *seq_status)\n{\n    pj_uint16_t udelta = (pj_uint16_t) (seq - sess->max_seq);\n    pjmedia_rtp_status st;\n    \n    /* Init status */\n    st.status.value = 0;\n    st.diff = 0;\n\n    /*\n     * Source is not valid until MIN_SEQUENTIAL packets with\n     * sequential sequence numbers have been received.\n     */\n    if (sess->probation) {\n\n\tst.status.flag.probation = 1;\n\t\n        if (seq == sess->max_seq+ 1) {\n\t    /* packet is in sequence */\n\t    st.diff = 1;\n\t    sess->probation--;\n            sess->max_seq = seq;\n            if (sess->probation == 0) {\n\t\tst.status.flag.probation = 0;\n            }\n\t} else {\n\n\t    st.diff = 0;\n\n\t    st.status.flag.bad = 1;\n\t    if (seq == sess->max_seq)\n\t\tst.status.flag.dup = 1;\n\t    else\n\t\tst.status.flag.outorder = 1;\n\n\t    sess->probation = MIN_SEQUENTIAL - 1;\n\t    sess->max_seq = seq;\n        }\n\n\n    } else if (udelta == 0) {\n\n\tst.status.flag.dup = 1;\n\n    } else if (udelta < MAX_DROPOUT) {\n\t/* in order, with permissible gap */\n\tif (seq < sess->max_seq) {\n\t    /* Sequence number wrapped - count another 64K cycle. */\n\t    sess->cycles += RTP_SEQ_MOD;\n        }\n        sess->max_seq = seq;\n\n\tst.diff = udelta;\n\n    } else if (udelta <= (RTP_SEQ_MOD - MAX_MISORDER)) {\n\t/* the sequence number made a very large jump */\n        if (seq == sess->bad_seq) {\n\t    /*\n\t     * Two sequential packets -- assume that the other side\n\t     * restarted without telling us so just re-sync\n\t     * (i.e., pretend this was the first packet).\n\t     */\n\t    pjmedia_rtp_seq_restart(sess, seq);\n\t    st.status.flag.restart = 1;\n\t    st.status.flag.probation = 1;\n\t    st.diff = 1;\n\t}\n        else {\n\t    sess->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);\n            st.status.flag.bad = 1;\n\t    st.status.flag.outorder = 1;\n        }\n    } else {\n\t/* old duplicate or reordered packet.\n\t * Not necessarily bad packet (?)\n\t */\n\tst.status.flag.outorder = 1;\n    }\n    \n\n    if (seq_status) {\n\tseq_status->diff = st.diff;\n\tseq_status->status.value = st.status.value;\n    }\n}\n\n\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/rtcp.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/event.h>\n#include <pjmedia/rtcp_fb.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n#define THIS_FILE \"rtcp.c\"\n\n#define RTCP_SR   200\n#define RTCP_RR   201\n#define RTCP_SDES 202\n#define RTCP_BYE  203\n#define RTCP_XR   207\n\n/* RTCP Feedbacks */\n#define RTCP_RTPFB\t205\n#define RTCP_PSFB\t206\n\nenum {\n    RTCP_SDES_NULL  = 0,\n    RTCP_SDES_CNAME = 1,\n    RTCP_SDES_NAME  = 2,\n    RTCP_SDES_EMAIL = 3,\n    RTCP_SDES_PHONE = 4,\n    RTCP_SDES_LOC   = 5,\n    RTCP_SDES_TOOL  = 6,\n    RTCP_SDES_NOTE  = 7\n};\n\n#if PJ_HAS_HIGH_RES_TIMER==0\n#   error \"High resolution timer needs to be enabled\"\n#endif\n\n\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(3,x)\n#else\n#   define TRACE_(x)\t;\n#endif\n\n\n/*\n * Get NTP time.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_get_ntp_time(const pjmedia_rtcp_session *sess,\n\t\t\t\t\t      pjmedia_rtcp_ntp_rec *ntp)\n{\n/* Seconds between 1900-01-01 to 1970-01-01 */\n#define JAN_1970  (2208988800UL)\n    pj_timestamp ts;\n    pj_status_t status;\n\n    status = pj_get_timestamp(&ts);\n\n    /* Fill up the high 32bit part */\n    ntp->hi = (pj_uint32_t)((ts.u64 - sess->ts_base.u64) / sess->ts_freq.u64)\n\t      + sess->tv_base.sec + JAN_1970;\n\n    /* Calculate seconds fractions */\n    ts.u64 = (ts.u64 - sess->ts_base.u64) % sess->ts_freq.u64;\n    pj_assert(ts.u64 < sess->ts_freq.u64);\n    ts.u64 = (ts.u64 << 32) / sess->ts_freq.u64;\n\n    /* Fill up the low 32bit part */\n    ntp->lo = ts.u32.lo;\n\n\n#if (defined(PJ_WIN32) && PJ_WIN32!=0) || \\\n    (defined(PJ_WIN64) && PJ_WIN64!=0) || \\\n    (defined(PJ_WIN32_WINCE) && PJ_WIN32_WINCE!=0)\n\n    /* On Win32, since we use QueryPerformanceCounter() as the backend\n     * timestamp API, we need to protect against this bug:\n     *   Performance counter value may unexpectedly leap forward\n     *   http://support.microsoft.com/default.aspx?scid=KB;EN-US;Q274323\n     */\n    {\n\t/*\n\t * Compare elapsed time reported by timestamp with actual elapsed \n\t * time. If the difference is too excessive, then we use system\n\t * time instead.\n\t */\n\n\t/* MIN_DIFF needs to be large enough so that \"normal\" diff caused\n\t * by system activity or context switch doesn't trigger the time\n\t * correction.\n\t */\n\tenum { MIN_DIFF = 400 };\n\n\tpj_time_val ts_time, elapsed, diff;\n\n\tpj_gettimeofday(&elapsed);\n\n\tts_time.sec = ntp->hi - sess->tv_base.sec - JAN_1970;\n\tts_time.msec = (long)(ntp->lo * 1000.0 / 0xFFFFFFFF);\n\n\tPJ_TIME_VAL_SUB(elapsed, sess->tv_base);\n\n\tif (PJ_TIME_VAL_LT(ts_time, elapsed)) {\n\t    diff = elapsed;\n\t    PJ_TIME_VAL_SUB(diff, ts_time);\n\t} else {\n\t    diff = ts_time;\n\t    PJ_TIME_VAL_SUB(diff, elapsed);\n\t}\n\n\tif (PJ_TIME_VAL_MSEC(diff) >= MIN_DIFF) {\n\n\t    TRACE_((sess->name, \"RTCP NTP timestamp corrected by %d ms\",\n\t\t    PJ_TIME_VAL_MSEC(diff)));\n\n\n\t    ntp->hi = elapsed.sec + sess->tv_base.sec + JAN_1970;\n\t    ntp->lo = (elapsed.msec * 65536 / 1000) << 16;\n\t}\n\n    }\n#endif\n\n    return status;\n}\n\n\n/*\n * Initialize RTCP session setting.\n */\nPJ_DEF(void) pjmedia_rtcp_session_setting_default(\n\t\t\t\t    pjmedia_rtcp_session_setting *settings)\n{\n    pj_bzero(settings, sizeof(*settings));\n}\n\n\n/*\n * Initialize bidirectional RTCP statistics.\n *\n */\nPJ_DEF(void) pjmedia_rtcp_init_stat(pjmedia_rtcp_stat *stat)\n{\n    pj_time_val now;\n\n    pj_assert(stat);\n\n    pj_bzero(stat, sizeof(pjmedia_rtcp_stat));\n\n    pj_math_stat_init(&stat->rtt);\n    pj_math_stat_init(&stat->rx.loss_period);\n    pj_math_stat_init(&stat->rx.jitter);\n    pj_math_stat_init(&stat->tx.loss_period);\n    pj_math_stat_init(&stat->tx.jitter);\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_IPDV) && PJMEDIA_RTCP_STAT_HAS_IPDV!=0\n    pj_math_stat_init(&stat->rx_ipdv);\n#endif\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_RAW_JITTER) && PJMEDIA_RTCP_STAT_HAS_RAW_JITTER!=0\n    pj_math_stat_init(&stat->rx_raw_jitter);\n#endif\n\n    pj_gettimeofday(&now);\n    stat->start = now;\n}\n\n\n/*\n * Initialize RTCP session.\n */\nPJ_DEF(void) pjmedia_rtcp_init(pjmedia_rtcp_session *sess, \n\t\t\t       char *name,\n\t\t\t       unsigned clock_rate,\n\t\t\t       unsigned samples_per_frame,\n\t\t\t       pj_uint32_t ssrc)\n{\n    pjmedia_rtcp_session_setting settings;\n\n    pjmedia_rtcp_session_setting_default(&settings);\n    settings.name = name;\n    settings.clock_rate = clock_rate;\n    settings.samples_per_frame = samples_per_frame;\n    settings.ssrc = ssrc;\n\n    pjmedia_rtcp_init2(sess, &settings);\n}\n\n\n/*\n * Initialize RTCP session.\n */\nPJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n\t\t\t\t const pjmedia_rtcp_session_setting *settings)\n{\n    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;\n    pj_time_val now;\n    \n    /* Memset everything */\n    pj_bzero(sess, sizeof(pjmedia_rtcp_session));\n\n    /* Last RX timestamp in RTP packet */\n    sess->rtp_last_ts = (unsigned)-1;\n\n    /* Name */\n    sess->name = settings->name ? settings->name : (char*)THIS_FILE;\n\n    /* Set clock rate */\n    sess->clock_rate = settings->clock_rate;\n    sess->pkt_size = settings->samples_per_frame;\n\n    /* Init common RTCP SR header */\n    sr_pkt->common.version = 2;\n    sr_pkt->common.count = 1;\n    sr_pkt->common.pt = RTCP_SR;\n    sr_pkt->common.length = pj_htons(12);\n    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);\n    \n    /* Copy to RTCP RR header */\n    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n    sess->rtcp_rr_pkt.common.length = pj_htons(7);\n\n    /* Get time and timestamp base and frequency */\n    pj_gettimeofday(&now);\n    sess->tv_base = now;\n    pj_get_timestamp(&sess->ts_base);\n    pj_get_timestamp_freq(&sess->ts_freq);\n    sess->rtp_ts_base = settings->rtp_ts_base;\n\n    /* Initialize statistics states */\n    pjmedia_rtcp_init_stat(&sess->stat);\n\n    /* RR will be initialized on receipt of the first RTP packet. */\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_fini(pjmedia_rtcp_session *sess)\n{\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    pjmedia_rtcp_xr_fini(&sess->xr_session);\n#else\n    /* Nothing to do. */\n    PJ_UNUSED_ARG(sess);\n#endif\n}\n\nstatic void rtcp_init_seq(pjmedia_rtcp_session *sess)\n{\n    sess->received = 0;\n    sess->exp_prior = 0;\n    sess->rx_prior = 0;\n    sess->transit = 0;\n    sess->jitter = 0;\n}\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtp( pjmedia_rtcp_session *sess, \n\t\t\t\t  unsigned seq, \n\t\t\t\t  unsigned rtp_ts,\n\t\t\t\t  unsigned payload)\n{\n    pjmedia_rtcp_rx_rtp2(sess, seq, rtp_ts, payload, PJ_FALSE);\n}\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtp2(pjmedia_rtcp_session *sess, \n\t\t\t\t  unsigned seq, \n\t\t\t\t  unsigned rtp_ts,\n\t\t\t\t  unsigned payload,\n\t\t\t\t  pj_bool_t discarded)\n{   \n    pj_timestamp ts;\n    pj_uint32_t arrival;\n    pj_int32_t transit;\n    pjmedia_rtp_status seq_st;\n\n#if !defined(PJMEDIA_HAS_RTCP_XR) || (PJMEDIA_HAS_RTCP_XR == 0)\n    PJ_UNUSED_ARG(discarded);\n#endif\n\n    if (sess->stat.rx.pkt == 0) {\n\t/* Init sequence for the first time. */\n\tpjmedia_rtp_seq_init(&sess->seq_ctrl, (pj_uint16_t)seq);\n    } \n\n    sess->stat.rx.pkt++;\n    sess->stat.rx.bytes += payload;\n\n    /* Process the RTP packet. */\n    pjmedia_rtp_seq_update(&sess->seq_ctrl, (pj_uint16_t)seq, &seq_st);\n\n    if (seq_st.status.flag.restart) {\n\trtcp_init_seq(sess);\n    }\n    \n    if (seq_st.status.flag.dup) {\n\tsess->stat.rx.dup++;\n\tTRACE_((sess->name, \"Duplicate packet detected\"));\n    }\n\n    if (seq_st.status.flag.outorder && !seq_st.status.flag.probation) {\n\tsess->stat.rx.reorder++;\n\tTRACE_((sess->name, \"Out-of-order packet detected\"));\n    }\n\n    if (seq_st.status.flag.bad) {\n\tsess->stat.rx.discard++;\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\tpjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t       -1,\t\t\t\t /* lost    */\n\t\t\t       (seq_st.status.flag.dup? 1:0),\t /* dup     */\n\t\t\t       (!seq_st.status.flag.dup? 1:-1),  /* discard */\n\t\t\t       -1,\t\t\t\t /* jitter  */\n\t\t\t       -1, 0);\t\t\t\t /* toh\t    */\n#endif\n\n\tTRACE_((sess->name, \"Bad packet discarded\"));\n\treturn;\n    }\n\n    /* Only mark \"good\" packets */\n    ++sess->received;\n\n    /* Calculate loss periods. */\n    if (seq_st.diff > 1) {\n\tunsigned count = seq_st.diff - 1;\n\tunsigned period;\n\n\tperiod = count * sess->pkt_size * 1000 / sess->clock_rate;\n\tperiod *= 1000;\n\n\t/* Update packet lost. \n\t * The packet lost number will also be updated when we're sending\n\t * outbound RTCP RR.\n\t */\n\tsess->stat.rx.loss += (seq_st.diff - 1);\n\tTRACE_((sess->name, \"%d packet(s) lost\", seq_st.diff - 1));\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.rx.loss_period, period);\n    }\n\n\n    /*\n     * Calculate jitter only when sequence is good (see RFC 3550 section A.8),\n     * AND only when the timestamp is different than the last packet\n     * (see RTP FAQ).\n     */\n    if (seq_st.diff == 1 && rtp_ts != sess->rtp_last_ts) {\n\t/* Get arrival time and convert timestamp to samples */\n\tpj_get_timestamp(&ts);\n\tts.u64 = ts.u64 * sess->clock_rate / sess->ts_freq.u64;\n\tarrival = ts.u32.lo;\n\n\ttransit = arrival - rtp_ts;\n    \n\t/* Ignore the first N packets as they normally have bad jitter\n\t * due to other threads working to establish the call\n\t */\n\tif (sess->transit == 0 || \n\t    sess->received < PJMEDIA_RTCP_IGNORE_FIRST_PACKETS) \n\t{\n\t    sess->transit = transit;\n\t    sess->stat.rx.jitter.min = (unsigned)-1;\n\t} else {\n\t    pj_int32_t d;\n\t    pj_uint32_t jitter;\n\n\t    d = transit - sess->transit;\n\t    if (d < 0) \n\t\td = -d;\n\t    \n\t    sess->jitter += d - ((sess->jitter + 8) >> 4);\n\n\t    /* Update jitter stat */\n\t    jitter = sess->jitter >> 4;\n\t    \n\t    /* Convert jitter unit from samples to usec */\n\t    if (jitter < 4294)\n\t\tjitter = jitter * 1000000 / sess->clock_rate;\n\t    else {\n\t\tjitter = jitter * 1000 / sess->clock_rate;\n\t\tjitter *= 1000;\n\t    }\n\t    pj_math_stat_update(&sess->stat.rx.jitter, jitter);\n\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_RAW_JITTER) && PJMEDIA_RTCP_STAT_HAS_RAW_JITTER!=0\n\t    {\n\t\tpj_uint32_t raw_jitter;\n\n\t\t/* Convert raw jitter unit from samples to usec */\n\t\tif (d < 4294)\n\t\t    raw_jitter = d * 1000000 / sess->clock_rate;\n\t\telse {\n\t\t    raw_jitter = d * 1000 / sess->clock_rate;\n\t\t    raw_jitter *= 1000;\n\t\t}\n\t\t\n\t\t/* Update jitter stat */\n\t\tpj_math_stat_update(&sess->stat.rx_raw_jitter, raw_jitter);\n\t    }\n#endif\n\n\n#if defined(PJMEDIA_RTCP_STAT_HAS_IPDV) && PJMEDIA_RTCP_STAT_HAS_IPDV!=0\n\t    {\n\t\tpj_int32_t ipdv;\n\n\t\tipdv = transit - sess->transit;\n\t\t/* Convert IPDV unit from samples to usec */\n\t\tif (ipdv > -2147 && ipdv < 2147)\n\t\t    ipdv = ipdv * 1000000 / (int)sess->clock_rate;\n\t\telse {\n\t\t    ipdv = ipdv * 1000 / (int)sess->clock_rate;\n\t\t    ipdv *= 1000;\n\t\t}\n\t\t\n\t\t/* Update jitter stat */\n\t\tpj_math_stat_update(&sess->stat.rx_ipdv, ipdv);\n\t    }\n#endif\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\t    pjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t\t   0,\t\t\t    /* lost    */\n\t\t\t\t   0,\t\t\t    /* dup     */\n\t\t\t\t   discarded,\t\t    /* discard */\n\t\t\t\t   (sess->jitter >> 4),\t    /* jitter  */\n\t\t\t\t   -1, 0);\t\t    /* toh     */\n#endif\n\n\t    /* Update session transit */\n\t    sess->transit = transit;\n\t}\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (seq_st.diff > 1) {\n\tint i;\n\n\t/* Report RTCP XR about packet losses */\n\tfor (i=seq_st.diff-1; i>0; --i) {\n\t    pjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq - i, \n\t\t\t\t   1,\t\t\t    /* lost    */\n\t\t\t\t   0,\t\t\t    /* dup     */\n\t\t\t\t   0,\t\t\t    /* discard */\n\t\t\t\t   -1,\t\t\t    /* jitter  */\n\t\t\t\t   -1, 0);\t\t    /* toh     */\n\t}\n\n\t/* Report RTCP XR this packet */\n\tpjmedia_rtcp_xr_rx_rtp(&sess->xr_session, seq, \n\t\t\t       0,\t\t\t    /* lost    */\n\t\t\t       0,\t\t\t    /* dup     */\n\t\t\t       discarded,\t\t    /* discard */\n\t\t\t       -1,\t\t\t    /* jitter  */\n\t\t\t       -1, 0);\t\t\t    /* toh     */\n#endif\n    }\n\n    /* Update timestamp of last RX RTP packet */\n    sess->rtp_last_ts = rtp_ts;\n}\n\nPJ_DEF(void) pjmedia_rtcp_tx_rtp(pjmedia_rtcp_session *sess, \n\t\t\t\t unsigned bytes_payload_size)\n{\n    /* Update statistics */\n    sess->stat.tx.pkt++;\n    sess->stat.tx.bytes += bytes_payload_size;\n}\n\n\nstatic void parse_rtcp_report( pjmedia_rtcp_session *sess,\n\t\t\t       const void *pkt,\n\t\t\t       pj_size_t size)\n{\n    pjmedia_rtcp_common *common = (pjmedia_rtcp_common*) pkt;\n    const pjmedia_rtcp_rr *rr = NULL;\n    const pjmedia_rtcp_sr *sr = NULL;\n    pj_uint32_t last_loss, jitter_samp, jitter;\n\n    /* Parse RTCP */\n    if (common->pt == RTCP_SR) {\n        if (sizeof (pjmedia_rtcp_common) + sizeof (pjmedia_rtcp_sr) > size) {\n\t    TRACE_((sess->name, \"Discarding RTCP SR due to truncated size \"\n\t    \t\t\t\"%d bytes\", size));\n            return;\n        }\n\tsr = (pjmedia_rtcp_sr*) (((char*)pkt) + sizeof(pjmedia_rtcp_common));\n\tif (common->count > 0 && size >= (sizeof(pjmedia_rtcp_sr_pkt))) {\n\t    rr = (pjmedia_rtcp_rr*)(((char*)pkt) + (sizeof(pjmedia_rtcp_common)\n\t\t\t\t    + sizeof(pjmedia_rtcp_sr)));\n\t}\n    } else if (common->pt == RTCP_RR && common->count > 0) {\n\tif (sizeof (pjmedia_rtcp_common) + sizeof (pjmedia_rtcp_rr) > size) {\n\t    TRACE_((sess->name, \"Discarding RTCP RR due to truncated size \"\n\t    \t\t\t\"%d bytes\", size));\n\t    return;\n\t}\n\trr = (pjmedia_rtcp_rr*)(((char*)pkt) + sizeof(pjmedia_rtcp_common));\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (common->pt == RTCP_XR) {\n\tif (sess->xr_enabled)\n\t    pjmedia_rtcp_xr_rx_rtcp_xr(&sess->xr_session, pkt, size);\n\n\treturn;\n#endif\n    }\n\n\n    if (sr) {\n\t/* Save LSR from NTP timestamp of RTCP packet */\n\tsess->rx_lsr = ((pj_ntohl(sr->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(sr->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate SR arrival time for DLSR */\n\tpj_get_timestamp(&sess->rx_lsr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", \n\t\tsess->rx_lsr,\n\t\t(pj_uint32_t)(sess->rx_lsr_time.u64*65536/sess->ts_freq.u64)));\n    }\n\n\n    /* Nothing more to do if there's no RR packet */\n    if (rr == NULL)\n\treturn;\n\n\n    last_loss = sess->stat.tx.loss;\n\n    /* Get packet loss */\n    sess->stat.tx.loss = (rr->total_lost_2 << 16) +\n\t\t\t (rr->total_lost_1 << 8) +\n\t\t\t  rr->total_lost_0;\n\n    TRACE_((sess->name, \"Rx RTCP RR: total_lost_2=%x, 1=%x, 0=%x, lost=%d\", \n\t    (int)rr->total_lost_2,\n\t    (int)rr->total_lost_1,\n\t    (int)rr->total_lost_0,\n\t    sess->stat.tx.loss));\n    \n    /* We can't calculate the exact loss period for TX, so just give the\n     * best estimation.\n     */\n    if (sess->stat.tx.loss > last_loss) {\n\tunsigned period;\n\n\t/* Loss period in msec */\n\tperiod = (sess->stat.tx.loss - last_loss) * sess->pkt_size *\n\t\t 1000 / sess->clock_rate;\n\n\t/* Loss period in usec */\n\tperiod *= 1000;\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.tx.loss_period, period);\n    }\n\n    /* Get jitter value in usec */\n    jitter_samp = pj_ntohl(rr->jitter);\n    /* Calculate jitter in usec, avoiding overflows */\n    if (jitter_samp <= 4294)\n\tjitter = jitter_samp * 1000000 / sess->clock_rate;\n    else {\n\tjitter = jitter_samp * 1000 / sess->clock_rate;\n\tjitter *= 1000;\n    }\n\n    /* Update jitter statistics */\n    pj_math_stat_update(&sess->stat.tx.jitter, jitter);\n\n    /* Can only calculate if LSR and DLSR is present in RR */\n    if (rr->lsr && rr->dlsr) {\n\tpj_uint32_t lsr, now, dlsr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LSR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlsr = pj_ntohl(rr->lsr);\n\n\t/* DLSR is delay since LSR, also in 1/65536 resolution */\n\tdlsr = pj_ntohl(rr->dlsr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lsr-dlsr) */\n\teedelay = now - lsr - dlsr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP RR: lsr=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlsr, dlsr, dlsr/65536, (dlsr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lsr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlsr >= lsr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay > 30 * 1000 * 1000UL) {\n\n\t\tTRACE_((sess->name, \"RTT not making any sense, ignored..\"));\n\t\tgoto end_rtt_calc;\n\t    }\n\n#if defined(PJMEDIA_RTCP_NORMALIZE_FACTOR) && PJMEDIA_RTCP_NORMALIZE_FACTOR!=0\n\t    /* \"Normalize\" rtt value that is exceptionally high. For such\n\t     * values, \"normalize\" the rtt to be PJMEDIA_RTCP_NORMALIZE_FACTOR\n\t     * times the average value.\n\t     */\n\t    if (rtt > ((unsigned)sess->stat.rtt.mean *\n\t\t       PJMEDIA_RTCP_NORMALIZE_FACTOR) && sess->stat.rtt.n!=0)\n\t    {\n\t\tunsigned orig_rtt = rtt;\n\t\trtt = sess->stat.rtt.mean * PJMEDIA_RTCP_NORMALIZE_FACTOR;\n\t\tPJ_LOG(5,(sess->name,\n\t\t\t  \"RTT value %d usec is normalized to %d usec\",\n\t\t\t  orig_rtt, rtt));\n\t    }\n#endif\n\t    TRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\n\t    /* Update RTT stat */\n\t    pj_math_stat_update(&sess->stat.rtt, rtt);\n\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lsr=%p, now=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lsr, now, dlsr, dlsr/65536,\n\t\t\t\t   (dlsr%65536)*1000/65536,\n\t\t\t\t   dlsr-(now-lsr)));\n\t}\n    }\n\nend_rtt_calc:\n\n    pj_gettimeofday(&sess->stat.tx.update);\n    sess->stat.tx.update_cnt++;\n}\n\n\nstatic void parse_rtcp_sdes(pjmedia_rtcp_session *sess,\n\t\t\t    const void *pkt,\n\t\t\t    pj_size_t size)\n{\n    pjmedia_rtcp_sdes *sdes = &sess->stat.peer_sdes;\n    char *p, *p_end;\n    char *b, *b_end;\n\n    p = (char*)pkt + 8;\n    p_end = (char*)pkt + size;\n\n    pj_bzero(sdes, sizeof(*sdes));\n    b = sess->stat.peer_sdes_buf_;\n    b_end = b + sizeof(sess->stat.peer_sdes_buf_);\n\n    while (p < p_end) {\n\tpj_uint8_t sdes_type, sdes_len;\n\tpj_str_t sdes_value = {NULL, 0};\n\n\tsdes_type = *p++;\n\n\t/* Check for end of SDES item list */\n\tif (sdes_type == RTCP_SDES_NULL || p == p_end)\n\t    break;\n\n\tsdes_len = *p++;\n\n\t/* Check for corrupted SDES packet */\n\tif (p + sdes_len > p_end)\n\t    break;\n\n\t/* Get SDES item */\n\tif (b + sdes_len < b_end) {\n\t    pj_memcpy(b, p, sdes_len);\n\t    sdes_value.ptr = b;\n\t    sdes_value.slen = sdes_len;\n\t    b += sdes_len;\n\t} else {\n\t    /* Insufficient SDES buffer */\n\t    PJ_LOG(5, (sess->name,\n\t\t    \"Unsufficient buffer to save RTCP SDES type %d:%.*s\",\n\t\t    sdes_type, sdes_len, p));\n\t    p += sdes_len;\n\t    continue;\n\t}\n\n\tswitch (sdes_type) {\n\tcase RTCP_SDES_CNAME:\n\t    sdes->cname = sdes_value;\n\t    break;\n\tcase RTCP_SDES_NAME:\n\t    sdes->name = sdes_value;\n\t    break;\n\tcase RTCP_SDES_EMAIL:\n\t    sdes->email = sdes_value;\n\t    break;\n\tcase RTCP_SDES_PHONE:\n\t    sdes->phone = sdes_value;\n\t    break;\n\tcase RTCP_SDES_LOC:\n\t    sdes->loc = sdes_value;\n\t    break;\n\tcase RTCP_SDES_TOOL:\n\t    sdes->tool = sdes_value;\n\t    break;\n\tcase RTCP_SDES_NOTE:\n\t    sdes->note = sdes_value;\n\t    break;\n\tdefault:\n\t    TRACE_((sess->name, \"Received unknown RTCP SDES type %d:%.*s\",\n\t\t    sdes_type, sdes_value.slen, sdes_value.ptr));\n\t    break;\n\t}\n\n\tp += sdes_len;\n    }\n}\n\n\nstatic void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n\n    /* Check and get BYE reason */\n    if (size > 8) {\n    \t/* Make sure the BYE reason does not exceed:\n    \t * - the size of the available buffer\n    \t * - the declared reason's length\n    \t * - the actual packet size\n    \t */\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n        reason.slen = PJ_MIN(reason.slen, size-9);\n\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n\n    /* Just print RTCP BYE log */\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}\n\n\nstatic void parse_rtcp_fb(pjmedia_rtcp_session *sess,\n\t\t\t  const void *pkt,\n\t\t\t  pj_size_t size)\n{\n    unsigned cnt = 1;\n    pjmedia_rtcp_fb_nack nack[1];\n    //pjmedia_rtcp_fb_sli sli[1];\n    //pjmedia_rtcp_fb_rpsi rpsi;\n    pjmedia_event ev;\n    pj_timestamp ts_now;\n\n    pj_get_timestamp(&ts_now);\n\n    if (pjmedia_rtcp_fb_parse_nack(pkt, size, &cnt, nack)==PJ_SUCCESS)\n    {\n\tpjmedia_event_init(&ev, PJMEDIA_EVENT_RX_RTCP_FB, &ts_now, sess);\n\tev.data.rx_rtcp_fb.cap.type = PJMEDIA_RTCP_FB_NACK;\n\tev.data.rx_rtcp_fb.msg.nack = nack[0];\n\tpjmedia_event_publish(NULL, sess, &ev, 0);\n\n    } else if (pjmedia_rtcp_fb_parse_pli(pkt, size)==PJ_SUCCESS)\n    {\n\tpjmedia_event_init(&ev, PJMEDIA_EVENT_RX_RTCP_FB, &ts_now, sess);\n\tev.data.rx_rtcp_fb.cap.type = PJMEDIA_RTCP_FB_NACK;\n\tpj_strset2(&ev.data.rx_rtcp_fb.cap.param, (char*)\"pli\");\n\tpjmedia_event_publish(NULL, sess, &ev, 0);\n\n\t/*  For other FB type implementations later\n    } else if (pjmedia_rtcp_fb_parse_sli(pkt, size, &cnt, sli)==PJ_SUCCESS)\n    {\n    } else if (pjmedia_rtcp_fb_parse_rpsi(pkt, size, &rpsi)==PJ_SUCCESS)\n    {\n\t*/\n    } else {\n\t/* Ignore unknown RTCP Feedback */\n\tTRACE_((sess->name, \"Received unknown RTCP feedback\"));\n    }\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n\t\t\t\t   const void *pkt,\n\t\t\t\t   pj_size_t size)\n{\n    pj_uint8_t *p, *p_end;\n\n    p = (pj_uint8_t*)pkt;\n    p_end = p + size;\n    while (p < p_end) {\n\tpjmedia_rtcp_common *common;\n\tunsigned len;\n\n\tif (p + sizeof(pjmedia_rtcp_common) > p_end) {\n\t    TRACE_((sess->name, \"Receiving truncated RTCP packet (1)\"));\n\t    break;\n\t}\n\tcommon = (pjmedia_rtcp_common*)p;\n\n\tlen = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;\n\tif (p + len > p_end) {\n\t    TRACE_((sess->name, \"Receiving truncated RTCP packet (2)\"));\n\t    break;\n\t}\n\n\tswitch(common->pt) {\n\tcase RTCP_SR:\n\tcase RTCP_RR:\n\tcase RTCP_XR:\n\t    parse_rtcp_report(sess, p, len);\n\t    break;\n\tcase RTCP_SDES:\n\t    parse_rtcp_sdes(sess, p, len);\n\t    break;\n\tcase RTCP_BYE:\n\t    parse_rtcp_bye(sess, p, len);\n\t    break;\n\tcase RTCP_RTPFB:\n\tcase RTCP_PSFB:\n\t    parse_rtcp_fb(sess, p, len);\n\t    break;\n\tdefault:\n\t    /* Ignore unknown RTCP */\n\t    TRACE_((sess->name, \"Received unknown RTCP packet type=%d\",\n\t\t    common->pt));\n\t    break;\n\t}\n\n\tp += len;\n    }\n}\n\n\nPJ_DEF(void) pjmedia_rtcp_build_rtcp(pjmedia_rtcp_session *sess, \n\t\t\t\t     void **ret_p_pkt, int *len)\n{\n    pj_uint32_t expected, expected_interval, received_interval, lost_interval;\n    pjmedia_rtcp_sr *sr;\n    pjmedia_rtcp_rr *rr;\n    pj_timestamp ts_now;\n    pjmedia_rtcp_ntp_rec ntp;\n\n    /* Get current NTP time. */\n    pj_get_timestamp(&ts_now);\n    pjmedia_rtcp_get_ntp_time(sess, &ntp);\n\n\n    /* See if we have transmitted RTP packets since last time we\n     * sent RTCP SR.\n     */\n    if (sess->stat.tx.pkt != pj_ntohl(sess->rtcp_sr_pkt.sr.sender_pcount)) {\n\tpj_time_val ts_time;\n\tpj_uint32_t rtp_ts;\n\n\t/* So we should send RTCP SR */\n\t*ret_p_pkt = (void*) &sess->rtcp_sr_pkt;\n\t*len = sizeof(pjmedia_rtcp_sr_pkt);\n\trr = &sess->rtcp_sr_pkt.rr;\n\tsr = &sess->rtcp_sr_pkt.sr;\n\n\t/* Update packet count */\n\tsr->sender_pcount = pj_htonl(sess->stat.tx.pkt);\n\n\t/* Update octets count */\n\tsr->sender_bcount = pj_htonl(sess->stat.tx.bytes);\n\n\t/* Fill in NTP timestamp in SR. */\n\tsr->ntp_sec = pj_htonl(ntp.hi);\n\tsr->ntp_frac = pj_htonl(ntp.lo);\n\n\t/* Fill in RTP timestamp (corresponds to NTP timestamp) in SR. */\n\tts_time.sec = ntp.hi - sess->tv_base.sec - JAN_1970;\n\tts_time.msec = (long)(ntp.lo * 1000.0 / 0xFFFFFFFF);\n\trtp_ts = sess->rtp_ts_base +\n\t\t (pj_uint32_t)(sess->clock_rate*ts_time.sec) +\n\t\t (pj_uint32_t)(sess->clock_rate*ts_time.msec/1000);\n\tsr->rtp_ts = pj_htonl(rtp_ts);\n\n\tTRACE_((sess->name, \"TX RTCP SR: ntp_ts=%p\", \n\t\t\t   ((ntp.hi & 0xFFFF) << 16) + ((ntp.lo & 0xFFFF0000) \n\t\t\t\t>> 16)));\n\n\n    } else {\n\t/* We should send RTCP RR then */\n\t*ret_p_pkt = (void*) &sess->rtcp_rr_pkt;\n\t*len = sizeof(pjmedia_rtcp_rr_pkt);\n\trr = &sess->rtcp_rr_pkt.rr;\n\tsr = NULL;\n    }\n    \n    /* SSRC and last_seq */\n    rr->ssrc = pj_htonl(sess->peer_ssrc);\n    rr->last_seq = (sess->seq_ctrl.cycles & 0xFFFF0000L);\n    /* Since this is an \"+=\" operation, make sure we update last_seq on\n     * both RR and SR.\n     */\n    sess->rtcp_sr_pkt.rr.last_seq += sess->seq_ctrl.max_seq;\n    sess->rtcp_rr_pkt.rr.last_seq += sess->seq_ctrl.max_seq;\n    rr->last_seq = pj_htonl(rr->last_seq);\n\n\n    /* Jitter */\n    rr->jitter = pj_htonl(sess->jitter >> 4);\n    \n    \n    /* Total lost. */\n    expected = pj_ntohl(rr->last_seq) - sess->seq_ctrl.base_seq;\n\n    /* This is bug: total lost already calculated on each incoming RTP!\n    if (expected >= sess->received)\n\tsess->stat.rx.loss = expected - sess->received;\n    else\n\tsess->stat.rx.loss = 0;\n    */\n\n    rr->total_lost_2 = (sess->stat.rx.loss >> 16) & 0xFF;\n    rr->total_lost_1 = (sess->stat.rx.loss >> 8) & 0xFF;\n    rr->total_lost_0 = (sess->stat.rx.loss & 0xFF);\n\n    /* Fraction lost calculation */\n    expected_interval = expected - sess->exp_prior;\n    sess->exp_prior = expected;\n    \n    received_interval = sess->received - sess->rx_prior;\n    sess->rx_prior = sess->received;\n    \n    if (expected_interval >= received_interval)\n\tlost_interval = expected_interval - received_interval;\n    else\n\tlost_interval = 0;\n    \n    if (expected_interval==0 || lost_interval == 0) {\n\trr->fract_lost = 0;\n    } else {\n\trr->fract_lost = (lost_interval << 8) / expected_interval;\n    }\n    \n    if (sess->rx_lsr_time.u64 == 0 || sess->rx_lsr == 0) {\n\trr->lsr = 0;\n\trr->dlsr = 0;\n    } else {\n\tpj_timestamp ts;\n\tpj_uint32_t lsr = sess->rx_lsr;\n\tpj_uint64_t lsr_time = sess->rx_lsr_time.u64;\n\tpj_uint32_t dlsr;\n\t\n\t/* Convert LSR time to 1/65536 seconds resolution */\n\tlsr_time = (lsr_time << 16) / sess->ts_freq.u64;\n\n\t/* Fill in LSR.\n\t   LSR is the middle 32bit of the last SR NTP time received.\n\t */\n\trr->lsr = pj_htonl(lsr);\n\t\n\t/* Fill in DLSR.\n\t   DLSR is Delay since Last SR, in 1/65536 seconds.\n\t */\n\tts.u64 = ts_now.u64;\n\n\t/* Convert interval to 1/65536 seconds value */\n\tts.u64 = (ts.u64 << 16) / sess->ts_freq.u64;\n\n\t/* Get DLSR */\n\tdlsr = (pj_uint32_t)(ts.u64 - lsr_time);\n\trr->dlsr = pj_htonl(dlsr);\n\n\tTRACE_((sess->name,\"Tx RTCP RR: lsr=%p, lsr_time=%p, now=%p, dlsr=%p\"\n\t\t\t   \"(%ds:%03dms)\",\n\t\t\t   lsr, \n\t\t\t   (pj_uint32_t)lsr_time,\n\t\t\t   (pj_uint32_t)ts.u64, \n\t\t\t   dlsr,\n\t\t\t   dlsr/65536,\n\t\t\t   (dlsr%65536)*1000/65536 ));\n    }\n    \n    /* Update counter */\n    pj_gettimeofday(&sess->stat.rx.update);\n    sess->stat.rx.update_cnt++;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_build_rtcp_sdes(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_sdes *sdes)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    pj_size_t len;\n\n    PJ_ASSERT_RETURN(session && buf && length && sdes, PJ_EINVAL);\n\n    /* Verify SDES item length */\n    if (sdes->cname.slen > 255 || sdes->name.slen  > 255 ||\n\tsdes->email.slen > 255 || sdes->phone.slen > 255 ||\n\tsdes->loc.slen   > 255 || sdes->tool.slen  > 255 ||\n\tsdes->note.slen  > 255)\n    {\n\treturn PJ_EINVAL;\n    }\n\n    /* Verify buffer length */\n    len = sizeof(*hdr);\n    if (sdes->cname.slen) len += sdes->cname.slen + 2;\n    if (sdes->name.slen)  len += sdes->name.slen  + 2;\n    if (sdes->email.slen) len += sdes->email.slen + 2;\n    if (sdes->phone.slen) len += sdes->phone.slen + 2;\n    if (sdes->loc.slen)   len += sdes->loc.slen   + 2;\n    if (sdes->tool.slen)  len += sdes->tool.slen  + 2;\n    if (sdes->note.slen)  len += sdes->note.slen  + 2;\n    len++; /* null termination */\n    len = ((len+3)/4) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP SDES header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_sr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_SDES;\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP SDES items */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n#define BUILD_SDES_ITEM(SDES_NAME, SDES_TYPE) \\\n    if (sdes->SDES_NAME.slen) { \\\n\t*p++ = SDES_TYPE; \\\n\t*p++ = (pj_uint8_t)sdes->SDES_NAME.slen; \\\n\tpj_memcpy(p, sdes->SDES_NAME.ptr, sdes->SDES_NAME.slen); \\\n\tp += sdes->SDES_NAME.slen; \\\n    }\n    BUILD_SDES_ITEM(cname, RTCP_SDES_CNAME);\n    BUILD_SDES_ITEM(name,  RTCP_SDES_NAME);\n    BUILD_SDES_ITEM(email, RTCP_SDES_EMAIL);\n    BUILD_SDES_ITEM(phone, RTCP_SDES_PHONE);\n    BUILD_SDES_ITEM(loc,   RTCP_SDES_LOC);\n    BUILD_SDES_ITEM(tool,  RTCP_SDES_TOOL);\n    BUILD_SDES_ITEM(note,  RTCP_SDES_NOTE);\n#undef BUILD_SDES_ITEM\n\n    /* Null termination */\n    *p++ = 0;\n\n    /* Pad to 32bit */\n    while ((p-(pj_uint8_t*)buf) % 4)\n\t*p++ = 0;\n\n    /* Finally */\n    pj_assert((int)len == p-(pj_uint8_t*)buf);\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_build_rtcp_bye(pjmedia_rtcp_session *session,\n\t\t\t\t\t\tvoid *buf,\n\t\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\t\tconst pj_str_t *reason)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    pj_size_t len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    /* Verify BYE reason length */\n    if (reason && reason->slen > 255)\n\treturn PJ_EINVAL;\n\n    /* Verify buffer length */\n    len = sizeof(*hdr);\n    if (reason && reason->slen) len += reason->slen + 1;\n    len = ((len+3)/4) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP BYE header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_sr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_BYE;\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Write RTCP BYE reason */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    if (reason && reason->slen) {\n\t*p++ = (pj_uint8_t)reason->slen;\n\tpj_memcpy(p, reason->ptr, reason->slen);\n\tp += reason->slen;\n    }\n\n    /* Pad to 32bit */\n    while ((p-(pj_uint8_t*)buf) % 4)\n\t*p++ = 0;\n\n    pj_assert((int)len == p-(pj_uint8_t*)buf);\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_enable_xr( pjmedia_rtcp_session *sess, \n\t\t\t\t\t    pj_bool_t enable)\n{\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\n    /* Check if request won't change anything */\n    if (!(enable ^ sess->xr_enabled))\n\treturn PJ_SUCCESS;\n\n    if (!enable) {\n\tsess->xr_enabled = PJ_FALSE;\n\treturn PJ_SUCCESS;\n    }\n\n    pjmedia_rtcp_xr_init(&sess->xr_session, sess, 0, 1);\n    sess->xr_enabled = PJ_TRUE;\n\n    return PJ_SUCCESS;\n\n#else\n\n    PJ_UNUSED_ARG(sess);\n    PJ_UNUSED_ARG(enable);\n    return PJ_ENOTSUP;\n\n#endif\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2018 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjmedia/rtcp_fb.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/vid_codec.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n#define THIS_FILE \"rtcp_fb.c\"\n\n#define RTCP_RTPFB\t205\n#define RTCP_PSFB\t206\n\n/*\n * Build an RTCP-FB Generic NACK packet.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB NACK header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_RTPFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB NACK FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;\n    }\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Build an RTCP-FB Picture Loss Indication (PLI) packet.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length)\n{\n    pjmedia_rtcp_common *hdr;\n    unsigned len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    len = 12;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB PLI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Build an RTCP-FB Slice Loss Indication (SLI) packet.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_sli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned sli_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && sli_cnt && sli, PJ_EINVAL);\n\n    len = (3 + sli_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB SLI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 2; /* FMT = 2 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB SLI FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\t*p++  = (pj_uint8_t)((sli[i].first >> 5) & 0xFF);   /* 8 MSB bits */\n\t*p    = (pj_uint8_t)((sli[i].first & 31) << 3);\t    /* 5 LSB bits */\n\t/* 'number' takes 13 bit */\n\t*p++ |= (pj_uint8_t)((sli[i].number >> 10) & 7);    /* 3 MSB bits */\n\t*p++  = (pj_uint8_t)((sli[i].number >> 2) & 0xFF);  /* 8 mid bits */\n\t*p    = (pj_uint8_t)((sli[i].number & 3) << 6);\t    /* 2 LSB bits */\n\t/* 'pict_id' takes 6 bit */\n\t*p++ |= (sli[i].pict_id & 63);\n    }\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Build an RTCP-FB Slice Loss Indication (SLI) packet.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned bitlen, padlen, len;\n\n    PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL);\n\n    bitlen = rpsi->rpsi_bit_len + 16;\n    padlen = (32 - (bitlen % 32)) % 32;\n    len = (3 + (bitlen+padlen)/32) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB RPSI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 3; /* FMT = 3 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB RPSI FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    /* PB (number of padding bits) */\n    *p++ = (pj_uint8_t)padlen;\n    /* Payload type */\n    *p++ = rpsi->pt & 0x7F;\n    /* RPSI bit string */\n    pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8);\n    p += rpsi->rpsi_bit_len/8;\n    if (rpsi->rpsi_bit_len % 8) {\n\t*p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8);\n    }\n    /* Zero padding */\n    if (padlen >= 8)\n\tpj_bzero(p, padlen/8);\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Initialize RTCP Feedback setting with default values.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_setting_default(\n\t\t\t\t\tpjmedia_rtcp_fb_setting *opt)\n{\n    pj_bzero(opt, sizeof(*opt));\n    opt->dont_use_avpf = PJ_TRUE;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void pjmedia_rtcp_fb_cap_dup(pj_pool_t *pool,\n\t\t\t\t    pjmedia_rtcp_fb_cap *dst,\n\t\t\t\t    const pjmedia_rtcp_fb_cap *src)\n{\n    pj_strdup(pool, &dst->codec_id, &src->codec_id);\n    dst->type = src->type;\n    pj_strdup(pool, &dst->type_name, &src->type_name);\n    pj_strdup(pool, &dst->param, &src->param);\n}\n\n\n/*\n * Duplicate RTCP Feedback setting.\n */\nPJ_DEF(void) pjmedia_rtcp_fb_setting_dup( pj_pool_t *pool,\n\t\t\t\t\t  pjmedia_rtcp_fb_setting *dst,\n\t\t\t\t\t  const pjmedia_rtcp_fb_setting *src)\n{\n    unsigned i;\n\n    pj_assert(pool && dst && src);\n\n    pj_memcpy(dst, src, sizeof(pjmedia_rtcp_fb_setting));\n    for (i = 0; i < src->cap_count; ++i) {\n\tpjmedia_rtcp_fb_cap_dup(pool, &dst->caps[i], &src->caps[i]);\n    }\n}\n\n\n/*\n * Duplicate RTCP Feedback info.\n */\nPJ_DEF(void) pjmedia_rtcp_fb_info_dup( pj_pool_t *pool,\n\t\t\t\t       pjmedia_rtcp_fb_info *dst,\n\t\t\t\t       const pjmedia_rtcp_fb_info *src)\n{\n    unsigned i;\n\n    pj_assert(pool && dst && src);\n\n    pj_memcpy(dst, src, sizeof(pjmedia_rtcp_fb_info));\n    for (i = 0; i < src->cap_count; ++i) {\n\tpjmedia_rtcp_fb_cap_dup(pool, &dst->caps[i], &src->caps[i]);\n    }\n}\n\n\n\nstruct rtcp_fb_type_name_t\n{\n    pjmedia_rtcp_fb_type     type;\n    const char\t\t    *name;\n} rtcp_fb_type_name[] =\n{\n    {PJMEDIA_RTCP_FB_ACK,\t\"ack\"},\n    {PJMEDIA_RTCP_FB_NACK,\t\"nack\"},\n    {PJMEDIA_RTCP_FB_TRR_INT,\t\"trr-int\"}\n};\n\n/* Generate a=rtcp-fb based on the specified PT & RTCP-FB capability */\nstatic pj_status_t add_sdp_attr_rtcp_fb( pj_pool_t *pool,\n\t\t\t\t\t const char *pt,\n\t\t\t\t\t const pjmedia_rtcp_fb_cap *cap,\n\t\t\t\t\t pjmedia_sdp_media *m)\n{\n    pjmedia_sdp_attr *a;\n    char tmp[128];\n    pj_str_t val;\n    pj_str_t type_name = {0};\n\n    if (cap->type < PJMEDIA_RTCP_FB_OTHER)\n\tpj_cstr(&type_name, rtcp_fb_type_name[cap->type].name);\n    else if (cap->type == PJMEDIA_RTCP_FB_OTHER)\n\ttype_name = cap->type_name;\n\n    if (type_name.slen == 0)\n\treturn PJ_EINVAL;\n\n    /* Generate RTCP FB param */\n    if (cap->param.slen) {\n\tpj_ansi_snprintf(tmp, sizeof(tmp), \"%s %.*s %.*s\", pt,\n\t\t\t (int)type_name.slen, type_name.ptr,\n\t\t\t (int)cap->param.slen, cap->param.ptr);\n    } else {\n\tpj_ansi_snprintf(tmp, sizeof(tmp), \"%s %.*s\", pt,\n\t\t\t (int)type_name.slen, type_name.ptr);\n    }\n    pj_strset2(&val, tmp);\n\n    /* Generate and add SDP attribute a=rtcp-fb */\n    a = pjmedia_sdp_attr_create(pool, \"rtcp-fb\", &val);\n    m->attr[m->attr_count++] = a;\n\n    return PJ_SUCCESS;\n}\n\n/* SDP codec info (ID and PT) */\ntypedef struct sdp_codec_info_t\n{\n    char\t id[32];\n    unsigned\t pt;\n} sdp_codec_info_t;\n\n\n/* Populate codec ID/name and PT in SDP */\nstatic pj_status_t get_codec_info_from_sdp(pjmedia_endpt *endpt,\n\t\t\t\t\t   const pjmedia_sdp_media *m,\n\t\t\t\t\t   unsigned *sci_cnt,\n\t\t\t\t\t   sdp_codec_info_t sci[])\n{\n    pjmedia_codec_mgr *codec_mgr;\n    unsigned j, cnt = 0;\n    pjmedia_type type = PJMEDIA_TYPE_UNKNOWN;\n    pj_status_t status;\n\n    type = pjmedia_get_type(&m->desc.media);\n    if (type != PJMEDIA_TYPE_AUDIO && type != PJMEDIA_TYPE_VIDEO)\n\treturn PJMEDIA_EUNSUPMEDIATYPE;\n\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    for (j = 0; j < m->desc.fmt_count && cnt < *sci_cnt; ++j) {\n\tunsigned pt = 0;\n\tpt = pj_strtoul(&m->desc.fmt[j]);\n\tif (pt < 96) {\n\t    if (type == PJMEDIA_TYPE_AUDIO) {\n\t\tconst pjmedia_codec_info *ci;\n\t\tstatus = pjmedia_codec_mgr_get_codec_info(codec_mgr, pt, &ci);\n\t\tif (status != PJ_SUCCESS)\n\t\t    continue;\n\n\t\tpjmedia_codec_info_to_id(ci, sci[cnt].id, sizeof(sci[0].id));\n\t    } else {\n#if defined(PJMEDIA_HAS_VIDEO) && (PJMEDIA_HAS_VIDEO != 0)\n\t\tconst pjmedia_vid_codec_info *ci;\n\t\tstatus = pjmedia_vid_codec_mgr_get_codec_info(NULL, pt, &ci);\n\t\tif (status != PJ_SUCCESS)\n\t\t    continue;\n\n\t\tpjmedia_vid_codec_info_to_id(ci, sci[cnt].id,\n\t\t\t\t\t     sizeof(sci[0].id));\n#else\n\t\tcontinue;\n#endif\n\t    }\n\t} else {\n\t    pjmedia_sdp_attr *a;\n\t    pjmedia_sdp_rtpmap r;\n\t    a = pjmedia_sdp_media_find_attr2(m, \"rtpmap\",\n\t\t\t\t\t     &m->desc.fmt[j]);\n\t    if (a == NULL)\n\t\tcontinue;\n\t    status = pjmedia_sdp_attr_get_rtpmap(a, &r);\n\t    if (status != PJ_SUCCESS)\n\t\tcontinue;\n\n\t    if (type == PJMEDIA_TYPE_AUDIO) {\n\t\t/* Audio codec id format: \"name/clock-rate/channel-count\" */\n\t\tif (r.param.slen) {\n\t\t    pj_ansi_snprintf(sci[cnt].id, sizeof(sci[0].id),\n\t\t\t\t     \"%.*s/%d/%.*s\",\n\t\t\t\t     (int)r.enc_name.slen, r.enc_name.ptr,\n\t\t\t\t     r.clock_rate,\n\t\t\t\t     (int)r.param.slen, r.param.ptr);\n\t\t} else {\n\t\t    pj_ansi_snprintf(sci[cnt].id, sizeof(sci[0].id),\n\t\t\t\t     \"%.*s/%d/1\",\n\t\t\t\t     (int)r.enc_name.slen, r.enc_name.ptr,\n\t\t\t\t     r.clock_rate);\n\t\t}\n\t    } else {\n\t\t/* Video codec id format: \"name/payload-type\" */\n\t\tpj_ansi_snprintf(sci[cnt].id, sizeof(sci[0].id),\n\t\t\t\t \"%.*s/%d\",\n\t\t\t\t (int)r.enc_name.slen, r.enc_name.ptr, pt);\n\t    }\n\t}\n\tsci[cnt++].pt = pt;\n    }\n    *sci_cnt = cnt;\n    \n    return PJ_SUCCESS;\n}\n\n/*\n * Encode RTCP Feedback specific information into the SDP according to\n * the provided RTCP Feedback setting.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_encode_sdp(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjmedia_endpt *endpt,\n\t\t\t\t    const pjmedia_rtcp_fb_setting *opt,\n\t\t\t\t    pjmedia_sdp_session *sdp_local,\n\t\t\t\t    unsigned med_idx,\n\t\t\t\t    const pjmedia_sdp_session *sdp_remote)\n{\n    pjmedia_sdp_media *m = sdp_local->media[med_idx];\n    unsigned i;\n    unsigned sci_cnt = 0;\n    sdp_codec_info_t sci[PJMEDIA_MAX_SDP_FMT];\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(sdp_remote);\n\n    PJ_ASSERT_RETURN(pool && endpt && opt && sdp_local, PJ_EINVAL);\n    PJ_ASSERT_RETURN(med_idx < sdp_local->media_count, PJ_EINVAL);\n\n    /* Add RTCP Feedback profile (AVPF), if configured to */\n    if (!opt->dont_use_avpf) {\n\tunsigned proto = pjmedia_sdp_transport_get_proto(&m->desc.transport);\n\tif (!PJMEDIA_TP_PROTO_HAS_FLAG(proto, PJMEDIA_TP_PROFILE_RTCP_FB)) {\n\t    pj_str_t new_tp;\n\t    pj_strdup_with_null(pool, &new_tp, &m->desc.transport);\n\t    new_tp.ptr[new_tp.slen++] = 'F';\n\t    m->desc.transport = new_tp;\n\t}\n    }\n\n    /* Add RTCP Feedback capability to SDP */\n    for (i = 0; i < opt->cap_count; ++i) {\n\tunsigned j;\n\n\t/* All codecs */\n\tif (pj_strcmp2(&opt->caps[i].codec_id, \"*\") == 0) {\n\t    status = add_sdp_attr_rtcp_fb(pool, \"*\", &opt->caps[i], m);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(3, (THIS_FILE, status,\n\t\t\t  \"Failed generating SDP a=rtcp-fb:*\"));\n\t    }\n\t    continue;\n\t}\n\n\t/* Specific codec */\n\tif (sci_cnt == 0) {\n\t    sci_cnt = PJ_ARRAY_SIZE(sci);\n\t    status = get_codec_info_from_sdp(endpt, m, &sci_cnt, sci);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(3, (THIS_FILE, status,\n\t\t\t  \"Failed populating codec info from SDP\"));\n\t\treturn status;\n\t    }\n\t}\n\n\tfor (j = 0; j < sci_cnt; ++j) {\n\t    if (pj_strnicmp2(&opt->caps[i].codec_id, sci[j].id,\n\t\t\t     opt->caps[i].codec_id.slen) == 0)\n\t    {\n\t\tchar tmp[4];\n\t\tsnprintf(tmp, sizeof(tmp), \"%d\", sci[j].pt);\n\t\tstatus = add_sdp_attr_rtcp_fb(pool, tmp, &opt->caps[i], m);\n\t\tif (status != PJ_SUCCESS) {\n\t\t    PJ_PERROR(3, (THIS_FILE, status,\n\t\t\t      \"Failed generating SDP a=rtcp-fb:%d (%s)\",\n\t\t\t      sci[j].pt, opt->caps[i].codec_id.ptr));\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (j == sci_cnt) {\n\t    /* Codec ID not found in SDP (perhaps better ignore this error\n\t     * as app may configure audio and video in single setting).\n\t     */\n\t    PJ_PERROR(6, (THIS_FILE, PJ_ENOTFOUND,\n\t\t      \"Failed generating SDP a=rtcp-fb for %s\",\n\t\t      opt->caps[i].codec_id.ptr));\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Decode RTCP Feedback specific information from SDP media.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_decode_sdp(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjmedia_endpt *endpt,\n\t\t\t\t    const void *opt,\n\t\t\t\t    const pjmedia_sdp_session *sdp,\n\t\t\t\t    unsigned med_idx,\n\t\t\t\t    pjmedia_rtcp_fb_info *info)\n{\n    return pjmedia_rtcp_fb_decode_sdp2(pool, endpt, opt, sdp, med_idx, -1,\n\t\t\t\t       info);\n}\n\n/*\n * Decode RTCP Feedback specific information from SDP media.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_decode_sdp2(\n\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t    pjmedia_endpt *endpt,\n\t\t\t\t    const void *opt,\n\t\t\t\t    const pjmedia_sdp_session *sdp,\n\t\t\t\t    unsigned med_idx,\n\t\t\t\t    int pt,\n\t\t\t\t    pjmedia_rtcp_fb_info *info)\n{\n    unsigned sci_cnt = PJMEDIA_MAX_SDP_FMT;\n    sdp_codec_info_t sci[PJMEDIA_MAX_SDP_FMT];\n    const pjmedia_sdp_media *m;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_UNUSED_ARG(opt);\n\n    PJ_ASSERT_RETURN(pool && endpt && opt==NULL && sdp, PJ_EINVAL);\n    PJ_ASSERT_RETURN(med_idx < sdp->media_count, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pt <= 127, PJ_EINVAL);\n\n    m = sdp->media[med_idx];\n    status = get_codec_info_from_sdp(endpt, m, &sci_cnt, sci);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pj_bzero(info, sizeof(*info));\n\n    /* Iterate all SDP attribute a=rtcp-fb in the SDP media */\n    for (i = 0; i < m->attr_count; ++i) {\n\tconst pjmedia_sdp_attr *a = m->attr[i];\n\tpj_str_t token;\n\tpj_ssize_t tok_idx;\n\tunsigned j;\n\tconst char *codec_id = NULL;\n\tpj_str_t type_name = {0};\n\tpjmedia_rtcp_fb_type type = PJMEDIA_RTCP_FB_OTHER;\n\n\t/* Skip non a=rtcp-fb */\n\tif (pj_strcmp2(&a->name, \"rtcp-fb\") != 0)\n\t    continue;\n\n\t/* Get PT */\n\ttok_idx = pj_strtok2(&a->value, \" \\t\", &token, 0);\n\tif (tok_idx == a->value.slen)\n\t    continue;\n\n\tif (pj_strcmp2(&token, \"*\") == 0) {\n\t    /* All codecs */\n\t    codec_id = \"*\";\n\t} else {\n\t    /* Specific PT/codec */\n\t    unsigned pt_ = (unsigned) pj_strtoul2(&token, NULL, 10);\n\t    for (j = 0; j < sci_cnt; ++j) {\n\t\t/* Check if payload type is valid and requested */\n\t\tif (pt_ == sci[j].pt && (pt < 0 || pt == (int)pt_)) {\n\t\t    codec_id = sci[j].id;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t/* Skip this a=rtcp-fb if PT is not recognized or not requested */\n\tif (!codec_id)\n\t    continue;\n\n\t/* Get RTCP-FB type */\n\ttok_idx = pj_strtok2(&a->value, \" \\t\", &token, tok_idx + token.slen);\n\tif (tok_idx == a->value.slen)\n\t    continue;\n\n\tfor (j = 0; j < PJ_ARRAY_SIZE(rtcp_fb_type_name); ++j) {\n\t    if (pj_strcmp2(&token, rtcp_fb_type_name[j].name) == 0) {\n\t\ttype = rtcp_fb_type_name[j].type;\n\t\tbreak;\n\t    }\n\t}\n\tif (type == PJMEDIA_RTCP_FB_OTHER)\n\t    type_name = token;\n\n\t/* Got all the mandatory fields, let's initialize RTCP-FB cap */\n\tpj_strdup2(pool, &info->caps[info->cap_count].codec_id, codec_id);\n\tinfo->caps[info->cap_count].type = type;\n\tif (type == PJMEDIA_RTCP_FB_OTHER)\n\t    pj_strdup(pool, &info->caps[info->cap_count].type_name, &type_name);\n\n\t/* Get RTCP-FB param */\n\ttok_idx = pj_strtok2(&a->value, \" \\t\", &token, tok_idx + token.slen);\n\tif (tok_idx != a->value.slen)\n\t    pj_strdup(pool, &info->caps[info->cap_count].param, &token);\n\n\t/* Next */\n\tif (++info->cap_count == PJMEDIA_RTCP_FB_MAX_CAP)\n\t    break;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check whether the specified payload contains RTCP feedback generic NACK\n * message, and parse the payload if it does.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *nack_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* Generic NACK uses pt==RTCP_RTPFB and FMT==1 */\n    if (hdr->pt != RTCP_RTPFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length);\n    if (cnt > 2) cnt -= 2; else cnt = 0;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *nack_cnt = PJ_MIN(*nack_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *nack_cnt; ++i) {\n\tpj_uint16_t val;\n\n\tpj_memcpy(&val, p, 2);\n\tnack[i].pid = pj_ntohs(val);\n\tpj_memcpy(&val, p+2, 2);\n\tnack[i].blp = pj_ntohs(val);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check whether the specified payload contains RTCP feedback Picture Loss\n * Indication (PLI) message.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n\n    if (length < 12)\n    \treturn PJ_ETOOSMALL;\n\n    /* PLI uses pt==RTCP_PSFB and FMT==1 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check whether the specified payload contains RTCP feedback Slice Loss\n * Indication (SLI) message, and parse the payload if it does.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==2 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t/* 'number' takes 13 bit */\n\tsli[i].number = ((p[1] & 0x07) << 10) +\n\t\t\t(p[2] << 2) +\n\t\t\t((p[3] & 0xC0) >> 6);\n\t/* 'pict_id' takes 6 bit */\n\tsli[i].pict_id = (p[3] & 0x3F);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check whether the specified payload contains RTCP feedback Reference\n * Picture Selection Indication (RPSI) message, and parse the payload\n * if it does.\n */\nPJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/rtp.h>\n#include <pjmedia/errno.h>\n#include <pj/log.h>\n#include <pj/sock.h>\t/* pj_htonx, pj_htonx */\n#include <pj/assert.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n\n#define THIS_FILE   \"rtp.c\"\n\n#define RTP_VERSION\t2\n\n#define RTP_SEQ_MOD\t(1 << 16)\n#define MAX_DROPOUT \t((pj_int16_t)3000)\n#define MAX_MISORDER \t((pj_int16_t)100)\n#define MIN_SEQUENTIAL  ((pj_int16_t)2)\n\nstatic void pjmedia_rtp_seq_restart(pjmedia_rtp_seq_session *seq_ctrl, \n\t\t\t\t    pj_uint16_t seq);\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_session_init( pjmedia_rtp_session *ses,\n\t\t\t\t\t      int default_pt, \n\t\t\t\t\t      pj_uint32_t sender_ssrc )\n{\n    PJ_LOG(5, (THIS_FILE, \n\t       \"pjmedia_rtp_session_init: ses=%p, default_pt=%d, ssrc=0x%x\",\n\t       ses, default_pt, sender_ssrc));\n\n    /* Check RTP header packing. */\n    if (sizeof(struct pjmedia_rtp_hdr) != 12) {\n\tpj_assert(!\"Wrong RTP header packing!\");\n\treturn PJMEDIA_RTP_EINPACK;\n    }\n\n    /* If sender_ssrc is not specified, create from random value. */\n    if (sender_ssrc == 0 || sender_ssrc == (pj_uint32_t)-1) {\n\tsender_ssrc = pj_htonl(pj_rand());\n    } else {\n\tsender_ssrc = pj_htonl(sender_ssrc);\n    }\n\n    /* Initialize session. */\n    pj_bzero(ses, sizeof(*ses));\n\n    /* Initial sequence number SHOULD be random, according to RFC 3550. */\n    /* According to RFC 3711, it should be random within 2^15 bit */\n    ses->out_extseq = pj_rand() & 0x7FFF;\n    ses->peer_ssrc = 0;\n    \n    /* Build default header for outgoing RTP packet. */\n    ses->out_hdr.v = RTP_VERSION;\n    ses->out_hdr.p = 0;\n    ses->out_hdr.x = 0;\n    ses->out_hdr.cc = 0;\n    ses->out_hdr.m = 0;\n    ses->out_hdr.pt = (pj_uint8_t) default_pt;\n    ses->out_hdr.seq = (pj_uint16_t) pj_htons( (pj_uint16_t)ses->out_extseq );\n    ses->out_hdr.ts = 0;\n    ses->out_hdr.ssrc = sender_ssrc;\n\n    /* Keep some arguments as session defaults. */\n    ses->out_pt = (pj_uint16_t) default_pt;\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_rtp_session_init2( \n\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t    pjmedia_rtp_session_setting settings)\n{\n    pj_status_t status;\n    int\t\t pt = 0;\n    pj_uint32_t\t sender_ssrc = 0;\n\n    if (settings.flags & 1)\n\tpt = settings.default_pt;\n    if (settings.flags & 2)\n\tsender_ssrc = settings.sender_ssrc;\n\n    status = pjmedia_rtp_session_init(ses, pt, sender_ssrc);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    if (settings.flags & 4) {\n\tses->out_extseq = settings.seq;\n\tses->out_hdr.seq = pj_htons((pj_uint16_t)ses->out_extseq);\n    }\n    if (settings.flags & 8)\n\tses->out_hdr.ts = pj_htonl(settings.ts);\n    if (settings.flags & 16) {\n        ses->has_peer_ssrc = PJ_TRUE;\n\tses->peer_ssrc = settings.peer_ssrc;\n    }\n\n    PJ_LOG(5, (THIS_FILE,\n\t       \"pjmedia_rtp_session_init2: ses=%p, seq=%d, ts=%d, peer_ssrc=%d\",\n\t       ses, pj_ntohs(ses->out_hdr.seq), pj_ntohl(ses->out_hdr.ts),\n\t       ses->has_peer_ssrc? ses->peer_ssrc : 0));\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_encode_rtp( pjmedia_rtp_session *ses, \n\t\t\t\t\t    int pt, int m,\n\t\t\t\t\t    int payload_len, int ts_len,\n\t\t\t\t\t    const void **rtphdr, int *hdrlen )\n{\n    /* Update timestamp */\n    ses->out_hdr.ts = pj_htonl(pj_ntohl(ses->out_hdr.ts)+ts_len);\n\n    /* If payload_len is zero, bail out.\n     * This is a clock frame; we're not really transmitting anything.\n     */\n    if (payload_len == 0)\n\treturn PJ_SUCCESS;\n\n    /* Update session. */\n    ses->out_extseq++;\n\n    /* Create outgoing header. */\n    ses->out_hdr.pt = (pj_uint8_t) ((pt == -1) ? ses->out_pt : pt);\n    ses->out_hdr.m = (pj_uint16_t) m;\n    ses->out_hdr.seq = pj_htons( (pj_uint16_t) ses->out_extseq);\n\n    /* Return values */\n    *rtphdr = &ses->out_hdr;\n    *hdrlen = sizeof(pjmedia_rtp_hdr);\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp( pjmedia_rtp_session *ses, \n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    pjmedia_rtp_dec_hdr dec_hdr;\n\n    return pjmedia_rtp_decode_rtp2(ses, pkt, pkt_len, hdr, &dec_hdr, \n\t\t\t\t   payload, payloadlen);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n\n    PJ_UNUSED_ARG(ses);\n\n    /* Assume RTP header at the start of packet. We'll verify this later. */\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n\n    /* Check RTP header sanity. */\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n\n    /* Payload is located right after header plus CSRC */\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n\n    /* Decode RTP extension. */\n    if ((*hdr)->x) {\n        if (offset + sizeof (pjmedia_rtp_ext_hdr) > pkt_len)\n            return PJMEDIA_RTP_EINLEN;\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n\n    /* Check that offset is less than packet size */\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n\n    /* Find and set payload. */\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n \n    /* Remove payload padding if any */\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(void) pjmedia_rtp_session_update( pjmedia_rtp_session *ses, \n\t\t\t\t\t const pjmedia_rtp_hdr *hdr,\n\t\t\t\t\t pjmedia_rtp_status *p_seq_st)\n{\n    pjmedia_rtp_session_update2(ses, hdr, p_seq_st, PJ_TRUE);\n}\n\nPJ_DEF(void) pjmedia_rtp_session_update2( pjmedia_rtp_session *ses, \n\t\t\t\t\t  const pjmedia_rtp_hdr *hdr,\n\t\t\t\t\t  pjmedia_rtp_status *p_seq_st,\n\t\t\t\t\t  pj_bool_t check_pt)\n{\n    pjmedia_rtp_status seq_st;\n\n    /* for now check_pt MUST be either PJ_TRUE or PJ_FALSE.\n     * In the future we might change check_pt from boolean to \n     * unsigned integer to accommodate more flags.\n     */\n    pj_assert(check_pt==PJ_TRUE || check_pt==PJ_FALSE);\n\n    /* Init status */\n    seq_st.status.value = 0;\n    seq_st.diff = 0;\n\n    /* Check SSRC. */\n    if (!ses->has_peer_ssrc && ses->peer_ssrc == 0)\n        ses->peer_ssrc = pj_ntohl(hdr->ssrc);\n\n    if (pj_ntohl(hdr->ssrc) != ses->peer_ssrc) {\n\tseq_st.status.flag.badssrc = 1;\n\tif (!ses->has_peer_ssrc)\n\t    ses->peer_ssrc = pj_ntohl(hdr->ssrc);\n    }\n\n    /* Check payload type. */\n    if (check_pt && hdr->pt != ses->out_pt) {\n\tif (p_seq_st) {\n\t    p_seq_st->status.value = seq_st.status.value;\n\t    p_seq_st->status.flag.bad = 1;\n\t    p_seq_st->status.flag.badpt = 1;\n\t}\n\treturn;\n    }\n\n    /* Initialize sequence number on first packet received. */\n    if (ses->received == 0)\n\tpjmedia_rtp_seq_init( &ses->seq_ctrl, pj_ntohs(hdr->seq) );\n\n    /* Check sequence number to see if remote session has been restarted. */\n    pjmedia_rtp_seq_update( &ses->seq_ctrl, pj_ntohs(hdr->seq), &seq_st);\n    if (seq_st.status.flag.restart) {\n\t++ses->received;\n\n    } else if (!seq_st.status.flag.bad) {\n\t++ses->received;\n    }\n\n    if (p_seq_st) {\n\tp_seq_st->status.value = seq_st.status.value;\n\tp_seq_st->diff = seq_st.diff;\n    }\n}\n\n\n\nvoid pjmedia_rtp_seq_restart(pjmedia_rtp_seq_session *sess, pj_uint16_t seq)\n{\n    sess->base_seq = seq;\n    sess->max_seq = seq;\n    sess->bad_seq = RTP_SEQ_MOD + 1;\n    sess->cycles = 0;\n}\n\n\nvoid pjmedia_rtp_seq_init(pjmedia_rtp_seq_session *sess, pj_uint16_t seq)\n{\n    pjmedia_rtp_seq_restart(sess, seq);\n\n    sess->max_seq = (pj_uint16_t) (seq - 1);\n    sess->probation = MIN_SEQUENTIAL;\n}\n\n\nvoid pjmedia_rtp_seq_update( pjmedia_rtp_seq_session *sess, \n\t\t\t     pj_uint16_t seq,\n\t\t\t     pjmedia_rtp_status *seq_status)\n{\n    pj_uint16_t udelta = (pj_uint16_t) (seq - sess->max_seq);\n    pjmedia_rtp_status st;\n    \n    /* Init status */\n    st.status.value = 0;\n    st.diff = 0;\n\n    /*\n     * Source is not valid until MIN_SEQUENTIAL packets with\n     * sequential sequence numbers have been received.\n     */\n    if (sess->probation) {\n\n\tst.status.flag.probation = 1;\n\t\n        if (seq == sess->max_seq+ 1) {\n\t    /* packet is in sequence */\n\t    st.diff = 1;\n\t    sess->probation--;\n            sess->max_seq = seq;\n            if (sess->probation == 0) {\n\t\tst.status.flag.probation = 0;\n            }\n\t} else {\n\n\t    st.diff = 0;\n\n\t    st.status.flag.bad = 1;\n\t    if (seq == sess->max_seq)\n\t\tst.status.flag.dup = 1;\n\t    else\n\t\tst.status.flag.outorder = 1;\n\n\t    sess->probation = MIN_SEQUENTIAL - 1;\n\t    sess->max_seq = seq;\n        }\n\n\n    } else if (udelta == 0) {\n\n\tst.status.flag.dup = 1;\n\n    } else if (udelta < MAX_DROPOUT) {\n\t/* in order, with permissible gap */\n\tif (seq < sess->max_seq) {\n\t    /* Sequence number wrapped - count another 64K cycle. */\n\t    sess->cycles += RTP_SEQ_MOD;\n        }\n        sess->max_seq = seq;\n\n\tst.diff = udelta;\n\n    } else if (udelta <= (RTP_SEQ_MOD - MAX_MISORDER)) {\n\t/* the sequence number made a very large jump */\n        if (seq == sess->bad_seq) {\n\t    /*\n\t     * Two sequential packets -- assume that the other side\n\t     * restarted without telling us so just re-sync\n\t     * (i.e., pretend this was the first packet).\n\t     */\n\t    pjmedia_rtp_seq_restart(sess, seq);\n\t    st.status.flag.restart = 1;\n\t    st.status.flag.probation = 1;\n\t    st.diff = 1;\n\t}\n        else {\n\t    sess->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);\n            st.status.flag.bad = 1;\n\t    st.status.flag.outorder = 1;\n        }\n    } else {\n\t/* old duplicate or reordered packet.\n\t * Not necessarily bad packet (?)\n\t */\n\tst.status.flag.outorder = 1;\n    }\n    \n\n    if (seq_status) {\n\tseq_status->diff = st.diff;\n\tseq_status->status.value = st.status.value;\n    }\n}\n\n\n"], "filenames": ["pjmedia/src/pjmedia/rtcp.c", "pjmedia/src/pjmedia/rtcp_fb.c", "pjmedia/src/pjmedia/rtp.c"], "buggy_code_start_loc": [504, 634, 192], "buggy_code_end_loc": [835, 667, 192], "fixing_code_start_loc": [505, 634, 193], "fixing_code_end_loc": [853, 670, 195], "type": "CWE-125", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.11.1 and prior, there are various cases where it is possible that certain incoming RTP/RTCP packets can potentially cause out-of-bound read access. This issue affects all users that use PJMEDIA and accept incoming RTP/RTCP. A patch is available as a commit in the `master` branch. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-21722", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-27T00:15:07.653", "lastModified": "2023-02-02T18:29:00.820", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.11.1 and prior, there are various cases where it is possible that certain incoming RTP/RTCP packets can potentially cause out-of-bound read access. This issue affects all users that use PJMEDIA and accept incoming RTP/RTCP. A patch is available as a commit in the `master` branch. There are no known workarounds."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C que implementa protocolos basados en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE. En la versi\u00f3n 2.11.1 y anteriores, se presentan varios casos en los que es posible que determinados paquetes RTP/RTCP entrantes puedan causar potencialmente un acceso de lectura fuera de l\u00edmites. Este problema afecta a todos los usuarios que usan PJMEDIA y aceptan RTP/RTCP entrantes. Se presenta un parche disponible en la rama \"master\". No se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.11.1", "matchCriteriaId": "6BB0273A-3235-4BC7-A1BE-7D35BABD8617"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/22af44e68a0c7d190ac1e25075e1382f77e9397a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-m66q-q64c-hv36", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/22af44e68a0c7d190ac1e25075e1382f77e9397a"}}