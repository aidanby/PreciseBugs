{"buggy_code": ["/*\n * NetLabel CIPSO/IPv4 Support\n *\n * This file defines the CIPSO/IPv4 functions for the NetLabel system.  The\n * NetLabel system manages static and dynamic label mappings for network\n * protocols such as CIPSO and RIPSO.\n *\n * Author: Paul Moore <paul.moore@hp.com>\n *\n */\n\n/*\n * (c) Copyright Hewlett-Packard Development Company, L.P., 2006\n *\n * This program is free software;  you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY;  without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n * the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program;  if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n *\n */\n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/genetlink.h>\n#include <net/netlabel.h>\n#include <net/cipso_ipv4.h>\n\n#include \"netlabel_user.h\"\n#include \"netlabel_cipso_v4.h\"\n\n/* Argument struct for cipso_v4_doi_walk() */\nstruct netlbl_cipsov4_doiwalk_arg {\n\tstruct netlink_callback *nl_cb;\n\tstruct sk_buff *skb;\n\tu32 seq;\n};\n\n/* NetLabel Generic NETLINK CIPSOv4 family */\nstatic struct genl_family netlbl_cipsov4_gnl_family = {\n\t.id = GENL_ID_GENERATE,\n\t.hdrsize = 0,\n\t.name = NETLBL_NLTYPE_CIPSOV4_NAME,\n\t.version = NETLBL_PROTO_VERSION,\n\t.maxattr = NLBL_CIPSOV4_A_MAX,\n};\n\n/* NetLabel Netlink attribute policy */\nstatic struct nla_policy netlbl_cipsov4_genl_policy[NLBL_CIPSOV4_A_MAX + 1] = {\n\t[NLBL_CIPSOV4_A_DOI] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MTYPE] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_TAG] = { .type = NLA_U8 },\n\t[NLBL_CIPSOV4_A_TAGLST] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSLVLLOC] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSLVLREM] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSLVL] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSLVLLST] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSCATLOC] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSCATREM] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSCAT] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSCATLST] = { .type = NLA_NESTED },\n};\n\n/*\n * Helper Functions\n */\n\n/**\n * netlbl_cipsov4_doi_free - Frees a CIPSO V4 DOI definition\n * @entry: the entry's RCU field\n *\n * Description:\n * This function is designed to be used as a callback to the call_rcu()\n * function so that the memory allocated to the DOI definition can be released\n * safely.\n *\n */\nstatic void netlbl_cipsov4_doi_free(struct rcu_head *entry)\n{\n\tstruct cipso_v4_doi *ptr;\n\n\tptr = container_of(entry, struct cipso_v4_doi, rcu);\n\tswitch (ptr->type) {\n\tcase CIPSO_V4_MAP_STD:\n\t\tkfree(ptr->map.std->lvl.cipso);\n\t\tkfree(ptr->map.std->lvl.local);\n\t\tkfree(ptr->map.std->cat.cipso);\n\t\tkfree(ptr->map.std->cat.local);\n\t\tbreak;\n\t}\n\tkfree(ptr);\n}\n\n/**\n * netlbl_cipsov4_add_common - Parse the common sections of a ADD message\n * @info: the Generic NETLINK info block\n * @doi_def: the CIPSO V4 DOI definition\n *\n * Description:\n * Parse the common sections of a ADD message and fill in the related values\n * in @doi_def.  Returns zero on success, negative values on failure.\n *\n */\nstatic int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}\n\n/*\n * NetLabel Command Handlers\n */\n\n/**\n * netlbl_cipsov4_add_std - Adds a CIPSO V4 DOI definition\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Create a new CIPSO_V4_MAP_STD DOI definition based on the given ADD message\n * and add it to the CIPSO V4 engine.  Return zero on success and non-zero on\n * error.\n *\n */\nstatic int netlbl_cipsov4_add_std(struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tstruct nlattr *nla_a;\n\tstruct nlattr *nla_b;\n\tint nla_a_rem;\n\tint nla_b_rem;\n\tu32 iter;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_TAGLST] ||\n\t    !info->attrs[NLBL_CIPSOV4_A_MLSLVLLST])\n\t\treturn -EINVAL;\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tdoi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);\n\tif (doi_def == NULL)\n\t\treturn -ENOMEM;\n\tdoi_def->map.std = kzalloc(sizeof(*doi_def->map.std), GFP_KERNEL);\n\tif (doi_def->map.std == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto add_std_failure;\n\t}\n\tdoi_def->type = CIPSO_V4_MAP_STD;\n\n\tret_val = netlbl_cipsov4_add_common(info, doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_std_failure;\n\tret_val = -EINVAL;\n\n\tnla_for_each_nested(nla_a,\n\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t    nla_a_rem)\n\t\tif (nla_a->nla_type == NLBL_CIPSOV4_A_MLSLVL) {\n\t\t\tif (nla_validate_nested(nla_a,\n\t\t\t\t\t    NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t    netlbl_cipsov4_genl_policy) != 0)\n\t\t\t\t\tgoto add_std_failure;\n\t\t\tnla_for_each_nested(nla_b, nla_a, nla_b_rem)\n\t\t\t\tswitch (nla_b->nla_type) {\n\t\t\t\tcase NLBL_CIPSOV4_A_MLSLVLLOC:\n\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t    CIPSO_V4_MAX_LOC_LVLS)\n\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t    doi_def->map.std->lvl.local_size)\n\t\t\t\t\t     doi_def->map.std->lvl.local_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase NLBL_CIPSOV4_A_MLSLVLREM:\n\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t    CIPSO_V4_MAX_REM_LVLS)\n\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t    doi_def->map.std->lvl.cipso_size)\n\t\t\t\t\t     doi_def->map.std->lvl.cipso_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\tdoi_def->map.std->lvl.local = kcalloc(doi_def->map.std->lvl.local_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (doi_def->map.std->lvl.local == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto add_std_failure;\n\t}\n\tdoi_def->map.std->lvl.cipso = kcalloc(doi_def->map.std->lvl.cipso_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (doi_def->map.std->lvl.cipso == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto add_std_failure;\n\t}\n\tfor (iter = 0; iter < doi_def->map.std->lvl.local_size; iter++)\n\t\tdoi_def->map.std->lvl.local[iter] = CIPSO_V4_INV_LVL;\n\tfor (iter = 0; iter < doi_def->map.std->lvl.cipso_size; iter++)\n\t\tdoi_def->map.std->lvl.cipso[iter] = CIPSO_V4_INV_LVL;\n\tnla_for_each_nested(nla_a,\n\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t    nla_a_rem)\n\t\tif (nla_a->nla_type == NLBL_CIPSOV4_A_MLSLVL) {\n\t\t\tstruct nlattr *lvl_loc;\n\t\t\tstruct nlattr *lvl_rem;\n\n\t\t\tlvl_loc = nla_find_nested(nla_a,\n\t\t\t\t\t\t  NLBL_CIPSOV4_A_MLSLVLLOC);\n\t\t\tlvl_rem = nla_find_nested(nla_a,\n\t\t\t\t\t\t  NLBL_CIPSOV4_A_MLSLVLREM);\n\t\t\tif (lvl_loc == NULL || lvl_rem == NULL)\n\t\t\t\tgoto add_std_failure;\n\t\t\tdoi_def->map.std->lvl.local[nla_get_u32(lvl_loc)] =\n\t\t\t\tnla_get_u32(lvl_rem);\n\t\t\tdoi_def->map.std->lvl.cipso[nla_get_u32(lvl_rem)] =\n\t\t\t\tnla_get_u32(lvl_loc);\n\t\t}\n\n\tif (info->attrs[NLBL_CIPSOV4_A_MLSCATLST]) {\n\t\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\t\tgoto add_std_failure;\n\n\t\tnla_for_each_nested(nla_a,\n\t\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t    nla_a_rem)\n\t\t\tif (nla_a->nla_type == NLBL_CIPSOV4_A_MLSCAT) {\n\t\t\t\tif (nla_validate_nested(nla_a,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t      netlbl_cipsov4_genl_policy) != 0)\n\t\t\t\t\tgoto add_std_failure;\n\t\t\t\tnla_for_each_nested(nla_b, nla_a, nla_b_rem)\n\t\t\t\t\tswitch (nla_b->nla_type) {\n\t\t\t\t\tcase NLBL_CIPSOV4_A_MLSCATLOC:\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t\t    CIPSO_V4_MAX_LOC_CATS)\n\t\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t      doi_def->map.std->cat.local_size)\n\t\t\t\t\t     doi_def->map.std->cat.local_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase NLBL_CIPSOV4_A_MLSCATREM:\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t\t    CIPSO_V4_MAX_REM_CATS)\n\t\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t      doi_def->map.std->cat.cipso_size)\n\t\t\t\t\t     doi_def->map.std->cat.cipso_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\tdoi_def->map.std->cat.local = kcalloc(\n\t\t\t                      doi_def->map.std->cat.local_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (doi_def->map.std->cat.local == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_std_failure;\n\t\t}\n\t\tdoi_def->map.std->cat.cipso = kcalloc(\n\t\t\t                      doi_def->map.std->cat.cipso_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (doi_def->map.std->cat.cipso == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_std_failure;\n\t\t}\n\t\tfor (iter = 0; iter < doi_def->map.std->cat.local_size; iter++)\n\t\t\tdoi_def->map.std->cat.local[iter] = CIPSO_V4_INV_CAT;\n\t\tfor (iter = 0; iter < doi_def->map.std->cat.cipso_size; iter++)\n\t\t\tdoi_def->map.std->cat.cipso[iter] = CIPSO_V4_INV_CAT;\n\t\tnla_for_each_nested(nla_a,\n\t\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t    nla_a_rem)\n\t\t\tif (nla_a->nla_type == NLBL_CIPSOV4_A_MLSCAT) {\n\t\t\t\tstruct nlattr *cat_loc;\n\t\t\t\tstruct nlattr *cat_rem;\n\n\t\t\t\tcat_loc = nla_find_nested(nla_a,\n\t\t\t\t\t\t     NLBL_CIPSOV4_A_MLSCATLOC);\n\t\t\t\tcat_rem = nla_find_nested(nla_a,\n\t\t\t\t\t\t     NLBL_CIPSOV4_A_MLSCATREM);\n\t\t\t\tif (cat_loc == NULL || cat_rem == NULL)\n\t\t\t\t\tgoto add_std_failure;\n\t\t\t\tdoi_def->map.std->cat.local[\n\t\t\t\t                        nla_get_u32(cat_loc)] =\n\t\t\t\t\tnla_get_u32(cat_rem);\n\t\t\t\tdoi_def->map.std->cat.cipso[\n\t\t\t\t\t                nla_get_u32(cat_rem)] =\n\t\t\t\t\tnla_get_u32(cat_loc);\n\t\t\t}\n\t}\n\n\tret_val = cipso_v4_doi_add(doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_std_failure;\n\treturn 0;\n\nadd_std_failure:\n\tif (doi_def)\n\t\tnetlbl_cipsov4_doi_free(&doi_def->rcu);\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_add_pass - Adds a CIPSO V4 DOI definition\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Create a new CIPSO_V4_MAP_PASS DOI definition based on the given ADD message\n * and add it to the CIPSO V4 engine.  Return zero on success and non-zero on\n * error.\n *\n */\nstatic int netlbl_cipsov4_add_pass(struct genl_info *info)\n{\n\tint ret_val;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_TAGLST])\n\t\treturn -EINVAL;\n\n\tdoi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);\n\tif (doi_def == NULL)\n\t\treturn -ENOMEM;\n\tdoi_def->type = CIPSO_V4_MAP_PASS;\n\n\tret_val = netlbl_cipsov4_add_common(info, doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_pass_failure;\n\n\tret_val = cipso_v4_doi_add(doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_pass_failure;\n\treturn 0;\n\nadd_pass_failure:\n\tnetlbl_cipsov4_doi_free(&doi_def->rcu);\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_add - Handle an ADD message\n * @skb: the NETLINK buffer\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Create a new DOI definition based on the given ADD message and add it to the\n * CIPSO V4 engine.  Returns zero on success, negative values on failure.\n *\n */\nstatic int netlbl_cipsov4_add(struct sk_buff *skb, struct genl_info *info)\n\n{\n\tint ret_val = -EINVAL;\n\tu32 type;\n\tu32 doi;\n\tconst char *type_str = \"(unknown)\";\n\tstruct audit_buffer *audit_buf;\n\tstruct netlbl_audit audit_info;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI] ||\n\t    !info->attrs[NLBL_CIPSOV4_A_MTYPE])\n\t\treturn -EINVAL;\n\n\tdoi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tnetlbl_netlink_auditinfo(skb, &audit_info);\n\n\ttype = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_MTYPE]);\n\tswitch (type) {\n\tcase CIPSO_V4_MAP_STD:\n\t\ttype_str = \"std\";\n\t\tret_val = netlbl_cipsov4_add_std(info);\n\t\tbreak;\n\tcase CIPSO_V4_MAP_PASS:\n\t\ttype_str = \"pass\";\n\t\tret_val = netlbl_cipsov4_add_pass(info);\n\t\tbreak;\n\t}\n\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_CIPSOV4_ADD,\n\t\t\t\t\t      &audit_info);\n\tif (audit_buf != NULL) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" cipso_doi=%u cipso_type=%s res=%u\",\n\t\t\t\t doi,\n\t\t\t\t type_str,\n\t\t\t\t ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_list - Handle a LIST message\n * @skb: the NETLINK buffer\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Process a user generated LIST message and respond accordingly.  While the\n * response message generated by the kernel is straightforward, determining\n * before hand the size of the buffer to allocate is not (we have to generate\n * the message to know the size).  In order to keep this function sane what we\n * do is allocate a buffer of NLMSG_GOODSIZE and try to fit the response in\n * that size, if we fail then we restart with a larger buffer and try again.\n * We continue in this manner until we hit a limit of failed attempts then we\n * give up and just send an error message.  Returns zero on success and\n * negative values on error.\n *\n */\nstatic int netlbl_cipsov4_list(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val;\n\tstruct sk_buff *ans_skb = NULL;\n\tu32 nlsze_mult = 1;\n\tvoid *data;\n\tu32 doi;\n\tstruct nlattr *nla_a;\n\tstruct nlattr *nla_b;\n\tstruct cipso_v4_doi *doi_def;\n\tu32 iter;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI]) {\n\t\tret_val = -EINVAL;\n\t\tgoto list_failure;\n\t}\n\nlist_start:\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE * nlsze_mult, GFP_KERNEL);\n\tif (ans_skb == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_cipsov4_gnl_family,\n\t\t\t\t 0, NLBL_CIPSOV4_C_LIST);\n\tif (data == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\n\tdoi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_getdef(doi);\n\tif (doi_def == NULL) {\n\t\tret_val = -EINVAL;\n\t\tgoto list_failure;\n\t}\n\n\tret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MTYPE, doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto list_failure_lock;\n\n\tnla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_TAGLST);\n\tif (nla_a == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure_lock;\n\t}\n\tfor (iter = 0;\n\t     iter < CIPSO_V4_TAG_MAXCNT &&\n\t       doi_def->tags[iter] != CIPSO_V4_TAG_INVALID;\n\t     iter++) {\n\t\tret_val = nla_put_u8(ans_skb,\n\t\t\t\t     NLBL_CIPSOV4_A_TAG,\n\t\t\t\t     doi_def->tags[iter]);\n\t\tif (ret_val != 0)\n\t\t\tgoto list_failure_lock;\n\t}\n\tnla_nest_end(ans_skb, nla_a);\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_STD:\n\t\tnla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSLVLLST);\n\t\tif (nla_a == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto list_failure_lock;\n\t\t}\n\t\tfor (iter = 0;\n\t\t     iter < doi_def->map.std->lvl.local_size;\n\t\t     iter++) {\n\t\t\tif (doi_def->map.std->lvl.local[iter] ==\n\t\t\t    CIPSO_V4_INV_LVL)\n\t\t\t\tcontinue;\n\n\t\t\tnla_b = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSLVL);\n\t\t\tif (nla_b == NULL) {\n\t\t\t\tret_val = -ENOMEM;\n\t\t\t\tgoto list_retry;\n\t\t\t}\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MLSLVLLOC,\n\t\t\t\t\t      iter);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t    NLBL_CIPSOV4_A_MLSLVLREM,\n\t\t\t\t\t    doi_def->map.std->lvl.local[iter]);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tnla_nest_end(ans_skb, nla_b);\n\t\t}\n\t\tnla_nest_end(ans_skb, nla_a);\n\n\t\tnla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSCATLST);\n\t\tif (nla_a == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto list_retry;\n\t\t}\n\t\tfor (iter = 0;\n\t\t     iter < doi_def->map.std->cat.local_size;\n\t\t     iter++) {\n\t\t\tif (doi_def->map.std->cat.local[iter] ==\n\t\t\t    CIPSO_V4_INV_CAT)\n\t\t\t\tcontinue;\n\n\t\t\tnla_b = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSCAT);\n\t\t\tif (nla_b == NULL) {\n\t\t\t\tret_val = -ENOMEM;\n\t\t\t\tgoto list_retry;\n\t\t\t}\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MLSCATLOC,\n\t\t\t\t\t      iter);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t    NLBL_CIPSOV4_A_MLSCATREM,\n\t\t\t\t\t    doi_def->map.std->cat.local[iter]);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tnla_nest_end(ans_skb, nla_b);\n\t\t}\n\t\tnla_nest_end(ans_skb, nla_a);\n\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tgenlmsg_end(ans_skb, data);\n\n\tret_val = genlmsg_reply(ans_skb, info);\n\tif (ret_val != 0)\n\t\tgoto list_failure;\n\n\treturn 0;\n\nlist_retry:\n\t/* XXX - this limit is a guesstimate */\n\tif (nlsze_mult < 4) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(ans_skb);\n\t\tnlsze_mult++;\n\t\tgoto list_start;\n\t}\nlist_failure_lock:\n\trcu_read_unlock();\nlist_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_listall_cb - cipso_v4_doi_walk() callback for LISTALL\n * @doi_def: the CIPSOv4 DOI definition\n * @arg: the netlbl_cipsov4_doiwalk_arg structure\n *\n * Description:\n * This function is designed to be used as a callback to the\n * cipso_v4_doi_walk() function for use in generating a response for a LISTALL\n * message.  Returns the size of the message on success, negative values on\n * failure.\n *\n */\nstatic int netlbl_cipsov4_listall_cb(struct cipso_v4_doi *doi_def, void *arg)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_cipsov4_doiwalk_arg *cb_arg = arg;\n\tvoid *data;\n\n\tdata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).pid,\n\t\t\t   cb_arg->seq, &netlbl_cipsov4_gnl_family,\n\t\t\t   NLM_F_MULTI, NLBL_CIPSOV4_C_LISTALL);\n\tif (data == NULL)\n\t\tgoto listall_cb_failure;\n\n\tret_val = nla_put_u32(cb_arg->skb, NLBL_CIPSOV4_A_DOI, doi_def->doi);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\tret_val = nla_put_u32(cb_arg->skb,\n\t\t\t      NLBL_CIPSOV4_A_MTYPE,\n\t\t\t      doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\n\treturn genlmsg_end(cb_arg->skb, data);\n\nlistall_cb_failure:\n\tgenlmsg_cancel(cb_arg->skb, data);\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_listall - Handle a LISTALL message\n * @skb: the NETLINK buffer\n * @cb: the NETLINK callback\n *\n * Description:\n * Process a user generated LISTALL message and respond accordingly.  Returns\n * zero on success and negative values on error.\n *\n */\nstatic int netlbl_cipsov4_listall(struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tstruct netlbl_cipsov4_doiwalk_arg cb_arg;\n\tint doi_skip = cb->args[0];\n\n\tcb_arg.nl_cb = cb;\n\tcb_arg.skb = skb;\n\tcb_arg.seq = cb->nlh->nlmsg_seq;\n\n\tcipso_v4_doi_walk(&doi_skip, netlbl_cipsov4_listall_cb, &cb_arg);\n\n\tcb->args[0] = doi_skip;\n\treturn skb->len;\n}\n\n/**\n * netlbl_cipsov4_remove - Handle a REMOVE message\n * @skb: the NETLINK buffer\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Process a user generated REMOVE message and respond accordingly.  Returns\n * zero on success, negative values on failure.\n *\n */\nstatic int netlbl_cipsov4_remove(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tu32 doi = 0;\n\tstruct audit_buffer *audit_buf;\n\tstruct netlbl_audit audit_info;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI])\n\t\treturn -EINVAL;\n\n\tdoi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tnetlbl_netlink_auditinfo(skb, &audit_info);\n\n\tret_val = cipso_v4_doi_remove(doi,\n\t\t\t\t      &audit_info,\n\t\t\t\t      netlbl_cipsov4_doi_free);\n\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_CIPSOV4_DEL,\n\t\t\t\t\t      &audit_info);\n\tif (audit_buf != NULL) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" cipso_doi=%u res=%u\",\n\t\t\t\t doi,\n\t\t\t\t ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}\n\n/*\n * NetLabel Generic NETLINK Command Definitions\n */\n\nstatic struct genl_ops netlbl_cipsov4_genl_c_add = {\n\t.cmd = NLBL_CIPSOV4_C_ADD,\n\t.flags = GENL_ADMIN_PERM,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.doit = netlbl_cipsov4_add,\n\t.dumpit = NULL,\n};\n\nstatic struct genl_ops netlbl_cipsov4_genl_c_remove = {\n\t.cmd = NLBL_CIPSOV4_C_REMOVE,\n\t.flags = GENL_ADMIN_PERM,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.doit = netlbl_cipsov4_remove,\n\t.dumpit = NULL,\n};\n\nstatic struct genl_ops netlbl_cipsov4_genl_c_list = {\n\t.cmd = NLBL_CIPSOV4_C_LIST,\n\t.flags = 0,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.doit = netlbl_cipsov4_list,\n\t.dumpit = NULL,\n};\n\nstatic struct genl_ops netlbl_cipsov4_genl_c_listall = {\n\t.cmd = NLBL_CIPSOV4_C_LISTALL,\n\t.flags = 0,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.doit = NULL,\n\t.dumpit = netlbl_cipsov4_listall,\n};\n\n/*\n * NetLabel Generic NETLINK Protocol Functions\n */\n\n/**\n * netlbl_cipsov4_genl_init - Register the CIPSOv4 NetLabel component\n *\n * Description:\n * Register the CIPSOv4 packet NetLabel component with the Generic NETLINK\n * mechanism.  Returns zero on success, negative values on failure.\n *\n */\nint netlbl_cipsov4_genl_init(void)\n{\n\tint ret_val;\n\n\tret_val = genl_register_family(&netlbl_cipsov4_gnl_family);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tret_val = genl_register_ops(&netlbl_cipsov4_gnl_family,\n\t\t\t\t    &netlbl_cipsov4_genl_c_add);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tret_val = genl_register_ops(&netlbl_cipsov4_gnl_family,\n\t\t\t\t    &netlbl_cipsov4_genl_c_remove);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tret_val = genl_register_ops(&netlbl_cipsov4_gnl_family,\n\t\t\t\t    &netlbl_cipsov4_genl_c_list);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tret_val = genl_register_ops(&netlbl_cipsov4_gnl_family,\n\t\t\t\t    &netlbl_cipsov4_genl_c_listall);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * NetLabel CIPSO/IPv4 Support\n *\n * This file defines the CIPSO/IPv4 functions for the NetLabel system.  The\n * NetLabel system manages static and dynamic label mappings for network\n * protocols such as CIPSO and RIPSO.\n *\n * Author: Paul Moore <paul.moore@hp.com>\n *\n */\n\n/*\n * (c) Copyright Hewlett-Packard Development Company, L.P., 2006\n *\n * This program is free software;  you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY;  without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n * the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program;  if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n *\n */\n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/genetlink.h>\n#include <net/netlabel.h>\n#include <net/cipso_ipv4.h>\n\n#include \"netlabel_user.h\"\n#include \"netlabel_cipso_v4.h\"\n\n/* Argument struct for cipso_v4_doi_walk() */\nstruct netlbl_cipsov4_doiwalk_arg {\n\tstruct netlink_callback *nl_cb;\n\tstruct sk_buff *skb;\n\tu32 seq;\n};\n\n/* NetLabel Generic NETLINK CIPSOv4 family */\nstatic struct genl_family netlbl_cipsov4_gnl_family = {\n\t.id = GENL_ID_GENERATE,\n\t.hdrsize = 0,\n\t.name = NETLBL_NLTYPE_CIPSOV4_NAME,\n\t.version = NETLBL_PROTO_VERSION,\n\t.maxattr = NLBL_CIPSOV4_A_MAX,\n};\n\n/* NetLabel Netlink attribute policy */\nstatic struct nla_policy netlbl_cipsov4_genl_policy[NLBL_CIPSOV4_A_MAX + 1] = {\n\t[NLBL_CIPSOV4_A_DOI] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MTYPE] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_TAG] = { .type = NLA_U8 },\n\t[NLBL_CIPSOV4_A_TAGLST] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSLVLLOC] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSLVLREM] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSLVL] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSLVLLST] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSCATLOC] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSCATREM] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSCAT] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSCATLST] = { .type = NLA_NESTED },\n};\n\n/*\n * Helper Functions\n */\n\n/**\n * netlbl_cipsov4_doi_free - Frees a CIPSO V4 DOI definition\n * @entry: the entry's RCU field\n *\n * Description:\n * This function is designed to be used as a callback to the call_rcu()\n * function so that the memory allocated to the DOI definition can be released\n * safely.\n *\n */\nstatic void netlbl_cipsov4_doi_free(struct rcu_head *entry)\n{\n\tstruct cipso_v4_doi *ptr;\n\n\tptr = container_of(entry, struct cipso_v4_doi, rcu);\n\tswitch (ptr->type) {\n\tcase CIPSO_V4_MAP_STD:\n\t\tkfree(ptr->map.std->lvl.cipso);\n\t\tkfree(ptr->map.std->lvl.local);\n\t\tkfree(ptr->map.std->cat.cipso);\n\t\tkfree(ptr->map.std->cat.local);\n\t\tbreak;\n\t}\n\tkfree(ptr);\n}\n\n/**\n * netlbl_cipsov4_add_common - Parse the common sections of a ADD message\n * @info: the Generic NETLINK info block\n * @doi_def: the CIPSO V4 DOI definition\n *\n * Description:\n * Parse the common sections of a ADD message and fill in the related values\n * in @doi_def.  Returns zero on success, negative values on failure.\n *\n */\nstatic int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}\n\n/*\n * NetLabel Command Handlers\n */\n\n/**\n * netlbl_cipsov4_add_std - Adds a CIPSO V4 DOI definition\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Create a new CIPSO_V4_MAP_STD DOI definition based on the given ADD message\n * and add it to the CIPSO V4 engine.  Return zero on success and non-zero on\n * error.\n *\n */\nstatic int netlbl_cipsov4_add_std(struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tstruct nlattr *nla_a;\n\tstruct nlattr *nla_b;\n\tint nla_a_rem;\n\tint nla_b_rem;\n\tu32 iter;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_TAGLST] ||\n\t    !info->attrs[NLBL_CIPSOV4_A_MLSLVLLST])\n\t\treturn -EINVAL;\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tdoi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);\n\tif (doi_def == NULL)\n\t\treturn -ENOMEM;\n\tdoi_def->map.std = kzalloc(sizeof(*doi_def->map.std), GFP_KERNEL);\n\tif (doi_def->map.std == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto add_std_failure;\n\t}\n\tdoi_def->type = CIPSO_V4_MAP_STD;\n\n\tret_val = netlbl_cipsov4_add_common(info, doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_std_failure;\n\tret_val = -EINVAL;\n\n\tnla_for_each_nested(nla_a,\n\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t    nla_a_rem)\n\t\tif (nla_a->nla_type == NLBL_CIPSOV4_A_MLSLVL) {\n\t\t\tif (nla_validate_nested(nla_a,\n\t\t\t\t\t    NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t    netlbl_cipsov4_genl_policy) != 0)\n\t\t\t\t\tgoto add_std_failure;\n\t\t\tnla_for_each_nested(nla_b, nla_a, nla_b_rem)\n\t\t\t\tswitch (nla_b->nla_type) {\n\t\t\t\tcase NLBL_CIPSOV4_A_MLSLVLLOC:\n\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t    CIPSO_V4_MAX_LOC_LVLS)\n\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t    doi_def->map.std->lvl.local_size)\n\t\t\t\t\t     doi_def->map.std->lvl.local_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase NLBL_CIPSOV4_A_MLSLVLREM:\n\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t    CIPSO_V4_MAX_REM_LVLS)\n\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t    doi_def->map.std->lvl.cipso_size)\n\t\t\t\t\t     doi_def->map.std->lvl.cipso_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\tdoi_def->map.std->lvl.local = kcalloc(doi_def->map.std->lvl.local_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (doi_def->map.std->lvl.local == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto add_std_failure;\n\t}\n\tdoi_def->map.std->lvl.cipso = kcalloc(doi_def->map.std->lvl.cipso_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (doi_def->map.std->lvl.cipso == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto add_std_failure;\n\t}\n\tfor (iter = 0; iter < doi_def->map.std->lvl.local_size; iter++)\n\t\tdoi_def->map.std->lvl.local[iter] = CIPSO_V4_INV_LVL;\n\tfor (iter = 0; iter < doi_def->map.std->lvl.cipso_size; iter++)\n\t\tdoi_def->map.std->lvl.cipso[iter] = CIPSO_V4_INV_LVL;\n\tnla_for_each_nested(nla_a,\n\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t    nla_a_rem)\n\t\tif (nla_a->nla_type == NLBL_CIPSOV4_A_MLSLVL) {\n\t\t\tstruct nlattr *lvl_loc;\n\t\t\tstruct nlattr *lvl_rem;\n\n\t\t\tlvl_loc = nla_find_nested(nla_a,\n\t\t\t\t\t\t  NLBL_CIPSOV4_A_MLSLVLLOC);\n\t\t\tlvl_rem = nla_find_nested(nla_a,\n\t\t\t\t\t\t  NLBL_CIPSOV4_A_MLSLVLREM);\n\t\t\tif (lvl_loc == NULL || lvl_rem == NULL)\n\t\t\t\tgoto add_std_failure;\n\t\t\tdoi_def->map.std->lvl.local[nla_get_u32(lvl_loc)] =\n\t\t\t\tnla_get_u32(lvl_rem);\n\t\t\tdoi_def->map.std->lvl.cipso[nla_get_u32(lvl_rem)] =\n\t\t\t\tnla_get_u32(lvl_loc);\n\t\t}\n\n\tif (info->attrs[NLBL_CIPSOV4_A_MLSCATLST]) {\n\t\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\t\tgoto add_std_failure;\n\n\t\tnla_for_each_nested(nla_a,\n\t\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t    nla_a_rem)\n\t\t\tif (nla_a->nla_type == NLBL_CIPSOV4_A_MLSCAT) {\n\t\t\t\tif (nla_validate_nested(nla_a,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t      netlbl_cipsov4_genl_policy) != 0)\n\t\t\t\t\tgoto add_std_failure;\n\t\t\t\tnla_for_each_nested(nla_b, nla_a, nla_b_rem)\n\t\t\t\t\tswitch (nla_b->nla_type) {\n\t\t\t\t\tcase NLBL_CIPSOV4_A_MLSCATLOC:\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t\t    CIPSO_V4_MAX_LOC_CATS)\n\t\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t      doi_def->map.std->cat.local_size)\n\t\t\t\t\t     doi_def->map.std->cat.local_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase NLBL_CIPSOV4_A_MLSCATREM:\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t\t    CIPSO_V4_MAX_REM_CATS)\n\t\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t      doi_def->map.std->cat.cipso_size)\n\t\t\t\t\t     doi_def->map.std->cat.cipso_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\tdoi_def->map.std->cat.local = kcalloc(\n\t\t\t                      doi_def->map.std->cat.local_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (doi_def->map.std->cat.local == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_std_failure;\n\t\t}\n\t\tdoi_def->map.std->cat.cipso = kcalloc(\n\t\t\t                      doi_def->map.std->cat.cipso_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (doi_def->map.std->cat.cipso == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_std_failure;\n\t\t}\n\t\tfor (iter = 0; iter < doi_def->map.std->cat.local_size; iter++)\n\t\t\tdoi_def->map.std->cat.local[iter] = CIPSO_V4_INV_CAT;\n\t\tfor (iter = 0; iter < doi_def->map.std->cat.cipso_size; iter++)\n\t\t\tdoi_def->map.std->cat.cipso[iter] = CIPSO_V4_INV_CAT;\n\t\tnla_for_each_nested(nla_a,\n\t\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t    nla_a_rem)\n\t\t\tif (nla_a->nla_type == NLBL_CIPSOV4_A_MLSCAT) {\n\t\t\t\tstruct nlattr *cat_loc;\n\t\t\t\tstruct nlattr *cat_rem;\n\n\t\t\t\tcat_loc = nla_find_nested(nla_a,\n\t\t\t\t\t\t     NLBL_CIPSOV4_A_MLSCATLOC);\n\t\t\t\tcat_rem = nla_find_nested(nla_a,\n\t\t\t\t\t\t     NLBL_CIPSOV4_A_MLSCATREM);\n\t\t\t\tif (cat_loc == NULL || cat_rem == NULL)\n\t\t\t\t\tgoto add_std_failure;\n\t\t\t\tdoi_def->map.std->cat.local[\n\t\t\t\t                        nla_get_u32(cat_loc)] =\n\t\t\t\t\tnla_get_u32(cat_rem);\n\t\t\t\tdoi_def->map.std->cat.cipso[\n\t\t\t\t\t                nla_get_u32(cat_rem)] =\n\t\t\t\t\tnla_get_u32(cat_loc);\n\t\t\t}\n\t}\n\n\tret_val = cipso_v4_doi_add(doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_std_failure;\n\treturn 0;\n\nadd_std_failure:\n\tif (doi_def)\n\t\tnetlbl_cipsov4_doi_free(&doi_def->rcu);\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_add_pass - Adds a CIPSO V4 DOI definition\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Create a new CIPSO_V4_MAP_PASS DOI definition based on the given ADD message\n * and add it to the CIPSO V4 engine.  Return zero on success and non-zero on\n * error.\n *\n */\nstatic int netlbl_cipsov4_add_pass(struct genl_info *info)\n{\n\tint ret_val;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_TAGLST])\n\t\treturn -EINVAL;\n\n\tdoi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);\n\tif (doi_def == NULL)\n\t\treturn -ENOMEM;\n\tdoi_def->type = CIPSO_V4_MAP_PASS;\n\n\tret_val = netlbl_cipsov4_add_common(info, doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_pass_failure;\n\n\tret_val = cipso_v4_doi_add(doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_pass_failure;\n\treturn 0;\n\nadd_pass_failure:\n\tnetlbl_cipsov4_doi_free(&doi_def->rcu);\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_add - Handle an ADD message\n * @skb: the NETLINK buffer\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Create a new DOI definition based on the given ADD message and add it to the\n * CIPSO V4 engine.  Returns zero on success, negative values on failure.\n *\n */\nstatic int netlbl_cipsov4_add(struct sk_buff *skb, struct genl_info *info)\n\n{\n\tint ret_val = -EINVAL;\n\tu32 type;\n\tu32 doi;\n\tconst char *type_str = \"(unknown)\";\n\tstruct audit_buffer *audit_buf;\n\tstruct netlbl_audit audit_info;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI] ||\n\t    !info->attrs[NLBL_CIPSOV4_A_MTYPE])\n\t\treturn -EINVAL;\n\n\tdoi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tnetlbl_netlink_auditinfo(skb, &audit_info);\n\n\ttype = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_MTYPE]);\n\tswitch (type) {\n\tcase CIPSO_V4_MAP_STD:\n\t\ttype_str = \"std\";\n\t\tret_val = netlbl_cipsov4_add_std(info);\n\t\tbreak;\n\tcase CIPSO_V4_MAP_PASS:\n\t\ttype_str = \"pass\";\n\t\tret_val = netlbl_cipsov4_add_pass(info);\n\t\tbreak;\n\t}\n\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_CIPSOV4_ADD,\n\t\t\t\t\t      &audit_info);\n\tif (audit_buf != NULL) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" cipso_doi=%u cipso_type=%s res=%u\",\n\t\t\t\t doi,\n\t\t\t\t type_str,\n\t\t\t\t ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_list - Handle a LIST message\n * @skb: the NETLINK buffer\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Process a user generated LIST message and respond accordingly.  While the\n * response message generated by the kernel is straightforward, determining\n * before hand the size of the buffer to allocate is not (we have to generate\n * the message to know the size).  In order to keep this function sane what we\n * do is allocate a buffer of NLMSG_GOODSIZE and try to fit the response in\n * that size, if we fail then we restart with a larger buffer and try again.\n * We continue in this manner until we hit a limit of failed attempts then we\n * give up and just send an error message.  Returns zero on success and\n * negative values on error.\n *\n */\nstatic int netlbl_cipsov4_list(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val;\n\tstruct sk_buff *ans_skb = NULL;\n\tu32 nlsze_mult = 1;\n\tvoid *data;\n\tu32 doi;\n\tstruct nlattr *nla_a;\n\tstruct nlattr *nla_b;\n\tstruct cipso_v4_doi *doi_def;\n\tu32 iter;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI]) {\n\t\tret_val = -EINVAL;\n\t\tgoto list_failure;\n\t}\n\nlist_start:\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE * nlsze_mult, GFP_KERNEL);\n\tif (ans_skb == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_cipsov4_gnl_family,\n\t\t\t\t 0, NLBL_CIPSOV4_C_LIST);\n\tif (data == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\n\tdoi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_getdef(doi);\n\tif (doi_def == NULL) {\n\t\tret_val = -EINVAL;\n\t\tgoto list_failure;\n\t}\n\n\tret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MTYPE, doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto list_failure_lock;\n\n\tnla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_TAGLST);\n\tif (nla_a == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure_lock;\n\t}\n\tfor (iter = 0;\n\t     iter < CIPSO_V4_TAG_MAXCNT &&\n\t       doi_def->tags[iter] != CIPSO_V4_TAG_INVALID;\n\t     iter++) {\n\t\tret_val = nla_put_u8(ans_skb,\n\t\t\t\t     NLBL_CIPSOV4_A_TAG,\n\t\t\t\t     doi_def->tags[iter]);\n\t\tif (ret_val != 0)\n\t\t\tgoto list_failure_lock;\n\t}\n\tnla_nest_end(ans_skb, nla_a);\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_STD:\n\t\tnla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSLVLLST);\n\t\tif (nla_a == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto list_failure_lock;\n\t\t}\n\t\tfor (iter = 0;\n\t\t     iter < doi_def->map.std->lvl.local_size;\n\t\t     iter++) {\n\t\t\tif (doi_def->map.std->lvl.local[iter] ==\n\t\t\t    CIPSO_V4_INV_LVL)\n\t\t\t\tcontinue;\n\n\t\t\tnla_b = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSLVL);\n\t\t\tif (nla_b == NULL) {\n\t\t\t\tret_val = -ENOMEM;\n\t\t\t\tgoto list_retry;\n\t\t\t}\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MLSLVLLOC,\n\t\t\t\t\t      iter);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t    NLBL_CIPSOV4_A_MLSLVLREM,\n\t\t\t\t\t    doi_def->map.std->lvl.local[iter]);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tnla_nest_end(ans_skb, nla_b);\n\t\t}\n\t\tnla_nest_end(ans_skb, nla_a);\n\n\t\tnla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSCATLST);\n\t\tif (nla_a == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto list_retry;\n\t\t}\n\t\tfor (iter = 0;\n\t\t     iter < doi_def->map.std->cat.local_size;\n\t\t     iter++) {\n\t\t\tif (doi_def->map.std->cat.local[iter] ==\n\t\t\t    CIPSO_V4_INV_CAT)\n\t\t\t\tcontinue;\n\n\t\t\tnla_b = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSCAT);\n\t\t\tif (nla_b == NULL) {\n\t\t\t\tret_val = -ENOMEM;\n\t\t\t\tgoto list_retry;\n\t\t\t}\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MLSCATLOC,\n\t\t\t\t\t      iter);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t    NLBL_CIPSOV4_A_MLSCATREM,\n\t\t\t\t\t    doi_def->map.std->cat.local[iter]);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tnla_nest_end(ans_skb, nla_b);\n\t\t}\n\t\tnla_nest_end(ans_skb, nla_a);\n\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tgenlmsg_end(ans_skb, data);\n\n\tret_val = genlmsg_reply(ans_skb, info);\n\tif (ret_val != 0)\n\t\tgoto list_failure;\n\n\treturn 0;\n\nlist_retry:\n\t/* XXX - this limit is a guesstimate */\n\tif (nlsze_mult < 4) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(ans_skb);\n\t\tnlsze_mult++;\n\t\tgoto list_start;\n\t}\nlist_failure_lock:\n\trcu_read_unlock();\nlist_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_listall_cb - cipso_v4_doi_walk() callback for LISTALL\n * @doi_def: the CIPSOv4 DOI definition\n * @arg: the netlbl_cipsov4_doiwalk_arg structure\n *\n * Description:\n * This function is designed to be used as a callback to the\n * cipso_v4_doi_walk() function for use in generating a response for a LISTALL\n * message.  Returns the size of the message on success, negative values on\n * failure.\n *\n */\nstatic int netlbl_cipsov4_listall_cb(struct cipso_v4_doi *doi_def, void *arg)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_cipsov4_doiwalk_arg *cb_arg = arg;\n\tvoid *data;\n\n\tdata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).pid,\n\t\t\t   cb_arg->seq, &netlbl_cipsov4_gnl_family,\n\t\t\t   NLM_F_MULTI, NLBL_CIPSOV4_C_LISTALL);\n\tif (data == NULL)\n\t\tgoto listall_cb_failure;\n\n\tret_val = nla_put_u32(cb_arg->skb, NLBL_CIPSOV4_A_DOI, doi_def->doi);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\tret_val = nla_put_u32(cb_arg->skb,\n\t\t\t      NLBL_CIPSOV4_A_MTYPE,\n\t\t\t      doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\n\treturn genlmsg_end(cb_arg->skb, data);\n\nlistall_cb_failure:\n\tgenlmsg_cancel(cb_arg->skb, data);\n\treturn ret_val;\n}\n\n/**\n * netlbl_cipsov4_listall - Handle a LISTALL message\n * @skb: the NETLINK buffer\n * @cb: the NETLINK callback\n *\n * Description:\n * Process a user generated LISTALL message and respond accordingly.  Returns\n * zero on success and negative values on error.\n *\n */\nstatic int netlbl_cipsov4_listall(struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tstruct netlbl_cipsov4_doiwalk_arg cb_arg;\n\tint doi_skip = cb->args[0];\n\n\tcb_arg.nl_cb = cb;\n\tcb_arg.skb = skb;\n\tcb_arg.seq = cb->nlh->nlmsg_seq;\n\n\tcipso_v4_doi_walk(&doi_skip, netlbl_cipsov4_listall_cb, &cb_arg);\n\n\tcb->args[0] = doi_skip;\n\treturn skb->len;\n}\n\n/**\n * netlbl_cipsov4_remove - Handle a REMOVE message\n * @skb: the NETLINK buffer\n * @info: the Generic NETLINK info block\n *\n * Description:\n * Process a user generated REMOVE message and respond accordingly.  Returns\n * zero on success, negative values on failure.\n *\n */\nstatic int netlbl_cipsov4_remove(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tu32 doi = 0;\n\tstruct audit_buffer *audit_buf;\n\tstruct netlbl_audit audit_info;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI])\n\t\treturn -EINVAL;\n\n\tdoi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tnetlbl_netlink_auditinfo(skb, &audit_info);\n\n\tret_val = cipso_v4_doi_remove(doi,\n\t\t\t\t      &audit_info,\n\t\t\t\t      netlbl_cipsov4_doi_free);\n\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_CIPSOV4_DEL,\n\t\t\t\t\t      &audit_info);\n\tif (audit_buf != NULL) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" cipso_doi=%u res=%u\",\n\t\t\t\t doi,\n\t\t\t\t ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}\n\n/*\n * NetLabel Generic NETLINK Command Definitions\n */\n\nstatic struct genl_ops netlbl_cipsov4_genl_c_add = {\n\t.cmd = NLBL_CIPSOV4_C_ADD,\n\t.flags = GENL_ADMIN_PERM,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.doit = netlbl_cipsov4_add,\n\t.dumpit = NULL,\n};\n\nstatic struct genl_ops netlbl_cipsov4_genl_c_remove = {\n\t.cmd = NLBL_CIPSOV4_C_REMOVE,\n\t.flags = GENL_ADMIN_PERM,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.doit = netlbl_cipsov4_remove,\n\t.dumpit = NULL,\n};\n\nstatic struct genl_ops netlbl_cipsov4_genl_c_list = {\n\t.cmd = NLBL_CIPSOV4_C_LIST,\n\t.flags = 0,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.doit = netlbl_cipsov4_list,\n\t.dumpit = NULL,\n};\n\nstatic struct genl_ops netlbl_cipsov4_genl_c_listall = {\n\t.cmd = NLBL_CIPSOV4_C_LISTALL,\n\t.flags = 0,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.doit = NULL,\n\t.dumpit = netlbl_cipsov4_listall,\n};\n\n/*\n * NetLabel Generic NETLINK Protocol Functions\n */\n\n/**\n * netlbl_cipsov4_genl_init - Register the CIPSOv4 NetLabel component\n *\n * Description:\n * Register the CIPSOv4 packet NetLabel component with the Generic NETLINK\n * mechanism.  Returns zero on success, negative values on failure.\n *\n */\nint netlbl_cipsov4_genl_init(void)\n{\n\tint ret_val;\n\n\tret_val = genl_register_family(&netlbl_cipsov4_gnl_family);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tret_val = genl_register_ops(&netlbl_cipsov4_gnl_family,\n\t\t\t\t    &netlbl_cipsov4_genl_c_add);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tret_val = genl_register_ops(&netlbl_cipsov4_gnl_family,\n\t\t\t\t    &netlbl_cipsov4_genl_c_remove);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tret_val = genl_register_ops(&netlbl_cipsov4_gnl_family,\n\t\t\t\t    &netlbl_cipsov4_genl_c_list);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tret_val = genl_register_ops(&netlbl_cipsov4_gnl_family,\n\t\t\t\t    &netlbl_cipsov4_genl_c_listall);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\treturn 0;\n}\n"], "filenames": ["net/netlabel/netlabel_cipso_v4.c"], "buggy_code_start_loc": [133], "buggy_code_end_loc": [139], "fixing_code_start_loc": [133], "fixing_code_end_loc": [139], "type": "CWE-119", "message": "In the Linux kernel before 2.6.20, there is an off-by-one bug in net/netlabel/netlabel_cipso_v4.c where it is possible to overflow the doi_def->tags[] array.", "other": {"cve": {"id": "CVE-2007-6762", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-27T22:15:10.950", "lastModified": "2019-09-27T18:15:10.647", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 2.6.20, there is an off-by-one bug in net/netlabel/netlabel_cipso_v4.c where it is possible to overflow the doi_def->tags[] array."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 2.6.20, se presenta un error por un paso en el archivo net/netlabel/netlabel_cipso_v4.c donde es posible desbordar la matriz doi_def-)tags[]."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.20", "matchCriteriaId": "404F0A3D-E6B5-4964-BD9D-32FAF1C76D2A"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2a2f11c227bdf292b3a2900ad04139d301b56ac4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2a2f11c227bdf292b3a2900ad04139d301b56ac4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mirrors.edge.kernel.org/pub/linux/kernel/v2.6/ChangeLog-2.6.20", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://support.f5.com/csp/article/K05342145", "source": "cve@mitre.org"}, {"url": "https://support.f5.com/csp/article/K05342145?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2a2f11c227bdf292b3a2900ad04139d301b56ac4"}}