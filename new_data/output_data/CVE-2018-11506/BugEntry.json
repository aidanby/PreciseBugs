{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"sr.h\"\n\n#if 0\n#define DEBUG\n#endif\n\n/* The sr_is_xa() seems to trigger firmware bugs with some drives :-(\n * It is off by default and can be turned on with this module parameter */\nstatic int xa_test = 0;\n\nmodule_param(xa_test, int, S_IRUGO | S_IWUSR);\n\n/* primitive to determine whether we need to have GFP_DMA set based on\n * the status of the unchecked_isa_dma flag in the host structure */\n#define SR_GFP_DMA(cd) (((cd)->device->host->unchecked_isa_dma) ? GFP_DMA : 0)\n\nstatic int sr_read_tochdr(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_tochdr *tochdr)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\tunsigned char *buffer;\n\n\tbuffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\n\tcgc.cmd[8] = 12;\t\t/* LSB of length */\n\tcgc.buffer = buffer;\n\tcgc.buflen = 12;\n\tcgc.quiet = 1;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\n\ttochdr->cdth_trk0 = buffer[2];\n\ttochdr->cdth_trk1 = buffer[3];\n\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic int sr_read_tocentry(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_tocentry *tocentry)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\tunsigned char *buffer;\n\n\tbuffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\n\tcgc.cmd[1] |= (tocentry->cdte_format == CDROM_MSF) ? 0x02 : 0;\n\tcgc.cmd[6] = tocentry->cdte_track;\n\tcgc.cmd[8] = 12;\t\t/* LSB of length */\n\tcgc.buffer = buffer;\n\tcgc.buflen = 12;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\n\ttocentry->cdte_ctrl = buffer[5] & 0xf;\n\ttocentry->cdte_adr = buffer[5] >> 4;\n\ttocentry->cdte_datamode = (tocentry->cdte_ctrl & 0x04) ? 1 : 0;\n\tif (tocentry->cdte_format == CDROM_MSF) {\n\t\ttocentry->cdte_addr.msf.minute = buffer[9];\n\t\ttocentry->cdte_addr.msf.second = buffer[10];\n\t\ttocentry->cdte_addr.msf.frame = buffer[11];\n\t} else\n\t\ttocentry->cdte_addr.lba = (((((buffer[8] << 8) + buffer[9]) << 8)\n\t\t\t+ buffer[10]) << 8) + buffer[11];\n\n\tkfree(buffer);\n\treturn result;\n}\n\n#define IOCTL_RETRIES 3\n\n/* ATAPI drives don't have a SCMD_PLAYAUDIO_TI command.  When these drives\n   are emulating a SCSI device via the idescsi module, they need to have\n   CDROMPLAYTRKIND commands translated into CDROMPLAYMSF commands for them */\n\nstatic int sr_fake_playtrkind(struct cdrom_device_info *cdi, struct cdrom_ti *ti)\n{\n\tstruct cdrom_tocentry trk0_te, trk1_te;\n\tstruct cdrom_tochdr tochdr;\n\tstruct packet_command cgc;\n\tint ntracks, ret;\n\n\tret = sr_read_tochdr(cdi, &tochdr);\n\tif (ret)\n\t\treturn ret;\n\n\tntracks = tochdr.cdth_trk1 - tochdr.cdth_trk0 + 1;\n\t\n\tif (ti->cdti_trk1 == ntracks) \n\t\tti->cdti_trk1 = CDROM_LEADOUT;\n\telse if (ti->cdti_trk1 != CDROM_LEADOUT)\n\t\tti->cdti_trk1 ++;\n\n\ttrk0_te.cdte_track = ti->cdti_trk0;\n\ttrk0_te.cdte_format = CDROM_MSF;\n\ttrk1_te.cdte_track = ti->cdti_trk1;\n\ttrk1_te.cdte_format = CDROM_MSF;\n\t\n\tret = sr_read_tocentry(cdi, &trk0_te);\n\tif (ret)\n\t\treturn ret;\n\tret = sr_read_tocentry(cdi, &trk1_te);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_PLAY_AUDIO_MSF;\n\tcgc.cmd[3] = trk0_te.cdte_addr.msf.minute;\n\tcgc.cmd[4] = trk0_te.cdte_addr.msf.second;\n\tcgc.cmd[5] = trk0_te.cdte_addr.msf.frame;\n\tcgc.cmd[6] = trk1_te.cdte_addr.msf.minute;\n\tcgc.cmd[7] = trk1_te.cdte_addr.msf.second;\n\tcgc.cmd[8] = trk1_te.cdte_addr.msf.frame;\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cdi->handle, &cgc);\n}\n\nstatic int sr_play_trkind(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_ti *ti)\n\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_PLAYAUDIO_TI;\n\tcgc.cmd[4] = ti->cdti_trk0;\n\tcgc.cmd[5] = ti->cdti_ind0;\n\tcgc.cmd[7] = ti->cdti_trk1;\n\tcgc.cmd[8] = ti->cdti_ind1;\n\tcgc.data_direction = DMA_NONE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\tif (result == -EDRIVE_CANT_DO_THIS)\n\t\tresult = sr_fake_playtrkind(cdi, ti);\n\n\treturn result;\n}\n\n/* We do our own retries because we want to know what the specific\n   error code is.  Normally the UNIT_ATTENTION code will automatically\n   clear after one error */\n\nint sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr sshdr;\n\tint result, err = 0, retries = 0;\n\n\tSDev = cd->device;\n\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n\t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n\n\t/* Minimal error checking.  Ignore cases we know about, and report the rest. */\n\tif (driver_byte(result) != 0) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t/* This happens if there is no disc in drive */\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\t/* sense: Logical unit is in process of becoming ready */\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\t/* sleep 2 sec and try again */\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\t/* 20 secs are enough? */\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\t/* sense: Invalid command operation code */\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\n\t/* Wake up a process waiting for device */\n      out:\n\tcgc->stat = err;\n\treturn err;\n}\n\n/* ---------------------------------------------------------------------- */\n/* interface to cdrom.c                                                   */\n\nint sr_tray_move(struct cdrom_device_info *cdi, int pos)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_START_STOP_UNIT;\n\tcgc.cmd[4] = (pos == 0) ? 0x03 /* close */ : 0x02 /* eject */ ;\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cd, &cgc);\n}\n\nint sr_lock_door(struct cdrom_device_info *cdi, int lock)\n{\n\tScsi_CD *cd = cdi->handle;\n\n\treturn scsi_set_medium_removal(cd->device, lock ?\n\t\t       SCSI_REMOVAL_PREVENT : SCSI_REMOVAL_ALLOW);\n}\n\nint sr_drive_status(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct scsi_sense_hdr sshdr;\n\tstruct media_event_desc med;\n\n\tif (CDSL_CURRENT != slot) {\n\t\t/* we have no changer support */\n\t\treturn -EINVAL;\n\t}\n\tif (!scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))\n\t\treturn CDS_DISC_OK;\n\n\t/* SK/ASC/ASCQ of 2/4/1 means \"unit is becoming ready\" */\n\tif (scsi_sense_valid(&sshdr) && sshdr.sense_key == NOT_READY\n\t\t\t&& sshdr.asc == 0x04 && sshdr.ascq == 0x01)\n\t\treturn CDS_DRIVE_NOT_READY;\n\n\tif (!cdrom_get_media_event(cdi, &med)) {\n\t\tif (med.media_present)\n\t\t\treturn CDS_DISC_OK;\n\t\telse if (med.door_open)\n\t\t\treturn CDS_TRAY_OPEN;\n\t\telse\n\t\t\treturn CDS_NO_DISC;\n\t}\n\n\t/*\n\t * SK/ASC/ASCQ of 2/4/2 means \"initialization required\"\n\t * Using CD_TRAY_OPEN results in an START_STOP_UNIT to close\n\t * the tray, which resolves the initialization requirement.\n\t */\n\tif (scsi_sense_valid(&sshdr) && sshdr.sense_key == NOT_READY\n\t\t\t&& sshdr.asc == 0x04 && sshdr.ascq == 0x02)\n\t\treturn CDS_TRAY_OPEN;\n\n\t/*\n\t * 0x04 is format in progress .. but there must be a disc present!\n\t */\n\tif (sshdr.sense_key == NOT_READY && sshdr.asc == 0x04)\n\t\treturn CDS_DISC_OK;\n\n\t/*\n\t * If not using Mt Fuji extended media tray reports,\n\t * just return TRAY_OPEN since ATAPI doesn't provide\n\t * any other way to detect this...\n\t */\n\tif (scsi_sense_valid(&sshdr) &&\n\t    /* 0x3a is medium not present */\n\t    sshdr.asc == 0x3a)\n\t\treturn CDS_NO_DISC;\n\telse\n\t\treturn CDS_TRAY_OPEN;\n\n\treturn CDS_DRIVE_NOT_READY;\n}\n\nint sr_disk_status(struct cdrom_device_info *cdi)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct cdrom_tochdr toc_h;\n\tstruct cdrom_tocentry toc_e;\n\tint i, rc, have_datatracks = 0;\n\n\t/* look for data tracks */\n\trc = sr_read_tochdr(cdi, &toc_h);\n\tif (rc)\n\t\treturn (rc == -ENOMEDIUM) ? CDS_NO_DISC : CDS_NO_INFO;\n\n\tfor (i = toc_h.cdth_trk0; i <= toc_h.cdth_trk1; i++) {\n\t\ttoc_e.cdte_track = i;\n\t\ttoc_e.cdte_format = CDROM_LBA;\n\t\tif (sr_read_tocentry(cdi, &toc_e))\n\t\t\treturn CDS_NO_INFO;\n\t\tif (toc_e.cdte_ctrl & CDROM_DATA_TRACK) {\n\t\t\thave_datatracks = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!have_datatracks)\n\t\treturn CDS_AUDIO;\n\n\tif (cd->xa_flag)\n\t\treturn CDS_XA_2_1;\n\telse\n\t\treturn CDS_DATA_1;\n}\n\nint sr_get_last_session(struct cdrom_device_info *cdi,\n\t\t\tstruct cdrom_multisession *ms_info)\n{\n\tScsi_CD *cd = cdi->handle;\n\n\tms_info->addr.lba = cd->ms_offset;\n\tms_info->xa_flag = cd->xa_flag || cd->ms_offset > 0;\n\n\treturn 0;\n}\n\nint sr_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tchar *buffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\n\tint result;\n\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_SUBCHANNEL;\n\tcgc.cmd[2] = 0x40;\t/* I do want the subchannel info */\n\tcgc.cmd[3] = 0x02;\t/* Give me medium catalog number info */\n\tcgc.cmd[8] = 24;\n\tcgc.buffer = buffer;\n\tcgc.buflen = 24;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tresult = sr_do_ioctl(cd, &cgc);\n\n\tmemcpy(mcn->medium_catalog_number, buffer + 9, 13);\n\tmcn->medium_catalog_number[13] = 0;\n\n\tkfree(buffer);\n\treturn result;\n}\n\nint sr_reset(struct cdrom_device_info *cdi)\n{\n\treturn 0;\n}\n\nint sr_select_speed(struct cdrom_device_info *cdi, int speed)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\n\tif (speed == 0)\n\t\tspeed = 0xffff;\t/* set to max */\n\telse\n\t\tspeed *= 177;\t/* Nx to kbyte/s */\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_SET_SPEED;\t/* SET CD SPEED */\n\tcgc.cmd[2] = (speed >> 8) & 0xff;\t/* MSB for speed (in kbytes/sec) */\n\tcgc.cmd[3] = speed & 0xff;\t/* LSB */\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\n\tif (sr_do_ioctl(cd, &cgc))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n/* ----------------------------------------------------------------------- */\n/* this is called by the generic cdrom driver. arg is a _kernel_ pointer,  */\n/* because the generic cdrom driver does the user access stuff for us.     */\n/* only cdromreadtochdr and cdromreadtocentry are left - for use with the  */\n/* sr_disk_status interface for the generic cdrom driver.                  */\n\nint sr_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase CDROMREADTOCHDR:\n\t\treturn sr_read_tochdr(cdi, arg);\n\tcase CDROMREADTOCENTRY:\n\t\treturn sr_read_tocentry(cdi, arg);\n\tcase CDROMPLAYTRKIND:\n\t\treturn sr_play_trkind(cdi, arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* -----------------------------------------------------------------------\n * a function to read all sorts of funny cdrom sectors using the READ_CD\n * scsi-3 mmc command\n *\n * lba:     linear block address\n * format:  0 = data (anything)\n *          1 = audio\n *          2 = data (mode 1)\n *          3 = data (mode 2)\n *          4 = data (mode 2 form1)\n *          5 = data (mode 2 form2)\n * blksize: 2048 | 2336 | 2340 | 2352\n */\n\nstatic int sr_read_cd(Scsi_CD *cd, unsigned char *dest, int lba, int format, int blksize)\n{\n\tstruct packet_command cgc;\n\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_read_cd lba=%d format=%d blksize=%d\\n\",\n\t\t  lba, format, blksize);\n#endif\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_CD;\t/* READ_CD */\n\tcgc.cmd[1] = ((format & 7) << 2);\n\tcgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;\n\tcgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;\n\tcgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;\n\tcgc.cmd[5] = (unsigned char) lba & 0xff;\n\tcgc.cmd[8] = 1;\n\tswitch (blksize) {\n\tcase 2336:\n\t\tcgc.cmd[9] = 0x58;\n\t\tbreak;\n\tcase 2340:\n\t\tcgc.cmd[9] = 0x78;\n\t\tbreak;\n\tcase 2352:\n\t\tcgc.cmd[9] = 0xf8;\n\t\tbreak;\n\tdefault:\n\t\tcgc.cmd[9] = 0x10;\n\t\tbreak;\n\t}\n\tcgc.buffer = dest;\n\tcgc.buflen = blksize;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cd, &cgc);\n}\n\n/*\n * read sectors with blocksizes other than 2048\n */\n\nstatic int sr_read_sector(Scsi_CD *cd, int lba, int blksize, unsigned char *dest)\n{\n\tstruct packet_command cgc;\n\tint rc;\n\n\t/* we try the READ CD command first... */\n\tif (cd->readcd_known) {\n\t\trc = sr_read_cd(cd, dest, lba, 0, blksize);\n\t\tif (-EDRIVE_CANT_DO_THIS != rc)\n\t\t\treturn rc;\n\t\tcd->readcd_known = 0;\n\t\tsr_printk(KERN_INFO, cd,\n\t\t\t  \"CDROM does'nt support READ CD (0xbe) command\\n\");\n\t\t/* fall & retry the other way */\n\t}\n\t/* ... if this fails, we switch the blocksize using MODE SELECT */\n\tif (blksize != cd->device->sector_size) {\n\t\tif (0 != (rc = sr_set_blocklength(cd, blksize)))\n\t\t\treturn rc;\n\t}\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_read_sector lba=%d blksize=%d\\n\",\n\t\t  lba, blksize);\n#endif\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_10;\n\tcgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;\n\tcgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;\n\tcgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;\n\tcgc.cmd[5] = (unsigned char) lba & 0xff;\n\tcgc.cmd[8] = 1;\n\tcgc.buffer = dest;\n\tcgc.buflen = blksize;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\trc = sr_do_ioctl(cd, &cgc);\n\n\treturn rc;\n}\n\n/*\n * read a sector in raw mode to check the sector format\n * ret: 1 == mode2 (XA), 0 == mode1, <0 == error \n */\n\nint sr_is_xa(Scsi_CD *cd)\n{\n\tunsigned char *raw_sector;\n\tint is_xa;\n\n\tif (!xa_test)\n\t\treturn 0;\n\n\traw_sector = kmalloc(2048, GFP_KERNEL | SR_GFP_DMA(cd));\n\tif (!raw_sector)\n\t\treturn -ENOMEM;\n\tif (0 == sr_read_sector(cd, cd->ms_offset + 16,\n\t\t\t\tCD_FRAMESIZE_RAW1, raw_sector)) {\n\t\tis_xa = (raw_sector[3] == 0x02) ? 1 : 0;\n\t} else {\n\t\t/* read a raw sector failed for some reason. */\n\t\tis_xa = -1;\n\t}\n\tkfree(raw_sector);\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_is_xa: %d\\n\", is_xa);\n#endif\n\treturn is_xa;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"sr.h\"\n\n#if 0\n#define DEBUG\n#endif\n\n/* The sr_is_xa() seems to trigger firmware bugs with some drives :-(\n * It is off by default and can be turned on with this module parameter */\nstatic int xa_test = 0;\n\nmodule_param(xa_test, int, S_IRUGO | S_IWUSR);\n\n/* primitive to determine whether we need to have GFP_DMA set based on\n * the status of the unchecked_isa_dma flag in the host structure */\n#define SR_GFP_DMA(cd) (((cd)->device->host->unchecked_isa_dma) ? GFP_DMA : 0)\n\nstatic int sr_read_tochdr(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_tochdr *tochdr)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\tunsigned char *buffer;\n\n\tbuffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\n\tcgc.cmd[8] = 12;\t\t/* LSB of length */\n\tcgc.buffer = buffer;\n\tcgc.buflen = 12;\n\tcgc.quiet = 1;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\n\ttochdr->cdth_trk0 = buffer[2];\n\ttochdr->cdth_trk1 = buffer[3];\n\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic int sr_read_tocentry(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_tocentry *tocentry)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\tunsigned char *buffer;\n\n\tbuffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\n\tcgc.cmd[1] |= (tocentry->cdte_format == CDROM_MSF) ? 0x02 : 0;\n\tcgc.cmd[6] = tocentry->cdte_track;\n\tcgc.cmd[8] = 12;\t\t/* LSB of length */\n\tcgc.buffer = buffer;\n\tcgc.buflen = 12;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\n\ttocentry->cdte_ctrl = buffer[5] & 0xf;\n\ttocentry->cdte_adr = buffer[5] >> 4;\n\ttocentry->cdte_datamode = (tocentry->cdte_ctrl & 0x04) ? 1 : 0;\n\tif (tocentry->cdte_format == CDROM_MSF) {\n\t\ttocentry->cdte_addr.msf.minute = buffer[9];\n\t\ttocentry->cdte_addr.msf.second = buffer[10];\n\t\ttocentry->cdte_addr.msf.frame = buffer[11];\n\t} else\n\t\ttocentry->cdte_addr.lba = (((((buffer[8] << 8) + buffer[9]) << 8)\n\t\t\t+ buffer[10]) << 8) + buffer[11];\n\n\tkfree(buffer);\n\treturn result;\n}\n\n#define IOCTL_RETRIES 3\n\n/* ATAPI drives don't have a SCMD_PLAYAUDIO_TI command.  When these drives\n   are emulating a SCSI device via the idescsi module, they need to have\n   CDROMPLAYTRKIND commands translated into CDROMPLAYMSF commands for them */\n\nstatic int sr_fake_playtrkind(struct cdrom_device_info *cdi, struct cdrom_ti *ti)\n{\n\tstruct cdrom_tocentry trk0_te, trk1_te;\n\tstruct cdrom_tochdr tochdr;\n\tstruct packet_command cgc;\n\tint ntracks, ret;\n\n\tret = sr_read_tochdr(cdi, &tochdr);\n\tif (ret)\n\t\treturn ret;\n\n\tntracks = tochdr.cdth_trk1 - tochdr.cdth_trk0 + 1;\n\t\n\tif (ti->cdti_trk1 == ntracks) \n\t\tti->cdti_trk1 = CDROM_LEADOUT;\n\telse if (ti->cdti_trk1 != CDROM_LEADOUT)\n\t\tti->cdti_trk1 ++;\n\n\ttrk0_te.cdte_track = ti->cdti_trk0;\n\ttrk0_te.cdte_format = CDROM_MSF;\n\ttrk1_te.cdte_track = ti->cdti_trk1;\n\ttrk1_te.cdte_format = CDROM_MSF;\n\t\n\tret = sr_read_tocentry(cdi, &trk0_te);\n\tif (ret)\n\t\treturn ret;\n\tret = sr_read_tocentry(cdi, &trk1_te);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_PLAY_AUDIO_MSF;\n\tcgc.cmd[3] = trk0_te.cdte_addr.msf.minute;\n\tcgc.cmd[4] = trk0_te.cdte_addr.msf.second;\n\tcgc.cmd[5] = trk0_te.cdte_addr.msf.frame;\n\tcgc.cmd[6] = trk1_te.cdte_addr.msf.minute;\n\tcgc.cmd[7] = trk1_te.cdte_addr.msf.second;\n\tcgc.cmd[8] = trk1_te.cdte_addr.msf.frame;\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cdi->handle, &cgc);\n}\n\nstatic int sr_play_trkind(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_ti *ti)\n\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tint result;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tcgc.cmd[0] = GPCMD_PLAYAUDIO_TI;\n\tcgc.cmd[4] = ti->cdti_trk0;\n\tcgc.cmd[5] = ti->cdti_ind0;\n\tcgc.cmd[7] = ti->cdti_trk1;\n\tcgc.cmd[8] = ti->cdti_ind1;\n\tcgc.data_direction = DMA_NONE;\n\n\tresult = sr_do_ioctl(cd, &cgc);\n\tif (result == -EDRIVE_CANT_DO_THIS)\n\t\tresult = sr_fake_playtrkind(cdi, ti);\n\n\treturn result;\n}\n\n/* We do our own retries because we want to know what the specific\n   error code is.  Normally the UNIT_ATTENTION code will automatically\n   clear after one error */\n\nint sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr sshdr;\n\tint result, err = 0, retries = 0;\n\tunsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE], *senseptr = NULL;\n\n\tSDev = cd->device;\n\n\tif (cgc->sense)\n\t\tsenseptr = sense_buffer;\n\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen, senseptr, &sshdr,\n\t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n\n\tif (cgc->sense)\n\t\tmemcpy(cgc->sense, sense_buffer, sizeof(*cgc->sense));\n\n\t/* Minimal error checking.  Ignore cases we know about, and report the rest. */\n\tif (driver_byte(result) != 0) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t/* This happens if there is no disc in drive */\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\t/* sense: Logical unit is in process of becoming ready */\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\t/* sleep 2 sec and try again */\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\t/* 20 secs are enough? */\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\t/* sense: Invalid command operation code */\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\n\t/* Wake up a process waiting for device */\n      out:\n\tcgc->stat = err;\n\treturn err;\n}\n\n/* ---------------------------------------------------------------------- */\n/* interface to cdrom.c                                                   */\n\nint sr_tray_move(struct cdrom_device_info *cdi, int pos)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_START_STOP_UNIT;\n\tcgc.cmd[4] = (pos == 0) ? 0x03 /* close */ : 0x02 /* eject */ ;\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cd, &cgc);\n}\n\nint sr_lock_door(struct cdrom_device_info *cdi, int lock)\n{\n\tScsi_CD *cd = cdi->handle;\n\n\treturn scsi_set_medium_removal(cd->device, lock ?\n\t\t       SCSI_REMOVAL_PREVENT : SCSI_REMOVAL_ALLOW);\n}\n\nint sr_drive_status(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct scsi_cd *cd = cdi->handle;\n\tstruct scsi_sense_hdr sshdr;\n\tstruct media_event_desc med;\n\n\tif (CDSL_CURRENT != slot) {\n\t\t/* we have no changer support */\n\t\treturn -EINVAL;\n\t}\n\tif (!scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))\n\t\treturn CDS_DISC_OK;\n\n\t/* SK/ASC/ASCQ of 2/4/1 means \"unit is becoming ready\" */\n\tif (scsi_sense_valid(&sshdr) && sshdr.sense_key == NOT_READY\n\t\t\t&& sshdr.asc == 0x04 && sshdr.ascq == 0x01)\n\t\treturn CDS_DRIVE_NOT_READY;\n\n\tif (!cdrom_get_media_event(cdi, &med)) {\n\t\tif (med.media_present)\n\t\t\treturn CDS_DISC_OK;\n\t\telse if (med.door_open)\n\t\t\treturn CDS_TRAY_OPEN;\n\t\telse\n\t\t\treturn CDS_NO_DISC;\n\t}\n\n\t/*\n\t * SK/ASC/ASCQ of 2/4/2 means \"initialization required\"\n\t * Using CD_TRAY_OPEN results in an START_STOP_UNIT to close\n\t * the tray, which resolves the initialization requirement.\n\t */\n\tif (scsi_sense_valid(&sshdr) && sshdr.sense_key == NOT_READY\n\t\t\t&& sshdr.asc == 0x04 && sshdr.ascq == 0x02)\n\t\treturn CDS_TRAY_OPEN;\n\n\t/*\n\t * 0x04 is format in progress .. but there must be a disc present!\n\t */\n\tif (sshdr.sense_key == NOT_READY && sshdr.asc == 0x04)\n\t\treturn CDS_DISC_OK;\n\n\t/*\n\t * If not using Mt Fuji extended media tray reports,\n\t * just return TRAY_OPEN since ATAPI doesn't provide\n\t * any other way to detect this...\n\t */\n\tif (scsi_sense_valid(&sshdr) &&\n\t    /* 0x3a is medium not present */\n\t    sshdr.asc == 0x3a)\n\t\treturn CDS_NO_DISC;\n\telse\n\t\treturn CDS_TRAY_OPEN;\n\n\treturn CDS_DRIVE_NOT_READY;\n}\n\nint sr_disk_status(struct cdrom_device_info *cdi)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct cdrom_tochdr toc_h;\n\tstruct cdrom_tocentry toc_e;\n\tint i, rc, have_datatracks = 0;\n\n\t/* look for data tracks */\n\trc = sr_read_tochdr(cdi, &toc_h);\n\tif (rc)\n\t\treturn (rc == -ENOMEDIUM) ? CDS_NO_DISC : CDS_NO_INFO;\n\n\tfor (i = toc_h.cdth_trk0; i <= toc_h.cdth_trk1; i++) {\n\t\ttoc_e.cdte_track = i;\n\t\ttoc_e.cdte_format = CDROM_LBA;\n\t\tif (sr_read_tocentry(cdi, &toc_e))\n\t\t\treturn CDS_NO_INFO;\n\t\tif (toc_e.cdte_ctrl & CDROM_DATA_TRACK) {\n\t\t\thave_datatracks = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!have_datatracks)\n\t\treturn CDS_AUDIO;\n\n\tif (cd->xa_flag)\n\t\treturn CDS_XA_2_1;\n\telse\n\t\treturn CDS_DATA_1;\n}\n\nint sr_get_last_session(struct cdrom_device_info *cdi,\n\t\t\tstruct cdrom_multisession *ms_info)\n{\n\tScsi_CD *cd = cdi->handle;\n\n\tms_info->addr.lba = cd->ms_offset;\n\tms_info->xa_flag = cd->xa_flag || cd->ms_offset > 0;\n\n\treturn 0;\n}\n\nint sr_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\tchar *buffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\n\tint result;\n\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_SUBCHANNEL;\n\tcgc.cmd[2] = 0x40;\t/* I do want the subchannel info */\n\tcgc.cmd[3] = 0x02;\t/* Give me medium catalog number info */\n\tcgc.cmd[8] = 24;\n\tcgc.buffer = buffer;\n\tcgc.buflen = 24;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\tresult = sr_do_ioctl(cd, &cgc);\n\n\tmemcpy(mcn->medium_catalog_number, buffer + 9, 13);\n\tmcn->medium_catalog_number[13] = 0;\n\n\tkfree(buffer);\n\treturn result;\n}\n\nint sr_reset(struct cdrom_device_info *cdi)\n{\n\treturn 0;\n}\n\nint sr_select_speed(struct cdrom_device_info *cdi, int speed)\n{\n\tScsi_CD *cd = cdi->handle;\n\tstruct packet_command cgc;\n\n\tif (speed == 0)\n\t\tspeed = 0xffff;\t/* set to max */\n\telse\n\t\tspeed *= 177;\t/* Nx to kbyte/s */\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_SET_SPEED;\t/* SET CD SPEED */\n\tcgc.cmd[2] = (speed >> 8) & 0xff;\t/* MSB for speed (in kbytes/sec) */\n\tcgc.cmd[3] = speed & 0xff;\t/* LSB */\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\n\tif (sr_do_ioctl(cd, &cgc))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n/* ----------------------------------------------------------------------- */\n/* this is called by the generic cdrom driver. arg is a _kernel_ pointer,  */\n/* because the generic cdrom driver does the user access stuff for us.     */\n/* only cdromreadtochdr and cdromreadtocentry are left - for use with the  */\n/* sr_disk_status interface for the generic cdrom driver.                  */\n\nint sr_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase CDROMREADTOCHDR:\n\t\treturn sr_read_tochdr(cdi, arg);\n\tcase CDROMREADTOCENTRY:\n\t\treturn sr_read_tocentry(cdi, arg);\n\tcase CDROMPLAYTRKIND:\n\t\treturn sr_play_trkind(cdi, arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* -----------------------------------------------------------------------\n * a function to read all sorts of funny cdrom sectors using the READ_CD\n * scsi-3 mmc command\n *\n * lba:     linear block address\n * format:  0 = data (anything)\n *          1 = audio\n *          2 = data (mode 1)\n *          3 = data (mode 2)\n *          4 = data (mode 2 form1)\n *          5 = data (mode 2 form2)\n * blksize: 2048 | 2336 | 2340 | 2352\n */\n\nstatic int sr_read_cd(Scsi_CD *cd, unsigned char *dest, int lba, int format, int blksize)\n{\n\tstruct packet_command cgc;\n\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_read_cd lba=%d format=%d blksize=%d\\n\",\n\t\t  lba, format, blksize);\n#endif\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_CD;\t/* READ_CD */\n\tcgc.cmd[1] = ((format & 7) << 2);\n\tcgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;\n\tcgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;\n\tcgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;\n\tcgc.cmd[5] = (unsigned char) lba & 0xff;\n\tcgc.cmd[8] = 1;\n\tswitch (blksize) {\n\tcase 2336:\n\t\tcgc.cmd[9] = 0x58;\n\t\tbreak;\n\tcase 2340:\n\t\tcgc.cmd[9] = 0x78;\n\t\tbreak;\n\tcase 2352:\n\t\tcgc.cmd[9] = 0xf8;\n\t\tbreak;\n\tdefault:\n\t\tcgc.cmd[9] = 0x10;\n\t\tbreak;\n\t}\n\tcgc.buffer = dest;\n\tcgc.buflen = blksize;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cd, &cgc);\n}\n\n/*\n * read sectors with blocksizes other than 2048\n */\n\nstatic int sr_read_sector(Scsi_CD *cd, int lba, int blksize, unsigned char *dest)\n{\n\tstruct packet_command cgc;\n\tint rc;\n\n\t/* we try the READ CD command first... */\n\tif (cd->readcd_known) {\n\t\trc = sr_read_cd(cd, dest, lba, 0, blksize);\n\t\tif (-EDRIVE_CANT_DO_THIS != rc)\n\t\t\treturn rc;\n\t\tcd->readcd_known = 0;\n\t\tsr_printk(KERN_INFO, cd,\n\t\t\t  \"CDROM does'nt support READ CD (0xbe) command\\n\");\n\t\t/* fall & retry the other way */\n\t}\n\t/* ... if this fails, we switch the blocksize using MODE SELECT */\n\tif (blksize != cd->device->sector_size) {\n\t\tif (0 != (rc = sr_set_blocklength(cd, blksize)))\n\t\t\treturn rc;\n\t}\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_read_sector lba=%d blksize=%d\\n\",\n\t\t  lba, blksize);\n#endif\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_READ_10;\n\tcgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;\n\tcgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;\n\tcgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;\n\tcgc.cmd[5] = (unsigned char) lba & 0xff;\n\tcgc.cmd[8] = 1;\n\tcgc.buffer = dest;\n\tcgc.buflen = blksize;\n\tcgc.data_direction = DMA_FROM_DEVICE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\trc = sr_do_ioctl(cd, &cgc);\n\n\treturn rc;\n}\n\n/*\n * read a sector in raw mode to check the sector format\n * ret: 1 == mode2 (XA), 0 == mode1, <0 == error \n */\n\nint sr_is_xa(Scsi_CD *cd)\n{\n\tunsigned char *raw_sector;\n\tint is_xa;\n\n\tif (!xa_test)\n\t\treturn 0;\n\n\traw_sector = kmalloc(2048, GFP_KERNEL | SR_GFP_DMA(cd));\n\tif (!raw_sector)\n\t\treturn -ENOMEM;\n\tif (0 == sr_read_sector(cd, cd->ms_offset + 16,\n\t\t\t\tCD_FRAMESIZE_RAW1, raw_sector)) {\n\t\tis_xa = (raw_sector[3] == 0x02) ? 1 : 0;\n\t} else {\n\t\t/* read a raw sector failed for some reason. */\n\t\tis_xa = -1;\n\t}\n\tkfree(raw_sector);\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"sr_is_xa: %d\\n\", is_xa);\n#endif\n\treturn is_xa;\n}\n"], "filenames": ["drivers/scsi/sr_ioctl.c"], "buggy_code_start_loc": [190], "buggy_code_end_loc": [203], "fixing_code_start_loc": [191], "fixing_code_end_loc": [210], "type": "CWE-787", "message": "The sr_do_ioctl function in drivers/scsi/sr_ioctl.c in the Linux kernel through 4.16.12 allows local users to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact because sense buffers have different sizes at the CDROM layer and the SCSI layer, as demonstrated by a CDROMREADMODE2 ioctl call.", "other": {"cve": {"id": "CVE-2018-11506", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-28T04:29:00.223", "lastModified": "2023-02-24T18:37:41.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The sr_do_ioctl function in drivers/scsi/sr_ioctl.c in the Linux kernel through 4.16.12 allows local users to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact because sense buffers have different sizes at the CDROM layer and the SCSI layer, as demonstrated by a CDROMREADMODE2 ioctl call."}, {"lang": "es", "value": "La funci\u00f3n sr_do_ioctl en drivers/scsi/sr_ioctl.c en el kernel de Linux hasta 4.16.12 permite a los usuarios locales causar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en pila) o, posiblemente, provocar otro impacto no especificado debido a que los b\u00faferes de sentido tienen diferentes tama\u00f1os en la capa de CDROM y en la capa SCSI, tal y como queda demostrado con una llamada ioctl CDROMREADMODE2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.11", "versionEndExcluding": "4.14.45", "matchCriteriaId": "45140399-FFFD-4C82-AD5C-732C06587127"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.16.13", "matchCriteriaId": "8D21E63D-6D60-456D-B65E-152D30840891"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f7068114d45ec55996b9040e98111afa56e010fe", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2948", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00016.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://twitter.com/efrmv/status/1001574894273007616", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe"}}