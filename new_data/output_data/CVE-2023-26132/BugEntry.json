{"buggy_code": ["[![Build Status](https://travis-ci.org/mickhansen/dottie.js.svg?branch=master)](https://travis-ci.org/mickhansen/dottie.js)\n\nDottie helps you easily (and without sacrificing too much performance) look up and play with nested keys in objects, without them throwing up in your face.\n\n## Install\n    npm install dottie\n\n## Usage\nFor detailed usage, check source or tests.\n\n### Get value\nGets nested value, or undefined if unreachable, or a default value if passed.\n\n```js\nvar values = {\n  some: {\n    nested: {\n        key: 'foobar';\n    }\n  },\n  'some.dot.included': {\n    key: 'barfoo'\n  }\n}\n\ndottie.get(values, 'some.nested.key'); // returns 'foobar'\ndottie.get(values, 'some.undefined.key'); // returns undefined\ndottie.get(values, 'some.undefined.key', 'defaultval'); // returns 'defaultval'\ndottie.get(values, ['some.dot.included', 'key']); // returns 'barfoo'\n```\n\n*Note: lodash.get() also works fine for this* \n\n### Set value\nSets nested value, creates nested structure if needed\n\n```js\ndottie.set(values, 'some.nested.value', someValue);\ndottie.set(values, ['some.dot.included', 'value'], someValue);\ndottie.set(values, 'some.nested.object', someValue, {\n  force: true // force overwrite defined non-object keys into objects if needed\n});\n```\n\n### Transform object\nTransform object from keys with dottie notation to nested objects\n\n```js\nvar values = {\n  'user.name': 'Gummy Bear',\n  'user.email': 'gummybear@candymountain.com',\n  'user.professional.title': 'King',\n  'user.professional.employer': 'Candy Mountain'\n};\nvar transformed = dottie.transform(values);\n\n/*\n{\n  user: {\n    name: 'Gummy Bear',\n    email: 'gummybear@candymountain.com',\n    professional: {\n      title: 'King',\n      employer: 'Candy Mountain'\n    }\n  }\n}\n*/\n```\n\n#### With a custom delimiter\n\n```js\nvar values = {\n  'user_name': 'Mick Hansen',\n  'user_email': 'maker@mhansen.io'\n};\nvar transformed = dottie.transform(values, { delimiter: '_' });\n\n/*\n{\n  user: {\n    name: 'Mick Hansen',\n    email: 'maker@mhansen.io'\n  }\n}\n*/\n```\n\n### Get paths in object\n```js\nvar object = {\n  a: 1,\n  b: {\n    c: 2,\n    d: { e: 3 }\n  }\n};\n\ndottie.paths(object); // [\"a\", \"b.c\", \"b.d.e\"];\n```\n\n## Performance\n\n`0.3.1` and up ships with `dottie.memoizePath: true` by default, if this causes any bugs, please try setting it to false\n\n## License\n\n[MIT](https://github.com/mickhansen/dottie.js/blob/master/LICENSE)\n", "(function(undefined) {\n  var root = this;\n\n  // Weird IE shit, objects do not have hasOwn, but the prototype does...\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var reverseDupArray = function (array) {\n    var result = new Array(array.length);\n    var index  = array.length;\n    var arrayMaxIndex = index - 1;\n\n    while (index--) {\n      result[arrayMaxIndex - index] = array[index];\n    }\n\n    return result;\n  };\n\n  var Dottie = function() {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length == 2) {\n      return Dottie.find.apply(this, args);\n    }\n    return Dottie.transform.apply(this, args);\n  };\n\n  // Legacy syntax, changed syntax to have get/set be similar in arg order\n  Dottie.find = function(path, object) {\n    return Dottie.get(object, path);\n  };\n\n  // Dottie memoization flag\n  Dottie.memoizePath = true;\n  var memoized = {};\n\n  // Traverse object according to path, return value if found - Return undefined if destination is unreachable\n  Dottie.get = function(object, path, defaultVal) {\n    if ((object === undefined) || (object === null) || (path === undefined) || (path === null)) {\n        return defaultVal;\n    }\n\n    var names;\n\n    if (typeof path === \"string\") {\n      if (Dottie.memoizePath) {\n        if (memoized[path]) {\n          names = memoized[path].slice(0);\n        } else {\n          names = path.split('.').reverse();\n          memoized[path] = names.slice(0);\n        }\n      } else {\n        names = path.split('.').reverse();\n      }\n    } else if (Array.isArray(path)) {\n      names = reverseDupArray(path);\n    }\n\n    while (names.length && (object = object[names.pop()]) !== undefined && object !== null);\n\n    // Handle cases where accessing a childprop of a null value\n    if (object === null && names.length) object = undefined;\n\n    return (object === undefined ? defaultVal : object);\n  };\n\n  Dottie.exists = function(object, path) {\n    return Dottie.get(object, path) !== undefined;\n  };\n\n  // Set nested value\n  Dottie.set = function(object, path, value, options) {\n    var pieces = Array.isArray(path) ? path : path.split('.'), current = object, piece, length = pieces.length;\n\n    if (typeof current !== 'object') {\n        throw new Error('Parent is not an object.');\n    }\n\n    for (var index = 0; index < length; index++) {\n      piece = pieces[index];\n\n      // Create namespace (object) where none exists.\n      // If `force === true`, bruteforce the path without throwing errors.\n      if (\n        !hasOwnProp.call(current, piece)\n        || current[piece] === undefined\n        || ((typeof current[piece] !== 'object' || current[piece] === null) && options && options.force === true)) {\n        current[piece] = {};\n      }\n\n      if (index == (length - 1)) {\n        // Set final value\n        current[piece] = value;\n      } else {\n        // We do not overwrite existing path pieces by default\n        if (typeof current[piece] !== 'object' || current[piece] === null) {\n          throw new Error('Target key \"' + piece + '\" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');\n        }\n\n        // Traverse next in path\n        current = current[piece];\n      }\n    }\n\n    // Is there any case when this is relevant? It's also the last line in the above for-loop\n    current[piece] = value;\n  };\n\n  // Set default nested value\n  Dottie['default'] = function(object, path, value) {\n    if (Dottie.get(object, path) === undefined) {\n      Dottie.set(object, path, value);\n    }\n  };\n\n  // Transform unnested object with .-seperated keys into a nested object.\n  Dottie.transform = function Dottie$transformfunction(object, options) {\n    if (Array.isArray(object)) {\n      return object.map(function(o) {\n        return Dottie.transform(o, options);\n      });\n    }\n\n    options = options || {};\n    options.delimiter = options.delimiter || '.';\n\n    var pieces\n      , piecesLength\n      , piece\n      , current\n      , transformed = {}\n      , key\n      , keys = Object.keys(object)\n      , length = keys.length\n      , i;\n\n    for (i = 0; i < length; i++) {\n      key = keys[i];\n\n      if (key.indexOf(options.delimiter) !== -1) {\n        pieces = key.split(options.delimiter);\n        piecesLength = pieces.length;\n        current = transformed;\n\n        for (var index = 0; index < piecesLength; index++) {\n          piece = pieces[index];\n          if (index != (piecesLength - 1) && !current.hasOwnProperty(piece)) {\n            current[piece] = {};\n          }\n\n          if (index == (piecesLength - 1)) {\n            current[piece] = object[key];\n          }\n\n          current = current[piece];\n          if (current === null) {\n            break;\n          }\n        }\n      } else {\n        transformed[key] = object[key];\n      }\n    }\n\n    return transformed;\n  };\n\n  Dottie.flatten = function(object, seperator) {\n    if (typeof seperator === \"undefined\") seperator = '.';\n    var flattened = {}\n      , current\n      , nested;\n\n    for (var key in object) {\n      if (hasOwnProp.call(object, key)) {\n        current = object[key];\n        if (Object.prototype.toString.call(current) === \"[object Object]\") {\n          nested = Dottie.flatten(current, seperator);\n\n          for (var _key in nested) {\n            flattened[key+seperator+_key] = nested[_key];\n          }\n        } else {\n          flattened[key] = current;\n        }\n      }\n    }\n\n    return flattened;\n  };\n\n  Dottie.paths = function(object, prefixes) {\n    var paths = [];\n    var value;\n    var key;\n\n    prefixes = prefixes || [];\n\n    if (typeof object === 'object') {\n      for (key in object) {\n        value = object[key];\n\n        if (typeof value === 'object' && value !== null) {\n          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));\n        } else {\n          paths.push(prefixes.concat(key).join('.'));\n        }\n      }\n    } else {\n      throw new Error('Paths was called with non-object argument.');\n    }\n\n    return paths;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = Dottie;\n  } else {\n    root['Dottie'] = Dottie;\n    root['Dot'] = Dottie; //BC\n\n    if (typeof define === \"function\") {\n      define([], function () { return Dottie; });\n    }\n  }\n})();\n", "var expect = require('chai').expect\n  , dottie = require('../dottie');\n\ndescribe(\"dottie.set\", function () {\n  var data = {\n    'foo': {\n      'bar': 'baa'\n    }\n  };\n\n  it(\"should set nested values on existing structure\", function () {\n    dottie.set(data, 'foo.bar', 'baz');\n    expect(data.foo.bar).to.equal('baz');\n  });\n\n  it(\"should create nested structure if not existing\", function () {\n    dottie.set(data, 'level1.level2', 'foo');\n    expect(data.level1.level2).to.equal('foo');\n    expect(typeof data.level1).to.equal('object');\n  });\n\n  it(\"should handle setting a nested value on an undefined value (should convert undefined to object)\", function () {\n    var data = {\n      'values': undefined\n    };\n\n    dottie.set(data, 'values.level1', 'foo');\n    expect(data.values.level1).to.equal('foo');\n  });\n\n  it(\"should throw when overwriting a nested null value with force: false\", function () {\n    var data = {\n      'values': null\n    };\n\n\n    expect(function () {\n      dottie.set(data, 'values.level1', 'foo');\n    }).to.throw();\n  });\n\n  it(\"should handle setting a nested value on an null value (should convert null to object) with force: true\", function () {\n    var data = {\n      'values': null\n    };\n\n    dottie.set(data, 'values.level1', 'foo', { force: true });\n    expect(data.values.level1).to.equal('foo');\n  });\n\n  it('should be able to set with an array path', function () {\n    dottie.set(data, ['some.dot.containing', 'value'], 'razzamataz');\n    expect(data['some.dot.containing'].value).to.equal('razzamataz');\n  });\n\n  it(\"should throw error when setting a nested value on an existing key with a non-object value\", function () {\n    expect(function () {\n      dottie.set(data, 'foo.bar.baz', 'someValue');\n    }).to.throw();\n  });\n\n  it('should overwrite a nested non-object value on force: true', function () {\n    dottie.set(data, 'foo.bar.baz', 'someValue', {\n      force: true\n    });\n    expect(data.foo.bar.baz).to.equal('someValue');\n  });\n});", "var expect = require('chai').expect\n  , dottie = require('../dottie');\n\n/* If people modify the array prototype Dottie should not be affected */\nArray.prototype.getByName = function(name) {\n    for (var i = 0, len = this.length; i < len; i++) {\n        if (typeof this[i] != \"object\") continue;\n        if (this[i].name === name) return this[i];\n\n    }\n};\nArray.prototype.getByType = function(type) {\n    var newvalues = [];\n    for (var i = 0, len = this.length; i < len; i++) {\n        if (typeof this[i] != \"object\") continue;\n        if (this[i].type === type) newvalues.push(this[i]);\n    }\n    if (newvalues.length <= 0) newvalues = undefined;\n    return newvalues;\n};\n\ndescribe(\"dottie.transform\", function () {\n  it(\"should create a properly nested object from a basic dottie notated set of keys\", function () {\n    var values = {\n      'user.name': 'John Doe',\n      'user.email': 'jd@foobar.com',\n      'user.location.country': 'Zanzibar',\n      'user.location.city': 'Zanzibar City'\n    };\n\n    var transformed = dottie.transform(values);\n\n    expect(transformed.user).not.to.equal(undefined);\n    expect(transformed.user.location).not.to.equal(undefined);\n\n    expect(transformed.user).to.be.an('object');\n    expect(transformed.user.location).to.be.an('object');\n\n    expect(transformed.user.email).to.equal('jd@foobar.com');\n    expect(transformed.user.location.city).to.equal('Zanzibar City');\n  });\n\n  it(\"should be able to handle a mixture of nested properties and dottie notated set of keys\", function () {\n    var values = {\n      user: {\n        name: 'John Doe'\n      },\n      'user.email': 'jd@foobar.com',\n      'user.location.country': 'Zanzibar',\n      'user.location.city': 'Zanzibar City',\n      'project.title': 'dottie'\n    };\n\n    var transformed = dottie.transform(values);\n\n    expect(transformed.user).not.to.equal(undefined);\n    expect(transformed.user.location).not.to.equal(undefined);\n    expect(transformed.project).not.to.equal(undefined);\n\n    expect(transformed.user).to.be.an('object');\n    expect(transformed.user.location).to.be.an('object');\n    expect(transformed.project).to.be.an('object');\n\n    expect(transformed.user.email).to.equal('jd@foobar.com');\n    expect(transformed.user.location.city).to.equal('Zanzibar City');\n    expect(transformed.project.title).to.equal('dottie');\n  });\n\n  it(\"should be able to handle base level properties together with nested\", function () {\n    var values = {\n      'customer.name': 'John Doe',\n      'customer.age': 15,\n      'client': 'Lolcat'\n    };\n\n    var transformed = dottie.transform(values);\n\n    expect(transformed.client).not.to.equal(undefined);\n    expect(transformed.hasOwnProperty('client')).to.be.true; // Ensure that the property is actually on the object itself, not on the prototype.\n    expect(transformed.customer).not.to.equal(undefined);\n\n    expect(transformed.customer).to.be.an('object');\n\n    expect(transformed.client).to.equal('Lolcat');\n    expect(transformed.customer.name).to.equal('John Doe');\n    expect(transformed.customer.age).to.equal(15);\n  });\n\n  it(\"should be able to handle null valued properties, not assigning nested level objects\", function() {\n    var values = {\n      'section.id': 20,\n      'section.layout': null,\n      'section.layout.id': null,\n      'section.layout.name': null\n    };\n\n    var transformed = dottie.transform(values);\n\n    expect(transformed.section.layout).to.equal(null);\n    expect(transformed['section.layout.id']).to.equal(undefined);\n    expect(transformed['section.layout.name']).to.equal(undefined);\n  });\n\n  it(\"supports arrays\", function () {\n    var values = [\n      {\n        'customer.name': 'John Doe',\n        'customer.age': 15,\n        'client': 'Lolcat'\n      },\n      {\n        'client.name': 'John Doe',\n        'client.age': 15,\n        'customer': 'Lolcat'\n      }\n    ];\n\n    var transformed = dottie.transform(values);\n    expect(transformed[0].customer.name).to.equal('John Doe');\n    expect(transformed[1].client.name).to.equal('John Doe');\n  });\n\n  it(\"supports custom delimiters\", function () {\n    var values = {\n      user: {\n        name: 'John Doe'\n      },\n      'user_email': 'jd@foobar.com',\n      'user_location_country': 'Zanzibar',\n      'user_location_city': 'Zanzibar City',\n      'project_title': 'dottie'\n    };\n\n    var transformed = dottie.transform(values, { delimiter: '_' });\n\n    expect(transformed.user).not.to.equal(undefined);\n    expect(transformed.user.location).not.to.equal(undefined);\n    expect(transformed.project).not.to.equal(undefined);\n\n    expect(transformed.user).to.be.an('object');\n    expect(transformed.user.location).to.be.an('object');\n    expect(transformed.project).to.be.an('object');\n\n    expect(transformed.user.email).to.equal('jd@foobar.com');\n    expect(transformed.user.location.city).to.equal('Zanzibar City');\n    expect(transformed.project.title).to.equal('dottie');\n  });\n});\n"], "fixing_code": ["[![Build Status](https://travis-ci.org/mickhansen/dottie.js.svg?branch=master)](https://travis-ci.org/mickhansen/dottie.js)\n\nDottie helps you easily (and without sacrificing too much performance) look up and play with nested keys in objects, without them throwing up in your face.\n\n## Install\n    npm install dottie\n\n## Usage\nFor detailed usage, check source or tests.\n\n### Get value\nGets nested value, or undefined if unreachable, or a default value if passed.\n\n```js\nvar values = {\n  some: {\n    nested: {\n        key: 'foobar';\n    }\n  },\n  'some.dot.included': {\n    key: 'barfoo'\n  }\n}\n\ndottie.get(values, 'some.nested.key'); // returns 'foobar'\ndottie.get(values, 'some.undefined.key'); // returns undefined\ndottie.get(values, 'some.undefined.key', 'defaultval'); // returns 'defaultval'\ndottie.get(values, ['some.dot.included', 'key']); // returns 'barfoo'\n```\n\n*Note: lodash.get() also works fine for this* \n\n### Set value\n\nSets nested value, creates nested structure if needed\n\n```js\ndottie.set(values, 'some.nested.value', someValue);\ndottie.set(values, ['some.dot.included', 'value'], someValue);\ndottie.set(values, 'some.nested.object', someValue, {\n  force: true // force overwrite defined non-object keys into objects if needed\n});\n```\n\nIf you accept arbitrary/user-defined paths to `set` you should call `Object.preventExtensions(values)` first to guard against potential pollution.\n\n### Transform object\nTransform object from keys with dottie notation to nested objects\n\n```js\nvar values = {\n  'user.name': 'Gummy Bear',\n  'user.email': 'gummybear@candymountain.com',\n  'user.professional.title': 'King',\n  'user.professional.employer': 'Candy Mountain'\n};\nvar transformed = dottie.transform(values);\n\n/*\n{\n  user: {\n    name: 'Gummy Bear',\n    email: 'gummybear@candymountain.com',\n    professional: {\n      title: 'King',\n      employer: 'Candy Mountain'\n    }\n  }\n}\n*/\n```\n\n#### With a custom delimiter\n\n```js\nvar values = {\n  'user_name': 'Mick Hansen',\n  'user_email': 'maker@mhansen.io'\n};\nvar transformed = dottie.transform(values, { delimiter: '_' });\n\n/*\n{\n  user: {\n    name: 'Mick Hansen',\n    email: 'maker@mhansen.io'\n  }\n}\n*/\n```\n\n### Get paths in object\n```js\nvar object = {\n  a: 1,\n  b: {\n    c: 2,\n    d: { e: 3 }\n  }\n};\n\ndottie.paths(object); // [\"a\", \"b.c\", \"b.d.e\"];\n```\n\n## Performance\n\n`0.3.1` and up ships with `dottie.memoizePath: true` by default, if this causes any bugs, please try setting it to false\n\n## License\n\n[MIT](https://github.com/mickhansen/dottie.js/blob/master/LICENSE)\n", "(function(undefined) {\n  var root = this;\n\n  // Weird IE shit, objects do not have hasOwn, but the prototype does...\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var reverseDupArray = function (array) {\n    var result = new Array(array.length);\n    var index  = array.length;\n    var arrayMaxIndex = index - 1;\n\n    while (index--) {\n      result[arrayMaxIndex - index] = array[index];\n    }\n\n    return result;\n  };\n\n  var Dottie = function() {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length == 2) {\n      return Dottie.find.apply(this, args);\n    }\n    return Dottie.transform.apply(this, args);\n  };\n\n  // Legacy syntax, changed syntax to have get/set be similar in arg order\n  Dottie.find = function(path, object) {\n    return Dottie.get(object, path);\n  };\n\n  // Dottie memoization flag\n  Dottie.memoizePath = true;\n  var memoized = {};\n\n  // Traverse object according to path, return value if found - Return undefined if destination is unreachable\n  Dottie.get = function(object, path, defaultVal) {\n    if ((object === undefined) || (object === null) || (path === undefined) || (path === null)) {\n        return defaultVal;\n    }\n\n    var names;\n\n    if (typeof path === \"string\") {\n      if (Dottie.memoizePath) {\n        if (memoized[path]) {\n          names = memoized[path].slice(0);\n        } else {\n          names = path.split('.').reverse();\n          memoized[path] = names.slice(0);\n        }\n      } else {\n        names = path.split('.').reverse();\n      }\n    } else if (Array.isArray(path)) {\n      names = reverseDupArray(path);\n    }\n\n    while (names.length && (object = object[names.pop()]) !== undefined && object !== null);\n\n    // Handle cases where accessing a childprop of a null value\n    if (object === null && names.length) object = undefined;\n\n    return (object === undefined ? defaultVal : object);\n  };\n\n  Dottie.exists = function(object, path) {\n    return Dottie.get(object, path) !== undefined;\n  };\n\n  // Set nested value\n  Dottie.set = function(object, path, value, options) {\n    var pieces = Array.isArray(path) ? path : path.split('.'), current = object, piece, length = pieces.length;\n    if (pieces[0] === '__proto__') return;\n\n    if (typeof current !== 'object') {\n        throw new Error('Parent is not an object.');\n    }\n\n    for (var index = 0; index < length; index++) {\n      piece = pieces[index];\n\n      // Create namespace (object) where none exists.\n      // If `force === true`, bruteforce the path without throwing errors.\n      if (\n        !hasOwnProp.call(current, piece)\n        || current[piece] === undefined\n        || ((typeof current[piece] !== 'object' || current[piece] === null) && options && options.force === true)) {\n        current[piece] = {};\n      }\n\n      if (index == (length - 1)) {\n        // Set final value\n        current[piece] = value;\n      } else {\n        // We do not overwrite existing path pieces by default\n        if (typeof current[piece] !== 'object' || current[piece] === null) {\n          throw new Error('Target key \"' + piece + '\" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');\n        }\n\n        // Traverse next in path\n        current = current[piece];\n      }\n    }\n\n    // Is there any case when this is relevant? It's also the last line in the above for-loop\n    current[piece] = value;\n  };\n\n  // Set default nested value\n  Dottie['default'] = function(object, path, value) {\n    if (Dottie.get(object, path) === undefined) {\n      Dottie.set(object, path, value);\n    }\n  };\n\n  // Transform unnested object with .-seperated keys into a nested object.\n  Dottie.transform = function Dottie$transformfunction(object, options) {\n    if (Array.isArray(object)) {\n      return object.map(function(o) {\n        return Dottie.transform(o, options);\n      });\n    }\n\n    options = options || {};\n    options.delimiter = options.delimiter || '.';\n\n    var pieces\n      , piecesLength\n      , piece\n      , current\n      , transformed = {}\n      , key\n      , keys = Object.keys(object)\n      , length = keys.length\n      , i;\n\n    for (i = 0; i < length; i++) {\n      key = keys[i];\n\n      if (key.indexOf(options.delimiter) !== -1) {\n        pieces = key.split(options.delimiter);\n\n        if (pieces[0] === '__proto__') break;\n\n        piecesLength = pieces.length;\n        current = transformed;\n\n        for (var index = 0; index < piecesLength; index++) {\n          piece = pieces[index];\n          if (index != (piecesLength - 1) && !current.hasOwnProperty(piece)) {\n            current[piece] = {};\n          }\n\n          if (index == (piecesLength - 1)) {\n            current[piece] = object[key];\n          }\n\n          current = current[piece];\n          if (current === null) {\n            break;\n          }\n        }\n      } else {\n        transformed[key] = object[key];\n      }\n    }\n\n    return transformed;\n  };\n\n  Dottie.flatten = function(object, seperator) {\n    if (typeof seperator === \"undefined\") seperator = '.';\n    var flattened = {}\n      , current\n      , nested;\n\n    for (var key in object) {\n      if (hasOwnProp.call(object, key)) {\n        current = object[key];\n        if (Object.prototype.toString.call(current) === \"[object Object]\") {\n          nested = Dottie.flatten(current, seperator);\n\n          for (var _key in nested) {\n            flattened[key+seperator+_key] = nested[_key];\n          }\n        } else {\n          flattened[key] = current;\n        }\n      }\n    }\n\n    return flattened;\n  };\n\n  Dottie.paths = function(object, prefixes) {\n    var paths = [];\n    var value;\n    var key;\n\n    prefixes = prefixes || [];\n\n    if (typeof object === 'object') {\n      for (key in object) {\n        value = object[key];\n\n        if (typeof value === 'object' && value !== null) {\n          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));\n        } else {\n          paths.push(prefixes.concat(key).join('.'));\n        }\n      }\n    } else {\n      throw new Error('Paths was called with non-object argument.');\n    }\n\n    return paths;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = Dottie;\n  } else {\n    root['Dottie'] = Dottie;\n    root['Dot'] = Dottie; //BC\n\n    if (typeof define === \"function\") {\n      define([], function () { return Dottie; });\n    }\n  }\n})();\n", "var expect = require('chai').expect\n  , dottie = require('../dottie');\n\ndescribe(\"dottie.set\", function () {\n  var data = {\n    'foo': {\n      'bar': 'baa'\n    }\n  };\n\n  it(\"should set nested values on existing structure\", function () {\n    dottie.set(data, 'foo.bar', 'baz');\n    expect(data.foo.bar).to.equal('baz');\n  });\n\n  it(\"should create nested structure if not existing\", function () {\n    dottie.set(data, 'level1.level2', 'foo');\n    expect(data.level1.level2).to.equal('foo');\n    expect(typeof data.level1).to.equal('object');\n  });\n\n  it(\"should handle setting a nested value on an undefined value (should convert undefined to object)\", function () {\n    var data = {\n      'values': undefined\n    };\n\n    dottie.set(data, 'values.level1', 'foo');\n    expect(data.values.level1).to.equal('foo');\n  });\n\n  it(\"should throw when overwriting a nested null value with force: false\", function () {\n    var data = {\n      'values': null\n    };\n\n\n    expect(function () {\n      dottie.set(data, 'values.level1', 'foo');\n    }).to.throw();\n  });\n\n  it(\"should handle setting a nested value on an null value (should convert null to object) with force: true\", function () {\n    var data = {\n      'values': null\n    };\n\n    dottie.set(data, 'values.level1', 'foo', { force: true });\n    expect(data.values.level1).to.equal('foo');\n  });\n\n  it('should be able to set with an array path', function () {\n    dottie.set(data, ['some.dot.containing', 'value'], 'razzamataz');\n    expect(data['some.dot.containing'].value).to.equal('razzamataz');\n  });\n\n  it(\"should throw error when setting a nested value on an existing key with a non-object value\", function () {\n    expect(function () {\n      dottie.set(data, 'foo.bar.baz', 'someValue');\n    }).to.throw();\n  });\n\n  it('should overwrite a nested non-object value on force: true', function () {\n    dottie.set(data, 'foo.bar.baz', 'someValue', {\n      force: true\n    });\n    expect(data.foo.bar.baz).to.equal('someValue');\n  });\n\n  it('should not attempt to set __proto__', function () {\n    var data = {};\n\n    dottie.set(data, '__proto__.pollution', 'polluted');\n\n    expect(data.__proto__.pollution).to.be.undefined;\n  });\n});", "var expect = require('chai').expect\n  , dottie = require('../dottie');\n\n/* If people modify the array prototype Dottie should not be affected */\nArray.prototype.getByName = function(name) {\n    for (var i = 0, len = this.length; i < len; i++) {\n        if (typeof this[i] != \"object\") continue;\n        if (this[i].name === name) return this[i];\n\n    }\n};\nArray.prototype.getByType = function(type) {\n    var newvalues = [];\n    for (var i = 0, len = this.length; i < len; i++) {\n        if (typeof this[i] != \"object\") continue;\n        if (this[i].type === type) newvalues.push(this[i]);\n    }\n    if (newvalues.length <= 0) newvalues = undefined;\n    return newvalues;\n};\n\ndescribe(\"dottie.transform\", function () {\n  it(\"should create a properly nested object from a basic dottie notated set of keys\", function () {\n    var values = {\n      'user.name': 'John Doe',\n      'user.email': 'jd@foobar.com',\n      'user.location.country': 'Zanzibar',\n      'user.location.city': 'Zanzibar City'\n    };\n\n    var transformed = dottie.transform(values);\n\n    expect(transformed.user).not.to.equal(undefined);\n    expect(transformed.user.location).not.to.equal(undefined);\n\n    expect(transformed.user).to.be.an('object');\n    expect(transformed.user.location).to.be.an('object');\n\n    expect(transformed.user.email).to.equal('jd@foobar.com');\n    expect(transformed.user.location.city).to.equal('Zanzibar City');\n  });\n\n  it(\"should be able to handle a mixture of nested properties and dottie notated set of keys\", function () {\n    var values = {\n      user: {\n        name: 'John Doe'\n      },\n      'user.email': 'jd@foobar.com',\n      'user.location.country': 'Zanzibar',\n      'user.location.city': 'Zanzibar City',\n      'project.title': 'dottie'\n    };\n\n    var transformed = dottie.transform(values);\n\n    expect(transformed.user).not.to.equal(undefined);\n    expect(transformed.user.location).not.to.equal(undefined);\n    expect(transformed.project).not.to.equal(undefined);\n\n    expect(transformed.user).to.be.an('object');\n    expect(transformed.user.location).to.be.an('object');\n    expect(transformed.project).to.be.an('object');\n\n    expect(transformed.user.email).to.equal('jd@foobar.com');\n    expect(transformed.user.location.city).to.equal('Zanzibar City');\n    expect(transformed.project.title).to.equal('dottie');\n  });\n\n  it(\"should be able to handle base level properties together with nested\", function () {\n    var values = {\n      'customer.name': 'John Doe',\n      'customer.age': 15,\n      'client': 'Lolcat'\n    };\n\n    var transformed = dottie.transform(values);\n\n    expect(transformed.client).not.to.equal(undefined);\n    expect(transformed.hasOwnProperty('client')).to.be.true; // Ensure that the property is actually on the object itself, not on the prototype.\n    expect(transformed.customer).not.to.equal(undefined);\n\n    expect(transformed.customer).to.be.an('object');\n\n    expect(transformed.client).to.equal('Lolcat');\n    expect(transformed.customer.name).to.equal('John Doe');\n    expect(transformed.customer.age).to.equal(15);\n  });\n\n  it(\"should be able to handle null valued properties, not assigning nested level objects\", function() {\n    var values = {\n      'section.id': 20,\n      'section.layout': null,\n      'section.layout.id': null,\n      'section.layout.name': null\n    };\n\n    var transformed = dottie.transform(values);\n\n    expect(transformed.section.layout).to.equal(null);\n    expect(transformed['section.layout.id']).to.equal(undefined);\n    expect(transformed['section.layout.name']).to.equal(undefined);\n  });\n\n  it(\"supports arrays\", function () {\n    var values = [\n      {\n        'customer.name': 'John Doe',\n        'customer.age': 15,\n        'client': 'Lolcat'\n      },\n      {\n        'client.name': 'John Doe',\n        'client.age': 15,\n        'customer': 'Lolcat'\n      }\n    ];\n\n    var transformed = dottie.transform(values);\n    expect(transformed[0].customer.name).to.equal('John Doe');\n    expect(transformed[1].client.name).to.equal('John Doe');\n  });\n\n  it(\"supports custom delimiters\", function () {\n    var values = {\n      user: {\n        name: 'John Doe'\n      },\n      'user_email': 'jd@foobar.com',\n      'user_location_country': 'Zanzibar',\n      'user_location_city': 'Zanzibar City',\n      'project_title': 'dottie'\n    };\n\n    var transformed = dottie.transform(values, { delimiter: '_' });\n\n    expect(transformed.user).not.to.equal(undefined);\n    expect(transformed.user.location).not.to.equal(undefined);\n    expect(transformed.project).not.to.equal(undefined);\n\n    expect(transformed.user).to.be.an('object');\n    expect(transformed.user.location).to.be.an('object');\n    expect(transformed.project).to.be.an('object');\n\n    expect(transformed.user.email).to.equal('jd@foobar.com');\n    expect(transformed.user.location.city).to.equal('Zanzibar City');\n    expect(transformed.project.title).to.equal('dottie');\n  });\n\n  it(\"should guard against prototype pollution\", function () {\n    var values = {\n      'user.name': 'John Doe',\n      '__proto__.pollution': 'pollution'\n    };\n\n    var transformed = dottie.transform(values);\n    expect(transformed.user).not.to.equal(undefined);\n    expect(transformed.user.name).to.equal('John Doe');\n    expect(transformed.__proto__.pollution).to.be.undefined;\n  });\n});\n"], "filenames": ["README.md", "dottie.js", "test/set.test.js", "test/transform.test.js"], "buggy_code_start_loc": [34, 74, 67, 147], "buggy_code_end_loc": [43, 142, 67, 147], "fixing_code_start_loc": [35, 75, 68, 148], "fixing_code_end_loc": [47, 147, 76, 160], "type": "CWE-1321", "message": "Versions of the package dottie before 2.0.4 are vulnerable to Prototype Pollution due to insufficient checks, via the set() function and the current variable in the /dottie.js file.", "other": {"cve": {"id": "CVE-2023-26132", "sourceIdentifier": "report@snyk.io", "published": "2023-06-10T05:15:08.970", "lastModified": "2023-11-07T04:09:25.510", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Versions of the package dottie before 2.0.4 are vulnerable to Prototype Pollution due to insufficient checks, via the set() function and the current variable in the /dottie.js file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dottie_project:dottie:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.4", "matchCriteriaId": "FCDBDD66-72B2-4F5B-9730-F9132E9FC2D7"}]}]}], "references": [{"url": "https://github.com/mickhansen/dottie.js/blob/b48e22714aae4489ea6276452f22cc61980ba5a4/dottie.js%23L107", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/mickhansen/dottie.js/commit/7d3aee1c9c3c842720506e131de7e181e5c8db68", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-DOTTIE-3332763", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mickhansen/dottie.js/commit/7d3aee1c9c3c842720506e131de7e181e5c8db68"}}