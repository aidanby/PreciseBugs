{"buggy_code": ["#ifndef __L2TP_PROT_H\n#define __L2TP_PROT_H\n\n#include <stdint.h>\n\n#define L2TP_PORT 1701\n\nstruct l2tp_hdr_t\n{\n\tuint8_t P:1;\n\tuint8_t O:1;\n\tuint8_t reserved2:1;\n\tuint8_t S:1;\n\tuint8_t reserved1:2;\n\tuint8_t L:1;\n\tuint8_t T:1;\n\tuint8_t ver:4;\n\tuint8_t reserved3:4;\n\tuint16_t length;\n\tunion {\n\t\tstruct {\n\t\t\tuint16_t tid;\n\t\t\tuint16_t sid;\n\t\t};\n\t\tuint32_t cid;\n\t};\n\tuint16_t Ns;\n\tuint16_t Nr;\n} __attribute__((packed));\n\n/*#define L2TP_T(hdr) (hdr->flags >> 15)\n#define L2TP_L(hdr) ((hdr->flags >> 14) & 1)\n#define L2TP_S(hdr) ((hdr->flags >> 10) & 1)\n#define L2TP_O(hdr) ((hdr->flags >> 8) & 1)\n#define L2TP_VER(hdr) (hdr->flags & 0xf)*/\n\nstruct l2tp_avp_t\n{\n\tuint16_t length:10;\n\tuint16_t reserved:4;\n\tuint16_t H:1;\n\tuint16_t M:1;\n\tuint16_t vendor;\n\tuint16_t type;\n\tuint8_t val[0];\n} __attribute__((packed));\n\nstruct l2tp_avp_result_code\n{\n\tuint16_t result_code;\n\tuint16_t error_code;\n\tchar error_msg[0];\n} __attribute__((packed));\n\n#endif\n\n", "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <endian.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <arpa/inet.h>\n\n#include \"crypto.h\"\n#include \"triton.h\"\n#include \"log.h\"\n#include \"mempool.h\"\n#include \"memdebug.h\"\n#include \"utils.h\"\n\n#include \"l2tp.h\"\n#include \"attr_defs.h\"\n\nstatic mempool_t attr_pool;\nstatic mempool_t pack_pool;\nstatic mempool_t buf_pool;\n\nvoid l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\n\tif (pack->hdr.ver == 2) {\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t} else {\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t}\n\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\n\tprint(\"]\\n\");\n}\n\nstruct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pack;\n}\n\nvoid l2tp_packet_free(struct l2tp_packet_t *pack)\n{\n\tstruct l2tp_attr_t *attr;\n\n\twhile (!list_empty(&pack->attrs)) {\n\t\tattr = list_entry(pack->attrs.next, typeof(*attr), entry);\n\t\tif (attr->H || attr->attr->type == ATTR_TYPE_OCTETS\n\t\t    || attr->attr->type == ATTR_TYPE_STRING)\n\t\t\t_free(attr->val.octets);\n\t\tlist_del(&attr->entry);\n\t\tmempool_free(attr);\n\t}\n\n\tmempool_free(pack);\n}\n\nstatic void memxor(uint8_t *dst, const uint8_t *src, size_t sz)\n{\n\tconst uintmax_t *umax_src = (const uintmax_t *)src;\n\tuintmax_t *umax_dst = (uintmax_t *)dst;\n\tsize_t left = sz % sizeof(uintmax_t);\n\tsize_t indx;\n\n\tfor (indx = 0; indx < sz / sizeof(uintmax_t); ++indx)\n\t\tumax_dst[indx] ^= umax_src[indx];\n\n\tsrc += sz - left;\n\tdst += sz - left;\n\twhile (left) {\n\t\tif (left >= sizeof(uint32_t)) {\n\t\t\t*(uint32_t *)dst ^= *(uint32_t *)src;\n\t\t\tsrc += sizeof(uint32_t);\n\t\t\tdst += sizeof(uint32_t);\n\t\t\tleft -= sizeof(uint32_t);\n\t\t} else if (left >= sizeof(uint16_t)) {\n\t\t\t*(uint16_t *)dst ^= *(uint16_t *)src;\n\t\t\tsrc += sizeof(uint16_t);\n\t\t\tdst += sizeof(uint16_t);\n\t\t\tleft -= sizeof(uint16_t);\n\t\t} else {\n\t\t\t*dst ^= *src;\n\t\t\tsrc += sizeof(uint8_t);\n\t\t\tdst += sizeof(uint8_t);\n\t\t\tleft -= sizeof(uint8_t);\n\t\t}\n\t}\n}\n\n/*\n * Decipher hidden AVPs, keeping the Hidden AVP Subformat (i.e. the attribute\n * value is prefixed by 2 bytes indicating its length in network byte order).\n */\nstatic int decode_avp(struct l2tp_avp_t *avp, const struct l2tp_attr_t *RV,\n\t\t      const char *secret, size_t secret_len)\n{\n\tMD5_CTX md5_ctx;\n\tuint8_t md5[MD5_DIGEST_LENGTH];\n\tuint8_t p1[MD5_DIGEST_LENGTH];\n\tuint8_t *prev_block = NULL;\n\tuint16_t attr_len;\n\tuint16_t orig_attr_len;\n\tuint16_t bytes_left;\n\tuint16_t blocks_left;\n\tuint16_t last_block_len;\n\n\tif (avp->length < sizeof(struct l2tp_avp_t) + 2) {\n\t\t/* Hidden AVPs must contain at least two bytes\n\t\t   for storing original attribute length */\n\t\tlog_warn(\"l2tp: incorrect hidden avp received (type %hu):\"\n\t\t\t \" length too small (%hu bytes)\\n\",\n\t\t\t ntohs(avp->type), avp->length);\n\t\treturn -1;\n\t}\n\tattr_len = avp->length - sizeof(struct l2tp_avp_t);\n\n\t/* Decode first block */\n\tMD5_Init(&md5_ctx);\n\tMD5_Update(&md5_ctx, &avp->type, sizeof(avp->type));\n\tMD5_Update(&md5_ctx, secret, secret_len);\n\tMD5_Update(&md5_ctx, RV->val.octets, RV->length);\n\tMD5_Final(p1, &md5_ctx);\n\n\tif (attr_len <= MD5_DIGEST_LENGTH) {\n\t\tmemxor(avp->val, p1, attr_len);\n\t\treturn 0;\n\t}\n\n\tmemxor(p1, avp->val, MD5_DIGEST_LENGTH);\n\torig_attr_len = ntohs(*(uint16_t *)p1);\n\n\tif (orig_attr_len <= MD5_DIGEST_LENGTH - 2) {\n\t\t/* Enough bytes decoded already, no need to decode padding */\n\t\tmemcpy(avp->val, p1, MD5_DIGEST_LENGTH);\n\t\treturn 0;\n\t}\n\n\tif (orig_attr_len > attr_len - 2) {\n\t\tlog_warn(\"l2tp: incorrect hidden avp received (type %hu):\"\n\t\t\t \" original attribute length too big (ciphered\"\n\t\t\t \" attribute length: %hu bytes, advertised original\"\n\t\t\t \" attribute length: %hu bytes)\\n\",\n\t\t\t ntohs(avp->type), attr_len, orig_attr_len);\n\t\treturn -1;\n\t}\n\n\t/* Decode remaining blocks. Start from the last block as\n\t   preceding blocks must be kept hidden for computing MD5s */\n\tbytes_left = orig_attr_len + 2 - MD5_DIGEST_LENGTH;\n\tlast_block_len = bytes_left % MD5_DIGEST_LENGTH;\n\tblocks_left = bytes_left / MD5_DIGEST_LENGTH;\n\tif (last_block_len) {\n\t\tprev_block = avp->val + blocks_left * MD5_DIGEST_LENGTH;\n\t\tMD5_Init(&md5_ctx);\n\t\tMD5_Update(&md5_ctx, secret, secret_len);\n\t\tMD5_Update(&md5_ctx, prev_block, MD5_DIGEST_LENGTH);\n\t\tMD5_Final(md5, &md5_ctx);\n\t\tmemxor(prev_block + MD5_DIGEST_LENGTH, md5, last_block_len);\n\t\tprev_block -= MD5_DIGEST_LENGTH;\n\t} else\n\t\tprev_block = avp->val + (blocks_left - 1) * MD5_DIGEST_LENGTH;\n\n\twhile (prev_block >= avp->val) {\n\t\tMD5_Init(&md5_ctx);\n\t\tMD5_Update(&md5_ctx, secret, secret_len);\n\t\tMD5_Update(&md5_ctx, prev_block, MD5_DIGEST_LENGTH);\n\t\tMD5_Final(md5, &md5_ctx);\n\t\tmemxor(prev_block + MD5_DIGEST_LENGTH, md5, MD5_DIGEST_LENGTH);\n\t\tprev_block -= MD5_DIGEST_LENGTH;\n\t}\n\tmemcpy(avp->val, p1, MD5_DIGEST_LENGTH);\n\n\treturn 0;\n}\n\nint l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n\t      const char *secret, size_t secret_len)\n{\n\tint n, length;\n\tuint8_t *buf;\n\tstruct l2tp_hdr_t *hdr;\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_dict_attr_t *da;\n\tstruct l2tp_attr_t *attr, *RV = NULL;\n\tuint8_t *ptr;\n\tstruct l2tp_packet_t *pack;\n\tstruct sockaddr_in addr;\n\tsocklen_t len = sizeof(addr);\n\tstruct msghdr msg;\n\tchar msg_control[128];\n\tstruct cmsghdr *cmsg;\n\tuint16_t orig_avp_len;\n\tvoid *orig_avp_val;\n\n  *p = NULL;\n\n\tif (pkt_info) {\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.msg_control = msg_control;\n\t\tmsg.msg_controllen = 128;\n\n\t\tn = recvmsg(fd, &msg, MSG_PEEK);\n\n\t\tif (n < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn -1;\n\t\t\tlog_error(\"l2tp: recvmsg: %s\\n\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tif (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_PKTINFO) {\n\t\t\t\tmemcpy(pkt_info, CMSG_DATA(cmsg), sizeof(*pkt_info));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuf = mempool_alloc(buf_pool);\n\tif (!buf) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn 0;\n\t}\n\thdr = (struct l2tp_hdr_t *)buf;\n\tptr = (uint8_t *)(hdr + 1);\n\n\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &len);\n\n\tif (n < 0) {\n\t\tmempool_free(buf);\n\t\tif (errno == EAGAIN) {\n\t\t\treturn -1;\n\t\t} else if (errno == ECONNREFUSED) {\n\t\t\treturn -2;\n\t\t}\n\t\tlog_error(\"l2tp: recv: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tif (n < 6) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", n, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t}\n\n\tif (hdr->T == 0)\n\t\tgoto out_err_hdr;\n\n\tif (n < ntohs(hdr->length)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%i)\\n\", n, ntohs(hdr->length));\n\t\tgoto out_err_hdr;\n\t}\n\n\tif (hdr->ver == 2) {\n\t\tif (hdr->L == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (L=0)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\n\t\tif (hdr->S == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (S=0)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\n\t\tif (hdr->O == 1) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (O=1)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\t} else if (hdr->ver != 3) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\", hdr->ver);\n\t\tgoto out_err_hdr;\n\t}\n\n\tpack = mempool_alloc(pack_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\tmemcpy(&pack->addr, &addr, sizeof(addr));\n\tmemcpy(&pack->hdr, hdr, sizeof(*hdr));\n\tlength = ntohs(hdr->length) - sizeof(*hdr);\n\n\twhile (length) {\n\t\t*(uint16_t *)ptr = ntohs(*(uint16_t *)ptr);\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\n\t\tif (avp->length > length) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (avp->vendor)\n\t\t\tgoto skip;\n\n\t\tda = l2tp_dict_find_attr_by_id(ntohs(avp->type));\n\t\tif (!da) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\", ntohs(avp->type), avp->M);\n\t\t\tif (avp->M && !conf_avp_permissive)\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\tif (da->M != -1 && da->M != avp->M) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\", ntohs(avp->type), avp->M, da->M);\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (da->H != -1 && da->H != avp->H) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\", ntohs(avp->type), avp->H, da->H);\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (avp->H) {\n\t\t\t\tif (!RV) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (secret == NULL || secret_len == 0) {\n\t\t\t\t\tlog_error(\"l2tp: impossible to decode\"\n\t\t\t\t\t\t  \" hidden avp (type %hu): no\"\n\t\t\t\t\t\t  \" secret set)\\n\",\n\t\t\t\t\t\t  ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (decode_avp(avp, RV, secret, secret_len) < 0)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\t\t\tif (avp->H) {\n\t\t\t\torig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);\n\t\t\t\torig_avp_val = avp->val + sizeof(uint16_t);\n\t\t\t} else {\n\t\t\t\torig_avp_len = avp->length;\n\t\t\t\torig_avp_val = avp->val;\n\t\t\t}\n\n\t\t\tattr->attr = da;\n\t\t\tattr->M = avp->M;\n\t\t\tattr->H = 0;\n\t\t\tattr->length = orig_avp_len - sizeof(*avp);\n\n\t\t\tif (attr->attr->id == Random_Vector)\n\t\t\t\tRV = attr;\n\n\t\t\tswitch (da->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 2)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint16 = ntohs(*(uint16_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 4)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint32 = ntohl(*(uint32_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT64:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 8)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint64 = be64toh(*(uint64_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tattr->val.octets = _malloc(attr->length);\n\t\t\t\t\tif (!attr->val.octets)\n\t\t\t\t\t\tgoto out_err_mem;\n\t\t\t\t\tmemcpy(attr->val.octets, orig_avp_val, attr->length);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tattr->val.string = _malloc(attr->length + 1);\n\t\t\t\t\tif (!attr->val.string)\n\t\t\t\t\t\tgoto out_err_mem;\n\t\t\t\t\tmemcpy(attr->val.string, orig_avp_val, attr->length);\n\t\t\t\t\tattr->val.string[attr->length] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nskip:\n\t\tptr += avp->length;\n\t\tlength -= avp->length;\n\t}\n\n\t*p = pack;\n\n\tmempool_free(buf);\n\n\treturn 0;\n\nout_err:\n\tl2tp_packet_free(pack);\nout_err_hdr:\n\tmempool_free(buf);\n\treturn 0;\nout_err_len:\n\tif (conf_verbose)\n\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, incorrect length %i)\\n\", ntohs(avp->type), orig_avp_len);\n\tgoto out_err;\nout_err_mem:\n\tlog_emerg(\"l2tp: out of memory\\n\");\n\tgoto out_err;\n}\n\nint l2tp_packet_send(int sock, struct l2tp_packet_t *pack)\n{\n\tuint8_t *buf = mempool_alloc(buf_pool);\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_attr_t *attr;\n\tuint8_t *ptr;\n\tint n;\n\tint len = sizeof(pack->hdr);\n\n\tif (!buf) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf, 0, L2TP_MAX_PACKET_SIZE);\n\n\tptr = buf + sizeof(pack->hdr);\n\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tif (len + sizeof(*avp) + attr->length >= L2TP_MAX_PACKET_SIZE) {\n\t\t\tlog_error(\"l2tp: cann't send packet (exceeds maximum size)\\n\");\n\t\t\tmempool_free(buf);\n\t\t\treturn -1;\n\t\t}\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\t\tavp->type = htons(attr->attr->id);\n\t\tavp->M = attr->M;\n\t\tavp->H = attr->H;\n\t\tavp->length = sizeof(*avp) + attr->length;\n\t\t*(uint16_t *)ptr = htons(*(uint16_t *)ptr);\n\t\tif (attr->H)\n\t\t\tmemcpy(avp->val, attr->val.octets, attr->length);\n\t\telse\n\t\t\tswitch (attr->attr->type) {\n\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t*(int16_t *)avp->val = htons(attr->val.int16);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t*(int32_t *)avp->val = htonl(attr->val.int32);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_INT64:\n\t\t\t\t*(uint64_t *)avp->val = htobe64(attr->val.uint64);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_STRING:\n\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\tmemcpy(avp->val, attr->val.string, attr->length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tptr += sizeof(*avp) + attr->length;\n\t\tlen += sizeof(*avp) + attr->length;\n\t}\n\n\tpack->hdr.length = htons(len);\n\tmemcpy(buf, &pack->hdr, sizeof(pack->hdr));\n\n\tn = sendto(sock, buf, ntohs(pack->hdr.length), 0,\n\t\t   &pack->addr, sizeof(pack->addr));\n\tmempool_free(buf);\n\n\tif (n < 0) {\n\t\tif (errno == EAGAIN) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: buffer overflow (packet lost)\\n\");\n\t\t} else {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: sendto: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n != ntohs(pack->hdr.length)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short write (%i/%i)\\n\", n, ntohs(pack->hdr.length));\n\t}\n\n\treturn 0;\n}\n\nint encode_attr(const struct l2tp_packet_t *pack, struct l2tp_attr_t *attr,\n\t\tconst void *val, uint16_t val_len)\n{\n\tuint8_t *u8_ptr = NULL;\n\tuint8_t md5[MD5_DIGEST_LENGTH];\n\tMD5_CTX md5_ctx;\n\tuint16_t pad_len;\n\tuint16_t attr_type;\n\tuint16_t blocks_left;\n\tuint16_t last_block_len;\n\tint err;\n\n\tif (pack->secret == NULL || pack->secret_len == 0) {\n\t\tlog_error(\"l2tp: impossible to hide AVP: no secret\\n\");\n\t\tgoto err;\n\t}\n\tif (pack->last_RV == NULL) {\n\t\tlog_error(\"l2tp: impossible to hide AVP: no random vector\\n\");\n\t\tgoto err;\n\t}\n\n\tif (u_randbuf(&pad_len, sizeof(pad_len), &err) < 0) {\n\t\tif (err)\n\t\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t\t  \" reading from urandom failed: %s\\n\",\n\t\t\t\t  strerror(err));\n\t\telse\n\t\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t\t  \" end of file reached while reading\"\n\t\t\t\t  \" from urandom\\n\");\n\t\tgoto err;\n\t}\n\t/* Use at least 16 bytes of padding */\n\tpad_len = (pad_len & 0x007F) + 16;\n\n\t/* Generate Hidden AVP Subformat:\n\t *   -original AVP size (2 bytes, network byte order)\n\t *   -original AVP value ('val_len' bytes)\n\t *   -padding ('pad_len' bytes of random values)\n\t */\n\tattr->length = sizeof(val_len) + val_len + pad_len;\n\tattr->val.octets = _malloc(attr->length);\n\tif (attr->val.octets == NULL) {\n\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t  \" memory allocation failed\\n\");\n\t\tgoto err;\n\t}\n\n\t*(uint16_t *)attr->val.octets = htons(val_len);\n\tmemcpy(attr->val.octets + sizeof(val_len), val, val_len);\n\n\tif (u_randbuf(attr->val.octets + sizeof(val_len) + val_len,\n\t\t      pad_len, &err) < 0) {\n\t\tif (err)\n\t\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t\t  \" reading from urandom failed: %s\\n\",\n\t\t\t\t  strerror(err));\n\t\telse\n\t\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t\t  \" end of file reached while reading\"\n\t\t\t\t  \" from urandom\\n\");\n\t\tgoto err_free;\n\t}\n\n\t/* Hidden AVP cipher:\n\t * ciphered[0] = clear[0] xor MD5(attr_type, secret, RV)\n\t * ciphered[1] = clear[1] xor MD5(secret, ciphered[0])\n\t * ...\n\t * ciphered[n] = clear[n] xor MD5(secret, ciphered[n-1])\n\t */\n\tattr_type = htons(attr->attr->id);\n\tMD5_Init(&md5_ctx);\n\tMD5_Update(&md5_ctx, &attr_type, sizeof(attr_type));\n\tMD5_Update(&md5_ctx, pack->secret, pack->secret_len);\n\tMD5_Update(&md5_ctx, pack->last_RV->val.octets, pack->last_RV->length);\n\tMD5_Final(md5, &md5_ctx);\n\n\tif (attr->length <= MD5_DIGEST_LENGTH) {\n\t\tmemxor(attr->val.octets, md5, attr->length);\n\t\treturn 0;\n\t}\n\n\tmemxor(attr->val.octets, md5, MD5_DIGEST_LENGTH);\n\n\tblocks_left = attr->length / MD5_DIGEST_LENGTH - 1;\n\tlast_block_len = attr->length % MD5_DIGEST_LENGTH;\n\n\tfor (u8_ptr = attr->val.octets; blocks_left; --blocks_left) {\n\t\tMD5_Init(&md5_ctx);\n\t\tMD5_Update(&md5_ctx, pack->secret, pack->secret_len);\n\t\tMD5_Update(&md5_ctx, u8_ptr, MD5_DIGEST_LENGTH);\n\t\tMD5_Final(md5, &md5_ctx);\n\t\tu8_ptr += MD5_DIGEST_LENGTH;\n\t\tmemxor(u8_ptr, md5, MD5_DIGEST_LENGTH);\n\t}\n\n\tif (last_block_len) {\n\t\tMD5_Init(&md5_ctx);\n\t\tMD5_Update(&md5_ctx, pack->secret, pack->secret_len);\n\t\tMD5_Update(&md5_ctx, u8_ptr, MD5_DIGEST_LENGTH);\n\t\tMD5_Final(md5, &md5_ctx);\n\t\tmemxor(u8_ptr + MD5_DIGEST_LENGTH, md5, last_block_len);\n\t}\n\n\treturn 0;\n\nerr_free:\n\t_free(attr->val.octets);\n\tattr->val.octets = NULL;\nerr:\n\treturn -1;\n}\n\nstatic struct l2tp_attr_t *attr_alloc(int id, int M, int H)\n{\n\tstruct l2tp_attr_t *attr;\n\tstruct l2tp_dict_attr_t *da;\n\n\tda = l2tp_dict_find_attr_by_id(id);\n\tif (!da)\n\t\treturn NULL;\n\n\tattr = mempool_alloc(attr_pool);\n\tif (!attr) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(attr, 0, sizeof(*attr));\n\n\tattr->attr = da;\n\n\tif (da->M != -1)\n\t\tattr->M = da->M;\n\telse\n\t\tattr->M = M;\n\n\tif (da->H != -1)\n\t\tattr->H = da->H;\n\telse\n\t\tattr->H = H;\n\n\treturn attr;\n}\n\nstatic int l2tp_packet_add_random_vector(struct l2tp_packet_t *pack)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(Random_Vector, 1, 0);\n\tuint16_t ranvec_len;\n\tint err;\n\n\tif (!attr)\n\t\tgoto err;\n\n\tif (u_randbuf(&ranvec_len, sizeof(ranvec_len), &err) < 0) {\n\t\tif (err)\n\t\t\tlog_error(\"l2tp: impossible to build Random Vector:\"\n\t\t\t\t  \" reading from urandom failed: %s\\n\",\n\t\t\t\t  strerror(err));\n\t\telse\n\t\t\tlog_error(\"l2tp: impossible to build Random Vector:\"\n\t\t\t\t  \" end of file reached while reading\"\n\t\t\t\t  \" from urandom\\n\");\n\t\tgoto err_attr;\n\t}\n\t/* RFC 2661 recommends that Random Vector be least 16 bytes long */\n\tranvec_len = (ranvec_len & 0x007F) + 16;\n\n\tattr->length = ranvec_len;\n\tattr->val.octets = _malloc(ranvec_len);\n\tif (!attr->val.octets) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\tgoto err_attr;\n\t}\n\n\tif (u_randbuf(attr->val.octets, ranvec_len, &err) < 0) {\n\t\tif (err)\n\t\t\tlog_error(\"l2tp: impossible to build Random Vector:\"\n\t\t\t\t  \" reading from urandom failed: %s\\n\",\n\t\t\t\t  strerror(err));\n\t\telse\n\t\t\tlog_error(\"l2tp: impossible to build Random Vector:\"\n\t\t\t\t  \" end of file reached while reading\"\n\t\t\t\t  \" from urandom\\n\");\n\t\tgoto err_attr_val;\n\t}\n\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\tpack->last_RV = attr;\n\n\treturn 0;\n\nerr_attr_val:\n\t_free(attr->val.octets);\nerr_attr:\n\tmempool_free(attr);\nerr:\n\treturn -1;\n}\n\nint l2tp_packet_add_int16(struct l2tp_packet_t *pack, int id, int16_t val, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tval = htons(val);\n\t\tif (encode_attr(pack, attr, &val, sizeof(val)) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = sizeof(val);\n\t\tattr->val.int16 = val;\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nint l2tp_packet_add_int32(struct l2tp_packet_t *pack, int id, int32_t val, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tval = htonl(val);\n\t\tif (encode_attr(pack, attr, &val, sizeof(val)) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = sizeof(val);\n\t\tattr->val.int32 = val;\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nint l2tp_packet_add_int64(struct l2tp_packet_t *pack, int id, int64_t val, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tval = htobe64(val);\n\t\tif (encode_attr(pack, attr, &val, sizeof(val)) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = sizeof(val);\n\t\tattr->val.uint64 = val;\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nint l2tp_packet_add_string(struct l2tp_packet_t *pack, int id, const char *val, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\tsize_t val_len = strlen(val);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tif (encode_attr(pack, attr, val, val_len) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = val_len;\n\t\tattr->val.string = _strdup(val);\n\t\tif (!attr->val.string) {\n\t\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nint l2tp_packet_add_octets(struct l2tp_packet_t *pack, int id, const uint8_t *val, int size, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (size == 0) {\n\t\tattr->length = size;\n\t\tattr->val.octets = NULL;\n\t} else if (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tif (encode_attr(pack, attr, val, size) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = size;\n\t\tattr->val.octets = _malloc(size);\n\t\tif (!attr->val.octets) {\n\t\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tmemcpy(attr->val.octets, val, attr->length);\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nstatic void init(void)\n{\n\tattr_pool = mempool_create(sizeof(struct l2tp_attr_t));\n\tpack_pool = mempool_create(sizeof(struct l2tp_packet_t));\n\tbuf_pool = mempool_create(L2TP_MAX_PACKET_SIZE);\n}\n\nDEFINE_INIT(21, init);\n"], "fixing_code": ["#ifndef __L2TP_PROT_H\n#define __L2TP_PROT_H\n\n#include <stdint.h>\n\n#define L2TP_PORT 1701\n\n#define L2TP_FLAG_T   0x8000\n#define L2TP_FLAG_L   0x4000\n#define L2TP_FLAG_S   0x0800\n#define L2TP_FLAG_O   0x0200\n#define L2TP_FLAG_P   0x0100\n#define L2TP_VER_MASK 0x000f\n\nstruct l2tp_hdr_t\n{\n\tuint16_t flags;\n\tuint16_t length;\n\tunion {\n\t\tstruct {\n\t\t\tuint16_t tid;\n\t\t\tuint16_t sid;\n\t\t};\n\t\tuint32_t cid;\n\t};\n\tuint16_t Ns;\n\tuint16_t Nr;\n} __attribute__((packed));\n\n#define L2TP_AVP_FLAG_M   0x8000\n#define L2TP_AVP_FLAG_H   0x4000\n#define L2TP_AVP_LEN_MASK 0x03ff\n\nstruct l2tp_avp_t\n{\n\tuint16_t flags;\n\tuint16_t vendor;\n\tuint16_t type;\n\tuint8_t val[0];\n} __attribute__((packed));\n\nstruct l2tp_avp_result_code\n{\n\tuint16_t result_code;\n\tuint16_t error_code;\n\tchar error_msg[0];\n} __attribute__((packed));\n\n#endif\n", "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <endian.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <arpa/inet.h>\n\n#include \"crypto.h\"\n#include \"triton.h\"\n#include \"log.h\"\n#include \"mempool.h\"\n#include \"memdebug.h\"\n#include \"utils.h\"\n\n#include \"l2tp.h\"\n#include \"attr_defs.h\"\n\nstatic mempool_t attr_pool;\nstatic mempool_t pack_pool;\nstatic mempool_t buf_pool;\n\nvoid l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\n\tswitch (pack->hdr.flags & L2TP_VER_MASK) {\n\tcase 2:\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t\tbreak;\n\tcase 3:\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t\tbreak;\n\tdefault:\n\t\tprint(\"[L2TP unknown version]\\n\");\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\n\tprint(\"]\\n\");\n}\n\nstruct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | (ver & L2TP_VER_MASK);\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pack;\n}\n\nvoid l2tp_packet_free(struct l2tp_packet_t *pack)\n{\n\tstruct l2tp_attr_t *attr;\n\n\twhile (!list_empty(&pack->attrs)) {\n\t\tattr = list_entry(pack->attrs.next, typeof(*attr), entry);\n\t\tif (attr->H || attr->attr->type == ATTR_TYPE_OCTETS\n\t\t    || attr->attr->type == ATTR_TYPE_STRING)\n\t\t\t_free(attr->val.octets);\n\t\tlist_del(&attr->entry);\n\t\tmempool_free(attr);\n\t}\n\n\tmempool_free(pack);\n}\n\nstatic void memxor(uint8_t *dst, const uint8_t *src, size_t sz)\n{\n\tconst uintmax_t *umax_src = (const uintmax_t *)src;\n\tuintmax_t *umax_dst = (uintmax_t *)dst;\n\tsize_t left = sz % sizeof(uintmax_t);\n\tsize_t indx;\n\n\tfor (indx = 0; indx < sz / sizeof(uintmax_t); ++indx)\n\t\tumax_dst[indx] ^= umax_src[indx];\n\n\tsrc += sz - left;\n\tdst += sz - left;\n\twhile (left) {\n\t\tif (left >= sizeof(uint32_t)) {\n\t\t\t*(uint32_t *)dst ^= *(uint32_t *)src;\n\t\t\tsrc += sizeof(uint32_t);\n\t\t\tdst += sizeof(uint32_t);\n\t\t\tleft -= sizeof(uint32_t);\n\t\t} else if (left >= sizeof(uint16_t)) {\n\t\t\t*(uint16_t *)dst ^= *(uint16_t *)src;\n\t\t\tsrc += sizeof(uint16_t);\n\t\t\tdst += sizeof(uint16_t);\n\t\t\tleft -= sizeof(uint16_t);\n\t\t} else {\n\t\t\t*dst ^= *src;\n\t\t\tsrc += sizeof(uint8_t);\n\t\t\tdst += sizeof(uint8_t);\n\t\t\tleft -= sizeof(uint8_t);\n\t\t}\n\t}\n}\n\n/*\n * Decipher hidden AVPs, keeping the Hidden AVP Subformat (i.e. the attribute\n * value is prefixed by 2 bytes indicating its length in network byte order).\n */\nstatic int decode_avp(struct l2tp_avp_t *avp, const struct l2tp_attr_t *RV,\n\t\t      const char *secret, size_t secret_len)\n{\n\tMD5_CTX md5_ctx;\n\tuint8_t md5[MD5_DIGEST_LENGTH];\n\tuint8_t p1[MD5_DIGEST_LENGTH];\n\tuint8_t *prev_block = NULL;\n\tuint16_t avp_len;\n\tuint16_t attr_len;\n\tuint16_t orig_attr_len;\n\tuint16_t bytes_left;\n\tuint16_t blocks_left;\n\tuint16_t last_block_len;\n\n\tavp_len = avp->flags & L2TP_AVP_LEN_MASK;\n\tif (avp_len < sizeof(struct l2tp_avp_t) + 2) {\n\t\t/* Hidden AVPs must contain at least two bytes\n\t\t   for storing original attribute length */\n\t\tlog_warn(\"l2tp: incorrect hidden avp received (type %hu):\"\n\t\t\t \" length too small (%hu bytes)\\n\",\n\t\t\t ntohs(avp->type), avp_len);\n\t\treturn -1;\n\t}\n\tattr_len = avp_len - sizeof(struct l2tp_avp_t);\n\n\t/* Decode first block */\n\tMD5_Init(&md5_ctx);\n\tMD5_Update(&md5_ctx, &avp->type, sizeof(avp->type));\n\tMD5_Update(&md5_ctx, secret, secret_len);\n\tMD5_Update(&md5_ctx, RV->val.octets, RV->length);\n\tMD5_Final(p1, &md5_ctx);\n\n\tif (attr_len <= MD5_DIGEST_LENGTH) {\n\t\tmemxor(avp->val, p1, attr_len);\n\t\treturn 0;\n\t}\n\n\tmemxor(p1, avp->val, MD5_DIGEST_LENGTH);\n\torig_attr_len = ntohs(*(uint16_t *)p1);\n\n\tif (orig_attr_len <= MD5_DIGEST_LENGTH - 2) {\n\t\t/* Enough bytes decoded already, no need to decode padding */\n\t\tmemcpy(avp->val, p1, MD5_DIGEST_LENGTH);\n\t\treturn 0;\n\t}\n\n\tif (orig_attr_len > attr_len - 2) {\n\t\tlog_warn(\"l2tp: incorrect hidden avp received (type %hu):\"\n\t\t\t \" original attribute length too big (ciphered\"\n\t\t\t \" attribute length: %hu bytes, advertised original\"\n\t\t\t \" attribute length: %hu bytes)\\n\",\n\t\t\t ntohs(avp->type), attr_len, orig_attr_len);\n\t\treturn -1;\n\t}\n\n\t/* Decode remaining blocks. Start from the last block as\n\t   preceding blocks must be kept hidden for computing MD5s */\n\tbytes_left = orig_attr_len + 2 - MD5_DIGEST_LENGTH;\n\tlast_block_len = bytes_left % MD5_DIGEST_LENGTH;\n\tblocks_left = bytes_left / MD5_DIGEST_LENGTH;\n\tif (last_block_len) {\n\t\tprev_block = avp->val + blocks_left * MD5_DIGEST_LENGTH;\n\t\tMD5_Init(&md5_ctx);\n\t\tMD5_Update(&md5_ctx, secret, secret_len);\n\t\tMD5_Update(&md5_ctx, prev_block, MD5_DIGEST_LENGTH);\n\t\tMD5_Final(md5, &md5_ctx);\n\t\tmemxor(prev_block + MD5_DIGEST_LENGTH, md5, last_block_len);\n\t\tprev_block -= MD5_DIGEST_LENGTH;\n\t} else\n\t\tprev_block = avp->val + (blocks_left - 1) * MD5_DIGEST_LENGTH;\n\n\twhile (prev_block >= avp->val) {\n\t\tMD5_Init(&md5_ctx);\n\t\tMD5_Update(&md5_ctx, secret, secret_len);\n\t\tMD5_Update(&md5_ctx, prev_block, MD5_DIGEST_LENGTH);\n\t\tMD5_Final(md5, &md5_ctx);\n\t\tmemxor(prev_block + MD5_DIGEST_LENGTH, md5, MD5_DIGEST_LENGTH);\n\t\tprev_block -= MD5_DIGEST_LENGTH;\n\t}\n\tmemcpy(avp->val, p1, MD5_DIGEST_LENGTH);\n\n\treturn 0;\n}\n\nint l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n\t      const char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack;\n\tstruct l2tp_hdr_t *hdr;\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_attr_t *RV = NULL;\n\tstruct sockaddr_in addr;\n\tsocklen_t addr_len;\n\tuint16_t orig_avp_len;\n\tvoid *orig_avp_val;\n\tuint8_t *buf, *ptr;\n\tint n, length;\n\n\t*p = NULL;\n\n\tif (pkt_info) {\n\t\tstruct msghdr msg;\n\t\tstruct cmsghdr *cmsg;\n\t\tchar msg_control[128];\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.msg_control = msg_control;\n\t\tmsg.msg_controllen = sizeof(msg_control);\n\n\t\tn = recvmsg(fd, &msg, MSG_PEEK);\n\t\tif (n < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn -1;\n\t\t\tlog_error(\"l2tp: recvmsg: %s\\n\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tif (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_PKTINFO) {\n\t\t\t\tmemcpy(pkt_info, CMSG_DATA(cmsg), sizeof(*pkt_info));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuf = mempool_alloc(buf_pool);\n\tif (!buf) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn 0;\n\t}\n\thdr = (struct l2tp_hdr_t *)buf;\n\tptr = (uint8_t *)(hdr + 1);\n\n\taddr_len = sizeof(addr);\n\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &addr_len);\n\tif (n < 0) {\n\t\tmempool_free(buf);\n\t\tif (errno == EAGAIN) {\n\t\t\treturn -1;\n\t\t} else if (errno == ECONNREFUSED) {\n\t\t\treturn -2;\n\t\t}\n\t\tlog_error(\"l2tp: recv: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tif (n < sizeof(*hdr)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", n, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t}\n\n\thdr->flags = ntohs(hdr->flags);\n\tif (!(hdr->flags & L2TP_FLAG_T))\n\t\tgoto out_err_hdr;\n\tif (!(hdr->flags & L2TP_FLAG_L)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: incorrect control message received (L=0)\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\tif (!(hdr->flags & L2TP_FLAG_S)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: incorrect control message received (S=0)\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\tswitch (hdr->flags & L2TP_VER_MASK) {\n\tcase 2:\n\t\tif (hdr->flags & L2TP_FLAG_O) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect control message received (O=1)\\n\");\n\t\t\tgoto out_err_hdr;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tbreak;\n\tdefault:\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\",\n\t\t\t\t hdr->flags & L2TP_VER_MASK);\n\t\tgoto out_err_hdr;\n\t}\n\n\tlength = ntohs(hdr->length);\n\tif (length < sizeof(*hdr)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", length, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t} else if (n < length) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%i)\\n\", n, length);\n\t\tgoto out_err_hdr;\n\t}\n\n\tpack = mempool_alloc(pack_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\tmemcpy(&pack->addr, &addr, sizeof(addr));\n\tmemcpy(&pack->hdr, hdr, sizeof(*hdr));\n\tlength -= sizeof(*hdr);\n\n\twhile (length > 0) {\n\t\tstruct l2tp_dict_attr_t *da;\n\t\tstruct l2tp_attr_t *attr;\n\t\tuint16_t avp_len;\n\n\t\tif (length < sizeof(*avp)) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: short avp received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\t\tavp->flags = ntohs(avp->flags);\n\t\tavp_len = avp->flags & L2TP_AVP_LEN_MASK;\n\t\tif (avp_len < sizeof(*avp)) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: short avp received\\n\");\n\t\t\tgoto out_err;\n\t\t} else if (length < avp_len) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (avp->vendor)\n\t\t\tgoto skip;\n\n\t\tda = l2tp_dict_find_attr_by_id(ntohs(avp->type));\n\t\tif (!da) {\n\t\t\tif (conf_verbose) {\n\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\",\n\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M));\n\t\t\t}\n\t\t\tif ((avp->flags & L2TP_AVP_FLAG_M) && !conf_avp_permissive)\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\tif (da->M != -1 && !da->M != !(avp->flags & L2TP_AVP_FLAG_M)) {\n\t\t\t\tif (conf_verbose) {\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\",\n\t\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M), da->M);\n\t\t\t\t}\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (da->H != -1 && !da->H != !(avp->flags & L2TP_AVP_FLAG_H)) {\n\t\t\t\tif (conf_verbose) {\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\",\n\t\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_H), da->H);\n\t\t\t\t}\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (avp->flags & L2TP_AVP_FLAG_H) {\n\t\t\t\tif (!RV) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (secret == NULL || secret_len == 0) {\n\t\t\t\t\tlog_error(\"l2tp: impossible to decode\"\n\t\t\t\t\t\t  \" hidden avp (type %hu): no\"\n\t\t\t\t\t\t  \" secret set)\\n\",\n\t\t\t\t\t\t  ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (decode_avp(avp, RV, secret, secret_len) < 0)\n\t\t\t\t\tgoto out_err;\n\n\t\t\t\torig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);\n\t\t\t\torig_avp_val = avp->val + sizeof(uint16_t);\n\t\t\t} else {\n\t\t\t\torig_avp_len = avp_len;\n\t\t\t\torig_avp_val = avp->val;\n\t\t\t}\n\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->attr = da;\n\t\t\tattr->M = !!(avp->flags & L2TP_AVP_FLAG_M);\n\t\t\tattr->H = 0;\n\t\t\tattr->length = orig_avp_len - sizeof(*avp);\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\t\t\tif (attr->attr->id == Random_Vector)\n\t\t\t\tRV = attr;\n\n\t\t\tswitch (da->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 2)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint16 = ntohs(*(uint16_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 4)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint32 = ntohl(*(uint32_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT64:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 8)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint64 = be64toh(*(uint64_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tattr->val.octets = _malloc(attr->length);\n\t\t\t\t\tif (!attr->val.octets)\n\t\t\t\t\t\tgoto out_err_mem;\n\t\t\t\t\tmemcpy(attr->val.octets, orig_avp_val, attr->length);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tattr->val.string = _malloc(attr->length + 1);\n\t\t\t\t\tif (!attr->val.string)\n\t\t\t\t\t\tgoto out_err_mem;\n\t\t\t\t\tmemcpy(attr->val.string, orig_avp_val, attr->length);\n\t\t\t\t\tattr->val.string[attr->length] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nskip:\n\t\tptr += avp_len;\n\t\tlength -= avp_len;\n\t}\n\n\t*p = pack;\n\n\tmempool_free(buf);\n\n\treturn 0;\n\nout_err:\n\tl2tp_packet_free(pack);\nout_err_hdr:\n\tmempool_free(buf);\n\treturn 0;\nout_err_len:\n\tif (conf_verbose)\n\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, incorrect length %i)\\n\", ntohs(avp->type), orig_avp_len);\n\tgoto out_err;\nout_err_mem:\n\tlog_emerg(\"l2tp: out of memory\\n\");\n\tgoto out_err;\n}\n\nint l2tp_packet_send(int sock, struct l2tp_packet_t *pack)\n{\n\tstruct l2tp_hdr_t *hdr;\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_attr_t *attr;\n\tuint8_t *buf, *ptr;\n\tint n, len;\n\n\tbuf = mempool_alloc(buf_pool);\n\tif (!buf) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf, 0, L2TP_MAX_PACKET_SIZE);\n\thdr = (struct l2tp_hdr_t *)buf;\n\tptr = (uint8_t *)(hdr + 1);\n\tlen = sizeof(pack->hdr);\n\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tif (len + sizeof(*avp) + attr->length >= L2TP_MAX_PACKET_SIZE) {\n\t\t\tlog_error(\"l2tp: cann't send packet (exceeds maximum size)\\n\");\n\t\t\tmempool_free(buf);\n\t\t\treturn -1;\n\t\t}\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\t\tavp->type = htons(attr->attr->id);\n\t\tavp->flags = htons((attr->M ? L2TP_AVP_FLAG_M : 0) |\n\t\t\t\t   (attr->H ? L2TP_AVP_FLAG_H : 0) |\n\t\t\t\t   ((sizeof(*avp) + attr->length) & L2TP_AVP_LEN_MASK));\n\t\tif (attr->H)\n\t\t\tmemcpy(avp->val, attr->val.octets, attr->length);\n\t\telse\n\t\t\tswitch (attr->attr->type) {\n\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t*(int16_t *)avp->val = htons(attr->val.int16);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t*(int32_t *)avp->val = htonl(attr->val.int32);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_INT64:\n\t\t\t\t*(uint64_t *)avp->val = htobe64(attr->val.uint64);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_STRING:\n\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\tmemcpy(avp->val, attr->val.string, attr->length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tptr += sizeof(*avp) + attr->length;\n\t\tlen += sizeof(*avp) + attr->length;\n\t}\n\n\tpack->hdr.length = htons(len);\n\tmemcpy(buf, &pack->hdr, sizeof(pack->hdr));\n\thdr->flags = htons(pack->hdr.flags);\n\n\tn = sendto(sock, buf, len, 0, &pack->addr, sizeof(pack->addr));\n\tmempool_free(buf);\n\n\tif (n < 0) {\n\t\tif (errno == EAGAIN) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: buffer overflow (packet lost)\\n\");\n\t\t} else {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: sendto: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n != len) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short write (%i/%i)\\n\", n, len);\n\t}\n\n\treturn 0;\n}\n\nint encode_attr(const struct l2tp_packet_t *pack, struct l2tp_attr_t *attr,\n\t\tconst void *val, uint16_t val_len)\n{\n\tuint8_t *u8_ptr = NULL;\n\tuint8_t md5[MD5_DIGEST_LENGTH];\n\tMD5_CTX md5_ctx;\n\tuint16_t pad_len;\n\tuint16_t attr_type;\n\tuint16_t blocks_left;\n\tuint16_t last_block_len;\n\tint err;\n\n\tif (pack->secret == NULL || pack->secret_len == 0) {\n\t\tlog_error(\"l2tp: impossible to hide AVP: no secret\\n\");\n\t\tgoto err;\n\t}\n\tif (pack->last_RV == NULL) {\n\t\tlog_error(\"l2tp: impossible to hide AVP: no random vector\\n\");\n\t\tgoto err;\n\t}\n\n\tif (u_randbuf(&pad_len, sizeof(pad_len), &err) < 0) {\n\t\tif (err)\n\t\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t\t  \" reading from urandom failed: %s\\n\",\n\t\t\t\t  strerror(err));\n\t\telse\n\t\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t\t  \" end of file reached while reading\"\n\t\t\t\t  \" from urandom\\n\");\n\t\tgoto err;\n\t}\n\t/* Use at least 16 bytes of padding */\n\tpad_len = (pad_len & 0x007F) + 16;\n\n\t/* Generate Hidden AVP Subformat:\n\t *   -original AVP size (2 bytes, network byte order)\n\t *   -original AVP value ('val_len' bytes)\n\t *   -padding ('pad_len' bytes of random values)\n\t */\n\tattr->length = sizeof(val_len) + val_len + pad_len;\n\tattr->val.octets = _malloc(attr->length);\n\tif (attr->val.octets == NULL) {\n\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t  \" memory allocation failed\\n\");\n\t\tgoto err;\n\t}\n\n\t*(uint16_t *)attr->val.octets = htons(val_len);\n\tmemcpy(attr->val.octets + sizeof(val_len), val, val_len);\n\n\tif (u_randbuf(attr->val.octets + sizeof(val_len) + val_len,\n\t\t      pad_len, &err) < 0) {\n\t\tif (err)\n\t\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t\t  \" reading from urandom failed: %s\\n\",\n\t\t\t\t  strerror(err));\n\t\telse\n\t\t\tlog_error(\"l2tp: impossible to hide AVP:\"\n\t\t\t\t  \" end of file reached while reading\"\n\t\t\t\t  \" from urandom\\n\");\n\t\tgoto err_free;\n\t}\n\n\t/* Hidden AVP cipher:\n\t * ciphered[0] = clear[0] xor MD5(attr_type, secret, RV)\n\t * ciphered[1] = clear[1] xor MD5(secret, ciphered[0])\n\t * ...\n\t * ciphered[n] = clear[n] xor MD5(secret, ciphered[n-1])\n\t */\n\tattr_type = htons(attr->attr->id);\n\tMD5_Init(&md5_ctx);\n\tMD5_Update(&md5_ctx, &attr_type, sizeof(attr_type));\n\tMD5_Update(&md5_ctx, pack->secret, pack->secret_len);\n\tMD5_Update(&md5_ctx, pack->last_RV->val.octets, pack->last_RV->length);\n\tMD5_Final(md5, &md5_ctx);\n\n\tif (attr->length <= MD5_DIGEST_LENGTH) {\n\t\tmemxor(attr->val.octets, md5, attr->length);\n\t\treturn 0;\n\t}\n\n\tmemxor(attr->val.octets, md5, MD5_DIGEST_LENGTH);\n\n\tblocks_left = attr->length / MD5_DIGEST_LENGTH - 1;\n\tlast_block_len = attr->length % MD5_DIGEST_LENGTH;\n\n\tfor (u8_ptr = attr->val.octets; blocks_left; --blocks_left) {\n\t\tMD5_Init(&md5_ctx);\n\t\tMD5_Update(&md5_ctx, pack->secret, pack->secret_len);\n\t\tMD5_Update(&md5_ctx, u8_ptr, MD5_DIGEST_LENGTH);\n\t\tMD5_Final(md5, &md5_ctx);\n\t\tu8_ptr += MD5_DIGEST_LENGTH;\n\t\tmemxor(u8_ptr, md5, MD5_DIGEST_LENGTH);\n\t}\n\n\tif (last_block_len) {\n\t\tMD5_Init(&md5_ctx);\n\t\tMD5_Update(&md5_ctx, pack->secret, pack->secret_len);\n\t\tMD5_Update(&md5_ctx, u8_ptr, MD5_DIGEST_LENGTH);\n\t\tMD5_Final(md5, &md5_ctx);\n\t\tmemxor(u8_ptr + MD5_DIGEST_LENGTH, md5, last_block_len);\n\t}\n\n\treturn 0;\n\nerr_free:\n\t_free(attr->val.octets);\n\tattr->val.octets = NULL;\nerr:\n\treturn -1;\n}\n\nstatic struct l2tp_attr_t *attr_alloc(int id, int M, int H)\n{\n\tstruct l2tp_attr_t *attr;\n\tstruct l2tp_dict_attr_t *da;\n\n\tda = l2tp_dict_find_attr_by_id(id);\n\tif (!da)\n\t\treturn NULL;\n\n\tattr = mempool_alloc(attr_pool);\n\tif (!attr) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(attr, 0, sizeof(*attr));\n\n\tattr->attr = da;\n\n\tif (da->M != -1)\n\t\tattr->M = da->M;\n\telse\n\t\tattr->M = M;\n\n\tif (da->H != -1)\n\t\tattr->H = da->H;\n\telse\n\t\tattr->H = H;\n\n\treturn attr;\n}\n\nstatic int l2tp_packet_add_random_vector(struct l2tp_packet_t *pack)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(Random_Vector, 1, 0);\n\tuint16_t ranvec_len;\n\tint err;\n\n\tif (!attr)\n\t\tgoto err;\n\n\tif (u_randbuf(&ranvec_len, sizeof(ranvec_len), &err) < 0) {\n\t\tif (err)\n\t\t\tlog_error(\"l2tp: impossible to build Random Vector:\"\n\t\t\t\t  \" reading from urandom failed: %s\\n\",\n\t\t\t\t  strerror(err));\n\t\telse\n\t\t\tlog_error(\"l2tp: impossible to build Random Vector:\"\n\t\t\t\t  \" end of file reached while reading\"\n\t\t\t\t  \" from urandom\\n\");\n\t\tgoto err_attr;\n\t}\n\t/* RFC 2661 recommends that Random Vector be least 16 bytes long */\n\tranvec_len = (ranvec_len & 0x007F) + 16;\n\n\tattr->length = ranvec_len;\n\tattr->val.octets = _malloc(ranvec_len);\n\tif (!attr->val.octets) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\tgoto err_attr;\n\t}\n\n\tif (u_randbuf(attr->val.octets, ranvec_len, &err) < 0) {\n\t\tif (err)\n\t\t\tlog_error(\"l2tp: impossible to build Random Vector:\"\n\t\t\t\t  \" reading from urandom failed: %s\\n\",\n\t\t\t\t  strerror(err));\n\t\telse\n\t\t\tlog_error(\"l2tp: impossible to build Random Vector:\"\n\t\t\t\t  \" end of file reached while reading\"\n\t\t\t\t  \" from urandom\\n\");\n\t\tgoto err_attr_val;\n\t}\n\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\tpack->last_RV = attr;\n\n\treturn 0;\n\nerr_attr_val:\n\t_free(attr->val.octets);\nerr_attr:\n\tmempool_free(attr);\nerr:\n\treturn -1;\n}\n\nint l2tp_packet_add_int16(struct l2tp_packet_t *pack, int id, int16_t val, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tval = htons(val);\n\t\tif (encode_attr(pack, attr, &val, sizeof(val)) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = sizeof(val);\n\t\tattr->val.int16 = val;\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nint l2tp_packet_add_int32(struct l2tp_packet_t *pack, int id, int32_t val, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tval = htonl(val);\n\t\tif (encode_attr(pack, attr, &val, sizeof(val)) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = sizeof(val);\n\t\tattr->val.int32 = val;\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nint l2tp_packet_add_int64(struct l2tp_packet_t *pack, int id, int64_t val, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tval = htobe64(val);\n\t\tif (encode_attr(pack, attr, &val, sizeof(val)) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = sizeof(val);\n\t\tattr->val.uint64 = val;\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nint l2tp_packet_add_string(struct l2tp_packet_t *pack, int id, const char *val, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\tsize_t val_len = strlen(val);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tif (encode_attr(pack, attr, val, val_len) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = val_len;\n\t\tattr->val.string = _strdup(val);\n\t\tif (!attr->val.string) {\n\t\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nint l2tp_packet_add_octets(struct l2tp_packet_t *pack, int id, const uint8_t *val, int size, int M)\n{\n\tstruct l2tp_attr_t *attr = attr_alloc(id, M, pack->hide_avps);\n\n\tif (!attr)\n\t\treturn -1;\n\n\tif (size == 0) {\n\t\tattr->length = size;\n\t\tattr->val.octets = NULL;\n\t} else if (attr->H) {\n\t\tif (pack->last_RV == NULL)\n\t\t\tif (l2tp_packet_add_random_vector(pack) < 0)\n\t\t\t\tgoto err;\n\t\tif (encode_attr(pack, attr, val, size) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tattr->length = size;\n\t\tattr->val.octets = _malloc(size);\n\t\tif (!attr->val.octets) {\n\t\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tmemcpy(attr->val.octets, val, attr->length);\n\t}\n\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\treturn 0;\n\nerr:\n\tmempool_free(attr);\n\treturn -1;\n}\n\nstatic void init(void)\n{\n\tattr_pool = mempool_create(sizeof(struct l2tp_attr_t));\n\tpack_pool = mempool_create(sizeof(struct l2tp_packet_t));\n\tbuf_pool = mempool_create(L2TP_MAX_PACKET_SIZE);\n}\n\nDEFINE_INIT(21, init);\n"], "filenames": ["accel-pppd/ctrl/l2tp/l2tp_prot.h", "accel-pppd/ctrl/l2tp/packet.c"], "buggy_code_start_loc": [7, 31], "buggy_code_end_loc": [57, 547], "fixing_code_start_loc": [8, 31], "fixing_code_end_loc": [49, 572], "type": "CWE-120", "message": "In ACCEL-PPP (an implementation of PPTP/PPPoE/L2TP/SSTP), there is a buffer overflow when receiving an l2tp control packet ith an AVP which type is a string and no hidden flags, length set to less than 6. If your application is used in open networks or there are untrusted nodes in the network it is highly recommended to apply the patch. The problem was patched with commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b As a workaround changes of commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b can be applied to older versions.", "other": {"cve": {"id": "CVE-2020-15173", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-09T23:15:10.977", "lastModified": "2021-11-18T17:48:21.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ACCEL-PPP (an implementation of PPTP/PPPoE/L2TP/SSTP), there is a buffer overflow when receiving an l2tp control packet ith an AVP which type is a string and no hidden flags, length set to less than 6. If your application is used in open networks or there are untrusted nodes in the network it is highly recommended to apply the patch. The problem was patched with commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b As a workaround changes of commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b can be applied to older versions."}, {"lang": "es", "value": "En ACCEL-PPP (una implementaci\u00f3n de PPTP/PPPoE/L2TP/SSTP), se presenta un desbordamiento del b\u00fafer cuando se recibe un paquete de control l2tp con un AVP cuyo tipo es una cadena y no indicadores ocultos, la longitud se establece en menos de 6. Si su aplicaci\u00f3n es usada en redes abiertas o existen nodos que no son confiables en la red, se recomienda aplicar el parche. El problema se corrigi\u00f3 con el commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b. Como soluci\u00f3n alternativa, los cambios del commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b pueden ser aplicados a versiones anteriores"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:accel-ppp:accel-ppp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.12.0-92-g38b6104", "matchCriteriaId": "679B5514-7B19-4406-900D-A10D6DA75DDA"}]}]}], "references": [{"url": "https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/accel-ppp/accel-ppp/security/advisories/GHSA-rr68-fchr-69vf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b"}}