{"buggy_code": ["PolarSSL ChangeLog\n\n= Branch 1.2\nChange\n   * HAVEGE random generator disabled by default\n\nBugfix\n   * Secure renegotiation extension should only be sent in case client\n     supports secure renegotiation\n   * Fixed offset for cert_type list in ssl_parse_certificate_request()\n   * Fixed const correctness issues that have no impact on the ABI\n   * x509parse_crt() now better handles PEM error situations\n\n= Version 1.2.7 released 2013-04-13\nFeatures\n   * Ability to specify allowed ciphersuites based on the protocol version.\n\nChanges\n   * Default Blowfish keysize is now 128-bits\n   * Test suites made smaller to accommodate Raspberry Pi\n\nBugfix\n   * Fix for MPI assembly for ARM\n   * GCM adapted to support sizes > 2^29\n\n= Version 1.2.6 released 2013-03-11\nBugfix\n   * Fixed memory leak in ssl_free() and ssl_reset() for active session\n   * Corrected GCM counter incrementation to use only 32-bits instead of\n     128-bits (found by Yawning Angel)\n   * Fixes for 64-bit compilation with MS Visual Studio\n   * Fixed net_bind() for specified IP addresses on little endian systems\n   * Fixed assembly code for ARM (Thumb and regular) for some compilers\n\nChanges\n   * Internally split up rsa_pkcs1_encrypt(), rsa_pkcs1_decrypt(),\n     rsa_pkcs1_sign() and rsa_pkcs1_verify() to separate PKCS#1 v1.5 and\n     PKCS#1 v2.1 functions\n   * Added support for custom labels when using rsa_rsaes_oaep_encrypt()\n     or rsa_rsaes_oaep_decrypt()\n   * Re-added handling for SSLv2 Client Hello when the define\n     POLARSSL_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO is set\n   * The SSL session cache module (ssl_cache) now also retains peer_cert\n     information (not the entire chain)\n\nSecurity\n   * Removed further timing differences during SSL message decryption in\n     ssl_decrypt_buf()\n   * Removed timing differences due to bad padding from\n     rsa_rsaes_pkcs1_v15_decrypt() and rsa_pkcs1_decrypt() for PKCS#1 v1.5\n     operations\n\n= Version 1.2.5 released 2013-02-02\nChanges\n   * Allow enabling of dummy error_strerror() to support some use-cases\n   * Debug messages about padding errors during SSL message decryption are\n     disabled by default and can be enabled with POLARSSL_SSL_DEBUG_ALL \n   * Sending of security-relevant alert messages that do not break\n     interoperability can be switched on/off with the flag\n     POLARSSL_SSL_ALL_ALERT_MESSAGES\n\nSecurity\n   * Removed timing differences during SSL message decryption in\n     ssl_decrypt_buf() due to badly formatted padding\n\n= Version 1.2.4 released 2013-01-25\nChanges\n   * Added ssl_handshake_step() to allow single stepping the handshake process\n\nBugfix\n   * Memory leak when using RSA_PKCS_V21 operations fixed\n   * Handle future version properly in ssl_write_certificate_request()\n   * Correctly handle CertificateRequest message in client for <= TLS 1.1\n     without DN list\n\n= Version 1.2.3 released 2012-11-26\nBugfix\n   * Server not always sending correct CertificateRequest message\n\n= Version 1.2.2 released 2012-11-24\nChanges\n   * Added p_hw_data to ssl_context for context specific hardware acceleration\n     data\n   * During verify trust-CA is only checked for expiration and CRL presence  \n\nBugfixes\n   * Fixed client authentication compatibility\n   * Fixed dependency on POLARSSL_SHA4_C in SSL modules\n\n= Version 1.2.1 released 2012-11-20\nChanges\n   * Depth that the certificate verify callback receives is now numbered\n     bottom-up (Peer cert depth is 0)\n\nBugfixes\n   * Fixes for MSVC6\n   * Moved mpi_inv_mod() outside POLARSSL_GENPRIME\n   * Allow R and A to point to same mpi in mpi_div_mpi (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Fixed possible segfault in mpi_shift_r() (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Added max length check for rsa_pkcs1_sign with PKCS#1 v2.1\n\n= Version 1.2.0 released 2012-10-31\nFeatures\n   * Added support for NULL cipher (POLARSSL_CIPHER_NULL_CIPHER) and weak\n     ciphersuites (POLARSSL_ENABLE_WEAK_CIPHERSUITES). They are disabled by\n     default!\n   * Added support for wildcard certificates\n   * Added support for multi-domain certificates through the X509 Subject\n     Alternative Name extension\n   * Added preliminary ASN.1 buffer writing support\n   * Added preliminary X509 Certificate Request writing support\n   * Added key_app_writer example application\n   * Added cert_req example application\n   * Added base Galois Counter Mode (GCM) for AES\n   * Added TLS 1.2 support (RFC 5246)\n   * Added GCM suites to TLS 1.2 (RFC 5288)\n   * Added commandline error code convertor (util/strerror)\n   * Added support for Hardware Acceleration hooking in SSL/TLS\n   * Added OpenSSL / PolarSSL compatibility script (tests/compat.sh) and\n     example application (programs/ssl/o_p_test) (requires OpenSSL)\n   * Added X509 CA Path support\n   * Added Thumb assembly optimizations\n   * Added DEFLATE compression support as per RFC3749 (requires zlib)\n   * Added blowfish algorithm (Generic and cipher layer)\n   * Added PKCS#5 PBKDF2 key derivation function\n   * Added Secure Renegotiation (RFC 5746)\n   * Added predefined DHM groups from RFC 5114\n   * Added simple SSL session cache implementation\n   * Added ServerName extension parsing (SNI) at server side\n   * Added option to add minimum accepted SSL/TLS protocol version\n\nChanges\n   * Removed redundant POLARSSL_DEBUG_MSG define\n   * AES code only check for Padlock once\n   * Fixed const-correctness mpi_get_bit()\n   * Documentation for mpi_lsb() and mpi_msb()\n   * Moved out_msg to out_hdr + 32 to support hardware acceleration\n   * Changed certificate verify behaviour to comply with RFC 6125 section 6.3\n     to not match CN if subjectAltName extension is present (Closes ticket #56)\n   * Cipher layer cipher_mode_t POLARSSL_MODE_CFB128 is renamed to\n     POLARSSL_MODE_CFB, to also handle different block size CFB modes.\n   * Removed handling for SSLv2 Client Hello (as per RFC 5246 recommendation)\n   * Revamped session resumption handling\n   * Generalized external private key implementation handling (like PKCS#11)\n     in SSL/TLS\n   * Revamped x509_verify() and the SSL f_vrfy callback implementations\n   * Moved from unsigned long to fixed width uint32_t types throughout code\n   * Renamed ciphersuites naming scheme to IANA reserved names\n\nBugfix\n   * Fixed handling error in mpi_cmp_mpi() on longer B values (found by\n     Hui Dong)\n   * Fixed potential heap corruption in x509_name allocation\n   * Fixed single RSA test that failed on Big Endian systems (Closes ticket #54)\n   * mpi_exp_mod() now correctly handles negative base numbers (Closes ticket\n     #52)\n   * Handle encryption with private key and decryption with public key as per\n   \t RFC 2313\n   * Handle empty certificate subject names\n   * Prevent reading over buffer boundaries on X509 certificate parsing\n   * mpi_add_abs() now correctly handles adding short numbers to long numbers\n     with carry rollover (found by Ruslan Yushchenko)\n   * Handle existence of OpenSSL Trust Extensions at end of X.509 DER blob\n   * Fixed MPI assembly for SPARC64 platform\n\nSecurity\n   * Fixed potential memory zeroization on miscrafted RSA key (found by Eloi\n     Vanderbeken)\n\n= Version 1.1.5 released on 2013-01-16\nBugfix\n   * Fixed MPI assembly for SPARC64 platform\n   * Handle existence of OpenSSL Trust Extensions at end of X.509 DER blob\n   * mpi_add_abs() now correctly handles adding short numbers to long numbers\n     with carry rollover\n   * Moved mpi_inv_mod() outside POLARSSL_GENPRIME\n   * Prevent reading over buffer boundaries on X509 certificate parsing\n   * mpi_exp_mod() now correctly handles negative base numbers (Closes ticket\n     #52)\n   * Fixed possible segfault in mpi_shift_r() (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Allow R and A to point to same mpi in mpi_div_mpi (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Added max length check for rsa_pkcs1_sign with PKCS#1 v2.1\n   * Memory leak when using RSA_PKCS_V21 operations fixed\n   * Handle encryption with private key and decryption with public key as per\n     RFC 2313\n   * Fixes for MSVC6\n\nSecurity\n   * Fixed potential memory zeroization on miscrafted RSA key (found by Eloi\n     Vanderbeken)\n\n= Version 1.1.4 released on 2012-05-31\nBugfix\n   * Correctly handle empty SSL/TLS packets (Found by James Yonan)\n   * Fixed potential heap corruption in x509_name allocation\n   * Fixed single RSA test that failed on Big Endian systems (Closes ticket #54)\n\n= Version 1.1.3 released on 2012-04-29\nBugfix\n   * Fixed random MPI generation to not generate more size than requested.\n\n= Version 1.1.2 released on 2012-04-26\nBugfix\n   * Fixed handling error in mpi_cmp_mpi() on longer B values (found by\n     Hui Dong)\n\nSecurity\n   * Fixed potential memory corruption on miscrafted client messages (found by\n     Frama-C team at CEA LIST)\n   * Fixed generation of DHM parameters to correct length (found by Ruslan\n     Yushchenko)\n\n= Version 1.1.1 released on 2012-01-23\nBugfix\n   * Check for failed malloc() in ssl_set_hostname() and x509_get_entries()\n     (Closes ticket #47, found by Hugo Leisink)\n   * Fixed issues with Intel compiler on 64-bit systems (Closes ticket #50)\n   * Fixed multiple compiler warnings for VS6 and armcc\n   * Fixed bug in CTR_CRBG selftest\n\n= Version 1.1.0 released on 2011-12-22\nFeatures\n   * Added ssl_session_reset() to allow better multi-connection pools of\n     SSL contexts without needing to set all non-connection-specific\n\t data and pointers again. Adapted ssl_server to use this functionality.\n   * Added ssl_set_max_version() to allow clients to offer a lower maximum\n     supported version to a server to help buggy server implementations.\n\t (Closes ticket #36)\n   * Added cipher_get_cipher_mode() and cipher_get_cipher_operation()\n     introspection functions (Closes ticket #40)\n   * Added CTR_DRBG based on AES-256-CTR (NIST SP 800-90) random generator\n   * Added a generic entropy accumulator that provides support for adding\n     custom entropy sources and added some generic and platform dependent\n\t entropy sources\n\nChanges\n   * Documentation for AES and Camellia in modes CTR and CFB128 clarified.\n   * Fixed rsa_encrypt and rsa_decrypt examples to use public key for\n     encryption and private key for decryption. (Closes ticket #34)\n   * Inceased maximum size of ASN1 length reads to 32-bits.\n   * Added an EXPLICIT tag number parameter to x509_get_ext()\n   * Added a separate CRL entry extension parsing function\n   * Separated the ASN.1 parsing code from the X.509 specific parsing code.\n     So now there is a module that is controlled with POLARSSL_ASN1_PARSE_C.\n   * Changed the defined key-length of DES ciphers in cipher.h to include the\n     parity bits, to prevent mistakes in copying data. (Closes ticket #33)\n   * Loads of minimal changes to better support WINCE as a build target\n     (Credits go to Marco Lizza)\n   * Added POLARSSL_MPI_WINDOW_SIZE definition to allow easier time to memory\n     trade-off\n   * Introduced POLARSSL_MPI_MAX_SIZE and POLARSSL_MPI_MAX_BITS for MPI size\n     management (Closes ticket #44)\n   * Changed the used random function pointer to more flexible format. Renamed\n     havege_rand() to havege_random() to prevent mistakes. Lots of changes as\n     a consequence in library code and programs\n   * Moved all examples programs to use the new entropy and CTR_DRBG\n   * Added permissive certificate parsing to x509parse_crt() and\n     x509parse_crtfile(). With permissive parsing the parsing does not stop on\n     encountering a parse-error. Beware that the meaning of return values has\n     changed!\n   * All error codes are now negative. Even on mermory failures and IO errors.\n\nBugfix\n   * Fixed faulty HMAC-MD2 implementation. Found by dibac. (Closes\n     ticket #37)\n   * Fixed a bug where the CRL parser expected an EXPLICIT ASN.1 tag\n     before version numbers\n   * Allowed X509 key usage parsing to accept 4 byte values instead of the\n     standard 1 byte version sometimes used by Microsoft. (Closes ticket #38)\n   * Fixed incorrect behaviour in case of RSASSA-PSS with a salt length\n     smaller than the hash length. (Closes ticket #41)\n   * If certificate serial is longer than 32 octets, serial number is now\n     appended with '....' after first 28 octets\n   * Improved build support for s390x and sparc64 in bignum.h\n   * Fixed MS Visual C++ name clash with int64 in sha4.h\n   * Corrected removal of leading \"00:\" in printing serial numbers in\n     certificates and CRLs\n\n= Version 1.0.0 released on 2011-07-27\nFeatures\n   * Expanded cipher layer with support for CFB128 and CTR mode\n   * Added rsa_encrypt and rsa_decrypt simple example programs.\n\nChanges\n   * The generic cipher and message digest layer now have normal error\n     codes instead of integers\n\nBugfix\n   * Undid faulty bug fix in ssl_write() when flushing old data (Ticket\n     #18)\n\n= Version 0.99-pre5 released on 2011-05-26\nFeatures\n   * Added additional Cipher Block Modes to symmetric ciphers\n     (AES CTR, Camellia CTR, XTEA CBC) including the option to\n     enable and disable individual modes when needed\n   * Functions requiring File System functions can now be disabled\n     by undefining POLARSSL_FS_IO\n   * A error_strerror function() has been added to translate between\n     error codes and their description.\n   * Added mpi_get_bit() and mpi_set_bit() individual bit setter/getter\n     functions.\n   * Added ssl_mail_client and ssl_fork_server as example programs.\n\nChanges\n   * Major argument / variable rewrite. Introduced use of size_t\n     instead of int for buffer lengths and loop variables for\n     better unsigned / signed use. Renamed internal bigint types\n     t_int and t_dbl to t_uint and t_udbl in the process\n   * mpi_init() and mpi_free() now only accept a single MPI\n     argument and do not accept variable argument lists anymore.\n   * The error codes have been remapped and combining error codes\n     is now done with a PLUS instead of an OR as error codes\n     used are negative.\n   * Changed behaviour of net_read(), ssl_fetch_input() and ssl_recv().\n     net_recv() now returns 0 on EOF instead of\n     POLARSSL_ERR_NET_CONN_RESET. ssl_fetch_input() returns\n     POLARSSL_ERR_SSL_CONN_EOF on an EOF from its f_recv() function.\n     ssl_read() returns 0 if a POLARSSL_ERR_SSL_CONN_EOF is received\n     after the handshake.\n   * Network functions now return POLARSSL_ERR_NET_WANT_READ or\n     POLARSSL_ERR_NET_WANT_WRITE instead of the ambiguous\n     POLARSSL_ERR_NET_TRY_AGAIN\n\n= Version 0.99-pre4 released on 2011-04-01\nFeatures\n   * Added support for PKCS#1 v2.1 encoding and thus support\n     for the RSAES-OAEP and RSASSA-PSS operations.\n   * Reading of Public Key files incorporated into default x509\n     functionality as well.\n   * Added mpi_fill_random() for centralized filling of big numbers\n     with random data (Fixed ticket #10)\n\nChanges\n   * Debug print of MPI now removes leading zero octets and \n     displays actual bit size of the value.\n   * x509parse_key() (and as a consequence x509parse_keyfile()) \n     does not zeroize memory in advance anymore. Use rsa_init()\n     before parsing a key or keyfile!\n\nBugfix\n   * Debug output of MPI's now the same independent of underlying\n     platform (32-bit / 64-bit) (Fixes ticket #19, found by Mads\n     Kiilerich and Mihai Militaru)\n   * Fixed bug in ssl_write() when flushing old data (Fixed ticket\n     #18, found by Nikolay Epifanov)\n   * Fixed proper handling of RSASSA-PSS verification with variable\n     length salt lengths\n\n= Version 0.99-pre3 released on 2011-02-28\nThis release replaces version 0.99-pre2 which had possible copyright issues.\nFeatures\n   * Parsing PEM private keys encrypted with DES and AES\n     are now supported as well (Fixes ticket #5)\n   * Added crl_app program to allow easy reading and\n     printing of X509 CRLs from file\n\nChanges\n   * Parsing of PEM files moved to separate module (Fixes \n     ticket #13). Also possible to remove PEM support for\n     systems only using DER encoding\n\nBugfixes\n   * Corrected parsing of UTCTime dates before 1990 and\n     after 1950\n   * Support more exotic OID's when parsing certificates\n   \t (found by Mads Kiilerich)\n   * Support more exotic name representations when parsing\n     certificates (found by Mads Kiilerich)\n   * Replaced the expired test certificates\n   * Do not bail out if no client certificate specified. Try\n     to negotiate anonymous connection (Fixes ticket #12,\n     found by Boris Krasnovskiy)\n\nSecurity fixes\n   * Fixed a possible Man-in-the-Middle attack on the\n     Diffie Hellman key exchange (thanks to Larry Highsmith,\n     Subreption LLC)\n\n= Version 0.99-pre1 released on 2011-01-30\nFeatures\nNote: Most of these features have been donated by Fox-IT\n   * Added Doxygen source code documentation parts\n   * Added reading of DHM context from memory and file\n   * Improved X509 certificate parsing to include extended\n     certificate fields, including Key Usage\n   * Improved certificate verification and verification\n     against the available CRLs\n   * Detection for DES weak keys and parity bits added\n   * Improvements to support integration in other\n     applications:\n       + Added generic message digest and cipher wrapper\n       + Improved information about current capabilities,\n         status, objects and configuration\n       + Added verification callback on certificate chain\n         verification to allow external blacklisting\n\t   + Additional example programs to show usage\n   * Added support for PKCS#11 through the use of the\n     libpkcs11-helper library\n\nChanges\n   * x509parse_time_expired() checks time in addition to\n     the existing date check\n   * The ciphers member of ssl_context and the cipher member\n     of ssl_session have been renamed to ciphersuites and\n     ciphersuite respectively. This clarifies the difference\n     with the generic cipher layer and is better naming\n     altogether\n\n= Version 0.14.0 released on 2010-08-16\nFeatures\n   * Added support for SSL_EDH_RSA_AES_128_SHA and\n     SSL_EDH_RSA_CAMELLIA_128_SHA ciphersuites\n   * Added compile-time and run-time version information\n   * Expanded ssl_client2 arguments for more flexibility\n   * Added support for TLS v1.1\n\nChanges\n   * Made Makefile cleaner\n   * Removed dependency on rand() in rsa_pkcs1_encrypt().\n     Now using random fuction provided to function and\n     changed the prototype of rsa_pkcs1_encrypt(),\n     rsa_init() and rsa_gen_key().\n   * Some SSL defines were renamed in order to avoid\n     future confusion\n\nBug fixes\n   * Fixed CMake out of source build for tests (found by\n     kkert)\n   * rsa_check_private() now supports PKCS1v2 keys as well\n   * Fixed deadlock in rsa_pkcs1_encrypt() on failing random\n     generator\n\n= Version 0.13.1 released on 2010-03-24\nBug fixes\n   * Fixed Makefile in library that was mistakenly merged\n   * Added missing const string fixes\n\n= Version 0.13.0 released on 2010-03-21\nFeatures\n   * Added option parsing for host and port selection to\n     ssl_client2\n   * Added support for GeneralizedTime in X509 parsing\n   * Added cert_app program to allow easy reading and\n     printing of X509 certificates from file or SSL\n     connection.\n\nChanges\n   * Added const correctness for main code base\n   * X509 signature algorithm determination is now\n     in a function to allow easy future expansion\n   * Changed symmetric cipher functions to\n     identical interface (returning int result values)\n   * Changed ARC4 to use seperate input/output buffer\n   * Added reset function for HMAC context as speed-up\n     for specific use-cases\n\nBug fixes\n   * Fixed bug resulting in failure to send the last\n     certificate in the chain in ssl_write_certificate() and\n     ssl_write_certificate_request() (found by fatbob)\n   * Added small fixes for compiler warnings on a Mac\n     (found by Frank de Brabander)\n   * Fixed algorithmic bug in mpi_is_prime() (found by\n     Smbat Tonoyan)\n\n= Version 0.12.1 released on 2009-10-04\nChanges\n   * Coverage test definitions now support 'depends_on'\n     tagging system.\n   * Tests requiring specific hashing algorithms now honor\n     the defines.\n\nBug fixes\n   * Changed typo in #ifdef in x509parse.c (found\n     by Eduardo)\n\n= Version 0.12.0 released on 2009-07-28\nFeatures\n   * Added CMake makefiles as alternative to regular Makefiles.\n   * Added preliminary Code Coverage tests for AES, ARC4,\n     Base64, MPI, SHA-family, MD-family, HMAC-SHA-family,\n     Camellia, DES, 3-DES, RSA PKCS#1, XTEA, Diffie-Hellman\n     and X509parse.\n\nChanges\n   * Error codes are not (necessarily) negative. Keep\n     this is mind when checking for errors.\n   * RSA_RAW renamed to SIG_RSA_RAW for consistency.\n   * Fixed typo in name of POLARSSL_ERR_RSA_OUTPUT_TOO_LARGE.\n   * Changed interface for AES and Camellia setkey functions\n     to indicate invalid key lengths.\n\nBug fixes\n   * Fixed include location of endian.h on FreeBSD (found by\n     Gabriel)\n   * Fixed include location of endian.h and name clash on\n     Apples (found by Martin van Hensbergen)\n   * Fixed HMAC-MD2 by modifying md2_starts(), so that the\n     required HMAC ipad and opad variables are not cleared.\n     (found by code coverage tests)\n   * Prevented use of long long in bignum if \n     POLARSSL_HAVE_LONGLONG not defined (found by Giles\n     Bathgate).\n   * Fixed incorrect handling of negative strings in\n     mpi_read_string() (found by code coverage tests).\n   * Fixed segfault on handling empty rsa_context in\n     rsa_check_pubkey() and rsa_check_privkey() (found by\n     code coverage tests).\n   * Fixed incorrect handling of one single negative input\n     value in mpi_add_abs() (found by code coverage tests).\n   * Fixed incorrect handling of negative first input\n     value in mpi_sub_abs() (found by code coverage tests).\n   * Fixed incorrect handling of negative first input\n     value in mpi_mod_mpi() and mpi_mod_int(). Resulting\n     change also affects mpi_write_string() (found by code\n     coverage tests).\n   * Corrected is_prime() results for 0, 1 and 2 (found by\n     code coverage tests).\n   * Fixed Camellia and XTEA for 64-bit Windows systems.\n\n= Version 0.11.1 released on 2009-05-17\n   * Fixed missing functionality for SHA-224, SHA-256, SHA384,\n     SHA-512 in rsa_pkcs1_sign()\n\n= Version 0.11.0 released on 2009-05-03\n   * Fixed a bug in mpi_gcd() so that it also works when both\n     input numbers are even and added testcases to check\n     (found by Pierre Habouzit).\n   * Added support for SHA-224, SHA-256, SHA-384 and SHA-512\n     one way hash functions with the PKCS#1 v1.5 signing and\n     verification.\n   * Fixed minor bug regarding mpi_gcd located within the\n     POLARSSL_GENPRIME block.\n   * Fixed minor memory leak in x509parse_crt() and added better\n     handling of 'full' certificate chains (found by Mathias\n     Olsson).\n   * Centralized file opening and reading for x509 files into\n     load_file()\n   * Made definition of net_htons() endian-clean for big endian\n     systems (Found by Gernot).\n   * Undefining POLARSSL_HAVE_ASM now also handles prevents asm in\n     padlock and timing code. \n   * Fixed an off-by-one buffer allocation in ssl_set_hostname()\n     responsible for crashes and unwanted behaviour.\n   * Added support for Certificate Revocation List (CRL) parsing.\n   * Added support for CRL revocation to x509parse_verify() and\n     SSL/TLS code.\n   * Fixed compatibility of XTEA and Camellia on a 64-bit system\n     (found by Felix von Leitner).\n\n= Version 0.10.0 released on 2009-01-12\n   * Migrated XySSL to PolarSSL\n   * Added XTEA symmetric cipher\n   * Added Camellia symmetric cipher\n   * Added support for ciphersuites: SSL_RSA_CAMELLIA_128_SHA,\n     SSL_RSA_CAMELLIA_256_SHA and SSL_EDH_RSA_CAMELLIA_256_SHA\n   * Fixed dangerous bug that can cause a heap overflow in\n     rsa_pkcs1_decrypt (found by Christophe Devine)\n\n================================================================\nXySSL ChangeLog\n\n= Version 0.9 released on 2008-03-16\n\n    * Added support for ciphersuite: SSL_RSA_AES_128_SHA\n    * Enabled support for large files by default in aescrypt2.c\n    * Preliminary openssl wrapper contributed by David Barrett\n    * Fixed a bug in ssl_write() that caused the same payload to\n      be sent twice in non-blocking mode when send returns EAGAIN\n    * Fixed ssl_parse_client_hello(): session id and challenge must\n      not be swapped in the SSLv2 ClientHello (found by Greg Robson)\n    * Added user-defined callback debug function (Krystian Kolodziej)\n    * Before freeing a certificate, properly zero out all cert. data\n    * Fixed the \"mode\" parameter so that encryption/decryption are\n      not swapped on PadLock; also fixed compilation on older versions\n      of gcc (bug reported by David Barrett)\n    * Correctly handle the case in padlock_xcryptcbc() when input or\n      ouput data is non-aligned by falling back to the software\n      implementation, as VIA Nehemiah cannot handle non-aligned buffers\n    * Fixed a memory leak in x509parse_crt() which was reported by Greg\n      Robson-Garth; some x509write.c fixes by Pascal Vizeli, thanks to\n      Matthew Page who reported several bugs\n    * Fixed x509_get_ext() to accept some rare certificates which have\n      an INTEGER instead of a BOOLEAN for BasicConstraints::cA.\n    * Added support on the client side for the TLS \"hostname\" extension\n      (patch contributed by David Patino)\n    * Make x509parse_verify() return BADCERT_CN_MISMATCH when an empty\n      string is passed as the CN (bug reported by spoofy)\n    * Added an option to enable/disable the BN assembly code\n    * Updated rsa_check_privkey() to verify that (D*E) = 1 % (P-1)*(Q-1)\n    * Disabled obsolete hash functions by default (MD2, MD4); updated\n      selftest and benchmark to not test ciphers that have been disabled\n    * Updated x509parse_cert_info() to correctly display byte 0 of the\n      serial number, setup correct server port in the ssl client example\n    * Fixed a critical denial-of-service with X.509 cert. verification:\n      peer may cause xyssl to loop indefinitely by sending a certificate\n      for which the RSA signature check fails (bug reported by Benoit)\n    * Added test vectors for: AES-CBC, AES-CFB, DES-CBC and 3DES-CBC,\n      HMAC-MD5, HMAC-SHA1, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\n    * Fixed HMAC-SHA-384 and HMAC-SHA-512 (thanks to Josh Sinykin)\n    * Modified ssl_parse_client_key_exchange() to protect against\n      Daniel Bleichenbacher attack on PKCS#1 v1.5 padding, as well\n      as the Klima-Pokorny-Rosa extension of Bleichenbacher's attack\n    * Updated rsa_gen_key() so that ctx->N is always nbits in size\n    * Fixed assembly PPC compilation errors on Mac OS X, thanks to\n      David Barrett and Dusan Semen\n\n= Version 0.8 released on 2007-10-20\n\n    * Modified the HMAC functions to handle keys larger\n      than 64 bytes, thanks to Stephane Desneux and gary ng\n    * Fixed ssl_read_record() to properly update the handshake\n      message digests, which fixes IE6/IE7 client authentication\n    * Cleaned up the XYSSL* #defines, suggested by Azriel Fasten\n    * Fixed net_recv(), thanks to Lorenz Schori and Egon Kocjan\n    * Added user-defined callbacks for handling I/O and sessions\n    * Added lots of debugging output in the SSL/TLS functions\n    * Added preliminary X.509 cert. writing by Pascal Vizeli\n    * Added preliminary support for the VIA PadLock routines\n    * Added AES-CFB mode of operation, contributed by chmike\n    * Added an SSL/TLS stress testing program (ssl_test.c)\n    * Updated the RSA PKCS#1 code to allow choosing between\n      RSA_PUBLIC and RSA_PRIVATE, as suggested by David Barrett\n    * Updated ssl_read() to skip 0-length records from OpenSSL\n    * Fixed the make install target to comply with *BSD make\n    * Fixed a bug in mpi_read_binary() on 64-bit platforms\n    * mpi_is_prime() speedups, thanks to Kevin McLaughlin\n    * Fixed a long standing memory leak in mpi_is_prime()\n    * Replaced realloc with malloc in mpi_grow(), and set\n      the sign of zero as positive in mpi_init() (reported\n      by Jonathan M. McCune)\n\n= Version 0.7 released on 2007-07-07\n\n    * Added support for the MicroBlaze soft-core processor\n    * Fixed a bug in ssl_tls.c which sometimes prevented SSL\n      connections from being established with non-blocking I/O\n    * Fixed a couple bugs in the VS6 and UNIX Makefiles\n    * Fixed the \"PIC register ebx clobbered in asm\" bug\n    * Added HMAC starts/update/finish support functions\n    * Added the SHA-224, SHA-384 and SHA-512 hash functions\n    * Fixed the net_set_*block routines, thanks to Andreas\n    * Added a few demonstration programs: md5sum, sha1sum,\n      dh_client, dh_server, rsa_genkey, rsa_sign, rsa_verify\n    * Added new bignum import and export helper functions\n    * Rewrote README.txt in program/ssl/ca to better explain\n      how to create a test PKI\n\n= Version 0.6 released on 2007-04-01\n\n    * Ciphers used in SSL/TLS can now be disabled at compile\n      time, to reduce the memory footprint on embedded systems\n    * Added multiply assembly code for the TriCore and modified\n      havege_struct for this processor, thanks to David Pati\u00f1o\n    * Added multiply assembly code for 64-bit PowerPCs,\n      thanks to Peking University and the OSU Open Source Lab\n    * Added experimental support of Quantum Cryptography\n    * Added support for autoconf, contributed by Arnaud Cornet\n    * Fixed \"long long\" compilation issues on IA-64 and PPC64\n    * Fixed a bug introduced in xyssl-0.5/timing.c: hardclock\n      was not being correctly defined on ARM and MIPS\n\n= Version 0.5 released on 2007-03-01\n\n    * Added multiply assembly code for SPARC and Alpha\n    * Added (beta) support for non-blocking I/O operations\n    * Implemented session resuming and client authentication\n    * Fixed some portability issues on WinCE, MINIX 3, Plan9\n      (thanks to Benjamin Newman), HP-UX, FreeBSD and Solaris\n    * Improved the performance of the EDH key exchange\n    * Fixed a bug that caused valid packets with a payload\n      size of 16384 bytes to be rejected\n\n= Version 0.4 released on 2007-02-01\n\n    * Added support for Ephemeral Diffie-Hellman key exchange\n    * Added multiply asm code for SSE2, ARM, PPC, MIPS and M68K\n    * Various improvement to the modular exponentiation code\n    * Rewrote the headers to generate the API docs with doxygen\n    * Fixed a bug in ssl_encrypt_buf (incorrect padding was\n      generated) and in ssl_parse_client_hello (max. client\n      version was not properly set), thanks to Didier Rebeix\n    * Fixed another bug in ssl_parse_client_hello: clients with\n      cipherlists larger than 96 bytes were incorrectly rejected\n    * Fixed a couple memory leak in x509_read.c\n\n= Version 0.3 released on 2007-01-01\n\n    * Added server-side SSLv3 and TLSv1.0 support\n    * Multiple fixes to enhance the compatibility with g++,\n      thanks to Xos\u00e9 Ant\u00f3n Otero Ferreira\n    * Fixed a bug in the CBC code, thanks to dowst; also,\n      the bignum code is no longer dependant on long long\n    * Updated rsa_pkcs1_sign to handle arbitrary large inputs\n    * Updated timing.c for improved compatibility with i386\n      and 486 processors, thanks to Arnaud Cornet\n\n= Version 0.2 released on 2006-12-01\n\n    * Updated timing.c to support ARM and MIPS arch\n    * Updated the MPI code to support 8086 on MSVC 1.5\n    * Added the copyright notice at the top of havege.h\n    * Fixed a bug in sha2_hmac, thanks to newsoft/Wenfang Zhang\n    * Fixed a bug reported by Adrian R\u00fcegsegger in x509_read_key\n    * Fixed a bug reported by Torsten Lauter in ssl_read_record\n    * Fixed a bug in rsa_check_privkey that would wrongly cause\n      valid RSA keys to be dismissed (thanks to oldwolf)\n    * Fixed a bug in mpi_is_prime that caused some primes to fail\n      the Miller-Rabin primality test\n\n    I'd also like to thank Youn\u00e8s Hafri for the CRUX linux port,\n    Khalil Petit who added XySSL into pkgsrc and Arnaud Cornet\n    who maintains the Debian package :-)\n\n= Version 0.1 released on 2006-11-01\n\n", "/**\n * \\file x509.h\n *\n * \\brief X.509 certificate and private key decoding\n *\n *  Copyright (C) 2006-2011, Brainspark B.V.\n *\n *  This file is part of PolarSSL (http://www.polarssl.org)\n *  Lead Maintainer: Paul Bakker <polarssl_maintainer at polarssl.org>\n *\n *  All rights reserved.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#ifndef POLARSSL_X509_H\n#define POLARSSL_X509_H\n\n#include \"asn1.h\"\n#include \"rsa.h\"\n#include \"dhm.h\"\n\n/** \n * \\addtogroup x509_module\n * \\{ \n */\n \n/** \n * \\name X509 Error codes\n * \\{\n */\n#define POLARSSL_ERR_X509_FEATURE_UNAVAILABLE              -0x2080  /**< Unavailable feature, e.g. RSA hashing/encryption combination. */\n#define POLARSSL_ERR_X509_CERT_INVALID_PEM                 -0x2100  /**< The PEM-encoded certificate contains invalid elements, e.g. invalid character. */ \n#define POLARSSL_ERR_X509_CERT_INVALID_FORMAT              -0x2180  /**< The certificate format is invalid, e.g. different type expected. */\n#define POLARSSL_ERR_X509_CERT_INVALID_VERSION             -0x2200  /**< The certificate version element is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_SERIAL              -0x2280  /**< The serial tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_ALG                 -0x2300  /**< The algorithm tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_NAME                -0x2380  /**< The name tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_DATE                -0x2400  /**< The date tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_PUBKEY              -0x2480  /**< The pubkey tag or value is invalid (only RSA is supported). */\n#define POLARSSL_ERR_X509_CERT_INVALID_SIGNATURE           -0x2500  /**< The signature tag or value invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_EXTENSIONS          -0x2580  /**< The extension tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_UNKNOWN_VERSION             -0x2600  /**< Certificate or CRL has an unsupported version number. */\n#define POLARSSL_ERR_X509_CERT_UNKNOWN_SIG_ALG             -0x2680  /**< Signature algorithm (oid) is unsupported. */\n#define POLARSSL_ERR_X509_UNKNOWN_PK_ALG                   -0x2700  /**< Key algorithm is unsupported (only RSA is supported). */\n#define POLARSSL_ERR_X509_CERT_SIG_MISMATCH                -0x2780  /**< Certificate signature algorithms do not match. (see \\c ::x509_cert sig_oid) */\n#define POLARSSL_ERR_X509_CERT_VERIFY_FAILED               -0x2800  /**< Certificate verification failed, e.g. CRL, CA or signature check failed. */\n#define POLARSSL_ERR_X509_KEY_INVALID_VERSION              -0x2880  /**< Unsupported RSA key version */\n#define POLARSSL_ERR_X509_KEY_INVALID_FORMAT               -0x2900  /**< Invalid RSA key tag or value. */\n#define POLARSSL_ERR_X509_CERT_UNKNOWN_FORMAT              -0x2980  /**< Format not recognized as DER or PEM. */\n#define POLARSSL_ERR_X509_INVALID_INPUT                    -0x2A00  /**< Input invalid. */\n#define POLARSSL_ERR_X509_MALLOC_FAILED                    -0x2A80  /**< Allocation of memory failed. */\n#define POLARSSL_ERR_X509_FILE_IO_ERROR                    -0x2B00  /**< Read/write of file failed. */\n/* \\} name */\n\n\n/**\n * \\name X509 Verify codes\n * \\{\n */\n#define BADCERT_EXPIRED             0x01  /**< The certificate validity has expired. */\n#define BADCERT_REVOKED             0x02  /**< The certificate has been revoked (is on a CRL). */\n#define BADCERT_CN_MISMATCH         0x04  /**< The certificate Common Name (CN) does not match with the expected CN. */\n#define BADCERT_NOT_TRUSTED         0x08  /**< The certificate is not correctly signed by the trusted CA. */\n#define BADCRL_NOT_TRUSTED          0x10  /**< CRL is not correctly signed by the trusted CA. */\n#define BADCRL_EXPIRED              0x20  /**< CRL is expired. */\n#define BADCERT_MISSING             0x40  /**< Certificate was missing. */\n#define BADCERT_SKIP_VERIFY         0x80  /**< Certificate verification was skipped. */\n#define BADCERT_OTHER             0x0100  /**< Other reason (can be used by verify callback) */\n/* \\} name */\n/* \\} addtogroup x509_module */\n\n/*\n * various object identifiers\n */\n#define X520_COMMON_NAME                3\n#define X520_COUNTRY                    6\n#define X520_LOCALITY                   7\n#define X520_STATE                      8\n#define X520_ORGANIZATION              10\n#define X520_ORG_UNIT                  11\n#define PKCS9_EMAIL                     1\n\n#define X509_OUTPUT_DER              0x01\n#define X509_OUTPUT_PEM              0x02\n#define PEM_LINE_LENGTH                72\n#define X509_ISSUER                  0x01\n#define X509_SUBJECT                 0x02\n\n#define OID_X520                \"\\x55\\x04\"\n#define OID_CN                  OID_X520 \"\\x03\"\n#define OID_COUNTRY             OID_X520 \"\\x06\"\n#define OID_LOCALITY            OID_X520 \"\\x07\"\n#define OID_STATE               OID_X520 \"\\x08\"\n#define OID_ORGANIZATION        OID_X520 \"\\x0A\"\n#define OID_ORG_UNIT            OID_X520 \"\\x0B\"\n\n#define OID_PKCS1               \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x01\\x01\"\n#define OID_PKCS1_RSA           OID_PKCS1 \"\\x01\"\n#define OID_PKCS1_SHA1          OID_PKCS1 \"\\x05\"\n\n#define OID_RSA_SHA_OBS         \"\\x2B\\x0E\\x03\\x02\\x1D\"\n\n#define OID_PKCS9               \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x01\\x09\"\n#define OID_PKCS9_EMAIL         OID_PKCS9 \"\\x01\"\n\n/** ISO arc for standard certificate and CRL extensions */\n#define OID_ID_CE               \"\\x55\\x1D\" /**< id-ce OBJECT IDENTIFIER  ::=  {joint-iso-ccitt(2) ds(5) 29} */\n\n/**\n * Private Internet Extensions\n * { iso(1) identified-organization(3) dod(6) internet(1)\n *                      security(5) mechanisms(5) pkix(7) }\n */\n#define OID_PKIX                \"\\x2B\\x06\\x01\\x05\\x05\\x07\"\n\n/*\n * OIDs for standard certificate extensions\n */\n#define OID_AUTHORITY_KEY_IDENTIFIER    OID_ID_CE \"\\x23\" /**< id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 } */\n#define OID_SUBJECT_KEY_IDENTIFIER      OID_ID_CE \"\\x0E\" /**< id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 14 } */\n#define OID_KEY_USAGE                   OID_ID_CE \"\\x0F\" /**< id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 } */\n#define OID_CERTIFICATE_POLICIES        OID_ID_CE \"\\x20\" /**< id-ce-certificatePolicies OBJECT IDENTIFIER ::=  { id-ce 32 } */\n#define OID_POLICY_MAPPINGS             OID_ID_CE \"\\x21\" /**< id-ce-policyMappings OBJECT IDENTIFIER ::=  { id-ce 33 } */\n#define OID_SUBJECT_ALT_NAME            OID_ID_CE \"\\x11\" /**< id-ce-subjectAltName OBJECT IDENTIFIER ::=  { id-ce 17 } */\n#define OID_ISSUER_ALT_NAME             OID_ID_CE \"\\x12\" /**< id-ce-issuerAltName OBJECT IDENTIFIER ::=  { id-ce 18 } */\n#define OID_SUBJECT_DIRECTORY_ATTRS     OID_ID_CE \"\\x09\" /**< id-ce-subjectDirectoryAttributes OBJECT IDENTIFIER ::=  { id-ce 9 } */\n#define OID_BASIC_CONSTRAINTS           OID_ID_CE \"\\x13\" /**< id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 } */\n#define OID_NAME_CONSTRAINTS            OID_ID_CE \"\\x1E\" /**< id-ce-nameConstraints OBJECT IDENTIFIER ::=  { id-ce 30 } */\n#define OID_POLICY_CONSTRAINTS          OID_ID_CE \"\\x24\" /**< id-ce-policyConstraints OBJECT IDENTIFIER ::=  { id-ce 36 } */\n#define OID_EXTENDED_KEY_USAGE          OID_ID_CE \"\\x25\" /**< id-ce-extKeyUsage OBJECT IDENTIFIER ::= { id-ce 37 } */\n#define OID_CRL_DISTRIBUTION_POINTS     OID_ID_CE \"\\x1F\" /**< id-ce-cRLDistributionPoints OBJECT IDENTIFIER ::=  { id-ce 31 } */\n#define OID_INIHIBIT_ANYPOLICY          OID_ID_CE \"\\x36\" /**< id-ce-inhibitAnyPolicy OBJECT IDENTIFIER ::=  { id-ce 54 } */\n#define OID_FRESHEST_CRL                OID_ID_CE \"\\x2E\" /**< id-ce-freshestCRL OBJECT IDENTIFIER ::=  { id-ce 46 } */\n\n/*\n * X.509 v3 Key Usage Extension flags\n */\n#define KU_DIGITAL_SIGNATURE            (0x80)  /* bit 0 */\n#define KU_NON_REPUDIATION              (0x40)  /* bit 1 */\n#define KU_KEY_ENCIPHERMENT             (0x20)  /* bit 2 */\n#define KU_DATA_ENCIPHERMENT            (0x10)  /* bit 3 */\n#define KU_KEY_AGREEMENT                (0x08)  /* bit 4 */\n#define KU_KEY_CERT_SIGN                (0x04)  /* bit 5 */\n#define KU_CRL_SIGN                     (0x02)  /* bit 6 */\n\n/*\n * X.509 v3 Extended key usage OIDs\n */\n#define OID_ANY_EXTENDED_KEY_USAGE      OID_EXTENDED_KEY_USAGE \"\\x00\" /**< anyExtendedKeyUsage OBJECT IDENTIFIER ::= { id-ce-extKeyUsage 0 } */\n\n#define OID_KP                          OID_PKIX \"\\x03\" /**< id-kp OBJECT IDENTIFIER ::= { id-pkix 3 } */\n#define OID_SERVER_AUTH                 OID_KP \"\\x01\" /**< id-kp-serverAuth OBJECT IDENTIFIER ::= { id-kp 1 } */\n#define OID_CLIENT_AUTH                 OID_KP \"\\x02\" /**< id-kp-clientAuth OBJECT IDENTIFIER ::= { id-kp 2 } */\n#define OID_CODE_SIGNING                OID_KP \"\\x03\" /**< id-kp-codeSigning OBJECT IDENTIFIER ::= { id-kp 3 } */\n#define OID_EMAIL_PROTECTION            OID_KP \"\\x04\" /**< id-kp-emailProtection OBJECT IDENTIFIER ::= { id-kp 4 } */\n#define OID_TIME_STAMPING               OID_KP \"\\x08\" /**< id-kp-timeStamping OBJECT IDENTIFIER ::= { id-kp 8 } */\n#define OID_OCSP_SIGNING                OID_KP \"\\x09\" /**< id-kp-OCSPSigning OBJECT IDENTIFIER ::= { id-kp 9 } */\n\n#define STRING_SERVER_AUTH              \"TLS Web Server Authentication\"\n#define STRING_CLIENT_AUTH              \"TLS Web Client Authentication\"\n#define STRING_CODE_SIGNING             \"Code Signing\"\n#define STRING_EMAIL_PROTECTION         \"E-mail Protection\"\n#define STRING_TIME_STAMPING            \"Time Stamping\"\n#define STRING_OCSP_SIGNING             \"OCSP Signing\"\n\n/*\n * OIDs for CRL extensions\n */\n#define OID_PRIVATE_KEY_USAGE_PERIOD    OID_ID_CE \"\\x10\"\n#define OID_CRL_NUMBER                  OID_ID_CE \"\\x14\" /**< id-ce-cRLNumber OBJECT IDENTIFIER ::= { id-ce 20 } */\n\n/*\n * Netscape certificate extensions\n */\n#define OID_NETSCAPE                \"\\x60\\x86\\x48\\x01\\x86\\xF8\\x42\" /**< Netscape OID */\n#define OID_NS_CERT                 OID_NETSCAPE \"\\x01\"\n#define OID_NS_CERT_TYPE            OID_NS_CERT  \"\\x01\"\n#define OID_NS_BASE_URL             OID_NS_CERT  \"\\x02\"\n#define OID_NS_REVOCATION_URL       OID_NS_CERT  \"\\x03\"\n#define OID_NS_CA_REVOCATION_URL    OID_NS_CERT  \"\\x04\"\n#define OID_NS_RENEWAL_URL          OID_NS_CERT  \"\\x07\"\n#define OID_NS_CA_POLICY_URL        OID_NS_CERT  \"\\x08\"\n#define OID_NS_SSL_SERVER_NAME      OID_NS_CERT  \"\\x0C\"\n#define OID_NS_COMMENT              OID_NS_CERT  \"\\x0D\"\n#define OID_NS_DATA_TYPE            OID_NETSCAPE \"\\x02\"\n#define OID_NS_CERT_SEQUENCE        OID_NS_DATA_TYPE \"\\x05\"\n\n/*\n * Netscape certificate types\n * (http://www.mozilla.org/projects/security/pki/nss/tech-notes/tn3.html)\n */\n\n#define NS_CERT_TYPE_SSL_CLIENT         (0x80)  /* bit 0 */\n#define NS_CERT_TYPE_SSL_SERVER         (0x40)  /* bit 1 */\n#define NS_CERT_TYPE_EMAIL              (0x20)  /* bit 2 */\n#define NS_CERT_TYPE_OBJECT_SIGNING     (0x10)  /* bit 3 */\n#define NS_CERT_TYPE_RESERVED           (0x08)  /* bit 4 */\n#define NS_CERT_TYPE_SSL_CA             (0x04)  /* bit 5 */\n#define NS_CERT_TYPE_EMAIL_CA           (0x02)  /* bit 6 */\n#define NS_CERT_TYPE_OBJECT_SIGNING_CA  (0x01)  /* bit 7 */\n\n#define EXT_AUTHORITY_KEY_IDENTIFIER    (1 << 0)\n#define EXT_SUBJECT_KEY_IDENTIFIER      (1 << 1)\n#define EXT_KEY_USAGE                   (1 << 2)\n#define EXT_CERTIFICATE_POLICIES        (1 << 3)\n#define EXT_POLICY_MAPPINGS             (1 << 4)\n#define EXT_SUBJECT_ALT_NAME            (1 << 5)\n#define EXT_ISSUER_ALT_NAME             (1 << 6)\n#define EXT_SUBJECT_DIRECTORY_ATTRS     (1 << 7)\n#define EXT_BASIC_CONSTRAINTS           (1 << 8)\n#define EXT_NAME_CONSTRAINTS            (1 << 9)\n#define EXT_POLICY_CONSTRAINTS          (1 << 10)\n#define EXT_EXTENDED_KEY_USAGE          (1 << 11)\n#define EXT_CRL_DISTRIBUTION_POINTS     (1 << 12)\n#define EXT_INIHIBIT_ANYPOLICY          (1 << 13)\n#define EXT_FRESHEST_CRL                (1 << 14)\n\n#define EXT_NS_CERT_TYPE                (1 << 16)\n\n/*\n * Storage format identifiers\n * Recognized formats: PEM and DER\n */\n#define X509_FORMAT_DER                 1\n#define X509_FORMAT_PEM                 2\n\n/** \n * \\addtogroup x509_module\n * \\{ */\n\n/**\n * \\name Structures for parsing X.509 certificates and CRLs\n * \\{\n */\n \n/** \n * Type-length-value structure that allows for ASN1 using DER.\n */\ntypedef asn1_buf x509_buf;\n\n/**\n * Container for ASN1 bit strings.\n */\ntypedef asn1_bitstring x509_bitstring;\n\n/**\n * Container for ASN1 named information objects. \n * It allows for Relative Distinguished Names (e.g. cn=polarssl,ou=code,etc.).\n */\ntypedef struct _x509_name\n{\n    x509_buf oid;               /**< The object identifier. */\n    x509_buf val;               /**< The named value. */\n    struct _x509_name *next;    /**< The next named information object. */\n}\nx509_name;\n\n/**\n * Container for a sequence of ASN.1 items\n */\ntypedef asn1_sequence x509_sequence;\n\n/** Container for date and time (precision in seconds). */\ntypedef struct _x509_time\n{\n    int year, mon, day;         /**< Date. */\n    int hour, min, sec;         /**< Time. */\n}\nx509_time;\n\n/** \n * Container for an X.509 certificate. The certificate may be chained.\n */\ntypedef struct _x509_cert\n{\n    x509_buf raw;               /**< The raw certificate data (DER). */\n    x509_buf tbs;               /**< The raw certificate body (DER). The part that is To Be Signed. */\n\n    int version;                /**< The X.509 version. (0=v1, 1=v2, 2=v3) */\n    x509_buf serial;            /**< Unique id for certificate issued by a specific CA. */\n    x509_buf sig_oid1;          /**< Signature algorithm, e.g. sha1RSA */\n\n    x509_buf issuer_raw;        /**< The raw issuer data (DER). Used for quick comparison. */\n    x509_buf subject_raw;       /**< The raw subject data (DER). Used for quick comparison. */\n\n    x509_name issuer;           /**< The parsed issuer data (named information object). */\n    x509_name subject;          /**< The parsed subject data (named information object). */\n\n    x509_time valid_from;       /**< Start time of certificate validity. */\n    x509_time valid_to;         /**< End time of certificate validity. */\n\n    x509_buf pk_oid;            /**< Subject public key info. Includes the public key algorithm and the key itself. */\n    rsa_context rsa;            /**< Container for the RSA context. Only RSA is supported for public keys at this time. */\n\n    x509_buf issuer_id;         /**< Optional X.509 v2/v3 issuer unique identifier. */\n    x509_buf subject_id;        /**< Optional X.509 v2/v3 subject unique identifier. */\n    x509_buf v3_ext;            /**< Optional X.509 v3 extensions. Only Basic Contraints are supported at this time. */\n    x509_sequence subject_alt_names;    /**< Optional list of Subject Alternative Names (Only dNSName supported). */\n\n    int ext_types;              /**< Bit string containing detected and parsed extensions */\n    int ca_istrue;              /**< Optional Basic Constraint extension value: 1 if this certificate belongs to a CA, 0 otherwise. */\n    int max_pathlen;            /**< Optional Basic Constraint extension value: The maximum path length to the root certificate. Path length is 1 higher than RFC 5280 'meaning', so 1+ */\n\n    unsigned char key_usage;    /**< Optional key usage extension value: See the values below */\n\n    x509_sequence ext_key_usage; /**< Optional list of extended key usage OIDs. */\n\n    unsigned char ns_cert_type; /**< Optional Netscape certificate type extension value: See the values below */\n\n    x509_buf sig_oid2;          /**< Signature algorithm. Must match sig_oid1. */\n    x509_buf sig;               /**< Signature: hash of the tbs part signed with the private key. */\n    int sig_alg;                /**< Internal representation of the signature algorithm, e.g. SIG_RSA_MD2 */\n\n    struct _x509_cert *next;    /**< Next certificate in the CA-chain. */ \n}\nx509_cert;\n\n/** \n * Certificate revocation list entry. \n * Contains the CA-specific serial numbers and revocation dates.\n */\ntypedef struct _x509_crl_entry\n{\n    x509_buf raw;\n\n    x509_buf serial;\n\n    x509_time revocation_date;\n\n    x509_buf entry_ext;\n\n    struct _x509_crl_entry *next;\n}\nx509_crl_entry;\n\n/** \n * Certificate revocation list structure. \n * Every CRL may have multiple entries.\n */\ntypedef struct _x509_crl\n{\n    x509_buf raw;           /**< The raw certificate data (DER). */\n    x509_buf tbs;           /**< The raw certificate body (DER). The part that is To Be Signed. */\n\n    int version;\n    x509_buf sig_oid1;\n\n    x509_buf issuer_raw;    /**< The raw issuer data (DER). */\n\n    x509_name issuer;       /**< The parsed issuer data (named information object). */\n\n    x509_time this_update;  \n    x509_time next_update;\n\n    x509_crl_entry entry;   /**< The CRL entries containing the certificate revocation times for this CA. */\n\n    x509_buf crl_ext;\n\n    x509_buf sig_oid2;\n    x509_buf sig;\n    int sig_alg;\n\n    struct _x509_crl *next; \n}\nx509_crl;\n/** \\} name Structures for parsing X.509 certificates and CRLs */\n/** \\} addtogroup x509_module */\n\n/**\n * \\name Structures for writing X.509 certificates.\n * XvP: commented out as they are not used.\n * - <tt>typedef struct _x509_node x509_node;</tt>\n * - <tt>typedef struct _x509_raw x509_raw;</tt>\n */\n/*\ntypedef struct _x509_node\n{\n    unsigned char *data;\n    unsigned char *p;\n    unsigned char *end;\n\n    size_t len;\n}\nx509_node;\n\ntypedef struct _x509_raw\n{\n    x509_node raw;\n    x509_node tbs;\n\n    x509_node version;\n    x509_node serial;\n    x509_node tbs_signalg;\n    x509_node issuer;\n    x509_node validity;\n    x509_node subject;\n    x509_node subpubkey;\n\n    x509_node signalg;\n    x509_node sign;\n}\nx509_raw;\n*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\name Functions to read in DHM parameters, a certificate, CRL or private RSA key\n * \\{\n */\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse one or more certificates and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the certificate data\n * \\param buflen   size of the buffer\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint x509parse_crt( x509_cert *chain, const unsigned char *buf, size_t buflen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load one or more certificates and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param path     filename to read the certificates from\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint x509parse_crtfile( x509_cert *chain, const char *path );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load one or more certificate files from a path and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param path     directory / folder to read the certificate files from\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint x509parse_crtpath( x509_cert *chain, const char *path );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse one or more CRLs and add them\n *                 to the chained list\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the CRL data\n * \\param buflen   size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_crl( x509_crl *chain, const unsigned char *buf, size_t buflen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load one or more CRLs and add them\n *                 to the chained list\n *\n * \\param chain    points to the start of the chain\n * \\param path     filename to read the CRLs from\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_crlfile( x509_crl *chain, const char *path );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse a private RSA key\n *\n * \\param rsa      RSA context to be initialized\n * \\param key      input buffer\n * \\param keylen   size of the buffer\n * \\param pwd      password for decryption (optional)\n * \\param pwdlen   size of the password\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_key( rsa_context *rsa,\n                   const unsigned char *key, size_t keylen,\n                   const unsigned char *pwd, size_t pwdlen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load and parse a private RSA key\n *\n * \\param rsa      RSA context to be initialized\n * \\param path     filename to read the private key from\n * \\param password password to decrypt the file (can be NULL)\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_keyfile( rsa_context *rsa, const char *path,\n                       const char *password );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse a public RSA key\n *\n * \\param rsa      RSA context to be initialized\n * \\param key      input buffer\n * \\param keylen   size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_public_key( rsa_context *rsa,\n                   const unsigned char *key, size_t keylen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load and parse a public RSA key\n *\n * \\param rsa      RSA context to be initialized\n * \\param path     filename to read the private key from\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_public_keyfile( rsa_context *rsa, const char *path );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse DHM parameters\n *\n * \\param dhm      DHM context to be initialized\n * \\param dhmin    input buffer\n * \\param dhminlen size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_dhm( dhm_context *dhm, const unsigned char *dhmin, size_t dhminlen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load and parse DHM parameters\n *\n * \\param dhm      DHM context to be initialized\n * \\param path     filename to read the DHM Parameters from\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_dhmfile( dhm_context *dhm, const char *path );\n\n/** \\} name Functions to read in DHM parameters, a certificate, CRL or private RSA key */\n\n/**\n * \\brief          Store the certificate DN in printable form into buf;\n *                 no more than size characters will be written.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param dn       The X509 name to represent\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509parse_dn_gets( char *buf, size_t size, const x509_name *dn );\n\n/**\n * \\brief          Store the certificate serial in printable form into buf;\n *                 no more than size characters will be written.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param serial   The X509 serial to represent\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509parse_serial_gets( char *buf, size_t size, const x509_buf *serial );\n\n/**\n * \\brief          Returns an informational string about the\n *                 certificate.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param prefix   A line prefix\n * \\param crt      The X509 certificate to represent\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509parse_cert_info( char *buf, size_t size, const char *prefix,\n                         const x509_cert *crt );\n\n/**\n * \\brief          Returns an informational string about the\n *                 CRL.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param prefix   A line prefix\n * \\param crl      The X509 CRL to represent\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509parse_crl_info( char *buf, size_t size, const char *prefix,\n                        const x509_crl *crl );\n\n/**\n * \\brief          Give an known OID, return its descriptive string.\n *\n * \\param oid      buffer containing the oid\n *\n * \\return         Return a string if the OID is known,\n *                 or NULL otherwise.\n */\nconst char *x509_oid_get_description( x509_buf *oid );\n\n/**\n * \\brief          Give an OID, return a string version of its OID number.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param oid      Buffer containing the OID\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509_oid_get_numeric_string( char *buf, size_t size, x509_buf *oid );\n\n/**\n * \\brief          Check a given x509_time against the system time and check\n *                 if it is valid.\n *\n * \\param time     x509_time to check\n *\n * \\return         Return 0 if the x509_time is still valid,\n *                 or 1 otherwise.\n */\nint x509parse_time_expired( const x509_time *time );\n\n/**\n * \\name Functions to verify a certificate\n * \\{\n */\n/** \\ingroup x509_module */\n/**\n * \\brief          Verify the certificate signature\n *\n *                 The verify callback is a user-supplied callback that\n *                 can clear / modify / add flags for a certificate. If set,\n *                 the verification callback is called for each\n *                 certificate in the chain (from the trust-ca down to the\n *                 presented crt). The parameters for the callback are:\n *                 (void *parameter, x509_cert *crt, int certificate_depth,\n *                 int *flags). With the flags representing current flags for\n *                 that specific certificate and the certificate depth from\n *                 the bottom (Peer cert depth = 0).\n *\n *                 All flags left after returning from the callback\n *                 are also returned to the application. The function should\n *                 return 0 for anything but a fatal error.\n *\n * \\param crt      a certificate to be verified\n * \\param trust_ca the trusted CA chain\n * \\param ca_crl   the CRL chain for trusted CA's\n * \\param cn       expected Common Name (can be set to\n *                 NULL if the CN must not be verified)\n * \\param flags    result of the verification\n * \\param f_vrfy   verification function\n * \\param p_vrfy   verification parameter\n *\n * \\return         0 if successful or POLARSSL_ERR_X509_SIG_VERIFY_FAILED,\n *                 in which case *flags will have one or more of\n *                 the following values set:\n *                      BADCERT_EXPIRED --\n *                      BADCERT_REVOKED --\n *                      BADCERT_CN_MISMATCH --\n *                      BADCERT_NOT_TRUSTED\n *                 or another error in case of a fatal error encountered\n *                 during the verification process.\n */\nint x509parse_verify( x509_cert *crt,\n                      x509_cert *trust_ca,\n                      x509_crl *ca_crl,\n                      const char *cn, int *flags,\n                      int (*f_vrfy)(void *, x509_cert *, int, int *),\n                      void *p_vrfy );\n\n/**\n * \\brief          Verify the certificate signature\n *\n * \\param crt      a certificate to be verified\n * \\param crl      the CRL to verify against\n *\n * \\return         1 if the certificate is revoked, 0 otherwise\n *\n */\nint x509parse_revoked( const x509_cert *crt, const x509_crl *crl );\n\n/** \\} name Functions to verify a certificate */\n\n\n\n/**\n * \\name Functions to clear a certificate, CRL or private RSA key \n * \\{\n */\n/** \\ingroup x509_module */\n/**\n * \\brief          Unallocate all certificate data\n *\n * \\param crt      Certificate chain to free\n */\nvoid x509_free( x509_cert *crt );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Unallocate all CRL data\n *\n * \\param crl      CRL chain to free\n */\nvoid x509_crl_free( x509_crl *crl );\n\n/** \\} name Functions to clear a certificate, CRL or private RSA key */\n\n\n/**\n * \\brief          Checkup routine\n *\n * \\return         0 if successful, or 1 if the test failed\n */\nint x509_self_test( int verbose );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* x509.h */\n", "/*\n *  SSLv3/TLSv1 shared functions\n *\n *  Copyright (C) 2006-2012, Brainspark B.V.\n *\n *  This file is part of PolarSSL (http://www.polarssl.org)\n *  Lead Maintainer: Paul Bakker <polarssl_maintainer at polarssl.org>\n *\n *  All rights reserved.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n/*\n *  The SSL 3.0 specification was drafted by Netscape in 1996,\n *  and became an IETF standard in 1999.\n *\n *  http://wp.netscape.com/eng/ssl3/\n *  http://www.ietf.org/rfc/rfc2246.txt\n *  http://www.ietf.org/rfc/rfc4346.txt\n */\n\n#include \"polarssl/config.h\"\n\n#if defined(POLARSSL_SSL_TLS_C)\n\n#include \"polarssl/aes.h\"\n#include \"polarssl/arc4.h\"\n#include \"polarssl/camellia.h\"\n#include \"polarssl/des.h\"\n#include \"polarssl/debug.h\"\n#include \"polarssl/ssl.h\"\n#include \"polarssl/sha2.h\"\n\n#if defined(POLARSSL_GCM_C)\n#include \"polarssl/gcm.h\"\n#endif\n\n#include <stdlib.h>\n#include <time.h>\n\n#if defined _MSC_VER && !defined strcasecmp\n#define strcasecmp _stricmp\n#endif\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\nint (*ssl_hw_record_init)(ssl_context *ssl,\n                       const unsigned char *key_enc, const unsigned char *key_dec,\n                       const unsigned char *iv_enc,  const unsigned char *iv_dec,\n                       const unsigned char *mac_enc, const unsigned char *mac_dec) = NULL;\nint (*ssl_hw_record_reset)(ssl_context *ssl) = NULL;\nint (*ssl_hw_record_write)(ssl_context *ssl) = NULL;\nint (*ssl_hw_record_read)(ssl_context *ssl) = NULL;\nint (*ssl_hw_record_finish)(ssl_context *ssl) = NULL;\n#endif\n\nstatic int ssl_rsa_decrypt( void *ctx, int mode, size_t *olen,\n                        const unsigned char *input, unsigned char *output,\n                        size_t output_max_len )\n{\n    return rsa_pkcs1_decrypt( (rsa_context *) ctx, mode, olen, input, output,\n                              output_max_len );\n}\n\nstatic int ssl_rsa_sign( void *ctx,\n                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,\n                    int mode, int hash_id, unsigned int hashlen,\n                    const unsigned char *hash, unsigned char *sig )\n{\n    return rsa_pkcs1_sign( (rsa_context *) ctx, f_rng, p_rng, mode, hash_id,\n                           hashlen, hash, sig );\n}\n\nstatic size_t ssl_rsa_key_len( void *ctx )\n{\n    return ( (rsa_context *) ctx )->len;\n}\n\n/*\n * Key material generation\n */\nstatic int ssl3_prf( unsigned char *secret, size_t slen, char *label,\n                     unsigned char *random, size_t rlen,\n                     unsigned char *dstbuf, size_t dlen )\n{\n    size_t i;\n    md5_context md5;\n    sha1_context sha1;\n    unsigned char padding[16];\n    unsigned char sha1sum[20];\n    ((void)label);\n\n    /*\n     *  SSLv3:\n     *    block =\n     *      MD5( secret + SHA1( 'A'    + secret + random ) ) +\n     *      MD5( secret + SHA1( 'BB'   + secret + random ) ) +\n     *      MD5( secret + SHA1( 'CCC'  + secret + random ) ) +\n     *      ...\n     */\n    for( i = 0; i < dlen / 16; i++ )\n    {\n        memset( padding, 'A' + i, 1 + i );\n\n        sha1_starts( &sha1 );\n        sha1_update( &sha1, padding, 1 + i );\n        sha1_update( &sha1, secret, slen );\n        sha1_update( &sha1, random, rlen );\n        sha1_finish( &sha1, sha1sum );\n\n        md5_starts( &md5 );\n        md5_update( &md5, secret, slen );\n        md5_update( &md5, sha1sum, 20 );\n        md5_finish( &md5, dstbuf + i * 16 );\n    }\n\n    memset( &md5,  0, sizeof( md5  ) );\n    memset( &sha1, 0, sizeof( sha1 ) );\n\n    memset( padding, 0, sizeof( padding ) );\n    memset( sha1sum, 0, sizeof( sha1sum ) );\n\n    return( 0 );\n}\n\nstatic int tls1_prf( unsigned char *secret, size_t slen, char *label,\n                     unsigned char *random, size_t rlen,\n                     unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb, hs;\n    size_t i, j, k;\n    unsigned char *S1, *S2;\n    unsigned char tmp[128];\n    unsigned char h_i[20];\n\n    if( sizeof( tmp ) < 20 + strlen( label ) + rlen )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    hs = ( slen + 1 ) / 2;\n    S1 = secret;\n    S2 = secret + slen - hs;\n\n    nb = strlen( label );\n    memcpy( tmp + 20, label, nb );\n    memcpy( tmp + 20 + nb, random, rlen );\n    nb += rlen;\n\n    /*\n     * First compute P_md5(secret,label+random)[0..dlen]\n     */\n    md5_hmac( S1, hs, tmp + 20, nb, 4 + tmp );\n\n    for( i = 0; i < dlen; i += 16 )\n    {\n        md5_hmac( S1, hs, 4 + tmp, 16 + nb, h_i );\n        md5_hmac( S1, hs, 4 + tmp, 16,  4 + tmp );\n\n        k = ( i + 16 > dlen ) ? dlen % 16 : 16;\n\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n\n    /*\n     * XOR out with P_sha1(secret,label+random)[0..dlen]\n     */\n    sha1_hmac( S2, hs, tmp + 20, nb, tmp );\n\n    for( i = 0; i < dlen; i += 20 )\n    {\n        sha1_hmac( S2, hs, tmp, 20 + nb, h_i );\n        sha1_hmac( S2, hs, tmp, 20,      tmp );\n\n        k = ( i + 20 > dlen ) ? dlen % 20 : 20;\n\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j] = (unsigned char)( dstbuf[i + j] ^ h_i[j] );\n    }\n\n    memset( tmp, 0, sizeof( tmp ) );\n    memset( h_i, 0, sizeof( h_i ) );\n\n    return( 0 );\n}\n\nstatic int tls_prf_sha256( unsigned char *secret, size_t slen, char *label,\n                           unsigned char *random, size_t rlen,\n                           unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb;\n    size_t i, j, k;\n    unsigned char tmp[128];\n    unsigned char h_i[32];\n\n    if( sizeof( tmp ) < 32 + strlen( label ) + rlen )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    nb = strlen( label );\n    memcpy( tmp + 32, label, nb );\n    memcpy( tmp + 32 + nb, random, rlen );\n    nb += rlen;\n\n    /*\n     * Compute P_<hash>(secret, label + random)[0..dlen]\n     */\n    sha2_hmac( secret, slen, tmp + 32, nb, tmp, 0 );\n\n    for( i = 0; i < dlen; i += 32 )\n    {\n        sha2_hmac( secret, slen, tmp, 32 + nb, h_i, 0 );\n        sha2_hmac( secret, slen, tmp, 32,      tmp, 0 );\n\n        k = ( i + 32 > dlen ) ? dlen % 32 : 32;\n\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n\n    memset( tmp, 0, sizeof( tmp ) );\n    memset( h_i, 0, sizeof( h_i ) );\n\n    return( 0 );\n}\n\n#if defined(POLARSSL_SHA4_C)\nstatic int tls_prf_sha384( unsigned char *secret, size_t slen, char *label,\n                           unsigned char *random, size_t rlen,\n                           unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb;\n    size_t i, j, k;\n    unsigned char tmp[128];\n    unsigned char h_i[48];\n\n    if( sizeof( tmp ) < 48 + strlen( label ) + rlen )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    nb = strlen( label );\n    memcpy( tmp + 48, label, nb );\n    memcpy( tmp + 48 + nb, random, rlen );\n    nb += rlen;\n\n    /*\n     * Compute P_<hash>(secret, label + random)[0..dlen]\n     */\n    sha4_hmac( secret, slen, tmp + 48, nb, tmp, 1 );\n\n    for( i = 0; i < dlen; i += 48 )\n    {\n        sha4_hmac( secret, slen, tmp, 48 + nb, h_i, 1 );\n        sha4_hmac( secret, slen, tmp, 48,      tmp, 1 );\n\n        k = ( i + 48 > dlen ) ? dlen % 48 : 48;\n\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n\n    memset( tmp, 0, sizeof( tmp ) );\n    memset( h_i, 0, sizeof( h_i ) );\n\n    return( 0 );\n}\n#endif\n\nstatic void ssl_update_checksum_start(ssl_context *, unsigned char *, size_t);\nstatic void ssl_update_checksum_md5sha1(ssl_context *, unsigned char *, size_t);\nstatic void ssl_update_checksum_sha256(ssl_context *, unsigned char *, size_t);\n\nstatic void ssl_calc_verify_ssl(ssl_context *,unsigned char *);\nstatic void ssl_calc_verify_tls(ssl_context *,unsigned char *);\nstatic void ssl_calc_verify_tls_sha256(ssl_context *,unsigned char *);\n\nstatic void ssl_calc_finished_ssl(ssl_context *,unsigned char *,int);\nstatic void ssl_calc_finished_tls(ssl_context *,unsigned char *,int);\nstatic void ssl_calc_finished_tls_sha256(ssl_context *,unsigned char *,int);\n\n#if defined(POLARSSL_SHA4_C)\nstatic void ssl_update_checksum_sha384(ssl_context *, unsigned char *, size_t);\nstatic void ssl_calc_verify_tls_sha384(ssl_context *,unsigned char *);\nstatic void ssl_calc_finished_tls_sha384(ssl_context *,unsigned char *,int);\n#endif\n\nint ssl_derive_keys( ssl_context *ssl )\n{\n    unsigned char tmp[64];\n    unsigned char keyblk[256];\n    unsigned char *key1;\n    unsigned char *key2;\n    unsigned int iv_copy_len;\n    ssl_session *session = ssl->session_negotiate;\n    ssl_transform *transform = ssl->transform_negotiate;\n    ssl_handshake_params *handshake = ssl->handshake;\n\n    SSL_DEBUG_MSG( 2, ( \"=> derive keys\" ) );\n\n    /*\n     * Set appropriate PRF function and other SSL / TLS / TLS1.2 functions\n     */\n    if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        handshake->tls_prf = ssl3_prf;\n        handshake->calc_verify = ssl_calc_verify_ssl;\n        handshake->calc_finished = ssl_calc_finished_ssl;\n    }\n    else if( ssl->minor_ver < SSL_MINOR_VERSION_3 )\n    {\n        handshake->tls_prf = tls1_prf;\n        handshake->calc_verify = ssl_calc_verify_tls;\n        handshake->calc_finished = ssl_calc_finished_tls;\n    }\n#if defined(POLARSSL_SHA4_C)\n    else if( session->ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n             session->ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n    {\n        handshake->tls_prf = tls_prf_sha384;\n        handshake->calc_verify = ssl_calc_verify_tls_sha384;\n        handshake->calc_finished = ssl_calc_finished_tls_sha384;\n    }\n#endif\n    else\n    {\n        handshake->tls_prf = tls_prf_sha256;\n        handshake->calc_verify = ssl_calc_verify_tls_sha256;\n        handshake->calc_finished = ssl_calc_finished_tls_sha256;\n    }\n\n    /*\n     * SSLv3:\n     *   master =\n     *     MD5( premaster + SHA1( 'A'   + premaster + randbytes ) ) +\n     *     MD5( premaster + SHA1( 'BB'  + premaster + randbytes ) ) +\n     *     MD5( premaster + SHA1( 'CCC' + premaster + randbytes ) )\n     *   \n     * TLSv1:\n     *   master = PRF( premaster, \"master secret\", randbytes )[0..47]\n     */\n    if( handshake->resume == 0 )\n    {\n        SSL_DEBUG_BUF( 3, \"premaster secret\", handshake->premaster,\n                       handshake->pmslen );\n\n        handshake->tls_prf( handshake->premaster, handshake->pmslen,\n                            \"master secret\",\n                            handshake->randbytes, 64, session->master, 48 );\n\n        memset( handshake->premaster, 0, sizeof( handshake->premaster ) );\n    }\n    else\n        SSL_DEBUG_MSG( 3, ( \"no premaster (session resumed)\" ) );\n\n    /*\n     * Swap the client and server random values.\n     */\n    memcpy( tmp, handshake->randbytes, 64 );\n    memcpy( handshake->randbytes, tmp + 32, 32 );\n    memcpy( handshake->randbytes + 32, tmp, 32 );\n    memset( tmp, 0, sizeof( tmp ) );\n\n    /*\n     *  SSLv3:\n     *    key block =\n     *      MD5( master + SHA1( 'A'    + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'BB'   + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'CCC'  + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'DDDD' + master + randbytes ) ) +\n     *      ...\n     *\n     *  TLSv1:\n     *    key block = PRF( master, \"key expansion\", randbytes )\n     */\n    handshake->tls_prf( session->master, 48, \"key expansion\",\n                        handshake->randbytes, 64, keyblk, 256 );\n\n    SSL_DEBUG_MSG( 3, ( \"ciphersuite = %s\",\n                   ssl_get_ciphersuite_name( session->ciphersuite ) ) );\n    SSL_DEBUG_BUF( 3, \"master secret\", session->master, 48 );\n    SSL_DEBUG_BUF( 4, \"random bytes\", handshake->randbytes, 64 );\n    SSL_DEBUG_BUF( 4, \"key block\", keyblk, 256 );\n\n    memset( handshake->randbytes, 0, sizeof( handshake->randbytes ) );\n\n    /*\n     * Determine the appropriate key, IV and MAC length.\n     */\n    switch( session->ciphersuite )\n    {\n#if defined(POLARSSL_ARC4_C)\n        case TLS_RSA_WITH_RC4_128_MD5:\n            transform->keylen = 16; transform->minlen = 16;\n            transform->ivlen  =  0; transform->maclen = 16;\n            break;\n\n        case TLS_RSA_WITH_RC4_128_SHA:\n            transform->keylen = 16; transform->minlen = 20;\n            transform->ivlen  =  0; transform->maclen = 20;\n            break;\n#endif\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_3DES_EDE_CBC_SHA:\n        case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:\n            transform->keylen = 24; transform->minlen = 24;\n            transform->ivlen  =  8; transform->maclen = 20;\n            break;\n#endif\n\n#if defined(POLARSSL_AES_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA:\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:\n            transform->keylen = 16; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 20;\n            break;\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA:\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:\n            transform->keylen = 32; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 20;\n            break;\n\n#if defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:\n            transform->keylen = 16; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 32;\n            break;\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:\n            transform->keylen = 32; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 32;\n            break;\n#endif\n#if defined(POLARSSL_GCM_C)\n        case TLS_RSA_WITH_AES_128_GCM_SHA256:\n        case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:\n            transform->keylen = 16; transform->minlen = 1;\n            transform->ivlen  = 12; transform->maclen = 0;\n            transform->fixed_ivlen = 4;\n            break;\n\n        case TLS_RSA_WITH_AES_256_GCM_SHA384:\n        case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:\n            transform->keylen = 32; transform->minlen = 1;\n            transform->ivlen  = 12; transform->maclen = 0;\n            transform->fixed_ivlen = 4;\n            break;\n#endif\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:\n            transform->keylen = 16; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 20;\n            break;\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:\n            transform->keylen = 32; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 20;\n            break;\n\n#if defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n            transform->keylen = 16; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 32;\n            break;\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n            transform->keylen = 32; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 32;\n            break;\n#endif\n#endif\n\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        case TLS_RSA_WITH_NULL_MD5:\n            transform->keylen = 0; transform->minlen = 0;\n            transform->ivlen  = 0; transform->maclen = 16;\n            break;\n\n        case TLS_RSA_WITH_NULL_SHA:\n            transform->keylen = 0; transform->minlen = 0;\n            transform->ivlen  = 0; transform->maclen = 20;\n            break;\n\n        case TLS_RSA_WITH_NULL_SHA256:\n            transform->keylen = 0; transform->minlen = 0;\n            transform->ivlen  = 0; transform->maclen = 32;\n            break;\n#endif /* defined(POLARSSL_CIPHER_NULL_CIPHER) */\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_DES_CBC_SHA:\n        case TLS_DHE_RSA_WITH_DES_CBC_SHA:\n            transform->keylen =  8; transform->minlen = 8;\n            transform->ivlen  =  8; transform->maclen = 20;\n            break;\n#endif\n#endif /* defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES) */\n\n        default:\n            SSL_DEBUG_MSG( 1, ( \"ciphersuite %s is not available\",\n                           ssl_get_ciphersuite_name( session->ciphersuite ) ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"keylen: %d, minlen: %d, ivlen: %d, maclen: %d\",\n                   transform->keylen, transform->minlen, transform->ivlen,\n                   transform->maclen ) );\n\n    /*\n     * Finally setup the cipher contexts, IVs and MAC secrets.\n     */\n    if( ssl->endpoint == SSL_IS_CLIENT )\n    {\n        key1 = keyblk + transform->maclen * 2;\n        key2 = keyblk + transform->maclen * 2 + transform->keylen;\n\n        memcpy( transform->mac_enc, keyblk,  transform->maclen );\n        memcpy( transform->mac_dec, keyblk + transform->maclen,\n                transform->maclen );\n\n        /*\n         * This is not used in TLS v1.1.\n         */\n        iv_copy_len = ( transform->fixed_ivlen ) ?\n                            transform->fixed_ivlen : transform->ivlen;\n        memcpy( transform->iv_enc, key2 + transform->keylen,  iv_copy_len );\n        memcpy( transform->iv_dec, key2 + transform->keylen + iv_copy_len,\n                iv_copy_len );\n    }\n    else\n    {\n        key1 = keyblk + transform->maclen * 2 + transform->keylen;\n        key2 = keyblk + transform->maclen * 2;\n\n        memcpy( transform->mac_dec, keyblk,  transform->maclen );\n        memcpy( transform->mac_enc, keyblk + transform->maclen,\n                transform->maclen );\n\n        /*\n         * This is not used in TLS v1.1.\n         */\n        iv_copy_len = ( transform->fixed_ivlen ) ?\n                            transform->fixed_ivlen : transform->ivlen;\n        memcpy( transform->iv_dec, key1 + transform->keylen,  iv_copy_len );\n        memcpy( transform->iv_enc, key1 + transform->keylen + iv_copy_len,\n                iv_copy_len );\n    }\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_init != NULL)\n    {\n        int ret = 0;\n\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_init()\" ) );\n\n        if( ( ret = ssl_hw_record_init( ssl, key1, key2, transform->iv_enc,\n                                        transform->iv_dec, transform->mac_enc,\n                                        transform->mac_dec ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_init\", ret );\n            return POLARSSL_ERR_SSL_HW_ACCEL_FAILED;\n        }\n    }\n#endif\n\n    switch( session->ciphersuite )\n    {\n#if defined(POLARSSL_ARC4_C)\n        case TLS_RSA_WITH_RC4_128_MD5:\n        case TLS_RSA_WITH_RC4_128_SHA:\n            arc4_setup( (arc4_context *) transform->ctx_enc, key1,\n                        transform->keylen );\n            arc4_setup( (arc4_context *) transform->ctx_dec, key2,\n                        transform->keylen );\n            break;\n#endif\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_3DES_EDE_CBC_SHA:\n        case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:\n            des3_set3key_enc( (des3_context *) transform->ctx_enc, key1 );\n            des3_set3key_dec( (des3_context *) transform->ctx_dec, key2 );\n            break;\n#endif\n\n#if defined(POLARSSL_AES_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA:\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:\n        case TLS_RSA_WITH_AES_128_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:\n            aes_setkey_enc( (aes_context *) transform->ctx_enc, key1, 128 );\n            aes_setkey_dec( (aes_context *) transform->ctx_dec, key2, 128 );\n            break;\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA:\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:\n        case TLS_RSA_WITH_AES_256_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:\n            aes_setkey_enc( (aes_context *) transform->ctx_enc, key1, 256 );\n            aes_setkey_dec( (aes_context *) transform->ctx_dec, key2, 256 );\n            break;\n\n#if defined(POLARSSL_GCM_C)\n        case TLS_RSA_WITH_AES_128_GCM_SHA256:\n        case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:\n            gcm_init( (gcm_context *) transform->ctx_enc, key1, 128 );\n            gcm_init( (gcm_context *) transform->ctx_dec, key2, 128 );\n            break;\n\n        case TLS_RSA_WITH_AES_256_GCM_SHA384:\n        case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:\n            gcm_init( (gcm_context *) transform->ctx_enc, key1, 256 );\n            gcm_init( (gcm_context *) transform->ctx_dec, key2, 256 );\n            break;\n#endif\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n            camellia_setkey_enc( (camellia_context *) transform->ctx_enc, key1, 128 );\n            camellia_setkey_dec( (camellia_context *) transform->ctx_dec, key2, 128 );\n            break;\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n            camellia_setkey_enc( (camellia_context *) transform->ctx_enc, key1, 256 );\n            camellia_setkey_dec( (camellia_context *) transform->ctx_dec, key2, 256 );\n            break;\n#endif\n\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        case TLS_RSA_WITH_NULL_MD5:\n        case TLS_RSA_WITH_NULL_SHA:\n        case TLS_RSA_WITH_NULL_SHA256:\n            break;\n#endif /* defined(POLARSSL_CIPHER_NULL_CIPHER) */\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_DES_CBC_SHA:\n        case TLS_DHE_RSA_WITH_DES_CBC_SHA:\n            des_setkey_enc( (des_context *) transform->ctx_enc, key1 );\n            des_setkey_dec( (des_context *) transform->ctx_dec, key2 );\n            break;\n#endif\n#endif /* defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES) */\n\n        default:\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n\n    memset( keyblk, 0, sizeof( keyblk ) );\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    // Initialize compression\n    //\n    if( session->compression == SSL_COMPRESS_DEFLATE )\n    {\n        SSL_DEBUG_MSG( 3, ( \"Initializing zlib states\" ) );\n\n        memset( &transform->ctx_deflate, 0, sizeof( transform->ctx_deflate ) );\n        memset( &transform->ctx_inflate, 0, sizeof( transform->ctx_inflate ) );\n\n        if( deflateInit( &transform->ctx_deflate, Z_DEFAULT_COMPRESSION ) != Z_OK ||\n            inflateInit( &transform->ctx_inflate ) != Z_OK )\n        {\n            SSL_DEBUG_MSG( 1, ( \"Failed to initialize compression\" ) );\n            return( POLARSSL_ERR_SSL_COMPRESSION_FAILED );\n        }\n    }\n#endif /* POLARSSL_ZLIB_SUPPORT */\n\n    SSL_DEBUG_MSG( 2, ( \"<= derive keys\" ) );\n\n    return( 0 );\n}\n\nvoid ssl_calc_verify_ssl( ssl_context *ssl, unsigned char hash[36] )\n{\n    md5_context md5;\n    sha1_context sha1;\n    unsigned char pad_1[48];\n    unsigned char pad_2[48];\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc verify ssl\" ) );\n\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n\n    memset( pad_1, 0x36, 48 );\n    memset( pad_2, 0x5C, 48 );\n\n    md5_update( &md5, ssl->session_negotiate->master, 48 );\n    md5_update( &md5, pad_1, 48 );\n    md5_finish( &md5, hash );\n\n    md5_starts( &md5 );\n    md5_update( &md5, ssl->session_negotiate->master, 48 );\n    md5_update( &md5, pad_2, 48 );\n    md5_update( &md5, hash,  16 );\n    md5_finish( &md5, hash );\n\n    sha1_update( &sha1, ssl->session_negotiate->master, 48 );\n    sha1_update( &sha1, pad_1, 40 );\n    sha1_finish( &sha1, hash + 16 );\n\n    sha1_starts( &sha1 );\n    sha1_update( &sha1, ssl->session_negotiate->master, 48 );\n    sha1_update( &sha1, pad_2, 40 );\n    sha1_update( &sha1, hash + 16, 20 );\n    sha1_finish( &sha1, hash + 16 );\n\n    SSL_DEBUG_BUF( 3, \"calculated verify result\", hash, 36 );\n    SSL_DEBUG_MSG( 2, ( \"<= calc verify\" ) );\n\n    return;\n}\n\nvoid ssl_calc_verify_tls( ssl_context *ssl, unsigned char hash[36] )\n{\n    md5_context md5;\n    sha1_context sha1;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc verify tls\" ) );\n\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n\n     md5_finish( &md5,  hash );\n    sha1_finish( &sha1, hash + 16 );\n\n    SSL_DEBUG_BUF( 3, \"calculated verify result\", hash, 36 );\n    SSL_DEBUG_MSG( 2, ( \"<= calc verify\" ) );\n\n    return;\n}\n\nvoid ssl_calc_verify_tls_sha256( ssl_context *ssl, unsigned char hash[32] )\n{\n    sha2_context sha2;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc verify sha256\" ) );\n\n    memcpy( &sha2, &ssl->handshake->fin_sha2, sizeof(sha2_context) );\n    sha2_finish( &sha2, hash );\n\n    SSL_DEBUG_BUF( 3, \"calculated verify result\", hash, 32 );\n    SSL_DEBUG_MSG( 2, ( \"<= calc verify\" ) );\n\n    return;\n}\n\n#if defined(POLARSSL_SHA4_C)\nvoid ssl_calc_verify_tls_sha384( ssl_context *ssl, unsigned char hash[48] )\n{\n    sha4_context sha4;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc verify sha384\" ) );\n\n    memcpy( &sha4, &ssl->handshake->fin_sha4, sizeof(sha4_context) );\n    sha4_finish( &sha4, hash );\n\n    SSL_DEBUG_BUF( 3, \"calculated verify result\", hash, 48 );\n    SSL_DEBUG_MSG( 2, ( \"<= calc verify\" ) );\n\n    return;\n}\n#endif\n\n/*\n * SSLv3.0 MAC functions\n */\nstatic void ssl_mac_md5( unsigned char *secret,\n                         unsigned char *buf, size_t len,\n                         unsigned char *ctr, int type )\n{\n    unsigned char header[11];\n    unsigned char padding[48];\n    md5_context md5;\n\n    memcpy( header, ctr, 8 );\n    header[ 8] = (unsigned char)  type;\n    header[ 9] = (unsigned char)( len >> 8 );\n    header[10] = (unsigned char)( len      );\n\n    memset( padding, 0x36, 48 );\n    md5_starts( &md5 );\n    md5_update( &md5, secret,  16 );\n    md5_update( &md5, padding, 48 );\n    md5_update( &md5, header,  11 );\n    md5_update( &md5, buf,  len );\n    md5_finish( &md5, buf + len );\n\n    memset( padding, 0x5C, 48 );\n    md5_starts( &md5 );\n    md5_update( &md5, secret,  16 );\n    md5_update( &md5, padding, 48 );\n    md5_update( &md5, buf + len, 16 );\n    md5_finish( &md5, buf + len );\n}\n\nstatic void ssl_mac_sha1( unsigned char *secret,\n                          unsigned char *buf, size_t len,\n                          unsigned char *ctr, int type )\n{\n    unsigned char header[11];\n    unsigned char padding[40];\n    sha1_context sha1;\n\n    memcpy( header, ctr, 8 );\n    header[ 8] = (unsigned char)  type;\n    header[ 9] = (unsigned char)( len >> 8 );\n    header[10] = (unsigned char)( len      );\n\n    memset( padding, 0x36, 40 );\n    sha1_starts( &sha1 );\n    sha1_update( &sha1, secret,  20 );\n    sha1_update( &sha1, padding, 40 );\n    sha1_update( &sha1, header,  11 );\n    sha1_update( &sha1, buf,  len );\n    sha1_finish( &sha1, buf + len );\n\n    memset( padding, 0x5C, 40 );\n    sha1_starts( &sha1 );\n    sha1_update( &sha1, secret,  20 );\n    sha1_update( &sha1, padding, 40 );\n    sha1_update( &sha1, buf + len, 20 );\n    sha1_finish( &sha1, buf + len );\n}\n\nstatic void ssl_mac_sha2( unsigned char *secret,\n                          unsigned char *buf, size_t len,\n                          unsigned char *ctr, int type )\n{\n    unsigned char header[11];\n    unsigned char padding[32];\n    sha2_context sha2;\n\n    memcpy( header, ctr, 8 );\n    header[ 8] = (unsigned char)  type;\n    header[ 9] = (unsigned char)( len >> 8 );\n    header[10] = (unsigned char)( len      );\n\n    memset( padding, 0x36, 32 );\n    sha2_starts( &sha2, 0 );\n    sha2_update( &sha2, secret,  32 );\n    sha2_update( &sha2, padding, 32 );\n    sha2_update( &sha2, header,  11 );\n    sha2_update( &sha2, buf,  len );\n    sha2_finish( &sha2, buf + len );\n\n    memset( padding, 0x5C, 32 );\n    sha2_starts( &sha2, 0 );\n    sha2_update( &sha2, secret,  32 );\n    sha2_update( &sha2, padding, 32 );\n    sha2_update( &sha2, buf + len, 32 );\n    sha2_finish( &sha2, buf + len );\n}\n\n/*\n * Encryption/decryption functions\n */ \nstatic int ssl_encrypt_buf( ssl_context *ssl )\n{\n    size_t i, padlen;\n\n    SSL_DEBUG_MSG( 2, ( \"=> encrypt buf\" ) );\n\n    /*\n     * Add MAC then encrypt\n     */\n    if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->transform_out->maclen == 16 )\n             ssl_mac_md5( ssl->transform_out->mac_enc,\n                          ssl->out_msg, ssl->out_msglen,\n                          ssl->out_ctr, ssl->out_msgtype );\n        else if( ssl->transform_out->maclen == 20 )\n            ssl_mac_sha1( ssl->transform_out->mac_enc,\n                          ssl->out_msg, ssl->out_msglen,\n                          ssl->out_ctr, ssl->out_msgtype );\n        else if( ssl->transform_out->maclen == 32 )\n            ssl_mac_sha2( ssl->transform_out->mac_enc,\n                          ssl->out_msg, ssl->out_msglen,\n                          ssl->out_ctr, ssl->out_msgtype );\n        else if( ssl->transform_out->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_out->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n    else\n    {\n        if( ssl->transform_out->maclen == 16 )\n        {\n            md5_context ctx;\n            md5_hmac_starts( &ctx, ssl->transform_out->mac_enc, 16 );\n            md5_hmac_update( &ctx, ssl->out_ctr, 13 );\n            md5_hmac_update( &ctx, ssl->out_msg, ssl->out_msglen );\n            md5_hmac_finish( &ctx, ssl->out_msg + ssl->out_msglen );\n            memset( &ctx, 0, sizeof(md5_context));\n        }\n        else if( ssl->transform_out->maclen == 20 )\n        {\n            sha1_context ctx;\n            sha1_hmac_starts( &ctx, ssl->transform_out->mac_enc, 20 );\n            sha1_hmac_update( &ctx, ssl->out_ctr, 13 );\n            sha1_hmac_update( &ctx, ssl->out_msg, ssl->out_msglen );\n            sha1_hmac_finish( &ctx, ssl->out_msg + ssl->out_msglen );\n            memset( &ctx, 0, sizeof(sha1_context));\n        }\n        else if( ssl->transform_out->maclen == 32 )\n        {\n            sha2_context ctx;\n            sha2_hmac_starts( &ctx, ssl->transform_out->mac_enc, 32, 0 );\n            sha2_hmac_update( &ctx, ssl->out_ctr, 13 );\n            sha2_hmac_update( &ctx, ssl->out_msg, ssl->out_msglen );\n            sha2_hmac_finish( &ctx, ssl->out_msg + ssl->out_msglen );\n            memset( &ctx, 0, sizeof(sha2_context));\n        }\n        else if( ssl->transform_out->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_out->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    SSL_DEBUG_BUF( 4, \"computed mac\",\n                   ssl->out_msg + ssl->out_msglen, ssl->transform_out->maclen );\n\n    ssl->out_msglen += ssl->transform_out->maclen;\n\n    if( ssl->transform_out->ivlen == 0 )\n    {\n        padlen = 0;\n\n        SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                            \"including %d bytes of padding\",\n                       ssl->out_msglen, 0 ) );\n\n        SSL_DEBUG_BUF( 4, \"before encrypt: output payload\",\n                       ssl->out_msg, ssl->out_msglen );\n\n#if defined(POLARSSL_ARC4_C)\n        if( ssl->session_out->ciphersuite == TLS_RSA_WITH_RC4_128_MD5 ||\n            ssl->session_out->ciphersuite == TLS_RSA_WITH_RC4_128_SHA )\n        {\n            arc4_crypt( (arc4_context *) ssl->transform_out->ctx_enc,\n                        ssl->out_msglen, ssl->out_msg,\n                        ssl->out_msg );\n        } else\n#endif\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        if( ssl->session_out->ciphersuite == TLS_RSA_WITH_NULL_MD5 ||\n            ssl->session_out->ciphersuite == TLS_RSA_WITH_NULL_SHA ||\n            ssl->session_out->ciphersuite == TLS_RSA_WITH_NULL_SHA256 )\n        {\n        } else\n#endif\n        return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n    else if( ssl->transform_out->ivlen == 12 )\n    {\n        size_t enc_msglen;\n        unsigned char *enc_msg;\n        unsigned char add_data[13];\n        int ret = POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE;\n\n        padlen = 0;\n        enc_msglen = ssl->out_msglen;\n\n        memcpy( add_data, ssl->out_ctr, 8 );\n        add_data[8]  = ssl->out_msgtype;\n        add_data[9]  = ssl->major_ver;\n        add_data[10] = ssl->minor_ver;\n        add_data[11] = ( ssl->out_msglen >> 8 ) & 0xFF;\n        add_data[12] = ssl->out_msglen & 0xFF;\n\n        SSL_DEBUG_BUF( 4, \"additional data used for AEAD\",\n                       add_data, 13 );\n\n#if defined(POLARSSL_AES_C) && defined(POLARSSL_GCM_C)\n\n        if( ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n            ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n        {\n            /*\n             * Generate IV\n             */\n            ret = ssl->f_rng( ssl->p_rng,\n                        ssl->transform_out->iv_enc + ssl->transform_out->fixed_ivlen,\n                        ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen );\n            if( ret != 0 )\n                return( ret );\n\n            /*\n             * Shift message for ivlen bytes and prepend IV\n             */\n            memmove( ssl->out_msg + ssl->transform_out->ivlen -\n                     ssl->transform_out->fixed_ivlen,\n                     ssl->out_msg, ssl->out_msglen );\n            memcpy( ssl->out_msg,\n                    ssl->transform_out->iv_enc + ssl->transform_out->fixed_ivlen,\n                    ssl->transform_out->ivlen  - ssl->transform_out->fixed_ivlen );\n\n            /*\n             * Fix pointer positions and message length with added IV\n             */\n            enc_msg = ssl->out_msg + ssl->transform_out->ivlen -\n                      ssl->transform_out->fixed_ivlen;\n            enc_msglen = ssl->out_msglen;\n            ssl->out_msglen += ssl->transform_out->ivlen -\n                               ssl->transform_out->fixed_ivlen;\n\n            SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                                \"including %d bytes of padding\",\n                           ssl->out_msglen, 0 ) );\n\n            SSL_DEBUG_BUF( 4, \"before encrypt: output payload\",\n                           ssl->out_msg, ssl->out_msglen );\n\n            /*\n             * Adjust for tag\n             */\n            ssl->out_msglen += 16;\n            \n            gcm_crypt_and_tag( (gcm_context *) ssl->transform_out->ctx_enc,\n                    GCM_ENCRYPT, enc_msglen,\n                    ssl->transform_out->iv_enc, ssl->transform_out->ivlen,\n                    add_data, 13,\n                    enc_msg, enc_msg,\n                    16, enc_msg + enc_msglen );\n\n            SSL_DEBUG_BUF( 4, \"after encrypt: tag\",\n                           enc_msg + enc_msglen, 16 );\n\n        } else\n#endif\n        return( ret );\n    }\n    else\n    {\n        unsigned char *enc_msg;\n        size_t enc_msglen;\n\n        padlen = ssl->transform_out->ivlen - ( ssl->out_msglen + 1 ) %\n                 ssl->transform_out->ivlen;\n        if( padlen == ssl->transform_out->ivlen )\n            padlen = 0;\n\n        for( i = 0; i <= padlen; i++ )\n            ssl->out_msg[ssl->out_msglen + i] = (unsigned char) padlen;\n\n        ssl->out_msglen += padlen + 1;\n\n        enc_msglen = ssl->out_msglen;\n        enc_msg = ssl->out_msg;\n\n        /*\n         * Prepend per-record IV for block cipher in TLS v1.1 and up as per\n         * Method 1 (6.2.3.2. in RFC4346 and RFC5246)\n         */\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_2 )\n        {\n            /*\n             * Generate IV\n             */\n            int ret = ssl->f_rng( ssl->p_rng, ssl->transform_out->iv_enc,\n                                  ssl->transform_out->ivlen );\n            if( ret != 0 )\n                return( ret );\n\n            /*\n             * Shift message for ivlen bytes and prepend IV\n             */\n            memmove( ssl->out_msg + ssl->transform_out->ivlen, ssl->out_msg,\n                     ssl->out_msglen );\n            memcpy( ssl->out_msg, ssl->transform_out->iv_enc,\n                    ssl->transform_out->ivlen );\n\n            /*\n             * Fix pointer positions and message length with added IV\n             */\n            enc_msg = ssl->out_msg + ssl->transform_out->ivlen;\n            enc_msglen = ssl->out_msglen;\n            ssl->out_msglen += ssl->transform_out->ivlen;\n        }\n\n        SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                            \"including %d bytes of IV and %d bytes of padding\",\n                       ssl->out_msglen, ssl->transform_out->ivlen, padlen + 1 ) );\n\n        SSL_DEBUG_BUF( 4, \"before encrypt: output payload\",\n                       ssl->out_msg, ssl->out_msglen );\n\n        switch( ssl->transform_out->ivlen )\n        {\n#if defined(POLARSSL_DES_C)\n            case  8:\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n                if( ssl->session_out->ciphersuite == TLS_RSA_WITH_DES_CBC_SHA ||\n                    ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_DES_CBC_SHA )\n                {\n                    des_crypt_cbc( (des_context *) ssl->transform_out->ctx_enc,\n                                   DES_ENCRYPT, enc_msglen,\n                                   ssl->transform_out->iv_enc, enc_msg, enc_msg );\n                }\n                else\n#endif\n                    des3_crypt_cbc( (des3_context *) ssl->transform_out->ctx_enc,\n                                    DES_ENCRYPT, enc_msglen,\n                                    ssl->transform_out->iv_enc, enc_msg, enc_msg );\n                break;\n#endif\n\n            case 16:\n#if defined(POLARSSL_AES_C)\n        if ( ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 )\n        {\n                    aes_crypt_cbc( (aes_context *) ssl->transform_out->ctx_enc,\n                        AES_ENCRYPT, enc_msglen,\n                        ssl->transform_out->iv_enc, enc_msg, enc_msg);\n                    break;\n        }\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        if ( ssl->session_out->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 )\n        {\n                    camellia_crypt_cbc( (camellia_context *) ssl->transform_out->ctx_enc,\n                        CAMELLIA_ENCRYPT, enc_msglen,\n                        ssl->transform_out->iv_enc, enc_msg, enc_msg );\n                    break;\n        }\n#endif\n\n            default:\n                return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    for( i = 8; i > 0; i-- )\n        if( ++ssl->out_ctr[i - 1] != 0 )\n            break;\n\n    SSL_DEBUG_MSG( 2, ( \"<= encrypt buf\" ) );\n\n    return( 0 );\n}\n\n/*\n * TODO: Use digest version when integrated!\n */\n#define POLARSSL_SSL_MAX_MAC_SIZE   32\n\nstatic int ssl_decrypt_buf( ssl_context *ssl )\n{\n    size_t i, padlen = 0, correct = 1;\n    unsigned char tmp[POLARSSL_SSL_MAX_MAC_SIZE];\n\n    SSL_DEBUG_MSG( 2, ( \"=> decrypt buf\" ) );\n\n    if( ssl->in_msglen < ssl->transform_in->minlen )\n    {\n        SSL_DEBUG_MSG( 1, ( \"in_msglen (%d) < minlen (%d)\",\n                       ssl->in_msglen, ssl->transform_in->minlen ) );\n        return( POLARSSL_ERR_SSL_INVALID_MAC );\n    }\n\n    if( ssl->transform_in->ivlen == 0 )\n    {\n#if defined(POLARSSL_ARC4_C)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_RC4_128_MD5 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_RC4_128_SHA )\n        {\n            arc4_crypt( (arc4_context *) ssl->transform_in->ctx_dec,\n                    ssl->in_msglen, ssl->in_msg,\n                    ssl->in_msg );\n        } else\n#endif\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_MD5 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_SHA ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_SHA256 )\n        {\n        } else\n#endif\n        return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n    else if( ssl->transform_in->ivlen == 12 )\n    {\n        unsigned char *dec_msg;\n        unsigned char *dec_msg_result;\n        size_t dec_msglen;\n        unsigned char add_data[13];\n        int ret = POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE;\n\n#if defined(POLARSSL_AES_C) && defined(POLARSSL_GCM_C)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n            ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n        {\n            dec_msglen = ssl->in_msglen - ( ssl->transform_in->ivlen -\n                                            ssl->transform_in->fixed_ivlen );\n            dec_msglen -= 16;\n            dec_msg = ssl->in_msg + ( ssl->transform_in->ivlen -\n                                      ssl->transform_in->fixed_ivlen );\n            dec_msg_result = ssl->in_msg;\n            ssl->in_msglen = dec_msglen;\n\n            memcpy( add_data, ssl->in_ctr, 8 );\n            add_data[8]  = ssl->in_msgtype;\n            add_data[9]  = ssl->major_ver;\n            add_data[10] = ssl->minor_ver;\n            add_data[11] = ( ssl->in_msglen >> 8 ) & 0xFF;\n            add_data[12] = ssl->in_msglen & 0xFF;\n\n            SSL_DEBUG_BUF( 4, \"additional data used for AEAD\",\n                           add_data, 13 );\n\n            memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,\n                    ssl->in_msg,\n                    ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen );\n\n            SSL_DEBUG_BUF( 4, \"IV used\", ssl->transform_in->iv_dec,\n                                         ssl->transform_in->ivlen );\n            SSL_DEBUG_BUF( 4, \"TAG used\", dec_msg + dec_msglen, 16 );\n\n            memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,\n                    ssl->in_msg,\n                    ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen );\n\n            ret = gcm_auth_decrypt( (gcm_context *) ssl->transform_in->ctx_dec,\n                                     dec_msglen,\n                                     ssl->transform_in->iv_dec,\n                                     ssl->transform_in->ivlen,\n                                     add_data, 13,\n                                     dec_msg + dec_msglen, 16,\n                                     dec_msg, dec_msg_result );\n            \n            if( ret != 0 )\n            {\n                SSL_DEBUG_MSG( 1, ( \"AEAD decrypt failed on validation (ret = -0x%02x)\",\n                                    -ret ) );\n\n                return( POLARSSL_ERR_SSL_INVALID_MAC );\n            }\n        } else\n#endif\n        return( ret );\n    }\n    else\n    {\n        /*\n         * Decrypt and check the padding\n         */\n        unsigned char *dec_msg;\n        unsigned char *dec_msg_result;\n        size_t dec_msglen;\n        size_t minlen = 0;\n\n        /*\n         * Check immediate ciphertext sanity\n         */\n        if( ssl->in_msglen % ssl->transform_in->ivlen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) %% ivlen (%d) != 0\",\n                           ssl->in_msglen, ssl->transform_in->ivlen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_2 )\n            minlen += ssl->transform_in->ivlen;\n\n        if( ssl->in_msglen < minlen + ssl->transform_in->ivlen ||\n            ssl->in_msglen < minlen + ssl->transform_in->maclen + 1 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) < max( ivlen(%d), maclen (%d) + 1 ) ( + expl IV )\",\n                           ssl->in_msglen, ssl->transform_in->ivlen, ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n\n        dec_msglen = ssl->in_msglen;\n        dec_msg = ssl->in_msg;\n        dec_msg_result = ssl->in_msg;\n\n        /*\n         * Initialize for prepended IV for block cipher in TLS v1.1 and up\n         */\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_2 )\n        {\n            dec_msg += ssl->transform_in->ivlen;\n            dec_msglen -= ssl->transform_in->ivlen;\n            ssl->in_msglen -= ssl->transform_in->ivlen;\n\n            for( i = 0; i < ssl->transform_in->ivlen; i++ )\n                ssl->transform_in->iv_dec[i] = ssl->in_msg[i];\n        }\n\n        switch( ssl->transform_in->ivlen )\n        {\n#if defined(POLARSSL_DES_C)\n            case  8:\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n                if( ssl->session_in->ciphersuite == TLS_RSA_WITH_DES_CBC_SHA ||\n                    ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_DES_CBC_SHA )\n                {\n                    des_crypt_cbc( (des_context *) ssl->transform_in->ctx_dec,\n                                   DES_DECRYPT, dec_msglen,\n                                   ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                }\n                else\n#endif\n                    des3_crypt_cbc( (des3_context *) ssl->transform_in->ctx_dec,\n                        DES_DECRYPT, dec_msglen,\n                        ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                break;\n#endif\n\n            case 16:\n#if defined(POLARSSL_AES_C)\n        if ( ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 )\n        {\n                    aes_crypt_cbc( (aes_context *) ssl->transform_in->ctx_dec,\n                       AES_DECRYPT, dec_msglen,\n                       ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                    break;\n        }\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        if ( ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 )\n        {\n                    camellia_crypt_cbc( (camellia_context *) ssl->transform_in->ctx_dec,\n                       CAMELLIA_DECRYPT, dec_msglen,\n                       ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                    break;\n        }\n#endif\n\n            default:\n                return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n\n        padlen = 1 + ssl->in_msg[ssl->in_msglen - 1];\n\n        if( ssl->in_msglen < ssl->transform_in->maclen + padlen )\n        {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) < maclen (%d) + padlen (%d)\",\n                        ssl->in_msglen, ssl->transform_in->maclen, padlen ) );\n#endif\n            padlen = 0;\n            correct = 0;\n        }\n\n        if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n        {\n            if( padlen > ssl->transform_in->ivlen )\n            {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n                SSL_DEBUG_MSG( 1, ( \"bad padding length: is %d, \"\n                                    \"should be no more than %d\",\n                               padlen, ssl->transform_in->ivlen ) );\n#endif\n                correct = 0;\n            }\n        }\n        else\n        {\n            /*\n             * TLSv1+: always check the padding up to the first failure\n             * and fake check up to 256 bytes of padding\n             */\n            size_t pad_count = 0, fake_pad_count = 0;\n            size_t padding_idx = ssl->in_msglen - padlen - 1;\n\n            for( i = 1; i <= padlen; i++ )\n                pad_count += ( ssl->in_msg[padding_idx + i] == padlen - 1 );\n\n            for( ; i <= 256; i++ )\n                fake_pad_count += ( ssl->in_msg[padding_idx + i] == padlen - 1 );\n\n            correct &= ( pad_count == padlen ); /* Only 1 on correct padding */\n            correct &= ( pad_count + fake_pad_count < 512 ); /* Always 1 */\n\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            if( padlen > 0 && correct == 0)\n                SSL_DEBUG_MSG( 1, ( \"bad padding byte detected\" ) );\n#endif\n            padlen &= correct * 0x1FF;\n        }\n    }\n\n    SSL_DEBUG_BUF( 4, \"raw buffer after decryption\",\n                   ssl->in_msg, ssl->in_msglen );\n\n    /*\n     * Always compute the MAC (RFC4346, CBCTIME).\n     */\n    ssl->in_msglen -= ( ssl->transform_in->maclen + padlen );\n\n    ssl->in_hdr[3] = (unsigned char)( ssl->in_msglen >> 8 );\n    ssl->in_hdr[4] = (unsigned char)( ssl->in_msglen      );\n\n    memcpy( tmp, ssl->in_msg + ssl->in_msglen, ssl->transform_in->maclen );\n\n    if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->transform_in->maclen == 16 )\n             ssl_mac_md5( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen == 20 )\n            ssl_mac_sha1( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen == 32 )\n            ssl_mac_sha2( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n    else\n    {\n        /*\n         * Process MAC and always update for padlen afterwards to make\n         * total time independent of padlen\n         *\n         * extra_run compensates MAC check for padlen \n         *\n         * Known timing attacks:\n         *  - Lucky Thirteen (http://www.isg.rhul.ac.uk/tls/TLStiming.pdf)\n         *\n         * We use ( ( Lx + 8 ) / 64 ) to handle 'negative Lx' values\n         * correctly. (We round down instead of up, so -56 is the correct\n         * value for our calculations instead of -55)\n         */\n        int j, extra_run = 0;\n        extra_run = ( 13 + ssl->in_msglen + padlen + 8 ) / 64 -\n                    ( 13 + ssl->in_msglen          + 8 ) / 64;\n\n        extra_run &= correct * 0xFF;\n\n        if( ssl->transform_in->maclen == 16 )\n        {\n            md5_context ctx;\n            md5_hmac_starts( &ctx, ssl->transform_in->mac_dec, 16 );\n            md5_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            md5_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                md5_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen == 20 )\n        {\n            sha1_context ctx;\n            sha1_hmac_starts( &ctx, ssl->transform_in->mac_dec, 20 );\n            sha1_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            sha1_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                sha1_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen == 32 )\n        {\n            sha2_context ctx;\n            sha2_hmac_starts( &ctx, ssl->transform_in->mac_dec, 32, 0 );\n            sha2_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            sha2_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                sha2_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    SSL_DEBUG_BUF( 4, \"message  mac\", tmp, ssl->transform_in->maclen );\n    SSL_DEBUG_BUF( 4, \"computed mac\", ssl->in_msg + ssl->in_msglen,\n                   ssl->transform_in->maclen );\n\n    if( memcmp( tmp, ssl->in_msg + ssl->in_msglen,\n                     ssl->transform_in->maclen ) != 0 )\n    {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n        SSL_DEBUG_MSG( 1, ( \"message mac does not match\" ) );\n#endif\n        correct = 0;\n    }\n\n    /*\n     * Finally check the correct flag\n     */\n    if( correct == 0 )\n        return( POLARSSL_ERR_SSL_INVALID_MAC );\n\n    if( ssl->in_msglen == 0 )\n    {\n        ssl->nb_zero++;\n\n        /*\n         * Three or more empty messages may be a DoS attack\n         * (excessive CPU consumption).\n         */\n        if( ssl->nb_zero > 3 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"received four consecutive empty \"\n                                \"messages, possible DoS attack\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n    }\n    else\n        ssl->nb_zero = 0;\n            \n    for( i = 8; i > 0; i-- )\n        if( ++ssl->in_ctr[i - 1] != 0 )\n            break;\n\n    SSL_DEBUG_MSG( 2, ( \"<= decrypt buf\" ) );\n\n    return( 0 );\n}\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n/*\n * Compression/decompression functions\n */\nstatic int ssl_compress_buf( ssl_context *ssl )\n{\n    int ret;\n    unsigned char *msg_post = ssl->out_msg;\n    size_t len_pre = ssl->out_msglen;\n    unsigned char *msg_pre;\n\n    SSL_DEBUG_MSG( 2, ( \"=> compress buf\" ) );\n\n    msg_pre = (unsigned char*) malloc( len_pre );\n    if( msg_pre == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len_pre ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memcpy( msg_pre, ssl->out_msg, len_pre );\n\n    SSL_DEBUG_MSG( 3, ( \"before compression: msglen = %d, \",\n                   ssl->out_msglen ) );\n\n    SSL_DEBUG_BUF( 4, \"before compression: output payload\",\n                   ssl->out_msg, ssl->out_msglen );\n\n    ssl->transform_out->ctx_deflate.next_in = msg_pre;\n    ssl->transform_out->ctx_deflate.avail_in = len_pre;\n    ssl->transform_out->ctx_deflate.next_out = msg_post;\n    ssl->transform_out->ctx_deflate.avail_out = SSL_BUFFER_LEN;\n\n    ret = deflate( &ssl->transform_out->ctx_deflate, Z_SYNC_FLUSH );\n    if( ret != Z_OK )\n    {\n        SSL_DEBUG_MSG( 1, ( \"failed to perform compression (%d)\", ret ) );\n        return( POLARSSL_ERR_SSL_COMPRESSION_FAILED );\n    }\n\n    ssl->out_msglen = SSL_BUFFER_LEN - ssl->transform_out->ctx_deflate.avail_out;\n\n    free( msg_pre );\n\n    SSL_DEBUG_MSG( 3, ( \"after compression: msglen = %d, \",\n                   ssl->out_msglen ) );\n\n    SSL_DEBUG_BUF( 4, \"after compression: output payload\",\n                   ssl->out_msg, ssl->out_msglen );\n\n    SSL_DEBUG_MSG( 2, ( \"<= compress buf\" ) );\n\n    return( 0 );\n}\n\nstatic int ssl_decompress_buf( ssl_context *ssl )\n{\n    int ret;\n    unsigned char *msg_post = ssl->in_msg;\n    size_t len_pre = ssl->in_msglen;\n    unsigned char *msg_pre;\n\n    SSL_DEBUG_MSG( 2, ( \"=> decompress buf\" ) );\n\n    msg_pre = (unsigned char*) malloc( len_pre );\n    if( msg_pre == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len_pre ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memcpy( msg_pre, ssl->in_msg, len_pre );\n\n    SSL_DEBUG_MSG( 3, ( \"before decompression: msglen = %d, \",\n                   ssl->in_msglen ) );\n\n    SSL_DEBUG_BUF( 4, \"before decompression: input payload\",\n                   ssl->in_msg, ssl->in_msglen );\n\n    ssl->transform_in->ctx_inflate.next_in = msg_pre;\n    ssl->transform_in->ctx_inflate.avail_in = len_pre;\n    ssl->transform_in->ctx_inflate.next_out = msg_post;\n    ssl->transform_in->ctx_inflate.avail_out = SSL_MAX_CONTENT_LEN;\n\n    ret = inflate( &ssl->transform_in->ctx_inflate, Z_SYNC_FLUSH );\n    if( ret != Z_OK )\n    {\n        SSL_DEBUG_MSG( 1, ( \"failed to perform decompression (%d)\", ret ) );\n        return( POLARSSL_ERR_SSL_COMPRESSION_FAILED );\n    }\n\n    ssl->in_msglen = SSL_MAX_CONTENT_LEN - ssl->transform_in->ctx_inflate.avail_out;\n\n    free( msg_pre );\n\n    SSL_DEBUG_MSG( 3, ( \"after decompression: msglen = %d, \",\n                   ssl->in_msglen ) );\n\n    SSL_DEBUG_BUF( 4, \"after decompression: input payload\",\n                   ssl->in_msg, ssl->in_msglen );\n\n    SSL_DEBUG_MSG( 2, ( \"<= decompress buf\" ) );\n\n    return( 0 );\n}\n#endif /* POLARSSL_ZLIB_SUPPORT */\n\n/*\n * Fill the input message buffer\n */\nint ssl_fetch_input( ssl_context *ssl, size_t nb_want )\n{\n    int ret;\n    size_t len;\n\n    SSL_DEBUG_MSG( 2, ( \"=> fetch input\" ) );\n\n    while( ssl->in_left < nb_want )\n    {\n        len = nb_want - ssl->in_left;\n        ret = ssl->f_recv( ssl->p_recv, ssl->in_hdr + ssl->in_left, len );\n\n        SSL_DEBUG_MSG( 2, ( \"in_left: %d, nb_want: %d\",\n                       ssl->in_left, nb_want ) );\n        SSL_DEBUG_RET( 2, \"ssl->f_recv\", ret );\n\n        if( ret == 0 )\n            return( POLARSSL_ERR_SSL_CONN_EOF );\n\n        if( ret < 0 )\n            return( ret );\n\n        ssl->in_left += ret;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= fetch input\" ) );\n\n    return( 0 );\n}\n\n/*\n * Flush any data not yet written\n */\nint ssl_flush_output( ssl_context *ssl )\n{\n    int ret;\n    unsigned char *buf;\n\n    SSL_DEBUG_MSG( 2, ( \"=> flush output\" ) );\n\n    while( ssl->out_left > 0 )\n    {\n        SSL_DEBUG_MSG( 2, ( \"message length: %d, out_left: %d\",\n                       5 + ssl->out_msglen, ssl->out_left ) );\n\n        if( ssl->out_msglen < ssl->out_left )\n        {\n            size_t header_left = ssl->out_left - ssl->out_msglen;\n\n            buf = ssl->out_hdr + 5 - header_left;\n            ret = ssl->f_send( ssl->p_send, buf, header_left );\n            \n            SSL_DEBUG_RET( 2, \"ssl->f_send (header)\", ret );\n\n            if( ret <= 0 )\n                return( ret );\n\n            ssl->out_left -= ret;\n        }\n        \n        buf = ssl->out_msg + ssl->out_msglen - ssl->out_left;\n        ret = ssl->f_send( ssl->p_send, buf, ssl->out_left );\n\n        SSL_DEBUG_RET( 2, \"ssl->f_send\", ret );\n\n        if( ret <= 0 )\n            return( ret );\n\n        ssl->out_left -= ret;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= flush output\" ) );\n\n    return( 0 );\n}\n\n/*\n * Record layer functions\n */\nint ssl_write_record( ssl_context *ssl )\n{\n    int ret, done = 0;\n    size_t len = ssl->out_msglen;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write record\" ) );\n\n    if( ssl->out_msgtype == SSL_MSG_HANDSHAKE )\n    {\n        ssl->out_msg[1] = (unsigned char)( ( len - 4 ) >> 16 );\n        ssl->out_msg[2] = (unsigned char)( ( len - 4 ) >>  8 );\n        ssl->out_msg[3] = (unsigned char)( ( len - 4 )       );\n\n        ssl->handshake->update_checksum( ssl, ssl->out_msg, len );\n    }\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    if( ssl->transform_out != NULL &&\n        ssl->session_out->compression == SSL_COMPRESS_DEFLATE )\n    {\n        if( ( ret = ssl_compress_buf( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_compress_buf\", ret );\n            return( ret );\n        }\n\n        len = ssl->out_msglen;\n    }\n#endif /*POLARSSL_ZLIB_SUPPORT */\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_write != NULL)\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_write()\" ) );\n\n        ret = ssl_hw_record_write( ssl );\n        if( ret != 0 && ret != POLARSSL_ERR_SSL_HW_ACCEL_FALLTHROUGH )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_write\", ret );\n            return POLARSSL_ERR_SSL_HW_ACCEL_FAILED;\n        }\n        done = 1;\n    }\n#endif\n    if( !done )\n    {\n        ssl->out_hdr[0] = (unsigned char) ssl->out_msgtype;\n        ssl->out_hdr[1] = (unsigned char) ssl->major_ver;\n        ssl->out_hdr[2] = (unsigned char) ssl->minor_ver;\n        ssl->out_hdr[3] = (unsigned char)( len >> 8 );\n        ssl->out_hdr[4] = (unsigned char)( len      );\n\n        if( ssl->transform_out != NULL )\n        {\n            if( ( ret = ssl_encrypt_buf( ssl ) ) != 0 )\n            {\n                SSL_DEBUG_RET( 1, \"ssl_encrypt_buf\", ret );\n                return( ret );\n            }\n\n            len = ssl->out_msglen;\n            ssl->out_hdr[3] = (unsigned char)( len >> 8 );\n            ssl->out_hdr[4] = (unsigned char)( len      );\n        }\n\n        ssl->out_left = 5 + ssl->out_msglen;\n\n        SSL_DEBUG_MSG( 3, ( \"output record: msgtype = %d, \"\n                            \"version = [%d:%d], msglen = %d\",\n                       ssl->out_hdr[0], ssl->out_hdr[1], ssl->out_hdr[2],\n                     ( ssl->out_hdr[3] << 8 ) | ssl->out_hdr[4] ) );\n\n        SSL_DEBUG_BUF( 4, \"output record header sent to network\",\n                       ssl->out_hdr, 5 );\n        SSL_DEBUG_BUF( 4, \"output record sent to network\",\n                       ssl->out_hdr + 32, ssl->out_msglen );\n    }\n\n    if( ( ret = ssl_flush_output( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_flush_output\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write record\" ) );\n\n    return( 0 );\n}\n\nint ssl_read_record( ssl_context *ssl )\n{\n    int ret, done = 0;\n\n    SSL_DEBUG_MSG( 2, ( \"=> read record\" ) );\n\n    if( ssl->in_hslen != 0 &&\n        ssl->in_hslen < ssl->in_msglen )\n    {\n        /*\n         * Get next Handshake message in the current record\n         */\n        ssl->in_msglen -= ssl->in_hslen;\n\n        memmove( ssl->in_msg, ssl->in_msg + ssl->in_hslen,\n                 ssl->in_msglen );\n\n        ssl->in_hslen  = 4;\n        ssl->in_hslen += ( ssl->in_msg[2] << 8 ) | ssl->in_msg[3];\n\n        SSL_DEBUG_MSG( 3, ( \"handshake message: msglen =\"\n                            \" %d, type = %d, hslen = %d\",\n                       ssl->in_msglen, ssl->in_msg[0], ssl->in_hslen ) );\n\n        if( ssl->in_msglen < 4 || ssl->in_msg[1] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad handshake length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl->in_msglen < ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad handshake length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );\n\n        return( 0 );\n    }\n\n    ssl->in_hslen = 0;\n\n    /*\n     * Read the record header and validate it\n     */\n    if( ( ret = ssl_fetch_input( ssl, 5 ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_fetch_input\", ret );\n        return( ret );\n    }\n\n    ssl->in_msgtype =  ssl->in_hdr[0];\n    ssl->in_msglen = ( ssl->in_hdr[3] << 8 ) | ssl->in_hdr[4];\n\n    SSL_DEBUG_MSG( 3, ( \"input record: msgtype = %d, \"\n                        \"version = [%d:%d], msglen = %d\",\n                     ssl->in_hdr[0], ssl->in_hdr[1], ssl->in_hdr[2],\n                   ( ssl->in_hdr[3] << 8 ) | ssl->in_hdr[4] ) );\n\n    if( ssl->in_hdr[1] != ssl->major_ver )\n    {\n        SSL_DEBUG_MSG( 1, ( \"major version mismatch\" ) );\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    if( ssl->in_hdr[2] > ssl->max_minor_ver )\n    {\n        SSL_DEBUG_MSG( 1, ( \"minor version mismatch\" ) );\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    /*\n     * Make sure the message length is acceptable\n     */\n    if( ssl->transform_in == NULL )\n    {\n        if( ssl->in_msglen < 1 ||\n            ssl->in_msglen > SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n    }\n    else\n    {\n        if( ssl->in_msglen < ssl->transform_in->minlen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl->minor_ver == SSL_MINOR_VERSION_0 &&\n            ssl->in_msglen > ssl->transform_in->minlen + SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        /*\n         * TLS encrypted messages can have up to 256 bytes of padding\n         */\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_1 &&\n            ssl->in_msglen > ssl->transform_in->minlen + SSL_MAX_CONTENT_LEN + 256 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n    }\n\n    /*\n     * Read and optionally decrypt the message contents\n     */\n    if( ( ret = ssl_fetch_input( ssl, 5 + ssl->in_msglen ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_fetch_input\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_BUF( 4, \"input record from network\",\n                   ssl->in_hdr, 5 + ssl->in_msglen );\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_read != NULL)\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_read()\" ) );\n\n        ret = ssl_hw_record_read( ssl );\n        if( ret != 0 && ret != POLARSSL_ERR_SSL_HW_ACCEL_FALLTHROUGH )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_read\", ret );\n            return POLARSSL_ERR_SSL_HW_ACCEL_FAILED;\n        }\n        done = 1;\n    }\n#endif\n    if( !done && ssl->transform_in != NULL )\n    {\n        if( ( ret = ssl_decrypt_buf( ssl ) ) != 0 )\n        {\n#if defined(POLARSSL_SSL_ALERT_MESSAGES)\n            if( ret == POLARSSL_ERR_SSL_INVALID_MAC )\n            {\n                ssl_send_alert_message( ssl,\n                                        SSL_ALERT_LEVEL_FATAL,\n                                        SSL_ALERT_MSG_BAD_RECORD_MAC );\n            }\n#endif\n            SSL_DEBUG_RET( 1, \"ssl_decrypt_buf\", ret );\n            return( ret );\n        }\n\n        SSL_DEBUG_BUF( 4, \"input payload after decrypt\",\n                       ssl->in_msg, ssl->in_msglen );\n\n        if( ssl->in_msglen > SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n    }\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    if( ssl->transform_in != NULL &&\n        ssl->session_in->compression == SSL_COMPRESS_DEFLATE )\n    {\n        if( ( ret = ssl_decompress_buf( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_decompress_buf\", ret );\n            return( ret );\n        }\n\n        ssl->in_hdr[3] = (unsigned char)( ssl->in_msglen >> 8 );\n        ssl->in_hdr[4] = (unsigned char)( ssl->in_msglen      );\n    }\n#endif /* POLARSSL_ZLIB_SUPPORT */\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE &&\n        ssl->in_msgtype != SSL_MSG_ALERT &&\n        ssl->in_msgtype != SSL_MSG_CHANGE_CIPHER_SPEC &&\n        ssl->in_msgtype != SSL_MSG_APPLICATION_DATA )\n    {\n        SSL_DEBUG_MSG( 1, ( \"unknown record type\" ) );\n\n        if( ( ret = ssl_send_alert_message( ssl,\n                        SSL_ALERT_LEVEL_FATAL,\n                        SSL_ALERT_MSG_UNEXPECTED_MESSAGE ) ) != 0 )\n        {\n            return( ret );\n        }\n\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    if( ssl->in_msgtype == SSL_MSG_HANDSHAKE )\n    {\n        ssl->in_hslen  = 4;\n        ssl->in_hslen += ( ssl->in_msg[2] << 8 ) | ssl->in_msg[3];\n\n        SSL_DEBUG_MSG( 3, ( \"handshake message: msglen =\"\n                            \" %d, type = %d, hslen = %d\",\n                       ssl->in_msglen, ssl->in_msg[0], ssl->in_hslen ) );\n\n        /*\n         * Additional checks to validate the handshake header\n         */\n        if( ssl->in_msglen < 4 || ssl->in_msg[1] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad handshake length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl->in_msglen < ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad handshake length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl->state != SSL_HANDSHAKE_OVER )\n            ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );\n    }\n\n    if( ssl->in_msgtype == SSL_MSG_ALERT )\n    {\n        SSL_DEBUG_MSG( 2, ( \"got an alert message, type: [%d:%d]\",\n                       ssl->in_msg[0], ssl->in_msg[1] ) );\n\n        /*\n         * Ignore non-fatal alerts, except close_notify\n         */\n        if( ssl->in_msg[0] == SSL_ALERT_LEVEL_FATAL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"is a fatal alert message (msg %d)\",\n                           ssl->in_msg[1] ) );\n            /**\n             * Subtract from error code as ssl->in_msg[1] is 7-bit positive\n             * error identifier.\n             */\n            return( POLARSSL_ERR_SSL_FATAL_ALERT_MESSAGE );\n        }\n\n        if( ssl->in_msg[0] == SSL_ALERT_LEVEL_WARNING &&\n            ssl->in_msg[1] == SSL_ALERT_MSG_CLOSE_NOTIFY )\n        {\n            SSL_DEBUG_MSG( 2, ( \"is a close notify message\" ) );\n            return( POLARSSL_ERR_SSL_PEER_CLOSE_NOTIFY );\n        }\n    }\n\n    ssl->in_left = 0;\n\n    SSL_DEBUG_MSG( 2, ( \"<= read record\" ) );\n\n    return( 0 );\n}\n\nint ssl_send_fatal_handshake_failure( ssl_context *ssl )\n{\n    int ret;\n\n    if( ( ret = ssl_send_alert_message( ssl,\n                    SSL_ALERT_LEVEL_FATAL,\n                    SSL_ALERT_MSG_HANDSHAKE_FAILURE ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    return( 0 );\n}\n\nint ssl_send_alert_message( ssl_context *ssl,\n                            unsigned char level,\n                            unsigned char message )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> send alert message\" ) );\n\n    ssl->out_msgtype = SSL_MSG_ALERT;\n    ssl->out_msglen = 2;\n    ssl->out_msg[0] = level;\n    ssl->out_msg[1] = message;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= send alert message\" ) );\n\n    return( 0 );\n}\n\n/*\n * Handshake functions\n */\nint ssl_write_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n    const x509_cert *crt;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write certificate\" ) );\n\n    if( ssl->endpoint == SSL_IS_CLIENT )\n    {\n        if( ssl->client_auth == 0 )\n        {\n            SSL_DEBUG_MSG( 2, ( \"<= skip write certificate\" ) );\n            ssl->state++;\n            return( 0 );\n        }\n\n        /*\n         * If using SSLv3 and got no cert, send an Alert message\n         * (otherwise an empty Certificate message will be sent).\n         */\n        if( ssl->own_cert  == NULL &&\n            ssl->minor_ver == SSL_MINOR_VERSION_0 )\n        {\n            ssl->out_msglen  = 2;\n            ssl->out_msgtype = SSL_MSG_ALERT;\n            ssl->out_msg[0]  = SSL_ALERT_LEVEL_WARNING;\n            ssl->out_msg[1]  = SSL_ALERT_MSG_NO_CERT;\n\n            SSL_DEBUG_MSG( 2, ( \"got no certificate to send\" ) );\n            goto write_msg;\n        }\n    }\n    else /* SSL_IS_SERVER */\n    {\n        if( ssl->own_cert == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"got no certificate to send\" ) );\n            return( POLARSSL_ERR_SSL_CERTIFICATE_REQUIRED );\n        }\n    }\n\n    SSL_DEBUG_CRT( 3, \"own certificate\", ssl->own_cert );\n\n    /*\n     *     0  .  0    handshake type\n     *     1  .  3    handshake length\n     *     4  .  6    length of all certs\n     *     7  .  9    length of cert. 1\n     *    10  . n-1   peer certificate\n     *     n  . n+2   length of cert. 2\n     *    n+3 . ...   upper level cert, etc.\n     */\n    i = 7;\n    crt = ssl->own_cert;\n\n    while( crt != NULL )\n    {\n        n = crt->raw.len;\n        if( i + 3 + n > SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"certificate too large, %d > %d\",\n                           i + 3 + n, SSL_MAX_CONTENT_LEN ) );\n            return( POLARSSL_ERR_SSL_CERTIFICATE_TOO_LARGE );\n        }\n\n        ssl->out_msg[i    ] = (unsigned char)( n >> 16 );\n        ssl->out_msg[i + 1] = (unsigned char)( n >>  8 );\n        ssl->out_msg[i + 2] = (unsigned char)( n       );\n\n        i += 3; memcpy( ssl->out_msg + i, crt->raw.p, n );\n        i += n; crt = crt->next;\n    }\n\n    ssl->out_msg[4]  = (unsigned char)( ( i - 7 ) >> 16 );\n    ssl->out_msg[5]  = (unsigned char)( ( i - 7 ) >>  8 );\n    ssl->out_msg[6]  = (unsigned char)( ( i - 7 )       );\n\n    ssl->out_msglen  = i;\n    ssl->out_msgtype = SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = SSL_HS_CERTIFICATE;\n\nwrite_msg:\n\n    ssl->state++;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write certificate\" ) );\n\n    return( 0 );\n}\n\nint ssl_parse_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse certificate\" ) );\n\n    if( ssl->endpoint == SSL_IS_SERVER &&\n        ssl->authmode == SSL_VERIFY_NONE )\n    {\n        ssl->verify_result = BADCERT_SKIP_VERIFY;\n        SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_msglen  == 2                        &&\n            ssl->in_msgtype == SSL_MSG_ALERT            &&\n            ssl->in_msg[0]  == SSL_ALERT_LEVEL_WARNING  &&\n            ssl->in_msg[1]  == SSL_ALERT_MSG_NO_CERT )\n        {\n            SSL_DEBUG_MSG( 1, ( \"SSLv3 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_OPTIONAL )\n                return( 0 );\n            else\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver != SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_hslen   == 7                    &&\n            ssl->in_msgtype == SSL_MSG_HANDSHAKE    &&\n            ssl->in_msg[0]  == SSL_HS_CERTIFICATE   &&\n            memcmp( ssl->in_msg + 4, \"\\0\\0\\0\", 3 ) == 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"TLSv1 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_REQUIRED )\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n            else\n                return( 0 );\n        }\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msg[0] != SSL_HS_CERTIFICATE || ssl->in_hslen < 10 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /*\n     * Same message structure as in ssl_write_certificate()\n     */\n    n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];\n\n    if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    if( ( ssl->session_negotiate->peer_cert = (x509_cert *) malloc(\n                    sizeof( x509_cert ) ) ) == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\",\n                       sizeof( x509_cert ) ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->session_negotiate->peer_cert, 0, sizeof( x509_cert ) );\n\n    i = 7;\n\n    while( i < ssl->in_hslen )\n    {\n        if( ssl->in_msg[i] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,\n                             n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );\n\n    if( ssl->authmode != SSL_VERIFY_NONE )\n    {\n        if( ssl->ca_chain == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"got no CA chain\" ) );\n            return( POLARSSL_ERR_SSL_CA_CHAIN_REQUIRED );\n        }\n\n        ret = x509parse_verify( ssl->session_negotiate->peer_cert,\n                                ssl->ca_chain, ssl->ca_crl,\n                                ssl->peer_cn,  &ssl->verify_result,\n                                ssl->f_vrfy, ssl->p_vrfy );\n\n        if( ret != 0 )\n            SSL_DEBUG_RET( 1, \"x509_verify_cert\", ret );\n\n        if( ssl->authmode != SSL_VERIFY_REQUIRED )\n            ret = 0;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse certificate\" ) );\n\n    return( ret );\n}\n\nint ssl_write_change_cipher_spec( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write change cipher spec\" ) );\n\n    ssl->out_msgtype = SSL_MSG_CHANGE_CIPHER_SPEC;\n    ssl->out_msglen  = 1;\n    ssl->out_msg[0]  = 1;\n\n    ssl->state++;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write change cipher spec\" ) );\n\n    return( 0 );\n}\n\nint ssl_parse_change_cipher_spec( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse change cipher spec\" ) );\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_CHANGE_CIPHER_SPEC )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad change cipher spec message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msglen != 1 || ssl->in_msg[0] != 1 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad change cipher spec message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC );\n    }\n\n    ssl->state++;\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse change cipher spec\" ) );\n\n    return( 0 );\n}\n\nvoid ssl_optimize_checksum( ssl_context *ssl, int ciphersuite )\n{\n#if !defined(POLARSSL_SHA4_C)\n    ((void) ciphersuite);\n#endif\n\n    if( ssl->minor_ver < SSL_MINOR_VERSION_3 )\n        ssl->handshake->update_checksum = ssl_update_checksum_md5sha1;\n#if defined(POLARSSL_SHA4_C)\n    else if ( ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n              ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n    {\n        ssl->handshake->update_checksum = ssl_update_checksum_sha384;\n    }\n#endif\n    else\n        ssl->handshake->update_checksum = ssl_update_checksum_sha256;\n}\n    \nstatic void ssl_update_checksum_start( ssl_context *ssl, unsigned char *buf,\n                                       size_t len )\n{\n     md5_update( &ssl->handshake->fin_md5 , buf, len );\n    sha1_update( &ssl->handshake->fin_sha1, buf, len );\n    sha2_update( &ssl->handshake->fin_sha2, buf, len );\n#if defined(POLARSSL_SHA4_C)\n    sha4_update( &ssl->handshake->fin_sha4, buf, len );\n#endif\n}\n\nstatic void ssl_update_checksum_md5sha1( ssl_context *ssl, unsigned char *buf,\n                                         size_t len )\n{\n     md5_update( &ssl->handshake->fin_md5 , buf, len );\n    sha1_update( &ssl->handshake->fin_sha1, buf, len );\n}\n\nstatic void ssl_update_checksum_sha256( ssl_context *ssl, unsigned char *buf,\n                                        size_t len )\n{\n    sha2_update( &ssl->handshake->fin_sha2, buf, len );\n}\n\n#if defined(POLARSSL_SHA4_C)\nstatic void ssl_update_checksum_sha384( ssl_context *ssl, unsigned char *buf,\n                                        size_t len )\n{\n    sha4_update( &ssl->handshake->fin_sha4, buf, len );\n}\n#endif\n\nstatic void ssl_calc_finished_ssl(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    const char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n\n    unsigned char padbuf[48];\n    unsigned char md5sum[16];\n    unsigned char sha1sum[20];\n\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished ssl\" ) );\n\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n\n    /*\n     * SSLv3:\n     *   hash =\n     *      MD5( master + pad2 +\n     *          MD5( handshake + sender + master + pad1 ) )\n     *   + SHA1( master + pad2 +\n     *         SHA1( handshake + sender + master + pad1 ) )\n     */\n\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n\n    sender = ( from == SSL_IS_CLIENT ) ? \"CLNT\"\n                                       : \"SRVR\";\n\n    memset( padbuf, 0x36, 48 );\n\n    md5_update( &md5, (const unsigned char *) sender, 4 );\n    md5_update( &md5, session->master, 48 );\n    md5_update( &md5, padbuf, 48 );\n    md5_finish( &md5, md5sum );\n\n    sha1_update( &sha1, (const unsigned char *) sender, 4 );\n    sha1_update( &sha1, session->master, 48 );\n    sha1_update( &sha1, padbuf, 40 );\n    sha1_finish( &sha1, sha1sum );\n\n    memset( padbuf, 0x5C, 48 );\n\n    md5_starts( &md5 );\n    md5_update( &md5, session->master, 48 );\n    md5_update( &md5, padbuf, 48 );\n    md5_update( &md5, md5sum, 16 );\n    md5_finish( &md5, buf );\n\n    sha1_starts( &sha1 );\n    sha1_update( &sha1, session->master, 48 );\n    sha1_update( &sha1, padbuf , 40 );\n    sha1_update( &sha1, sha1sum, 20 );\n    sha1_finish( &sha1, buf + 16 );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, 36 );\n\n    memset(  &md5, 0, sizeof(  md5_context ) );\n    memset( &sha1, 0, sizeof( sha1_context ) );\n\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n    memset(  md5sum, 0, sizeof(  md5sum ) );\n    memset( sha1sum, 0, sizeof( sha1sum ) );\n\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}\n\nstatic void ssl_calc_finished_tls(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    const char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n    unsigned char padbuf[36];\n\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls\" ) );\n\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n\n    /*\n     * TLSv1:\n     *   hash = PRF( master, finished_label,\n     *               MD5( handshake ) + SHA1( handshake ) )[0..11]\n     */\n\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n\n    sender = ( from == SSL_IS_CLIENT )\n             ? \"client finished\"\n             : \"server finished\";\n\n    md5_finish(  &md5, padbuf );\n    sha1_finish( &sha1, padbuf + 16 );\n\n    ssl->handshake->tls_prf( session->master, 48, (char *) sender,\n                             padbuf, 36, buf, len );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n\n    memset(  &md5, 0, sizeof(  md5_context ) );\n    memset( &sha1, 0, sizeof( sha1_context ) );\n\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}\n\nstatic void ssl_calc_finished_tls_sha256(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    const char *sender;\n    sha2_context sha2;\n    unsigned char padbuf[32];\n\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls sha256\" ) );\n\n    memcpy( &sha2, &ssl->handshake->fin_sha2, sizeof(sha2_context) );\n\n    /*\n     * TLSv1.2:\n     *   hash = PRF( master, finished_label,\n     *               Hash( handshake ) )[0.11]\n     */\n\n    SSL_DEBUG_BUF( 4, \"finished sha2 state\", (unsigned char *)\n                   sha2.state, sizeof( sha2.state ) );\n\n    sender = ( from == SSL_IS_CLIENT )\n             ? \"client finished\"\n             : \"server finished\";\n\n    sha2_finish( &sha2, padbuf );\n\n    ssl->handshake->tls_prf( session->master, 48, (char *) sender,\n                             padbuf, 32, buf, len );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n\n    memset( &sha2, 0, sizeof( sha2_context ) );\n\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}\n\n#if defined(POLARSSL_SHA4_C)\nstatic void ssl_calc_finished_tls_sha384(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    const char *sender;\n    sha4_context sha4;\n    unsigned char padbuf[48];\n\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls sha384\" ) );\n\n    memcpy( &sha4, &ssl->handshake->fin_sha4, sizeof(sha4_context) );\n\n    /*\n     * TLSv1.2:\n     *   hash = PRF( master, finished_label,\n     *               Hash( handshake ) )[0.11]\n     */\n\n    SSL_DEBUG_BUF( 4, \"finished sha4 state\", (unsigned char *)\n                   sha4.state, sizeof( sha4.state ) );\n\n    sender = ( from == SSL_IS_CLIENT )\n             ? \"client finished\"\n             : \"server finished\";\n\n    sha4_finish( &sha4, padbuf );\n\n    ssl->handshake->tls_prf( session->master, 48, (char *) sender,\n                             padbuf, 48, buf, len );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n\n    memset( &sha4, 0, sizeof( sha4_context ) );\n\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}\n#endif\n\nvoid ssl_handshake_wrapup( ssl_context *ssl )\n{\n    SSL_DEBUG_MSG( 3, ( \"=> handshake wrapup\" ) );\n\n    /*\n     * Free our handshake params\n     */\n    ssl_handshake_free( ssl->handshake );\n    free( ssl->handshake );\n    ssl->handshake = NULL;\n\n    /*\n     * Switch in our now active transform context\n     */\n    if( ssl->transform )\n    {\n        ssl_transform_free( ssl->transform );\n        free( ssl->transform );\n    }\n    ssl->transform = ssl->transform_negotiate;\n    ssl->transform_negotiate = NULL;\n\n    if( ssl->session )\n    {\n        ssl_session_free( ssl->session );\n        free( ssl->session );\n    }\n    ssl->session = ssl->session_negotiate;\n    ssl->session_negotiate = NULL;\n\n    /*\n     * Add cache entry\n     */\n    if( ssl->f_set_cache != NULL )\n        if( ssl->f_set_cache( ssl->p_set_cache, ssl->session ) != 0 )\n            SSL_DEBUG_MSG( 1, ( \"cache did not store session\" ) );\n\n    ssl->state++;\n\n    SSL_DEBUG_MSG( 3, ( \"<= handshake wrapup\" ) );\n}\n\nint ssl_write_finished( ssl_context *ssl )\n{\n    int ret, hash_len;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write finished\" ) );\n\n    ssl->handshake->calc_finished( ssl, ssl->out_msg + 4, ssl->endpoint );\n\n    // TODO TLS/1.2 Hash length is determined by cipher suite (Page 63)\n    hash_len = ( ssl->minor_ver == SSL_MINOR_VERSION_0 ) ? 36 : 12;\n\n    ssl->verify_data_len = hash_len;\n    memcpy( ssl->own_verify_data, ssl->out_msg + 4, hash_len );\n\n    ssl->out_msglen  = 4 + hash_len;\n    ssl->out_msgtype = SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = SSL_HS_FINISHED;\n\n    /*\n     * In case of session resuming, invert the client and server\n     * ChangeCipherSpec messages order.\n     */\n    if( ssl->handshake->resume != 0 )\n    {\n        if( ssl->endpoint == SSL_IS_CLIENT )\n            ssl->state = SSL_HANDSHAKE_WRAPUP;\n        else\n            ssl->state = SSL_CLIENT_CHANGE_CIPHER_SPEC;\n    }\n    else\n        ssl->state++;\n\n    /*\n     * Switch to our negotiated transform and session parameters for outbound data.\n     */\n    SSL_DEBUG_MSG( 3, ( \"switching to new transform spec for outbound data\" ) );\n    ssl->transform_out = ssl->transform_negotiate;\n    ssl->session_out = ssl->session_negotiate;\n    memset( ssl->out_ctr, 0, 8 );\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write finished\" ) );\n\n    return( 0 );\n}\n\nint ssl_parse_finished( ssl_context *ssl )\n{\n    int ret;\n    unsigned int hash_len;\n    unsigned char buf[36];\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse finished\" ) );\n\n    ssl->handshake->calc_finished( ssl, buf, ssl->endpoint ^ 1 );\n\n    /*\n     * Switch to our negotiated transform and session parameters for inbound data.\n     */\n    SSL_DEBUG_MSG( 3, ( \"switching to new transform spec for inbound data\" ) );\n    ssl->transform_in = ssl->transform_negotiate;\n    ssl->session_in = ssl->session_negotiate;\n    memset( ssl->in_ctr, 0, 8 );\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    // TODO TLS/1.2 Hash length is determined by cipher suite (Page 63)\n    hash_len = ( ssl->minor_ver == SSL_MINOR_VERSION_0 ) ? 36 : 12;\n\n    if( ssl->in_msg[0] != SSL_HS_FINISHED ||\n        ssl->in_hslen  != 4 + hash_len )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_FINISHED );\n    }\n\n    if( memcmp( ssl->in_msg + 4, buf, hash_len ) != 0 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_FINISHED );\n    }\n\n    ssl->verify_data_len = hash_len;\n    memcpy( ssl->peer_verify_data, buf, hash_len );\n\n    if( ssl->handshake->resume != 0 )\n    {\n        if( ssl->endpoint == SSL_IS_CLIENT )\n            ssl->state = SSL_CLIENT_CHANGE_CIPHER_SPEC;\n\n        if( ssl->endpoint == SSL_IS_SERVER )\n            ssl->state = SSL_HANDSHAKE_WRAPUP;\n    }\n    else\n        ssl->state++;\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse finished\" ) );\n\n    return( 0 );\n}\n\nint ssl_handshake_init( ssl_context *ssl )\n{\n    if( ssl->transform_negotiate )\n        ssl_transform_free( ssl->transform_negotiate );\n    else\n        ssl->transform_negotiate = malloc( sizeof(ssl_transform) );\n\n    if( ssl->session_negotiate )\n        ssl_session_free( ssl->session_negotiate );\n    else\n        ssl->session_negotiate = malloc( sizeof(ssl_session) );\n\n    if( ssl->handshake )\n        ssl_handshake_free( ssl->handshake );\n    else\n        ssl->handshake = malloc( sizeof(ssl_handshake_params) );\n\n    if( ssl->handshake == NULL ||\n        ssl->transform_negotiate == NULL ||\n        ssl->session_negotiate == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc() of ssl sub-contexts failed\" ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->handshake, 0, sizeof(ssl_handshake_params) );\n    memset( ssl->transform_negotiate, 0, sizeof(ssl_transform) );\n    memset( ssl->session_negotiate, 0, sizeof(ssl_session) );\n\n     md5_starts( &ssl->handshake->fin_md5 );\n    sha1_starts( &ssl->handshake->fin_sha1 );\n    sha2_starts( &ssl->handshake->fin_sha2, 0 );\n#if defined(POLARSSL_SHA4_C)\n    sha4_starts( &ssl->handshake->fin_sha4, 1 );\n#endif\n\n    ssl->handshake->update_checksum = ssl_update_checksum_start;\n    ssl->handshake->sig_alg = SSL_HASH_SHA1;\n    \n    return( 0 );\n}\n\n/*\n * Initialize an SSL context\n */\nint ssl_init( ssl_context *ssl )\n{\n    int ret;\n    int len = SSL_BUFFER_LEN;\n\n    memset( ssl, 0, sizeof( ssl_context ) );\n\n    /*\n     * Sane defaults\n     */\n    ssl->rsa_decrypt = ssl_rsa_decrypt;\n    ssl->rsa_sign = ssl_rsa_sign;\n    ssl->rsa_key_len = ssl_rsa_key_len;\n\n    ssl->min_major_ver = SSL_MAJOR_VERSION_3;\n    ssl->min_minor_ver = SSL_MINOR_VERSION_0;\n\n    ssl->ciphersuites = malloc( sizeof(int *) * 4 );\n    ssl_set_ciphersuites( ssl, ssl_default_ciphersuites );\n\n#if defined(POLARSSL_DHM_C)\n    if( ( ret = mpi_read_string( &ssl->dhm_P, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_P) ) != 0 ||\n        ( ret = mpi_read_string( &ssl->dhm_G, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_G) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n#endif\n\n    /*\n     * Prepare base structures\n     */\n    ssl->in_ctr = (unsigned char *) malloc( len );\n    ssl->in_hdr = ssl->in_ctr +  8;\n    ssl->in_msg = ssl->in_ctr + 13;\n\n    if( ssl->in_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    ssl->out_ctr = (unsigned char *) malloc( len );\n    ssl->out_hdr = ssl->out_ctr +  8;\n    ssl->out_msg = ssl->out_ctr + 40;\n\n    if( ssl->out_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        free( ssl-> in_ctr );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl-> in_ctr, 0, SSL_BUFFER_LEN );\n    memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n\n    ssl->hostname = NULL;\n    ssl->hostname_len = 0;\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\n/*\n * Reset an initialized and used SSL context for re-use while retaining\n * all application-set variables, function pointers and data.\n */\nint ssl_session_reset( ssl_context *ssl )\n{\n    int ret;\n\n    ssl->state = SSL_HELLO_REQUEST;\n    ssl->renegotiation = SSL_INITIAL_HANDSHAKE;\n    ssl->secure_renegotiation = SSL_LEGACY_RENEGOTIATION;\n\n    ssl->verify_data_len = 0;\n    memset( ssl->own_verify_data, 0, 36 );\n    memset( ssl->peer_verify_data, 0, 36 );\n\n    ssl->in_offt = NULL;\n\n    ssl->in_msgtype = 0;\n    ssl->in_msglen = 0;\n    ssl->in_left = 0;\n\n    ssl->in_hslen = 0;\n    ssl->nb_zero = 0;\n\n    ssl->out_msgtype = 0;\n    ssl->out_msglen = 0;\n    ssl->out_left = 0;\n\n    ssl->transform_in = NULL;\n    ssl->transform_out = NULL;\n\n    memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n    memset( ssl->in_ctr, 0, SSL_BUFFER_LEN );\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_reset != NULL)\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_reset()\" ) );\n        if( ssl_hw_record_reset( ssl ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_reset\", ret );\n            return( POLARSSL_ERR_SSL_HW_ACCEL_FAILED );\n        }\n    }\n#endif\n\n    if( ssl->transform )\n    {\n        ssl_transform_free( ssl->transform );\n        free( ssl->transform );\n        ssl->transform = NULL;\n    }\n\n    if( ssl->session )\n    {\n        ssl_session_free( ssl->session );\n        free( ssl->session );\n        ssl->session = NULL;\n    }\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\n/*\n * SSL set accessors\n */\nvoid ssl_set_endpoint( ssl_context *ssl, int endpoint )\n{\n    ssl->endpoint   = endpoint;\n}\n\nvoid ssl_set_authmode( ssl_context *ssl, int authmode )\n{\n    ssl->authmode   = authmode;\n}\n\nvoid ssl_set_verify( ssl_context *ssl,\n                     int (*f_vrfy)(void *, x509_cert *, int, int *),\n                     void *p_vrfy )\n{\n    ssl->f_vrfy      = f_vrfy;\n    ssl->p_vrfy      = p_vrfy;\n}\n\nvoid ssl_set_rng( ssl_context *ssl,\n                  int (*f_rng)(void *, unsigned char *, size_t),\n                  void *p_rng )\n{\n    ssl->f_rng      = f_rng;\n    ssl->p_rng      = p_rng;\n}\n\nvoid ssl_set_dbg( ssl_context *ssl,\n                  void (*f_dbg)(void *, int, const char *),\n                  void  *p_dbg )\n{\n    ssl->f_dbg      = f_dbg;\n    ssl->p_dbg      = p_dbg;\n}\n\nvoid ssl_set_bio( ssl_context *ssl,\n            int (*f_recv)(void *, unsigned char *, size_t), void *p_recv,\n            int (*f_send)(void *, const unsigned char *, size_t), void *p_send )\n{\n    ssl->f_recv     = f_recv;\n    ssl->f_send     = f_send;\n    ssl->p_recv     = p_recv;\n    ssl->p_send     = p_send;\n}\n\nvoid ssl_set_session_cache( ssl_context *ssl,\n        int (*f_get_cache)(void *, ssl_session *), void *p_get_cache,\n        int (*f_set_cache)(void *, const ssl_session *), void *p_set_cache )\n{\n    ssl->f_get_cache = f_get_cache;\n    ssl->p_get_cache = p_get_cache;\n    ssl->f_set_cache = f_set_cache;\n    ssl->p_set_cache = p_set_cache;\n}\n\nvoid ssl_set_session( ssl_context *ssl, const ssl_session *session )\n{\n    memcpy( ssl->session_negotiate, session, sizeof(ssl_session) );\n    ssl->handshake->resume = 1;\n}\n\nvoid ssl_set_ciphersuites( ssl_context *ssl, const int *ciphersuites )\n{\n    ssl->ciphersuites[SSL_MINOR_VERSION_0] = ciphersuites;\n    ssl->ciphersuites[SSL_MINOR_VERSION_1] = ciphersuites;\n    ssl->ciphersuites[SSL_MINOR_VERSION_2] = ciphersuites;\n    ssl->ciphersuites[SSL_MINOR_VERSION_3] = ciphersuites;\n}\n\nvoid ssl_set_ciphersuites_for_version( ssl_context *ssl, const int *ciphersuites,\n                                       int major, int minor )\n{\n    if( major != SSL_MAJOR_VERSION_3 )\n        return;\n\n    if( minor < SSL_MINOR_VERSION_0 || minor > SSL_MINOR_VERSION_3 )\n        return;\n\n    ssl->ciphersuites[minor] = ciphersuites;\n}\n\nvoid ssl_set_ca_chain( ssl_context *ssl, x509_cert *ca_chain,\n                       x509_crl *ca_crl, const char *peer_cn )\n{\n    ssl->ca_chain   = ca_chain;\n    ssl->ca_crl     = ca_crl;\n    ssl->peer_cn    = peer_cn;\n}\n\nvoid ssl_set_own_cert( ssl_context *ssl, x509_cert *own_cert,\n                       rsa_context *rsa_key )\n{\n    ssl->own_cert   = own_cert;\n    ssl->rsa_key    = rsa_key;\n}\n\nvoid ssl_set_own_cert_alt( ssl_context *ssl, x509_cert *own_cert,\n                           void *rsa_key,\n                           rsa_decrypt_func rsa_decrypt,\n                           rsa_sign_func rsa_sign,\n                           rsa_key_len_func rsa_key_len )\n{\n    ssl->own_cert   = own_cert;\n    ssl->rsa_key    = rsa_key;\n    ssl->rsa_decrypt = rsa_decrypt;\n    ssl->rsa_sign = rsa_sign;\n    ssl->rsa_key_len = rsa_key_len;\n}\n\n\n#if defined(POLARSSL_DHM_C)\nint ssl_set_dh_param( ssl_context *ssl, const char *dhm_P, const char *dhm_G )\n{\n    int ret;\n\n    if( ( ret = mpi_read_string( &ssl->dhm_P, 16, dhm_P ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n\n    if( ( ret = mpi_read_string( &ssl->dhm_G, 16, dhm_G ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n\n    return( 0 );\n}\n\nint ssl_set_dh_param_ctx( ssl_context *ssl, dhm_context *dhm_ctx )\n{\n    int ret;\n\n    if( ( ret = mpi_copy(&ssl->dhm_P, &dhm_ctx->P) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_copy\", ret );\n        return( ret );\n    }\n\n    if( ( ret = mpi_copy(&ssl->dhm_G, &dhm_ctx->G) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_copy\", ret );\n        return( ret );\n    }\n\n    return( 0 );\n}\n#endif /* POLARSSL_DHM_C */\n\nint ssl_set_hostname( ssl_context *ssl, const char *hostname )\n{\n    if( hostname == NULL )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    ssl->hostname_len = strlen( hostname );\n    ssl->hostname = (unsigned char *) malloc( ssl->hostname_len + 1 );\n\n    if( ssl->hostname == NULL )\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n\n    memcpy( ssl->hostname, (const unsigned char *) hostname,\n            ssl->hostname_len );\n    \n    ssl->hostname[ssl->hostname_len] = '\\0';\n\n    return( 0 );\n}\n\nvoid ssl_set_sni( ssl_context *ssl,\n                  int (*f_sni)(void *, ssl_context *,\n                                const unsigned char *, size_t),\n                  void *p_sni )\n{\n    ssl->f_sni = f_sni;\n    ssl->p_sni = p_sni;\n}\n\nvoid ssl_set_max_version( ssl_context *ssl, int major, int minor )\n{\n    ssl->max_major_ver = major;\n    ssl->max_minor_ver = minor;\n}\n\nvoid ssl_set_min_version( ssl_context *ssl, int major, int minor )\n{\n    ssl->min_major_ver = major;\n    ssl->min_minor_ver = minor;\n}\n\nvoid ssl_set_renegotiation( ssl_context *ssl, int renegotiation )\n{\n    ssl->disable_renegotiation = renegotiation;\n}\n\nvoid ssl_legacy_renegotiation( ssl_context *ssl, int allow_legacy )\n{\n    ssl->allow_legacy_renegotiation = allow_legacy;\n}\n\n/*\n * SSL get accessors\n */\nsize_t ssl_get_bytes_avail( const ssl_context *ssl )\n{\n    return( ssl->in_offt == NULL ? 0 : ssl->in_msglen );\n}\n\nint ssl_get_verify_result( const ssl_context *ssl )\n{\n    return( ssl->verify_result );\n}\n\nconst char *ssl_get_ciphersuite_name( const int ciphersuite_id )\n{\n    switch( ciphersuite_id )\n    {\n#if defined(POLARSSL_ARC4_C)\n        case TLS_RSA_WITH_RC4_128_MD5:\n            return( \"TLS-RSA-WITH-RC4-128-MD5\" );\n\n        case TLS_RSA_WITH_RC4_128_SHA:\n            return( \"TLS-RSA-WITH-RC4-128-SHA\" );\n#endif\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_3DES_EDE_CBC_SHA:\n            return( \"TLS-RSA-WITH-3DES-EDE-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA\" );\n#endif\n\n#if defined(POLARSSL_AES_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA:\n            return( \"TLS-RSA-WITH-AES-128-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-AES-128-CBC-SHA\" );\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA:\n            return( \"TLS-RSA-WITH-AES-256-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-AES-256-CBC-SHA\" );\n\n#if defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA256:\n            return( \"TLS-RSA-WITH-AES-128-CBC-SHA256\" );\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA256:\n            return( \"TLS-RSA-WITH-AES-256-CBC-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:\n            return( \"TLS-DHE-RSA-WITH-AES-128-CBC-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:\n            return( \"TLS-DHE-RSA-WITH-AES-256-CBC-SHA256\" );\n#endif\n\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_AES_128_GCM_SHA256:\n            return( \"TLS-RSA-WITH-AES-128-GCM-SHA256\" );\n\n        case TLS_RSA_WITH_AES_256_GCM_SHA384:\n            return( \"TLS-RSA-WITH-AES-256-GCM-SHA384\" );\n#endif\n\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA4_C)\n        case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:\n            return( \"TLS-DHE-RSA-WITH-AES-128-GCM-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:\n            return( \"TLS-DHE-RSA-WITH-AES-256-GCM-SHA384\" );\n#endif\n#endif /* POLARSSL_AES_C */\n\n#if defined(POLARSSL_CAMELLIA_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:\n            return( \"TLS-RSA-WITH-CAMELLIA-128-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA\" );\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:\n            return( \"TLS-RSA-WITH-CAMELLIA-256-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA\" );\n\n#if defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n            return( \"TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n            return( \"TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256\" );\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n            return( \"TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n            return( \"TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256\" );\n#endif\n#endif\n\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        case TLS_RSA_WITH_NULL_MD5:\n            return( \"TLS-RSA-WITH-NULL-MD5\" );\n        case TLS_RSA_WITH_NULL_SHA:\n            return( \"TLS-RSA-WITH-NULL-SHA\" );\n        case TLS_RSA_WITH_NULL_SHA256:\n            return( \"TLS-RSA-WITH-NULL-SHA256\" );\n#endif /* defined(POLARSSL_CIPHER_NULL_CIPHER) */\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_DES_CBC_SHA:\n            return( \"TLS-RSA-WITH-DES-CBC-SHA\" );\n        case TLS_DHE_RSA_WITH_DES_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-DES-CBC-SHA\" );\n#endif\n#endif /* defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES) */\n\n    default:\n        break;\n    }\n\n    return( \"unknown\" );\n}\n\nint ssl_get_ciphersuite_id( const char *ciphersuite_name )\n{\n#if defined(POLARSSL_ARC4_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-RC4-128-MD5\"))\n        return( TLS_RSA_WITH_RC4_128_MD5 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-RC4-128-SHA\"))\n        return( TLS_RSA_WITH_RC4_128_SHA );\n#endif\n\n#if defined(POLARSSL_DES_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-3DES-EDE-CBC-SHA\"))\n        return( TLS_RSA_WITH_3DES_EDE_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA );\n#endif\n\n#if defined(POLARSSL_AES_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-128-CBC-SHA\"))\n        return( TLS_RSA_WITH_AES_128_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-128-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_AES_128_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-256-CBC-SHA\"))\n        return( TLS_RSA_WITH_AES_256_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-256-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_AES_256_CBC_SHA );\n\n#if defined(POLARSSL_SHA2_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-128-CBC-SHA256\"))\n        return( TLS_RSA_WITH_AES_128_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-256-CBC-SHA256\"))\n        return( TLS_RSA_WITH_AES_256_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-128-CBC-SHA256\"))\n        return( TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-256-CBC-SHA256\"))\n        return( TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 );\n#endif\n\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-128-GCM-SHA256\"))\n        return( TLS_RSA_WITH_AES_128_GCM_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-256-GCM-SHA384\"))\n        return( TLS_RSA_WITH_AES_256_GCM_SHA384 );\n#endif\n\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-128-GCM-SHA256\"))\n        return( TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-256-GCM-SHA384\"))\n        return( TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 );\n#endif\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-CAMELLIA-128-CBC-SHA\"))\n        return( TLS_RSA_WITH_CAMELLIA_128_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-CAMELLIA-256-CBC-SHA\"))\n        return( TLS_RSA_WITH_CAMELLIA_256_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA );\n\n#if defined(POLARSSL_SHA2_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256\"))\n        return( TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256\"))\n        return( TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256\"))\n        return( TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256\"))\n        return( TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 );\n#endif\n#endif\n\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-NULL-MD5\"))\n        return( TLS_RSA_WITH_NULL_MD5 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-NULL-SHA\"))\n        return( TLS_RSA_WITH_NULL_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-NULL-SHA256\"))\n        return( TLS_RSA_WITH_NULL_SHA256 );\n#endif /* defined(POLARSSL_CIPHER_NULL_CIPHER) */\n\n#if defined(POLARSSL_DES_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-DES-CBC-SHA\"))\n        return( TLS_RSA_WITH_DES_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-DES-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_DES_CBC_SHA );\n#endif\n#endif /* defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES) */\n\n    return( 0 );\n}\n\nconst char *ssl_get_ciphersuite( const ssl_context *ssl )\n{\n    if( ssl == NULL || ssl->session == NULL )\n        return NULL;\n\n    return ssl_get_ciphersuite_name( ssl->session->ciphersuite );\n}\n\nconst char *ssl_get_version( const ssl_context *ssl )\n{\n    switch( ssl->minor_ver )\n    {\n        case SSL_MINOR_VERSION_0:\n            return( \"SSLv3.0\" );\n\n        case SSL_MINOR_VERSION_1:\n            return( \"TLSv1.0\" );\n\n        case SSL_MINOR_VERSION_2:\n            return( \"TLSv1.1\" );\n\n        case SSL_MINOR_VERSION_3:\n            return( \"TLSv1.2\" );\n\n        default:\n            break;\n    }\n    return( \"unknown\" );\n}\n\nconst x509_cert *ssl_get_peer_cert( const ssl_context *ssl )\n{\n    if( ssl == NULL || ssl->session == NULL )\n        return NULL;\n\n    return ssl->session->peer_cert;\n}\n\nconst int ssl_default_ciphersuites[] =\n{\n#if defined(POLARSSL_DHM_C)\n#if defined(POLARSSL_AES_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA4_C)\n    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,\n#endif\n    TLS_DHE_RSA_WITH_AES_256_CBC_SHA,\n#if defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,\n#endif\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,\n#endif\n    TLS_DHE_RSA_WITH_AES_128_CBC_SHA,\n#endif\n#if defined(POLARSSL_CAMELLIA_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,\n#if defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,\n#endif\n#if defined(POLARSSL_DES_C)\n    TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA,\n#endif\n#endif\n\n#if defined(POLARSSL_AES_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_AES_256_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA4_C)\n    TLS_RSA_WITH_AES_256_GCM_SHA384,\n#endif /* POLARSSL_SHA2_C */\n    TLS_RSA_WITH_AES_256_CBC_SHA,\n#endif\n#if defined(POLARSSL_CAMELLIA_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,\n#endif\n#if defined(POLARSSL_AES_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_AES_128_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_AES_128_GCM_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_RSA_WITH_AES_128_CBC_SHA,\n#endif\n#if defined(POLARSSL_CAMELLIA_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_RSA_WITH_CAMELLIA_128_CBC_SHA,\n#endif\n#if defined(POLARSSL_DES_C)\n    TLS_RSA_WITH_3DES_EDE_CBC_SHA,\n#endif\n#if defined(POLARSSL_ARC4_C)\n    TLS_RSA_WITH_RC4_128_SHA,\n    TLS_RSA_WITH_RC4_128_MD5,\n#endif\n    0\n};\n\n/*\n * Perform a single step of the SSL handshake\n */\nint ssl_handshake_step( ssl_context *ssl )\n{\n    int ret = POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE;\n\n#if defined(POLARSSL_SSL_CLI_C)\n    if( ssl->endpoint == SSL_IS_CLIENT )\n        ret = ssl_handshake_client_step( ssl );\n#endif\n\n#if defined(POLARSSL_SSL_SRV_C)\n    if( ssl->endpoint == SSL_IS_SERVER )\n        ret = ssl_handshake_server_step( ssl );\n#endif\n\n    return( ret );\n}\n\n/*\n * Perform the SSL handshake\n */\nint ssl_handshake( ssl_context *ssl )\n{\n    int ret = 0;\n\n    SSL_DEBUG_MSG( 2, ( \"=> handshake\" ) );\n\n    while( ssl->state != SSL_HANDSHAKE_OVER )\n    {\n        ret = ssl_handshake_step( ssl );\n\n        if( ret != 0 )\n            break;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= handshake\" ) );\n\n    return( ret );\n}\n\n/*\n * Renegotiate current connection\n */\nint ssl_renegotiate( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> renegotiate\" ) );\n\n    if( ssl->state != SSL_HANDSHAKE_OVER )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    ssl->state = SSL_HELLO_REQUEST;\n    ssl->renegotiation = SSL_RENEGOTIATION;\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n\n    if( ( ret = ssl_handshake( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_handshake\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= renegotiate\" ) );\n\n    return( 0 );\n}\n\n/*\n * Receive application data decrypted from the SSL layer\n */\nint ssl_read( ssl_context *ssl, unsigned char *buf, size_t len )\n{\n    int ret;\n    size_t n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> read\" ) );\n\n    if( ssl->state != SSL_HANDSHAKE_OVER )\n    {\n        if( ( ret = ssl_handshake( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_handshake\", ret );\n            return( ret );\n        }\n    }\n\n    if( ssl->in_offt == NULL )\n    {\n        if( ( ret = ssl_read_record( ssl ) ) != 0 )\n        {\n            if( ret == POLARSSL_ERR_SSL_CONN_EOF )\n                return( 0 );\n\n            SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n            return( ret );\n        }\n\n        if( ssl->in_msglen  == 0 &&\n            ssl->in_msgtype == SSL_MSG_APPLICATION_DATA )\n        {\n            /*\n             * OpenSSL sends empty messages to randomize the IV\n             */\n            if( ( ret = ssl_read_record( ssl ) ) != 0 )\n            {\n                if( ret == POLARSSL_ERR_SSL_CONN_EOF )\n                    return( 0 );\n\n                SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n                return( ret );\n            }\n        }\n\n        if( ssl->in_msgtype == SSL_MSG_HANDSHAKE )\n        {\n            SSL_DEBUG_MSG( 1, ( \"received handshake message\" ) );\n\n            if( ssl->endpoint == SSL_IS_CLIENT &&\n                ( ssl->in_msg[0] != SSL_HS_HELLO_REQUEST ||\n                  ssl->in_hslen != 4 ) )\n            {\n                SSL_DEBUG_MSG( 1, ( \"handshake received (not HelloRequest)\" ) );\n                return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n            }\n\n            if( ssl->disable_renegotiation == SSL_RENEGOTIATION_DISABLED ||\n                ( ssl->secure_renegotiation == SSL_LEGACY_RENEGOTIATION &&\n                  ssl->allow_legacy_renegotiation == SSL_LEGACY_NO_RENEGOTIATION ) )\n            {\n                SSL_DEBUG_MSG( 3, ( \"ignoring renegotiation, sending alert\" ) );\n\n                if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n                {\n                    /*\n                     * SSLv3 does not have a \"no_renegotiation\" alert\n                     */\n                    if( ( ret = ssl_send_fatal_handshake_failure( ssl ) ) != 0 )\n                        return( ret );\n                }\n                else\n                {\n                    if( ( ret = ssl_send_alert_message( ssl,\n                                    SSL_ALERT_LEVEL_WARNING,\n                                    SSL_ALERT_MSG_NO_RENEGOTIATION ) ) != 0 )\n                    {\n                        return( ret );\n                    }\n                }\n            }\n            else\n            {\n                if( ( ret = ssl_renegotiate( ssl ) ) != 0 )\n                {\n                    SSL_DEBUG_RET( 1, \"ssl_renegotiate\", ret );\n                    return( ret );\n                }\n\n                return( POLARSSL_ERR_NET_WANT_READ );\n            }\n        }\n        else if( ssl->in_msgtype != SSL_MSG_APPLICATION_DATA )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad application data message\" ) );\n            return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        ssl->in_offt = ssl->in_msg;\n    }\n\n    n = ( len < ssl->in_msglen )\n        ? len : ssl->in_msglen;\n\n    memcpy( buf, ssl->in_offt, n );\n    ssl->in_msglen -= n;\n\n    if( ssl->in_msglen == 0 )\n        /* all bytes consumed  */\n        ssl->in_offt = NULL;\n    else\n        /* more data available */\n        ssl->in_offt += n;\n\n    SSL_DEBUG_MSG( 2, ( \"<= read\" ) );\n\n    return( (int) n );\n}\n\n/*\n * Send application data to be encrypted by the SSL layer\n */\nint ssl_write( ssl_context *ssl, const unsigned char *buf, size_t len )\n{\n    int ret;\n    size_t n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write\" ) );\n\n    if( ssl->state != SSL_HANDSHAKE_OVER )\n    {\n        if( ( ret = ssl_handshake( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_handshake\", ret );\n            return( ret );\n        }\n    }\n\n    n = ( len < SSL_MAX_CONTENT_LEN )\n        ? len : SSL_MAX_CONTENT_LEN;\n\n    if( ssl->out_left != 0 )\n    {\n        if( ( ret = ssl_flush_output( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_flush_output\", ret );\n            return( ret );\n        }\n    }\n    else\n    {\n        ssl->out_msglen  = n;\n        ssl->out_msgtype = SSL_MSG_APPLICATION_DATA;\n        memcpy( ssl->out_msg, buf, n );\n\n        if( ( ret = ssl_write_record( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n            return( ret );\n        }\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write\" ) );\n\n    return( (int) n );\n}\n\n/*\n * Notify the peer that the connection is being closed\n */\nint ssl_close_notify( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write close notify\" ) );\n\n    if( ( ret = ssl_flush_output( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_flush_output\", ret );\n        return( ret );\n    }\n\n    if( ssl->state == SSL_HANDSHAKE_OVER )\n    {\n        if( ( ret = ssl_send_alert_message( ssl,\n                        SSL_ALERT_LEVEL_WARNING,\n                        SSL_ALERT_MSG_CLOSE_NOTIFY ) ) != 0 )\n        {\n            return( ret );\n        }\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write close notify\" ) );\n\n    return( ret );\n}\n\nvoid ssl_transform_free( ssl_transform *transform )\n{\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    deflateEnd( &transform->ctx_deflate );\n    inflateEnd( &transform->ctx_inflate );\n#endif\n\n    memset( transform, 0, sizeof( ssl_transform ) );\n}\n\nvoid ssl_handshake_free( ssl_handshake_params *handshake )\n{\n#if defined(POLARSSL_DHM_C)\n    dhm_free( &handshake->dhm_ctx );\n#endif\n    memset( handshake, 0, sizeof( ssl_handshake_params ) );\n}\n\nvoid ssl_session_free( ssl_session *session )\n{\n    if( session->peer_cert != NULL )\n    {\n        x509_free( session->peer_cert );\n        free( session->peer_cert );\n    }\n\n    memset( session, 0, sizeof( ssl_session ) );\n}\n\n/*\n * Free an SSL context\n */\nvoid ssl_free( ssl_context *ssl )\n{\n    SSL_DEBUG_MSG( 2, ( \"=> free\" ) );\n\n    free( ssl->ciphersuites );\n\n    if( ssl->out_ctr != NULL )\n    {\n        memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n          free( ssl->out_ctr );\n    }\n\n    if( ssl->in_ctr != NULL )\n    {\n        memset( ssl->in_ctr, 0, SSL_BUFFER_LEN );\n          free( ssl->in_ctr );\n    }\n\n#if defined(POLARSSL_DHM_C)\n    mpi_free( &ssl->dhm_P );\n    mpi_free( &ssl->dhm_G );\n#endif\n\n    if( ssl->transform )\n    {\n        ssl_transform_free( ssl->transform );\n        free( ssl->transform );\n    }\n\n    if( ssl->handshake )\n    {\n        ssl_handshake_free( ssl->handshake );\n        ssl_transform_free( ssl->transform_negotiate );\n        ssl_session_free( ssl->session_negotiate );\n\n        free( ssl->handshake );\n        free( ssl->transform_negotiate );\n        free( ssl->session_negotiate );\n    }\n\n    if( ssl->session )\n    {\n        ssl_session_free( ssl->session );\n        free( ssl->session );\n    }\n\n    if ( ssl->hostname != NULL)\n    {\n        memset( ssl->hostname, 0, ssl->hostname_len );\n        free( ssl->hostname );\n        ssl->hostname_len = 0;\n    }\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_finish != NULL )\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_finish()\" ) );\n        ssl_hw_record_finish( ssl );\n    }\n#endif\n\n    SSL_DEBUG_MSG( 2, ( \"<= free\" ) );\n\n    /* Actually clear after last debug message */\n    memset( ssl, 0, sizeof( ssl_context ) );\n}\n\n#endif\n"], "fixing_code": ["PolarSSL ChangeLog\n\n= Branch 1.2\nChange\n   * HAVEGE random generator disabled by default\n\nBugfix\n   * Secure renegotiation extension should only be sent in case client\n     supports secure renegotiation\n   * Fixed offset for cert_type list in ssl_parse_certificate_request()\n   * Fixed const correctness issues that have no impact on the ABI\n   * x509parse_crt() now better handles PEM error situations\n   * ssl_parse_certificate() now calls x509parse_crt_der() directly\n     instead of the x509parse_crt() wrapper that can also parse PEM\n\t certificates\n\n= Version 1.2.7 released 2013-04-13\nFeatures\n   * Ability to specify allowed ciphersuites based on the protocol version.\n\nChanges\n   * Default Blowfish keysize is now 128-bits\n   * Test suites made smaller to accommodate Raspberry Pi\n\nBugfix\n   * Fix for MPI assembly for ARM\n   * GCM adapted to support sizes > 2^29\n\n= Version 1.2.6 released 2013-03-11\nBugfix\n   * Fixed memory leak in ssl_free() and ssl_reset() for active session\n   * Corrected GCM counter incrementation to use only 32-bits instead of\n     128-bits (found by Yawning Angel)\n   * Fixes for 64-bit compilation with MS Visual Studio\n   * Fixed net_bind() for specified IP addresses on little endian systems\n   * Fixed assembly code for ARM (Thumb and regular) for some compilers\n\nChanges\n   * Internally split up rsa_pkcs1_encrypt(), rsa_pkcs1_decrypt(),\n     rsa_pkcs1_sign() and rsa_pkcs1_verify() to separate PKCS#1 v1.5 and\n     PKCS#1 v2.1 functions\n   * Added support for custom labels when using rsa_rsaes_oaep_encrypt()\n     or rsa_rsaes_oaep_decrypt()\n   * Re-added handling for SSLv2 Client Hello when the define\n     POLARSSL_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO is set\n   * The SSL session cache module (ssl_cache) now also retains peer_cert\n     information (not the entire chain)\n\nSecurity\n   * Removed further timing differences during SSL message decryption in\n     ssl_decrypt_buf()\n   * Removed timing differences due to bad padding from\n     rsa_rsaes_pkcs1_v15_decrypt() and rsa_pkcs1_decrypt() for PKCS#1 v1.5\n     operations\n\n= Version 1.2.5 released 2013-02-02\nChanges\n   * Allow enabling of dummy error_strerror() to support some use-cases\n   * Debug messages about padding errors during SSL message decryption are\n     disabled by default and can be enabled with POLARSSL_SSL_DEBUG_ALL \n   * Sending of security-relevant alert messages that do not break\n     interoperability can be switched on/off with the flag\n     POLARSSL_SSL_ALL_ALERT_MESSAGES\n\nSecurity\n   * Removed timing differences during SSL message decryption in\n     ssl_decrypt_buf() due to badly formatted padding\n\n= Version 1.2.4 released 2013-01-25\nChanges\n   * Added ssl_handshake_step() to allow single stepping the handshake process\n\nBugfix\n   * Memory leak when using RSA_PKCS_V21 operations fixed\n   * Handle future version properly in ssl_write_certificate_request()\n   * Correctly handle CertificateRequest message in client for <= TLS 1.1\n     without DN list\n\n= Version 1.2.3 released 2012-11-26\nBugfix\n   * Server not always sending correct CertificateRequest message\n\n= Version 1.2.2 released 2012-11-24\nChanges\n   * Added p_hw_data to ssl_context for context specific hardware acceleration\n     data\n   * During verify trust-CA is only checked for expiration and CRL presence  \n\nBugfixes\n   * Fixed client authentication compatibility\n   * Fixed dependency on POLARSSL_SHA4_C in SSL modules\n\n= Version 1.2.1 released 2012-11-20\nChanges\n   * Depth that the certificate verify callback receives is now numbered\n     bottom-up (Peer cert depth is 0)\n\nBugfixes\n   * Fixes for MSVC6\n   * Moved mpi_inv_mod() outside POLARSSL_GENPRIME\n   * Allow R and A to point to same mpi in mpi_div_mpi (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Fixed possible segfault in mpi_shift_r() (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Added max length check for rsa_pkcs1_sign with PKCS#1 v2.1\n\n= Version 1.2.0 released 2012-10-31\nFeatures\n   * Added support for NULL cipher (POLARSSL_CIPHER_NULL_CIPHER) and weak\n     ciphersuites (POLARSSL_ENABLE_WEAK_CIPHERSUITES). They are disabled by\n     default!\n   * Added support for wildcard certificates\n   * Added support for multi-domain certificates through the X509 Subject\n     Alternative Name extension\n   * Added preliminary ASN.1 buffer writing support\n   * Added preliminary X509 Certificate Request writing support\n   * Added key_app_writer example application\n   * Added cert_req example application\n   * Added base Galois Counter Mode (GCM) for AES\n   * Added TLS 1.2 support (RFC 5246)\n   * Added GCM suites to TLS 1.2 (RFC 5288)\n   * Added commandline error code convertor (util/strerror)\n   * Added support for Hardware Acceleration hooking in SSL/TLS\n   * Added OpenSSL / PolarSSL compatibility script (tests/compat.sh) and\n     example application (programs/ssl/o_p_test) (requires OpenSSL)\n   * Added X509 CA Path support\n   * Added Thumb assembly optimizations\n   * Added DEFLATE compression support as per RFC3749 (requires zlib)\n   * Added blowfish algorithm (Generic and cipher layer)\n   * Added PKCS#5 PBKDF2 key derivation function\n   * Added Secure Renegotiation (RFC 5746)\n   * Added predefined DHM groups from RFC 5114\n   * Added simple SSL session cache implementation\n   * Added ServerName extension parsing (SNI) at server side\n   * Added option to add minimum accepted SSL/TLS protocol version\n\nChanges\n   * Removed redundant POLARSSL_DEBUG_MSG define\n   * AES code only check for Padlock once\n   * Fixed const-correctness mpi_get_bit()\n   * Documentation for mpi_lsb() and mpi_msb()\n   * Moved out_msg to out_hdr + 32 to support hardware acceleration\n   * Changed certificate verify behaviour to comply with RFC 6125 section 6.3\n     to not match CN if subjectAltName extension is present (Closes ticket #56)\n   * Cipher layer cipher_mode_t POLARSSL_MODE_CFB128 is renamed to\n     POLARSSL_MODE_CFB, to also handle different block size CFB modes.\n   * Removed handling for SSLv2 Client Hello (as per RFC 5246 recommendation)\n   * Revamped session resumption handling\n   * Generalized external private key implementation handling (like PKCS#11)\n     in SSL/TLS\n   * Revamped x509_verify() and the SSL f_vrfy callback implementations\n   * Moved from unsigned long to fixed width uint32_t types throughout code\n   * Renamed ciphersuites naming scheme to IANA reserved names\n\nBugfix\n   * Fixed handling error in mpi_cmp_mpi() on longer B values (found by\n     Hui Dong)\n   * Fixed potential heap corruption in x509_name allocation\n   * Fixed single RSA test that failed on Big Endian systems (Closes ticket #54)\n   * mpi_exp_mod() now correctly handles negative base numbers (Closes ticket\n     #52)\n   * Handle encryption with private key and decryption with public key as per\n   \t RFC 2313\n   * Handle empty certificate subject names\n   * Prevent reading over buffer boundaries on X509 certificate parsing\n   * mpi_add_abs() now correctly handles adding short numbers to long numbers\n     with carry rollover (found by Ruslan Yushchenko)\n   * Handle existence of OpenSSL Trust Extensions at end of X.509 DER blob\n   * Fixed MPI assembly for SPARC64 platform\n\nSecurity\n   * Fixed potential memory zeroization on miscrafted RSA key (found by Eloi\n     Vanderbeken)\n\n= Version 1.1.5 released on 2013-01-16\nBugfix\n   * Fixed MPI assembly for SPARC64 platform\n   * Handle existence of OpenSSL Trust Extensions at end of X.509 DER blob\n   * mpi_add_abs() now correctly handles adding short numbers to long numbers\n     with carry rollover\n   * Moved mpi_inv_mod() outside POLARSSL_GENPRIME\n   * Prevent reading over buffer boundaries on X509 certificate parsing\n   * mpi_exp_mod() now correctly handles negative base numbers (Closes ticket\n     #52)\n   * Fixed possible segfault in mpi_shift_r() (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Allow R and A to point to same mpi in mpi_div_mpi (found by Manuel\n     P\u00e9gouri\u00e9-Gonnard)\n   * Added max length check for rsa_pkcs1_sign with PKCS#1 v2.1\n   * Memory leak when using RSA_PKCS_V21 operations fixed\n   * Handle encryption with private key and decryption with public key as per\n     RFC 2313\n   * Fixes for MSVC6\n\nSecurity\n   * Fixed potential memory zeroization on miscrafted RSA key (found by Eloi\n     Vanderbeken)\n\n= Version 1.1.4 released on 2012-05-31\nBugfix\n   * Correctly handle empty SSL/TLS packets (Found by James Yonan)\n   * Fixed potential heap corruption in x509_name allocation\n   * Fixed single RSA test that failed on Big Endian systems (Closes ticket #54)\n\n= Version 1.1.3 released on 2012-04-29\nBugfix\n   * Fixed random MPI generation to not generate more size than requested.\n\n= Version 1.1.2 released on 2012-04-26\nBugfix\n   * Fixed handling error in mpi_cmp_mpi() on longer B values (found by\n     Hui Dong)\n\nSecurity\n   * Fixed potential memory corruption on miscrafted client messages (found by\n     Frama-C team at CEA LIST)\n   * Fixed generation of DHM parameters to correct length (found by Ruslan\n     Yushchenko)\n\n= Version 1.1.1 released on 2012-01-23\nBugfix\n   * Check for failed malloc() in ssl_set_hostname() and x509_get_entries()\n     (Closes ticket #47, found by Hugo Leisink)\n   * Fixed issues with Intel compiler on 64-bit systems (Closes ticket #50)\n   * Fixed multiple compiler warnings for VS6 and armcc\n   * Fixed bug in CTR_CRBG selftest\n\n= Version 1.1.0 released on 2011-12-22\nFeatures\n   * Added ssl_session_reset() to allow better multi-connection pools of\n     SSL contexts without needing to set all non-connection-specific\n\t data and pointers again. Adapted ssl_server to use this functionality.\n   * Added ssl_set_max_version() to allow clients to offer a lower maximum\n     supported version to a server to help buggy server implementations.\n\t (Closes ticket #36)\n   * Added cipher_get_cipher_mode() and cipher_get_cipher_operation()\n     introspection functions (Closes ticket #40)\n   * Added CTR_DRBG based on AES-256-CTR (NIST SP 800-90) random generator\n   * Added a generic entropy accumulator that provides support for adding\n     custom entropy sources and added some generic and platform dependent\n\t entropy sources\n\nChanges\n   * Documentation for AES and Camellia in modes CTR and CFB128 clarified.\n   * Fixed rsa_encrypt and rsa_decrypt examples to use public key for\n     encryption and private key for decryption. (Closes ticket #34)\n   * Inceased maximum size of ASN1 length reads to 32-bits.\n   * Added an EXPLICIT tag number parameter to x509_get_ext()\n   * Added a separate CRL entry extension parsing function\n   * Separated the ASN.1 parsing code from the X.509 specific parsing code.\n     So now there is a module that is controlled with POLARSSL_ASN1_PARSE_C.\n   * Changed the defined key-length of DES ciphers in cipher.h to include the\n     parity bits, to prevent mistakes in copying data. (Closes ticket #33)\n   * Loads of minimal changes to better support WINCE as a build target\n     (Credits go to Marco Lizza)\n   * Added POLARSSL_MPI_WINDOW_SIZE definition to allow easier time to memory\n     trade-off\n   * Introduced POLARSSL_MPI_MAX_SIZE and POLARSSL_MPI_MAX_BITS for MPI size\n     management (Closes ticket #44)\n   * Changed the used random function pointer to more flexible format. Renamed\n     havege_rand() to havege_random() to prevent mistakes. Lots of changes as\n     a consequence in library code and programs\n   * Moved all examples programs to use the new entropy and CTR_DRBG\n   * Added permissive certificate parsing to x509parse_crt() and\n     x509parse_crtfile(). With permissive parsing the parsing does not stop on\n     encountering a parse-error. Beware that the meaning of return values has\n     changed!\n   * All error codes are now negative. Even on mermory failures and IO errors.\n\nBugfix\n   * Fixed faulty HMAC-MD2 implementation. Found by dibac. (Closes\n     ticket #37)\n   * Fixed a bug where the CRL parser expected an EXPLICIT ASN.1 tag\n     before version numbers\n   * Allowed X509 key usage parsing to accept 4 byte values instead of the\n     standard 1 byte version sometimes used by Microsoft. (Closes ticket #38)\n   * Fixed incorrect behaviour in case of RSASSA-PSS with a salt length\n     smaller than the hash length. (Closes ticket #41)\n   * If certificate serial is longer than 32 octets, serial number is now\n     appended with '....' after first 28 octets\n   * Improved build support for s390x and sparc64 in bignum.h\n   * Fixed MS Visual C++ name clash with int64 in sha4.h\n   * Corrected removal of leading \"00:\" in printing serial numbers in\n     certificates and CRLs\n\n= Version 1.0.0 released on 2011-07-27\nFeatures\n   * Expanded cipher layer with support for CFB128 and CTR mode\n   * Added rsa_encrypt and rsa_decrypt simple example programs.\n\nChanges\n   * The generic cipher and message digest layer now have normal error\n     codes instead of integers\n\nBugfix\n   * Undid faulty bug fix in ssl_write() when flushing old data (Ticket\n     #18)\n\n= Version 0.99-pre5 released on 2011-05-26\nFeatures\n   * Added additional Cipher Block Modes to symmetric ciphers\n     (AES CTR, Camellia CTR, XTEA CBC) including the option to\n     enable and disable individual modes when needed\n   * Functions requiring File System functions can now be disabled\n     by undefining POLARSSL_FS_IO\n   * A error_strerror function() has been added to translate between\n     error codes and their description.\n   * Added mpi_get_bit() and mpi_set_bit() individual bit setter/getter\n     functions.\n   * Added ssl_mail_client and ssl_fork_server as example programs.\n\nChanges\n   * Major argument / variable rewrite. Introduced use of size_t\n     instead of int for buffer lengths and loop variables for\n     better unsigned / signed use. Renamed internal bigint types\n     t_int and t_dbl to t_uint and t_udbl in the process\n   * mpi_init() and mpi_free() now only accept a single MPI\n     argument and do not accept variable argument lists anymore.\n   * The error codes have been remapped and combining error codes\n     is now done with a PLUS instead of an OR as error codes\n     used are negative.\n   * Changed behaviour of net_read(), ssl_fetch_input() and ssl_recv().\n     net_recv() now returns 0 on EOF instead of\n     POLARSSL_ERR_NET_CONN_RESET. ssl_fetch_input() returns\n     POLARSSL_ERR_SSL_CONN_EOF on an EOF from its f_recv() function.\n     ssl_read() returns 0 if a POLARSSL_ERR_SSL_CONN_EOF is received\n     after the handshake.\n   * Network functions now return POLARSSL_ERR_NET_WANT_READ or\n     POLARSSL_ERR_NET_WANT_WRITE instead of the ambiguous\n     POLARSSL_ERR_NET_TRY_AGAIN\n\n= Version 0.99-pre4 released on 2011-04-01\nFeatures\n   * Added support for PKCS#1 v2.1 encoding and thus support\n     for the RSAES-OAEP and RSASSA-PSS operations.\n   * Reading of Public Key files incorporated into default x509\n     functionality as well.\n   * Added mpi_fill_random() for centralized filling of big numbers\n     with random data (Fixed ticket #10)\n\nChanges\n   * Debug print of MPI now removes leading zero octets and \n     displays actual bit size of the value.\n   * x509parse_key() (and as a consequence x509parse_keyfile()) \n     does not zeroize memory in advance anymore. Use rsa_init()\n     before parsing a key or keyfile!\n\nBugfix\n   * Debug output of MPI's now the same independent of underlying\n     platform (32-bit / 64-bit) (Fixes ticket #19, found by Mads\n     Kiilerich and Mihai Militaru)\n   * Fixed bug in ssl_write() when flushing old data (Fixed ticket\n     #18, found by Nikolay Epifanov)\n   * Fixed proper handling of RSASSA-PSS verification with variable\n     length salt lengths\n\n= Version 0.99-pre3 released on 2011-02-28\nThis release replaces version 0.99-pre2 which had possible copyright issues.\nFeatures\n   * Parsing PEM private keys encrypted with DES and AES\n     are now supported as well (Fixes ticket #5)\n   * Added crl_app program to allow easy reading and\n     printing of X509 CRLs from file\n\nChanges\n   * Parsing of PEM files moved to separate module (Fixes \n     ticket #13). Also possible to remove PEM support for\n     systems only using DER encoding\n\nBugfixes\n   * Corrected parsing of UTCTime dates before 1990 and\n     after 1950\n   * Support more exotic OID's when parsing certificates\n   \t (found by Mads Kiilerich)\n   * Support more exotic name representations when parsing\n     certificates (found by Mads Kiilerich)\n   * Replaced the expired test certificates\n   * Do not bail out if no client certificate specified. Try\n     to negotiate anonymous connection (Fixes ticket #12,\n     found by Boris Krasnovskiy)\n\nSecurity fixes\n   * Fixed a possible Man-in-the-Middle attack on the\n     Diffie Hellman key exchange (thanks to Larry Highsmith,\n     Subreption LLC)\n\n= Version 0.99-pre1 released on 2011-01-30\nFeatures\nNote: Most of these features have been donated by Fox-IT\n   * Added Doxygen source code documentation parts\n   * Added reading of DHM context from memory and file\n   * Improved X509 certificate parsing to include extended\n     certificate fields, including Key Usage\n   * Improved certificate verification and verification\n     against the available CRLs\n   * Detection for DES weak keys and parity bits added\n   * Improvements to support integration in other\n     applications:\n       + Added generic message digest and cipher wrapper\n       + Improved information about current capabilities,\n         status, objects and configuration\n       + Added verification callback on certificate chain\n         verification to allow external blacklisting\n\t   + Additional example programs to show usage\n   * Added support for PKCS#11 through the use of the\n     libpkcs11-helper library\n\nChanges\n   * x509parse_time_expired() checks time in addition to\n     the existing date check\n   * The ciphers member of ssl_context and the cipher member\n     of ssl_session have been renamed to ciphersuites and\n     ciphersuite respectively. This clarifies the difference\n     with the generic cipher layer and is better naming\n     altogether\n\n= Version 0.14.0 released on 2010-08-16\nFeatures\n   * Added support for SSL_EDH_RSA_AES_128_SHA and\n     SSL_EDH_RSA_CAMELLIA_128_SHA ciphersuites\n   * Added compile-time and run-time version information\n   * Expanded ssl_client2 arguments for more flexibility\n   * Added support for TLS v1.1\n\nChanges\n   * Made Makefile cleaner\n   * Removed dependency on rand() in rsa_pkcs1_encrypt().\n     Now using random fuction provided to function and\n     changed the prototype of rsa_pkcs1_encrypt(),\n     rsa_init() and rsa_gen_key().\n   * Some SSL defines were renamed in order to avoid\n     future confusion\n\nBug fixes\n   * Fixed CMake out of source build for tests (found by\n     kkert)\n   * rsa_check_private() now supports PKCS1v2 keys as well\n   * Fixed deadlock in rsa_pkcs1_encrypt() on failing random\n     generator\n\n= Version 0.13.1 released on 2010-03-24\nBug fixes\n   * Fixed Makefile in library that was mistakenly merged\n   * Added missing const string fixes\n\n= Version 0.13.0 released on 2010-03-21\nFeatures\n   * Added option parsing for host and port selection to\n     ssl_client2\n   * Added support for GeneralizedTime in X509 parsing\n   * Added cert_app program to allow easy reading and\n     printing of X509 certificates from file or SSL\n     connection.\n\nChanges\n   * Added const correctness for main code base\n   * X509 signature algorithm determination is now\n     in a function to allow easy future expansion\n   * Changed symmetric cipher functions to\n     identical interface (returning int result values)\n   * Changed ARC4 to use seperate input/output buffer\n   * Added reset function for HMAC context as speed-up\n     for specific use-cases\n\nBug fixes\n   * Fixed bug resulting in failure to send the last\n     certificate in the chain in ssl_write_certificate() and\n     ssl_write_certificate_request() (found by fatbob)\n   * Added small fixes for compiler warnings on a Mac\n     (found by Frank de Brabander)\n   * Fixed algorithmic bug in mpi_is_prime() (found by\n     Smbat Tonoyan)\n\n= Version 0.12.1 released on 2009-10-04\nChanges\n   * Coverage test definitions now support 'depends_on'\n     tagging system.\n   * Tests requiring specific hashing algorithms now honor\n     the defines.\n\nBug fixes\n   * Changed typo in #ifdef in x509parse.c (found\n     by Eduardo)\n\n= Version 0.12.0 released on 2009-07-28\nFeatures\n   * Added CMake makefiles as alternative to regular Makefiles.\n   * Added preliminary Code Coverage tests for AES, ARC4,\n     Base64, MPI, SHA-family, MD-family, HMAC-SHA-family,\n     Camellia, DES, 3-DES, RSA PKCS#1, XTEA, Diffie-Hellman\n     and X509parse.\n\nChanges\n   * Error codes are not (necessarily) negative. Keep\n     this is mind when checking for errors.\n   * RSA_RAW renamed to SIG_RSA_RAW for consistency.\n   * Fixed typo in name of POLARSSL_ERR_RSA_OUTPUT_TOO_LARGE.\n   * Changed interface for AES and Camellia setkey functions\n     to indicate invalid key lengths.\n\nBug fixes\n   * Fixed include location of endian.h on FreeBSD (found by\n     Gabriel)\n   * Fixed include location of endian.h and name clash on\n     Apples (found by Martin van Hensbergen)\n   * Fixed HMAC-MD2 by modifying md2_starts(), so that the\n     required HMAC ipad and opad variables are not cleared.\n     (found by code coverage tests)\n   * Prevented use of long long in bignum if \n     POLARSSL_HAVE_LONGLONG not defined (found by Giles\n     Bathgate).\n   * Fixed incorrect handling of negative strings in\n     mpi_read_string() (found by code coverage tests).\n   * Fixed segfault on handling empty rsa_context in\n     rsa_check_pubkey() and rsa_check_privkey() (found by\n     code coverage tests).\n   * Fixed incorrect handling of one single negative input\n     value in mpi_add_abs() (found by code coverage tests).\n   * Fixed incorrect handling of negative first input\n     value in mpi_sub_abs() (found by code coverage tests).\n   * Fixed incorrect handling of negative first input\n     value in mpi_mod_mpi() and mpi_mod_int(). Resulting\n     change also affects mpi_write_string() (found by code\n     coverage tests).\n   * Corrected is_prime() results for 0, 1 and 2 (found by\n     code coverage tests).\n   * Fixed Camellia and XTEA for 64-bit Windows systems.\n\n= Version 0.11.1 released on 2009-05-17\n   * Fixed missing functionality for SHA-224, SHA-256, SHA384,\n     SHA-512 in rsa_pkcs1_sign()\n\n= Version 0.11.0 released on 2009-05-03\n   * Fixed a bug in mpi_gcd() so that it also works when both\n     input numbers are even and added testcases to check\n     (found by Pierre Habouzit).\n   * Added support for SHA-224, SHA-256, SHA-384 and SHA-512\n     one way hash functions with the PKCS#1 v1.5 signing and\n     verification.\n   * Fixed minor bug regarding mpi_gcd located within the\n     POLARSSL_GENPRIME block.\n   * Fixed minor memory leak in x509parse_crt() and added better\n     handling of 'full' certificate chains (found by Mathias\n     Olsson).\n   * Centralized file opening and reading for x509 files into\n     load_file()\n   * Made definition of net_htons() endian-clean for big endian\n     systems (Found by Gernot).\n   * Undefining POLARSSL_HAVE_ASM now also handles prevents asm in\n     padlock and timing code. \n   * Fixed an off-by-one buffer allocation in ssl_set_hostname()\n     responsible for crashes and unwanted behaviour.\n   * Added support for Certificate Revocation List (CRL) parsing.\n   * Added support for CRL revocation to x509parse_verify() and\n     SSL/TLS code.\n   * Fixed compatibility of XTEA and Camellia on a 64-bit system\n     (found by Felix von Leitner).\n\n= Version 0.10.0 released on 2009-01-12\n   * Migrated XySSL to PolarSSL\n   * Added XTEA symmetric cipher\n   * Added Camellia symmetric cipher\n   * Added support for ciphersuites: SSL_RSA_CAMELLIA_128_SHA,\n     SSL_RSA_CAMELLIA_256_SHA and SSL_EDH_RSA_CAMELLIA_256_SHA\n   * Fixed dangerous bug that can cause a heap overflow in\n     rsa_pkcs1_decrypt (found by Christophe Devine)\n\n================================================================\nXySSL ChangeLog\n\n= Version 0.9 released on 2008-03-16\n\n    * Added support for ciphersuite: SSL_RSA_AES_128_SHA\n    * Enabled support for large files by default in aescrypt2.c\n    * Preliminary openssl wrapper contributed by David Barrett\n    * Fixed a bug in ssl_write() that caused the same payload to\n      be sent twice in non-blocking mode when send returns EAGAIN\n    * Fixed ssl_parse_client_hello(): session id and challenge must\n      not be swapped in the SSLv2 ClientHello (found by Greg Robson)\n    * Added user-defined callback debug function (Krystian Kolodziej)\n    * Before freeing a certificate, properly zero out all cert. data\n    * Fixed the \"mode\" parameter so that encryption/decryption are\n      not swapped on PadLock; also fixed compilation on older versions\n      of gcc (bug reported by David Barrett)\n    * Correctly handle the case in padlock_xcryptcbc() when input or\n      ouput data is non-aligned by falling back to the software\n      implementation, as VIA Nehemiah cannot handle non-aligned buffers\n    * Fixed a memory leak in x509parse_crt() which was reported by Greg\n      Robson-Garth; some x509write.c fixes by Pascal Vizeli, thanks to\n      Matthew Page who reported several bugs\n    * Fixed x509_get_ext() to accept some rare certificates which have\n      an INTEGER instead of a BOOLEAN for BasicConstraints::cA.\n    * Added support on the client side for the TLS \"hostname\" extension\n      (patch contributed by David Patino)\n    * Make x509parse_verify() return BADCERT_CN_MISMATCH when an empty\n      string is passed as the CN (bug reported by spoofy)\n    * Added an option to enable/disable the BN assembly code\n    * Updated rsa_check_privkey() to verify that (D*E) = 1 % (P-1)*(Q-1)\n    * Disabled obsolete hash functions by default (MD2, MD4); updated\n      selftest and benchmark to not test ciphers that have been disabled\n    * Updated x509parse_cert_info() to correctly display byte 0 of the\n      serial number, setup correct server port in the ssl client example\n    * Fixed a critical denial-of-service with X.509 cert. verification:\n      peer may cause xyssl to loop indefinitely by sending a certificate\n      for which the RSA signature check fails (bug reported by Benoit)\n    * Added test vectors for: AES-CBC, AES-CFB, DES-CBC and 3DES-CBC,\n      HMAC-MD5, HMAC-SHA1, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\n    * Fixed HMAC-SHA-384 and HMAC-SHA-512 (thanks to Josh Sinykin)\n    * Modified ssl_parse_client_key_exchange() to protect against\n      Daniel Bleichenbacher attack on PKCS#1 v1.5 padding, as well\n      as the Klima-Pokorny-Rosa extension of Bleichenbacher's attack\n    * Updated rsa_gen_key() so that ctx->N is always nbits in size\n    * Fixed assembly PPC compilation errors on Mac OS X, thanks to\n      David Barrett and Dusan Semen\n\n= Version 0.8 released on 2007-10-20\n\n    * Modified the HMAC functions to handle keys larger\n      than 64 bytes, thanks to Stephane Desneux and gary ng\n    * Fixed ssl_read_record() to properly update the handshake\n      message digests, which fixes IE6/IE7 client authentication\n    * Cleaned up the XYSSL* #defines, suggested by Azriel Fasten\n    * Fixed net_recv(), thanks to Lorenz Schori and Egon Kocjan\n    * Added user-defined callbacks for handling I/O and sessions\n    * Added lots of debugging output in the SSL/TLS functions\n    * Added preliminary X.509 cert. writing by Pascal Vizeli\n    * Added preliminary support for the VIA PadLock routines\n    * Added AES-CFB mode of operation, contributed by chmike\n    * Added an SSL/TLS stress testing program (ssl_test.c)\n    * Updated the RSA PKCS#1 code to allow choosing between\n      RSA_PUBLIC and RSA_PRIVATE, as suggested by David Barrett\n    * Updated ssl_read() to skip 0-length records from OpenSSL\n    * Fixed the make install target to comply with *BSD make\n    * Fixed a bug in mpi_read_binary() on 64-bit platforms\n    * mpi_is_prime() speedups, thanks to Kevin McLaughlin\n    * Fixed a long standing memory leak in mpi_is_prime()\n    * Replaced realloc with malloc in mpi_grow(), and set\n      the sign of zero as positive in mpi_init() (reported\n      by Jonathan M. McCune)\n\n= Version 0.7 released on 2007-07-07\n\n    * Added support for the MicroBlaze soft-core processor\n    * Fixed a bug in ssl_tls.c which sometimes prevented SSL\n      connections from being established with non-blocking I/O\n    * Fixed a couple bugs in the VS6 and UNIX Makefiles\n    * Fixed the \"PIC register ebx clobbered in asm\" bug\n    * Added HMAC starts/update/finish support functions\n    * Added the SHA-224, SHA-384 and SHA-512 hash functions\n    * Fixed the net_set_*block routines, thanks to Andreas\n    * Added a few demonstration programs: md5sum, sha1sum,\n      dh_client, dh_server, rsa_genkey, rsa_sign, rsa_verify\n    * Added new bignum import and export helper functions\n    * Rewrote README.txt in program/ssl/ca to better explain\n      how to create a test PKI\n\n= Version 0.6 released on 2007-04-01\n\n    * Ciphers used in SSL/TLS can now be disabled at compile\n      time, to reduce the memory footprint on embedded systems\n    * Added multiply assembly code for the TriCore and modified\n      havege_struct for this processor, thanks to David Pati\u00f1o\n    * Added multiply assembly code for 64-bit PowerPCs,\n      thanks to Peking University and the OSU Open Source Lab\n    * Added experimental support of Quantum Cryptography\n    * Added support for autoconf, contributed by Arnaud Cornet\n    * Fixed \"long long\" compilation issues on IA-64 and PPC64\n    * Fixed a bug introduced in xyssl-0.5/timing.c: hardclock\n      was not being correctly defined on ARM and MIPS\n\n= Version 0.5 released on 2007-03-01\n\n    * Added multiply assembly code for SPARC and Alpha\n    * Added (beta) support for non-blocking I/O operations\n    * Implemented session resuming and client authentication\n    * Fixed some portability issues on WinCE, MINIX 3, Plan9\n      (thanks to Benjamin Newman), HP-UX, FreeBSD and Solaris\n    * Improved the performance of the EDH key exchange\n    * Fixed a bug that caused valid packets with a payload\n      size of 16384 bytes to be rejected\n\n= Version 0.4 released on 2007-02-01\n\n    * Added support for Ephemeral Diffie-Hellman key exchange\n    * Added multiply asm code for SSE2, ARM, PPC, MIPS and M68K\n    * Various improvement to the modular exponentiation code\n    * Rewrote the headers to generate the API docs with doxygen\n    * Fixed a bug in ssl_encrypt_buf (incorrect padding was\n      generated) and in ssl_parse_client_hello (max. client\n      version was not properly set), thanks to Didier Rebeix\n    * Fixed another bug in ssl_parse_client_hello: clients with\n      cipherlists larger than 96 bytes were incorrectly rejected\n    * Fixed a couple memory leak in x509_read.c\n\n= Version 0.3 released on 2007-01-01\n\n    * Added server-side SSLv3 and TLSv1.0 support\n    * Multiple fixes to enhance the compatibility with g++,\n      thanks to Xos\u00e9 Ant\u00f3n Otero Ferreira\n    * Fixed a bug in the CBC code, thanks to dowst; also,\n      the bignum code is no longer dependant on long long\n    * Updated rsa_pkcs1_sign to handle arbitrary large inputs\n    * Updated timing.c for improved compatibility with i386\n      and 486 processors, thanks to Arnaud Cornet\n\n= Version 0.2 released on 2006-12-01\n\n    * Updated timing.c to support ARM and MIPS arch\n    * Updated the MPI code to support 8086 on MSVC 1.5\n    * Added the copyright notice at the top of havege.h\n    * Fixed a bug in sha2_hmac, thanks to newsoft/Wenfang Zhang\n    * Fixed a bug reported by Adrian R\u00fcegsegger in x509_read_key\n    * Fixed a bug reported by Torsten Lauter in ssl_read_record\n    * Fixed a bug in rsa_check_privkey that would wrongly cause\n      valid RSA keys to be dismissed (thanks to oldwolf)\n    * Fixed a bug in mpi_is_prime that caused some primes to fail\n      the Miller-Rabin primality test\n\n    I'd also like to thank Youn\u00e8s Hafri for the CRUX linux port,\n    Khalil Petit who added XySSL into pkgsrc and Arnaud Cornet\n    who maintains the Debian package :-)\n\n= Version 0.1 released on 2006-11-01\n\n", "/**\n * \\file x509.h\n *\n * \\brief X.509 certificate and private key decoding\n *\n *  Copyright (C) 2006-2011, Brainspark B.V.\n *\n *  This file is part of PolarSSL (http://www.polarssl.org)\n *  Lead Maintainer: Paul Bakker <polarssl_maintainer at polarssl.org>\n *\n *  All rights reserved.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#ifndef POLARSSL_X509_H\n#define POLARSSL_X509_H\n\n#include \"asn1.h\"\n#include \"rsa.h\"\n#include \"dhm.h\"\n\n/** \n * \\addtogroup x509_module\n * \\{ \n */\n \n/** \n * \\name X509 Error codes\n * \\{\n */\n#define POLARSSL_ERR_X509_FEATURE_UNAVAILABLE              -0x2080  /**< Unavailable feature, e.g. RSA hashing/encryption combination. */\n#define POLARSSL_ERR_X509_CERT_INVALID_PEM                 -0x2100  /**< The PEM-encoded certificate contains invalid elements, e.g. invalid character. */ \n#define POLARSSL_ERR_X509_CERT_INVALID_FORMAT              -0x2180  /**< The certificate format is invalid, e.g. different type expected. */\n#define POLARSSL_ERR_X509_CERT_INVALID_VERSION             -0x2200  /**< The certificate version element is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_SERIAL              -0x2280  /**< The serial tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_ALG                 -0x2300  /**< The algorithm tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_NAME                -0x2380  /**< The name tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_DATE                -0x2400  /**< The date tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_PUBKEY              -0x2480  /**< The pubkey tag or value is invalid (only RSA is supported). */\n#define POLARSSL_ERR_X509_CERT_INVALID_SIGNATURE           -0x2500  /**< The signature tag or value invalid. */\n#define POLARSSL_ERR_X509_CERT_INVALID_EXTENSIONS          -0x2580  /**< The extension tag or value is invalid. */\n#define POLARSSL_ERR_X509_CERT_UNKNOWN_VERSION             -0x2600  /**< Certificate or CRL has an unsupported version number. */\n#define POLARSSL_ERR_X509_CERT_UNKNOWN_SIG_ALG             -0x2680  /**< Signature algorithm (oid) is unsupported. */\n#define POLARSSL_ERR_X509_UNKNOWN_PK_ALG                   -0x2700  /**< Key algorithm is unsupported (only RSA is supported). */\n#define POLARSSL_ERR_X509_CERT_SIG_MISMATCH                -0x2780  /**< Certificate signature algorithms do not match. (see \\c ::x509_cert sig_oid) */\n#define POLARSSL_ERR_X509_CERT_VERIFY_FAILED               -0x2800  /**< Certificate verification failed, e.g. CRL, CA or signature check failed. */\n#define POLARSSL_ERR_X509_KEY_INVALID_VERSION              -0x2880  /**< Unsupported RSA key version */\n#define POLARSSL_ERR_X509_KEY_INVALID_FORMAT               -0x2900  /**< Invalid RSA key tag or value. */\n#define POLARSSL_ERR_X509_CERT_UNKNOWN_FORMAT              -0x2980  /**< Format not recognized as DER or PEM. */\n#define POLARSSL_ERR_X509_INVALID_INPUT                    -0x2A00  /**< Input invalid. */\n#define POLARSSL_ERR_X509_MALLOC_FAILED                    -0x2A80  /**< Allocation of memory failed. */\n#define POLARSSL_ERR_X509_FILE_IO_ERROR                    -0x2B00  /**< Read/write of file failed. */\n/* \\} name */\n\n\n/**\n * \\name X509 Verify codes\n * \\{\n */\n#define BADCERT_EXPIRED             0x01  /**< The certificate validity has expired. */\n#define BADCERT_REVOKED             0x02  /**< The certificate has been revoked (is on a CRL). */\n#define BADCERT_CN_MISMATCH         0x04  /**< The certificate Common Name (CN) does not match with the expected CN. */\n#define BADCERT_NOT_TRUSTED         0x08  /**< The certificate is not correctly signed by the trusted CA. */\n#define BADCRL_NOT_TRUSTED          0x10  /**< CRL is not correctly signed by the trusted CA. */\n#define BADCRL_EXPIRED              0x20  /**< CRL is expired. */\n#define BADCERT_MISSING             0x40  /**< Certificate was missing. */\n#define BADCERT_SKIP_VERIFY         0x80  /**< Certificate verification was skipped. */\n#define BADCERT_OTHER             0x0100  /**< Other reason (can be used by verify callback) */\n/* \\} name */\n/* \\} addtogroup x509_module */\n\n/*\n * various object identifiers\n */\n#define X520_COMMON_NAME                3\n#define X520_COUNTRY                    6\n#define X520_LOCALITY                   7\n#define X520_STATE                      8\n#define X520_ORGANIZATION              10\n#define X520_ORG_UNIT                  11\n#define PKCS9_EMAIL                     1\n\n#define X509_OUTPUT_DER              0x01\n#define X509_OUTPUT_PEM              0x02\n#define PEM_LINE_LENGTH                72\n#define X509_ISSUER                  0x01\n#define X509_SUBJECT                 0x02\n\n#define OID_X520                \"\\x55\\x04\"\n#define OID_CN                  OID_X520 \"\\x03\"\n#define OID_COUNTRY             OID_X520 \"\\x06\"\n#define OID_LOCALITY            OID_X520 \"\\x07\"\n#define OID_STATE               OID_X520 \"\\x08\"\n#define OID_ORGANIZATION        OID_X520 \"\\x0A\"\n#define OID_ORG_UNIT            OID_X520 \"\\x0B\"\n\n#define OID_PKCS1               \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x01\\x01\"\n#define OID_PKCS1_RSA           OID_PKCS1 \"\\x01\"\n#define OID_PKCS1_SHA1          OID_PKCS1 \"\\x05\"\n\n#define OID_RSA_SHA_OBS         \"\\x2B\\x0E\\x03\\x02\\x1D\"\n\n#define OID_PKCS9               \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x01\\x09\"\n#define OID_PKCS9_EMAIL         OID_PKCS9 \"\\x01\"\n\n/** ISO arc for standard certificate and CRL extensions */\n#define OID_ID_CE               \"\\x55\\x1D\" /**< id-ce OBJECT IDENTIFIER  ::=  {joint-iso-ccitt(2) ds(5) 29} */\n\n/**\n * Private Internet Extensions\n * { iso(1) identified-organization(3) dod(6) internet(1)\n *                      security(5) mechanisms(5) pkix(7) }\n */\n#define OID_PKIX                \"\\x2B\\x06\\x01\\x05\\x05\\x07\"\n\n/*\n * OIDs for standard certificate extensions\n */\n#define OID_AUTHORITY_KEY_IDENTIFIER    OID_ID_CE \"\\x23\" /**< id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 } */\n#define OID_SUBJECT_KEY_IDENTIFIER      OID_ID_CE \"\\x0E\" /**< id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 14 } */\n#define OID_KEY_USAGE                   OID_ID_CE \"\\x0F\" /**< id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 } */\n#define OID_CERTIFICATE_POLICIES        OID_ID_CE \"\\x20\" /**< id-ce-certificatePolicies OBJECT IDENTIFIER ::=  { id-ce 32 } */\n#define OID_POLICY_MAPPINGS             OID_ID_CE \"\\x21\" /**< id-ce-policyMappings OBJECT IDENTIFIER ::=  { id-ce 33 } */\n#define OID_SUBJECT_ALT_NAME            OID_ID_CE \"\\x11\" /**< id-ce-subjectAltName OBJECT IDENTIFIER ::=  { id-ce 17 } */\n#define OID_ISSUER_ALT_NAME             OID_ID_CE \"\\x12\" /**< id-ce-issuerAltName OBJECT IDENTIFIER ::=  { id-ce 18 } */\n#define OID_SUBJECT_DIRECTORY_ATTRS     OID_ID_CE \"\\x09\" /**< id-ce-subjectDirectoryAttributes OBJECT IDENTIFIER ::=  { id-ce 9 } */\n#define OID_BASIC_CONSTRAINTS           OID_ID_CE \"\\x13\" /**< id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 } */\n#define OID_NAME_CONSTRAINTS            OID_ID_CE \"\\x1E\" /**< id-ce-nameConstraints OBJECT IDENTIFIER ::=  { id-ce 30 } */\n#define OID_POLICY_CONSTRAINTS          OID_ID_CE \"\\x24\" /**< id-ce-policyConstraints OBJECT IDENTIFIER ::=  { id-ce 36 } */\n#define OID_EXTENDED_KEY_USAGE          OID_ID_CE \"\\x25\" /**< id-ce-extKeyUsage OBJECT IDENTIFIER ::= { id-ce 37 } */\n#define OID_CRL_DISTRIBUTION_POINTS     OID_ID_CE \"\\x1F\" /**< id-ce-cRLDistributionPoints OBJECT IDENTIFIER ::=  { id-ce 31 } */\n#define OID_INIHIBIT_ANYPOLICY          OID_ID_CE \"\\x36\" /**< id-ce-inhibitAnyPolicy OBJECT IDENTIFIER ::=  { id-ce 54 } */\n#define OID_FRESHEST_CRL                OID_ID_CE \"\\x2E\" /**< id-ce-freshestCRL OBJECT IDENTIFIER ::=  { id-ce 46 } */\n\n/*\n * X.509 v3 Key Usage Extension flags\n */\n#define KU_DIGITAL_SIGNATURE            (0x80)  /* bit 0 */\n#define KU_NON_REPUDIATION              (0x40)  /* bit 1 */\n#define KU_KEY_ENCIPHERMENT             (0x20)  /* bit 2 */\n#define KU_DATA_ENCIPHERMENT            (0x10)  /* bit 3 */\n#define KU_KEY_AGREEMENT                (0x08)  /* bit 4 */\n#define KU_KEY_CERT_SIGN                (0x04)  /* bit 5 */\n#define KU_CRL_SIGN                     (0x02)  /* bit 6 */\n\n/*\n * X.509 v3 Extended key usage OIDs\n */\n#define OID_ANY_EXTENDED_KEY_USAGE      OID_EXTENDED_KEY_USAGE \"\\x00\" /**< anyExtendedKeyUsage OBJECT IDENTIFIER ::= { id-ce-extKeyUsage 0 } */\n\n#define OID_KP                          OID_PKIX \"\\x03\" /**< id-kp OBJECT IDENTIFIER ::= { id-pkix 3 } */\n#define OID_SERVER_AUTH                 OID_KP \"\\x01\" /**< id-kp-serverAuth OBJECT IDENTIFIER ::= { id-kp 1 } */\n#define OID_CLIENT_AUTH                 OID_KP \"\\x02\" /**< id-kp-clientAuth OBJECT IDENTIFIER ::= { id-kp 2 } */\n#define OID_CODE_SIGNING                OID_KP \"\\x03\" /**< id-kp-codeSigning OBJECT IDENTIFIER ::= { id-kp 3 } */\n#define OID_EMAIL_PROTECTION            OID_KP \"\\x04\" /**< id-kp-emailProtection OBJECT IDENTIFIER ::= { id-kp 4 } */\n#define OID_TIME_STAMPING               OID_KP \"\\x08\" /**< id-kp-timeStamping OBJECT IDENTIFIER ::= { id-kp 8 } */\n#define OID_OCSP_SIGNING                OID_KP \"\\x09\" /**< id-kp-OCSPSigning OBJECT IDENTIFIER ::= { id-kp 9 } */\n\n#define STRING_SERVER_AUTH              \"TLS Web Server Authentication\"\n#define STRING_CLIENT_AUTH              \"TLS Web Client Authentication\"\n#define STRING_CODE_SIGNING             \"Code Signing\"\n#define STRING_EMAIL_PROTECTION         \"E-mail Protection\"\n#define STRING_TIME_STAMPING            \"Time Stamping\"\n#define STRING_OCSP_SIGNING             \"OCSP Signing\"\n\n/*\n * OIDs for CRL extensions\n */\n#define OID_PRIVATE_KEY_USAGE_PERIOD    OID_ID_CE \"\\x10\"\n#define OID_CRL_NUMBER                  OID_ID_CE \"\\x14\" /**< id-ce-cRLNumber OBJECT IDENTIFIER ::= { id-ce 20 } */\n\n/*\n * Netscape certificate extensions\n */\n#define OID_NETSCAPE                \"\\x60\\x86\\x48\\x01\\x86\\xF8\\x42\" /**< Netscape OID */\n#define OID_NS_CERT                 OID_NETSCAPE \"\\x01\"\n#define OID_NS_CERT_TYPE            OID_NS_CERT  \"\\x01\"\n#define OID_NS_BASE_URL             OID_NS_CERT  \"\\x02\"\n#define OID_NS_REVOCATION_URL       OID_NS_CERT  \"\\x03\"\n#define OID_NS_CA_REVOCATION_URL    OID_NS_CERT  \"\\x04\"\n#define OID_NS_RENEWAL_URL          OID_NS_CERT  \"\\x07\"\n#define OID_NS_CA_POLICY_URL        OID_NS_CERT  \"\\x08\"\n#define OID_NS_SSL_SERVER_NAME      OID_NS_CERT  \"\\x0C\"\n#define OID_NS_COMMENT              OID_NS_CERT  \"\\x0D\"\n#define OID_NS_DATA_TYPE            OID_NETSCAPE \"\\x02\"\n#define OID_NS_CERT_SEQUENCE        OID_NS_DATA_TYPE \"\\x05\"\n\n/*\n * Netscape certificate types\n * (http://www.mozilla.org/projects/security/pki/nss/tech-notes/tn3.html)\n */\n\n#define NS_CERT_TYPE_SSL_CLIENT         (0x80)  /* bit 0 */\n#define NS_CERT_TYPE_SSL_SERVER         (0x40)  /* bit 1 */\n#define NS_CERT_TYPE_EMAIL              (0x20)  /* bit 2 */\n#define NS_CERT_TYPE_OBJECT_SIGNING     (0x10)  /* bit 3 */\n#define NS_CERT_TYPE_RESERVED           (0x08)  /* bit 4 */\n#define NS_CERT_TYPE_SSL_CA             (0x04)  /* bit 5 */\n#define NS_CERT_TYPE_EMAIL_CA           (0x02)  /* bit 6 */\n#define NS_CERT_TYPE_OBJECT_SIGNING_CA  (0x01)  /* bit 7 */\n\n#define EXT_AUTHORITY_KEY_IDENTIFIER    (1 << 0)\n#define EXT_SUBJECT_KEY_IDENTIFIER      (1 << 1)\n#define EXT_KEY_USAGE                   (1 << 2)\n#define EXT_CERTIFICATE_POLICIES        (1 << 3)\n#define EXT_POLICY_MAPPINGS             (1 << 4)\n#define EXT_SUBJECT_ALT_NAME            (1 << 5)\n#define EXT_ISSUER_ALT_NAME             (1 << 6)\n#define EXT_SUBJECT_DIRECTORY_ATTRS     (1 << 7)\n#define EXT_BASIC_CONSTRAINTS           (1 << 8)\n#define EXT_NAME_CONSTRAINTS            (1 << 9)\n#define EXT_POLICY_CONSTRAINTS          (1 << 10)\n#define EXT_EXTENDED_KEY_USAGE          (1 << 11)\n#define EXT_CRL_DISTRIBUTION_POINTS     (1 << 12)\n#define EXT_INIHIBIT_ANYPOLICY          (1 << 13)\n#define EXT_FRESHEST_CRL                (1 << 14)\n\n#define EXT_NS_CERT_TYPE                (1 << 16)\n\n/*\n * Storage format identifiers\n * Recognized formats: PEM and DER\n */\n#define X509_FORMAT_DER                 1\n#define X509_FORMAT_PEM                 2\n\n/** \n * \\addtogroup x509_module\n * \\{ */\n\n/**\n * \\name Structures for parsing X.509 certificates and CRLs\n * \\{\n */\n \n/** \n * Type-length-value structure that allows for ASN1 using DER.\n */\ntypedef asn1_buf x509_buf;\n\n/**\n * Container for ASN1 bit strings.\n */\ntypedef asn1_bitstring x509_bitstring;\n\n/**\n * Container for ASN1 named information objects. \n * It allows for Relative Distinguished Names (e.g. cn=polarssl,ou=code,etc.).\n */\ntypedef struct _x509_name\n{\n    x509_buf oid;               /**< The object identifier. */\n    x509_buf val;               /**< The named value. */\n    struct _x509_name *next;    /**< The next named information object. */\n}\nx509_name;\n\n/**\n * Container for a sequence of ASN.1 items\n */\ntypedef asn1_sequence x509_sequence;\n\n/** Container for date and time (precision in seconds). */\ntypedef struct _x509_time\n{\n    int year, mon, day;         /**< Date. */\n    int hour, min, sec;         /**< Time. */\n}\nx509_time;\n\n/** \n * Container for an X.509 certificate. The certificate may be chained.\n */\ntypedef struct _x509_cert\n{\n    x509_buf raw;               /**< The raw certificate data (DER). */\n    x509_buf tbs;               /**< The raw certificate body (DER). The part that is To Be Signed. */\n\n    int version;                /**< The X.509 version. (0=v1, 1=v2, 2=v3) */\n    x509_buf serial;            /**< Unique id for certificate issued by a specific CA. */\n    x509_buf sig_oid1;          /**< Signature algorithm, e.g. sha1RSA */\n\n    x509_buf issuer_raw;        /**< The raw issuer data (DER). Used for quick comparison. */\n    x509_buf subject_raw;       /**< The raw subject data (DER). Used for quick comparison. */\n\n    x509_name issuer;           /**< The parsed issuer data (named information object). */\n    x509_name subject;          /**< The parsed subject data (named information object). */\n\n    x509_time valid_from;       /**< Start time of certificate validity. */\n    x509_time valid_to;         /**< End time of certificate validity. */\n\n    x509_buf pk_oid;            /**< Subject public key info. Includes the public key algorithm and the key itself. */\n    rsa_context rsa;            /**< Container for the RSA context. Only RSA is supported for public keys at this time. */\n\n    x509_buf issuer_id;         /**< Optional X.509 v2/v3 issuer unique identifier. */\n    x509_buf subject_id;        /**< Optional X.509 v2/v3 subject unique identifier. */\n    x509_buf v3_ext;            /**< Optional X.509 v3 extensions. Only Basic Contraints are supported at this time. */\n    x509_sequence subject_alt_names;    /**< Optional list of Subject Alternative Names (Only dNSName supported). */\n\n    int ext_types;              /**< Bit string containing detected and parsed extensions */\n    int ca_istrue;              /**< Optional Basic Constraint extension value: 1 if this certificate belongs to a CA, 0 otherwise. */\n    int max_pathlen;            /**< Optional Basic Constraint extension value: The maximum path length to the root certificate. Path length is 1 higher than RFC 5280 'meaning', so 1+ */\n\n    unsigned char key_usage;    /**< Optional key usage extension value: See the values below */\n\n    x509_sequence ext_key_usage; /**< Optional list of extended key usage OIDs. */\n\n    unsigned char ns_cert_type; /**< Optional Netscape certificate type extension value: See the values below */\n\n    x509_buf sig_oid2;          /**< Signature algorithm. Must match sig_oid1. */\n    x509_buf sig;               /**< Signature: hash of the tbs part signed with the private key. */\n    int sig_alg;                /**< Internal representation of the signature algorithm, e.g. SIG_RSA_MD2 */\n\n    struct _x509_cert *next;    /**< Next certificate in the CA-chain. */ \n}\nx509_cert;\n\n/** \n * Certificate revocation list entry. \n * Contains the CA-specific serial numbers and revocation dates.\n */\ntypedef struct _x509_crl_entry\n{\n    x509_buf raw;\n\n    x509_buf serial;\n\n    x509_time revocation_date;\n\n    x509_buf entry_ext;\n\n    struct _x509_crl_entry *next;\n}\nx509_crl_entry;\n\n/** \n * Certificate revocation list structure. \n * Every CRL may have multiple entries.\n */\ntypedef struct _x509_crl\n{\n    x509_buf raw;           /**< The raw certificate data (DER). */\n    x509_buf tbs;           /**< The raw certificate body (DER). The part that is To Be Signed. */\n\n    int version;\n    x509_buf sig_oid1;\n\n    x509_buf issuer_raw;    /**< The raw issuer data (DER). */\n\n    x509_name issuer;       /**< The parsed issuer data (named information object). */\n\n    x509_time this_update;  \n    x509_time next_update;\n\n    x509_crl_entry entry;   /**< The CRL entries containing the certificate revocation times for this CA. */\n\n    x509_buf crl_ext;\n\n    x509_buf sig_oid2;\n    x509_buf sig;\n    int sig_alg;\n\n    struct _x509_crl *next; \n}\nx509_crl;\n/** \\} name Structures for parsing X.509 certificates and CRLs */\n/** \\} addtogroup x509_module */\n\n/**\n * \\name Structures for writing X.509 certificates.\n * XvP: commented out as they are not used.\n * - <tt>typedef struct _x509_node x509_node;</tt>\n * - <tt>typedef struct _x509_raw x509_raw;</tt>\n */\n/*\ntypedef struct _x509_node\n{\n    unsigned char *data;\n    unsigned char *p;\n    unsigned char *end;\n\n    size_t len;\n}\nx509_node;\n\ntypedef struct _x509_raw\n{\n    x509_node raw;\n    x509_node tbs;\n\n    x509_node version;\n    x509_node serial;\n    x509_node tbs_signalg;\n    x509_node issuer;\n    x509_node validity;\n    x509_node subject;\n    x509_node subpubkey;\n\n    x509_node signalg;\n    x509_node sign;\n}\nx509_raw;\n*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\name Functions to read in DHM parameters, a certificate, CRL or private RSA key\n * \\{\n */\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse a single DER formatted certificate and add it\n *                 to the chained list.\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the certificate DER data\n * \\param buflen   size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_crt_der( x509_cert *chain, const unsigned char *buf, size_t buflen );\n\n/**\n * \\brief          Parse one or more certificates and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the certificate data\n * \\param buflen   size of the buffer\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint x509parse_crt( x509_cert *chain, const unsigned char *buf, size_t buflen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load one or more certificates and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param path     filename to read the certificates from\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint x509parse_crtfile( x509_cert *chain, const char *path );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load one or more certificate files from a path and add them\n *                 to the chained list. Parses permissively. If some\n *                 certificates can be parsed, the result is the number\n *                 of failed certificates it encountered. If none complete\n *                 correctly, the first error is returned.\n *\n * \\param chain    points to the start of the chain\n * \\param path     directory / folder to read the certificate files from\n *\n * \\return         0 if all certificates parsed successfully, a positive number\n *                 if partly successful or a specific X509 or PEM error code\n */\nint x509parse_crtpath( x509_cert *chain, const char *path );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse one or more CRLs and add them\n *                 to the chained list\n *\n * \\param chain    points to the start of the chain\n * \\param buf      buffer holding the CRL data\n * \\param buflen   size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_crl( x509_crl *chain, const unsigned char *buf, size_t buflen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load one or more CRLs and add them\n *                 to the chained list\n *\n * \\param chain    points to the start of the chain\n * \\param path     filename to read the CRLs from\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_crlfile( x509_crl *chain, const char *path );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse a private RSA key\n *\n * \\param rsa      RSA context to be initialized\n * \\param key      input buffer\n * \\param keylen   size of the buffer\n * \\param pwd      password for decryption (optional)\n * \\param pwdlen   size of the password\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_key( rsa_context *rsa,\n                   const unsigned char *key, size_t keylen,\n                   const unsigned char *pwd, size_t pwdlen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load and parse a private RSA key\n *\n * \\param rsa      RSA context to be initialized\n * \\param path     filename to read the private key from\n * \\param password password to decrypt the file (can be NULL)\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_keyfile( rsa_context *rsa, const char *path,\n                       const char *password );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse a public RSA key\n *\n * \\param rsa      RSA context to be initialized\n * \\param key      input buffer\n * \\param keylen   size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_public_key( rsa_context *rsa,\n                   const unsigned char *key, size_t keylen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load and parse a public RSA key\n *\n * \\param rsa      RSA context to be initialized\n * \\param path     filename to read the private key from\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_public_keyfile( rsa_context *rsa, const char *path );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Parse DHM parameters\n *\n * \\param dhm      DHM context to be initialized\n * \\param dhmin    input buffer\n * \\param dhminlen size of the buffer\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_dhm( dhm_context *dhm, const unsigned char *dhmin, size_t dhminlen );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Load and parse DHM parameters\n *\n * \\param dhm      DHM context to be initialized\n * \\param path     filename to read the DHM Parameters from\n *\n * \\return         0 if successful, or a specific X509 or PEM error code\n */\nint x509parse_dhmfile( dhm_context *dhm, const char *path );\n\n/** \\} name Functions to read in DHM parameters, a certificate, CRL or private RSA key */\n\n/**\n * \\brief          Store the certificate DN in printable form into buf;\n *                 no more than size characters will be written.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param dn       The X509 name to represent\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509parse_dn_gets( char *buf, size_t size, const x509_name *dn );\n\n/**\n * \\brief          Store the certificate serial in printable form into buf;\n *                 no more than size characters will be written.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param serial   The X509 serial to represent\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509parse_serial_gets( char *buf, size_t size, const x509_buf *serial );\n\n/**\n * \\brief          Returns an informational string about the\n *                 certificate.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param prefix   A line prefix\n * \\param crt      The X509 certificate to represent\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509parse_cert_info( char *buf, size_t size, const char *prefix,\n                         const x509_cert *crt );\n\n/**\n * \\brief          Returns an informational string about the\n *                 CRL.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param prefix   A line prefix\n * \\param crl      The X509 CRL to represent\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509parse_crl_info( char *buf, size_t size, const char *prefix,\n                        const x509_crl *crl );\n\n/**\n * \\brief          Give an known OID, return its descriptive string.\n *\n * \\param oid      buffer containing the oid\n *\n * \\return         Return a string if the OID is known,\n *                 or NULL otherwise.\n */\nconst char *x509_oid_get_description( x509_buf *oid );\n\n/**\n * \\brief          Give an OID, return a string version of its OID number.\n *\n * \\param buf      Buffer to write to\n * \\param size     Maximum size of buffer\n * \\param oid      Buffer containing the OID\n *\n * \\return         The amount of data written to the buffer, or -1 in\n *                 case of an error.\n */\nint x509_oid_get_numeric_string( char *buf, size_t size, x509_buf *oid );\n\n/**\n * \\brief          Check a given x509_time against the system time and check\n *                 if it is valid.\n *\n * \\param time     x509_time to check\n *\n * \\return         Return 0 if the x509_time is still valid,\n *                 or 1 otherwise.\n */\nint x509parse_time_expired( const x509_time *time );\n\n/**\n * \\name Functions to verify a certificate\n * \\{\n */\n/** \\ingroup x509_module */\n/**\n * \\brief          Verify the certificate signature\n *\n *                 The verify callback is a user-supplied callback that\n *                 can clear / modify / add flags for a certificate. If set,\n *                 the verification callback is called for each\n *                 certificate in the chain (from the trust-ca down to the\n *                 presented crt). The parameters for the callback are:\n *                 (void *parameter, x509_cert *crt, int certificate_depth,\n *                 int *flags). With the flags representing current flags for\n *                 that specific certificate and the certificate depth from\n *                 the bottom (Peer cert depth = 0).\n *\n *                 All flags left after returning from the callback\n *                 are also returned to the application. The function should\n *                 return 0 for anything but a fatal error.\n *\n * \\param crt      a certificate to be verified\n * \\param trust_ca the trusted CA chain\n * \\param ca_crl   the CRL chain for trusted CA's\n * \\param cn       expected Common Name (can be set to\n *                 NULL if the CN must not be verified)\n * \\param flags    result of the verification\n * \\param f_vrfy   verification function\n * \\param p_vrfy   verification parameter\n *\n * \\return         0 if successful or POLARSSL_ERR_X509_SIG_VERIFY_FAILED,\n *                 in which case *flags will have one or more of\n *                 the following values set:\n *                      BADCERT_EXPIRED --\n *                      BADCERT_REVOKED --\n *                      BADCERT_CN_MISMATCH --\n *                      BADCERT_NOT_TRUSTED\n *                 or another error in case of a fatal error encountered\n *                 during the verification process.\n */\nint x509parse_verify( x509_cert *crt,\n                      x509_cert *trust_ca,\n                      x509_crl *ca_crl,\n                      const char *cn, int *flags,\n                      int (*f_vrfy)(void *, x509_cert *, int, int *),\n                      void *p_vrfy );\n\n/**\n * \\brief          Verify the certificate signature\n *\n * \\param crt      a certificate to be verified\n * \\param crl      the CRL to verify against\n *\n * \\return         1 if the certificate is revoked, 0 otherwise\n *\n */\nint x509parse_revoked( const x509_cert *crt, const x509_crl *crl );\n\n/** \\} name Functions to verify a certificate */\n\n\n\n/**\n * \\name Functions to clear a certificate, CRL or private RSA key \n * \\{\n */\n/** \\ingroup x509_module */\n/**\n * \\brief          Unallocate all certificate data\n *\n * \\param crt      Certificate chain to free\n */\nvoid x509_free( x509_cert *crt );\n\n/** \\ingroup x509_module */\n/**\n * \\brief          Unallocate all CRL data\n *\n * \\param crl      CRL chain to free\n */\nvoid x509_crl_free( x509_crl *crl );\n\n/** \\} name Functions to clear a certificate, CRL or private RSA key */\n\n\n/**\n * \\brief          Checkup routine\n *\n * \\return         0 if successful, or 1 if the test failed\n */\nint x509_self_test( int verbose );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* x509.h */\n", "/*\n *  SSLv3/TLSv1 shared functions\n *\n *  Copyright (C) 2006-2012, Brainspark B.V.\n *\n *  This file is part of PolarSSL (http://www.polarssl.org)\n *  Lead Maintainer: Paul Bakker <polarssl_maintainer at polarssl.org>\n *\n *  All rights reserved.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n/*\n *  The SSL 3.0 specification was drafted by Netscape in 1996,\n *  and became an IETF standard in 1999.\n *\n *  http://wp.netscape.com/eng/ssl3/\n *  http://www.ietf.org/rfc/rfc2246.txt\n *  http://www.ietf.org/rfc/rfc4346.txt\n */\n\n#include \"polarssl/config.h\"\n\n#if defined(POLARSSL_SSL_TLS_C)\n\n#include \"polarssl/aes.h\"\n#include \"polarssl/arc4.h\"\n#include \"polarssl/camellia.h\"\n#include \"polarssl/des.h\"\n#include \"polarssl/debug.h\"\n#include \"polarssl/ssl.h\"\n#include \"polarssl/sha2.h\"\n\n#if defined(POLARSSL_GCM_C)\n#include \"polarssl/gcm.h\"\n#endif\n\n#include <stdlib.h>\n#include <time.h>\n\n#if defined _MSC_VER && !defined strcasecmp\n#define strcasecmp _stricmp\n#endif\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\nint (*ssl_hw_record_init)(ssl_context *ssl,\n                       const unsigned char *key_enc, const unsigned char *key_dec,\n                       const unsigned char *iv_enc,  const unsigned char *iv_dec,\n                       const unsigned char *mac_enc, const unsigned char *mac_dec) = NULL;\nint (*ssl_hw_record_reset)(ssl_context *ssl) = NULL;\nint (*ssl_hw_record_write)(ssl_context *ssl) = NULL;\nint (*ssl_hw_record_read)(ssl_context *ssl) = NULL;\nint (*ssl_hw_record_finish)(ssl_context *ssl) = NULL;\n#endif\n\nstatic int ssl_rsa_decrypt( void *ctx, int mode, size_t *olen,\n                        const unsigned char *input, unsigned char *output,\n                        size_t output_max_len )\n{\n    return rsa_pkcs1_decrypt( (rsa_context *) ctx, mode, olen, input, output,\n                              output_max_len );\n}\n\nstatic int ssl_rsa_sign( void *ctx,\n                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,\n                    int mode, int hash_id, unsigned int hashlen,\n                    const unsigned char *hash, unsigned char *sig )\n{\n    return rsa_pkcs1_sign( (rsa_context *) ctx, f_rng, p_rng, mode, hash_id,\n                           hashlen, hash, sig );\n}\n\nstatic size_t ssl_rsa_key_len( void *ctx )\n{\n    return ( (rsa_context *) ctx )->len;\n}\n\n/*\n * Key material generation\n */\nstatic int ssl3_prf( unsigned char *secret, size_t slen, char *label,\n                     unsigned char *random, size_t rlen,\n                     unsigned char *dstbuf, size_t dlen )\n{\n    size_t i;\n    md5_context md5;\n    sha1_context sha1;\n    unsigned char padding[16];\n    unsigned char sha1sum[20];\n    ((void)label);\n\n    /*\n     *  SSLv3:\n     *    block =\n     *      MD5( secret + SHA1( 'A'    + secret + random ) ) +\n     *      MD5( secret + SHA1( 'BB'   + secret + random ) ) +\n     *      MD5( secret + SHA1( 'CCC'  + secret + random ) ) +\n     *      ...\n     */\n    for( i = 0; i < dlen / 16; i++ )\n    {\n        memset( padding, 'A' + i, 1 + i );\n\n        sha1_starts( &sha1 );\n        sha1_update( &sha1, padding, 1 + i );\n        sha1_update( &sha1, secret, slen );\n        sha1_update( &sha1, random, rlen );\n        sha1_finish( &sha1, sha1sum );\n\n        md5_starts( &md5 );\n        md5_update( &md5, secret, slen );\n        md5_update( &md5, sha1sum, 20 );\n        md5_finish( &md5, dstbuf + i * 16 );\n    }\n\n    memset( &md5,  0, sizeof( md5  ) );\n    memset( &sha1, 0, sizeof( sha1 ) );\n\n    memset( padding, 0, sizeof( padding ) );\n    memset( sha1sum, 0, sizeof( sha1sum ) );\n\n    return( 0 );\n}\n\nstatic int tls1_prf( unsigned char *secret, size_t slen, char *label,\n                     unsigned char *random, size_t rlen,\n                     unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb, hs;\n    size_t i, j, k;\n    unsigned char *S1, *S2;\n    unsigned char tmp[128];\n    unsigned char h_i[20];\n\n    if( sizeof( tmp ) < 20 + strlen( label ) + rlen )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    hs = ( slen + 1 ) / 2;\n    S1 = secret;\n    S2 = secret + slen - hs;\n\n    nb = strlen( label );\n    memcpy( tmp + 20, label, nb );\n    memcpy( tmp + 20 + nb, random, rlen );\n    nb += rlen;\n\n    /*\n     * First compute P_md5(secret,label+random)[0..dlen]\n     */\n    md5_hmac( S1, hs, tmp + 20, nb, 4 + tmp );\n\n    for( i = 0; i < dlen; i += 16 )\n    {\n        md5_hmac( S1, hs, 4 + tmp, 16 + nb, h_i );\n        md5_hmac( S1, hs, 4 + tmp, 16,  4 + tmp );\n\n        k = ( i + 16 > dlen ) ? dlen % 16 : 16;\n\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n\n    /*\n     * XOR out with P_sha1(secret,label+random)[0..dlen]\n     */\n    sha1_hmac( S2, hs, tmp + 20, nb, tmp );\n\n    for( i = 0; i < dlen; i += 20 )\n    {\n        sha1_hmac( S2, hs, tmp, 20 + nb, h_i );\n        sha1_hmac( S2, hs, tmp, 20,      tmp );\n\n        k = ( i + 20 > dlen ) ? dlen % 20 : 20;\n\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j] = (unsigned char)( dstbuf[i + j] ^ h_i[j] );\n    }\n\n    memset( tmp, 0, sizeof( tmp ) );\n    memset( h_i, 0, sizeof( h_i ) );\n\n    return( 0 );\n}\n\nstatic int tls_prf_sha256( unsigned char *secret, size_t slen, char *label,\n                           unsigned char *random, size_t rlen,\n                           unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb;\n    size_t i, j, k;\n    unsigned char tmp[128];\n    unsigned char h_i[32];\n\n    if( sizeof( tmp ) < 32 + strlen( label ) + rlen )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    nb = strlen( label );\n    memcpy( tmp + 32, label, nb );\n    memcpy( tmp + 32 + nb, random, rlen );\n    nb += rlen;\n\n    /*\n     * Compute P_<hash>(secret, label + random)[0..dlen]\n     */\n    sha2_hmac( secret, slen, tmp + 32, nb, tmp, 0 );\n\n    for( i = 0; i < dlen; i += 32 )\n    {\n        sha2_hmac( secret, slen, tmp, 32 + nb, h_i, 0 );\n        sha2_hmac( secret, slen, tmp, 32,      tmp, 0 );\n\n        k = ( i + 32 > dlen ) ? dlen % 32 : 32;\n\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n\n    memset( tmp, 0, sizeof( tmp ) );\n    memset( h_i, 0, sizeof( h_i ) );\n\n    return( 0 );\n}\n\n#if defined(POLARSSL_SHA4_C)\nstatic int tls_prf_sha384( unsigned char *secret, size_t slen, char *label,\n                           unsigned char *random, size_t rlen,\n                           unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb;\n    size_t i, j, k;\n    unsigned char tmp[128];\n    unsigned char h_i[48];\n\n    if( sizeof( tmp ) < 48 + strlen( label ) + rlen )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    nb = strlen( label );\n    memcpy( tmp + 48, label, nb );\n    memcpy( tmp + 48 + nb, random, rlen );\n    nb += rlen;\n\n    /*\n     * Compute P_<hash>(secret, label + random)[0..dlen]\n     */\n    sha4_hmac( secret, slen, tmp + 48, nb, tmp, 1 );\n\n    for( i = 0; i < dlen; i += 48 )\n    {\n        sha4_hmac( secret, slen, tmp, 48 + nb, h_i, 1 );\n        sha4_hmac( secret, slen, tmp, 48,      tmp, 1 );\n\n        k = ( i + 48 > dlen ) ? dlen % 48 : 48;\n\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n\n    memset( tmp, 0, sizeof( tmp ) );\n    memset( h_i, 0, sizeof( h_i ) );\n\n    return( 0 );\n}\n#endif\n\nstatic void ssl_update_checksum_start(ssl_context *, unsigned char *, size_t);\nstatic void ssl_update_checksum_md5sha1(ssl_context *, unsigned char *, size_t);\nstatic void ssl_update_checksum_sha256(ssl_context *, unsigned char *, size_t);\n\nstatic void ssl_calc_verify_ssl(ssl_context *,unsigned char *);\nstatic void ssl_calc_verify_tls(ssl_context *,unsigned char *);\nstatic void ssl_calc_verify_tls_sha256(ssl_context *,unsigned char *);\n\nstatic void ssl_calc_finished_ssl(ssl_context *,unsigned char *,int);\nstatic void ssl_calc_finished_tls(ssl_context *,unsigned char *,int);\nstatic void ssl_calc_finished_tls_sha256(ssl_context *,unsigned char *,int);\n\n#if defined(POLARSSL_SHA4_C)\nstatic void ssl_update_checksum_sha384(ssl_context *, unsigned char *, size_t);\nstatic void ssl_calc_verify_tls_sha384(ssl_context *,unsigned char *);\nstatic void ssl_calc_finished_tls_sha384(ssl_context *,unsigned char *,int);\n#endif\n\nint ssl_derive_keys( ssl_context *ssl )\n{\n    unsigned char tmp[64];\n    unsigned char keyblk[256];\n    unsigned char *key1;\n    unsigned char *key2;\n    unsigned int iv_copy_len;\n    ssl_session *session = ssl->session_negotiate;\n    ssl_transform *transform = ssl->transform_negotiate;\n    ssl_handshake_params *handshake = ssl->handshake;\n\n    SSL_DEBUG_MSG( 2, ( \"=> derive keys\" ) );\n\n    /*\n     * Set appropriate PRF function and other SSL / TLS / TLS1.2 functions\n     */\n    if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        handshake->tls_prf = ssl3_prf;\n        handshake->calc_verify = ssl_calc_verify_ssl;\n        handshake->calc_finished = ssl_calc_finished_ssl;\n    }\n    else if( ssl->minor_ver < SSL_MINOR_VERSION_3 )\n    {\n        handshake->tls_prf = tls1_prf;\n        handshake->calc_verify = ssl_calc_verify_tls;\n        handshake->calc_finished = ssl_calc_finished_tls;\n    }\n#if defined(POLARSSL_SHA4_C)\n    else if( session->ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n             session->ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n    {\n        handshake->tls_prf = tls_prf_sha384;\n        handshake->calc_verify = ssl_calc_verify_tls_sha384;\n        handshake->calc_finished = ssl_calc_finished_tls_sha384;\n    }\n#endif\n    else\n    {\n        handshake->tls_prf = tls_prf_sha256;\n        handshake->calc_verify = ssl_calc_verify_tls_sha256;\n        handshake->calc_finished = ssl_calc_finished_tls_sha256;\n    }\n\n    /*\n     * SSLv3:\n     *   master =\n     *     MD5( premaster + SHA1( 'A'   + premaster + randbytes ) ) +\n     *     MD5( premaster + SHA1( 'BB'  + premaster + randbytes ) ) +\n     *     MD5( premaster + SHA1( 'CCC' + premaster + randbytes ) )\n     *   \n     * TLSv1:\n     *   master = PRF( premaster, \"master secret\", randbytes )[0..47]\n     */\n    if( handshake->resume == 0 )\n    {\n        SSL_DEBUG_BUF( 3, \"premaster secret\", handshake->premaster,\n                       handshake->pmslen );\n\n        handshake->tls_prf( handshake->premaster, handshake->pmslen,\n                            \"master secret\",\n                            handshake->randbytes, 64, session->master, 48 );\n\n        memset( handshake->premaster, 0, sizeof( handshake->premaster ) );\n    }\n    else\n        SSL_DEBUG_MSG( 3, ( \"no premaster (session resumed)\" ) );\n\n    /*\n     * Swap the client and server random values.\n     */\n    memcpy( tmp, handshake->randbytes, 64 );\n    memcpy( handshake->randbytes, tmp + 32, 32 );\n    memcpy( handshake->randbytes + 32, tmp, 32 );\n    memset( tmp, 0, sizeof( tmp ) );\n\n    /*\n     *  SSLv3:\n     *    key block =\n     *      MD5( master + SHA1( 'A'    + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'BB'   + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'CCC'  + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'DDDD' + master + randbytes ) ) +\n     *      ...\n     *\n     *  TLSv1:\n     *    key block = PRF( master, \"key expansion\", randbytes )\n     */\n    handshake->tls_prf( session->master, 48, \"key expansion\",\n                        handshake->randbytes, 64, keyblk, 256 );\n\n    SSL_DEBUG_MSG( 3, ( \"ciphersuite = %s\",\n                   ssl_get_ciphersuite_name( session->ciphersuite ) ) );\n    SSL_DEBUG_BUF( 3, \"master secret\", session->master, 48 );\n    SSL_DEBUG_BUF( 4, \"random bytes\", handshake->randbytes, 64 );\n    SSL_DEBUG_BUF( 4, \"key block\", keyblk, 256 );\n\n    memset( handshake->randbytes, 0, sizeof( handshake->randbytes ) );\n\n    /*\n     * Determine the appropriate key, IV and MAC length.\n     */\n    switch( session->ciphersuite )\n    {\n#if defined(POLARSSL_ARC4_C)\n        case TLS_RSA_WITH_RC4_128_MD5:\n            transform->keylen = 16; transform->minlen = 16;\n            transform->ivlen  =  0; transform->maclen = 16;\n            break;\n\n        case TLS_RSA_WITH_RC4_128_SHA:\n            transform->keylen = 16; transform->minlen = 20;\n            transform->ivlen  =  0; transform->maclen = 20;\n            break;\n#endif\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_3DES_EDE_CBC_SHA:\n        case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:\n            transform->keylen = 24; transform->minlen = 24;\n            transform->ivlen  =  8; transform->maclen = 20;\n            break;\n#endif\n\n#if defined(POLARSSL_AES_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA:\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:\n            transform->keylen = 16; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 20;\n            break;\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA:\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:\n            transform->keylen = 32; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 20;\n            break;\n\n#if defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:\n            transform->keylen = 16; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 32;\n            break;\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:\n            transform->keylen = 32; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 32;\n            break;\n#endif\n#if defined(POLARSSL_GCM_C)\n        case TLS_RSA_WITH_AES_128_GCM_SHA256:\n        case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:\n            transform->keylen = 16; transform->minlen = 1;\n            transform->ivlen  = 12; transform->maclen = 0;\n            transform->fixed_ivlen = 4;\n            break;\n\n        case TLS_RSA_WITH_AES_256_GCM_SHA384:\n        case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:\n            transform->keylen = 32; transform->minlen = 1;\n            transform->ivlen  = 12; transform->maclen = 0;\n            transform->fixed_ivlen = 4;\n            break;\n#endif\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:\n            transform->keylen = 16; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 20;\n            break;\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:\n            transform->keylen = 32; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 20;\n            break;\n\n#if defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n            transform->keylen = 16; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 32;\n            break;\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n            transform->keylen = 32; transform->minlen = 32;\n            transform->ivlen  = 16; transform->maclen = 32;\n            break;\n#endif\n#endif\n\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        case TLS_RSA_WITH_NULL_MD5:\n            transform->keylen = 0; transform->minlen = 0;\n            transform->ivlen  = 0; transform->maclen = 16;\n            break;\n\n        case TLS_RSA_WITH_NULL_SHA:\n            transform->keylen = 0; transform->minlen = 0;\n            transform->ivlen  = 0; transform->maclen = 20;\n            break;\n\n        case TLS_RSA_WITH_NULL_SHA256:\n            transform->keylen = 0; transform->minlen = 0;\n            transform->ivlen  = 0; transform->maclen = 32;\n            break;\n#endif /* defined(POLARSSL_CIPHER_NULL_CIPHER) */\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_DES_CBC_SHA:\n        case TLS_DHE_RSA_WITH_DES_CBC_SHA:\n            transform->keylen =  8; transform->minlen = 8;\n            transform->ivlen  =  8; transform->maclen = 20;\n            break;\n#endif\n#endif /* defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES) */\n\n        default:\n            SSL_DEBUG_MSG( 1, ( \"ciphersuite %s is not available\",\n                           ssl_get_ciphersuite_name( session->ciphersuite ) ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"keylen: %d, minlen: %d, ivlen: %d, maclen: %d\",\n                   transform->keylen, transform->minlen, transform->ivlen,\n                   transform->maclen ) );\n\n    /*\n     * Finally setup the cipher contexts, IVs and MAC secrets.\n     */\n    if( ssl->endpoint == SSL_IS_CLIENT )\n    {\n        key1 = keyblk + transform->maclen * 2;\n        key2 = keyblk + transform->maclen * 2 + transform->keylen;\n\n        memcpy( transform->mac_enc, keyblk,  transform->maclen );\n        memcpy( transform->mac_dec, keyblk + transform->maclen,\n                transform->maclen );\n\n        /*\n         * This is not used in TLS v1.1.\n         */\n        iv_copy_len = ( transform->fixed_ivlen ) ?\n                            transform->fixed_ivlen : transform->ivlen;\n        memcpy( transform->iv_enc, key2 + transform->keylen,  iv_copy_len );\n        memcpy( transform->iv_dec, key2 + transform->keylen + iv_copy_len,\n                iv_copy_len );\n    }\n    else\n    {\n        key1 = keyblk + transform->maclen * 2 + transform->keylen;\n        key2 = keyblk + transform->maclen * 2;\n\n        memcpy( transform->mac_dec, keyblk,  transform->maclen );\n        memcpy( transform->mac_enc, keyblk + transform->maclen,\n                transform->maclen );\n\n        /*\n         * This is not used in TLS v1.1.\n         */\n        iv_copy_len = ( transform->fixed_ivlen ) ?\n                            transform->fixed_ivlen : transform->ivlen;\n        memcpy( transform->iv_dec, key1 + transform->keylen,  iv_copy_len );\n        memcpy( transform->iv_enc, key1 + transform->keylen + iv_copy_len,\n                iv_copy_len );\n    }\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_init != NULL)\n    {\n        int ret = 0;\n\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_init()\" ) );\n\n        if( ( ret = ssl_hw_record_init( ssl, key1, key2, transform->iv_enc,\n                                        transform->iv_dec, transform->mac_enc,\n                                        transform->mac_dec ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_init\", ret );\n            return POLARSSL_ERR_SSL_HW_ACCEL_FAILED;\n        }\n    }\n#endif\n\n    switch( session->ciphersuite )\n    {\n#if defined(POLARSSL_ARC4_C)\n        case TLS_RSA_WITH_RC4_128_MD5:\n        case TLS_RSA_WITH_RC4_128_SHA:\n            arc4_setup( (arc4_context *) transform->ctx_enc, key1,\n                        transform->keylen );\n            arc4_setup( (arc4_context *) transform->ctx_dec, key2,\n                        transform->keylen );\n            break;\n#endif\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_3DES_EDE_CBC_SHA:\n        case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:\n            des3_set3key_enc( (des3_context *) transform->ctx_enc, key1 );\n            des3_set3key_dec( (des3_context *) transform->ctx_dec, key2 );\n            break;\n#endif\n\n#if defined(POLARSSL_AES_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA:\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:\n        case TLS_RSA_WITH_AES_128_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:\n            aes_setkey_enc( (aes_context *) transform->ctx_enc, key1, 128 );\n            aes_setkey_dec( (aes_context *) transform->ctx_dec, key2, 128 );\n            break;\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA:\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:\n        case TLS_RSA_WITH_AES_256_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:\n            aes_setkey_enc( (aes_context *) transform->ctx_enc, key1, 256 );\n            aes_setkey_dec( (aes_context *) transform->ctx_dec, key2, 256 );\n            break;\n\n#if defined(POLARSSL_GCM_C)\n        case TLS_RSA_WITH_AES_128_GCM_SHA256:\n        case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:\n            gcm_init( (gcm_context *) transform->ctx_enc, key1, 128 );\n            gcm_init( (gcm_context *) transform->ctx_dec, key2, 128 );\n            break;\n\n        case TLS_RSA_WITH_AES_256_GCM_SHA384:\n        case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:\n            gcm_init( (gcm_context *) transform->ctx_enc, key1, 256 );\n            gcm_init( (gcm_context *) transform->ctx_dec, key2, 256 );\n            break;\n#endif\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n            camellia_setkey_enc( (camellia_context *) transform->ctx_enc, key1, 128 );\n            camellia_setkey_dec( (camellia_context *) transform->ctx_dec, key2, 128 );\n            break;\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n            camellia_setkey_enc( (camellia_context *) transform->ctx_enc, key1, 256 );\n            camellia_setkey_dec( (camellia_context *) transform->ctx_dec, key2, 256 );\n            break;\n#endif\n\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        case TLS_RSA_WITH_NULL_MD5:\n        case TLS_RSA_WITH_NULL_SHA:\n        case TLS_RSA_WITH_NULL_SHA256:\n            break;\n#endif /* defined(POLARSSL_CIPHER_NULL_CIPHER) */\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_DES_CBC_SHA:\n        case TLS_DHE_RSA_WITH_DES_CBC_SHA:\n            des_setkey_enc( (des_context *) transform->ctx_enc, key1 );\n            des_setkey_dec( (des_context *) transform->ctx_dec, key2 );\n            break;\n#endif\n#endif /* defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES) */\n\n        default:\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n\n    memset( keyblk, 0, sizeof( keyblk ) );\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    // Initialize compression\n    //\n    if( session->compression == SSL_COMPRESS_DEFLATE )\n    {\n        SSL_DEBUG_MSG( 3, ( \"Initializing zlib states\" ) );\n\n        memset( &transform->ctx_deflate, 0, sizeof( transform->ctx_deflate ) );\n        memset( &transform->ctx_inflate, 0, sizeof( transform->ctx_inflate ) );\n\n        if( deflateInit( &transform->ctx_deflate, Z_DEFAULT_COMPRESSION ) != Z_OK ||\n            inflateInit( &transform->ctx_inflate ) != Z_OK )\n        {\n            SSL_DEBUG_MSG( 1, ( \"Failed to initialize compression\" ) );\n            return( POLARSSL_ERR_SSL_COMPRESSION_FAILED );\n        }\n    }\n#endif /* POLARSSL_ZLIB_SUPPORT */\n\n    SSL_DEBUG_MSG( 2, ( \"<= derive keys\" ) );\n\n    return( 0 );\n}\n\nvoid ssl_calc_verify_ssl( ssl_context *ssl, unsigned char hash[36] )\n{\n    md5_context md5;\n    sha1_context sha1;\n    unsigned char pad_1[48];\n    unsigned char pad_2[48];\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc verify ssl\" ) );\n\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n\n    memset( pad_1, 0x36, 48 );\n    memset( pad_2, 0x5C, 48 );\n\n    md5_update( &md5, ssl->session_negotiate->master, 48 );\n    md5_update( &md5, pad_1, 48 );\n    md5_finish( &md5, hash );\n\n    md5_starts( &md5 );\n    md5_update( &md5, ssl->session_negotiate->master, 48 );\n    md5_update( &md5, pad_2, 48 );\n    md5_update( &md5, hash,  16 );\n    md5_finish( &md5, hash );\n\n    sha1_update( &sha1, ssl->session_negotiate->master, 48 );\n    sha1_update( &sha1, pad_1, 40 );\n    sha1_finish( &sha1, hash + 16 );\n\n    sha1_starts( &sha1 );\n    sha1_update( &sha1, ssl->session_negotiate->master, 48 );\n    sha1_update( &sha1, pad_2, 40 );\n    sha1_update( &sha1, hash + 16, 20 );\n    sha1_finish( &sha1, hash + 16 );\n\n    SSL_DEBUG_BUF( 3, \"calculated verify result\", hash, 36 );\n    SSL_DEBUG_MSG( 2, ( \"<= calc verify\" ) );\n\n    return;\n}\n\nvoid ssl_calc_verify_tls( ssl_context *ssl, unsigned char hash[36] )\n{\n    md5_context md5;\n    sha1_context sha1;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc verify tls\" ) );\n\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n\n     md5_finish( &md5,  hash );\n    sha1_finish( &sha1, hash + 16 );\n\n    SSL_DEBUG_BUF( 3, \"calculated verify result\", hash, 36 );\n    SSL_DEBUG_MSG( 2, ( \"<= calc verify\" ) );\n\n    return;\n}\n\nvoid ssl_calc_verify_tls_sha256( ssl_context *ssl, unsigned char hash[32] )\n{\n    sha2_context sha2;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc verify sha256\" ) );\n\n    memcpy( &sha2, &ssl->handshake->fin_sha2, sizeof(sha2_context) );\n    sha2_finish( &sha2, hash );\n\n    SSL_DEBUG_BUF( 3, \"calculated verify result\", hash, 32 );\n    SSL_DEBUG_MSG( 2, ( \"<= calc verify\" ) );\n\n    return;\n}\n\n#if defined(POLARSSL_SHA4_C)\nvoid ssl_calc_verify_tls_sha384( ssl_context *ssl, unsigned char hash[48] )\n{\n    sha4_context sha4;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc verify sha384\" ) );\n\n    memcpy( &sha4, &ssl->handshake->fin_sha4, sizeof(sha4_context) );\n    sha4_finish( &sha4, hash );\n\n    SSL_DEBUG_BUF( 3, \"calculated verify result\", hash, 48 );\n    SSL_DEBUG_MSG( 2, ( \"<= calc verify\" ) );\n\n    return;\n}\n#endif\n\n/*\n * SSLv3.0 MAC functions\n */\nstatic void ssl_mac_md5( unsigned char *secret,\n                         unsigned char *buf, size_t len,\n                         unsigned char *ctr, int type )\n{\n    unsigned char header[11];\n    unsigned char padding[48];\n    md5_context md5;\n\n    memcpy( header, ctr, 8 );\n    header[ 8] = (unsigned char)  type;\n    header[ 9] = (unsigned char)( len >> 8 );\n    header[10] = (unsigned char)( len      );\n\n    memset( padding, 0x36, 48 );\n    md5_starts( &md5 );\n    md5_update( &md5, secret,  16 );\n    md5_update( &md5, padding, 48 );\n    md5_update( &md5, header,  11 );\n    md5_update( &md5, buf,  len );\n    md5_finish( &md5, buf + len );\n\n    memset( padding, 0x5C, 48 );\n    md5_starts( &md5 );\n    md5_update( &md5, secret,  16 );\n    md5_update( &md5, padding, 48 );\n    md5_update( &md5, buf + len, 16 );\n    md5_finish( &md5, buf + len );\n}\n\nstatic void ssl_mac_sha1( unsigned char *secret,\n                          unsigned char *buf, size_t len,\n                          unsigned char *ctr, int type )\n{\n    unsigned char header[11];\n    unsigned char padding[40];\n    sha1_context sha1;\n\n    memcpy( header, ctr, 8 );\n    header[ 8] = (unsigned char)  type;\n    header[ 9] = (unsigned char)( len >> 8 );\n    header[10] = (unsigned char)( len      );\n\n    memset( padding, 0x36, 40 );\n    sha1_starts( &sha1 );\n    sha1_update( &sha1, secret,  20 );\n    sha1_update( &sha1, padding, 40 );\n    sha1_update( &sha1, header,  11 );\n    sha1_update( &sha1, buf,  len );\n    sha1_finish( &sha1, buf + len );\n\n    memset( padding, 0x5C, 40 );\n    sha1_starts( &sha1 );\n    sha1_update( &sha1, secret,  20 );\n    sha1_update( &sha1, padding, 40 );\n    sha1_update( &sha1, buf + len, 20 );\n    sha1_finish( &sha1, buf + len );\n}\n\nstatic void ssl_mac_sha2( unsigned char *secret,\n                          unsigned char *buf, size_t len,\n                          unsigned char *ctr, int type )\n{\n    unsigned char header[11];\n    unsigned char padding[32];\n    sha2_context sha2;\n\n    memcpy( header, ctr, 8 );\n    header[ 8] = (unsigned char)  type;\n    header[ 9] = (unsigned char)( len >> 8 );\n    header[10] = (unsigned char)( len      );\n\n    memset( padding, 0x36, 32 );\n    sha2_starts( &sha2, 0 );\n    sha2_update( &sha2, secret,  32 );\n    sha2_update( &sha2, padding, 32 );\n    sha2_update( &sha2, header,  11 );\n    sha2_update( &sha2, buf,  len );\n    sha2_finish( &sha2, buf + len );\n\n    memset( padding, 0x5C, 32 );\n    sha2_starts( &sha2, 0 );\n    sha2_update( &sha2, secret,  32 );\n    sha2_update( &sha2, padding, 32 );\n    sha2_update( &sha2, buf + len, 32 );\n    sha2_finish( &sha2, buf + len );\n}\n\n/*\n * Encryption/decryption functions\n */ \nstatic int ssl_encrypt_buf( ssl_context *ssl )\n{\n    size_t i, padlen;\n\n    SSL_DEBUG_MSG( 2, ( \"=> encrypt buf\" ) );\n\n    /*\n     * Add MAC then encrypt\n     */\n    if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->transform_out->maclen == 16 )\n             ssl_mac_md5( ssl->transform_out->mac_enc,\n                          ssl->out_msg, ssl->out_msglen,\n                          ssl->out_ctr, ssl->out_msgtype );\n        else if( ssl->transform_out->maclen == 20 )\n            ssl_mac_sha1( ssl->transform_out->mac_enc,\n                          ssl->out_msg, ssl->out_msglen,\n                          ssl->out_ctr, ssl->out_msgtype );\n        else if( ssl->transform_out->maclen == 32 )\n            ssl_mac_sha2( ssl->transform_out->mac_enc,\n                          ssl->out_msg, ssl->out_msglen,\n                          ssl->out_ctr, ssl->out_msgtype );\n        else if( ssl->transform_out->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_out->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n    else\n    {\n        if( ssl->transform_out->maclen == 16 )\n        {\n            md5_context ctx;\n            md5_hmac_starts( &ctx, ssl->transform_out->mac_enc, 16 );\n            md5_hmac_update( &ctx, ssl->out_ctr, 13 );\n            md5_hmac_update( &ctx, ssl->out_msg, ssl->out_msglen );\n            md5_hmac_finish( &ctx, ssl->out_msg + ssl->out_msglen );\n            memset( &ctx, 0, sizeof(md5_context));\n        }\n        else if( ssl->transform_out->maclen == 20 )\n        {\n            sha1_context ctx;\n            sha1_hmac_starts( &ctx, ssl->transform_out->mac_enc, 20 );\n            sha1_hmac_update( &ctx, ssl->out_ctr, 13 );\n            sha1_hmac_update( &ctx, ssl->out_msg, ssl->out_msglen );\n            sha1_hmac_finish( &ctx, ssl->out_msg + ssl->out_msglen );\n            memset( &ctx, 0, sizeof(sha1_context));\n        }\n        else if( ssl->transform_out->maclen == 32 )\n        {\n            sha2_context ctx;\n            sha2_hmac_starts( &ctx, ssl->transform_out->mac_enc, 32, 0 );\n            sha2_hmac_update( &ctx, ssl->out_ctr, 13 );\n            sha2_hmac_update( &ctx, ssl->out_msg, ssl->out_msglen );\n            sha2_hmac_finish( &ctx, ssl->out_msg + ssl->out_msglen );\n            memset( &ctx, 0, sizeof(sha2_context));\n        }\n        else if( ssl->transform_out->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_out->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    SSL_DEBUG_BUF( 4, \"computed mac\",\n                   ssl->out_msg + ssl->out_msglen, ssl->transform_out->maclen );\n\n    ssl->out_msglen += ssl->transform_out->maclen;\n\n    if( ssl->transform_out->ivlen == 0 )\n    {\n        padlen = 0;\n\n        SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                            \"including %d bytes of padding\",\n                       ssl->out_msglen, 0 ) );\n\n        SSL_DEBUG_BUF( 4, \"before encrypt: output payload\",\n                       ssl->out_msg, ssl->out_msglen );\n\n#if defined(POLARSSL_ARC4_C)\n        if( ssl->session_out->ciphersuite == TLS_RSA_WITH_RC4_128_MD5 ||\n            ssl->session_out->ciphersuite == TLS_RSA_WITH_RC4_128_SHA )\n        {\n            arc4_crypt( (arc4_context *) ssl->transform_out->ctx_enc,\n                        ssl->out_msglen, ssl->out_msg,\n                        ssl->out_msg );\n        } else\n#endif\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        if( ssl->session_out->ciphersuite == TLS_RSA_WITH_NULL_MD5 ||\n            ssl->session_out->ciphersuite == TLS_RSA_WITH_NULL_SHA ||\n            ssl->session_out->ciphersuite == TLS_RSA_WITH_NULL_SHA256 )\n        {\n        } else\n#endif\n        return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n    else if( ssl->transform_out->ivlen == 12 )\n    {\n        size_t enc_msglen;\n        unsigned char *enc_msg;\n        unsigned char add_data[13];\n        int ret = POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE;\n\n        padlen = 0;\n        enc_msglen = ssl->out_msglen;\n\n        memcpy( add_data, ssl->out_ctr, 8 );\n        add_data[8]  = ssl->out_msgtype;\n        add_data[9]  = ssl->major_ver;\n        add_data[10] = ssl->minor_ver;\n        add_data[11] = ( ssl->out_msglen >> 8 ) & 0xFF;\n        add_data[12] = ssl->out_msglen & 0xFF;\n\n        SSL_DEBUG_BUF( 4, \"additional data used for AEAD\",\n                       add_data, 13 );\n\n#if defined(POLARSSL_AES_C) && defined(POLARSSL_GCM_C)\n\n        if( ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n            ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n        {\n            /*\n             * Generate IV\n             */\n            ret = ssl->f_rng( ssl->p_rng,\n                        ssl->transform_out->iv_enc + ssl->transform_out->fixed_ivlen,\n                        ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen );\n            if( ret != 0 )\n                return( ret );\n\n            /*\n             * Shift message for ivlen bytes and prepend IV\n             */\n            memmove( ssl->out_msg + ssl->transform_out->ivlen -\n                     ssl->transform_out->fixed_ivlen,\n                     ssl->out_msg, ssl->out_msglen );\n            memcpy( ssl->out_msg,\n                    ssl->transform_out->iv_enc + ssl->transform_out->fixed_ivlen,\n                    ssl->transform_out->ivlen  - ssl->transform_out->fixed_ivlen );\n\n            /*\n             * Fix pointer positions and message length with added IV\n             */\n            enc_msg = ssl->out_msg + ssl->transform_out->ivlen -\n                      ssl->transform_out->fixed_ivlen;\n            enc_msglen = ssl->out_msglen;\n            ssl->out_msglen += ssl->transform_out->ivlen -\n                               ssl->transform_out->fixed_ivlen;\n\n            SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                                \"including %d bytes of padding\",\n                           ssl->out_msglen, 0 ) );\n\n            SSL_DEBUG_BUF( 4, \"before encrypt: output payload\",\n                           ssl->out_msg, ssl->out_msglen );\n\n            /*\n             * Adjust for tag\n             */\n            ssl->out_msglen += 16;\n            \n            gcm_crypt_and_tag( (gcm_context *) ssl->transform_out->ctx_enc,\n                    GCM_ENCRYPT, enc_msglen,\n                    ssl->transform_out->iv_enc, ssl->transform_out->ivlen,\n                    add_data, 13,\n                    enc_msg, enc_msg,\n                    16, enc_msg + enc_msglen );\n\n            SSL_DEBUG_BUF( 4, \"after encrypt: tag\",\n                           enc_msg + enc_msglen, 16 );\n\n        } else\n#endif\n        return( ret );\n    }\n    else\n    {\n        unsigned char *enc_msg;\n        size_t enc_msglen;\n\n        padlen = ssl->transform_out->ivlen - ( ssl->out_msglen + 1 ) %\n                 ssl->transform_out->ivlen;\n        if( padlen == ssl->transform_out->ivlen )\n            padlen = 0;\n\n        for( i = 0; i <= padlen; i++ )\n            ssl->out_msg[ssl->out_msglen + i] = (unsigned char) padlen;\n\n        ssl->out_msglen += padlen + 1;\n\n        enc_msglen = ssl->out_msglen;\n        enc_msg = ssl->out_msg;\n\n        /*\n         * Prepend per-record IV for block cipher in TLS v1.1 and up as per\n         * Method 1 (6.2.3.2. in RFC4346 and RFC5246)\n         */\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_2 )\n        {\n            /*\n             * Generate IV\n             */\n            int ret = ssl->f_rng( ssl->p_rng, ssl->transform_out->iv_enc,\n                                  ssl->transform_out->ivlen );\n            if( ret != 0 )\n                return( ret );\n\n            /*\n             * Shift message for ivlen bytes and prepend IV\n             */\n            memmove( ssl->out_msg + ssl->transform_out->ivlen, ssl->out_msg,\n                     ssl->out_msglen );\n            memcpy( ssl->out_msg, ssl->transform_out->iv_enc,\n                    ssl->transform_out->ivlen );\n\n            /*\n             * Fix pointer positions and message length with added IV\n             */\n            enc_msg = ssl->out_msg + ssl->transform_out->ivlen;\n            enc_msglen = ssl->out_msglen;\n            ssl->out_msglen += ssl->transform_out->ivlen;\n        }\n\n        SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                            \"including %d bytes of IV and %d bytes of padding\",\n                       ssl->out_msglen, ssl->transform_out->ivlen, padlen + 1 ) );\n\n        SSL_DEBUG_BUF( 4, \"before encrypt: output payload\",\n                       ssl->out_msg, ssl->out_msglen );\n\n        switch( ssl->transform_out->ivlen )\n        {\n#if defined(POLARSSL_DES_C)\n            case  8:\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n                if( ssl->session_out->ciphersuite == TLS_RSA_WITH_DES_CBC_SHA ||\n                    ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_DES_CBC_SHA )\n                {\n                    des_crypt_cbc( (des_context *) ssl->transform_out->ctx_enc,\n                                   DES_ENCRYPT, enc_msglen,\n                                   ssl->transform_out->iv_enc, enc_msg, enc_msg );\n                }\n                else\n#endif\n                    des3_crypt_cbc( (des3_context *) ssl->transform_out->ctx_enc,\n                                    DES_ENCRYPT, enc_msglen,\n                                    ssl->transform_out->iv_enc, enc_msg, enc_msg );\n                break;\n#endif\n\n            case 16:\n#if defined(POLARSSL_AES_C)\n        if ( ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 )\n        {\n                    aes_crypt_cbc( (aes_context *) ssl->transform_out->ctx_enc,\n                        AES_ENCRYPT, enc_msglen,\n                        ssl->transform_out->iv_enc, enc_msg, enc_msg);\n                    break;\n        }\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        if ( ssl->session_out->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 ||\n             ssl->session_out->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 )\n        {\n                    camellia_crypt_cbc( (camellia_context *) ssl->transform_out->ctx_enc,\n                        CAMELLIA_ENCRYPT, enc_msglen,\n                        ssl->transform_out->iv_enc, enc_msg, enc_msg );\n                    break;\n        }\n#endif\n\n            default:\n                return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    for( i = 8; i > 0; i-- )\n        if( ++ssl->out_ctr[i - 1] != 0 )\n            break;\n\n    SSL_DEBUG_MSG( 2, ( \"<= encrypt buf\" ) );\n\n    return( 0 );\n}\n\n/*\n * TODO: Use digest version when integrated!\n */\n#define POLARSSL_SSL_MAX_MAC_SIZE   32\n\nstatic int ssl_decrypt_buf( ssl_context *ssl )\n{\n    size_t i, padlen = 0, correct = 1;\n    unsigned char tmp[POLARSSL_SSL_MAX_MAC_SIZE];\n\n    SSL_DEBUG_MSG( 2, ( \"=> decrypt buf\" ) );\n\n    if( ssl->in_msglen < ssl->transform_in->minlen )\n    {\n        SSL_DEBUG_MSG( 1, ( \"in_msglen (%d) < minlen (%d)\",\n                       ssl->in_msglen, ssl->transform_in->minlen ) );\n        return( POLARSSL_ERR_SSL_INVALID_MAC );\n    }\n\n    if( ssl->transform_in->ivlen == 0 )\n    {\n#if defined(POLARSSL_ARC4_C)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_RC4_128_MD5 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_RC4_128_SHA )\n        {\n            arc4_crypt( (arc4_context *) ssl->transform_in->ctx_dec,\n                    ssl->in_msglen, ssl->in_msg,\n                    ssl->in_msg );\n        } else\n#endif\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_MD5 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_SHA ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_SHA256 )\n        {\n        } else\n#endif\n        return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n    else if( ssl->transform_in->ivlen == 12 )\n    {\n        unsigned char *dec_msg;\n        unsigned char *dec_msg_result;\n        size_t dec_msglen;\n        unsigned char add_data[13];\n        int ret = POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE;\n\n#if defined(POLARSSL_AES_C) && defined(POLARSSL_GCM_C)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n            ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n        {\n            dec_msglen = ssl->in_msglen - ( ssl->transform_in->ivlen -\n                                            ssl->transform_in->fixed_ivlen );\n            dec_msglen -= 16;\n            dec_msg = ssl->in_msg + ( ssl->transform_in->ivlen -\n                                      ssl->transform_in->fixed_ivlen );\n            dec_msg_result = ssl->in_msg;\n            ssl->in_msglen = dec_msglen;\n\n            memcpy( add_data, ssl->in_ctr, 8 );\n            add_data[8]  = ssl->in_msgtype;\n            add_data[9]  = ssl->major_ver;\n            add_data[10] = ssl->minor_ver;\n            add_data[11] = ( ssl->in_msglen >> 8 ) & 0xFF;\n            add_data[12] = ssl->in_msglen & 0xFF;\n\n            SSL_DEBUG_BUF( 4, \"additional data used for AEAD\",\n                           add_data, 13 );\n\n            memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,\n                    ssl->in_msg,\n                    ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen );\n\n            SSL_DEBUG_BUF( 4, \"IV used\", ssl->transform_in->iv_dec,\n                                         ssl->transform_in->ivlen );\n            SSL_DEBUG_BUF( 4, \"TAG used\", dec_msg + dec_msglen, 16 );\n\n            memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,\n                    ssl->in_msg,\n                    ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen );\n\n            ret = gcm_auth_decrypt( (gcm_context *) ssl->transform_in->ctx_dec,\n                                     dec_msglen,\n                                     ssl->transform_in->iv_dec,\n                                     ssl->transform_in->ivlen,\n                                     add_data, 13,\n                                     dec_msg + dec_msglen, 16,\n                                     dec_msg, dec_msg_result );\n            \n            if( ret != 0 )\n            {\n                SSL_DEBUG_MSG( 1, ( \"AEAD decrypt failed on validation (ret = -0x%02x)\",\n                                    -ret ) );\n\n                return( POLARSSL_ERR_SSL_INVALID_MAC );\n            }\n        } else\n#endif\n        return( ret );\n    }\n    else\n    {\n        /*\n         * Decrypt and check the padding\n         */\n        unsigned char *dec_msg;\n        unsigned char *dec_msg_result;\n        size_t dec_msglen;\n        size_t minlen = 0;\n\n        /*\n         * Check immediate ciphertext sanity\n         */\n        if( ssl->in_msglen % ssl->transform_in->ivlen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) %% ivlen (%d) != 0\",\n                           ssl->in_msglen, ssl->transform_in->ivlen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_2 )\n            minlen += ssl->transform_in->ivlen;\n\n        if( ssl->in_msglen < minlen + ssl->transform_in->ivlen ||\n            ssl->in_msglen < minlen + ssl->transform_in->maclen + 1 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) < max( ivlen(%d), maclen (%d) + 1 ) ( + expl IV )\",\n                           ssl->in_msglen, ssl->transform_in->ivlen, ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n\n        dec_msglen = ssl->in_msglen;\n        dec_msg = ssl->in_msg;\n        dec_msg_result = ssl->in_msg;\n\n        /*\n         * Initialize for prepended IV for block cipher in TLS v1.1 and up\n         */\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_2 )\n        {\n            dec_msg += ssl->transform_in->ivlen;\n            dec_msglen -= ssl->transform_in->ivlen;\n            ssl->in_msglen -= ssl->transform_in->ivlen;\n\n            for( i = 0; i < ssl->transform_in->ivlen; i++ )\n                ssl->transform_in->iv_dec[i] = ssl->in_msg[i];\n        }\n\n        switch( ssl->transform_in->ivlen )\n        {\n#if defined(POLARSSL_DES_C)\n            case  8:\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n                if( ssl->session_in->ciphersuite == TLS_RSA_WITH_DES_CBC_SHA ||\n                    ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_DES_CBC_SHA )\n                {\n                    des_crypt_cbc( (des_context *) ssl->transform_in->ctx_dec,\n                                   DES_DECRYPT, dec_msglen,\n                                   ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                }\n                else\n#endif\n                    des3_crypt_cbc( (des3_context *) ssl->transform_in->ctx_dec,\n                        DES_DECRYPT, dec_msglen,\n                        ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                break;\n#endif\n\n            case 16:\n#if defined(POLARSSL_AES_C)\n        if ( ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 )\n        {\n                    aes_crypt_cbc( (aes_context *) ssl->transform_in->ctx_dec,\n                       AES_DECRYPT, dec_msglen,\n                       ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                    break;\n        }\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        if ( ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 )\n        {\n                    camellia_crypt_cbc( (camellia_context *) ssl->transform_in->ctx_dec,\n                       CAMELLIA_DECRYPT, dec_msglen,\n                       ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                    break;\n        }\n#endif\n\n            default:\n                return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n\n        padlen = 1 + ssl->in_msg[ssl->in_msglen - 1];\n\n        if( ssl->in_msglen < ssl->transform_in->maclen + padlen )\n        {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) < maclen (%d) + padlen (%d)\",\n                        ssl->in_msglen, ssl->transform_in->maclen, padlen ) );\n#endif\n            padlen = 0;\n            correct = 0;\n        }\n\n        if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n        {\n            if( padlen > ssl->transform_in->ivlen )\n            {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n                SSL_DEBUG_MSG( 1, ( \"bad padding length: is %d, \"\n                                    \"should be no more than %d\",\n                               padlen, ssl->transform_in->ivlen ) );\n#endif\n                correct = 0;\n            }\n        }\n        else\n        {\n            /*\n             * TLSv1+: always check the padding up to the first failure\n             * and fake check up to 256 bytes of padding\n             */\n            size_t pad_count = 0, fake_pad_count = 0;\n            size_t padding_idx = ssl->in_msglen - padlen - 1;\n\n            for( i = 1; i <= padlen; i++ )\n                pad_count += ( ssl->in_msg[padding_idx + i] == padlen - 1 );\n\n            for( ; i <= 256; i++ )\n                fake_pad_count += ( ssl->in_msg[padding_idx + i] == padlen - 1 );\n\n            correct &= ( pad_count == padlen ); /* Only 1 on correct padding */\n            correct &= ( pad_count + fake_pad_count < 512 ); /* Always 1 */\n\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            if( padlen > 0 && correct == 0)\n                SSL_DEBUG_MSG( 1, ( \"bad padding byte detected\" ) );\n#endif\n            padlen &= correct * 0x1FF;\n        }\n    }\n\n    SSL_DEBUG_BUF( 4, \"raw buffer after decryption\",\n                   ssl->in_msg, ssl->in_msglen );\n\n    /*\n     * Always compute the MAC (RFC4346, CBCTIME).\n     */\n    ssl->in_msglen -= ( ssl->transform_in->maclen + padlen );\n\n    ssl->in_hdr[3] = (unsigned char)( ssl->in_msglen >> 8 );\n    ssl->in_hdr[4] = (unsigned char)( ssl->in_msglen      );\n\n    memcpy( tmp, ssl->in_msg + ssl->in_msglen, ssl->transform_in->maclen );\n\n    if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->transform_in->maclen == 16 )\n             ssl_mac_md5( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen == 20 )\n            ssl_mac_sha1( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen == 32 )\n            ssl_mac_sha2( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n    else\n    {\n        /*\n         * Process MAC and always update for padlen afterwards to make\n         * total time independent of padlen\n         *\n         * extra_run compensates MAC check for padlen \n         *\n         * Known timing attacks:\n         *  - Lucky Thirteen (http://www.isg.rhul.ac.uk/tls/TLStiming.pdf)\n         *\n         * We use ( ( Lx + 8 ) / 64 ) to handle 'negative Lx' values\n         * correctly. (We round down instead of up, so -56 is the correct\n         * value for our calculations instead of -55)\n         */\n        int j, extra_run = 0;\n        extra_run = ( 13 + ssl->in_msglen + padlen + 8 ) / 64 -\n                    ( 13 + ssl->in_msglen          + 8 ) / 64;\n\n        extra_run &= correct * 0xFF;\n\n        if( ssl->transform_in->maclen == 16 )\n        {\n            md5_context ctx;\n            md5_hmac_starts( &ctx, ssl->transform_in->mac_dec, 16 );\n            md5_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            md5_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                md5_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen == 20 )\n        {\n            sha1_context ctx;\n            sha1_hmac_starts( &ctx, ssl->transform_in->mac_dec, 20 );\n            sha1_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            sha1_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                sha1_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen == 32 )\n        {\n            sha2_context ctx;\n            sha2_hmac_starts( &ctx, ssl->transform_in->mac_dec, 32, 0 );\n            sha2_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            sha2_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                sha2_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    SSL_DEBUG_BUF( 4, \"message  mac\", tmp, ssl->transform_in->maclen );\n    SSL_DEBUG_BUF( 4, \"computed mac\", ssl->in_msg + ssl->in_msglen,\n                   ssl->transform_in->maclen );\n\n    if( memcmp( tmp, ssl->in_msg + ssl->in_msglen,\n                     ssl->transform_in->maclen ) != 0 )\n    {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n        SSL_DEBUG_MSG( 1, ( \"message mac does not match\" ) );\n#endif\n        correct = 0;\n    }\n\n    /*\n     * Finally check the correct flag\n     */\n    if( correct == 0 )\n        return( POLARSSL_ERR_SSL_INVALID_MAC );\n\n    if( ssl->in_msglen == 0 )\n    {\n        ssl->nb_zero++;\n\n        /*\n         * Three or more empty messages may be a DoS attack\n         * (excessive CPU consumption).\n         */\n        if( ssl->nb_zero > 3 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"received four consecutive empty \"\n                                \"messages, possible DoS attack\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n    }\n    else\n        ssl->nb_zero = 0;\n            \n    for( i = 8; i > 0; i-- )\n        if( ++ssl->in_ctr[i - 1] != 0 )\n            break;\n\n    SSL_DEBUG_MSG( 2, ( \"<= decrypt buf\" ) );\n\n    return( 0 );\n}\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n/*\n * Compression/decompression functions\n */\nstatic int ssl_compress_buf( ssl_context *ssl )\n{\n    int ret;\n    unsigned char *msg_post = ssl->out_msg;\n    size_t len_pre = ssl->out_msglen;\n    unsigned char *msg_pre;\n\n    SSL_DEBUG_MSG( 2, ( \"=> compress buf\" ) );\n\n    msg_pre = (unsigned char*) malloc( len_pre );\n    if( msg_pre == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len_pre ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memcpy( msg_pre, ssl->out_msg, len_pre );\n\n    SSL_DEBUG_MSG( 3, ( \"before compression: msglen = %d, \",\n                   ssl->out_msglen ) );\n\n    SSL_DEBUG_BUF( 4, \"before compression: output payload\",\n                   ssl->out_msg, ssl->out_msglen );\n\n    ssl->transform_out->ctx_deflate.next_in = msg_pre;\n    ssl->transform_out->ctx_deflate.avail_in = len_pre;\n    ssl->transform_out->ctx_deflate.next_out = msg_post;\n    ssl->transform_out->ctx_deflate.avail_out = SSL_BUFFER_LEN;\n\n    ret = deflate( &ssl->transform_out->ctx_deflate, Z_SYNC_FLUSH );\n    if( ret != Z_OK )\n    {\n        SSL_DEBUG_MSG( 1, ( \"failed to perform compression (%d)\", ret ) );\n        return( POLARSSL_ERR_SSL_COMPRESSION_FAILED );\n    }\n\n    ssl->out_msglen = SSL_BUFFER_LEN - ssl->transform_out->ctx_deflate.avail_out;\n\n    free( msg_pre );\n\n    SSL_DEBUG_MSG( 3, ( \"after compression: msglen = %d, \",\n                   ssl->out_msglen ) );\n\n    SSL_DEBUG_BUF( 4, \"after compression: output payload\",\n                   ssl->out_msg, ssl->out_msglen );\n\n    SSL_DEBUG_MSG( 2, ( \"<= compress buf\" ) );\n\n    return( 0 );\n}\n\nstatic int ssl_decompress_buf( ssl_context *ssl )\n{\n    int ret;\n    unsigned char *msg_post = ssl->in_msg;\n    size_t len_pre = ssl->in_msglen;\n    unsigned char *msg_pre;\n\n    SSL_DEBUG_MSG( 2, ( \"=> decompress buf\" ) );\n\n    msg_pre = (unsigned char*) malloc( len_pre );\n    if( msg_pre == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len_pre ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memcpy( msg_pre, ssl->in_msg, len_pre );\n\n    SSL_DEBUG_MSG( 3, ( \"before decompression: msglen = %d, \",\n                   ssl->in_msglen ) );\n\n    SSL_DEBUG_BUF( 4, \"before decompression: input payload\",\n                   ssl->in_msg, ssl->in_msglen );\n\n    ssl->transform_in->ctx_inflate.next_in = msg_pre;\n    ssl->transform_in->ctx_inflate.avail_in = len_pre;\n    ssl->transform_in->ctx_inflate.next_out = msg_post;\n    ssl->transform_in->ctx_inflate.avail_out = SSL_MAX_CONTENT_LEN;\n\n    ret = inflate( &ssl->transform_in->ctx_inflate, Z_SYNC_FLUSH );\n    if( ret != Z_OK )\n    {\n        SSL_DEBUG_MSG( 1, ( \"failed to perform decompression (%d)\", ret ) );\n        return( POLARSSL_ERR_SSL_COMPRESSION_FAILED );\n    }\n\n    ssl->in_msglen = SSL_MAX_CONTENT_LEN - ssl->transform_in->ctx_inflate.avail_out;\n\n    free( msg_pre );\n\n    SSL_DEBUG_MSG( 3, ( \"after decompression: msglen = %d, \",\n                   ssl->in_msglen ) );\n\n    SSL_DEBUG_BUF( 4, \"after decompression: input payload\",\n                   ssl->in_msg, ssl->in_msglen );\n\n    SSL_DEBUG_MSG( 2, ( \"<= decompress buf\" ) );\n\n    return( 0 );\n}\n#endif /* POLARSSL_ZLIB_SUPPORT */\n\n/*\n * Fill the input message buffer\n */\nint ssl_fetch_input( ssl_context *ssl, size_t nb_want )\n{\n    int ret;\n    size_t len;\n\n    SSL_DEBUG_MSG( 2, ( \"=> fetch input\" ) );\n\n    while( ssl->in_left < nb_want )\n    {\n        len = nb_want - ssl->in_left;\n        ret = ssl->f_recv( ssl->p_recv, ssl->in_hdr + ssl->in_left, len );\n\n        SSL_DEBUG_MSG( 2, ( \"in_left: %d, nb_want: %d\",\n                       ssl->in_left, nb_want ) );\n        SSL_DEBUG_RET( 2, \"ssl->f_recv\", ret );\n\n        if( ret == 0 )\n            return( POLARSSL_ERR_SSL_CONN_EOF );\n\n        if( ret < 0 )\n            return( ret );\n\n        ssl->in_left += ret;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= fetch input\" ) );\n\n    return( 0 );\n}\n\n/*\n * Flush any data not yet written\n */\nint ssl_flush_output( ssl_context *ssl )\n{\n    int ret;\n    unsigned char *buf;\n\n    SSL_DEBUG_MSG( 2, ( \"=> flush output\" ) );\n\n    while( ssl->out_left > 0 )\n    {\n        SSL_DEBUG_MSG( 2, ( \"message length: %d, out_left: %d\",\n                       5 + ssl->out_msglen, ssl->out_left ) );\n\n        if( ssl->out_msglen < ssl->out_left )\n        {\n            size_t header_left = ssl->out_left - ssl->out_msglen;\n\n            buf = ssl->out_hdr + 5 - header_left;\n            ret = ssl->f_send( ssl->p_send, buf, header_left );\n            \n            SSL_DEBUG_RET( 2, \"ssl->f_send (header)\", ret );\n\n            if( ret <= 0 )\n                return( ret );\n\n            ssl->out_left -= ret;\n        }\n        \n        buf = ssl->out_msg + ssl->out_msglen - ssl->out_left;\n        ret = ssl->f_send( ssl->p_send, buf, ssl->out_left );\n\n        SSL_DEBUG_RET( 2, \"ssl->f_send\", ret );\n\n        if( ret <= 0 )\n            return( ret );\n\n        ssl->out_left -= ret;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= flush output\" ) );\n\n    return( 0 );\n}\n\n/*\n * Record layer functions\n */\nint ssl_write_record( ssl_context *ssl )\n{\n    int ret, done = 0;\n    size_t len = ssl->out_msglen;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write record\" ) );\n\n    if( ssl->out_msgtype == SSL_MSG_HANDSHAKE )\n    {\n        ssl->out_msg[1] = (unsigned char)( ( len - 4 ) >> 16 );\n        ssl->out_msg[2] = (unsigned char)( ( len - 4 ) >>  8 );\n        ssl->out_msg[3] = (unsigned char)( ( len - 4 )       );\n\n        ssl->handshake->update_checksum( ssl, ssl->out_msg, len );\n    }\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    if( ssl->transform_out != NULL &&\n        ssl->session_out->compression == SSL_COMPRESS_DEFLATE )\n    {\n        if( ( ret = ssl_compress_buf( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_compress_buf\", ret );\n            return( ret );\n        }\n\n        len = ssl->out_msglen;\n    }\n#endif /*POLARSSL_ZLIB_SUPPORT */\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_write != NULL)\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_write()\" ) );\n\n        ret = ssl_hw_record_write( ssl );\n        if( ret != 0 && ret != POLARSSL_ERR_SSL_HW_ACCEL_FALLTHROUGH )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_write\", ret );\n            return POLARSSL_ERR_SSL_HW_ACCEL_FAILED;\n        }\n        done = 1;\n    }\n#endif\n    if( !done )\n    {\n        ssl->out_hdr[0] = (unsigned char) ssl->out_msgtype;\n        ssl->out_hdr[1] = (unsigned char) ssl->major_ver;\n        ssl->out_hdr[2] = (unsigned char) ssl->minor_ver;\n        ssl->out_hdr[3] = (unsigned char)( len >> 8 );\n        ssl->out_hdr[4] = (unsigned char)( len      );\n\n        if( ssl->transform_out != NULL )\n        {\n            if( ( ret = ssl_encrypt_buf( ssl ) ) != 0 )\n            {\n                SSL_DEBUG_RET( 1, \"ssl_encrypt_buf\", ret );\n                return( ret );\n            }\n\n            len = ssl->out_msglen;\n            ssl->out_hdr[3] = (unsigned char)( len >> 8 );\n            ssl->out_hdr[4] = (unsigned char)( len      );\n        }\n\n        ssl->out_left = 5 + ssl->out_msglen;\n\n        SSL_DEBUG_MSG( 3, ( \"output record: msgtype = %d, \"\n                            \"version = [%d:%d], msglen = %d\",\n                       ssl->out_hdr[0], ssl->out_hdr[1], ssl->out_hdr[2],\n                     ( ssl->out_hdr[3] << 8 ) | ssl->out_hdr[4] ) );\n\n        SSL_DEBUG_BUF( 4, \"output record header sent to network\",\n                       ssl->out_hdr, 5 );\n        SSL_DEBUG_BUF( 4, \"output record sent to network\",\n                       ssl->out_hdr + 32, ssl->out_msglen );\n    }\n\n    if( ( ret = ssl_flush_output( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_flush_output\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write record\" ) );\n\n    return( 0 );\n}\n\nint ssl_read_record( ssl_context *ssl )\n{\n    int ret, done = 0;\n\n    SSL_DEBUG_MSG( 2, ( \"=> read record\" ) );\n\n    if( ssl->in_hslen != 0 &&\n        ssl->in_hslen < ssl->in_msglen )\n    {\n        /*\n         * Get next Handshake message in the current record\n         */\n        ssl->in_msglen -= ssl->in_hslen;\n\n        memmove( ssl->in_msg, ssl->in_msg + ssl->in_hslen,\n                 ssl->in_msglen );\n\n        ssl->in_hslen  = 4;\n        ssl->in_hslen += ( ssl->in_msg[2] << 8 ) | ssl->in_msg[3];\n\n        SSL_DEBUG_MSG( 3, ( \"handshake message: msglen =\"\n                            \" %d, type = %d, hslen = %d\",\n                       ssl->in_msglen, ssl->in_msg[0], ssl->in_hslen ) );\n\n        if( ssl->in_msglen < 4 || ssl->in_msg[1] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad handshake length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl->in_msglen < ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad handshake length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );\n\n        return( 0 );\n    }\n\n    ssl->in_hslen = 0;\n\n    /*\n     * Read the record header and validate it\n     */\n    if( ( ret = ssl_fetch_input( ssl, 5 ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_fetch_input\", ret );\n        return( ret );\n    }\n\n    ssl->in_msgtype =  ssl->in_hdr[0];\n    ssl->in_msglen = ( ssl->in_hdr[3] << 8 ) | ssl->in_hdr[4];\n\n    SSL_DEBUG_MSG( 3, ( \"input record: msgtype = %d, \"\n                        \"version = [%d:%d], msglen = %d\",\n                     ssl->in_hdr[0], ssl->in_hdr[1], ssl->in_hdr[2],\n                   ( ssl->in_hdr[3] << 8 ) | ssl->in_hdr[4] ) );\n\n    if( ssl->in_hdr[1] != ssl->major_ver )\n    {\n        SSL_DEBUG_MSG( 1, ( \"major version mismatch\" ) );\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    if( ssl->in_hdr[2] > ssl->max_minor_ver )\n    {\n        SSL_DEBUG_MSG( 1, ( \"minor version mismatch\" ) );\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    /*\n     * Make sure the message length is acceptable\n     */\n    if( ssl->transform_in == NULL )\n    {\n        if( ssl->in_msglen < 1 ||\n            ssl->in_msglen > SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n    }\n    else\n    {\n        if( ssl->in_msglen < ssl->transform_in->minlen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl->minor_ver == SSL_MINOR_VERSION_0 &&\n            ssl->in_msglen > ssl->transform_in->minlen + SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        /*\n         * TLS encrypted messages can have up to 256 bytes of padding\n         */\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_1 &&\n            ssl->in_msglen > ssl->transform_in->minlen + SSL_MAX_CONTENT_LEN + 256 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n    }\n\n    /*\n     * Read and optionally decrypt the message contents\n     */\n    if( ( ret = ssl_fetch_input( ssl, 5 + ssl->in_msglen ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_fetch_input\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_BUF( 4, \"input record from network\",\n                   ssl->in_hdr, 5 + ssl->in_msglen );\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_read != NULL)\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_read()\" ) );\n\n        ret = ssl_hw_record_read( ssl );\n        if( ret != 0 && ret != POLARSSL_ERR_SSL_HW_ACCEL_FALLTHROUGH )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_read\", ret );\n            return POLARSSL_ERR_SSL_HW_ACCEL_FAILED;\n        }\n        done = 1;\n    }\n#endif\n    if( !done && ssl->transform_in != NULL )\n    {\n        if( ( ret = ssl_decrypt_buf( ssl ) ) != 0 )\n        {\n#if defined(POLARSSL_SSL_ALERT_MESSAGES)\n            if( ret == POLARSSL_ERR_SSL_INVALID_MAC )\n            {\n                ssl_send_alert_message( ssl,\n                                        SSL_ALERT_LEVEL_FATAL,\n                                        SSL_ALERT_MSG_BAD_RECORD_MAC );\n            }\n#endif\n            SSL_DEBUG_RET( 1, \"ssl_decrypt_buf\", ret );\n            return( ret );\n        }\n\n        SSL_DEBUG_BUF( 4, \"input payload after decrypt\",\n                       ssl->in_msg, ssl->in_msglen );\n\n        if( ssl->in_msglen > SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n    }\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    if( ssl->transform_in != NULL &&\n        ssl->session_in->compression == SSL_COMPRESS_DEFLATE )\n    {\n        if( ( ret = ssl_decompress_buf( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_decompress_buf\", ret );\n            return( ret );\n        }\n\n        ssl->in_hdr[3] = (unsigned char)( ssl->in_msglen >> 8 );\n        ssl->in_hdr[4] = (unsigned char)( ssl->in_msglen      );\n    }\n#endif /* POLARSSL_ZLIB_SUPPORT */\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE &&\n        ssl->in_msgtype != SSL_MSG_ALERT &&\n        ssl->in_msgtype != SSL_MSG_CHANGE_CIPHER_SPEC &&\n        ssl->in_msgtype != SSL_MSG_APPLICATION_DATA )\n    {\n        SSL_DEBUG_MSG( 1, ( \"unknown record type\" ) );\n\n        if( ( ret = ssl_send_alert_message( ssl,\n                        SSL_ALERT_LEVEL_FATAL,\n                        SSL_ALERT_MSG_UNEXPECTED_MESSAGE ) ) != 0 )\n        {\n            return( ret );\n        }\n\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    if( ssl->in_msgtype == SSL_MSG_HANDSHAKE )\n    {\n        ssl->in_hslen  = 4;\n        ssl->in_hslen += ( ssl->in_msg[2] << 8 ) | ssl->in_msg[3];\n\n        SSL_DEBUG_MSG( 3, ( \"handshake message: msglen =\"\n                            \" %d, type = %d, hslen = %d\",\n                       ssl->in_msglen, ssl->in_msg[0], ssl->in_hslen ) );\n\n        /*\n         * Additional checks to validate the handshake header\n         */\n        if( ssl->in_msglen < 4 || ssl->in_msg[1] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad handshake length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl->in_msglen < ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad handshake length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl->state != SSL_HANDSHAKE_OVER )\n            ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );\n    }\n\n    if( ssl->in_msgtype == SSL_MSG_ALERT )\n    {\n        SSL_DEBUG_MSG( 2, ( \"got an alert message, type: [%d:%d]\",\n                       ssl->in_msg[0], ssl->in_msg[1] ) );\n\n        /*\n         * Ignore non-fatal alerts, except close_notify\n         */\n        if( ssl->in_msg[0] == SSL_ALERT_LEVEL_FATAL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"is a fatal alert message (msg %d)\",\n                           ssl->in_msg[1] ) );\n            /**\n             * Subtract from error code as ssl->in_msg[1] is 7-bit positive\n             * error identifier.\n             */\n            return( POLARSSL_ERR_SSL_FATAL_ALERT_MESSAGE );\n        }\n\n        if( ssl->in_msg[0] == SSL_ALERT_LEVEL_WARNING &&\n            ssl->in_msg[1] == SSL_ALERT_MSG_CLOSE_NOTIFY )\n        {\n            SSL_DEBUG_MSG( 2, ( \"is a close notify message\" ) );\n            return( POLARSSL_ERR_SSL_PEER_CLOSE_NOTIFY );\n        }\n    }\n\n    ssl->in_left = 0;\n\n    SSL_DEBUG_MSG( 2, ( \"<= read record\" ) );\n\n    return( 0 );\n}\n\nint ssl_send_fatal_handshake_failure( ssl_context *ssl )\n{\n    int ret;\n\n    if( ( ret = ssl_send_alert_message( ssl,\n                    SSL_ALERT_LEVEL_FATAL,\n                    SSL_ALERT_MSG_HANDSHAKE_FAILURE ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    return( 0 );\n}\n\nint ssl_send_alert_message( ssl_context *ssl,\n                            unsigned char level,\n                            unsigned char message )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> send alert message\" ) );\n\n    ssl->out_msgtype = SSL_MSG_ALERT;\n    ssl->out_msglen = 2;\n    ssl->out_msg[0] = level;\n    ssl->out_msg[1] = message;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= send alert message\" ) );\n\n    return( 0 );\n}\n\n/*\n * Handshake functions\n */\nint ssl_write_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n    const x509_cert *crt;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write certificate\" ) );\n\n    if( ssl->endpoint == SSL_IS_CLIENT )\n    {\n        if( ssl->client_auth == 0 )\n        {\n            SSL_DEBUG_MSG( 2, ( \"<= skip write certificate\" ) );\n            ssl->state++;\n            return( 0 );\n        }\n\n        /*\n         * If using SSLv3 and got no cert, send an Alert message\n         * (otherwise an empty Certificate message will be sent).\n         */\n        if( ssl->own_cert  == NULL &&\n            ssl->minor_ver == SSL_MINOR_VERSION_0 )\n        {\n            ssl->out_msglen  = 2;\n            ssl->out_msgtype = SSL_MSG_ALERT;\n            ssl->out_msg[0]  = SSL_ALERT_LEVEL_WARNING;\n            ssl->out_msg[1]  = SSL_ALERT_MSG_NO_CERT;\n\n            SSL_DEBUG_MSG( 2, ( \"got no certificate to send\" ) );\n            goto write_msg;\n        }\n    }\n    else /* SSL_IS_SERVER */\n    {\n        if( ssl->own_cert == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"got no certificate to send\" ) );\n            return( POLARSSL_ERR_SSL_CERTIFICATE_REQUIRED );\n        }\n    }\n\n    SSL_DEBUG_CRT( 3, \"own certificate\", ssl->own_cert );\n\n    /*\n     *     0  .  0    handshake type\n     *     1  .  3    handshake length\n     *     4  .  6    length of all certs\n     *     7  .  9    length of cert. 1\n     *    10  . n-1   peer certificate\n     *     n  . n+2   length of cert. 2\n     *    n+3 . ...   upper level cert, etc.\n     */\n    i = 7;\n    crt = ssl->own_cert;\n\n    while( crt != NULL )\n    {\n        n = crt->raw.len;\n        if( i + 3 + n > SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"certificate too large, %d > %d\",\n                           i + 3 + n, SSL_MAX_CONTENT_LEN ) );\n            return( POLARSSL_ERR_SSL_CERTIFICATE_TOO_LARGE );\n        }\n\n        ssl->out_msg[i    ] = (unsigned char)( n >> 16 );\n        ssl->out_msg[i + 1] = (unsigned char)( n >>  8 );\n        ssl->out_msg[i + 2] = (unsigned char)( n       );\n\n        i += 3; memcpy( ssl->out_msg + i, crt->raw.p, n );\n        i += n; crt = crt->next;\n    }\n\n    ssl->out_msg[4]  = (unsigned char)( ( i - 7 ) >> 16 );\n    ssl->out_msg[5]  = (unsigned char)( ( i - 7 ) >>  8 );\n    ssl->out_msg[6]  = (unsigned char)( ( i - 7 )       );\n\n    ssl->out_msglen  = i;\n    ssl->out_msgtype = SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = SSL_HS_CERTIFICATE;\n\nwrite_msg:\n\n    ssl->state++;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write certificate\" ) );\n\n    return( 0 );\n}\n\nint ssl_parse_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse certificate\" ) );\n\n    if( ssl->endpoint == SSL_IS_SERVER &&\n        ssl->authmode == SSL_VERIFY_NONE )\n    {\n        ssl->verify_result = BADCERT_SKIP_VERIFY;\n        SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_msglen  == 2                        &&\n            ssl->in_msgtype == SSL_MSG_ALERT            &&\n            ssl->in_msg[0]  == SSL_ALERT_LEVEL_WARNING  &&\n            ssl->in_msg[1]  == SSL_ALERT_MSG_NO_CERT )\n        {\n            SSL_DEBUG_MSG( 1, ( \"SSLv3 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_OPTIONAL )\n                return( 0 );\n            else\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver != SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_hslen   == 7                    &&\n            ssl->in_msgtype == SSL_MSG_HANDSHAKE    &&\n            ssl->in_msg[0]  == SSL_HS_CERTIFICATE   &&\n            memcmp( ssl->in_msg + 4, \"\\0\\0\\0\", 3 ) == 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"TLSv1 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_REQUIRED )\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n            else\n                return( 0 );\n        }\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msg[0] != SSL_HS_CERTIFICATE || ssl->in_hslen < 10 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /*\n     * Same message structure as in ssl_write_certificate()\n     */\n    n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];\n\n    if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    if( ( ssl->session_negotiate->peer_cert = (x509_cert *) malloc(\n                    sizeof( x509_cert ) ) ) == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\",\n                       sizeof( x509_cert ) ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->session_negotiate->peer_cert, 0, sizeof( x509_cert ) );\n\n    i = 7;\n\n    while( i < ssl->in_hslen )\n    {\n        if( ssl->in_msg[i] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt_der( ssl->session_negotiate->peer_cert,\n                                 ssl->in_msg + i, n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );\n\n    if( ssl->authmode != SSL_VERIFY_NONE )\n    {\n        if( ssl->ca_chain == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"got no CA chain\" ) );\n            return( POLARSSL_ERR_SSL_CA_CHAIN_REQUIRED );\n        }\n\n        ret = x509parse_verify( ssl->session_negotiate->peer_cert,\n                                ssl->ca_chain, ssl->ca_crl,\n                                ssl->peer_cn,  &ssl->verify_result,\n                                ssl->f_vrfy, ssl->p_vrfy );\n\n        if( ret != 0 )\n            SSL_DEBUG_RET( 1, \"x509_verify_cert\", ret );\n\n        if( ssl->authmode != SSL_VERIFY_REQUIRED )\n            ret = 0;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse certificate\" ) );\n\n    return( ret );\n}\n\nint ssl_write_change_cipher_spec( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write change cipher spec\" ) );\n\n    ssl->out_msgtype = SSL_MSG_CHANGE_CIPHER_SPEC;\n    ssl->out_msglen  = 1;\n    ssl->out_msg[0]  = 1;\n\n    ssl->state++;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write change cipher spec\" ) );\n\n    return( 0 );\n}\n\nint ssl_parse_change_cipher_spec( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse change cipher spec\" ) );\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_CHANGE_CIPHER_SPEC )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad change cipher spec message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msglen != 1 || ssl->in_msg[0] != 1 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad change cipher spec message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC );\n    }\n\n    ssl->state++;\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse change cipher spec\" ) );\n\n    return( 0 );\n}\n\nvoid ssl_optimize_checksum( ssl_context *ssl, int ciphersuite )\n{\n#if !defined(POLARSSL_SHA4_C)\n    ((void) ciphersuite);\n#endif\n\n    if( ssl->minor_ver < SSL_MINOR_VERSION_3 )\n        ssl->handshake->update_checksum = ssl_update_checksum_md5sha1;\n#if defined(POLARSSL_SHA4_C)\n    else if ( ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n              ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n    {\n        ssl->handshake->update_checksum = ssl_update_checksum_sha384;\n    }\n#endif\n    else\n        ssl->handshake->update_checksum = ssl_update_checksum_sha256;\n}\n    \nstatic void ssl_update_checksum_start( ssl_context *ssl, unsigned char *buf,\n                                       size_t len )\n{\n     md5_update( &ssl->handshake->fin_md5 , buf, len );\n    sha1_update( &ssl->handshake->fin_sha1, buf, len );\n    sha2_update( &ssl->handshake->fin_sha2, buf, len );\n#if defined(POLARSSL_SHA4_C)\n    sha4_update( &ssl->handshake->fin_sha4, buf, len );\n#endif\n}\n\nstatic void ssl_update_checksum_md5sha1( ssl_context *ssl, unsigned char *buf,\n                                         size_t len )\n{\n     md5_update( &ssl->handshake->fin_md5 , buf, len );\n    sha1_update( &ssl->handshake->fin_sha1, buf, len );\n}\n\nstatic void ssl_update_checksum_sha256( ssl_context *ssl, unsigned char *buf,\n                                        size_t len )\n{\n    sha2_update( &ssl->handshake->fin_sha2, buf, len );\n}\n\n#if defined(POLARSSL_SHA4_C)\nstatic void ssl_update_checksum_sha384( ssl_context *ssl, unsigned char *buf,\n                                        size_t len )\n{\n    sha4_update( &ssl->handshake->fin_sha4, buf, len );\n}\n#endif\n\nstatic void ssl_calc_finished_ssl(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    const char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n\n    unsigned char padbuf[48];\n    unsigned char md5sum[16];\n    unsigned char sha1sum[20];\n\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished ssl\" ) );\n\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n\n    /*\n     * SSLv3:\n     *   hash =\n     *      MD5( master + pad2 +\n     *          MD5( handshake + sender + master + pad1 ) )\n     *   + SHA1( master + pad2 +\n     *         SHA1( handshake + sender + master + pad1 ) )\n     */\n\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n\n    sender = ( from == SSL_IS_CLIENT ) ? \"CLNT\"\n                                       : \"SRVR\";\n\n    memset( padbuf, 0x36, 48 );\n\n    md5_update( &md5, (const unsigned char *) sender, 4 );\n    md5_update( &md5, session->master, 48 );\n    md5_update( &md5, padbuf, 48 );\n    md5_finish( &md5, md5sum );\n\n    sha1_update( &sha1, (const unsigned char *) sender, 4 );\n    sha1_update( &sha1, session->master, 48 );\n    sha1_update( &sha1, padbuf, 40 );\n    sha1_finish( &sha1, sha1sum );\n\n    memset( padbuf, 0x5C, 48 );\n\n    md5_starts( &md5 );\n    md5_update( &md5, session->master, 48 );\n    md5_update( &md5, padbuf, 48 );\n    md5_update( &md5, md5sum, 16 );\n    md5_finish( &md5, buf );\n\n    sha1_starts( &sha1 );\n    sha1_update( &sha1, session->master, 48 );\n    sha1_update( &sha1, padbuf , 40 );\n    sha1_update( &sha1, sha1sum, 20 );\n    sha1_finish( &sha1, buf + 16 );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, 36 );\n\n    memset(  &md5, 0, sizeof(  md5_context ) );\n    memset( &sha1, 0, sizeof( sha1_context ) );\n\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n    memset(  md5sum, 0, sizeof(  md5sum ) );\n    memset( sha1sum, 0, sizeof( sha1sum ) );\n\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}\n\nstatic void ssl_calc_finished_tls(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    const char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n    unsigned char padbuf[36];\n\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls\" ) );\n\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n\n    /*\n     * TLSv1:\n     *   hash = PRF( master, finished_label,\n     *               MD5( handshake ) + SHA1( handshake ) )[0..11]\n     */\n\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n\n    sender = ( from == SSL_IS_CLIENT )\n             ? \"client finished\"\n             : \"server finished\";\n\n    md5_finish(  &md5, padbuf );\n    sha1_finish( &sha1, padbuf + 16 );\n\n    ssl->handshake->tls_prf( session->master, 48, (char *) sender,\n                             padbuf, 36, buf, len );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n\n    memset(  &md5, 0, sizeof(  md5_context ) );\n    memset( &sha1, 0, sizeof( sha1_context ) );\n\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}\n\nstatic void ssl_calc_finished_tls_sha256(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    const char *sender;\n    sha2_context sha2;\n    unsigned char padbuf[32];\n\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls sha256\" ) );\n\n    memcpy( &sha2, &ssl->handshake->fin_sha2, sizeof(sha2_context) );\n\n    /*\n     * TLSv1.2:\n     *   hash = PRF( master, finished_label,\n     *               Hash( handshake ) )[0.11]\n     */\n\n    SSL_DEBUG_BUF( 4, \"finished sha2 state\", (unsigned char *)\n                   sha2.state, sizeof( sha2.state ) );\n\n    sender = ( from == SSL_IS_CLIENT )\n             ? \"client finished\"\n             : \"server finished\";\n\n    sha2_finish( &sha2, padbuf );\n\n    ssl->handshake->tls_prf( session->master, 48, (char *) sender,\n                             padbuf, 32, buf, len );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n\n    memset( &sha2, 0, sizeof( sha2_context ) );\n\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}\n\n#if defined(POLARSSL_SHA4_C)\nstatic void ssl_calc_finished_tls_sha384(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    const char *sender;\n    sha4_context sha4;\n    unsigned char padbuf[48];\n\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls sha384\" ) );\n\n    memcpy( &sha4, &ssl->handshake->fin_sha4, sizeof(sha4_context) );\n\n    /*\n     * TLSv1.2:\n     *   hash = PRF( master, finished_label,\n     *               Hash( handshake ) )[0.11]\n     */\n\n    SSL_DEBUG_BUF( 4, \"finished sha4 state\", (unsigned char *)\n                   sha4.state, sizeof( sha4.state ) );\n\n    sender = ( from == SSL_IS_CLIENT )\n             ? \"client finished\"\n             : \"server finished\";\n\n    sha4_finish( &sha4, padbuf );\n\n    ssl->handshake->tls_prf( session->master, 48, (char *) sender,\n                             padbuf, 48, buf, len );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n\n    memset( &sha4, 0, sizeof( sha4_context ) );\n\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}\n#endif\n\nvoid ssl_handshake_wrapup( ssl_context *ssl )\n{\n    SSL_DEBUG_MSG( 3, ( \"=> handshake wrapup\" ) );\n\n    /*\n     * Free our handshake params\n     */\n    ssl_handshake_free( ssl->handshake );\n    free( ssl->handshake );\n    ssl->handshake = NULL;\n\n    /*\n     * Switch in our now active transform context\n     */\n    if( ssl->transform )\n    {\n        ssl_transform_free( ssl->transform );\n        free( ssl->transform );\n    }\n    ssl->transform = ssl->transform_negotiate;\n    ssl->transform_negotiate = NULL;\n\n    if( ssl->session )\n    {\n        ssl_session_free( ssl->session );\n        free( ssl->session );\n    }\n    ssl->session = ssl->session_negotiate;\n    ssl->session_negotiate = NULL;\n\n    /*\n     * Add cache entry\n     */\n    if( ssl->f_set_cache != NULL )\n        if( ssl->f_set_cache( ssl->p_set_cache, ssl->session ) != 0 )\n            SSL_DEBUG_MSG( 1, ( \"cache did not store session\" ) );\n\n    ssl->state++;\n\n    SSL_DEBUG_MSG( 3, ( \"<= handshake wrapup\" ) );\n}\n\nint ssl_write_finished( ssl_context *ssl )\n{\n    int ret, hash_len;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write finished\" ) );\n\n    ssl->handshake->calc_finished( ssl, ssl->out_msg + 4, ssl->endpoint );\n\n    // TODO TLS/1.2 Hash length is determined by cipher suite (Page 63)\n    hash_len = ( ssl->minor_ver == SSL_MINOR_VERSION_0 ) ? 36 : 12;\n\n    ssl->verify_data_len = hash_len;\n    memcpy( ssl->own_verify_data, ssl->out_msg + 4, hash_len );\n\n    ssl->out_msglen  = 4 + hash_len;\n    ssl->out_msgtype = SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = SSL_HS_FINISHED;\n\n    /*\n     * In case of session resuming, invert the client and server\n     * ChangeCipherSpec messages order.\n     */\n    if( ssl->handshake->resume != 0 )\n    {\n        if( ssl->endpoint == SSL_IS_CLIENT )\n            ssl->state = SSL_HANDSHAKE_WRAPUP;\n        else\n            ssl->state = SSL_CLIENT_CHANGE_CIPHER_SPEC;\n    }\n    else\n        ssl->state++;\n\n    /*\n     * Switch to our negotiated transform and session parameters for outbound data.\n     */\n    SSL_DEBUG_MSG( 3, ( \"switching to new transform spec for outbound data\" ) );\n    ssl->transform_out = ssl->transform_negotiate;\n    ssl->session_out = ssl->session_negotiate;\n    memset( ssl->out_ctr, 0, 8 );\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write finished\" ) );\n\n    return( 0 );\n}\n\nint ssl_parse_finished( ssl_context *ssl )\n{\n    int ret;\n    unsigned int hash_len;\n    unsigned char buf[36];\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse finished\" ) );\n\n    ssl->handshake->calc_finished( ssl, buf, ssl->endpoint ^ 1 );\n\n    /*\n     * Switch to our negotiated transform and session parameters for inbound data.\n     */\n    SSL_DEBUG_MSG( 3, ( \"switching to new transform spec for inbound data\" ) );\n    ssl->transform_in = ssl->transform_negotiate;\n    ssl->session_in = ssl->session_negotiate;\n    memset( ssl->in_ctr, 0, 8 );\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    // TODO TLS/1.2 Hash length is determined by cipher suite (Page 63)\n    hash_len = ( ssl->minor_ver == SSL_MINOR_VERSION_0 ) ? 36 : 12;\n\n    if( ssl->in_msg[0] != SSL_HS_FINISHED ||\n        ssl->in_hslen  != 4 + hash_len )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_FINISHED );\n    }\n\n    if( memcmp( ssl->in_msg + 4, buf, hash_len ) != 0 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_FINISHED );\n    }\n\n    ssl->verify_data_len = hash_len;\n    memcpy( ssl->peer_verify_data, buf, hash_len );\n\n    if( ssl->handshake->resume != 0 )\n    {\n        if( ssl->endpoint == SSL_IS_CLIENT )\n            ssl->state = SSL_CLIENT_CHANGE_CIPHER_SPEC;\n\n        if( ssl->endpoint == SSL_IS_SERVER )\n            ssl->state = SSL_HANDSHAKE_WRAPUP;\n    }\n    else\n        ssl->state++;\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse finished\" ) );\n\n    return( 0 );\n}\n\nint ssl_handshake_init( ssl_context *ssl )\n{\n    if( ssl->transform_negotiate )\n        ssl_transform_free( ssl->transform_negotiate );\n    else\n        ssl->transform_negotiate = malloc( sizeof(ssl_transform) );\n\n    if( ssl->session_negotiate )\n        ssl_session_free( ssl->session_negotiate );\n    else\n        ssl->session_negotiate = malloc( sizeof(ssl_session) );\n\n    if( ssl->handshake )\n        ssl_handshake_free( ssl->handshake );\n    else\n        ssl->handshake = malloc( sizeof(ssl_handshake_params) );\n\n    if( ssl->handshake == NULL ||\n        ssl->transform_negotiate == NULL ||\n        ssl->session_negotiate == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc() of ssl sub-contexts failed\" ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->handshake, 0, sizeof(ssl_handshake_params) );\n    memset( ssl->transform_negotiate, 0, sizeof(ssl_transform) );\n    memset( ssl->session_negotiate, 0, sizeof(ssl_session) );\n\n     md5_starts( &ssl->handshake->fin_md5 );\n    sha1_starts( &ssl->handshake->fin_sha1 );\n    sha2_starts( &ssl->handshake->fin_sha2, 0 );\n#if defined(POLARSSL_SHA4_C)\n    sha4_starts( &ssl->handshake->fin_sha4, 1 );\n#endif\n\n    ssl->handshake->update_checksum = ssl_update_checksum_start;\n    ssl->handshake->sig_alg = SSL_HASH_SHA1;\n    \n    return( 0 );\n}\n\n/*\n * Initialize an SSL context\n */\nint ssl_init( ssl_context *ssl )\n{\n    int ret;\n    int len = SSL_BUFFER_LEN;\n\n    memset( ssl, 0, sizeof( ssl_context ) );\n\n    /*\n     * Sane defaults\n     */\n    ssl->rsa_decrypt = ssl_rsa_decrypt;\n    ssl->rsa_sign = ssl_rsa_sign;\n    ssl->rsa_key_len = ssl_rsa_key_len;\n\n    ssl->min_major_ver = SSL_MAJOR_VERSION_3;\n    ssl->min_minor_ver = SSL_MINOR_VERSION_0;\n\n    ssl->ciphersuites = malloc( sizeof(int *) * 4 );\n    ssl_set_ciphersuites( ssl, ssl_default_ciphersuites );\n\n#if defined(POLARSSL_DHM_C)\n    if( ( ret = mpi_read_string( &ssl->dhm_P, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_P) ) != 0 ||\n        ( ret = mpi_read_string( &ssl->dhm_G, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_G) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n#endif\n\n    /*\n     * Prepare base structures\n     */\n    ssl->in_ctr = (unsigned char *) malloc( len );\n    ssl->in_hdr = ssl->in_ctr +  8;\n    ssl->in_msg = ssl->in_ctr + 13;\n\n    if( ssl->in_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    ssl->out_ctr = (unsigned char *) malloc( len );\n    ssl->out_hdr = ssl->out_ctr +  8;\n    ssl->out_msg = ssl->out_ctr + 40;\n\n    if( ssl->out_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        free( ssl-> in_ctr );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl-> in_ctr, 0, SSL_BUFFER_LEN );\n    memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n\n    ssl->hostname = NULL;\n    ssl->hostname_len = 0;\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\n/*\n * Reset an initialized and used SSL context for re-use while retaining\n * all application-set variables, function pointers and data.\n */\nint ssl_session_reset( ssl_context *ssl )\n{\n    int ret;\n\n    ssl->state = SSL_HELLO_REQUEST;\n    ssl->renegotiation = SSL_INITIAL_HANDSHAKE;\n    ssl->secure_renegotiation = SSL_LEGACY_RENEGOTIATION;\n\n    ssl->verify_data_len = 0;\n    memset( ssl->own_verify_data, 0, 36 );\n    memset( ssl->peer_verify_data, 0, 36 );\n\n    ssl->in_offt = NULL;\n\n    ssl->in_msgtype = 0;\n    ssl->in_msglen = 0;\n    ssl->in_left = 0;\n\n    ssl->in_hslen = 0;\n    ssl->nb_zero = 0;\n\n    ssl->out_msgtype = 0;\n    ssl->out_msglen = 0;\n    ssl->out_left = 0;\n\n    ssl->transform_in = NULL;\n    ssl->transform_out = NULL;\n\n    memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n    memset( ssl->in_ctr, 0, SSL_BUFFER_LEN );\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_reset != NULL)\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_reset()\" ) );\n        if( ssl_hw_record_reset( ssl ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_reset\", ret );\n            return( POLARSSL_ERR_SSL_HW_ACCEL_FAILED );\n        }\n    }\n#endif\n\n    if( ssl->transform )\n    {\n        ssl_transform_free( ssl->transform );\n        free( ssl->transform );\n        ssl->transform = NULL;\n    }\n\n    if( ssl->session )\n    {\n        ssl_session_free( ssl->session );\n        free( ssl->session );\n        ssl->session = NULL;\n    }\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\n/*\n * SSL set accessors\n */\nvoid ssl_set_endpoint( ssl_context *ssl, int endpoint )\n{\n    ssl->endpoint   = endpoint;\n}\n\nvoid ssl_set_authmode( ssl_context *ssl, int authmode )\n{\n    ssl->authmode   = authmode;\n}\n\nvoid ssl_set_verify( ssl_context *ssl,\n                     int (*f_vrfy)(void *, x509_cert *, int, int *),\n                     void *p_vrfy )\n{\n    ssl->f_vrfy      = f_vrfy;\n    ssl->p_vrfy      = p_vrfy;\n}\n\nvoid ssl_set_rng( ssl_context *ssl,\n                  int (*f_rng)(void *, unsigned char *, size_t),\n                  void *p_rng )\n{\n    ssl->f_rng      = f_rng;\n    ssl->p_rng      = p_rng;\n}\n\nvoid ssl_set_dbg( ssl_context *ssl,\n                  void (*f_dbg)(void *, int, const char *),\n                  void  *p_dbg )\n{\n    ssl->f_dbg      = f_dbg;\n    ssl->p_dbg      = p_dbg;\n}\n\nvoid ssl_set_bio( ssl_context *ssl,\n            int (*f_recv)(void *, unsigned char *, size_t), void *p_recv,\n            int (*f_send)(void *, const unsigned char *, size_t), void *p_send )\n{\n    ssl->f_recv     = f_recv;\n    ssl->f_send     = f_send;\n    ssl->p_recv     = p_recv;\n    ssl->p_send     = p_send;\n}\n\nvoid ssl_set_session_cache( ssl_context *ssl,\n        int (*f_get_cache)(void *, ssl_session *), void *p_get_cache,\n        int (*f_set_cache)(void *, const ssl_session *), void *p_set_cache )\n{\n    ssl->f_get_cache = f_get_cache;\n    ssl->p_get_cache = p_get_cache;\n    ssl->f_set_cache = f_set_cache;\n    ssl->p_set_cache = p_set_cache;\n}\n\nvoid ssl_set_session( ssl_context *ssl, const ssl_session *session )\n{\n    memcpy( ssl->session_negotiate, session, sizeof(ssl_session) );\n    ssl->handshake->resume = 1;\n}\n\nvoid ssl_set_ciphersuites( ssl_context *ssl, const int *ciphersuites )\n{\n    ssl->ciphersuites[SSL_MINOR_VERSION_0] = ciphersuites;\n    ssl->ciphersuites[SSL_MINOR_VERSION_1] = ciphersuites;\n    ssl->ciphersuites[SSL_MINOR_VERSION_2] = ciphersuites;\n    ssl->ciphersuites[SSL_MINOR_VERSION_3] = ciphersuites;\n}\n\nvoid ssl_set_ciphersuites_for_version( ssl_context *ssl, const int *ciphersuites,\n                                       int major, int minor )\n{\n    if( major != SSL_MAJOR_VERSION_3 )\n        return;\n\n    if( minor < SSL_MINOR_VERSION_0 || minor > SSL_MINOR_VERSION_3 )\n        return;\n\n    ssl->ciphersuites[minor] = ciphersuites;\n}\n\nvoid ssl_set_ca_chain( ssl_context *ssl, x509_cert *ca_chain,\n                       x509_crl *ca_crl, const char *peer_cn )\n{\n    ssl->ca_chain   = ca_chain;\n    ssl->ca_crl     = ca_crl;\n    ssl->peer_cn    = peer_cn;\n}\n\nvoid ssl_set_own_cert( ssl_context *ssl, x509_cert *own_cert,\n                       rsa_context *rsa_key )\n{\n    ssl->own_cert   = own_cert;\n    ssl->rsa_key    = rsa_key;\n}\n\nvoid ssl_set_own_cert_alt( ssl_context *ssl, x509_cert *own_cert,\n                           void *rsa_key,\n                           rsa_decrypt_func rsa_decrypt,\n                           rsa_sign_func rsa_sign,\n                           rsa_key_len_func rsa_key_len )\n{\n    ssl->own_cert   = own_cert;\n    ssl->rsa_key    = rsa_key;\n    ssl->rsa_decrypt = rsa_decrypt;\n    ssl->rsa_sign = rsa_sign;\n    ssl->rsa_key_len = rsa_key_len;\n}\n\n\n#if defined(POLARSSL_DHM_C)\nint ssl_set_dh_param( ssl_context *ssl, const char *dhm_P, const char *dhm_G )\n{\n    int ret;\n\n    if( ( ret = mpi_read_string( &ssl->dhm_P, 16, dhm_P ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n\n    if( ( ret = mpi_read_string( &ssl->dhm_G, 16, dhm_G ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n\n    return( 0 );\n}\n\nint ssl_set_dh_param_ctx( ssl_context *ssl, dhm_context *dhm_ctx )\n{\n    int ret;\n\n    if( ( ret = mpi_copy(&ssl->dhm_P, &dhm_ctx->P) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_copy\", ret );\n        return( ret );\n    }\n\n    if( ( ret = mpi_copy(&ssl->dhm_G, &dhm_ctx->G) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_copy\", ret );\n        return( ret );\n    }\n\n    return( 0 );\n}\n#endif /* POLARSSL_DHM_C */\n\nint ssl_set_hostname( ssl_context *ssl, const char *hostname )\n{\n    if( hostname == NULL )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    ssl->hostname_len = strlen( hostname );\n    ssl->hostname = (unsigned char *) malloc( ssl->hostname_len + 1 );\n\n    if( ssl->hostname == NULL )\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n\n    memcpy( ssl->hostname, (const unsigned char *) hostname,\n            ssl->hostname_len );\n    \n    ssl->hostname[ssl->hostname_len] = '\\0';\n\n    return( 0 );\n}\n\nvoid ssl_set_sni( ssl_context *ssl,\n                  int (*f_sni)(void *, ssl_context *,\n                                const unsigned char *, size_t),\n                  void *p_sni )\n{\n    ssl->f_sni = f_sni;\n    ssl->p_sni = p_sni;\n}\n\nvoid ssl_set_max_version( ssl_context *ssl, int major, int minor )\n{\n    ssl->max_major_ver = major;\n    ssl->max_minor_ver = minor;\n}\n\nvoid ssl_set_min_version( ssl_context *ssl, int major, int minor )\n{\n    ssl->min_major_ver = major;\n    ssl->min_minor_ver = minor;\n}\n\nvoid ssl_set_renegotiation( ssl_context *ssl, int renegotiation )\n{\n    ssl->disable_renegotiation = renegotiation;\n}\n\nvoid ssl_legacy_renegotiation( ssl_context *ssl, int allow_legacy )\n{\n    ssl->allow_legacy_renegotiation = allow_legacy;\n}\n\n/*\n * SSL get accessors\n */\nsize_t ssl_get_bytes_avail( const ssl_context *ssl )\n{\n    return( ssl->in_offt == NULL ? 0 : ssl->in_msglen );\n}\n\nint ssl_get_verify_result( const ssl_context *ssl )\n{\n    return( ssl->verify_result );\n}\n\nconst char *ssl_get_ciphersuite_name( const int ciphersuite_id )\n{\n    switch( ciphersuite_id )\n    {\n#if defined(POLARSSL_ARC4_C)\n        case TLS_RSA_WITH_RC4_128_MD5:\n            return( \"TLS-RSA-WITH-RC4-128-MD5\" );\n\n        case TLS_RSA_WITH_RC4_128_SHA:\n            return( \"TLS-RSA-WITH-RC4-128-SHA\" );\n#endif\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_3DES_EDE_CBC_SHA:\n            return( \"TLS-RSA-WITH-3DES-EDE-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA\" );\n#endif\n\n#if defined(POLARSSL_AES_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA:\n            return( \"TLS-RSA-WITH-AES-128-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-AES-128-CBC-SHA\" );\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA:\n            return( \"TLS-RSA-WITH-AES-256-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-AES-256-CBC-SHA\" );\n\n#if defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_AES_128_CBC_SHA256:\n            return( \"TLS-RSA-WITH-AES-128-CBC-SHA256\" );\n\n        case TLS_RSA_WITH_AES_256_CBC_SHA256:\n            return( \"TLS-RSA-WITH-AES-256-CBC-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:\n            return( \"TLS-DHE-RSA-WITH-AES-128-CBC-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:\n            return( \"TLS-DHE-RSA-WITH-AES-256-CBC-SHA256\" );\n#endif\n\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_AES_128_GCM_SHA256:\n            return( \"TLS-RSA-WITH-AES-128-GCM-SHA256\" );\n\n        case TLS_RSA_WITH_AES_256_GCM_SHA384:\n            return( \"TLS-RSA-WITH-AES-256-GCM-SHA384\" );\n#endif\n\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA4_C)\n        case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:\n            return( \"TLS-DHE-RSA-WITH-AES-128-GCM-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:\n            return( \"TLS-DHE-RSA-WITH-AES-256-GCM-SHA384\" );\n#endif\n#endif /* POLARSSL_AES_C */\n\n#if defined(POLARSSL_CAMELLIA_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:\n            return( \"TLS-RSA-WITH-CAMELLIA-128-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA\" );\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:\n            return( \"TLS-RSA-WITH-CAMELLIA-256-CBC-SHA\" );\n\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA\" );\n\n#if defined(POLARSSL_SHA2_C)\n        case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n            return( \"TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:\n            return( \"TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256\" );\n\n        case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n            return( \"TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256\" );\n\n        case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:\n            return( \"TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256\" );\n#endif\n#endif\n\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        case TLS_RSA_WITH_NULL_MD5:\n            return( \"TLS-RSA-WITH-NULL-MD5\" );\n        case TLS_RSA_WITH_NULL_SHA:\n            return( \"TLS-RSA-WITH-NULL-SHA\" );\n        case TLS_RSA_WITH_NULL_SHA256:\n            return( \"TLS-RSA-WITH-NULL-SHA256\" );\n#endif /* defined(POLARSSL_CIPHER_NULL_CIPHER) */\n\n#if defined(POLARSSL_DES_C)\n        case TLS_RSA_WITH_DES_CBC_SHA:\n            return( \"TLS-RSA-WITH-DES-CBC-SHA\" );\n        case TLS_DHE_RSA_WITH_DES_CBC_SHA:\n            return( \"TLS-DHE-RSA-WITH-DES-CBC-SHA\" );\n#endif\n#endif /* defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES) */\n\n    default:\n        break;\n    }\n\n    return( \"unknown\" );\n}\n\nint ssl_get_ciphersuite_id( const char *ciphersuite_name )\n{\n#if defined(POLARSSL_ARC4_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-RC4-128-MD5\"))\n        return( TLS_RSA_WITH_RC4_128_MD5 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-RC4-128-SHA\"))\n        return( TLS_RSA_WITH_RC4_128_SHA );\n#endif\n\n#if defined(POLARSSL_DES_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-3DES-EDE-CBC-SHA\"))\n        return( TLS_RSA_WITH_3DES_EDE_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA );\n#endif\n\n#if defined(POLARSSL_AES_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-128-CBC-SHA\"))\n        return( TLS_RSA_WITH_AES_128_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-128-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_AES_128_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-256-CBC-SHA\"))\n        return( TLS_RSA_WITH_AES_256_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-256-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_AES_256_CBC_SHA );\n\n#if defined(POLARSSL_SHA2_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-128-CBC-SHA256\"))\n        return( TLS_RSA_WITH_AES_128_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-256-CBC-SHA256\"))\n        return( TLS_RSA_WITH_AES_256_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-128-CBC-SHA256\"))\n        return( TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-256-CBC-SHA256\"))\n        return( TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 );\n#endif\n\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-128-GCM-SHA256\"))\n        return( TLS_RSA_WITH_AES_128_GCM_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-AES-256-GCM-SHA384\"))\n        return( TLS_RSA_WITH_AES_256_GCM_SHA384 );\n#endif\n\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-128-GCM-SHA256\"))\n        return( TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-AES-256-GCM-SHA384\"))\n        return( TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 );\n#endif\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-CAMELLIA-128-CBC-SHA\"))\n        return( TLS_RSA_WITH_CAMELLIA_128_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-CAMELLIA-256-CBC-SHA\"))\n        return( TLS_RSA_WITH_CAMELLIA_256_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA );\n\n#if defined(POLARSSL_SHA2_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256\"))\n        return( TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256\"))\n        return( TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256\"))\n        return( TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256\"))\n        return( TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 );\n#endif\n#endif\n\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-NULL-MD5\"))\n        return( TLS_RSA_WITH_NULL_MD5 );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-NULL-SHA\"))\n        return( TLS_RSA_WITH_NULL_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-NULL-SHA256\"))\n        return( TLS_RSA_WITH_NULL_SHA256 );\n#endif /* defined(POLARSSL_CIPHER_NULL_CIPHER) */\n\n#if defined(POLARSSL_DES_C)\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-RSA-WITH-DES-CBC-SHA\"))\n        return( TLS_RSA_WITH_DES_CBC_SHA );\n    if (0 == strcasecmp(ciphersuite_name, \"TLS-DHE-RSA-WITH-DES-CBC-SHA\"))\n        return( TLS_DHE_RSA_WITH_DES_CBC_SHA );\n#endif\n#endif /* defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES) */\n\n    return( 0 );\n}\n\nconst char *ssl_get_ciphersuite( const ssl_context *ssl )\n{\n    if( ssl == NULL || ssl->session == NULL )\n        return NULL;\n\n    return ssl_get_ciphersuite_name( ssl->session->ciphersuite );\n}\n\nconst char *ssl_get_version( const ssl_context *ssl )\n{\n    switch( ssl->minor_ver )\n    {\n        case SSL_MINOR_VERSION_0:\n            return( \"SSLv3.0\" );\n\n        case SSL_MINOR_VERSION_1:\n            return( \"TLSv1.0\" );\n\n        case SSL_MINOR_VERSION_2:\n            return( \"TLSv1.1\" );\n\n        case SSL_MINOR_VERSION_3:\n            return( \"TLSv1.2\" );\n\n        default:\n            break;\n    }\n    return( \"unknown\" );\n}\n\nconst x509_cert *ssl_get_peer_cert( const ssl_context *ssl )\n{\n    if( ssl == NULL || ssl->session == NULL )\n        return NULL;\n\n    return ssl->session->peer_cert;\n}\n\nconst int ssl_default_ciphersuites[] =\n{\n#if defined(POLARSSL_DHM_C)\n#if defined(POLARSSL_AES_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA4_C)\n    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,\n#endif\n    TLS_DHE_RSA_WITH_AES_256_CBC_SHA,\n#if defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,\n#endif\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,\n#endif\n    TLS_DHE_RSA_WITH_AES_128_CBC_SHA,\n#endif\n#if defined(POLARSSL_CAMELLIA_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,\n#if defined(POLARSSL_SHA2_C)\n    TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,\n#endif\n#if defined(POLARSSL_DES_C)\n    TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA,\n#endif\n#endif\n\n#if defined(POLARSSL_AES_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_AES_256_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA4_C)\n    TLS_RSA_WITH_AES_256_GCM_SHA384,\n#endif /* POLARSSL_SHA2_C */\n    TLS_RSA_WITH_AES_256_CBC_SHA,\n#endif\n#if defined(POLARSSL_CAMELLIA_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,\n#endif\n#if defined(POLARSSL_AES_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_AES_128_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n#if defined(POLARSSL_GCM_C) && defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_AES_128_GCM_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_RSA_WITH_AES_128_CBC_SHA,\n#endif\n#if defined(POLARSSL_CAMELLIA_C)\n#if defined(POLARSSL_SHA2_C)\n    TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256,\n#endif /* POLARSSL_SHA2_C */\n    TLS_RSA_WITH_CAMELLIA_128_CBC_SHA,\n#endif\n#if defined(POLARSSL_DES_C)\n    TLS_RSA_WITH_3DES_EDE_CBC_SHA,\n#endif\n#if defined(POLARSSL_ARC4_C)\n    TLS_RSA_WITH_RC4_128_SHA,\n    TLS_RSA_WITH_RC4_128_MD5,\n#endif\n    0\n};\n\n/*\n * Perform a single step of the SSL handshake\n */\nint ssl_handshake_step( ssl_context *ssl )\n{\n    int ret = POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE;\n\n#if defined(POLARSSL_SSL_CLI_C)\n    if( ssl->endpoint == SSL_IS_CLIENT )\n        ret = ssl_handshake_client_step( ssl );\n#endif\n\n#if defined(POLARSSL_SSL_SRV_C)\n    if( ssl->endpoint == SSL_IS_SERVER )\n        ret = ssl_handshake_server_step( ssl );\n#endif\n\n    return( ret );\n}\n\n/*\n * Perform the SSL handshake\n */\nint ssl_handshake( ssl_context *ssl )\n{\n    int ret = 0;\n\n    SSL_DEBUG_MSG( 2, ( \"=> handshake\" ) );\n\n    while( ssl->state != SSL_HANDSHAKE_OVER )\n    {\n        ret = ssl_handshake_step( ssl );\n\n        if( ret != 0 )\n            break;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= handshake\" ) );\n\n    return( ret );\n}\n\n/*\n * Renegotiate current connection\n */\nint ssl_renegotiate( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> renegotiate\" ) );\n\n    if( ssl->state != SSL_HANDSHAKE_OVER )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    ssl->state = SSL_HELLO_REQUEST;\n    ssl->renegotiation = SSL_RENEGOTIATION;\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n\n    if( ( ret = ssl_handshake( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_handshake\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= renegotiate\" ) );\n\n    return( 0 );\n}\n\n/*\n * Receive application data decrypted from the SSL layer\n */\nint ssl_read( ssl_context *ssl, unsigned char *buf, size_t len )\n{\n    int ret;\n    size_t n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> read\" ) );\n\n    if( ssl->state != SSL_HANDSHAKE_OVER )\n    {\n        if( ( ret = ssl_handshake( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_handshake\", ret );\n            return( ret );\n        }\n    }\n\n    if( ssl->in_offt == NULL )\n    {\n        if( ( ret = ssl_read_record( ssl ) ) != 0 )\n        {\n            if( ret == POLARSSL_ERR_SSL_CONN_EOF )\n                return( 0 );\n\n            SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n            return( ret );\n        }\n\n        if( ssl->in_msglen  == 0 &&\n            ssl->in_msgtype == SSL_MSG_APPLICATION_DATA )\n        {\n            /*\n             * OpenSSL sends empty messages to randomize the IV\n             */\n            if( ( ret = ssl_read_record( ssl ) ) != 0 )\n            {\n                if( ret == POLARSSL_ERR_SSL_CONN_EOF )\n                    return( 0 );\n\n                SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n                return( ret );\n            }\n        }\n\n        if( ssl->in_msgtype == SSL_MSG_HANDSHAKE )\n        {\n            SSL_DEBUG_MSG( 1, ( \"received handshake message\" ) );\n\n            if( ssl->endpoint == SSL_IS_CLIENT &&\n                ( ssl->in_msg[0] != SSL_HS_HELLO_REQUEST ||\n                  ssl->in_hslen != 4 ) )\n            {\n                SSL_DEBUG_MSG( 1, ( \"handshake received (not HelloRequest)\" ) );\n                return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n            }\n\n            if( ssl->disable_renegotiation == SSL_RENEGOTIATION_DISABLED ||\n                ( ssl->secure_renegotiation == SSL_LEGACY_RENEGOTIATION &&\n                  ssl->allow_legacy_renegotiation == SSL_LEGACY_NO_RENEGOTIATION ) )\n            {\n                SSL_DEBUG_MSG( 3, ( \"ignoring renegotiation, sending alert\" ) );\n\n                if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n                {\n                    /*\n                     * SSLv3 does not have a \"no_renegotiation\" alert\n                     */\n                    if( ( ret = ssl_send_fatal_handshake_failure( ssl ) ) != 0 )\n                        return( ret );\n                }\n                else\n                {\n                    if( ( ret = ssl_send_alert_message( ssl,\n                                    SSL_ALERT_LEVEL_WARNING,\n                                    SSL_ALERT_MSG_NO_RENEGOTIATION ) ) != 0 )\n                    {\n                        return( ret );\n                    }\n                }\n            }\n            else\n            {\n                if( ( ret = ssl_renegotiate( ssl ) ) != 0 )\n                {\n                    SSL_DEBUG_RET( 1, \"ssl_renegotiate\", ret );\n                    return( ret );\n                }\n\n                return( POLARSSL_ERR_NET_WANT_READ );\n            }\n        }\n        else if( ssl->in_msgtype != SSL_MSG_APPLICATION_DATA )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad application data message\" ) );\n            return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        ssl->in_offt = ssl->in_msg;\n    }\n\n    n = ( len < ssl->in_msglen )\n        ? len : ssl->in_msglen;\n\n    memcpy( buf, ssl->in_offt, n );\n    ssl->in_msglen -= n;\n\n    if( ssl->in_msglen == 0 )\n        /* all bytes consumed  */\n        ssl->in_offt = NULL;\n    else\n        /* more data available */\n        ssl->in_offt += n;\n\n    SSL_DEBUG_MSG( 2, ( \"<= read\" ) );\n\n    return( (int) n );\n}\n\n/*\n * Send application data to be encrypted by the SSL layer\n */\nint ssl_write( ssl_context *ssl, const unsigned char *buf, size_t len )\n{\n    int ret;\n    size_t n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write\" ) );\n\n    if( ssl->state != SSL_HANDSHAKE_OVER )\n    {\n        if( ( ret = ssl_handshake( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_handshake\", ret );\n            return( ret );\n        }\n    }\n\n    n = ( len < SSL_MAX_CONTENT_LEN )\n        ? len : SSL_MAX_CONTENT_LEN;\n\n    if( ssl->out_left != 0 )\n    {\n        if( ( ret = ssl_flush_output( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_flush_output\", ret );\n            return( ret );\n        }\n    }\n    else\n    {\n        ssl->out_msglen  = n;\n        ssl->out_msgtype = SSL_MSG_APPLICATION_DATA;\n        memcpy( ssl->out_msg, buf, n );\n\n        if( ( ret = ssl_write_record( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n            return( ret );\n        }\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write\" ) );\n\n    return( (int) n );\n}\n\n/*\n * Notify the peer that the connection is being closed\n */\nint ssl_close_notify( ssl_context *ssl )\n{\n    int ret;\n\n    SSL_DEBUG_MSG( 2, ( \"=> write close notify\" ) );\n\n    if( ( ret = ssl_flush_output( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_flush_output\", ret );\n        return( ret );\n    }\n\n    if( ssl->state == SSL_HANDSHAKE_OVER )\n    {\n        if( ( ret = ssl_send_alert_message( ssl,\n                        SSL_ALERT_LEVEL_WARNING,\n                        SSL_ALERT_MSG_CLOSE_NOTIFY ) ) != 0 )\n        {\n            return( ret );\n        }\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= write close notify\" ) );\n\n    return( ret );\n}\n\nvoid ssl_transform_free( ssl_transform *transform )\n{\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    deflateEnd( &transform->ctx_deflate );\n    inflateEnd( &transform->ctx_inflate );\n#endif\n\n    memset( transform, 0, sizeof( ssl_transform ) );\n}\n\nvoid ssl_handshake_free( ssl_handshake_params *handshake )\n{\n#if defined(POLARSSL_DHM_C)\n    dhm_free( &handshake->dhm_ctx );\n#endif\n    memset( handshake, 0, sizeof( ssl_handshake_params ) );\n}\n\nvoid ssl_session_free( ssl_session *session )\n{\n    if( session->peer_cert != NULL )\n    {\n        x509_free( session->peer_cert );\n        free( session->peer_cert );\n    }\n\n    memset( session, 0, sizeof( ssl_session ) );\n}\n\n/*\n * Free an SSL context\n */\nvoid ssl_free( ssl_context *ssl )\n{\n    SSL_DEBUG_MSG( 2, ( \"=> free\" ) );\n\n    free( ssl->ciphersuites );\n\n    if( ssl->out_ctr != NULL )\n    {\n        memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n          free( ssl->out_ctr );\n    }\n\n    if( ssl->in_ctr != NULL )\n    {\n        memset( ssl->in_ctr, 0, SSL_BUFFER_LEN );\n          free( ssl->in_ctr );\n    }\n\n#if defined(POLARSSL_DHM_C)\n    mpi_free( &ssl->dhm_P );\n    mpi_free( &ssl->dhm_G );\n#endif\n\n    if( ssl->transform )\n    {\n        ssl_transform_free( ssl->transform );\n        free( ssl->transform );\n    }\n\n    if( ssl->handshake )\n    {\n        ssl_handshake_free( ssl->handshake );\n        ssl_transform_free( ssl->transform_negotiate );\n        ssl_session_free( ssl->session_negotiate );\n\n        free( ssl->handshake );\n        free( ssl->transform_negotiate );\n        free( ssl->session_negotiate );\n    }\n\n    if( ssl->session )\n    {\n        ssl_session_free( ssl->session );\n        free( ssl->session );\n    }\n\n    if ( ssl->hostname != NULL)\n    {\n        memset( ssl->hostname, 0, ssl->hostname_len );\n        free( ssl->hostname );\n        ssl->hostname_len = 0;\n    }\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_finish != NULL )\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_finish()\" ) );\n        ssl_hw_record_finish( ssl );\n    }\n#endif\n\n    SSL_DEBUG_MSG( 2, ( \"<= free\" ) );\n\n    /* Actually clear after last debug message */\n    memset( ssl, 0, sizeof( ssl_context ) );\n}\n\n#endif\n"], "filenames": ["ChangeLog", "include/polarssl/x509.h", "library/ssl_tls.c"], "buggy_code_start_loc": [12, 427, 2378], "buggy_code_end_loc": [12, 427, 2380], "fixing_code_start_loc": [13, 428, 2378], "fixing_code_end_loc": [16, 440, 2380], "type": "CWE-20", "message": "The x509parse_crt function in x509.h in PolarSSL 1.1.x before 1.1.7 and 1.2.x before 1.2.8 does not properly parse certificate messages during the SSL/TLS handshake, which allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a certificate message that contains a PEM encoded certificate.", "other": {"cve": {"id": "CVE-2013-4623", "sourceIdentifier": "cve@mitre.org", "published": "2013-09-30T22:55:04.930", "lastModified": "2013-10-31T03:35:02.657", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The x509parse_crt function in x509.h in PolarSSL 1.1.x before 1.1.7 and 1.2.x before 1.2.8 does not properly parse certificate messages during the SSL/TLS handshake, which allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a certificate message that contains a PEM encoded certificate."}, {"lang": "es", "value": "La funci\u00f3n x509parse_crt en x509.h de PolarSSL 1.1.x (anteriores a 1.1.7) y 1.2.x (anteriores a 1.2.8) no procesa apropiadamente los mensajes de certificado durante un handshake SSL/TLS, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicio (bucle infinito y consumo de CPU) a trav\u00e9s de un mensaje de certificado que contiene un certificado codificado en PEM."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "18BC3056-6CF9-4C6A-9F03-C8812CA10AF1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "02CE9326-279B-4CFE-8FBD-4450793D9C67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "7513F8AC-A847-412D-B657-9426E4C6C020"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "88CE920F-DBD6-4D01-87E1-26FA10101692"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "C6F1E192-D0F2-476E-A7A9-AFB031687533"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "2F9DDE3F-26AE-41E0-9433-E5C018C699E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "40F9819E-798E-4DA6-A7E4-39A85B68A5F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "E9001635-AA9C-4165-B021-2B296CF6DE1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "1D105753-A704-4BF4-BD7A-99985911B943"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8CF482DF-9F5C-45D6-AA5E-D9163A710AAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "F5152886-DFBB-415C-99E0-A7E645A5F86B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "C5BD989E-FC1D-44D2-9394-C36AD18325DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "AE349CDB-AE50-4043-86EF-1CED401AAEFC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "48FAB18E-F1C9-46B2-985E-28AC2736DB3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "7C453569-3736-4FC3-87FE-8282A1572CA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "E86CC3C2-C0D0-420A-97FA-1862B9CF2CE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:polarssl:polarssl:1.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "67CE5D3D-FE2C-403E-9A90-43CB04A96CD1"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-September/115922.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-September/115927.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-September/116351.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2013/dsa-2782", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/61764", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=997767", "source": "cve@mitre.org"}, {"url": "https://github.com/polarssl/polarssl/commit/1922a4e6aade7b1d685af19d4d9339ddb5c02859", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://polarssl.org/tech-updates/security-advisories/polarssl-security-advisory-2013-03", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/polarssl/polarssl/commit/1922a4e6aade7b1d685af19d4d9339ddb5c02859"}}