{"buggy_code": ["<?php\n/**\n * ownCloud\n *\n * @author Tom Needham\n * @copyright 2012 Tom Needham tom@owncloud.com\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU AFFERO GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU Affero General Public\n * License along with this library.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\n/**\n * provides an interface to migrate users and whole ownclouds\n */\nclass OC_Migrate{\n\n\n\t// Array of OC_Migration_Provider objects\n\tstatic private $providers=array();\n\t// User id of the user to import/export\n\tstatic private $uid=false;\n\t// Holds the ZipArchive object\n\tstatic private $zip=false;\n\t// Stores the type of export\n\tstatic private $exporttype=false;\n\t// Array of temp files to be deleted after zip creation\n\tstatic private $tmpfiles=array();\n\t// Holds the db object\n\tstatic private $MDB2=false;\n\t// Schema db object\n\tstatic private $schema=false;\n\t// Path to the sqlite db\n\tstatic private $dbpath=false;\n\t// Holds the path to the zip file\n\tstatic private $zippath=false;\n\t// Holds the OC_Migration_Content object\n\tstatic private $content=false;\n\n\t/**\n\t * register a new migration provider\n\t * @param OC_Migrate_Provider $provider\n\t */\n\tpublic static function registerProvider($provider){\n\t\tself::$providers[]=$provider;\n\t}\n\n\t/**\n\t* @brief finds and loads the providers\n\t*/\n\tstatic private function findProviders(){\n\t\t// Find the providers\n\t\t$apps = OC_App::getAllApps();\n\n\t\tforeach($apps as $app){\n\t\t\t$path = OC::$SERVERROOT . '/apps/' . $app . '/appinfo/migrate.php';\n\t\t\tif( file_exists( $path ) ){\n\t\t\t\tinclude( $path );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @brief exports a user, or owncloud instance\n\t * @param optional $uid string user id of user to export if export type is user, defaults to current\n\t * @param ootional $type string type of export, defualts to user\n\t * @param otional $path string path to zip output folder\n\t * @return false on error, path to zip on success\n\t */\n\t public static function export( $uid=null, $type='user', $path=null ){\n\t\t$datadir = OC_Config::getValue( 'datadirectory' );\n\t \t// Validate export type\n\t \t$types = array( 'user', 'instance', 'system', 'userfiles' );\n\t \tif( !in_array( $type, $types ) ){\n\t \t\tOC_Log::write( 'migration', 'Invalid export type', OC_Log::ERROR );\n\t \t\treturn json_encode( array( array( 'success' => false ) ) );\n\t \t}\n\t \tself::$exporttype = $type;\n\t \t// Userid?\n\t \tif( self::$exporttype == 'user' ){\n\t \t\t// Check user exists\n\t \t\tif( !is_null($uid) ){\n                                $db = new OC_User_Database;\n\t\t \t\tif( !$db->userExists( $uid ) ){\n\t\t\t\t\tOC_Log::write('migration', 'User: '.$uid.' is not in the database and so cannot be exported.', OC_Log::ERROR);\n\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t}\n\t\t\t\tself::$uid = $uid;\n\t \t\t} else {\n\t \t\t\tself::$uid = OC_User::getUser();\n\t \t\t}\n\t \t}\n\t \t// Calculate zipname\n\t \tif( self::$exporttype == 'user' ){\n\t \t\t$zipname = 'oc_export_' . self::$uid . '_' . date(\"y-m-d_H-i-s\") . '.zip';\n\t \t} else {\n\t \t\t$zipname = 'oc_export_' . self::$exporttype . '_' . date(\"y-m-d_H-i-s\") . '.zip';\n\t \t}\n\t \t// Calculate path\n\t \tif( self::$exporttype == 'user' ){\n\t \t\tself::$zippath = $datadir . '/' . self::$uid . '/' . $zipname;\n\t \t} else {\n\t \t\tif( !is_null( $path ) ){\n\t \t\t\t// Validate custom path\n\t \t\t\tif( !file_exists( $path ) || !is_writeable( $path ) ){\n\t \t\t\t\tOC_Log::write( 'migration', 'Path supplied is invalid.', OC_Log::ERROR );\n\t \t\t\t\treturn json_encode( array( 'success' => false ) );\n\t \t\t\t}\n\t \t\t\tself::$zippath = $path . $zipname;\n\t \t\t} else {\n\t \t\t\t// Default path\n\t \t\t\tself::$zippath = get_temp_dir() . '/' . $zipname;\n\t \t\t}\n\t \t}\n\t \t// Create the zip object\n\t \tif( !self::createZip() ){\n\t \t\treturn json_encode( array( 'success' => false ) );\n\t \t}\n\t \t// Do the export\n\t \tself::findProviders();\n\t \t$exportdata = array();\n\t \tswitch( self::$exporttype ){\n\t \t\tcase 'user':\n\t \t\t\t// Connect to the db\n\t \t\t\tself::$dbpath = $datadir . '/' . self::$uid . '/migration.db';\n\t \t\t\tif( !self::connectDB() ){\n\t \t\t\t\treturn json_encode( array( 'success' => false ) );\n\t \t\t\t}\n\t \t\t\tself::$content = new OC_Migration_Content( self::$zip, self::$MDB2 );\n\t \t\t\t// Export the app info\n\t\t\t    $exportdata = self::exportAppData();\n\t\t\t\t// Add the data dir to the zip\n\t\t\t\tself::$content->addDir( $datadir . '/' . self::$uid, true, '/' );\n\t \t\tbreak;\n\t \t\tcase 'instance':\n\t \t\t\tself::$content = new OC_Migration_Content( self::$zip );\n\t\t\t\t// Creates a zip that is compatable with the import function\n\t\t\t\t$dbfile = tempnam( get_temp_dir(), \"owncloud_export_data_\" );\n\t\t\t\tOC_DB::getDbStructure( $dbfile, 'MDB2_SCHEMA_DUMP_ALL');\n\n\t\t\t\t// Now add in *dbname* and *dbprefix*\n\t\t\t\t$dbexport = file_get_contents( $dbfile );\n\t\t\t\t$dbnamestring = \"<database>\\n\\n <name>\" . OC_Config::getValue( \"dbname\", \"owncloud\" );\n\t\t\t\t$dbtableprefixstring = \"<table>\\n\\n  <name>\" . OC_Config::getValue( \"dbtableprefix\", \"oc_\" );\n\t\t\t\t$dbexport = str_replace( $dbnamestring, \"<database>\\n\\n <name>*dbname*\", $dbexport );\n\t\t\t\t$dbexport = str_replace( $dbtableprefixstring, \"<table>\\n\\n  <name>*dbprefix*\", $dbexport );\n\t\t\t\t// Add the export to the zip\n\t\t\t\tself::$content->addFromString( $dbexport, \"dbexport.xml\" );\n\t\t\t\t// Add user data\n\t\t\t\tforeach(OC_User::getUsers() as $user){\n\t\t\t\t\tself::$content->addDir( $datadir . '/' . $user . '/', true, \"/userdata/\" );\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'userfiles':\n\t\t\t\tself::$content = new OC_Migration_Content( self::$zip );\n\t\t\t\t// Creates a zip with all of the users files\n\t\t\t\tforeach(OC_User::getUsers() as $user){\n\t\t\t\t\tself::$content->addDir( $datadir . '/' . $user . '/', true, \"/\" );\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'system':\n\t\t\t\tself::$content = new OC_Migration_Content( self::$zip );\n\t\t\t\t// Creates a zip with the owncloud system files\n\t\t\t\tself::$content->addDir( OC::$SERVERROOT . '/', false, '/');\n\t\t\t\tforeach (array(\".git\", \"3rdparty\", \"apps\", \"core\", \"files\", \"l10n\", \"lib\", \"ocs\", \"search\", \"settings\", \"tests\") as $dir) {\n\t\t\t    \tself::$content->addDir( OC::$SERVERROOT . '/' . $dir, true, \"/\");\n\t\t\t\t}\n\t\t\tbreak;\n\t \t}\n\t \tif( !$info = self::getExportInfo( $exportdata ) ){\n\t \t\treturn json_encode( array( 'success' => false ) );\n\t \t}\n\t \t// Add the export info json to the export zip\n\t \tself::$content->addFromString( $info, 'export_info.json' );\n\t \tif( !self::$content->finish() ){\n\t \t\treturn json_encode( array( 'success' => false ) );\n\t \t}\n\t \treturn json_encode( array( 'success' => true, 'data' => self::$zippath ) );\n\t }\n\n\t/**\n\t* @brief imports a user, or owncloud instance\n\t* @param $path string path to zip\n\t* @param optional $type type of import (user or instance)\n\t* @param optional $uid userid of new user\n\t*/\n\tpublic static function import( $path, $type='user', $uid=null ){\n\t\t\n\t\t$datadir = OC_Config::getValue( 'datadirectory' );\n\t\t// Extract the zip\n\t\tif( !$extractpath = self::extractZip( $path ) ){\n\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t}\n\t\t// Get export_info.json\n\t\t$scan = scandir( $extractpath );\n\t\t// Check for export_info.json\n\t\tif( !in_array( 'export_info.json', $scan ) ){\n\t\t\tOC_Log::write( 'migration', 'Invalid import file, export_info.json note found', OC_Log::ERROR );\n\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t}\n\t\t$json = json_decode( file_get_contents( $extractpath . 'export_info.json' ) );\n\t\tif( $json->exporttype != $type ){\n\t\t\tOC_Log::write( 'migration', 'Invalid import file', OC_Log::ERROR );\n\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t}\n\t\tself::$exporttype = $type;\n\n\t\t$currentuser = OC_User::getUser();\n\n\t\t// Have we got a user if type is user\n\t\tif( self::$exporttype == 'user' ){\n\t\t\tself::$uid = !is_null($uid) ? $uid : $currentuser;\n\t\t}\n\t\t\n\t\t// We need to be an admin if we are not importing our own data\n\t\tif(($type == 'user' && self::$uid != $currentuser) || $type != 'user' ){\n\t\t\tif( !OC_Group::inGroup( OC_User::getUser(), 'admin' )){\n\t\t\t\t// Naughty.\n\t\t\t\tOC_Log::write( 'migration', 'Import not permitted.', OC_Log::ERROR );\n\t\t\t\treturn json_encode( array( 'success' => false ) ); \t\n\t\t\t}\n\t\t}\n\n\t\t// Handle export types\n\t\tswitch( self::$exporttype ){\n\t\t\tcase 'user':\n\t\t\t\t// Check user availability\n\t\t\t\tif( !OC_User::userExists( self::$uid ) ){\n\t\t\t\t\tOC_Log::write( 'migration', 'User doesn\\'t exist', OC_Log::ERROR );\n\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t}\n\t\t\t\t// Copy data\n\t\t\t\tif( !self::copy_r( $extractpath . $json->exporteduser, $datadir . '/' . self::$uid ) ){\n\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t}\n\t\t\t\t// Import user app data\n\t\t\t\tif( !$appsimported = self::importAppData( $extractpath . $json->exporteduser . '/migration.db', $json, self::$uid ) ){\n\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t}\n\t\t\t\t// All done!\n\t\t\t\tif( !self::unlink_r( $extractpath ) ){\n\t\t\t\t\tOC_Log::write( 'migration', 'Failed to delete the extracted zip', OC_Log::ERROR );\n\t\t\t\t}\n\t\t\t\treturn json_encode( array( 'success' => true, 'data' => $appsimported ) );\n\t\t\tbreak;\n\t\t\tcase 'instance':\n\t\t\t\t\t/*\n\t\t\t\t\t * EXPERIMENTAL\n\t\t\t\t\t// Check for new data dir and dbexport before doing anything\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Delete current data folder.\n\t\t\t\t\tOC_Log::write( 'migration', \"Deleting current data dir\", OC_Log::INFO );\n\t\t\t\t\tif( !self::unlink_r( $datadir, false ) ){\n\t\t\t\t\t\tOC_Log::write( 'migration', 'Failed to delete the current data dir', OC_Log::ERROR );\n\t\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Copy over data\n\t\t\t\t\tif( !self::copy_r( $extractpath . 'userdata', $datadir ) ){\n\t\t\t\t\t\tOC_Log::write( 'migration', 'Failed to copy over data directory', OC_Log::ERROR );\n\t\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Import the db\n\t\t\t\t\tif( !OC_DB::replaceDB( $extractpath . 'dbexport.xml' ) ){\n\t\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t\t}\n\t\t\t\t\t// Done\n\t\t\t\t\treturn json_encode( 'success' => true );\n\t\t\t\t\t*/\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t/**\n\t* @brief recursively deletes a directory\n\t* @param $dir string path of dir to delete\n\t* $param optional $deleteRootToo bool delete the root directory\n\t* @return bool\n\t*/\n\tprivate static function unlink_r( $dir, $deleteRootToo=true ){\n\t\tif( !$dh = @opendir( $dir ) ){\n\t\t\treturn false;\n\t\t}\n\t\twhile (false !== ($obj = readdir($dh))){\n\t\t\tif($obj == '.' || $obj == '..') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!@unlink($dir . '/' . $obj)){\n\t\t\t\tself::unlink_r($dir.'/'.$obj, true);\n\t\t\t}\n\t\t}\n\t\tclosedir($dh);\n\t\tif ( $deleteRootToo ) {\n\t\t\t@rmdir($dir);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t* @brief copies recursively\n\t* @param $path string path to source folder\n\t* @param $dest string path to destination\n\t* @return bool\n\t*/\n\tprivate static function copy_r( $path, $dest ){\n\t\tif( is_dir($path) ){\n\t\t\t@mkdir( $dest );\n\t\t\t$objects = scandir( $path );\n\t\t\tif( sizeof( $objects ) > 0 ){\n\t\t\t\tforeach( $objects as $file ){\n\t\t\t\t\tif( $file == \".\" || $file == \"..\" )\n\t\t\t\t\tcontinue;\n\t\t\t\t\t// go on\n\t\t\t\t\tif( is_dir( $path . '/' . $file ) ){\n\t\t\t\t\t\tself::copy_r( $path  .'/' . $file, $dest . '/' . $file );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcopy( $path . '/' . $file, $dest . '/' . $file );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telseif( is_file( $path ) ){\n\t\t\treturn copy( $path, $dest );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t* @brief tries to extract the import zip\n\t* @param $path string path to the zip\n\t* @return string path to extract location (with a trailing slash) or false on failure\n\t*/\n\tstatic private function extractZip( $path ){\n\t\tself::$zip = new ZipArchive;\n\t\t// Validate path\n\t \tif( !file_exists( $path ) ){\n\t \t\tOC_Log::write( 'migration', 'Zip not found', OC_Log::ERROR );\n\t \t\treturn false;\n\t \t}\n\t\tif ( self::$zip->open( $path ) != TRUE ) {\n\t\t\tOC_Log::write( 'migration', \"Failed to open zip file\", OC_Log::ERROR );\n\t\t\treturn false;\n\t\t}\n\t\t$to = get_temp_dir() . '/oc_import_' . self::$exporttype . '_' . date(\"y-m-d_H-i-s\") . '/';\n\t\tif( !self::$zip->extractTo( $to ) ){\n\t\t\treturn false;\n\t\t}\n\t\tself::$zip->close();\n\t\treturn $to;\n\t}\n\n\t/**\n\t * @brief connects to a MDB2 database scheme\n\t * @returns bool\n\t */\n\tstatic private function connectScheme(){\n\t\t// We need a mdb2 database connection\n\t\tself::$MDB2->loadModule( 'Manager' );\n\t\tself::$MDB2->loadModule( 'Reverse' );\n\n\t\t// Connect if this did not happen before\n\t\tif( !self::$schema ){\n\t\t\trequire_once('MDB2/Schema.php');\n\t\t\tself::$schema=MDB2_Schema::factory( self::$MDB2 );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @brief creates a migration.db in the users data dir with their app data in\n\t * @return bool whether operation was successfull\n\t */\n\tprivate static function exportAppData( ){\n\n\t\t$success = true;\n\t\t$return = array();\n\n\t\t// Foreach provider\n\t\tforeach( self::$providers as $provider ){\n\t\t\t// Check if the app is enabled\n\t\t\tif( OC_App::isEnabled( $provider->getID() ) ){\n\t\t\t\t$success = true;\n\t\t\t\t// Does this app use the database?\n\t\t\t\tif( file_exists( OC::$SERVERROOT.'/apps/'.$provider->getID().'/appinfo/database.xml' ) ){\n\t\t\t\t\t// Create some app tables\n\t\t\t\t\t$tables = self::createAppTables( $provider->getID() );\n\t\t\t\t\tif( is_array( $tables ) ){\n\t\t\t\t\t\t// Save the table names\n\t\t\t\t\t\tforeach($tables as $table){\n\t\t\t\t\t\t\t$return['apps'][$provider->getID()]['tables'][] = $table;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It failed to create the tables\n\t\t\t\t\t\t$success = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Run the export function?\n\t\t\t\tif( $success ){\n\t\t\t\t\t// Set the provider properties\n\t\t\t\t\t$provider->setData( self::$uid, self::$content );\n\t\t\t\t\t$return['apps'][$provider->getID()]['success'] = $provider->export();\n\t\t\t\t} else {\n\t\t\t\t\t$return['apps'][$provider->getID()]['success'] = false;\n\t\t\t\t\t$return['apps'][$provider->getID()]['message'] = 'failed to create the app tables';\n\t\t\t\t}\n\t\n\t\t\t\t// Now add some app info the the return array\n\t\t\t\t$appinfo = OC_App::getAppInfo( $provider->getID() );\n\t\t\t\t$return['apps'][$provider->getID()]['version'] = OC_App::getAppVersion($provider->getID());\n\t\t\t}\n\t\t}\n\n\t\treturn $return;\n\n\t}\n\n\n\t/**\n\t * @brief generates json containing export info, and merges any data supplied\n\t * @param optional $array array of data to include in the returned json\n\t * @return bool\n\t */\n\tstatic private function getExportInfo( $array=array() ){\n\t\t$info = array(\n\t\t\t\t\t\t'ocversion' => OC_Util::getVersion(),\n\t\t\t\t\t\t'exporttime' => time(),\n\t\t\t\t\t\t'exportedby' => OC_User::getUser(),\n\t\t\t\t\t\t'exporttype' => self::$exporttype\n\t\t\t\t\t);\n\t\t// Add hash if user export\n\t\tif( self::$exporttype == 'user' ){\n\t\t\t$query = OC_DB::prepare( \"SELECT password FROM *PREFIX*users WHERE uid = ?\" );\n\t\t\t$result = $query->execute( array( self::$uid ) );\n\t\t\t$row = $result->fetchRow();\n\t\t\t$hash = $row ? $row['password'] : false;\n\t\t\tif( !$hash ){\n\t\t\t\tOC_Log::write( 'migration', 'Failed to get the users password hash', OC_log::ERROR);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$info['hash'] = $hash;\n\t\t\t$info['exporteduser'] = self::$uid;\n\t\t}\n\t\tif( !is_array( $array ) ){\n\t\t\tOC_Log::write( 'migration', 'Supplied $array was not an array in getExportInfo()', OC_Log::ERROR );\n\t\t}\n\t\t// Merge in other data\n\t\t$info = array_merge( $info, (array)$array );\n\t\t// Create json\n\t\t$json = json_encode( $info );\n\t\treturn $json;\n\t}\n\n\t/**\n\t * @brief connects to migration.db, or creates if not found\n\t * @param $db optional path to migration.db, defaults to user data dir\n\t * @return bool whether the operation was successful\n\t */\n\tstatic private function connectDB( $path=null ){\n\t\t// Has the dbpath been set?\n\t\tself::$dbpath = !is_null( $path ) ? $path : self::$dbpath;\n\t\tif( !self::$dbpath ){\n\t\t\tOC_Log::write( 'migration', 'connectDB() was called without dbpath being set', OC_Log::ERROR );\n\t\t\treturn false;\n\t\t}\n\t\t// Already connected\n\t\tif(!self::$MDB2){\n\t\t\trequire_once('MDB2.php');\n\n\t\t\t$datadir = OC_Config::getValue( \"datadirectory\", OC::$SERVERROOT.\"/data\" );\n\n\t\t\t// DB type\n\t\t\tif( class_exists( 'SQLite3' ) ){\n\t\t\t\t$dbtype = 'sqlite3';\n\t\t\t} else if( is_callable( 'sqlite_open' ) ){\n\t\t\t\t$dbtype = 'sqlite';\n\t\t\t} else {\n\t\t\t\tOC_Log::write( 'migration', 'SQLite not found', OC_Log::ERROR );\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Prepare options array\n\t\t\t$options = array(\n\t\t\t\t'portability' => MDB2_PORTABILITY_ALL & (!MDB2_PORTABILITY_FIX_CASE),\n\t\t\t\t'log_line_break' => '<br>',\n\t\t\t\t'idxname_format' => '%s',\n\t\t\t\t'debug' => true,\n\t\t\t\t'quote_identifier' => true\n\t\t\t\t);\n\t\t\t$dsn = array(\n\t\t\t\t'phptype'  => $dbtype,\n\t\t\t\t'database' => self::$dbpath,\n\t\t\t\t'mode' => '0644'\n\t\t\t);\n\n\t\t\t// Try to establish connection\n\t\t\tself::$MDB2 = MDB2::factory( $dsn, $options );\n\t\t\t// Die if we could not connect\n\t\t\tif( PEAR::isError( self::$MDB2 ) ){\n\t\t\t\tdie( self::$MDB2->getMessage() );\n\t\t\t\tOC_Log::write( 'migration', 'Failed to create/connect to migration.db', OC_Log::FATAL );\n\t\t\t\tOC_Log::write( 'migration', self::$MDB2->getUserInfo(), OC_Log::FATAL );\n\t\t\t\tOC_Log::write( 'migration', self::$MDB2->getMessage(), OC_Log::FATAL );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// We always, really always want associative arrays\n\t\t\tself::$MDB2->setFetchMode(MDB2_FETCHMODE_ASSOC);\n\t\t}\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * @brief creates the tables in migration.db from an apps database.xml\n\t * @param $appid string id of the app\n\t * @return bool whether the operation was successful\n\t */\n\tstatic private function createAppTables( $appid ){\n\n\t\tif( !self::connectScheme() ){\n\t\t\treturn false;\n\t\t}\n\n\t\t// There is a database.xml file\n\t\t$content = file_get_contents( OC::$SERVERROOT . '/apps/' . $appid . '/appinfo/database.xml' );\n\n\t\t$file2 = 'static://db_scheme';\n\t\t// TODO get the relative path to migration.db from the data dir\n\t\t// For now just cheat\n\t\t$path = pathinfo( self::$dbpath );\n\t\t$content = str_replace( '*dbname*', self::$uid.'/migration', $content );\n\t\t$content = str_replace( '*dbprefix*', '', $content );\n\n\t\t$xml = new SimpleXMLElement($content);\n\t\tforeach($xml->table as $table){\n\t\t\t$tables[] = (string)$table->name;\n\t\t}\n\n\t\tfile_put_contents( $file2, $content );\n\n\t\t// Try to create tables\n\t\t$definition = self::$schema->parseDatabaseDefinitionFile( $file2 );\n\n\t\tunlink( $file2 );\n\n\t\t// Die in case something went wrong\n\t\tif( $definition instanceof MDB2_Schema_Error ){\n\t\t\tOC_Log::write( 'migration', 'Failed to parse database.xml for: '.$appid, OC_Log::FATAL );\n\t\t\tOC_Log::write( 'migration', $definition->getMessage().': '.$definition->getUserInfo(), OC_Log::FATAL );\n\t\t\treturn false;\n\t\t}\n\n\t\t$definition['overwrite'] = true;\n\n\t\t$ret = self::$schema->createDatabase( $definition );\n\n\t\t// Die in case something went wrong\n\t\tif( $ret instanceof MDB2_Error ){\n\t\t\tOC_Log::write( 'migration', 'Failed to create tables for: '.$appid, OC_Log::FATAL );\n\t\t\tOC_Log::write( 'migration', $ret->getMessage().': '.$ret->getUserInfo(), OC_Log::FATAL );\n\t\t\treturn false;\n\t\t}\n\t\treturn $tables;\n\n\t}\n\n\t/**\n\t* @brief tries to create the zip\n\t* @param $path string path to zip destination\n\t* @return bool\n\t*/\n\tstatic private function createZip(){\n\t\tself::$zip = new ZipArchive;\n\t\t// Check if properties are set\n\t\tif( !self::$zippath ){\n\t\t\tOC_Log::write('migration', 'createZip() called but $zip and/or $zippath have not been set', OC_Log::ERROR);\n\t\t\treturn false;\n\t\t}\n\t\tif ( self::$zip->open( self::$zippath, ZIPARCHIVE::CREATE | ZIPARCHIVE::OVERWRITE ) !== TRUE ) {\n\t\t\tOC_Log::write('migration', 'Failed to create the zip with error: '.self::$zip->getStatusString(), OC_Log::ERROR);\n\t\t\treturn false;\n\t    } else {\n\t    \treturn true;\n\t    }\n\t}\n\n\t/**\n\t* @brief returns an array of apps that support migration\n\t* @return array\n\t*/\n\tstatic public function getApps(){\n\t\t$allapps = OC_App::getAllApps();\n\t\tforeach($allapps as $app){\n\t\t\t$path = OC::$SERVERROOT . '/apps/' . $app . '/lib/migrate.php';\n\t\t\tif( file_exists( $path ) ){\n\t\t\t\t$supportsmigration[] = $app;\n\t\t\t}\n\t\t}\n\t\treturn $supportsmigration;\n\t}\n\n\t/**\n\t* @brief imports a new user\n\t* @param $db string path to migration.db\n\t* @param $info object of migration info\n\t* @param $uid optional uid to use\n\t* @return array of apps with import statuses, or false on failure.\n\t*/\n\tpublic static function importAppData( $db, $info, $uid=null ){\n\t\t// Check if the db exists\n\t\tif( file_exists( $db ) ){\n\t\t\t// Connect to the db\n\t\t\tif(!self::connectDB( $db )){\n\t\t\t\tOC_Log::write('migration','Failed to connect to migration.db',OC_Log::ERROR);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tOC_Log::write('migration','Migration.db not found at: '.$db, OC_Log::FATAL );\n\t\t\treturn false;\n\t\t}\n\n\t\t// Find providers\n\t\tself::findProviders();\n\n\t\t// Generate importinfo array\n\t\t$importinfo = array(\n\t\t\t\t\t\t\t'olduid' => $info->exporteduser,\n\t\t\t\t\t\t\t'newuid' => self::$uid\n\t\t\t\t\t\t\t);\n\n\t\tforeach( self::$providers as $provider){\n\t\t\t// Is the app in the export?\n\t\t\t$id = $provider->getID();\n\t\t\tif( isset( $info->apps->$id ) ){\n\t\t\t\t// Is the app installed\n\t\t\t\tif( !OC_App::isEnabled( $id ) ){\n\t\t\t\t\tOC_Log::write( 'migration', 'App: ' . $id . ' is not installed, can\\'t import data.', OC_Log::INFO );\n\t\t\t\t\t$appsstatus[$id] = 'notsupported';\n\t\t\t\t} else {\n\t\t\t\t\t// Did it succeed on export?\n\t\t\t\t\tif( $info->apps->$id->success ){\n\t\t\t\t\t\t// Give the provider the content object\n\t\t\t\t\t\tif( !self::connectDB( $db ) ){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$content = new OC_Migration_Content( self::$zip, self::$MDB2 );\n\t\t\t\t\t\t$provider->setData( self::$uid, $content, $info );\n\t\t\t\t\t\t// Then do the import\n\t\t\t\t\t\tif( !$appsstatus[$id] = $provider->import( $info->apps->$id, $importinfo ) ){\n\t\t\t\t\t\t\t// Failed to import app\n\t\t\t\t\t\t\tOC_Log::write( 'migration', 'Failed to import app data for user: ' . self::$uid . ' for app: ' . $id, OC_Log::ERROR );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Add to failed list\n\t\t\t\t\t\t$appsstatus[$id] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $appsstatus;\n\n\t}\n\n\t/*\n\t* @brief creates a new user in the database\n\t* @param $uid string user_id of the user to be created\n\t* @param $hash string hash of the user to be created\n\t* @return bool result of user creation\n\t*/\n\tpublic static function createUser( $uid, $hash ){\n\n\t\t// Check if userid exists\n\t\tif(OC_User::userExists( $uid )){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Create the user\n\t\t$query = OC_DB::prepare( \"INSERT INTO `*PREFIX*users` ( `uid`, `password` ) VALUES( ?, ? )\" );\n\t\t$result = $query->execute( array( $uid, $hash));\n\t\tif( !$result ){\n\t\t\tOC_Log::write('migration', 'Failed to create the new user \"'.$uid.\"\");\n\t\t}\n\t\treturn $result ? true : false;\n\n\t}\n\n}\n"], "fixing_code": ["<?php\n/**\n * ownCloud\n *\n * @author Tom Needham\n * @copyright 2012 Tom Needham tom@owncloud.com\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU AFFERO GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU Affero General Public\n * License along with this library.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\n/**\n * provides an interface to migrate users and whole ownclouds\n */\nclass OC_Migrate{\n\n\n\t// Array of OC_Migration_Provider objects\n\tstatic private $providers=array();\n\t// User id of the user to import/export\n\tstatic private $uid=false;\n\t// Holds the ZipArchive object\n\tstatic private $zip=false;\n\t// Stores the type of export\n\tstatic private $exporttype=false;\n\t// Array of temp files to be deleted after zip creation\n\tstatic private $tmpfiles=array();\n\t// Holds the db object\n\tstatic private $MDB2=false;\n\t// Schema db object\n\tstatic private $schema=false;\n\t// Path to the sqlite db\n\tstatic private $dbpath=false;\n\t// Holds the path to the zip file\n\tstatic private $zippath=false;\n\t// Holds the OC_Migration_Content object\n\tstatic private $content=false;\n\n\t/**\n\t * register a new migration provider\n\t * @param OC_Migrate_Provider $provider\n\t */\n\tpublic static function registerProvider($provider){\n\t\tself::$providers[]=$provider;\n\t}\n\n\t/**\n\t* @brief finds and loads the providers\n\t*/\n\tstatic private function findProviders(){\n\t\t// Find the providers\n\t\t$apps = OC_App::getAllApps();\n\n\t\tforeach($apps as $app){\n\t\t\t$path = OC::$SERVERROOT . '/apps/' . $app . '/appinfo/migrate.php';\n\t\t\tif( file_exists( $path ) ){\n\t\t\t\tinclude( $path );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @brief exports a user, or owncloud instance\n\t * @param optional $uid string user id of user to export if export type is user, defaults to current\n\t * @param ootional $type string type of export, defualts to user\n\t * @param otional $path string path to zip output folder\n\t * @return false on error, path to zip on success\n\t */\n\t public static function export( $uid=null, $type='user', $path=null ){\n\t\t$datadir = OC_Config::getValue( 'datadirectory' );\n\t \t// Validate export type\n\t \t$types = array( 'user', 'instance', 'system', 'userfiles' );\n\t \tif( !in_array( $type, $types ) ){\n\t \t\tOC_Log::write( 'migration', 'Invalid export type', OC_Log::ERROR );\n\t \t\treturn json_encode( array( array( 'success' => false ) ) );\n\t \t}\n\t \tself::$exporttype = $type;\n\t \t// Userid?\n\t \tif( self::$exporttype == 'user' ){\n\t \t\t// Check user exists\n\t \t\tif( !is_null($uid) ){\n                                $db = new OC_User_Database;\n\t\t \t\tif( !$db->userExists( $uid ) ){\n\t\t\t\t\tOC_Log::write('migration', 'User: '.$uid.' is not in the database and so cannot be exported.', OC_Log::ERROR);\n\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t}\n\t\t\t\tself::$uid = $uid;\n\t \t\t} else {\n\t \t\t\tself::$uid = OC_User::getUser();\n\t \t\t}\n\t \t}\n\t \t// Calculate zipname\n\t \tif( self::$exporttype == 'user' ){\n\t \t\t$zipname = 'oc_export_' . self::$uid . '_' . date(\"y-m-d_H-i-s\") . '.zip';\n\t \t} else {\n\t \t\t$zipname = 'oc_export_' . self::$exporttype . '_' . date(\"y-m-d_H-i-s\") . '.zip';\n\t \t}\n\t \t// Calculate path\n\t \tif( self::$exporttype == 'user' ){\n\t \t\tself::$zippath = $datadir . '/' . self::$uid . '/' . $zipname;\n\t \t} else {\n\t \t\tif( !is_null( $path ) ){\n\t \t\t\t// Validate custom path\n\t \t\t\tif( !file_exists( $path ) || !is_writeable( $path ) ){\n\t \t\t\t\tOC_Log::write( 'migration', 'Path supplied is invalid.', OC_Log::ERROR );\n\t \t\t\t\treturn json_encode( array( 'success' => false ) );\n\t \t\t\t}\n\t \t\t\tself::$zippath = $path . $zipname;\n\t \t\t} else {\n\t \t\t\t// Default path\n\t \t\t\tself::$zippath = get_temp_dir() . '/' . $zipname;\n\t \t\t}\n\t \t}\n\t \t// Create the zip object\n\t \tif( !self::createZip() ){\n\t \t\treturn json_encode( array( 'success' => false ) );\n\t \t}\n\t \t// Do the export\n\t \tself::findProviders();\n\t \t$exportdata = array();\n\t \tswitch( self::$exporttype ){\n\t \t\tcase 'user':\n\t \t\t\t// Connect to the db\n\t \t\t\tself::$dbpath = $datadir . '/' . self::$uid . '/migration.db';\n\t \t\t\tif( !self::connectDB() ){\n\t \t\t\t\treturn json_encode( array( 'success' => false ) );\n\t \t\t\t}\n\t \t\t\tself::$content = new OC_Migration_Content( self::$zip, self::$MDB2 );\n\t \t\t\t// Export the app info\n\t\t\t    $exportdata = self::exportAppData();\n\t\t\t\t// Add the data dir to the zip\n\t\t\t\tself::$content->addDir( $datadir . '/' . self::$uid, true, '/' );\n\t \t\tbreak;\n\t \t\tcase 'instance':\n\t \t\t\tself::$content = new OC_Migration_Content( self::$zip );\n\t\t\t\t// Creates a zip that is compatable with the import function\n\t\t\t\t$dbfile = tempnam( get_temp_dir(), \"owncloud_export_data_\" );\n\t\t\t\tOC_DB::getDbStructure( $dbfile, 'MDB2_SCHEMA_DUMP_ALL');\n\n\t\t\t\t// Now add in *dbname* and *dbprefix*\n\t\t\t\t$dbexport = file_get_contents( $dbfile );\n\t\t\t\t$dbnamestring = \"<database>\\n\\n <name>\" . OC_Config::getValue( \"dbname\", \"owncloud\" );\n\t\t\t\t$dbtableprefixstring = \"<table>\\n\\n  <name>\" . OC_Config::getValue( \"dbtableprefix\", \"oc_\" );\n\t\t\t\t$dbexport = str_replace( $dbnamestring, \"<database>\\n\\n <name>*dbname*\", $dbexport );\n\t\t\t\t$dbexport = str_replace( $dbtableprefixstring, \"<table>\\n\\n  <name>*dbprefix*\", $dbexport );\n\t\t\t\t// Add the export to the zip\n\t\t\t\tself::$content->addFromString( $dbexport, \"dbexport.xml\" );\n\t\t\t\t// Add user data\n\t\t\t\tforeach(OC_User::getUsers() as $user){\n\t\t\t\t\tself::$content->addDir( $datadir . '/' . $user . '/', true, \"/userdata/\" );\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'userfiles':\n\t\t\t\tself::$content = new OC_Migration_Content( self::$zip );\n\t\t\t\t// Creates a zip with all of the users files\n\t\t\t\tforeach(OC_User::getUsers() as $user){\n\t\t\t\t\tself::$content->addDir( $datadir . '/' . $user . '/', true, \"/\" );\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'system':\n\t\t\t\tself::$content = new OC_Migration_Content( self::$zip );\n\t\t\t\t// Creates a zip with the owncloud system files\n\t\t\t\tself::$content->addDir( OC::$SERVERROOT . '/', false, '/');\n\t\t\t\tforeach (array(\".git\", \"3rdparty\", \"apps\", \"core\", \"files\", \"l10n\", \"lib\", \"ocs\", \"search\", \"settings\", \"tests\") as $dir) {\n\t\t\t    \tself::$content->addDir( OC::$SERVERROOT . '/' . $dir, true, \"/\");\n\t\t\t\t}\n\t\t\tbreak;\n\t \t}\n\t \tif( !$info = self::getExportInfo( $exportdata ) ){\n\t \t\treturn json_encode( array( 'success' => false ) );\n\t \t}\n\t \t// Add the export info json to the export zip\n\t \tself::$content->addFromString( $info, 'export_info.json' );\n\t \tif( !self::$content->finish() ){\n\t \t\treturn json_encode( array( 'success' => false ) );\n\t \t}\n\t \treturn json_encode( array( 'success' => true, 'data' => self::$zippath ) );\n\t }\n\n\t/**\n\t* @brief imports a user, or owncloud instance\n\t* @param $path string path to zip\n\t* @param optional $type type of import (user or instance)\n\t* @param optional $uid userid of new user\n\t*/\n\tpublic static function import( $path, $type='user', $uid=null ){\n\t\t\n\t\t$datadir = OC_Config::getValue( 'datadirectory' );\n\t\t// Extract the zip\n\t\tif( !$extractpath = self::extractZip( $path ) ){\n\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t}\n\t\t// Get export_info.json\n\t\t$scan = scandir( $extractpath );\n\t\t// Check for export_info.json\n\t\tif( !in_array( 'export_info.json', $scan ) ){\n\t\t\tOC_Log::write( 'migration', 'Invalid import file, export_info.json note found', OC_Log::ERROR );\n\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t}\n\t\t$json = json_decode( file_get_contents( $extractpath . 'export_info.json' ) );\n\t\tif( $json->exporttype != $type ){\n\t\t\tOC_Log::write( 'migration', 'Invalid import file', OC_Log::ERROR );\n\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t}\n\t\tself::$exporttype = $type;\n\n\t\t$currentuser = OC_User::getUser();\n\n\t\t// Have we got a user if type is user\n\t\tif( self::$exporttype == 'user' ){\n\t\t\tself::$uid = !is_null($uid) ? $uid : $currentuser;\n\t\t}\n\t\t\n\t\t// We need to be an admin if we are not importing our own data\n\t\tif(($type == 'user' && self::$uid != $currentuser) || $type != 'user' ){\n\t\t\tif( !OC_Group::inGroup( OC_User::getUser(), 'admin' )){\n\t\t\t\t// Naughty.\n\t\t\t\tOC_Log::write( 'migration', 'Import not permitted.', OC_Log::ERROR );\n\t\t\t\treturn json_encode( array( 'success' => false ) ); \t\n\t\t\t}\n\t\t}\n\n\t\t// Handle export types\n\t\tswitch( self::$exporttype ){\n\t\t\tcase 'user':\n\t\t\t\t// Check user availability\n\t\t\t\tif( !OC_User::userExists( self::$uid ) ){\n\t\t\t\t\tOC_Log::write( 'migration', 'User doesn\\'t exist', OC_Log::ERROR );\n\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t}\n\t\t\t\t// Copy data\n\t\t\t\tif( !self::copy_r( $extractpath . $json->exporteduser, $datadir . '/' . self::$uid ) ){\n\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t}\n\t\t\t\t// Import user app data\n\t\t\t\tif( !$appsimported = self::importAppData( $extractpath . $json->exporteduser . '/migration.db', $json, self::$uid ) ){\n\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t}\n\t\t\t\t// All done!\n\t\t\t\tif( !self::unlink_r( $extractpath ) ){\n\t\t\t\t\tOC_Log::write( 'migration', 'Failed to delete the extracted zip', OC_Log::ERROR );\n\t\t\t\t}\n\t\t\t\treturn json_encode( array( 'success' => true, 'data' => $appsimported ) );\n\t\t\tbreak;\n\t\t\tcase 'instance':\n\t\t\t\t\t/*\n\t\t\t\t\t * EXPERIMENTAL\n\t\t\t\t\t// Check for new data dir and dbexport before doing anything\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Delete current data folder.\n\t\t\t\t\tOC_Log::write( 'migration', \"Deleting current data dir\", OC_Log::INFO );\n\t\t\t\t\tif( !self::unlink_r( $datadir, false ) ){\n\t\t\t\t\t\tOC_Log::write( 'migration', 'Failed to delete the current data dir', OC_Log::ERROR );\n\t\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Copy over data\n\t\t\t\t\tif( !self::copy_r( $extractpath . 'userdata', $datadir ) ){\n\t\t\t\t\t\tOC_Log::write( 'migration', 'Failed to copy over data directory', OC_Log::ERROR );\n\t\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Import the db\n\t\t\t\t\tif( !OC_DB::replaceDB( $extractpath . 'dbexport.xml' ) ){\n\t\t\t\t\t\treturn json_encode( array( 'success' => false ) );\n\t\t\t\t\t}\n\t\t\t\t\t// Done\n\t\t\t\t\treturn json_encode( 'success' => true );\n\t\t\t\t\t*/\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t/**\n\t* @brief recursively deletes a directory\n\t* @param $dir string path of dir to delete\n\t* $param optional $deleteRootToo bool delete the root directory\n\t* @return bool\n\t*/\n\tprivate static function unlink_r( $dir, $deleteRootToo=true ){\n\t\tif( !$dh = @opendir( $dir ) ){\n\t\t\treturn false;\n\t\t}\n\t\twhile (false !== ($obj = readdir($dh))){\n\t\t\tif($obj == '.' || $obj == '..') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!@unlink($dir . '/' . $obj)){\n\t\t\t\tself::unlink_r($dir.'/'.$obj, true);\n\t\t\t}\n\t\t}\n\t\tclosedir($dh);\n\t\tif ( $deleteRootToo ) {\n\t\t\t@rmdir($dir);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t* @brief copies recursively\n\t* @param $path string path to source folder\n\t* @param $dest string path to destination\n\t* @return bool\n\t*/\n\tprivate static function copy_r( $path, $dest ){\n\t\tif( is_dir($path) ){\n\t\t\t@mkdir( $dest );\n\t\t\t$objects = scandir( $path );\n\t\t\tif( sizeof( $objects ) > 0 ){\n\t\t\t\tforeach( $objects as $file ){\n\t\t\t\t\tif( $file == \".\" || $file == \"..\" || $file == \".htaccess\")\n\t\t\t\t\tcontinue;\n\t\t\t\t\t// go on\n\t\t\t\t\tif( is_dir( $path . '/' . $file ) ){\n\t\t\t\t\t\tself::copy_r( $path  .'/' . $file, $dest . '/' . $file );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcopy( $path . '/' . $file, $dest . '/' . $file );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telseif( is_file( $path ) ){\n\t\t\treturn copy( $path, $dest );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t* @brief tries to extract the import zip\n\t* @param $path string path to the zip\n\t* @return string path to extract location (with a trailing slash) or false on failure\n\t*/\n\tstatic private function extractZip( $path ){\n\t\tself::$zip = new ZipArchive;\n\t\t// Validate path\n\t \tif( !file_exists( $path ) ){\n\t \t\tOC_Log::write( 'migration', 'Zip not found', OC_Log::ERROR );\n\t \t\treturn false;\n\t \t}\n\t\tif ( self::$zip->open( $path ) != TRUE ) {\n\t\t\tOC_Log::write( 'migration', \"Failed to open zip file\", OC_Log::ERROR );\n\t\t\treturn false;\n\t\t}\n\t\t$to = get_temp_dir() . '/oc_import_' . self::$exporttype . '_' . date(\"y-m-d_H-i-s\") . '/';\n\t\tif( !self::$zip->extractTo( $to ) ){\n\t\t\treturn false;\n\t\t}\n\t\tself::$zip->close();\n\t\treturn $to;\n\t}\n\n\t/**\n\t * @brief connects to a MDB2 database scheme\n\t * @returns bool\n\t */\n\tstatic private function connectScheme(){\n\t\t// We need a mdb2 database connection\n\t\tself::$MDB2->loadModule( 'Manager' );\n\t\tself::$MDB2->loadModule( 'Reverse' );\n\n\t\t// Connect if this did not happen before\n\t\tif( !self::$schema ){\n\t\t\trequire_once('MDB2/Schema.php');\n\t\t\tself::$schema=MDB2_Schema::factory( self::$MDB2 );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @brief creates a migration.db in the users data dir with their app data in\n\t * @return bool whether operation was successfull\n\t */\n\tprivate static function exportAppData( ){\n\n\t\t$success = true;\n\t\t$return = array();\n\n\t\t// Foreach provider\n\t\tforeach( self::$providers as $provider ){\n\t\t\t// Check if the app is enabled\n\t\t\tif( OC_App::isEnabled( $provider->getID() ) ){\n\t\t\t\t$success = true;\n\t\t\t\t// Does this app use the database?\n\t\t\t\tif( file_exists( OC::$SERVERROOT.'/apps/'.$provider->getID().'/appinfo/database.xml' ) ){\n\t\t\t\t\t// Create some app tables\n\t\t\t\t\t$tables = self::createAppTables( $provider->getID() );\n\t\t\t\t\tif( is_array( $tables ) ){\n\t\t\t\t\t\t// Save the table names\n\t\t\t\t\t\tforeach($tables as $table){\n\t\t\t\t\t\t\t$return['apps'][$provider->getID()]['tables'][] = $table;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It failed to create the tables\n\t\t\t\t\t\t$success = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Run the export function?\n\t\t\t\tif( $success ){\n\t\t\t\t\t// Set the provider properties\n\t\t\t\t\t$provider->setData( self::$uid, self::$content );\n\t\t\t\t\t$return['apps'][$provider->getID()]['success'] = $provider->export();\n\t\t\t\t} else {\n\t\t\t\t\t$return['apps'][$provider->getID()]['success'] = false;\n\t\t\t\t\t$return['apps'][$provider->getID()]['message'] = 'failed to create the app tables';\n\t\t\t\t}\n\t\n\t\t\t\t// Now add some app info the the return array\n\t\t\t\t$appinfo = OC_App::getAppInfo( $provider->getID() );\n\t\t\t\t$return['apps'][$provider->getID()]['version'] = OC_App::getAppVersion($provider->getID());\n\t\t\t}\n\t\t}\n\n\t\treturn $return;\n\n\t}\n\n\n\t/**\n\t * @brief generates json containing export info, and merges any data supplied\n\t * @param optional $array array of data to include in the returned json\n\t * @return bool\n\t */\n\tstatic private function getExportInfo( $array=array() ){\n\t\t$info = array(\n\t\t\t\t\t\t'ocversion' => OC_Util::getVersion(),\n\t\t\t\t\t\t'exporttime' => time(),\n\t\t\t\t\t\t'exportedby' => OC_User::getUser(),\n\t\t\t\t\t\t'exporttype' => self::$exporttype\n\t\t\t\t\t);\n\t\t// Add hash if user export\n\t\tif( self::$exporttype == 'user' ){\n\t\t\t$query = OC_DB::prepare( \"SELECT password FROM *PREFIX*users WHERE uid = ?\" );\n\t\t\t$result = $query->execute( array( self::$uid ) );\n\t\t\t$row = $result->fetchRow();\n\t\t\t$hash = $row ? $row['password'] : false;\n\t\t\tif( !$hash ){\n\t\t\t\tOC_Log::write( 'migration', 'Failed to get the users password hash', OC_log::ERROR);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$info['hash'] = $hash;\n\t\t\t$info['exporteduser'] = self::$uid;\n\t\t}\n\t\tif( !is_array( $array ) ){\n\t\t\tOC_Log::write( 'migration', 'Supplied $array was not an array in getExportInfo()', OC_Log::ERROR );\n\t\t}\n\t\t// Merge in other data\n\t\t$info = array_merge( $info, (array)$array );\n\t\t// Create json\n\t\t$json = json_encode( $info );\n\t\treturn $json;\n\t}\n\n\t/**\n\t * @brief connects to migration.db, or creates if not found\n\t * @param $db optional path to migration.db, defaults to user data dir\n\t * @return bool whether the operation was successful\n\t */\n\tstatic private function connectDB( $path=null ){\n\t\t// Has the dbpath been set?\n\t\tself::$dbpath = !is_null( $path ) ? $path : self::$dbpath;\n\t\tif( !self::$dbpath ){\n\t\t\tOC_Log::write( 'migration', 'connectDB() was called without dbpath being set', OC_Log::ERROR );\n\t\t\treturn false;\n\t\t}\n\t\t// Already connected\n\t\tif(!self::$MDB2){\n\t\t\trequire_once('MDB2.php');\n\n\t\t\t$datadir = OC_Config::getValue( \"datadirectory\", OC::$SERVERROOT.\"/data\" );\n\n\t\t\t// DB type\n\t\t\tif( class_exists( 'SQLite3' ) ){\n\t\t\t\t$dbtype = 'sqlite3';\n\t\t\t} else if( is_callable( 'sqlite_open' ) ){\n\t\t\t\t$dbtype = 'sqlite';\n\t\t\t} else {\n\t\t\t\tOC_Log::write( 'migration', 'SQLite not found', OC_Log::ERROR );\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Prepare options array\n\t\t\t$options = array(\n\t\t\t\t'portability' => MDB2_PORTABILITY_ALL & (!MDB2_PORTABILITY_FIX_CASE),\n\t\t\t\t'log_line_break' => '<br>',\n\t\t\t\t'idxname_format' => '%s',\n\t\t\t\t'debug' => true,\n\t\t\t\t'quote_identifier' => true\n\t\t\t\t);\n\t\t\t$dsn = array(\n\t\t\t\t'phptype'  => $dbtype,\n\t\t\t\t'database' => self::$dbpath,\n\t\t\t\t'mode' => '0644'\n\t\t\t);\n\n\t\t\t// Try to establish connection\n\t\t\tself::$MDB2 = MDB2::factory( $dsn, $options );\n\t\t\t// Die if we could not connect\n\t\t\tif( PEAR::isError( self::$MDB2 ) ){\n\t\t\t\tdie( self::$MDB2->getMessage() );\n\t\t\t\tOC_Log::write( 'migration', 'Failed to create/connect to migration.db', OC_Log::FATAL );\n\t\t\t\tOC_Log::write( 'migration', self::$MDB2->getUserInfo(), OC_Log::FATAL );\n\t\t\t\tOC_Log::write( 'migration', self::$MDB2->getMessage(), OC_Log::FATAL );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// We always, really always want associative arrays\n\t\t\tself::$MDB2->setFetchMode(MDB2_FETCHMODE_ASSOC);\n\t\t}\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * @brief creates the tables in migration.db from an apps database.xml\n\t * @param $appid string id of the app\n\t * @return bool whether the operation was successful\n\t */\n\tstatic private function createAppTables( $appid ){\n\n\t\tif( !self::connectScheme() ){\n\t\t\treturn false;\n\t\t}\n\n\t\t// There is a database.xml file\n\t\t$content = file_get_contents( OC::$SERVERROOT . '/apps/' . $appid . '/appinfo/database.xml' );\n\n\t\t$file2 = 'static://db_scheme';\n\t\t// TODO get the relative path to migration.db from the data dir\n\t\t// For now just cheat\n\t\t$path = pathinfo( self::$dbpath );\n\t\t$content = str_replace( '*dbname*', self::$uid.'/migration', $content );\n\t\t$content = str_replace( '*dbprefix*', '', $content );\n\n\t\t$xml = new SimpleXMLElement($content);\n\t\tforeach($xml->table as $table){\n\t\t\t$tables[] = (string)$table->name;\n\t\t}\n\n\t\tfile_put_contents( $file2, $content );\n\n\t\t// Try to create tables\n\t\t$definition = self::$schema->parseDatabaseDefinitionFile( $file2 );\n\n\t\tunlink( $file2 );\n\n\t\t// Die in case something went wrong\n\t\tif( $definition instanceof MDB2_Schema_Error ){\n\t\t\tOC_Log::write( 'migration', 'Failed to parse database.xml for: '.$appid, OC_Log::FATAL );\n\t\t\tOC_Log::write( 'migration', $definition->getMessage().': '.$definition->getUserInfo(), OC_Log::FATAL );\n\t\t\treturn false;\n\t\t}\n\n\t\t$definition['overwrite'] = true;\n\n\t\t$ret = self::$schema->createDatabase( $definition );\n\n\t\t// Die in case something went wrong\n\t\tif( $ret instanceof MDB2_Error ){\n\t\t\tOC_Log::write( 'migration', 'Failed to create tables for: '.$appid, OC_Log::FATAL );\n\t\t\tOC_Log::write( 'migration', $ret->getMessage().': '.$ret->getUserInfo(), OC_Log::FATAL );\n\t\t\treturn false;\n\t\t}\n\t\treturn $tables;\n\n\t}\n\n\t/**\n\t* @brief tries to create the zip\n\t* @param $path string path to zip destination\n\t* @return bool\n\t*/\n\tstatic private function createZip(){\n\t\tself::$zip = new ZipArchive;\n\t\t// Check if properties are set\n\t\tif( !self::$zippath ){\n\t\t\tOC_Log::write('migration', 'createZip() called but $zip and/or $zippath have not been set', OC_Log::ERROR);\n\t\t\treturn false;\n\t\t}\n\t\tif ( self::$zip->open( self::$zippath, ZIPARCHIVE::CREATE | ZIPARCHIVE::OVERWRITE ) !== TRUE ) {\n\t\t\tOC_Log::write('migration', 'Failed to create the zip with error: '.self::$zip->getStatusString(), OC_Log::ERROR);\n\t\t\treturn false;\n\t    } else {\n\t    \treturn true;\n\t    }\n\t}\n\n\t/**\n\t* @brief returns an array of apps that support migration\n\t* @return array\n\t*/\n\tstatic public function getApps(){\n\t\t$allapps = OC_App::getAllApps();\n\t\tforeach($allapps as $app){\n\t\t\t$path = OC::$SERVERROOT . '/apps/' . $app . '/lib/migrate.php';\n\t\t\tif( file_exists( $path ) ){\n\t\t\t\t$supportsmigration[] = $app;\n\t\t\t}\n\t\t}\n\t\treturn $supportsmigration;\n\t}\n\n\t/**\n\t* @brief imports a new user\n\t* @param $db string path to migration.db\n\t* @param $info object of migration info\n\t* @param $uid optional uid to use\n\t* @return array of apps with import statuses, or false on failure.\n\t*/\n\tpublic static function importAppData( $db, $info, $uid=null ){\n\t\t// Check if the db exists\n\t\tif( file_exists( $db ) ){\n\t\t\t// Connect to the db\n\t\t\tif(!self::connectDB( $db )){\n\t\t\t\tOC_Log::write('migration','Failed to connect to migration.db',OC_Log::ERROR);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tOC_Log::write('migration','Migration.db not found at: '.$db, OC_Log::FATAL );\n\t\t\treturn false;\n\t\t}\n\n\t\t// Find providers\n\t\tself::findProviders();\n\n\t\t// Generate importinfo array\n\t\t$importinfo = array(\n\t\t\t\t\t\t\t'olduid' => $info->exporteduser,\n\t\t\t\t\t\t\t'newuid' => self::$uid\n\t\t\t\t\t\t\t);\n\n\t\tforeach( self::$providers as $provider){\n\t\t\t// Is the app in the export?\n\t\t\t$id = $provider->getID();\n\t\t\tif( isset( $info->apps->$id ) ){\n\t\t\t\t// Is the app installed\n\t\t\t\tif( !OC_App::isEnabled( $id ) ){\n\t\t\t\t\tOC_Log::write( 'migration', 'App: ' . $id . ' is not installed, can\\'t import data.', OC_Log::INFO );\n\t\t\t\t\t$appsstatus[$id] = 'notsupported';\n\t\t\t\t} else {\n\t\t\t\t\t// Did it succeed on export?\n\t\t\t\t\tif( $info->apps->$id->success ){\n\t\t\t\t\t\t// Give the provider the content object\n\t\t\t\t\t\tif( !self::connectDB( $db ) ){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$content = new OC_Migration_Content( self::$zip, self::$MDB2 );\n\t\t\t\t\t\t$provider->setData( self::$uid, $content, $info );\n\t\t\t\t\t\t// Then do the import\n\t\t\t\t\t\tif( !$appsstatus[$id] = $provider->import( $info->apps->$id, $importinfo ) ){\n\t\t\t\t\t\t\t// Failed to import app\n\t\t\t\t\t\t\tOC_Log::write( 'migration', 'Failed to import app data for user: ' . self::$uid . ' for app: ' . $id, OC_Log::ERROR );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Add to failed list\n\t\t\t\t\t\t$appsstatus[$id] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $appsstatus;\n\n\t}\n\n\t/*\n\t* @brief creates a new user in the database\n\t* @param $uid string user_id of the user to be created\n\t* @param $hash string hash of the user to be created\n\t* @return bool result of user creation\n\t*/\n\tpublic static function createUser( $uid, $hash ){\n\n\t\t// Check if userid exists\n\t\tif(OC_User::userExists( $uid )){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Create the user\n\t\t$query = OC_DB::prepare( \"INSERT INTO `*PREFIX*users` ( `uid`, `password` ) VALUES( ?, ? )\" );\n\t\t$result = $query->execute( array( $uid, $hash));\n\t\tif( !$result ){\n\t\t\tOC_Log::write('migration', 'Failed to create the new user \"'.$uid.\"\");\n\t\t}\n\t\treturn $result ? true : false;\n\n\t}\n\n}\n"], "filenames": ["lib/migrate.php"], "buggy_code_start_loc": [325], "buggy_code_end_loc": [326], "fixing_code_start_loc": [325], "fixing_code_end_loc": [326], "type": "NVD-CWE-Other", "message": "Incomplete blacklist vulnerability in lib/migrate.php in ownCloud before 4.0.7 allows remote attackers to execute arbitrary code by uploading a crafted .htaccess file in an import.zip file and accessing an uploaded PHP file.", "other": {"cve": {"id": "CVE-2012-4389", "sourceIdentifier": "secalert@redhat.com", "published": "2012-09-05T23:55:02.757", "lastModified": "2012-09-13T04:00:00.000", "vulnStatus": "Analyzed", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/184.html\r\n\r\n'CWE-184: Incomplete Blacklist'", "descriptions": [{"lang": "en", "value": "Incomplete blacklist vulnerability in lib/migrate.php in ownCloud before 4.0.7 allows remote attackers to execute arbitrary code by uploading a crafted .htaccess file in an import.zip file and accessing an uploaded PHP file."}, {"lang": "es", "value": "Vulnerabilidad de incompatibilidad en lib/migrate.php en ownCloud anterior a v4.0.7 permite a atacantes remotos ejecutar c\u00f3digo arbitrario mediante la carga de un archivo .htaccess en un archivo import.zip y el acceso a un archivo PHP cargado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.0.6", "matchCriteriaId": "9C5EB081-BE10-49B1-8A91-3EC70F6DC6AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "0A1021FF-2A5A-49AA-A376-09C98FECC519"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "3F6C12F7-5897-4DBB-A9AB-8180101F37C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "E9CC055C-CFA3-4A23-AF91-83F7F087F282"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "AA5445B4-9115-4D31-9DF9-E7E30CAF1FFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "8FAE7D90-6190-44E2-B4EA-F47FF3263BE6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "C7BAB402-B6A0-4314-A37A-C9465157BF5E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:4.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "8A32BED8-F428-44D3-BEAC-E0BB0208B6B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:4.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "F46F53A9-52B2-41D6-859B-9062B1F02B86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:4.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "875B306F-92A2-4360-979E-2B53466A33F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:4.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "6EB01EA3-3071-424F-9586-83CD208D5CAE"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2012/09/02/2", "source": "secalert@redhat.com"}, {"url": "https://github.com/owncloud/core/commit/4fd069b47906ebcf83887970c732d464dbe7d37a", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/owncloud/core/commit/4fd069b47906ebcf83887970c732d464dbe7d37a"}}