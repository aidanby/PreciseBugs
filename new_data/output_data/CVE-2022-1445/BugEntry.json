{"buggy_code": ["<?php\nnamespace App\\Http\\Transformers;\n\nuse App\\Helpers\\Helper;\nuse App\\Models\\Asset;\nuse Illuminate\\Database\\Eloquent\\Collection;\n\n/**\n *  This tranformer looks like it's extraneous, since we return as much or more\n * info in the AssetsTransformer, but we want to flatten these results out so that they \n * don't dislose more information than we want. Folks with depreciation powers don't necessaily \n * have the right to see additional info, and inspecting the API call here could disclose \n * info they're not supposed to see.\n * \n * @author [A. Gianotto] [<snipe@snipe.net>]\n * @since [v5.2.0]\n */\nclass DepreciationReportTransformer\n{\n    public function transformAssets(Collection $assets, $total)\n    {\n        $array = array();\n        foreach ($assets as $asset) {\n            $array[] = self::transformAsset($asset);\n        }\n        return (new DatatablesTransformer)->transformDatatables($array, $total);\n    }\n\n\n    public function transformAsset(Asset $asset)\n    {\n\n        /**\n         * Set some default values here\n         */\n        $purchase_cost = null;\n        $depreciated_value = null;\n        $monthly_depreciation = null;\n        $diff = null;\n        $checkout_target = null;\n\n        /**\n         * If there is a location set and a currency set, use that for display\n         */\n        if ($asset->location && $asset->location->currency) {\n            $purchase_cost_currency = $asset->location->currency;\n        } else {\n            $purchase_cost_currency = \\App\\Models\\Setting::getSettings()->default_currency;\n        }\n\n        /**\n         * If there is a NOT an empty purchase cost (meaning not null or '' but it *could* be zero),\n         * format the purchase cost. We coould do this inline in the transformer, but we need that value \n         * for the other calculations that come after, like diff, etc.\n         */\n        if ($asset->purchase_cost!='') {\n            $purchase_cost = $asset->purchase_cost;\n        }\n       \n\n        /**\n         * Override the previously set null values if there is a valid model and associated depreciation\n         */\n        if (($asset->model) && ($asset->model->depreciation)) {\n            $depreciated_value = \\App\\Helpers\\Helper::formatCurrencyOutput($asset->getDepreciatedValue());\n            $monthly_depreciation = \\App\\Helpers\\Helper::formatCurrencyOutput(($asset->model->eol > 0 ? ($asset->purchase_cost / $asset->model->eol) : 0));\n            $diff = \\App\\Helpers\\Helper::formatCurrencyOutput(($asset->purchase_cost - $asset->getDepreciatedValue()));\n        }\n\n        if ($asset->assigned) {\n            $checkout_target = $asset->assigned->name;\n            if ($asset->checkedOutToUser()) {\n                $checkout_target = $asset->assigned->getFullNameAttribute();\n            } \n\n        }\n                   \n        $array = [\n    \n            'company' => ($asset->company) ? e($asset->company->name) : null,\n            'name' => e($asset->name),\n            'asset_tag' => e($asset->asset_tag),\n            'serial' => e($asset->serial),\n            'model' => ($asset->model) ?  e($asset->model->name) : null,\n            'model_number' => (($asset->model) && ($asset->model->model_number)) ? e($asset->model->model_number) : null,\n            'eol' => ($asset->purchase_date!='') ? Helper::getFormattedDateObject($asset->present()->eol_date(), 'date') : null ,\n            'status_label' => ($asset->assetstatus) ? e($asset->assetstatus->name) : null,\n            'status' => ($asset->assetstatus) ?  e($asset->present()->statusMeta) : null,\n            'category' => (($asset->model) && ($asset->model->category)) ? e($asset->model->category->name) : null,\n            'manufacturer' => (($asset->model) && ($asset->model->manufacturer)) ? e($asset->model->manufacturer->name) : null,\n            'supplier' => ($asset->supplier) ? e($asset->supplier->name) : null,\n            'notes' => ($asset->notes) ? e($asset->notes) : null,\n            'order_number' => ($asset->order_number) ? e($asset->order_number) : null,\n            'location' => ($asset->location) ? e($asset->location->name) : null,\n            'warranty_expires' => ($asset->warranty_months > 0) ?  Helper::getFormattedDateObject($asset->warranty_expires, 'date') : null,\n            'currency' => $purchase_cost_currency,\n            'purchase_date' => Helper::getFormattedDateObject($asset->purchase_date, 'date'),\n            'purchase_cost' => Helper::formatCurrencyOutput($asset->purchase_cost),\n            'book_value' => Helper::formatCurrencyOutput($depreciated_value),\n            'monthly_depreciation' => $monthly_depreciation,\n            'checked_out_to' => $checkout_target,\n            'diff' =>  Helper::formatCurrencyOutput($diff),\n            'number_of_months' =>  ($asset->model && $asset->model->depreciation) ? e($asset->model->depreciation->months) : null,\n            'depreciation' => (($asset->model) && ($asset->model->depreciation)) ?  e($asset->model->depreciation->name) : null,\n            \n\n        \n        ];\n\n        return $array;\n    }\n\n    public function transformAssetsDatatable($assets)\n    {\n        return (new DatatablesTransformer)->transformDatatables($assets);\n    }\n\n\n   \n}\n"], "fixing_code": ["<?php\nnamespace App\\Http\\Transformers;\n\nuse App\\Helpers\\Helper;\nuse App\\Models\\Asset;\nuse Illuminate\\Database\\Eloquent\\Collection;\n\n/**\n *  This tranformer looks like it's extraneous, since we return as much or more\n * info in the AssetsTransformer, but we want to flatten these results out so that they \n * don't dislose more information than we want. Folks with depreciation powers don't necessaily \n * have the right to see additional info, and inspecting the API call here could disclose \n * info they're not supposed to see.\n * \n * @author [A. Gianotto] [<snipe@snipe.net>]\n * @since [v5.2.0]\n */\nclass DepreciationReportTransformer\n{\n    public function transformAssets(Collection $assets, $total)\n    {\n        $array = array();\n        foreach ($assets as $asset) {\n            $array[] = self::transformAsset($asset);\n        }\n        return (new DatatablesTransformer)->transformDatatables($array, $total);\n    }\n\n\n    public function transformAsset(Asset $asset)\n    {\n\n        /**\n         * Set some default values here\n         */\n        $purchase_cost = null;\n        $depreciated_value = null;\n        $monthly_depreciation = null;\n        $diff = null;\n        $checkout_target = null;\n\n        /**\n         * If there is a location set and a currency set, use that for display\n         */\n        if ($asset->location && $asset->location->currency) {\n            $purchase_cost_currency = $asset->location->currency;\n        } else {\n            $purchase_cost_currency = \\App\\Models\\Setting::getSettings()->default_currency;\n        }\n\n        /**\n         * If there is a NOT an empty purchase cost (meaning not null or '' but it *could* be zero),\n         * format the purchase cost. We coould do this inline in the transformer, but we need that value \n         * for the other calculations that come after, like diff, etc.\n         */\n        if ($asset->purchase_cost!='') {\n            $purchase_cost = $asset->purchase_cost;\n        }\n       \n\n        /**\n         * Override the previously set null values if there is a valid model and associated depreciation\n         */\n        if (($asset->model) && ($asset->model->depreciation)) {\n            $depreciated_value = \\App\\Helpers\\Helper::formatCurrencyOutput($asset->getDepreciatedValue());\n            $monthly_depreciation = \\App\\Helpers\\Helper::formatCurrencyOutput(($asset->model->eol > 0 ? ($asset->purchase_cost / $asset->model->eol) : 0));\n            $diff = \\App\\Helpers\\Helper::formatCurrencyOutput(($asset->purchase_cost - $asset->getDepreciatedValue()));\n        }\n\n        if ($asset->assigned) {\n            $checkout_target = $asset->assigned->name;\n            if ($asset->checkedOutToUser()) {\n                $checkout_target = $asset->assigned->getFullNameAttribute();\n            } \n\n        }\n                   \n        $array = [\n    \n            'company' => ($asset->company) ? e($asset->company->name) : null,\n            'name' => e($asset->name),\n            'asset_tag' => e($asset->asset_tag),\n            'serial' => e($asset->serial),\n            'model' => ($asset->model) ?  e($asset->model->name) : null,\n            'model_number' => (($asset->model) && ($asset->model->model_number)) ? e($asset->model->model_number) : null,\n            'eol' => ($asset->purchase_date!='') ? Helper::getFormattedDateObject($asset->present()->eol_date(), 'date') : null ,\n            'status_label' => ($asset->assetstatus) ? e($asset->assetstatus->name) : null,\n            'status' => ($asset->assetstatus) ?  e($asset->present()->statusMeta) : null,\n            'category' => (($asset->model) && ($asset->model->category)) ? e($asset->model->category->name) : null,\n            'manufacturer' => (($asset->model) && ($asset->model->manufacturer)) ? e($asset->model->manufacturer->name) : null,\n            'supplier' => ($asset->supplier) ? e($asset->supplier->name) : null,\n            'notes' => ($asset->notes) ? e($asset->notes) : null,\n            'order_number' => ($asset->order_number) ? e($asset->order_number) : null,\n            'location' => ($asset->location) ? e($asset->location->name) : null,\n            'warranty_expires' => ($asset->warranty_months > 0) ?  Helper::getFormattedDateObject($asset->warranty_expires, 'date') : null,\n            'currency' => $purchase_cost_currency,\n            'purchase_date' => Helper::getFormattedDateObject($asset->purchase_date, 'date'),\n            'purchase_cost' => Helper::formatCurrencyOutput($asset->purchase_cost),\n            'book_value' => Helper::formatCurrencyOutput($depreciated_value),\n            'monthly_depreciation' => $monthly_depreciation,\n            'checked_out_to' => ($checkout_target) ? e($checkout_target) : null,\n            'diff' =>  Helper::formatCurrencyOutput($diff),\n            'number_of_months' =>  ($asset->model && $asset->model->depreciation) ? e($asset->model->depreciation->months) : null,\n            'depreciation' => (($asset->model) && ($asset->model->depreciation)) ?  e($asset->model->depreciation->name) : null,\n            \n\n        \n        ];\n\n        return $array;\n    }\n\n    public function transformAssetsDatatable($assets)\n    {\n        return (new DatatablesTransformer)->transformDatatables($assets);\n    }\n\n\n   \n}\n"], "filenames": ["app/Http/Transformers/DepreciationReportTransformer.php"], "buggy_code_start_loc": [101], "buggy_code_end_loc": [102], "fixing_code_start_loc": [101], "fixing_code_end_loc": [102], "type": "CWE-79", "message": "Stored Cross Site Scripting vulnerability in the checked_out_to parameter in GitHub repository snipe/snipe-it prior to 5.4.3. The vulnerability is capable of stolen the user Cookie.", "other": {"cve": {"id": "CVE-2022-1445", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-24T15:15:07.817", "lastModified": "2022-05-03T17:23:15.280", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stored Cross Site Scripting vulnerability in the checked_out_to parameter in GitHub repository snipe/snipe-it prior to 5.4.3. The vulnerability is capable of stolen the user Cookie."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross Site Scripting almacenada en el par\u00e1metro checked_out_to del repositorio GitHub snipe/snipe-it versiones anteriores a 5.4.3. La vulnerabilidad es capaz de robar la Cookie del usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:snipeitapp:snipe-it:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.4.3", "matchCriteriaId": "098A2F0C-2F28-4EC7-B1DE-018D56BA8286"}]}]}], "references": [{"url": "https://github.com/snipe/snipe-it/commit/f623d05d0c3487ae24c4f13907e4709484e5bf41", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f4420149-5236-4051-a458-5d4f1d5b7abd", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/snipe/snipe-it/commit/f623d05d0c3487ae24c4f13907e4709484e5bf41"}}