{"buggy_code": ["/*\n *   ALSA sequencer Timing queue handling\n *   Copyright (c) 1998-1999 by Frank van de Pol <fvdpol@coil.demon.nl>\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n * MAJOR CHANGES\n *   Nov. 13, 1999\tTakashi Iwai <iwai@ww.uni-erlangen.de>\n *     - Queues are allocated dynamically via ioctl.\n *     - When owner client is deleted, all owned queues are deleted, too.\n *     - Owner of unlocked queue is kept unmodified even if it is\n *\t manipulated by other clients.\n *     - Owner field in SET_QUEUE_OWNER ioctl must be identical with the\n *       caller client.  i.e. Changing owner to a third client is not\n *       allowed.\n *\n *  Aug. 30, 2000\tTakashi Iwai\n *     - Queues are managed in static array again, but with better way.\n *       The API itself is identical.\n *     - The queue is locked when struct snd_seq_queue pointer is returned via\n *       queueptr().  This pointer *MUST* be released afterward by\n *       queuefree(ptr).\n *     - Addition of experimental sync support.\n */\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n\n#include \"seq_memory.h\"\n#include \"seq_queue.h\"\n#include \"seq_clientmgr.h\"\n#include \"seq_fifo.h\"\n#include \"seq_timer.h\"\n#include \"seq_info.h\"\n\n/* list of allocated queues */\nstatic struct snd_seq_queue *queue_list[SNDRV_SEQ_MAX_QUEUES];\nstatic DEFINE_SPINLOCK(queue_list_lock);\n/* number of queues allocated */\nstatic int num_queues;\n\nint snd_seq_queue_get_cur_queues(void)\n{\n\treturn num_queues;\n}\n\n/*----------------------------------------------------------------*/\n\n/* assign queue id and insert to list */\nstatic int queue_list_add(struct snd_seq_queue *q)\n{\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif (! queue_list[i]) {\n\t\t\tqueue_list[i] = q;\n\t\t\tq->queue = i;\n\t\t\tnum_queues++;\n\t\t\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\t\t\treturn i;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn -1;\n}\n\nstatic struct snd_seq_queue *queue_list_remove(int id, int client)\n{\n\tstruct snd_seq_queue *q;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tq = queue_list[id];\n\tif (q) {\n\t\tspin_lock(&q->owner_lock);\n\t\tif (q->owner == client) {\n\t\t\t/* found */\n\t\t\tq->klocked = 1;\n\t\t\tspin_unlock(&q->owner_lock);\n\t\t\tqueue_list[id] = NULL;\n\t\t\tnum_queues--;\n\t\t\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\t\t\treturn q;\n\t\t}\n\t\tspin_unlock(&q->owner_lock);\n\t}\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn NULL;\n}\n\n/*----------------------------------------------------------------*/\n\n/* create new queue (constructor) */\nstatic struct snd_seq_queue *queue_new(int owner, int locked)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\n\tspin_lock_init(&q->owner_lock);\n\tspin_lock_init(&q->check_lock);\n\tmutex_init(&q->timer_mutex);\n\tsnd_use_lock_init(&q->use_lock);\n\tq->queue = -1;\n\n\tq->tickq = snd_seq_prioq_new();\n\tq->timeq = snd_seq_prioq_new();\n\tq->timer = snd_seq_timer_new();\n\tif (q->tickq == NULL || q->timeq == NULL || q->timer == NULL) {\n\t\tsnd_seq_prioq_delete(&q->tickq);\n\t\tsnd_seq_prioq_delete(&q->timeq);\n\t\tsnd_seq_timer_delete(&q->timer);\n\t\tkfree(q);\n\t\treturn NULL;\n\t}\n\n\tq->owner = owner;\n\tq->locked = locked;\n\tq->klocked = 0;\n\n\treturn q;\n}\n\n/* delete queue (destructor) */\nstatic void queue_delete(struct snd_seq_queue *q)\n{\n\t/* stop and release the timer */\n\tsnd_seq_timer_stop(q->timer);\n\tsnd_seq_timer_close(q);\n\t/* wait until access free */\n\tsnd_use_lock_sync(&q->use_lock);\n\t/* release resources... */\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\n\tkfree(q);\n}\n\n\n/*----------------------------------------------------------------*/\n\n/* setup queues */\nint __init snd_seq_queues_init(void)\n{\n\t/*\n\tmemset(queue_list, 0, sizeof(queue_list));\n\tnum_queues = 0;\n\t*/\n\treturn 0;\n}\n\n/* delete all existing queues */\nvoid __exit snd_seq_queues_delete(void)\n{\n\tint i;\n\n\t/* clear list */\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif (queue_list[i])\n\t\t\tqueue_delete(queue_list[i]);\n\t}\n}\n\n/* allocate a new queue -\n * return queue index value or negative value for error\n */\nint snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = queue_new(client, locked);\n\tif (q == NULL)\n\t\treturn -ENOMEM;\n\tq->info_flags = info_flags;\n\tif (queue_list_add(q) < 0) {\n\t\tqueue_delete(q);\n\t\treturn -ENOMEM;\n\t}\n\tsnd_seq_queue_use(q->queue, client, 1); /* use this queue */\n\treturn q->queue;\n}\n\n/* delete a queue - queue must be owned by the client */\nint snd_seq_queue_delete(int client, int queueid)\n{\n\tstruct snd_seq_queue *q;\n\n\tif (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)\n\t\treturn -EINVAL;\n\tq = queue_list_remove(queueid, client);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tqueue_delete(q);\n\n\treturn 0;\n}\n\n\n/* return pointer to queue structure for specified id */\nstruct snd_seq_queue *queueptr(int queueid)\n{\n\tstruct snd_seq_queue *q;\n\tunsigned long flags;\n\n\tif (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)\n\t\treturn NULL;\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tq = queue_list[queueid];\n\tif (q)\n\t\tsnd_use_lock_use(&q->use_lock);\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn q;\n}\n\n/* return the (first) queue matching with the specified name */\nstruct snd_seq_queue *snd_seq_queue_find_name(char *name)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) != NULL) {\n\t\t\tif (strncmp(q->name, name, sizeof(q->name)) == 0)\n\t\t\t\treturn q;\n\t\t\tqueuefree(q);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\n/* -------------------------------------------------------- */\n\nvoid snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop)\n{\n\tunsigned long flags;\n\tstruct snd_seq_event_cell *cell;\n\n\tif (q == NULL)\n\t\treturn;\n\n\t/* make this function non-reentrant */\n\tspin_lock_irqsave(&q->check_lock, flags);\n\tif (q->check_blocked) {\n\t\tq->check_again = 1;\n\t\tspin_unlock_irqrestore(&q->check_lock, flags);\n\t\treturn;\t\t/* other thread is already checking queues */\n\t}\n\tq->check_blocked = 1;\n\tspin_unlock_irqrestore(&q->check_lock, flags);\n\n      __again:\n\t/* Process tick queue... */\n\twhile ((cell = snd_seq_prioq_cell_peek(q->tickq)) != NULL) {\n\t\tif (snd_seq_compare_tick_time(&q->timer->tick.cur_tick,\n\t\t\t\t\t      &cell->event.time.tick)) {\n\t\t\tcell = snd_seq_prioq_cell_out(q->tickq);\n\t\t\tif (cell)\n\t\t\t\tsnd_seq_dispatch_event(cell, atomic, hop);\n\t\t} else {\n\t\t\t/* event remains in the queue */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/* Process time queue... */\n\twhile ((cell = snd_seq_prioq_cell_peek(q->timeq)) != NULL) {\n\t\tif (snd_seq_compare_real_time(&q->timer->cur_time,\n\t\t\t\t\t      &cell->event.time.time)) {\n\t\t\tcell = snd_seq_prioq_cell_out(q->timeq);\n\t\t\tif (cell)\n\t\t\t\tsnd_seq_dispatch_event(cell, atomic, hop);\n\t\t} else {\n\t\t\t/* event remains in the queue */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* free lock */\n\tspin_lock_irqsave(&q->check_lock, flags);\n\tif (q->check_again) {\n\t\tq->check_again = 0;\n\t\tspin_unlock_irqrestore(&q->check_lock, flags);\n\t\tgoto __again;\n\t}\n\tq->check_blocked = 0;\n\tspin_unlock_irqrestore(&q->check_lock, flags);\n}\n\n\n/* enqueue a event to singe queue */\nint snd_seq_enqueue_event(struct snd_seq_event_cell *cell, int atomic, int hop)\n{\n\tint dest, err;\n\tstruct snd_seq_queue *q;\n\n\tif (snd_BUG_ON(!cell))\n\t\treturn -EINVAL;\n\tdest = cell->event.queue;\t/* destination queue */\n\tq = queueptr(dest);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\t/* handle relative time stamps, convert them into absolute */\n\tif ((cell->event.flags & SNDRV_SEQ_TIME_MODE_MASK) == SNDRV_SEQ_TIME_MODE_REL) {\n\t\tswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\t\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\t\tcell->event.time.tick += q->timer->tick.cur_tick;\n\t\t\tbreak;\n\n\t\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\t\t\tsnd_seq_inc_real_time(&cell->event.time.time,\n\t\t\t\t\t      &q->timer->cur_time);\n\t\t\tbreak;\n\t\t}\n\t\tcell->event.flags &= ~SNDRV_SEQ_TIME_MODE_MASK;\n\t\tcell->event.flags |= SNDRV_SEQ_TIME_MODE_ABS;\n\t}\n\t/* enqueue event in the real-time or midi queue */\n\tswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\terr = snd_seq_prioq_cell_in(q->tickq, cell);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\tdefault:\n\t\terr = snd_seq_prioq_cell_in(q->timeq, cell);\n\t\tbreak;\n\t}\n\n\tif (err < 0) {\n\t\tqueuefree(q); /* unlock */\n\t\treturn err;\n\t}\n\n\t/* trigger dispatching */\n\tsnd_seq_check_queue(q, atomic, hop);\n\n\tqueuefree(q); /* unlock */\n\n\treturn 0;\n}\n\n\n/*----------------------------------------------------------------*/\n\nstatic inline int check_access(struct snd_seq_queue *q, int client)\n{\n\treturn (q->owner == client) || (!q->locked && !q->klocked);\n}\n\n/* check if the client has permission to modify queue parameters.\n * if it does, lock the queue\n */\nstatic int queue_access_lock(struct snd_seq_queue *q, int client)\n{\n\tunsigned long flags;\n\tint access_ok;\n\t\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\taccess_ok = check_access(q, client);\n\tif (access_ok)\n\t\tq->klocked = 1;\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\treturn access_ok;\n}\n\n/* unlock the queue */\nstatic inline void queue_access_unlock(struct snd_seq_queue *q)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\tq->klocked = 0;\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n}\n\n/* exported - only checking permission */\nint snd_seq_queue_check_access(int queueid, int client)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\tint access_ok;\n\tunsigned long flags;\n\n\tif (! q)\n\t\treturn 0;\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\taccess_ok = check_access(q, client);\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\tqueuefree(q);\n\treturn access_ok;\n}\n\n/*----------------------------------------------------------------*/\n\n/*\n * change queue's owner and permission\n */\nint snd_seq_queue_set_owner(int queueid, int client, int locked)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tif (! queue_access_lock(q, client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tq->locked = locked ? 1 : 0;\n\tq->owner = client;\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n\n/*----------------------------------------------------------------*/\n\n/* open timer -\n * q->use mutex should be down before calling this function to avoid\n * confliction with snd_seq_queue_use()\n */\nint snd_seq_queue_timer_open(int queueid)\n{\n\tint result = 0;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\ttmr = queue->timer;\n\tif ((result = snd_seq_timer_open(queue)) < 0) {\n\t\tsnd_seq_timer_defaults(tmr);\n\t\tresult = snd_seq_timer_open(queue);\n\t}\n\tqueuefree(queue);\n\treturn result;\n}\n\n/* close timer -\n * q->use mutex should be down before calling this function\n */\nint snd_seq_queue_timer_close(int queueid)\n{\n\tstruct snd_seq_queue *queue;\n\tint result = 0;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tsnd_seq_timer_close(queue);\n\tqueuefree(queue);\n\treturn result;\n}\n\n/* change queue tempo and ppq */\nint snd_seq_queue_timer_set_tempo(int queueid, int client,\n\t\t\t\t  struct snd_seq_queue_tempo *info)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\tint result;\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tif (! queue_access_lock(q, client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tresult = snd_seq_timer_set_tempo(q->timer, info->tempo);\n\tif (result >= 0)\n\t\tresult = snd_seq_timer_set_ppq(q->timer, info->ppq);\n\tif (result >= 0 && info->skew_base > 0)\n\t\tresult = snd_seq_timer_set_skew(q->timer, info->skew_value,\n\t\t\t\t\t\tinfo->skew_base);\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\treturn result;\n}\n\n\n/* use or unuse this queue -\n * if it is the first client, starts the timer.\n * if it is not longer used by any clients, stop the timer.\n */\nint snd_seq_queue_use(int queueid, int client, int use)\n{\n\tstruct snd_seq_queue *queue;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmutex_lock(&queue->timer_mutex);\n\tif (use) {\n\t\tif (!test_and_set_bit(client, queue->clients_bitmap))\n\t\t\tqueue->clients++;\n\t} else {\n\t\tif (test_and_clear_bit(client, queue->clients_bitmap))\n\t\t\tqueue->clients--;\n\t}\n\tif (queue->clients) {\n\t\tif (use && queue->clients == 1)\n\t\t\tsnd_seq_timer_defaults(queue->timer);\n\t\tsnd_seq_timer_open(queue);\n\t} else {\n\t\tsnd_seq_timer_close(queue);\n\t}\n\tmutex_unlock(&queue->timer_mutex);\n\tqueuefree(queue);\n\treturn 0;\n}\n\n/*\n * check if queue is used by the client\n * return negative value if the queue is invalid.\n * return 0 if not used, 1 if used.\n */\nint snd_seq_queue_is_used(int queueid, int client)\n{\n\tstruct snd_seq_queue *q;\n\tint result;\n\n\tq = queueptr(queueid);\n\tif (q == NULL)\n\t\treturn -EINVAL; /* invalid queue */\n\tresult = test_bit(client, q->clients_bitmap) ? 1 : 0;\n\tqueuefree(q);\n\treturn result;\n}\n\n\n/*----------------------------------------------------------------*/\n\n/* notification that client has left the system -\n * stop the timer on all queues owned by this client\n */\nvoid snd_seq_queue_client_termination(int client)\n{\n\tunsigned long flags;\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&q->owner_lock, flags);\n\t\tif (q->owner == client)\n\t\t\tq->klocked = 1;\n\t\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\t\tif (q->owner == client) {\n\t\t\tif (q->timer->running)\n\t\t\t\tsnd_seq_timer_stop(q->timer);\n\t\t\tsnd_seq_timer_reset(q->timer);\n\t\t}\n\t\tqueuefree(q);\n\t}\n}\n\n/* final stage notification -\n * remove cells for no longer exist client (for non-owned queue)\n * or delete this queue (for owned queue)\n */\nvoid snd_seq_queue_client_leave(int client)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\t/* delete own queues from queue list */\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queue_list_remove(i, client)) != NULL)\n\t\t\tqueue_delete(q);\n\t}\n\n\t/* remove cells from existing queues -\n\t * they are not owned by this client\n\t */\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\t\tif (test_bit(client, q->clients_bitmap)) {\n\t\t\tsnd_seq_prioq_leave(q->tickq, client, 0);\n\t\t\tsnd_seq_prioq_leave(q->timeq, client, 0);\n\t\t\tsnd_seq_queue_use(q->queue, client, 0);\n\t\t}\n\t\tqueuefree(q);\n\t}\n}\n\n\n\n/*----------------------------------------------------------------*/\n\n/* remove cells from all queues */\nvoid snd_seq_queue_client_leave_cells(int client)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\t\tsnd_seq_prioq_leave(q->tickq, client, 0);\n\t\tsnd_seq_prioq_leave(q->timeq, client, 0);\n\t\tqueuefree(q);\n\t}\n}\n\n/* remove cells based on flush criteria */\nvoid snd_seq_queue_remove_cells(int client, struct snd_seq_remove_events *info)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\t\tif (test_bit(client, q->clients_bitmap) &&\n\t\t    (! (info->remove_mode & SNDRV_SEQ_REMOVE_DEST) ||\n\t\t     q->queue == info->queue)) {\n\t\t\tsnd_seq_prioq_remove_events(q->tickq, client, info);\n\t\t\tsnd_seq_prioq_remove_events(q->timeq, client, info);\n\t\t}\n\t\tqueuefree(q);\n\t}\n}\n\n/*----------------------------------------------------------------*/\n\n/*\n * send events to all subscribed ports\n */\nstatic void queue_broadcast_event(struct snd_seq_queue *q, struct snd_seq_event *ev,\n\t\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_event sev;\n\n\tsev = *ev;\n\t\n\tsev.flags = SNDRV_SEQ_TIME_STAMP_TICK|SNDRV_SEQ_TIME_MODE_ABS;\n\tsev.time.tick = q->timer->tick.cur_tick;\n\tsev.queue = q->queue;\n\tsev.data.queue.queue = q->queue;\n\n\t/* broadcast events from Timer port */\n\tsev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;\n\tsev.source.port = SNDRV_SEQ_PORT_SYSTEM_TIMER;\n\tsev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\tsnd_seq_kernel_client_dispatch(SNDRV_SEQ_CLIENT_SYSTEM, &sev, atomic, hop);\n}\n\n/*\n * process a received queue-control event.\n * this function is exported for seq_sync.c.\n */\nstatic void snd_seq_queue_process_event(struct snd_seq_queue *q,\n\t\t\t\t\tstruct snd_seq_event *ev,\n\t\t\t\t\tint atomic, int hop)\n{\n\tswitch (ev->type) {\n\tcase SNDRV_SEQ_EVENT_START:\n\t\tsnd_seq_prioq_leave(q->tickq, ev->source.client, 1);\n\t\tsnd_seq_prioq_leave(q->timeq, ev->source.client, 1);\n\t\tif (! snd_seq_timer_start(q->timer))\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_CONTINUE:\n\t\tif (! snd_seq_timer_continue(q->timer))\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_STOP:\n\t\tsnd_seq_timer_stop(q->timer);\n\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_TEMPO:\n\t\tsnd_seq_timer_set_tempo(q->timer, ev->data.queue.param.value);\n\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_SETPOS_TICK:\n\t\tif (snd_seq_timer_set_position_tick(q->timer, ev->data.queue.param.time.tick) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_SETPOS_TIME:\n\t\tif (snd_seq_timer_set_position_time(q->timer, ev->data.queue.param.time.time) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_QUEUE_SKEW:\n\t\tif (snd_seq_timer_set_skew(q->timer,\n\t\t\t\t\t   ev->data.queue.param.skew.value,\n\t\t\t\t\t   ev->data.queue.param.skew.base) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\n/*\n * Queue control via timer control port:\n * this function is exported as a callback of timer port.\n */\nint snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop)\n{\n\tstruct snd_seq_queue *q;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\tq = queueptr(ev->data.queue.queue);\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tif (! queue_access_lock(q, ev->source.client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tsnd_seq_queue_process_event(q, ev, atomic, hop);\n\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\treturn 0;\n}\n\n\n/*----------------------------------------------------------------*/\n\n#ifdef CONFIG_SND_PROC_FS\n/* exported to seq_info.c */\nvoid snd_seq_info_queues_read(struct snd_info_entry *entry, \n\t\t\t      struct snd_info_buffer *buffer)\n{\n\tint i, bpm;\n\tstruct snd_seq_queue *q;\n\tstruct snd_seq_timer *tmr;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\n\t\ttmr = q->timer;\n\t\tif (tmr->tempo)\n\t\t\tbpm = 60000000 / tmr->tempo;\n\t\telse\n\t\t\tbpm = 0;\n\n\t\tsnd_iprintf(buffer, \"queue %d: [%s]\\n\", q->queue, q->name);\n\t\tsnd_iprintf(buffer, \"owned by client    : %d\\n\", q->owner);\n\t\tsnd_iprintf(buffer, \"lock status        : %s\\n\", q->locked ? \"Locked\" : \"Free\");\n\t\tsnd_iprintf(buffer, \"queued time events : %d\\n\", snd_seq_prioq_avail(q->timeq));\n\t\tsnd_iprintf(buffer, \"queued tick events : %d\\n\", snd_seq_prioq_avail(q->tickq));\n\t\tsnd_iprintf(buffer, \"timer state        : %s\\n\", tmr->running ? \"Running\" : \"Stopped\");\n\t\tsnd_iprintf(buffer, \"timer PPQ          : %d\\n\", tmr->ppq);\n\t\tsnd_iprintf(buffer, \"current tempo      : %d\\n\", tmr->tempo);\n\t\tsnd_iprintf(buffer, \"current BPM        : %d\\n\", bpm);\n\t\tsnd_iprintf(buffer, \"current time       : %d.%09d s\\n\", tmr->cur_time.tv_sec, tmr->cur_time.tv_nsec);\n\t\tsnd_iprintf(buffer, \"current tick       : %d\\n\", tmr->tick.cur_tick);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tqueuefree(q);\n\t}\n}\n#endif /* CONFIG_SND_PROC_FS */\n\n"], "fixing_code": ["/*\n *   ALSA sequencer Timing queue handling\n *   Copyright (c) 1998-1999 by Frank van de Pol <fvdpol@coil.demon.nl>\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n * MAJOR CHANGES\n *   Nov. 13, 1999\tTakashi Iwai <iwai@ww.uni-erlangen.de>\n *     - Queues are allocated dynamically via ioctl.\n *     - When owner client is deleted, all owned queues are deleted, too.\n *     - Owner of unlocked queue is kept unmodified even if it is\n *\t manipulated by other clients.\n *     - Owner field in SET_QUEUE_OWNER ioctl must be identical with the\n *       caller client.  i.e. Changing owner to a third client is not\n *       allowed.\n *\n *  Aug. 30, 2000\tTakashi Iwai\n *     - Queues are managed in static array again, but with better way.\n *       The API itself is identical.\n *     - The queue is locked when struct snd_seq_queue pointer is returned via\n *       queueptr().  This pointer *MUST* be released afterward by\n *       queuefree(ptr).\n *     - Addition of experimental sync support.\n */\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n\n#include \"seq_memory.h\"\n#include \"seq_queue.h\"\n#include \"seq_clientmgr.h\"\n#include \"seq_fifo.h\"\n#include \"seq_timer.h\"\n#include \"seq_info.h\"\n\n/* list of allocated queues */\nstatic struct snd_seq_queue *queue_list[SNDRV_SEQ_MAX_QUEUES];\nstatic DEFINE_SPINLOCK(queue_list_lock);\n/* number of queues allocated */\nstatic int num_queues;\n\nint snd_seq_queue_get_cur_queues(void)\n{\n\treturn num_queues;\n}\n\n/*----------------------------------------------------------------*/\n\n/* assign queue id and insert to list */\nstatic int queue_list_add(struct snd_seq_queue *q)\n{\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif (! queue_list[i]) {\n\t\t\tqueue_list[i] = q;\n\t\t\tq->queue = i;\n\t\t\tnum_queues++;\n\t\t\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\t\t\treturn i;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn -1;\n}\n\nstatic struct snd_seq_queue *queue_list_remove(int id, int client)\n{\n\tstruct snd_seq_queue *q;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tq = queue_list[id];\n\tif (q) {\n\t\tspin_lock(&q->owner_lock);\n\t\tif (q->owner == client) {\n\t\t\t/* found */\n\t\t\tq->klocked = 1;\n\t\t\tspin_unlock(&q->owner_lock);\n\t\t\tqueue_list[id] = NULL;\n\t\t\tnum_queues--;\n\t\t\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\t\t\treturn q;\n\t\t}\n\t\tspin_unlock(&q->owner_lock);\n\t}\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn NULL;\n}\n\n/*----------------------------------------------------------------*/\n\n/* create new queue (constructor) */\nstatic struct snd_seq_queue *queue_new(int owner, int locked)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\n\tspin_lock_init(&q->owner_lock);\n\tspin_lock_init(&q->check_lock);\n\tmutex_init(&q->timer_mutex);\n\tsnd_use_lock_init(&q->use_lock);\n\tq->queue = -1;\n\n\tq->tickq = snd_seq_prioq_new();\n\tq->timeq = snd_seq_prioq_new();\n\tq->timer = snd_seq_timer_new();\n\tif (q->tickq == NULL || q->timeq == NULL || q->timer == NULL) {\n\t\tsnd_seq_prioq_delete(&q->tickq);\n\t\tsnd_seq_prioq_delete(&q->timeq);\n\t\tsnd_seq_timer_delete(&q->timer);\n\t\tkfree(q);\n\t\treturn NULL;\n\t}\n\n\tq->owner = owner;\n\tq->locked = locked;\n\tq->klocked = 0;\n\n\treturn q;\n}\n\n/* delete queue (destructor) */\nstatic void queue_delete(struct snd_seq_queue *q)\n{\n\t/* stop and release the timer */\n\tmutex_lock(&q->timer_mutex);\n\tsnd_seq_timer_stop(q->timer);\n\tsnd_seq_timer_close(q);\n\tmutex_unlock(&q->timer_mutex);\n\t/* wait until access free */\n\tsnd_use_lock_sync(&q->use_lock);\n\t/* release resources... */\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\n\tkfree(q);\n}\n\n\n/*----------------------------------------------------------------*/\n\n/* setup queues */\nint __init snd_seq_queues_init(void)\n{\n\t/*\n\tmemset(queue_list, 0, sizeof(queue_list));\n\tnum_queues = 0;\n\t*/\n\treturn 0;\n}\n\n/* delete all existing queues */\nvoid __exit snd_seq_queues_delete(void)\n{\n\tint i;\n\n\t/* clear list */\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif (queue_list[i])\n\t\t\tqueue_delete(queue_list[i]);\n\t}\n}\n\n/* allocate a new queue -\n * return queue index value or negative value for error\n */\nint snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = queue_new(client, locked);\n\tif (q == NULL)\n\t\treturn -ENOMEM;\n\tq->info_flags = info_flags;\n\tif (queue_list_add(q) < 0) {\n\t\tqueue_delete(q);\n\t\treturn -ENOMEM;\n\t}\n\tsnd_seq_queue_use(q->queue, client, 1); /* use this queue */\n\treturn q->queue;\n}\n\n/* delete a queue - queue must be owned by the client */\nint snd_seq_queue_delete(int client, int queueid)\n{\n\tstruct snd_seq_queue *q;\n\n\tif (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)\n\t\treturn -EINVAL;\n\tq = queue_list_remove(queueid, client);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tqueue_delete(q);\n\n\treturn 0;\n}\n\n\n/* return pointer to queue structure for specified id */\nstruct snd_seq_queue *queueptr(int queueid)\n{\n\tstruct snd_seq_queue *q;\n\tunsigned long flags;\n\n\tif (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)\n\t\treturn NULL;\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tq = queue_list[queueid];\n\tif (q)\n\t\tsnd_use_lock_use(&q->use_lock);\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn q;\n}\n\n/* return the (first) queue matching with the specified name */\nstruct snd_seq_queue *snd_seq_queue_find_name(char *name)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) != NULL) {\n\t\t\tif (strncmp(q->name, name, sizeof(q->name)) == 0)\n\t\t\t\treturn q;\n\t\t\tqueuefree(q);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\n/* -------------------------------------------------------- */\n\nvoid snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop)\n{\n\tunsigned long flags;\n\tstruct snd_seq_event_cell *cell;\n\n\tif (q == NULL)\n\t\treturn;\n\n\t/* make this function non-reentrant */\n\tspin_lock_irqsave(&q->check_lock, flags);\n\tif (q->check_blocked) {\n\t\tq->check_again = 1;\n\t\tspin_unlock_irqrestore(&q->check_lock, flags);\n\t\treturn;\t\t/* other thread is already checking queues */\n\t}\n\tq->check_blocked = 1;\n\tspin_unlock_irqrestore(&q->check_lock, flags);\n\n      __again:\n\t/* Process tick queue... */\n\twhile ((cell = snd_seq_prioq_cell_peek(q->tickq)) != NULL) {\n\t\tif (snd_seq_compare_tick_time(&q->timer->tick.cur_tick,\n\t\t\t\t\t      &cell->event.time.tick)) {\n\t\t\tcell = snd_seq_prioq_cell_out(q->tickq);\n\t\t\tif (cell)\n\t\t\t\tsnd_seq_dispatch_event(cell, atomic, hop);\n\t\t} else {\n\t\t\t/* event remains in the queue */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/* Process time queue... */\n\twhile ((cell = snd_seq_prioq_cell_peek(q->timeq)) != NULL) {\n\t\tif (snd_seq_compare_real_time(&q->timer->cur_time,\n\t\t\t\t\t      &cell->event.time.time)) {\n\t\t\tcell = snd_seq_prioq_cell_out(q->timeq);\n\t\t\tif (cell)\n\t\t\t\tsnd_seq_dispatch_event(cell, atomic, hop);\n\t\t} else {\n\t\t\t/* event remains in the queue */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* free lock */\n\tspin_lock_irqsave(&q->check_lock, flags);\n\tif (q->check_again) {\n\t\tq->check_again = 0;\n\t\tspin_unlock_irqrestore(&q->check_lock, flags);\n\t\tgoto __again;\n\t}\n\tq->check_blocked = 0;\n\tspin_unlock_irqrestore(&q->check_lock, flags);\n}\n\n\n/* enqueue a event to singe queue */\nint snd_seq_enqueue_event(struct snd_seq_event_cell *cell, int atomic, int hop)\n{\n\tint dest, err;\n\tstruct snd_seq_queue *q;\n\n\tif (snd_BUG_ON(!cell))\n\t\treturn -EINVAL;\n\tdest = cell->event.queue;\t/* destination queue */\n\tq = queueptr(dest);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\t/* handle relative time stamps, convert them into absolute */\n\tif ((cell->event.flags & SNDRV_SEQ_TIME_MODE_MASK) == SNDRV_SEQ_TIME_MODE_REL) {\n\t\tswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\t\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\t\tcell->event.time.tick += q->timer->tick.cur_tick;\n\t\t\tbreak;\n\n\t\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\t\t\tsnd_seq_inc_real_time(&cell->event.time.time,\n\t\t\t\t\t      &q->timer->cur_time);\n\t\t\tbreak;\n\t\t}\n\t\tcell->event.flags &= ~SNDRV_SEQ_TIME_MODE_MASK;\n\t\tcell->event.flags |= SNDRV_SEQ_TIME_MODE_ABS;\n\t}\n\t/* enqueue event in the real-time or midi queue */\n\tswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\terr = snd_seq_prioq_cell_in(q->tickq, cell);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\tdefault:\n\t\terr = snd_seq_prioq_cell_in(q->timeq, cell);\n\t\tbreak;\n\t}\n\n\tif (err < 0) {\n\t\tqueuefree(q); /* unlock */\n\t\treturn err;\n\t}\n\n\t/* trigger dispatching */\n\tsnd_seq_check_queue(q, atomic, hop);\n\n\tqueuefree(q); /* unlock */\n\n\treturn 0;\n}\n\n\n/*----------------------------------------------------------------*/\n\nstatic inline int check_access(struct snd_seq_queue *q, int client)\n{\n\treturn (q->owner == client) || (!q->locked && !q->klocked);\n}\n\n/* check if the client has permission to modify queue parameters.\n * if it does, lock the queue\n */\nstatic int queue_access_lock(struct snd_seq_queue *q, int client)\n{\n\tunsigned long flags;\n\tint access_ok;\n\t\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\taccess_ok = check_access(q, client);\n\tif (access_ok)\n\t\tq->klocked = 1;\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\treturn access_ok;\n}\n\n/* unlock the queue */\nstatic inline void queue_access_unlock(struct snd_seq_queue *q)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\tq->klocked = 0;\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n}\n\n/* exported - only checking permission */\nint snd_seq_queue_check_access(int queueid, int client)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\tint access_ok;\n\tunsigned long flags;\n\n\tif (! q)\n\t\treturn 0;\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\taccess_ok = check_access(q, client);\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\tqueuefree(q);\n\treturn access_ok;\n}\n\n/*----------------------------------------------------------------*/\n\n/*\n * change queue's owner and permission\n */\nint snd_seq_queue_set_owner(int queueid, int client, int locked)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tif (! queue_access_lock(q, client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tq->locked = locked ? 1 : 0;\n\tq->owner = client;\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n\n/*----------------------------------------------------------------*/\n\n/* open timer -\n * q->use mutex should be down before calling this function to avoid\n * confliction with snd_seq_queue_use()\n */\nint snd_seq_queue_timer_open(int queueid)\n{\n\tint result = 0;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\ttmr = queue->timer;\n\tif ((result = snd_seq_timer_open(queue)) < 0) {\n\t\tsnd_seq_timer_defaults(tmr);\n\t\tresult = snd_seq_timer_open(queue);\n\t}\n\tqueuefree(queue);\n\treturn result;\n}\n\n/* close timer -\n * q->use mutex should be down before calling this function\n */\nint snd_seq_queue_timer_close(int queueid)\n{\n\tstruct snd_seq_queue *queue;\n\tint result = 0;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tsnd_seq_timer_close(queue);\n\tqueuefree(queue);\n\treturn result;\n}\n\n/* change queue tempo and ppq */\nint snd_seq_queue_timer_set_tempo(int queueid, int client,\n\t\t\t\t  struct snd_seq_queue_tempo *info)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\tint result;\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tif (! queue_access_lock(q, client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tresult = snd_seq_timer_set_tempo(q->timer, info->tempo);\n\tif (result >= 0)\n\t\tresult = snd_seq_timer_set_ppq(q->timer, info->ppq);\n\tif (result >= 0 && info->skew_base > 0)\n\t\tresult = snd_seq_timer_set_skew(q->timer, info->skew_value,\n\t\t\t\t\t\tinfo->skew_base);\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\treturn result;\n}\n\n\n/* use or unuse this queue -\n * if it is the first client, starts the timer.\n * if it is not longer used by any clients, stop the timer.\n */\nint snd_seq_queue_use(int queueid, int client, int use)\n{\n\tstruct snd_seq_queue *queue;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmutex_lock(&queue->timer_mutex);\n\tif (use) {\n\t\tif (!test_and_set_bit(client, queue->clients_bitmap))\n\t\t\tqueue->clients++;\n\t} else {\n\t\tif (test_and_clear_bit(client, queue->clients_bitmap))\n\t\t\tqueue->clients--;\n\t}\n\tif (queue->clients) {\n\t\tif (use && queue->clients == 1)\n\t\t\tsnd_seq_timer_defaults(queue->timer);\n\t\tsnd_seq_timer_open(queue);\n\t} else {\n\t\tsnd_seq_timer_close(queue);\n\t}\n\tmutex_unlock(&queue->timer_mutex);\n\tqueuefree(queue);\n\treturn 0;\n}\n\n/*\n * check if queue is used by the client\n * return negative value if the queue is invalid.\n * return 0 if not used, 1 if used.\n */\nint snd_seq_queue_is_used(int queueid, int client)\n{\n\tstruct snd_seq_queue *q;\n\tint result;\n\n\tq = queueptr(queueid);\n\tif (q == NULL)\n\t\treturn -EINVAL; /* invalid queue */\n\tresult = test_bit(client, q->clients_bitmap) ? 1 : 0;\n\tqueuefree(q);\n\treturn result;\n}\n\n\n/*----------------------------------------------------------------*/\n\n/* notification that client has left the system -\n * stop the timer on all queues owned by this client\n */\nvoid snd_seq_queue_client_termination(int client)\n{\n\tunsigned long flags;\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&q->owner_lock, flags);\n\t\tif (q->owner == client)\n\t\t\tq->klocked = 1;\n\t\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\t\tif (q->owner == client) {\n\t\t\tif (q->timer->running)\n\t\t\t\tsnd_seq_timer_stop(q->timer);\n\t\t\tsnd_seq_timer_reset(q->timer);\n\t\t}\n\t\tqueuefree(q);\n\t}\n}\n\n/* final stage notification -\n * remove cells for no longer exist client (for non-owned queue)\n * or delete this queue (for owned queue)\n */\nvoid snd_seq_queue_client_leave(int client)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\t/* delete own queues from queue list */\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queue_list_remove(i, client)) != NULL)\n\t\t\tqueue_delete(q);\n\t}\n\n\t/* remove cells from existing queues -\n\t * they are not owned by this client\n\t */\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\t\tif (test_bit(client, q->clients_bitmap)) {\n\t\t\tsnd_seq_prioq_leave(q->tickq, client, 0);\n\t\t\tsnd_seq_prioq_leave(q->timeq, client, 0);\n\t\t\tsnd_seq_queue_use(q->queue, client, 0);\n\t\t}\n\t\tqueuefree(q);\n\t}\n}\n\n\n\n/*----------------------------------------------------------------*/\n\n/* remove cells from all queues */\nvoid snd_seq_queue_client_leave_cells(int client)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\t\tsnd_seq_prioq_leave(q->tickq, client, 0);\n\t\tsnd_seq_prioq_leave(q->timeq, client, 0);\n\t\tqueuefree(q);\n\t}\n}\n\n/* remove cells based on flush criteria */\nvoid snd_seq_queue_remove_cells(int client, struct snd_seq_remove_events *info)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\t\tif (test_bit(client, q->clients_bitmap) &&\n\t\t    (! (info->remove_mode & SNDRV_SEQ_REMOVE_DEST) ||\n\t\t     q->queue == info->queue)) {\n\t\t\tsnd_seq_prioq_remove_events(q->tickq, client, info);\n\t\t\tsnd_seq_prioq_remove_events(q->timeq, client, info);\n\t\t}\n\t\tqueuefree(q);\n\t}\n}\n\n/*----------------------------------------------------------------*/\n\n/*\n * send events to all subscribed ports\n */\nstatic void queue_broadcast_event(struct snd_seq_queue *q, struct snd_seq_event *ev,\n\t\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_event sev;\n\n\tsev = *ev;\n\t\n\tsev.flags = SNDRV_SEQ_TIME_STAMP_TICK|SNDRV_SEQ_TIME_MODE_ABS;\n\tsev.time.tick = q->timer->tick.cur_tick;\n\tsev.queue = q->queue;\n\tsev.data.queue.queue = q->queue;\n\n\t/* broadcast events from Timer port */\n\tsev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;\n\tsev.source.port = SNDRV_SEQ_PORT_SYSTEM_TIMER;\n\tsev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\tsnd_seq_kernel_client_dispatch(SNDRV_SEQ_CLIENT_SYSTEM, &sev, atomic, hop);\n}\n\n/*\n * process a received queue-control event.\n * this function is exported for seq_sync.c.\n */\nstatic void snd_seq_queue_process_event(struct snd_seq_queue *q,\n\t\t\t\t\tstruct snd_seq_event *ev,\n\t\t\t\t\tint atomic, int hop)\n{\n\tswitch (ev->type) {\n\tcase SNDRV_SEQ_EVENT_START:\n\t\tsnd_seq_prioq_leave(q->tickq, ev->source.client, 1);\n\t\tsnd_seq_prioq_leave(q->timeq, ev->source.client, 1);\n\t\tif (! snd_seq_timer_start(q->timer))\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_CONTINUE:\n\t\tif (! snd_seq_timer_continue(q->timer))\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_STOP:\n\t\tsnd_seq_timer_stop(q->timer);\n\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_TEMPO:\n\t\tsnd_seq_timer_set_tempo(q->timer, ev->data.queue.param.value);\n\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_SETPOS_TICK:\n\t\tif (snd_seq_timer_set_position_tick(q->timer, ev->data.queue.param.time.tick) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_SETPOS_TIME:\n\t\tif (snd_seq_timer_set_position_time(q->timer, ev->data.queue.param.time.time) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_QUEUE_SKEW:\n\t\tif (snd_seq_timer_set_skew(q->timer,\n\t\t\t\t\t   ev->data.queue.param.skew.value,\n\t\t\t\t\t   ev->data.queue.param.skew.base) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\n/*\n * Queue control via timer control port:\n * this function is exported as a callback of timer port.\n */\nint snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop)\n{\n\tstruct snd_seq_queue *q;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\tq = queueptr(ev->data.queue.queue);\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tif (! queue_access_lock(q, ev->source.client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tsnd_seq_queue_process_event(q, ev, atomic, hop);\n\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\treturn 0;\n}\n\n\n/*----------------------------------------------------------------*/\n\n#ifdef CONFIG_SND_PROC_FS\n/* exported to seq_info.c */\nvoid snd_seq_info_queues_read(struct snd_info_entry *entry, \n\t\t\t      struct snd_info_buffer *buffer)\n{\n\tint i, bpm;\n\tstruct snd_seq_queue *q;\n\tstruct snd_seq_timer *tmr;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif ((q = queueptr(i)) == NULL)\n\t\t\tcontinue;\n\n\t\ttmr = q->timer;\n\t\tif (tmr->tempo)\n\t\t\tbpm = 60000000 / tmr->tempo;\n\t\telse\n\t\t\tbpm = 0;\n\n\t\tsnd_iprintf(buffer, \"queue %d: [%s]\\n\", q->queue, q->name);\n\t\tsnd_iprintf(buffer, \"owned by client    : %d\\n\", q->owner);\n\t\tsnd_iprintf(buffer, \"lock status        : %s\\n\", q->locked ? \"Locked\" : \"Free\");\n\t\tsnd_iprintf(buffer, \"queued time events : %d\\n\", snd_seq_prioq_avail(q->timeq));\n\t\tsnd_iprintf(buffer, \"queued tick events : %d\\n\", snd_seq_prioq_avail(q->tickq));\n\t\tsnd_iprintf(buffer, \"timer state        : %s\\n\", tmr->running ? \"Running\" : \"Stopped\");\n\t\tsnd_iprintf(buffer, \"timer PPQ          : %d\\n\", tmr->ppq);\n\t\tsnd_iprintf(buffer, \"current tempo      : %d\\n\", tmr->tempo);\n\t\tsnd_iprintf(buffer, \"current BPM        : %d\\n\", bpm);\n\t\tsnd_iprintf(buffer, \"current time       : %d.%09d s\\n\", tmr->cur_time.tv_sec, tmr->cur_time.tv_nsec);\n\t\tsnd_iprintf(buffer, \"current tick       : %d\\n\", tmr->tick.cur_tick);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tqueuefree(q);\n\t}\n}\n#endif /* CONFIG_SND_PROC_FS */\n\n"], "filenames": ["sound/core/seq/seq_queue.c"], "buggy_code_start_loc": [144], "buggy_code_end_loc": [146], "fixing_code_start_loc": [145], "fixing_code_end_loc": [149], "type": "CWE-362", "message": "Race condition in the queue_delete function in sound/core/seq/seq_queue.c in the Linux kernel before 4.4.1 allows local users to cause a denial of service (use-after-free and system crash) by making an ioctl call at a certain time.", "other": {"cve": {"id": "CVE-2016-2544", "sourceIdentifier": "cve@mitre.org", "published": "2016-04-27T17:59:13.897", "lastModified": "2017-09-07T01:29:02.307", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the queue_delete function in sound/core/seq/seq_queue.c in the Linux kernel before 4.4.1 allows local users to cause a denial of service (use-after-free and system crash) by making an ioctl call at a certain time."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n queue_delete en sound/core/seq/seq_queue.c en el kernel de Linux en versiones anteriores a 4.4.1 permite a usuarios locales causar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n de memoria y ca\u00edda del sistema) al realizar una llamada ioctl en un momento determinado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.4, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4", "matchCriteriaId": "8B458ACF-17C3-4551-9F11-8D02B6D52B7C"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=3567eb6af614dac436c4b16a8d426f9faed639b3", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-03/msg00094.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00045.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2016/dsa-3503", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.4.1", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/01/19/1", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/83380", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1035305", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2929-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2929-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-3", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2931-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2932-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2967-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2967-2", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1311558", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/3567eb6af614dac436c4b16a8d426f9faed639b3", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3567eb6af614dac436c4b16a8d426f9faed639b3"}}