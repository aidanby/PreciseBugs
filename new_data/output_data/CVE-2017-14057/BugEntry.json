{"buggy_code": ["/*\n * ASF compatible demuxer\n * Copyright (c) 2000, 2001 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/bswap.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"avlanguage.h\"\n#include \"id3v2.h\"\n#include \"internal.h\"\n#include \"riff.h\"\n#include \"asf.h\"\n#include \"asfcrypt.h\"\n\ntypedef struct ASFPayload {\n    uint8_t type;\n    uint16_t size;\n} ASFPayload;\n\ntypedef struct ASFStream {\n    int num;\n    unsigned char seq;\n    /* use for reading */\n    AVPacket pkt;\n    int frag_offset;\n    int packet_obj_size;\n    int timestamp;\n    int64_t duration;\n    int skip_to_key;\n    int pkt_clean;\n\n    int ds_span;                /* descrambling  */\n    int ds_packet_size;\n    int ds_chunk_size;\n\n    int64_t packet_pos;\n\n    uint16_t stream_language_index;\n\n    int      palette_changed;\n    uint32_t palette[256];\n\n    int payload_ext_ct;\n    ASFPayload payload[8];\n} ASFStream;\n\ntypedef struct ASFContext {\n    const AVClass *class;\n    int asfid2avid[128];                 ///< conversion table from asf ID 2 AVStream ID\n    ASFStream streams[128];              ///< it's max number and it's not that big\n    uint32_t stream_bitrates[128];       ///< max number of streams, bitrate for each (for streaming)\n    AVRational dar[128];\n    char stream_languages[128][6];       ///< max number of streams, language for each (RFC1766, e.g. en-US)\n    /* non streamed additonnal info */\n    /* packet filling */\n    int packet_size_left;\n    /* only for reading */\n    uint64_t data_offset;                ///< beginning of the first data packet\n    uint64_t data_object_offset;         ///< data object offset (excl. GUID & size)\n    uint64_t data_object_size;           ///< size of the data object\n    int index_read;\n\n    ASFMainHeader hdr;\n\n    int packet_flags;\n    int packet_property;\n    int packet_timestamp;\n    int packet_segsizetype;\n    int packet_segments;\n    int packet_seq;\n    int packet_replic_size;\n    int packet_key_frame;\n    int packet_padsize;\n    unsigned int packet_frag_offset;\n    unsigned int packet_frag_size;\n    int64_t packet_frag_timestamp;\n    int ts_is_pts;\n    int packet_multi_size;\n    int packet_time_delta;\n    int packet_time_start;\n    int64_t packet_pos;\n\n    int stream_index;\n\n    ASFStream *asf_st;                   ///< currently decoded stream\n\n    int no_resync_search;\n    int export_xmp;\n\n    int uses_std_ecc;\n} ASFContext;\n\nstatic const AVOption options[] = {\n    { \"no_resync_search\", \"Don't try to resynchronize by looking for a certain optional start code\", offsetof(ASFContext, no_resync_search), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, AV_OPT_FLAG_DECODING_PARAM },\n    { \"export_xmp\", \"Export full XMP metadata\", offsetof(ASFContext, export_xmp), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, AV_OPT_FLAG_DECODING_PARAM },\n    { NULL },\n};\n\nstatic const AVClass asf_class = {\n    .class_name = \"asf demuxer\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\n#undef NDEBUG\n#include <assert.h>\n\n#define ASF_MAX_STREAMS 127\n#define FRAME_HEADER_SIZE 6\n// Fix Me! FRAME_HEADER_SIZE may be different.\n// (7 is known to be too large for GipsyGuitar.wmv)\n\n#ifdef DEBUG\nstatic const ff_asf_guid stream_bitrate_guid = { /* (http://get.to/sdp) */\n    0xce, 0x75, 0xf8, 0x7b, 0x8d, 0x46, 0xd1, 0x11, 0x8d, 0x82, 0x00, 0x60, 0x97, 0xc9, 0xa2, 0xb2\n};\n\n#define PRINT_IF_GUID(g, cmp) \\\n    if (!ff_guidcmp(g, &cmp)) \\\n        av_log(NULL, AV_LOG_TRACE, \"(GUID: %s) \", # cmp)\n\nstatic void print_guid(ff_asf_guid *g)\n{\n    int i;\n    PRINT_IF_GUID(g, ff_asf_header);\n    else PRINT_IF_GUID(g, ff_asf_file_header);\n    else PRINT_IF_GUID(g, ff_asf_stream_header);\n    else PRINT_IF_GUID(g, ff_asf_audio_stream);\n    else PRINT_IF_GUID(g, ff_asf_audio_conceal_none);\n    else PRINT_IF_GUID(g, ff_asf_video_stream);\n    else PRINT_IF_GUID(g, ff_asf_video_conceal_none);\n    else PRINT_IF_GUID(g, ff_asf_command_stream);\n    else PRINT_IF_GUID(g, ff_asf_comment_header);\n    else PRINT_IF_GUID(g, ff_asf_codec_comment_header);\n    else PRINT_IF_GUID(g, ff_asf_codec_comment1_header);\n    else PRINT_IF_GUID(g, ff_asf_data_header);\n    else PRINT_IF_GUID(g, ff_asf_simple_index_header);\n    else PRINT_IF_GUID(g, ff_asf_head1_guid);\n    else PRINT_IF_GUID(g, ff_asf_head2_guid);\n    else PRINT_IF_GUID(g, ff_asf_my_guid);\n    else PRINT_IF_GUID(g, ff_asf_ext_stream_header);\n    else PRINT_IF_GUID(g, ff_asf_extended_content_header);\n    else PRINT_IF_GUID(g, ff_asf_ext_stream_embed_stream_header);\n    else PRINT_IF_GUID(g, ff_asf_ext_stream_audio_stream);\n    else PRINT_IF_GUID(g, ff_asf_metadata_header);\n    else PRINT_IF_GUID(g, ff_asf_metadata_library_header);\n    else PRINT_IF_GUID(g, ff_asf_marker_header);\n    else PRINT_IF_GUID(g, stream_bitrate_guid);\n    else PRINT_IF_GUID(g, ff_asf_language_guid);\n    else\n        av_log(NULL, AV_LOG_TRACE, \"(GUID: unknown) \");\n    for (i = 0; i < 16; i++)\n        av_log(NULL, AV_LOG_TRACE, \" 0x%02x,\", (*g)[i]);\n    av_log(NULL, AV_LOG_TRACE, \"}\\n\");\n}\n#undef PRINT_IF_GUID\n#else\n#define print_guid(g) while(0)\n#endif\n\nstatic int asf_probe(AVProbeData *pd)\n{\n    /* check file header */\n    if (!ff_guidcmp(pd->buf, &ff_asf_header))\n        return AVPROBE_SCORE_MAX;\n    else\n        return 0;\n}\n\n/* size of type 2 (BOOL) is 32bit for \"Extended Content Description Object\"\n * but 16 bit for \"Metadata Object\" and \"Metadata Library Object\" */\nstatic int get_value(AVIOContext *pb, int type, int type2_size)\n{\n    switch (type) {\n    case 2:\n        return (type2_size == 32) ? avio_rl32(pb) : avio_rl16(pb);\n    case 3:\n        return avio_rl32(pb);\n    case 4:\n        return avio_rl64(pb);\n    case 5:\n        return avio_rl16(pb);\n    default:\n        return INT_MIN;\n    }\n}\n\n/* MSDN claims that this should be \"compatible with the ID3 frame, APIC\",\n * but in reality this is only loosely similar */\nstatic int asf_read_picture(AVFormatContext *s, int len)\n{\n    AVPacket pkt          = { 0 };\n    const CodecMime *mime = ff_id3v2_mime_tags;\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n    char mimetype[64];\n    uint8_t  *desc = NULL;\n    AVStream   *st = NULL;\n    int ret, type, picsize, desc_len;\n\n    /* type + picsize + mime + desc */\n    if (len < 1 + 4 + 2 + 2) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture type */\n    type = avio_r8(s->pb);\n    len--;\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n        type = 0;\n    }\n\n    /* picture data size */\n    picsize = avio_rl32(s->pb);\n    len    -= 4;\n\n    /* picture MIME type */\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n    while (mime->id != AV_CODEC_ID_NONE) {\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n            id = mime->id;\n            break;\n        }\n        mime++;\n    }\n    if (id == AV_CODEC_ID_NONE) {\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n               mimetype);\n        return 0;\n    }\n\n    if (picsize >= len) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n               picsize, len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture description */\n    desc_len = (len - picsize) * 2 + 1;\n    desc     = av_malloc(desc_len);\n    if (!desc)\n        return AVERROR(ENOMEM);\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n    if (ret < 0)\n        goto fail;\n\n    st  = avformat_new_stream(s, NULL);\n    if (!st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n    st->codecpar->codec_type      = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id        = id;\n    st->attached_pic              = pkt;\n    st->attached_pic.stream_index = st->index;\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n    if (*desc)\n        av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_freep(&desc);\n\n    av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0);\n\n    return 0;\n\nfail:\n    av_freep(&desc);\n    av_packet_unref(&pkt);\n    return ret;\n}\n\nstatic void get_id3_tag(AVFormatContext *s, int len)\n{\n    ID3v2ExtraMeta *id3v2_extra_meta = NULL;\n\n    ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta, len);\n    if (id3v2_extra_meta)\n        ff_id3v2_parse_apic(s, &id3v2_extra_meta);\n    ff_id3v2_free_extra_meta(&id3v2_extra_meta);\n}\n\nstatic void get_tag(AVFormatContext *s, const char *key, int type, int len, int type2_size)\n{\n    ASFContext *asf = s->priv_data;\n    char *value = NULL;\n    int64_t off = avio_tell(s->pb);\n#define LEN 22\n\n    if ((unsigned)len >= (UINT_MAX - LEN) / 2)\n        return;\n\n    if (!asf->export_xmp && !strncmp(key, \"xmp\", 3))\n        goto finish;\n\n    value = av_malloc(2 * len + LEN);\n    if (!value)\n        goto finish;\n\n    switch (type) {\n    case ASF_UNICODE:\n        avio_get_str16le(s->pb, len, value, 2 * len + 1);\n        break;\n    case -1: // ASCI\n        avio_read(s->pb, value, len);\n        value[len]=0;\n        break;\n    case ASF_BYTE_ARRAY:\n        if (!strcmp(key, \"WM/Picture\")) { // handle cover art\n            asf_read_picture(s, len);\n        } else if (!strcmp(key, \"ID3\")) { // handle ID3 tag\n            get_id3_tag(s, len);\n        } else {\n            av_log(s, AV_LOG_VERBOSE, \"Unsupported byte array in tag %s.\\n\", key);\n        }\n        goto finish;\n    case ASF_BOOL:\n    case ASF_DWORD:\n    case ASF_QWORD:\n    case ASF_WORD: {\n        uint64_t num = get_value(s->pb, type, type2_size);\n        snprintf(value, LEN, \"%\"PRIu64, num);\n        break;\n    }\n    case ASF_GUID:\n        av_log(s, AV_LOG_DEBUG, \"Unsupported GUID value in tag %s.\\n\", key);\n        goto finish;\n    default:\n        av_log(s, AV_LOG_DEBUG,\n               \"Unsupported value type %d in tag %s.\\n\", type, key);\n        goto finish;\n    }\n    if (*value)\n        av_dict_set(&s->metadata, key, value, 0);\n\nfinish:\n    av_freep(&value);\n    avio_seek(s->pb, off + len, SEEK_SET);\n}\n\nstatic int asf_read_file_properties(AVFormatContext *s, int64_t size)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n\n    ff_get_guid(pb, &asf->hdr.guid);\n    asf->hdr.file_size   = avio_rl64(pb);\n    asf->hdr.create_time = avio_rl64(pb);\n    avio_rl64(pb);                               /* number of packets */\n    asf->hdr.play_time   = avio_rl64(pb);\n    asf->hdr.send_time   = avio_rl64(pb);\n    asf->hdr.preroll     = avio_rl32(pb);\n    asf->hdr.ignore      = avio_rl32(pb);\n    asf->hdr.flags       = avio_rl32(pb);\n    asf->hdr.min_pktsize = avio_rl32(pb);\n    asf->hdr.max_pktsize = avio_rl32(pb);\n    if (asf->hdr.min_pktsize >= (1U << 29))\n        return AVERROR_INVALIDDATA;\n    asf->hdr.max_bitrate = avio_rl32(pb);\n    s->packet_size       = asf->hdr.max_pktsize;\n\n    return 0;\n}\n\nstatic int asf_read_stream_properties(AVFormatContext *s, int64_t size)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    ASFStream *asf_st;\n    ff_asf_guid g;\n    enum AVMediaType type;\n    int type_specific_size, sizeX;\n    unsigned int tag1;\n    int64_t pos1, pos2, start_time;\n    int test_for_ext_stream_audio, is_dvr_ms_audio = 0;\n\n    if (s->nb_streams == ASF_MAX_STREAMS) {\n        av_log(s, AV_LOG_ERROR, \"too many streams\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    pos1 = avio_tell(pb);\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    avpriv_set_pts_info(st, 32, 1, 1000); /* 32 bit pts in ms */\n    start_time     = asf->hdr.preroll;\n\n    if (!(asf->hdr.flags & 0x01)) { // if we aren't streaming...\n        int64_t fsize = avio_size(pb);\n        if (fsize <= 0 || (int64_t)asf->hdr.file_size <= 0 ||\n            20*FFABS(fsize - (int64_t)asf->hdr.file_size) < FFMIN(fsize, asf->hdr.file_size))\n            st->duration = asf->hdr.play_time /\n                       (10000000 / 1000) - start_time;\n    }\n    ff_get_guid(pb, &g);\n\n    test_for_ext_stream_audio = 0;\n    if (!ff_guidcmp(&g, &ff_asf_audio_stream)) {\n        type = AVMEDIA_TYPE_AUDIO;\n    } else if (!ff_guidcmp(&g, &ff_asf_video_stream)) {\n        type = AVMEDIA_TYPE_VIDEO;\n    } else if (!ff_guidcmp(&g, &ff_asf_jfif_media)) {\n        type                = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id = AV_CODEC_ID_MJPEG;\n    } else if (!ff_guidcmp(&g, &ff_asf_command_stream)) {\n        type = AVMEDIA_TYPE_DATA;\n    } else if (!ff_guidcmp(&g, &ff_asf_ext_stream_embed_stream_header)) {\n        test_for_ext_stream_audio = 1;\n        type                      = AVMEDIA_TYPE_UNKNOWN;\n    } else {\n        return -1;\n    }\n    ff_get_guid(pb, &g);\n    avio_skip(pb, 8); /* total_size */\n    type_specific_size = avio_rl32(pb);\n    avio_rl32(pb);\n    st->id = avio_rl16(pb) & 0x7f; /* stream id */\n    // mapping of asf ID to AV stream ID;\n    asf->asfid2avid[st->id] = s->nb_streams - 1;\n    asf_st = &asf->streams[st->id];\n\n    avio_rl32(pb);\n\n    if (test_for_ext_stream_audio) {\n        ff_get_guid(pb, &g);\n        if (!ff_guidcmp(&g, &ff_asf_ext_stream_audio_stream)) {\n            type            = AVMEDIA_TYPE_AUDIO;\n            is_dvr_ms_audio = 1;\n            ff_get_guid(pb, &g);\n            avio_rl32(pb);\n            avio_rl32(pb);\n            avio_rl32(pb);\n            ff_get_guid(pb, &g);\n            avio_rl32(pb);\n        }\n    }\n\n    st->codecpar->codec_type = type;\n    if (type == AVMEDIA_TYPE_AUDIO) {\n        int ret = ff_get_wav_header(s, pb, st->codecpar, type_specific_size, 0);\n        if (ret < 0)\n            return ret;\n        if (is_dvr_ms_audio) {\n            // codec_id and codec_tag are unreliable in dvr_ms\n            // files. Set them later by probing stream.\n            st->request_probe    = 1;\n            st->codecpar->codec_tag = 0;\n        }\n        if (st->codecpar->codec_id == AV_CODEC_ID_AAC)\n            st->need_parsing = AVSTREAM_PARSE_NONE;\n        else\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n        /* We have to init the frame size at some point .... */\n        pos2 = avio_tell(pb);\n        if (size >= (pos2 + 8 - pos1 + 24)) {\n            asf_st->ds_span        = avio_r8(pb);\n            asf_st->ds_packet_size = avio_rl16(pb);\n            asf_st->ds_chunk_size  = avio_rl16(pb);\n            avio_rl16(pb);  // ds_data_size\n            avio_r8(pb);    // ds_silence_data\n        }\n        if (asf_st->ds_span > 1) {\n            if (!asf_st->ds_chunk_size                                ||\n                (asf_st->ds_packet_size / asf_st->ds_chunk_size <= 1) ||\n                asf_st->ds_packet_size % asf_st->ds_chunk_size)\n                asf_st->ds_span = 0;  // disable descrambling\n        }\n    } else if (type == AVMEDIA_TYPE_VIDEO &&\n               size - (avio_tell(pb) - pos1 + 24) >= 51) {\n        avio_rl32(pb);\n        avio_rl32(pb);\n        avio_r8(pb);\n        avio_rl16(pb);        /* size */\n        sizeX             = avio_rl32(pb); /* size */\n        st->codecpar->width  = avio_rl32(pb);\n        st->codecpar->height = avio_rl32(pb);\n        /* not available for asf */\n        avio_rl16(pb); /* panes */\n        st->codecpar->bits_per_coded_sample = avio_rl16(pb); /* depth */\n        tag1                             = avio_rl32(pb);\n        avio_skip(pb, 20);\n        if (sizeX > 40) {\n            st->codecpar->extradata_size = ffio_limit(pb, sizeX - 40);\n            st->codecpar->extradata      = av_mallocz(st->codecpar->extradata_size +\n                                                   AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!st->codecpar->extradata)\n                return AVERROR(ENOMEM);\n            avio_read(pb, st->codecpar->extradata, st->codecpar->extradata_size);\n        }\n\n        /* Extract palette from extradata if bpp <= 8 */\n        /* This code assumes that extradata contains only palette */\n        /* This is true for all paletted codecs implemented in libavcodec */\n        if (st->codecpar->extradata_size && (st->codecpar->bits_per_coded_sample <= 8)) {\n#if HAVE_BIGENDIAN\n            int i;\n            for (i = 0; i < FFMIN(st->codecpar->extradata_size, AVPALETTE_SIZE) / 4; i++)\n                asf_st->palette[i] = av_bswap32(((uint32_t *)st->codecpar->extradata)[i]);\n#else\n            memcpy(asf_st->palette, st->codecpar->extradata,\n                   FFMIN(st->codecpar->extradata_size, AVPALETTE_SIZE));\n#endif\n            asf_st->palette_changed = 1;\n        }\n\n        st->codecpar->codec_tag = tag1;\n        st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag1);\n        if (tag1 == MKTAG('D', 'V', 'R', ' ')) {\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n            /* issue658 contains wrong w/h and MS even puts a fake seq header\n             * with wrong w/h in extradata while a correct one is in the stream.\n             * maximum lameness */\n            st->codecpar->width      =\n                st->codecpar->height = 0;\n            av_freep(&st->codecpar->extradata);\n            st->codecpar->extradata_size = 0;\n        }\n        if (st->codecpar->codec_id == AV_CODEC_ID_H264)\n            st->need_parsing = AVSTREAM_PARSE_FULL_ONCE;\n        if (st->codecpar->codec_id == AV_CODEC_ID_MPEG4)\n            st->need_parsing = AVSTREAM_PARSE_FULL_ONCE;\n    }\n    pos2 = avio_tell(pb);\n    avio_skip(pb, size - (pos2 - pos1 + 24));\n\n    return 0;\n}\n\nstatic int asf_read_ext_stream_properties(AVFormatContext *s, int64_t size)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    ff_asf_guid g;\n    int ext_len, payload_ext_ct, stream_ct, i;\n    uint32_t leak_rate, stream_num;\n    unsigned int stream_languageid_index;\n\n    avio_rl64(pb); // starttime\n    avio_rl64(pb); // endtime\n    leak_rate = avio_rl32(pb); // leak-datarate\n    avio_rl32(pb); // bucket-datasize\n    avio_rl32(pb); // init-bucket-fullness\n    avio_rl32(pb); // alt-leak-datarate\n    avio_rl32(pb); // alt-bucket-datasize\n    avio_rl32(pb); // alt-init-bucket-fullness\n    avio_rl32(pb); // max-object-size\n    avio_rl32(pb); // flags (reliable,seekable,no_cleanpoints?,resend-live-cleanpoints, rest of bits reserved)\n    stream_num = avio_rl16(pb); // stream-num\n\n    stream_languageid_index = avio_rl16(pb); // stream-language-id-index\n    if (stream_num < 128)\n        asf->streams[stream_num].stream_language_index = stream_languageid_index;\n\n    avio_rl64(pb); // avg frametime in 100ns units\n    stream_ct      = avio_rl16(pb); // stream-name-count\n    payload_ext_ct = avio_rl16(pb); // payload-extension-system-count\n\n    if (stream_num < 128) {\n        asf->stream_bitrates[stream_num] = leak_rate;\n        asf->streams[stream_num].payload_ext_ct = 0;\n    }\n\n    for (i = 0; i < stream_ct; i++) {\n        avio_rl16(pb);\n        ext_len = avio_rl16(pb);\n        avio_skip(pb, ext_len);\n    }\n\n    for (i = 0; i < payload_ext_ct; i++) {\n        int size;\n        ff_get_guid(pb, &g);\n        size = avio_rl16(pb);\n        ext_len = avio_rl32(pb);\n        avio_skip(pb, ext_len);\n        if (stream_num < 128 && i < FF_ARRAY_ELEMS(asf->streams[stream_num].payload)) {\n            ASFPayload *p = &asf->streams[stream_num].payload[i];\n            p->type = g[0];\n            p->size = size;\n            av_log(s, AV_LOG_DEBUG, \"Payload extension %x %d\\n\", g[0], p->size );\n            asf->streams[stream_num].payload_ext_ct ++;\n        }\n    }\n\n    return 0;\n}\n\nstatic int asf_read_content_desc(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    int len1, len2, len3, len4, len5;\n\n    len1 = avio_rl16(pb);\n    len2 = avio_rl16(pb);\n    len3 = avio_rl16(pb);\n    len4 = avio_rl16(pb);\n    len5 = avio_rl16(pb);\n    get_tag(s, \"title\", 0, len1, 32);\n    get_tag(s, \"author\", 0, len2, 32);\n    get_tag(s, \"copyright\", 0, len3, 32);\n    get_tag(s, \"comment\", 0, len4, 32);\n    avio_skip(pb, len5);\n\n    return 0;\n}\n\nstatic int asf_read_ext_content_desc(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int desc_count, i, ret;\n\n    desc_count = avio_rl16(pb);\n    for (i = 0; i < desc_count; i++) {\n        int name_len, value_type, value_len;\n        char name[1024];\n\n        name_len = avio_rl16(pb);\n        if (name_len % 2)   // must be even, broken lavf versions wrote len-1\n            name_len += 1;\n        if ((ret = avio_get_str16le(pb, name_len, name, sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        value_type = avio_rl16(pb);\n        value_len  = avio_rl16(pb);\n        if (!value_type && value_len % 2)\n            value_len += 1;\n        /* My sample has that stream set to 0 maybe that mean the container.\n         * ASF stream count starts at 1. I am using 0 to the container value\n         * since it's unused. */\n        if (!strcmp(name, \"AspectRatioX\"))\n            asf->dar[0].num = get_value(s->pb, value_type, 32);\n        else if (!strcmp(name, \"AspectRatioY\"))\n            asf->dar[0].den = get_value(s->pb, value_type, 32);\n        else\n            get_tag(s, name, value_type, value_len, 32);\n    }\n\n    return 0;\n}\n\nstatic int asf_read_language_list(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int j, ret;\n    int stream_count = avio_rl16(pb);\n    for (j = 0; j < stream_count; j++) {\n        char lang[6];\n        unsigned int lang_len = avio_r8(pb);\n        if ((ret = avio_get_str16le(pb, lang_len, lang,\n                                    sizeof(lang))) < lang_len)\n            avio_skip(pb, lang_len - ret);\n        if (j < 128)\n            av_strlcpy(asf->stream_languages[j], lang,\n                       sizeof(*asf->stream_languages));\n    }\n\n    return 0;\n}\n\nstatic int asf_read_metadata(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int n, stream_num, name_len_utf16, name_len_utf8, value_len;\n    int ret, i;\n    n = avio_rl16(pb);\n\n    for (i = 0; i < n; i++) {\n        uint8_t *name;\n        int value_type;\n\n        avio_rl16(pb);  // lang_list_index\n        stream_num = avio_rl16(pb);\n        name_len_utf16 = avio_rl16(pb);\n        value_type = avio_rl16(pb); /* value_type */\n        value_len  = avio_rl32(pb);\n\n        name_len_utf8 = 2*name_len_utf16 + 1;\n        name          = av_malloc(name_len_utf8);\n        if (!name)\n            return AVERROR(ENOMEM);\n\n        if ((ret = avio_get_str16le(pb, name_len_utf16, name, name_len_utf8)) < name_len_utf16)\n            avio_skip(pb, name_len_utf16 - ret);\n        av_log(s, AV_LOG_TRACE, \"%d stream %d name_len %2d type %d len %4d <%s>\\n\",\n                i, stream_num, name_len_utf16, value_type, value_len, name);\n\n        if (!strcmp(name, \"AspectRatioX\")){\n            int aspect_x = get_value(s->pb, value_type, 16);\n            if(stream_num < 128)\n                asf->dar[stream_num].num = aspect_x;\n        } else if(!strcmp(name, \"AspectRatioY\")){\n            int aspect_y = get_value(s->pb, value_type, 16);\n            if(stream_num < 128)\n                asf->dar[stream_num].den = aspect_y;\n        } else {\n            get_tag(s, name, value_type, value_len, 16);\n        }\n        av_freep(&name);\n    }\n\n    return 0;\n}\n\nstatic int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); // skip the name\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}\n\nstatic int asf_read_header(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    ff_asf_guid g;\n    AVIOContext *pb = s->pb;\n    int i;\n    int64_t gsize;\n\n    ff_get_guid(pb, &g);\n    if (ff_guidcmp(&g, &ff_asf_header))\n        return AVERROR_INVALIDDATA;\n    avio_rl64(pb);\n    avio_rl32(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n    memset(&asf->asfid2avid, -1, sizeof(asf->asfid2avid));\n\n    for (i = 0; i<128; i++)\n        asf->streams[i].stream_language_index = 128; // invalid stream index means no language info\n\n    for (;;) {\n        uint64_t gpos = avio_tell(pb);\n        int ret = 0;\n        ff_get_guid(pb, &g);\n        gsize = avio_rl64(pb);\n        print_guid(&g);\n        if (!ff_guidcmp(&g, &ff_asf_data_header)) {\n            asf->data_object_offset = avio_tell(pb);\n            /* If not streaming, gsize is not unlimited (how?),\n             * and there is enough space in the file.. */\n            if (!(asf->hdr.flags & 0x01) && gsize >= 100)\n                asf->data_object_size = gsize - 24;\n            else\n                asf->data_object_size = (uint64_t)-1;\n            break;\n        }\n        if (gsize < 24)\n            return AVERROR_INVALIDDATA;\n        if (!ff_guidcmp(&g, &ff_asf_file_header)) {\n            ret = asf_read_file_properties(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_stream_header)) {\n            ret = asf_read_stream_properties(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_comment_header)) {\n            asf_read_content_desc(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_language_guid)) {\n            asf_read_language_list(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_extended_content_header)) {\n            asf_read_ext_content_desc(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_metadata_header)) {\n            asf_read_metadata(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_metadata_library_header)) {\n            asf_read_metadata(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_ext_stream_header)) {\n            asf_read_ext_stream_properties(s, gsize);\n\n            // there could be an optional stream properties object to follow\n            // if so the next iteration will pick it up\n            continue;\n        } else if (!ff_guidcmp(&g, &ff_asf_head1_guid)) {\n            ff_get_guid(pb, &g);\n            avio_skip(pb, 6);\n            continue;\n        } else if (!ff_guidcmp(&g, &ff_asf_marker_header)) {\n            asf_read_marker(s, gsize);\n        } else if (avio_feof(pb)) {\n            return AVERROR_EOF;\n        } else {\n            if (!s->keylen) {\n                if (!ff_guidcmp(&g, &ff_asf_content_encryption)) {\n                    unsigned int len;\n                    AVPacket pkt;\n                    av_log(s, AV_LOG_WARNING,\n                           \"DRM protected stream detected, decoding will likely fail!\\n\");\n                    len= avio_rl32(pb);\n                    av_log(s, AV_LOG_DEBUG, \"Secret data:\\n\");\n\n                    if ((ret = av_get_packet(pb, &pkt, len)) < 0)\n                        return ret;\n                    av_hex_dump_log(s, AV_LOG_DEBUG, pkt.data, pkt.size);\n                    av_packet_unref(&pkt);\n                    len= avio_rl32(pb);\n                    get_tag(s, \"ASF_Protection_Type\", -1, len, 32);\n                    len= avio_rl32(pb);\n                    get_tag(s, \"ASF_Key_ID\", -1, len, 32);\n                    len= avio_rl32(pb);\n                    get_tag(s, \"ASF_License_URL\", -1, len, 32);\n                } else if (!ff_guidcmp(&g, &ff_asf_ext_content_encryption)) {\n                    av_log(s, AV_LOG_WARNING,\n                           \"Ext DRM protected stream detected, decoding will likely fail!\\n\");\n                    av_dict_set(&s->metadata, \"encryption\", \"ASF Extended Content Encryption\", 0);\n                } else if (!ff_guidcmp(&g, &ff_asf_digital_signature)) {\n                    av_log(s, AV_LOG_INFO, \"Digital signature detected!\\n\");\n                }\n            }\n        }\n        if (ret < 0)\n            return ret;\n\n        if (avio_tell(pb) != gpos + gsize)\n            av_log(s, AV_LOG_DEBUG,\n                   \"gpos mismatch our pos=%\"PRIu64\", end=%\"PRId64\"\\n\",\n                   avio_tell(pb) - gpos, gsize);\n        avio_seek(pb, gpos + gsize, SEEK_SET);\n    }\n    ff_get_guid(pb, &g);\n    avio_rl64(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n    if (avio_feof(pb))\n        return AVERROR_EOF;\n    asf->data_offset      = avio_tell(pb);\n    asf->packet_size_left = 0;\n\n    for (i = 0; i < 128; i++) {\n        int stream_num = asf->asfid2avid[i];\n        if (stream_num >= 0) {\n            AVStream *st = s->streams[stream_num];\n            if (!st->codecpar->bit_rate)\n                st->codecpar->bit_rate = asf->stream_bitrates[i];\n            if (asf->dar[i].num > 0 && asf->dar[i].den > 0) {\n                av_reduce(&st->sample_aspect_ratio.num,\n                          &st->sample_aspect_ratio.den,\n                          asf->dar[i].num, asf->dar[i].den, INT_MAX);\n            } else if ((asf->dar[0].num > 0) && (asf->dar[0].den > 0) &&\n                       // Use ASF container value if the stream doesn't set AR.\n                       (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO))\n                av_reduce(&st->sample_aspect_ratio.num,\n                          &st->sample_aspect_ratio.den,\n                          asf->dar[0].num, asf->dar[0].den, INT_MAX);\n\n            av_log(s, AV_LOG_TRACE, \"i=%d, st->codecpar->codec_type:%d, asf->dar %d:%d sar=%d:%d\\n\",\n                    i, st->codecpar->codec_type, asf->dar[i].num, asf->dar[i].den,\n                    st->sample_aspect_ratio.num, st->sample_aspect_ratio.den);\n\n            // copy and convert language codes to the frontend\n            if (asf->streams[i].stream_language_index < 128) {\n                const char *rfc1766 = asf->stream_languages[asf->streams[i].stream_language_index];\n                if (rfc1766 && strlen(rfc1766) > 1) {\n                    const char primary_tag[3] = { rfc1766[0], rfc1766[1], '\\0' }; // ignore country code if any\n                    const char *iso6392       = ff_convert_lang_to(primary_tag,\n                                                                   AV_LANG_ISO639_2_BIBL);\n                    if (iso6392)\n                        av_dict_set(&st->metadata, \"language\", iso6392, 0);\n                }\n            }\n        }\n    }\n\n    ff_metadata_conv(&s->metadata, NULL, ff_asf_metadata_conv);\n\n    return 0;\n}\n\n#define DO_2BITS(bits, var, defval)             \\\n    switch (bits & 3) {                         \\\n    case 3:                                     \\\n        var = avio_rl32(pb);                    \\\n        rsize += 4;                             \\\n        break;                                  \\\n    case 2:                                     \\\n        var = avio_rl16(pb);                    \\\n        rsize += 2;                             \\\n        break;                                  \\\n    case 1:                                     \\\n        var = avio_r8(pb);                      \\\n        rsize++;                                \\\n        break;                                  \\\n    default:                                    \\\n        var = defval;                           \\\n        break;                                  \\\n    }\n\n/**\n * Load a single ASF packet into the demuxer.\n * @param s demux context\n * @param pb context to read data from\n * @return 0 on success, <0 on error\n */\nstatic int asf_get_packet(AVFormatContext *s, AVIOContext *pb)\n{\n    ASFContext *asf = s->priv_data;\n    uint32_t packet_length, padsize;\n    int rsize = 8;\n    int c, d, e, off;\n\n    if (asf->uses_std_ecc > 0) {\n        // if we do not know packet size, allow skipping up to 32 kB\n        off = 32768;\n        if (asf->no_resync_search)\n            off = 3;\n//         else if (s->packet_size > 0 && !asf->uses_std_ecc)\n//             off = (avio_tell(pb) - s->internal->data_offset) % s->packet_size + 3;\n\n        c = d = e = -1;\n        while (off-- > 0) {\n            c = d;\n            d = e;\n            e = avio_r8(pb);\n            if (c == 0x82 && !d && !e)\n                break;\n        }\n\n        if (c != 0x82) {\n            /* This code allows handling of -EAGAIN at packet boundaries (i.e.\n            * if the packet sync code above triggers -EAGAIN). This does not\n            * imply complete -EAGAIN handling support at random positions in\n            * the stream. */\n            if (pb->error == AVERROR(EAGAIN))\n                return AVERROR(EAGAIN);\n            if (!avio_feof(pb))\n                av_log(s, AV_LOG_ERROR,\n                    \"ff asf bad header %x  at:%\"PRId64\"\\n\", c, avio_tell(pb));\n        }\n        if ((c & 0x8f) == 0x82) {\n            if (d || e) {\n                if (!avio_feof(pb))\n                    av_log(s, AV_LOG_ERROR, \"ff asf bad non zero\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            c      = avio_r8(pb);\n            d      = avio_r8(pb);\n            rsize += 3;\n        } else if(!avio_feof(pb)) {\n            avio_seek(pb, -1, SEEK_CUR); // FIXME\n        }\n    } else {\n        c = avio_r8(pb);\n        if (c & 0x80) {\n            rsize ++;\n            if (!(c & 0x60)) {\n                d = avio_r8(pb);\n                e = avio_r8(pb);\n                avio_seek(pb, (c & 0xF) - 2, SEEK_CUR);\n                rsize += c & 0xF;\n            }\n\n            if (c != 0x82)\n                avpriv_request_sample(s, \"Invalid ECC byte\");\n\n            if (!asf->uses_std_ecc)\n                asf->uses_std_ecc =  (c == 0x82 && !d && !e) ? 1 : -1;\n\n            c = avio_r8(pb);\n        } else\n            asf->uses_std_ecc =  -1;\n        d = avio_r8(pb);\n    }\n\n    asf->packet_flags    = c;\n    asf->packet_property = d;\n\n    DO_2BITS(asf->packet_flags >> 5, packet_length, s->packet_size);\n    DO_2BITS(asf->packet_flags >> 1, padsize, 0); // sequence ignored\n    DO_2BITS(asf->packet_flags >> 3, padsize, 0); // padding length\n\n    // the following checks prevent overflows and infinite loops\n    if (!packet_length || packet_length >= (1U << 29)) {\n        av_log(s, AV_LOG_ERROR,\n               \"invalid packet_length %\"PRIu32\" at:%\"PRId64\"\\n\",\n               packet_length, avio_tell(pb));\n        return AVERROR_INVALIDDATA;\n    }\n    if (padsize >= packet_length) {\n        av_log(s, AV_LOG_ERROR,\n               \"invalid padsize %\"PRIu32\" at:%\"PRId64\"\\n\", padsize, avio_tell(pb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    asf->packet_timestamp = avio_rl32(pb);\n    avio_rl16(pb); /* duration */\n    // rsize has at least 11 bytes which have to be present\n\n    if (asf->packet_flags & 0x01) {\n        asf->packet_segsizetype = avio_r8(pb);\n        rsize++;\n        asf->packet_segments = asf->packet_segsizetype & 0x3f;\n    } else {\n        asf->packet_segments    = 1;\n        asf->packet_segsizetype = 0x80;\n    }\n    if (rsize > packet_length - padsize) {\n        asf->packet_size_left = 0;\n        av_log(s, AV_LOG_ERROR,\n               \"invalid packet header length %d for pktlen %\"PRIu32\"-%\"PRIu32\" at %\"PRId64\"\\n\",\n               rsize, packet_length, padsize, avio_tell(pb));\n        return AVERROR_INVALIDDATA;\n    }\n    asf->packet_size_left = packet_length - padsize - rsize;\n    if (packet_length < asf->hdr.min_pktsize)\n        padsize += asf->hdr.min_pktsize - packet_length;\n    asf->packet_padsize = padsize;\n    av_log(s, AV_LOG_TRACE, \"packet: size=%d padsize=%d  left=%d\\n\",\n            s->packet_size, asf->packet_padsize, asf->packet_size_left);\n    return 0;\n}\n\n/**\n *\n * @return <0 if error\n */\nstatic int asf_read_frame_header(AVFormatContext *s, AVIOContext *pb)\n{\n    ASFContext *asf = s->priv_data;\n    ASFStream *asfst;\n    int rsize       = 1;\n    int num         = avio_r8(pb);\n    int i;\n    int64_t ts0, ts1 av_unused;\n\n    asf->packet_segments--;\n    asf->packet_key_frame = num >> 7;\n    asf->stream_index     = asf->asfid2avid[num & 0x7f];\n    asfst                 = &asf->streams[num & 0x7f];\n    // sequence should be ignored!\n    DO_2BITS(asf->packet_property >> 4, asf->packet_seq, 0);\n    DO_2BITS(asf->packet_property >> 2, asf->packet_frag_offset, 0);\n    DO_2BITS(asf->packet_property, asf->packet_replic_size, 0);\n    av_log(asf, AV_LOG_TRACE, \"key:%d stream:%d seq:%d offset:%d replic_size:%d num:%X packet_property %X\\n\",\n            asf->packet_key_frame, asf->stream_index, asf->packet_seq,\n            asf->packet_frag_offset, asf->packet_replic_size, num, asf->packet_property);\n    if (rsize+(int64_t)asf->packet_replic_size > asf->packet_size_left) {\n        av_log(s, AV_LOG_ERROR, \"packet_replic_size %d is invalid\\n\", asf->packet_replic_size);\n        return AVERROR_INVALIDDATA;\n    }\n    if (asf->packet_replic_size >= 8) {\n        int64_t end = avio_tell(pb) + asf->packet_replic_size;\n        AVRational aspect;\n        asfst->packet_obj_size = avio_rl32(pb);\n        if (asfst->packet_obj_size >= (1 << 24) || asfst->packet_obj_size < 0) {\n            av_log(s, AV_LOG_ERROR, \"packet_obj_size %d invalid\\n\", asfst->packet_obj_size);\n            asfst->packet_obj_size = 0;\n            return AVERROR_INVALIDDATA;\n        }\n        asf->packet_frag_timestamp = avio_rl32(pb); // timestamp\n\n        for (i = 0; i < asfst->payload_ext_ct; i++) {\n            ASFPayload *p = &asfst->payload[i];\n            int size = p->size;\n            int64_t payend;\n            if (size == 0xFFFF)\n                size = avio_rl16(pb);\n            payend = avio_tell(pb) + size;\n            if (payend > end) {\n                av_log(s, AV_LOG_ERROR, \"too long payload\\n\");\n                break;\n            }\n            switch (p->type) {\n            case 0x50:\n//              duration = avio_rl16(pb);\n                break;\n            case 0x54:\n                aspect.num = avio_r8(pb);\n                aspect.den = avio_r8(pb);\n                if (aspect.num > 0 && aspect.den > 0 && asf->stream_index >= 0) {\n                    s->streams[asf->stream_index]->sample_aspect_ratio = aspect;\n                }\n                break;\n            case 0x2A:\n                avio_skip(pb, 8);\n                ts0 = avio_rl64(pb);\n                ts1 = avio_rl64(pb);\n                if (ts0!= -1) asf->packet_frag_timestamp = ts0/10000;\n                else          asf->packet_frag_timestamp = AV_NOPTS_VALUE;\n                asf->ts_is_pts = 1;\n                break;\n            case 0x5B:\n            case 0xB7:\n            case 0xCC:\n            case 0xC0:\n            case 0xA0:\n                //unknown\n                break;\n            }\n            avio_seek(pb, payend, SEEK_SET);\n        }\n\n        avio_seek(pb, end, SEEK_SET);\n        rsize += asf->packet_replic_size; // FIXME - check validity\n    } else if (asf->packet_replic_size == 1) {\n        // multipacket - frag_offset is beginning timestamp\n        asf->packet_time_start     = asf->packet_frag_offset;\n        asf->packet_frag_offset    = 0;\n        asf->packet_frag_timestamp = asf->packet_timestamp;\n\n        asf->packet_time_delta = avio_r8(pb);\n        rsize++;\n    } else if (asf->packet_replic_size != 0) {\n        av_log(s, AV_LOG_ERROR, \"unexpected packet_replic_size of %d\\n\",\n               asf->packet_replic_size);\n        return AVERROR_INVALIDDATA;\n    }\n    if (asf->packet_flags & 0x01) {\n        DO_2BITS(asf->packet_segsizetype >> 6, asf->packet_frag_size, 0); // 0 is illegal\n        if (rsize > asf->packet_size_left) {\n            av_log(s, AV_LOG_ERROR, \"packet_replic_size is invalid\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (asf->packet_frag_size > asf->packet_size_left - rsize) {\n            if (asf->packet_frag_size > asf->packet_size_left - rsize + asf->packet_padsize) {\n                av_log(s, AV_LOG_ERROR, \"packet_frag_size is invalid (%d>%d-%d+%d)\\n\",\n                       asf->packet_frag_size, asf->packet_size_left, rsize, asf->packet_padsize);\n                return AVERROR_INVALIDDATA;\n            } else {\n                int diff = asf->packet_frag_size - (asf->packet_size_left - rsize);\n                asf->packet_size_left += diff;\n                asf->packet_padsize   -= diff;\n            }\n        }\n    } else {\n        asf->packet_frag_size = asf->packet_size_left - rsize;\n    }\n    if (asf->packet_replic_size == 1) {\n        asf->packet_multi_size = asf->packet_frag_size;\n        if (asf->packet_multi_size > asf->packet_size_left)\n            return AVERROR_INVALIDDATA;\n    }\n    asf->packet_size_left -= rsize;\n\n    return 0;\n}\n\n/**\n * Parse data from individual ASF packets (which were previously loaded\n * with asf_get_packet()).\n * @param s demux context\n * @param pb context to read data from\n * @param pkt pointer to store packet data into\n * @return 0 if data was stored in pkt, <0 on error or 1 if more ASF\n *          packets need to be loaded (through asf_get_packet())\n */\nstatic int asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt)\n{\n    ASFContext *asf   = s->priv_data;\n    ASFStream *asf_st = 0;\n    for (;;) {\n        int ret;\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        if (asf->packet_size_left < FRAME_HEADER_SIZE ||\n            asf->packet_segments < 1 && asf->packet_time_start == 0) {\n            int ret = asf->packet_size_left + asf->packet_padsize;\n\n            if (asf->packet_size_left && asf->packet_size_left < FRAME_HEADER_SIZE)\n                av_log(s, AV_LOG_WARNING, \"Skip due to FRAME_HEADER_SIZE\\n\");\n\n            assert(ret >= 0);\n            /* fail safe */\n            avio_skip(pb, ret);\n\n            asf->packet_pos = avio_tell(pb);\n            if (asf->data_object_size != (uint64_t)-1 &&\n                (asf->packet_pos - asf->data_object_offset >= asf->data_object_size))\n                return AVERROR_EOF;  /* Do not exceed the size of the data object */\n            return 1;\n        }\n        if (asf->packet_time_start == 0) {\n            if (asf_read_frame_header(s, pb) < 0) {\n                asf->packet_time_start = asf->packet_segments = 0;\n                continue;\n            }\n            if (asf->stream_index < 0 ||\n                s->streams[asf->stream_index]->discard >= AVDISCARD_ALL ||\n                (!asf->packet_key_frame &&\n                 (s->streams[asf->stream_index]->discard >= AVDISCARD_NONKEY || asf->streams[s->streams[asf->stream_index]->id].skip_to_key))) {\n                asf->packet_time_start = 0;\n                /* unhandled packet (should not happen) */\n                avio_skip(pb, asf->packet_frag_size);\n                asf->packet_size_left -= asf->packet_frag_size;\n                if (asf->stream_index < 0)\n                    av_log(s, AV_LOG_ERROR, \"ff asf skip %d (unknown stream)\\n\",\n                           asf->packet_frag_size);\n                continue;\n            }\n            asf->asf_st = &asf->streams[s->streams[asf->stream_index]->id];\n            if (!asf->packet_frag_offset)\n                asf->asf_st->skip_to_key = 0;\n        }\n        asf_st = asf->asf_st;\n        av_assert0(asf_st);\n\n        if (!asf_st->frag_offset && asf->packet_frag_offset) {\n            av_log(s, AV_LOG_TRACE, \"skipping asf data pkt with fragment offset for \"\n                    \"stream:%d, expected:%d but got %d from pkt)\\n\",\n                    asf->stream_index, asf_st->frag_offset,\n                    asf->packet_frag_offset);\n            avio_skip(pb, asf->packet_frag_size);\n            asf->packet_size_left -= asf->packet_frag_size;\n            continue;\n        }\n\n        if (asf->packet_replic_size == 1) {\n            // frag_offset is here used as the beginning timestamp\n            asf->packet_frag_timestamp = asf->packet_time_start;\n            asf->packet_time_start    += asf->packet_time_delta;\n            asf_st->packet_obj_size    = asf->packet_frag_size = avio_r8(pb);\n            asf->packet_size_left--;\n            asf->packet_multi_size--;\n            if (asf->packet_multi_size < asf_st->packet_obj_size) {\n                asf->packet_time_start = 0;\n                avio_skip(pb, asf->packet_multi_size);\n                asf->packet_size_left -= asf->packet_multi_size;\n                continue;\n            }\n            asf->packet_multi_size -= asf_st->packet_obj_size;\n        }\n\n        if (asf_st->pkt.size != asf_st->packet_obj_size ||\n            // FIXME is this condition sufficient?\n            asf_st->frag_offset + asf->packet_frag_size > asf_st->pkt.size) {\n            int ret;\n\n            if (asf_st->pkt.data) {\n                av_log(s, AV_LOG_INFO,\n                       \"freeing incomplete packet size %d, new %d\\n\",\n                       asf_st->pkt.size, asf_st->packet_obj_size);\n                asf_st->frag_offset = 0;\n                av_packet_unref(&asf_st->pkt);\n            }\n            /* new packet */\n            if ((ret = av_new_packet(&asf_st->pkt, asf_st->packet_obj_size)) < 0)\n                return ret;\n            asf_st->seq              = asf->packet_seq;\n            if (asf->ts_is_pts) {\n                asf_st->pkt.pts          = asf->packet_frag_timestamp - asf->hdr.preroll;\n            } else\n                asf_st->pkt.dts          = asf->packet_frag_timestamp - asf->hdr.preroll;\n            asf_st->pkt.stream_index = asf->stream_index;\n            asf_st->pkt.pos          = asf_st->packet_pos = asf->packet_pos;\n            asf_st->pkt_clean        = 0;\n\n            if (asf_st->pkt.data && asf_st->palette_changed) {\n                uint8_t *pal;\n                pal = av_packet_new_side_data(&asf_st->pkt, AV_PKT_DATA_PALETTE,\n                                              AVPALETTE_SIZE);\n                if (!pal) {\n                    av_log(s, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n                } else {\n                    memcpy(pal, asf_st->palette, AVPALETTE_SIZE);\n                    asf_st->palette_changed = 0;\n                }\n            }\n            av_log(asf, AV_LOG_TRACE, \"new packet: stream:%d key:%d packet_key:%d audio:%d size:%d\\n\",\n                    asf->stream_index, asf->packet_key_frame,\n                    asf_st->pkt.flags & AV_PKT_FLAG_KEY,\n                    s->streams[asf->stream_index]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO,\n                    asf_st->packet_obj_size);\n            if (s->streams[asf->stream_index]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n                asf->packet_key_frame = 1;\n            if (asf->packet_key_frame)\n                asf_st->pkt.flags |= AV_PKT_FLAG_KEY;\n        }\n\n        /* read data */\n        av_log(asf, AV_LOG_TRACE, \"READ PACKET s:%d  os:%d  o:%d,%d  l:%d   DATA:%p\\n\",\n                s->packet_size, asf_st->pkt.size, asf->packet_frag_offset,\n                asf_st->frag_offset, asf->packet_frag_size, asf_st->pkt.data);\n        asf->packet_size_left -= asf->packet_frag_size;\n        if (asf->packet_size_left < 0)\n            continue;\n\n        if (asf->packet_frag_offset >= asf_st->pkt.size ||\n            asf->packet_frag_size > asf_st->pkt.size - asf->packet_frag_offset) {\n            av_log(s, AV_LOG_ERROR,\n                   \"packet fragment position invalid %u,%u not in %u\\n\",\n                   asf->packet_frag_offset, asf->packet_frag_size,\n                   asf_st->pkt.size);\n            continue;\n        }\n\n        if (asf->packet_frag_offset != asf_st->frag_offset && !asf_st->pkt_clean) {\n            memset(asf_st->pkt.data + asf_st->frag_offset, 0, asf_st->pkt.size - asf_st->frag_offset);\n            asf_st->pkt_clean = 1;\n        }\n\n        ret = avio_read(pb, asf_st->pkt.data + asf->packet_frag_offset,\n                        asf->packet_frag_size);\n        if (ret != asf->packet_frag_size) {\n            if (ret < 0 || asf->packet_frag_offset + ret == 0)\n                return ret < 0 ? ret : AVERROR_EOF;\n\n            if (asf_st->ds_span > 1) {\n                // scrambling, we can either drop it completely or fill the remainder\n                // TODO: should we fill the whole packet instead of just the current\n                // fragment?\n                memset(asf_st->pkt.data + asf->packet_frag_offset + ret, 0,\n                       asf->packet_frag_size - ret);\n                ret = asf->packet_frag_size;\n            } else {\n                // no scrambling, so we can return partial packets\n                av_shrink_packet(&asf_st->pkt, asf->packet_frag_offset + ret);\n            }\n        }\n        if (s->key && s->keylen == 20)\n            ff_asfcrypt_dec(s->key, asf_st->pkt.data + asf->packet_frag_offset,\n                            ret);\n        asf_st->frag_offset += ret;\n        /* test if whole packet is read */\n        if (asf_st->frag_offset == asf_st->pkt.size) {\n            // workaround for macroshit radio DVR-MS files\n            if (s->streams[asf->stream_index]->codecpar->codec_id == AV_CODEC_ID_MPEG2VIDEO &&\n                asf_st->pkt.size > 100) {\n                int i;\n                for (i = 0; i < asf_st->pkt.size && !asf_st->pkt.data[i]; i++)\n                    ;\n                if (i == asf_st->pkt.size) {\n                    av_log(s, AV_LOG_DEBUG, \"discarding ms fart\\n\");\n                    asf_st->frag_offset = 0;\n                    av_packet_unref(&asf_st->pkt);\n                    continue;\n                }\n            }\n\n            /* return packet */\n            if (asf_st->ds_span > 1) {\n                if (asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span) {\n                    av_log(s, AV_LOG_ERROR,\n                           \"pkt.size != ds_packet_size * ds_span (%d %d %d)\\n\",\n                           asf_st->pkt.size, asf_st->ds_packet_size,\n                           asf_st->ds_span);\n                } else {\n                    /* packet descrambling */\n                    AVBufferRef *buf = av_buffer_alloc(asf_st->pkt.size +\n                                                       AV_INPUT_BUFFER_PADDING_SIZE);\n                    if (buf) {\n                        uint8_t *newdata = buf->data;\n                        int offset = 0;\n                        memset(newdata + asf_st->pkt.size, 0,\n                               AV_INPUT_BUFFER_PADDING_SIZE);\n                        while (offset < asf_st->pkt.size) {\n                            int off = offset / asf_st->ds_chunk_size;\n                            int row = off / asf_st->ds_span;\n                            int col = off % asf_st->ds_span;\n                            int idx = row + col * asf_st->ds_packet_size / asf_st->ds_chunk_size;\n                            assert(offset + asf_st->ds_chunk_size <= asf_st->pkt.size);\n                            assert(idx + 1 <= asf_st->pkt.size / asf_st->ds_chunk_size);\n                            memcpy(newdata + offset,\n                                   asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n                                   asf_st->ds_chunk_size);\n                            offset += asf_st->ds_chunk_size;\n                        }\n                        av_buffer_unref(&asf_st->pkt.buf);\n                        asf_st->pkt.buf  = buf;\n                        asf_st->pkt.data = buf->data;\n                    }\n                }\n            }\n            asf_st->frag_offset         = 0;\n            *pkt                        = asf_st->pkt;\n            asf_st->pkt.buf             = 0;\n            asf_st->pkt.size            = 0;\n            asf_st->pkt.data            = 0;\n            asf_st->pkt.side_data_elems = 0;\n            asf_st->pkt.side_data       = NULL;\n            break; // packet completed\n        }\n    }\n    return 0;\n}\n\nstatic int asf_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    ASFContext *asf = s->priv_data;\n\n    for (;;) {\n        int ret;\n\n        /* parse cached packets, if any */\n        if ((ret = asf_parse_packet(s, s->pb, pkt)) <= 0)\n            return ret;\n        if ((ret = asf_get_packet(s, s->pb)) < 0)\n            assert(asf->packet_size_left < FRAME_HEADER_SIZE ||\n                   asf->packet_segments < 1);\n        asf->packet_time_start = 0;\n    }\n}\n\n// Added to support seeking after packets have been read\n// If information is not reset, read_packet fails due to\n// leftover information from previous reads\nstatic void asf_reset_header(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    ASFStream *asf_st;\n    int i;\n\n    asf->packet_size_left      = 0;\n    asf->packet_flags          = 0;\n    asf->packet_property       = 0;\n    asf->packet_timestamp      = 0;\n    asf->packet_segsizetype    = 0;\n    asf->packet_segments       = 0;\n    asf->packet_seq            = 0;\n    asf->packet_replic_size    = 0;\n    asf->packet_key_frame      = 0;\n    asf->packet_padsize        = 0;\n    asf->packet_frag_offset    = 0;\n    asf->packet_frag_size      = 0;\n    asf->packet_frag_timestamp = 0;\n    asf->packet_multi_size     = 0;\n    asf->packet_time_delta     = 0;\n    asf->packet_time_start     = 0;\n\n    for (i = 0; i < 128; i++) {\n        asf_st = &asf->streams[i];\n        av_packet_unref(&asf_st->pkt);\n        asf_st->packet_obj_size = 0;\n        asf_st->frag_offset = 0;\n        asf_st->seq         = 0;\n    }\n    asf->asf_st = NULL;\n}\n\nstatic void skip_to_key(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    int i;\n\n    for (i = 0; i < 128; i++) {\n        int j = asf->asfid2avid[i];\n        ASFStream *asf_st = &asf->streams[i];\n        if (j < 0 || s->streams[j]->codecpar->codec_type != AVMEDIA_TYPE_VIDEO)\n            continue;\n\n        asf_st->skip_to_key = 1;\n    }\n}\n\nstatic int asf_read_close(AVFormatContext *s)\n{\n    asf_reset_header(s);\n\n    return 0;\n}\n\nstatic int64_t asf_read_pts(AVFormatContext *s, int stream_index,\n                            int64_t *ppos, int64_t pos_limit)\n{\n    ASFContext *asf     = s->priv_data;\n    AVPacket pkt1, *pkt = &pkt1;\n    ASFStream *asf_st;\n    int64_t pts;\n    int64_t pos = *ppos;\n    int i;\n    int64_t start_pos[ASF_MAX_STREAMS];\n\n    for (i = 0; i < s->nb_streams; i++)\n        start_pos[i] = pos;\n\n    if (s->packet_size > 0)\n        pos = (pos + s->packet_size - 1 - s->internal->data_offset) /\n              s->packet_size * s->packet_size +\n              s->internal->data_offset;\n    *ppos = pos;\n    if (avio_seek(s->pb, pos, SEEK_SET) < 0)\n        return AV_NOPTS_VALUE;\n\n    ff_read_frame_flush(s);\n    asf_reset_header(s);\n    for (;;) {\n        if (av_read_frame(s, pkt) < 0) {\n            av_log(s, AV_LOG_INFO, \"asf_read_pts failed\\n\");\n            return AV_NOPTS_VALUE;\n        }\n\n        pts = pkt->dts;\n\n        if (pkt->flags & AV_PKT_FLAG_KEY) {\n            i = pkt->stream_index;\n\n            asf_st = &asf->streams[s->streams[i]->id];\n\n//            assert((asf_st->packet_pos - s->data_offset) % s->packet_size == 0);\n            pos = asf_st->packet_pos;\n            av_assert1(pkt->pos == asf_st->packet_pos);\n\n            av_add_index_entry(s->streams[i], pos, pts, pkt->size,\n                               pos - start_pos[i] + 1, AVINDEX_KEYFRAME);\n            start_pos[i] = asf_st->packet_pos + 1;\n\n            if (pkt->stream_index == stream_index) {\n                av_packet_unref(pkt);\n                break;\n            }\n        }\n        av_packet_unref(pkt);\n    }\n\n    *ppos = pos;\n    return pts;\n}\n\nstatic int asf_build_simple_index(AVFormatContext *s, int stream_index)\n{\n    ff_asf_guid g;\n    ASFContext *asf     = s->priv_data;\n    int64_t current_pos = avio_tell(s->pb);\n    int64_t ret;\n\n    if((ret = avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET)) < 0) {\n        return ret;\n    }\n\n    if ((ret = ff_get_guid(s->pb, &g)) < 0)\n        goto end;\n\n    /* the data object can be followed by other top-level objects,\n     * skip them until the simple index object is reached */\n    while (ff_guidcmp(&g, &ff_asf_simple_index_header)) {\n        int64_t gsize = avio_rl64(s->pb);\n        if (gsize < 24 || avio_feof(s->pb)) {\n            goto end;\n        }\n        avio_skip(s->pb, gsize - 24);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n    }\n\n    {\n        int64_t itime, last_pos = -1;\n        int pct, ict;\n        int i;\n        int64_t av_unused gsize = avio_rl64(s->pb);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n        itime = avio_rl64(s->pb);\n        pct   = avio_rl32(s->pb);\n        ict   = avio_rl32(s->pb);\n        av_log(s, AV_LOG_DEBUG,\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n\n        for (i = 0; i < ict; i++) {\n            int pktnum        = avio_rl32(s->pb);\n            int pktct         = avio_rl16(s->pb);\n            int64_t pos       = s->internal->data_offset + s->packet_size * (int64_t)pktnum;\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n\n            if (pos != last_pos) {\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n                       pktnum, pktct, index_pts);\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n                last_pos = pos;\n            }\n        }\n        asf->index_read = ict > 1;\n    }\nend:\n//     if (avio_feof(s->pb)) {\n//         ret = 0;\n//     }\n    avio_seek(s->pb, current_pos, SEEK_SET);\n    return ret;\n}\n\nstatic int asf_read_seek(AVFormatContext *s, int stream_index,\n                         int64_t pts, int flags)\n{\n    ASFContext *asf = s->priv_data;\n    AVStream *st    = s->streams[stream_index];\n    int ret = 0;\n\n    if (s->packet_size <= 0)\n        return -1;\n\n    /* Try using the protocol's read_seek if available */\n    if (s->pb) {\n        int64_t ret = avio_seek_time(s->pb, stream_index, pts, flags);\n        if (ret >= 0)\n            asf_reset_header(s);\n        if (ret != AVERROR(ENOSYS))\n            return ret;\n    }\n\n    /* explicitly handle the case of seeking to 0 */\n    if (!pts) {\n        asf_reset_header(s);\n        avio_seek(s->pb, s->internal->data_offset, SEEK_SET);\n        return 0;\n    }\n\n    if (!asf->index_read) {\n        ret = asf_build_simple_index(s, stream_index);\n        if (ret < 0)\n            asf->index_read = -1;\n    }\n\n    if (asf->index_read > 0 && st->index_entries) {\n        int index = av_index_search_timestamp(st, pts, flags);\n        if (index >= 0) {\n            /* find the position */\n            uint64_t pos = st->index_entries[index].pos;\n\n            /* do the seek */\n            av_log(s, AV_LOG_DEBUG, \"SEEKTO: %\"PRId64\"\\n\", pos);\n            if(avio_seek(s->pb, pos, SEEK_SET) < 0)\n                return -1;\n            asf_reset_header(s);\n            skip_to_key(s);\n            return 0;\n        }\n    }\n    /* no index or seeking by index failed */\n    if (ff_seek_frame_binary(s, stream_index, pts, flags) < 0)\n        return -1;\n    asf_reset_header(s);\n    skip_to_key(s);\n    return 0;\n}\n\nAVInputFormat ff_asf_demuxer = {\n    .name           = \"asf\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"ASF (Advanced / Active Streaming Format)\"),\n    .priv_data_size = sizeof(ASFContext),\n    .read_probe     = asf_probe,\n    .read_header    = asf_read_header,\n    .read_packet    = asf_read_packet,\n    .read_close     = asf_read_close,\n    .read_seek      = asf_read_seek,\n    .read_timestamp = asf_read_pts,\n    .flags          = AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH,\n    .priv_class     = &asf_class,\n};\n"], "fixing_code": ["/*\n * ASF compatible demuxer\n * Copyright (c) 2000, 2001 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/bswap.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"avlanguage.h\"\n#include \"id3v2.h\"\n#include \"internal.h\"\n#include \"riff.h\"\n#include \"asf.h\"\n#include \"asfcrypt.h\"\n\ntypedef struct ASFPayload {\n    uint8_t type;\n    uint16_t size;\n} ASFPayload;\n\ntypedef struct ASFStream {\n    int num;\n    unsigned char seq;\n    /* use for reading */\n    AVPacket pkt;\n    int frag_offset;\n    int packet_obj_size;\n    int timestamp;\n    int64_t duration;\n    int skip_to_key;\n    int pkt_clean;\n\n    int ds_span;                /* descrambling  */\n    int ds_packet_size;\n    int ds_chunk_size;\n\n    int64_t packet_pos;\n\n    uint16_t stream_language_index;\n\n    int      palette_changed;\n    uint32_t palette[256];\n\n    int payload_ext_ct;\n    ASFPayload payload[8];\n} ASFStream;\n\ntypedef struct ASFContext {\n    const AVClass *class;\n    int asfid2avid[128];                 ///< conversion table from asf ID 2 AVStream ID\n    ASFStream streams[128];              ///< it's max number and it's not that big\n    uint32_t stream_bitrates[128];       ///< max number of streams, bitrate for each (for streaming)\n    AVRational dar[128];\n    char stream_languages[128][6];       ///< max number of streams, language for each (RFC1766, e.g. en-US)\n    /* non streamed additonnal info */\n    /* packet filling */\n    int packet_size_left;\n    /* only for reading */\n    uint64_t data_offset;                ///< beginning of the first data packet\n    uint64_t data_object_offset;         ///< data object offset (excl. GUID & size)\n    uint64_t data_object_size;           ///< size of the data object\n    int index_read;\n\n    ASFMainHeader hdr;\n\n    int packet_flags;\n    int packet_property;\n    int packet_timestamp;\n    int packet_segsizetype;\n    int packet_segments;\n    int packet_seq;\n    int packet_replic_size;\n    int packet_key_frame;\n    int packet_padsize;\n    unsigned int packet_frag_offset;\n    unsigned int packet_frag_size;\n    int64_t packet_frag_timestamp;\n    int ts_is_pts;\n    int packet_multi_size;\n    int packet_time_delta;\n    int packet_time_start;\n    int64_t packet_pos;\n\n    int stream_index;\n\n    ASFStream *asf_st;                   ///< currently decoded stream\n\n    int no_resync_search;\n    int export_xmp;\n\n    int uses_std_ecc;\n} ASFContext;\n\nstatic const AVOption options[] = {\n    { \"no_resync_search\", \"Don't try to resynchronize by looking for a certain optional start code\", offsetof(ASFContext, no_resync_search), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, AV_OPT_FLAG_DECODING_PARAM },\n    { \"export_xmp\", \"Export full XMP metadata\", offsetof(ASFContext, export_xmp), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, AV_OPT_FLAG_DECODING_PARAM },\n    { NULL },\n};\n\nstatic const AVClass asf_class = {\n    .class_name = \"asf demuxer\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\n#undef NDEBUG\n#include <assert.h>\n\n#define ASF_MAX_STREAMS 127\n#define FRAME_HEADER_SIZE 6\n// Fix Me! FRAME_HEADER_SIZE may be different.\n// (7 is known to be too large for GipsyGuitar.wmv)\n\n#ifdef DEBUG\nstatic const ff_asf_guid stream_bitrate_guid = { /* (http://get.to/sdp) */\n    0xce, 0x75, 0xf8, 0x7b, 0x8d, 0x46, 0xd1, 0x11, 0x8d, 0x82, 0x00, 0x60, 0x97, 0xc9, 0xa2, 0xb2\n};\n\n#define PRINT_IF_GUID(g, cmp) \\\n    if (!ff_guidcmp(g, &cmp)) \\\n        av_log(NULL, AV_LOG_TRACE, \"(GUID: %s) \", # cmp)\n\nstatic void print_guid(ff_asf_guid *g)\n{\n    int i;\n    PRINT_IF_GUID(g, ff_asf_header);\n    else PRINT_IF_GUID(g, ff_asf_file_header);\n    else PRINT_IF_GUID(g, ff_asf_stream_header);\n    else PRINT_IF_GUID(g, ff_asf_audio_stream);\n    else PRINT_IF_GUID(g, ff_asf_audio_conceal_none);\n    else PRINT_IF_GUID(g, ff_asf_video_stream);\n    else PRINT_IF_GUID(g, ff_asf_video_conceal_none);\n    else PRINT_IF_GUID(g, ff_asf_command_stream);\n    else PRINT_IF_GUID(g, ff_asf_comment_header);\n    else PRINT_IF_GUID(g, ff_asf_codec_comment_header);\n    else PRINT_IF_GUID(g, ff_asf_codec_comment1_header);\n    else PRINT_IF_GUID(g, ff_asf_data_header);\n    else PRINT_IF_GUID(g, ff_asf_simple_index_header);\n    else PRINT_IF_GUID(g, ff_asf_head1_guid);\n    else PRINT_IF_GUID(g, ff_asf_head2_guid);\n    else PRINT_IF_GUID(g, ff_asf_my_guid);\n    else PRINT_IF_GUID(g, ff_asf_ext_stream_header);\n    else PRINT_IF_GUID(g, ff_asf_extended_content_header);\n    else PRINT_IF_GUID(g, ff_asf_ext_stream_embed_stream_header);\n    else PRINT_IF_GUID(g, ff_asf_ext_stream_audio_stream);\n    else PRINT_IF_GUID(g, ff_asf_metadata_header);\n    else PRINT_IF_GUID(g, ff_asf_metadata_library_header);\n    else PRINT_IF_GUID(g, ff_asf_marker_header);\n    else PRINT_IF_GUID(g, stream_bitrate_guid);\n    else PRINT_IF_GUID(g, ff_asf_language_guid);\n    else\n        av_log(NULL, AV_LOG_TRACE, \"(GUID: unknown) \");\n    for (i = 0; i < 16; i++)\n        av_log(NULL, AV_LOG_TRACE, \" 0x%02x,\", (*g)[i]);\n    av_log(NULL, AV_LOG_TRACE, \"}\\n\");\n}\n#undef PRINT_IF_GUID\n#else\n#define print_guid(g) while(0)\n#endif\n\nstatic int asf_probe(AVProbeData *pd)\n{\n    /* check file header */\n    if (!ff_guidcmp(pd->buf, &ff_asf_header))\n        return AVPROBE_SCORE_MAX;\n    else\n        return 0;\n}\n\n/* size of type 2 (BOOL) is 32bit for \"Extended Content Description Object\"\n * but 16 bit for \"Metadata Object\" and \"Metadata Library Object\" */\nstatic int get_value(AVIOContext *pb, int type, int type2_size)\n{\n    switch (type) {\n    case 2:\n        return (type2_size == 32) ? avio_rl32(pb) : avio_rl16(pb);\n    case 3:\n        return avio_rl32(pb);\n    case 4:\n        return avio_rl64(pb);\n    case 5:\n        return avio_rl16(pb);\n    default:\n        return INT_MIN;\n    }\n}\n\n/* MSDN claims that this should be \"compatible with the ID3 frame, APIC\",\n * but in reality this is only loosely similar */\nstatic int asf_read_picture(AVFormatContext *s, int len)\n{\n    AVPacket pkt          = { 0 };\n    const CodecMime *mime = ff_id3v2_mime_tags;\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n    char mimetype[64];\n    uint8_t  *desc = NULL;\n    AVStream   *st = NULL;\n    int ret, type, picsize, desc_len;\n\n    /* type + picsize + mime + desc */\n    if (len < 1 + 4 + 2 + 2) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture type */\n    type = avio_r8(s->pb);\n    len--;\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n        type = 0;\n    }\n\n    /* picture data size */\n    picsize = avio_rl32(s->pb);\n    len    -= 4;\n\n    /* picture MIME type */\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n    while (mime->id != AV_CODEC_ID_NONE) {\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n            id = mime->id;\n            break;\n        }\n        mime++;\n    }\n    if (id == AV_CODEC_ID_NONE) {\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n               mimetype);\n        return 0;\n    }\n\n    if (picsize >= len) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n               picsize, len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture description */\n    desc_len = (len - picsize) * 2 + 1;\n    desc     = av_malloc(desc_len);\n    if (!desc)\n        return AVERROR(ENOMEM);\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n    if (ret < 0)\n        goto fail;\n\n    st  = avformat_new_stream(s, NULL);\n    if (!st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n    st->codecpar->codec_type      = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id        = id;\n    st->attached_pic              = pkt;\n    st->attached_pic.stream_index = st->index;\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n    if (*desc)\n        av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_freep(&desc);\n\n    av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0);\n\n    return 0;\n\nfail:\n    av_freep(&desc);\n    av_packet_unref(&pkt);\n    return ret;\n}\n\nstatic void get_id3_tag(AVFormatContext *s, int len)\n{\n    ID3v2ExtraMeta *id3v2_extra_meta = NULL;\n\n    ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta, len);\n    if (id3v2_extra_meta)\n        ff_id3v2_parse_apic(s, &id3v2_extra_meta);\n    ff_id3v2_free_extra_meta(&id3v2_extra_meta);\n}\n\nstatic void get_tag(AVFormatContext *s, const char *key, int type, int len, int type2_size)\n{\n    ASFContext *asf = s->priv_data;\n    char *value = NULL;\n    int64_t off = avio_tell(s->pb);\n#define LEN 22\n\n    if ((unsigned)len >= (UINT_MAX - LEN) / 2)\n        return;\n\n    if (!asf->export_xmp && !strncmp(key, \"xmp\", 3))\n        goto finish;\n\n    value = av_malloc(2 * len + LEN);\n    if (!value)\n        goto finish;\n\n    switch (type) {\n    case ASF_UNICODE:\n        avio_get_str16le(s->pb, len, value, 2 * len + 1);\n        break;\n    case -1: // ASCI\n        avio_read(s->pb, value, len);\n        value[len]=0;\n        break;\n    case ASF_BYTE_ARRAY:\n        if (!strcmp(key, \"WM/Picture\")) { // handle cover art\n            asf_read_picture(s, len);\n        } else if (!strcmp(key, \"ID3\")) { // handle ID3 tag\n            get_id3_tag(s, len);\n        } else {\n            av_log(s, AV_LOG_VERBOSE, \"Unsupported byte array in tag %s.\\n\", key);\n        }\n        goto finish;\n    case ASF_BOOL:\n    case ASF_DWORD:\n    case ASF_QWORD:\n    case ASF_WORD: {\n        uint64_t num = get_value(s->pb, type, type2_size);\n        snprintf(value, LEN, \"%\"PRIu64, num);\n        break;\n    }\n    case ASF_GUID:\n        av_log(s, AV_LOG_DEBUG, \"Unsupported GUID value in tag %s.\\n\", key);\n        goto finish;\n    default:\n        av_log(s, AV_LOG_DEBUG,\n               \"Unsupported value type %d in tag %s.\\n\", type, key);\n        goto finish;\n    }\n    if (*value)\n        av_dict_set(&s->metadata, key, value, 0);\n\nfinish:\n    av_freep(&value);\n    avio_seek(s->pb, off + len, SEEK_SET);\n}\n\nstatic int asf_read_file_properties(AVFormatContext *s, int64_t size)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n\n    ff_get_guid(pb, &asf->hdr.guid);\n    asf->hdr.file_size   = avio_rl64(pb);\n    asf->hdr.create_time = avio_rl64(pb);\n    avio_rl64(pb);                               /* number of packets */\n    asf->hdr.play_time   = avio_rl64(pb);\n    asf->hdr.send_time   = avio_rl64(pb);\n    asf->hdr.preroll     = avio_rl32(pb);\n    asf->hdr.ignore      = avio_rl32(pb);\n    asf->hdr.flags       = avio_rl32(pb);\n    asf->hdr.min_pktsize = avio_rl32(pb);\n    asf->hdr.max_pktsize = avio_rl32(pb);\n    if (asf->hdr.min_pktsize >= (1U << 29))\n        return AVERROR_INVALIDDATA;\n    asf->hdr.max_bitrate = avio_rl32(pb);\n    s->packet_size       = asf->hdr.max_pktsize;\n\n    return 0;\n}\n\nstatic int asf_read_stream_properties(AVFormatContext *s, int64_t size)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    ASFStream *asf_st;\n    ff_asf_guid g;\n    enum AVMediaType type;\n    int type_specific_size, sizeX;\n    unsigned int tag1;\n    int64_t pos1, pos2, start_time;\n    int test_for_ext_stream_audio, is_dvr_ms_audio = 0;\n\n    if (s->nb_streams == ASF_MAX_STREAMS) {\n        av_log(s, AV_LOG_ERROR, \"too many streams\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    pos1 = avio_tell(pb);\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    avpriv_set_pts_info(st, 32, 1, 1000); /* 32 bit pts in ms */\n    start_time     = asf->hdr.preroll;\n\n    if (!(asf->hdr.flags & 0x01)) { // if we aren't streaming...\n        int64_t fsize = avio_size(pb);\n        if (fsize <= 0 || (int64_t)asf->hdr.file_size <= 0 ||\n            20*FFABS(fsize - (int64_t)asf->hdr.file_size) < FFMIN(fsize, asf->hdr.file_size))\n            st->duration = asf->hdr.play_time /\n                       (10000000 / 1000) - start_time;\n    }\n    ff_get_guid(pb, &g);\n\n    test_for_ext_stream_audio = 0;\n    if (!ff_guidcmp(&g, &ff_asf_audio_stream)) {\n        type = AVMEDIA_TYPE_AUDIO;\n    } else if (!ff_guidcmp(&g, &ff_asf_video_stream)) {\n        type = AVMEDIA_TYPE_VIDEO;\n    } else if (!ff_guidcmp(&g, &ff_asf_jfif_media)) {\n        type                = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id = AV_CODEC_ID_MJPEG;\n    } else if (!ff_guidcmp(&g, &ff_asf_command_stream)) {\n        type = AVMEDIA_TYPE_DATA;\n    } else if (!ff_guidcmp(&g, &ff_asf_ext_stream_embed_stream_header)) {\n        test_for_ext_stream_audio = 1;\n        type                      = AVMEDIA_TYPE_UNKNOWN;\n    } else {\n        return -1;\n    }\n    ff_get_guid(pb, &g);\n    avio_skip(pb, 8); /* total_size */\n    type_specific_size = avio_rl32(pb);\n    avio_rl32(pb);\n    st->id = avio_rl16(pb) & 0x7f; /* stream id */\n    // mapping of asf ID to AV stream ID;\n    asf->asfid2avid[st->id] = s->nb_streams - 1;\n    asf_st = &asf->streams[st->id];\n\n    avio_rl32(pb);\n\n    if (test_for_ext_stream_audio) {\n        ff_get_guid(pb, &g);\n        if (!ff_guidcmp(&g, &ff_asf_ext_stream_audio_stream)) {\n            type            = AVMEDIA_TYPE_AUDIO;\n            is_dvr_ms_audio = 1;\n            ff_get_guid(pb, &g);\n            avio_rl32(pb);\n            avio_rl32(pb);\n            avio_rl32(pb);\n            ff_get_guid(pb, &g);\n            avio_rl32(pb);\n        }\n    }\n\n    st->codecpar->codec_type = type;\n    if (type == AVMEDIA_TYPE_AUDIO) {\n        int ret = ff_get_wav_header(s, pb, st->codecpar, type_specific_size, 0);\n        if (ret < 0)\n            return ret;\n        if (is_dvr_ms_audio) {\n            // codec_id and codec_tag are unreliable in dvr_ms\n            // files. Set them later by probing stream.\n            st->request_probe    = 1;\n            st->codecpar->codec_tag = 0;\n        }\n        if (st->codecpar->codec_id == AV_CODEC_ID_AAC)\n            st->need_parsing = AVSTREAM_PARSE_NONE;\n        else\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n        /* We have to init the frame size at some point .... */\n        pos2 = avio_tell(pb);\n        if (size >= (pos2 + 8 - pos1 + 24)) {\n            asf_st->ds_span        = avio_r8(pb);\n            asf_st->ds_packet_size = avio_rl16(pb);\n            asf_st->ds_chunk_size  = avio_rl16(pb);\n            avio_rl16(pb);  // ds_data_size\n            avio_r8(pb);    // ds_silence_data\n        }\n        if (asf_st->ds_span > 1) {\n            if (!asf_st->ds_chunk_size                                ||\n                (asf_st->ds_packet_size / asf_st->ds_chunk_size <= 1) ||\n                asf_st->ds_packet_size % asf_st->ds_chunk_size)\n                asf_st->ds_span = 0;  // disable descrambling\n        }\n    } else if (type == AVMEDIA_TYPE_VIDEO &&\n               size - (avio_tell(pb) - pos1 + 24) >= 51) {\n        avio_rl32(pb);\n        avio_rl32(pb);\n        avio_r8(pb);\n        avio_rl16(pb);        /* size */\n        sizeX             = avio_rl32(pb); /* size */\n        st->codecpar->width  = avio_rl32(pb);\n        st->codecpar->height = avio_rl32(pb);\n        /* not available for asf */\n        avio_rl16(pb); /* panes */\n        st->codecpar->bits_per_coded_sample = avio_rl16(pb); /* depth */\n        tag1                             = avio_rl32(pb);\n        avio_skip(pb, 20);\n        if (sizeX > 40) {\n            st->codecpar->extradata_size = ffio_limit(pb, sizeX - 40);\n            st->codecpar->extradata      = av_mallocz(st->codecpar->extradata_size +\n                                                   AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!st->codecpar->extradata)\n                return AVERROR(ENOMEM);\n            avio_read(pb, st->codecpar->extradata, st->codecpar->extradata_size);\n        }\n\n        /* Extract palette from extradata if bpp <= 8 */\n        /* This code assumes that extradata contains only palette */\n        /* This is true for all paletted codecs implemented in libavcodec */\n        if (st->codecpar->extradata_size && (st->codecpar->bits_per_coded_sample <= 8)) {\n#if HAVE_BIGENDIAN\n            int i;\n            for (i = 0; i < FFMIN(st->codecpar->extradata_size, AVPALETTE_SIZE) / 4; i++)\n                asf_st->palette[i] = av_bswap32(((uint32_t *)st->codecpar->extradata)[i]);\n#else\n            memcpy(asf_st->palette, st->codecpar->extradata,\n                   FFMIN(st->codecpar->extradata_size, AVPALETTE_SIZE));\n#endif\n            asf_st->palette_changed = 1;\n        }\n\n        st->codecpar->codec_tag = tag1;\n        st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag1);\n        if (tag1 == MKTAG('D', 'V', 'R', ' ')) {\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n            /* issue658 contains wrong w/h and MS even puts a fake seq header\n             * with wrong w/h in extradata while a correct one is in the stream.\n             * maximum lameness */\n            st->codecpar->width      =\n                st->codecpar->height = 0;\n            av_freep(&st->codecpar->extradata);\n            st->codecpar->extradata_size = 0;\n        }\n        if (st->codecpar->codec_id == AV_CODEC_ID_H264)\n            st->need_parsing = AVSTREAM_PARSE_FULL_ONCE;\n        if (st->codecpar->codec_id == AV_CODEC_ID_MPEG4)\n            st->need_parsing = AVSTREAM_PARSE_FULL_ONCE;\n    }\n    pos2 = avio_tell(pb);\n    avio_skip(pb, size - (pos2 - pos1 + 24));\n\n    return 0;\n}\n\nstatic int asf_read_ext_stream_properties(AVFormatContext *s, int64_t size)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    ff_asf_guid g;\n    int ext_len, payload_ext_ct, stream_ct, i;\n    uint32_t leak_rate, stream_num;\n    unsigned int stream_languageid_index;\n\n    avio_rl64(pb); // starttime\n    avio_rl64(pb); // endtime\n    leak_rate = avio_rl32(pb); // leak-datarate\n    avio_rl32(pb); // bucket-datasize\n    avio_rl32(pb); // init-bucket-fullness\n    avio_rl32(pb); // alt-leak-datarate\n    avio_rl32(pb); // alt-bucket-datasize\n    avio_rl32(pb); // alt-init-bucket-fullness\n    avio_rl32(pb); // max-object-size\n    avio_rl32(pb); // flags (reliable,seekable,no_cleanpoints?,resend-live-cleanpoints, rest of bits reserved)\n    stream_num = avio_rl16(pb); // stream-num\n\n    stream_languageid_index = avio_rl16(pb); // stream-language-id-index\n    if (stream_num < 128)\n        asf->streams[stream_num].stream_language_index = stream_languageid_index;\n\n    avio_rl64(pb); // avg frametime in 100ns units\n    stream_ct      = avio_rl16(pb); // stream-name-count\n    payload_ext_ct = avio_rl16(pb); // payload-extension-system-count\n\n    if (stream_num < 128) {\n        asf->stream_bitrates[stream_num] = leak_rate;\n        asf->streams[stream_num].payload_ext_ct = 0;\n    }\n\n    for (i = 0; i < stream_ct; i++) {\n        avio_rl16(pb);\n        ext_len = avio_rl16(pb);\n        avio_skip(pb, ext_len);\n    }\n\n    for (i = 0; i < payload_ext_ct; i++) {\n        int size;\n        ff_get_guid(pb, &g);\n        size = avio_rl16(pb);\n        ext_len = avio_rl32(pb);\n        avio_skip(pb, ext_len);\n        if (stream_num < 128 && i < FF_ARRAY_ELEMS(asf->streams[stream_num].payload)) {\n            ASFPayload *p = &asf->streams[stream_num].payload[i];\n            p->type = g[0];\n            p->size = size;\n            av_log(s, AV_LOG_DEBUG, \"Payload extension %x %d\\n\", g[0], p->size );\n            asf->streams[stream_num].payload_ext_ct ++;\n        }\n    }\n\n    return 0;\n}\n\nstatic int asf_read_content_desc(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    int len1, len2, len3, len4, len5;\n\n    len1 = avio_rl16(pb);\n    len2 = avio_rl16(pb);\n    len3 = avio_rl16(pb);\n    len4 = avio_rl16(pb);\n    len5 = avio_rl16(pb);\n    get_tag(s, \"title\", 0, len1, 32);\n    get_tag(s, \"author\", 0, len2, 32);\n    get_tag(s, \"copyright\", 0, len3, 32);\n    get_tag(s, \"comment\", 0, len4, 32);\n    avio_skip(pb, len5);\n\n    return 0;\n}\n\nstatic int asf_read_ext_content_desc(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int desc_count, i, ret;\n\n    desc_count = avio_rl16(pb);\n    for (i = 0; i < desc_count; i++) {\n        int name_len, value_type, value_len;\n        char name[1024];\n\n        name_len = avio_rl16(pb);\n        if (name_len % 2)   // must be even, broken lavf versions wrote len-1\n            name_len += 1;\n        if ((ret = avio_get_str16le(pb, name_len, name, sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        value_type = avio_rl16(pb);\n        value_len  = avio_rl16(pb);\n        if (!value_type && value_len % 2)\n            value_len += 1;\n        /* My sample has that stream set to 0 maybe that mean the container.\n         * ASF stream count starts at 1. I am using 0 to the container value\n         * since it's unused. */\n        if (!strcmp(name, \"AspectRatioX\"))\n            asf->dar[0].num = get_value(s->pb, value_type, 32);\n        else if (!strcmp(name, \"AspectRatioY\"))\n            asf->dar[0].den = get_value(s->pb, value_type, 32);\n        else\n            get_tag(s, name, value_type, value_len, 32);\n    }\n\n    return 0;\n}\n\nstatic int asf_read_language_list(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int j, ret;\n    int stream_count = avio_rl16(pb);\n    for (j = 0; j < stream_count; j++) {\n        char lang[6];\n        unsigned int lang_len = avio_r8(pb);\n        if ((ret = avio_get_str16le(pb, lang_len, lang,\n                                    sizeof(lang))) < lang_len)\n            avio_skip(pb, lang_len - ret);\n        if (j < 128)\n            av_strlcpy(asf->stream_languages[j], lang,\n                       sizeof(*asf->stream_languages));\n    }\n\n    return 0;\n}\n\nstatic int asf_read_metadata(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int n, stream_num, name_len_utf16, name_len_utf8, value_len;\n    int ret, i;\n    n = avio_rl16(pb);\n\n    for (i = 0; i < n; i++) {\n        uint8_t *name;\n        int value_type;\n\n        avio_rl16(pb);  // lang_list_index\n        stream_num = avio_rl16(pb);\n        name_len_utf16 = avio_rl16(pb);\n        value_type = avio_rl16(pb); /* value_type */\n        value_len  = avio_rl32(pb);\n\n        name_len_utf8 = 2*name_len_utf16 + 1;\n        name          = av_malloc(name_len_utf8);\n        if (!name)\n            return AVERROR(ENOMEM);\n\n        if ((ret = avio_get_str16le(pb, name_len_utf16, name, name_len_utf8)) < name_len_utf16)\n            avio_skip(pb, name_len_utf16 - ret);\n        av_log(s, AV_LOG_TRACE, \"%d stream %d name_len %2d type %d len %4d <%s>\\n\",\n                i, stream_num, name_len_utf16, value_type, value_len, name);\n\n        if (!strcmp(name, \"AspectRatioX\")){\n            int aspect_x = get_value(s->pb, value_type, 16);\n            if(stream_num < 128)\n                asf->dar[stream_num].num = aspect_x;\n        } else if(!strcmp(name, \"AspectRatioY\")){\n            int aspect_y = get_value(s->pb, value_type, 16);\n            if(stream_num < 128)\n                asf->dar[stream_num].den = aspect_y;\n        } else {\n            get_tag(s, name, value_type, value_len, 16);\n        }\n        av_freep(&name);\n    }\n\n    return 0;\n}\n\nstatic int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    avio_skip(pb, name_len);\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}\n\nstatic int asf_read_header(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    ff_asf_guid g;\n    AVIOContext *pb = s->pb;\n    int i;\n    int64_t gsize;\n\n    ff_get_guid(pb, &g);\n    if (ff_guidcmp(&g, &ff_asf_header))\n        return AVERROR_INVALIDDATA;\n    avio_rl64(pb);\n    avio_rl32(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n    memset(&asf->asfid2avid, -1, sizeof(asf->asfid2avid));\n\n    for (i = 0; i<128; i++)\n        asf->streams[i].stream_language_index = 128; // invalid stream index means no language info\n\n    for (;;) {\n        uint64_t gpos = avio_tell(pb);\n        int ret = 0;\n        ff_get_guid(pb, &g);\n        gsize = avio_rl64(pb);\n        print_guid(&g);\n        if (!ff_guidcmp(&g, &ff_asf_data_header)) {\n            asf->data_object_offset = avio_tell(pb);\n            /* If not streaming, gsize is not unlimited (how?),\n             * and there is enough space in the file.. */\n            if (!(asf->hdr.flags & 0x01) && gsize >= 100)\n                asf->data_object_size = gsize - 24;\n            else\n                asf->data_object_size = (uint64_t)-1;\n            break;\n        }\n        if (gsize < 24)\n            return AVERROR_INVALIDDATA;\n        if (!ff_guidcmp(&g, &ff_asf_file_header)) {\n            ret = asf_read_file_properties(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_stream_header)) {\n            ret = asf_read_stream_properties(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_comment_header)) {\n            asf_read_content_desc(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_language_guid)) {\n            asf_read_language_list(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_extended_content_header)) {\n            asf_read_ext_content_desc(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_metadata_header)) {\n            asf_read_metadata(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_metadata_library_header)) {\n            asf_read_metadata(s, gsize);\n        } else if (!ff_guidcmp(&g, &ff_asf_ext_stream_header)) {\n            asf_read_ext_stream_properties(s, gsize);\n\n            // there could be an optional stream properties object to follow\n            // if so the next iteration will pick it up\n            continue;\n        } else if (!ff_guidcmp(&g, &ff_asf_head1_guid)) {\n            ff_get_guid(pb, &g);\n            avio_skip(pb, 6);\n            continue;\n        } else if (!ff_guidcmp(&g, &ff_asf_marker_header)) {\n            asf_read_marker(s, gsize);\n        } else if (avio_feof(pb)) {\n            return AVERROR_EOF;\n        } else {\n            if (!s->keylen) {\n                if (!ff_guidcmp(&g, &ff_asf_content_encryption)) {\n                    unsigned int len;\n                    AVPacket pkt;\n                    av_log(s, AV_LOG_WARNING,\n                           \"DRM protected stream detected, decoding will likely fail!\\n\");\n                    len= avio_rl32(pb);\n                    av_log(s, AV_LOG_DEBUG, \"Secret data:\\n\");\n\n                    if ((ret = av_get_packet(pb, &pkt, len)) < 0)\n                        return ret;\n                    av_hex_dump_log(s, AV_LOG_DEBUG, pkt.data, pkt.size);\n                    av_packet_unref(&pkt);\n                    len= avio_rl32(pb);\n                    get_tag(s, \"ASF_Protection_Type\", -1, len, 32);\n                    len= avio_rl32(pb);\n                    get_tag(s, \"ASF_Key_ID\", -1, len, 32);\n                    len= avio_rl32(pb);\n                    get_tag(s, \"ASF_License_URL\", -1, len, 32);\n                } else if (!ff_guidcmp(&g, &ff_asf_ext_content_encryption)) {\n                    av_log(s, AV_LOG_WARNING,\n                           \"Ext DRM protected stream detected, decoding will likely fail!\\n\");\n                    av_dict_set(&s->metadata, \"encryption\", \"ASF Extended Content Encryption\", 0);\n                } else if (!ff_guidcmp(&g, &ff_asf_digital_signature)) {\n                    av_log(s, AV_LOG_INFO, \"Digital signature detected!\\n\");\n                }\n            }\n        }\n        if (ret < 0)\n            return ret;\n\n        if (avio_tell(pb) != gpos + gsize)\n            av_log(s, AV_LOG_DEBUG,\n                   \"gpos mismatch our pos=%\"PRIu64\", end=%\"PRId64\"\\n\",\n                   avio_tell(pb) - gpos, gsize);\n        avio_seek(pb, gpos + gsize, SEEK_SET);\n    }\n    ff_get_guid(pb, &g);\n    avio_rl64(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n    if (avio_feof(pb))\n        return AVERROR_EOF;\n    asf->data_offset      = avio_tell(pb);\n    asf->packet_size_left = 0;\n\n    for (i = 0; i < 128; i++) {\n        int stream_num = asf->asfid2avid[i];\n        if (stream_num >= 0) {\n            AVStream *st = s->streams[stream_num];\n            if (!st->codecpar->bit_rate)\n                st->codecpar->bit_rate = asf->stream_bitrates[i];\n            if (asf->dar[i].num > 0 && asf->dar[i].den > 0) {\n                av_reduce(&st->sample_aspect_ratio.num,\n                          &st->sample_aspect_ratio.den,\n                          asf->dar[i].num, asf->dar[i].den, INT_MAX);\n            } else if ((asf->dar[0].num > 0) && (asf->dar[0].den > 0) &&\n                       // Use ASF container value if the stream doesn't set AR.\n                       (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO))\n                av_reduce(&st->sample_aspect_ratio.num,\n                          &st->sample_aspect_ratio.den,\n                          asf->dar[0].num, asf->dar[0].den, INT_MAX);\n\n            av_log(s, AV_LOG_TRACE, \"i=%d, st->codecpar->codec_type:%d, asf->dar %d:%d sar=%d:%d\\n\",\n                    i, st->codecpar->codec_type, asf->dar[i].num, asf->dar[i].den,\n                    st->sample_aspect_ratio.num, st->sample_aspect_ratio.den);\n\n            // copy and convert language codes to the frontend\n            if (asf->streams[i].stream_language_index < 128) {\n                const char *rfc1766 = asf->stream_languages[asf->streams[i].stream_language_index];\n                if (rfc1766 && strlen(rfc1766) > 1) {\n                    const char primary_tag[3] = { rfc1766[0], rfc1766[1], '\\0' }; // ignore country code if any\n                    const char *iso6392       = ff_convert_lang_to(primary_tag,\n                                                                   AV_LANG_ISO639_2_BIBL);\n                    if (iso6392)\n                        av_dict_set(&st->metadata, \"language\", iso6392, 0);\n                }\n            }\n        }\n    }\n\n    ff_metadata_conv(&s->metadata, NULL, ff_asf_metadata_conv);\n\n    return 0;\n}\n\n#define DO_2BITS(bits, var, defval)             \\\n    switch (bits & 3) {                         \\\n    case 3:                                     \\\n        var = avio_rl32(pb);                    \\\n        rsize += 4;                             \\\n        break;                                  \\\n    case 2:                                     \\\n        var = avio_rl16(pb);                    \\\n        rsize += 2;                             \\\n        break;                                  \\\n    case 1:                                     \\\n        var = avio_r8(pb);                      \\\n        rsize++;                                \\\n        break;                                  \\\n    default:                                    \\\n        var = defval;                           \\\n        break;                                  \\\n    }\n\n/**\n * Load a single ASF packet into the demuxer.\n * @param s demux context\n * @param pb context to read data from\n * @return 0 on success, <0 on error\n */\nstatic int asf_get_packet(AVFormatContext *s, AVIOContext *pb)\n{\n    ASFContext *asf = s->priv_data;\n    uint32_t packet_length, padsize;\n    int rsize = 8;\n    int c, d, e, off;\n\n    if (asf->uses_std_ecc > 0) {\n        // if we do not know packet size, allow skipping up to 32 kB\n        off = 32768;\n        if (asf->no_resync_search)\n            off = 3;\n//         else if (s->packet_size > 0 && !asf->uses_std_ecc)\n//             off = (avio_tell(pb) - s->internal->data_offset) % s->packet_size + 3;\n\n        c = d = e = -1;\n        while (off-- > 0) {\n            c = d;\n            d = e;\n            e = avio_r8(pb);\n            if (c == 0x82 && !d && !e)\n                break;\n        }\n\n        if (c != 0x82) {\n            /* This code allows handling of -EAGAIN at packet boundaries (i.e.\n            * if the packet sync code above triggers -EAGAIN). This does not\n            * imply complete -EAGAIN handling support at random positions in\n            * the stream. */\n            if (pb->error == AVERROR(EAGAIN))\n                return AVERROR(EAGAIN);\n            if (!avio_feof(pb))\n                av_log(s, AV_LOG_ERROR,\n                    \"ff asf bad header %x  at:%\"PRId64\"\\n\", c, avio_tell(pb));\n        }\n        if ((c & 0x8f) == 0x82) {\n            if (d || e) {\n                if (!avio_feof(pb))\n                    av_log(s, AV_LOG_ERROR, \"ff asf bad non zero\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            c      = avio_r8(pb);\n            d      = avio_r8(pb);\n            rsize += 3;\n        } else if(!avio_feof(pb)) {\n            avio_seek(pb, -1, SEEK_CUR); // FIXME\n        }\n    } else {\n        c = avio_r8(pb);\n        if (c & 0x80) {\n            rsize ++;\n            if (!(c & 0x60)) {\n                d = avio_r8(pb);\n                e = avio_r8(pb);\n                avio_seek(pb, (c & 0xF) - 2, SEEK_CUR);\n                rsize += c & 0xF;\n            }\n\n            if (c != 0x82)\n                avpriv_request_sample(s, \"Invalid ECC byte\");\n\n            if (!asf->uses_std_ecc)\n                asf->uses_std_ecc =  (c == 0x82 && !d && !e) ? 1 : -1;\n\n            c = avio_r8(pb);\n        } else\n            asf->uses_std_ecc =  -1;\n        d = avio_r8(pb);\n    }\n\n    asf->packet_flags    = c;\n    asf->packet_property = d;\n\n    DO_2BITS(asf->packet_flags >> 5, packet_length, s->packet_size);\n    DO_2BITS(asf->packet_flags >> 1, padsize, 0); // sequence ignored\n    DO_2BITS(asf->packet_flags >> 3, padsize, 0); // padding length\n\n    // the following checks prevent overflows and infinite loops\n    if (!packet_length || packet_length >= (1U << 29)) {\n        av_log(s, AV_LOG_ERROR,\n               \"invalid packet_length %\"PRIu32\" at:%\"PRId64\"\\n\",\n               packet_length, avio_tell(pb));\n        return AVERROR_INVALIDDATA;\n    }\n    if (padsize >= packet_length) {\n        av_log(s, AV_LOG_ERROR,\n               \"invalid padsize %\"PRIu32\" at:%\"PRId64\"\\n\", padsize, avio_tell(pb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    asf->packet_timestamp = avio_rl32(pb);\n    avio_rl16(pb); /* duration */\n    // rsize has at least 11 bytes which have to be present\n\n    if (asf->packet_flags & 0x01) {\n        asf->packet_segsizetype = avio_r8(pb);\n        rsize++;\n        asf->packet_segments = asf->packet_segsizetype & 0x3f;\n    } else {\n        asf->packet_segments    = 1;\n        asf->packet_segsizetype = 0x80;\n    }\n    if (rsize > packet_length - padsize) {\n        asf->packet_size_left = 0;\n        av_log(s, AV_LOG_ERROR,\n               \"invalid packet header length %d for pktlen %\"PRIu32\"-%\"PRIu32\" at %\"PRId64\"\\n\",\n               rsize, packet_length, padsize, avio_tell(pb));\n        return AVERROR_INVALIDDATA;\n    }\n    asf->packet_size_left = packet_length - padsize - rsize;\n    if (packet_length < asf->hdr.min_pktsize)\n        padsize += asf->hdr.min_pktsize - packet_length;\n    asf->packet_padsize = padsize;\n    av_log(s, AV_LOG_TRACE, \"packet: size=%d padsize=%d  left=%d\\n\",\n            s->packet_size, asf->packet_padsize, asf->packet_size_left);\n    return 0;\n}\n\n/**\n *\n * @return <0 if error\n */\nstatic int asf_read_frame_header(AVFormatContext *s, AVIOContext *pb)\n{\n    ASFContext *asf = s->priv_data;\n    ASFStream *asfst;\n    int rsize       = 1;\n    int num         = avio_r8(pb);\n    int i;\n    int64_t ts0, ts1 av_unused;\n\n    asf->packet_segments--;\n    asf->packet_key_frame = num >> 7;\n    asf->stream_index     = asf->asfid2avid[num & 0x7f];\n    asfst                 = &asf->streams[num & 0x7f];\n    // sequence should be ignored!\n    DO_2BITS(asf->packet_property >> 4, asf->packet_seq, 0);\n    DO_2BITS(asf->packet_property >> 2, asf->packet_frag_offset, 0);\n    DO_2BITS(asf->packet_property, asf->packet_replic_size, 0);\n    av_log(asf, AV_LOG_TRACE, \"key:%d stream:%d seq:%d offset:%d replic_size:%d num:%X packet_property %X\\n\",\n            asf->packet_key_frame, asf->stream_index, asf->packet_seq,\n            asf->packet_frag_offset, asf->packet_replic_size, num, asf->packet_property);\n    if (rsize+(int64_t)asf->packet_replic_size > asf->packet_size_left) {\n        av_log(s, AV_LOG_ERROR, \"packet_replic_size %d is invalid\\n\", asf->packet_replic_size);\n        return AVERROR_INVALIDDATA;\n    }\n    if (asf->packet_replic_size >= 8) {\n        int64_t end = avio_tell(pb) + asf->packet_replic_size;\n        AVRational aspect;\n        asfst->packet_obj_size = avio_rl32(pb);\n        if (asfst->packet_obj_size >= (1 << 24) || asfst->packet_obj_size < 0) {\n            av_log(s, AV_LOG_ERROR, \"packet_obj_size %d invalid\\n\", asfst->packet_obj_size);\n            asfst->packet_obj_size = 0;\n            return AVERROR_INVALIDDATA;\n        }\n        asf->packet_frag_timestamp = avio_rl32(pb); // timestamp\n\n        for (i = 0; i < asfst->payload_ext_ct; i++) {\n            ASFPayload *p = &asfst->payload[i];\n            int size = p->size;\n            int64_t payend;\n            if (size == 0xFFFF)\n                size = avio_rl16(pb);\n            payend = avio_tell(pb) + size;\n            if (payend > end) {\n                av_log(s, AV_LOG_ERROR, \"too long payload\\n\");\n                break;\n            }\n            switch (p->type) {\n            case 0x50:\n//              duration = avio_rl16(pb);\n                break;\n            case 0x54:\n                aspect.num = avio_r8(pb);\n                aspect.den = avio_r8(pb);\n                if (aspect.num > 0 && aspect.den > 0 && asf->stream_index >= 0) {\n                    s->streams[asf->stream_index]->sample_aspect_ratio = aspect;\n                }\n                break;\n            case 0x2A:\n                avio_skip(pb, 8);\n                ts0 = avio_rl64(pb);\n                ts1 = avio_rl64(pb);\n                if (ts0!= -1) asf->packet_frag_timestamp = ts0/10000;\n                else          asf->packet_frag_timestamp = AV_NOPTS_VALUE;\n                asf->ts_is_pts = 1;\n                break;\n            case 0x5B:\n            case 0xB7:\n            case 0xCC:\n            case 0xC0:\n            case 0xA0:\n                //unknown\n                break;\n            }\n            avio_seek(pb, payend, SEEK_SET);\n        }\n\n        avio_seek(pb, end, SEEK_SET);\n        rsize += asf->packet_replic_size; // FIXME - check validity\n    } else if (asf->packet_replic_size == 1) {\n        // multipacket - frag_offset is beginning timestamp\n        asf->packet_time_start     = asf->packet_frag_offset;\n        asf->packet_frag_offset    = 0;\n        asf->packet_frag_timestamp = asf->packet_timestamp;\n\n        asf->packet_time_delta = avio_r8(pb);\n        rsize++;\n    } else if (asf->packet_replic_size != 0) {\n        av_log(s, AV_LOG_ERROR, \"unexpected packet_replic_size of %d\\n\",\n               asf->packet_replic_size);\n        return AVERROR_INVALIDDATA;\n    }\n    if (asf->packet_flags & 0x01) {\n        DO_2BITS(asf->packet_segsizetype >> 6, asf->packet_frag_size, 0); // 0 is illegal\n        if (rsize > asf->packet_size_left) {\n            av_log(s, AV_LOG_ERROR, \"packet_replic_size is invalid\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (asf->packet_frag_size > asf->packet_size_left - rsize) {\n            if (asf->packet_frag_size > asf->packet_size_left - rsize + asf->packet_padsize) {\n                av_log(s, AV_LOG_ERROR, \"packet_frag_size is invalid (%d>%d-%d+%d)\\n\",\n                       asf->packet_frag_size, asf->packet_size_left, rsize, asf->packet_padsize);\n                return AVERROR_INVALIDDATA;\n            } else {\n                int diff = asf->packet_frag_size - (asf->packet_size_left - rsize);\n                asf->packet_size_left += diff;\n                asf->packet_padsize   -= diff;\n            }\n        }\n    } else {\n        asf->packet_frag_size = asf->packet_size_left - rsize;\n    }\n    if (asf->packet_replic_size == 1) {\n        asf->packet_multi_size = asf->packet_frag_size;\n        if (asf->packet_multi_size > asf->packet_size_left)\n            return AVERROR_INVALIDDATA;\n    }\n    asf->packet_size_left -= rsize;\n\n    return 0;\n}\n\n/**\n * Parse data from individual ASF packets (which were previously loaded\n * with asf_get_packet()).\n * @param s demux context\n * @param pb context to read data from\n * @param pkt pointer to store packet data into\n * @return 0 if data was stored in pkt, <0 on error or 1 if more ASF\n *          packets need to be loaded (through asf_get_packet())\n */\nstatic int asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt)\n{\n    ASFContext *asf   = s->priv_data;\n    ASFStream *asf_st = 0;\n    for (;;) {\n        int ret;\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        if (asf->packet_size_left < FRAME_HEADER_SIZE ||\n            asf->packet_segments < 1 && asf->packet_time_start == 0) {\n            int ret = asf->packet_size_left + asf->packet_padsize;\n\n            if (asf->packet_size_left && asf->packet_size_left < FRAME_HEADER_SIZE)\n                av_log(s, AV_LOG_WARNING, \"Skip due to FRAME_HEADER_SIZE\\n\");\n\n            assert(ret >= 0);\n            /* fail safe */\n            avio_skip(pb, ret);\n\n            asf->packet_pos = avio_tell(pb);\n            if (asf->data_object_size != (uint64_t)-1 &&\n                (asf->packet_pos - asf->data_object_offset >= asf->data_object_size))\n                return AVERROR_EOF;  /* Do not exceed the size of the data object */\n            return 1;\n        }\n        if (asf->packet_time_start == 0) {\n            if (asf_read_frame_header(s, pb) < 0) {\n                asf->packet_time_start = asf->packet_segments = 0;\n                continue;\n            }\n            if (asf->stream_index < 0 ||\n                s->streams[asf->stream_index]->discard >= AVDISCARD_ALL ||\n                (!asf->packet_key_frame &&\n                 (s->streams[asf->stream_index]->discard >= AVDISCARD_NONKEY || asf->streams[s->streams[asf->stream_index]->id].skip_to_key))) {\n                asf->packet_time_start = 0;\n                /* unhandled packet (should not happen) */\n                avio_skip(pb, asf->packet_frag_size);\n                asf->packet_size_left -= asf->packet_frag_size;\n                if (asf->stream_index < 0)\n                    av_log(s, AV_LOG_ERROR, \"ff asf skip %d (unknown stream)\\n\",\n                           asf->packet_frag_size);\n                continue;\n            }\n            asf->asf_st = &asf->streams[s->streams[asf->stream_index]->id];\n            if (!asf->packet_frag_offset)\n                asf->asf_st->skip_to_key = 0;\n        }\n        asf_st = asf->asf_st;\n        av_assert0(asf_st);\n\n        if (!asf_st->frag_offset && asf->packet_frag_offset) {\n            av_log(s, AV_LOG_TRACE, \"skipping asf data pkt with fragment offset for \"\n                    \"stream:%d, expected:%d but got %d from pkt)\\n\",\n                    asf->stream_index, asf_st->frag_offset,\n                    asf->packet_frag_offset);\n            avio_skip(pb, asf->packet_frag_size);\n            asf->packet_size_left -= asf->packet_frag_size;\n            continue;\n        }\n\n        if (asf->packet_replic_size == 1) {\n            // frag_offset is here used as the beginning timestamp\n            asf->packet_frag_timestamp = asf->packet_time_start;\n            asf->packet_time_start    += asf->packet_time_delta;\n            asf_st->packet_obj_size    = asf->packet_frag_size = avio_r8(pb);\n            asf->packet_size_left--;\n            asf->packet_multi_size--;\n            if (asf->packet_multi_size < asf_st->packet_obj_size) {\n                asf->packet_time_start = 0;\n                avio_skip(pb, asf->packet_multi_size);\n                asf->packet_size_left -= asf->packet_multi_size;\n                continue;\n            }\n            asf->packet_multi_size -= asf_st->packet_obj_size;\n        }\n\n        if (asf_st->pkt.size != asf_st->packet_obj_size ||\n            // FIXME is this condition sufficient?\n            asf_st->frag_offset + asf->packet_frag_size > asf_st->pkt.size) {\n            int ret;\n\n            if (asf_st->pkt.data) {\n                av_log(s, AV_LOG_INFO,\n                       \"freeing incomplete packet size %d, new %d\\n\",\n                       asf_st->pkt.size, asf_st->packet_obj_size);\n                asf_st->frag_offset = 0;\n                av_packet_unref(&asf_st->pkt);\n            }\n            /* new packet */\n            if ((ret = av_new_packet(&asf_st->pkt, asf_st->packet_obj_size)) < 0)\n                return ret;\n            asf_st->seq              = asf->packet_seq;\n            if (asf->ts_is_pts) {\n                asf_st->pkt.pts          = asf->packet_frag_timestamp - asf->hdr.preroll;\n            } else\n                asf_st->pkt.dts          = asf->packet_frag_timestamp - asf->hdr.preroll;\n            asf_st->pkt.stream_index = asf->stream_index;\n            asf_st->pkt.pos          = asf_st->packet_pos = asf->packet_pos;\n            asf_st->pkt_clean        = 0;\n\n            if (asf_st->pkt.data && asf_st->palette_changed) {\n                uint8_t *pal;\n                pal = av_packet_new_side_data(&asf_st->pkt, AV_PKT_DATA_PALETTE,\n                                              AVPALETTE_SIZE);\n                if (!pal) {\n                    av_log(s, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n                } else {\n                    memcpy(pal, asf_st->palette, AVPALETTE_SIZE);\n                    asf_st->palette_changed = 0;\n                }\n            }\n            av_log(asf, AV_LOG_TRACE, \"new packet: stream:%d key:%d packet_key:%d audio:%d size:%d\\n\",\n                    asf->stream_index, asf->packet_key_frame,\n                    asf_st->pkt.flags & AV_PKT_FLAG_KEY,\n                    s->streams[asf->stream_index]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO,\n                    asf_st->packet_obj_size);\n            if (s->streams[asf->stream_index]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n                asf->packet_key_frame = 1;\n            if (asf->packet_key_frame)\n                asf_st->pkt.flags |= AV_PKT_FLAG_KEY;\n        }\n\n        /* read data */\n        av_log(asf, AV_LOG_TRACE, \"READ PACKET s:%d  os:%d  o:%d,%d  l:%d   DATA:%p\\n\",\n                s->packet_size, asf_st->pkt.size, asf->packet_frag_offset,\n                asf_st->frag_offset, asf->packet_frag_size, asf_st->pkt.data);\n        asf->packet_size_left -= asf->packet_frag_size;\n        if (asf->packet_size_left < 0)\n            continue;\n\n        if (asf->packet_frag_offset >= asf_st->pkt.size ||\n            asf->packet_frag_size > asf_st->pkt.size - asf->packet_frag_offset) {\n            av_log(s, AV_LOG_ERROR,\n                   \"packet fragment position invalid %u,%u not in %u\\n\",\n                   asf->packet_frag_offset, asf->packet_frag_size,\n                   asf_st->pkt.size);\n            continue;\n        }\n\n        if (asf->packet_frag_offset != asf_st->frag_offset && !asf_st->pkt_clean) {\n            memset(asf_st->pkt.data + asf_st->frag_offset, 0, asf_st->pkt.size - asf_st->frag_offset);\n            asf_st->pkt_clean = 1;\n        }\n\n        ret = avio_read(pb, asf_st->pkt.data + asf->packet_frag_offset,\n                        asf->packet_frag_size);\n        if (ret != asf->packet_frag_size) {\n            if (ret < 0 || asf->packet_frag_offset + ret == 0)\n                return ret < 0 ? ret : AVERROR_EOF;\n\n            if (asf_st->ds_span > 1) {\n                // scrambling, we can either drop it completely or fill the remainder\n                // TODO: should we fill the whole packet instead of just the current\n                // fragment?\n                memset(asf_st->pkt.data + asf->packet_frag_offset + ret, 0,\n                       asf->packet_frag_size - ret);\n                ret = asf->packet_frag_size;\n            } else {\n                // no scrambling, so we can return partial packets\n                av_shrink_packet(&asf_st->pkt, asf->packet_frag_offset + ret);\n            }\n        }\n        if (s->key && s->keylen == 20)\n            ff_asfcrypt_dec(s->key, asf_st->pkt.data + asf->packet_frag_offset,\n                            ret);\n        asf_st->frag_offset += ret;\n        /* test if whole packet is read */\n        if (asf_st->frag_offset == asf_st->pkt.size) {\n            // workaround for macroshit radio DVR-MS files\n            if (s->streams[asf->stream_index]->codecpar->codec_id == AV_CODEC_ID_MPEG2VIDEO &&\n                asf_st->pkt.size > 100) {\n                int i;\n                for (i = 0; i < asf_st->pkt.size && !asf_st->pkt.data[i]; i++)\n                    ;\n                if (i == asf_st->pkt.size) {\n                    av_log(s, AV_LOG_DEBUG, \"discarding ms fart\\n\");\n                    asf_st->frag_offset = 0;\n                    av_packet_unref(&asf_st->pkt);\n                    continue;\n                }\n            }\n\n            /* return packet */\n            if (asf_st->ds_span > 1) {\n                if (asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span) {\n                    av_log(s, AV_LOG_ERROR,\n                           \"pkt.size != ds_packet_size * ds_span (%d %d %d)\\n\",\n                           asf_st->pkt.size, asf_st->ds_packet_size,\n                           asf_st->ds_span);\n                } else {\n                    /* packet descrambling */\n                    AVBufferRef *buf = av_buffer_alloc(asf_st->pkt.size +\n                                                       AV_INPUT_BUFFER_PADDING_SIZE);\n                    if (buf) {\n                        uint8_t *newdata = buf->data;\n                        int offset = 0;\n                        memset(newdata + asf_st->pkt.size, 0,\n                               AV_INPUT_BUFFER_PADDING_SIZE);\n                        while (offset < asf_st->pkt.size) {\n                            int off = offset / asf_st->ds_chunk_size;\n                            int row = off / asf_st->ds_span;\n                            int col = off % asf_st->ds_span;\n                            int idx = row + col * asf_st->ds_packet_size / asf_st->ds_chunk_size;\n                            assert(offset + asf_st->ds_chunk_size <= asf_st->pkt.size);\n                            assert(idx + 1 <= asf_st->pkt.size / asf_st->ds_chunk_size);\n                            memcpy(newdata + offset,\n                                   asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n                                   asf_st->ds_chunk_size);\n                            offset += asf_st->ds_chunk_size;\n                        }\n                        av_buffer_unref(&asf_st->pkt.buf);\n                        asf_st->pkt.buf  = buf;\n                        asf_st->pkt.data = buf->data;\n                    }\n                }\n            }\n            asf_st->frag_offset         = 0;\n            *pkt                        = asf_st->pkt;\n            asf_st->pkt.buf             = 0;\n            asf_st->pkt.size            = 0;\n            asf_st->pkt.data            = 0;\n            asf_st->pkt.side_data_elems = 0;\n            asf_st->pkt.side_data       = NULL;\n            break; // packet completed\n        }\n    }\n    return 0;\n}\n\nstatic int asf_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    ASFContext *asf = s->priv_data;\n\n    for (;;) {\n        int ret;\n\n        /* parse cached packets, if any */\n        if ((ret = asf_parse_packet(s, s->pb, pkt)) <= 0)\n            return ret;\n        if ((ret = asf_get_packet(s, s->pb)) < 0)\n            assert(asf->packet_size_left < FRAME_HEADER_SIZE ||\n                   asf->packet_segments < 1);\n        asf->packet_time_start = 0;\n    }\n}\n\n// Added to support seeking after packets have been read\n// If information is not reset, read_packet fails due to\n// leftover information from previous reads\nstatic void asf_reset_header(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    ASFStream *asf_st;\n    int i;\n\n    asf->packet_size_left      = 0;\n    asf->packet_flags          = 0;\n    asf->packet_property       = 0;\n    asf->packet_timestamp      = 0;\n    asf->packet_segsizetype    = 0;\n    asf->packet_segments       = 0;\n    asf->packet_seq            = 0;\n    asf->packet_replic_size    = 0;\n    asf->packet_key_frame      = 0;\n    asf->packet_padsize        = 0;\n    asf->packet_frag_offset    = 0;\n    asf->packet_frag_size      = 0;\n    asf->packet_frag_timestamp = 0;\n    asf->packet_multi_size     = 0;\n    asf->packet_time_delta     = 0;\n    asf->packet_time_start     = 0;\n\n    for (i = 0; i < 128; i++) {\n        asf_st = &asf->streams[i];\n        av_packet_unref(&asf_st->pkt);\n        asf_st->packet_obj_size = 0;\n        asf_st->frag_offset = 0;\n        asf_st->seq         = 0;\n    }\n    asf->asf_st = NULL;\n}\n\nstatic void skip_to_key(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    int i;\n\n    for (i = 0; i < 128; i++) {\n        int j = asf->asfid2avid[i];\n        ASFStream *asf_st = &asf->streams[i];\n        if (j < 0 || s->streams[j]->codecpar->codec_type != AVMEDIA_TYPE_VIDEO)\n            continue;\n\n        asf_st->skip_to_key = 1;\n    }\n}\n\nstatic int asf_read_close(AVFormatContext *s)\n{\n    asf_reset_header(s);\n\n    return 0;\n}\n\nstatic int64_t asf_read_pts(AVFormatContext *s, int stream_index,\n                            int64_t *ppos, int64_t pos_limit)\n{\n    ASFContext *asf     = s->priv_data;\n    AVPacket pkt1, *pkt = &pkt1;\n    ASFStream *asf_st;\n    int64_t pts;\n    int64_t pos = *ppos;\n    int i;\n    int64_t start_pos[ASF_MAX_STREAMS];\n\n    for (i = 0; i < s->nb_streams; i++)\n        start_pos[i] = pos;\n\n    if (s->packet_size > 0)\n        pos = (pos + s->packet_size - 1 - s->internal->data_offset) /\n              s->packet_size * s->packet_size +\n              s->internal->data_offset;\n    *ppos = pos;\n    if (avio_seek(s->pb, pos, SEEK_SET) < 0)\n        return AV_NOPTS_VALUE;\n\n    ff_read_frame_flush(s);\n    asf_reset_header(s);\n    for (;;) {\n        if (av_read_frame(s, pkt) < 0) {\n            av_log(s, AV_LOG_INFO, \"asf_read_pts failed\\n\");\n            return AV_NOPTS_VALUE;\n        }\n\n        pts = pkt->dts;\n\n        if (pkt->flags & AV_PKT_FLAG_KEY) {\n            i = pkt->stream_index;\n\n            asf_st = &asf->streams[s->streams[i]->id];\n\n//            assert((asf_st->packet_pos - s->data_offset) % s->packet_size == 0);\n            pos = asf_st->packet_pos;\n            av_assert1(pkt->pos == asf_st->packet_pos);\n\n            av_add_index_entry(s->streams[i], pos, pts, pkt->size,\n                               pos - start_pos[i] + 1, AVINDEX_KEYFRAME);\n            start_pos[i] = asf_st->packet_pos + 1;\n\n            if (pkt->stream_index == stream_index) {\n                av_packet_unref(pkt);\n                break;\n            }\n        }\n        av_packet_unref(pkt);\n    }\n\n    *ppos = pos;\n    return pts;\n}\n\nstatic int asf_build_simple_index(AVFormatContext *s, int stream_index)\n{\n    ff_asf_guid g;\n    ASFContext *asf     = s->priv_data;\n    int64_t current_pos = avio_tell(s->pb);\n    int64_t ret;\n\n    if((ret = avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET)) < 0) {\n        return ret;\n    }\n\n    if ((ret = ff_get_guid(s->pb, &g)) < 0)\n        goto end;\n\n    /* the data object can be followed by other top-level objects,\n     * skip them until the simple index object is reached */\n    while (ff_guidcmp(&g, &ff_asf_simple_index_header)) {\n        int64_t gsize = avio_rl64(s->pb);\n        if (gsize < 24 || avio_feof(s->pb)) {\n            goto end;\n        }\n        avio_skip(s->pb, gsize - 24);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n    }\n\n    {\n        int64_t itime, last_pos = -1;\n        int pct, ict;\n        int i;\n        int64_t av_unused gsize = avio_rl64(s->pb);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n        itime = avio_rl64(s->pb);\n        pct   = avio_rl32(s->pb);\n        ict   = avio_rl32(s->pb);\n        av_log(s, AV_LOG_DEBUG,\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n\n        for (i = 0; i < ict; i++) {\n            int pktnum        = avio_rl32(s->pb);\n            int pktct         = avio_rl16(s->pb);\n            int64_t pos       = s->internal->data_offset + s->packet_size * (int64_t)pktnum;\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n\n            if (pos != last_pos) {\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n                       pktnum, pktct, index_pts);\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n                last_pos = pos;\n            }\n        }\n        asf->index_read = ict > 1;\n    }\nend:\n//     if (avio_feof(s->pb)) {\n//         ret = 0;\n//     }\n    avio_seek(s->pb, current_pos, SEEK_SET);\n    return ret;\n}\n\nstatic int asf_read_seek(AVFormatContext *s, int stream_index,\n                         int64_t pts, int flags)\n{\n    ASFContext *asf = s->priv_data;\n    AVStream *st    = s->streams[stream_index];\n    int ret = 0;\n\n    if (s->packet_size <= 0)\n        return -1;\n\n    /* Try using the protocol's read_seek if available */\n    if (s->pb) {\n        int64_t ret = avio_seek_time(s->pb, stream_index, pts, flags);\n        if (ret >= 0)\n            asf_reset_header(s);\n        if (ret != AVERROR(ENOSYS))\n            return ret;\n    }\n\n    /* explicitly handle the case of seeking to 0 */\n    if (!pts) {\n        asf_reset_header(s);\n        avio_seek(s->pb, s->internal->data_offset, SEEK_SET);\n        return 0;\n    }\n\n    if (!asf->index_read) {\n        ret = asf_build_simple_index(s, stream_index);\n        if (ret < 0)\n            asf->index_read = -1;\n    }\n\n    if (asf->index_read > 0 && st->index_entries) {\n        int index = av_index_search_timestamp(st, pts, flags);\n        if (index >= 0) {\n            /* find the position */\n            uint64_t pos = st->index_entries[index].pos;\n\n            /* do the seek */\n            av_log(s, AV_LOG_DEBUG, \"SEEKTO: %\"PRId64\"\\n\", pos);\n            if(avio_seek(s->pb, pos, SEEK_SET) < 0)\n                return -1;\n            asf_reset_header(s);\n            skip_to_key(s);\n            return 0;\n        }\n    }\n    /* no index or seeking by index failed */\n    if (ff_seek_frame_binary(s, stream_index, pts, flags) < 0)\n        return -1;\n    asf_reset_header(s);\n    skip_to_key(s);\n    return 0;\n}\n\nAVInputFormat ff_asf_demuxer = {\n    .name           = \"asf\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"ASF (Advanced / Active Streaming Format)\"),\n    .priv_data_size = sizeof(ASFContext),\n    .read_probe     = asf_probe,\n    .read_header    = asf_read_header,\n    .read_packet    = asf_read_packet,\n    .read_close     = asf_read_close,\n    .read_seek      = asf_read_seek,\n    .read_timestamp = asf_read_pts,\n    .flags          = AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH,\n    .priv_class     = &asf_class,\n};\n"], "filenames": ["libavformat/asfdec_f.c"], "buggy_code_start_loc": [752], "buggy_code_end_loc": [757], "fixing_code_start_loc": [752], "fixing_code_end_loc": [760], "type": "CWE-834", "message": "In FFmpeg 3.3.3, a DoS in asf_read_marker() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted ASF file, which claims a large \"name_len\" or \"count\" field in the header but does not contain sufficient backing data, is provided, the loops over the name and markers would consume huge CPU and memory resources, since there is no EOF check inside these loops.", "other": {"cve": {"id": "CVE-2017-14057", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-31T15:29:00.420", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In FFmpeg 3.3.3, a DoS in asf_read_marker() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted ASF file, which claims a large \"name_len\" or \"count\" field in the header but does not contain sufficient backing data, is provided, the loops over the name and markers would consume huge CPU and memory resources, since there is no EOF check inside these loops."}, {"lang": "es", "value": "En FFmpeg 3.3.3, se podr\u00eda realizar un ataque de denegaci\u00f3n de servicio en asf_read_marker() al no haber un chequeo EOF (End Of File) que podr\u00eda provocar acabar en un gran consumo de CPU y de memoria. Cuando se env\u00eda un archivo MV manipulado que reclama un campo \"name_len\" o \"count\" grande en la cabecera pero que no contiene suficientes datos de respaldo, los bucles en torno al nombre y los marcadores consumir\u00edan una gran cantidad de recursos de CPU y de memoria, ya que no hay ning\u00fan chequeo EOF en estos bucles."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100630", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/7f9ec5593e04827249e7aeb466da06a98a0d7329", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7f9ec5593e04827249e7aeb466da06a98a0d7329"}}