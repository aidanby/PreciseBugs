{"buggy_code": ["/*\n * Copyright (C) 1996-2023 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n#include \"squid.h\"\n#include \"rfc1123.h\"\n\n/*\n *  Adapted from HTSUtils.c in CERN httpd 3.0 (http://info.cern.ch/httpd/)\n *  by Darren Hardy <hardy@cs.colorado.edu>, November 1994.\n */\n#if HAVE_STRING_H\n#include <string.h>\n#endif\n#if HAVE_CTYPE_H\n#include <ctype.h>\n#endif\n#if HAVE_TIME_H\n#include <time.h>\n#endif\n\n#define RFC850_STRFTIME \"%A, %d-%b-%y %H:%M:%S GMT\"\n#define RFC1123_STRFTIME \"%a, %d %b %Y %H:%M:%S GMT\"\n\nstatic int make_month(const char *s);\nstatic int make_num(const char *s);\n\nstatic const char *month_names[12] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\nstatic int\nmake_num(const char *s)\n{\n    if (*s >= '0' && *s <= '9')\n        return 10 * (*s - '0') + *(s + 1) - '0';\n    else\n        return *(s + 1) - '0';\n}\n\nstatic int\nmake_month(const char *s)\n{\n    int i;\n    char month[3];\n\n    month[0] = xtoupper(*s);\n    month[1] = xtolower(*(s + 1));\n    month[2] = xtolower(*(s + 2));\n\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}\n\nstatic int\ntmSaneValues(struct tm *tm)\n{\n    if (tm->tm_sec < 0 || tm->tm_sec > 59)\n        return 0;\n    if (tm->tm_min < 0 || tm->tm_min > 59)\n        return 0;\n    if (tm->tm_hour < 0 || tm->tm_hour > 23)\n        return 0;\n    if (tm->tm_mday < 1 || tm->tm_mday > 31)\n        return 0;\n    if (tm->tm_mon < 0 || tm->tm_mon > 11)\n        return 0;\n    return 1;\n}\n\nstatic struct tm *\nparse_date_elements(const char *day, const char *month, const char *year,\n                    const char *aTime, const char *zone) {\n    static struct tm tm;\n    char *t;\n    memset(&tm, 0, sizeof(tm));\n\n    if (!day || !month || !year || !aTime || (zone && strcmp(zone, \"GMT\")))\n        return NULL;\n    tm.tm_mday = atoi(day);\n    tm.tm_mon = make_month(month);\n    if (tm.tm_mon < 0)\n        return NULL;\n    tm.tm_year = atoi(year);\n    if (strlen(year) == 4)\n        tm.tm_year -= 1900;\n    else if (tm.tm_year < 70)\n        tm.tm_year += 100;\n    else if (tm.tm_year > 19000)\n        tm.tm_year -= 19000;\n    tm.tm_hour = make_num(aTime);\n    t = strchr(aTime, ':');\n    if (!t)\n        return NULL;\n    t++;\n    tm.tm_min = atoi(t);\n    t = strchr(t, ':');\n    if (t)\n        tm.tm_sec = atoi(t + 1);\n    return tmSaneValues(&tm) ? &tm : NULL;\n}\n\nstatic struct tm *\nparse_date(const char *str) {\n    struct tm *tm;\n    static char tmp[64];\n    char *t;\n    char *wday = NULL;\n    char *day = NULL;\n    char *month = NULL;\n    char *year = NULL;\n    char *timestr = NULL;\n    char *zone = NULL;\n\n    xstrncpy(tmp, str, 64);\n\n    for (t = strtok(tmp, \", \"); t; t = strtok(NULL, \", \")) {\n        if (xisdigit(*t)) {\n            if (!day) {\n                day = t;\n                t = strchr(t, '-');\n                if (t) {\n                    *t++ = '\\0';\n                    month = t;\n                    t = strchr(t, '-');\n                    if (!t)\n                        return NULL;\n                    *t++ = '\\0';\n                    year = t;\n                }\n            } else if (strchr(t, ':'))\n                timestr = t;\n            else if (!year)\n                year = t;\n            else\n                return NULL;\n        } else if (!wday)\n            wday = t;\n        else if (!month)\n            month = t;\n        else if (!zone)\n            zone = t;\n        else\n            return NULL;\n    }\n    tm = parse_date_elements(day, month, year, timestr, zone);\n\n    return tm;\n}\n\ntime_t\nparse_rfc1123(const char *str)\n{\n    struct tm *tm;\n    time_t t;\n    if (NULL == str)\n        return -1;\n    tm = parse_date(str);\n    if (!tm)\n        return -1;\n    tm->tm_isdst = -1;\n#if HAVE_TIMEGM\n    t = timegm(tm);\n#elif HAVE_TM_TM_GMTOFF\n    t = mktime(tm);\n    if (t != -1) {\n        struct tm *local = localtime(&t);\n        t += local->tm_gmtoff;\n    }\n#else\n    /* some systems do not have tm_gmtoff so we fake it */\n    t = mktime(tm);\n    if (t != -1) {\n        time_t dst = 0;\n#if !(defined(_TIMEZONE) || defined(_timezone) || _SQUID_AIX_ || _SQUID_WINDOWS_ || _SQUID_SGI_)\n        extern long timezone;\n#endif\n        /*\n         * The following assumes a fixed DST offset of 1 hour,\n         * which is probably wrong.\n         */\n        if (tm->tm_isdst > 0)\n            dst = -3600;\n#if defined(_timezone) || _SQUID_WINDOWS_\n        t -= (_timezone + dst);\n#else\n        t -= (timezone + dst);\n#endif\n    }\n#endif\n    return t;\n}\n\nconst char *\nmkrfc1123(time_t t)\n{\n    static char buf[128];\n\n    struct tm *gmt = gmtime(&t);\n\n    buf[0] = '\\0';\n    strftime(buf, 127, RFC1123_STRFTIME, gmt);\n    return buf;\n}\n\n#if 0\nint\nmain()\n{\n    char *x;\n    time_t t, pt;\n\n    t = time(NULL);\n    x = mkrfc1123(t);\n    printf(\"HTTP Time: %s\\n\", x);\n\n    pt = parse_rfc1123(x);\n    printf(\"Parsed: %d vs. %d\\n\", pt, t);\n}\n\n#endif\n\n"], "fixing_code": ["/*\n * Copyright (C) 1996-2023 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n#include \"squid.h\"\n#include \"rfc1123.h\"\n\n/*\n *  Adapted from HTSUtils.c in CERN httpd 3.0 (http://info.cern.ch/httpd/)\n *  by Darren Hardy <hardy@cs.colorado.edu>, November 1994.\n */\n#if HAVE_STRING_H\n#include <string.h>\n#endif\n#if HAVE_CTYPE_H\n#include <ctype.h>\n#endif\n#if HAVE_TIME_H\n#include <time.h>\n#endif\n\n#define RFC850_STRFTIME \"%A, %d-%b-%y %H:%M:%S GMT\"\n#define RFC1123_STRFTIME \"%a, %d %b %Y %H:%M:%S GMT\"\n\nstatic int make_month(const char *s);\nstatic int make_num(const char *s);\n\nstatic const char *month_names[12] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\nstatic int\nmake_num(const char *s)\n{\n    if (*s >= '0' && *s <= '9')\n        return 10 * (*s - '0') + *(s + 1) - '0';\n    else\n        return *(s + 1) - '0';\n}\n\nstatic int\nmake_month(const char *s)\n{\n    int i;\n    char month[3];\n\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; // protects *(s + 1) below\n\n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; // protects *(s + 2) below\n\n    month[2] = xtolower(*(s + 2));\n\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}\n\nstatic int\ntmSaneValues(struct tm *tm)\n{\n    if (tm->tm_sec < 0 || tm->tm_sec > 59)\n        return 0;\n    if (tm->tm_min < 0 || tm->tm_min > 59)\n        return 0;\n    if (tm->tm_hour < 0 || tm->tm_hour > 23)\n        return 0;\n    if (tm->tm_mday < 1 || tm->tm_mday > 31)\n        return 0;\n    if (tm->tm_mon < 0 || tm->tm_mon > 11)\n        return 0;\n    return 1;\n}\n\nstatic struct tm *\nparse_date_elements(const char *day, const char *month, const char *year,\n                    const char *aTime, const char *zone) {\n    static struct tm tm;\n    char *t;\n    memset(&tm, 0, sizeof(tm));\n\n    if (!day || !month || !year || !aTime || (zone && strcmp(zone, \"GMT\")))\n        return NULL;\n    tm.tm_mday = atoi(day);\n    tm.tm_mon = make_month(month);\n    if (tm.tm_mon < 0)\n        return NULL;\n    tm.tm_year = atoi(year);\n    if (strlen(year) == 4)\n        tm.tm_year -= 1900;\n    else if (tm.tm_year < 70)\n        tm.tm_year += 100;\n    else if (tm.tm_year > 19000)\n        tm.tm_year -= 19000;\n    tm.tm_hour = make_num(aTime);\n    t = strchr(aTime, ':');\n    if (!t)\n        return NULL;\n    t++;\n    tm.tm_min = atoi(t);\n    t = strchr(t, ':');\n    if (t)\n        tm.tm_sec = atoi(t + 1);\n    return tmSaneValues(&tm) ? &tm : NULL;\n}\n\nstatic struct tm *\nparse_date(const char *str) {\n    struct tm *tm;\n    static char tmp[64];\n    char *t;\n    char *wday = NULL;\n    char *day = NULL;\n    char *month = NULL;\n    char *year = NULL;\n    char *timestr = NULL;\n    char *zone = NULL;\n\n    xstrncpy(tmp, str, 64);\n\n    for (t = strtok(tmp, \", \"); t; t = strtok(NULL, \", \")) {\n        if (xisdigit(*t)) {\n            if (!day) {\n                day = t;\n                t = strchr(t, '-');\n                if (t) {\n                    *t++ = '\\0';\n                    month = t;\n                    t = strchr(t, '-');\n                    if (!t)\n                        return NULL;\n                    *t++ = '\\0';\n                    year = t;\n                }\n            } else if (strchr(t, ':'))\n                timestr = t;\n            else if (!year)\n                year = t;\n            else\n                return NULL;\n        } else if (!wday)\n            wday = t;\n        else if (!month)\n            month = t;\n        else if (!zone)\n            zone = t;\n        else\n            return NULL;\n    }\n    tm = parse_date_elements(day, month, year, timestr, zone);\n\n    return tm;\n}\n\ntime_t\nparse_rfc1123(const char *str)\n{\n    struct tm *tm;\n    time_t t;\n    if (NULL == str)\n        return -1;\n    tm = parse_date(str);\n    if (!tm)\n        return -1;\n    tm->tm_isdst = -1;\n#if HAVE_TIMEGM\n    t = timegm(tm);\n#elif HAVE_TM_TM_GMTOFF\n    t = mktime(tm);\n    if (t != -1) {\n        struct tm *local = localtime(&t);\n        t += local->tm_gmtoff;\n    }\n#else\n    /* some systems do not have tm_gmtoff so we fake it */\n    t = mktime(tm);\n    if (t != -1) {\n        time_t dst = 0;\n#if !(defined(_TIMEZONE) || defined(_timezone) || _SQUID_AIX_ || _SQUID_WINDOWS_ || _SQUID_SGI_)\n        extern long timezone;\n#endif\n        /*\n         * The following assumes a fixed DST offset of 1 hour,\n         * which is probably wrong.\n         */\n        if (tm->tm_isdst > 0)\n            dst = -3600;\n#if defined(_timezone) || _SQUID_WINDOWS_\n        t -= (_timezone + dst);\n#else\n        t -= (timezone + dst);\n#endif\n    }\n#endif\n    return t;\n}\n\nconst char *\nmkrfc1123(time_t t)\n{\n    static char buf[128];\n\n    struct tm *gmt = gmtime(&t);\n\n    buf[0] = '\\0';\n    strftime(buf, 127, RFC1123_STRFTIME, gmt);\n    return buf;\n}\n\n#if 0\nint\nmain()\n{\n    char *x;\n    time_t t, pt;\n\n    t = time(NULL);\n    x = mkrfc1123(t);\n    printf(\"HTTP Time: %s\\n\", x);\n\n    pt = parse_rfc1123(x);\n    printf(\"Parsed: %d vs. %d\\n\", pt, t);\n}\n\n#endif\n\n"], "filenames": ["lib/rfc1123.c"], "buggy_code_start_loc": [52], "buggy_code_end_loc": [53], "fixing_code_start_loc": [53], "fixing_code_end_loc": [60], "type": "CWE-125", "message": "Squid is a caching proxy for the Web supporting HTTP, HTTPS, FTP, and more. Due to a Buffer Overread bug Squid is vulnerable to a Denial of Service attack against Squid HTTP Message processing. This bug is fixed by Squid version 6.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-49285", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-04T23:15:27.007", "lastModified": "2024-01-19T16:15:09.653", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Squid is a caching proxy for the Web supporting HTTP, HTTPS, FTP, and more. Due to a Buffer Overread bug Squid is vulnerable to a Denial of Service attack against Squid HTTP Message processing. This bug is fixed by Squid version 6.5. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Squid es un proxy de almacenamiento en cach\u00e9 para la Web que admite HTTP, HTTPS, FTP y m\u00e1s. Debido a un error de sobrelectura del b\u00fafer, Squid es vulnerable a un ataque de denegaci\u00f3n de servicio contra el procesamiento de mensajes HTTP de Squid. Este error se solucion\u00f3 con la versi\u00f3n 6.5 de Squid. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.4", "matchCriteriaId": "64A6EFAB-804C-4B6B-B609-2F5A797EACB0"}]}]}], "references": [{"url": "http://www.squid-cache.org/Versions/v5/SQUID-2023_7.patch", "source": "security-advisories@github.com", "tags": ["Broken Link"]}, {"url": "http://www.squid-cache.org/Versions/v6/SQUID-2023_7.patch", "source": "security-advisories@github.com", "tags": ["Broken Link"]}, {"url": "https://github.com/squid-cache/squid/commit/77b3fb4df0f126784d5fd4967c28ed40eb8d521b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/squid-cache/squid/commit/deee944f9a12c9fd399ce52f3e2526bb573a9470", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/squid-cache/squid/security/advisories/GHSA-8w9r-p88v-mmx9", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00003.html", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A5QASTMCUSUEW3UOMKHZJB3FTONWSRXS/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MEV66D3PAAY6K7TWDT3WZBLCPLASFJDC/", "source": "security-advisories@github.com"}, {"url": "https://security.netapp.com/advisory/ntap-20240119-0004/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/squid-cache/squid/commit/77b3fb4df0f126784d5fd4967c28ed40eb8d521b"}}