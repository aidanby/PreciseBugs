{"buggy_code": ["# CMakeLists file for DIPlib 3\ncmake_minimum_required(VERSION 3.5)\nif(POLICY CMP0068)\n   cmake_policy(SET CMP0068 NEW)\nendif()\n\nproject(DIPlib)\n\n# The version number and latest copyright year. Update these values here, they're used all throughout the project.\nset(PROJECT_VERSION_MAJOR \"3\")\nset(PROJECT_VERSION_MINOR \"0\")\nset(PROJECT_VERSION_PATCH \"0\")\nset(PROJECT_VERSION \"${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}\")\nset(DIP_COPYRIGHT_YEAR \"2021\")\n\n# Debug or Release?\nif(NOT CMAKE_CONFIGURATION_TYPES AND NOT CMAKE_BUILD_TYPE)\n   set(CMAKE_BUILD_TYPE Release)\nendif()\n\n# Static or shared?\nset(DIP_SHARED_LIBRARY ON CACHE BOOL \"Build a shared library (off for static library)\")\nset(BUILD_SHARED_LIBS ${DIP_SHARED_LIBRARY})\n\n# Installation path\nset(CMAKE_INSTALL_PREFIX \"${CMAKE_BUILD_TYPE}\" CACHE PATH \"Installation directory\")\nset(DOCUMENTATION_OUTPUT share/doc/DIPlib)\nset(DIPIMAGE_INSTALL_PATH share/DIPimage)\nset(RUNTIME_DESTINATION bin)\nif(WIN32)\n   set(LIBRARY_DESTINATION bin)\nelse()\n   set(LIBRARY_DESTINATION lib)\nendif()\nset(ARCHIVE_DESTINATION lib)\nset(DIP_DESTINATIONS\n    RUNTIME DESTINATION ${RUNTIME_DESTINATION}\n    LIBRARY DESTINATION ${LIBRARY_DESTINATION}\n    ARCHIVE DESTINATION ${ARCHIVE_DESTINATION})\n\n# Compiler flags\nif(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") # also matchs \"AppleClang\"\n   # Compiler flags for Clang C++\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Wconversion -Wsign-conversion -pedantic -Wno-c++17-extensions\")\n   #set(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -march=native\") # This is optimal for local usage.\n   set(CMAKE_CXX_FLAGS_SANITIZE \"${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address\")\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n   # Compiler flags for GNU C++\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Wextra -Wconversion -Wsign-conversion -pedantic\")\n   # \"#pragma omp\" causes a warning if OpenMP is not enabled.\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-unknown-pragmas\")\n   # \"enum class DIP_EXPORT\" causes a warning in GCC 5.4, fixed in 6.0.\n   # \"DIP_EXPORT\" in forward class declaration sometimes causes a warning in GCC 6.0 and 7.0.\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-attributes\")\n   #set(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -march=native\") # This is optimal for local usage; to see which flags are enabled: gcc -march=native -Q --help=target\n   set(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -Og\") # Does some optimization that doesn't impact debugging.\n   set(CMAKE_CXX_FLAGS_SANITIZE \"${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address\")\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"Intel\")\n   # Compiler flags for Intel C++\n   # TODO: compiler flags for Intel compiler\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n   # Compiler flags for Visual Studio C++\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /bigobj\")\n   add_definitions(-D_SCL_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS) # Disable unchecked iterator warnings and unsafe (string manipulation) function warnings\n   add_definitions(/wd4180) # Disable \"qualifier applied to function type has no meaning; ignored\" that happens in union_find.h as used in maxima.cpp\n   add_definitions(/EHa) # This exception handling model apparently is what MATLAB uses (default is /EHsc)\n   add_definitions(/MP) # Enable Multi-Processor compilation\nendif()\n\n# RPATH\n#set(CMAKE_MACOSX_RPATH 1) # This is the default\n#set(CMAKE_SKIP_BUILD_RPATH 0)\nset(CMAKE_BUILD_WITH_INSTALL_RPATH 1) # Prevent relinking when installing\n#set(CMAKE_INSTALL_RPATH_USE_LINK_PATH 1)\n\n# Extend CMake module path\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_CURRENT_SOURCE_DIR}/tools\")\n\n# OpenMP\nfind_package(OpenMP)\nif(OpenMP_CXX_FOUND OR OPENMP_FOUND) # OPENMP_FOUND for CMake <= 3.8\n   set(DIP_ENABLE_MULTITHREADING ON CACHE BOOL \"Enable multithreading support\")\nendif()\n\ninclude(tools/update_deps_file.cmake)\n\n\n### DIPlib library\n\nadd_subdirectory(src)\n\n\n### DIPjavaio\n\nfind_package(Java 1.7 COMPONENTS Development)\nif(JAVA_FOUND)\n   # Set JAVA_HOME so that the JNI found is from the same JDK as the Java package\n   get_filename_component(JAVA_HOME \"${Java_JAVAC_EXECUTABLE}\" DIRECTORY) # strip off /javac\n   get_filename_component(JAVA_HOME \"${JAVA_HOME}\" DIRECTORY)             # strip off /bin\n   find_package(JNI)\n   if(JNI_FOUND)\n      set(DIP_BUILD_JAVAIO ON CACHE BOOL \"Build the javaio module\")\n      include(UseJava)\n      find_jar(BIOFORMATS_JAR bioformats_package)\n      if(BIOFORMATS_JAR)\n         list(APPEND DIP_JAVAIO_INTERFACES \"Bio-Formats\")\n      endif()\n   endif()\n   set(CMAKE_JAVA_COMPILE_FLAGS -target 1.7 -source 1.7) # MATLAB R2013b--R2017a use Java SDK 1.7, R2017b-- use SDK 1.8.\n   # TODO: Make target Java version configurable?\nendif()\n\nif(DIP_BUILD_JAVAIO)\n   add_subdirectory(javaio)\nendif()\n\n\n### DIPviewer\n\n# OpenGL, FreeGLUT, GLFW\nfind_package(OpenGL)\nif(NOT APPLE)\n   find_package(FreeGLUT)\nendif()\nif(FREEGLUT_FOUND)\n   list(APPEND DIP_VIEWER_MANAGERS \"FreeGLUT\")\n   set(FREEGLUT_STATIC OFF CACHE BOOL \"Link to static FreeGLUT library\")\nendif()\nfind_package(GLFW)\nif(GLFW_FOUND)\n   list(APPEND DIP_VIEWER_MANAGERS \"GLFW\")\nendif()\n\nif(OPENGL_FOUND AND (FREEGLUT_FOUND OR GLFW_FOUND))\n   set(DIP_BUILD_DIPVIEWER ON CACHE BOOL \"Build the viewer module\")\nendif()\n\nif(DIP_BUILD_DIPVIEWER)\n   set(THREADS_PREFER_PTHREAD_FLAG ON)\n   find_package(Threads REQUIRED)\n   add_subdirectory(viewer)\nendif()\n\n\n### PyDIP module for Python\n\n# Some code modified from the Pybind11 cmake file, to determine if Python is installed.\n# Pybind11 cmake file calls `find_package` for Python with `REQUIRED`, which causes the\n# build to fail if Python is not installed. Here we disable the `DIP_BUILD_PYDIP` setting\n# if there is no Python libraries.\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_CURRENT_SOURCE_DIR}/dependencies/pybind11/tools\")\nset(Python_ADDITIONAL_VERSIONS ${PYBIND11_PYTHON_VERSION} 3.10 3.9 3.8 3.7 3.6 3.5) # TODO: This line will need to be updated when new versions of Python are released\n   # CMake 3.5 knows about Python 3.6 and older, but by adding these version numbers here we make sure Python3 is found over Python2.\nfind_package(PythonLibsNew)\n\nif(PYTHONLIBS_FOUND)\n   set(DIP_BUILD_PYDIP ON CACHE BOOL \"Build the PyDIP Python module\")\nendif()\n\nif(DIP_BUILD_PYDIP)\n   add_subdirectory(pydip)\nendif()\n\n\n### DIPimage toolbox for MATLAB\n\nif(DIP_SHARED_LIBRARY)\n   # We will not build DIPimage without a shared DIPlib -- technically possible, but not desireable.\n   # (This would also require solving linker warnings because of Doctest.)\n\n   #set(MATLAB_ADDITIONAL_VERSIONS \"R2018b=9.5\") # You might need to add a line like this if your version of MATLAB is not recognized\n   find_package(Matlab COMPONENTS MAIN_PROGRAM) # NOTE! Here we use the local copy of the FindMatlab.cmake script\n   if(Matlab_FOUND)\n      set(DIP_BUILD_DIPIMAGE ON CACHE BOOL \"Build the DIPimage toolbox\")\n   endif()\n\nendif()\n\nif(DIP_BUILD_DIPIMAGE)\n   add_subdirectory(dipimage)\nendif()\n\n\n### Documentation\n\nadd_subdirectory(doc)\n\n### Examples\n\nadd_subdirectory(examples EXCLUDE_FROM_ALL)\n\n\n### Packaging\n\n# Write CMake configuration import scripts (but only when DIPlib is a shared library)\nif(DIP_SHARED_LIBRARY)\n\n   include(CMakePackageConfigHelpers)\n   set(ConfigPackageLocation lib/cmake/DIPlib)\n\n   export(EXPORT DIPlibTargets\n          FILE \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibTargets.cmake\"\n          NAMESPACE DIPlib::)\n   install(EXPORT DIPlibTargets\n           FILE DIPlibTargets.cmake\n           NAMESPACE DIPlib::\n           DESTINATION ${ConfigPackageLocation})\n\n   configure_package_config_file(\n         tools/DIPlibConfig.cmake.in\n         \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibConfig.cmake\"\n         INSTALL_DESTINATION ${ConfigPackageLocation})\n   write_basic_package_version_file(\n         \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibConfigVersion.cmake\"\n         VERSION ${DIPlib_VERSION}\n         COMPATIBILITY SameMajorVersion)\n   install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibConfigVersion.cmake\"\n                 \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibConfig.cmake\"\n           DESTINATION ${ConfigPackageLocation})\n\nendif()\n\n# Package stuff\nif(CMAKE_HOST_WIN32)\n   # On Windows we use the NSIS generator\n   # TODO: This must be tested and configured properly\n   set(CPACK_GENERATOR \"NSIS\")\n#elseif(CMAKE_HOST_APPLE)\n   # On MacOS we use the Bundle generator\n   #set(CPACK_GENERATOR \"Bundle\")\n   #CPACK_BUNDLE_NAME\n   #CPACK_BUNDLE_ICON\n   #CPACK_BUNDLE_PLIST\n   #CPACK_BUNDLE_STARTUP_COMMAND # What would the startup command be???\nelse()\n   # On Linux (or any other platform) we use a tar file\n   set(CPACK_GENERATOR \"TBZ2\")\nendif()\nset(CPACK_RESOURCE_FILE_README \"${CMAKE_CURRENT_SOURCE_DIR}/README.md\")\nset(CPACK_PACKAGE_VENDOR \"The DIPlib Project\")\nset(CPACK_PACKAGE_CONTACT \"https://github.com/DIPlib/DIPlib\")\nset(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.txt\")\nset(CPACK_PACKAGE_VERSION_MAJOR \"${PROJECT_VERSION_MAJOR}\")\nset(CPACK_PACKAGE_VERSION_MINOR \"${PROJECT_VERSION_MINOR}\")\nstring(TIMESTAMP TODAYS_DATE \"%Y%m%d\" UTC)\nset(CPACK_PACKAGE_VERSION_PATCH \"${PROJECT_VERSION_PATCH}-${TODAYS_DATE}\")\n#CPACK_PACKAGE_ICON\ninclude(CPack)\n# TODO: The package doesn't contain any of the dependencies: OpenMP, C++ stdlib, etc.\n#       Including these is highly dependent on the configuration of the system used for compiling.\n#       Posible solutions:\n#        - `install(PROGRAMS ${libname} DESTINATION lib)`\n#          We'd then need to modify the library names and the search locations using `install_name_tool`,\n#          see http://doc.qt.io/qt-4.8/deployment-mac.html#linking-the-application-to-qt-as-frameworks\n#        See also: https://cmake.org/cmake/help/v3.5/manual/cmake-packages.7.html#creating-relocatable-packages\n\n\n### Status report\n\nmessage(\"\")\nmessage(\"--------------------------------------\")\nmessage(\"   DIPlib CONFIGURATION REPORT\")\nmessage(\"\")\n\nmessage(\" * PROJECT_VERSION: ${PROJECT_VERSION}\")\nmessage(\" * DIP_COPYRIGHT_YEAR: ${DIP_COPYRIGHT_YEAR}\")\n\nmessage(\" * C++ compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}\")\nif(NOT \"${CMAKE_BUILD_TYPE}\" STREQUAL \"\")\n   string(TOUPPER ${CMAKE_BUILD_TYPE} UPPERCASE_BUILD_TYPE)\n   message(\" * C++ compiler flags: ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_${UPPERCASE_BUILD_TYPE}}\")\n   message(\" * Build type: ${CMAKE_BUILD_TYPE}\")\nendif()\n\nif(DIP_SHARED_LIBRARY)\n   message(\" * Building shared library\")\nelse()\n   message(\" * Building static library\")\nendif()\nmessage(\" * Library installed to: ${CMAKE_INSTALL_PREFIX}/${LIBRARY_DESTINATION}\")\nmessage(\" * Binaries installed to: ${CMAKE_INSTALL_PREFIX}/${RUNTIME_DESTINATION}\")\nif (WIN32)\n   message(\" * Import library installed to: ${CMAKE_INSTALL_PREFIX}/${ARCHIVE_DESTINATION}\")\nendif()\nmessage(\" * Header files installed to: ${CMAKE_INSTALL_PREFIX}/include\")\n\nif(DOXPP_FOUND)\n   message(\" * Documentation installed to: ${CMAKE_INSTALL_PREFIX}/${DOCUMENTATION_OUTPUT}\")\nelse()\n   message(\" * dox++ program not configured, no documentation can be generated\")\nendif()\n\n\nif(DIP_ENABLE_MULTITHREADING)\n   message(\" * Using OpenMP for multithreading\")\nelse()\n   message(\" * Multithreading disabled\")\nendif()\n\nif(DIP_ENABLE_STACK_TRACE)\n   message(\" * Stack trace recording enabled\")\nelse()\n   message(\" * Stack trace recording disabled\")\nendif()\nif(DIP_ENABLE_ASSERT)\n   message(\" * Asserts enabled\")\nelse()\n   message(\" * Asserts disabled\")\nendif()\nif(DIP_ENABLE_UNICODE)\n   message(\" * Unicode support enabled\")\nelse()\n   message(\" * Unicode support disabled\")\nendif()\nif(HAS_128_INT)\n   message(\" * Using 128-bit PRNG\")\nelse()\n   message(\" * Using 64-bit PRNG\")\nendif()\n\nif(DIP_ENABLE_ICS)\n   if(DIP_ENABLE_ZLIB)\n      set(features \", with zlib\")\n   else()\n      set(features \", without zlib\")\n   endif()\n   message(\" * ICS file IO enabled${features}\")\nelse()\n   message(\" * ICS file IO disabled\")\nendif()\nif(DIP_ENABLE_TIFF)\n   set(features \"\")\n   if(DIP_ENABLE_ZLIB)\n      set(features \"${features}, with zlib\")\n   else()\n      set(features \"${features}, without zlib\")\n   endif()\n   if(DIP_ENABLE_JPEG)\n      set(features \"${features}, with JPEG\")\n   else()\n      set(features \"${features}, without JPEG\")\n   endif()\n   message(\" * TIFF file IO enabled${features}\")\nelse()\n   message(\" * TIFF file IO disabled\")\nendif()\nif(DIP_ENABLE_JPEG)\n   message(\" * JPEG file IO enabled\")\nelse()\n   message(\" * JPEG file IO disabled\")\nendif()\n\nif(DIP_ENABLE_FFTW)\n   message(\" * Using FFT from FFTW3 library (GPL)\")\nelse()\n   message(\" * Using built-in FFT\")\nendif()\n\nif(DIP_ENABLE_DOCTEST)\n   message(\" * Unit test code included\")\nelse()\n   message(\" * Unit test code excluded\")\nendif()\n\nif(DIP_BUILD_DIPVIEWER)\n   message(\" * DIPviewer module added to 'all' with window managers: ${DIP_VIEWER_MANAGERS}\")\n   if (FREEGLUT_STATIC)\n      message(\" * Using static FreeGLUT library\")\n   endif()\nelse()\n   message(\" * DIPviewer module not configured\")\nendif()\n\nif(DIP_BUILD_DIPVIEWER_JAVA)\n   message(\" * DIPviewer Java bindings added to 'all' target\")\nelse()\n   message(\" * DIPviewer Java bindings not configured\")\nendif()\n\nif(DIP_BUILD_JAVAIO)\n   message(\" * DIPjavaio module added to 'all' target with interfaces: ${DIP_JAVAIO_INTERFACES}\")\n   message(\" * DIPjavaio compiled using Java version ${Java_VERSION_STRING}\")\nelse()\n   message(\" * DIPJavaio module not configured\")\nendif()\n\nif(DIP_BUILD_PYDIP)\n   message(\" * PyDIP module added to 'all' target\")\n   message(\" * PyDIP compiled for Python version ${PYTHON_VERSION_STRING}\")\n   if(DIP_PYDIP_WHEEL_INCLUDE_LIBS)\n      message(\" * PyDIP includes libraries in binary wheel\")\n   else()\n      message(\" * PyDIP does not include libraries in binary wheel\")\n   endif()\nelse()\n   message(\" * PyDIP module not configured\")\nendif()\n\nif(DIP_BUILD_DIPIMAGE)\n   message(\" * DIPimage toolbox added to 'all' target\")\n   matlab_get_release_name_from_version(${Matlab_VERSION_STRING} Matlab_RELEASE_NAME)\n   message(\" * DIPimage toolbox compiled for MATLAB ${Matlab_RELEASE_NAME}\")\n   message(\" * DIPimage toolbox installed to: ${CMAKE_INSTALL_PREFIX}/${DIPIMAGE_INSTALL_PATH}\")\n   if(DOXPP_FOUND)\n      message(\" * DIPimage User Manual installed to: ${CMAKE_INSTALL_PREFIX}/${DOCUMENTATION_OUTPUT}/html/dipimage_user_manual.html\")\n   else()\n      message(\" * DIPimage User Manual cannot be created (dox++ program not configured)\")\n   endif()\nelse()\n   message(\" * DIPimage toolbox not configured\")\nendif()\n\nif(CMAKE_GENERATOR MATCHES \"Unix Makefiles\")\n   message(\"\")\n   if(DIP_ENABLE_DOCTEST)\n      message(\"Next, type 'make; make check; make install'\")\n   else()\n      message(\"Next, type 'make; make install'\")\n   endif()\n   if(DOXPP_FOUND)\n      message(\"Type 'make apidoc' to build the documentation\")\n   endif()\nendif()\n\nmessage(\"\")\nmessage(\"--------------------------------------\")\nmessage(\"\")\n", "---\nlayout: post\ntitle: \"Changes DIPlib 3.1.0\"\n---\n\n## Changes to *DIPlib*\n\n### New functionality\n\n- Added `dip::MarginalPercentile()` histogram-based statistics function.\n\n- Added `dip::SplitRegions()`, a function to transform labeled images.\n\n- Added `dip::FlushToZero()`, a function to remove denormal values from an image.\n\n- Added `dip::maximum_gauss_truncation()`, returning the maximum truncation that is useful for Gaussian functions.\n\n- `dip::NeighborList` allows accessing neighbors by index, through the new member functions `Coordinates`,\n  `Distance` and `IsInImage`.\n\n- Added `dip::Measurement::SetObjectIDs()`.\n\n- Added `dip::Image::SwapBytesInSample()` to convert from little endian to big endian representation.\n\n- Added `dip::ImageReadNPY()`, `dip::ImageReadNPYInfo()`, `dip::ImageIsNPY()` and `dip::ImageWriteNPY()`, to\n  work with NumPy's NPY files, expanding interoperability with Python.\n\n- Compound assignment operators defined for image views (`img[ 0 ] += ...` now works).\n\n- Added `dip::GetLabelBoundingBox()`.\n\n- Added `dip::IsotropicDilation()` and `dip::IsotropicErosion()` for binary images.\n\n- Added `dip::Image::Sample::Maximum()` and `dip::Image::Sample::Minimum()`.\n\n- Added `dip::ImposeMinima()`.\n\n### Changed functionality\n\n- Replaced the use of `std::map` and `std::set` in various functions to `tsl::robin_map` and\n  `tsl::robin_set`, which are significantly faster. This affects `dip::Measurement` and functions\n  using it (including `dip::MeasurementTool::Measure()`), `dip::GetImageChainCodes()`, `dip::GetObjectLabels()`,\n  `dip::Relabel()`, `dip::ChordLength()` and `dip::PairCorrelation()`.\n\n- The speed of the following functions has been improved:\n    - `dip::Measurement::AddObjectIDs()` and `dip::Measurement::operator+()`.\n    - `dip::Label` (slightly more efficient for 3D and higher-dimensional images).\n    - `dip::MomentAccumulator`.\n    - `dip::MorphologicalReconstruction` and functions that depend on it.\n\n- `dip::OptimalFourierTransformSize()` has a new option to return a smaller or equal size, rather than\n  a larger or equal size, so we can crop an image for efficient FFT instead of padding.\n\n- All the variants of the Gaussian filter (`dip::Gauss()` et al.) now limit the truncation value to avoid\n  unnecessarily large filter kernels. `dip::DrawBandlimitedPoint()`, `dip::DrawBandlimitedBall()`,\n  `dip::DrawBandlimitedBox()`, `dip::GaussianEdgeClip()` and `dip::GaussianLineClip()` also limit the\n  truncation in the same way.\n\n- `dip::ColorSpaceConverter` has a `SetWhitePoint` member function. `dip::ColorSpaceManager::SetWhitePoint`\n  calls the `SetWhitePoint` member function for all registered converters. This allows custom converters\n  to use the white point as well.\n\n- `dip::ColorSpaceManager::XYZ` is deprecated, use `dip::XYZ` instead.\n\n- `dip::SetNumberOfThreads()` and `dip::GetNumberOfThreads()` set a thread-local value now. Each\n  thread should set its own limit for how many threads *DIPlib* can use.\n\n- All functions that used randomness internally but didn't have a `dip::Random` input parameter now do\n  have such a parameter. Overloaded functions with the old signature create a default-initialized\n  `dip::Random` object and call the function with the new signature. This affects the following functions:\n  `dip::ChordLength`, `dip::PairCorrelation`, `dip::ProbabilisticPairCorrelation`, `dip::Semivariogram`,\n  `dip::CostesSignificanceTest`, `dip::StochasticWatershed`, `dip::KMeansClustering`, and `dip::Superpixels`.\n\n- `dip::Image::Rotation90()` can now be called without any arguments at all.\n\n### Bug fixes\n\n- `dip::DrawPolygon2D()` produced wrong results for filled polygons when vertices were very close together\n  (distances smaller than a pixel).\n\n- `dip::ColorSpaceManager` didn't register the ICH and ISH color spaces.\n\n- `dip::Image::ResetNonDataProperties()` incorrectly set the number of tensor elements to 1.\n\n- `dip::Image::Copy()` would incorrectly copy the external interface if the destination image didn't have one defined.\n\n- `dip::MaximumPixel()` and `dip::MinimumPixel()` produced an empty output array when the input was all NaN.\n\n- `dip::Image::HasSameDimensionOrder()` didn't properly ignore singleton dimensions.\n\n- `dip::GaussianMixtureModelThreshold()` passed wrong parameter values to `dip::GaussianMixtureModel()`.\n\n- `dip::ResampleAt(in, map)` didn't use the pixels at the right or bottom edges of the input image.\n\n- Fixed various issues in underlying code for `dip::AreaOpening()`, `dip::AreaClosing()`, `dip::VolumeOpening()` and `dip::VolumeClosing()`.\n  These functions now behave as described in the documentation.\n\n- There was a strange rounding error when creating disk-shaped filter kernels and structuring elements,\n  for some even integer sizes, which caused these kernels to be not symmetric over 90 degree rotations.\n\n- `dip::MeanAbs()` and `dip::SumAbs()` could produce wrong results for complex inputs.\n\n- libics had a typo that caused out-of-bounds read (#81). \n\n\n\n\n## Changes to *DIPimage*\n\n### New functionality\n\n- Added `dip_image/ftz`, a function to remove denormal values from an image.\n\n### Changed functionality\n\n- Most functions now also accept a string array instead of char vector or a cell array of char vectors\n  (that is, `\"foo\"` is now interpreted the same as `'foo'`, and `[\"foo\",\"bar\"]` is now interpreted the\n  same as `{'foo','bar'}`).\n\n(See also changes to *DIPlib*.)\n\n### Bug fixes\n\n- `readim` and `writeim`, when using *MATLAB*'s functionality, would work in linear RGB space, instead of sRGB\n  like the *DIPlib* functions do.\n\n- `readics` tried to read the file as a TIFF file instead of an ICS file.\n\n- Code like `img * [1,2,3]` converted the second argument into a 0D column vector image. The same code\n  with e.g. a 3x3 matrix would convert the matrix to a scalar 3x3 image, rather than a 0D matrix image.\n  These now behave more similarly to how they behaved in *DIPimage* 2.9.\n\n(See also bugfixes to *DIPlib*.)\n\n\n\n\n## Changes to *PyDIP*\n\n### New functionality\n\n- Added `dip.FlushToZero()`, `dip.SplitRegions()`, `dip.ApplyWindow()`.\n\n- Added `dip.ImageReadNPY()`, `dip.ImageReadNPYInfo()`, `dip.ImageIsNPY()` and `dip.ImageWriteNPY()`.\n\n- Added `dip.FourierMellinMatch2Dparams()`, identical to `dip.FourierMellinMatch2D()` but it also returns the\n  transform parameters (which `dip.FourierMellinMatch2D()` should have done from the beginning).\n\n- Added `dip.GetLabelBoundingBox()`.\n\n- Added `dip.IsotropicDilation()` and `dip.IsotropicErosion()` for binary images.\n\n- Added `dip.ImposeMinima()`.\n\n### Changed functionality\n\n- `dip.ChordLength`, `dip.PairCorrelation`, `dip.ProbabilisticPairCorrelation`, `dip.Semivariogram`,\n  `dip.CostesSignificanceTest`, `dip.StochasticWatershed`, `dip.KMeansClustering`, and `dip.Superpixels`\n  now use the global random number generator instead of creating a default-initialized one.\n\n(See also changes to *DIPlib*.)\n\n### Bug fixes\n\n- Updated default connectivity values in the morphology and binary image processing modules to match the defaults in *DIPlib*.\n\n(See also bugfixes to *DIPlib*.)\n\n\n\n\n## Changes to *DIPviewer*\n\n### New functionality\n\n### Changed functionality\n\n### Bug fixes\n\n\n\n\n## Changes to *DIPjavaio*\n\n### New functionality\n\n### Changed functionality\n\n### Bug fixes\n\n- Signed integer images could not be read.\n", "/*\n * DIPlib 3.0\n * This file contains definitions for JPEG reading and writing\n *\n * (c)2019, Cris Luengo.\n * Based on original DIPlib code: (c)1995-2014, Delft University of Technology.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef DIP_CONFIG_HAS_JPEG\n\n#include \"diplib.h\"\n#include \"diplib/file_io.h\"\n\n#include \"jpeglib.h\"\n#include <setjmp.h>\n\nnamespace dip {\n\nnamespace {\n\n// JPEG error handling stuff - modified from example.c in libjpeg source\nstruct my_error_mgr {\n   struct jpeg_error_mgr pub;   // \"public\" fields\n   jmp_buf setjmp_buffer;      // for return to caller\n};\nusing my_error_ptr = struct my_error_mgr*;\n\nvoid my_error_exit( j_common_ptr cinfo ) {\n   // cinfo->err really points to a my_error_mgr struct, so coerce pointer\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   // Return control to the setjmp point\n   longjmp( myerr->setjmp_buffer, 1 );\n}\n\nvoid my_output_message( j_common_ptr ) {} // Don't do anything with messages!\n\nclass JpegInput {\n   public:\n      JpegInput( String filename ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); // Try with \"jpg\" extension\n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); // Try with \"jpeg\" extension\n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            // If we get here, the JPEG code has signaled an error.\n            DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n         }\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }\n      JpegInput( JpegInput const& ) = delete;\n      JpegInput( JpegInput&& ) = delete;\n      JpegInput& operator=( JpegInput const& ) = delete;\n      JpegInput& operator=( JpegInput&& ) = delete;\n      ~JpegInput() {\n         if( initialized_ ) {\n            jpeg_destroy_decompress( &cinfo_ );\n         }\n         if( infile_ ) {\n            std::fclose( infile_ );\n         }\n      }\n      // Retrieve jpeg_decompress_struct\n      jpeg_decompress_struct& cinfo() { return cinfo_; }\n      j_decompress_ptr cinfoptr() { return &cinfo_; }\n      // Retrieve file name\n      String const& FileName() const { return filename_; }\n   private:\n      String filename_;\n      FILE* infile_ = nullptr;\n      jpeg_decompress_struct cinfo_;\n      my_error_mgr jerr_;\n      bool initialized_ = false;\n};\n\nclass JpegOutput {\n   public:\n      explicit JpegOutput( String const& filename ) {\n         // Open the file for writing\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            // If we get here, the JPEG code has signaled an error.\n            DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n         }\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }\n      JpegOutput( JpegOutput const& ) = delete;\n      JpegOutput( JpegOutput&& ) = delete;\n      JpegOutput& operator=( JpegOutput const& ) = delete;\n      JpegOutput& operator=( JpegOutput&& ) = delete;\n      ~JpegOutput() {\n         if( initialized_ ) {\n            jpeg_destroy_compress( &cinfo_ );\n         }\n         if( outfile_ ) {\n            std::fclose( outfile_ );\n         }\n      }\n      // Retrieve jpeg_decompress_struct\n      jpeg_compress_struct& cinfo() { return cinfo_; }\n      j_compress_ptr cinfoptr() { return &cinfo_; }\n   private:\n      FILE* outfile_ = nullptr;\n      jpeg_compress_struct cinfo_;\n      my_error_mgr jerr_;\n      bool initialized_ = false;\n};\n\nFileInformation GetJPEGInfo( JpegInput& jpeg ) {\n   FileInformation fileInformation;\n   fileInformation.name = jpeg.FileName();\n   fileInformation.fileType = \"JPEG\";\n   fileInformation.numberOfImages = 1;\n   fileInformation.significantBits = 8;\n   fileInformation.dataType = DT_UINT8;\n   fileInformation.tensorElements = static_cast< dip::uint >( jpeg.cinfo().num_components );\n   fileInformation.colorSpace = fileInformation.tensorElements == 3 ? \"sRGB\" : \"\";\n   fileInformation.sizes = { jpeg.cinfo().image_width, jpeg.cinfo().image_height };\n   PhysicalQuantity units;\n   switch (jpeg.cinfo().density_unit) {\n      default: // no units\n         units = Units::Pixel();\n         break;\n      case 1: // dots per inch\n         units = PhysicalQuantity::Inch();\n         break;\n      case 2: // dots per cm\n         units = PhysicalQuantity::Centimeter();\n   }\n   fileInformation.pixelSize = {{ units / static_cast< dfloat >( jpeg.cinfo().X_density ),\n                                  units / static_cast< dfloat >( jpeg.cinfo().Y_density ) }};\n   return fileInformation;\n}\n\n} // namespace\n\nFileInformation ImageReadJPEG(\n      Image& out,\n      String const& filename\n) {\n   // Open the file\n   JpegInput jpeg( filename );\n\n   // Get info\n   FileInformation info = GetJPEGInfo( jpeg );\n\n   // Allocate image\n   int nchan = jpeg.cinfo().num_components;\n   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );\n   out.SetPixelSize( info.pixelSize );\n   out.SetColorSpace( info.colorSpace );\n\n   // Read data\n   jpeg_start_decompress( jpeg.cinfoptr() );\n   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); // casting to unsigned rather than dip::uint to shut up GCC warning.\n   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );\n   auto stride = out.Strides();\n   auto tStride = out.TensorStride();\n   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {\n      JSAMPLE* indata = buffer.data();\n      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );\n      dip::uint8* outdata = imagedata;\n      if( nchan > 1 ) {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            for( int kk = 0; kk < nchan; ++kk ) {\n               *( outdata + kk * tStride ) = *indata;\n               ++indata;\n            }\n            outdata += stride[ 0 ];\n         }\n      } else {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            *outdata = *indata;\n            ++indata;\n            outdata += stride[ 0 ];\n         }\n      }\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_decompress( jpeg.cinfoptr() );\n\n   return info;\n}\n\nFileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}\n\nbool ImageIsJPEG( String const& filename ) {\n   try {\n      JpegInput jpeg( filename );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}\n\nvoid ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n\n   // Open the file\n   JpegOutput jpeg( filename );\n\n   // Set image properties\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; // dots per cm\n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); // let's assume it's meter\n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n\n   // Convert the image to uint8 if necessary\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n\n   // Write data\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}\n\n} // namespace dip\n\n#else // DIP_CONFIG_HAS_JPEG\n\n#include \"diplib.h\"\n#include \"diplib/file_io.h\"\n\nnamespace dip {\n\nstatic char const* NOT_AVAILABLE = \"DIPlib was compiled without JPEG support.\";\n\nFileInformation ImageReadJPEG( Image&, String const& ) {\n   DIP_THROW( NOT_AVAILABLE );\n}\n\nFileInformation ImageReadJPEGInfo( String const& ) {\n   DIP_THROW( NOT_AVAILABLE );\n}\n\nbool ImageIsJPEG( String const& ) {\n   DIP_THROW( NOT_AVAILABLE );\n}\n\nvoid ImageWriteJPEG( Image const&, String const&, dip::uint ) {\n   DIP_THROW( NOT_AVAILABLE );\n}\n\n}\n\n#endif // DIP_CONFIG_HAS_JPEG\n"], "fixing_code": ["# CMakeLists file for DIPlib 3\ncmake_minimum_required(VERSION 3.5)\nif(POLICY CMP0068)\n   cmake_policy(SET CMP0068 NEW)\nendif()\n\nproject(DIPlib)\n\n# The version number and latest copyright year. Update these values here, they're used all throughout the project.\nset(PROJECT_VERSION_MAJOR \"3\")\nset(PROJECT_VERSION_MINOR \"0\")\nset(PROJECT_VERSION_PATCH \"0\")\nset(PROJECT_VERSION \"${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}\")\nset(DIP_COPYRIGHT_YEAR \"2021\")\n\n# Debug or Release?\nif(NOT CMAKE_CONFIGURATION_TYPES AND NOT CMAKE_BUILD_TYPE)\n   set(CMAKE_BUILD_TYPE Release)\nendif()\n\n# Static or shared?\nset(DIP_SHARED_LIBRARY ON CACHE BOOL \"Build a shared library (off for static library)\")\nset(BUILD_SHARED_LIBS ${DIP_SHARED_LIBRARY})\n\n# Installation path\nset(CMAKE_INSTALL_PREFIX \"${CMAKE_BUILD_TYPE}\" CACHE PATH \"Installation directory\")\nset(DOCUMENTATION_OUTPUT share/doc/DIPlib)\nset(DIPIMAGE_INSTALL_PATH share/DIPimage)\nset(RUNTIME_DESTINATION bin)\nif(WIN32)\n   set(LIBRARY_DESTINATION bin)\nelse()\n   set(LIBRARY_DESTINATION lib)\nendif()\nset(ARCHIVE_DESTINATION lib)\nset(DIP_DESTINATIONS\n    RUNTIME DESTINATION ${RUNTIME_DESTINATION}\n    LIBRARY DESTINATION ${LIBRARY_DESTINATION}\n    ARCHIVE DESTINATION ${ARCHIVE_DESTINATION})\n\n# Compiler flags\nif(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") # also matchs \"AppleClang\"\n   # Compiler flags for Clang C++\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Wconversion -Wsign-conversion -pedantic -Wno-c++17-extensions\")\n   #set(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -march=native\") # This is optimal for local usage.\n   set(CMAKE_C_FLAGS_SANITIZE \"${CMAKE_C_FLAGS_DEBUG} -fsanitize=address\")\n   set(CMAKE_CXX_FLAGS_SANITIZE \"${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address\")\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n   # Compiler flags for GNU C++\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Wextra -Wconversion -Wsign-conversion -pedantic\")\n   # \"#pragma omp\" causes a warning if OpenMP is not enabled.\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-unknown-pragmas\")\n   # \"enum class DIP_EXPORT\" causes a warning in GCC 5.4, fixed in 6.0.\n   # \"DIP_EXPORT\" in forward class declaration sometimes causes a warning in GCC 6.0 and 7.0.\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-attributes\")\n   #set(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -march=native\") # This is optimal for local usage; to see which flags are enabled: gcc -march=native -Q --help=target\n   set(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG} -Og\") # Does some optimization that doesn't impact debugging.\n   set(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -Og\") # Does some optimization that doesn't impact debugging.\n   set(CMAKE_C_FLAGS_SANITIZE \"${CMAKE_C_FLAGS_DEBUG} -fsanitize=address\")\n   set(CMAKE_CXX_FLAGS_SANITIZE \"${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address\")\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"Intel\")\n   # Compiler flags for Intel C++\n   # TODO: compiler flags for Intel compiler\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n   # Compiler flags for Visual Studio C++\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /bigobj\")\n   add_definitions(-D_SCL_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS) # Disable unchecked iterator warnings and unsafe (string manipulation) function warnings\n   add_definitions(/wd4180) # Disable \"qualifier applied to function type has no meaning; ignored\" that happens in union_find.h as used in maxima.cpp\n   add_definitions(/EHa) # This exception handling model apparently is what MATLAB uses (default is /EHsc)\n   add_definitions(/MP) # Enable Multi-Processor compilation\nendif()\n\n# RPATH\n#set(CMAKE_MACOSX_RPATH 1) # This is the default\n#set(CMAKE_SKIP_BUILD_RPATH 0)\nset(CMAKE_BUILD_WITH_INSTALL_RPATH 1) # Prevent relinking when installing\n#set(CMAKE_INSTALL_RPATH_USE_LINK_PATH 1)\n\n# Extend CMake module path\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_CURRENT_SOURCE_DIR}/tools\")\n\n# OpenMP\nfind_package(OpenMP)\nif(OpenMP_CXX_FOUND OR OPENMP_FOUND) # OPENMP_FOUND for CMake <= 3.8\n   set(DIP_ENABLE_MULTITHREADING ON CACHE BOOL \"Enable multithreading support\")\nendif()\n\ninclude(tools/update_deps_file.cmake)\n\n\n### DIPlib library\n\nadd_subdirectory(src)\n\n\n### DIPjavaio\n\nfind_package(Java 1.7 COMPONENTS Development)\nif(JAVA_FOUND)\n   # Set JAVA_HOME so that the JNI found is from the same JDK as the Java package\n   get_filename_component(JAVA_HOME \"${Java_JAVAC_EXECUTABLE}\" DIRECTORY) # strip off /javac\n   get_filename_component(JAVA_HOME \"${JAVA_HOME}\" DIRECTORY)             # strip off /bin\n   find_package(JNI)\n   if(JNI_FOUND)\n      set(DIP_BUILD_JAVAIO ON CACHE BOOL \"Build the javaio module\")\n      include(UseJava)\n      find_jar(BIOFORMATS_JAR bioformats_package)\n      if(BIOFORMATS_JAR)\n         list(APPEND DIP_JAVAIO_INTERFACES \"Bio-Formats\")\n      endif()\n   endif()\n   set(CMAKE_JAVA_COMPILE_FLAGS -target 1.7 -source 1.7) # MATLAB R2013b--R2017a use Java SDK 1.7, R2017b-- use SDK 1.8.\n   # TODO: Make target Java version configurable?\nendif()\n\nif(DIP_BUILD_JAVAIO)\n   add_subdirectory(javaio)\nendif()\n\n\n### DIPviewer\n\n# OpenGL, FreeGLUT, GLFW\nfind_package(OpenGL)\nif(NOT APPLE)\n   find_package(FreeGLUT)\nendif()\nif(FREEGLUT_FOUND)\n   list(APPEND DIP_VIEWER_MANAGERS \"FreeGLUT\")\n   set(FREEGLUT_STATIC OFF CACHE BOOL \"Link to static FreeGLUT library\")\nendif()\nfind_package(GLFW)\nif(GLFW_FOUND)\n   list(APPEND DIP_VIEWER_MANAGERS \"GLFW\")\nendif()\n\nif(OPENGL_FOUND AND (FREEGLUT_FOUND OR GLFW_FOUND))\n   set(DIP_BUILD_DIPVIEWER ON CACHE BOOL \"Build the viewer module\")\nendif()\n\nif(DIP_BUILD_DIPVIEWER)\n   set(THREADS_PREFER_PTHREAD_FLAG ON)\n   find_package(Threads REQUIRED)\n   add_subdirectory(viewer)\nendif()\n\n\n### PyDIP module for Python\n\n# Some code modified from the Pybind11 cmake file, to determine if Python is installed.\n# Pybind11 cmake file calls `find_package` for Python with `REQUIRED`, which causes the\n# build to fail if Python is not installed. Here we disable the `DIP_BUILD_PYDIP` setting\n# if there is no Python libraries.\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_CURRENT_SOURCE_DIR}/dependencies/pybind11/tools\")\nset(Python_ADDITIONAL_VERSIONS ${PYBIND11_PYTHON_VERSION} 3.10 3.9 3.8 3.7 3.6 3.5) # TODO: This line will need to be updated when new versions of Python are released\n   # CMake 3.5 knows about Python 3.6 and older, but by adding these version numbers here we make sure Python3 is found over Python2.\nfind_package(PythonLibsNew)\n\nif(PYTHONLIBS_FOUND)\n   set(DIP_BUILD_PYDIP ON CACHE BOOL \"Build the PyDIP Python module\")\nendif()\n\nif(DIP_BUILD_PYDIP)\n   add_subdirectory(pydip)\nendif()\n\n\n### DIPimage toolbox for MATLAB\n\nif(DIP_SHARED_LIBRARY)\n   # We will not build DIPimage without a shared DIPlib -- technically possible, but not desireable.\n   # (This would also require solving linker warnings because of Doctest.)\n\n   #set(MATLAB_ADDITIONAL_VERSIONS \"R2018b=9.5\") # You might need to add a line like this if your version of MATLAB is not recognized\n   find_package(Matlab COMPONENTS MAIN_PROGRAM) # NOTE! Here we use the local copy of the FindMatlab.cmake script\n   if(Matlab_FOUND)\n      set(DIP_BUILD_DIPIMAGE ON CACHE BOOL \"Build the DIPimage toolbox\")\n   endif()\n\nendif()\n\nif(DIP_BUILD_DIPIMAGE)\n   add_subdirectory(dipimage)\nendif()\n\n\n### Documentation\n\nadd_subdirectory(doc)\n\n### Examples\n\nadd_subdirectory(examples EXCLUDE_FROM_ALL)\n\n\n### Packaging\n\n# Write CMake configuration import scripts (but only when DIPlib is a shared library)\nif(DIP_SHARED_LIBRARY)\n\n   include(CMakePackageConfigHelpers)\n   set(ConfigPackageLocation lib/cmake/DIPlib)\n\n   export(EXPORT DIPlibTargets\n          FILE \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibTargets.cmake\"\n          NAMESPACE DIPlib::)\n   install(EXPORT DIPlibTargets\n           FILE DIPlibTargets.cmake\n           NAMESPACE DIPlib::\n           DESTINATION ${ConfigPackageLocation})\n\n   configure_package_config_file(\n         tools/DIPlibConfig.cmake.in\n         \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibConfig.cmake\"\n         INSTALL_DESTINATION ${ConfigPackageLocation})\n   write_basic_package_version_file(\n         \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibConfigVersion.cmake\"\n         VERSION ${DIPlib_VERSION}\n         COMPATIBILITY SameMajorVersion)\n   install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibConfigVersion.cmake\"\n                 \"${CMAKE_CURRENT_BINARY_DIR}/DIPlibConfig.cmake\"\n           DESTINATION ${ConfigPackageLocation})\n\nendif()\n\n# Package stuff\nif(CMAKE_HOST_WIN32)\n   # On Windows we use the NSIS generator\n   # TODO: This must be tested and configured properly\n   set(CPACK_GENERATOR \"NSIS\")\n#elseif(CMAKE_HOST_APPLE)\n   # On MacOS we use the Bundle generator\n   #set(CPACK_GENERATOR \"Bundle\")\n   #CPACK_BUNDLE_NAME\n   #CPACK_BUNDLE_ICON\n   #CPACK_BUNDLE_PLIST\n   #CPACK_BUNDLE_STARTUP_COMMAND # What would the startup command be???\nelse()\n   # On Linux (or any other platform) we use a tar file\n   set(CPACK_GENERATOR \"TBZ2\")\nendif()\nset(CPACK_RESOURCE_FILE_README \"${CMAKE_CURRENT_SOURCE_DIR}/README.md\")\nset(CPACK_PACKAGE_VENDOR \"The DIPlib Project\")\nset(CPACK_PACKAGE_CONTACT \"https://github.com/DIPlib/DIPlib\")\nset(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.txt\")\nset(CPACK_PACKAGE_VERSION_MAJOR \"${PROJECT_VERSION_MAJOR}\")\nset(CPACK_PACKAGE_VERSION_MINOR \"${PROJECT_VERSION_MINOR}\")\nstring(TIMESTAMP TODAYS_DATE \"%Y%m%d\" UTC)\nset(CPACK_PACKAGE_VERSION_PATCH \"${PROJECT_VERSION_PATCH}-${TODAYS_DATE}\")\n#CPACK_PACKAGE_ICON\ninclude(CPack)\n# TODO: The package doesn't contain any of the dependencies: OpenMP, C++ stdlib, etc.\n#       Including these is highly dependent on the configuration of the system used for compiling.\n#       Posible solutions:\n#        - `install(PROGRAMS ${libname} DESTINATION lib)`\n#          We'd then need to modify the library names and the search locations using `install_name_tool`,\n#          see http://doc.qt.io/qt-4.8/deployment-mac.html#linking-the-application-to-qt-as-frameworks\n#        See also: https://cmake.org/cmake/help/v3.5/manual/cmake-packages.7.html#creating-relocatable-packages\n\n\n### Status report\n\nmessage(\"\")\nmessage(\"--------------------------------------\")\nmessage(\"   DIPlib CONFIGURATION REPORT\")\nmessage(\"\")\n\nmessage(\" * PROJECT_VERSION: ${PROJECT_VERSION}\")\nmessage(\" * DIP_COPYRIGHT_YEAR: ${DIP_COPYRIGHT_YEAR}\")\n\nmessage(\" * C++ compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}\")\nif(NOT \"${CMAKE_BUILD_TYPE}\" STREQUAL \"\")\n   string(TOUPPER ${CMAKE_BUILD_TYPE} UPPERCASE_BUILD_TYPE)\n   message(\" * C++ compiler flags: ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_${UPPERCASE_BUILD_TYPE}}\")\n   message(\" * Build type: ${CMAKE_BUILD_TYPE}\")\nendif()\n\nif(DIP_SHARED_LIBRARY)\n   message(\" * Building shared library\")\nelse()\n   message(\" * Building static library\")\nendif()\nmessage(\" * Library installed to: ${CMAKE_INSTALL_PREFIX}/${LIBRARY_DESTINATION}\")\nmessage(\" * Binaries installed to: ${CMAKE_INSTALL_PREFIX}/${RUNTIME_DESTINATION}\")\nif (WIN32)\n   message(\" * Import library installed to: ${CMAKE_INSTALL_PREFIX}/${ARCHIVE_DESTINATION}\")\nendif()\nmessage(\" * Header files installed to: ${CMAKE_INSTALL_PREFIX}/include\")\n\nif(DOXPP_FOUND)\n   message(\" * Documentation installed to: ${CMAKE_INSTALL_PREFIX}/${DOCUMENTATION_OUTPUT}\")\nelse()\n   message(\" * dox++ program not configured, no documentation can be generated\")\nendif()\n\n\nif(DIP_ENABLE_MULTITHREADING)\n   message(\" * Using OpenMP for multithreading\")\nelse()\n   message(\" * Multithreading disabled\")\nendif()\n\nif(DIP_ENABLE_STACK_TRACE)\n   message(\" * Stack trace recording enabled\")\nelse()\n   message(\" * Stack trace recording disabled\")\nendif()\nif(DIP_ENABLE_ASSERT)\n   message(\" * Asserts enabled\")\nelse()\n   message(\" * Asserts disabled\")\nendif()\nif(DIP_ENABLE_UNICODE)\n   message(\" * Unicode support enabled\")\nelse()\n   message(\" * Unicode support disabled\")\nendif()\nif(HAS_128_INT)\n   message(\" * Using 128-bit PRNG\")\nelse()\n   message(\" * Using 64-bit PRNG\")\nendif()\n\nif(DIP_ENABLE_ICS)\n   if(DIP_ENABLE_ZLIB)\n      set(features \", with zlib\")\n   else()\n      set(features \", without zlib\")\n   endif()\n   message(\" * ICS file IO enabled${features}\")\nelse()\n   message(\" * ICS file IO disabled\")\nendif()\nif(DIP_ENABLE_TIFF)\n   set(features \"\")\n   if(DIP_ENABLE_ZLIB)\n      set(features \"${features}, with zlib\")\n   else()\n      set(features \"${features}, without zlib\")\n   endif()\n   if(DIP_ENABLE_JPEG)\n      set(features \"${features}, with JPEG\")\n   else()\n      set(features \"${features}, without JPEG\")\n   endif()\n   message(\" * TIFF file IO enabled${features}\")\nelse()\n   message(\" * TIFF file IO disabled\")\nendif()\nif(DIP_ENABLE_JPEG)\n   message(\" * JPEG file IO enabled\")\nelse()\n   message(\" * JPEG file IO disabled\")\nendif()\n\nif(DIP_ENABLE_FFTW)\n   message(\" * Using FFT from FFTW3 library (GPL)\")\nelse()\n   message(\" * Using built-in FFT\")\nendif()\n\nif(DIP_ENABLE_DOCTEST)\n   message(\" * Unit test code included\")\nelse()\n   message(\" * Unit test code excluded\")\nendif()\n\nif(DIP_BUILD_DIPVIEWER)\n   message(\" * DIPviewer module added to 'all' with window managers: ${DIP_VIEWER_MANAGERS}\")\n   if (FREEGLUT_STATIC)\n      message(\" * Using static FreeGLUT library\")\n   endif()\nelse()\n   message(\" * DIPviewer module not configured\")\nendif()\n\nif(DIP_BUILD_DIPVIEWER_JAVA)\n   message(\" * DIPviewer Java bindings added to 'all' target\")\nelse()\n   message(\" * DIPviewer Java bindings not configured\")\nendif()\n\nif(DIP_BUILD_JAVAIO)\n   message(\" * DIPjavaio module added to 'all' target with interfaces: ${DIP_JAVAIO_INTERFACES}\")\n   message(\" * DIPjavaio compiled using Java version ${Java_VERSION_STRING}\")\nelse()\n   message(\" * DIPJavaio module not configured\")\nendif()\n\nif(DIP_BUILD_PYDIP)\n   message(\" * PyDIP module added to 'all' target\")\n   message(\" * PyDIP compiled for Python version ${PYTHON_VERSION_STRING}\")\n   if(DIP_PYDIP_WHEEL_INCLUDE_LIBS)\n      message(\" * PyDIP includes libraries in binary wheel\")\n   else()\n      message(\" * PyDIP does not include libraries in binary wheel\")\n   endif()\nelse()\n   message(\" * PyDIP module not configured\")\nendif()\n\nif(DIP_BUILD_DIPIMAGE)\n   message(\" * DIPimage toolbox added to 'all' target\")\n   matlab_get_release_name_from_version(${Matlab_VERSION_STRING} Matlab_RELEASE_NAME)\n   message(\" * DIPimage toolbox compiled for MATLAB ${Matlab_RELEASE_NAME}\")\n   message(\" * DIPimage toolbox installed to: ${CMAKE_INSTALL_PREFIX}/${DIPIMAGE_INSTALL_PATH}\")\n   if(DOXPP_FOUND)\n      message(\" * DIPimage User Manual installed to: ${CMAKE_INSTALL_PREFIX}/${DOCUMENTATION_OUTPUT}/html/dipimage_user_manual.html\")\n   else()\n      message(\" * DIPimage User Manual cannot be created (dox++ program not configured)\")\n   endif()\nelse()\n   message(\" * DIPimage toolbox not configured\")\nendif()\n\nif(CMAKE_GENERATOR MATCHES \"Unix Makefiles\")\n   message(\"\")\n   if(DIP_ENABLE_DOCTEST)\n      message(\"Next, type 'make; make check; make install'\")\n   else()\n      message(\"Next, type 'make; make install'\")\n   endif()\n   if(DOXPP_FOUND)\n      message(\"Type 'make apidoc' to build the documentation\")\n   endif()\nendif()\n\nmessage(\"\")\nmessage(\"--------------------------------------\")\nmessage(\"\")\n", "---\nlayout: post\ntitle: \"Changes DIPlib 3.1.0\"\n---\n\n## Changes to *DIPlib*\n\n### New functionality\n\n- Added `dip::MarginalPercentile()` histogram-based statistics function.\n\n- Added `dip::SplitRegions()`, a function to transform labeled images.\n\n- Added `dip::FlushToZero()`, a function to remove denormal values from an image.\n\n- Added `dip::maximum_gauss_truncation()`, returning the maximum truncation that is useful for Gaussian functions.\n\n- `dip::NeighborList` allows accessing neighbors by index, through the new member functions `Coordinates`,\n  `Distance` and `IsInImage`.\n\n- Added `dip::Measurement::SetObjectIDs()`.\n\n- Added `dip::Image::SwapBytesInSample()` to convert from little endian to big endian representation.\n\n- Added `dip::ImageReadNPY()`, `dip::ImageReadNPYInfo()`, `dip::ImageIsNPY()` and `dip::ImageWriteNPY()`, to\n  work with NumPy's NPY files, expanding interoperability with Python.\n\n- Compound assignment operators defined for image views (`img[ 0 ] += ...` now works).\n\n- Added `dip::GetLabelBoundingBox()`.\n\n- Added `dip::IsotropicDilation()` and `dip::IsotropicErosion()` for binary images.\n\n- Added `dip::Image::Sample::Maximum()` and `dip::Image::Sample::Minimum()`.\n\n- Added `dip::ImposeMinima()`.\n\n### Changed functionality\n\n- Replaced the use of `std::map` and `std::set` in various functions to `tsl::robin_map` and\n  `tsl::robin_set`, which are significantly faster. This affects `dip::Measurement` and functions\n  using it (including `dip::MeasurementTool::Measure()`), `dip::GetImageChainCodes()`, `dip::GetObjectLabels()`,\n  `dip::Relabel()`, `dip::ChordLength()` and `dip::PairCorrelation()`.\n\n- The speed of the following functions has been improved:\n    - `dip::Measurement::AddObjectIDs()` and `dip::Measurement::operator+()`.\n    - `dip::Label` (slightly more efficient for 3D and higher-dimensional images).\n    - `dip::MomentAccumulator`.\n    - `dip::MorphologicalReconstruction` and functions that depend on it.\n\n- `dip::OptimalFourierTransformSize()` has a new option to return a smaller or equal size, rather than\n  a larger or equal size, so we can crop an image for efficient FFT instead of padding.\n\n- All the variants of the Gaussian filter (`dip::Gauss()` et al.) now limit the truncation value to avoid\n  unnecessarily large filter kernels. `dip::DrawBandlimitedPoint()`, `dip::DrawBandlimitedBall()`,\n  `dip::DrawBandlimitedBox()`, `dip::GaussianEdgeClip()` and `dip::GaussianLineClip()` also limit the\n  truncation in the same way.\n\n- `dip::ColorSpaceConverter` has a `SetWhitePoint` member function. `dip::ColorSpaceManager::SetWhitePoint`\n  calls the `SetWhitePoint` member function for all registered converters. This allows custom converters\n  to use the white point as well.\n\n- `dip::ColorSpaceManager::XYZ` is deprecated, use `dip::XYZ` instead.\n\n- `dip::SetNumberOfThreads()` and `dip::GetNumberOfThreads()` set a thread-local value now. Each\n  thread should set its own limit for how many threads *DIPlib* can use.\n\n- All functions that used randomness internally but didn't have a `dip::Random` input parameter now do\n  have such a parameter. Overloaded functions with the old signature create a default-initialized\n  `dip::Random` object and call the function with the new signature. This affects the following functions:\n  `dip::ChordLength`, `dip::PairCorrelation`, `dip::ProbabilisticPairCorrelation`, `dip::Semivariogram`,\n  `dip::CostesSignificanceTest`, `dip::StochasticWatershed`, `dip::KMeansClustering`, and `dip::Superpixels`.\n\n- `dip::Image::Rotation90()` can now be called without any arguments at all.\n\n### Bug fixes\n\n- `dip::DrawPolygon2D()` produced wrong results for filled polygons when vertices were very close together\n  (distances smaller than a pixel).\n\n- `dip::ColorSpaceManager` didn't register the ICH and ISH color spaces.\n\n- `dip::Image::ResetNonDataProperties()` incorrectly set the number of tensor elements to 1.\n\n- `dip::Image::Copy()` would incorrectly copy the external interface if the destination image didn't have one defined.\n\n- `dip::MaximumPixel()` and `dip::MinimumPixel()` produced an empty output array when the input was all NaN.\n\n- `dip::Image::HasSameDimensionOrder()` didn't properly ignore singleton dimensions.\n\n- `dip::GaussianMixtureModelThreshold()` passed wrong parameter values to `dip::GaussianMixtureModel()`.\n\n- `dip::ResampleAt(in, map)` didn't use the pixels at the right or bottom edges of the input image.\n\n- Fixed various issues in underlying code for `dip::AreaOpening()`, `dip::AreaClosing()`, `dip::VolumeOpening()` and `dip::VolumeClosing()`.\n  These functions now behave as described in the documentation.\n\n- There was a strange rounding error when creating disk-shaped filter kernels and structuring elements,\n  for some even integer sizes, which caused these kernels to be not symmetric over 90 degree rotations.\n\n- `dip::MeanAbs()` and `dip::SumAbs()` could produce wrong results for complex inputs.\n\n- libics had a typo that caused out-of-bounds read (#81). \n\n- Fixed error handling in `dip::ImageReadJPEG()` and `dip::ImageWriteJPEG()`, which previously would crash when libjpeg produced an error (#80).\n\n\n\n\n## Changes to *DIPimage*\n\n### New functionality\n\n- Added `dip_image/ftz`, a function to remove denormal values from an image.\n\n### Changed functionality\n\n- Most functions now also accept a string array instead of char vector or a cell array of char vectors\n  (that is, `\"foo\"` is now interpreted the same as `'foo'`, and `[\"foo\",\"bar\"]` is now interpreted the\n  same as `{'foo','bar'}`).\n\n(See also changes to *DIPlib*.)\n\n### Bug fixes\n\n- `readim` and `writeim`, when using *MATLAB*'s functionality, would work in linear RGB space, instead of sRGB\n  like the *DIPlib* functions do.\n\n- `readics` tried to read the file as a TIFF file instead of an ICS file.\n\n- Code like `img * [1,2,3]` converted the second argument into a 0D column vector image. The same code\n  with e.g. a 3x3 matrix would convert the matrix to a scalar 3x3 image, rather than a 0D matrix image.\n  These now behave more similarly to how they behaved in *DIPimage* 2.9.\n\n(See also bugfixes to *DIPlib*.)\n\n\n\n\n## Changes to *PyDIP*\n\n### New functionality\n\n- Added `dip.FlushToZero()`, `dip.SplitRegions()`, `dip.ApplyWindow()`.\n\n- Added `dip.ImageReadNPY()`, `dip.ImageReadNPYInfo()`, `dip.ImageIsNPY()` and `dip.ImageWriteNPY()`.\n\n- Added `dip.FourierMellinMatch2Dparams()`, identical to `dip.FourierMellinMatch2D()` but it also returns the\n  transform parameters (which `dip.FourierMellinMatch2D()` should have done from the beginning).\n\n- Added `dip.GetLabelBoundingBox()`.\n\n- Added `dip.IsotropicDilation()` and `dip.IsotropicErosion()` for binary images.\n\n- Added `dip.ImposeMinima()`.\n\n### Changed functionality\n\n- `dip.ChordLength`, `dip.PairCorrelation`, `dip.ProbabilisticPairCorrelation`, `dip.Semivariogram`,\n  `dip.CostesSignificanceTest`, `dip.StochasticWatershed`, `dip.KMeansClustering`, and `dip.Superpixels`\n  now use the global random number generator instead of creating a default-initialized one.\n\n(See also changes to *DIPlib*.)\n\n### Bug fixes\n\n- Updated default connectivity values in the morphology and binary image processing modules to match the defaults in *DIPlib*.\n\n(See also bugfixes to *DIPlib*.)\n\n\n\n\n## Changes to *DIPviewer*\n\n### New functionality\n\n### Changed functionality\n\n### Bug fixes\n\n\n\n\n## Changes to *DIPjavaio*\n\n### New functionality\n\n### Changed functionality\n\n### Bug fixes\n\n- Signed integer images could not be read.\n", "/*\n * DIPlib 3.0\n * This file contains definitions for JPEG reading and writing\n *\n * (c)2019, Cris Luengo.\n * Based on original DIPlib code: (c)1995-2014, Delft University of Technology.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef DIP_CONFIG_HAS_JPEG\n\n#include \"diplib.h\"\n#include \"diplib/file_io.h\"\n\n#include \"jpeglib.h\"\n#include <csetjmp>\n\n// JPEG error handling stuff - modified from example.c in libjpeg source\nextern \"C\" {\n   static void my_error_exit( j_common_ptr cinfo );\n   static void my_output_message( j_common_ptr );\n}\n\nstruct my_error_mgr {\n   struct jpeg_error_mgr pub; // \"public\" fields\n   std::jmp_buf setjmp_buffer;     // for return to caller\n};\nusing my_error_ptr = struct my_error_mgr*;\n\nstatic void my_error_exit( j_common_ptr cinfo ) {\n   // cinfo->err really points to a my_error_mgr struct, so coerce pointer\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );\n   // Return control to the setjmp point\n   longjmp( myerr->setjmp_buffer, 1 );\n}\n\nstatic void my_output_message( j_common_ptr ) {} // Don't do anything with messages!\n\n#define DIP__DECLARE_JPEG_EXIT( message ) \\\nstd::jmp_buf setjmp_buffer; if( setjmp( setjmp_buffer )) { DIP_THROW_RUNTIME( message ); }\n\n\nnamespace dip {\n\nnamespace {\n\nclass JpegInput {\n   public:\n      JpegInput( String filename, std::jmp_buf const& setjmp_buffer ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); // Try with \"jpg\" extension\n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); // Try with \"jpeg\" extension\n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }\n      JpegInput( JpegInput const& ) = delete;\n      JpegInput( JpegInput&& ) = delete;\n      JpegInput& operator=( JpegInput const& ) = delete;\n      JpegInput& operator=( JpegInput&& ) = delete;\n      ~JpegInput() {\n         if( initialized_ ) {\n            jpeg_destroy_decompress( &cinfo_ );\n         }\n         if( infile_ ) {\n            std::fclose( infile_ );\n         }\n      }\n      // Retrieve jpeg_decompress_struct\n      jpeg_decompress_struct& cinfo() { return cinfo_; }\n      j_decompress_ptr cinfoptr() { return &cinfo_; }\n      // Retrieve file name\n      String const& FileName() const { return filename_; }\n   private:\n      String filename_;\n      FILE* infile_ = nullptr;\n      jpeg_decompress_struct cinfo_;\n      my_error_mgr jerr_;\n      bool initialized_ = false;\n};\n\nclass JpegOutput {\n   public:\n      explicit JpegOutput( String const& filename, std::jmp_buf const& setjmp_buffer ) {\n         // Open the file for writing\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }\n      JpegOutput( JpegOutput const& ) = delete;\n      JpegOutput( JpegOutput&& ) = delete;\n      JpegOutput& operator=( JpegOutput const& ) = delete;\n      JpegOutput& operator=( JpegOutput&& ) = delete;\n      ~JpegOutput() {\n         if( initialized_ ) {\n            jpeg_destroy_compress( &cinfo_ );\n         }\n         if( outfile_ ) {\n            std::fclose( outfile_ );\n         }\n      }\n      // Retrieve jpeg_decompress_struct\n      jpeg_compress_struct& cinfo() { return cinfo_; }\n      j_compress_ptr cinfoptr() { return &cinfo_; }\n   private:\n      FILE* outfile_ = nullptr;\n      jpeg_compress_struct cinfo_;\n      my_error_mgr jerr_;\n      bool initialized_ = false;\n};\n\nFileInformation GetJPEGInfo( JpegInput& jpeg ) {\n   FileInformation fileInformation;\n   fileInformation.name = jpeg.FileName();\n   fileInformation.fileType = \"JPEG\";\n   fileInformation.numberOfImages = 1;\n   fileInformation.significantBits = 8;\n   fileInformation.dataType = DT_UINT8;\n   fileInformation.tensorElements = static_cast< dip::uint >( jpeg.cinfo().num_components );\n   fileInformation.colorSpace = fileInformation.tensorElements == 3 ? \"sRGB\" : \"\";\n   fileInformation.sizes = { jpeg.cinfo().image_width, jpeg.cinfo().image_height };\n   PhysicalQuantity units;\n   switch (jpeg.cinfo().density_unit) {\n      default: // no units\n         units = Units::Pixel();\n         break;\n      case 1: // dots per inch\n         units = PhysicalQuantity::Inch();\n         break;\n      case 2: // dots per cm\n         units = PhysicalQuantity::Centimeter();\n   }\n   fileInformation.pixelSize = {{ units / static_cast< dfloat >( jpeg.cinfo().X_density ),\n                                  units / static_cast< dfloat >( jpeg.cinfo().Y_density ) }};\n   return fileInformation;\n}\n\n} // namespace\n\nFileInformation ImageReadJPEG(\n      Image& out,\n      String const& filename\n) {\n   // Open the file\n   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n   JpegInput jpeg( filename, setjmp_buffer );\n\n   // Get info\n   FileInformation info = GetJPEGInfo( jpeg );\n\n   // Allocate image\n   int nchan = jpeg.cinfo().num_components;\n   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );\n   out.SetPixelSize( info.pixelSize );\n   out.SetColorSpace( info.colorSpace );\n\n   // Read data\n   jpeg_start_decompress( jpeg.cinfoptr() );\n   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); // casting to unsigned rather than dip::uint to shut up GCC warning.\n   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );\n   auto stride = out.Strides();\n   auto tStride = out.TensorStride();\n   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {\n      JSAMPLE* indata = buffer.data();\n      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );\n      dip::uint8* outdata = imagedata;\n      if( nchan > 1 ) {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            for( int kk = 0; kk < nchan; ++kk ) {\n               *( outdata + kk * tStride ) = *indata;\n               ++indata;\n            }\n            outdata += stride[ 0 ];\n         }\n      } else {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            *outdata = *indata;\n            ++indata;\n            outdata += stride[ 0 ];\n         }\n      }\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_decompress( jpeg.cinfoptr() );\n\n   return info;\n}\n\nFileInformation ImageReadJPEGInfo( String const& filename ) {\n   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n   JpegInput jpeg( filename, setjmp_buffer );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}\n\nbool ImageIsJPEG( String const& filename ) {\n   try {\n      DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n      JpegInput jpeg( filename, setjmp_buffer );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}\n\nvoid ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n\n   // Open the file\n   DIP__DECLARE_JPEG_EXIT( \"Error writing JPEG file\" );\n   JpegOutput jpeg( filename, setjmp_buffer );\n\n   // Set image properties\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( clamp< dip::uint >( jpegLevel, 1, 100 )), FALSE );\n   jpeg.cinfo().density_unit = 2; // dots per cm\n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); // let's assume it's meter\n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n\n   // Convert the image to uint8 if necessary\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n\n   // Write data\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}\n\n} // namespace dip\n\n#else // DIP_CONFIG_HAS_JPEG\n\n#include \"diplib.h\"\n#include \"diplib/file_io.h\"\n\nnamespace dip {\n\nstatic char const* NOT_AVAILABLE = \"DIPlib was compiled without JPEG support.\";\n\nFileInformation ImageReadJPEG( Image&, String const& ) {\n   DIP_THROW( NOT_AVAILABLE );\n}\n\nFileInformation ImageReadJPEGInfo( String const& ) {\n   DIP_THROW( NOT_AVAILABLE );\n}\n\nbool ImageIsJPEG( String const& ) {\n   DIP_THROW( NOT_AVAILABLE );\n}\n\nvoid ImageWriteJPEG( Image const&, String const&, dip::uint ) {\n   DIP_THROW( NOT_AVAILABLE );\n}\n\n}\n\n#endif // DIP_CONFIG_HAS_JPEG\n"], "filenames": ["CMakeLists.txt", "changelogs/diplib_3.1.0.md", "src/file_io/jpeg.cpp"], "buggy_code_start_loc": [45, 104, 27], "buggy_code_end_loc": [56, 104, 260], "fixing_code_start_loc": [46, 105, 27], "fixing_code_end_loc": [60, 107, 266], "type": "CWE-415", "message": "diplib v3.0.0 is vulnerable to Double Free.", "other": {"cve": {"id": "CVE-2021-39432", "sourceIdentifier": "cve@mitre.org", "published": "2022-11-04T17:15:10.627", "lastModified": "2022-11-07T02:26:22.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "diplib v3.0.0 is vulnerable to Double Free."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:diplib:diplib:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "27F31D36-AC0B-4786-AEA1-AAC19D1F70F1"}]}]}], "references": [{"url": "https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DIPlib/diplib/issues/80", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5"}}