{"buggy_code": ["/*\n * Copyright (c) 2000, 2001, 2002 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * multiple format streaming server based on the FFmpeg libraries\n */\n\n#include \"config.h\"\n#if !HAVE_CLOSESOCKET\n#define closesocket close\n#endif\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"libavformat/avformat.h\"\n/* FIXME: those are internal headers, ffserver _really_ shouldn't use them */\n#include \"libavformat/rtpproto.h\"\n#include \"libavformat/rtsp.h\"\n#include \"libavformat/avio_internal.h\"\n#include \"libavformat/internal.h\"\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/lfg.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/random_seed.h\"\n#include \"libavutil/rational.h\"\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/time.h\"\n\n#include <stdarg.h>\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#if HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <errno.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#include \"cmdutils.h\"\n#include \"ffserver_config.h\"\n\n#define PATH_LENGTH 1024\n\nconst char program_name[] = \"ffserver\";\nconst int program_birth_year = 2000;\n\nstatic const OptionDef options[];\n\nenum HTTPState {\n    HTTPSTATE_WAIT_REQUEST,\n    HTTPSTATE_SEND_HEADER,\n    HTTPSTATE_SEND_DATA_HEADER,\n    HTTPSTATE_SEND_DATA,          /* sending TCP or UDP data */\n    HTTPSTATE_SEND_DATA_TRAILER,\n    HTTPSTATE_RECEIVE_DATA,\n    HTTPSTATE_WAIT_FEED,          /* wait for data from the feed */\n    HTTPSTATE_READY,\n\n    RTSPSTATE_WAIT_REQUEST,\n    RTSPSTATE_SEND_REPLY,\n    RTSPSTATE_SEND_PACKET,\n};\n\nstatic const char * const http_state[] = {\n    \"HTTP_WAIT_REQUEST\",\n    \"HTTP_SEND_HEADER\",\n\n    \"SEND_DATA_HEADER\",\n    \"SEND_DATA\",\n    \"SEND_DATA_TRAILER\",\n    \"RECEIVE_DATA\",\n    \"WAIT_FEED\",\n    \"READY\",\n\n    \"RTSP_WAIT_REQUEST\",\n    \"RTSP_SEND_REPLY\",\n    \"RTSP_SEND_PACKET\",\n};\n\n#define IOBUFFER_INIT_SIZE 8192\n\n/* timeouts are in ms */\n#define HTTP_REQUEST_TIMEOUT (15 * 1000)\n#define RTSP_REQUEST_TIMEOUT (3600 * 24 * 1000)\n\n#define SYNC_TIMEOUT (10 * 1000)\n\ntypedef struct RTSPActionServerSetup {\n    uint32_t ipaddr;\n    char transport_option[512];\n} RTSPActionServerSetup;\n\ntypedef struct {\n    int64_t count1, count2;\n    int64_t time1, time2;\n} DataRateData;\n\n/* context associated with one connection */\ntypedef struct HTTPContext {\n    enum HTTPState state;\n    int fd; /* socket file descriptor */\n    struct sockaddr_in from_addr; /* origin */\n    struct pollfd *poll_entry; /* used when polling */\n    int64_t timeout;\n    uint8_t *buffer_ptr, *buffer_end;\n    int http_error;\n    int post;\n    int chunked_encoding;\n    int chunk_size;               /* 0 if it needs to be read */\n    struct HTTPContext *next;\n    int got_key_frame; /* stream 0 => 1, stream 1 => 2, stream 2=> 4 */\n    int64_t data_count;\n    /* feed input */\n    int feed_fd;\n    /* input format handling */\n    AVFormatContext *fmt_in;\n    int64_t start_time;            /* In milliseconds - this wraps fairly often */\n    int64_t first_pts;            /* initial pts value */\n    int64_t cur_pts;             /* current pts value from the stream in us */\n    int64_t cur_frame_duration;  /* duration of the current frame in us */\n    int cur_frame_bytes;       /* output frame size, needed to compute\n                                  the time at which we send each\n                                  packet */\n    int pts_stream_index;        /* stream we choose as clock reference */\n    int64_t cur_clock;           /* current clock reference value in us */\n    /* output format handling */\n    struct FFServerStream *stream;\n    /* -1 is invalid stream */\n    int feed_streams[FFSERVER_MAX_STREAMS]; /* index of streams in the feed */\n    int switch_feed_streams[FFSERVER_MAX_STREAMS]; /* index of streams in the feed */\n    int switch_pending;\n    AVFormatContext *pfmt_ctx; /* instance of FFServerStream for one user */\n    int last_packet_sent; /* true if last data packet was sent */\n    int suppress_log;\n    DataRateData datarate;\n    int wmp_client_id;\n    char protocol[16];\n    char method[16];\n    char url[128];\n    char clean_url[128*7];\n    int buffer_size;\n    uint8_t *buffer;\n    int is_packetized; /* if true, the stream is packetized */\n    int packet_stream_index; /* current stream for output in state machine */\n\n    /* RTSP state specific */\n    uint8_t *pb_buffer; /* XXX: use that in all the code */\n    AVIOContext *pb;\n    int seq; /* RTSP sequence number */\n\n    /* RTP state specific */\n    enum RTSPLowerTransport rtp_protocol;\n    char session_id[32]; /* session id */\n    AVFormatContext *rtp_ctx[FFSERVER_MAX_STREAMS];\n\n    /* RTP/UDP specific */\n    URLContext *rtp_handles[FFSERVER_MAX_STREAMS];\n\n    /* RTP/TCP specific */\n    struct HTTPContext *rtsp_c;\n    uint8_t *packet_buffer, *packet_buffer_ptr, *packet_buffer_end;\n} HTTPContext;\n\nstatic HTTPContext *first_http_ctx;\n\nstatic FFServerConfig config = {\n    .nb_max_http_connections = 2000,\n    .nb_max_connections = 5,\n    .max_bandwidth = 1000,\n    .use_defaults = 1,\n};\n\nstatic void new_connection(int server_fd, int is_rtsp);\nstatic void close_connection(HTTPContext *c);\n\n/* HTTP handling */\nstatic int handle_connection(HTTPContext *c);\nstatic inline void print_stream_params(AVIOContext *pb, FFServerStream *stream);\nstatic void compute_status(HTTPContext *c);\nstatic int open_input_stream(HTTPContext *c, const char *info);\nstatic int http_parse_request(HTTPContext *c);\nstatic int http_send_data(HTTPContext *c);\nstatic int http_start_receive_data(HTTPContext *c);\nstatic int http_receive_data(HTTPContext *c);\n\n/* RTSP handling */\nstatic int rtsp_parse_request(HTTPContext *c);\nstatic void rtsp_cmd_describe(HTTPContext *c, const char *url);\nstatic void rtsp_cmd_options(HTTPContext *c, const char *url);\nstatic void rtsp_cmd_setup(HTTPContext *c, const char *url,\n                           RTSPMessageHeader *h);\nstatic void rtsp_cmd_play(HTTPContext *c, const char *url,\n                          RTSPMessageHeader *h);\nstatic void rtsp_cmd_interrupt(HTTPContext *c, const char *url,\n                               RTSPMessageHeader *h, int pause_only);\n\n/* SDP handling */\nstatic int prepare_sdp_description(FFServerStream *stream, uint8_t **pbuffer,\n                                   struct in_addr my_ip);\n\n/* RTP handling */\nstatic HTTPContext *rtp_new_connection(struct sockaddr_in *from_addr,\n                                       FFServerStream *stream,\n                                       const char *session_id,\n                                       enum RTSPLowerTransport rtp_protocol);\nstatic int rtp_new_av_stream(HTTPContext *c,\n                             int stream_index, struct sockaddr_in *dest_addr,\n                             HTTPContext *rtsp_c);\n/* utils */\nstatic size_t htmlencode (const char *src, char **dest);\nstatic inline void cp_html_entity (char *buffer, const char *entity);\nstatic inline int check_codec_match(LayeredAVStream *ccf, AVStream *ccs, int stream);\n\nstatic const char *my_program_name;\n\nstatic int no_launch;\nstatic int need_to_start_children;\n\n/* maximum number of simultaneous HTTP connections */\nstatic unsigned int nb_connections;\n\nstatic uint64_t current_bandwidth;\n\n/* Making this global saves on passing it around everywhere */\nstatic int64_t cur_time;\n\nstatic AVLFG random_state;\n\nstatic FILE *logfile = NULL;\n\nstatic void unlayer_stream(AVStream *st, LayeredAVStream *lst)\n{\n    avcodec_free_context(&st->codec);\n    avcodec_parameters_free(&st->codecpar);\n#define COPY(a) st->a = lst->a;\n    COPY(index)\n    COPY(id)\n    COPY(codec)\n    COPY(codecpar)\n    COPY(time_base)\n    COPY(pts_wrap_bits)\n    COPY(sample_aspect_ratio)\n    COPY(recommended_encoder_configuration)\n}\n\nstatic inline void cp_html_entity (char *buffer, const char *entity) {\n    if (!buffer || !entity)\n        return;\n    while (*entity)\n        *buffer++ = *entity++;\n}\n\n/**\n * Substitutes known conflicting chars on a text string with\n * their corresponding HTML entities.\n *\n * Returns the number of bytes in the 'encoded' representation\n * not including the terminating NUL.\n */\nstatic size_t htmlencode (const char *src, char **dest) {\n    const char *amp = \"&amp;\";\n    const char *lt  = \"&lt;\";\n    const char *gt  = \"&gt;\";\n    const char *start;\n    char *tmp;\n    size_t final_size = 0;\n\n    if (!src)\n        return 0;\n\n    start = src;\n\n    /* Compute needed dest size */\n    while (*src != '\\0') {\n        switch(*src) {\n            case 38: /* & */\n                final_size += 5;\n                break;\n            case 60: /* < */\n            case 62: /* > */\n                final_size += 4;\n                break;\n            default:\n                final_size++;\n        }\n        src++;\n    }\n\n    src = start;\n    *dest = av_mallocz(final_size + 1);\n    if (!*dest)\n        return 0;\n\n    /* Build dest */\n    tmp = *dest;\n    while (*src != '\\0') {\n        switch(*src) {\n            case 38: /* & */\n                cp_html_entity (tmp, amp);\n                tmp += 5;\n                break;\n            case 60: /* < */\n                cp_html_entity (tmp, lt);\n                tmp += 4;\n                break;\n            case 62: /* > */\n                cp_html_entity (tmp, gt);\n                tmp += 4;\n                break;\n            default:\n                *tmp = *src;\n                tmp += 1;\n        }\n        src++;\n    }\n    *tmp = '\\0';\n\n    return final_size;\n}\n\nstatic int64_t ffm_read_write_index(int fd)\n{\n    uint8_t buf[8];\n\n    if (lseek(fd, 8, SEEK_SET) < 0)\n        return AVERROR(EIO);\n    if (read(fd, buf, 8) != 8)\n        return AVERROR(EIO);\n    return AV_RB64(buf);\n}\n\nstatic int ffm_write_write_index(int fd, int64_t pos)\n{\n    uint8_t buf[8];\n    int i;\n\n    for(i=0;i<8;i++)\n        buf[i] = (pos >> (56 - i * 8)) & 0xff;\n    if (lseek(fd, 8, SEEK_SET) < 0)\n        goto bail_eio;\n    if (write(fd, buf, 8) != 8)\n        goto bail_eio;\n\n    return 8;\n\nbail_eio:\n    return AVERROR(EIO);\n}\n\nstatic void ffm_set_write_index(AVFormatContext *s, int64_t pos,\n                                int64_t file_size)\n{\n    av_opt_set_int(s, \"server_attached\", 1, AV_OPT_SEARCH_CHILDREN);\n    av_opt_set_int(s, \"ffm_write_index\", pos, AV_OPT_SEARCH_CHILDREN);\n    av_opt_set_int(s, \"ffm_file_size\", file_size, AV_OPT_SEARCH_CHILDREN);\n}\n\nstatic char *ctime1(char *buf2, size_t buf_size)\n{\n    time_t ti;\n    char *p;\n\n    ti = time(NULL);\n    p = ctime(&ti);\n    if (!p || !*p) {\n        *buf2 = '\\0';\n        return buf2;\n    }\n    av_strlcpy(buf2, p, buf_size);\n    p = buf2 + strlen(buf2) - 1;\n    if (*p == '\\n')\n        *p = '\\0';\n    return buf2;\n}\n\nstatic void http_vlog(const char *fmt, va_list vargs)\n{\n    static int print_prefix = 1;\n    char buf[32];\n\n    if (!logfile)\n        return;\n\n    if (print_prefix) {\n        ctime1(buf, sizeof(buf));\n        fprintf(logfile, \"%s \", buf);\n    }\n    print_prefix = strstr(fmt, \"\\n\") != NULL;\n    vfprintf(logfile, fmt, vargs);\n    fflush(logfile);\n}\n\n#ifdef __GNUC__\n__attribute__ ((format (printf, 1, 2)))\n#endif\nstatic void http_log(const char *fmt, ...)\n{\n    va_list vargs;\n    va_start(vargs, fmt);\n    http_vlog(fmt, vargs);\n    va_end(vargs);\n}\n\nstatic void http_av_log(void *ptr, int level, const char *fmt, va_list vargs)\n{\n    static int print_prefix = 1;\n    AVClass *avc = ptr ? *(AVClass**)ptr : NULL;\n    if (level > av_log_get_level())\n        return;\n    if (print_prefix && avc)\n        http_log(\"[%s @ %p]\", avc->item_name(ptr), ptr);\n    print_prefix = strstr(fmt, \"\\n\") != NULL;\n    http_vlog(fmt, vargs);\n}\n\nstatic void log_connection(HTTPContext *c)\n{\n    if (c->suppress_log)\n        return;\n\n    http_log(\"%s - - [%s] \\\"%s %s\\\" %d %\"PRId64\"\\n\",\n             inet_ntoa(c->from_addr.sin_addr), c->method, c->url,\n             c->protocol, (c->http_error ? c->http_error : 200), c->data_count);\n}\n\nstatic void update_datarate(DataRateData *drd, int64_t count)\n{\n    if (!drd->time1 && !drd->count1) {\n        drd->time1 = drd->time2 = cur_time;\n        drd->count1 = drd->count2 = count;\n    } else if (cur_time - drd->time2 > 5000) {\n        drd->time1 = drd->time2;\n        drd->count1 = drd->count2;\n        drd->time2 = cur_time;\n        drd->count2 = count;\n    }\n}\n\n/* In bytes per second */\nstatic int compute_datarate(DataRateData *drd, int64_t count)\n{\n    if (cur_time == drd->time1)\n        return 0;\n\n    return ((count - drd->count1) * 1000) / (cur_time - drd->time1);\n}\n\n\nstatic void start_children(FFServerStream *feed)\n{\n    char *pathname;\n    char *slash;\n    int i;\n    size_t cmd_length;\n\n    if (no_launch)\n        return;\n\n    cmd_length = strlen(my_program_name);\n\n   /**\n    * FIXME: WIP Safeguard. Remove after clearing all harcoded\n    * '1024' path lengths\n    */\n    if (cmd_length > PATH_LENGTH - 1) {\n        http_log(\"Could not start children. Command line: '%s' exceeds \"\n                    \"path length limit (%d)\\n\", my_program_name, PATH_LENGTH);\n        return;\n    }\n\n    pathname = av_strdup (my_program_name);\n    if (!pathname) {\n        http_log(\"Could not allocate memory for children cmd line\\n\");\n        return;\n    }\n   /* replace \"ffserver\" with \"ffmpeg\" in the path of current\n    * program. Ignore user provided path */\n\n    slash = strrchr(pathname, '/');\n    if (!slash)\n        slash = pathname;\n    else\n        slash++;\n    strcpy(slash, \"ffmpeg\");\n\n    for (; feed; feed = feed->next) {\n\n        if (!feed->child_argv || feed->pid)\n            continue;\n\n        feed->pid_start = time(0);\n\n        feed->pid = fork();\n        if (feed->pid < 0) {\n            http_log(\"Unable to create children: %s\\n\", strerror(errno));\n            av_free (pathname);\n            exit(EXIT_FAILURE);\n        }\n\n        if (feed->pid)\n            continue;\n\n        /* In child */\n\n        http_log(\"Launch command line: \");\n        http_log(\"%s \", pathname);\n\n        for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)\n            http_log(\"%s \", feed->child_argv[i]);\n        http_log(\"\\n\");\n\n        for (i = 3; i < 256; i++)\n            close(i);\n\n        if (!config.debug) {\n            if (!freopen(\"/dev/null\", \"r\", stdin))\n                http_log(\"failed to redirect STDIN to /dev/null\\n;\");\n            if (!freopen(\"/dev/null\", \"w\", stdout))\n                http_log(\"failed to redirect STDOUT to /dev/null\\n;\");\n            if (!freopen(\"/dev/null\", \"w\", stderr))\n                http_log(\"failed to redirect STDERR to /dev/null\\n;\");\n        }\n\n        signal(SIGPIPE, SIG_DFL);\n        execvp(pathname, feed->child_argv);\n        av_free (pathname);\n        _exit(1);\n    }\n    av_free (pathname);\n}\n\n/* open a listening socket */\nstatic int socket_open_listen(struct sockaddr_in *my_addr)\n{\n    int server_fd, tmp;\n\n    server_fd = socket(AF_INET,SOCK_STREAM,0);\n    if (server_fd < 0) {\n        perror (\"socket\");\n        return -1;\n    }\n\n    tmp = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof(tmp)))\n        av_log(NULL, AV_LOG_WARNING, \"setsockopt SO_REUSEADDR failed\\n\");\n\n    my_addr->sin_family = AF_INET;\n    if (bind (server_fd, (struct sockaddr *) my_addr, sizeof (*my_addr)) < 0) {\n        char bindmsg[32];\n        snprintf(bindmsg, sizeof(bindmsg), \"bind(port %d)\",\n                 ntohs(my_addr->sin_port));\n        perror (bindmsg);\n        goto fail;\n    }\n\n    if (listen (server_fd, 5) < 0) {\n        perror (\"listen\");\n        goto fail;\n    }\n\n    if (ff_socket_nonblock(server_fd, 1) < 0)\n        av_log(NULL, AV_LOG_WARNING, \"ff_socket_nonblock failed\\n\");\n\n    return server_fd;\n\nfail:\n    closesocket(server_fd);\n    return -1;\n}\n\n/* start all multicast streams */\nstatic void start_multicast(void)\n{\n    FFServerStream *stream;\n    char session_id[32];\n    HTTPContext *rtp_c;\n    struct sockaddr_in dest_addr = {0};\n    int default_port, stream_index;\n    unsigned int random0, random1;\n\n    default_port = 6000;\n    for(stream = config.first_stream; stream; stream = stream->next) {\n\n        if (!stream->is_multicast)\n            continue;\n\n        random0 = av_lfg_get(&random_state);\n        random1 = av_lfg_get(&random_state);\n\n        /* open the RTP connection */\n        snprintf(session_id, sizeof(session_id), \"%08x%08x\", random0, random1);\n\n        /* choose a port if none given */\n        if (stream->multicast_port == 0) {\n            stream->multicast_port = default_port;\n            default_port += 100;\n        }\n\n        dest_addr.sin_family = AF_INET;\n        dest_addr.sin_addr = stream->multicast_ip;\n        dest_addr.sin_port = htons(stream->multicast_port);\n\n        rtp_c = rtp_new_connection(&dest_addr, stream, session_id,\n                                   RTSP_LOWER_TRANSPORT_UDP_MULTICAST);\n        if (!rtp_c)\n            continue;\n\n        if (open_input_stream(rtp_c, \"\") < 0) {\n            http_log(\"Could not open input stream for stream '%s'\\n\",\n                     stream->filename);\n            continue;\n        }\n\n        /* open each RTP stream */\n        for(stream_index = 0; stream_index < stream->nb_streams;\n            stream_index++) {\n            dest_addr.sin_port = htons(stream->multicast_port +\n                                       2 * stream_index);\n            if (rtp_new_av_stream(rtp_c, stream_index, &dest_addr, NULL) >= 0)\n                continue;\n\n            http_log(\"Could not open output stream '%s/streamid=%d'\\n\",\n                     stream->filename, stream_index);\n            exit(1);\n        }\n\n        rtp_c->state = HTTPSTATE_SEND_DATA;\n    }\n}\n\n/* main loop of the HTTP server */\nstatic int http_server(void)\n{\n    int server_fd = 0, rtsp_server_fd = 0;\n    int ret, delay;\n    struct pollfd *poll_table, *poll_entry;\n    HTTPContext *c, *c_next;\n\n    poll_table = av_mallocz_array(config.nb_max_http_connections + 2,\n                                  sizeof(*poll_table));\n    if(!poll_table) {\n        http_log(\"Impossible to allocate a poll table handling %d \"\n                 \"connections.\\n\", config.nb_max_http_connections);\n        return -1;\n    }\n\n    if (config.http_addr.sin_port) {\n        server_fd = socket_open_listen(&config.http_addr);\n        if (server_fd < 0)\n            goto quit;\n    }\n\n    if (config.rtsp_addr.sin_port) {\n        rtsp_server_fd = socket_open_listen(&config.rtsp_addr);\n        if (rtsp_server_fd < 0) {\n            closesocket(server_fd);\n            goto quit;\n        }\n    }\n\n    if (!rtsp_server_fd && !server_fd) {\n        http_log(\"HTTP and RTSP disabled.\\n\");\n        goto quit;\n    }\n\n    http_log(\"FFserver started.\\n\");\n\n    start_children(config.first_feed);\n\n    start_multicast();\n\n    for(;;) {\n        poll_entry = poll_table;\n        if (server_fd) {\n            poll_entry->fd = server_fd;\n            poll_entry->events = POLLIN;\n            poll_entry++;\n        }\n        if (rtsp_server_fd) {\n            poll_entry->fd = rtsp_server_fd;\n            poll_entry->events = POLLIN;\n            poll_entry++;\n        }\n\n        /* wait for events on each HTTP handle */\n        c = first_http_ctx;\n        delay = 1000;\n        while (c) {\n            int fd;\n            fd = c->fd;\n            switch(c->state) {\n            case HTTPSTATE_SEND_HEADER:\n            case RTSPSTATE_SEND_REPLY:\n            case RTSPSTATE_SEND_PACKET:\n                c->poll_entry = poll_entry;\n                poll_entry->fd = fd;\n                poll_entry->events = POLLOUT;\n                poll_entry++;\n                break;\n            case HTTPSTATE_SEND_DATA_HEADER:\n            case HTTPSTATE_SEND_DATA:\n            case HTTPSTATE_SEND_DATA_TRAILER:\n                if (!c->is_packetized) {\n                    /* for TCP, we output as much as we can\n                     * (may need to put a limit) */\n                    c->poll_entry = poll_entry;\n                    poll_entry->fd = fd;\n                    poll_entry->events = POLLOUT;\n                    poll_entry++;\n                } else {\n                    /* when ffserver is doing the timing, we work by\n                     * looking at which packet needs to be sent every\n                     * 10 ms (one tick wait XXX: 10 ms assumed) */\n                    if (delay > 10)\n                        delay = 10;\n                }\n                break;\n            case HTTPSTATE_WAIT_REQUEST:\n            case HTTPSTATE_RECEIVE_DATA:\n            case HTTPSTATE_WAIT_FEED:\n            case RTSPSTATE_WAIT_REQUEST:\n                /* need to catch errors */\n                c->poll_entry = poll_entry;\n                poll_entry->fd = fd;\n                poll_entry->events = POLLIN;/* Maybe this will work */\n                poll_entry++;\n                break;\n            default:\n                c->poll_entry = NULL;\n                break;\n            }\n            c = c->next;\n        }\n\n        /* wait for an event on one connection. We poll at least every\n         * second to handle timeouts */\n        do {\n            ret = poll(poll_table, poll_entry - poll_table, delay);\n            if (ret < 0 && ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                goto quit;\n            }\n        } while (ret < 0);\n\n        cur_time = av_gettime() / 1000;\n\n        if (need_to_start_children) {\n            need_to_start_children = 0;\n            start_children(config.first_feed);\n        }\n\n        /* now handle the events */\n        for(c = first_http_ctx; c; c = c_next) {\n            c_next = c->next;\n            if (handle_connection(c) < 0) {\n                log_connection(c);\n                /* close and free the connection */\n                close_connection(c);\n            }\n        }\n\n        poll_entry = poll_table;\n        if (server_fd) {\n            /* new HTTP connection request ? */\n            if (poll_entry->revents & POLLIN)\n                new_connection(server_fd, 0);\n            poll_entry++;\n        }\n        if (rtsp_server_fd) {\n            /* new RTSP connection request ? */\n            if (poll_entry->revents & POLLIN)\n                new_connection(rtsp_server_fd, 1);\n        }\n    }\n\nquit:\n    av_free(poll_table);\n    return -1;\n}\n\n/* start waiting for a new HTTP/RTSP request */\nstatic void start_wait_request(HTTPContext *c, int is_rtsp)\n{\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = c->buffer + c->buffer_size - 1; /* leave room for '\\0' */\n\n    c->state = is_rtsp ? RTSPSTATE_WAIT_REQUEST : HTTPSTATE_WAIT_REQUEST;\n    c->timeout = cur_time +\n                 (is_rtsp ? RTSP_REQUEST_TIMEOUT : HTTP_REQUEST_TIMEOUT);\n}\n\nstatic void http_send_too_busy_reply(int fd)\n{\n    char buffer[400];\n    int len = snprintf(buffer, sizeof(buffer),\n                       \"HTTP/1.0 503 Server too busy\\r\\n\"\n                       \"Content-type: text/html\\r\\n\"\n                       \"\\r\\n\"\n                       \"<!DOCTYPE html>\\n\"\n                       \"<html><head><title>Too busy</title></head><body>\\r\\n\"\n                       \"<p>The server is too busy to serve your request at \"\n                       \"this time.</p>\\r\\n\"\n                       \"<p>The number of current connections is %u, and this \"\n                       \"exceeds the limit of %u.</p>\\r\\n\"\n                       \"</body></html>\\r\\n\",\n                       nb_connections, config.nb_max_connections);\n    av_assert0(len < sizeof(buffer));\n    if (send(fd, buffer, len, 0) < len)\n        av_log(NULL, AV_LOG_WARNING,\n               \"Could not send too-busy reply, send() failed\\n\");\n}\n\n\nstatic void new_connection(int server_fd, int is_rtsp)\n{\n    struct sockaddr_in from_addr;\n    socklen_t len;\n    int fd;\n    HTTPContext *c = NULL;\n\n    len = sizeof(from_addr);\n    fd = accept(server_fd, (struct sockaddr *)&from_addr,\n                &len);\n    if (fd < 0) {\n        http_log(\"error during accept %s\\n\", strerror(errno));\n        return;\n    }\n    if (ff_socket_nonblock(fd, 1) < 0)\n        av_log(NULL, AV_LOG_WARNING, \"ff_socket_nonblock failed\\n\");\n\n    if (nb_connections >= config.nb_max_connections) {\n        http_send_too_busy_reply(fd);\n        goto fail;\n    }\n\n    /* add a new connection */\n    c = av_mallocz(sizeof(HTTPContext));\n    if (!c)\n        goto fail;\n\n    c->fd = fd;\n    c->poll_entry = NULL;\n    c->from_addr = from_addr;\n    c->buffer_size = IOBUFFER_INIT_SIZE;\n    c->buffer = av_malloc(c->buffer_size);\n    if (!c->buffer)\n        goto fail;\n\n    c->next = first_http_ctx;\n    first_http_ctx = c;\n    nb_connections++;\n\n    start_wait_request(c, is_rtsp);\n\n    return;\n\n fail:\n    if (c) {\n        av_freep(&c->buffer);\n        av_free(c);\n    }\n    closesocket(fd);\n}\n\nstatic void close_connection(HTTPContext *c)\n{\n    HTTPContext **cp, *c1;\n    int i, nb_streams;\n    AVFormatContext *ctx;\n    AVStream *st;\n\n    /* remove connection from list */\n    cp = &first_http_ctx;\n    while (*cp) {\n        c1 = *cp;\n        if (c1 == c)\n            *cp = c->next;\n        else\n            cp = &c1->next;\n    }\n\n    /* remove references, if any (XXX: do it faster) */\n    for(c1 = first_http_ctx; c1; c1 = c1->next) {\n        if (c1->rtsp_c == c)\n            c1->rtsp_c = NULL;\n    }\n\n    /* remove connection associated resources */\n    if (c->fd >= 0)\n        closesocket(c->fd);\n    if (c->fmt_in) {\n        /* close each frame parser */\n        for(i=0;i<c->fmt_in->nb_streams;i++) {\n            st = c->fmt_in->streams[i];\n            if (st->codec->codec)\n                avcodec_close(st->codec);\n        }\n        avformat_close_input(&c->fmt_in);\n    }\n\n    /* free RTP output streams if any */\n    nb_streams = 0;\n    if (c->stream)\n        nb_streams = c->stream->nb_streams;\n\n    for(i=0;i<nb_streams;i++) {\n        ctx = c->rtp_ctx[i];\n        if (ctx) {\n            av_write_trailer(ctx);\n            av_dict_free(&ctx->metadata);\n            av_freep(&ctx->streams[0]);\n            av_freep(&ctx);\n        }\n        ffurl_close(c->rtp_handles[i]);\n    }\n\n    ctx = c->pfmt_ctx;\n\n    if (ctx) {\n        if (!c->last_packet_sent && c->state == HTTPSTATE_SEND_DATA_TRAILER) {\n            /* prepare header */\n            if (ctx->oformat && avio_open_dyn_buf(&ctx->pb) >= 0) {\n                av_write_trailer(ctx);\n                av_freep(&c->pb_buffer);\n                avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n            }\n        }\n        for(i=0; i<ctx->nb_streams; i++)\n            av_freep(&ctx->streams[i]);\n        av_freep(&ctx->streams);\n        av_freep(&ctx->priv_data);\n        }\n\n    if (c->stream && !c->post && c->stream->stream_type == STREAM_TYPE_LIVE)\n        current_bandwidth -= c->stream->bandwidth;\n\n    /* signal that there is no feed if we are the feeder socket */\n    if (c->state == HTTPSTATE_RECEIVE_DATA && c->stream) {\n        c->stream->feed_opened = 0;\n        close(c->feed_fd);\n    }\n\n    av_freep(&c->pb_buffer);\n    av_freep(&c->packet_buffer);\n    av_freep(&c->buffer);\n    av_free(c);\n    nb_connections--;\n}\n\nstatic int handle_connection(HTTPContext *c)\n{\n    int len, ret;\n    uint8_t *ptr;\n\n    switch(c->state) {\n    case HTTPSTATE_WAIT_REQUEST:\n    case RTSPSTATE_WAIT_REQUEST:\n        /* timeout ? */\n        if ((c->timeout - cur_time) < 0)\n            return -1;\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n\n        /* no need to read if no events */\n        if (!(c->poll_entry->revents & POLLIN))\n            return 0;\n        /* read the data */\n    read_loop:\n        if (!(len = recv(c->fd, c->buffer_ptr, 1, 0)))\n            return -1;\n\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                return -1;\n            break;\n        }\n        /* search for end of request. */\n        c->buffer_ptr += len;\n        ptr = c->buffer_ptr;\n        if ((ptr >= c->buffer + 2 && !memcmp(ptr-2, \"\\n\\n\", 2)) ||\n            (ptr >= c->buffer + 4 && !memcmp(ptr-4, \"\\r\\n\\r\\n\", 4))) {\n            /* request found : parse it and reply */\n            if (c->state == HTTPSTATE_WAIT_REQUEST)\n                ret = http_parse_request(c);\n            else\n                ret = rtsp_parse_request(c);\n\n            if (ret < 0)\n                return -1;\n        } else if (ptr >= c->buffer_end) {\n            /* request too long: cannot do anything */\n            return -1;\n        } else goto read_loop;\n\n        break;\n\n    case HTTPSTATE_SEND_HEADER:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                goto close_connection;\n            }\n            break;\n        }\n        c->buffer_ptr += len;\n        if (c->stream)\n            c->stream->bytes_served += len;\n        c->data_count += len;\n        if (c->buffer_ptr >= c->buffer_end) {\n            av_freep(&c->pb_buffer);\n            /* if error, exit */\n            if (c->http_error)\n                return -1;\n            /* all the buffer was sent : synchronize to the incoming\n             * stream */\n            c->state = HTTPSTATE_SEND_DATA_HEADER;\n            c->buffer_ptr = c->buffer_end = c->buffer;\n        }\n        break;\n\n    case HTTPSTATE_SEND_DATA:\n    case HTTPSTATE_SEND_DATA_HEADER:\n    case HTTPSTATE_SEND_DATA_TRAILER:\n        /* for packetized output, we consider we can always write (the\n         * input streams set the speed). It may be better to verify\n         * that we do not rely too much on the kernel queues */\n        if (!c->is_packetized) {\n            if (c->poll_entry->revents & (POLLERR | POLLHUP))\n                return -1;\n\n            /* no need to read if no events */\n            if (!(c->poll_entry->revents & POLLOUT))\n                return 0;\n        }\n        if (http_send_data(c) < 0)\n            return -1;\n        /* close connection if trailer sent */\n        if (c->state == HTTPSTATE_SEND_DATA_TRAILER)\n            return -1;\n        /* Check if it is a single jpeg frame 123 */\n        if (c->stream->single_frame && c->data_count > c->cur_frame_bytes && c->cur_frame_bytes > 0) {\n            close_connection(c);\n        }\n        break;\n    case HTTPSTATE_RECEIVE_DATA:\n        /* no need to read if no events */\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n        if (!(c->poll_entry->revents & POLLIN))\n            return 0;\n        if (http_receive_data(c) < 0)\n            return -1;\n        break;\n    case HTTPSTATE_WAIT_FEED:\n        /* no need to read if no events */\n        if (c->poll_entry->revents & (POLLIN | POLLERR | POLLHUP))\n            return -1;\n\n        /* nothing to do, we'll be waken up by incoming feed packets */\n        break;\n\n    case RTSPSTATE_SEND_REPLY:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            goto close_connection;\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                goto close_connection;\n            }\n            break;\n        }\n        c->buffer_ptr += len;\n        c->data_count += len;\n        if (c->buffer_ptr >= c->buffer_end) {\n            /* all the buffer was sent : wait for a new request */\n            av_freep(&c->pb_buffer);\n            start_wait_request(c, 1);\n        }\n        break;\n    case RTSPSTATE_SEND_PACKET:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP)) {\n            av_freep(&c->packet_buffer);\n            return -1;\n        }\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->packet_buffer_ptr,\n                    c->packet_buffer_end - c->packet_buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                /* error : close connection */\n                av_freep(&c->packet_buffer);\n                return -1;\n            }\n            break;\n        }\n        c->packet_buffer_ptr += len;\n        if (c->packet_buffer_ptr >= c->packet_buffer_end) {\n            /* all the buffer was sent : wait for a new request */\n            av_freep(&c->packet_buffer);\n            c->state = RTSPSTATE_WAIT_REQUEST;\n        }\n        break;\n    case HTTPSTATE_READY:\n        /* nothing to do */\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n\nclose_connection:\n    av_freep(&c->pb_buffer);\n    return -1;\n}\n\nstatic int extract_rates(char *rates, int ratelen, const char *request)\n{\n    const char *p;\n\n    for (p = request; *p && *p != '\\r' && *p != '\\n'; ) {\n        if (av_strncasecmp(p, \"Pragma:\", 7) == 0) {\n            const char *q = p + 7;\n\n            while (*q && *q != '\\n' && av_isspace(*q))\n                q++;\n\n            if (av_strncasecmp(q, \"stream-switch-entry=\", 20) == 0) {\n                int stream_no;\n                int rate_no;\n\n                q += 20;\n\n                memset(rates, 0xff, ratelen);\n\n                while (1) {\n                    while (*q && *q != '\\n' && *q != ':')\n                        q++;\n\n                    if (sscanf(q, \":%d:%d\", &stream_no, &rate_no) != 2)\n                        break;\n\n                    stream_no--;\n                    if (stream_no < ratelen && stream_no >= 0)\n                        rates[stream_no] = rate_no;\n\n                    while (*q && *q != '\\n' && !av_isspace(*q))\n                        q++;\n                }\n\n                return 1;\n            }\n        }\n        p = strchr(p, '\\n');\n        if (!p)\n            break;\n\n        p++;\n    }\n\n    return 0;\n}\n\nstatic int find_stream_in_feed(FFServerStream *feed, AVCodecParameters *codec,\n                               int bit_rate)\n{\n    int i;\n    int best_bitrate = 100000000;\n    int best = -1;\n\n    for (i = 0; i < feed->nb_streams; i++) {\n        AVCodecParameters *feed_codec = feed->streams[i]->codecpar;\n\n        if (feed_codec->codec_id != codec->codec_id ||\n            feed_codec->sample_rate != codec->sample_rate ||\n            feed_codec->width != codec->width ||\n            feed_codec->height != codec->height)\n            continue;\n\n        /* Potential stream */\n\n        /* We want the fastest stream less than bit_rate, or the slowest\n         * faster than bit_rate\n         */\n\n        if (feed_codec->bit_rate <= bit_rate) {\n            if (best_bitrate > bit_rate ||\n                feed_codec->bit_rate > best_bitrate) {\n                best_bitrate = feed_codec->bit_rate;\n                best = i;\n            }\n            continue;\n        }\n        if (feed_codec->bit_rate < best_bitrate) {\n            best_bitrate = feed_codec->bit_rate;\n            best = i;\n        }\n    }\n    return best;\n}\n\nstatic int modify_current_stream(HTTPContext *c, char *rates)\n{\n    int i;\n    FFServerStream *req = c->stream;\n    int action_required = 0;\n\n    /* Not much we can do for a feed */\n    if (!req->feed)\n        return 0;\n\n    for (i = 0; i < req->nb_streams; i++) {\n        AVCodecParameters *codec = req->streams[i]->codecpar;\n\n        switch(rates[i]) {\n            case 0:\n                c->switch_feed_streams[i] = req->feed_streams[i];\n                break;\n            case 1:\n                c->switch_feed_streams[i] = find_stream_in_feed(req->feed, codec, codec->bit_rate / 2);\n                break;\n            case 2:\n                /* Wants off or slow */\n                c->switch_feed_streams[i] = find_stream_in_feed(req->feed, codec, codec->bit_rate / 4);\n#ifdef WANTS_OFF\n                /* This doesn't work well when it turns off the only stream! */\n                c->switch_feed_streams[i] = -2;\n                c->feed_streams[i] = -2;\n#endif\n                break;\n        }\n\n        if (c->switch_feed_streams[i] >= 0 &&\n            c->switch_feed_streams[i] != c->feed_streams[i]) {\n            action_required = 1;\n        }\n    }\n\n    return action_required;\n}\n\nstatic void get_word(char *buf, int buf_size, const char **pp)\n{\n    const char *p;\n    char *q;\n\n#define SPACE_CHARS \" \\t\\r\\n\"\n\n    p = *pp;\n    p += strspn(p, SPACE_CHARS);\n    q = buf;\n    while (!av_isspace(*p) && *p != '\\0') {\n        if ((q - buf) < buf_size - 1)\n            *q++ = *p;\n        p++;\n    }\n    if (buf_size > 0)\n        *q = '\\0';\n    *pp = p;\n}\n\nstatic FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream,\n                                               HTTPContext *c)\n{\n    FILE* f;\n    char line[1024];\n    char  cmd[1024];\n    FFServerIPAddressACL *acl = NULL;\n    int line_num = 0;\n    const char *p;\n\n    f = fopen(stream->dynamic_acl, \"r\");\n    if (!f) {\n        perror(stream->dynamic_acl);\n        return NULL;\n    }\n\n    acl = av_mallocz(sizeof(FFServerIPAddressACL));\n    if (!acl) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* Build ACL */\n    while (fgets(line, sizeof(line), f)) {\n        line_num++;\n        p = line;\n        while (av_isspace(*p))\n            p++;\n        if (*p == '\\0' || *p == '#')\n            continue;\n        ffserver_get_arg(cmd, sizeof(cmd), &p);\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl,\n                                   line_num);\n    }\n    fclose(f);\n    return acl;\n}\n\n\nstatic void free_acl_list(FFServerIPAddressACL *in_acl)\n{\n    FFServerIPAddressACL *pacl, *pacl2;\n\n    pacl = in_acl;\n    while(pacl) {\n        pacl2 = pacl;\n        pacl = pacl->next;\n        av_freep(pacl2);\n    }\n}\n\nstatic int validate_acl_list(FFServerIPAddressACL *in_acl, HTTPContext *c)\n{\n    enum FFServerIPAddressAction last_action = IP_DENY;\n    FFServerIPAddressACL *acl;\n    struct in_addr *src = &c->from_addr.sin_addr;\n    unsigned long src_addr = src->s_addr;\n\n    for (acl = in_acl; acl; acl = acl->next) {\n        if (src_addr >= acl->first.s_addr && src_addr <= acl->last.s_addr)\n            return (acl->action == IP_ALLOW) ? 1 : 0;\n        last_action = acl->action;\n    }\n\n    /* Nothing matched, so return not the last action */\n    return (last_action == IP_DENY) ? 1 : 0;\n}\n\nstatic int validate_acl(FFServerStream *stream, HTTPContext *c)\n{\n    int ret = 0;\n    FFServerIPAddressACL *acl;\n\n    /* if stream->acl is null validate_acl_list will return 1 */\n    ret = validate_acl_list(stream->acl, c);\n\n    if (stream->dynamic_acl[0]) {\n        acl = parse_dynamic_acl(stream, c);\n        ret = validate_acl_list(acl, c);\n        free_acl_list(acl);\n    }\n\n    return ret;\n}\n\n/**\n * compute the real filename of a file by matching it without its\n * extensions to all the stream's filenames\n */\nstatic void compute_real_filename(char *filename, int max_size)\n{\n    char file1[1024];\n    char file2[1024];\n    char *p;\n    FFServerStream *stream;\n\n    av_strlcpy(file1, filename, sizeof(file1));\n    p = strrchr(file1, '.');\n    if (p)\n        *p = '\\0';\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        av_strlcpy(file2, stream->filename, sizeof(file2));\n        p = strrchr(file2, '.');\n        if (p)\n            *p = '\\0';\n        if (!strcmp(file1, file2)) {\n            av_strlcpy(filename, stream->filename, max_size);\n            break;\n        }\n    }\n}\n\nenum RedirType {\n    REDIR_NONE,\n    REDIR_ASX,\n    REDIR_RAM,\n    REDIR_ASF,\n    REDIR_RTSP,\n    REDIR_SDP,\n};\n\n/* parse HTTP request and prepare header */\nstatic int http_parse_request(HTTPContext *c)\n{\n    const char *p;\n    char *p1;\n    enum RedirType redir_type;\n    char cmd[32];\n    char info[1024], filename[1024];\n    char url[1024], *q;\n    char protocol[32];\n    char msg[1024];\n    char *encoded_msg = NULL;\n    const char *mime_type;\n    FFServerStream *stream;\n    int i;\n    char ratebuf[32];\n    const char *useragent = 0;\n\n    p = c->buffer;\n    get_word(cmd, sizeof(cmd), &p);\n    av_strlcpy(c->method, cmd, sizeof(c->method));\n\n    if (!strcmp(cmd, \"GET\"))\n        c->post = 0;\n    else if (!strcmp(cmd, \"POST\"))\n        c->post = 1;\n    else\n        return -1;\n\n    get_word(url, sizeof(url), &p);\n    av_strlcpy(c->url, url, sizeof(c->url));\n\n    get_word(protocol, sizeof(protocol), (const char **)&p);\n    if (strcmp(protocol, \"HTTP/1.0\") && strcmp(protocol, \"HTTP/1.1\"))\n        return -1;\n\n    av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n\n    if (config.debug)\n        http_log(\"%s - - New connection: %s %s\\n\",\n                 inet_ntoa(c->from_addr.sin_addr), cmd, url);\n\n    /* find the filename and the optional info string in the request */\n    p1 = strchr(url, '?');\n    if (p1) {\n        av_strlcpy(info, p1, sizeof(info));\n        *p1 = '\\0';\n    } else\n        info[0] = '\\0';\n\n    av_strlcpy(filename, url + ((*url == '/') ? 1 : 0), sizeof(filename)-1);\n\n    for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n        if (av_strncasecmp(p, \"User-Agent:\", 11) == 0) {\n            useragent = p + 11;\n            if (*useragent && *useragent != '\\n' && av_isspace(*useragent))\n                useragent++;\n            break;\n        }\n        p = strchr(p, '\\n');\n        if (!p)\n            break;\n\n        p++;\n    }\n\n    redir_type = REDIR_NONE;\n    if (av_match_ext(filename, \"asx\")) {\n        redir_type = REDIR_ASX;\n        filename[strlen(filename)-1] = 'f';\n    } else if (av_match_ext(filename, \"asf\") &&\n        (!useragent || av_strncasecmp(useragent, \"NSPlayer\", 8))) {\n        /* if this isn't WMP or lookalike, return the redirector file */\n        redir_type = REDIR_ASF;\n    } else if (av_match_ext(filename, \"rpm,ram\")) {\n        redir_type = REDIR_RAM;\n        strcpy(filename + strlen(filename)-2, \"m\");\n    } else if (av_match_ext(filename, \"rtsp\")) {\n        redir_type = REDIR_RTSP;\n        compute_real_filename(filename, sizeof(filename) - 1);\n    } else if (av_match_ext(filename, \"sdp\")) {\n        redir_type = REDIR_SDP;\n        compute_real_filename(filename, sizeof(filename) - 1);\n    }\n\n    /* \"redirect\" request to index.html */\n    if (!strlen(filename))\n        av_strlcpy(filename, \"index.html\", sizeof(filename) - 1);\n\n    stream = config.first_stream;\n    while (stream) {\n        if (!strcmp(stream->filename, filename) && validate_acl(stream, c))\n            break;\n        stream = stream->next;\n    }\n    if (!stream) {\n        snprintf(msg, sizeof(msg), \"File '%s' not found\", url);\n        http_log(\"File '%s' not found\\n\", url);\n        goto send_error;\n    }\n\n    c->stream = stream;\n    memcpy(c->feed_streams, stream->feed_streams, sizeof(c->feed_streams));\n    memset(c->switch_feed_streams, -1, sizeof(c->switch_feed_streams));\n\n    if (stream->stream_type == STREAM_TYPE_REDIRECT) {\n        c->http_error = 301;\n        q = c->buffer;\n        snprintf(q, c->buffer_size,\n                      \"HTTP/1.0 301 Moved\\r\\n\"\n                      \"Location: %s\\r\\n\"\n                      \"Content-type: text/html\\r\\n\"\n                      \"\\r\\n\"\n                      \"<!DOCTYPE html>\\n\"\n                      \"<html><head><title>Moved</title></head><body>\\r\\n\"\n                      \"You should be <a href=\\\"%s\\\">redirected</a>.\\r\\n\"\n                      \"</body></html>\\r\\n\",\n                 stream->feed_filename, stream->feed_filename);\n        q += strlen(q);\n        /* prepare output buffer */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = q;\n        c->state = HTTPSTATE_SEND_HEADER;\n        return 0;\n    }\n\n    /* If this is WMP, get the rate information */\n    if (extract_rates(ratebuf, sizeof(ratebuf), c->buffer)) {\n        if (modify_current_stream(c, ratebuf)) {\n            for (i = 0; i < FF_ARRAY_ELEMS(c->feed_streams); i++) {\n                if (c->switch_feed_streams[i] >= 0)\n                    c->switch_feed_streams[i] = -1;\n            }\n        }\n    }\n\n    if (c->post == 0 && stream->stream_type == STREAM_TYPE_LIVE)\n        current_bandwidth += stream->bandwidth;\n\n    /* If already streaming this feed, do not let another feeder start */\n    if (stream->feed_opened) {\n        snprintf(msg, sizeof(msg), \"This feed is already being received.\");\n        http_log(\"Feed '%s' already being received\\n\", stream->feed_filename);\n        goto send_error;\n    }\n\n    if (c->post == 0 && config.max_bandwidth < current_bandwidth) {\n        c->http_error = 503;\n        q = c->buffer;\n        snprintf(q, c->buffer_size,\n                      \"HTTP/1.0 503 Server too busy\\r\\n\"\n                      \"Content-type: text/html\\r\\n\"\n                      \"\\r\\n\"\n                      \"<!DOCTYPE html>\\n\"\n                      \"<html><head><title>Too busy</title></head><body>\\r\\n\"\n                      \"<p>The server is too busy to serve your request at \"\n                      \"this time.</p>\\r\\n\"\n                      \"<p>The bandwidth being served (including your stream) \"\n                      \"is %\"PRIu64\"kbit/s, and this exceeds the limit of \"\n                      \"%\"PRIu64\"kbit/s.</p>\\r\\n\"\n                      \"</body></html>\\r\\n\",\n                 current_bandwidth, config.max_bandwidth);\n        q += strlen(q);\n        /* prepare output buffer */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = q;\n        c->state = HTTPSTATE_SEND_HEADER;\n        return 0;\n    }\n\n    if (redir_type != REDIR_NONE) {\n        const char *hostinfo = 0;\n\n        for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n            if (av_strncasecmp(p, \"Host:\", 5) == 0) {\n                hostinfo = p + 5;\n                break;\n            }\n            p = strchr(p, '\\n');\n            if (!p)\n                break;\n\n            p++;\n        }\n\n        if (hostinfo) {\n            char *eoh;\n            char hostbuf[260];\n\n            while (av_isspace(*hostinfo))\n                hostinfo++;\n\n            eoh = strchr(hostinfo, '\\n');\n            if (eoh) {\n                if (eoh[-1] == '\\r')\n                    eoh--;\n\n                if (eoh - hostinfo < sizeof(hostbuf) - 1) {\n                    memcpy(hostbuf, hostinfo, eoh - hostinfo);\n                    hostbuf[eoh - hostinfo] = 0;\n\n                    c->http_error = 200;\n                    q = c->buffer;\n                    switch(redir_type) {\n                    case REDIR_ASX:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 ASX Follows\\r\\n\"\n                                      \"Content-type: video/x-ms-asf\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"<ASX Version=\\\"3\\\">\\r\\n\"\n                                      //\"<!-- Autogenerated by ffserver -->\\r\\n\"\n                                      \"<ENTRY><REF HREF=\\\"http://%s/%s%s\\\"/></ENTRY>\\r\\n\"\n                                      \"</ASX>\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_RAM:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 RAM Follows\\r\\n\"\n                                      \"Content-type: audio/x-pn-realaudio\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"# Autogenerated by ffserver\\r\\n\"\n                                      \"http://%s/%s%s\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_ASF:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 ASF Redirect follows\\r\\n\"\n                                      \"Content-type: video/x-ms-asf\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"[Reference]\\r\\n\"\n                                      \"Ref1=http://%s/%s%s\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_RTSP:\n                        {\n                            char hostname[256], *p;\n                            /* extract only hostname */\n                            av_strlcpy(hostname, hostbuf, sizeof(hostname));\n                            p = strrchr(hostname, ':');\n                            if (p)\n                                *p = '\\0';\n                            snprintf(q, c->buffer_size,\n                                          \"HTTP/1.0 200 RTSP Redirect follows\\r\\n\"\n                                          /* XXX: incorrect MIME type ? */\n                                          \"Content-type: application/x-rtsp\\r\\n\"\n                                          \"\\r\\n\"\n                                          \"rtsp://%s:%d/%s\\r\\n\", hostname, ntohs(config.rtsp_addr.sin_port), filename);\n                            q += strlen(q);\n                        }\n                        break;\n                    case REDIR_SDP:\n                        {\n                            uint8_t *sdp_data;\n                            int sdp_data_size;\n                            socklen_t len;\n                            struct sockaddr_in my_addr;\n\n                            snprintf(q, c->buffer_size,\n                                          \"HTTP/1.0 200 OK\\r\\n\"\n                                          \"Content-type: application/sdp\\r\\n\"\n                                          \"\\r\\n\");\n                            q += strlen(q);\n\n                            len = sizeof(my_addr);\n\n                            /* XXX: Should probably fail? */\n                            if (getsockname(c->fd, (struct sockaddr *)&my_addr, &len))\n                                http_log(\"getsockname() failed\\n\");\n\n                            /* XXX: should use a dynamic buffer */\n                            sdp_data_size = prepare_sdp_description(stream,\n                                                                    &sdp_data,\n                                                                    my_addr.sin_addr);\n                            if (sdp_data_size > 0) {\n                                memcpy(q, sdp_data, sdp_data_size);\n                                q += sdp_data_size;\n                                *q = '\\0';\n                                av_freep(&sdp_data);\n                            }\n                        }\n                        break;\n                    default:\n                        abort();\n                        break;\n                    }\n\n                    /* prepare output buffer */\n                    c->buffer_ptr = c->buffer;\n                    c->buffer_end = q;\n                    c->state = HTTPSTATE_SEND_HEADER;\n                    return 0;\n                }\n            }\n        }\n\n        snprintf(msg, sizeof(msg), \"ASX/RAM file not handled\");\n        goto send_error;\n    }\n\n    stream->conns_served++;\n\n    /* XXX: add there authenticate and IP match */\n\n    if (c->post) {\n        /* if post, it means a feed is being sent */\n        if (!stream->is_feed) {\n            /* However it might be a status report from WMP! Let us log the\n             * data as it might come handy one day. */\n            const char *logline = 0;\n            int client_id = 0;\n\n            for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n                if (av_strncasecmp(p, \"Pragma: log-line=\", 17) == 0) {\n                    logline = p;\n                    break;\n                }\n                if (av_strncasecmp(p, \"Pragma: client-id=\", 18) == 0)\n                    client_id = strtol(p + 18, 0, 10);\n                p = strchr(p, '\\n');\n                if (!p)\n                    break;\n\n                p++;\n            }\n\n            if (logline) {\n                char *eol = strchr(logline, '\\n');\n\n                logline += 17;\n\n                if (eol) {\n                    if (eol[-1] == '\\r')\n                        eol--;\n                    http_log(\"%.*s\\n\", (int) (eol - logline), logline);\n                    c->suppress_log = 1;\n                }\n            }\n\n#ifdef DEBUG\n            http_log(\"\\nGot request:\\n%s\\n\", c->buffer);\n#endif\n\n            if (client_id && extract_rates(ratebuf, sizeof(ratebuf), c->buffer)) {\n                HTTPContext *wmpc;\n\n                /* Now we have to find the client_id */\n                for (wmpc = first_http_ctx; wmpc; wmpc = wmpc->next) {\n                    if (wmpc->wmp_client_id == client_id)\n                        break;\n                }\n\n                if (wmpc && modify_current_stream(wmpc, ratebuf))\n                    wmpc->switch_pending = 1;\n            }\n\n            snprintf(msg, sizeof(msg), \"POST command not handled\");\n            c->stream = 0;\n            goto send_error;\n        }\n        if (http_start_receive_data(c) < 0) {\n            snprintf(msg, sizeof(msg), \"could not open feed\");\n            goto send_error;\n        }\n        c->http_error = 0;\n        c->state = HTTPSTATE_RECEIVE_DATA;\n        return 0;\n    }\n\n#ifdef DEBUG\n    if (strcmp(stream->filename + strlen(stream->filename) - 4, \".asf\") == 0)\n        http_log(\"\\nGot request:\\n%s\\n\", c->buffer);\n#endif\n\n    if (c->stream->stream_type == STREAM_TYPE_STATUS)\n        goto send_status;\n\n    /* open input stream */\n    if (open_input_stream(c, info) < 0) {\n        snprintf(msg, sizeof(msg), \"Input stream corresponding to '%s' not found\", url);\n        goto send_error;\n    }\n\n    /* prepare HTTP header */\n    c->buffer[0] = 0;\n    av_strlcatf(c->buffer, c->buffer_size, \"HTTP/1.0 200 OK\\r\\n\");\n    mime_type = c->stream->fmt->mime_type;\n    if (!mime_type)\n        mime_type = \"application/x-octet-stream\";\n    av_strlcatf(c->buffer, c->buffer_size, \"Pragma: no-cache\\r\\n\");\n\n    /* for asf, we need extra headers */\n    if (!strcmp(c->stream->fmt->name,\"asf_stream\")) {\n        /* Need to allocate a client id */\n\n        c->wmp_client_id = av_lfg_get(&random_state);\n\n        av_strlcatf(c->buffer, c->buffer_size, \"Server: Cougar 4.1.0.3923\\r\\nCache-Control: no-cache\\r\\nPragma: client-id=%d\\r\\nPragma: features=\\\"broadcast\\\"\\r\\n\", c->wmp_client_id);\n    }\n    av_strlcatf(c->buffer, c->buffer_size, \"Content-Type: %s\\r\\n\", mime_type);\n    av_strlcatf(c->buffer, c->buffer_size, \"\\r\\n\");\n    q = c->buffer + strlen(c->buffer);\n\n    /* prepare output buffer */\n    c->http_error = 0;\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = q;\n    c->state = HTTPSTATE_SEND_HEADER;\n    return 0;\n send_error:\n    c->http_error = 404;\n    q = c->buffer;\n    if (!htmlencode(msg, &encoded_msg)) {\n        http_log(\"Could not encode filename '%s' as HTML\\n\", msg);\n    }\n    snprintf(q, c->buffer_size,\n                  \"HTTP/1.0 404 Not Found\\r\\n\"\n                  \"Content-type: text/html\\r\\n\"\n                  \"\\r\\n\"\n                  \"<!DOCTYPE html>\\n\"\n                  \"<html>\\n\"\n                  \"<head>\\n\"\n                  \"<meta charset=\\\"UTF-8\\\">\\n\"\n                  \"<title>404 Not Found</title>\\n\"\n                  \"</head>\\n\"\n                  \"<body>%s</body>\\n\"\n                  \"</html>\\n\", encoded_msg? encoded_msg : \"File not found\");\n    q += strlen(q);\n    /* prepare output buffer */\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = q;\n    c->state = HTTPSTATE_SEND_HEADER;\n    av_freep(&encoded_msg);\n    return 0;\n send_status:\n    compute_status(c);\n    /* horrible: we use this value to avoid\n     * going to the send data state */\n    c->http_error = 200;\n    c->state = HTTPSTATE_SEND_HEADER;\n    return 0;\n}\n\nstatic void fmt_bytecount(AVIOContext *pb, int64_t count)\n{\n    static const char suffix[] = \" kMGTP\";\n    const char *s;\n\n    for (s = suffix; count >= 100000 && s[1]; count /= 1000, s++);\n\n    avio_printf(pb, \"%\"PRId64\"%c\", count, *s);\n}\n\nstatic inline void print_stream_params(AVIOContext *pb, FFServerStream *stream)\n{\n    int i, stream_no;\n    const char *type = \"unknown\";\n    char parameters[64];\n    LayeredAVStream *st;\n    AVCodec *codec;\n\n    stream_no = stream->nb_streams;\n\n    avio_printf(pb, \"<table><tr><th>Stream<th>\"\n                    \"type<th>kbit/s<th>codec<th>\"\n                    \"Parameters\\n\");\n\n    for (i = 0; i < stream_no; i++) {\n        st = stream->streams[i];\n        codec = avcodec_find_encoder(st->codecpar->codec_id);\n\n        parameters[0] = 0;\n\n        switch(st->codecpar->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            type = \"audio\";\n            snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\",\n                     st->codecpar->channels, st->codecpar->sample_rate);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            type = \"video\";\n            snprintf(parameters, sizeof(parameters),\n                     \"%dx%d, q=%d-%d, fps=%d\", st->codecpar->width,\n                     st->codecpar->height, st->codec->qmin, st->codec->qmax,\n                     st->time_base.den / st->time_base.num);\n            break;\n        default:\n            abort();\n        }\n\n        avio_printf(pb, \"<tr><td>%d<td>%s<td>%\"PRId64\n                        \"<td>%s<td>%s\\n\",\n                    i, type, (int64_t)st->codecpar->bit_rate/1000,\n                    codec ? codec->name : \"\", parameters);\n     }\n\n     avio_printf(pb, \"</table>\\n\");\n}\n\nstatic void clean_html(char *clean, int clean_len, char *dirty)\n{\n    int i, o;\n\n    for (o = i = 0; o+10 < clean_len && dirty[i];) {\n        int len = strspn(dirty+i, \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$-_.+!*(),?/ :;%\");\n        if (len) {\n            if (o + len >= clean_len)\n                break;\n            memcpy(clean + o, dirty + i, len);\n            i += len;\n            o += len;\n        } else {\n            int c = dirty[i++];\n            switch (c) {\n            case  '&': av_strlcat(clean+o, \"&amp;\"  , clean_len - o); break;\n            case  '<': av_strlcat(clean+o, \"&lt;\"   , clean_len - o); break;\n            case  '>': av_strlcat(clean+o, \"&gt;\"   , clean_len - o); break;\n            case '\\'': av_strlcat(clean+o, \"&apos;\" , clean_len - o); break;\n            case '\\\"': av_strlcat(clean+o, \"&quot;\" , clean_len - o); break;\n            default:   av_strlcat(clean+o, \"&#9785;\", clean_len - o); break;\n            }\n            o += strlen(clean+o);\n        }\n    }\n    clean[o] = 0;\n}\n\nstatic void compute_status(HTTPContext *c)\n{\n    HTTPContext *c1;\n    FFServerStream *stream;\n    char *p;\n    time_t ti;\n    int i, len;\n    AVIOContext *pb;\n\n    if (avio_open_dyn_buf(&pb) < 0) {\n        /* XXX: return an error ? */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = c->buffer;\n        return;\n    }\n\n    avio_printf(pb, \"HTTP/1.0 200 OK\\r\\n\");\n    avio_printf(pb, \"Content-type: text/html\\r\\n\");\n    avio_printf(pb, \"Pragma: no-cache\\r\\n\");\n    avio_printf(pb, \"\\r\\n\");\n\n    avio_printf(pb, \"<!DOCTYPE html>\\n\");\n    avio_printf(pb, \"<html><head><title>%s Status</title>\\n\", program_name);\n    if (c->stream->feed_filename[0])\n        avio_printf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\",\n                    c->stream->feed_filename);\n    avio_printf(pb, \"</head>\\n<body>\");\n    avio_printf(pb, \"<h1>%s Status</h1>\\n\", program_name);\n    /* format status */\n    avio_printf(pb, \"<h2>Available Streams</h2>\\n\");\n    avio_printf(pb, \"<table>\\n\");\n    avio_printf(pb, \"<tr><th>Path<th>Served<br>Conns<th><br>bytes<th>Format<th>Bit rate<br>kbit/s<th>Video<br>kbit/s<th><br>Codec<th>Audio<br>kbit/s<th><br>Codec<th>Feed\\n\");\n    stream = config.first_stream;\n    while (stream) {\n        char sfilename[1024];\n        char *eosf;\n\n        if (stream->feed == stream) {\n            stream = stream->next;\n            continue;\n        }\n\n        av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n        eosf = sfilename + strlen(sfilename);\n        if (eosf - sfilename >= 4) {\n            if (strcmp(eosf - 4, \".asf\") == 0)\n                strcpy(eosf - 4, \".asx\");\n            else if (strcmp(eosf - 3, \".rm\") == 0)\n                strcpy(eosf - 3, \".ram\");\n            else if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n                /* generate a sample RTSP director if\n                 * unicast. Generate an SDP redirector if\n                 * multicast */\n                eosf = strrchr(sfilename, '.');\n                if (!eosf)\n                    eosf = sfilename + strlen(sfilename);\n                if (stream->is_multicast)\n                    strcpy(eosf, \".sdp\");\n                else\n                    strcpy(eosf, \".rtsp\");\n            }\n        }\n\n        avio_printf(pb, \"<tr><td><a href=\\\"/%s\\\">%s</a> \",\n                    sfilename, stream->filename);\n        avio_printf(pb, \"<td> %d <td> \",\n                    stream->conns_served);\n        // TODO: Investigate if we can make http bitexact so it always produces the same count of bytes\n        if (!config.bitexact)\n            fmt_bytecount(pb, stream->bytes_served);\n\n        switch(stream->stream_type) {\n        case STREAM_TYPE_LIVE: {\n            int audio_bit_rate = 0;\n            int video_bit_rate = 0;\n            const char *audio_codec_name = \"\";\n            const char *video_codec_name = \"\";\n            const char *audio_codec_name_extra = \"\";\n            const char *video_codec_name_extra = \"\";\n\n            for(i=0;i<stream->nb_streams;i++) {\n                LayeredAVStream *st = stream->streams[i];\n                AVCodec *codec = avcodec_find_encoder(st->codecpar->codec_id);\n\n                switch(st->codecpar->codec_type) {\n                case AVMEDIA_TYPE_AUDIO:\n                    audio_bit_rate += st->codecpar->bit_rate;\n                    if (codec) {\n                        if (*audio_codec_name)\n                            audio_codec_name_extra = \"...\";\n                        audio_codec_name = codec->name;\n                    }\n                    break;\n                case AVMEDIA_TYPE_VIDEO:\n                    video_bit_rate += st->codecpar->bit_rate;\n                    if (codec) {\n                        if (*video_codec_name)\n                            video_codec_name_extra = \"...\";\n                        video_codec_name = codec->name;\n                    }\n                    break;\n                case AVMEDIA_TYPE_DATA:\n                    video_bit_rate += st->codecpar->bit_rate;\n                    break;\n                default:\n                    abort();\n                }\n            }\n\n            avio_printf(pb, \"<td> %s <td> %d <td> %d <td> %s %s <td> \"\n                            \"%d <td> %s %s\",\n                        stream->fmt->name, stream->bandwidth,\n                        video_bit_rate / 1000, video_codec_name,\n                        video_codec_name_extra, audio_bit_rate / 1000,\n                        audio_codec_name, audio_codec_name_extra);\n\n            if (stream->feed)\n                avio_printf(pb, \"<td>%s\", stream->feed->filename);\n            else\n                avio_printf(pb, \"<td>%s\", stream->feed_filename);\n            avio_printf(pb, \"\\n\");\n        }\n            break;\n        default:\n            avio_printf(pb, \"<td> - <td> - \"\n                            \"<td> - <td><td> - <td>\\n\");\n            break;\n        }\n        stream = stream->next;\n    }\n    avio_printf(pb, \"</table>\\n\");\n\n    stream = config.first_stream;\n    while (stream) {\n\n        if (stream->feed != stream) {\n            stream = stream->next;\n            continue;\n        }\n\n        avio_printf(pb, \"<h2>Feed %s</h2>\", stream->filename);\n        if (stream->pid) {\n            avio_printf(pb, \"Running as pid %\"PRId64\".\\n\", (int64_t) stream->pid);\n\n#if defined(linux)\n            {\n                FILE *pid_stat;\n                char ps_cmd[64];\n\n                /* This is somewhat linux specific I guess */\n                snprintf(ps_cmd, sizeof(ps_cmd),\n                         \"ps -o \\\"%%cpu,cputime\\\" --no-headers %\"PRId64\"\",\n                         (int64_t) stream->pid);\n\n                 pid_stat = popen(ps_cmd, \"r\");\n                 if (pid_stat) {\n                     char cpuperc[10];\n                     char cpuused[64];\n\n                     if (fscanf(pid_stat, \"%9s %63s\", cpuperc, cpuused) == 2) {\n                         avio_printf(pb, \"Currently using %s%% of the cpu. \"\n                                         \"Total time used %s.\\n\",\n                                     cpuperc, cpuused);\n                     }\n                     fclose(pid_stat);\n                 }\n            }\n#endif\n\n            avio_printf(pb, \"<p>\");\n        }\n\n        print_stream_params(pb, stream);\n        stream = stream->next;\n    }\n\n    /* connection status */\n    avio_printf(pb, \"<h2>Connection Status</h2>\\n\");\n\n    avio_printf(pb, \"Number of connections: %d / %d<br>\\n\",\n                nb_connections, config.nb_max_connections);\n\n    avio_printf(pb, \"Bandwidth in use: %\"PRIu64\"k / %\"PRIu64\"k<br>\\n\",\n                current_bandwidth, config.max_bandwidth);\n\n    avio_printf(pb, \"<table>\\n\");\n    avio_printf(pb, \"<tr><th>#<th>File<th>IP<th>URL<th>Proto<th>State<th>Target \"\n                    \"bit/s<th>Actual bit/s<th>Bytes transferred\\n\");\n    c1 = first_http_ctx;\n    i = 0;\n    while (c1) {\n        int bitrate;\n        int j;\n\n        bitrate = 0;\n        if (c1->stream) {\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n                if (!c1->stream->feed)\n                    bitrate += c1->stream->streams[j]->codecpar->bit_rate;\n                else if (c1->feed_streams[j] >= 0)\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codecpar->bit_rate;\n            }\n        }\n\n        i++;\n        p = inet_ntoa(c1->from_addr.sin_addr);\n        clean_html(c1->clean_url, sizeof(c1->clean_url), c1->url);\n        avio_printf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td>%s\"\n                        \"<td>\",\n                    i, c1->stream ? c1->stream->filename : \"\",\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n                    p,\n                    c1->clean_url,\n                    c1->protocol, http_state[c1->state]);\n        fmt_bytecount(pb, bitrate);\n        avio_printf(pb, \"<td>\");\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n        avio_printf(pb, \"<td>\");\n        fmt_bytecount(pb, c1->data_count);\n        avio_printf(pb, \"\\n\");\n        c1 = c1->next;\n    }\n    avio_printf(pb, \"</table>\\n\");\n\n    if (!config.bitexact) {\n        /* date */\n        ti = time(NULL);\n        p = ctime(&ti);\n        avio_printf(pb, \"<hr>Generated at %s\", p);\n    }\n    avio_printf(pb, \"</body>\\n</html>\\n\");\n\n    len = avio_close_dyn_buf(pb, &c->pb_buffer);\n    c->buffer_ptr = c->pb_buffer;\n    c->buffer_end = c->pb_buffer + len;\n}\n\nstatic int open_input_stream(HTTPContext *c, const char *info)\n{\n    char buf[128];\n    char input_filename[1024];\n    AVFormatContext *s = NULL;\n    int buf_size, i, ret;\n    int64_t stream_pos;\n\n    /* find file name */\n    if (c->stream->feed) {\n        strcpy(input_filename, c->stream->feed->feed_filename);\n        buf_size = FFM_PACKET_SIZE;\n        /* compute position (absolute time) */\n        if (av_find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            if ((ret = av_parse_time(&stream_pos, buf, 0)) < 0) {\n                http_log(\"Invalid date specification '%s' for stream\\n\", buf);\n                return ret;\n            }\n        } else if (av_find_info_tag(buf, sizeof(buf), \"buffer\", info)) {\n            int prebuffer = strtol(buf, 0, 10);\n            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;\n        } else\n            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;\n    } else {\n        strcpy(input_filename, c->stream->feed_filename);\n        buf_size = 0;\n        /* compute position (relative time) */\n        if (av_find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            if ((ret = av_parse_time(&stream_pos, buf, 1)) < 0) {\n                http_log(\"Invalid date specification '%s' for stream\\n\", buf);\n                return ret;\n            }\n        } else\n            stream_pos = 0;\n    }\n    if (!input_filename[0]) {\n        http_log(\"No filename was specified for stream\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* open stream */\n    ret = avformat_open_input(&s, input_filename, c->stream->ifmt,\n                              &c->stream->in_opts);\n    if (ret < 0) {\n        http_log(\"Could not open input '%s': %s\\n\",\n                 input_filename, av_err2str(ret));\n        return ret;\n    }\n\n    /* set buffer size */\n    if (buf_size > 0) {\n        ret = ffio_set_buf_size(s->pb, buf_size);\n        if (ret < 0) {\n            http_log(\"Failed to set buffer size\\n\");\n            return ret;\n        }\n    }\n\n    s->flags |= AVFMT_FLAG_GENPTS;\n    c->fmt_in = s;\n    if (strcmp(s->iformat->name, \"ffm\") &&\n        (ret = avformat_find_stream_info(c->fmt_in, NULL)) < 0) {\n        http_log(\"Could not find stream info for input '%s'\\n\", input_filename);\n        avformat_close_input(&s);\n        return ret;\n    }\n\n    /* choose stream as clock source (we favor the video stream if\n     * present) for packet sending */\n    c->pts_stream_index = 0;\n    for(i=0;i<c->stream->nb_streams;i++) {\n        if (c->pts_stream_index == 0 &&\n            c->stream->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n            c->pts_stream_index = i;\n        }\n    }\n\n    if (c->fmt_in->iformat->read_seek)\n        av_seek_frame(c->fmt_in, -1, stream_pos, 0);\n    /* set the start time (needed for maxtime and RTP packet timing) */\n    c->start_time = cur_time;\n    c->first_pts = AV_NOPTS_VALUE;\n    return 0;\n}\n\n/* return the server clock (in us) */\nstatic int64_t get_server_clock(HTTPContext *c)\n{\n    /* compute current pts value from system time */\n    return (cur_time - c->start_time) * 1000;\n}\n\n/* return the estimated time (in us) at which the current packet must be sent */\nstatic int64_t get_packet_send_clock(HTTPContext *c)\n{\n    int bytes_left, bytes_sent, frame_bytes;\n\n    frame_bytes = c->cur_frame_bytes;\n    if (frame_bytes <= 0)\n        return c->cur_pts;\n\n    bytes_left = c->buffer_end - c->buffer_ptr;\n    bytes_sent = frame_bytes - bytes_left;\n    return c->cur_pts + (c->cur_frame_duration * bytes_sent) / frame_bytes;\n}\n\n\nstatic int http_prepare_data(HTTPContext *c)\n{\n    int i, len, ret;\n    AVFormatContext *ctx;\n\n    av_freep(&c->pb_buffer);\n    switch(c->state) {\n    case HTTPSTATE_SEND_DATA_HEADER:\n        ctx = avformat_alloc_context();\n        if (!ctx)\n            return AVERROR(ENOMEM);\n        c->pfmt_ctx = ctx;\n        av_dict_copy(&(c->pfmt_ctx->metadata), c->stream->metadata, 0);\n\n        for(i=0;i<c->stream->nb_streams;i++) {\n            LayeredAVStream *src;\n            AVStream *st = avformat_new_stream(c->pfmt_ctx, NULL);\n            if (!st)\n                return AVERROR(ENOMEM);\n\n            /* if file or feed, then just take streams from FFServerStream\n             * struct */\n            if (!c->stream->feed ||\n                c->stream->feed == c->stream)\n                src = c->stream->streams[i];\n            else\n                src = c->stream->feed->streams[c->stream->feed_streams[i]];\n\n            unlayer_stream(c->pfmt_ctx->streams[i], src); //TODO we no longer copy st->internal, does this matter?\n            av_assert0(!c->pfmt_ctx->streams[i]->priv_data);\n\n            if (src->codec->flags & AV_CODEC_FLAG_BITEXACT)\n                c->pfmt_ctx->flags |= AVFMT_FLAG_BITEXACT;\n        }\n        /* set output format parameters */\n        c->pfmt_ctx->oformat = c->stream->fmt;\n        av_assert0(c->pfmt_ctx->nb_streams == c->stream->nb_streams);\n\n        c->got_key_frame = 0;\n\n        /* prepare header and save header data in a stream */\n        if (avio_open_dyn_buf(&c->pfmt_ctx->pb) < 0) {\n            /* XXX: potential leak */\n            return -1;\n        }\n        c->pfmt_ctx->pb->seekable = 0;\n\n        /*\n         * HACK to avoid MPEG-PS muxer to spit many underflow errors\n         * Default value from FFmpeg\n         * Try to set it using configuration option\n         */\n        c->pfmt_ctx->max_delay = (int)(0.7*AV_TIME_BASE);\n\n        if ((ret = avformat_write_header(c->pfmt_ctx, NULL)) < 0) {\n            http_log(\"Error writing output header for stream '%s': %s\\n\",\n                     c->stream->filename, av_err2str(ret));\n            return ret;\n        }\n        av_dict_free(&c->pfmt_ctx->metadata);\n\n        len = avio_close_dyn_buf(c->pfmt_ctx->pb, &c->pb_buffer);\n        c->buffer_ptr = c->pb_buffer;\n        c->buffer_end = c->pb_buffer + len;\n\n        c->state = HTTPSTATE_SEND_DATA;\n        c->last_packet_sent = 0;\n        break;\n    case HTTPSTATE_SEND_DATA:\n        /* find a new packet */\n        /* read a packet from the input stream */\n        if (c->stream->feed)\n            ffm_set_write_index(c->fmt_in,\n                                c->stream->feed->feed_write_index,\n                                c->stream->feed->feed_size);\n\n        if (c->stream->max_time &&\n            c->stream->max_time + c->start_time - cur_time < 0)\n            /* We have timed out */\n            c->state = HTTPSTATE_SEND_DATA_TRAILER;\n        else {\n            AVPacket pkt;\n        redo:\n            ret = av_read_frame(c->fmt_in, &pkt);\n            if (ret < 0) {\n                if (c->stream->feed) {\n                    /* if coming from feed, it means we reached the end of the\n                     * ffm file, so must wait for more data */\n                    c->state = HTTPSTATE_WAIT_FEED;\n                    return 1; /* state changed */\n                }\n                if (ret == AVERROR(EAGAIN)) {\n                    /* input not ready, come back later */\n                    return 0;\n                }\n                if (c->stream->loop) {\n                    avformat_close_input(&c->fmt_in);\n                    if (open_input_stream(c, \"\") < 0)\n                        goto no_loop;\n                    goto redo;\n                } else {\n                    no_loop:\n                        /* must send trailer now because EOF or error */\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n                }\n            } else {\n                int source_index = pkt.stream_index;\n                /* update first pts if needed */\n                if (c->first_pts == AV_NOPTS_VALUE && pkt.dts != AV_NOPTS_VALUE) {\n                    c->first_pts = av_rescale_q(pkt.dts, c->fmt_in->streams[pkt.stream_index]->time_base, AV_TIME_BASE_Q);\n                    c->start_time = cur_time;\n                }\n                /* send it to the appropriate stream */\n                if (c->stream->feed) {\n                    /* if coming from a feed, select the right stream */\n                    if (c->switch_pending) {\n                        c->switch_pending = 0;\n                        for(i=0;i<c->stream->nb_streams;i++) {\n                            if (c->switch_feed_streams[i] == pkt.stream_index)\n                                if (pkt.flags & AV_PKT_FLAG_KEY)\n                                    c->switch_feed_streams[i] = -1;\n                            if (c->switch_feed_streams[i] >= 0)\n                                c->switch_pending = 1;\n                        }\n                    }\n                    for(i=0;i<c->stream->nb_streams;i++) {\n                        if (c->stream->feed_streams[i] == pkt.stream_index) {\n                            AVStream *st = c->fmt_in->streams[source_index];\n                            pkt.stream_index = i;\n                            if (pkt.flags & AV_PKT_FLAG_KEY &&\n                                (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n                                 c->stream->nb_streams == 1))\n                                c->got_key_frame = 1;\n                            if (!c->stream->send_on_key || c->got_key_frame)\n                                goto send_it;\n                        }\n                    }\n                } else {\n                    AVStream *ist, *ost;\n                send_it:\n                    ist = c->fmt_in->streams[source_index];\n                    /* specific handling for RTP: we use several\n                     * output streams (one for each RTP connection).\n                     * XXX: need more abstract handling */\n                    if (c->is_packetized) {\n                        /* compute send time and duration */\n                        if (pkt.dts != AV_NOPTS_VALUE) {\n                            c->cur_pts = av_rescale_q(pkt.dts, ist->time_base, AV_TIME_BASE_Q);\n                            c->cur_pts -= c->first_pts;\n                        }\n                        c->cur_frame_duration = av_rescale_q(pkt.duration, ist->time_base, AV_TIME_BASE_Q);\n                        /* find RTP context */\n                        c->packet_stream_index = pkt.stream_index;\n                        ctx = c->rtp_ctx[c->packet_stream_index];\n                        if(!ctx) {\n                            av_packet_unref(&pkt);\n                            break;\n                        }\n                        /* only one stream per RTP connection */\n                        pkt.stream_index = 0;\n                    } else {\n                        ctx = c->pfmt_ctx;\n                        /* Fudge here */\n                    }\n\n                    if (c->is_packetized) {\n                        int max_packet_size;\n                        if (c->rtp_protocol == RTSP_LOWER_TRANSPORT_TCP)\n                            max_packet_size = RTSP_TCP_MAX_PACKET_SIZE;\n                        else\n                            max_packet_size = c->rtp_handles[c->packet_stream_index]->max_packet_size;\n                        ret = ffio_open_dyn_packet_buf(&ctx->pb,\n                                                       max_packet_size);\n                    } else\n                        ret = avio_open_dyn_buf(&ctx->pb);\n\n                    if (ret < 0) {\n                        /* XXX: potential leak */\n                        return -1;\n                    }\n                    ost = ctx->streams[pkt.stream_index];\n\n                    ctx->pb->seekable = 0;\n                    if (pkt.dts != AV_NOPTS_VALUE)\n                        pkt.dts = av_rescale_q(pkt.dts, ist->time_base,\n                                               ost->time_base);\n                    if (pkt.pts != AV_NOPTS_VALUE)\n                        pkt.pts = av_rescale_q(pkt.pts, ist->time_base,\n                                               ost->time_base);\n                    pkt.duration = av_rescale_q(pkt.duration, ist->time_base,\n                                                ost->time_base);\n                    if ((ret = av_write_frame(ctx, &pkt)) < 0) {\n                        http_log(\"Error writing frame to output for stream '%s': %s\\n\",\n                                 c->stream->filename, av_err2str(ret));\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n                    }\n\n                    av_freep(&c->pb_buffer);\n                    len = avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n                    ctx->pb = NULL;\n                    c->cur_frame_bytes = len;\n                    c->buffer_ptr = c->pb_buffer;\n                    c->buffer_end = c->pb_buffer + len;\n\n                    if (len == 0) {\n                        av_packet_unref(&pkt);\n                        goto redo;\n                    }\n                }\n                av_packet_unref(&pkt);\n            }\n        }\n        break;\n    default:\n    case HTTPSTATE_SEND_DATA_TRAILER:\n        /* last packet test ? */\n        if (c->last_packet_sent || c->is_packetized)\n            return -1;\n        ctx = c->pfmt_ctx;\n        /* prepare header */\n        if (avio_open_dyn_buf(&ctx->pb) < 0) {\n            /* XXX: potential leak */\n            return -1;\n        }\n        c->pfmt_ctx->pb->seekable = 0;\n        av_write_trailer(ctx);\n        len = avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n        c->buffer_ptr = c->pb_buffer;\n        c->buffer_end = c->pb_buffer + len;\n\n        c->last_packet_sent = 1;\n        break;\n    }\n    return 0;\n}\n\n/* should convert the format at the same time */\n/* send data starting at c->buffer_ptr to the output connection\n * (either UDP or TCP)\n */\nstatic int http_send_data(HTTPContext *c)\n{\n    int len, ret;\n\n    for(;;) {\n        if (c->buffer_ptr >= c->buffer_end) {\n            ret = http_prepare_data(c);\n            if (ret < 0)\n                return -1;\n            else if (ret)\n                /* state change requested */\n                break;\n        } else {\n            if (c->is_packetized) {\n                /* RTP data output */\n                len = c->buffer_end - c->buffer_ptr;\n                if (len < 4) {\n                    /* fail safe - should never happen */\n                fail1:\n                    c->buffer_ptr = c->buffer_end;\n                    return 0;\n                }\n                len = (c->buffer_ptr[0] << 24) |\n                    (c->buffer_ptr[1] << 16) |\n                    (c->buffer_ptr[2] << 8) |\n                    (c->buffer_ptr[3]);\n                if (len > (c->buffer_end - c->buffer_ptr))\n                    goto fail1;\n                if ((get_packet_send_clock(c) - get_server_clock(c)) > 0) {\n                    /* nothing to send yet: we can wait */\n                    return 0;\n                }\n\n                c->data_count += len;\n                update_datarate(&c->datarate, c->data_count);\n                if (c->stream)\n                    c->stream->bytes_served += len;\n\n                if (c->rtp_protocol == RTSP_LOWER_TRANSPORT_TCP) {\n                    /* RTP packets are sent inside the RTSP TCP connection */\n                    AVIOContext *pb;\n                    int interleaved_index, size;\n                    uint8_t header[4];\n                    HTTPContext *rtsp_c;\n\n                    rtsp_c = c->rtsp_c;\n                    /* if no RTSP connection left, error */\n                    if (!rtsp_c)\n                        return -1;\n                    /* if already sending something, then wait. */\n                    if (rtsp_c->state != RTSPSTATE_WAIT_REQUEST)\n                        break;\n                    if (avio_open_dyn_buf(&pb) < 0)\n                        goto fail1;\n                    interleaved_index = c->packet_stream_index * 2;\n                    /* RTCP packets are sent at odd indexes */\n                    if (c->buffer_ptr[1] == 200)\n                        interleaved_index++;\n                    /* write RTSP TCP header */\n                    header[0] = '$';\n                    header[1] = interleaved_index;\n                    header[2] = len >> 8;\n                    header[3] = len;\n                    avio_write(pb, header, 4);\n                    /* write RTP packet data */\n                    c->buffer_ptr += 4;\n                    avio_write(pb, c->buffer_ptr, len);\n                    size = avio_close_dyn_buf(pb, &c->packet_buffer);\n                    /* prepare asynchronous TCP sending */\n                    rtsp_c->packet_buffer_ptr = c->packet_buffer;\n                    rtsp_c->packet_buffer_end = c->packet_buffer + size;\n                    c->buffer_ptr += len;\n\n                    /* send everything we can NOW */\n                    len = send(rtsp_c->fd, rtsp_c->packet_buffer_ptr,\n                               rtsp_c->packet_buffer_end - rtsp_c->packet_buffer_ptr, 0);\n                    if (len > 0)\n                        rtsp_c->packet_buffer_ptr += len;\n                    if (rtsp_c->packet_buffer_ptr < rtsp_c->packet_buffer_end) {\n                        /* if we could not send all the data, we will\n                         * send it later, so a new state is needed to\n                         * \"lock\" the RTSP TCP connection */\n                        rtsp_c->state = RTSPSTATE_SEND_PACKET;\n                        break;\n                    } else\n                        /* all data has been sent */\n                        av_freep(&c->packet_buffer);\n                } else {\n                    /* send RTP packet directly in UDP */\n                    c->buffer_ptr += 4;\n                    ffurl_write(c->rtp_handles[c->packet_stream_index],\n                                c->buffer_ptr, len);\n                    c->buffer_ptr += len;\n                    /* here we continue as we can send several packets\n                     * per 10 ms slot */\n                }\n            } else {\n                /* TCP data output */\n                len = send(c->fd, c->buffer_ptr,\n                           c->buffer_end - c->buffer_ptr, 0);\n                if (len < 0) {\n                    if (ff_neterrno() != AVERROR(EAGAIN) &&\n                        ff_neterrno() != AVERROR(EINTR))\n                        /* error : close connection */\n                        return -1;\n                    else\n                        return 0;\n                }\n                c->buffer_ptr += len;\n\n                c->data_count += len;\n                update_datarate(&c->datarate, c->data_count);\n                if (c->stream)\n                    c->stream->bytes_served += len;\n                break;\n            }\n        }\n    } /* for(;;) */\n    return 0;\n}\n\nstatic int http_start_receive_data(HTTPContext *c)\n{\n    int fd;\n    int ret;\n    int64_t ret64;\n\n    if (c->stream->feed_opened) {\n        http_log(\"Stream feed '%s' was not opened\\n\",\n                 c->stream->feed_filename);\n        return AVERROR(EINVAL);\n    }\n\n    /* Don't permit writing to this one */\n    if (c->stream->readonly) {\n        http_log(\"Cannot write to read-only file '%s'\\n\",\n                 c->stream->feed_filename);\n        return AVERROR(EINVAL);\n    }\n\n    /* open feed */\n    fd = open(c->stream->feed_filename, O_RDWR);\n    if (fd < 0) {\n        ret = AVERROR(errno);\n        http_log(\"Could not open feed file '%s': %s\\n\",\n                 c->stream->feed_filename, strerror(errno));\n        return ret;\n    }\n    c->feed_fd = fd;\n\n    if (c->stream->truncate) {\n        /* truncate feed file */\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n        if (ftruncate(c->feed_fd, FFM_PACKET_SIZE) < 0) {\n            ret = AVERROR(errno);\n            http_log(\"Error truncating feed file '%s': %s\\n\",\n                     c->stream->feed_filename, strerror(errno));\n            return ret;\n        }\n    } else {\n        ret64 = ffm_read_write_index(fd);\n        if (ret64 < 0) {\n            http_log(\"Error reading write index from feed file '%s': %s\\n\",\n                     c->stream->feed_filename, strerror(errno));\n            return ret64;\n        }\n        c->stream->feed_write_index = ret64;\n    }\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd),\n                                        FFM_PACKET_SIZE);\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n    lseek(fd, 0, SEEK_SET);\n\n    /* init buffer input */\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n    c->stream->feed_opened = 1;\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n    return 0;\n}\n\nstatic int http_receive_data(HTTPContext *c)\n{\n    HTTPContext *c1;\n    int len, loop_run = 0;\n\n    while (c->chunked_encoding && !c->chunk_size &&\n           c->buffer_end > c->buffer_ptr) {\n        /* read chunk header, if present */\n        len = recv(c->fd, c->buffer_ptr, 1, 0);\n\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                /* error : close connection */\n                goto fail;\n            return 0;\n        } else if (len == 0) {\n            /* end of connection : close it */\n            goto fail;\n        } else if (c->buffer_ptr - c->buffer >= 2 &&\n                   !memcmp(c->buffer_ptr - 1, \"\\r\\n\", 2)) {\n            c->chunk_size = strtol(c->buffer, 0, 16);\n            if (c->chunk_size == 0) // end of stream\n                goto fail;\n            c->buffer_ptr = c->buffer;\n            break;\n        } else if (++loop_run > 10)\n            /* no chunk header, abort */\n            goto fail;\n        else\n            c->buffer_ptr++;\n    }\n\n    if (c->buffer_end > c->buffer_ptr) {\n        len = recv(c->fd, c->buffer_ptr,\n                   FFMIN(c->chunk_size, c->buffer_end - c->buffer_ptr), 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                /* error : close connection */\n                goto fail;\n        } else if (len == 0)\n            /* end of connection : close it */\n            goto fail;\n        else {\n            c->chunk_size -= len;\n            c->buffer_ptr += len;\n            c->data_count += len;\n            update_datarate(&c->datarate, c->data_count);\n        }\n    }\n\n    if (c->buffer_ptr - c->buffer >= 2 && c->data_count > FFM_PACKET_SIZE) {\n        if (c->buffer[0] != 'f' ||\n            c->buffer[1] != 'm') {\n            http_log(\"Feed stream has become desynchronized -- disconnecting\\n\");\n            goto fail;\n        }\n    }\n\n    if (c->buffer_ptr >= c->buffer_end) {\n        FFServerStream *feed = c->stream;\n        /* a packet has been received : write it in the store, except\n         * if header */\n        if (c->data_count > FFM_PACKET_SIZE) {\n            /* XXX: use llseek or url_seek\n             * XXX: Should probably fail? */\n            if (lseek(c->feed_fd, feed->feed_write_index, SEEK_SET) == -1)\n                http_log(\"Seek to %\"PRId64\" failed\\n\", feed->feed_write_index);\n\n            if (write(c->feed_fd, c->buffer, FFM_PACKET_SIZE) < 0) {\n                http_log(\"Error writing to feed file: %s\\n\", strerror(errno));\n                goto fail;\n            }\n\n            feed->feed_write_index += FFM_PACKET_SIZE;\n            /* update file size */\n            if (feed->feed_write_index > c->stream->feed_size)\n                feed->feed_size = feed->feed_write_index;\n\n            /* handle wrap around if max file size reached */\n            if (c->stream->feed_max_size &&\n                feed->feed_write_index >= c->stream->feed_max_size)\n                feed->feed_write_index = FFM_PACKET_SIZE;\n\n            /* write index */\n            if (ffm_write_write_index(c->feed_fd, feed->feed_write_index) < 0) {\n                http_log(\"Error writing index to feed file: %s\\n\",\n                         strerror(errno));\n                goto fail;\n            }\n\n            /* wake up any waiting connections */\n            for(c1 = first_http_ctx; c1; c1 = c1->next) {\n                if (c1->state == HTTPSTATE_WAIT_FEED &&\n                    c1->stream->feed == c->stream->feed)\n                    c1->state = HTTPSTATE_SEND_DATA;\n            }\n        } else {\n            /* We have a header in our hands that contains useful data */\n            AVFormatContext *s = avformat_alloc_context();\n            AVIOContext *pb;\n            AVInputFormat *fmt_in;\n            int i;\n\n            if (!s)\n                goto fail;\n\n            /* use feed output format name to find corresponding input format */\n            fmt_in = av_find_input_format(feed->fmt->name);\n            if (!fmt_in)\n                goto fail;\n\n            pb = avio_alloc_context(c->buffer, c->buffer_end - c->buffer,\n                                    0, NULL, NULL, NULL, NULL);\n            if (!pb)\n                goto fail;\n\n            pb->seekable = 0;\n\n            s->pb = pb;\n            if (avformat_open_input(&s, c->stream->feed_filename, fmt_in, NULL) < 0) {\n                av_freep(&pb);\n                goto fail;\n            }\n\n            /* Now we have the actual streams */\n            if (s->nb_streams != feed->nb_streams) {\n                avformat_close_input(&s);\n                av_freep(&pb);\n                http_log(\"Feed '%s' stream number does not match registered feed\\n\",\n                         c->stream->feed_filename);\n                goto fail;\n            }\n\n            for (i = 0; i < s->nb_streams; i++) {\n                LayeredAVStream *fst = feed->streams[i];\n                AVStream *st = s->streams[i];\n                avcodec_parameters_to_context(fst->codec, st->codecpar);\n                avcodec_parameters_from_context(fst->codecpar, fst->codec);\n            }\n\n            avformat_close_input(&s);\n            av_freep(&pb);\n        }\n        c->buffer_ptr = c->buffer;\n    }\n\n    return 0;\n fail:\n    c->stream->feed_opened = 0;\n    close(c->feed_fd);\n    /* wake up any waiting connections to stop waiting for feed */\n    for(c1 = first_http_ctx; c1; c1 = c1->next) {\n        if (c1->state == HTTPSTATE_WAIT_FEED &&\n            c1->stream->feed == c->stream->feed)\n            c1->state = HTTPSTATE_SEND_DATA_TRAILER;\n    }\n    return -1;\n}\n\n/********************************************************************/\n/* RTSP handling */\n\nstatic void rtsp_reply_header(HTTPContext *c, enum RTSPStatusCode error_number)\n{\n    const char *str;\n    time_t ti;\n    struct tm *tm;\n    char buf2[32];\n\n    str = RTSP_STATUS_CODE2STRING(error_number);\n    if (!str)\n        str = \"Unknown Error\";\n\n    avio_printf(c->pb, \"RTSP/1.0 %d %s\\r\\n\", error_number, str);\n    avio_printf(c->pb, \"CSeq: %d\\r\\n\", c->seq);\n\n    /* output GMT time */\n    ti = time(NULL);\n    tm = gmtime(&ti);\n    strftime(buf2, sizeof(buf2), \"%a, %d %b %Y %H:%M:%S\", tm);\n    avio_printf(c->pb, \"Date: %s GMT\\r\\n\", buf2);\n}\n\nstatic void rtsp_reply_error(HTTPContext *c, enum RTSPStatusCode error_number)\n{\n    rtsp_reply_header(c, error_number);\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic int rtsp_parse_request(HTTPContext *c)\n{\n    const char *p, *p1, *p2;\n    char cmd[32];\n    char url[1024];\n    char protocol[32];\n    char line[1024];\n    int len;\n    RTSPMessageHeader header1 = { 0 }, *header = &header1;\n\n    c->buffer_ptr[0] = '\\0';\n    p = c->buffer;\n\n    get_word(cmd, sizeof(cmd), &p);\n    get_word(url, sizeof(url), &p);\n    get_word(protocol, sizeof(protocol), &p);\n\n    av_strlcpy(c->method, cmd, sizeof(c->method));\n    av_strlcpy(c->url, url, sizeof(c->url));\n    av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n\n    if (avio_open_dyn_buf(&c->pb) < 0) {\n        /* XXX: cannot do more */\n        c->pb = NULL; /* safety */\n        return -1;\n    }\n\n    /* check version name */\n    if (strcmp(protocol, \"RTSP/1.0\")) {\n        rtsp_reply_error(c, RTSP_STATUS_VERSION);\n        goto the_end;\n    }\n\n    /* parse each header line */\n    /* skip to next line */\n    while (*p != '\\n' && *p != '\\0')\n        p++;\n    if (*p == '\\n')\n        p++;\n    while (*p != '\\0') {\n        p1 = memchr(p, '\\n', (char *)c->buffer_ptr - p);\n        if (!p1)\n            break;\n        p2 = p1;\n        if (p2 > p && p2[-1] == '\\r')\n            p2--;\n        /* skip empty line */\n        if (p2 == p)\n            break;\n        len = p2 - p;\n        if (len > sizeof(line) - 1)\n            len = sizeof(line) - 1;\n        memcpy(line, p, len);\n        line[len] = '\\0';\n        ff_rtsp_parse_line(NULL, header, line, NULL, NULL);\n        p = p1 + 1;\n    }\n\n    /* handle sequence number */\n    c->seq = header->seq;\n\n    if (!strcmp(cmd, \"DESCRIBE\"))\n        rtsp_cmd_describe(c, url);\n    else if (!strcmp(cmd, \"OPTIONS\"))\n        rtsp_cmd_options(c, url);\n    else if (!strcmp(cmd, \"SETUP\"))\n        rtsp_cmd_setup(c, url, header);\n    else if (!strcmp(cmd, \"PLAY\"))\n        rtsp_cmd_play(c, url, header);\n    else if (!strcmp(cmd, \"PAUSE\"))\n        rtsp_cmd_interrupt(c, url, header, 1);\n    else if (!strcmp(cmd, \"TEARDOWN\"))\n        rtsp_cmd_interrupt(c, url, header, 0);\n    else\n        rtsp_reply_error(c, RTSP_STATUS_METHOD);\n\n the_end:\n    len = avio_close_dyn_buf(c->pb, &c->pb_buffer);\n    c->pb = NULL; /* safety */\n    if (len < 0)\n        /* XXX: cannot do more */\n        return -1;\n\n    c->buffer_ptr = c->pb_buffer;\n    c->buffer_end = c->pb_buffer + len;\n    c->state = RTSPSTATE_SEND_REPLY;\n    return 0;\n}\n\nstatic int prepare_sdp_description(FFServerStream *stream, uint8_t **pbuffer,\n                                   struct in_addr my_ip)\n{\n    AVFormatContext *avc;\n    AVOutputFormat *rtp_format = av_guess_format(\"rtp\", NULL, NULL);\n    AVDictionaryEntry *entry = av_dict_get(stream->metadata, \"title\", NULL, 0);\n    int i;\n\n    *pbuffer = NULL;\n\n    avc =  avformat_alloc_context();\n    if (!avc || !rtp_format)\n        return -1;\n\n    avc->oformat = rtp_format;\n    av_dict_set(&avc->metadata, \"title\",\n                entry ? entry->value : \"No Title\", 0);\n    if (stream->is_multicast) {\n        snprintf(avc->filename, 1024, \"rtp://%s:%d?multicast=1?ttl=%d\",\n                 inet_ntoa(stream->multicast_ip),\n                 stream->multicast_port, stream->multicast_ttl);\n    } else\n        snprintf(avc->filename, 1024, \"rtp://0.0.0.0\");\n\n    for(i = 0; i < stream->nb_streams; i++) {\n        AVStream *st = avformat_new_stream(avc, NULL);\n        if (!st)\n            goto sdp_done;\n        avcodec_parameters_from_context(stream->streams[i]->codecpar, stream->streams[i]->codec);\n        unlayer_stream(st, stream->streams[i]);\n    }\n#define PBUFFER_SIZE 2048\n    *pbuffer = av_mallocz(PBUFFER_SIZE);\n    if (!*pbuffer)\n        goto sdp_done;\n    av_sdp_create(&avc, 1, *pbuffer, PBUFFER_SIZE);\n\n sdp_done:\n    av_freep(&avc->streams);\n    av_dict_free(&avc->metadata);\n    av_free(avc);\n\n    return *pbuffer ? strlen(*pbuffer) : AVERROR(ENOMEM);\n}\n\nstatic void rtsp_cmd_options(HTTPContext *c, const char *url)\n{\n    /* rtsp_reply_header(c, RTSP_STATUS_OK); */\n    avio_printf(c->pb, \"RTSP/1.0 %d %s\\r\\n\", RTSP_STATUS_OK, \"OK\");\n    avio_printf(c->pb, \"CSeq: %d\\r\\n\", c->seq);\n    avio_printf(c->pb, \"Public: %s\\r\\n\",\n                \"OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE\");\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic void rtsp_cmd_describe(HTTPContext *c, const char *url)\n{\n    FFServerStream *stream;\n    char path1[1024];\n    const char *path;\n    uint8_t *content;\n    int content_length;\n    socklen_t len;\n    struct sockaddr_in my_addr;\n\n    /* find which URL is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        if (!stream->is_feed &&\n            stream->fmt && !strcmp(stream->fmt->name, \"rtp\") &&\n            !strcmp(path, stream->filename)) {\n            goto found;\n        }\n    }\n    /* no stream found */\n    rtsp_reply_error(c, RTSP_STATUS_NOT_FOUND);\n    return;\n\n found:\n    /* prepare the media description in SDP format */\n\n    /* get the host IP */\n    len = sizeof(my_addr);\n    getsockname(c->fd, (struct sockaddr *)&my_addr, &len);\n    content_length = prepare_sdp_description(stream, &content,\n                                             my_addr.sin_addr);\n    if (content_length < 0) {\n        rtsp_reply_error(c, RTSP_STATUS_INTERNAL);\n        return;\n    }\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    avio_printf(c->pb, \"Content-Base: %s/\\r\\n\", url);\n    avio_printf(c->pb, \"Content-Type: application/sdp\\r\\n\");\n    avio_printf(c->pb, \"Content-Length: %d\\r\\n\", content_length);\n    avio_printf(c->pb, \"\\r\\n\");\n    avio_write(c->pb, content, content_length);\n    av_free(content);\n}\n\nstatic HTTPContext *find_rtp_session(const char *session_id)\n{\n    HTTPContext *c;\n\n    if (session_id[0] == '\\0')\n        return NULL;\n\n    for(c = first_http_ctx; c; c = c->next) {\n        if (!strcmp(c->session_id, session_id))\n            return c;\n    }\n    return NULL;\n}\n\nstatic RTSPTransportField *find_transport(RTSPMessageHeader *h, enum RTSPLowerTransport lower_transport)\n{\n    RTSPTransportField *th;\n    int i;\n\n    for(i=0;i<h->nb_transports;i++) {\n        th = &h->transports[i];\n        if (th->lower_transport == lower_transport)\n            return th;\n    }\n    return NULL;\n}\n\nstatic void rtsp_cmd_setup(HTTPContext *c, const char *url,\n                           RTSPMessageHeader *h)\n{\n    FFServerStream *stream;\n    int stream_index, rtp_port, rtcp_port;\n    char buf[1024];\n    char path1[1024];\n    const char *path;\n    HTTPContext *rtp_c;\n    RTSPTransportField *th;\n    struct sockaddr_in dest_addr;\n    RTSPActionServerSetup setup;\n\n    /* find which URL is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n\n    /* now check each stream */\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        if (stream->is_feed || !stream->fmt ||\n            strcmp(stream->fmt->name, \"rtp\")) {\n            continue;\n        }\n        /* accept aggregate filenames only if single stream */\n        if (!strcmp(path, stream->filename)) {\n            if (stream->nb_streams != 1) {\n                rtsp_reply_error(c, RTSP_STATUS_AGGREGATE);\n                return;\n            }\n            stream_index = 0;\n            goto found;\n        }\n\n        for(stream_index = 0; stream_index < stream->nb_streams;\n            stream_index++) {\n            snprintf(buf, sizeof(buf), \"%s/streamid=%d\",\n                     stream->filename, stream_index);\n            if (!strcmp(path, buf))\n                goto found;\n        }\n    }\n    /* no stream found */\n    rtsp_reply_error(c, RTSP_STATUS_SERVICE); /* XXX: right error ? */\n    return;\n found:\n\n    /* generate session id if needed */\n    if (h->session_id[0] == '\\0') {\n        unsigned random0 = av_lfg_get(&random_state);\n        unsigned random1 = av_lfg_get(&random_state);\n        snprintf(h->session_id, sizeof(h->session_id), \"%08x%08x\",\n                 random0, random1);\n    }\n\n    /* find RTP session, and create it if none found */\n    rtp_c = find_rtp_session(h->session_id);\n    if (!rtp_c) {\n        /* always prefer UDP */\n        th = find_transport(h, RTSP_LOWER_TRANSPORT_UDP);\n        if (!th) {\n            th = find_transport(h, RTSP_LOWER_TRANSPORT_TCP);\n            if (!th) {\n                rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n                return;\n            }\n        }\n\n        rtp_c = rtp_new_connection(&c->from_addr, stream, h->session_id,\n                                   th->lower_transport);\n        if (!rtp_c) {\n            rtsp_reply_error(c, RTSP_STATUS_BANDWIDTH);\n            return;\n        }\n\n        /* open input stream */\n        if (open_input_stream(rtp_c, \"\") < 0) {\n            rtsp_reply_error(c, RTSP_STATUS_INTERNAL);\n            return;\n        }\n    }\n\n    /* test if stream is OK (test needed because several SETUP needs\n     * to be done for a given file) */\n    if (rtp_c->stream != stream) {\n        rtsp_reply_error(c, RTSP_STATUS_SERVICE);\n        return;\n    }\n\n    /* test if stream is already set up */\n    if (rtp_c->rtp_ctx[stream_index]) {\n        rtsp_reply_error(c, RTSP_STATUS_STATE);\n        return;\n    }\n\n    /* check transport */\n    th = find_transport(h, rtp_c->rtp_protocol);\n    if (!th || (th->lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n                th->client_port_min <= 0)) {\n        rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n        return;\n    }\n\n    /* setup default options */\n    setup.transport_option[0] = '\\0';\n    dest_addr = rtp_c->from_addr;\n    dest_addr.sin_port = htons(th->client_port_min);\n\n    /* setup stream */\n    if (rtp_new_av_stream(rtp_c, stream_index, &dest_addr, c) < 0) {\n        rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n        return;\n    }\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n\n    switch(rtp_c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP:\n        rtp_port = ff_rtp_get_local_rtp_port(rtp_c->rtp_handles[stream_index]);\n        rtcp_port = ff_rtp_get_local_rtcp_port(rtp_c->rtp_handles[stream_index]);\n        avio_printf(c->pb, \"Transport: RTP/AVP/UDP;unicast;\"\n                    \"client_port=%d-%d;server_port=%d-%d\",\n                    th->client_port_min, th->client_port_max,\n                    rtp_port, rtcp_port);\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        avio_printf(c->pb, \"Transport: RTP/AVP/TCP;interleaved=%d-%d\",\n                    stream_index * 2, stream_index * 2 + 1);\n        break;\n    default:\n        break;\n    }\n    if (setup.transport_option[0] != '\\0')\n        avio_printf(c->pb, \";%s\", setup.transport_option);\n    avio_printf(c->pb, \"\\r\\n\");\n\n\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\n\n/**\n * find an RTP connection by using the session ID. Check consistency\n * with filename\n */\nstatic HTTPContext *find_rtp_session_with_url(const char *url,\n                                              const char *session_id)\n{\n    HTTPContext *rtp_c;\n    char path1[1024];\n    const char *path;\n    char buf[1024];\n    int s, len;\n\n    rtp_c = find_rtp_session(session_id);\n    if (!rtp_c)\n        return NULL;\n\n    /* find which URL is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n    if(!strcmp(path, rtp_c->stream->filename)) return rtp_c;\n    for(s=0; s<rtp_c->stream->nb_streams; ++s) {\n      snprintf(buf, sizeof(buf), \"%s/streamid=%d\",\n        rtp_c->stream->filename, s);\n      if(!strncmp(path, buf, sizeof(buf)))\n        /* XXX: Should we reply with RTSP_STATUS_ONLY_AGGREGATE\n         * if nb_streams>1? */\n        return rtp_c;\n    }\n    len = strlen(path);\n    if (len > 0 && path[len - 1] == '/' &&\n        !strncmp(path, rtp_c->stream->filename, len - 1))\n        return rtp_c;\n    return NULL;\n}\n\nstatic void rtsp_cmd_play(HTTPContext *c, const char *url, RTSPMessageHeader *h)\n{\n    HTTPContext *rtp_c;\n\n    rtp_c = find_rtp_session_with_url(url, h->session_id);\n    if (!rtp_c) {\n        rtsp_reply_error(c, RTSP_STATUS_SESSION);\n        return;\n    }\n\n    if (rtp_c->state != HTTPSTATE_SEND_DATA &&\n        rtp_c->state != HTTPSTATE_WAIT_FEED &&\n        rtp_c->state != HTTPSTATE_READY) {\n        rtsp_reply_error(c, RTSP_STATUS_STATE);\n        return;\n    }\n\n    rtp_c->state = HTTPSTATE_SEND_DATA;\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic void rtsp_cmd_interrupt(HTTPContext *c, const char *url,\n                               RTSPMessageHeader *h, int pause_only)\n{\n    HTTPContext *rtp_c;\n\n    rtp_c = find_rtp_session_with_url(url, h->session_id);\n    if (!rtp_c) {\n        rtsp_reply_error(c, RTSP_STATUS_SESSION);\n        return;\n    }\n\n    if (pause_only) {\n        if (rtp_c->state != HTTPSTATE_SEND_DATA &&\n            rtp_c->state != HTTPSTATE_WAIT_FEED) {\n            rtsp_reply_error(c, RTSP_STATUS_STATE);\n            return;\n        }\n        rtp_c->state = HTTPSTATE_READY;\n        rtp_c->first_pts = AV_NOPTS_VALUE;\n    }\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n    avio_printf(c->pb, \"\\r\\n\");\n\n    if (!pause_only)\n        close_connection(rtp_c);\n}\n\n/********************************************************************/\n/* RTP handling */\n\nstatic HTTPContext *rtp_new_connection(struct sockaddr_in *from_addr,\n                                       FFServerStream *stream,\n                                       const char *session_id,\n                                       enum RTSPLowerTransport rtp_protocol)\n{\n    HTTPContext *c = NULL;\n    const char *proto_str;\n\n    /* XXX: should output a warning page when coming\n     * close to the connection limit */\n    if (nb_connections >= config.nb_max_connections)\n        goto fail;\n\n    /* add a new connection */\n    c = av_mallocz(sizeof(HTTPContext));\n    if (!c)\n        goto fail;\n\n    c->fd = -1;\n    c->poll_entry = NULL;\n    c->from_addr = *from_addr;\n    c->buffer_size = IOBUFFER_INIT_SIZE;\n    c->buffer = av_malloc(c->buffer_size);\n    if (!c->buffer)\n        goto fail;\n    nb_connections++;\n    c->stream = stream;\n    av_strlcpy(c->session_id, session_id, sizeof(c->session_id));\n    c->state = HTTPSTATE_READY;\n    c->is_packetized = 1;\n    c->rtp_protocol = rtp_protocol;\n\n    /* protocol is shown in statistics */\n    switch(c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP_MULTICAST:\n        proto_str = \"MCAST\";\n        break;\n    case RTSP_LOWER_TRANSPORT_UDP:\n        proto_str = \"UDP\";\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        proto_str = \"TCP\";\n        break;\n    default:\n        proto_str = \"???\";\n        break;\n    }\n    av_strlcpy(c->protocol, \"RTP/\", sizeof(c->protocol));\n    av_strlcat(c->protocol, proto_str, sizeof(c->protocol));\n\n    current_bandwidth += stream->bandwidth;\n\n    c->next = first_http_ctx;\n    first_http_ctx = c;\n    return c;\n\n fail:\n    if (c) {\n        av_freep(&c->buffer);\n        av_free(c);\n    }\n    return NULL;\n}\n\n/**\n * add a new RTP stream in an RTP connection (used in RTSP SETUP\n * command). If RTP/TCP protocol is used, TCP connection 'rtsp_c' is\n * used.\n */\nstatic int rtp_new_av_stream(HTTPContext *c,\n                             int stream_index, struct sockaddr_in *dest_addr,\n                             HTTPContext *rtsp_c)\n{\n    AVFormatContext *ctx;\n    AVStream *st;\n    char *ipaddr;\n    URLContext *h = NULL;\n    uint8_t *dummy_buf;\n    int max_packet_size;\n    void *st_internal;\n\n    /* now we can open the relevant output stream */\n    ctx = avformat_alloc_context();\n    if (!ctx)\n        return -1;\n    ctx->oformat = av_guess_format(\"rtp\", NULL, NULL);\n\n    st = avformat_new_stream(ctx, NULL);\n    if (!st)\n        goto fail;\n\n    st_internal = st->internal;\n\n    if (!c->stream->feed ||\n        c->stream->feed == c->stream)\n        unlayer_stream(st, c->stream->streams[stream_index]);\n    else\n        unlayer_stream(st,\n               c->stream->feed->streams[c->stream->feed_streams[stream_index]]);\n    av_assert0(st->priv_data == NULL);\n    av_assert0(st->internal == st_internal);\n\n    /* build destination RTP address */\n    ipaddr = inet_ntoa(dest_addr->sin_addr);\n\n    switch(c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP:\n    case RTSP_LOWER_TRANSPORT_UDP_MULTICAST:\n        /* RTP/UDP case */\n\n        /* XXX: also pass as parameter to function ? */\n        if (c->stream->is_multicast) {\n            int ttl;\n            ttl = c->stream->multicast_ttl;\n            if (!ttl)\n                ttl = 16;\n            snprintf(ctx->filename, sizeof(ctx->filename),\n                     \"rtp://%s:%d?multicast=1&ttl=%d\",\n                     ipaddr, ntohs(dest_addr->sin_port), ttl);\n        } else {\n            snprintf(ctx->filename, sizeof(ctx->filename),\n                     \"rtp://%s:%d\", ipaddr, ntohs(dest_addr->sin_port));\n        }\n\n        if (ffurl_open(&h, ctx->filename, AVIO_FLAG_WRITE, NULL, NULL) < 0)\n            goto fail;\n        c->rtp_handles[stream_index] = h;\n        max_packet_size = h->max_packet_size;\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        /* RTP/TCP case */\n        c->rtsp_c = rtsp_c;\n        max_packet_size = RTSP_TCP_MAX_PACKET_SIZE;\n        break;\n    default:\n        goto fail;\n    }\n\n    http_log(\"%s:%d - - \\\"PLAY %s/streamid=%d %s\\\"\\n\",\n             ipaddr, ntohs(dest_addr->sin_port),\n             c->stream->filename, stream_index, c->protocol);\n\n    /* normally, no packets should be output here, but the packet size may\n     * be checked */\n    if (ffio_open_dyn_packet_buf(&ctx->pb, max_packet_size) < 0)\n        /* XXX: close stream */\n        goto fail;\n\n    if (avformat_write_header(ctx, NULL) < 0) {\n    fail:\n        if (h)\n            ffurl_close(h);\n        av_free(st);\n        av_free(ctx);\n        return -1;\n    }\n    avio_close_dyn_buf(ctx->pb, &dummy_buf);\n    ctx->pb = NULL;\n    av_free(dummy_buf);\n\n    c->rtp_ctx[stream_index] = ctx;\n    return 0;\n}\n\n/********************************************************************/\n/* ffserver initialization */\n\n/* FIXME: This code should use avformat_new_stream() */\nstatic LayeredAVStream *add_av_stream1(FFServerStream *stream,\n                                AVCodecContext *codec, int copy)\n{\n    LayeredAVStream *fst;\n\n    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))\n        return NULL;\n\n    fst = av_mallocz(sizeof(*fst));\n    if (!fst)\n        return NULL;\n    if (copy) {\n        fst->codec = avcodec_alloc_context3(codec->codec);\n        if (!fst->codec) {\n            av_free(fst);\n            return NULL;\n        }\n        avcodec_copy_context(fst->codec, codec);\n    } else\n        /* live streams must use the actual feed's codec since it may be\n         * updated later to carry extradata needed by them.\n         */\n        fst->codec = codec;\n\n    //NOTE we previously allocated internal & internal->avctx, these seemed uneeded though\n    fst->codecpar = avcodec_parameters_alloc();\n    fst->index = stream->nb_streams;\n    fst->time_base = codec->time_base;\n    fst->pts_wrap_bits = 33;\n    fst->sample_aspect_ratio = codec->sample_aspect_ratio;\n    stream->streams[stream->nb_streams++] = fst;\n    return fst;\n}\n\n/* return the stream number in the feed */\nstatic int add_av_stream(FFServerStream *feed, LayeredAVStream *st)\n{\n    LayeredAVStream *fst;\n    AVCodecContext *av, *av1;\n    int i;\n\n    av = st->codec;\n    for(i=0;i<feed->nb_streams;i++) {\n        av1 = feed->streams[i]->codec;\n        if (av1->codec_id == av->codec_id &&\n            av1->codec_type == av->codec_type &&\n            av1->bit_rate == av->bit_rate) {\n\n            switch(av->codec_type) {\n            case AVMEDIA_TYPE_AUDIO:\n                if (av1->channels == av->channels &&\n                    av1->sample_rate == av->sample_rate)\n                    return i;\n                break;\n            case AVMEDIA_TYPE_VIDEO:\n                if (av1->width == av->width &&\n                    av1->height == av->height &&\n                    av1->time_base.den == av->time_base.den &&\n                    av1->time_base.num == av->time_base.num &&\n                    av1->gop_size == av->gop_size)\n                    return i;\n                break;\n            default:\n                abort();\n            }\n        }\n    }\n\n    fst = add_av_stream1(feed, av, 0);\n    if (!fst)\n        return -1;\n    if (st->recommended_encoder_configuration)\n        fst->recommended_encoder_configuration =\n            av_strdup(st->recommended_encoder_configuration);\n    return feed->nb_streams - 1;\n}\n\nstatic void remove_stream(FFServerStream *stream)\n{\n    FFServerStream **ps;\n    ps = &config.first_stream;\n    while (*ps) {\n        if (*ps == stream)\n            *ps = (*ps)->next;\n        else\n            ps = &(*ps)->next;\n    }\n}\n\n/* compute the needed AVStream for each file */\nstatic void build_file_streams(void)\n{\n    FFServerStream *stream;\n    AVFormatContext *infile;\n    int i, ret;\n\n    /* gather all streams */\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        infile = NULL;\n\n        if (stream->stream_type != STREAM_TYPE_LIVE || stream->feed)\n            continue;\n\n        /* the stream comes from a file */\n        /* try to open the file */\n        /* open stream */\n\n\n        /* specific case: if transport stream output to RTP,\n         * we use a raw transport stream reader */\n        if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\"))\n            av_dict_set(&stream->in_opts, \"mpeg2ts_compute_pcr\", \"1\", 0);\n\n        if (!stream->feed_filename[0]) {\n            http_log(\"Unspecified feed file for stream '%s'\\n\",\n                     stream->filename);\n            goto fail;\n        }\n\n        http_log(\"Opening feed file '%s' for stream '%s'\\n\",\n                 stream->feed_filename, stream->filename);\n\n        ret = avformat_open_input(&infile, stream->feed_filename,\n                                  stream->ifmt, &stream->in_opts);\n        if (ret < 0) {\n            http_log(\"Could not open '%s': %s\\n\", stream->feed_filename,\n                     av_err2str(ret));\n            /* remove stream (no need to spend more time on it) */\n        fail:\n            remove_stream(stream);\n        } else {\n            /* find all the AVStreams inside and reference them in\n             * 'stream' */\n            if (avformat_find_stream_info(infile, NULL) < 0) {\n                http_log(\"Could not find codec parameters from '%s'\\n\",\n                         stream->feed_filename);\n                avformat_close_input(&infile);\n                goto fail;\n            }\n\n            for(i=0;i<infile->nb_streams;i++)\n                add_av_stream1(stream, infile->streams[i]->codec, 1);\n\n            avformat_close_input(&infile);\n        }\n    }\n}\n\nstatic inline\nint check_codec_match(LayeredAVStream *ccf, AVStream *ccs, int stream)\n{\n    int matches = 1;\n\n/* FIXME: Missed check on AVCodecContext.flags */\n#define CHECK_CODEC(x)  (ccf->codecpar->x != ccs->codecpar->x)\n    if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n        http_log(\"Codecs do not match for stream %d\\n\", stream);\n        matches = 0;\n    } else if (CHECK_CODEC(bit_rate)) {\n        http_log(\"Codec bitrates do not match for stream %d\\n\", stream);\n        matches = 0;\n    } else if (ccf->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (av_cmp_q(ccf->time_base, ccs->time_base) ||\n            CHECK_CODEC(width) || CHECK_CODEC(height)) {\n            http_log(\"Codec width, height or framerate do not match for stream %d\\n\", stream);\n            matches = 0;\n        }\n    } else if (ccf->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n        if (CHECK_CODEC(sample_rate) ||\n            CHECK_CODEC(channels) ||\n            CHECK_CODEC(frame_size)) {\n            http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", stream);\n            matches = 0;\n        }\n    } else {\n        http_log(\"Unknown codec type for stream %d\\n\", stream);\n        matches = 0;\n    }\n\n    return matches;\n}\n\n/* compute the needed AVStream for each feed */\nstatic int build_feed_streams(void)\n{\n    FFServerStream *stream, *feed;\n    int i, fd;\n\n    /* gather all streams */\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        feed = stream->feed;\n        if (!feed)\n            continue;\n\n        if (stream->is_feed) {\n            for(i=0;i<stream->nb_streams;i++)\n                stream->feed_streams[i] = i;\n            continue;\n        }\n        /* we handle a stream coming from a feed */\n        for(i=0;i<stream->nb_streams;i++)\n            stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n    }\n\n    /* create feed files if needed */\n    for(feed = config.first_feed; feed; feed = feed->next_feed) {\n\n        if (avio_check(feed->feed_filename, AVIO_FLAG_READ) > 0) {\n            AVFormatContext *s = NULL;\n            int matches = 0;\n\n            /* See if it matches */\n\n            if (avformat_open_input(&s, feed->feed_filename, NULL, NULL) < 0) {\n                http_log(\"Deleting feed file '%s' as it appears \"\n                            \"to be corrupt\\n\",\n                         feed->feed_filename);\n                goto drop;\n            }\n\n            /* set buffer size */\n            if (ffio_set_buf_size(s->pb, FFM_PACKET_SIZE) < 0) {\n                http_log(\"Failed to set buffer size\\n\");\n                avformat_close_input(&s);\n                goto bail;\n            }\n\n            /* Now see if it matches */\n            if (s->nb_streams != feed->nb_streams) {\n                http_log(\"Deleting feed file '%s' as stream counts \"\n                            \"differ (%d != %d)\\n\",\n                         feed->feed_filename, s->nb_streams, feed->nb_streams);\n                goto drop;\n            }\n\n            matches = 1;\n            for(i=0;i<s->nb_streams;i++) {\n                AVStream *ss;\n                LayeredAVStream *sf;\n\n                sf = feed->streams[i];\n                ss = s->streams[i];\n\n                if (sf->index != ss->index || sf->id != ss->id) {\n                    http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n                             i, feed->feed_filename);\n                    matches = 0;\n                    break;\n                }\n\n                matches = check_codec_match (sf, ss, i);\n                if (!matches)\n                    break;\n            }\n\ndrop:\n            if (s)\n                avformat_close_input(&s);\n\n            if (!matches) {\n                if (feed->readonly) {\n                    http_log(\"Unable to delete read-only feed file '%s'\\n\",\n                             feed->feed_filename);\n                    goto bail;\n                }\n                unlink(feed->feed_filename);\n            }\n        }\n\n        if (avio_check(feed->feed_filename, AVIO_FLAG_WRITE) <= 0) {\n            AVFormatContext *s = avformat_alloc_context();\n\n            if (!s) {\n                http_log(\"Failed to allocate context\\n\");\n                goto bail;\n            }\n\n            if (feed->readonly) {\n                http_log(\"Unable to create feed file '%s' as it is \"\n                            \"marked readonly\\n\",\n                         feed->feed_filename);\n                avformat_free_context(s);\n                goto bail;\n            }\n\n            /* only write the header of the ffm file */\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n                http_log(\"Could not open output feed file '%s'\\n\",\n                         feed->feed_filename);\n                avformat_free_context(s);\n                goto bail;\n            }\n            s->oformat = feed->fmt;\n            for (i = 0; i<feed->nb_streams; i++) {\n                AVStream *st = avformat_new_stream(s, NULL); // FIXME free this\n                if (!st) {\n                    http_log(\"Failed to allocate stream\\n\");\n                    goto bail;\n                }\n                unlayer_stream(st, feed->streams[i]);\n            }\n            if (avformat_write_header(s, NULL) < 0) {\n                http_log(\"Container doesn't support the required parameters\\n\");\n                avio_closep(&s->pb);\n                s->streams = NULL;\n                s->nb_streams = 0;\n                avformat_free_context(s);\n                goto bail;\n            }\n            /* XXX: need better API */\n            av_freep(&s->priv_data);\n            avio_closep(&s->pb);\n            s->streams = NULL;\n            s->nb_streams = 0;\n            avformat_free_context(s);\n        }\n\n        /* get feed size and write index */\n        fd = open(feed->feed_filename, O_RDONLY);\n        if (fd < 0) {\n            http_log(\"Could not open output feed file '%s'\\n\",\n                    feed->feed_filename);\n            goto bail;\n        }\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd),\n                                       FFM_PACKET_SIZE);\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n        /* ensure that we do not wrap before the end of file */\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n            feed->feed_max_size = feed->feed_size;\n\n        close(fd);\n    }\n    return 0;\n\nbail:\n    return -1;\n}\n\n/* compute the bandwidth used by each stream */\nstatic void compute_bandwidth(void)\n{\n    unsigned bandwidth;\n    int i;\n    FFServerStream *stream;\n\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        bandwidth = 0;\n        for(i=0;i<stream->nb_streams;i++) {\n            LayeredAVStream *st = stream->streams[i];\n            switch(st->codec->codec_type) {\n            case AVMEDIA_TYPE_AUDIO:\n            case AVMEDIA_TYPE_VIDEO:\n                bandwidth += st->codec->bit_rate;\n                break;\n            default:\n                break;\n            }\n        }\n        stream->bandwidth = (bandwidth + 999) / 1000;\n    }\n}\n\nstatic void handle_child_exit(int sig)\n{\n    pid_t pid;\n    int status;\n    time_t uptime;\n\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        FFServerStream *feed;\n\n        for (feed = config.first_feed; feed; feed = feed->next) {\n            if (feed->pid != pid)\n                continue;\n\n            uptime = time(0) - feed->pid_start;\n            feed->pid = 0;\n            fprintf(stderr,\n                    \"%s: Pid %\"PRId64\" exited with status %d after %\"PRId64\" \"\n                        \"seconds\\n\",\n                    feed->filename, (int64_t) pid, status, (int64_t)uptime);\n\n            if (uptime < 30)\n                /* Turn off any more restarts */\n                ffserver_free_child_args(&feed->child_argv);\n        }\n    }\n\n    need_to_start_children = 1;\n}\n\nstatic void opt_debug(void)\n{\n    config.debug = 1;\n    snprintf(config.logfilename, sizeof(config.logfilename), \"-\");\n}\n\nvoid show_help_default(const char *opt, const char *arg)\n{\n    printf(\"usage: ffserver [options]\\n\"\n           \"Hyper fast multi format Audio/Video streaming server\\n\");\n    printf(\"\\n\");\n    show_help_options(options, \"Main options:\", 0, 0, 0);\n}\n\nstatic const OptionDef options[] = {\n#include \"cmdutils_common_opts.h\"\n    { \"n\", OPT_BOOL, {(void *)&no_launch }, \"enable no-launch mode\" },\n    { \"d\", 0, {(void*)opt_debug}, \"enable debug mode\" },\n    { \"f\", HAS_ARG | OPT_STRING, {(void*)&config.filename }, \"use configfile instead of /etc/ffserver.conf\", \"configfile\" },\n    { NULL },\n};\n\nint main(int argc, char **argv)\n{\n    struct sigaction sigact = { { 0 } };\n    int cfg_parsed;\n    int ret = EXIT_FAILURE;\n\n    init_dynload();\n\n    config.filename = av_strdup(\"/etc/ffserver.conf\");\n\n    parse_loglevel(argc, argv, options);\n    av_register_all();\n    avformat_network_init();\n\n    show_banner(argc, argv, options);\n\n    my_program_name = argv[0];\n\n    parse_options(NULL, argc, argv, options, NULL);\n\n    unsetenv(\"http_proxy\");             /* Kill the http_proxy */\n\n    av_lfg_init(&random_state, av_get_random_seed());\n\n    sigact.sa_handler = handle_child_exit;\n    sigact.sa_flags = SA_NOCLDSTOP | SA_RESTART;\n    sigaction(SIGCHLD, &sigact, 0);\n\n    if ((cfg_parsed = ffserver_parse_ffconfig(config.filename, &config)) < 0) {\n        fprintf(stderr, \"Error reading configuration file '%s': %s\\n\",\n                config.filename, av_err2str(cfg_parsed));\n        goto bail;\n    }\n\n    /* open log file if needed */\n    if (config.logfilename[0] != '\\0') {\n        if (!strcmp(config.logfilename, \"-\"))\n            logfile = stdout;\n        else\n            logfile = fopen(config.logfilename, \"a\");\n        av_log_set_callback(http_av_log);\n    }\n\n    build_file_streams();\n\n    if (build_feed_streams() < 0) {\n        http_log(\"Could not setup feed streams\\n\");\n        goto bail;\n    }\n\n    compute_bandwidth();\n\n    /* signal init */\n    signal(SIGPIPE, SIG_IGN);\n\n    if (http_server() < 0) {\n        http_log(\"Could not start server\\n\");\n        goto bail;\n    }\n\n    ret=EXIT_SUCCESS;\n\nbail:\n    av_freep (&config.filename);\n    avformat_network_deinit();\n    return ret;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2000, 2001, 2002 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * multiple format streaming server based on the FFmpeg libraries\n */\n\n#include \"config.h\"\n#if !HAVE_CLOSESOCKET\n#define closesocket close\n#endif\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"libavformat/avformat.h\"\n/* FIXME: those are internal headers, ffserver _really_ shouldn't use them */\n#include \"libavformat/rtpproto.h\"\n#include \"libavformat/rtsp.h\"\n#include \"libavformat/avio_internal.h\"\n#include \"libavformat/internal.h\"\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/lfg.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/random_seed.h\"\n#include \"libavutil/rational.h\"\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/time.h\"\n\n#include <stdarg.h>\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#if HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <errno.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#include \"cmdutils.h\"\n#include \"ffserver_config.h\"\n\n#define PATH_LENGTH 1024\n\nconst char program_name[] = \"ffserver\";\nconst int program_birth_year = 2000;\n\nstatic const OptionDef options[];\n\nenum HTTPState {\n    HTTPSTATE_WAIT_REQUEST,\n    HTTPSTATE_SEND_HEADER,\n    HTTPSTATE_SEND_DATA_HEADER,\n    HTTPSTATE_SEND_DATA,          /* sending TCP or UDP data */\n    HTTPSTATE_SEND_DATA_TRAILER,\n    HTTPSTATE_RECEIVE_DATA,\n    HTTPSTATE_WAIT_FEED,          /* wait for data from the feed */\n    HTTPSTATE_READY,\n\n    RTSPSTATE_WAIT_REQUEST,\n    RTSPSTATE_SEND_REPLY,\n    RTSPSTATE_SEND_PACKET,\n};\n\nstatic const char * const http_state[] = {\n    \"HTTP_WAIT_REQUEST\",\n    \"HTTP_SEND_HEADER\",\n\n    \"SEND_DATA_HEADER\",\n    \"SEND_DATA\",\n    \"SEND_DATA_TRAILER\",\n    \"RECEIVE_DATA\",\n    \"WAIT_FEED\",\n    \"READY\",\n\n    \"RTSP_WAIT_REQUEST\",\n    \"RTSP_SEND_REPLY\",\n    \"RTSP_SEND_PACKET\",\n};\n\n#define IOBUFFER_INIT_SIZE 8192\n\n/* timeouts are in ms */\n#define HTTP_REQUEST_TIMEOUT (15 * 1000)\n#define RTSP_REQUEST_TIMEOUT (3600 * 24 * 1000)\n\n#define SYNC_TIMEOUT (10 * 1000)\n\ntypedef struct RTSPActionServerSetup {\n    uint32_t ipaddr;\n    char transport_option[512];\n} RTSPActionServerSetup;\n\ntypedef struct {\n    int64_t count1, count2;\n    int64_t time1, time2;\n} DataRateData;\n\n/* context associated with one connection */\ntypedef struct HTTPContext {\n    enum HTTPState state;\n    int fd; /* socket file descriptor */\n    struct sockaddr_in from_addr; /* origin */\n    struct pollfd *poll_entry; /* used when polling */\n    int64_t timeout;\n    uint8_t *buffer_ptr, *buffer_end;\n    int http_error;\n    int post;\n    int chunked_encoding;\n    int chunk_size;               /* 0 if it needs to be read */\n    struct HTTPContext *next;\n    int got_key_frame; /* stream 0 => 1, stream 1 => 2, stream 2=> 4 */\n    int64_t data_count;\n    /* feed input */\n    int feed_fd;\n    /* input format handling */\n    AVFormatContext *fmt_in;\n    int64_t start_time;            /* In milliseconds - this wraps fairly often */\n    int64_t first_pts;            /* initial pts value */\n    int64_t cur_pts;             /* current pts value from the stream in us */\n    int64_t cur_frame_duration;  /* duration of the current frame in us */\n    int cur_frame_bytes;       /* output frame size, needed to compute\n                                  the time at which we send each\n                                  packet */\n    int pts_stream_index;        /* stream we choose as clock reference */\n    int64_t cur_clock;           /* current clock reference value in us */\n    /* output format handling */\n    struct FFServerStream *stream;\n    /* -1 is invalid stream */\n    int feed_streams[FFSERVER_MAX_STREAMS]; /* index of streams in the feed */\n    int switch_feed_streams[FFSERVER_MAX_STREAMS]; /* index of streams in the feed */\n    int switch_pending;\n    AVFormatContext *pfmt_ctx; /* instance of FFServerStream for one user */\n    int last_packet_sent; /* true if last data packet was sent */\n    int suppress_log;\n    DataRateData datarate;\n    int wmp_client_id;\n    char protocol[16];\n    char method[16];\n    char url[128];\n    char clean_url[128*7];\n    int buffer_size;\n    uint8_t *buffer;\n    int is_packetized; /* if true, the stream is packetized */\n    int packet_stream_index; /* current stream for output in state machine */\n\n    /* RTSP state specific */\n    uint8_t *pb_buffer; /* XXX: use that in all the code */\n    AVIOContext *pb;\n    int seq; /* RTSP sequence number */\n\n    /* RTP state specific */\n    enum RTSPLowerTransport rtp_protocol;\n    char session_id[32]; /* session id */\n    AVFormatContext *rtp_ctx[FFSERVER_MAX_STREAMS];\n\n    /* RTP/UDP specific */\n    URLContext *rtp_handles[FFSERVER_MAX_STREAMS];\n\n    /* RTP/TCP specific */\n    struct HTTPContext *rtsp_c;\n    uint8_t *packet_buffer, *packet_buffer_ptr, *packet_buffer_end;\n} HTTPContext;\n\nstatic HTTPContext *first_http_ctx;\n\nstatic FFServerConfig config = {\n    .nb_max_http_connections = 2000,\n    .nb_max_connections = 5,\n    .max_bandwidth = 1000,\n    .use_defaults = 1,\n};\n\nstatic void new_connection(int server_fd, int is_rtsp);\nstatic void close_connection(HTTPContext *c);\n\n/* HTTP handling */\nstatic int handle_connection(HTTPContext *c);\nstatic inline void print_stream_params(AVIOContext *pb, FFServerStream *stream);\nstatic void compute_status(HTTPContext *c);\nstatic int open_input_stream(HTTPContext *c, const char *info);\nstatic int http_parse_request(HTTPContext *c);\nstatic int http_send_data(HTTPContext *c);\nstatic int http_start_receive_data(HTTPContext *c);\nstatic int http_receive_data(HTTPContext *c);\n\n/* RTSP handling */\nstatic int rtsp_parse_request(HTTPContext *c);\nstatic void rtsp_cmd_describe(HTTPContext *c, const char *url);\nstatic void rtsp_cmd_options(HTTPContext *c, const char *url);\nstatic void rtsp_cmd_setup(HTTPContext *c, const char *url,\n                           RTSPMessageHeader *h);\nstatic void rtsp_cmd_play(HTTPContext *c, const char *url,\n                          RTSPMessageHeader *h);\nstatic void rtsp_cmd_interrupt(HTTPContext *c, const char *url,\n                               RTSPMessageHeader *h, int pause_only);\n\n/* SDP handling */\nstatic int prepare_sdp_description(FFServerStream *stream, uint8_t **pbuffer,\n                                   struct in_addr my_ip);\n\n/* RTP handling */\nstatic HTTPContext *rtp_new_connection(struct sockaddr_in *from_addr,\n                                       FFServerStream *stream,\n                                       const char *session_id,\n                                       enum RTSPLowerTransport rtp_protocol);\nstatic int rtp_new_av_stream(HTTPContext *c,\n                             int stream_index, struct sockaddr_in *dest_addr,\n                             HTTPContext *rtsp_c);\n/* utils */\nstatic size_t htmlencode (const char *src, char **dest);\nstatic inline void cp_html_entity (char *buffer, const char *entity);\nstatic inline int check_codec_match(LayeredAVStream *ccf, AVStream *ccs, int stream);\n\nstatic const char *my_program_name;\n\nstatic int no_launch;\nstatic int need_to_start_children;\n\n/* maximum number of simultaneous HTTP connections */\nstatic unsigned int nb_connections;\n\nstatic uint64_t current_bandwidth;\n\n/* Making this global saves on passing it around everywhere */\nstatic int64_t cur_time;\n\nstatic AVLFG random_state;\n\nstatic FILE *logfile = NULL;\n\nstatic void unlayer_stream(AVStream *st, LayeredAVStream *lst)\n{\n    avcodec_free_context(&st->codec);\n    avcodec_parameters_free(&st->codecpar);\n#define COPY(a) st->a = lst->a;\n    COPY(index)\n    COPY(id)\n    COPY(codec)\n    COPY(codecpar)\n    COPY(time_base)\n    COPY(pts_wrap_bits)\n    COPY(sample_aspect_ratio)\n    COPY(recommended_encoder_configuration)\n}\n\nstatic inline void cp_html_entity (char *buffer, const char *entity) {\n    if (!buffer || !entity)\n        return;\n    while (*entity)\n        *buffer++ = *entity++;\n}\n\n/**\n * Substitutes known conflicting chars on a text string with\n * their corresponding HTML entities.\n *\n * Returns the number of bytes in the 'encoded' representation\n * not including the terminating NUL.\n */\nstatic size_t htmlencode (const char *src, char **dest) {\n    const char *amp = \"&amp;\";\n    const char *lt  = \"&lt;\";\n    const char *gt  = \"&gt;\";\n    const char *start;\n    char *tmp;\n    size_t final_size = 0;\n\n    if (!src)\n        return 0;\n\n    start = src;\n\n    /* Compute needed dest size */\n    while (*src != '\\0') {\n        switch(*src) {\n            case 38: /* & */\n                final_size += 5;\n                break;\n            case 60: /* < */\n            case 62: /* > */\n                final_size += 4;\n                break;\n            default:\n                final_size++;\n        }\n        src++;\n    }\n\n    src = start;\n    *dest = av_mallocz(final_size + 1);\n    if (!*dest)\n        return 0;\n\n    /* Build dest */\n    tmp = *dest;\n    while (*src != '\\0') {\n        switch(*src) {\n            case 38: /* & */\n                cp_html_entity (tmp, amp);\n                tmp += 5;\n                break;\n            case 60: /* < */\n                cp_html_entity (tmp, lt);\n                tmp += 4;\n                break;\n            case 62: /* > */\n                cp_html_entity (tmp, gt);\n                tmp += 4;\n                break;\n            default:\n                *tmp = *src;\n                tmp += 1;\n        }\n        src++;\n    }\n    *tmp = '\\0';\n\n    return final_size;\n}\n\nstatic int64_t ffm_read_write_index(int fd)\n{\n    uint8_t buf[8];\n\n    if (lseek(fd, 8, SEEK_SET) < 0)\n        return AVERROR(EIO);\n    if (read(fd, buf, 8) != 8)\n        return AVERROR(EIO);\n    return AV_RB64(buf);\n}\n\nstatic int ffm_write_write_index(int fd, int64_t pos)\n{\n    uint8_t buf[8];\n    int i;\n\n    for(i=0;i<8;i++)\n        buf[i] = (pos >> (56 - i * 8)) & 0xff;\n    if (lseek(fd, 8, SEEK_SET) < 0)\n        goto bail_eio;\n    if (write(fd, buf, 8) != 8)\n        goto bail_eio;\n\n    return 8;\n\nbail_eio:\n    return AVERROR(EIO);\n}\n\nstatic void ffm_set_write_index(AVFormatContext *s, int64_t pos,\n                                int64_t file_size)\n{\n    av_opt_set_int(s, \"server_attached\", 1, AV_OPT_SEARCH_CHILDREN);\n    av_opt_set_int(s, \"ffm_write_index\", pos, AV_OPT_SEARCH_CHILDREN);\n    av_opt_set_int(s, \"ffm_file_size\", file_size, AV_OPT_SEARCH_CHILDREN);\n}\n\nstatic char *ctime1(char *buf2, size_t buf_size)\n{\n    time_t ti;\n    char *p;\n\n    ti = time(NULL);\n    p = ctime(&ti);\n    if (!p || !*p) {\n        *buf2 = '\\0';\n        return buf2;\n    }\n    av_strlcpy(buf2, p, buf_size);\n    p = buf2 + strlen(buf2) - 1;\n    if (*p == '\\n')\n        *p = '\\0';\n    return buf2;\n}\n\nstatic void http_vlog(const char *fmt, va_list vargs)\n{\n    static int print_prefix = 1;\n    char buf[32];\n\n    if (!logfile)\n        return;\n\n    if (print_prefix) {\n        ctime1(buf, sizeof(buf));\n        fprintf(logfile, \"%s \", buf);\n    }\n    print_prefix = strstr(fmt, \"\\n\") != NULL;\n    vfprintf(logfile, fmt, vargs);\n    fflush(logfile);\n}\n\n#ifdef __GNUC__\n__attribute__ ((format (printf, 1, 2)))\n#endif\nstatic void http_log(const char *fmt, ...)\n{\n    va_list vargs;\n    va_start(vargs, fmt);\n    http_vlog(fmt, vargs);\n    va_end(vargs);\n}\n\nstatic void http_av_log(void *ptr, int level, const char *fmt, va_list vargs)\n{\n    static int print_prefix = 1;\n    AVClass *avc = ptr ? *(AVClass**)ptr : NULL;\n    if (level > av_log_get_level())\n        return;\n    if (print_prefix && avc)\n        http_log(\"[%s @ %p]\", avc->item_name(ptr), ptr);\n    print_prefix = strstr(fmt, \"\\n\") != NULL;\n    http_vlog(fmt, vargs);\n}\n\nstatic void log_connection(HTTPContext *c)\n{\n    if (c->suppress_log)\n        return;\n\n    http_log(\"%s - - [%s] \\\"%s %s\\\" %d %\"PRId64\"\\n\",\n             inet_ntoa(c->from_addr.sin_addr), c->method, c->url,\n             c->protocol, (c->http_error ? c->http_error : 200), c->data_count);\n}\n\nstatic void update_datarate(DataRateData *drd, int64_t count)\n{\n    if (!drd->time1 && !drd->count1) {\n        drd->time1 = drd->time2 = cur_time;\n        drd->count1 = drd->count2 = count;\n    } else if (cur_time - drd->time2 > 5000) {\n        drd->time1 = drd->time2;\n        drd->count1 = drd->count2;\n        drd->time2 = cur_time;\n        drd->count2 = count;\n    }\n}\n\n/* In bytes per second */\nstatic int compute_datarate(DataRateData *drd, int64_t count)\n{\n    if (cur_time == drd->time1)\n        return 0;\n\n    return ((count - drd->count1) * 1000) / (cur_time - drd->time1);\n}\n\n\nstatic void start_children(FFServerStream *feed)\n{\n    char *pathname;\n    char *slash;\n    int i;\n    size_t cmd_length;\n\n    if (no_launch)\n        return;\n\n    cmd_length = strlen(my_program_name);\n\n   /**\n    * FIXME: WIP Safeguard. Remove after clearing all harcoded\n    * '1024' path lengths\n    */\n    if (cmd_length > PATH_LENGTH - 1) {\n        http_log(\"Could not start children. Command line: '%s' exceeds \"\n                    \"path length limit (%d)\\n\", my_program_name, PATH_LENGTH);\n        return;\n    }\n\n    pathname = av_strdup (my_program_name);\n    if (!pathname) {\n        http_log(\"Could not allocate memory for children cmd line\\n\");\n        return;\n    }\n   /* replace \"ffserver\" with \"ffmpeg\" in the path of current\n    * program. Ignore user provided path */\n\n    slash = strrchr(pathname, '/');\n    if (!slash)\n        slash = pathname;\n    else\n        slash++;\n    strcpy(slash, \"ffmpeg\");\n\n    for (; feed; feed = feed->next) {\n\n        if (!feed->child_argv || feed->pid)\n            continue;\n\n        feed->pid_start = time(0);\n\n        feed->pid = fork();\n        if (feed->pid < 0) {\n            http_log(\"Unable to create children: %s\\n\", strerror(errno));\n            av_free (pathname);\n            exit(EXIT_FAILURE);\n        }\n\n        if (feed->pid)\n            continue;\n\n        /* In child */\n\n        http_log(\"Launch command line: \");\n        http_log(\"%s \", pathname);\n\n        for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)\n            http_log(\"%s \", feed->child_argv[i]);\n        http_log(\"\\n\");\n\n        for (i = 3; i < 256; i++)\n            close(i);\n\n        if (!config.debug) {\n            if (!freopen(\"/dev/null\", \"r\", stdin))\n                http_log(\"failed to redirect STDIN to /dev/null\\n;\");\n            if (!freopen(\"/dev/null\", \"w\", stdout))\n                http_log(\"failed to redirect STDOUT to /dev/null\\n;\");\n            if (!freopen(\"/dev/null\", \"w\", stderr))\n                http_log(\"failed to redirect STDERR to /dev/null\\n;\");\n        }\n\n        signal(SIGPIPE, SIG_DFL);\n        execvp(pathname, feed->child_argv);\n        av_free (pathname);\n        _exit(1);\n    }\n    av_free (pathname);\n}\n\n/* open a listening socket */\nstatic int socket_open_listen(struct sockaddr_in *my_addr)\n{\n    int server_fd, tmp;\n\n    server_fd = socket(AF_INET,SOCK_STREAM,0);\n    if (server_fd < 0) {\n        perror (\"socket\");\n        return -1;\n    }\n\n    tmp = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof(tmp)))\n        av_log(NULL, AV_LOG_WARNING, \"setsockopt SO_REUSEADDR failed\\n\");\n\n    my_addr->sin_family = AF_INET;\n    if (bind (server_fd, (struct sockaddr *) my_addr, sizeof (*my_addr)) < 0) {\n        char bindmsg[32];\n        snprintf(bindmsg, sizeof(bindmsg), \"bind(port %d)\",\n                 ntohs(my_addr->sin_port));\n        perror (bindmsg);\n        goto fail;\n    }\n\n    if (listen (server_fd, 5) < 0) {\n        perror (\"listen\");\n        goto fail;\n    }\n\n    if (ff_socket_nonblock(server_fd, 1) < 0)\n        av_log(NULL, AV_LOG_WARNING, \"ff_socket_nonblock failed\\n\");\n\n    return server_fd;\n\nfail:\n    closesocket(server_fd);\n    return -1;\n}\n\n/* start all multicast streams */\nstatic void start_multicast(void)\n{\n    FFServerStream *stream;\n    char session_id[32];\n    HTTPContext *rtp_c;\n    struct sockaddr_in dest_addr = {0};\n    int default_port, stream_index;\n    unsigned int random0, random1;\n\n    default_port = 6000;\n    for(stream = config.first_stream; stream; stream = stream->next) {\n\n        if (!stream->is_multicast)\n            continue;\n\n        random0 = av_lfg_get(&random_state);\n        random1 = av_lfg_get(&random_state);\n\n        /* open the RTP connection */\n        snprintf(session_id, sizeof(session_id), \"%08x%08x\", random0, random1);\n\n        /* choose a port if none given */\n        if (stream->multicast_port == 0) {\n            stream->multicast_port = default_port;\n            default_port += 100;\n        }\n\n        dest_addr.sin_family = AF_INET;\n        dest_addr.sin_addr = stream->multicast_ip;\n        dest_addr.sin_port = htons(stream->multicast_port);\n\n        rtp_c = rtp_new_connection(&dest_addr, stream, session_id,\n                                   RTSP_LOWER_TRANSPORT_UDP_MULTICAST);\n        if (!rtp_c)\n            continue;\n\n        if (open_input_stream(rtp_c, \"\") < 0) {\n            http_log(\"Could not open input stream for stream '%s'\\n\",\n                     stream->filename);\n            continue;\n        }\n\n        /* open each RTP stream */\n        for(stream_index = 0; stream_index < stream->nb_streams;\n            stream_index++) {\n            dest_addr.sin_port = htons(stream->multicast_port +\n                                       2 * stream_index);\n            if (rtp_new_av_stream(rtp_c, stream_index, &dest_addr, NULL) >= 0)\n                continue;\n\n            http_log(\"Could not open output stream '%s/streamid=%d'\\n\",\n                     stream->filename, stream_index);\n            exit(1);\n        }\n\n        rtp_c->state = HTTPSTATE_SEND_DATA;\n    }\n}\n\n/* main loop of the HTTP server */\nstatic int http_server(void)\n{\n    int server_fd = 0, rtsp_server_fd = 0;\n    int ret, delay;\n    struct pollfd *poll_table, *poll_entry;\n    HTTPContext *c, *c_next;\n\n    poll_table = av_mallocz_array(config.nb_max_http_connections + 2,\n                                  sizeof(*poll_table));\n    if(!poll_table) {\n        http_log(\"Impossible to allocate a poll table handling %d \"\n                 \"connections.\\n\", config.nb_max_http_connections);\n        return -1;\n    }\n\n    if (config.http_addr.sin_port) {\n        server_fd = socket_open_listen(&config.http_addr);\n        if (server_fd < 0)\n            goto quit;\n    }\n\n    if (config.rtsp_addr.sin_port) {\n        rtsp_server_fd = socket_open_listen(&config.rtsp_addr);\n        if (rtsp_server_fd < 0) {\n            closesocket(server_fd);\n            goto quit;\n        }\n    }\n\n    if (!rtsp_server_fd && !server_fd) {\n        http_log(\"HTTP and RTSP disabled.\\n\");\n        goto quit;\n    }\n\n    http_log(\"FFserver started.\\n\");\n\n    start_children(config.first_feed);\n\n    start_multicast();\n\n    for(;;) {\n        poll_entry = poll_table;\n        if (server_fd) {\n            poll_entry->fd = server_fd;\n            poll_entry->events = POLLIN;\n            poll_entry++;\n        }\n        if (rtsp_server_fd) {\n            poll_entry->fd = rtsp_server_fd;\n            poll_entry->events = POLLIN;\n            poll_entry++;\n        }\n\n        /* wait for events on each HTTP handle */\n        c = first_http_ctx;\n        delay = 1000;\n        while (c) {\n            int fd;\n            fd = c->fd;\n            switch(c->state) {\n            case HTTPSTATE_SEND_HEADER:\n            case RTSPSTATE_SEND_REPLY:\n            case RTSPSTATE_SEND_PACKET:\n                c->poll_entry = poll_entry;\n                poll_entry->fd = fd;\n                poll_entry->events = POLLOUT;\n                poll_entry++;\n                break;\n            case HTTPSTATE_SEND_DATA_HEADER:\n            case HTTPSTATE_SEND_DATA:\n            case HTTPSTATE_SEND_DATA_TRAILER:\n                if (!c->is_packetized) {\n                    /* for TCP, we output as much as we can\n                     * (may need to put a limit) */\n                    c->poll_entry = poll_entry;\n                    poll_entry->fd = fd;\n                    poll_entry->events = POLLOUT;\n                    poll_entry++;\n                } else {\n                    /* when ffserver is doing the timing, we work by\n                     * looking at which packet needs to be sent every\n                     * 10 ms (one tick wait XXX: 10 ms assumed) */\n                    if (delay > 10)\n                        delay = 10;\n                }\n                break;\n            case HTTPSTATE_WAIT_REQUEST:\n            case HTTPSTATE_RECEIVE_DATA:\n            case HTTPSTATE_WAIT_FEED:\n            case RTSPSTATE_WAIT_REQUEST:\n                /* need to catch errors */\n                c->poll_entry = poll_entry;\n                poll_entry->fd = fd;\n                poll_entry->events = POLLIN;/* Maybe this will work */\n                poll_entry++;\n                break;\n            default:\n                c->poll_entry = NULL;\n                break;\n            }\n            c = c->next;\n        }\n\n        /* wait for an event on one connection. We poll at least every\n         * second to handle timeouts */\n        do {\n            ret = poll(poll_table, poll_entry - poll_table, delay);\n            if (ret < 0 && ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                goto quit;\n            }\n        } while (ret < 0);\n\n        cur_time = av_gettime() / 1000;\n\n        if (need_to_start_children) {\n            need_to_start_children = 0;\n            start_children(config.first_feed);\n        }\n\n        /* now handle the events */\n        for(c = first_http_ctx; c; c = c_next) {\n            c_next = c->next;\n            if (handle_connection(c) < 0) {\n                log_connection(c);\n                /* close and free the connection */\n                close_connection(c);\n            }\n        }\n\n        poll_entry = poll_table;\n        if (server_fd) {\n            /* new HTTP connection request ? */\n            if (poll_entry->revents & POLLIN)\n                new_connection(server_fd, 0);\n            poll_entry++;\n        }\n        if (rtsp_server_fd) {\n            /* new RTSP connection request ? */\n            if (poll_entry->revents & POLLIN)\n                new_connection(rtsp_server_fd, 1);\n        }\n    }\n\nquit:\n    av_free(poll_table);\n    return -1;\n}\n\n/* start waiting for a new HTTP/RTSP request */\nstatic void start_wait_request(HTTPContext *c, int is_rtsp)\n{\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = c->buffer + c->buffer_size - 1; /* leave room for '\\0' */\n\n    c->state = is_rtsp ? RTSPSTATE_WAIT_REQUEST : HTTPSTATE_WAIT_REQUEST;\n    c->timeout = cur_time +\n                 (is_rtsp ? RTSP_REQUEST_TIMEOUT : HTTP_REQUEST_TIMEOUT);\n}\n\nstatic void http_send_too_busy_reply(int fd)\n{\n    char buffer[400];\n    int len = snprintf(buffer, sizeof(buffer),\n                       \"HTTP/1.0 503 Server too busy\\r\\n\"\n                       \"Content-type: text/html\\r\\n\"\n                       \"\\r\\n\"\n                       \"<!DOCTYPE html>\\n\"\n                       \"<html><head><title>Too busy</title></head><body>\\r\\n\"\n                       \"<p>The server is too busy to serve your request at \"\n                       \"this time.</p>\\r\\n\"\n                       \"<p>The number of current connections is %u, and this \"\n                       \"exceeds the limit of %u.</p>\\r\\n\"\n                       \"</body></html>\\r\\n\",\n                       nb_connections, config.nb_max_connections);\n    av_assert0(len < sizeof(buffer));\n    if (send(fd, buffer, len, 0) < len)\n        av_log(NULL, AV_LOG_WARNING,\n               \"Could not send too-busy reply, send() failed\\n\");\n}\n\n\nstatic void new_connection(int server_fd, int is_rtsp)\n{\n    struct sockaddr_in from_addr;\n    socklen_t len;\n    int fd;\n    HTTPContext *c = NULL;\n\n    len = sizeof(from_addr);\n    fd = accept(server_fd, (struct sockaddr *)&from_addr,\n                &len);\n    if (fd < 0) {\n        http_log(\"error during accept %s\\n\", strerror(errno));\n        return;\n    }\n    if (ff_socket_nonblock(fd, 1) < 0)\n        av_log(NULL, AV_LOG_WARNING, \"ff_socket_nonblock failed\\n\");\n\n    if (nb_connections >= config.nb_max_connections) {\n        http_send_too_busy_reply(fd);\n        goto fail;\n    }\n\n    /* add a new connection */\n    c = av_mallocz(sizeof(HTTPContext));\n    if (!c)\n        goto fail;\n\n    c->fd = fd;\n    c->poll_entry = NULL;\n    c->from_addr = from_addr;\n    c->buffer_size = IOBUFFER_INIT_SIZE;\n    c->buffer = av_malloc(c->buffer_size);\n    if (!c->buffer)\n        goto fail;\n\n    c->next = first_http_ctx;\n    first_http_ctx = c;\n    nb_connections++;\n\n    start_wait_request(c, is_rtsp);\n\n    return;\n\n fail:\n    if (c) {\n        av_freep(&c->buffer);\n        av_free(c);\n    }\n    closesocket(fd);\n}\n\nstatic void close_connection(HTTPContext *c)\n{\n    HTTPContext **cp, *c1;\n    int i, nb_streams;\n    AVFormatContext *ctx;\n    AVStream *st;\n\n    /* remove connection from list */\n    cp = &first_http_ctx;\n    while (*cp) {\n        c1 = *cp;\n        if (c1 == c)\n            *cp = c->next;\n        else\n            cp = &c1->next;\n    }\n\n    /* remove references, if any (XXX: do it faster) */\n    for(c1 = first_http_ctx; c1; c1 = c1->next) {\n        if (c1->rtsp_c == c)\n            c1->rtsp_c = NULL;\n    }\n\n    /* remove connection associated resources */\n    if (c->fd >= 0)\n        closesocket(c->fd);\n    if (c->fmt_in) {\n        /* close each frame parser */\n        for(i=0;i<c->fmt_in->nb_streams;i++) {\n            st = c->fmt_in->streams[i];\n            if (st->codec->codec)\n                avcodec_close(st->codec);\n        }\n        avformat_close_input(&c->fmt_in);\n    }\n\n    /* free RTP output streams if any */\n    nb_streams = 0;\n    if (c->stream)\n        nb_streams = c->stream->nb_streams;\n\n    for(i=0;i<nb_streams;i++) {\n        ctx = c->rtp_ctx[i];\n        if (ctx) {\n            av_write_trailer(ctx);\n            av_dict_free(&ctx->metadata);\n            av_freep(&ctx->streams[0]);\n            av_freep(&ctx);\n        }\n        ffurl_close(c->rtp_handles[i]);\n    }\n\n    ctx = c->pfmt_ctx;\n\n    if (ctx) {\n        if (!c->last_packet_sent && c->state == HTTPSTATE_SEND_DATA_TRAILER) {\n            /* prepare header */\n            if (ctx->oformat && avio_open_dyn_buf(&ctx->pb) >= 0) {\n                av_write_trailer(ctx);\n                av_freep(&c->pb_buffer);\n                avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n            }\n        }\n        for(i=0; i<ctx->nb_streams; i++)\n            av_freep(&ctx->streams[i]);\n        av_freep(&ctx->streams);\n        av_freep(&ctx->priv_data);\n        }\n\n    if (c->stream && !c->post && c->stream->stream_type == STREAM_TYPE_LIVE)\n        current_bandwidth -= c->stream->bandwidth;\n\n    /* signal that there is no feed if we are the feeder socket */\n    if (c->state == HTTPSTATE_RECEIVE_DATA && c->stream) {\n        c->stream->feed_opened = 0;\n        close(c->feed_fd);\n    }\n\n    av_freep(&c->pb_buffer);\n    av_freep(&c->packet_buffer);\n    av_freep(&c->buffer);\n    av_free(c);\n    nb_connections--;\n}\n\nstatic int handle_connection(HTTPContext *c)\n{\n    int len, ret;\n    uint8_t *ptr;\n\n    switch(c->state) {\n    case HTTPSTATE_WAIT_REQUEST:\n    case RTSPSTATE_WAIT_REQUEST:\n        /* timeout ? */\n        if ((c->timeout - cur_time) < 0)\n            return -1;\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n\n        /* no need to read if no events */\n        if (!(c->poll_entry->revents & POLLIN))\n            return 0;\n        /* read the data */\n    read_loop:\n        if (!(len = recv(c->fd, c->buffer_ptr, 1, 0)))\n            return -1;\n\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                return -1;\n            break;\n        }\n        /* search for end of request. */\n        c->buffer_ptr += len;\n        ptr = c->buffer_ptr;\n        if ((ptr >= c->buffer + 2 && !memcmp(ptr-2, \"\\n\\n\", 2)) ||\n            (ptr >= c->buffer + 4 && !memcmp(ptr-4, \"\\r\\n\\r\\n\", 4))) {\n            /* request found : parse it and reply */\n            if (c->state == HTTPSTATE_WAIT_REQUEST)\n                ret = http_parse_request(c);\n            else\n                ret = rtsp_parse_request(c);\n\n            if (ret < 0)\n                return -1;\n        } else if (ptr >= c->buffer_end) {\n            /* request too long: cannot do anything */\n            return -1;\n        } else goto read_loop;\n\n        break;\n\n    case HTTPSTATE_SEND_HEADER:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                goto close_connection;\n            }\n            break;\n        }\n        c->buffer_ptr += len;\n        if (c->stream)\n            c->stream->bytes_served += len;\n        c->data_count += len;\n        if (c->buffer_ptr >= c->buffer_end) {\n            av_freep(&c->pb_buffer);\n            /* if error, exit */\n            if (c->http_error)\n                return -1;\n            /* all the buffer was sent : synchronize to the incoming\n             * stream */\n            c->state = HTTPSTATE_SEND_DATA_HEADER;\n            c->buffer_ptr = c->buffer_end = c->buffer;\n        }\n        break;\n\n    case HTTPSTATE_SEND_DATA:\n    case HTTPSTATE_SEND_DATA_HEADER:\n    case HTTPSTATE_SEND_DATA_TRAILER:\n        /* for packetized output, we consider we can always write (the\n         * input streams set the speed). It may be better to verify\n         * that we do not rely too much on the kernel queues */\n        if (!c->is_packetized) {\n            if (c->poll_entry->revents & (POLLERR | POLLHUP))\n                return -1;\n\n            /* no need to read if no events */\n            if (!(c->poll_entry->revents & POLLOUT))\n                return 0;\n        }\n        if (http_send_data(c) < 0)\n            return -1;\n        /* close connection if trailer sent */\n        if (c->state == HTTPSTATE_SEND_DATA_TRAILER)\n            return -1;\n        /* Check if it is a single jpeg frame 123 */\n        if (c->stream->single_frame && c->data_count > c->cur_frame_bytes && c->cur_frame_bytes > 0) {\n            close_connection(c);\n        }\n        break;\n    case HTTPSTATE_RECEIVE_DATA:\n        /* no need to read if no events */\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n        if (!(c->poll_entry->revents & POLLIN))\n            return 0;\n        if (http_receive_data(c) < 0)\n            return -1;\n        break;\n    case HTTPSTATE_WAIT_FEED:\n        /* no need to read if no events */\n        if (c->poll_entry->revents & (POLLIN | POLLERR | POLLHUP))\n            return -1;\n\n        /* nothing to do, we'll be waken up by incoming feed packets */\n        break;\n\n    case RTSPSTATE_SEND_REPLY:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            goto close_connection;\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                goto close_connection;\n            }\n            break;\n        }\n        c->buffer_ptr += len;\n        c->data_count += len;\n        if (c->buffer_ptr >= c->buffer_end) {\n            /* all the buffer was sent : wait for a new request */\n            av_freep(&c->pb_buffer);\n            start_wait_request(c, 1);\n        }\n        break;\n    case RTSPSTATE_SEND_PACKET:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP)) {\n            av_freep(&c->packet_buffer);\n            return -1;\n        }\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->packet_buffer_ptr,\n                    c->packet_buffer_end - c->packet_buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                /* error : close connection */\n                av_freep(&c->packet_buffer);\n                return -1;\n            }\n            break;\n        }\n        c->packet_buffer_ptr += len;\n        if (c->packet_buffer_ptr >= c->packet_buffer_end) {\n            /* all the buffer was sent : wait for a new request */\n            av_freep(&c->packet_buffer);\n            c->state = RTSPSTATE_WAIT_REQUEST;\n        }\n        break;\n    case HTTPSTATE_READY:\n        /* nothing to do */\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n\nclose_connection:\n    av_freep(&c->pb_buffer);\n    return -1;\n}\n\nstatic int extract_rates(char *rates, int ratelen, const char *request)\n{\n    const char *p;\n\n    for (p = request; *p && *p != '\\r' && *p != '\\n'; ) {\n        if (av_strncasecmp(p, \"Pragma:\", 7) == 0) {\n            const char *q = p + 7;\n\n            while (*q && *q != '\\n' && av_isspace(*q))\n                q++;\n\n            if (av_strncasecmp(q, \"stream-switch-entry=\", 20) == 0) {\n                int stream_no;\n                int rate_no;\n\n                q += 20;\n\n                memset(rates, 0xff, ratelen);\n\n                while (1) {\n                    while (*q && *q != '\\n' && *q != ':')\n                        q++;\n\n                    if (sscanf(q, \":%d:%d\", &stream_no, &rate_no) != 2)\n                        break;\n\n                    stream_no--;\n                    if (stream_no < ratelen && stream_no >= 0)\n                        rates[stream_no] = rate_no;\n\n                    while (*q && *q != '\\n' && !av_isspace(*q))\n                        q++;\n                }\n\n                return 1;\n            }\n        }\n        p = strchr(p, '\\n');\n        if (!p)\n            break;\n\n        p++;\n    }\n\n    return 0;\n}\n\nstatic int find_stream_in_feed(FFServerStream *feed, AVCodecParameters *codec,\n                               int bit_rate)\n{\n    int i;\n    int best_bitrate = 100000000;\n    int best = -1;\n\n    for (i = 0; i < feed->nb_streams; i++) {\n        AVCodecParameters *feed_codec = feed->streams[i]->codecpar;\n\n        if (feed_codec->codec_id != codec->codec_id ||\n            feed_codec->sample_rate != codec->sample_rate ||\n            feed_codec->width != codec->width ||\n            feed_codec->height != codec->height)\n            continue;\n\n        /* Potential stream */\n\n        /* We want the fastest stream less than bit_rate, or the slowest\n         * faster than bit_rate\n         */\n\n        if (feed_codec->bit_rate <= bit_rate) {\n            if (best_bitrate > bit_rate ||\n                feed_codec->bit_rate > best_bitrate) {\n                best_bitrate = feed_codec->bit_rate;\n                best = i;\n            }\n            continue;\n        }\n        if (feed_codec->bit_rate < best_bitrate) {\n            best_bitrate = feed_codec->bit_rate;\n            best = i;\n        }\n    }\n    return best;\n}\n\nstatic int modify_current_stream(HTTPContext *c, char *rates)\n{\n    int i;\n    FFServerStream *req = c->stream;\n    int action_required = 0;\n\n    /* Not much we can do for a feed */\n    if (!req->feed)\n        return 0;\n\n    for (i = 0; i < req->nb_streams; i++) {\n        AVCodecParameters *codec = req->streams[i]->codecpar;\n\n        switch(rates[i]) {\n            case 0:\n                c->switch_feed_streams[i] = req->feed_streams[i];\n                break;\n            case 1:\n                c->switch_feed_streams[i] = find_stream_in_feed(req->feed, codec, codec->bit_rate / 2);\n                break;\n            case 2:\n                /* Wants off or slow */\n                c->switch_feed_streams[i] = find_stream_in_feed(req->feed, codec, codec->bit_rate / 4);\n#ifdef WANTS_OFF\n                /* This doesn't work well when it turns off the only stream! */\n                c->switch_feed_streams[i] = -2;\n                c->feed_streams[i] = -2;\n#endif\n                break;\n        }\n\n        if (c->switch_feed_streams[i] >= 0 &&\n            c->switch_feed_streams[i] != c->feed_streams[i]) {\n            action_required = 1;\n        }\n    }\n\n    return action_required;\n}\n\nstatic void get_word(char *buf, int buf_size, const char **pp)\n{\n    const char *p;\n    char *q;\n\n#define SPACE_CHARS \" \\t\\r\\n\"\n\n    p = *pp;\n    p += strspn(p, SPACE_CHARS);\n    q = buf;\n    while (!av_isspace(*p) && *p != '\\0') {\n        if ((q - buf) < buf_size - 1)\n            *q++ = *p;\n        p++;\n    }\n    if (buf_size > 0)\n        *q = '\\0';\n    *pp = p;\n}\n\nstatic FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream,\n                                               HTTPContext *c)\n{\n    FILE* f;\n    char line[1024];\n    char  cmd[1024];\n    FFServerIPAddressACL *acl = NULL;\n    int line_num = 0;\n    const char *p;\n\n    f = fopen(stream->dynamic_acl, \"r\");\n    if (!f) {\n        perror(stream->dynamic_acl);\n        return NULL;\n    }\n\n    acl = av_mallocz(sizeof(FFServerIPAddressACL));\n    if (!acl) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* Build ACL */\n    while (fgets(line, sizeof(line), f)) {\n        line_num++;\n        p = line;\n        while (av_isspace(*p))\n            p++;\n        if (*p == '\\0' || *p == '#')\n            continue;\n        ffserver_get_arg(cmd, sizeof(cmd), &p);\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl,\n                                   line_num);\n    }\n    fclose(f);\n    return acl;\n}\n\n\nstatic void free_acl_list(FFServerIPAddressACL *in_acl)\n{\n    FFServerIPAddressACL *pacl, *pacl2;\n\n    pacl = in_acl;\n    while(pacl) {\n        pacl2 = pacl;\n        pacl = pacl->next;\n        av_freep(pacl2);\n    }\n}\n\nstatic int validate_acl_list(FFServerIPAddressACL *in_acl, HTTPContext *c)\n{\n    enum FFServerIPAddressAction last_action = IP_DENY;\n    FFServerIPAddressACL *acl;\n    struct in_addr *src = &c->from_addr.sin_addr;\n    unsigned long src_addr = src->s_addr;\n\n    for (acl = in_acl; acl; acl = acl->next) {\n        if (src_addr >= acl->first.s_addr && src_addr <= acl->last.s_addr)\n            return (acl->action == IP_ALLOW) ? 1 : 0;\n        last_action = acl->action;\n    }\n\n    /* Nothing matched, so return not the last action */\n    return (last_action == IP_DENY) ? 1 : 0;\n}\n\nstatic int validate_acl(FFServerStream *stream, HTTPContext *c)\n{\n    int ret = 0;\n    FFServerIPAddressACL *acl;\n\n    /* if stream->acl is null validate_acl_list will return 1 */\n    ret = validate_acl_list(stream->acl, c);\n\n    if (stream->dynamic_acl[0]) {\n        acl = parse_dynamic_acl(stream, c);\n        ret = validate_acl_list(acl, c);\n        free_acl_list(acl);\n    }\n\n    return ret;\n}\n\n/**\n * compute the real filename of a file by matching it without its\n * extensions to all the stream's filenames\n */\nstatic void compute_real_filename(char *filename, int max_size)\n{\n    char file1[1024];\n    char file2[1024];\n    char *p;\n    FFServerStream *stream;\n\n    av_strlcpy(file1, filename, sizeof(file1));\n    p = strrchr(file1, '.');\n    if (p)\n        *p = '\\0';\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        av_strlcpy(file2, stream->filename, sizeof(file2));\n        p = strrchr(file2, '.');\n        if (p)\n            *p = '\\0';\n        if (!strcmp(file1, file2)) {\n            av_strlcpy(filename, stream->filename, max_size);\n            break;\n        }\n    }\n}\n\nenum RedirType {\n    REDIR_NONE,\n    REDIR_ASX,\n    REDIR_RAM,\n    REDIR_ASF,\n    REDIR_RTSP,\n    REDIR_SDP,\n};\n\n/* parse HTTP request and prepare header */\nstatic int http_parse_request(HTTPContext *c)\n{\n    const char *p;\n    char *p1;\n    enum RedirType redir_type;\n    char cmd[32];\n    char info[1024], filename[1024];\n    char url[1024], *q;\n    char protocol[32];\n    char msg[1024];\n    char *encoded_msg = NULL;\n    const char *mime_type;\n    FFServerStream *stream;\n    int i;\n    char ratebuf[32];\n    const char *useragent = 0;\n\n    p = c->buffer;\n    get_word(cmd, sizeof(cmd), &p);\n    av_strlcpy(c->method, cmd, sizeof(c->method));\n\n    if (!strcmp(cmd, \"GET\"))\n        c->post = 0;\n    else if (!strcmp(cmd, \"POST\"))\n        c->post = 1;\n    else\n        return -1;\n\n    get_word(url, sizeof(url), &p);\n    av_strlcpy(c->url, url, sizeof(c->url));\n\n    get_word(protocol, sizeof(protocol), (const char **)&p);\n    if (strcmp(protocol, \"HTTP/1.0\") && strcmp(protocol, \"HTTP/1.1\"))\n        return -1;\n\n    av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n\n    if (config.debug)\n        http_log(\"%s - - New connection: %s %s\\n\",\n                 inet_ntoa(c->from_addr.sin_addr), cmd, url);\n\n    /* find the filename and the optional info string in the request */\n    p1 = strchr(url, '?');\n    if (p1) {\n        av_strlcpy(info, p1, sizeof(info));\n        *p1 = '\\0';\n    } else\n        info[0] = '\\0';\n\n    av_strlcpy(filename, url + ((*url == '/') ? 1 : 0), sizeof(filename)-1);\n\n    for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n        if (av_strncasecmp(p, \"User-Agent:\", 11) == 0) {\n            useragent = p + 11;\n            if (*useragent && *useragent != '\\n' && av_isspace(*useragent))\n                useragent++;\n            break;\n        }\n        p = strchr(p, '\\n');\n        if (!p)\n            break;\n\n        p++;\n    }\n\n    redir_type = REDIR_NONE;\n    if (av_match_ext(filename, \"asx\")) {\n        redir_type = REDIR_ASX;\n        filename[strlen(filename)-1] = 'f';\n    } else if (av_match_ext(filename, \"asf\") &&\n        (!useragent || av_strncasecmp(useragent, \"NSPlayer\", 8))) {\n        /* if this isn't WMP or lookalike, return the redirector file */\n        redir_type = REDIR_ASF;\n    } else if (av_match_ext(filename, \"rpm,ram\")) {\n        redir_type = REDIR_RAM;\n        strcpy(filename + strlen(filename)-2, \"m\");\n    } else if (av_match_ext(filename, \"rtsp\")) {\n        redir_type = REDIR_RTSP;\n        compute_real_filename(filename, sizeof(filename) - 1);\n    } else if (av_match_ext(filename, \"sdp\")) {\n        redir_type = REDIR_SDP;\n        compute_real_filename(filename, sizeof(filename) - 1);\n    }\n\n    /* \"redirect\" request to index.html */\n    if (!strlen(filename))\n        av_strlcpy(filename, \"index.html\", sizeof(filename) - 1);\n\n    stream = config.first_stream;\n    while (stream) {\n        if (!strcmp(stream->filename, filename) && validate_acl(stream, c))\n            break;\n        stream = stream->next;\n    }\n    if (!stream) {\n        snprintf(msg, sizeof(msg), \"File '%s' not found\", url);\n        http_log(\"File '%s' not found\\n\", url);\n        goto send_error;\n    }\n\n    c->stream = stream;\n    memcpy(c->feed_streams, stream->feed_streams, sizeof(c->feed_streams));\n    memset(c->switch_feed_streams, -1, sizeof(c->switch_feed_streams));\n\n    if (stream->stream_type == STREAM_TYPE_REDIRECT) {\n        c->http_error = 301;\n        q = c->buffer;\n        snprintf(q, c->buffer_size,\n                      \"HTTP/1.0 301 Moved\\r\\n\"\n                      \"Location: %s\\r\\n\"\n                      \"Content-type: text/html\\r\\n\"\n                      \"\\r\\n\"\n                      \"<!DOCTYPE html>\\n\"\n                      \"<html><head><title>Moved</title></head><body>\\r\\n\"\n                      \"You should be <a href=\\\"%s\\\">redirected</a>.\\r\\n\"\n                      \"</body></html>\\r\\n\",\n                 stream->feed_filename, stream->feed_filename);\n        q += strlen(q);\n        /* prepare output buffer */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = q;\n        c->state = HTTPSTATE_SEND_HEADER;\n        return 0;\n    }\n\n    /* If this is WMP, get the rate information */\n    if (extract_rates(ratebuf, sizeof(ratebuf), c->buffer)) {\n        if (modify_current_stream(c, ratebuf)) {\n            for (i = 0; i < FF_ARRAY_ELEMS(c->feed_streams); i++) {\n                if (c->switch_feed_streams[i] >= 0)\n                    c->switch_feed_streams[i] = -1;\n            }\n        }\n    }\n\n    if (c->post == 0 && stream->stream_type == STREAM_TYPE_LIVE)\n        current_bandwidth += stream->bandwidth;\n\n    /* If already streaming this feed, do not let another feeder start */\n    if (stream->feed_opened) {\n        snprintf(msg, sizeof(msg), \"This feed is already being received.\");\n        http_log(\"Feed '%s' already being received\\n\", stream->feed_filename);\n        goto send_error;\n    }\n\n    if (c->post == 0 && config.max_bandwidth < current_bandwidth) {\n        c->http_error = 503;\n        q = c->buffer;\n        snprintf(q, c->buffer_size,\n                      \"HTTP/1.0 503 Server too busy\\r\\n\"\n                      \"Content-type: text/html\\r\\n\"\n                      \"\\r\\n\"\n                      \"<!DOCTYPE html>\\n\"\n                      \"<html><head><title>Too busy</title></head><body>\\r\\n\"\n                      \"<p>The server is too busy to serve your request at \"\n                      \"this time.</p>\\r\\n\"\n                      \"<p>The bandwidth being served (including your stream) \"\n                      \"is %\"PRIu64\"kbit/s, and this exceeds the limit of \"\n                      \"%\"PRIu64\"kbit/s.</p>\\r\\n\"\n                      \"</body></html>\\r\\n\",\n                 current_bandwidth, config.max_bandwidth);\n        q += strlen(q);\n        /* prepare output buffer */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = q;\n        c->state = HTTPSTATE_SEND_HEADER;\n        return 0;\n    }\n\n    if (redir_type != REDIR_NONE) {\n        const char *hostinfo = 0;\n\n        for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n            if (av_strncasecmp(p, \"Host:\", 5) == 0) {\n                hostinfo = p + 5;\n                break;\n            }\n            p = strchr(p, '\\n');\n            if (!p)\n                break;\n\n            p++;\n        }\n\n        if (hostinfo) {\n            char *eoh;\n            char hostbuf[260];\n\n            while (av_isspace(*hostinfo))\n                hostinfo++;\n\n            eoh = strchr(hostinfo, '\\n');\n            if (eoh) {\n                if (eoh[-1] == '\\r')\n                    eoh--;\n\n                if (eoh - hostinfo < sizeof(hostbuf) - 1) {\n                    memcpy(hostbuf, hostinfo, eoh - hostinfo);\n                    hostbuf[eoh - hostinfo] = 0;\n\n                    c->http_error = 200;\n                    q = c->buffer;\n                    switch(redir_type) {\n                    case REDIR_ASX:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 ASX Follows\\r\\n\"\n                                      \"Content-type: video/x-ms-asf\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"<ASX Version=\\\"3\\\">\\r\\n\"\n                                      //\"<!-- Autogenerated by ffserver -->\\r\\n\"\n                                      \"<ENTRY><REF HREF=\\\"http://%s/%s%s\\\"/></ENTRY>\\r\\n\"\n                                      \"</ASX>\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_RAM:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 RAM Follows\\r\\n\"\n                                      \"Content-type: audio/x-pn-realaudio\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"# Autogenerated by ffserver\\r\\n\"\n                                      \"http://%s/%s%s\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_ASF:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 ASF Redirect follows\\r\\n\"\n                                      \"Content-type: video/x-ms-asf\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"[Reference]\\r\\n\"\n                                      \"Ref1=http://%s/%s%s\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_RTSP:\n                        {\n                            char hostname[256], *p;\n                            /* extract only hostname */\n                            av_strlcpy(hostname, hostbuf, sizeof(hostname));\n                            p = strrchr(hostname, ':');\n                            if (p)\n                                *p = '\\0';\n                            snprintf(q, c->buffer_size,\n                                          \"HTTP/1.0 200 RTSP Redirect follows\\r\\n\"\n                                          /* XXX: incorrect MIME type ? */\n                                          \"Content-type: application/x-rtsp\\r\\n\"\n                                          \"\\r\\n\"\n                                          \"rtsp://%s:%d/%s\\r\\n\", hostname, ntohs(config.rtsp_addr.sin_port), filename);\n                            q += strlen(q);\n                        }\n                        break;\n                    case REDIR_SDP:\n                        {\n                            uint8_t *sdp_data;\n                            int sdp_data_size;\n                            socklen_t len;\n                            struct sockaddr_in my_addr;\n\n                            snprintf(q, c->buffer_size,\n                                          \"HTTP/1.0 200 OK\\r\\n\"\n                                          \"Content-type: application/sdp\\r\\n\"\n                                          \"\\r\\n\");\n                            q += strlen(q);\n\n                            len = sizeof(my_addr);\n\n                            /* XXX: Should probably fail? */\n                            if (getsockname(c->fd, (struct sockaddr *)&my_addr, &len))\n                                http_log(\"getsockname() failed\\n\");\n\n                            /* XXX: should use a dynamic buffer */\n                            sdp_data_size = prepare_sdp_description(stream,\n                                                                    &sdp_data,\n                                                                    my_addr.sin_addr);\n                            if (sdp_data_size > 0) {\n                                memcpy(q, sdp_data, sdp_data_size);\n                                q += sdp_data_size;\n                                *q = '\\0';\n                                av_freep(&sdp_data);\n                            }\n                        }\n                        break;\n                    default:\n                        abort();\n                        break;\n                    }\n\n                    /* prepare output buffer */\n                    c->buffer_ptr = c->buffer;\n                    c->buffer_end = q;\n                    c->state = HTTPSTATE_SEND_HEADER;\n                    return 0;\n                }\n            }\n        }\n\n        snprintf(msg, sizeof(msg), \"ASX/RAM file not handled\");\n        goto send_error;\n    }\n\n    stream->conns_served++;\n\n    /* XXX: add there authenticate and IP match */\n\n    if (c->post) {\n        /* if post, it means a feed is being sent */\n        if (!stream->is_feed) {\n            /* However it might be a status report from WMP! Let us log the\n             * data as it might come handy one day. */\n            const char *logline = 0;\n            int client_id = 0;\n\n            for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n                if (av_strncasecmp(p, \"Pragma: log-line=\", 17) == 0) {\n                    logline = p;\n                    break;\n                }\n                if (av_strncasecmp(p, \"Pragma: client-id=\", 18) == 0)\n                    client_id = strtol(p + 18, 0, 10);\n                p = strchr(p, '\\n');\n                if (!p)\n                    break;\n\n                p++;\n            }\n\n            if (logline) {\n                char *eol = strchr(logline, '\\n');\n\n                logline += 17;\n\n                if (eol) {\n                    if (eol[-1] == '\\r')\n                        eol--;\n                    http_log(\"%.*s\\n\", (int) (eol - logline), logline);\n                    c->suppress_log = 1;\n                }\n            }\n\n#ifdef DEBUG\n            http_log(\"\\nGot request:\\n%s\\n\", c->buffer);\n#endif\n\n            if (client_id && extract_rates(ratebuf, sizeof(ratebuf), c->buffer)) {\n                HTTPContext *wmpc;\n\n                /* Now we have to find the client_id */\n                for (wmpc = first_http_ctx; wmpc; wmpc = wmpc->next) {\n                    if (wmpc->wmp_client_id == client_id)\n                        break;\n                }\n\n                if (wmpc && modify_current_stream(wmpc, ratebuf))\n                    wmpc->switch_pending = 1;\n            }\n\n            snprintf(msg, sizeof(msg), \"POST command not handled\");\n            c->stream = 0;\n            goto send_error;\n        }\n        if (http_start_receive_data(c) < 0) {\n            snprintf(msg, sizeof(msg), \"could not open feed\");\n            goto send_error;\n        }\n        c->http_error = 0;\n        c->state = HTTPSTATE_RECEIVE_DATA;\n        return 0;\n    }\n\n#ifdef DEBUG\n    if (strcmp(stream->filename + strlen(stream->filename) - 4, \".asf\") == 0)\n        http_log(\"\\nGot request:\\n%s\\n\", c->buffer);\n#endif\n\n    if (c->stream->stream_type == STREAM_TYPE_STATUS)\n        goto send_status;\n\n    /* open input stream */\n    if (open_input_stream(c, info) < 0) {\n        snprintf(msg, sizeof(msg), \"Input stream corresponding to '%s' not found\", url);\n        goto send_error;\n    }\n\n    /* prepare HTTP header */\n    c->buffer[0] = 0;\n    av_strlcatf(c->buffer, c->buffer_size, \"HTTP/1.0 200 OK\\r\\n\");\n    mime_type = c->stream->fmt->mime_type;\n    if (!mime_type)\n        mime_type = \"application/x-octet-stream\";\n    av_strlcatf(c->buffer, c->buffer_size, \"Pragma: no-cache\\r\\n\");\n\n    /* for asf, we need extra headers */\n    if (!strcmp(c->stream->fmt->name,\"asf_stream\")) {\n        /* Need to allocate a client id */\n\n        c->wmp_client_id = av_lfg_get(&random_state);\n\n        av_strlcatf(c->buffer, c->buffer_size, \"Server: Cougar 4.1.0.3923\\r\\nCache-Control: no-cache\\r\\nPragma: client-id=%d\\r\\nPragma: features=\\\"broadcast\\\"\\r\\n\", c->wmp_client_id);\n    }\n    av_strlcatf(c->buffer, c->buffer_size, \"Content-Type: %s\\r\\n\", mime_type);\n    av_strlcatf(c->buffer, c->buffer_size, \"\\r\\n\");\n    q = c->buffer + strlen(c->buffer);\n\n    /* prepare output buffer */\n    c->http_error = 0;\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = q;\n    c->state = HTTPSTATE_SEND_HEADER;\n    return 0;\n send_error:\n    c->http_error = 404;\n    q = c->buffer;\n    if (!htmlencode(msg, &encoded_msg)) {\n        http_log(\"Could not encode filename '%s' as HTML\\n\", msg);\n    }\n    snprintf(q, c->buffer_size,\n                  \"HTTP/1.0 404 Not Found\\r\\n\"\n                  \"Content-type: text/html\\r\\n\"\n                  \"\\r\\n\"\n                  \"<!DOCTYPE html>\\n\"\n                  \"<html>\\n\"\n                  \"<head>\\n\"\n                  \"<meta charset=\\\"UTF-8\\\">\\n\"\n                  \"<title>404 Not Found</title>\\n\"\n                  \"</head>\\n\"\n                  \"<body>%s</body>\\n\"\n                  \"</html>\\n\", encoded_msg? encoded_msg : \"File not found\");\n    q += strlen(q);\n    /* prepare output buffer */\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = q;\n    c->state = HTTPSTATE_SEND_HEADER;\n    av_freep(&encoded_msg);\n    return 0;\n send_status:\n    compute_status(c);\n    /* horrible: we use this value to avoid\n     * going to the send data state */\n    c->http_error = 200;\n    c->state = HTTPSTATE_SEND_HEADER;\n    return 0;\n}\n\nstatic void fmt_bytecount(AVIOContext *pb, int64_t count)\n{\n    static const char suffix[] = \" kMGTP\";\n    const char *s;\n\n    for (s = suffix; count >= 100000 && s[1]; count /= 1000, s++);\n\n    avio_printf(pb, \"%\"PRId64\"%c\", count, *s);\n}\n\nstatic inline void print_stream_params(AVIOContext *pb, FFServerStream *stream)\n{\n    int i, stream_no;\n    const char *type = \"unknown\";\n    char parameters[64];\n    LayeredAVStream *st;\n    AVCodec *codec;\n\n    stream_no = stream->nb_streams;\n\n    avio_printf(pb, \"<table><tr><th>Stream<th>\"\n                    \"type<th>kbit/s<th>codec<th>\"\n                    \"Parameters\\n\");\n\n    for (i = 0; i < stream_no; i++) {\n        st = stream->streams[i];\n        codec = avcodec_find_encoder(st->codecpar->codec_id);\n\n        parameters[0] = 0;\n\n        switch(st->codecpar->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            type = \"audio\";\n            snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\",\n                     st->codecpar->channels, st->codecpar->sample_rate);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            type = \"video\";\n            snprintf(parameters, sizeof(parameters),\n                     \"%dx%d, q=%d-%d, fps=%d\", st->codecpar->width,\n                     st->codecpar->height, st->codec->qmin, st->codec->qmax,\n                     st->time_base.den / st->time_base.num);\n            break;\n        default:\n            abort();\n        }\n\n        avio_printf(pb, \"<tr><td>%d<td>%s<td>%\"PRId64\n                        \"<td>%s<td>%s\\n\",\n                    i, type, (int64_t)st->codecpar->bit_rate/1000,\n                    codec ? codec->name : \"\", parameters);\n     }\n\n     avio_printf(pb, \"</table>\\n\");\n}\n\nstatic void clean_html(char *clean, int clean_len, char *dirty)\n{\n    int i, o;\n\n    for (o = i = 0; o+10 < clean_len && dirty[i];) {\n        int len = strspn(dirty+i, \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$-_.+!*(),?/ :;%\");\n        if (len) {\n            if (o + len >= clean_len)\n                break;\n            memcpy(clean + o, dirty + i, len);\n            i += len;\n            o += len;\n        } else {\n            int c = dirty[i++];\n            switch (c) {\n            case  '&': av_strlcat(clean+o, \"&amp;\"  , clean_len - o); break;\n            case  '<': av_strlcat(clean+o, \"&lt;\"   , clean_len - o); break;\n            case  '>': av_strlcat(clean+o, \"&gt;\"   , clean_len - o); break;\n            case '\\'': av_strlcat(clean+o, \"&apos;\" , clean_len - o); break;\n            case '\\\"': av_strlcat(clean+o, \"&quot;\" , clean_len - o); break;\n            default:   av_strlcat(clean+o, \"&#9785;\", clean_len - o); break;\n            }\n            o += strlen(clean+o);\n        }\n    }\n    clean[o] = 0;\n}\n\nstatic void compute_status(HTTPContext *c)\n{\n    HTTPContext *c1;\n    FFServerStream *stream;\n    char *p;\n    time_t ti;\n    int i, len;\n    AVIOContext *pb;\n\n    if (avio_open_dyn_buf(&pb) < 0) {\n        /* XXX: return an error ? */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = c->buffer;\n        return;\n    }\n\n    avio_printf(pb, \"HTTP/1.0 200 OK\\r\\n\");\n    avio_printf(pb, \"Content-type: text/html\\r\\n\");\n    avio_printf(pb, \"Pragma: no-cache\\r\\n\");\n    avio_printf(pb, \"\\r\\n\");\n\n    avio_printf(pb, \"<!DOCTYPE html>\\n\");\n    avio_printf(pb, \"<html><head><title>%s Status</title>\\n\", program_name);\n    if (c->stream->feed_filename[0])\n        avio_printf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\",\n                    c->stream->feed_filename);\n    avio_printf(pb, \"</head>\\n<body>\");\n    avio_printf(pb, \"<h1>%s Status</h1>\\n\", program_name);\n    /* format status */\n    avio_printf(pb, \"<h2>Available Streams</h2>\\n\");\n    avio_printf(pb, \"<table>\\n\");\n    avio_printf(pb, \"<tr><th>Path<th>Served<br>Conns<th><br>bytes<th>Format<th>Bit rate<br>kbit/s<th>Video<br>kbit/s<th><br>Codec<th>Audio<br>kbit/s<th><br>Codec<th>Feed\\n\");\n    stream = config.first_stream;\n    while (stream) {\n        char sfilename[1024];\n        char *eosf;\n\n        if (stream->feed == stream) {\n            stream = stream->next;\n            continue;\n        }\n\n        av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n        eosf = sfilename + strlen(sfilename);\n        if (eosf - sfilename >= 4) {\n            if (strcmp(eosf - 4, \".asf\") == 0)\n                strcpy(eosf - 4, \".asx\");\n            else if (strcmp(eosf - 3, \".rm\") == 0)\n                strcpy(eosf - 3, \".ram\");\n            else if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n                /* generate a sample RTSP director if\n                 * unicast. Generate an SDP redirector if\n                 * multicast */\n                eosf = strrchr(sfilename, '.');\n                if (!eosf)\n                    eosf = sfilename + strlen(sfilename);\n                if (stream->is_multicast)\n                    strcpy(eosf, \".sdp\");\n                else\n                    strcpy(eosf, \".rtsp\");\n            }\n        }\n\n        avio_printf(pb, \"<tr><td><a href=\\\"/%s\\\">%s</a> \",\n                    sfilename, stream->filename);\n        avio_printf(pb, \"<td> %d <td> \",\n                    stream->conns_served);\n        // TODO: Investigate if we can make http bitexact so it always produces the same count of bytes\n        if (!config.bitexact)\n            fmt_bytecount(pb, stream->bytes_served);\n\n        switch(stream->stream_type) {\n        case STREAM_TYPE_LIVE: {\n            int audio_bit_rate = 0;\n            int video_bit_rate = 0;\n            const char *audio_codec_name = \"\";\n            const char *video_codec_name = \"\";\n            const char *audio_codec_name_extra = \"\";\n            const char *video_codec_name_extra = \"\";\n\n            for(i=0;i<stream->nb_streams;i++) {\n                LayeredAVStream *st = stream->streams[i];\n                AVCodec *codec = avcodec_find_encoder(st->codecpar->codec_id);\n\n                switch(st->codecpar->codec_type) {\n                case AVMEDIA_TYPE_AUDIO:\n                    audio_bit_rate += st->codecpar->bit_rate;\n                    if (codec) {\n                        if (*audio_codec_name)\n                            audio_codec_name_extra = \"...\";\n                        audio_codec_name = codec->name;\n                    }\n                    break;\n                case AVMEDIA_TYPE_VIDEO:\n                    video_bit_rate += st->codecpar->bit_rate;\n                    if (codec) {\n                        if (*video_codec_name)\n                            video_codec_name_extra = \"...\";\n                        video_codec_name = codec->name;\n                    }\n                    break;\n                case AVMEDIA_TYPE_DATA:\n                    video_bit_rate += st->codecpar->bit_rate;\n                    break;\n                default:\n                    abort();\n                }\n            }\n\n            avio_printf(pb, \"<td> %s <td> %d <td> %d <td> %s %s <td> \"\n                            \"%d <td> %s %s\",\n                        stream->fmt->name, stream->bandwidth,\n                        video_bit_rate / 1000, video_codec_name,\n                        video_codec_name_extra, audio_bit_rate / 1000,\n                        audio_codec_name, audio_codec_name_extra);\n\n            if (stream->feed)\n                avio_printf(pb, \"<td>%s\", stream->feed->filename);\n            else\n                avio_printf(pb, \"<td>%s\", stream->feed_filename);\n            avio_printf(pb, \"\\n\");\n        }\n            break;\n        default:\n            avio_printf(pb, \"<td> - <td> - \"\n                            \"<td> - <td><td> - <td>\\n\");\n            break;\n        }\n        stream = stream->next;\n    }\n    avio_printf(pb, \"</table>\\n\");\n\n    stream = config.first_stream;\n    while (stream) {\n\n        if (stream->feed != stream) {\n            stream = stream->next;\n            continue;\n        }\n\n        avio_printf(pb, \"<h2>Feed %s</h2>\", stream->filename);\n        if (stream->pid) {\n            avio_printf(pb, \"Running as pid %\"PRId64\".\\n\", (int64_t) stream->pid);\n\n#if defined(linux)\n            {\n                FILE *pid_stat;\n                char ps_cmd[64];\n\n                /* This is somewhat linux specific I guess */\n                snprintf(ps_cmd, sizeof(ps_cmd),\n                         \"ps -o \\\"%%cpu,cputime\\\" --no-headers %\"PRId64\"\",\n                         (int64_t) stream->pid);\n\n                 pid_stat = popen(ps_cmd, \"r\");\n                 if (pid_stat) {\n                     char cpuperc[10];\n                     char cpuused[64];\n\n                     if (fscanf(pid_stat, \"%9s %63s\", cpuperc, cpuused) == 2) {\n                         avio_printf(pb, \"Currently using %s%% of the cpu. \"\n                                         \"Total time used %s.\\n\",\n                                     cpuperc, cpuused);\n                     }\n                     fclose(pid_stat);\n                 }\n            }\n#endif\n\n            avio_printf(pb, \"<p>\");\n        }\n\n        print_stream_params(pb, stream);\n        stream = stream->next;\n    }\n\n    /* connection status */\n    avio_printf(pb, \"<h2>Connection Status</h2>\\n\");\n\n    avio_printf(pb, \"Number of connections: %d / %d<br>\\n\",\n                nb_connections, config.nb_max_connections);\n\n    avio_printf(pb, \"Bandwidth in use: %\"PRIu64\"k / %\"PRIu64\"k<br>\\n\",\n                current_bandwidth, config.max_bandwidth);\n\n    avio_printf(pb, \"<table>\\n\");\n    avio_printf(pb, \"<tr><th>#<th>File<th>IP<th>URL<th>Proto<th>State<th>Target \"\n                    \"bit/s<th>Actual bit/s<th>Bytes transferred\\n\");\n    c1 = first_http_ctx;\n    i = 0;\n    while (c1) {\n        int bitrate;\n        int j;\n\n        bitrate = 0;\n        if (c1->stream) {\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n                if (!c1->stream->feed)\n                    bitrate += c1->stream->streams[j]->codecpar->bit_rate;\n                else if (c1->feed_streams[j] >= 0)\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codecpar->bit_rate;\n            }\n        }\n\n        i++;\n        p = inet_ntoa(c1->from_addr.sin_addr);\n        clean_html(c1->clean_url, sizeof(c1->clean_url), c1->url);\n        avio_printf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td>%s\"\n                        \"<td>\",\n                    i, c1->stream ? c1->stream->filename : \"\",\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n                    p,\n                    c1->clean_url,\n                    c1->protocol, http_state[c1->state]);\n        fmt_bytecount(pb, bitrate);\n        avio_printf(pb, \"<td>\");\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n        avio_printf(pb, \"<td>\");\n        fmt_bytecount(pb, c1->data_count);\n        avio_printf(pb, \"\\n\");\n        c1 = c1->next;\n    }\n    avio_printf(pb, \"</table>\\n\");\n\n    if (!config.bitexact) {\n        /* date */\n        ti = time(NULL);\n        p = ctime(&ti);\n        avio_printf(pb, \"<hr>Generated at %s\", p);\n    }\n    avio_printf(pb, \"</body>\\n</html>\\n\");\n\n    len = avio_close_dyn_buf(pb, &c->pb_buffer);\n    c->buffer_ptr = c->pb_buffer;\n    c->buffer_end = c->pb_buffer + len;\n}\n\nstatic int open_input_stream(HTTPContext *c, const char *info)\n{\n    char buf[128];\n    char input_filename[1024];\n    AVFormatContext *s = NULL;\n    int buf_size, i, ret;\n    int64_t stream_pos;\n\n    /* find file name */\n    if (c->stream->feed) {\n        strcpy(input_filename, c->stream->feed->feed_filename);\n        buf_size = FFM_PACKET_SIZE;\n        /* compute position (absolute time) */\n        if (av_find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            if ((ret = av_parse_time(&stream_pos, buf, 0)) < 0) {\n                http_log(\"Invalid date specification '%s' for stream\\n\", buf);\n                return ret;\n            }\n        } else if (av_find_info_tag(buf, sizeof(buf), \"buffer\", info)) {\n            int prebuffer = strtol(buf, 0, 10);\n            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;\n        } else\n            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;\n    } else {\n        strcpy(input_filename, c->stream->feed_filename);\n        buf_size = 0;\n        /* compute position (relative time) */\n        if (av_find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            if ((ret = av_parse_time(&stream_pos, buf, 1)) < 0) {\n                http_log(\"Invalid date specification '%s' for stream\\n\", buf);\n                return ret;\n            }\n        } else\n            stream_pos = 0;\n    }\n    if (!input_filename[0]) {\n        http_log(\"No filename was specified for stream\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* open stream */\n    ret = avformat_open_input(&s, input_filename, c->stream->ifmt,\n                              &c->stream->in_opts);\n    if (ret < 0) {\n        http_log(\"Could not open input '%s': %s\\n\",\n                 input_filename, av_err2str(ret));\n        return ret;\n    }\n\n    /* set buffer size */\n    if (buf_size > 0) {\n        ret = ffio_set_buf_size(s->pb, buf_size);\n        if (ret < 0) {\n            http_log(\"Failed to set buffer size\\n\");\n            return ret;\n        }\n    }\n\n    s->flags |= AVFMT_FLAG_GENPTS;\n    c->fmt_in = s;\n    if (strcmp(s->iformat->name, \"ffm\") &&\n        (ret = avformat_find_stream_info(c->fmt_in, NULL)) < 0) {\n        http_log(\"Could not find stream info for input '%s'\\n\", input_filename);\n        avformat_close_input(&s);\n        return ret;\n    }\n\n    /* choose stream as clock source (we favor the video stream if\n     * present) for packet sending */\n    c->pts_stream_index = 0;\n    for(i=0;i<c->stream->nb_streams;i++) {\n        if (c->pts_stream_index == 0 &&\n            c->stream->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n            c->pts_stream_index = i;\n        }\n    }\n\n    if (c->fmt_in->iformat->read_seek)\n        av_seek_frame(c->fmt_in, -1, stream_pos, 0);\n    /* set the start time (needed for maxtime and RTP packet timing) */\n    c->start_time = cur_time;\n    c->first_pts = AV_NOPTS_VALUE;\n    return 0;\n}\n\n/* return the server clock (in us) */\nstatic int64_t get_server_clock(HTTPContext *c)\n{\n    /* compute current pts value from system time */\n    return (cur_time - c->start_time) * 1000;\n}\n\n/* return the estimated time (in us) at which the current packet must be sent */\nstatic int64_t get_packet_send_clock(HTTPContext *c)\n{\n    int bytes_left, bytes_sent, frame_bytes;\n\n    frame_bytes = c->cur_frame_bytes;\n    if (frame_bytes <= 0)\n        return c->cur_pts;\n\n    bytes_left = c->buffer_end - c->buffer_ptr;\n    bytes_sent = frame_bytes - bytes_left;\n    return c->cur_pts + (c->cur_frame_duration * bytes_sent) / frame_bytes;\n}\n\n\nstatic int http_prepare_data(HTTPContext *c)\n{\n    int i, len, ret;\n    AVFormatContext *ctx;\n\n    av_freep(&c->pb_buffer);\n    switch(c->state) {\n    case HTTPSTATE_SEND_DATA_HEADER:\n        ctx = avformat_alloc_context();\n        if (!ctx)\n            return AVERROR(ENOMEM);\n        c->pfmt_ctx = ctx;\n        av_dict_copy(&(c->pfmt_ctx->metadata), c->stream->metadata, 0);\n\n        for(i=0;i<c->stream->nb_streams;i++) {\n            LayeredAVStream *src;\n            AVStream *st = avformat_new_stream(c->pfmt_ctx, NULL);\n            if (!st)\n                return AVERROR(ENOMEM);\n\n            /* if file or feed, then just take streams from FFServerStream\n             * struct */\n            if (!c->stream->feed ||\n                c->stream->feed == c->stream)\n                src = c->stream->streams[i];\n            else\n                src = c->stream->feed->streams[c->stream->feed_streams[i]];\n\n            unlayer_stream(c->pfmt_ctx->streams[i], src); //TODO we no longer copy st->internal, does this matter?\n            av_assert0(!c->pfmt_ctx->streams[i]->priv_data);\n\n            if (src->codec->flags & AV_CODEC_FLAG_BITEXACT)\n                c->pfmt_ctx->flags |= AVFMT_FLAG_BITEXACT;\n        }\n        /* set output format parameters */\n        c->pfmt_ctx->oformat = c->stream->fmt;\n        av_assert0(c->pfmt_ctx->nb_streams == c->stream->nb_streams);\n\n        c->got_key_frame = 0;\n\n        /* prepare header and save header data in a stream */\n        if (avio_open_dyn_buf(&c->pfmt_ctx->pb) < 0) {\n            /* XXX: potential leak */\n            return -1;\n        }\n        c->pfmt_ctx->pb->seekable = 0;\n\n        /*\n         * HACK to avoid MPEG-PS muxer to spit many underflow errors\n         * Default value from FFmpeg\n         * Try to set it using configuration option\n         */\n        c->pfmt_ctx->max_delay = (int)(0.7*AV_TIME_BASE);\n\n        if ((ret = avformat_write_header(c->pfmt_ctx, NULL)) < 0) {\n            http_log(\"Error writing output header for stream '%s': %s\\n\",\n                     c->stream->filename, av_err2str(ret));\n            return ret;\n        }\n        av_dict_free(&c->pfmt_ctx->metadata);\n\n        len = avio_close_dyn_buf(c->pfmt_ctx->pb, &c->pb_buffer);\n        c->buffer_ptr = c->pb_buffer;\n        c->buffer_end = c->pb_buffer + len;\n\n        c->state = HTTPSTATE_SEND_DATA;\n        c->last_packet_sent = 0;\n        break;\n    case HTTPSTATE_SEND_DATA:\n        /* find a new packet */\n        /* read a packet from the input stream */\n        if (c->stream->feed)\n            ffm_set_write_index(c->fmt_in,\n                                c->stream->feed->feed_write_index,\n                                c->stream->feed->feed_size);\n\n        if (c->stream->max_time &&\n            c->stream->max_time + c->start_time - cur_time < 0)\n            /* We have timed out */\n            c->state = HTTPSTATE_SEND_DATA_TRAILER;\n        else {\n            AVPacket pkt;\n        redo:\n            ret = av_read_frame(c->fmt_in, &pkt);\n            if (ret < 0) {\n                if (c->stream->feed) {\n                    /* if coming from feed, it means we reached the end of the\n                     * ffm file, so must wait for more data */\n                    c->state = HTTPSTATE_WAIT_FEED;\n                    return 1; /* state changed */\n                }\n                if (ret == AVERROR(EAGAIN)) {\n                    /* input not ready, come back later */\n                    return 0;\n                }\n                if (c->stream->loop) {\n                    avformat_close_input(&c->fmt_in);\n                    if (open_input_stream(c, \"\") < 0)\n                        goto no_loop;\n                    goto redo;\n                } else {\n                    no_loop:\n                        /* must send trailer now because EOF or error */\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n                }\n            } else {\n                int source_index = pkt.stream_index;\n                /* update first pts if needed */\n                if (c->first_pts == AV_NOPTS_VALUE && pkt.dts != AV_NOPTS_VALUE) {\n                    c->first_pts = av_rescale_q(pkt.dts, c->fmt_in->streams[pkt.stream_index]->time_base, AV_TIME_BASE_Q);\n                    c->start_time = cur_time;\n                }\n                /* send it to the appropriate stream */\n                if (c->stream->feed) {\n                    /* if coming from a feed, select the right stream */\n                    if (c->switch_pending) {\n                        c->switch_pending = 0;\n                        for(i=0;i<c->stream->nb_streams;i++) {\n                            if (c->switch_feed_streams[i] == pkt.stream_index)\n                                if (pkt.flags & AV_PKT_FLAG_KEY)\n                                    c->switch_feed_streams[i] = -1;\n                            if (c->switch_feed_streams[i] >= 0)\n                                c->switch_pending = 1;\n                        }\n                    }\n                    for(i=0;i<c->stream->nb_streams;i++) {\n                        if (c->stream->feed_streams[i] == pkt.stream_index) {\n                            AVStream *st = c->fmt_in->streams[source_index];\n                            pkt.stream_index = i;\n                            if (pkt.flags & AV_PKT_FLAG_KEY &&\n                                (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n                                 c->stream->nb_streams == 1))\n                                c->got_key_frame = 1;\n                            if (!c->stream->send_on_key || c->got_key_frame)\n                                goto send_it;\n                        }\n                    }\n                } else {\n                    AVStream *ist, *ost;\n                send_it:\n                    ist = c->fmt_in->streams[source_index];\n                    /* specific handling for RTP: we use several\n                     * output streams (one for each RTP connection).\n                     * XXX: need more abstract handling */\n                    if (c->is_packetized) {\n                        /* compute send time and duration */\n                        if (pkt.dts != AV_NOPTS_VALUE) {\n                            c->cur_pts = av_rescale_q(pkt.dts, ist->time_base, AV_TIME_BASE_Q);\n                            c->cur_pts -= c->first_pts;\n                        }\n                        c->cur_frame_duration = av_rescale_q(pkt.duration, ist->time_base, AV_TIME_BASE_Q);\n                        /* find RTP context */\n                        c->packet_stream_index = pkt.stream_index;\n                        ctx = c->rtp_ctx[c->packet_stream_index];\n                        if(!ctx) {\n                            av_packet_unref(&pkt);\n                            break;\n                        }\n                        /* only one stream per RTP connection */\n                        pkt.stream_index = 0;\n                    } else {\n                        ctx = c->pfmt_ctx;\n                        /* Fudge here */\n                    }\n\n                    if (c->is_packetized) {\n                        int max_packet_size;\n                        if (c->rtp_protocol == RTSP_LOWER_TRANSPORT_TCP)\n                            max_packet_size = RTSP_TCP_MAX_PACKET_SIZE;\n                        else\n                            max_packet_size = c->rtp_handles[c->packet_stream_index]->max_packet_size;\n                        ret = ffio_open_dyn_packet_buf(&ctx->pb,\n                                                       max_packet_size);\n                    } else\n                        ret = avio_open_dyn_buf(&ctx->pb);\n\n                    if (ret < 0) {\n                        /* XXX: potential leak */\n                        return -1;\n                    }\n                    ost = ctx->streams[pkt.stream_index];\n\n                    ctx->pb->seekable = 0;\n                    if (pkt.dts != AV_NOPTS_VALUE)\n                        pkt.dts = av_rescale_q(pkt.dts, ist->time_base,\n                                               ost->time_base);\n                    if (pkt.pts != AV_NOPTS_VALUE)\n                        pkt.pts = av_rescale_q(pkt.pts, ist->time_base,\n                                               ost->time_base);\n                    pkt.duration = av_rescale_q(pkt.duration, ist->time_base,\n                                                ost->time_base);\n                    if ((ret = av_write_frame(ctx, &pkt)) < 0) {\n                        http_log(\"Error writing frame to output for stream '%s': %s\\n\",\n                                 c->stream->filename, av_err2str(ret));\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n                    }\n\n                    av_freep(&c->pb_buffer);\n                    len = avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n                    ctx->pb = NULL;\n                    c->cur_frame_bytes = len;\n                    c->buffer_ptr = c->pb_buffer;\n                    c->buffer_end = c->pb_buffer + len;\n\n                    if (len == 0) {\n                        av_packet_unref(&pkt);\n                        goto redo;\n                    }\n                }\n                av_packet_unref(&pkt);\n            }\n        }\n        break;\n    default:\n    case HTTPSTATE_SEND_DATA_TRAILER:\n        /* last packet test ? */\n        if (c->last_packet_sent || c->is_packetized)\n            return -1;\n        ctx = c->pfmt_ctx;\n        /* prepare header */\n        if (avio_open_dyn_buf(&ctx->pb) < 0) {\n            /* XXX: potential leak */\n            return -1;\n        }\n        c->pfmt_ctx->pb->seekable = 0;\n        av_write_trailer(ctx);\n        len = avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n        c->buffer_ptr = c->pb_buffer;\n        c->buffer_end = c->pb_buffer + len;\n\n        c->last_packet_sent = 1;\n        break;\n    }\n    return 0;\n}\n\n/* should convert the format at the same time */\n/* send data starting at c->buffer_ptr to the output connection\n * (either UDP or TCP)\n */\nstatic int http_send_data(HTTPContext *c)\n{\n    int len, ret;\n\n    for(;;) {\n        if (c->buffer_ptr >= c->buffer_end) {\n            ret = http_prepare_data(c);\n            if (ret < 0)\n                return -1;\n            else if (ret)\n                /* state change requested */\n                break;\n        } else {\n            if (c->is_packetized) {\n                /* RTP data output */\n                len = c->buffer_end - c->buffer_ptr;\n                if (len < 4) {\n                    /* fail safe - should never happen */\n                fail1:\n                    c->buffer_ptr = c->buffer_end;\n                    return 0;\n                }\n                len = (c->buffer_ptr[0] << 24) |\n                    (c->buffer_ptr[1] << 16) |\n                    (c->buffer_ptr[2] << 8) |\n                    (c->buffer_ptr[3]);\n                if (len > (c->buffer_end - c->buffer_ptr))\n                    goto fail1;\n                if ((get_packet_send_clock(c) - get_server_clock(c)) > 0) {\n                    /* nothing to send yet: we can wait */\n                    return 0;\n                }\n\n                c->data_count += len;\n                update_datarate(&c->datarate, c->data_count);\n                if (c->stream)\n                    c->stream->bytes_served += len;\n\n                if (c->rtp_protocol == RTSP_LOWER_TRANSPORT_TCP) {\n                    /* RTP packets are sent inside the RTSP TCP connection */\n                    AVIOContext *pb;\n                    int interleaved_index, size;\n                    uint8_t header[4];\n                    HTTPContext *rtsp_c;\n\n                    rtsp_c = c->rtsp_c;\n                    /* if no RTSP connection left, error */\n                    if (!rtsp_c)\n                        return -1;\n                    /* if already sending something, then wait. */\n                    if (rtsp_c->state != RTSPSTATE_WAIT_REQUEST)\n                        break;\n                    if (avio_open_dyn_buf(&pb) < 0)\n                        goto fail1;\n                    interleaved_index = c->packet_stream_index * 2;\n                    /* RTCP packets are sent at odd indexes */\n                    if (c->buffer_ptr[1] == 200)\n                        interleaved_index++;\n                    /* write RTSP TCP header */\n                    header[0] = '$';\n                    header[1] = interleaved_index;\n                    header[2] = len >> 8;\n                    header[3] = len;\n                    avio_write(pb, header, 4);\n                    /* write RTP packet data */\n                    c->buffer_ptr += 4;\n                    avio_write(pb, c->buffer_ptr, len);\n                    size = avio_close_dyn_buf(pb, &c->packet_buffer);\n                    /* prepare asynchronous TCP sending */\n                    rtsp_c->packet_buffer_ptr = c->packet_buffer;\n                    rtsp_c->packet_buffer_end = c->packet_buffer + size;\n                    c->buffer_ptr += len;\n\n                    /* send everything we can NOW */\n                    len = send(rtsp_c->fd, rtsp_c->packet_buffer_ptr,\n                               rtsp_c->packet_buffer_end - rtsp_c->packet_buffer_ptr, 0);\n                    if (len > 0)\n                        rtsp_c->packet_buffer_ptr += len;\n                    if (rtsp_c->packet_buffer_ptr < rtsp_c->packet_buffer_end) {\n                        /* if we could not send all the data, we will\n                         * send it later, so a new state is needed to\n                         * \"lock\" the RTSP TCP connection */\n                        rtsp_c->state = RTSPSTATE_SEND_PACKET;\n                        break;\n                    } else\n                        /* all data has been sent */\n                        av_freep(&c->packet_buffer);\n                } else {\n                    /* send RTP packet directly in UDP */\n                    c->buffer_ptr += 4;\n                    ffurl_write(c->rtp_handles[c->packet_stream_index],\n                                c->buffer_ptr, len);\n                    c->buffer_ptr += len;\n                    /* here we continue as we can send several packets\n                     * per 10 ms slot */\n                }\n            } else {\n                /* TCP data output */\n                len = send(c->fd, c->buffer_ptr,\n                           c->buffer_end - c->buffer_ptr, 0);\n                if (len < 0) {\n                    if (ff_neterrno() != AVERROR(EAGAIN) &&\n                        ff_neterrno() != AVERROR(EINTR))\n                        /* error : close connection */\n                        return -1;\n                    else\n                        return 0;\n                }\n                c->buffer_ptr += len;\n\n                c->data_count += len;\n                update_datarate(&c->datarate, c->data_count);\n                if (c->stream)\n                    c->stream->bytes_served += len;\n                break;\n            }\n        }\n    } /* for(;;) */\n    return 0;\n}\n\nstatic int http_start_receive_data(HTTPContext *c)\n{\n    int fd;\n    int ret;\n    int64_t ret64;\n\n    if (c->stream->feed_opened) {\n        http_log(\"Stream feed '%s' was not opened\\n\",\n                 c->stream->feed_filename);\n        return AVERROR(EINVAL);\n    }\n\n    /* Don't permit writing to this one */\n    if (c->stream->readonly) {\n        http_log(\"Cannot write to read-only file '%s'\\n\",\n                 c->stream->feed_filename);\n        return AVERROR(EINVAL);\n    }\n\n    /* open feed */\n    fd = open(c->stream->feed_filename, O_RDWR);\n    if (fd < 0) {\n        ret = AVERROR(errno);\n        http_log(\"Could not open feed file '%s': %s\\n\",\n                 c->stream->feed_filename, strerror(errno));\n        return ret;\n    }\n    c->feed_fd = fd;\n\n    if (c->stream->truncate) {\n        /* truncate feed file */\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n        if (ftruncate(c->feed_fd, FFM_PACKET_SIZE) < 0) {\n            ret = AVERROR(errno);\n            http_log(\"Error truncating feed file '%s': %s\\n\",\n                     c->stream->feed_filename, strerror(errno));\n            return ret;\n        }\n    } else {\n        ret64 = ffm_read_write_index(fd);\n        if (ret64 < 0) {\n            http_log(\"Error reading write index from feed file '%s': %s\\n\",\n                     c->stream->feed_filename, strerror(errno));\n            return ret64;\n        }\n        c->stream->feed_write_index = ret64;\n    }\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd),\n                                        FFM_PACKET_SIZE);\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n    lseek(fd, 0, SEEK_SET);\n\n    /* init buffer input */\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n    c->stream->feed_opened = 1;\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n    return 0;\n}\n\nstatic int http_receive_data(HTTPContext *c)\n{\n    HTTPContext *c1;\n    int len, loop_run = 0;\n\n    while (c->chunked_encoding && !c->chunk_size &&\n           c->buffer_end > c->buffer_ptr) {\n        /* read chunk header, if present */\n        len = recv(c->fd, c->buffer_ptr, 1, 0);\n\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                /* error : close connection */\n                goto fail;\n            return 0;\n        } else if (len == 0) {\n            /* end of connection : close it */\n            goto fail;\n        } else if (c->buffer_ptr - c->buffer >= 2 &&\n                   !memcmp(c->buffer_ptr - 1, \"\\r\\n\", 2)) {\n            c->chunk_size = strtol(c->buffer, 0, 16);\n            if (c->chunk_size <= 0) { // end of stream or invalid chunk size\n                c->chunk_size = 0;\n                goto fail;\n            }\n            c->buffer_ptr = c->buffer;\n            break;\n        } else if (++loop_run > 10)\n            /* no chunk header, abort */\n            goto fail;\n        else\n            c->buffer_ptr++;\n    }\n\n    if (c->buffer_end > c->buffer_ptr) {\n        len = recv(c->fd, c->buffer_ptr,\n                   FFMIN(c->chunk_size, c->buffer_end - c->buffer_ptr), 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                /* error : close connection */\n                goto fail;\n        } else if (len == 0)\n            /* end of connection : close it */\n            goto fail;\n        else {\n            av_assert0(len <= c->chunk_size);\n            c->chunk_size -= len;\n            c->buffer_ptr += len;\n            c->data_count += len;\n            update_datarate(&c->datarate, c->data_count);\n        }\n    }\n\n    if (c->buffer_ptr - c->buffer >= 2 && c->data_count > FFM_PACKET_SIZE) {\n        if (c->buffer[0] != 'f' ||\n            c->buffer[1] != 'm') {\n            http_log(\"Feed stream has become desynchronized -- disconnecting\\n\");\n            goto fail;\n        }\n    }\n\n    if (c->buffer_ptr >= c->buffer_end) {\n        FFServerStream *feed = c->stream;\n        /* a packet has been received : write it in the store, except\n         * if header */\n        if (c->data_count > FFM_PACKET_SIZE) {\n            /* XXX: use llseek or url_seek\n             * XXX: Should probably fail? */\n            if (lseek(c->feed_fd, feed->feed_write_index, SEEK_SET) == -1)\n                http_log(\"Seek to %\"PRId64\" failed\\n\", feed->feed_write_index);\n\n            if (write(c->feed_fd, c->buffer, FFM_PACKET_SIZE) < 0) {\n                http_log(\"Error writing to feed file: %s\\n\", strerror(errno));\n                goto fail;\n            }\n\n            feed->feed_write_index += FFM_PACKET_SIZE;\n            /* update file size */\n            if (feed->feed_write_index > c->stream->feed_size)\n                feed->feed_size = feed->feed_write_index;\n\n            /* handle wrap around if max file size reached */\n            if (c->stream->feed_max_size &&\n                feed->feed_write_index >= c->stream->feed_max_size)\n                feed->feed_write_index = FFM_PACKET_SIZE;\n\n            /* write index */\n            if (ffm_write_write_index(c->feed_fd, feed->feed_write_index) < 0) {\n                http_log(\"Error writing index to feed file: %s\\n\",\n                         strerror(errno));\n                goto fail;\n            }\n\n            /* wake up any waiting connections */\n            for(c1 = first_http_ctx; c1; c1 = c1->next) {\n                if (c1->state == HTTPSTATE_WAIT_FEED &&\n                    c1->stream->feed == c->stream->feed)\n                    c1->state = HTTPSTATE_SEND_DATA;\n            }\n        } else {\n            /* We have a header in our hands that contains useful data */\n            AVFormatContext *s = avformat_alloc_context();\n            AVIOContext *pb;\n            AVInputFormat *fmt_in;\n            int i;\n\n            if (!s)\n                goto fail;\n\n            /* use feed output format name to find corresponding input format */\n            fmt_in = av_find_input_format(feed->fmt->name);\n            if (!fmt_in)\n                goto fail;\n\n            pb = avio_alloc_context(c->buffer, c->buffer_end - c->buffer,\n                                    0, NULL, NULL, NULL, NULL);\n            if (!pb)\n                goto fail;\n\n            pb->seekable = 0;\n\n            s->pb = pb;\n            if (avformat_open_input(&s, c->stream->feed_filename, fmt_in, NULL) < 0) {\n                av_freep(&pb);\n                goto fail;\n            }\n\n            /* Now we have the actual streams */\n            if (s->nb_streams != feed->nb_streams) {\n                avformat_close_input(&s);\n                av_freep(&pb);\n                http_log(\"Feed '%s' stream number does not match registered feed\\n\",\n                         c->stream->feed_filename);\n                goto fail;\n            }\n\n            for (i = 0; i < s->nb_streams; i++) {\n                LayeredAVStream *fst = feed->streams[i];\n                AVStream *st = s->streams[i];\n                avcodec_parameters_to_context(fst->codec, st->codecpar);\n                avcodec_parameters_from_context(fst->codecpar, fst->codec);\n            }\n\n            avformat_close_input(&s);\n            av_freep(&pb);\n        }\n        c->buffer_ptr = c->buffer;\n    }\n\n    return 0;\n fail:\n    c->stream->feed_opened = 0;\n    close(c->feed_fd);\n    /* wake up any waiting connections to stop waiting for feed */\n    for(c1 = first_http_ctx; c1; c1 = c1->next) {\n        if (c1->state == HTTPSTATE_WAIT_FEED &&\n            c1->stream->feed == c->stream->feed)\n            c1->state = HTTPSTATE_SEND_DATA_TRAILER;\n    }\n    return -1;\n}\n\n/********************************************************************/\n/* RTSP handling */\n\nstatic void rtsp_reply_header(HTTPContext *c, enum RTSPStatusCode error_number)\n{\n    const char *str;\n    time_t ti;\n    struct tm *tm;\n    char buf2[32];\n\n    str = RTSP_STATUS_CODE2STRING(error_number);\n    if (!str)\n        str = \"Unknown Error\";\n\n    avio_printf(c->pb, \"RTSP/1.0 %d %s\\r\\n\", error_number, str);\n    avio_printf(c->pb, \"CSeq: %d\\r\\n\", c->seq);\n\n    /* output GMT time */\n    ti = time(NULL);\n    tm = gmtime(&ti);\n    strftime(buf2, sizeof(buf2), \"%a, %d %b %Y %H:%M:%S\", tm);\n    avio_printf(c->pb, \"Date: %s GMT\\r\\n\", buf2);\n}\n\nstatic void rtsp_reply_error(HTTPContext *c, enum RTSPStatusCode error_number)\n{\n    rtsp_reply_header(c, error_number);\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic int rtsp_parse_request(HTTPContext *c)\n{\n    const char *p, *p1, *p2;\n    char cmd[32];\n    char url[1024];\n    char protocol[32];\n    char line[1024];\n    int len;\n    RTSPMessageHeader header1 = { 0 }, *header = &header1;\n\n    c->buffer_ptr[0] = '\\0';\n    p = c->buffer;\n\n    get_word(cmd, sizeof(cmd), &p);\n    get_word(url, sizeof(url), &p);\n    get_word(protocol, sizeof(protocol), &p);\n\n    av_strlcpy(c->method, cmd, sizeof(c->method));\n    av_strlcpy(c->url, url, sizeof(c->url));\n    av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n\n    if (avio_open_dyn_buf(&c->pb) < 0) {\n        /* XXX: cannot do more */\n        c->pb = NULL; /* safety */\n        return -1;\n    }\n\n    /* check version name */\n    if (strcmp(protocol, \"RTSP/1.0\")) {\n        rtsp_reply_error(c, RTSP_STATUS_VERSION);\n        goto the_end;\n    }\n\n    /* parse each header line */\n    /* skip to next line */\n    while (*p != '\\n' && *p != '\\0')\n        p++;\n    if (*p == '\\n')\n        p++;\n    while (*p != '\\0') {\n        p1 = memchr(p, '\\n', (char *)c->buffer_ptr - p);\n        if (!p1)\n            break;\n        p2 = p1;\n        if (p2 > p && p2[-1] == '\\r')\n            p2--;\n        /* skip empty line */\n        if (p2 == p)\n            break;\n        len = p2 - p;\n        if (len > sizeof(line) - 1)\n            len = sizeof(line) - 1;\n        memcpy(line, p, len);\n        line[len] = '\\0';\n        ff_rtsp_parse_line(NULL, header, line, NULL, NULL);\n        p = p1 + 1;\n    }\n\n    /* handle sequence number */\n    c->seq = header->seq;\n\n    if (!strcmp(cmd, \"DESCRIBE\"))\n        rtsp_cmd_describe(c, url);\n    else if (!strcmp(cmd, \"OPTIONS\"))\n        rtsp_cmd_options(c, url);\n    else if (!strcmp(cmd, \"SETUP\"))\n        rtsp_cmd_setup(c, url, header);\n    else if (!strcmp(cmd, \"PLAY\"))\n        rtsp_cmd_play(c, url, header);\n    else if (!strcmp(cmd, \"PAUSE\"))\n        rtsp_cmd_interrupt(c, url, header, 1);\n    else if (!strcmp(cmd, \"TEARDOWN\"))\n        rtsp_cmd_interrupt(c, url, header, 0);\n    else\n        rtsp_reply_error(c, RTSP_STATUS_METHOD);\n\n the_end:\n    len = avio_close_dyn_buf(c->pb, &c->pb_buffer);\n    c->pb = NULL; /* safety */\n    if (len < 0)\n        /* XXX: cannot do more */\n        return -1;\n\n    c->buffer_ptr = c->pb_buffer;\n    c->buffer_end = c->pb_buffer + len;\n    c->state = RTSPSTATE_SEND_REPLY;\n    return 0;\n}\n\nstatic int prepare_sdp_description(FFServerStream *stream, uint8_t **pbuffer,\n                                   struct in_addr my_ip)\n{\n    AVFormatContext *avc;\n    AVOutputFormat *rtp_format = av_guess_format(\"rtp\", NULL, NULL);\n    AVDictionaryEntry *entry = av_dict_get(stream->metadata, \"title\", NULL, 0);\n    int i;\n\n    *pbuffer = NULL;\n\n    avc =  avformat_alloc_context();\n    if (!avc || !rtp_format)\n        return -1;\n\n    avc->oformat = rtp_format;\n    av_dict_set(&avc->metadata, \"title\",\n                entry ? entry->value : \"No Title\", 0);\n    if (stream->is_multicast) {\n        snprintf(avc->filename, 1024, \"rtp://%s:%d?multicast=1?ttl=%d\",\n                 inet_ntoa(stream->multicast_ip),\n                 stream->multicast_port, stream->multicast_ttl);\n    } else\n        snprintf(avc->filename, 1024, \"rtp://0.0.0.0\");\n\n    for(i = 0; i < stream->nb_streams; i++) {\n        AVStream *st = avformat_new_stream(avc, NULL);\n        if (!st)\n            goto sdp_done;\n        avcodec_parameters_from_context(stream->streams[i]->codecpar, stream->streams[i]->codec);\n        unlayer_stream(st, stream->streams[i]);\n    }\n#define PBUFFER_SIZE 2048\n    *pbuffer = av_mallocz(PBUFFER_SIZE);\n    if (!*pbuffer)\n        goto sdp_done;\n    av_sdp_create(&avc, 1, *pbuffer, PBUFFER_SIZE);\n\n sdp_done:\n    av_freep(&avc->streams);\n    av_dict_free(&avc->metadata);\n    av_free(avc);\n\n    return *pbuffer ? strlen(*pbuffer) : AVERROR(ENOMEM);\n}\n\nstatic void rtsp_cmd_options(HTTPContext *c, const char *url)\n{\n    /* rtsp_reply_header(c, RTSP_STATUS_OK); */\n    avio_printf(c->pb, \"RTSP/1.0 %d %s\\r\\n\", RTSP_STATUS_OK, \"OK\");\n    avio_printf(c->pb, \"CSeq: %d\\r\\n\", c->seq);\n    avio_printf(c->pb, \"Public: %s\\r\\n\",\n                \"OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE\");\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic void rtsp_cmd_describe(HTTPContext *c, const char *url)\n{\n    FFServerStream *stream;\n    char path1[1024];\n    const char *path;\n    uint8_t *content;\n    int content_length;\n    socklen_t len;\n    struct sockaddr_in my_addr;\n\n    /* find which URL is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        if (!stream->is_feed &&\n            stream->fmt && !strcmp(stream->fmt->name, \"rtp\") &&\n            !strcmp(path, stream->filename)) {\n            goto found;\n        }\n    }\n    /* no stream found */\n    rtsp_reply_error(c, RTSP_STATUS_NOT_FOUND);\n    return;\n\n found:\n    /* prepare the media description in SDP format */\n\n    /* get the host IP */\n    len = sizeof(my_addr);\n    getsockname(c->fd, (struct sockaddr *)&my_addr, &len);\n    content_length = prepare_sdp_description(stream, &content,\n                                             my_addr.sin_addr);\n    if (content_length < 0) {\n        rtsp_reply_error(c, RTSP_STATUS_INTERNAL);\n        return;\n    }\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    avio_printf(c->pb, \"Content-Base: %s/\\r\\n\", url);\n    avio_printf(c->pb, \"Content-Type: application/sdp\\r\\n\");\n    avio_printf(c->pb, \"Content-Length: %d\\r\\n\", content_length);\n    avio_printf(c->pb, \"\\r\\n\");\n    avio_write(c->pb, content, content_length);\n    av_free(content);\n}\n\nstatic HTTPContext *find_rtp_session(const char *session_id)\n{\n    HTTPContext *c;\n\n    if (session_id[0] == '\\0')\n        return NULL;\n\n    for(c = first_http_ctx; c; c = c->next) {\n        if (!strcmp(c->session_id, session_id))\n            return c;\n    }\n    return NULL;\n}\n\nstatic RTSPTransportField *find_transport(RTSPMessageHeader *h, enum RTSPLowerTransport lower_transport)\n{\n    RTSPTransportField *th;\n    int i;\n\n    for(i=0;i<h->nb_transports;i++) {\n        th = &h->transports[i];\n        if (th->lower_transport == lower_transport)\n            return th;\n    }\n    return NULL;\n}\n\nstatic void rtsp_cmd_setup(HTTPContext *c, const char *url,\n                           RTSPMessageHeader *h)\n{\n    FFServerStream *stream;\n    int stream_index, rtp_port, rtcp_port;\n    char buf[1024];\n    char path1[1024];\n    const char *path;\n    HTTPContext *rtp_c;\n    RTSPTransportField *th;\n    struct sockaddr_in dest_addr;\n    RTSPActionServerSetup setup;\n\n    /* find which URL is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n\n    /* now check each stream */\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        if (stream->is_feed || !stream->fmt ||\n            strcmp(stream->fmt->name, \"rtp\")) {\n            continue;\n        }\n        /* accept aggregate filenames only if single stream */\n        if (!strcmp(path, stream->filename)) {\n            if (stream->nb_streams != 1) {\n                rtsp_reply_error(c, RTSP_STATUS_AGGREGATE);\n                return;\n            }\n            stream_index = 0;\n            goto found;\n        }\n\n        for(stream_index = 0; stream_index < stream->nb_streams;\n            stream_index++) {\n            snprintf(buf, sizeof(buf), \"%s/streamid=%d\",\n                     stream->filename, stream_index);\n            if (!strcmp(path, buf))\n                goto found;\n        }\n    }\n    /* no stream found */\n    rtsp_reply_error(c, RTSP_STATUS_SERVICE); /* XXX: right error ? */\n    return;\n found:\n\n    /* generate session id if needed */\n    if (h->session_id[0] == '\\0') {\n        unsigned random0 = av_lfg_get(&random_state);\n        unsigned random1 = av_lfg_get(&random_state);\n        snprintf(h->session_id, sizeof(h->session_id), \"%08x%08x\",\n                 random0, random1);\n    }\n\n    /* find RTP session, and create it if none found */\n    rtp_c = find_rtp_session(h->session_id);\n    if (!rtp_c) {\n        /* always prefer UDP */\n        th = find_transport(h, RTSP_LOWER_TRANSPORT_UDP);\n        if (!th) {\n            th = find_transport(h, RTSP_LOWER_TRANSPORT_TCP);\n            if (!th) {\n                rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n                return;\n            }\n        }\n\n        rtp_c = rtp_new_connection(&c->from_addr, stream, h->session_id,\n                                   th->lower_transport);\n        if (!rtp_c) {\n            rtsp_reply_error(c, RTSP_STATUS_BANDWIDTH);\n            return;\n        }\n\n        /* open input stream */\n        if (open_input_stream(rtp_c, \"\") < 0) {\n            rtsp_reply_error(c, RTSP_STATUS_INTERNAL);\n            return;\n        }\n    }\n\n    /* test if stream is OK (test needed because several SETUP needs\n     * to be done for a given file) */\n    if (rtp_c->stream != stream) {\n        rtsp_reply_error(c, RTSP_STATUS_SERVICE);\n        return;\n    }\n\n    /* test if stream is already set up */\n    if (rtp_c->rtp_ctx[stream_index]) {\n        rtsp_reply_error(c, RTSP_STATUS_STATE);\n        return;\n    }\n\n    /* check transport */\n    th = find_transport(h, rtp_c->rtp_protocol);\n    if (!th || (th->lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n                th->client_port_min <= 0)) {\n        rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n        return;\n    }\n\n    /* setup default options */\n    setup.transport_option[0] = '\\0';\n    dest_addr = rtp_c->from_addr;\n    dest_addr.sin_port = htons(th->client_port_min);\n\n    /* setup stream */\n    if (rtp_new_av_stream(rtp_c, stream_index, &dest_addr, c) < 0) {\n        rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n        return;\n    }\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n\n    switch(rtp_c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP:\n        rtp_port = ff_rtp_get_local_rtp_port(rtp_c->rtp_handles[stream_index]);\n        rtcp_port = ff_rtp_get_local_rtcp_port(rtp_c->rtp_handles[stream_index]);\n        avio_printf(c->pb, \"Transport: RTP/AVP/UDP;unicast;\"\n                    \"client_port=%d-%d;server_port=%d-%d\",\n                    th->client_port_min, th->client_port_max,\n                    rtp_port, rtcp_port);\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        avio_printf(c->pb, \"Transport: RTP/AVP/TCP;interleaved=%d-%d\",\n                    stream_index * 2, stream_index * 2 + 1);\n        break;\n    default:\n        break;\n    }\n    if (setup.transport_option[0] != '\\0')\n        avio_printf(c->pb, \";%s\", setup.transport_option);\n    avio_printf(c->pb, \"\\r\\n\");\n\n\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\n\n/**\n * find an RTP connection by using the session ID. Check consistency\n * with filename\n */\nstatic HTTPContext *find_rtp_session_with_url(const char *url,\n                                              const char *session_id)\n{\n    HTTPContext *rtp_c;\n    char path1[1024];\n    const char *path;\n    char buf[1024];\n    int s, len;\n\n    rtp_c = find_rtp_session(session_id);\n    if (!rtp_c)\n        return NULL;\n\n    /* find which URL is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n    if(!strcmp(path, rtp_c->stream->filename)) return rtp_c;\n    for(s=0; s<rtp_c->stream->nb_streams; ++s) {\n      snprintf(buf, sizeof(buf), \"%s/streamid=%d\",\n        rtp_c->stream->filename, s);\n      if(!strncmp(path, buf, sizeof(buf)))\n        /* XXX: Should we reply with RTSP_STATUS_ONLY_AGGREGATE\n         * if nb_streams>1? */\n        return rtp_c;\n    }\n    len = strlen(path);\n    if (len > 0 && path[len - 1] == '/' &&\n        !strncmp(path, rtp_c->stream->filename, len - 1))\n        return rtp_c;\n    return NULL;\n}\n\nstatic void rtsp_cmd_play(HTTPContext *c, const char *url, RTSPMessageHeader *h)\n{\n    HTTPContext *rtp_c;\n\n    rtp_c = find_rtp_session_with_url(url, h->session_id);\n    if (!rtp_c) {\n        rtsp_reply_error(c, RTSP_STATUS_SESSION);\n        return;\n    }\n\n    if (rtp_c->state != HTTPSTATE_SEND_DATA &&\n        rtp_c->state != HTTPSTATE_WAIT_FEED &&\n        rtp_c->state != HTTPSTATE_READY) {\n        rtsp_reply_error(c, RTSP_STATUS_STATE);\n        return;\n    }\n\n    rtp_c->state = HTTPSTATE_SEND_DATA;\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic void rtsp_cmd_interrupt(HTTPContext *c, const char *url,\n                               RTSPMessageHeader *h, int pause_only)\n{\n    HTTPContext *rtp_c;\n\n    rtp_c = find_rtp_session_with_url(url, h->session_id);\n    if (!rtp_c) {\n        rtsp_reply_error(c, RTSP_STATUS_SESSION);\n        return;\n    }\n\n    if (pause_only) {\n        if (rtp_c->state != HTTPSTATE_SEND_DATA &&\n            rtp_c->state != HTTPSTATE_WAIT_FEED) {\n            rtsp_reply_error(c, RTSP_STATUS_STATE);\n            return;\n        }\n        rtp_c->state = HTTPSTATE_READY;\n        rtp_c->first_pts = AV_NOPTS_VALUE;\n    }\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n    avio_printf(c->pb, \"\\r\\n\");\n\n    if (!pause_only)\n        close_connection(rtp_c);\n}\n\n/********************************************************************/\n/* RTP handling */\n\nstatic HTTPContext *rtp_new_connection(struct sockaddr_in *from_addr,\n                                       FFServerStream *stream,\n                                       const char *session_id,\n                                       enum RTSPLowerTransport rtp_protocol)\n{\n    HTTPContext *c = NULL;\n    const char *proto_str;\n\n    /* XXX: should output a warning page when coming\n     * close to the connection limit */\n    if (nb_connections >= config.nb_max_connections)\n        goto fail;\n\n    /* add a new connection */\n    c = av_mallocz(sizeof(HTTPContext));\n    if (!c)\n        goto fail;\n\n    c->fd = -1;\n    c->poll_entry = NULL;\n    c->from_addr = *from_addr;\n    c->buffer_size = IOBUFFER_INIT_SIZE;\n    c->buffer = av_malloc(c->buffer_size);\n    if (!c->buffer)\n        goto fail;\n    nb_connections++;\n    c->stream = stream;\n    av_strlcpy(c->session_id, session_id, sizeof(c->session_id));\n    c->state = HTTPSTATE_READY;\n    c->is_packetized = 1;\n    c->rtp_protocol = rtp_protocol;\n\n    /* protocol is shown in statistics */\n    switch(c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP_MULTICAST:\n        proto_str = \"MCAST\";\n        break;\n    case RTSP_LOWER_TRANSPORT_UDP:\n        proto_str = \"UDP\";\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        proto_str = \"TCP\";\n        break;\n    default:\n        proto_str = \"???\";\n        break;\n    }\n    av_strlcpy(c->protocol, \"RTP/\", sizeof(c->protocol));\n    av_strlcat(c->protocol, proto_str, sizeof(c->protocol));\n\n    current_bandwidth += stream->bandwidth;\n\n    c->next = first_http_ctx;\n    first_http_ctx = c;\n    return c;\n\n fail:\n    if (c) {\n        av_freep(&c->buffer);\n        av_free(c);\n    }\n    return NULL;\n}\n\n/**\n * add a new RTP stream in an RTP connection (used in RTSP SETUP\n * command). If RTP/TCP protocol is used, TCP connection 'rtsp_c' is\n * used.\n */\nstatic int rtp_new_av_stream(HTTPContext *c,\n                             int stream_index, struct sockaddr_in *dest_addr,\n                             HTTPContext *rtsp_c)\n{\n    AVFormatContext *ctx;\n    AVStream *st;\n    char *ipaddr;\n    URLContext *h = NULL;\n    uint8_t *dummy_buf;\n    int max_packet_size;\n    void *st_internal;\n\n    /* now we can open the relevant output stream */\n    ctx = avformat_alloc_context();\n    if (!ctx)\n        return -1;\n    ctx->oformat = av_guess_format(\"rtp\", NULL, NULL);\n\n    st = avformat_new_stream(ctx, NULL);\n    if (!st)\n        goto fail;\n\n    st_internal = st->internal;\n\n    if (!c->stream->feed ||\n        c->stream->feed == c->stream)\n        unlayer_stream(st, c->stream->streams[stream_index]);\n    else\n        unlayer_stream(st,\n               c->stream->feed->streams[c->stream->feed_streams[stream_index]]);\n    av_assert0(st->priv_data == NULL);\n    av_assert0(st->internal == st_internal);\n\n    /* build destination RTP address */\n    ipaddr = inet_ntoa(dest_addr->sin_addr);\n\n    switch(c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP:\n    case RTSP_LOWER_TRANSPORT_UDP_MULTICAST:\n        /* RTP/UDP case */\n\n        /* XXX: also pass as parameter to function ? */\n        if (c->stream->is_multicast) {\n            int ttl;\n            ttl = c->stream->multicast_ttl;\n            if (!ttl)\n                ttl = 16;\n            snprintf(ctx->filename, sizeof(ctx->filename),\n                     \"rtp://%s:%d?multicast=1&ttl=%d\",\n                     ipaddr, ntohs(dest_addr->sin_port), ttl);\n        } else {\n            snprintf(ctx->filename, sizeof(ctx->filename),\n                     \"rtp://%s:%d\", ipaddr, ntohs(dest_addr->sin_port));\n        }\n\n        if (ffurl_open(&h, ctx->filename, AVIO_FLAG_WRITE, NULL, NULL) < 0)\n            goto fail;\n        c->rtp_handles[stream_index] = h;\n        max_packet_size = h->max_packet_size;\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        /* RTP/TCP case */\n        c->rtsp_c = rtsp_c;\n        max_packet_size = RTSP_TCP_MAX_PACKET_SIZE;\n        break;\n    default:\n        goto fail;\n    }\n\n    http_log(\"%s:%d - - \\\"PLAY %s/streamid=%d %s\\\"\\n\",\n             ipaddr, ntohs(dest_addr->sin_port),\n             c->stream->filename, stream_index, c->protocol);\n\n    /* normally, no packets should be output here, but the packet size may\n     * be checked */\n    if (ffio_open_dyn_packet_buf(&ctx->pb, max_packet_size) < 0)\n        /* XXX: close stream */\n        goto fail;\n\n    if (avformat_write_header(ctx, NULL) < 0) {\n    fail:\n        if (h)\n            ffurl_close(h);\n        av_free(st);\n        av_free(ctx);\n        return -1;\n    }\n    avio_close_dyn_buf(ctx->pb, &dummy_buf);\n    ctx->pb = NULL;\n    av_free(dummy_buf);\n\n    c->rtp_ctx[stream_index] = ctx;\n    return 0;\n}\n\n/********************************************************************/\n/* ffserver initialization */\n\n/* FIXME: This code should use avformat_new_stream() */\nstatic LayeredAVStream *add_av_stream1(FFServerStream *stream,\n                                AVCodecContext *codec, int copy)\n{\n    LayeredAVStream *fst;\n\n    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))\n        return NULL;\n\n    fst = av_mallocz(sizeof(*fst));\n    if (!fst)\n        return NULL;\n    if (copy) {\n        fst->codec = avcodec_alloc_context3(codec->codec);\n        if (!fst->codec) {\n            av_free(fst);\n            return NULL;\n        }\n        avcodec_copy_context(fst->codec, codec);\n    } else\n        /* live streams must use the actual feed's codec since it may be\n         * updated later to carry extradata needed by them.\n         */\n        fst->codec = codec;\n\n    //NOTE we previously allocated internal & internal->avctx, these seemed uneeded though\n    fst->codecpar = avcodec_parameters_alloc();\n    fst->index = stream->nb_streams;\n    fst->time_base = codec->time_base;\n    fst->pts_wrap_bits = 33;\n    fst->sample_aspect_ratio = codec->sample_aspect_ratio;\n    stream->streams[stream->nb_streams++] = fst;\n    return fst;\n}\n\n/* return the stream number in the feed */\nstatic int add_av_stream(FFServerStream *feed, LayeredAVStream *st)\n{\n    LayeredAVStream *fst;\n    AVCodecContext *av, *av1;\n    int i;\n\n    av = st->codec;\n    for(i=0;i<feed->nb_streams;i++) {\n        av1 = feed->streams[i]->codec;\n        if (av1->codec_id == av->codec_id &&\n            av1->codec_type == av->codec_type &&\n            av1->bit_rate == av->bit_rate) {\n\n            switch(av->codec_type) {\n            case AVMEDIA_TYPE_AUDIO:\n                if (av1->channels == av->channels &&\n                    av1->sample_rate == av->sample_rate)\n                    return i;\n                break;\n            case AVMEDIA_TYPE_VIDEO:\n                if (av1->width == av->width &&\n                    av1->height == av->height &&\n                    av1->time_base.den == av->time_base.den &&\n                    av1->time_base.num == av->time_base.num &&\n                    av1->gop_size == av->gop_size)\n                    return i;\n                break;\n            default:\n                abort();\n            }\n        }\n    }\n\n    fst = add_av_stream1(feed, av, 0);\n    if (!fst)\n        return -1;\n    if (st->recommended_encoder_configuration)\n        fst->recommended_encoder_configuration =\n            av_strdup(st->recommended_encoder_configuration);\n    return feed->nb_streams - 1;\n}\n\nstatic void remove_stream(FFServerStream *stream)\n{\n    FFServerStream **ps;\n    ps = &config.first_stream;\n    while (*ps) {\n        if (*ps == stream)\n            *ps = (*ps)->next;\n        else\n            ps = &(*ps)->next;\n    }\n}\n\n/* compute the needed AVStream for each file */\nstatic void build_file_streams(void)\n{\n    FFServerStream *stream;\n    AVFormatContext *infile;\n    int i, ret;\n\n    /* gather all streams */\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        infile = NULL;\n\n        if (stream->stream_type != STREAM_TYPE_LIVE || stream->feed)\n            continue;\n\n        /* the stream comes from a file */\n        /* try to open the file */\n        /* open stream */\n\n\n        /* specific case: if transport stream output to RTP,\n         * we use a raw transport stream reader */\n        if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\"))\n            av_dict_set(&stream->in_opts, \"mpeg2ts_compute_pcr\", \"1\", 0);\n\n        if (!stream->feed_filename[0]) {\n            http_log(\"Unspecified feed file for stream '%s'\\n\",\n                     stream->filename);\n            goto fail;\n        }\n\n        http_log(\"Opening feed file '%s' for stream '%s'\\n\",\n                 stream->feed_filename, stream->filename);\n\n        ret = avformat_open_input(&infile, stream->feed_filename,\n                                  stream->ifmt, &stream->in_opts);\n        if (ret < 0) {\n            http_log(\"Could not open '%s': %s\\n\", stream->feed_filename,\n                     av_err2str(ret));\n            /* remove stream (no need to spend more time on it) */\n        fail:\n            remove_stream(stream);\n        } else {\n            /* find all the AVStreams inside and reference them in\n             * 'stream' */\n            if (avformat_find_stream_info(infile, NULL) < 0) {\n                http_log(\"Could not find codec parameters from '%s'\\n\",\n                         stream->feed_filename);\n                avformat_close_input(&infile);\n                goto fail;\n            }\n\n            for(i=0;i<infile->nb_streams;i++)\n                add_av_stream1(stream, infile->streams[i]->codec, 1);\n\n            avformat_close_input(&infile);\n        }\n    }\n}\n\nstatic inline\nint check_codec_match(LayeredAVStream *ccf, AVStream *ccs, int stream)\n{\n    int matches = 1;\n\n/* FIXME: Missed check on AVCodecContext.flags */\n#define CHECK_CODEC(x)  (ccf->codecpar->x != ccs->codecpar->x)\n    if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n        http_log(\"Codecs do not match for stream %d\\n\", stream);\n        matches = 0;\n    } else if (CHECK_CODEC(bit_rate)) {\n        http_log(\"Codec bitrates do not match for stream %d\\n\", stream);\n        matches = 0;\n    } else if (ccf->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (av_cmp_q(ccf->time_base, ccs->time_base) ||\n            CHECK_CODEC(width) || CHECK_CODEC(height)) {\n            http_log(\"Codec width, height or framerate do not match for stream %d\\n\", stream);\n            matches = 0;\n        }\n    } else if (ccf->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n        if (CHECK_CODEC(sample_rate) ||\n            CHECK_CODEC(channels) ||\n            CHECK_CODEC(frame_size)) {\n            http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", stream);\n            matches = 0;\n        }\n    } else {\n        http_log(\"Unknown codec type for stream %d\\n\", stream);\n        matches = 0;\n    }\n\n    return matches;\n}\n\n/* compute the needed AVStream for each feed */\nstatic int build_feed_streams(void)\n{\n    FFServerStream *stream, *feed;\n    int i, fd;\n\n    /* gather all streams */\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        feed = stream->feed;\n        if (!feed)\n            continue;\n\n        if (stream->is_feed) {\n            for(i=0;i<stream->nb_streams;i++)\n                stream->feed_streams[i] = i;\n            continue;\n        }\n        /* we handle a stream coming from a feed */\n        for(i=0;i<stream->nb_streams;i++)\n            stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n    }\n\n    /* create feed files if needed */\n    for(feed = config.first_feed; feed; feed = feed->next_feed) {\n\n        if (avio_check(feed->feed_filename, AVIO_FLAG_READ) > 0) {\n            AVFormatContext *s = NULL;\n            int matches = 0;\n\n            /* See if it matches */\n\n            if (avformat_open_input(&s, feed->feed_filename, NULL, NULL) < 0) {\n                http_log(\"Deleting feed file '%s' as it appears \"\n                            \"to be corrupt\\n\",\n                         feed->feed_filename);\n                goto drop;\n            }\n\n            /* set buffer size */\n            if (ffio_set_buf_size(s->pb, FFM_PACKET_SIZE) < 0) {\n                http_log(\"Failed to set buffer size\\n\");\n                avformat_close_input(&s);\n                goto bail;\n            }\n\n            /* Now see if it matches */\n            if (s->nb_streams != feed->nb_streams) {\n                http_log(\"Deleting feed file '%s' as stream counts \"\n                            \"differ (%d != %d)\\n\",\n                         feed->feed_filename, s->nb_streams, feed->nb_streams);\n                goto drop;\n            }\n\n            matches = 1;\n            for(i=0;i<s->nb_streams;i++) {\n                AVStream *ss;\n                LayeredAVStream *sf;\n\n                sf = feed->streams[i];\n                ss = s->streams[i];\n\n                if (sf->index != ss->index || sf->id != ss->id) {\n                    http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n                             i, feed->feed_filename);\n                    matches = 0;\n                    break;\n                }\n\n                matches = check_codec_match (sf, ss, i);\n                if (!matches)\n                    break;\n            }\n\ndrop:\n            if (s)\n                avformat_close_input(&s);\n\n            if (!matches) {\n                if (feed->readonly) {\n                    http_log(\"Unable to delete read-only feed file '%s'\\n\",\n                             feed->feed_filename);\n                    goto bail;\n                }\n                unlink(feed->feed_filename);\n            }\n        }\n\n        if (avio_check(feed->feed_filename, AVIO_FLAG_WRITE) <= 0) {\n            AVFormatContext *s = avformat_alloc_context();\n\n            if (!s) {\n                http_log(\"Failed to allocate context\\n\");\n                goto bail;\n            }\n\n            if (feed->readonly) {\n                http_log(\"Unable to create feed file '%s' as it is \"\n                            \"marked readonly\\n\",\n                         feed->feed_filename);\n                avformat_free_context(s);\n                goto bail;\n            }\n\n            /* only write the header of the ffm file */\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n                http_log(\"Could not open output feed file '%s'\\n\",\n                         feed->feed_filename);\n                avformat_free_context(s);\n                goto bail;\n            }\n            s->oformat = feed->fmt;\n            for (i = 0; i<feed->nb_streams; i++) {\n                AVStream *st = avformat_new_stream(s, NULL); // FIXME free this\n                if (!st) {\n                    http_log(\"Failed to allocate stream\\n\");\n                    goto bail;\n                }\n                unlayer_stream(st, feed->streams[i]);\n            }\n            if (avformat_write_header(s, NULL) < 0) {\n                http_log(\"Container doesn't support the required parameters\\n\");\n                avio_closep(&s->pb);\n                s->streams = NULL;\n                s->nb_streams = 0;\n                avformat_free_context(s);\n                goto bail;\n            }\n            /* XXX: need better API */\n            av_freep(&s->priv_data);\n            avio_closep(&s->pb);\n            s->streams = NULL;\n            s->nb_streams = 0;\n            avformat_free_context(s);\n        }\n\n        /* get feed size and write index */\n        fd = open(feed->feed_filename, O_RDONLY);\n        if (fd < 0) {\n            http_log(\"Could not open output feed file '%s'\\n\",\n                    feed->feed_filename);\n            goto bail;\n        }\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd),\n                                       FFM_PACKET_SIZE);\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n        /* ensure that we do not wrap before the end of file */\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n            feed->feed_max_size = feed->feed_size;\n\n        close(fd);\n    }\n    return 0;\n\nbail:\n    return -1;\n}\n\n/* compute the bandwidth used by each stream */\nstatic void compute_bandwidth(void)\n{\n    unsigned bandwidth;\n    int i;\n    FFServerStream *stream;\n\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        bandwidth = 0;\n        for(i=0;i<stream->nb_streams;i++) {\n            LayeredAVStream *st = stream->streams[i];\n            switch(st->codec->codec_type) {\n            case AVMEDIA_TYPE_AUDIO:\n            case AVMEDIA_TYPE_VIDEO:\n                bandwidth += st->codec->bit_rate;\n                break;\n            default:\n                break;\n            }\n        }\n        stream->bandwidth = (bandwidth + 999) / 1000;\n    }\n}\n\nstatic void handle_child_exit(int sig)\n{\n    pid_t pid;\n    int status;\n    time_t uptime;\n\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        FFServerStream *feed;\n\n        for (feed = config.first_feed; feed; feed = feed->next) {\n            if (feed->pid != pid)\n                continue;\n\n            uptime = time(0) - feed->pid_start;\n            feed->pid = 0;\n            fprintf(stderr,\n                    \"%s: Pid %\"PRId64\" exited with status %d after %\"PRId64\" \"\n                        \"seconds\\n\",\n                    feed->filename, (int64_t) pid, status, (int64_t)uptime);\n\n            if (uptime < 30)\n                /* Turn off any more restarts */\n                ffserver_free_child_args(&feed->child_argv);\n        }\n    }\n\n    need_to_start_children = 1;\n}\n\nstatic void opt_debug(void)\n{\n    config.debug = 1;\n    snprintf(config.logfilename, sizeof(config.logfilename), \"-\");\n}\n\nvoid show_help_default(const char *opt, const char *arg)\n{\n    printf(\"usage: ffserver [options]\\n\"\n           \"Hyper fast multi format Audio/Video streaming server\\n\");\n    printf(\"\\n\");\n    show_help_options(options, \"Main options:\", 0, 0, 0);\n}\n\nstatic const OptionDef options[] = {\n#include \"cmdutils_common_opts.h\"\n    { \"n\", OPT_BOOL, {(void *)&no_launch }, \"enable no-launch mode\" },\n    { \"d\", 0, {(void*)opt_debug}, \"enable debug mode\" },\n    { \"f\", HAS_ARG | OPT_STRING, {(void*)&config.filename }, \"use configfile instead of /etc/ffserver.conf\", \"configfile\" },\n    { NULL },\n};\n\nint main(int argc, char **argv)\n{\n    struct sigaction sigact = { { 0 } };\n    int cfg_parsed;\n    int ret = EXIT_FAILURE;\n\n    init_dynload();\n\n    config.filename = av_strdup(\"/etc/ffserver.conf\");\n\n    parse_loglevel(argc, argv, options);\n    av_register_all();\n    avformat_network_init();\n\n    show_banner(argc, argv, options);\n\n    my_program_name = argv[0];\n\n    parse_options(NULL, argc, argv, options, NULL);\n\n    unsetenv(\"http_proxy\");             /* Kill the http_proxy */\n\n    av_lfg_init(&random_state, av_get_random_seed());\n\n    sigact.sa_handler = handle_child_exit;\n    sigact.sa_flags = SA_NOCLDSTOP | SA_RESTART;\n    sigaction(SIGCHLD, &sigact, 0);\n\n    if ((cfg_parsed = ffserver_parse_ffconfig(config.filename, &config)) < 0) {\n        fprintf(stderr, \"Error reading configuration file '%s': %s\\n\",\n                config.filename, av_err2str(cfg_parsed));\n        goto bail;\n    }\n\n    /* open log file if needed */\n    if (config.logfilename[0] != '\\0') {\n        if (!strcmp(config.logfilename, \"-\"))\n            logfile = stdout;\n        else\n            logfile = fopen(config.logfilename, \"a\");\n        av_log_set_callback(http_av_log);\n    }\n\n    build_file_streams();\n\n    if (build_feed_streams() < 0) {\n        http_log(\"Could not setup feed streams\\n\");\n        goto bail;\n    }\n\n    compute_bandwidth();\n\n    /* signal init */\n    signal(SIGPIPE, SIG_IGN);\n\n    if (http_server() < 0) {\n        http_log(\"Could not start server\\n\");\n        goto bail;\n    }\n\n    ret=EXIT_SUCCESS;\n\nbail:\n    av_freep (&config.filename);\n    avformat_network_deinit();\n    return ret;\n}\n"], "filenames": ["ffserver.c"], "buggy_code_start_loc": [2741], "buggy_code_end_loc": [2763], "fixing_code_start_loc": [2741], "fixing_code_end_loc": [2767], "type": "CWE-119", "message": "Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size.", "other": {"cve": {"id": "CVE-2016-10192", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-09T15:59:00.753", "lastModified": "2017-02-24T20:20:43.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en ffserver.c en FFmpeg en versiones anteriores a 2.8.10, 3.0.x en versiones anteriores a 3.0.5, 3.1.x en versiones anteriores a 3.1.6 y 3.2.x en versiones anteriores a 3.2.2 permite a atacantes remotos ejecutar c\u00f3digo arbitrario aprovechando el fallo para comprobar el tama\u00f1o del fragmento."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.9", "matchCriteriaId": "BB8F94CB-75BE-4D48-A4A6-4CE03A3D60B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "C6E85AA0-559E-4EC5-AF61-100732EF0643"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "3E86E3C4-946B-4E89-B0C1-010046D8D478"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "94E316AE-DF67-40B7-99CE-CE30BFECC4C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "368CB50E-729C-4CA3-A6E4-67A277354255"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "10FD1F85-27FB-4E8B-A2D0-529A048701C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "1A730657-04E4-4802-8336-DB067AF00C5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "77E8C6C8-4849-4475-8271-CAD3ECE761CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "59A336FF-56BE-4B09-827E-887FCF0A018B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "E6FB6CF6-F80E-4570-8790-F43D2F035A07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "95D2E370-7B0E-451F-9802-D4C272C4902E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A040488F-32AA-4451-B922-45B17D2AEA90"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "21F765CB-B78E-42A3-BB22-D9FC515694B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "F5DFEAF5-8003-4EDB-B2B3-9022052939C4"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/01/31/12", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/02/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95991", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://ffmpeg.org/security.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/a5d25faa3f4b18dac737fdb35d0dd68eb0dc2156", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/a5d25faa3f4b18dac737fdb35d0dd68eb0dc2156"}}