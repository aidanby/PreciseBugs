{"buggy_code": ["/*\n * This file is part of the Goobi viewer - a content presentation and management\n * application for digitized objects.\n *\n * Visit these websites for more information.\n *          - http://www.intranda.com\n *          - http://digiverso.com\n *\n * This program is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage io.goobi.viewer.managedbeans;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport javax.enterprise.context.SessionScoped;\nimport javax.faces.context.ExternalContext;\nimport javax.faces.context.FacesContext;\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrDocumentList;\n\nimport com.ocpsoft.pretty.PrettyContext;\nimport com.ocpsoft.pretty.faces.url.URL;\n\nimport de.intranda.api.annotation.wa.TypedResource;\nimport de.intranda.metadata.multilanguage.IMetadataValue;\nimport de.intranda.metadata.multilanguage.MultiLanguageMetadataValue;\nimport io.goobi.viewer.controller.DataManager;\nimport io.goobi.viewer.controller.IndexerTools;\nimport io.goobi.viewer.controller.NetTools;\nimport io.goobi.viewer.controller.PrettyUrlTools;\nimport io.goobi.viewer.controller.StringConstants;\nimport io.goobi.viewer.controller.StringTools;\nimport io.goobi.viewer.exceptions.DAOException;\nimport io.goobi.viewer.exceptions.IDDOCNotFoundException;\nimport io.goobi.viewer.exceptions.IndexUnreachableException;\nimport io.goobi.viewer.exceptions.PresentationException;\nimport io.goobi.viewer.exceptions.RecordDeletedException;\nimport io.goobi.viewer.exceptions.RecordLimitExceededException;\nimport io.goobi.viewer.exceptions.RecordNotFoundException;\nimport io.goobi.viewer.exceptions.ViewerConfigurationException;\nimport io.goobi.viewer.faces.validators.PIValidator;\nimport io.goobi.viewer.faces.validators.SolrQueryValidator;\nimport io.goobi.viewer.managedbeans.utils.BeanUtils;\nimport io.goobi.viewer.messages.Messages;\nimport io.goobi.viewer.messages.ViewerResourceBundle;\nimport io.goobi.viewer.model.annotation.PublicationStatus;\nimport io.goobi.viewer.model.annotation.comments.CommentGroup;\nimport io.goobi.viewer.model.cms.pages.CMSPage;\nimport io.goobi.viewer.model.crowdsourcing.DisplayUserGeneratedContent;\nimport io.goobi.viewer.model.crowdsourcing.DisplayUserGeneratedContent.ContentType;\nimport io.goobi.viewer.model.job.download.DownloadJob;\nimport io.goobi.viewer.model.job.download.DownloadOption;\nimport io.goobi.viewer.model.job.download.EPUBDownloadJob;\nimport io.goobi.viewer.model.job.download.PDFDownloadJob;\nimport io.goobi.viewer.model.maps.GeoMap;\nimport io.goobi.viewer.model.maps.GeoMap.GeoMapType;\nimport io.goobi.viewer.model.maps.GeoMapFeature;\nimport io.goobi.viewer.model.search.BrowseElement;\nimport io.goobi.viewer.model.search.SearchHelper;\nimport io.goobi.viewer.model.search.SearchHit;\nimport io.goobi.viewer.model.security.AccessConditionUtils;\nimport io.goobi.viewer.model.security.AccessPermission;\nimport io.goobi.viewer.model.security.IPrivilegeHolder;\nimport io.goobi.viewer.model.statistics.usage.RequestType;\nimport io.goobi.viewer.model.toc.TOC;\nimport io.goobi.viewer.model.toc.TOCElement;\nimport io.goobi.viewer.model.toc.export.pdf.TocWriter;\nimport io.goobi.viewer.model.toc.export.pdf.WriteTocException;\nimport io.goobi.viewer.model.translations.language.Language;\nimport io.goobi.viewer.model.viewer.PageOrientation;\nimport io.goobi.viewer.model.viewer.PageType;\nimport io.goobi.viewer.model.viewer.PhysicalElement;\nimport io.goobi.viewer.model.viewer.StructElement;\nimport io.goobi.viewer.model.viewer.ViewManager;\nimport io.goobi.viewer.model.viewer.pageloader.AbstractPageLoader;\nimport io.goobi.viewer.modules.IModule;\nimport io.goobi.viewer.solr.SolrConstants;\nimport io.goobi.viewer.solr.SolrConstants.DocType;\nimport io.goobi.viewer.solr.SolrSearchIndex;\nimport io.goobi.viewer.solr.SolrTools;\n\n/**\n * This bean opens the requested record and provides all data relevant to this record.\n */\n@Named\n@SessionScoped\npublic class ActiveDocumentBean implements Serializable {\n\n    private static final long serialVersionUID = -8686943862186336894L;\n\n    private static final Logger logger = LogManager.getLogger(ActiveDocumentBean.class);\n\n    /**\n     * Regex pattern 'imageToShow' matches if doublePageMode should be active\n     */\n    private static final String DOUBLE_PAGE_PATTERN = \"\\\\d+-\\\\d+\";\n\n    private static int imageContainerWidth = 600;\n\n    private final transient Object lock = new Object();\n\n    @Inject\n    private NavigationHelper navigationHelper;\n    @Inject\n    private CmsBean cmsBean;\n    @Inject\n    private SearchBean searchBean;\n    @Inject\n    private BookmarkBean bookmarkBean;\n    @Inject\n    private ImageDeliveryBean imageDelivery;\n    @Inject\n    private BreadcrumbBean breadcrumbBean;\n\n    /** URL parameter 'action'. */\n    private String action = \"\";\n    /** URL parameter 'imageToShow'. */\n    private String imageToShow = \"1\";\n    /** URL parameter 'logid'. */\n    private String logid = \"\";\n    /** URL parameter 'tocCurrentPage'. */\n    private int tocCurrentPage = 1;\n\n    private ViewManager viewManager;\n    private boolean anchor = false;\n    private boolean volume = false;\n    private boolean group = false;\n    protected long topDocumentIddoc = 0;\n\n    // TODO move to SearchBean\n    private BrowseElement prevHit;\n    private BrowseElement nextHit;\n\n    /** This persists the last value given to setPersistentIdentifier() and is used for handling a RecordNotFoundException. */\n    String lastReceivedIdentifier;\n    /** Available languages for this record. */\n    private List<String> recordLanguages;\n    /** Currently selected language for multilingual records. */\n    private String selectedRecordLanguage;\n\n    private Boolean deleteRecordKeepTrace;\n\n    private String clearCacheMode;\n\n    private Map<String, GeoMap> geoMaps = new HashMap<>();\n\n    private int reloads = 0;\n\n    private boolean downloadImageModalVisible = false;\n\n    private String selectedDownloadOptionLabel;\n    /* Previous docstruct URL cache. TODO Implement differently once other views beside full-screen are used. */\n    private Map<String, String> prevDocstructUrlCache = new HashMap<>();\n    /* Next docstruct URL cache. TODO Implement differently once other views beside full-screen are used. */\n    private Map<String, String> nextDocstructUrlCache = new HashMap<>();\n\n    /**\n     * Empty constructor.\n     */\n    public ActiveDocumentBean() {\n        // the emptiness inside\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param navigationHelper the navigationHelper to set\n     */\n    public void setNavigationHelper(NavigationHelper navigationHelper) {\n        this.navigationHelper = navigationHelper;\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param cmsBean the cmsBean to set\n     */\n    public void setCmsBean(CmsBean cmsBean) {\n        this.cmsBean = cmsBean;\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param searchBean the searchBean to set\n     */\n    public void setSearchBean(SearchBean searchBean) {\n        this.searchBean = searchBean;\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param bookshelfBean the bookshelfBean to set\n     */\n    public void setBookshelfBean(BookmarkBean bookshelfBean) {\n        this.bookmarkBean = bookshelfBean;\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param breadcrumbBean the breadcrumbBean to set\n     */\n    public void setBreadcrumbBean(BreadcrumbBean breadcrumbBean) {\n        this.breadcrumbBean = breadcrumbBean;\n    }\n\n    /**\n     * TODO This can cause NPEs if called while update() is running.\n     *\n     * @throws IndexUnreachableException\n     * @should reset lastReceivedIdentifier\n     */\n    public void reset() throws IndexUnreachableException {\n        synchronized (this) {\n            logger.trace(\"reset (thread {})\", Thread.currentThread().getId());\n            String pi = viewManager != null ? viewManager.getPi() : null;\n            viewManager = null;\n            topDocumentIddoc = 0;\n            logid = \"\";\n            action = \"\";\n            prevHit = null;\n            nextHit = null;\n            group = false;\n            clearCacheMode = null;\n            prevDocstructUrlCache.clear();\n            nextDocstructUrlCache.clear();\n            lastReceivedIdentifier = null;\n\n            // Any cleanup modules need to do when a record is unloaded\n            for (IModule module : DataManager.getInstance().getModules()) {\n                module.augmentResetRecord();\n            }\n\n            // Remove record lock for this record and session\n            if (BeanUtils.getSession() != null) {\n                DataManager.getInstance()\n                        .getRecordLockManager()\n                        .removeLockForPiAndSessionId(pi, BeanUtils.getSession().getId());\n            }\n        }\n    }\n\n    /**\n     * Do not call from ActiveDocumentBean.update()!\n     *\n     * @return a {@link io.goobi.viewer.model.viewer.ViewManager} object.\n     */\n    public ViewManager getViewManager() {\n        if (viewManager == null) {\n            try {\n                try {\n                    update();\n                } catch (IDDOCNotFoundException e) {\n                    reload(lastReceivedIdentifier);\n                }\n            } catch (PresentationException e) {\n                logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage());\n            } catch (RecordNotFoundException | RecordDeletedException | RecordLimitExceededException e) {\n                if (e.getMessage() != null && !\"null\".equals(e.getMessage()) && !\"???\".equals(e.getMessage())) {\n                    logger.warn(\"{}: {}\", e.getClass().getName(), e.getMessage());\n                }\n            } catch (IndexUnreachableException | DAOException | ViewerConfigurationException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n\n        return viewManager;\n    }\n\n    /**\n     *\n     * @param pi @throws PresentationException @throws RecordNotFoundException @throws RecordDeletedException @throws\n     *            IndexUnreachableException @throws DAOException @throws ViewerConfigurationException @throws RecordLimitExceededException @throws\n     */\n    public String reload(String pi) throws PresentationException, RecordNotFoundException, RecordDeletedException, IndexUnreachableException,\n            DAOException, ViewerConfigurationException, RecordLimitExceededException {\n        logger.trace(\"reload({})\", pi);\n        reloads++;\n        reset();\n        if (reloads > 3) {\n            throw new RecordNotFoundException(pi);\n        }\n        setPersistentIdentifier(pi);\n        //        setImageToShow(1);\n        return open();\n    }\n\n    /**\n     * Loads the record with the IDDOC set in <code>currentElementIddoc</code>.\n     *\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     * @throws io.goobi.viewer.exceptions.RecordDeletedException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     * @throws IDDOCNotFoundException\n     * @throws RecordLimitExceededException\n     * @throws NumberFormatException\n     * @should create ViewManager correctly\n     * @should update ViewManager correctly if LOGID has changed\n     * @should not override topDocumentIddoc if LOGID has changed\n     * @should throw RecordNotFoundException if listing not allowed by default\n     * @should load records that have been released via moving wall\n     */\n\n    public void update() throws PresentationException, IndexUnreachableException, RecordNotFoundException, RecordDeletedException, DAOException,\n            ViewerConfigurationException, IDDOCNotFoundException, NumberFormatException, RecordLimitExceededException {\n        synchronized (this) {\n            if (topDocumentIddoc == 0) {\n                try {\n                    if (StringUtils.isNotEmpty(lastReceivedIdentifier)) {\n                        throw new RecordNotFoundException(lastReceivedIdentifier);\n                    }\n                    throw new RecordNotFoundException(\"???\");\n                } finally {\n                    lastReceivedIdentifier = null;\n                }\n            }\n            logger.debug(\"update(): (IDDOC {} ; page {} ; thread {})\", topDocumentIddoc, imageToShow, Thread.currentThread().getId());\n            prevHit = null;\n            nextHit = null;\n            boolean doublePageMode = isDoublePageUrl();\n            // Do these steps only if a new document has been loaded\n            boolean mayChangeHitIndex = false;\n            if (viewManager == null || viewManager.getTopStructElement() == null || viewManager.getTopStructElementIddoc() != topDocumentIddoc) {\n                anchor = false;\n                volume = false;\n                group = false;\n\n                // Change current hit index only if loading a new record\n                if (searchBean != null && searchBean.getCurrentSearch() != null) {\n                    searchBean.increaseCurrentHitIndex();\n                    mayChangeHitIndex = true;\n                }\n\n                StructElement topStructElement = new StructElement(topDocumentIddoc);\n\n                // Exit here if record is not found or has been deleted\n                if (!topStructElement.isExists()) {\n                    logger.info(\"IDDOC for the current record '{}' ({}) no longer seems to exist, attempting to retrieve an updated IDDOC...\",\n                            topStructElement.getPi(), topDocumentIddoc);\n                    topDocumentIddoc = DataManager.getInstance().getSearchIndex().getIddocFromIdentifier(topStructElement.getPi());\n                    if (topDocumentIddoc == 0) {\n                        logger.warn(\"New IDDOC for the current record '{}' could not be found. Perhaps this record has been deleted?\",\n                                topStructElement.getPi());\n                        reset();\n                        try {\n                            throw new RecordNotFoundException(lastReceivedIdentifier);\n                        } finally {\n                            lastReceivedIdentifier = null;\n                        }\n                    }\n                } else if (topStructElement.isDeleted()) {\n                    logger.debug(\"Record '{}' is deleted and only available as a trace document.\", topStructElement.getPi());\n                    reset();\n                    throw new RecordDeletedException(topStructElement.getPi());\n                }\n\n                // Do not open records who may not be listed for the current user\n                List<String> requiredAccessConditions = topStructElement.getMetadataValues(SolrConstants.ACCESSCONDITION);\n                if (requiredAccessConditions != null && !requiredAccessConditions.isEmpty()) {\n                    AccessPermission access =\n                            AccessConditionUtils.checkAccessPermission(new HashSet<>(requiredAccessConditions), IPrivilegeHolder.PRIV_LIST,\n                                    new StringBuilder().append('+').append(SolrConstants.PI).append(':').append(topStructElement.getPi()).toString(),\n                                    (HttpServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest());\n                    if (!access.isGranted()) {\n                        logger.debug(\"User may not open {}\", topStructElement.getPi());\n                        try {\n                            throw new RecordNotFoundException(lastReceivedIdentifier);\n                        } finally {\n                            lastReceivedIdentifier = null;\n                        }\n                    }\n                    // If license type is configured to redirect to a URL, redirect here\n                    if (access.isRedirect() && StringUtils.isNotEmpty(access.getRedirectUrl())) {\n                        logger.debug(\"Redirecting to {}\", access.getRedirectUrl());\n                        try {\n                            FacesContext.getCurrentInstance().getExternalContext().redirect(access.getRedirectUrl());\n                            return;\n                        } catch (IOException e) {\n                            logger.error(e.getMessage());\n                            return;\n                        }\n                    }\n\n                }\n\n                viewManager = new ViewManager(topStructElement, AbstractPageLoader.create(topStructElement), topDocumentIddoc,\n                        logid, topStructElement.getMetadataValue(SolrConstants.MIMETYPE), imageDelivery);\n                viewManager.setToc(createTOC());\n\n                HttpSession session = BeanUtils.getSession();\n                // Release all locks for this session except the current record\n                if (session != null) {\n                    DataManager.getInstance()\n                            .getRecordLockManager()\n                            .removeLocksForSessionId(session.getId(), Collections.singletonList(viewManager.getPi()));\n                }\n                String limit = viewManager.getTopStructElement().getMetadataValue(SolrConstants.ACCESSCONDITION_CONCURRENTUSE);\n                // Lock limited view records, if limit exists and record has a license type that has this feature enabled\n                if (limit != null && AccessConditionUtils.isConcurrentViewsLimitEnabledForAnyAccessCondition(\n                        viewManager.getTopStructElement().getMetadataValues(SolrConstants.ACCESSCONDITION))) {\n                    if (session != null) {\n                        DataManager.getInstance()\n                                .getRecordLockManager()\n                                .lockRecord(viewManager.getPi(), session.getId(), Integer.valueOf(limit));\n                    } else {\n                        logger.debug(\"No session found, unable to lock limited view record {}\", topStructElement.getPi());\n                        try {\n                            throw new RecordLimitExceededException(lastReceivedIdentifier + \":\" + limit);\n                        } finally {\n                            lastReceivedIdentifier = null;\n                        }\n                    }\n                }\n            }\n\n            //update usage statistics\n            DataManager.getInstance()\n                    .getUsageStatisticsRecorder()\n                    .recordRequest(RequestType.RECORD_VIEW, viewManager.getPi(), BeanUtils.getRequest());\n\n            // If LOGID is set, update the current element\n            if (StringUtils.isNotEmpty(logid) && viewManager != null && !logid.equals(viewManager.getLogId())) {\n                // TODO set new values instead of re-creating ViewManager, perhaps\n                logger.debug(\"Find doc by LOGID: {}\", logid);\n                new StructElement(topDocumentIddoc);\n                String query = new StringBuilder(\"+\")\n                        .append(SolrConstants.LOGID)\n                        .append(\":\\\"\")\n                        .append(logid)\n                        .append(\"\\\" +\")\n                        .append(SolrConstants.PI_TOPSTRUCT)\n                        .append(\":\")\n                        .append(viewManager.getPi())\n                        .append(\" +\")\n                        .append(SolrConstants.DOCTYPE)\n                        .append(':')\n                        .append(DocType.DOCSTRCT.name())\n                        .toString();\n                SolrDocumentList docList = DataManager.getInstance()\n                        .getSearchIndex()\n                        .search(query, 1, null, Collections.singletonList(SolrConstants.IDDOC));\n                long subElementIddoc = 0;\n                // TODO check whether creating a new ViewManager can be avoided here\n                if (!docList.isEmpty()) {\n                    subElementIddoc = Long.valueOf((String) docList.get(0).getFieldValue(SolrConstants.IDDOC));\n                    // Re-initialize ViewManager with the new current element\n                    PageOrientation firstPageOrientation = viewManager.getFirstPageOrientation();\n                    viewManager = new ViewManager(viewManager.getTopStructElement(), viewManager.getPageLoader(), subElementIddoc, logid,\n                            viewManager.getMimeType(), imageDelivery);\n                    viewManager.setFirstPageOrientation(firstPageOrientation);\n                    viewManager.setToc(createTOC());\n                } else {\n                    logger.warn(\"{} not found for LOGID '{}'.\", SolrConstants.IDDOC, logid);\n                }\n            }\n\n            if (viewManager != null && viewManager.getCurrentStructElement() != null) {\n                viewManager.setDoublePageMode(doublePageMode);\n                StructElement structElement = viewManager.getCurrentStructElement();\n                if (!structElement.isExists()) {\n                    logger.trace(\"StructElement {} is not marked as existing. Record will be reloaded\", structElement.getLuceneId());\n                    try {\n                        throw new IDDOCNotFoundException(lastReceivedIdentifier + \" - \" + structElement.getLuceneId());\n                    } finally {\n                        lastReceivedIdentifier = null;\n                    }\n                }\n                if (structElement.isAnchor()) {\n                    anchor = true;\n                }\n                if (structElement.isVolume()) {\n                    volume = true;\n                }\n                if (structElement.isGroup()) {\n                    group = true;\n                }\n\n                viewManager.setCurrentImageOrderString(imageToShow);\n                viewManager.updateDropdownSelected();\n\n                // Search hit navigation\n                if (searchBean != null && searchBean.getCurrentSearch() != null) {\n                    if (searchBean.getCurrentHitIndex() < 0) {\n                        // Determine the index of this element in the search result list. Must be done after re-initializing ViewManager so that the PI is correct!\n                        searchBean.findCurrentHitIndex(getPersistentIdentifier(), viewManager.getCurrentImageOrder(), true);\n                    } else if (mayChangeHitIndex) {\n                        // Modify the current hit index\n                        searchBean.increaseCurrentHitIndex();\n                    } else if (searchBean.getHitIndexOperand() != 0) {\n                        // Reset hit index operand (should only be necessary if the URL was called twice, but the current hit has not changed\n                        // logger.trace(\"Hit index modifier operand is {}, resetting...\", searchBean.getHitIndexOperand());\n                        searchBean.setHitIndexOperand(0);\n                    }\n                }\n            } else {\n                logger.debug(\"ViewManager is null or ViewManager.currentDocument is null.\");\n                try {\n                    throw new RecordNotFoundException(lastReceivedIdentifier);\n                } finally {\n                    lastReceivedIdentifier = null;\n                }\n            }\n\n            // Metadata language versions\n            recordLanguages = viewManager.getTopStructElement().getMetadataValues(SolrConstants.LANGUAGE);\n            // If the record has metadata language versions, pre-select the current locale as the record language\n            //            if (StringUtils.isBlank(selectedRecordLanguage) && !recordLanguages.isEmpty()) {\n            if (StringUtils.isBlank(selectedRecordLanguage) && navigationHelper != null) {\n                selectedRecordLanguage = navigationHelper.getLocaleString();\n            }\n\n            // Prepare a new bookshelf item\n            if (bookmarkBean != null) {\n                bookmarkBean.prepareItemForBookmarkList();\n                if (bookmarkBean.getCurrentBookmark() == null || !viewManager.getPi().equals(bookmarkBean.getCurrentBookmark().getPi())) {\n                    bookmarkBean.prepareItemForBookmarkList();\n                }\n            }\n        }\n\n    }\n\n    /**\n     *\n     * @return true if the 'imageToShow' part of the url matches {@link #DOUBLE_PAGE_PATTERN}, i.e. if the url suggests that double page mode is\n     *         expected\n     */\n    private boolean isDoublePageUrl() {\n        return StringUtils.isNotBlank(imageToShow) && imageToShow.matches(DOUBLE_PAGE_PATTERN);\n    }\n\n    /**\n     * @throws PresentationException\n     * @throws IndexUnreachableException\n     * @throws DAOException\n     * @throws ViewerConfigurationException\n     */\n    private TOC createTOC() throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        TOC toc = new TOC();\n        synchronized (toc) {\n            if (viewManager != null) {\n                toc.generate(viewManager.getTopStructElement(), viewManager.isListAllVolumesInTOC(), viewManager.getMimeType(), tocCurrentPage);\n                // The TOC object will correct values that are too high, so update the local value, if necessary\n                if (toc.getCurrentPage() != this.tocCurrentPage) {\n                    this.tocCurrentPage = toc.getCurrentPage();\n                }\n            }\n        }\n        return toc;\n    }\n\n    /**\n     * Pretty-URL entry point.\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     * @throws io.goobi.viewer.exceptions.RecordDeletedException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     * @throws RecordLimitExceededException\n     * @throws PresentationException\n     */\n    public String open()\n            throws RecordNotFoundException, RecordDeletedException, IndexUnreachableException, DAOException, ViewerConfigurationException,\n            RecordLimitExceededException {\n        synchronized (this) {\n            logger.trace(\"open()\");\n            try {\n                update();\n                if (navigationHelper == null || viewManager == null) {\n                    return \"\";\n                }\n\n                IMetadataValue name = viewManager.getTopStructElement().getMultiLanguageDisplayLabel();\n                HttpServletRequest request = (HttpServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest();\n                URL url = PrettyContext.getCurrentInstance(request).getRequestURL();\n\n                for (String language : name.getLanguages()) {\n                    String translation = name.getValue(language).orElse(getPersistentIdentifier());\n                    if (translation != null && translation.length() > DataManager.getInstance().getConfiguration().getBreadcrumbsClipping()) {\n                        translation =\n                                new StringBuilder(translation.substring(0, DataManager.getInstance().getConfiguration().getBreadcrumbsClipping()))\n                                        .append(\"...\")\n                                        .toString();\n                        name.setValue(translation, language);\n                    }\n                }\n                // Fallback using the identifier as the label\n                if (name.isEmpty()) {\n                    name.setValue(getPersistentIdentifier());\n                }\n                logger.trace(\"topdocument label: {} \", name.getValue());\n                if (!PrettyContext.getCurrentInstance(request).getRequestURL().toURL().contains(\"/crowd\")) {\n                    breadcrumbBean.addRecordBreadcrumbs(viewManager, name, url);\n                }\n            } catch (PresentationException e) {\n                logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage(), e);\n                Messages.error(e.getMessage());\n            } catch (IDDOCNotFoundException e) {\n                try {\n                    return reload(lastReceivedIdentifier);\n                } catch (PresentationException e1) {\n                    logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage(), e);\n                }\n            }\n\n            reloads = 0;\n            return \"\";\n        }\n    }\n\n    /**\n     * <p>\n     * openFulltext.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     * @throws io.goobi.viewer.exceptions.RecordDeletedException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     * @throws PresentationException\n     * @throws RecordLimitExceededException\n     * @throws NumberFormatException\n     */\n    public String openFulltext()\n            throws RecordNotFoundException, RecordDeletedException, IndexUnreachableException, DAOException, ViewerConfigurationException,\n            PresentationException, NumberFormatException, RecordLimitExceededException {\n        open();\n        return \"viewFulltext\";\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>prevHit</code>.\n     * </p>\n     *\n     * @return a {@link io.goobi.viewer.model.search.BrowseElement} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public BrowseElement getPrevHit() throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (prevHit == null && searchBean != null) {\n            prevHit = searchBean.getPreviousElement();\n        }\n\n        return prevHit;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>nextHit</code>.\n     * </p>\n     *\n     * @return a {@link io.goobi.viewer.model.search.BrowseElement} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public BrowseElement getNextHit() throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (nextHit == null && searchBean != null) {\n            nextHit = searchBean.getNextElement();\n        }\n\n        return nextHit;\n    }\n\n    /**\n     ********************************* Getter and Setter **************************************\n     *\n     * @return a long.\n     */\n    public long getActiveDocumentIddoc() {\n        if (viewManager != null) {\n            return viewManager.getTopStructElementIddoc();\n        }\n\n        return 0;\n    }\n\n    /**\n     * <p>\n     * getCurrentElement.\n     * </p>\n     *\n     * @return the currentElement\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public StructElement getCurrentElement() throws IndexUnreachableException {\n        if (viewManager != null) {\n            return viewManager.getCurrentStructElement();\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>imageToShow</code>.\n     * </p>\n     *\n     * @param imageToShow the imageToShow to set\n     */\n    public void setImageToShow(String imageToShow) {\n        synchronized (lock) {\n            this.imageToShow = imageToShow;\n            if (viewManager != null) {\n                viewManager.setDropdownSelected(String.valueOf(imageToShow));\n            }\n            // Reset LOGID (the LOGID setter is called later by PrettyFaces, so if a value is passed, it will still be set)\n            setLogid(\"\");\n            logger.trace(\"imageToShow: {}\", this.imageToShow);\n        }\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>imageToShow</code>.\n     * </p>\n     *\n     * @return the imageToShow\n     */\n    public String getImageToShow() {\n        synchronized (lock) {\n            return imageToShow;\n        }\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>logid</code>.\n     * </p>\n     *\n     * @param logid the logid to set\n     */\n    public void setLogid(String logid) {\n        synchronized (this) {\n            if (\"-\".equals(logid)) {\n                this.logid = \"\";\n            } else {\n                this.logid = SolrTools.escapeSpecialCharacters(logid);\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>logid</code>.\n     * </p>\n     *\n     * @return the logid\n     */\n    public String getLogid() {\n        synchronized (this) {\n            if (StringUtils.isEmpty(logid)) {\n                return \"-\";\n            }\n\n            return logid;\n        }\n    }\n\n    /**\n     * <p>\n     * isAnchor.\n     * </p>\n     *\n     * @return the anchor\n     */\n    public boolean isAnchor() {\n        return anchor;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>anchor</code>.\n     * </p>\n     *\n     * @param anchor the anchor to set\n     */\n    public void setAnchor(boolean anchor) {\n        this.anchor = anchor;\n    }\n\n    /**\n     * <p>\n     * isVolume.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isVolume() {\n        return volume;\n    }\n\n    /**\n     * <p>\n     * isGroup.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isGroup() {\n        return group;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>action</code>.\n     * </p>\n     *\n     * @return the action\n     */\n    public String getAction() {\n        synchronized (this) {\n            return action;\n        }\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>action</code>.\n     * </p>\n     *\n     * @param action the action to set\n     */\n    public void setAction(String action) {\n        synchronized (this) {\n            logger.trace(\"setAction: \" + action);\n            this.action = action;\n            if (searchBean != null && action != null) {\n                switch (action) {\n                    case \"nextHit\":\n                        searchBean.setHitIndexOperand(1);\n                        break;\n                    case \"prevHit\":\n                        searchBean.setHitIndexOperand(-1);\n                        break;\n                    default:\n                        // do nothing\n                        break;\n\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * setPersistentIdentifier.\n     * </p>\n     *\n     * @param persistentIdentifier a {@link java.lang.String} object.\n     * @should determine currentElementIddoc correctly\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public void setPersistentIdentifier(String persistentIdentifier)\n            throws PresentationException, RecordNotFoundException, IndexUnreachableException {\n        synchronized (this) {\n            logger.trace(\"setPersistentIdentifier: {}\", persistentIdentifier);\n            lastReceivedIdentifier = persistentIdentifier;\n            if (!PIValidator.validatePi(persistentIdentifier)) {\n                logger.warn(\"Invalid identifier '{}'.\", persistentIdentifier);\n                reset();\n                return;\n                // throw new RecordNotFoundException(\"Illegal identifier: \" + persistentIdentifier);\n            }\n            if (!\"-\".equals(persistentIdentifier) && (viewManager == null || !persistentIdentifier.equals(viewManager.getPi()))) {\n                long id = DataManager.getInstance().getSearchIndex().getIddocFromIdentifier(persistentIdentifier);\n                if (id > 0) {\n                    if (topDocumentIddoc != id) {\n                        topDocumentIddoc = id;\n                        logger.trace(\"IDDOC found for {}: {}\", persistentIdentifier, id);\n                    }\n                } else {\n                    logger.warn(\"No IDDOC for identifier '{}' found.\", persistentIdentifier);\n                    reset();\n                    return;\n                    // throw new RecordNotFoundException(new StringBuilder(persistentIdentifier).toString());\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the PI of the currently loaded record. Only call this method after the update() method has re-initialized ViewManager, otherwise the\n     * previous PI may be returned!\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPersistentIdentifier() throws IndexUnreachableException {\n        synchronized (this) {\n            if (viewManager != null) {\n                return viewManager.getPi();\n            }\n            return \"-\";\n        }\n    }\n\n    /**\n     * <p>\n     * getThumbPart.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getThumbPart() throws IndexUnreachableException {\n        if (viewManager != null) {\n            return new StringBuilder(\"/\").append(getPersistentIdentifier())\n                    .append('/')\n                    .append(viewManager.getCurrentThumbnailPage())\n                    .append('/')\n                    .toString();\n        }\n\n        return \"\";\n    }\n\n    /**\n     * <p>\n     * getLogPart.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getLogPart() throws IndexUnreachableException {\n        return new StringBuilder(\"/\").append(getPersistentIdentifier())\n                .append('/')\n                .append(imageToShow)\n                .append('/')\n                .append(getLogid())\n                .append('/')\n                .toString();\n    }\n\n    // navigation in work\n\n    /**\n     * Returns the navigation URL for the given page type and number.\n     *\n     * @param pageType a {@link java.lang.String} object.\n     * @param pageOrderRange Single page number or range\n     * @should construct url correctly\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPageUrl(String pageType, String pageOrderRange) throws IndexUnreachableException {\n        StringBuilder sbUrl = new StringBuilder();\n        if (StringUtils.isBlank(pageType)) {\n            if (navigationHelper != null) {\n                pageType = navigationHelper.getCurrentView();\n                if (pageType == null) {\n                    pageType = PageType.viewObject.name();\n                }\n            }\n            if (StringUtils.isBlank(pageType)) {\n                pageType = PageType.viewObject.name();\n            }\n            // logger.trace(\"current view: {}\", pageType);\n        }\n\n        int[] pages = StringTools.getIntegerRange(pageOrderRange);\n        int page = pages[0];\n        int page2 = pages[1];\n\n        if (viewManager != null) {\n            page = Math.max(page, viewManager.getPageLoader().getFirstPageOrder());\n            page = Math.min(page, viewManager.getPageLoader().getLastPageOrder());\n            if (page2 != Integer.MAX_VALUE) {\n                page2 = Math.max(page2, viewManager.getPageLoader().getFirstPageOrder());\n                page2 = Math.min(page2, viewManager.getPageLoader().getLastPageOrder());\n            }\n        }\n        //        if (page == page2) {\n        //            page2 = Integer.MAX_VALUE;\n        //        }\n        String range = page + (page2 != Integer.MAX_VALUE ? \"-\" + page2 : \"\");\n        // logger.trace(\"final range: {}\", range);\n        sbUrl.append(BeanUtils.getServletPathWithHostAsUrlFromJsfContext())\n                .append('/')\n                .append(PageType.getByName(pageType).getName())\n                .append('/')\n                .append(getPersistentIdentifier())\n                .append('/')\n                .append(range)\n                .append('/');\n\n        return sbUrl.toString();\n    }\n\n    /**\n     * <p>\n     * getPageUrl.\n     * </p>\n     *\n     * @param pageOrderRange Single page number or range\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPageUrl(String pageOrderRange) throws IndexUnreachableException {\n        return getPageUrl(null, pageOrderRange);\n    }\n\n    /**\n     * <p>\n     * getPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPageUrl() throws IndexUnreachableException {\n        String pageType = null;\n        if (StringUtils.isBlank(pageType)) {\n            pageType = navigationHelper.getPreferredView();\n        }\n        if (StringUtils.isBlank(pageType)) {\n            pageType = navigationHelper.getCurrentView();\n        }\n        return getPageUrlByType(pageType);\n    }\n\n    /**\n     * <p>\n     * getPageUrl.\n     * </p>\n     *\n     * @param pageType a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPageUrlByType(String pageType) throws IndexUnreachableException {\n        StringBuilder sbUrl = new StringBuilder();\n        sbUrl.append(BeanUtils.getServletPathWithHostAsUrlFromJsfContext())\n                .append('/')\n                .append(PageType.getByName(pageType).getName())\n                .append('/')\n                .append(getPersistentIdentifier())\n                .append('/');\n\n        return sbUrl.toString();\n    }\n\n    /**\n     * <p>\n     * getFirstPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getFirstPageUrl() throws IndexUnreachableException {\n        if (viewManager != null) {\n            int image = viewManager.getPageLoader().getFirstPageOrder();\n            if (viewManager.isDoublePageMode()) {\n                return getPageUrl(image + \"-\" + image);\n            }\n\n            return getPageUrl(Integer.toString(image));\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * getLastPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getLastPageUrl() throws IndexUnreachableException {\n        if (viewManager != null) {\n            int image = viewManager.getPageLoader().getLastPageOrder();\n            if (viewManager.isDoublePageMode()) {\n                return getPageUrl(image + \"-\" + image);\n            }\n\n            return getPageUrl(Integer.toString(image));\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * getNextPageUrl.\n     * </p>\n     *\n     * @param step a int.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     * @should return correct page in single page mode\n     * @should return correct range in double page mode if current page double image\n     * @should return correct range in double page mode if currently showing two pages\n     * @should return correct range in double page mode if currently showing one page\n     */\n    public String getPageUrlRelativeToCurrentPage(int step) throws IndexUnreachableException, DAOException {\n        // logger.trace(\"getPageUrl: {}\", step);\n        if (viewManager == null) {\n            return getPageUrl(imageToShow);\n        }\n\n        if (!viewManager.isDoublePageMode()) {\n            int number = viewManager.getCurrentImageOrder() + step;\n            return getPageUrl(String.valueOf(number));\n        }\n\n        int number;\n\n        // Current image contains two pages\n        if (viewManager.getCurrentPage().isDoubleImage()) {\n            // logger.trace(\"{} is double page\", viewManager.getCurrentPage().getOrder());\n            if (step < 0) {\n                number = viewManager.getCurrentImageOrder() + 2 * step;\n            } else {\n                number = viewManager.getCurrentImageOrder() + step;\n            }\n            return getPageUrl(number + \"-\" + (number + 1));\n        }\n\n        // Use current left/right page as a point of reference, if available (opposite when in right-to-left navigation)\n        Optional<PhysicalElement> currentLeftPage =\n                viewManager.getTopStructElement().isRtl() ? viewManager.getCurrentRightPage() : viewManager.getCurrentLeftPage();\n        Optional<PhysicalElement> currentRightPage =\n                viewManager.getTopStructElement().isRtl() ? viewManager.getCurrentLeftPage() : viewManager.getCurrentRightPage();\n\n        // Only go back one step unit at first\n        if (currentLeftPage.isPresent()) {\n            // logger.trace(\"{} is left page\", currentLeftPage.get().getOrder());\n            number = currentLeftPage.get().getOrder() + step;\n        } else if (currentRightPage.isPresent()) {\n            // If only the right page is present, it's probably the first page - do not add step at this point\n            // logger.trace(\"{} is right page\", currentRightPage.get().getOrder());\n            number = currentRightPage.get().getOrder();\n        } else {\n            number = viewManager.getCurrentImageOrder() + step;\n        }\n\n        // Target image candidate contains two pages\n        Optional<PhysicalElement> nextPage = viewManager.getPage(number);\n        if (nextPage.isPresent() && nextPage.get().isDoubleImage()) {\n            return getPageUrl(String.valueOf(number) + \"-\" + String.valueOf(number));\n        }\n        // If the immediate neighbor is not a double image, add another step\n        number += step;\n\n        nextPage = viewManager.getPage(number);\n        if (nextPage.isPresent() && nextPage.get().isDoubleImage()) {\n            return getPageUrl(String.valueOf(number) + \"-\" + String.valueOf(number));\n        }\n\n        // logger.trace(\"step: {}\", step);\n        // logger.trace(\"Number: {}\", number);\n\n        return getPageUrl(number + \"-\" + (number + 1));\n    }\n\n    public String getPageUrl(int order) throws IndexUnreachableException {\n        return getPageUrl(Integer.toString(order));\n    }\n\n    /**\n     * <p>\n     * getPreviousPageUrl.\n     * </p>\n     *\n     * @param step\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getPreviousPageUrl(int step) throws IndexUnreachableException, DAOException {\n        return getPageUrlRelativeToCurrentPage(step * -1);\n    }\n\n    /**\n     * <p>\n     * getNextPageUrl.\n     * </p>\n     *\n     * @param step\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getNextPageUrl(int step) throws IndexUnreachableException, DAOException {\n        return getPageUrlRelativeToCurrentPage(step);\n    }\n\n    /**\n     * <p>\n     * getPreviousPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getPreviousPageUrl() throws IndexUnreachableException, DAOException {\n        return getPreviousPageUrl(1);\n    }\n\n    /**\n     * <p>\n     * getNextPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getNextPageUrl() throws IndexUnreachableException, DAOException {\n        return getNextPageUrl(1);\n    }\n\n    /**\n     *\n     * @return\n     * @throws IndexUnreachableException\n     * @throws ViewerConfigurationException\n     * @throws DAOException\n     * @throws PresentationException\n     */\n    public String getPreviousDocstructUrl() throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        // logger.trace(\"getPreviousDocstructUrl\");\n        if (viewManager == null) {\n            return null;\n        }\n        List<String> docstructTypes =\n                DataManager.getInstance().getConfiguration().getDocstructNavigationTypes(viewManager.getTopStructElement().getDocStructType(), true);\n        if (docstructTypes.isEmpty()) {\n            return null;\n        }\n\n        String currentDocstructIddoc = String.valueOf(viewManager.getCurrentStructElementIddoc());\n        // Determine docstruct URL and cache it\n        if (prevDocstructUrlCache.get(currentDocstructIddoc) == null) {\n            int currentElementIndex = getToc().findTocElementIndexByIddoc(currentDocstructIddoc);\n            if (currentElementIndex == -1) {\n                logger.warn(\"Current IDDOC not found in TOC: {}\", viewManager.getCurrentStructElement().getLuceneId());\n                return null;\n            }\n\n            boolean found = false;\n            for (int i = currentElementIndex - 1; i >= 0; --i) {\n                TOCElement tocElement = viewManager.getToc().getTocElements().get(i);\n                String docstructType = tocElement.getMetadataValue(SolrConstants.DOCSTRCT);\n                if (docstructType != null && docstructTypes.contains(docstructType) && StringUtils.isNotBlank(tocElement.getPageNo())) {\n                    logger.trace(\"Found previous {}: {}\", docstructType, tocElement.getLogId());\n                    // Add LOGID to the URL because ViewManager.currentStructElementIddoc (IDDOC_OWNER) can be incorrect in the index sometimes,\n                    // resulting in the URL pointing at the current element\n                    prevDocstructUrlCache.put(currentDocstructIddoc,\n                            \"/\" + viewManager.getPi() + \"/\" + Integer.valueOf(tocElement.getPageNo()) + \"/\" + tocElement.getLogId() + \"/\");\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                prevDocstructUrlCache.put(currentDocstructIddoc, \"\");\n            }\n        }\n\n        if (StringUtils.isNotEmpty(prevDocstructUrlCache.get(currentDocstructIddoc))) {\n            return BeanUtils.getServletPathWithHostAsUrlFromJsfContext() + \"/\" + navigationHelper.getCurrentPageType().getName()\n                    + prevDocstructUrlCache.get(currentDocstructIddoc);\n        }\n\n        return \"\";\n    }\n\n    /**\n     *\n     * @return\n     * @throws IndexUnreachableException\n     * @throws ViewerConfigurationException\n     * @throws DAOException\n     * @throws PresentationException\n     */\n    public String getNextDocstructUrl() throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        // logger.trace(\"getNextDocstructUrl\");\n        if (viewManager == null) {\n            return \"\";\n        }\n        List<String> docstructTypes =\n                DataManager.getInstance().getConfiguration().getDocstructNavigationTypes(viewManager.getTopStructElement().getDocStructType(), true);\n        if (docstructTypes.isEmpty()) {\n            return null;\n        }\n\n        String currentDocstructIddoc = String.valueOf(viewManager.getCurrentStructElementIddoc());\n        // Determine docstruct URL and cache it\n        if (nextDocstructUrlCache.get(currentDocstructIddoc) == null) {\n            int currentElementIndex = getToc().findTocElementIndexByIddoc(currentDocstructIddoc);\n            logger.trace(\"currentIndexElement: {}\", currentElementIndex);\n            if (currentElementIndex == -1) {\n                return null;\n            }\n\n            boolean found = false;\n            for (int i = currentElementIndex + 1; i < viewManager.getToc().getTocElements().size(); ++i) {\n                TOCElement tocElement = viewManager.getToc().getTocElements().get(i);\n                String docstructType = tocElement.getMetadataValue(SolrConstants.DOCSTRCT);\n                if (docstructType != null && docstructTypes.contains(docstructType)) {\n                    logger.trace(\"Found next {}: {}\", docstructType, tocElement.getLogId());\n                    // Add LOGID to the URL because ViewManager.currentStructElementIddoc (IDDOC_OWNER) can be incorrect in the index sometimes,\n                    // resulting in the URL pointing at the current element\n                    nextDocstructUrlCache.put(currentDocstructIddoc,\n                            \"/\" + viewManager.getPi() + \"/\" + Integer.valueOf(tocElement.getPageNo()) + \"/\" + tocElement.getLogId() + \"/\");\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                nextDocstructUrlCache.put(currentDocstructIddoc, \"\");\n            }\n        }\n\n        if (StringUtils.isNotEmpty(nextDocstructUrlCache.get(currentDocstructIddoc))) {\n            return BeanUtils.getServletPathWithHostAsUrlFromJsfContext() + \"/\" + navigationHelper.getCurrentPageType().getName()\n                    + nextDocstructUrlCache.get(currentDocstructIddoc);\n        }\n\n        return \"\";\n    }\n\n    /**\n     * <p>\n     * getImageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getImageUrl() throws IndexUnreachableException {\n        return getPageUrl(PageType.viewImage.getName(), imageToShow);\n    }\n\n    /**\n     * <p>\n     * getFullscreenImageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getFullscreenImageUrl() throws IndexUnreachableException, DAOException {\n        if (viewManager != null && viewManager.isDoublePageMode() && !viewManager.getCurrentPage().isDoubleImage()) {\n            Optional<PhysicalElement> currentLeftPage = viewManager.getCurrentLeftPage();\n            Optional<PhysicalElement> currentRightPage = viewManager.getCurrentRightPage();\n            if (currentLeftPage.isPresent() && currentRightPage.isPresent()) {\n                return getPageUrl(PageType.viewFullscreen.getName(), currentLeftPage.get().getOrder() + \"-\" + currentRightPage.get().getOrder());\n            }\n        }\n\n        return getPageUrl(PageType.viewFullscreen.getName(), imageToShow);\n    }\n\n    /**\n     * <p>\n     * getReadingModeUrl.\n     * </p>\n     *\n     * @deprecated renamed to fullscreen\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getReadingModeUrl() throws IndexUnreachableException, DAOException {\n        return getFullscreenImageUrl();\n    }\n\n    /**\n     * <p>\n     * getFulltextUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getFulltextUrl() throws IndexUnreachableException {\n        return getPageUrl(PageType.viewFulltext.getName(), imageToShow);\n    }\n\n    /**\n     * <p>\n     * getMetadataUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getMetadataUrl() throws IndexUnreachableException {\n        return getPageUrl(PageType.viewMetadata.getName(), imageToShow);\n    }\n\n    /**\n     * <p>\n     * getTopDocument.\n     * </p>\n     *\n     * @return a {@link io.goobi.viewer.model.viewer.StructElement} object.\n     */\n    public StructElement getTopDocument() {\n        if (viewManager != null) {\n            return viewManager.getTopStructElement();\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * setChildrenVisible.\n     * </p>\n     *\n     * @param element a {@link io.goobi.viewer.model.toc.TOCElement} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public void setChildrenVisible(TOCElement element)\n            throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (getToc() != null) {\n            synchronized (getToc()) {\n                getToc().setChildVisible(element.getID());\n                getToc().getActiveElement();\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * setChildrenInvisible.\n     * </p>\n     *\n     * @param element a {@link io.goobi.viewer.model.toc.TOCElement} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public void setChildrenInvisible(TOCElement element)\n            throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (getToc() != null) {\n            synchronized (getToc()) {\n                getToc().setChildInvisible(element.getID());\n                getToc().getActiveElement();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the visibility of TOC elements and jumps to the active element after a +/- button has been pressed.\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String calculateSidebarToc()\n            throws IOException, PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (getToc() != null) {\n            TOCElement activeTocElement = getToc().getActiveElement();\n            if (activeTocElement != null) {\n                String result = new StringBuilder(\"#\").append(activeTocElement.getLogId()).toString();\n                FacesContext.getCurrentInstance().getExternalContext().redirect(result);\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>toc</code>.\n     * </p>\n     *\n     * @return the toc\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public TOC getToc() throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (viewManager == null) {\n            return null;\n        }\n\n        if (viewManager.getToc() == null) {\n            viewManager.setToc(createTOC());\n        }\n        return viewManager.getToc();\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>tocCurrentPage</code>.\n     * </p>\n     *\n     * @return a int.\n     */\n    public String getTocCurrentPage() {\n        synchronized (this) {\n            return Integer.toString(tocCurrentPage);\n        }\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>tocCurrentPage</code>.\n     * </p>\n     *\n     * @param tocCurrentPage a int.\n     * @should set toc page to last page if value too high\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public void setTocCurrentPage(String tocCurrentPage)\n            throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        synchronized (this) {\n            int[] pages = StringTools.getIntegerRange(tocCurrentPage);\n            this.tocCurrentPage = pages[0];\n            if (this.tocCurrentPage < 1) {\n                this.tocCurrentPage = 1;\n            }\n            // Do not call getToc() here - the setter is usually called before update(), so the required information for proper TOC creation is not yet available\n            if (viewManager != null && viewManager.getToc() != null) {\n                int currentCurrentPage = viewManager.getToc().getCurrentPage();\n                viewManager.getToc().setCurrentPage(this.tocCurrentPage);\n                // The TOC object will correct values that are too high, so update the local value, if necessary\n                if (viewManager.getToc().getCurrentPage() != this.tocCurrentPage) {\n                    this.tocCurrentPage = viewManager.getToc().getCurrentPage();\n                }\n                // Create a new TOC if pagination is enabled and the paginator page has changed\n                if (currentCurrentPage != this.tocCurrentPage && DataManager.getInstance().getConfiguration().getTocAnchorGroupElementsPerPage() > 0\n                        && viewManager != null) {\n                    viewManager.getToc()\n                            .generate(viewManager.getTopStructElement(), viewManager.isListAllVolumesInTOC(), viewManager.getMimeType(),\n                                    this.tocCurrentPage);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * getTitleBarLabel.\n     * </p>\n     *\n     * @param locale a {@link java.util.Locale} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String getTitleBarLabel(Locale locale)\n            throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        return getTitleBarLabel(locale.getLanguage());\n    }\n\n    /**\n     * <p>\n     * getTitleBarLabel.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String getTitleBarLabel() throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        Locale locale = BeanUtils.getLocale();\n        if (locale != null) {\n            return getTitleBarLabel(locale.getLanguage());\n        }\n\n        return getTitleBarLabel(MultiLanguageMetadataValue.DEFAULT_LANGUAGE);\n    }\n\n    /**\n     * <p>\n     * getTitleBarLabel.\n     * </p>\n     *\n     * @param language a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String getTitleBarLabel(String language)\n            throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        if (navigationHelper == null) {\n            return null;\n        }\n\n        if (PageType.getByName(navigationHelper.getCurrentPage()) != null\n                && PageType.getByName(navigationHelper.getCurrentPage()).isDocumentPage() && viewManager != null) {\n            // Prefer the label of the current TOC element\n            TOC toc = getToc();\n            if (toc != null && toc.getTocElements() != null && !toc.getTocElements().isEmpty()) {\n                String label = null;\n                String labelTemplate = \"_DEFAULT\";\n                if (getViewManager() != null) {\n                    labelTemplate = getViewManager().getTopStructElement().getDocStructType();\n                }\n                if (DataManager.getInstance().getConfiguration().isDisplayAnchorLabelInTitleBar(labelTemplate)\n                        && StringUtils.isNotBlank(viewManager.getAnchorPi())) {\n                    String prefix = DataManager.getInstance().getConfiguration().getAnchorLabelInTitleBarPrefix(labelTemplate);\n                    String suffix = DataManager.getInstance().getConfiguration().getAnchorLabelInTitleBarSuffix(labelTemplate);\n                    prefix = ViewerResourceBundle.getTranslation(prefix, Locale.forLanguageTag(language)).replace(\"_SPACE_\", \" \");\n                    suffix = ViewerResourceBundle.getTranslation(suffix, Locale.forLanguageTag(language)).replace(\"_SPACE_\", \" \");\n                    label = prefix = toc.getLabel(viewManager.getAnchorPi(), language) + suffix + toc.getLabel(viewManager.getPi(), language);\n                } else {\n                    label = toc.getLabel(viewManager.getPi(), language);\n                }\n                if (label != null) {\n                    return label;\n                }\n            }\n            String label = viewManager.getTopStructElement().getLabel(selectedRecordLanguage);\n            if (StringUtils.isNotEmpty(label)) {\n                return label;\n            }\n        } else if (cmsBean != null && navigationHelper.isCmsPage()) {\n            CMSPage cmsPage = cmsBean.getCurrentPage();\n            if (cmsPage != null) {\n                String cmsPageName = StringUtils.isNotBlank(cmsPage.getMenuTitle()) ? cmsPage.getMenuTitle() : cmsPage.getTitle();\n                if (StringUtils.isNotBlank(cmsPageName)) {\n                    return cmsPageName;\n                }\n            }\n        }\n\n        if (navigationHelper.getCurrentPageType() != null) {\n            PageType pageType = navigationHelper.getCurrentPageType();\n            if (PageType.other.equals(pageType)) {\n                String pageLabel = navigationHelper.getCurrentPage();\n                if (StringUtils.isNotBlank(pageLabel)) {\n                    return Messages.translate(pageLabel, Locale.forLanguageTag(language));\n                }\n            }\n            return Messages.translate(pageType.getLabel(), Locale.forLanguageTag(language));\n        }\n\n        return null;\n    }\n\n    /**\n     * Title bar label value escaped for JavaScript.\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String getLabelForJS() throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        String label = getTitleBarLabel();\n        if (label != null) {\n            return StringEscapeUtils.escapeEcmaScript(label);\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>imageContainerWidth</code>.\n     * </p>\n     *\n     * @return a int.\n     */\n    public int getImageContainerWidth() {\n        return imageContainerWidth;\n    }\n\n    /**\n     * <p>\n     * getNumberOfImages.\n     * </p>\n     *\n     * @return a int.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public int getNumberOfImages() throws IndexUnreachableException {\n        if (viewManager != null) {\n            return viewManager.getImagesCount();\n        }\n\n        return 0;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>topDocumentIddoc</code>.\n     * </p>\n     *\n     * @return Not this.topDocumentIddoc but ViewManager.topDocumentIddoc\n     */\n    public long getTopDocumentIddoc() {\n        if (viewManager != null) {\n            return viewManager.getTopStructElementIddoc();\n        }\n        return 0;\n    }\n\n    /**\n     * Indicates whether a record is currently properly loaded in this bean. Use to determine whether to display components.\n     *\n     * @return a boolean.\n     */\n    public boolean isRecordLoaded() {\n        return viewManager != null;\n    }\n\n    /**\n     * Checks if there is an anchor in this docStruct's hierarchy\n     *\n     * @return a boolean.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public boolean hasAnchor() throws IndexUnreachableException {\n        return getTopDocument().isAnchorChild();\n    }\n\n    /**\n     * Exports the currently loaded for re-indexing.\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     */\n    public String reIndexRecordAction() throws IndexUnreachableException, DAOException, RecordNotFoundException {\n        if (viewManager != null) {\n            if (IndexerTools.reIndexRecord(viewManager.getPi())) {\n                Messages.info(\"reIndexRecordSuccess\");\n            } else {\n                Messages.error(\"reIndexRecordFailure\");\n            }\n        }\n\n        return \"\";\n    }\n\n    /**\n     * <p>\n     * deleteRecordAction.\n     * </p>\n     *\n     * @param keepTraceDocument If true, a .delete file will be created; otherwise a .purge file\n     * @return outcome\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String deleteRecordAction(boolean keepTraceDocument) throws IOException, IndexUnreachableException {\n        try {\n            if (viewManager == null) {\n                return \"\";\n            }\n\n            if (IndexerTools.deleteRecord(viewManager.getPi(), keepTraceDocument,\n                    Paths.get(DataManager.getInstance().getConfiguration().getHotfolder()))) {\n                Messages.info(\"deleteRecord_success\");\n                return \"pretty:index\";\n            }\n            Messages.error(\"deleteRecord_failure\");\n        } finally {\n            deleteRecordKeepTrace = null;\n        }\n\n        return \"\";\n    }\n\n    /**\n     *\n     * @return\n     * @throws ClientProtocolException\n     * @throws IOException\n     * @throws IndexUnreachableException\n     */\n    public String clearCacheAction() throws ClientProtocolException, IOException, IndexUnreachableException {\n        logger.trace(\"clearCacheAction: {}\", clearCacheMode);\n        if (clearCacheMode == null || viewManager == null) {\n            return \"\";\n        }\n\n        String url = NetTools.buildClearCacheUrl(clearCacheMode, viewManager.getPi(), navigationHelper.getApplicationUrl(),\n                DataManager.getInstance().getConfiguration().getWebApiToken());\n        try {\n            try {\n                NetTools.getWebContentDELETE(url, null, null, null, null);\n                Messages.info(\"cache_clear__success\");\n            } catch (ClientProtocolException e) {\n                logger.error(e.getMessage());\n                Messages.error(\"cache_clear__failure\");\n            } catch (IOException e) {\n                logger.error(e.getMessage());\n                Messages.error(\"cache_clear__failure\");\n            }\n        } finally {\n            clearCacheMode = null;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * <p>\n     * getCurrentThumbnailPage.\n     * </p>\n     *\n     * @return a int.\n     */\n    public int getCurrentThumbnailPage() {\n        synchronized (this) {\n            return viewManager != null ? viewManager.getCurrentThumbnailPage() : 1;\n        }\n    }\n\n    /**\n     * <p>\n     * setCurrentThumbnailPage.\n     * </p>\n     *\n     * @param currentThumbnailPage a int.\n     */\n    public void setCurrentThumbnailPage(int currentThumbnailPage) {\n        synchronized (this) {\n            if (viewManager != null) {\n                viewManager.setCurrentThumbnailPage(currentThumbnailPage);\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * isHasLanguages.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isHasLanguages() {\n        return recordLanguages != null && !recordLanguages.isEmpty();\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>recordLanguages</code>.\n     * </p>\n     *\n     * @return the recordLanguages\n     */\n    public List<String> getRecordLanguages() {\n        return recordLanguages;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>recordLanguages</code>.\n     * </p>\n     *\n     * @param recordLanguages the recordLanguages to set\n     */\n    public void setRecordLanguages(List<String> recordLanguages) {\n        this.recordLanguages = recordLanguages;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>selectedRecordLanguage</code>.\n     * </p>\n     *\n     * @return the selectedRecordLanguage\n     */\n    public String getSelectedRecordLanguage() {\n        return selectedRecordLanguage;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>selectedRecordLanguage</code>.\n     * </p>\n     *\n     * @param selectedRecordLanguage the selectedRecordLanguage to set\n     */\n    public void setSelectedRecordLanguage(String selectedRecordLanguage) {\n        logger.trace(\"setSelectedRecordLanguage: {}\", selectedRecordLanguage);\n        if (selectedRecordLanguage != null && selectedRecordLanguage.length() == 3) {\n            // Map ISO-3 codes to their ISO-2 variant\n            Language language = DataManager.getInstance().getLanguageHelper().getLanguage(selectedRecordLanguage);\n            if (language != null) {\n                logger.trace(\"Mapped language found: {}\", language.getIsoCodeOld());\n                this.selectedRecordLanguage = language.getIsoCodeOld();\n            } else {\n                logger.warn(\"Language not found for code: {}\", selectedRecordLanguage);\n                this.selectedRecordLanguage = selectedRecordLanguage;\n            }\n        } else {\n            this.selectedRecordLanguage = selectedRecordLanguage;\n        }\n        MetadataBean mdb = BeanUtils.getMetadataBean();\n        if (mdb != null) {\n            mdb.setSelectedRecordLanguage(this.selectedRecordLanguage);\n        }\n    }\n\n    /**\n     * <p>\n     * isAccessPermissionEpub.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isAccessPermissionEpub() {\n        synchronized (this) {\n            try {\n                if ((navigationHelper != null && !isEnabled(EPUBDownloadJob.LOCAL_TYPE, navigationHelper.getCurrentPage())) || viewManager == null\n                        || !DownloadJob.ocrFolderExists(viewManager.getPi())) {\n                    return false;\n                }\n            } catch (PresentationException | IndexUnreachableException e) {\n                logger.error(\"Error checking EPUB resources: {}\", e.getMessage());\n                return false;\n            }\n\n            // TODO EPUB privilege type\n            return viewManager.isAccessPermissionPdf();\n        }\n    }\n\n    /**\n     * <p>\n     * isAccessPermissionPdf.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isAccessPermissionPdf() {\n        synchronized (this) {\n            if ((navigationHelper != null && !isEnabled(PDFDownloadJob.LOCAL_TYPE, navigationHelper.getCurrentPage())) || viewManager == null) {\n                return false;\n            }\n\n            return viewManager.isAccessPermissionPdf();\n        }\n    }\n\n    /**\n     * @param currentPage\n     * @return\n     */\n    private static boolean isEnabled(String downloadType, String pageTypeName) {\n        if (downloadType.equals(EPUBDownloadJob.LOCAL_TYPE) && !DataManager.getInstance().getConfiguration().isGeneratePdfInTaskManager()) {\n            return false;\n        }\n        PageType pageType = PageType.getByName(pageTypeName);\n        boolean pdf = PDFDownloadJob.LOCAL_TYPE.equals(downloadType);\n        if (pageType != null) {\n            switch (pageType) {\n                case viewToc:\n                    return pdf ? DataManager.getInstance().getConfiguration().isTocPdfEnabled()\n                            : DataManager.getInstance().getConfiguration().isTocEpubEnabled();\n                case viewMetadata:\n                    return pdf ? DataManager.getInstance().getConfiguration().isMetadataPdfEnabled()\n                            : DataManager.getInstance().getConfiguration().isMetadataEpubEnabled();\n                default:\n                    return pdf ? DataManager.getInstance().getConfiguration().isTitlePdfEnabled()\n                            : DataManager.getInstance().getConfiguration().isTitleEpubEnabled();\n            }\n        }\n\n        logger.warn(\"Unknown page type: {}\", pageTypeName);\n        return false;\n    }\n\n    /**\n     * <p>\n     * downloadTOCAction.\n     * </p>\n     *\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public void downloadTOCAction() throws IOException, PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        try {\n\n            String fileNameRaw = getToc().getTocElements().get(0).getLabel();\n            String fileName = fileNameRaw + \".pdf\";\n\n            FacesContext fc = FacesContext.getCurrentInstance();\n            ExternalContext ec = fc.getExternalContext();\n            ec.responseReset(); // Some JSF component library or some Filter might have set some headers in the buffer beforehand. We want to get rid of them, else it may collide.\n            ec.setResponseContentType(\"application/pdf\");\n            ec.setResponseHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\"\");\n            OutputStream os = ec.getResponseOutputStream();\n            TocWriter writer = new TocWriter(\"\", fileNameRaw);\n            writer.createPdfDocument(os, getToc().getTocElements());\n            fc.responseComplete(); // Important! Otherwise JSF will attempt to render the response which obviously will fail since it's already written with a file and closed.\n        } catch (IndexOutOfBoundsException e) {\n            logger.error(\"No toc to generate\");\n        } catch (WriteTocException e) {\n            logger.error(\"Error writing toc: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * <p>\n     * getRelatedItems.\n     * </p>\n     *\n     * @param identifierField Index field containing related item identifiers\n     * @return List of related items as SearchHit objects.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public List<SearchHit> getRelatedItems(String identifierField)\n            throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        logger.trace(\"getRelatedItems: {}\", identifierField);\n        if (identifierField == null) {\n            return null;\n        }\n        if (viewManager == null) {\n            return null;\n        }\n        String query = getRelatedItemsQueryString(identifierField);\n        if (query == null) {\n            return null;\n        }\n\n        List<SearchHit> ret = SearchHelper.searchWithAggregation(query, 0, SolrSearchIndex.MAX_HITS, null, null, null, null, null, null,\n                navigationHelper.getLocale(), 0);\n\n        logger.trace(\"{} related items found\", ret.size());\n        return ret;\n    }\n\n    /**\n     * Returns a query string containing all values of the given identifier field.\n     *\n     * @param identifierField Index field containing related item identifiers\n     * @return Query string of the pattern \"PI:(a OR b OR c)\"\n     * @should construct query correctly\n     */\n    public String getRelatedItemsQueryString(String identifierField) {\n        logger.trace(\"getRelatedItemsQueryString: {}\", identifierField);\n        List<String> relatedItemIdentifiers = viewManager.getTopStructElement().getMetadataValues(identifierField);\n        if (relatedItemIdentifiers.isEmpty()) {\n            return null;\n        }\n\n        StringBuilder sbQuery = new StringBuilder(SolrConstants.PI).append(\":(\");\n        int initLength = sbQuery.length();\n        for (String identifier : relatedItemIdentifiers) {\n            if (sbQuery.length() > initLength) {\n                sbQuery.append(\" OR \");\n            }\n            sbQuery.append(identifier);\n        }\n        sbQuery.append(')');\n\n        return sbQuery.toString();\n    }\n\n    /**\n     * Returns a string that contains previous and/or next url <link> elements\n     *\n     * @return string containing previous and/or next url <link> elements\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     */\n    public String getRelativeUrlTags() throws IndexUnreachableException, DAOException, PresentationException {\n        if (!isRecordLoaded() || navigationHelper == null) {\n            return \"\";\n        }\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"current view: {}\", navigationHelper.getCurrentView());\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        // Add canonical links\n        if (viewManager.getCurrentPage() != null) {\n            if (StringUtils.isNotEmpty(viewManager.getCurrentPage().getUrn())) {\n                String urnResolverUrl = DataManager.getInstance().getConfiguration().getUrnResolverUrl() + viewManager.getCurrentPage().getUrn();\n                sb.append(\"\\n<link rel=\\\"canonical\\\" href=\\\"\").append(urnResolverUrl).append(\"\\\" />\");\n            }\n            if (viewManager.getCurrentPage().equals(viewManager.getRepresentativePage())) {\n                String piResolverUrl = navigationHelper.getApplicationUrl() + \"piresolver?id=\" + viewManager.getPi();\n                sb.append(\"\\n<link rel=\\\"canonical\\\" href=\\\"\").append(piResolverUrl).append(\"\\\" />\");\n            }\n        }\n        PageType currentPageType = PageType.getByName(navigationHelper.getCurrentView());\n        if (currentPageType != null && StringUtils.isNotEmpty(currentPageType.name())) {\n            // logger.trace(\"page type: {}\", currentPageType.getName());\n            // logger.trace(\"current url: {}\", navigationHelper.getCurrentUrl());\n            String currentUrl = navigationHelper.getCurrentUrl();\n            \n            if(currentUrl.contains(SolrTools.unescapeSpecialCharacters(getLogid()))) {\n                currentUrl = currentUrl.replace(SolrTools.unescapeSpecialCharacters(getLogid()), getLogid());\n            }\n            \n            if (currentUrl.contains(\"!\" + currentPageType.getName())) {\n                // Preferred view - add regular view URL\n                sb.append(\"\\n<link rel=\\\"canonical\\\" href=\\\"\")\n                        .append(currentUrl.replace(\"!\" + currentPageType.getName(), currentPageType.getName()))\n                        .append(\"\\\" />\");\n            } else if (currentUrl.contains(currentPageType.getName())) {\n                // Regular view - add preferred view URL\n                sb.append(\"\\n<link rel=\\\"canonical\\\" href=\\\"\")\n                        .append(currentUrl.replace(currentPageType.getName(), \"!\" + currentPageType.getName()))\n                        .append(\"\\\" />\");\n            }\n        }\n\n        // Skip prev/next links for non-paginated views\n        if (PageType.viewMetadata.equals(currentPageType) || PageType.viewToc.equals(currentPageType)) {\n            return \"\";\n        }\n\n        // Add next/prev links\n        String currentUrl = getPageUrl(imageToShow);\n        String prevUrl = getPreviousPageUrl();\n        String nextUrl = getNextPageUrl();\n        if (StringUtils.isNotEmpty(nextUrl) && !nextUrl.equals(currentUrl)) {\n            sb.append(\"\\n<link rel=\\\"next\\\" href=\\\"\").append(nextUrl).append(\"\\\" />\");\n        }\n        if (StringUtils.isNotEmpty(prevUrl) && !prevUrl.equals(currentUrl)) {\n            sb.append(\"\\n<link rel=\\\"prev\\\" href=\\\"\").append(prevUrl).append(\"\\\" />\");\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * resets the access rights for user comments and pdf download stored in {@link io.goobi.viewer.model.viewer.ViewManager}. After reset, the access\n     * rights will be evaluated again on being called\n     */\n    public void resetAccess() {\n        if (getViewManager() != null) {\n            getViewManager().resetAccessPermissionPdf();\n            getViewManager().resetAllowUserComments();\n        }\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>deleteRecordKeepTrace</code>.\n     * </p>\n     *\n     * @return the deleteRecordKeepTrace\n     */\n    public Boolean getDeleteRecordKeepTrace() {\n        return deleteRecordKeepTrace;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>deleteRecordKeepTrace</code>.\n     * </p>\n     *\n     * @param deleteRecordKeepTrace the deleteRecordKeepTrace to set\n     */\n    public void setDeleteRecordKeepTrace(Boolean deleteRecordKeepTrace) {\n        this.deleteRecordKeepTrace = deleteRecordKeepTrace;\n    }\n\n    /**\n     * @return the clearCacheMode\n     */\n    public String getClearCacheMode() {\n        return clearCacheMode;\n    }\n\n    /**\n     * @param clearCacheMode the clearCacheMode to set\n     */\n    public void setClearCacheMode(String clearCacheMode) {\n        logger.trace(\"setClearCacheMode: {}\", clearCacheMode);\n        this.clearCacheMode = clearCacheMode;\n    }\n\n    /**\n     * Get a CMSSidebarElement with a map containing all GeoMarkers for the current PI. The widget is stored in the bean, but refreshed each time the\n     * PI changes\n     *\n     * @return\n     * @throws PresentationException\n     * @throws DAOException\n     * @throws IndexUnreachableException\n     */\n    public synchronized GeoMap getGeoMap() throws PresentationException, DAOException, IndexUnreachableException {\n        GeoMap widget = this.geoMaps.get(getPersistentIdentifier());\n        if (widget == null) {\n            widget = generateGeoMap(getPersistentIdentifier());\n            this.geoMaps = Collections.singletonMap(getPersistentIdentifier(), widget);\n        }\n        return widget;\n    }\n\n    /**\n     * \n     * @param pi\n     * @return\n     * @throws PresentationException\n     * @throws DAOException\n     */\n    public GeoMap generateGeoMap(String pi) throws PresentationException, DAOException {\n        try {\n            if (\"-\".equals(pi)) {\n                return null;\n            }\n\n            GeoMap map = new GeoMap();\n            map.setId(Long.MAX_VALUE);\n            map.setType(GeoMapType.MANUAL);\n            map.setShowPopover(true);\n            map.setMarkerTitleField(null);\n            map.setMarker(\"default\");\n\n            String mainDocQuery = String.format(\"PI:%s\", pi);\n            List<String> mainDocFields = PrettyUrlTools.getSolrFieldsToDeterminePageType();\n            SolrDocument mainDoc = DataManager.getInstance().getSearchIndex().getFirstDoc(mainDocQuery, mainDocFields);\n            PageType pageType = PrettyUrlTools.getPreferredPageType(mainDoc);\n\n            boolean addMetadataFeatures = DataManager.getInstance().getConfiguration().includeCoordinateFieldsFromMetadataDocs();\n            String docTypeFilter = \"+DOCTYPE:DOCSTRCT\";\n            if (addMetadataFeatures) {\n                docTypeFilter = \"+(DOCTYPE:DOCSTRCT DOCTYPE:METADATA)\";\n            }\n\n            String subDocQuery = String.format(\"+PI_TOPSTRUCT:%s \" + docTypeFilter, pi);\n            List<String> coordinateFields = DataManager.getInstance().getConfiguration().getGeoMapMarkerFields();\n            List<String> subDocFields = new ArrayList<>();\n            subDocFields.add(SolrConstants.LABEL);\n            subDocFields.add(SolrConstants.PI_TOPSTRUCT);\n            subDocFields.add(SolrConstants.THUMBPAGENO);\n            subDocFields.add(SolrConstants.LOGID);\n            subDocFields.add(SolrConstants.ISWORK);\n            subDocFields.add(SolrConstants.DOCTYPE);\n            subDocFields.add(\"MD_VALUE\");\n            subDocFields.addAll(coordinateFields);\n\n            Collection<GeoMapFeature> features = new ArrayList<>();\n\n            List<DisplayUserGeneratedContent> annos = DataManager.getInstance()\n                    .getDao()\n                    .getAnnotationsForWork(pi)\n                    .stream()\n                    .filter(a -> PublicationStatus.PUBLISHED.equals(a.getPublicationStatus()))\n                    .filter(a -> StringUtils.isNotBlank(a.getBody()))\n                    .map(a -> new DisplayUserGeneratedContent(a))\n                    .filter(a -> ContentType.GEOLOCATION.equals(a.getType()))\n                    .filter(a -> ContentBean.isAccessible(a, BeanUtils.getRequest()))\n                    .collect(Collectors.toList());\n            for (DisplayUserGeneratedContent anno : annos) {\n                if (anno.getAnnotationBody() instanceof TypedResource) {\n                    GeoMapFeature feature = new GeoMapFeature(((TypedResource) anno.getAnnotationBody()).asJson());\n                    features.add(feature);\n                }\n            }\n\n            SolrDocumentList subDocs = DataManager.getInstance().getSearchIndex().getDocs(subDocQuery, subDocFields);\n            if (subDocs != null) {\n                for (SolrDocument solrDocument : subDocs) {\n                    List<GeoMapFeature> docFeatures = new ArrayList<>();\n                    for (String coordinateField : coordinateFields) {\n                        String docType = solrDocument.getFieldValue(SolrConstants.DOCTYPE).toString();\n                        String labelField = \"METADATA\".equals(docType) ? \"MD_VALUE\" : SolrConstants.LABEL;\n                        docFeatures.addAll(GeoMap.getGeojsonPoints(solrDocument, coordinateField, labelField, null));\n                    }\n                    if (!solrDocument.containsKey(SolrConstants.ISWORK) && solrDocument.getFieldValue(SolrConstants.DOCTYPE).equals(\"DOCSTRCT\")) {\n                        docFeatures.forEach(f -> f.setLink(PrettyUrlTools.getRecordUrl(solrDocument, pageType)));\n                    } else {\n                        docFeatures.forEach(f -> f.setLink(null));\n                    }\n                    docFeatures.forEach(f -> f.setDocumentId((String) solrDocument.getFieldValue(SolrConstants.LOGID)));\n                    features.addAll(docFeatures);\n                }\n            }\n            //remove dubplicates\n            features = features.stream().distinct().collect(Collectors.toList());\n            if (!features.isEmpty()) {\n                map.setFeatures(features.stream().map(f -> f.getJsonObject().toString()).collect(Collectors.toList()));\n            }\n            return map;\n        } catch (IndexUnreachableException e) {\n            logger.error(\"Unable to load geomap\", e);\n            return null;\n        }\n    }\n\n    /**\n     *\n     */\n    public void toggleDownloadImageModal() {\n        downloadImageModalVisible = !downloadImageModalVisible;\n    }\n\n    /**\n     * @return the downloadImageModalVisible\n     */\n    public boolean isDownloadImageModalVisible() {\n        return downloadImageModalVisible;\n    }\n\n    /**\n     *\n     */\n    public DownloadOption getSelectedDownloadOption() {\n        if (selectedDownloadOptionLabel == null) {\n            return null;\n        }\n\n        return DownloadOption.getByLabel(selectedDownloadOptionLabel);\n    }\n\n    /**\n     * @return the selectedDownloadOptionLabel\n     */\n    public String getSelectedDownloadOptionLabel() {\n        return selectedDownloadOptionLabel;\n    }\n\n    /**\n     * @param selectedDownloadOptionLabel the selectedDownloadOptionLabel to set\n     */\n    public void setSelectedDownloadOptionLabel(String selectedDownloadOptionLabel) {\n        logger.trace(\"setSelectedDownloadOption: {}\", selectedDownloadOptionLabel != null ? selectedDownloadOptionLabel : null);\n        this.selectedDownloadOptionLabel = selectedDownloadOptionLabel;\n    }\n\n    public void setDownloadOptionLabelFromRequestParameter() {\n        Map<String, String> params = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap();\n\n        String value = params.get(\"optionvalue\");\n        if (StringUtils.isNotBlank(value)) {\n            setSelectedDownloadOptionLabel(value);\n        }\n\n    }\n\n    /**\n     * This method augments the setter <code>ViewManager.setDoublePageMode(boolean)</code> with URL modifications to reflect the mode.\n     *\n     * @param doublePageMode The doublePageMode to set\n     * @throws IndexUnreachableException\n     * @throws DAOException\n     * @should set imageToShow if value changes\n     */\n    public String setDoublePageModeAction(boolean doublePageMode) throws IndexUnreachableException, DAOException {\n        if (viewManager == null) {\n            return \"\";\n        }\n        try {\n            // Adapt URL page range when switching between single and double page modes\n            if (viewManager.isDoublePageMode() != doublePageMode) {\n                if (doublePageMode && !viewManager.getCurrentPage().isDoubleImage()) {\n                    Optional<PhysicalElement> currentLeftPage = viewManager.getCurrentLeftPage();\n                    Optional<PhysicalElement> currentRightPage = viewManager.getCurrentRightPage();\n                    if (currentLeftPage.isPresent() && currentRightPage.isPresent()) {\n                        imageToShow = currentLeftPage.get().getOrder() + \"-\" + currentRightPage.get().getOrder();\n                    } else if (currentLeftPage.isPresent()) {\n                        imageToShow = currentLeftPage.get().getOrder() + \"-\" + currentLeftPage.get().getOrder();\n                    } else if (currentRightPage.isPresent()) {\n                        imageToShow = currentRightPage.get().getOrder() + \"-\" + currentRightPage.get().getOrder();\n                    }\n                } else if (doublePageMode) {\n                    imageToShow = String.valueOf(viewManager.getCurrentPage().getOrder() + \"-\" + viewManager.getCurrentPage().getOrder());\n                } else {\n                    imageToShow = String.valueOf(viewManager.getCurrentPage().getOrder());\n                }\n            }\n        } finally {\n            viewManager.setDoublePageMode(doublePageMode);\n        }\n\n        // When not using PrettyContext, the updated URL will always be a click behind\n        if (PrettyContext.getCurrentInstance() != null && PrettyContext.getCurrentInstance().getCurrentMapping() != null) {\n            return \"pretty:\" + PrettyContext.getCurrentInstance().getCurrentMapping().getId();\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Indicates whether user comments are allowed for the current record based on several criteria.\n     *\n     * @return a boolean.\n     * @throws DAOException\n     */\n    public synchronized boolean isAllowUserComments() throws DAOException {\n        if (viewManager == null) {\n            return false;\n        }\n\n        CommentGroup commentGroupAll = DataManager.getInstance().getDao().getCommentGroupUnfiltered();\n        if (commentGroupAll == null) {\n            logger.warn(\"Comment view for all comments not found in the DB, please insert.\");\n            return false;\n        }\n        if (!commentGroupAll.isEnabled()) {\n            logger.trace(\"User comments disabled globally.\");\n            viewManager.setAllowUserComments(false);\n            return false;\n        }\n\n        if (viewManager.isAllowUserComments() == null) {\n            try {\n                if (StringUtils.isNotEmpty(commentGroupAll.getSolrQuery()) && DataManager.getInstance()\n                        .getSearchIndex()\n                        .getHitCount(new StringBuilder(\"+\").append(SolrConstants.PI)\n                                .append(':')\n                                .append(viewManager.getPi())\n                                .append(\" +(\")\n                                .append(commentGroupAll.getSolrQuery())\n                                .append(')')\n                                .toString()) == 0) {\n                    viewManager.setAllowUserComments(false);\n                    logger.trace(\"User comments are not allowed for this record.\");\n                } else {\n                    viewManager.setAllowUserComments(true);\n                }\n            } catch (IndexUnreachableException e) {\n                logger.debug(\"IndexUnreachableException thrown here: {}\", e.getMessage());\n                return false;\n            } catch (PresentationException e) {\n                logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage());\n                return false;\n            }\n        }\n\n        return viewManager.isAllowUserComments();\n    }\n\n    /**\n     * Check if the current page should initialize a WebSocket\n     * \n     * @return true if a document is loaded and it contains the field {@link SolrConstants.ACCESSCONDITION_CONCURRENTUSE}\n     */\n    public boolean isRequiresWebSocket() {\n        if (viewManager != null && viewManager.getTopStructElement() != null && viewManager.getTopStructElement().getMetadataFields() != null) {\n            return viewManager.getTopStructElement().getMetadataFields().containsKey(SolrConstants.ACCESSCONDITION_CONCURRENTUSE);\n        }\n\n        return false;\n    }\n\n}\n"], "fixing_code": ["/*\n * This file is part of the Goobi viewer - a content presentation and management\n * application for digitized objects.\n *\n * Visit these websites for more information.\n *          - http://www.intranda.com\n *          - http://digiverso.com\n *\n * This program is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage io.goobi.viewer.managedbeans;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport javax.enterprise.context.SessionScoped;\nimport javax.faces.context.ExternalContext;\nimport javax.faces.context.FacesContext;\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrDocumentList;\n\nimport com.ocpsoft.pretty.PrettyContext;\nimport com.ocpsoft.pretty.faces.url.URL;\n\nimport de.intranda.api.annotation.wa.TypedResource;\nimport de.intranda.metadata.multilanguage.IMetadataValue;\nimport de.intranda.metadata.multilanguage.MultiLanguageMetadataValue;\nimport io.goobi.viewer.controller.DataManager;\nimport io.goobi.viewer.controller.IndexerTools;\nimport io.goobi.viewer.controller.NetTools;\nimport io.goobi.viewer.controller.PrettyUrlTools;\nimport io.goobi.viewer.controller.StringConstants;\nimport io.goobi.viewer.controller.StringTools;\nimport io.goobi.viewer.exceptions.DAOException;\nimport io.goobi.viewer.exceptions.IDDOCNotFoundException;\nimport io.goobi.viewer.exceptions.IndexUnreachableException;\nimport io.goobi.viewer.exceptions.PresentationException;\nimport io.goobi.viewer.exceptions.RecordDeletedException;\nimport io.goobi.viewer.exceptions.RecordLimitExceededException;\nimport io.goobi.viewer.exceptions.RecordNotFoundException;\nimport io.goobi.viewer.exceptions.ViewerConfigurationException;\nimport io.goobi.viewer.faces.validators.PIValidator;\nimport io.goobi.viewer.faces.validators.SolrQueryValidator;\nimport io.goobi.viewer.managedbeans.utils.BeanUtils;\nimport io.goobi.viewer.messages.Messages;\nimport io.goobi.viewer.messages.ViewerResourceBundle;\nimport io.goobi.viewer.model.annotation.PublicationStatus;\nimport io.goobi.viewer.model.annotation.comments.CommentGroup;\nimport io.goobi.viewer.model.cms.pages.CMSPage;\nimport io.goobi.viewer.model.crowdsourcing.DisplayUserGeneratedContent;\nimport io.goobi.viewer.model.crowdsourcing.DisplayUserGeneratedContent.ContentType;\nimport io.goobi.viewer.model.job.download.DownloadJob;\nimport io.goobi.viewer.model.job.download.DownloadOption;\nimport io.goobi.viewer.model.job.download.EPUBDownloadJob;\nimport io.goobi.viewer.model.job.download.PDFDownloadJob;\nimport io.goobi.viewer.model.maps.GeoMap;\nimport io.goobi.viewer.model.maps.GeoMap.GeoMapType;\nimport io.goobi.viewer.model.maps.GeoMapFeature;\nimport io.goobi.viewer.model.search.BrowseElement;\nimport io.goobi.viewer.model.search.SearchHelper;\nimport io.goobi.viewer.model.search.SearchHit;\nimport io.goobi.viewer.model.security.AccessConditionUtils;\nimport io.goobi.viewer.model.security.AccessPermission;\nimport io.goobi.viewer.model.security.IPrivilegeHolder;\nimport io.goobi.viewer.model.statistics.usage.RequestType;\nimport io.goobi.viewer.model.toc.TOC;\nimport io.goobi.viewer.model.toc.TOCElement;\nimport io.goobi.viewer.model.toc.export.pdf.TocWriter;\nimport io.goobi.viewer.model.toc.export.pdf.WriteTocException;\nimport io.goobi.viewer.model.translations.language.Language;\nimport io.goobi.viewer.model.viewer.PageOrientation;\nimport io.goobi.viewer.model.viewer.PageType;\nimport io.goobi.viewer.model.viewer.PhysicalElement;\nimport io.goobi.viewer.model.viewer.StructElement;\nimport io.goobi.viewer.model.viewer.ViewManager;\nimport io.goobi.viewer.model.viewer.pageloader.AbstractPageLoader;\nimport io.goobi.viewer.modules.IModule;\nimport io.goobi.viewer.solr.SolrConstants;\nimport io.goobi.viewer.solr.SolrConstants.DocType;\nimport io.goobi.viewer.solr.SolrSearchIndex;\nimport io.goobi.viewer.solr.SolrTools;\n\n/**\n * This bean opens the requested record and provides all data relevant to this record.\n */\n@Named\n@SessionScoped\npublic class ActiveDocumentBean implements Serializable {\n\n    private static final long serialVersionUID = -8686943862186336894L;\n\n    private static final Logger logger = LogManager.getLogger(ActiveDocumentBean.class);\n\n    /**\n     * Regex pattern 'imageToShow' matches if doublePageMode should be active\n     */\n    private static final String DOUBLE_PAGE_PATTERN = \"\\\\d+-\\\\d+\";\n\n    private static int imageContainerWidth = 600;\n\n    private final transient Object lock = new Object();\n\n    @Inject\n    private NavigationHelper navigationHelper;\n    @Inject\n    private CmsBean cmsBean;\n    @Inject\n    private SearchBean searchBean;\n    @Inject\n    private BookmarkBean bookmarkBean;\n    @Inject\n    private ImageDeliveryBean imageDelivery;\n    @Inject\n    private BreadcrumbBean breadcrumbBean;\n\n    /** URL parameter 'action'. */\n    private String action = \"\";\n    /** URL parameter 'imageToShow'. */\n    private String imageToShow = \"1\";\n    /** URL parameter 'logid'. */\n    private String logid = \"\";\n    /** URL parameter 'tocCurrentPage'. */\n    private int tocCurrentPage = 1;\n\n    private ViewManager viewManager;\n    private boolean anchor = false;\n    private boolean volume = false;\n    private boolean group = false;\n    protected long topDocumentIddoc = 0;\n\n    // TODO move to SearchBean\n    private BrowseElement prevHit;\n    private BrowseElement nextHit;\n\n    /** This persists the last value given to setPersistentIdentifier() and is used for handling a RecordNotFoundException. */\n    String lastReceivedIdentifier;\n    /** Available languages for this record. */\n    private List<String> recordLanguages;\n    /** Currently selected language for multilingual records. */\n    private String selectedRecordLanguage;\n\n    private Boolean deleteRecordKeepTrace;\n\n    private String clearCacheMode;\n\n    private Map<String, GeoMap> geoMaps = new HashMap<>();\n\n    private int reloads = 0;\n\n    private boolean downloadImageModalVisible = false;\n\n    private String selectedDownloadOptionLabel;\n    /* Previous docstruct URL cache. TODO Implement differently once other views beside full-screen are used. */\n    private Map<String, String> prevDocstructUrlCache = new HashMap<>();\n    /* Next docstruct URL cache. TODO Implement differently once other views beside full-screen are used. */\n    private Map<String, String> nextDocstructUrlCache = new HashMap<>();\n\n    /**\n     * Empty constructor.\n     */\n    public ActiveDocumentBean() {\n        // the emptiness inside\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param navigationHelper the navigationHelper to set\n     */\n    public void setNavigationHelper(NavigationHelper navigationHelper) {\n        this.navigationHelper = navigationHelper;\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param cmsBean the cmsBean to set\n     */\n    public void setCmsBean(CmsBean cmsBean) {\n        this.cmsBean = cmsBean;\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param searchBean the searchBean to set\n     */\n    public void setSearchBean(SearchBean searchBean) {\n        this.searchBean = searchBean;\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param bookshelfBean the bookshelfBean to set\n     */\n    public void setBookshelfBean(BookmarkBean bookshelfBean) {\n        this.bookmarkBean = bookshelfBean;\n    }\n\n    /**\n     * Required setter for ManagedProperty injection\n     *\n     * @param breadcrumbBean the breadcrumbBean to set\n     */\n    public void setBreadcrumbBean(BreadcrumbBean breadcrumbBean) {\n        this.breadcrumbBean = breadcrumbBean;\n    }\n\n    /**\n     * TODO This can cause NPEs if called while update() is running.\n     *\n     * @throws IndexUnreachableException\n     * @should reset lastReceivedIdentifier\n     */\n    public void reset() throws IndexUnreachableException {\n        synchronized (this) {\n            logger.trace(\"reset (thread {})\", Thread.currentThread().getId());\n            String pi = viewManager != null ? viewManager.getPi() : null;\n            viewManager = null;\n            topDocumentIddoc = 0;\n            logid = \"\";\n            action = \"\";\n            prevHit = null;\n            nextHit = null;\n            group = false;\n            clearCacheMode = null;\n            prevDocstructUrlCache.clear();\n            nextDocstructUrlCache.clear();\n            lastReceivedIdentifier = null;\n\n            // Any cleanup modules need to do when a record is unloaded\n            for (IModule module : DataManager.getInstance().getModules()) {\n                module.augmentResetRecord();\n            }\n\n            // Remove record lock for this record and session\n            if (BeanUtils.getSession() != null) {\n                DataManager.getInstance()\n                        .getRecordLockManager()\n                        .removeLockForPiAndSessionId(pi, BeanUtils.getSession().getId());\n            }\n        }\n    }\n\n    /**\n     * Do not call from ActiveDocumentBean.update()!\n     *\n     * @return a {@link io.goobi.viewer.model.viewer.ViewManager} object.\n     */\n    public ViewManager getViewManager() {\n        if (viewManager == null) {\n            try {\n                try {\n                    update();\n                } catch (IDDOCNotFoundException e) {\n                    reload(lastReceivedIdentifier);\n                }\n            } catch (PresentationException e) {\n                logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage());\n            } catch (RecordNotFoundException | RecordDeletedException | RecordLimitExceededException e) {\n                if (e.getMessage() != null && !\"null\".equals(e.getMessage()) && !\"???\".equals(e.getMessage())) {\n                    logger.warn(\"{}: {}\", e.getClass().getName(), e.getMessage());\n                }\n            } catch (IndexUnreachableException | DAOException | ViewerConfigurationException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n\n        return viewManager;\n    }\n\n    /**\n     *\n     * @param pi @throws PresentationException @throws RecordNotFoundException @throws RecordDeletedException @throws\n     *            IndexUnreachableException @throws DAOException @throws ViewerConfigurationException @throws RecordLimitExceededException @throws\n     */\n    public String reload(String pi) throws PresentationException, RecordNotFoundException, RecordDeletedException, IndexUnreachableException,\n            DAOException, ViewerConfigurationException, RecordLimitExceededException {\n        logger.trace(\"reload({})\", pi);\n        reloads++;\n        reset();\n        if (reloads > 3) {\n            throw new RecordNotFoundException(pi);\n        }\n        setPersistentIdentifier(pi);\n        //        setImageToShow(1);\n        return open();\n    }\n\n    /**\n     * Loads the record with the IDDOC set in <code>currentElementIddoc</code>.\n     *\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     * @throws io.goobi.viewer.exceptions.RecordDeletedException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     * @throws IDDOCNotFoundException\n     * @throws RecordLimitExceededException\n     * @throws NumberFormatException\n     * @should create ViewManager correctly\n     * @should update ViewManager correctly if LOGID has changed\n     * @should not override topDocumentIddoc if LOGID has changed\n     * @should throw RecordNotFoundException if listing not allowed by default\n     * @should load records that have been released via moving wall\n     */\n\n    public void update() throws PresentationException, IndexUnreachableException, RecordNotFoundException, RecordDeletedException, DAOException,\n            ViewerConfigurationException, IDDOCNotFoundException, NumberFormatException, RecordLimitExceededException {\n        synchronized (this) {\n            if (topDocumentIddoc == 0) {\n                try {\n                    if (StringUtils.isNotEmpty(lastReceivedIdentifier)) {\n                        throw new RecordNotFoundException(lastReceivedIdentifier);\n                    }\n                    throw new RecordNotFoundException(\"???\");\n                } finally {\n                    lastReceivedIdentifier = null;\n                }\n            }\n            logger.debug(\"update(): (IDDOC {} ; page {} ; thread {})\", topDocumentIddoc, imageToShow, Thread.currentThread().getId());\n            prevHit = null;\n            nextHit = null;\n            boolean doublePageMode = isDoublePageUrl();\n            // Do these steps only if a new document has been loaded\n            boolean mayChangeHitIndex = false;\n            if (viewManager == null || viewManager.getTopStructElement() == null || viewManager.getTopStructElementIddoc() != topDocumentIddoc) {\n                anchor = false;\n                volume = false;\n                group = false;\n\n                // Change current hit index only if loading a new record\n                if (searchBean != null && searchBean.getCurrentSearch() != null) {\n                    searchBean.increaseCurrentHitIndex();\n                    mayChangeHitIndex = true;\n                }\n\n                StructElement topStructElement = new StructElement(topDocumentIddoc);\n\n                // Exit here if record is not found or has been deleted\n                if (!topStructElement.isExists()) {\n                    logger.info(\"IDDOC for the current record '{}' ({}) no longer seems to exist, attempting to retrieve an updated IDDOC...\",\n                            topStructElement.getPi(), topDocumentIddoc);\n                    topDocumentIddoc = DataManager.getInstance().getSearchIndex().getIddocFromIdentifier(topStructElement.getPi());\n                    if (topDocumentIddoc == 0) {\n                        logger.warn(\"New IDDOC for the current record '{}' could not be found. Perhaps this record has been deleted?\",\n                                topStructElement.getPi());\n                        reset();\n                        try {\n                            throw new RecordNotFoundException(lastReceivedIdentifier);\n                        } finally {\n                            lastReceivedIdentifier = null;\n                        }\n                    }\n                } else if (topStructElement.isDeleted()) {\n                    logger.debug(\"Record '{}' is deleted and only available as a trace document.\", topStructElement.getPi());\n                    reset();\n                    throw new RecordDeletedException(topStructElement.getPi());\n                }\n\n                // Do not open records who may not be listed for the current user\n                List<String> requiredAccessConditions = topStructElement.getMetadataValues(SolrConstants.ACCESSCONDITION);\n                if (requiredAccessConditions != null && !requiredAccessConditions.isEmpty()) {\n                    AccessPermission access =\n                            AccessConditionUtils.checkAccessPermission(new HashSet<>(requiredAccessConditions), IPrivilegeHolder.PRIV_LIST,\n                                    new StringBuilder().append('+').append(SolrConstants.PI).append(':').append(topStructElement.getPi()).toString(),\n                                    (HttpServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest());\n                    if (!access.isGranted()) {\n                        logger.debug(\"User may not open {}\", topStructElement.getPi());\n                        try {\n                            throw new RecordNotFoundException(lastReceivedIdentifier);\n                        } finally {\n                            lastReceivedIdentifier = null;\n                        }\n                    }\n                    // If license type is configured to redirect to a URL, redirect here\n                    if (access.isRedirect() && StringUtils.isNotEmpty(access.getRedirectUrl())) {\n                        logger.debug(\"Redirecting to {}\", access.getRedirectUrl());\n                        try {\n                            FacesContext.getCurrentInstance().getExternalContext().redirect(access.getRedirectUrl());\n                            return;\n                        } catch (IOException e) {\n                            logger.error(e.getMessage());\n                            return;\n                        }\n                    }\n\n                }\n\n                viewManager = new ViewManager(topStructElement, AbstractPageLoader.create(topStructElement), topDocumentIddoc,\n                        logid, topStructElement.getMetadataValue(SolrConstants.MIMETYPE), imageDelivery);\n                viewManager.setToc(createTOC());\n\n                HttpSession session = BeanUtils.getSession();\n                // Release all locks for this session except the current record\n                if (session != null) {\n                    DataManager.getInstance()\n                            .getRecordLockManager()\n                            .removeLocksForSessionId(session.getId(), Collections.singletonList(viewManager.getPi()));\n                }\n                String limit = viewManager.getTopStructElement().getMetadataValue(SolrConstants.ACCESSCONDITION_CONCURRENTUSE);\n                // Lock limited view records, if limit exists and record has a license type that has this feature enabled\n                if (limit != null && AccessConditionUtils.isConcurrentViewsLimitEnabledForAnyAccessCondition(\n                        viewManager.getTopStructElement().getMetadataValues(SolrConstants.ACCESSCONDITION))) {\n                    if (session != null) {\n                        DataManager.getInstance()\n                                .getRecordLockManager()\n                                .lockRecord(viewManager.getPi(), session.getId(), Integer.valueOf(limit));\n                    } else {\n                        logger.debug(\"No session found, unable to lock limited view record {}\", topStructElement.getPi());\n                        try {\n                            throw new RecordLimitExceededException(lastReceivedIdentifier + \":\" + limit);\n                        } finally {\n                            lastReceivedIdentifier = null;\n                        }\n                    }\n                }\n            }\n\n            //update usage statistics\n            DataManager.getInstance()\n                    .getUsageStatisticsRecorder()\n                    .recordRequest(RequestType.RECORD_VIEW, viewManager.getPi(), BeanUtils.getRequest());\n\n            // If LOGID is set, update the current element\n            if (StringUtils.isNotEmpty(logid) && viewManager != null && !logid.equals(viewManager.getLogId())) {\n                // TODO set new values instead of re-creating ViewManager, perhaps\n                logger.debug(\"Find doc by LOGID: {}\", logid);\n                new StructElement(topDocumentIddoc);\n                String query = new StringBuilder(\"+\")\n                        .append(SolrConstants.LOGID)\n                        .append(\":\\\"\")\n                        .append(logid)\n                        .append(\"\\\" +\")\n                        .append(SolrConstants.PI_TOPSTRUCT)\n                        .append(\":\")\n                        .append(viewManager.getPi())\n                        .append(\" +\")\n                        .append(SolrConstants.DOCTYPE)\n                        .append(':')\n                        .append(DocType.DOCSTRCT.name())\n                        .toString();\n                SolrDocumentList docList = DataManager.getInstance()\n                        .getSearchIndex()\n                        .search(query, 1, null, Collections.singletonList(SolrConstants.IDDOC));\n                long subElementIddoc = 0;\n                // TODO check whether creating a new ViewManager can be avoided here\n                if (!docList.isEmpty()) {\n                    subElementIddoc = Long.valueOf((String) docList.get(0).getFieldValue(SolrConstants.IDDOC));\n                    // Re-initialize ViewManager with the new current element\n                    PageOrientation firstPageOrientation = viewManager.getFirstPageOrientation();\n                    viewManager = new ViewManager(viewManager.getTopStructElement(), viewManager.getPageLoader(), subElementIddoc, logid,\n                            viewManager.getMimeType(), imageDelivery);\n                    viewManager.setFirstPageOrientation(firstPageOrientation);\n                    viewManager.setToc(createTOC());\n                } else {\n                    logger.warn(\"{} not found for LOGID '{}'.\", SolrConstants.IDDOC, logid);\n                }\n            }\n\n            if (viewManager != null && viewManager.getCurrentStructElement() != null) {\n                viewManager.setDoublePageMode(doublePageMode);\n                StructElement structElement = viewManager.getCurrentStructElement();\n                if (!structElement.isExists()) {\n                    logger.trace(\"StructElement {} is not marked as existing. Record will be reloaded\", structElement.getLuceneId());\n                    try {\n                        throw new IDDOCNotFoundException(lastReceivedIdentifier + \" - \" + structElement.getLuceneId());\n                    } finally {\n                        lastReceivedIdentifier = null;\n                    }\n                }\n                if (structElement.isAnchor()) {\n                    anchor = true;\n                }\n                if (structElement.isVolume()) {\n                    volume = true;\n                }\n                if (structElement.isGroup()) {\n                    group = true;\n                }\n\n                viewManager.setCurrentImageOrderString(imageToShow);\n                viewManager.updateDropdownSelected();\n\n                // Search hit navigation\n                if (searchBean != null && searchBean.getCurrentSearch() != null) {\n                    if (searchBean.getCurrentHitIndex() < 0) {\n                        // Determine the index of this element in the search result list. Must be done after re-initializing ViewManager so that the PI is correct!\n                        searchBean.findCurrentHitIndex(getPersistentIdentifier(), viewManager.getCurrentImageOrder(), true);\n                    } else if (mayChangeHitIndex) {\n                        // Modify the current hit index\n                        searchBean.increaseCurrentHitIndex();\n                    } else if (searchBean.getHitIndexOperand() != 0) {\n                        // Reset hit index operand (should only be necessary if the URL was called twice, but the current hit has not changed\n                        // logger.trace(\"Hit index modifier operand is {}, resetting...\", searchBean.getHitIndexOperand());\n                        searchBean.setHitIndexOperand(0);\n                    }\n                }\n            } else {\n                logger.debug(\"ViewManager is null or ViewManager.currentDocument is null.\");\n                try {\n                    throw new RecordNotFoundException(lastReceivedIdentifier);\n                } finally {\n                    lastReceivedIdentifier = null;\n                }\n            }\n\n            // Metadata language versions\n            recordLanguages = viewManager.getTopStructElement().getMetadataValues(SolrConstants.LANGUAGE);\n            // If the record has metadata language versions, pre-select the current locale as the record language\n            //            if (StringUtils.isBlank(selectedRecordLanguage) && !recordLanguages.isEmpty()) {\n            if (StringUtils.isBlank(selectedRecordLanguage) && navigationHelper != null) {\n                selectedRecordLanguage = navigationHelper.getLocaleString();\n            }\n\n            // Prepare a new bookshelf item\n            if (bookmarkBean != null) {\n                bookmarkBean.prepareItemForBookmarkList();\n                if (bookmarkBean.getCurrentBookmark() == null || !viewManager.getPi().equals(bookmarkBean.getCurrentBookmark().getPi())) {\n                    bookmarkBean.prepareItemForBookmarkList();\n                }\n            }\n        }\n\n    }\n\n    /**\n     *\n     * @return true if the 'imageToShow' part of the url matches {@link #DOUBLE_PAGE_PATTERN}, i.e. if the url suggests that double page mode is\n     *         expected\n     */\n    private boolean isDoublePageUrl() {\n        return StringUtils.isNotBlank(imageToShow) && imageToShow.matches(DOUBLE_PAGE_PATTERN);\n    }\n\n    /**\n     * @throws PresentationException\n     * @throws IndexUnreachableException\n     * @throws DAOException\n     * @throws ViewerConfigurationException\n     */\n    private TOC createTOC() throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        TOC toc = new TOC();\n        synchronized (toc) {\n            if (viewManager != null) {\n                toc.generate(viewManager.getTopStructElement(), viewManager.isListAllVolumesInTOC(), viewManager.getMimeType(), tocCurrentPage);\n                // The TOC object will correct values that are too high, so update the local value, if necessary\n                if (toc.getCurrentPage() != this.tocCurrentPage) {\n                    this.tocCurrentPage = toc.getCurrentPage();\n                }\n            }\n        }\n        return toc;\n    }\n\n    /**\n     * Pretty-URL entry point.\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     * @throws io.goobi.viewer.exceptions.RecordDeletedException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     * @throws RecordLimitExceededException\n     * @throws PresentationException\n     */\n    public String open()\n            throws RecordNotFoundException, RecordDeletedException, IndexUnreachableException, DAOException, ViewerConfigurationException,\n            RecordLimitExceededException {\n        synchronized (this) {\n            logger.trace(\"open()\");\n            try {\n                update();\n                if (navigationHelper == null || viewManager == null) {\n                    return \"\";\n                }\n\n                IMetadataValue name = viewManager.getTopStructElement().getMultiLanguageDisplayLabel();\n                HttpServletRequest request = (HttpServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest();\n                URL url = PrettyContext.getCurrentInstance(request).getRequestURL();\n\n                for (String language : name.getLanguages()) {\n                    String translation = name.getValue(language).orElse(getPersistentIdentifier());\n                    if (translation != null && translation.length() > DataManager.getInstance().getConfiguration().getBreadcrumbsClipping()) {\n                        translation =\n                                new StringBuilder(translation.substring(0, DataManager.getInstance().getConfiguration().getBreadcrumbsClipping()))\n                                        .append(\"...\")\n                                        .toString();\n                        name.setValue(translation, language);\n                    }\n                }\n                // Fallback using the identifier as the label\n                if (name.isEmpty()) {\n                    name.setValue(getPersistentIdentifier());\n                }\n                logger.trace(\"topdocument label: {} \", name.getValue());\n                if (!PrettyContext.getCurrentInstance(request).getRequestURL().toURL().contains(\"/crowd\")) {\n                    breadcrumbBean.addRecordBreadcrumbs(viewManager, name, url);\n                }\n            } catch (PresentationException e) {\n                logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage(), e);\n                Messages.error(e.getMessage());\n            } catch (IDDOCNotFoundException e) {\n                try {\n                    return reload(lastReceivedIdentifier);\n                } catch (PresentationException e1) {\n                    logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage(), e);\n                }\n            }\n\n            reloads = 0;\n            return \"\";\n        }\n    }\n\n    /**\n     * <p>\n     * openFulltext.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     * @throws io.goobi.viewer.exceptions.RecordDeletedException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     * @throws PresentationException\n     * @throws RecordLimitExceededException\n     * @throws NumberFormatException\n     */\n    public String openFulltext()\n            throws RecordNotFoundException, RecordDeletedException, IndexUnreachableException, DAOException, ViewerConfigurationException,\n            PresentationException, NumberFormatException, RecordLimitExceededException {\n        open();\n        return \"viewFulltext\";\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>prevHit</code>.\n     * </p>\n     *\n     * @return a {@link io.goobi.viewer.model.search.BrowseElement} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public BrowseElement getPrevHit() throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (prevHit == null && searchBean != null) {\n            prevHit = searchBean.getPreviousElement();\n        }\n\n        return prevHit;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>nextHit</code>.\n     * </p>\n     *\n     * @return a {@link io.goobi.viewer.model.search.BrowseElement} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public BrowseElement getNextHit() throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (nextHit == null && searchBean != null) {\n            nextHit = searchBean.getNextElement();\n        }\n\n        return nextHit;\n    }\n\n    /**\n     ********************************* Getter and Setter **************************************\n     *\n     * @return a long.\n     */\n    public long getActiveDocumentIddoc() {\n        if (viewManager != null) {\n            return viewManager.getTopStructElementIddoc();\n        }\n\n        return 0;\n    }\n\n    /**\n     * <p>\n     * getCurrentElement.\n     * </p>\n     *\n     * @return the currentElement\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public StructElement getCurrentElement() throws IndexUnreachableException {\n        if (viewManager != null) {\n            return viewManager.getCurrentStructElement();\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>imageToShow</code>.\n     * </p>\n     *\n     * @param imageToShow the imageToShow to set\n     */\n    public void setImageToShow(String imageToShow) {\n        synchronized (lock) {\n            this.imageToShow = imageToShow;\n            if (viewManager != null) {\n                viewManager.setDropdownSelected(String.valueOf(imageToShow));\n            }\n            // Reset LOGID (the LOGID setter is called later by PrettyFaces, so if a value is passed, it will still be set)\n            try {\n                setLogid(\"\");\n            } catch (PresentationException e) {\n                //cannot be thrown here\n            }\n            logger.trace(\"imageToShow: {}\", this.imageToShow);\n        }\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>imageToShow</code>.\n     * </p>\n     *\n     * @return the imageToShow\n     */\n    public String getImageToShow() {\n        synchronized (lock) {\n            return imageToShow;\n        }\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>logid</code>.\n     * </p>\n     *\n     * @param logid the logid to set\n     * @throws PresentationException \n     */\n    public void setLogid(String logid) throws PresentationException {\n        synchronized (this) {\n            if (\"-\".equals(logid)) {\n                this.logid = \"\";\n            } else if(StringUtils.isNotBlank(logid) && logid.matches(\"[\\\\w-]+\")) {\n                this.logid = SolrTools.escapeSpecialCharacters(logid);\n            } else {\n                throw new PresentationException(\"The passed logId \" + SolrTools.escapeSpecialCharacters(logid) + \" contains illegal characters\");\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>logid</code>.\n     * </p>\n     *\n     * @return the logid\n     */\n    public String getLogid() {\n        synchronized (this) {\n            if (StringUtils.isEmpty(logid)) {\n                return \"-\";\n            }\n\n            return logid;\n        }\n    }\n\n    /**\n     * <p>\n     * isAnchor.\n     * </p>\n     *\n     * @return the anchor\n     */\n    public boolean isAnchor() {\n        return anchor;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>anchor</code>.\n     * </p>\n     *\n     * @param anchor the anchor to set\n     */\n    public void setAnchor(boolean anchor) {\n        this.anchor = anchor;\n    }\n\n    /**\n     * <p>\n     * isVolume.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isVolume() {\n        return volume;\n    }\n\n    /**\n     * <p>\n     * isGroup.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isGroup() {\n        return group;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>action</code>.\n     * </p>\n     *\n     * @return the action\n     */\n    public String getAction() {\n        synchronized (this) {\n            return action;\n        }\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>action</code>.\n     * </p>\n     *\n     * @param action the action to set\n     */\n    public void setAction(String action) {\n        synchronized (this) {\n            logger.trace(\"setAction: \" + action);\n            this.action = action;\n            if (searchBean != null && action != null) {\n                switch (action) {\n                    case \"nextHit\":\n                        searchBean.setHitIndexOperand(1);\n                        break;\n                    case \"prevHit\":\n                        searchBean.setHitIndexOperand(-1);\n                        break;\n                    default:\n                        // do nothing\n                        break;\n\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * setPersistentIdentifier.\n     * </p>\n     *\n     * @param persistentIdentifier a {@link java.lang.String} object.\n     * @should determine currentElementIddoc correctly\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public void setPersistentIdentifier(String persistentIdentifier)\n            throws PresentationException, RecordNotFoundException, IndexUnreachableException {\n        synchronized (this) {\n            logger.trace(\"setPersistentIdentifier: {}\", persistentIdentifier);\n            lastReceivedIdentifier = persistentIdentifier;\n            if (!PIValidator.validatePi(persistentIdentifier)) {\n                logger.warn(\"Invalid identifier '{}'.\", persistentIdentifier);\n                reset();\n                return;\n                // throw new RecordNotFoundException(\"Illegal identifier: \" + persistentIdentifier);\n            }\n            if (!\"-\".equals(persistentIdentifier) && (viewManager == null || !persistentIdentifier.equals(viewManager.getPi()))) {\n                long id = DataManager.getInstance().getSearchIndex().getIddocFromIdentifier(persistentIdentifier);\n                if (id > 0) {\n                    if (topDocumentIddoc != id) {\n                        topDocumentIddoc = id;\n                        logger.trace(\"IDDOC found for {}: {}\", persistentIdentifier, id);\n                    }\n                } else {\n                    logger.warn(\"No IDDOC for identifier '{}' found.\", persistentIdentifier);\n                    reset();\n                    return;\n                    // throw new RecordNotFoundException(new StringBuilder(persistentIdentifier).toString());\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the PI of the currently loaded record. Only call this method after the update() method has re-initialized ViewManager, otherwise the\n     * previous PI may be returned!\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPersistentIdentifier() throws IndexUnreachableException {\n        synchronized (this) {\n            if (viewManager != null) {\n                return viewManager.getPi();\n            }\n            return \"-\";\n        }\n    }\n\n    /**\n     * <p>\n     * getThumbPart.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getThumbPart() throws IndexUnreachableException {\n        if (viewManager != null) {\n            return new StringBuilder(\"/\").append(getPersistentIdentifier())\n                    .append('/')\n                    .append(viewManager.getCurrentThumbnailPage())\n                    .append('/')\n                    .toString();\n        }\n\n        return \"\";\n    }\n\n    /**\n     * <p>\n     * getLogPart.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getLogPart() throws IndexUnreachableException {\n        return new StringBuilder(\"/\").append(getPersistentIdentifier())\n                .append('/')\n                .append(imageToShow)\n                .append('/')\n                .append(getLogid())\n                .append('/')\n                .toString();\n    }\n\n    // navigation in work\n\n    /**\n     * Returns the navigation URL for the given page type and number.\n     *\n     * @param pageType a {@link java.lang.String} object.\n     * @param pageOrderRange Single page number or range\n     * @should construct url correctly\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPageUrl(String pageType, String pageOrderRange) throws IndexUnreachableException {\n        StringBuilder sbUrl = new StringBuilder();\n        if (StringUtils.isBlank(pageType)) {\n            if (navigationHelper != null) {\n                pageType = navigationHelper.getCurrentView();\n                if (pageType == null) {\n                    pageType = PageType.viewObject.name();\n                }\n            }\n            if (StringUtils.isBlank(pageType)) {\n                pageType = PageType.viewObject.name();\n            }\n            // logger.trace(\"current view: {}\", pageType);\n        }\n\n        int[] pages = StringTools.getIntegerRange(pageOrderRange);\n        int page = pages[0];\n        int page2 = pages[1];\n\n        if (viewManager != null) {\n            page = Math.max(page, viewManager.getPageLoader().getFirstPageOrder());\n            page = Math.min(page, viewManager.getPageLoader().getLastPageOrder());\n            if (page2 != Integer.MAX_VALUE) {\n                page2 = Math.max(page2, viewManager.getPageLoader().getFirstPageOrder());\n                page2 = Math.min(page2, viewManager.getPageLoader().getLastPageOrder());\n            }\n        }\n        //        if (page == page2) {\n        //            page2 = Integer.MAX_VALUE;\n        //        }\n        String range = page + (page2 != Integer.MAX_VALUE ? \"-\" + page2 : \"\");\n        // logger.trace(\"final range: {}\", range);\n        sbUrl.append(BeanUtils.getServletPathWithHostAsUrlFromJsfContext())\n                .append('/')\n                .append(PageType.getByName(pageType).getName())\n                .append('/')\n                .append(getPersistentIdentifier())\n                .append('/')\n                .append(range)\n                .append('/');\n\n        return sbUrl.toString();\n    }\n\n    /**\n     * <p>\n     * getPageUrl.\n     * </p>\n     *\n     * @param pageOrderRange Single page number or range\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPageUrl(String pageOrderRange) throws IndexUnreachableException {\n        return getPageUrl(null, pageOrderRange);\n    }\n\n    /**\n     * <p>\n     * getPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPageUrl() throws IndexUnreachableException {\n        String pageType = null;\n        if (StringUtils.isBlank(pageType)) {\n            pageType = navigationHelper.getPreferredView();\n        }\n        if (StringUtils.isBlank(pageType)) {\n            pageType = navigationHelper.getCurrentView();\n        }\n        return getPageUrlByType(pageType);\n    }\n\n    /**\n     * <p>\n     * getPageUrl.\n     * </p>\n     *\n     * @param pageType a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getPageUrlByType(String pageType) throws IndexUnreachableException {\n        StringBuilder sbUrl = new StringBuilder();\n        sbUrl.append(BeanUtils.getServletPathWithHostAsUrlFromJsfContext())\n                .append('/')\n                .append(PageType.getByName(pageType).getName())\n                .append('/')\n                .append(getPersistentIdentifier())\n                .append('/');\n\n        return sbUrl.toString();\n    }\n\n    /**\n     * <p>\n     * getFirstPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getFirstPageUrl() throws IndexUnreachableException {\n        if (viewManager != null) {\n            int image = viewManager.getPageLoader().getFirstPageOrder();\n            if (viewManager.isDoublePageMode()) {\n                return getPageUrl(image + \"-\" + image);\n            }\n\n            return getPageUrl(Integer.toString(image));\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * getLastPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getLastPageUrl() throws IndexUnreachableException {\n        if (viewManager != null) {\n            int image = viewManager.getPageLoader().getLastPageOrder();\n            if (viewManager.isDoublePageMode()) {\n                return getPageUrl(image + \"-\" + image);\n            }\n\n            return getPageUrl(Integer.toString(image));\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * getNextPageUrl.\n     * </p>\n     *\n     * @param step a int.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     * @should return correct page in single page mode\n     * @should return correct range in double page mode if current page double image\n     * @should return correct range in double page mode if currently showing two pages\n     * @should return correct range in double page mode if currently showing one page\n     */\n    public String getPageUrlRelativeToCurrentPage(int step) throws IndexUnreachableException, DAOException {\n        // logger.trace(\"getPageUrl: {}\", step);\n        if (viewManager == null) {\n            return getPageUrl(imageToShow);\n        }\n\n        if (!viewManager.isDoublePageMode()) {\n            int number = viewManager.getCurrentImageOrder() + step;\n            return getPageUrl(String.valueOf(number));\n        }\n\n        int number;\n\n        // Current image contains two pages\n        if (viewManager.getCurrentPage().isDoubleImage()) {\n            // logger.trace(\"{} is double page\", viewManager.getCurrentPage().getOrder());\n            if (step < 0) {\n                number = viewManager.getCurrentImageOrder() + 2 * step;\n            } else {\n                number = viewManager.getCurrentImageOrder() + step;\n            }\n            return getPageUrl(number + \"-\" + (number + 1));\n        }\n\n        // Use current left/right page as a point of reference, if available (opposite when in right-to-left navigation)\n        Optional<PhysicalElement> currentLeftPage =\n                viewManager.getTopStructElement().isRtl() ? viewManager.getCurrentRightPage() : viewManager.getCurrentLeftPage();\n        Optional<PhysicalElement> currentRightPage =\n                viewManager.getTopStructElement().isRtl() ? viewManager.getCurrentLeftPage() : viewManager.getCurrentRightPage();\n\n        // Only go back one step unit at first\n        if (currentLeftPage.isPresent()) {\n            // logger.trace(\"{} is left page\", currentLeftPage.get().getOrder());\n            number = currentLeftPage.get().getOrder() + step;\n        } else if (currentRightPage.isPresent()) {\n            // If only the right page is present, it's probably the first page - do not add step at this point\n            // logger.trace(\"{} is right page\", currentRightPage.get().getOrder());\n            number = currentRightPage.get().getOrder();\n        } else {\n            number = viewManager.getCurrentImageOrder() + step;\n        }\n\n        // Target image candidate contains two pages\n        Optional<PhysicalElement> nextPage = viewManager.getPage(number);\n        if (nextPage.isPresent() && nextPage.get().isDoubleImage()) {\n            return getPageUrl(String.valueOf(number) + \"-\" + String.valueOf(number));\n        }\n        // If the immediate neighbor is not a double image, add another step\n        number += step;\n\n        nextPage = viewManager.getPage(number);\n        if (nextPage.isPresent() && nextPage.get().isDoubleImage()) {\n            return getPageUrl(String.valueOf(number) + \"-\" + String.valueOf(number));\n        }\n\n        // logger.trace(\"step: {}\", step);\n        // logger.trace(\"Number: {}\", number);\n\n        return getPageUrl(number + \"-\" + (number + 1));\n    }\n\n    public String getPageUrl(int order) throws IndexUnreachableException {\n        return getPageUrl(Integer.toString(order));\n    }\n\n    /**\n     * <p>\n     * getPreviousPageUrl.\n     * </p>\n     *\n     * @param step\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getPreviousPageUrl(int step) throws IndexUnreachableException, DAOException {\n        return getPageUrlRelativeToCurrentPage(step * -1);\n    }\n\n    /**\n     * <p>\n     * getNextPageUrl.\n     * </p>\n     *\n     * @param step\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getNextPageUrl(int step) throws IndexUnreachableException, DAOException {\n        return getPageUrlRelativeToCurrentPage(step);\n    }\n\n    /**\n     * <p>\n     * getPreviousPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getPreviousPageUrl() throws IndexUnreachableException, DAOException {\n        return getPreviousPageUrl(1);\n    }\n\n    /**\n     * <p>\n     * getNextPageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getNextPageUrl() throws IndexUnreachableException, DAOException {\n        return getNextPageUrl(1);\n    }\n\n    /**\n     *\n     * @return\n     * @throws IndexUnreachableException\n     * @throws ViewerConfigurationException\n     * @throws DAOException\n     * @throws PresentationException\n     */\n    public String getPreviousDocstructUrl() throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        // logger.trace(\"getPreviousDocstructUrl\");\n        if (viewManager == null) {\n            return null;\n        }\n        List<String> docstructTypes =\n                DataManager.getInstance().getConfiguration().getDocstructNavigationTypes(viewManager.getTopStructElement().getDocStructType(), true);\n        if (docstructTypes.isEmpty()) {\n            return null;\n        }\n\n        String currentDocstructIddoc = String.valueOf(viewManager.getCurrentStructElementIddoc());\n        // Determine docstruct URL and cache it\n        if (prevDocstructUrlCache.get(currentDocstructIddoc) == null) {\n            int currentElementIndex = getToc().findTocElementIndexByIddoc(currentDocstructIddoc);\n            if (currentElementIndex == -1) {\n                logger.warn(\"Current IDDOC not found in TOC: {}\", viewManager.getCurrentStructElement().getLuceneId());\n                return null;\n            }\n\n            boolean found = false;\n            for (int i = currentElementIndex - 1; i >= 0; --i) {\n                TOCElement tocElement = viewManager.getToc().getTocElements().get(i);\n                String docstructType = tocElement.getMetadataValue(SolrConstants.DOCSTRCT);\n                if (docstructType != null && docstructTypes.contains(docstructType) && StringUtils.isNotBlank(tocElement.getPageNo())) {\n                    logger.trace(\"Found previous {}: {}\", docstructType, tocElement.getLogId());\n                    // Add LOGID to the URL because ViewManager.currentStructElementIddoc (IDDOC_OWNER) can be incorrect in the index sometimes,\n                    // resulting in the URL pointing at the current element\n                    prevDocstructUrlCache.put(currentDocstructIddoc,\n                            \"/\" + viewManager.getPi() + \"/\" + Integer.valueOf(tocElement.getPageNo()) + \"/\" + tocElement.getLogId() + \"/\");\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                prevDocstructUrlCache.put(currentDocstructIddoc, \"\");\n            }\n        }\n\n        if (StringUtils.isNotEmpty(prevDocstructUrlCache.get(currentDocstructIddoc))) {\n            return BeanUtils.getServletPathWithHostAsUrlFromJsfContext() + \"/\" + navigationHelper.getCurrentPageType().getName()\n                    + prevDocstructUrlCache.get(currentDocstructIddoc);\n        }\n\n        return \"\";\n    }\n\n    /**\n     *\n     * @return\n     * @throws IndexUnreachableException\n     * @throws ViewerConfigurationException\n     * @throws DAOException\n     * @throws PresentationException\n     */\n    public String getNextDocstructUrl() throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        // logger.trace(\"getNextDocstructUrl\");\n        if (viewManager == null) {\n            return \"\";\n        }\n        List<String> docstructTypes =\n                DataManager.getInstance().getConfiguration().getDocstructNavigationTypes(viewManager.getTopStructElement().getDocStructType(), true);\n        if (docstructTypes.isEmpty()) {\n            return null;\n        }\n\n        String currentDocstructIddoc = String.valueOf(viewManager.getCurrentStructElementIddoc());\n        // Determine docstruct URL and cache it\n        if (nextDocstructUrlCache.get(currentDocstructIddoc) == null) {\n            int currentElementIndex = getToc().findTocElementIndexByIddoc(currentDocstructIddoc);\n            logger.trace(\"currentIndexElement: {}\", currentElementIndex);\n            if (currentElementIndex == -1) {\n                return null;\n            }\n\n            boolean found = false;\n            for (int i = currentElementIndex + 1; i < viewManager.getToc().getTocElements().size(); ++i) {\n                TOCElement tocElement = viewManager.getToc().getTocElements().get(i);\n                String docstructType = tocElement.getMetadataValue(SolrConstants.DOCSTRCT);\n                if (docstructType != null && docstructTypes.contains(docstructType)) {\n                    logger.trace(\"Found next {}: {}\", docstructType, tocElement.getLogId());\n                    // Add LOGID to the URL because ViewManager.currentStructElementIddoc (IDDOC_OWNER) can be incorrect in the index sometimes,\n                    // resulting in the URL pointing at the current element\n                    nextDocstructUrlCache.put(currentDocstructIddoc,\n                            \"/\" + viewManager.getPi() + \"/\" + Integer.valueOf(tocElement.getPageNo()) + \"/\" + tocElement.getLogId() + \"/\");\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                nextDocstructUrlCache.put(currentDocstructIddoc, \"\");\n            }\n        }\n\n        if (StringUtils.isNotEmpty(nextDocstructUrlCache.get(currentDocstructIddoc))) {\n            return BeanUtils.getServletPathWithHostAsUrlFromJsfContext() + \"/\" + navigationHelper.getCurrentPageType().getName()\n                    + nextDocstructUrlCache.get(currentDocstructIddoc);\n        }\n\n        return \"\";\n    }\n\n    /**\n     * <p>\n     * getImageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getImageUrl() throws IndexUnreachableException {\n        return getPageUrl(PageType.viewImage.getName(), imageToShow);\n    }\n\n    /**\n     * <p>\n     * getFullscreenImageUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getFullscreenImageUrl() throws IndexUnreachableException, DAOException {\n        if (viewManager != null && viewManager.isDoublePageMode() && !viewManager.getCurrentPage().isDoubleImage()) {\n            Optional<PhysicalElement> currentLeftPage = viewManager.getCurrentLeftPage();\n            Optional<PhysicalElement> currentRightPage = viewManager.getCurrentRightPage();\n            if (currentLeftPage.isPresent() && currentRightPage.isPresent()) {\n                return getPageUrl(PageType.viewFullscreen.getName(), currentLeftPage.get().getOrder() + \"-\" + currentRightPage.get().getOrder());\n            }\n        }\n\n        return getPageUrl(PageType.viewFullscreen.getName(), imageToShow);\n    }\n\n    /**\n     * <p>\n     * getReadingModeUrl.\n     * </p>\n     *\n     * @deprecated renamed to fullscreen\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws DAOException\n     */\n    public String getReadingModeUrl() throws IndexUnreachableException, DAOException {\n        return getFullscreenImageUrl();\n    }\n\n    /**\n     * <p>\n     * getFulltextUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getFulltextUrl() throws IndexUnreachableException {\n        return getPageUrl(PageType.viewFulltext.getName(), imageToShow);\n    }\n\n    /**\n     * <p>\n     * getMetadataUrl.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String getMetadataUrl() throws IndexUnreachableException {\n        return getPageUrl(PageType.viewMetadata.getName(), imageToShow);\n    }\n\n    /**\n     * <p>\n     * getTopDocument.\n     * </p>\n     *\n     * @return a {@link io.goobi.viewer.model.viewer.StructElement} object.\n     */\n    public StructElement getTopDocument() {\n        if (viewManager != null) {\n            return viewManager.getTopStructElement();\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * setChildrenVisible.\n     * </p>\n     *\n     * @param element a {@link io.goobi.viewer.model.toc.TOCElement} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public void setChildrenVisible(TOCElement element)\n            throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (getToc() != null) {\n            synchronized (getToc()) {\n                getToc().setChildVisible(element.getID());\n                getToc().getActiveElement();\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * setChildrenInvisible.\n     * </p>\n     *\n     * @param element a {@link io.goobi.viewer.model.toc.TOCElement} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public void setChildrenInvisible(TOCElement element)\n            throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (getToc() != null) {\n            synchronized (getToc()) {\n                getToc().setChildInvisible(element.getID());\n                getToc().getActiveElement();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the visibility of TOC elements and jumps to the active element after a +/- button has been pressed.\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String calculateSidebarToc()\n            throws IOException, PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (getToc() != null) {\n            TOCElement activeTocElement = getToc().getActiveElement();\n            if (activeTocElement != null) {\n                String result = new StringBuilder(\"#\").append(activeTocElement.getLogId()).toString();\n                FacesContext.getCurrentInstance().getExternalContext().redirect(result);\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>toc</code>.\n     * </p>\n     *\n     * @return the toc\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public TOC getToc() throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        if (viewManager == null) {\n            return null;\n        }\n\n        if (viewManager.getToc() == null) {\n            viewManager.setToc(createTOC());\n        }\n        return viewManager.getToc();\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>tocCurrentPage</code>.\n     * </p>\n     *\n     * @return a int.\n     */\n    public String getTocCurrentPage() {\n        synchronized (this) {\n            return Integer.toString(tocCurrentPage);\n        }\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>tocCurrentPage</code>.\n     * </p>\n     *\n     * @param tocCurrentPage a int.\n     * @should set toc page to last page if value too high\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public void setTocCurrentPage(String tocCurrentPage)\n            throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        synchronized (this) {\n            int[] pages = StringTools.getIntegerRange(tocCurrentPage);\n            this.tocCurrentPage = pages[0];\n            if (this.tocCurrentPage < 1) {\n                this.tocCurrentPage = 1;\n            }\n            // Do not call getToc() here - the setter is usually called before update(), so the required information for proper TOC creation is not yet available\n            if (viewManager != null && viewManager.getToc() != null) {\n                int currentCurrentPage = viewManager.getToc().getCurrentPage();\n                viewManager.getToc().setCurrentPage(this.tocCurrentPage);\n                // The TOC object will correct values that are too high, so update the local value, if necessary\n                if (viewManager.getToc().getCurrentPage() != this.tocCurrentPage) {\n                    this.tocCurrentPage = viewManager.getToc().getCurrentPage();\n                }\n                // Create a new TOC if pagination is enabled and the paginator page has changed\n                if (currentCurrentPage != this.tocCurrentPage && DataManager.getInstance().getConfiguration().getTocAnchorGroupElementsPerPage() > 0\n                        && viewManager != null) {\n                    viewManager.getToc()\n                            .generate(viewManager.getTopStructElement(), viewManager.isListAllVolumesInTOC(), viewManager.getMimeType(),\n                                    this.tocCurrentPage);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * getTitleBarLabel.\n     * </p>\n     *\n     * @param locale a {@link java.util.Locale} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String getTitleBarLabel(Locale locale)\n            throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        return getTitleBarLabel(locale.getLanguage());\n    }\n\n    /**\n     * <p>\n     * getTitleBarLabel.\n     * </p>\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String getTitleBarLabel() throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        Locale locale = BeanUtils.getLocale();\n        if (locale != null) {\n            return getTitleBarLabel(locale.getLanguage());\n        }\n\n        return getTitleBarLabel(MultiLanguageMetadataValue.DEFAULT_LANGUAGE);\n    }\n\n    /**\n     * <p>\n     * getTitleBarLabel.\n     * </p>\n     *\n     * @param language a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String getTitleBarLabel(String language)\n            throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        if (navigationHelper == null) {\n            return null;\n        }\n\n        if (PageType.getByName(navigationHelper.getCurrentPage()) != null\n                && PageType.getByName(navigationHelper.getCurrentPage()).isDocumentPage() && viewManager != null) {\n            // Prefer the label of the current TOC element\n            TOC toc = getToc();\n            if (toc != null && toc.getTocElements() != null && !toc.getTocElements().isEmpty()) {\n                String label = null;\n                String labelTemplate = \"_DEFAULT\";\n                if (getViewManager() != null) {\n                    labelTemplate = getViewManager().getTopStructElement().getDocStructType();\n                }\n                if (DataManager.getInstance().getConfiguration().isDisplayAnchorLabelInTitleBar(labelTemplate)\n                        && StringUtils.isNotBlank(viewManager.getAnchorPi())) {\n                    String prefix = DataManager.getInstance().getConfiguration().getAnchorLabelInTitleBarPrefix(labelTemplate);\n                    String suffix = DataManager.getInstance().getConfiguration().getAnchorLabelInTitleBarSuffix(labelTemplate);\n                    prefix = ViewerResourceBundle.getTranslation(prefix, Locale.forLanguageTag(language)).replace(\"_SPACE_\", \" \");\n                    suffix = ViewerResourceBundle.getTranslation(suffix, Locale.forLanguageTag(language)).replace(\"_SPACE_\", \" \");\n                    label = prefix = toc.getLabel(viewManager.getAnchorPi(), language) + suffix + toc.getLabel(viewManager.getPi(), language);\n                } else {\n                    label = toc.getLabel(viewManager.getPi(), language);\n                }\n                if (label != null) {\n                    return label;\n                }\n            }\n            String label = viewManager.getTopStructElement().getLabel(selectedRecordLanguage);\n            if (StringUtils.isNotEmpty(label)) {\n                return label;\n            }\n        } else if (cmsBean != null && navigationHelper.isCmsPage()) {\n            CMSPage cmsPage = cmsBean.getCurrentPage();\n            if (cmsPage != null) {\n                String cmsPageName = StringUtils.isNotBlank(cmsPage.getMenuTitle()) ? cmsPage.getMenuTitle() : cmsPage.getTitle();\n                if (StringUtils.isNotBlank(cmsPageName)) {\n                    return cmsPageName;\n                }\n            }\n        }\n\n        if (navigationHelper.getCurrentPageType() != null) {\n            PageType pageType = navigationHelper.getCurrentPageType();\n            if (PageType.other.equals(pageType)) {\n                String pageLabel = navigationHelper.getCurrentPage();\n                if (StringUtils.isNotBlank(pageLabel)) {\n                    return Messages.translate(pageLabel, Locale.forLanguageTag(language));\n                }\n            }\n            return Messages.translate(pageType.getLabel(), Locale.forLanguageTag(language));\n        }\n\n        return null;\n    }\n\n    /**\n     * Title bar label value escaped for JavaScript.\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public String getLabelForJS() throws IndexUnreachableException, PresentationException, DAOException, ViewerConfigurationException {\n        String label = getTitleBarLabel();\n        if (label != null) {\n            return StringEscapeUtils.escapeEcmaScript(label);\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>imageContainerWidth</code>.\n     * </p>\n     *\n     * @return a int.\n     */\n    public int getImageContainerWidth() {\n        return imageContainerWidth;\n    }\n\n    /**\n     * <p>\n     * getNumberOfImages.\n     * </p>\n     *\n     * @return a int.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public int getNumberOfImages() throws IndexUnreachableException {\n        if (viewManager != null) {\n            return viewManager.getImagesCount();\n        }\n\n        return 0;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>topDocumentIddoc</code>.\n     * </p>\n     *\n     * @return Not this.topDocumentIddoc but ViewManager.topDocumentIddoc\n     */\n    public long getTopDocumentIddoc() {\n        if (viewManager != null) {\n            return viewManager.getTopStructElementIddoc();\n        }\n        return 0;\n    }\n\n    /**\n     * Indicates whether a record is currently properly loaded in this bean. Use to determine whether to display components.\n     *\n     * @return a boolean.\n     */\n    public boolean isRecordLoaded() {\n        return viewManager != null;\n    }\n\n    /**\n     * Checks if there is an anchor in this docStruct's hierarchy\n     *\n     * @return a boolean.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public boolean hasAnchor() throws IndexUnreachableException {\n        return getTopDocument().isAnchorChild();\n    }\n\n    /**\n     * Exports the currently loaded for re-indexing.\n     *\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.RecordNotFoundException if any.\n     */\n    public String reIndexRecordAction() throws IndexUnreachableException, DAOException, RecordNotFoundException {\n        if (viewManager != null) {\n            if (IndexerTools.reIndexRecord(viewManager.getPi())) {\n                Messages.info(\"reIndexRecordSuccess\");\n            } else {\n                Messages.error(\"reIndexRecordFailure\");\n            }\n        }\n\n        return \"\";\n    }\n\n    /**\n     * <p>\n     * deleteRecordAction.\n     * </p>\n     *\n     * @param keepTraceDocument If true, a .delete file will be created; otherwise a .purge file\n     * @return outcome\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public String deleteRecordAction(boolean keepTraceDocument) throws IOException, IndexUnreachableException {\n        try {\n            if (viewManager == null) {\n                return \"\";\n            }\n\n            if (IndexerTools.deleteRecord(viewManager.getPi(), keepTraceDocument,\n                    Paths.get(DataManager.getInstance().getConfiguration().getHotfolder()))) {\n                Messages.info(\"deleteRecord_success\");\n                return \"pretty:index\";\n            }\n            Messages.error(\"deleteRecord_failure\");\n        } finally {\n            deleteRecordKeepTrace = null;\n        }\n\n        return \"\";\n    }\n\n    /**\n     *\n     * @return\n     * @throws ClientProtocolException\n     * @throws IOException\n     * @throws IndexUnreachableException\n     */\n    public String clearCacheAction() throws ClientProtocolException, IOException, IndexUnreachableException {\n        logger.trace(\"clearCacheAction: {}\", clearCacheMode);\n        if (clearCacheMode == null || viewManager == null) {\n            return \"\";\n        }\n\n        String url = NetTools.buildClearCacheUrl(clearCacheMode, viewManager.getPi(), navigationHelper.getApplicationUrl(),\n                DataManager.getInstance().getConfiguration().getWebApiToken());\n        try {\n            try {\n                NetTools.getWebContentDELETE(url, null, null, null, null);\n                Messages.info(\"cache_clear__success\");\n            } catch (ClientProtocolException e) {\n                logger.error(e.getMessage());\n                Messages.error(\"cache_clear__failure\");\n            } catch (IOException e) {\n                logger.error(e.getMessage());\n                Messages.error(\"cache_clear__failure\");\n            }\n        } finally {\n            clearCacheMode = null;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * <p>\n     * getCurrentThumbnailPage.\n     * </p>\n     *\n     * @return a int.\n     */\n    public int getCurrentThumbnailPage() {\n        synchronized (this) {\n            return viewManager != null ? viewManager.getCurrentThumbnailPage() : 1;\n        }\n    }\n\n    /**\n     * <p>\n     * setCurrentThumbnailPage.\n     * </p>\n     *\n     * @param currentThumbnailPage a int.\n     */\n    public void setCurrentThumbnailPage(int currentThumbnailPage) {\n        synchronized (this) {\n            if (viewManager != null) {\n                viewManager.setCurrentThumbnailPage(currentThumbnailPage);\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * isHasLanguages.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isHasLanguages() {\n        return recordLanguages != null && !recordLanguages.isEmpty();\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>recordLanguages</code>.\n     * </p>\n     *\n     * @return the recordLanguages\n     */\n    public List<String> getRecordLanguages() {\n        return recordLanguages;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>recordLanguages</code>.\n     * </p>\n     *\n     * @param recordLanguages the recordLanguages to set\n     */\n    public void setRecordLanguages(List<String> recordLanguages) {\n        this.recordLanguages = recordLanguages;\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>selectedRecordLanguage</code>.\n     * </p>\n     *\n     * @return the selectedRecordLanguage\n     */\n    public String getSelectedRecordLanguage() {\n        return selectedRecordLanguage;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>selectedRecordLanguage</code>.\n     * </p>\n     *\n     * @param selectedRecordLanguage the selectedRecordLanguage to set\n     */\n    public void setSelectedRecordLanguage(String selectedRecordLanguage) {\n        logger.trace(\"setSelectedRecordLanguage: {}\", selectedRecordLanguage);\n        if (selectedRecordLanguage != null && selectedRecordLanguage.length() == 3) {\n            // Map ISO-3 codes to their ISO-2 variant\n            Language language = DataManager.getInstance().getLanguageHelper().getLanguage(selectedRecordLanguage);\n            if (language != null) {\n                logger.trace(\"Mapped language found: {}\", language.getIsoCodeOld());\n                this.selectedRecordLanguage = language.getIsoCodeOld();\n            } else {\n                logger.warn(\"Language not found for code: {}\", selectedRecordLanguage);\n                this.selectedRecordLanguage = selectedRecordLanguage;\n            }\n        } else {\n            this.selectedRecordLanguage = selectedRecordLanguage;\n        }\n        MetadataBean mdb = BeanUtils.getMetadataBean();\n        if (mdb != null) {\n            mdb.setSelectedRecordLanguage(this.selectedRecordLanguage);\n        }\n    }\n\n    /**\n     * <p>\n     * isAccessPermissionEpub.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isAccessPermissionEpub() {\n        synchronized (this) {\n            try {\n                if ((navigationHelper != null && !isEnabled(EPUBDownloadJob.LOCAL_TYPE, navigationHelper.getCurrentPage())) || viewManager == null\n                        || !DownloadJob.ocrFolderExists(viewManager.getPi())) {\n                    return false;\n                }\n            } catch (PresentationException | IndexUnreachableException e) {\n                logger.error(\"Error checking EPUB resources: {}\", e.getMessage());\n                return false;\n            }\n\n            // TODO EPUB privilege type\n            return viewManager.isAccessPermissionPdf();\n        }\n    }\n\n    /**\n     * <p>\n     * isAccessPermissionPdf.\n     * </p>\n     *\n     * @return a boolean.\n     */\n    public boolean isAccessPermissionPdf() {\n        synchronized (this) {\n            if ((navigationHelper != null && !isEnabled(PDFDownloadJob.LOCAL_TYPE, navigationHelper.getCurrentPage())) || viewManager == null) {\n                return false;\n            }\n\n            return viewManager.isAccessPermissionPdf();\n        }\n    }\n\n    /**\n     * @param currentPage\n     * @return\n     */\n    private static boolean isEnabled(String downloadType, String pageTypeName) {\n        if (downloadType.equals(EPUBDownloadJob.LOCAL_TYPE) && !DataManager.getInstance().getConfiguration().isGeneratePdfInTaskManager()) {\n            return false;\n        }\n        PageType pageType = PageType.getByName(pageTypeName);\n        boolean pdf = PDFDownloadJob.LOCAL_TYPE.equals(downloadType);\n        if (pageType != null) {\n            switch (pageType) {\n                case viewToc:\n                    return pdf ? DataManager.getInstance().getConfiguration().isTocPdfEnabled()\n                            : DataManager.getInstance().getConfiguration().isTocEpubEnabled();\n                case viewMetadata:\n                    return pdf ? DataManager.getInstance().getConfiguration().isMetadataPdfEnabled()\n                            : DataManager.getInstance().getConfiguration().isMetadataEpubEnabled();\n                default:\n                    return pdf ? DataManager.getInstance().getConfiguration().isTitlePdfEnabled()\n                            : DataManager.getInstance().getConfiguration().isTitleEpubEnabled();\n            }\n        }\n\n        logger.warn(\"Unknown page type: {}\", pageTypeName);\n        return false;\n    }\n\n    /**\n     * <p>\n     * downloadTOCAction.\n     * </p>\n     *\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public void downloadTOCAction() throws IOException, PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        try {\n\n            String fileNameRaw = getToc().getTocElements().get(0).getLabel();\n            String fileName = fileNameRaw + \".pdf\";\n\n            FacesContext fc = FacesContext.getCurrentInstance();\n            ExternalContext ec = fc.getExternalContext();\n            ec.responseReset(); // Some JSF component library or some Filter might have set some headers in the buffer beforehand. We want to get rid of them, else it may collide.\n            ec.setResponseContentType(\"application/pdf\");\n            ec.setResponseHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\"\");\n            OutputStream os = ec.getResponseOutputStream();\n            TocWriter writer = new TocWriter(\"\", fileNameRaw);\n            writer.createPdfDocument(os, getToc().getTocElements());\n            fc.responseComplete(); // Important! Otherwise JSF will attempt to render the response which obviously will fail since it's already written with a file and closed.\n        } catch (IndexOutOfBoundsException e) {\n            logger.error(\"No toc to generate\");\n        } catch (WriteTocException e) {\n            logger.error(\"Error writing toc: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * <p>\n     * getRelatedItems.\n     * </p>\n     *\n     * @param identifierField Index field containing related item identifiers\n     * @return List of related items as SearchHit objects.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public List<SearchHit> getRelatedItems(String identifierField)\n            throws PresentationException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        logger.trace(\"getRelatedItems: {}\", identifierField);\n        if (identifierField == null) {\n            return null;\n        }\n        if (viewManager == null) {\n            return null;\n        }\n        String query = getRelatedItemsQueryString(identifierField);\n        if (query == null) {\n            return null;\n        }\n\n        List<SearchHit> ret = SearchHelper.searchWithAggregation(query, 0, SolrSearchIndex.MAX_HITS, null, null, null, null, null, null,\n                navigationHelper.getLocale(), 0);\n\n        logger.trace(\"{} related items found\", ret.size());\n        return ret;\n    }\n\n    /**\n     * Returns a query string containing all values of the given identifier field.\n     *\n     * @param identifierField Index field containing related item identifiers\n     * @return Query string of the pattern \"PI:(a OR b OR c)\"\n     * @should construct query correctly\n     */\n    public String getRelatedItemsQueryString(String identifierField) {\n        logger.trace(\"getRelatedItemsQueryString: {}\", identifierField);\n        List<String> relatedItemIdentifiers = viewManager.getTopStructElement().getMetadataValues(identifierField);\n        if (relatedItemIdentifiers.isEmpty()) {\n            return null;\n        }\n\n        StringBuilder sbQuery = new StringBuilder(SolrConstants.PI).append(\":(\");\n        int initLength = sbQuery.length();\n        for (String identifier : relatedItemIdentifiers) {\n            if (sbQuery.length() > initLength) {\n                sbQuery.append(\" OR \");\n            }\n            sbQuery.append(identifier);\n        }\n        sbQuery.append(')');\n\n        return sbQuery.toString();\n    }\n\n    /**\n     * Returns a string that contains previous and/or next url <link> elements\n     *\n     * @return string containing previous and/or next url <link> elements\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     */\n    public String getRelativeUrlTags() throws IndexUnreachableException, DAOException, PresentationException {\n        if (!isRecordLoaded() || navigationHelper == null) {\n            return \"\";\n        }\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"current view: {}\", navigationHelper.getCurrentView());\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        // Add canonical links\n        if (viewManager.getCurrentPage() != null) {\n            if (StringUtils.isNotEmpty(viewManager.getCurrentPage().getUrn())) {\n                String urnResolverUrl = DataManager.getInstance().getConfiguration().getUrnResolverUrl() + viewManager.getCurrentPage().getUrn();\n                sb.append(\"\\n<link rel=\\\"canonical\\\" href=\\\"\").append(urnResolverUrl).append(\"\\\" />\");\n            }\n            if (viewManager.getCurrentPage().equals(viewManager.getRepresentativePage())) {\n                String piResolverUrl = navigationHelper.getApplicationUrl() + \"piresolver?id=\" + viewManager.getPi();\n                sb.append(\"\\n<link rel=\\\"canonical\\\" href=\\\"\").append(piResolverUrl).append(\"\\\" />\");\n            }\n        }\n        PageType currentPageType = PageType.getByName(navigationHelper.getCurrentView());\n        if (currentPageType != null && StringUtils.isNotEmpty(currentPageType.name())) {\n            // logger.trace(\"page type: {}\", currentPageType.getName());\n            // logger.trace(\"current url: {}\", navigationHelper.getCurrentUrl());\n            String currentUrl = navigationHelper.getCurrentUrl();\n            \n            if(currentUrl.contains(SolrTools.unescapeSpecialCharacters(getLogid()))) {\n                currentUrl = currentUrl.replace(SolrTools.unescapeSpecialCharacters(getLogid()), getLogid());\n            }\n            \n            if (currentUrl.contains(\"!\" + currentPageType.getName())) {\n                // Preferred view - add regular view URL\n                sb.append(\"\\n<link rel=\\\"canonical\\\" href=\\\"\")\n                        .append(currentUrl.replace(\"!\" + currentPageType.getName(), currentPageType.getName()))\n                        .append(\"\\\" />\");\n            } else if (currentUrl.contains(currentPageType.getName())) {\n                // Regular view - add preferred view URL\n                sb.append(\"\\n<link rel=\\\"canonical\\\" href=\\\"\")\n                        .append(currentUrl.replace(currentPageType.getName(), \"!\" + currentPageType.getName()))\n                        .append(\"\\\" />\");\n            }\n        }\n\n        // Skip prev/next links for non-paginated views\n        if (PageType.viewMetadata.equals(currentPageType) || PageType.viewToc.equals(currentPageType)) {\n            return \"\";\n        }\n\n        // Add next/prev links\n        String currentUrl = getPageUrl(imageToShow);\n        String prevUrl = getPreviousPageUrl();\n        String nextUrl = getNextPageUrl();\n        if (StringUtils.isNotEmpty(nextUrl) && !nextUrl.equals(currentUrl)) {\n            sb.append(\"\\n<link rel=\\\"next\\\" href=\\\"\").append(nextUrl).append(\"\\\" />\");\n        }\n        if (StringUtils.isNotEmpty(prevUrl) && !prevUrl.equals(currentUrl)) {\n            sb.append(\"\\n<link rel=\\\"prev\\\" href=\\\"\").append(prevUrl).append(\"\\\" />\");\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * resets the access rights for user comments and pdf download stored in {@link io.goobi.viewer.model.viewer.ViewManager}. After reset, the access\n     * rights will be evaluated again on being called\n     */\n    public void resetAccess() {\n        if (getViewManager() != null) {\n            getViewManager().resetAccessPermissionPdf();\n            getViewManager().resetAllowUserComments();\n        }\n    }\n\n    /**\n     * <p>\n     * Getter for the field <code>deleteRecordKeepTrace</code>.\n     * </p>\n     *\n     * @return the deleteRecordKeepTrace\n     */\n    public Boolean getDeleteRecordKeepTrace() {\n        return deleteRecordKeepTrace;\n    }\n\n    /**\n     * <p>\n     * Setter for the field <code>deleteRecordKeepTrace</code>.\n     * </p>\n     *\n     * @param deleteRecordKeepTrace the deleteRecordKeepTrace to set\n     */\n    public void setDeleteRecordKeepTrace(Boolean deleteRecordKeepTrace) {\n        this.deleteRecordKeepTrace = deleteRecordKeepTrace;\n    }\n\n    /**\n     * @return the clearCacheMode\n     */\n    public String getClearCacheMode() {\n        return clearCacheMode;\n    }\n\n    /**\n     * @param clearCacheMode the clearCacheMode to set\n     */\n    public void setClearCacheMode(String clearCacheMode) {\n        logger.trace(\"setClearCacheMode: {}\", clearCacheMode);\n        this.clearCacheMode = clearCacheMode;\n    }\n\n    /**\n     * Get a CMSSidebarElement with a map containing all GeoMarkers for the current PI. The widget is stored in the bean, but refreshed each time the\n     * PI changes\n     *\n     * @return\n     * @throws PresentationException\n     * @throws DAOException\n     * @throws IndexUnreachableException\n     */\n    public synchronized GeoMap getGeoMap() throws PresentationException, DAOException, IndexUnreachableException {\n        GeoMap widget = this.geoMaps.get(getPersistentIdentifier());\n        if (widget == null) {\n            widget = generateGeoMap(getPersistentIdentifier());\n            this.geoMaps = Collections.singletonMap(getPersistentIdentifier(), widget);\n        }\n        return widget;\n    }\n\n    /**\n     * \n     * @param pi\n     * @return\n     * @throws PresentationException\n     * @throws DAOException\n     */\n    public GeoMap generateGeoMap(String pi) throws PresentationException, DAOException {\n        try {\n            if (\"-\".equals(pi)) {\n                return null;\n            }\n\n            GeoMap map = new GeoMap();\n            map.setId(Long.MAX_VALUE);\n            map.setType(GeoMapType.MANUAL);\n            map.setShowPopover(true);\n            map.setMarkerTitleField(null);\n            map.setMarker(\"default\");\n\n            String mainDocQuery = String.format(\"PI:%s\", pi);\n            List<String> mainDocFields = PrettyUrlTools.getSolrFieldsToDeterminePageType();\n            SolrDocument mainDoc = DataManager.getInstance().getSearchIndex().getFirstDoc(mainDocQuery, mainDocFields);\n            PageType pageType = PrettyUrlTools.getPreferredPageType(mainDoc);\n\n            boolean addMetadataFeatures = DataManager.getInstance().getConfiguration().includeCoordinateFieldsFromMetadataDocs();\n            String docTypeFilter = \"+DOCTYPE:DOCSTRCT\";\n            if (addMetadataFeatures) {\n                docTypeFilter = \"+(DOCTYPE:DOCSTRCT DOCTYPE:METADATA)\";\n            }\n\n            String subDocQuery = String.format(\"+PI_TOPSTRUCT:%s \" + docTypeFilter, pi);\n            List<String> coordinateFields = DataManager.getInstance().getConfiguration().getGeoMapMarkerFields();\n            List<String> subDocFields = new ArrayList<>();\n            subDocFields.add(SolrConstants.LABEL);\n            subDocFields.add(SolrConstants.PI_TOPSTRUCT);\n            subDocFields.add(SolrConstants.THUMBPAGENO);\n            subDocFields.add(SolrConstants.LOGID);\n            subDocFields.add(SolrConstants.ISWORK);\n            subDocFields.add(SolrConstants.DOCTYPE);\n            subDocFields.add(\"MD_VALUE\");\n            subDocFields.addAll(coordinateFields);\n\n            Collection<GeoMapFeature> features = new ArrayList<>();\n\n            List<DisplayUserGeneratedContent> annos = DataManager.getInstance()\n                    .getDao()\n                    .getAnnotationsForWork(pi)\n                    .stream()\n                    .filter(a -> PublicationStatus.PUBLISHED.equals(a.getPublicationStatus()))\n                    .filter(a -> StringUtils.isNotBlank(a.getBody()))\n                    .map(a -> new DisplayUserGeneratedContent(a))\n                    .filter(a -> ContentType.GEOLOCATION.equals(a.getType()))\n                    .filter(a -> ContentBean.isAccessible(a, BeanUtils.getRequest()))\n                    .collect(Collectors.toList());\n            for (DisplayUserGeneratedContent anno : annos) {\n                if (anno.getAnnotationBody() instanceof TypedResource) {\n                    GeoMapFeature feature = new GeoMapFeature(((TypedResource) anno.getAnnotationBody()).asJson());\n                    features.add(feature);\n                }\n            }\n\n            SolrDocumentList subDocs = DataManager.getInstance().getSearchIndex().getDocs(subDocQuery, subDocFields);\n            if (subDocs != null) {\n                for (SolrDocument solrDocument : subDocs) {\n                    List<GeoMapFeature> docFeatures = new ArrayList<>();\n                    for (String coordinateField : coordinateFields) {\n                        String docType = solrDocument.getFieldValue(SolrConstants.DOCTYPE).toString();\n                        String labelField = \"METADATA\".equals(docType) ? \"MD_VALUE\" : SolrConstants.LABEL;\n                        docFeatures.addAll(GeoMap.getGeojsonPoints(solrDocument, coordinateField, labelField, null));\n                    }\n                    if (!solrDocument.containsKey(SolrConstants.ISWORK) && solrDocument.getFieldValue(SolrConstants.DOCTYPE).equals(\"DOCSTRCT\")) {\n                        docFeatures.forEach(f -> f.setLink(PrettyUrlTools.getRecordUrl(solrDocument, pageType)));\n                    } else {\n                        docFeatures.forEach(f -> f.setLink(null));\n                    }\n                    docFeatures.forEach(f -> f.setDocumentId((String) solrDocument.getFieldValue(SolrConstants.LOGID)));\n                    features.addAll(docFeatures);\n                }\n            }\n            //remove dubplicates\n            features = features.stream().distinct().collect(Collectors.toList());\n            if (!features.isEmpty()) {\n                map.setFeatures(features.stream().map(f -> f.getJsonObject().toString()).collect(Collectors.toList()));\n            }\n            return map;\n        } catch (IndexUnreachableException e) {\n            logger.error(\"Unable to load geomap\", e);\n            return null;\n        }\n    }\n\n    /**\n     *\n     */\n    public void toggleDownloadImageModal() {\n        downloadImageModalVisible = !downloadImageModalVisible;\n    }\n\n    /**\n     * @return the downloadImageModalVisible\n     */\n    public boolean isDownloadImageModalVisible() {\n        return downloadImageModalVisible;\n    }\n\n    /**\n     *\n     */\n    public DownloadOption getSelectedDownloadOption() {\n        if (selectedDownloadOptionLabel == null) {\n            return null;\n        }\n\n        return DownloadOption.getByLabel(selectedDownloadOptionLabel);\n    }\n\n    /**\n     * @return the selectedDownloadOptionLabel\n     */\n    public String getSelectedDownloadOptionLabel() {\n        return selectedDownloadOptionLabel;\n    }\n\n    /**\n     * @param selectedDownloadOptionLabel the selectedDownloadOptionLabel to set\n     */\n    public void setSelectedDownloadOptionLabel(String selectedDownloadOptionLabel) {\n        logger.trace(\"setSelectedDownloadOption: {}\", selectedDownloadOptionLabel != null ? selectedDownloadOptionLabel : null);\n        this.selectedDownloadOptionLabel = selectedDownloadOptionLabel;\n    }\n\n    public void setDownloadOptionLabelFromRequestParameter() {\n        Map<String, String> params = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap();\n\n        String value = params.get(\"optionvalue\");\n        if (StringUtils.isNotBlank(value)) {\n            setSelectedDownloadOptionLabel(value);\n        }\n\n    }\n\n    /**\n     * This method augments the setter <code>ViewManager.setDoublePageMode(boolean)</code> with URL modifications to reflect the mode.\n     *\n     * @param doublePageMode The doublePageMode to set\n     * @throws IndexUnreachableException\n     * @throws DAOException\n     * @should set imageToShow if value changes\n     */\n    public String setDoublePageModeAction(boolean doublePageMode) throws IndexUnreachableException, DAOException {\n        if (viewManager == null) {\n            return \"\";\n        }\n        try {\n            // Adapt URL page range when switching between single and double page modes\n            if (viewManager.isDoublePageMode() != doublePageMode) {\n                if (doublePageMode && !viewManager.getCurrentPage().isDoubleImage()) {\n                    Optional<PhysicalElement> currentLeftPage = viewManager.getCurrentLeftPage();\n                    Optional<PhysicalElement> currentRightPage = viewManager.getCurrentRightPage();\n                    if (currentLeftPage.isPresent() && currentRightPage.isPresent()) {\n                        imageToShow = currentLeftPage.get().getOrder() + \"-\" + currentRightPage.get().getOrder();\n                    } else if (currentLeftPage.isPresent()) {\n                        imageToShow = currentLeftPage.get().getOrder() + \"-\" + currentLeftPage.get().getOrder();\n                    } else if (currentRightPage.isPresent()) {\n                        imageToShow = currentRightPage.get().getOrder() + \"-\" + currentRightPage.get().getOrder();\n                    }\n                } else if (doublePageMode) {\n                    imageToShow = String.valueOf(viewManager.getCurrentPage().getOrder() + \"-\" + viewManager.getCurrentPage().getOrder());\n                } else {\n                    imageToShow = String.valueOf(viewManager.getCurrentPage().getOrder());\n                }\n            }\n        } finally {\n            viewManager.setDoublePageMode(doublePageMode);\n        }\n\n        // When not using PrettyContext, the updated URL will always be a click behind\n        if (PrettyContext.getCurrentInstance() != null && PrettyContext.getCurrentInstance().getCurrentMapping() != null) {\n            return \"pretty:\" + PrettyContext.getCurrentInstance().getCurrentMapping().getId();\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Indicates whether user comments are allowed for the current record based on several criteria.\n     *\n     * @return a boolean.\n     * @throws DAOException\n     */\n    public synchronized boolean isAllowUserComments() throws DAOException {\n        if (viewManager == null) {\n            return false;\n        }\n\n        CommentGroup commentGroupAll = DataManager.getInstance().getDao().getCommentGroupUnfiltered();\n        if (commentGroupAll == null) {\n            logger.warn(\"Comment view for all comments not found in the DB, please insert.\");\n            return false;\n        }\n        if (!commentGroupAll.isEnabled()) {\n            logger.trace(\"User comments disabled globally.\");\n            viewManager.setAllowUserComments(false);\n            return false;\n        }\n\n        if (viewManager.isAllowUserComments() == null) {\n            try {\n                if (StringUtils.isNotEmpty(commentGroupAll.getSolrQuery()) && DataManager.getInstance()\n                        .getSearchIndex()\n                        .getHitCount(new StringBuilder(\"+\").append(SolrConstants.PI)\n                                .append(':')\n                                .append(viewManager.getPi())\n                                .append(\" +(\")\n                                .append(commentGroupAll.getSolrQuery())\n                                .append(')')\n                                .toString()) == 0) {\n                    viewManager.setAllowUserComments(false);\n                    logger.trace(\"User comments are not allowed for this record.\");\n                } else {\n                    viewManager.setAllowUserComments(true);\n                }\n            } catch (IndexUnreachableException e) {\n                logger.debug(\"IndexUnreachableException thrown here: {}\", e.getMessage());\n                return false;\n            } catch (PresentationException e) {\n                logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage());\n                return false;\n            }\n        }\n\n        return viewManager.isAllowUserComments();\n    }\n\n    /**\n     * Check if the current page should initialize a WebSocket\n     * \n     * @return true if a document is loaded and it contains the field {@link SolrConstants.ACCESSCONDITION_CONCURRENTUSE}\n     */\n    public boolean isRequiresWebSocket() {\n        if (viewManager != null && viewManager.getTopStructElement() != null && viewManager.getTopStructElement().getMetadataFields() != null) {\n            return viewManager.getTopStructElement().getMetadataFields().containsKey(SolrConstants.ACCESSCONDITION_CONCURRENTUSE);\n        }\n\n        return false;\n    }\n\n}\n"], "filenames": ["goobi-viewer-core/src/main/java/io/goobi/viewer/managedbeans/ActiveDocumentBean.java"], "buggy_code_start_loc": [755], "buggy_code_end_loc": [786], "fixing_code_start_loc": [755], "fixing_code_end_loc": [793], "type": "CWE-79", "message": "The Goobi viewer is a web application that allows digitised material to be displayed in a web browser. A reflected cross-site scripting vulnerability has been identified in Goobi viewer core prior to version 23.03 when evaluating the LOGID parameter. An attacker could trick a user into following a specially crafted link to a Goobi viewer installation, resulting in the execution of malicious script code in the user's browser. The vulnerability has been fixed in version 23.03.", "other": {"cve": {"id": "CVE-2023-29014", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-06T20:15:08.557", "lastModified": "2023-04-12T20:21:16.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Goobi viewer is a web application that allows digitised material to be displayed in a web browser. A reflected cross-site scripting vulnerability has been identified in Goobi viewer core prior to version 23.03 when evaluating the LOGID parameter. An attacker could trick a user into following a specially crafted link to a Goobi viewer installation, resulting in the execution of malicious script code in the user's browser. The vulnerability has been fixed in version 23.03."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:intranda:goobi_viewer_core:*:*:*:*:*:*:*:*", "versionEndExcluding": "23.03", "matchCriteriaId": "F8174D86-7F9F-4ADD-85CA-16EB572F1F26"}]}]}], "references": [{"url": "https://github.com/intranda/goobi-viewer-core/commit/c29efe60e745a94d03debc17681c4950f3917455", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/intranda/goobi-viewer-core/security/advisories/GHSA-7v7g-9vx6-vcg2", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/intranda/goobi-viewer-core/commit/c29efe60e745a94d03debc17681c4950f3917455"}}