{"buggy_code": ["Changes\n=======\n\nv2 has many incompatibilities with v1. To see the full list of differences between\nv1 and v2, please read the Changes-v2.md file (https://github.com/lestrrat-go/jwx/blob/develop/v2/Changes-v2.md)\n\nv2.0.19 UNRELEASED\n[New Features]\n  * [jws] Added jws.IsVerificationError to check if the error returned by `jws.Verify`\n    was caused by actual verification step or something else, for example, while fetching\n    a key from datasource\n\nv2.0.18 03 Dec 2023\n[Security Fixes]\n  * [jwe] A large number in p2c parameter for PBKDF2 based encryptions could cause a DoS attack,\n    similar to https://nvd.nist.gov/vuln/detail/CVE-2022-36083.  All users who use JWE via this\n    package should upgrade. While the JOSE spec allows for encryption using JWE on JWTs, users of\n    the `jwt` package are not immediately susceptible unless they explicitly try to decrypt\n    JWTs -- by default the `jwt` package verifies signatures, but does not decrypt messages.\n    [GHSA-7f9x-gw85-8grf]\n\nv2.0.17 20 Nov 2023\n[Bug Fixes]\n  * [jws] Previously, `jws.UnregisterSigner` did not remove the previous signer instance when\n    the signer was registered and unregistered multiple times (#1016). This has been fixed.\n\n[New Features]\n  * [jwe] (EXPERIMENTAL) `jwe.WithCEK` has been added to extract the content encryption key (CEK) from the Decrypt operation.\n  * [jwe] (EXPERIMENTAL) `jwe.EncryptStatic` has been added to encrypt content using a static CEK.\n    Using static CEKs has serious security implications, and you should not use\n    this unless you completely understand the risks involved.\n\nv2.0.16 31 Oct 2023\n[Security]\n  * [jws] ECDSA signature verification requires us to check if the signature\n    is of the desired length of bytes, but this check that used to exist before\n    had been removed in #65, resulting in certain malformed signatures to pass\n    verification.\n\n    One of the ways this could happen if R is a 31 byte integer and S is 32 byte integer,\n    both containing the correct signature values, but R is not zero-padded.\n\n       Correct = R: [ 0 , ... ] (32 bytes) S: [ ... ] (32 bytes)\n       Wrong   = R: [ ... ] (31 bytes)     S: [ ... ] (32 bytes)\n\n    In order for this check to pass, you would still need to have all 63 bytes\n    populated with the correct signature. The only modification a bad actor\n    may be able to do is to add one more byte at the end, in which case the\n    first 32 bytes (including what would have been S's first byte) is used for R,\n    and S would contain the rest. But this will only result in the verification to\n    fail. Therefore this in itself should not pose any security risk, albeit\n    allowing some illegally formated messages to be verified.\n\n  * [jwk] `jwk.Key` objects now have a `Validate()` method to validate the data\n    stored in the keys. However, this still does not necessarily mean that the key's\n    are valid for use in cryptographic operations. If `Validate()` is successful,\n    it only means that the keys are in the right _format_, including the presence\n    of required fields and that certain fields have proper length, etc.\n\n[New Features]\n  * [jws] Added `jws.WithValidateKey()` to force calling `key.Validate()` before\n    signing or verification.\n\n  * [jws] `jws.Sign()` now returns a special type of error that can hold the\n    individual errors from the signers. The stringification is still the same\n    as before to preserve backwards compatibility.\n\n  * [jwk] Added `jwk.IsKeyValidationError` that checks if an error is an error\n    from `key.Validate()`.\n\n[Bug Fixes]\n  * [jwt] `jwt.ParseInsecure()` was running verification if you provided a key\n    via `jwt.WithKey()` or `jwt.WithKeySet()` (#1007)\n\nv2.0.15 19 20 Oct 2023\n[Bug fixes]\n  * [jws] jws.Sign() now properly check for valid algorithm / key type pair when\n    the key implements crypto.Signer. This was caused by the fact that when \n    jws.WithKey() accepted keys that implemented crypto.Signer, there really\n    is no way to robustly check what algorithm the crypto.Signer implements.\n\n    The code has now been modified to check for KNOWN key types, i.e. those\n    that are defined in Go standard library, and those that are defined in\n    this library. For example, now calling jws.Sign() with jws.WithKey(jwa.RS256, ecdsaKey)\n    where ecdsaKey is either an instance of *ecdsa.PrivateKey or jwk.ECDSAPrivateKey\n    will produce an error.\n\n    However, if you use a separate library that wraps some KMS library which implements\n    crypto.Signer, this same check will not be performed due to the fact that\n    it is an unknown library to us. And there's no way to query a crypto.Signer\n    for its algorithm family.\n\nv2.0.14 17 Oct 2023\n[New Features]\n  * [jwk] jwk.IsPrivateKey(), as well as jwk.AsymmetricKey has been added.\n    The function can be used to tell if a jwk.Key is a private key of an\n    asymmetric key pair.\n[Security]\n  * golang.org/x/crypto has been updated to 0.14.0. The update contains a fix for HTTP/2\n    rapid reset DoS vulnerability, which some security scanning softwares may flag.\n    However, do note that this library is NOT affected by the issue, as it does not have\n    the capability to serve as an HTTP/2 server. This is included in this release\n    document so that users will be able to tell why this library may be flagged\n    when/if their scanning software do so.\n\nv2.0.13 26 Sep 2023\n[New Features]\n  * [jwk] jwk.Equal has been added. Please note that this is equivalent to\n  comparing the keys' thumbprints, therefore it does NOT take in consideration\n  non-essential fields.\n\n[Miscellaneous]\n  * Various documentation fixes and additions.\n\nv2.0.12 - 11 Aug 2023\n[Bug fixes]\n  * [jwt] jwt.Serializer was ignoring JWE flags (#951)\n\n[Miscellaneous]\n  * [jwk] Check for seed length on OKP JWKs to avoid panics (#947)\n  * [jws] Documentation for jws.WithKeySet()\n\nv2.0.11 - 14 Jun 2023\n[Security]\n  * Potential Padding Oracle Attack Vulnerability and Timing Attack Vulnerability \n    for JWE AES-CBC encrypted payloads affecting all v2 releases up to v2.0.10,\n    all v1 releases up to v1.2.25, and all v0 releases up to v0.9.2 have been reported by\n    @shogo82148.\n\n    Please note that v0 versions will NOT receive fixes.\n    This release fixes these vulnerabilities for the v2 series.\n\nv2.0.10 - 12 Jun 2023\n[New Features]\n  * [jwe] (EXPERIMENTAL) Added `jwe.KeyEncrypter` and `jwe.KeyDecrypter` interfaces\n    that works in similar ways as how `crypto.Signer` works for signature\n    generation and verification. It can act as the interface for your encryption/decryption\n    keys that are for example stored in an hardware device.\n\n    This feature is labeled experimental because the API for the above interfaces have not\n    been battle tested, and may need to changed yet. Please be aware that until the API\n    is deemed stable, you may have to adapat our code to these possible changes,\n    _even_ during minor version upgrades of this library.\n   \n[Bug fixes]\n  * Registering JWS signers/verifiers did not work since v2.0.0, because the\n    way we handle algorithm names changed in 2aa98ce6884187180a7145b73da78c859dd46c84.\n    (We previously thought that this would be checked by the example code, but it\n     apparently failed to flag us properly)\n\n    The logic behind managing the internal database has been fixed, and\n    `jws.RegisterSigner` and `jws.RegisterVerifier` now properly hooks into the new\n    `jwa.RegisterSignatureAlgorithm` to automatically register new algorithm names\n    (#910, #911)\n[Miscellaneous]\n  * Added limited support for github.com/segmentio/asm/base64. Compile your code\n    with the `jwx_asmbase64` build tag. This feature is EXPERIMENTAL.\n\n    Through limited testing, the use of a faster base64 library provide 1~5% increase\n    in throughput on average. It might make more difference if the input/output is large.\n    If you care about this performance improvement, you should probably enable\n    `goccy` JSON parser as well, by specifying `jwx_goccy,jwx_asmbase64` in your build call.\n  * Slightly changed the way global variables underneath `jwk.Fetch` are initialized and\n    configured. `jwk.Fetch` creates an object that spawns wokers to fetch JWKS when it's\n    first called.\n    You can now also use `jwk.SetGlobalFetcher()` to set a fetcher object which you can\n    control.\n\nv2.0.9 - 21 Mar 2023\n[Security Fixes]\n  * Updated use of golang.org/x/crypto to v0.7.0\n[Bug fixes]\n  * Emitted PEM file for EC private key types used the wrong PEM armor (#875)\n[Miscellaneous]\n  * Banners for generated files have been modified to allow tools to pick them up (#867)\n  * Remove unused variables around ReadFileOption (#866)\n  * Fix test failures\n  * Support bazel out of the box\n  * Now you can create JWS messages using `{\"alg\":\"none\"}`, by calling `jws.Sign()`\n    with `jws.WithInsecureNoSignature()` option. (#888, #890).\n\n    Note that there is no way to call\n    `jws.Verify()` while allowing `{\"alg\":\"none\"}` as you wouldn't be _verifying_\n    the message if we allowed the \"none\" algorithm. `jws.Parse()` will parse such\n    messages witout verification.\n\n    `jwt` also allows you to sign using alg=\"none\", but there's no symmetrical\n    way to verify such messages.\n\nv2.0.8 - 25 Nov 2022\n[Security Fixes]\n  * [jws][jwe] Starting from go 1.19, code related to elliptic algorithms\n    panics (instead of returning an error) when certain methods\n    such as `ScalarMult` are called using points that are not on the\n    elliptic curve being used.\n\n    Using inputs that cause this condition, and you accept unverified JWK\n    from the outside it may be possible for a third-party to cause panics\n    in your program.\n\n    This has been fixed by verifying that the point being used is actually\n    on the curve before such computations (#840)\n[Miscellaneous]\n  * `jwx.GuessFormat` now returns `jwx.InvalidFormat` when the heuristics\n    is sure that the buffer format is invalid.\n\nv2.0.7 - 15 Nov 2022\n[New features]\n  * [jwt] Each `jwt.Token` now has an `Options()` method\n  * [jwt] `jwt.Settings(jwt.WithFlattenedAudience(true))` has a slightly\n    different semantic than before. Instead of changing a global variable,\n    it now specifies that the default value of each per-token option for\n    `jwt.FlattenAudience` is true.\n\n    Therefore, this is what happens:\n\n       // No global settings\n       tok := jwt.New()\n       tok.Options.IsEnabled(jwt.FlattenAudience) // false\n\n       // With global settings\n       jwt.Settings(jwt.WithFlattenedAudience(true))\n       tok := jwt.New()\n       tok.Options.IsEnabled(jwt.FlattenAudience) // true\n       // But you can still turn FlattenAudience off for this\n       // token alone\n       tok.Options.Disable(jwt.FlattenAudience)\n\n    Note that while unlikely to happen for users relying on the old behavior,\n    this change DOES introduce timing issues: whereas old versions switched the\n    JSON marshaling for ALL tokens immediately after calling `jwt.Settings`,\n    the new behavior does NOT affect tokens that have been created before the\n    call to `jwt.Settings` (but marshaled afterwards).\n\n    So the following may happen:\n\n      // < v2.0.7\n      tok := jwt.New() \n      jwt.Settings(jwt.WithFlattenedAudience(true))\n      json.Marshal(tok) // flatten = on\n\n      // >= v2.0.7\n      tok := jwt.New() // flatten = off\n      jwt.Settings(jwt.WithFlattenedAudience(true))\n      json.Marshal(tok) // flatten is still off\n\n    It is recommended that you only set the global setting once at the\n    very beginning of your program to avoid problems.\n\n    Also note that `Clone()` copies the settings as well.\n\n[Miscellaneous]\n  * WithCompact's stringification should have been that of the\n    internal indentity struct (\"WithSerialization\"), but it was\n    wrongly producing \"WithCompact\". This has been fixed.\n  * Go Workspaces have been enabled within this module.\n    - When developing, modules will refer to the main jwx module that they\n      are part of. This allows us to explicitly specify the dependency version\n      in, for example, ./cmd/jwx/go.mod but still develop against the local version.\n    - If you are using `goimports` and other tools, you might want to upgrade\n      binaries -- for example, when using vim-go's auto-format-on-save feature,\n      my old binaries took well over 5~10 seconds to compute the import paths.\n      This was fixed when I switched to using go1.19, and upgraded the binaries\n      used by vim-go\n\nv2.0.6 - 25 Aug 2022\n[Bug fixes][Security]\n  * [jwe] Agreement Party UInfo and VInfo (apv/apu) were not properly being\n    passed to the functions to compute the aad when encrypting using ECDH-ES\n    family of algorithms. Therefore, when using apu/apv, messages encrypted\n    via this module would have failed to be properly decrypted.\n\n    Please note that bogus encrypted messages would not have succeed being\n    decrypted (i.e. this problem does not allow spoofed messages to be decrypted).\n    Therefore this would not have caused unwanted data to to creep in --\n    however it did pose problems for data to be sent and decrypted from this module\n    when using ECDH-ES with apu/apv.\n\n    While not extensively tested, we believe this regression was introduced\n    with the v2 release.\n\nv2.0.5 - 11 Aug 2022\n[Bug fixes]\n  * [jwt] Remove stray debug log\n  * [jwk] Fix x5u field name, caused by a typo\n  * [misc] Update golangci-lint action to v3; v2 was causing weird problems\n\nv2.0.4 - 19 Jul 2022\n[Bug Fixes]\n  * [jwk] github.com/lestrrat-go/httprc, which jwk.Cache depends on,\n    had a problem with inserting URLs to be re-fetched into its queue.\n    As a result it could have been the case that some JWKS were not\n    updated properly. Please upgrade if you use jwk.Cache.\n\n  * [jwk] cert.Get could fail with an out of bounds index look up\n\n  * [jwk] Fix doc buglet in `KeyType()` method\n\n[New Features]\n  * [jws] Add `jws.WithMultipleKeysPerKeyID()` sub-option to allow non-unique\n    key IDs in a given JWK set. By default we assume that a key ID is unique\n    within a key set, but enabling this option allows you to handle JWK sets\n    that contain multiple keys that contain the same key ID.\n\n  * [jwt] Before v2.0.1, sub-second accuracy for time based fields\n    (i.e. `iat`, `exp`, `nbf`) were not respected. Because of this the code\n    to evaluate this code had always truncated any-subsecond portion\n    of these fields, and therefore no sub-second comparisons worked.\n    A new option for validation `jwt.WithTruncation()` has been added\n    to workaround this. This option controls the value used to truncate\n    the time fields. When set to 0, sub-second comparison would be\n    possible.\n    FIY, truncatation will still happen because we do not want to\n    use the monotonic clocks when making comparisons. It's just that\n    truncating using `0` as its argument effectively only strips out\n    the monotonic clock\n\nv2.0.3 - 13 Jun 2022\n[Bug Fixes]\n  * [jwk] Update dependency on github.com/lestrrat-go/httprc to v1.0.2 to\n    avoid unintended blocking in the update goroutine for jwk.Cache\n\nv2.0.2 - 23 May 2022\n[Bug Fixes][Security]\n  * [jwe] An old bug from at least 7 years ago existed in handling AES-CBC unpadding,\n    where the unpad operation might remove more bytes than necessary (#744)\n    This affects all jwx code that is available before v2.0.2 and v1.2.25.\n\n[New Features]\n  * [jwt] RFC3339 timestamps are also accepted for Numeric Date types in JWT tokens.\n    This allows users to parse servers that errnously use RFC3339 timestamps in\n    some pre-defined fields. You can change this behavior by setting \n    `jwt.WithNumericDateParsePedantic` to `false`\n  * [jwt] `jwt.WithNumericDateParsePedantic` has been added. This is a global\n    option that is set using `jwt.Settings`\n\nv2.0.1 - 06 May 2022\n  * [jwk] `jwk.Set` had erronously been documented as not returning an error\n    when the same key already exists in the set. This is a behavior change\n    since v2, and it was missing in the docs (#730)\n  * [jwt] `jwt.ErrMissingRequiredClaim` has been deprecated. Please use\n    `jwt.ErrRequiredClaim` instead.\n  * [jwt] `jwt.WithNumericDateParsePrecision` and `jwt.WithNumericDateFormatPrecision`\n    have been added to parse and format fractional seconds. These options can be\n    passed to `jwt.Settings`.\n    The default precision is set to 0, and fractional portions are not parsed nor\n    formatted. The precision may be set up to 9.\n  * `golang.org/x/crypto` has been upgraded (#724)\n  * `io/ioutil` has been removed from the source code.\n\nv2.0.0 - 24 Apr 2022\n  * This i the first v2 release, which represents a set of design changes\n    that were learnt over the previous 2 years. As a result the v2 API\n    should be much more consistent and uniform across packages, and\n    should be much more flexible to accomodate real-world needs.\n    \n    For a complete list of changes, please see the Changes-v2.md file,\n    or check the diff at https://github.com/lestrrat-go/jwx/compare/v1...v2\n\n[Miscellaneous]\n  * Minor house cleaning on code generation tools\n\n[jwt]\n  * `jwt.ErrMissingRequiredClaim()` has been added\n\nv2.0.0-beta2 - 16 Apr 2022\n[jwk]\n  * Updated `jwk.Set` API and reflected pending changes from v1 which were\n    left over. Please see Changes-v2.md file for details.\n\n  * Added `jwk.CachedSet`, a shim over `jwk.Cache` that allows you to\n    have to write wrappers around `jwk.Cache` that retrieves a particular\n    `jwk.Set` out of it. You can use it to, for example, pass `jwk.CachedSet`\n    to a `jws.Verify`\n\n      cache := jwk.NewCache(ctx)\n      cache.Register(ctx, jwksURL)\n      cachedSet := jwk.NewCachedSet(cache, jwksURL)\n      jws.Verify(signed, jws.WithKeySet(cachedSet))\n\nv2.0.0-beta1 - 09 Apr 2022\n[Miscellaneous]\n  * Renamed Changes.v2 to Changes-v2.md\n  * Housecleaning for lint action.\n  * While v2 was not affected, ported over equivalent test for #681 to catch\n    regressions in the future.\n  * Please note that there is no stability guarantees on pre-releases.\n\nv2.0.0-alpha1 - 04 Apr 2022\n  * Initial pre-release of v2 line. Please note that there is no stability guarantees\n    on pre-releases.\n", "package jws_test\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"encoding/asn1\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/lestrrat-go/httprc\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/base64\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/json\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/jwxtest\"\n\t\"github.com/lestrrat-go/jwx/v2/jwa\"\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\t\"github.com/lestrrat-go/jwx/v2/jws\"\n\t\"github.com/lestrrat-go/jwx/v2/jwt\"\n\t\"github.com/lestrrat-go/jwx/v2/x25519\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst examplePayload = `{\"iss\":\"joe\",` + \"\\r\\n\" + ` \"exp\":1300819380,` + \"\\r\\n\" + ` \"http://example.com/is_root\":true}`\nconst exampleCompactSerialization = `eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk`\nconst badValue = \"%badvalue%\"\n\nvar hasES256K bool\n\nfunc TestSanity(t *testing.T) {\n\tt.Run(\"sanity: Verify with single key\", func(t *testing.T) {\n\t\tkey, err := jwk.ParseKey([]byte(`{\n    \"kty\": \"oct\",\n    \"k\": \"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow\"\n  }`))\n\t\trequire.NoError(t, err, `jwk.ParseKey should succeed`)\n\t\tpayload, err := jws.Verify([]byte(exampleCompactSerialization), jws.WithKey(jwa.HS256, key))\n\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\trequire.Equal(t, []byte(examplePayload), payload, `payloads should match`)\n\t})\n}\n\nfunc TestParseReader(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"Empty []byte\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t_, err := jws.Parse(nil)\n\t\trequire.Error(t, err, \"Parsing an empty byte slice should result in an error\")\n\t})\n\tt.Run(\"Empty bytes.Buffer\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t_, err := jws.ParseReader(&bytes.Buffer{})\n\t\trequire.Error(t, err, \"Parsing an empty buffer should result in an error\")\n\t})\n\tt.Run(\"Compact detached payload\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsplit := strings.Split(exampleCompactSerialization, \".\")\n\t\tincoming := strings.Join([]string{split[0], \"\", split[2]}, \".\")\n\t\t_, err := jws.ParseString(incoming)\n\t\trequire.NoError(t, err, `jws.ParseString should succeed`)\n\t})\n\tt.Run(\"Compact missing header\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tincoming := strings.Join(\n\t\t\t(strings.Split(\n\t\t\t\texampleCompactSerialization,\n\t\t\t\t\".\",\n\t\t\t))[:2],\n\t\t\t\".\",\n\t\t)\n\n\t\tfor _, useReader := range []bool{true, false} {\n\t\t\tvar err error\n\t\t\tif useReader {\n\t\t\t\t// Force ParseReader() to choose un-optimized path by using bufio.NewReader\n\t\t\t\t_, err = jws.ParseReader(bufio.NewReader(strings.NewReader(incoming)))\n\t\t\t} else {\n\t\t\t\t_, err = jws.ParseString(incoming)\n\t\t\t}\n\t\t\trequire.Error(t, err, \"Parsing compact serialization with less than 3 parts should be an error\")\n\t\t}\n\t})\n\tt.Run(\"Compact bad header\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tparts := strings.Split(exampleCompactSerialization, \".\")\n\t\tparts[0] = badValue\n\t\tincoming := strings.Join(parts, \".\")\n\n\t\tfor _, useReader := range []bool{true, false} {\n\t\t\tvar err error\n\t\t\tif useReader {\n\t\t\t\t_, err = jws.ParseReader(bufio.NewReader(strings.NewReader(incoming)))\n\t\t\t} else {\n\t\t\t\t_, err = jws.ParseString(incoming)\n\t\t\t}\n\t\t\trequire.Error(t, err, \"Parsing compact serialization with bad header should be an error\")\n\t\t}\n\t})\n\tt.Run(\"Compact bad payload\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tparts := strings.Split(exampleCompactSerialization, \".\")\n\t\tparts[1] = badValue\n\t\tincoming := strings.Join(parts, \".\")\n\n\t\tfor _, useReader := range []bool{true, false} {\n\t\t\tvar err error\n\t\t\tif useReader {\n\t\t\t\t_, err = jws.ParseReader(bufio.NewReader(strings.NewReader(incoming)))\n\t\t\t} else {\n\t\t\t\t_, err = jws.ParseString(incoming)\n\t\t\t}\n\t\t\trequire.Error(t, err, \"Parsing compact serialization with bad payload should be an error\")\n\t\t}\n\t})\n\tt.Run(\"Compact bad signature\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tparts := strings.Split(exampleCompactSerialization, \".\")\n\t\tparts[2] = badValue\n\t\tincoming := strings.Join(parts, \".\")\n\n\t\tfor _, useReader := range []bool{true, false} {\n\t\t\tvar err error\n\t\t\tif useReader {\n\t\t\t\t_, err = jws.ParseReader(bufio.NewReader(strings.NewReader(incoming)))\n\t\t\t} else {\n\t\t\t\t_, err = jws.ParseString(incoming)\n\t\t\t}\n\t\t\trequire.Error(t, err, \"Parsing compact serialization with bad signature should be an error\")\n\t\t}\n\t})\n}\n\ntype dummyCryptoSigner struct {\n\traw crypto.Signer\n}\n\nfunc (s *dummyCryptoSigner) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error) {\n\treturn s.raw.Sign(rand, digest, opts)\n}\n\nfunc (s *dummyCryptoSigner) Public() crypto.PublicKey {\n\treturn s.raw.Public()\n}\n\nvar _ crypto.Signer = &dummyCryptoSigner{}\n\ntype dummyECDSACryptoSigner struct {\n\traw *ecdsa.PrivateKey\n}\n\nfunc (es *dummyECDSACryptoSigner) Public() crypto.PublicKey {\n\treturn es.raw.Public()\n}\n\nfunc (es *dummyECDSACryptoSigner) Sign(rand io.Reader, digest []byte, _ crypto.SignerOpts) ([]byte, error) {\n\t// The implementation is the same as ecdsaCryptoSigner.\n\t// This is just here to test the interface conversion\n\tr, s, err := ecdsa.Sign(rand, es.raw, digest)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to sign payload using ecdsa: %w`, err)\n\t}\n\n\treturn asn1.Marshal(struct {\n\t\tR *big.Int\n\t\tS *big.Int\n\t}{R: r, S: s})\n}\n\nvar _ crypto.Signer = &dummyECDSACryptoSigner{}\n\nfunc testRoundtrip(t *testing.T, payload []byte, alg jwa.SignatureAlgorithm, signKey interface{}, keys map[string]interface{}) {\n\tjwkKey, err := jwk.FromRaw(signKey)\n\trequire.NoError(t, err, `jwk.New should succeed`)\n\tsignKeys := []struct {\n\t\tName string\n\t\tKey  interface{}\n\t}{\n\t\t{\n\t\t\tName: \"Raw Key\",\n\t\t\tKey:  signKey,\n\t\t},\n\t\t{\n\t\t\tName: \"JWK Key\",\n\t\t\tKey:  jwkKey,\n\t\t},\n\t}\n\n\tif es, ok := signKey.(*ecdsa.PrivateKey); ok {\n\t\tsignKeys = append(signKeys, struct {\n\t\t\tName string\n\t\t\tKey  interface{}\n\t\t}{\n\t\t\tName: \"crypto.Hash\",\n\t\t\tKey:  &dummyECDSACryptoSigner{raw: es},\n\t\t})\n\t} else if cs, ok := signKey.(crypto.Signer); ok {\n\t\tsignKeys = append(signKeys, struct {\n\t\t\tName string\n\t\t\tKey  interface{}\n\t\t}{\n\t\t\tName: \"crypto.Hash\",\n\t\t\tKey:  &dummyCryptoSigner{raw: cs},\n\t\t})\n\t}\n\n\tfor _, key := range signKeys {\n\t\tkey := key\n\t\tt.Run(key.Name, func(t *testing.T) {\n\t\t\tsigned, err := jws.Sign(payload, jws.WithKey(alg, key.Key))\n\t\t\trequire.NoError(t, err, \"jws.Sign should succeed\")\n\n\t\t\tparsers := map[string]func([]byte) (*jws.Message, error){\n\t\t\t\t\"ParseReader(io.Reader)\": func(b []byte) (*jws.Message, error) { return jws.ParseReader(bufio.NewReader(bytes.NewReader(b))) },\n\t\t\t\t\"Parse([]byte)\":          func(b []byte) (*jws.Message, error) { return jws.Parse(b) },\n\t\t\t\t\"ParseString(string)\":    func(b []byte) (*jws.Message, error) { return jws.ParseString(string(b)) },\n\t\t\t}\n\t\t\tfor name, f := range parsers {\n\t\t\t\tname := name\n\t\t\t\tf := f\n\t\t\t\tt.Run(name, func(t *testing.T) {\n\t\t\t\t\tt.Parallel()\n\t\t\t\t\tm, err := f(signed)\n\t\t\t\t\trequire.NoError(t, err, \"(%s) %s is successful\", alg, name)\n\t\t\t\t\trequire.Equal(t, payload, m.Payload(), \"(%s) %s: Payload is decoded\", alg, name)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tfor name, testKey := range keys {\n\t\t\t\tname := name\n\t\t\t\ttestKey := testKey\n\t\t\t\tt.Run(name, func(t *testing.T) {\n\t\t\t\t\tverified, err := jws.Verify(signed, jws.WithKey(alg, testKey))\n\t\t\t\t\trequire.NoError(t, err, \"(%s) Verify is successful\", alg)\n\t\t\t\t\trequire.Equal(t, payload, verified, \"(%s) Verified payload is the same\", alg)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRoundtrip(t *testing.T) {\n\tt.Parallel()\n\tpayload := []byte(\"Lorem ipsum\")\n\n\tt.Run(\"HMAC\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsharedkey := []byte(\"Avracadabra\")\n\t\tjwkKey, _ := jwk.FromRaw(sharedkey)\n\t\tkeys := map[string]interface{}{\n\t\t\t\"[]byte\":  sharedkey,\n\t\t\t\"jwk.Key\": jwkKey,\n\t\t}\n\t\thmacAlgorithms := []jwa.SignatureAlgorithm{jwa.HS256, jwa.HS384, jwa.HS512}\n\t\tfor _, alg := range hmacAlgorithms {\n\t\t\talg := alg\n\t\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttestRoundtrip(t, payload, alg, sharedkey, keys)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"ECDSA\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tkey, err := jwxtest.GenerateEcdsaKey(jwa.P521)\n\t\trequire.NoError(t, err, \"ECDSA key generated\")\n\t\tjwkKey, _ := jwk.FromRaw(key.PublicKey)\n\t\tkeys := map[string]interface{}{\n\t\t\t\"Verify(ecdsa.PublicKey)\":  key.PublicKey,\n\t\t\t\"Verify(*ecdsa.PublicKey)\": &key.PublicKey,\n\t\t\t\"Verify(jwk.Key)\":          jwkKey,\n\t\t}\n\t\tfor _, alg := range []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512} {\n\t\t\talg := alg\n\t\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttestRoundtrip(t, payload, alg, key, keys)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"RSA\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tkey, err := jwxtest.GenerateRsaKey()\n\t\trequire.NoError(t, err, \"RSA key generated\")\n\t\tjwkKey, _ := jwk.FromRaw(key.PublicKey)\n\t\tkeys := map[string]interface{}{\n\t\t\t\"Verify(rsa.PublicKey)\":  key.PublicKey,\n\t\t\t\"Verify(*rsa.PublicKey)\": &key.PublicKey,\n\t\t\t\"Verify(jwk.Key)\":        jwkKey,\n\t\t}\n\t\tfor _, alg := range []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512} {\n\t\t\talg := alg\n\t\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttestRoundtrip(t, payload, alg, key, keys)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"EdDSA\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tkey, err := jwxtest.GenerateEd25519Key()\n\t\trequire.NoError(t, err, \"ed25519 key generated\")\n\t\tpubkey := key.Public()\n\t\tjwkKey, _ := jwk.FromRaw(pubkey)\n\t\tkeys := map[string]interface{}{\n\t\t\t\"Verify(ed25519.Public())\": pubkey,\n\t\t\t// Meh, this doesn't work\n\t\t\t// \"Verify(*ed25519.Public())\": &pubkey,\n\t\t\t\"Verify(jwk.Key)\": jwkKey,\n\t\t}\n\t\tfor _, alg := range []jwa.SignatureAlgorithm{jwa.EdDSA} {\n\t\t\talg := alg\n\t\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttestRoundtrip(t, payload, alg, key, keys)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestSignMulti2(t *testing.T) {\n\tsharedkey := []byte(\"Avracadabra\")\n\tpayload := []byte(\"Lorem ipsum\")\n\thmacAlgorithms := []jwa.SignatureAlgorithm{jwa.HS256, jwa.HS384, jwa.HS512}\n\tvar signed []byte\n\tt.Run(\"Sign\", func(t *testing.T) {\n\t\tvar options = []jws.SignOption{jws.WithJSON()}\n\t\tfor _, alg := range hmacAlgorithms {\n\t\t\toptions = append(options, jws.WithKey(alg, sharedkey)) // (signer, sharedkey, nil, nil))\n\t\t}\n\t\tvar err error\n\t\tsigned, err = jws.Sign(payload, options...)\n\t\trequire.NoError(t, err, `jws.SignMulti should succeed`)\n\t})\n\tfor _, alg := range hmacAlgorithms {\n\t\talg := alg\n\t\tt.Run(\"Verify \"+alg.String(), func(t *testing.T) {\n\t\t\tm := jws.NewMessage()\n\t\t\tverified, err := jws.Verify(signed, jws.WithKey(alg, sharedkey), jws.WithMessage(m))\n\t\t\trequire.NoError(t, err, \"Verify succeeded\")\n\t\t\trequire.Equal(t, payload, verified, \"verified payload matches\")\n\n\t\t\t// XXX This actally doesn't really test much, but if there was anything\n\t\t\t// wrong, the process should have failed well before reaching here\n\t\t\trequire.Equal(t, payload, m.Payload(), \"message payload matches\")\n\t\t})\n\t}\n}\n\nfunc TestEncode(t *testing.T) {\n\tt.Parallel()\n\n\t// HS256Compact tests that https://tools.ietf.org/html/rfc7515#appendix-A.1 works\n\tt.Run(\"HS256Compact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tconst hdr = `{\"typ\":\"JWT\",` + \"\\r\\n\" + ` \"alg\":\"HS256\"}`\n\t\tconst hmacKey = `AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow`\n\t\tconst expected = `eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk`\n\n\t\thmacKeyDecoded, err := base64.DecodeString(hmacKey)\n\t\trequire.NoError(t, err, \"HMAC base64 decoded successful\")\n\n\t\thdrbuf := base64.Encode([]byte(hdr))\n\t\tpayload := base64.Encode([]byte(examplePayload))\n\n\t\tsigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\thdrbuf,\n\t\t\t\tpayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\tsign, err := jws.NewSigner(jwa.HS256)\n\t\trequire.NoError(t, err, \"HMAC signer created successfully\")\n\n\t\tsignature, err := sign.Sign(signingInput, hmacKeyDecoded)\n\t\trequire.NoError(t, err, \"PayloadSign is successful\")\n\t\tsigbuf := base64.Encode(signature)\n\n\t\tencoded := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningInput,\n\t\t\t\tsigbuf,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\t\trequire.Equal(t, expected, string(encoded), \"generated compact serialization should match\")\n\n\t\tmsg, err := jws.ParseReader(bytes.NewReader(encoded))\n\t\trequire.NoError(t, err, \"Parsing compact encoded serialization succeeds\")\n\n\t\tsignatures := msg.Signatures()\n\t\trequire.Len(t, signatures, 1, `there should be exactly one signature`)\n\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.HS256 {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\tv, err := jws.NewVerifier(jwa.HS256)\n\t\trequire.NoError(t, err, \"HmacVerify created\")\n\n\t\trequire.NoError(t, v.Verify(signingInput, signature, hmacKeyDecoded), \"Verify succeeds\")\n\t})\n\tt.Run(\"ES512Compact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t// ES256Compact tests that https://tools.ietf.org/html/rfc7515#appendix-A.3 works\n\t\thdr := []byte{123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 53, 49, 50, 34, 125}\n\t\tconst jwksrc = `{\n\"kty\":\"EC\",\n\"crv\":\"P-521\",\n\"x\":\"AekpBQ8ST8a8VcfVOTNl353vSrDCLLJXmPk06wTjxrrjcBpXp5EOnYG_NjFZ6OvLFV1jSfS9tsz4qUxcWceqwQGk\",\n\"y\":\"ADSmRA43Z1DSNx_RvcLI87cdL07l6jQyyBXMoxVg_l2Th-x3S1WDhjDly79ajL4Kkd0AZMaZmh9ubmf63e3kyMj2\",\n\"d\":\"AY5pb7A0UFiB3RELSD64fTLOSV_jazdF7fLYyuTw8lOfRhWg6Y6rUrPAxerEzgdRhajnu0ferB0d53vM9mE15j2C\"\n}`\n\n\t\t// \"Payload\"\n\t\tjwsPayload := []byte{80, 97, 121, 108, 111, 97, 100}\n\n\t\tstandardHeaders := jws.NewHeaders()\n\t\trequire.NoError(t, json.Unmarshal(hdr, standardHeaders), `parsing headers should succeed`)\n\n\t\talg := standardHeaders.Algorithm()\n\n\t\tjwkKey, err := jwk.ParseKey([]byte(jwksrc))\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to parse JWK\")\n\t\t}\n\t\tvar key interface{}\n\t\trequire.NoError(t, jwkKey.Raw(&key), `jwk.Raw should succeed`)\n\t\tvar jwsCompact []byte\n\t\tjwsCompact, err = jws.Sign(jwsPayload, jws.WithKey(alg, key))\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to sign message\")\n\t\t}\n\n\t\t// Verify with standard ecdsa library\n\t\t_, _, jwsSignature, err := jws.SplitCompact(jwsCompact)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to split compact JWT\")\n\t\t}\n\n\t\tdecodedJwsSignature, err := base64.Decode(jwsSignature)\n\t\trequire.NoError(t, err, `base64.Decode should succeed`)\n\t\tr, s := &big.Int{}, &big.Int{}\n\t\tn := len(decodedJwsSignature) / 2\n\t\tr.SetBytes(decodedJwsSignature[:n])\n\t\ts.SetBytes(decodedJwsSignature[n:])\n\t\tsigningHdr := base64.Encode(hdr)\n\t\tsigningPayload := base64.Encode(jwsPayload)\n\n\t\tjwsSigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningHdr,\n\t\t\t\tsigningPayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\t\thashed512 := sha512.Sum512(jwsSigningInput)\n\t\tecdsaPrivateKey := key.(*ecdsa.PrivateKey)\n\t\trequire.True(t, ecdsa.Verify(&ecdsaPrivateKey.PublicKey, hashed512[:], r, s), \"ecdsa.Verify should succeed\")\n\n\t\t// Verify with API library\n\t\tpublicKey, err := jwk.PublicRawKeyOf(key)\n\t\trequire.NoError(t, err, `jwk.PublicRawKeyOf should succeed`)\n\t\tverifiedPayload, err := jws.Verify(jwsCompact, jws.WithKey(alg, publicKey))\n\t\tif err != nil || string(verifiedPayload) != string(jwsPayload) {\n\t\t\tt.Fatal(\"Failed to verify message\")\n\t\t}\n\t})\n\tt.Run(\"RS256Compact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t// RS256Compact tests that https://tools.ietf.org/html/rfc7515#appendix-A.2 works\n\t\tconst hdr = `{\"alg\":\"RS256\"}`\n\t\tconst expected = `eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw`\n\t\tconst jwksrc = `{\n    \"kty\":\"RSA\",\n    \"n\":\"ofgWCuLjybRlzo0tZWJjNiuSfb4p4fAkd_wWJcyQoTbji9k0l8W26mPddxHmfHQp-Vaw-4qPCJrcS2mJPMEzP1Pt0Bm4d4QlL-yRT-SFd2lZS-pCgNMsD1W_YpRPEwOWvG6b32690r2jZ47soMZo9wGzjb_7OMg0LOL-bSf63kpaSHSXndS5z5rexMdbBYUsLA9e-KXBdQOS-UTo7WTBEMa2R2CapHg665xsmtdVMTBQY4uDZlxvb3qCo5ZwKh9kG4LT6_I5IhlJH7aGhyxXFvUK-DWNmoudF8NAco9_h9iaGNj8q2ethFkMLs91kzk2PAcDTW9gb54h4FRWyuXpoQ\",\n    \"e\":\"AQAB\",\n    \"d\":\"Eq5xpGnNCivDflJsRQBXHx1hdR1k6Ulwe2JZD50LpXyWPEAeP88vLNO97IjlA7_GQ5sLKMgvfTeXZx9SE-7YwVol2NXOoAJe46sui395IW_GO-pWJ1O0BkTGoVEn2bKVRUCgu-GjBVaYLU6f3l9kJfFNS3E0QbVdxzubSu3Mkqzjkn439X0M_V51gfpRLI9JYanrC4D4qAdGcopV_0ZHHzQlBjudU2QvXt4ehNYTCBr6XCLQUShb1juUO1ZdiYoFaFQT5Tw8bGUl_x_jTj3ccPDVZFD9pIuhLhBOneufuBiB4cS98l2SR_RQyGWSeWjnczT0QU91p1DhOVRuOopznQ\",\n    \"p\":\"4BzEEOtIpmVdVEZNCqS7baC4crd0pqnRH_5IB3jw3bcxGn6QLvnEtfdUdiYrqBdss1l58BQ3KhooKeQTa9AB0Hw_Py5PJdTJNPY8cQn7ouZ2KKDcmnPGBY5t7yLc1QlQ5xHdwW1VhvKn-nXqhJTBgIPgtldC-KDV5z-y2XDwGUc\",\n    \"q\":\"uQPEfgmVtjL0Uyyx88GZFF1fOunH3-7cepKmtH4pxhtCoHqpWmT8YAmZxaewHgHAjLYsp1ZSe7zFYHj7C6ul7TjeLQeZD_YwD66t62wDmpe_HlB-TnBA-njbglfIsRLtXlnDzQkv5dTltRJ11BKBBypeeF6689rjcJIDEz9RWdc\",\n    \"dp\":\"BwKfV3Akq5_MFZDFZCnW-wzl-CCo83WoZvnLQwCTeDv8uzluRSnm71I3QCLdhrqE2e9YkxvuxdBfpT_PI7Yz-FOKnu1R6HsJeDCjn12Sk3vmAktV2zb34MCdy7cpdTh_YVr7tss2u6vneTwrA86rZtu5Mbr1C1XsmvkxHQAdYo0\",\n    \"dq\":\"h_96-mK1R_7glhsum81dZxjTnYynPbZpHziZjeeHcXYsXaaMwkOlODsWa7I9xXDoRwbKgB719rrmI2oKr6N3Do9U0ajaHF-NKJnwgjMd2w9cjz3_-kyNlxAr2v4IKhGNpmM5iIgOS1VZnOZ68m6_pbLBSp3nssTdlqvd0tIiTHU\",\n    \"qi\":\"IYd7DHOhrWvxkwPQsRM2tOgrjbcrfvtQJipd-DlcxyVuuM9sQLdgjVk2oy26F0EmpScGLq2MowX7fhd_QJQ3ydy5cY7YIBi87w93IKLEdfnbJtoOPLUW0ITrJReOgo1cq9SbsxYawBgfp_gh6A5603k2-ZQwVK0JKSHuLFkuQ3U\"\n  }`\n\n\t\tprivkey, err := jwk.ParseKey([]byte(jwksrc))\n\t\trequire.NoError(t, err, `parsing jwk should be successful`)\n\n\t\tvar rawkey rsa.PrivateKey\n\t\trequire.NoError(t, privkey.Raw(&rawkey), `obtaining raw key should succeed`)\n\n\t\tsign, err := jws.NewSigner(jwa.RS256)\n\t\trequire.NoError(t, err, \"RsaSign created successfully\")\n\n\t\thdrbuf := base64.Encode([]byte(hdr))\n\t\tpayload := base64.Encode([]byte(examplePayload))\n\t\tsigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\thdrbuf,\n\t\t\t\tpayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\t\tsignature, err := sign.Sign(signingInput, rawkey)\n\t\trequire.NoError(t, err, \"PayloadSign is successful\")\n\t\tsigbuf := base64.Encode(signature)\n\n\t\tencoded := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningInput,\n\t\t\t\tsigbuf,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\trequire.Equal(t, expected, string(encoded), \"generated compact serialization should match\")\n\n\t\tmsg, err := jws.ParseReader(bytes.NewReader(encoded))\n\t\trequire.NoError(t, err, \"Parsing compact encoded serialization succeeds\")\n\n\t\tsignatures := msg.Signatures()\n\t\trequire.Len(t, signatures, 1, `there should be exactly one signature`)\n\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.RS256 {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\tv, err := jws.NewVerifier(jwa.RS256)\n\t\trequire.NoError(t, err, \"Verify created\")\n\t\trequire.NoError(t, v.Verify(signingInput, signature, rawkey.PublicKey), \"Verify succeeds\")\n\t})\n\tt.Run(\"ES256Compact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t// ES256Compact tests that https://tools.ietf.org/html/rfc7515#appendix-A.3 works\n\t\tconst hdr = `{\"alg\":\"ES256\"}`\n\t\tconst jwksrc = `{\n    \"kty\":\"EC\",\n    \"crv\":\"P-256\",\n    \"x\":\"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU\",\n    \"y\":\"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0\",\n    \"d\":\"jpsQnnGQmL-YBIffH1136cspYG6-0iY7X1fCE9-E9LI\"\n  }`\n\t\tprivkey, err := jwk.ParseKey([]byte(jwksrc))\n\t\trequire.NoError(t, err, `parsing jwk should succeed`)\n\n\t\tvar rawkey ecdsa.PrivateKey\n\t\trequire.NoError(t, privkey.Raw(&rawkey), `obtaining raw key should succeed`)\n\n\t\tsigner, err := jws.NewSigner(jwa.ES256)\n\t\trequire.NoError(t, err, \"RsaSign created successfully\")\n\n\t\thdrbuf := base64.Encode([]byte(hdr))\n\t\tpayload := base64.Encode([]byte(examplePayload))\n\t\tsigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\thdrbuf,\n\t\t\t\tpayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\t\tsignature, err := signer.Sign(signingInput, &rawkey)\n\t\trequire.NoError(t, err, \"PayloadSign is successful\")\n\t\tsigbuf := base64.Encode(signature)\n\t\trequire.NoError(t, err, \"base64 encode successful\")\n\n\t\tencoded := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningInput,\n\t\t\t\tsigbuf,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\t// The signature contains random factor, so unfortunately we can't match\n\t\t// the output against a fixed expected outcome. We'll wave doing an\n\t\t// exact match, and just try to verify using the signature\n\n\t\tmsg, err := jws.ParseReader(bytes.NewReader(encoded))\n\t\trequire.NoError(t, err, \"Parsing compact encoded serialization succeeds\")\n\n\t\tsignatures := msg.Signatures()\n\t\trequire.Len(t, signatures, 1, `there should be exactly one signature`)\n\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.ES256 {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\tv, err := jws.NewVerifier(jwa.ES256)\n\t\trequire.NoError(t, err, \"EcdsaVerify created\")\n\t\trequire.NoError(t, v.Verify(signingInput, signature, rawkey.PublicKey), \"Verify succeeds\")\n\t})\n\tt.Run(\"EdDSACompact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t// EdDSACompact tests that https://tools.ietf.org/html/rfc8037#appendix-A.1-5 works\n\t\tconst hdr = `{\"alg\":\"EdDSA\"}`\n\t\tconst jwksrc = `{\n    \"kty\":\"OKP\",\n    \"crv\":\"Ed25519\",\n    \"d\":\"nWGxne_9WmC6hEr0kuwsxERJxWl7MmkZcDusAxyuf2A\",\n    \"x\":\"11qYAYKxCrfVS_7TyWQHOg7hcvPapiMlrwIaaPcHURo\"\n  }`\n\t\tconst examplePayload = `Example of Ed25519 signing`\n\t\tconst expected = `hgyY0il_MGCjP0JzlnLWG1PPOt7-09PGcvMg3AIbQR6dWbhijcNR4ki4iylGjg5BhVsPt9g7sVvpAr_MuM0KAg`\n\t\texpectedDecoded, err := base64.Decode([]byte(expected))\n\t\trequire.NoError(t, err, \"Expected Signature decode successful\")\n\n\t\tprivkey, err := jwk.ParseKey([]byte(jwksrc))\n\t\trequire.NoError(t, err, `parsing jwk should succeed`)\n\n\t\tvar rawkey ed25519.PrivateKey\n\t\trequire.NoError(t, privkey.Raw(&rawkey), `obtaining raw key should succeed`)\n\n\t\tsigner, err := jws.NewSigner(jwa.EdDSA)\n\t\trequire.NoError(t, err, \"EdDSASign created successfully\")\n\n\t\thdrbuf := base64.Encode([]byte(hdr))\n\t\tpayload := base64.Encode([]byte(examplePayload))\n\t\tsigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\thdrbuf,\n\t\t\t\tpayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\tsignature, err := signer.Sign(signingInput, rawkey)\n\t\trequire.NoError(t, err, \"PayloadSign is successful\")\n\t\tsigbuf := base64.Encode(signature)\n\t\tencoded := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningInput,\n\t\t\t\tsigbuf,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\t// The signature contains random factor, so unfortunately we can't match\n\t\t// the output against a fixed expected outcome. We'll wave doing an\n\t\t// exact match, and just try to verify using the signature\n\n\t\tmsg, err := jws.ParseReader(bytes.NewReader(encoded))\n\t\trequire.NoError(t, err, \"Parsing compact encoded serialization succeeds\")\n\n\t\tsignatures := msg.Signatures()\n\t\trequire.Len(t, signatures, 1, `there should be exactly one signature`)\n\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.EdDSA {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\tv, err := jws.NewVerifier(jwa.EdDSA)\n\t\trequire.NoError(t, err, \"EcdsaVerify created\")\n\t\trequire.NoError(t, v.Verify(signingInput, signature, rawkey.Public()), \"Verify succeeds\")\n\t\trequire.Equal(t, signature, expectedDecoded, \"signatures match\")\n\t})\n\tt.Run(\"UnsecuredCompact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ts := `eyJhbGciOiJub25lIn0.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.`\n\n\t\tm, err := jws.ParseReader(strings.NewReader(s))\n\t\trequire.NoError(t, err, \"Parsing compact serialization\")\n\n\t\t{\n\t\t\tv := map[string]interface{}{}\n\t\t\trequire.NoError(t, json.Unmarshal(m.Payload(), &v), \"Unmarshal payload\")\n\t\t\trequire.Equal(t, v[\"iss\"], \"joe\", \"iss matches\")\n\t\t\trequire.Equal(t, int(v[\"exp\"].(float64)), 1300819380, \"exp matches\")\n\t\t\trequire.Equal(t, v[\"http://example.com/is_root\"], true, \"'http://example.com/is_root' matches\")\n\t\t}\n\n\t\trequire.Len(t, m.Signatures(), 1, \"There should be 1 signature\")\n\n\t\tsignatures := m.Signatures()\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.NoSignature {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\trequire.Empty(t, signatures[0].Signature(), \"Signature should be empty\")\n\t})\n\tt.Run(\"CompleteJSON\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ts := `{\n    \"payload\": \"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\",\n    \"signatures\":[\n      {\n        \"header\": {\"kid\":\"2010-12-29\"},\n        \"protected\":\"eyJhbGciOiJSUzI1NiJ9\",\n        \"signature\": \"cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw\"\n      },\n      {\n        \"header\": {\"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"},\n        \"protected\":\"eyJhbGciOiJFUzI1NiJ9\",\n        \"signature\": \"DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q\"\n      }\n    ]\n  }`\n\n\t\tm, err := jws.ParseReader(strings.NewReader(s))\n\t\trequire.NoError(t, err, \"Unmarshal complete json serialization\")\n\t\trequire.Len(t, m.Signatures(), 2, \"There should be 2 signatures\")\n\n\t\tsigs := m.LookupSignature(\"2010-12-29\")\n\t\trequire.Len(t, sigs, 1, \"There should be 1 signature with kid = '2010-12-29'\")\n\t})\n\tt.Run(\"Protected Header lookup\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ts := `{\n    \"payload\": \"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\",\n    \"signatures\":[\n      {\n        \"header\": {\"cty\":\"example\"},\n        \"protected\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6ImU5YmMwOTdhLWNlNTEtNDAzNi05NTYyLWQyYWRlODgyZGIwZCJ9\",\n        \"signature\": \"JcLb1udPAV72TayGv6eawZKlIQQ3K1NzB0fU7wwYoFypGxEczdCQU-V9jp4WwY2ueJKYeE4fF6jigB0PdSKR0Q\"\n      }\n    ]\n  }`\n\n\t\t// Protected Header is {\"alg\":\"ES256\",\"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"}\n\t\t// This protected header combination forces the parser/unmarshal to go trough the code path to populate and look for protected header fields.\n\t\t// The signature is valid.\n\n\t\tm, err := jws.ParseReader(strings.NewReader(s))\n\t\trequire.NoError(t, err, \"Unmarshal complete json serialization\")\n\t\trequire.Len(t, m.Signatures(), 1, \"There should be 1 signature\")\n\n\t\tsigs := m.LookupSignature(\"e9bc097a-ce51-4036-9562-d2ade882db0d\")\n\t\trequire.Len(t, sigs, 1, \"There should be 1 signature with kid = '2010-12-29'\")\n\t})\n\tt.Run(\"FlattenedJSON\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ts := `{\n    \"payload\": \"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\",\n    \"protected\":\"eyJhbGciOiJFUzI1NiJ9\",\n    \"header\": {\n      \"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"\n    },\n    \"signature\": \"DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q\"\n  }`\n\n\t\tm, err := jws.ParseReader(strings.NewReader(s))\n\t\trequire.NoError(t, err, \"Parsing flattened json serialization\")\n\t\trequire.Len(t, m.Signatures(), 1, \"There should be 1 signature\")\n\n\t\tjsonbuf, _ := json.MarshalIndent(m, \"\", \"  \")\n\t\tt.Logf(\"%s\", jsonbuf)\n\t})\n\tt.Run(\"SplitCompact\", func(t *testing.T) {\n\t\ttestcases := []struct {\n\t\t\tName string\n\t\t\tSize int\n\t\t}{\n\t\t\t{Name: \"Short\", Size: 100},\n\t\t\t{Name: \"Long\", Size: 8000},\n\t\t}\n\t\tfor _, tc := range testcases {\n\t\t\tsize := tc.Size\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\t// Create payload with X.Y.Z\n\t\t\t\tvar payload []byte\n\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\tpayload = append(payload, 'X')\n\t\t\t\t}\n\t\t\t\tpayload = append(payload, '.')\n\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\tpayload = append(payload, 'Y')\n\t\t\t\t}\n\t\t\t\tpayload = append(payload, '.')\n\n\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\tpayload = append(payload, 'Y')\n\t\t\t\t}\n\n\t\t\t\t// Test using bytes, reader optimized and non-optimized path\n\t\t\t\tfor _, method := range []int{0, 1, 2} {\n\t\t\t\t\tvar x, y, z []byte\n\t\t\t\t\tvar err error\n\t\t\t\t\tswitch method {\n\t\t\t\t\tcase 0: // bytes\n\t\t\t\t\t\tx, y, z, err = jws.SplitCompact(payload)\n\t\t\t\t\tcase 1: // un-optimized io.Reader\n\t\t\t\t\t\tx, y, z, err = jws.SplitCompactReader(bytes.NewReader(payload))\n\t\t\t\t\tdefault: // optimized io.Reader\n\t\t\t\t\t\tx, y, z, err = jws.SplitCompactReader(bufio.NewReader(bytes.NewReader(payload)))\n\t\t\t\t\t}\n\t\t\t\t\trequire.NoError(t, err, \"SplitCompact should succeed\")\n\t\t\t\t\trequire.Len(t, x, size, \"Length of header\")\n\t\t\t\t\trequire.Len(t, y, size, \"Length of payload\")\n\t\t\t\t\trequire.Len(t, z, size, \"Length of signature\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestPublicHeaders(t *testing.T) {\n\tkey, err := jwxtest.GenerateRsaKey()\n\trequire.NoError(t, err, \"GenerateKey should succeed\")\n\n\tsigner, err := jws.NewSigner(jwa.RS256)\n\trequire.NoError(t, err, \"jws.NewSigner should succeed\")\n\t_ = signer // TODO\n\n\tpubkey := key.PublicKey\n\tpubjwk, err := jwk.FromRaw(&pubkey)\n\trequire.NoError(t, err, \"NewRsaPublicKey should succeed\")\n\t_ = pubjwk // TODO\n}\n\nfunc TestDecode_ES384Compact_NoSigTrim(t *testing.T) {\n\tincoming := \"eyJhbGciOiJFUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6IjE5MzFmZTQ0YmFhMWNhZTkyZWUzNzYzOTQ0MDU1OGMwODdlMTRlNjk5ZWU5NjVhM2Q1OGU1MmU2NGY4MDE0NWIifQ.eyJpc3MiOiJicmt0LWNsaS0xLjAuN3ByZTEiLCJpYXQiOjE0ODQ2OTU1MjAsImp0aSI6IjgxYjczY2Y3In0.DdFi0KmPHSv4PfIMGcWGMSRLmZsfRPQ3muLFW6Ly2HpiLFFQWZ0VEanyrFV263wjlp3udfedgw_vrBLz3XC8CkbvCo_xeHMzaTr_yfhjoheSj8gWRLwB-22rOnUX_M0A\"\n\tt.Logf(\"incoming = '%s'\", incoming)\n\tconst jwksrc = `{\n    \"kty\":\"EC\",\n    \"crv\":\"P-384\",\n    \"x\":\"YHVZ4gc1RDoqxKm4NzaN_Y1r7R7h3RM3JMteC478apSKUiLVb4UNytqWaLoE6ygH\",\n    \"y\":\"CRKSqP-aYTIsqJfg_wZEEYUayUR5JhZaS2m4NLk2t1DfXZgfApAJ2lBO0vWKnUMp\"\n  }`\n\n\tpubkey, err := jwk.ParseKey([]byte(jwksrc))\n\trequire.NoError(t, err, `parsing jwk should be successful`)\n\n\tvar rawkey ecdsa.PublicKey\n\trequire.NoError(t, pubkey.Raw(&rawkey), `obtaining raw key should succeed`)\n\n\tv, err := jws.NewVerifier(jwa.ES384)\n\trequire.NoError(t, err, \"EcdsaVerify created\")\n\n\tprotected, payload, signature, err := jws.SplitCompact([]byte(incoming))\n\trequire.NoError(t, err, `jws.SplitCompact should succeed`)\n\n\tvar buf bytes.Buffer\n\tbuf.Write(protected)\n\tbuf.WriteByte('.')\n\tbuf.Write(payload)\n\n\tdecodedSignature, err := base64.Decode(signature)\n\trequire.NoError(t, err, `decoding signature should succeed`)\n\trequire.NoError(t, v.Verify(buf.Bytes(), decodedSignature, rawkey), \"Verify succeeds\")\n}\n\nfunc TestReadFile(t *testing.T) {\n\tt.Parallel()\n\n\tf, err := os.CreateTemp(\"\", \"test-read-file-*.jws\")\n\trequire.NoError(t, err, `io.CreateTemp should succeed`)\n\tdefer f.Close()\n\n\tfmt.Fprintf(f, \"%s\", exampleCompactSerialization)\n\n\tif _, err := jws.ReadFile(f.Name()); !assert.NoError(t, err, `jws.ReadFile should succeed`) {\n\t\treturn\n\t}\n}\n\nfunc TestVerifyNonUniqueKid(t *testing.T) {\n\tconst payload = \"Lorem ipsum\"\n\tconst kid = \"notUniqueKid\"\n\tprivateKey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, \"jwxtest.GenerateJwk should succeed\")\n\t_ = privateKey.Set(jwk.KeyIDKey, kid)\n\tsigned, err := jws.Sign([]byte(payload), jws.WithKey(jwa.RS256, privateKey))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\tcorrectKey, _ := jwk.PublicKeyOf(privateKey)\n\t_ = correctKey.Set(jwk.AlgorithmKey, jwa.RS256)\n\n\tmakeSet := func(keys ...jwk.Key) jwk.Set {\n\t\tset := jwk.NewSet()\n\t\tfor _, key := range keys {\n\t\t\t_ = set.AddKey(key)\n\t\t}\n\t\treturn set\n\t}\n\n\ttestcases := []struct {\n\t\tName string\n\t\tKey  func() jwk.Key // Generates the \"wrong\" key\n\t}{\n\t\t{\n\t\t\tName: `match 2 keys via same \"kid\"`,\n\t\t\tKey: func() jwk.Key {\n\t\t\t\tprivateKey, _ := jwxtest.GenerateRsaJwk()\n\t\t\t\twrongKey, _ := jwk.PublicKeyOf(privateKey)\n\t\t\t\t_ = wrongKey.Set(jwk.KeyIDKey, kid)\n\t\t\t\t_ = wrongKey.Set(jwk.AlgorithmKey, jwa.RS256)\n\t\t\t\treturn wrongKey\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: `match 2 keys via same \"kid\", same key value but different alg`,\n\t\t\tKey: func() jwk.Key {\n\t\t\t\twrongKey, _ := correctKey.Clone()\n\t\t\t\t_ = wrongKey.Set(jwk.KeyIDKey, kid)\n\t\t\t\t_ = wrongKey.Set(jwk.AlgorithmKey, jwa.RS512)\n\t\t\t\treturn wrongKey\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: `match 2 keys via same \"kid\", same key type but different alg`,\n\t\t\tKey: func() jwk.Key {\n\t\t\t\tprivateKey, _ := jwxtest.GenerateRsaJwk()\n\t\t\t\twrongKey, _ := jwk.PublicKeyOf(privateKey)\n\t\t\t\t_ = wrongKey.Set(jwk.KeyIDKey, kid)\n\t\t\t\t_ = wrongKey.Set(jwk.AlgorithmKey, jwa.RS512)\n\t\t\t\treturn wrongKey\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: `match 2 keys via same \"kid\" and different key type / alg`,\n\t\t\tKey: func() jwk.Key {\n\t\t\t\tprivateKey, _ := jwxtest.GenerateEcdsaKey(jwa.P256)\n\t\t\t\twrongKey, err := jwk.PublicKeyOf(privateKey)\n\t\t\t\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\t\t\t\t_ = wrongKey.Set(jwk.KeyIDKey, kid)\n\t\t\t\t_ = wrongKey.Set(jwk.AlgorithmKey, jwa.ES256K)\n\t\t\t\treturn wrongKey\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\twrongKey, err := tc.Key().Clone()\n\t\trequire.NoError(t, err, `cloning wrong key should succeed`)\n\t\tfor _, set := range []jwk.Set{makeSet(wrongKey, correctKey), makeSet(correctKey, wrongKey)} {\n\t\t\tset := set\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\t// Try matching in different orders\n\t\t\t\tvar usedKey jwk.Key\n\t\t\t\t_, err = jws.Verify(signed, jws.WithKeySet(set, jws.WithMultipleKeysPerKeyID(true)), jws.WithKeyUsed(&usedKey))\n\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\trequire.Equal(t, usedKey, correctKey)\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestVerifySet(t *testing.T) {\n\tt.Parallel()\n\tconst payload = \"Lorem ipsum\"\n\n\tmakeSet := func(privkey jwk.Key) jwk.Set {\n\t\tset := jwk.NewSet()\n\t\tk1, _ := jwk.FromRaw([]byte(\"abracadabra\"))\n\t\tset.AddKey(k1)\n\t\tk2, _ := jwk.FromRaw([]byte(\"opensesame\"))\n\t\tset.AddKey(k2)\n\t\tpubkey, _ := jwk.PublicKeyOf(privkey)\n\t\tpubkey.Set(jwk.AlgorithmKey, jwa.RS256)\n\t\tset.AddKey(pubkey)\n\t\treturn set\n\t}\n\n\tfor _, useJSON := range []bool{true, false} {\n\t\tuseJSON := useJSON\n\t\tt.Run(fmt.Sprintf(\"useJSON=%t\", useJSON), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tt.Run(`match via \"alg\"`, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\tkey, err := jwxtest.GenerateRsaJwk()\n\t\t\t\trequire.NoError(t, err, \"jwxtest.GenerateJwk should succeed\")\n\n\t\t\t\tset := makeSet(key)\n\t\t\t\tsigned, err := jws.Sign([]byte(payload), jws.WithKey(jwa.RS256, key))\n\t\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\t\t\t\tif useJSON {\n\t\t\t\t\tm, err := jws.Parse(signed)\n\t\t\t\t\trequire.NoError(t, err, `jws.Parse should succeed`)\n\t\t\t\t\tsigned, err = json.Marshal(m)\n\t\t\t\t\trequire.NoError(t, err, `json.Marshal should succeed`)\n\t\t\t\t}\n\n\t\t\t\tvar used jwk.Key\n\t\t\t\tverified, err := jws.Verify(signed, jws.WithKeySet(set, jws.WithRequireKid(false)), jws.WithKeyUsed(&used))\n\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\trequire.Equal(t, []byte(payload), verified, `payload should match`)\n\t\t\t\texpected, _ := jwk.PublicKeyOf(key)\n\t\t\t\tthumb1, _ := expected.Thumbprint(crypto.SHA1)\n\t\t\t\tthumb2, _ := used.Thumbprint(crypto.SHA1)\n\t\t\t\trequire.Equal(t, thumb1, thumb2, `keys should match`)\n\t\t\t})\n\t\t\tt.Run(`match via \"kid\"`, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tkey, err := jwxtest.GenerateRsaJwk()\n\t\t\t\trequire.NoError(t, err, \"jwxtest.GenerateJwk should succeed\")\n\t\t\t\tkey.Set(jwk.KeyIDKey, `mykey`)\n\n\t\t\t\tset := makeSet(key)\n\t\t\t\tsigned, err := jws.Sign([]byte(payload), jws.WithKey(jwa.RS256, key))\n\t\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\t\t\t\tif useJSON {\n\t\t\t\t\tm, err := jws.Parse(signed)\n\t\t\t\t\trequire.NoError(t, err, `jws.Parse should succeed`)\n\t\t\t\t\tsigned, err = json.Marshal(m)\n\t\t\t\t\trequire.NoError(t, err, `json.Marshal should succeed`)\n\t\t\t\t}\n\n\t\t\t\tvar used jwk.Key\n\t\t\t\tverified, err := jws.Verify(signed, jws.WithKeySet(set), jws.WithKeyUsed(&used))\n\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\trequire.Equal(t, []byte(payload), verified, `payload should match`)\n\t\t\t\texpected, _ := jwk.PublicKeyOf(key)\n\t\t\t\tthumb1, _ := expected.Thumbprint(crypto.SHA1)\n\t\t\t\tthumb2, _ := used.Thumbprint(crypto.SHA1)\n\t\t\t\trequire.Equal(t, thumb1, thumb2, `keys should match`)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestCustomField(t *testing.T) {\n\t// XXX has global effect!!!\n\tjws.RegisterCustomField(`x-birthday`, time.Time{})\n\tdefer jws.RegisterCustomField(`x-birthday`, nil)\n\n\texpected := time.Date(2015, 11, 4, 5, 12, 52, 0, time.UTC)\n\tbdaybytes, _ := expected.MarshalText() // RFC3339\n\n\tpayload := \"Hello, World!\"\n\tprivkey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk() should succeed`)\n\n\thdrs := jws.NewHeaders()\n\thdrs.Set(`x-birthday`, string(bdaybytes))\n\n\tsigned, err := jws.Sign([]byte(payload), jws.WithKey(jwa.RS256, privkey, jws.WithProtectedHeaders(hdrs)))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\tt.Run(\"jws.Parse + json.Unmarshal\", func(t *testing.T) {\n\t\tmsg, err := jws.Parse(signed)\n\t\trequire.NoError(t, err, `jws.Parse should succeed`)\n\n\t\tv, ok := msg.Signatures()[0].ProtectedHeaders().Get(`x-birthday`)\n\t\trequire.True(t, ok, `msg.Signatures()[0].ProtectedHeaders().Get(\"x-birthday\") should succeed`)\n\t\trequire.Equal(t, expected, v, `values should match`)\n\n\t\t// Create JSON from jws.Message\n\t\tbuf, err := json.Marshal(msg)\n\t\trequire.NoError(t, err, `json.Marshal should succeed`)\n\n\t\tvar msg2 jws.Message\n\t\trequire.NoError(t, json.Unmarshal(buf, &msg2), `json.Unmarshal should succeed`)\n\n\t\tv, ok = msg2.Signatures()[0].ProtectedHeaders().Get(`x-birthday`)\n\t\trequire.True(t, ok, `msg2.Signatures()[0].ProtectedHeaders().Get(\"x-birthday\") should succeed`)\n\t\trequire.Equal(t, expected, v, `values should match`)\n\t})\n}\n\nfunc TestWithMessage(t *testing.T) {\n\tkey, err := jwxtest.GenerateRsaKey()\n\trequire.NoError(t, err, \"jwxtest.Generate should succeed\")\n\n\tconst text = \"hello, world\"\n\tsigned, err := jws.Sign([]byte(text), jws.WithKey(jwa.RS256, key))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\tm := jws.NewMessage()\n\tpayload, err := jws.Verify(signed, jws.WithKey(jwa.RS256, key.PublicKey), jws.WithMessage(m))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, payload, []byte(text), `jws.Verify should produce the correct payload`)\n\n\tparsed, err := jws.Parse(signed)\n\trequire.NoError(t, err, `jws.Parse should succeed`)\n\n\t// The result of using jws.WithMessage should match the result of jws.Parse\n\tbuf1, _ := json.Marshal(m)\n\tbuf2, _ := json.Marshal(parsed)\n\n\trequire.Equal(t, buf1, buf2, `result of jws.PArse and jws.Verify(..., jws.WithMessage()) should match`)\n}\n\nfunc TestRFC7797(t *testing.T) {\n\tconst keysrc = `{\"kty\":\"oct\",\n      \"k\":\"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow\"\n     }`\n\n\tkey, err := jwk.ParseKey([]byte(keysrc))\n\trequire.NoError(t, err, `jwk.Parse should succeed`)\n\n\tt.Run(\"Invalid payload when b64 = false and NOT detached\", func(t *testing.T) {\n\t\tconst payload = `$.02`\n\t\thdrs := jws.NewHeaders()\n\t\thdrs.Set(\"b64\", false)\n\t\thdrs.Set(\"crit\", \"b64\")\n\n\t\t_, err := jws.Sign([]byte(payload), jws.WithKey(jwa.HS256, key, jws.WithProtectedHeaders(hdrs)))\n\t\trequire.Error(t, err, `jws.Sign should fail`)\n\t})\n\tt.Run(\"Invalid usage when b64 = false and NOT detached\", func(t *testing.T) {\n\t\tconst payload = `$.02`\n\t\thdrs := jws.NewHeaders()\n\t\thdrs.Set(\"b64\", false)\n\t\thdrs.Set(\"crit\", \"b64\")\n\n\t\t_, err := jws.Sign([]byte(payload), jws.WithKey(jwa.HS256, key, jws.WithProtectedHeaders(hdrs)), jws.WithDetachedPayload([]byte(payload)))\n\t\trequire.Error(t, err, `jws.Sign should fail`)\n\t})\n\tt.Run(\"Valid payload when b64 = false\", func(t *testing.T) {\n\t\ttestcases := []struct {\n\t\t\tName     string\n\t\t\tPayload  []byte\n\t\t\tDetached bool\n\t\t}{\n\t\t\t{\n\t\t\t\tName:     `(Detached) payload contains a period`,\n\t\t\t\tPayload:  []byte(`$.02`),\n\t\t\t\tDetached: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    `(NOT detached) payload does not contain a period`,\n\t\t\t\tPayload: []byte(`hell0w0rld`),\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testcases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\thdrs := jws.NewHeaders()\n\t\t\t\thdrs.Set(\"b64\", false)\n\t\t\t\thdrs.Set(\"crit\", \"b64\")\n\n\t\t\t\tpayload := tc.Payload\n\t\t\t\tsignOptions := []jws.SignOption{jws.WithKey(jwa.HS256, key, jws.WithProtectedHeaders(hdrs))}\n\t\t\t\tvar verifyOptions []jws.VerifyOption\n\t\t\t\tverifyOptions = append(verifyOptions, jws.WithKey(jwa.HS256, key))\n\t\t\t\tif tc.Detached {\n\t\t\t\t\tsignOptions = append(signOptions, jws.WithDetachedPayload(payload))\n\t\t\t\t\tverifyOptions = append(verifyOptions, jws.WithDetachedPayload(payload))\n\t\t\t\t\tpayload = nil\n\t\t\t\t}\n\t\t\t\tsigned, err := jws.Sign(payload, signOptions...)\n\t\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t\t\t\tverified, err := jws.Verify(signed, verifyOptions...)\n\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\trequire.Equal(t, tc.Payload, verified, `payload should match`)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"Verify\", func(t *testing.T) {\n\t\tdetached := []byte(`$.02`)\n\t\ttestcases := []struct {\n\t\t\tName          string\n\t\t\tInput         []byte\n\t\t\tVerifyOptions []jws.VerifyOption\n\t\t\tError         bool\n\t\t}{\n\t\t\t{\n\t\t\t\tName: \"JSON format\",\n\t\t\t\tInput: []byte(`{\n      \"protected\": \"eyJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19\",\n      \"payload\": \"$.02\",\n      \"signature\": \"A5dxf2s96_n5FLueVuW1Z_vh161FwXZC4YLPff6dmDY\"\n     }`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"JSON format (detached payload)\",\n\t\t\t\tVerifyOptions: []jws.VerifyOption{\n\t\t\t\t\tjws.WithDetachedPayload(detached),\n\t\t\t\t},\n\t\t\t\tInput: []byte(`{\n      \"protected\": \"eyJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19\",\n      \"signature\": \"A5dxf2s96_n5FLueVuW1Z_vh161FwXZC4YLPff6dmDY\"\n     }`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"JSON Format (b64 does not match)\",\n\t\t\t\tError: true,\n\t\t\t\tInput: []byte(`{\n\t\t\t\t\t\"signatures\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"protected\": \"eyJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19\",\n\t\t\t\t            \"signature\": \"A5dxf2s96_n5FLueVuW1Z_vh161FwXZC4YLPff6dmDY\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"protected\": \"eyJhbGciOiJIUzI1NiIsImI2NCI6dHJ1ZSwiY3JpdCI6WyJiNjQiXX0\", \n\t\t\t\t\t\t\t\"signature\": \"6BjugbC8MfrT_yy5WxWVFZrEHVPDtpdsV9u-wbzQDV8\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"payload\":\"$.02\"\n\t\t\t\t}`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"Compact (detached payload)\",\n\t\t\t\tInput: []byte(`eyJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..A5dxf2s96_n5FLueVuW1Z_vh161FwXZC4YLPff6dmDY`),\n\t\t\t\tVerifyOptions: []jws.VerifyOption{\n\t\t\t\t\tjws.WithDetachedPayload(detached),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testcases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\toptions := tc.VerifyOptions\n\t\t\t\toptions = append(options, jws.WithKey(jwa.HS256, key))\n\t\t\t\tpayload, err := jws.Verify(tc.Input, options...)\n\t\t\t\tif tc.Error {\n\t\t\t\t\trequire.Error(t, err, `jws.Verify should fail`)\n\t\t\t\t\trequire.False(t, jws.IsVerificationError(err), `jws.IsVerifyError should return false`)\n\t\t\t\t} else {\n\t\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\t\trequire.Equal(t, detached, payload, `payload should match`)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestGH485(t *testing.T) {\n\tconst payload = `eyJhIjoiYiJ9`\n\tconst protected = `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImNyaXQiOlsiZXhwIl0sImV4cCI6MCwiaXNzIjoiZm9vIiwibmJmIjowLCJpYXQiOjB9`\n\tconst signature = `qM0CdRcyR4hw03J2ThJDat3Af40U87wVCF3Tp3xsyOg`\n\tconst expected = `{\"a\":\"b\"}`\n\tsigned := fmt.Sprintf(`{\n    \"payload\": %q,\n    \"signatures\": [{\"protected\": %q, \"signature\": %q}]\n}`, payload, protected, signature)\n\n\tverified, err := jws.Verify([]byte(signed), jws.WithKey(jwa.HS256, []byte(\"secret\")))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, expected, string(verified), `verified payload should match`)\n\n\tcompact := strings.Join([]string{protected, payload, signature}, \".\")\n\tverified, err = jws.Verify([]byte(compact), jws.WithKey(jwa.HS256, []byte(\"secret\")))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, expected, string(verified), `verified payload should match`)\n}\n\nfunc TestJKU(t *testing.T) {\n\tkey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\n\tkey.Set(jwk.KeyIDKey, `my-awesome-key`)\n\n\tpubkey, err := jwk.PublicKeyOf(key)\n\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\tset := jwk.NewSet()\n\tset.AddKey(pubkey)\n\tsrv := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tjson.NewEncoder(w).Encode(set)\n\t}))\n\tdefer srv.Close()\n\n\tpayload := []byte(\"Lorem Ipsum\")\n\n\tt.Run(\"Compact\", func(t *testing.T) {\n\t\ttestcases := []struct {\n\t\t\tName         string\n\t\t\tError        bool\n\t\t\tQuery        string\n\t\t\tFetcher      func() jwk.Fetcher\n\t\t\tFetchOptions func() []jwk.FetchOption\n\t\t}{\n\t\t\t{\n\t\t\t\tName:  \"Fail without whitelist\",\n\t\t\t\tError: true,\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\treturn []jwk.FetchOption{jwk.WithHTTPClient(srv.Client())}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Success\",\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\treturn []jwk.FetchOption{\n\t\t\t\t\t\tjwk.WithFetchWhitelist(jwk.InsecureWhitelist{}),\n\t\t\t\t\t\tjwk.WithHTTPClient(srv.Client()),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"Rejected by whitelist\",\n\t\t\t\tError: true,\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\twl := jwk.NewMapWhitelist().Add(`https://github.com/lestrrat-go/jwx/v2`)\n\t\t\t\t\treturn []jwk.FetchOption{\n\t\t\t\t\t\tjwk.WithFetchWhitelist(wl),\n\t\t\t\t\t\tjwk.WithHTTPClient(srv.Client()),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"JWKFetcher\",\n\t\t\t\tFetcher: func() jwk.Fetcher {\n\t\t\t\t\tc := jwk.NewCache(context.TODO())\n\t\t\t\t\treturn jwk.FetchFunc(func(ctx context.Context, u string, options ...jwk.FetchOption) (jwk.Set, error) {\n\t\t\t\t\t\tvar cacheopts []jwk.RegisterOption\n\t\t\t\t\t\tfor _, option := range options {\n\t\t\t\t\t\t\tcacheopts = append(cacheopts, option)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcacheopts = append(cacheopts, jwk.WithHTTPClient(srv.Client()))\n\t\t\t\t\t\tcacheopts = append(cacheopts, jwk.WithFetchWhitelist(httprc.InsecureWhitelist{}))\n\t\t\t\t\t\tc.Register(u, cacheopts...)\n\n\t\t\t\t\t\treturn c.Get(ctx, u)\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testcases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\thdr := jws.NewHeaders()\n\t\t\t\tu := srv.URL\n\t\t\t\tif tc.Query != \"\" {\n\t\t\t\t\tu += \"?\" + tc.Query\n\t\t\t\t}\n\t\t\t\thdr.Set(jws.JWKSetURLKey, u)\n\t\t\t\tsigned, err := jws.Sign(payload, jws.WithKey(jwa.RS256, key, jws.WithProtectedHeaders(hdr)))\n\t\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t\t\t\tvar options []jwk.FetchOption\n\t\t\t\tif f := tc.FetchOptions; f != nil {\n\t\t\t\t\toptions = append(options, f()...)\n\t\t\t\t}\n\n\t\t\t\tvar fetcher jwk.Fetcher\n\t\t\t\tif f := tc.Fetcher; f != nil {\n\t\t\t\t\tfetcher = f()\n\t\t\t\t}\n\t\t\t\tdecoded, err := jws.Verify(signed, jws.WithVerifyAuto(fetcher, options...))\n\t\t\t\tif tc.Error {\n\t\t\t\t\trequire.Error(t, err, `jws.Verify should fail`)\n\t\t\t\t} else {\n\t\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\t\trequire.Equal(t, payload, decoded, `decoded payload should match`)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"JSON\", func(t *testing.T) {\n\t\t// scenario: create a JSON message, which contains 3 signature entries.\n\t\t// 1st and 3rd signatures are valid, but signed using keys that are not\n\t\t// present in the JWKS.\n\t\t// Only the second signature uses a key found in the JWKS\n\t\tvar keys []jwk.Key\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tkey, err := jwxtest.GenerateRsaJwk()\n\t\t\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\t\t\tkey.Set(jwk.KeyIDKey, fmt.Sprintf(`used-%d`, i))\n\t\t\tkeys = append(keys, key)\n\t\t}\n\n\t\tvar unusedKeys []jwk.Key\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tkey, err := jwxtest.GenerateRsaJwk()\n\t\t\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\t\t\tkey.Set(jwk.KeyIDKey, fmt.Sprintf(`unused-%d`, i))\n\t\t\tunusedKeys = append(unusedKeys, key)\n\t\t}\n\n\t\t// The set should contain unused key, used key, and unused key.\n\t\t// ...but they need to be public keys\n\t\tset := jwk.NewSet()\n\t\tfor _, key := range []jwk.Key{unusedKeys[0], keys[1], unusedKeys[1]} {\n\t\t\tpubkey, err := jwk.PublicKeyOf(key)\n\t\t\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\t\t\trequire.Equal(t, pubkey.KeyID(), key.KeyID(), `key ID should be populated`)\n\t\t\tset.AddKey(pubkey)\n\t\t}\n\t\tsrv := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tjson.NewEncoder(w).Encode(set)\n\t\t}))\n\t\tdefer srv.Close()\n\n\t\t// Sign the payload using the three keys\n\t\tvar signOptions = []jws.SignOption{jws.WithJSON()}\n\t\tfor _, key := range keys {\n\t\t\thdr := jws.NewHeaders()\n\t\t\thdr.Set(jws.JWKSetURLKey, srv.URL)\n\t\t\tsignOptions = append(signOptions, jws.WithKey(jwa.RS256, key, jws.WithProtectedHeaders(hdr)))\n\t\t}\n\n\t\tsigned, err := jws.Sign(payload, signOptions...)\n\t\trequire.NoError(t, err, `jws.SignMulti should succeed`)\n\n\t\ttestcases := []struct {\n\t\t\tName         string\n\t\t\tFetchOptions func() []jwk.FetchOption\n\t\t\tError        bool\n\t\t}{\n\t\t\t{\n\t\t\t\tName:  \"Fail without whitelist\",\n\t\t\t\tError: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Success\",\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\treturn []jwk.FetchOption{\n\t\t\t\t\t\tjwk.WithFetchWhitelist(jwk.InsecureWhitelist{}),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"Rejected by whitelist\",\n\t\t\t\tError: true,\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\twl := jwk.NewMapWhitelist().Add(`https://github.com/lestrrat-go/jwx/v2`)\n\t\t\t\t\treturn []jwk.FetchOption{\n\t\t\t\t\t\tjwk.WithFetchWhitelist(wl),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testcases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\tm := jws.NewMessage()\n\t\t\t\tvar options []jwk.FetchOption\n\t\t\t\tif fn := tc.FetchOptions; fn != nil {\n\t\t\t\t\toptions = fn()\n\t\t\t\t}\n\t\t\t\toptions = append(options, jwk.WithHTTPClient(srv.Client()))\n\n\t\t\t\tdecoded, err := jws.Verify(signed, jws.WithVerifyAuto(nil, options...), jws.WithMessage(m))\n\t\t\t\tif tc.Error {\n\t\t\t\t\trequire.Error(t, err, `jws.Verify should fail`)\n\t\t\t\t} else {\n\t\t\t\t\tif !assert.NoError(t, err, `jws.Verify should succeed`) {\n\t\t\t\t\t\tset, _ := jwk.Fetch(context.Background(), srv.URL, options...)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbuf, _ := json.MarshalIndent(set, \"\", \"  \")\n\t\t\t\t\t\t\tt.Logf(\"%s\", buf)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\trequire.Equal(t, payload, decoded, `decoded payload should match`)\n\t\t\t\t\t// XXX This actally doesn't really test much, but if there was anything\n\t\t\t\t\t// wrong, the process should have failed well before reaching here\n\t\t\t\t\trequire.Equal(t, payload, m.Payload(), \"message payload matches\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestAlgorithmsForKey(t *testing.T) {\n\trsaprivkey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaPrivateKey should succeed`)\n\trsapubkey, err := rsaprivkey.PublicKey()\n\trequire.NoError(t, err, `jwk (RSA) PublicKey() should succeed`)\n\n\tecdsaprivkey, err := jwxtest.GenerateEcdsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateEcdsaPrivateKey should succeed`)\n\tecdsapubkey, err := ecdsaprivkey.PublicKey()\n\trequire.NoError(t, err, `jwk (ECDSA) PublicKey() should succeed`)\n\n\ttestcases := []struct {\n\t\tName     string\n\t\tKey      interface{}\n\t\tExpected []jwa.SignatureAlgorithm\n\t}{\n\t\t{\n\t\t\tName:     \"Octet sequence\",\n\t\t\tKey:      []byte(\"hello\"),\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.HS256, jwa.HS384, jwa.HS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"rsa.PublicKey\",\n\t\t\tKey:      rsa.PublicKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"*rsa.PublicKey\",\n\t\t\tKey:      &rsa.PublicKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"jwk.RSAPublicKey\",\n\t\t\tKey:      rsapubkey,\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"ecdsa.PublicKey\",\n\t\t\tKey:      ecdsa.PublicKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"*ecdsa.PublicKey\",\n\t\t\tKey:      &ecdsa.PublicKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"jwk.ECDSAPublicKey\",\n\t\t\tKey:      ecdsapubkey,\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"rsa.PrivateKey\",\n\t\t\tKey:      rsa.PrivateKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"*rsa.PrivateKey\",\n\t\t\tKey:      &rsa.PrivateKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"jwk.RSAPrivateKey\",\n\t\t\tKey:      rsapubkey,\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"ecdsa.PrivateKey\",\n\t\t\tKey:      ecdsa.PrivateKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"*ecdsa.PrivateKey\",\n\t\t\tKey:      &ecdsa.PrivateKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"jwk.ECDSAPrivateKey\",\n\t\t\tKey:      ecdsaprivkey,\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"ed25519.PublicKey\",\n\t\t\tKey:      ed25519.PublicKey(nil),\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.EdDSA},\n\t\t},\n\t\t{\n\t\t\tName:     \"x25519.PublicKey\",\n\t\t\tKey:      x25519.PublicKey(nil),\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.EdDSA},\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\n\t\tif hasES256K {\n\t\t\tif strings.Contains(strings.ToLower(tc.Name), `ecdsa`) {\n\t\t\t\ttc.Expected = append(tc.Expected, jwa.ES256K)\n\t\t\t}\n\t\t}\n\n\t\tsort.Slice(tc.Expected, func(i, j int) bool {\n\t\t\treturn tc.Expected[i].String() < tc.Expected[j].String()\n\t\t})\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\talgs, err := jws.AlgorithmsForKey(tc.Key)\n\t\t\trequire.NoError(t, err, `jws.AlgorithmsForKey should succeed`)\n\n\t\t\tsort.Slice(algs, func(i, j int) bool {\n\t\t\t\treturn algs[i].String() < algs[j].String()\n\t\t\t})\n\t\t\trequire.Equal(t, tc.Expected, algs, `results should match`)\n\t\t})\n\t}\n}\n\nfunc TestGH681(t *testing.T) {\n\tprivkey, err := jwxtest.GenerateRsaKey()\n\trequire.NoError(t, err, \"failed to create private key\")\n\n\tbuf, err := jws.Sign(nil, jws.WithKey(jwa.RS256, privkey), jws.WithDetachedPayload([]byte(\"Lorem ipsum\")))\n\trequire.NoError(t, err, \"failed to sign payload\")\n\n\tt.Logf(\"%s\", buf)\n\n\t_, err = jws.Verify(buf, jws.WithKey(jwa.RS256, &privkey.PublicKey), jws.WithDetachedPayload([]byte(\"Lorem ipsum\")))\n\trequire.NoError(t, err, \"failed to verify JWS message\")\n}\n\nfunc TestGH840(t *testing.T) {\n\t// Go 1.19+ panics if elliptic curve operations are called against\n\t// a point that's _NOT_ on the curve\n\tuntrustedJWK := []byte(`{\n\t\t\"kty\": \"EC\",\n\t\t\"crv\": \"P-256\",\n\t\t\"x\": \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqx7D4\",\n\t\t\"y\": \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n\t\t\"d\": \"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\"\n\t}`)\n\n\t// Parse, serialize, slice and dice JWKs!\n\tprivkey, err := jwk.ParseKey(untrustedJWK)\n\trequire.NoError(t, err, `jwk.ParseKey should succeed`)\n\n\tpubkey, err := jwk.PublicKeyOf(privkey)\n\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\n\ttok, err := jwt.NewBuilder().\n\t\tIssuer(`github.com/lestrrat-go/jwx`).\n\t\tIssuedAt(time.Now()).\n\t\tBuild()\n\trequire.NoError(t, err, `jwt.NewBuilder should succeed`)\n\n\tsigned, err := jwt.Sign(tok, jwt.WithKey(jwa.ES256, privkey))\n\trequire.NoError(t, err, `jwt.Sign should succeed`)\n\n\t_, err = jwt.Parse(signed, jwt.WithKey(jwa.ES256, pubkey))\n\trequire.Error(t, err, `jwt.Parse should FAIL`) // pubkey's X/Y is not on the curve\n}\n\nfunc TestGH888(t *testing.T) {\n\t// This should fail because we're passing multiple keys (i.e. multiple signatures)\n\t// and yet we haven't specified JSON serialization\n\t_, err := jws.Sign([]byte(`foo`), jws.WithInsecureNoSignature(), jws.WithKey(jwa.HS256, []byte(`bar`)))\n\trequire.Error(t, err, `jws.Sign with multiple keys (including alg=none) should fail`)\n\n\t// This should pass because we can now have multiple signaures with JSON serialization\n\tsigned, err := jws.Sign([]byte(`foo`), jws.WithInsecureNoSignature(), jws.WithKey(jwa.HS256, []byte(`bar`)), jws.WithJSON())\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\tmessage, err := jws.Parse(signed)\n\trequire.NoError(t, err, `jws.Parse should succeed`)\n\n\t// Look for alg=none signature\n\tvar foundNoSignature bool\n\tfor _, sig := range message.Signatures() {\n\t\tif sig.ProtectedHeaders().Algorithm() != jwa.NoSignature {\n\t\t\tcontinue\n\t\t}\n\n\t\trequire.Nil(t, sig.Signature(), `signature must be nil for alg=none`)\n\t\tfoundNoSignature = true\n\t}\n\trequire.True(t, foundNoSignature, `signature with no signature was found`)\n\n\t_, err = jws.Verify(signed)\n\trequire.Error(t, err, `jws.Verify should fail`)\n\n\t_, err = jws.Verify(signed, jws.WithKey(jwa.NoSignature, nil))\n\trequire.Error(t, err, `jws.Verify should fail`)\n\n\t// Note: you can't do jws.Verify(..., jws.WithInsecureNoSignature())\n\n\tverified, err := jws.Verify(signed, jws.WithKey(jwa.HS256, []byte(`bar`)))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, []byte(`foo`), verified)\n}\n\n// Some stuff required for testing #910\n// The original code used an external library to sign/verify, but here\n// we just use a simple SHA256 digest here so that we don't force\n// users to download an optional dependency\ntype s256SignerVerifier struct{}\n\nconst sha256Algo jwa.SignatureAlgorithm = \"SillyTest256\"\n\nfunc (s256SignerVerifier) Algorithm() jwa.SignatureAlgorithm {\n\treturn sha256Algo\n}\n\nfunc (s256SignerVerifier) Sign(payload []byte, _ interface{}) ([]byte, error) {\n\th := sha256.Sum256(payload)\n\treturn h[:], nil\n}\n\nfunc (s256SignerVerifier) Verify(payload, signature []byte, _ interface{}) error {\n\th := sha256.Sum256(payload)\n\tif !bytes.Equal(h[:], signature) {\n\t\treturn errors.New(\"invalid signature\")\n\t}\n\treturn nil\n}\n\nfunc TestGH910(t *testing.T) {\n\t// Note: This has global effect. You can't run this in parallel with other tests\n\tjws.RegisterSigner(sha256Algo, jws.SignerFactoryFn(func() (jws.Signer, error) {\n\t\treturn s256SignerVerifier{}, nil\n\t}))\n\tdefer jws.UnregisterSigner(sha256Algo)\n\n\tjws.RegisterVerifier(sha256Algo, jws.VerifierFactoryFn(func() (jws.Verifier, error) {\n\t\treturn s256SignerVerifier{}, nil\n\t}))\n\tdefer jws.UnregisterVerifier(sha256Algo)\n\tdefer jwa.UnregisterSignatureAlgorithm(sha256Algo)\n\n\tvar sa jwa.SignatureAlgorithm\n\trequire.NoError(t, sa.Accept(sha256Algo.String()), `jwa.SignatureAlgorithm.Accept should succeed`)\n\n\t// Now that we have established that the signature algorithm works,\n\t// we can proceed with the test\n\tconst src = `Lorem Ipsum`\n\tsigned, err := jws.Sign([]byte(src), jws.WithKey(sha256Algo, nil))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\tverified, err := jws.Verify(signed, jws.WithKey(sha256Algo, nil))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\n\trequire.Equal(t, src, string(verified), `verified payload should match`)\n\n\tjws.UnregisterSigner(sha256Algo)\n\n\t// Now try after unregistering the signer for the algorithm\n\t_, err = jws.Sign([]byte(src), jws.WithKey(sha256Algo, nil))\n\trequire.Error(t, err, `jws.Sign should succeed`)\n\n\tjws.RegisterSigner(sha256Algo, jws.SignerFactoryFn(func() (jws.Signer, error) {\n\t\treturn s256SignerVerifier{}, nil\n\t}))\n\n\t_, err = jws.Sign([]byte(src), jws.WithKey(sha256Algo, nil))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n}\n\nfunc TestUnpaddedSignatureR(t *testing.T) {\n\t// I brute-forced generating a key and signature where the R portion\n\t// of the signature was not padded by using the following code in the\n\t// first run, then copied the result to the test\n\t/*\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\trawKey, err := jwxtest.GenerateEcdsaKey(jwa.P256)\n\t\t\trequire.NoError(t, err, `jwxtest.GenerateEcdsaJwk should succeed`)\n\n\t\t\tkey, err := jwk.FromRaw(rawKey)\n\t\t\trequire.NoError(t, err, `jwk.FromRaw should succeed`)\n\n\t\t\tpubkey, _ := key.PublicKey()\n\n\t\t\tsigned, err := jws.Sign([]byte(\"Lorem Ipsum\"), jws.WithKey(jwa.ES256, key))\n\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t\t\tmessage, err := jws.Parse(signed)\n\t\t\trequire.NoError(t, err, `jws.Parse should succeed`)\n\n\t\t\tasJson, _ := json.Marshal(message)\n\t\t\tt.Logf(\"%s\", asJson)\n\n\t\t\tfor _, sig := range message.Signatures() {\n\t\t\t\tsigBytes := sig.Signature()\n\t\t\t\tif sigBytes[0] == 0x00 {\n\t\t\t\t\t// Found it!\n\t\t\t\t\tt.Logf(\"Found signature that can be unpadded.\")\n\t\t\t\t\tt.Logf(\"Original signature: %q\", base64.EncodeToString(sigBytes))\n\n\t\t\t\t\t//\t\t\t\tunpaddedSig := append(sigBytes[1:31], sigBytes[32:]...)\n\t\t\t\t\tunpaddedSig := sigBytes[1:]\n\t\t\t\t\tt.Logf(\"Signature with first byte of R removed: %q\", base64.EncodeToString(unpaddedSig))\n\t\t\t\t\tt.Logf(\"Original JWS payload: %q\", signed)\n\t\t\t\t\trequire.Len(t, unpaddedSig, 63)\n\n\t\t\t\t\ti := bytes.LastIndexByte(signed, '.')\n\t\t\t\t\tmodified := append(signed[:i+1], base64.Encode(unpaddedSig)...)\n\t\t\t\t\tt.Logf(\"JWS payload with unpadded signature: %q\", modified)\n\n\t\t\t\t\t// jws.Verify for sanity\n\t\t\t\t\tverified, err := jws.Verify(modified, jws.WithKey(jwa.ES256, pubkey))\n\t\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\t\tt.Logf(\"verified payload: %q\", verified)\n\n\t\t\t\t\tbuf, _ := json.Marshal(key)\n\t\t\t\t\tt.Logf(\"Private JWK: %s\", buf)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t*/\n\t// Padded has R with a leading 0 (as it should)\n\tpadded := \"eyJhbGciOiJFUzI1NiJ9.TG9yZW0gSXBzdW0.ALFru4CRZDiAlVKyyHtlLGtXIAWxC3lXIlZuYO8G8a5ePzCwyw6c2FzWBZwrLaoLFZb_TcYs3TcZ8mhONPaavQ\"\n\t// Unpadded has R with a leading 0 removed (31 bytes, WRONG)\n\tunpadded := \"eyJhbGciOiJFUzI1NiJ9.TG9yZW0gSXBzdW0.sWu7gJFkOICVUrLIe2Usa1cgBbELeVciVm5g7wbxrl4_MLDLDpzYXNYFnCstqgsVlv9NxizdNxnyaE409pq9\"\n\n\t// This is the private key used to sign the payload\n\tkeySrc := `{\"crv\":\"P-256\",\"d\":\"MqGwMl-dlJFrMnu7rFyslPV8EdsVC7I4V19N-ADVqaU\",\"kty\":\"EC\",\"x\":\"Anf1p2lRrcXgZKpVRRC1xLxPiw_45PbOlygfbxvD8Es\",\"y\":\"d0HiZq-aurVVLLtK-xqXPpzpWloZJNwKNve7akBDuvg\"}`\n\n\tprivKey, err := jwk.ParseKey([]byte(keySrc))\n\trequire.NoError(t, err, `jwk.ParseKey should succeed`)\n\n\tpubKey, err := jwk.PublicKeyOf(privKey)\n\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\n\t// Should always succeed\n\tpayload, err := jws.Verify([]byte(padded), jws.WithKey(jwa.ES256, pubKey))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, \"Lorem Ipsum\", string(payload))\n\n\t// Should fail\n\t_, err = jws.Verify([]byte(unpadded), jws.WithKey(jwa.ES256, pubKey))\n\trequire.Error(t, err, `jws.Verify should fail`)\n}\n\nfunc TestValidateKey(t *testing.T) {\n\tprivKey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\n\tsigned, err := jws.Sign([]byte(\"Lorem Ipsum\"), jws.WithKey(jwa.RS256, privKey), jws.WithValidateKey(true))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t// This should fail because D is empty\n\trequire.NoError(t, privKey.Set(jwk.RSADKey, []byte(nil)), `jwk.Set should succeed`)\n\t_, err = jws.Sign([]byte(\"Lorem Ipsum\"), jws.WithKey(jwa.RS256, privKey), jws.WithValidateKey(true))\n\trequire.Error(t, err, `jws.Sign should fail`)\n\n\tpubKey, err := jwk.PublicKeyOf(privKey)\n\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\n\tn := pubKey.(jwk.RSAPublicKey).N()\n\n\t// Set N to an empty value\n\trequire.NoError(t, pubKey.Set(jwk.RSANKey, []byte(nil)), `jwk.Set should succeed`)\n\n\t// This is going to fail regardless, because the public key is now\n\t// invalid (empty N), but we want to make sure that it fails because\n\t// of the validation failing\n\t_, err = jws.Verify(signed, jws.WithKey(jwa.RS256, pubKey), jws.WithValidateKey(true))\n\trequire.Error(t, err, `jws.Verify should fail`)\n\trequire.True(t, jwk.IsKeyValidationError(err), `jwk.IsKeyValidationError should return true`)\n\n\t// The following should now succeed, because N has been reinstated\n\trequire.NoError(t, pubKey.Set(jwk.RSANKey, n), `jwk.Set should succeed`)\n\t_, err = jws.Verify(signed, jws.WithKey(jwa.RS256, pubKey), jws.WithValidateKey(true))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n}\n", "package jws\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/lestrrat-go/jwx/v2/internal/base64\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/json\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/pool\"\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n)\n\nfunc NewSignature() *Signature {\n\treturn &Signature{}\n}\n\nfunc (s *Signature) DecodeCtx() DecodeCtx {\n\treturn s.dc\n}\n\nfunc (s *Signature) SetDecodeCtx(dc DecodeCtx) {\n\ts.dc = dc\n}\n\nfunc (s Signature) PublicHeaders() Headers {\n\treturn s.headers\n}\n\nfunc (s *Signature) SetPublicHeaders(v Headers) *Signature {\n\ts.headers = v\n\treturn s\n}\n\nfunc (s Signature) ProtectedHeaders() Headers {\n\treturn s.protected\n}\n\nfunc (s *Signature) SetProtectedHeaders(v Headers) *Signature {\n\ts.protected = v\n\treturn s\n}\n\nfunc (s Signature) Signature() []byte {\n\treturn s.signature\n}\n\nfunc (s *Signature) SetSignature(v []byte) *Signature {\n\ts.signature = v\n\treturn s\n}\n\ntype signatureUnmarshalProbe struct {\n\tHeader    Headers `json:\"header,omitempty\"`\n\tProtected *string `json:\"protected,omitempty\"`\n\tSignature *string `json:\"signature,omitempty\"`\n}\n\nfunc (s *Signature) UnmarshalJSON(data []byte) error {\n\tvar sup signatureUnmarshalProbe\n\tsup.Header = NewHeaders()\n\tif err := json.Unmarshal(data, &sup); err != nil {\n\t\treturn fmt.Errorf(`failed to unmarshal signature into temporary struct: %w`, err)\n\t}\n\n\ts.headers = sup.Header\n\tif buf := sup.Protected; buf != nil {\n\t\tsrc := []byte(*buf)\n\t\tif !bytes.HasPrefix(src, []byte{'{'}) {\n\t\t\tdecoded, err := base64.Decode(src)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to base64 decode protected headers: %w`, err)\n\t\t\t}\n\t\t\tsrc = decoded\n\t\t}\n\n\t\tprt := NewHeaders()\n\t\t//nolint:forcetypeassert\n\t\tprt.(*stdHeaders).SetDecodeCtx(s.DecodeCtx())\n\t\tif err := json.Unmarshal(src, prt); err != nil {\n\t\t\treturn fmt.Errorf(`failed to unmarshal protected headers: %w`, err)\n\t\t}\n\t\t//nolint:forcetypeassert\n\t\tprt.(*stdHeaders).SetDecodeCtx(nil)\n\t\ts.protected = prt\n\t}\n\n\tif sup.Signature != nil {\n\t\tdecoded, err := base64.DecodeString(*sup.Signature)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(`failed to base decode signature: %w`, err)\n\t\t}\n\t\ts.signature = decoded\n\t}\n\treturn nil\n}\n\n// Sign populates the signature field, with a signature generated by\n// given the signer object and payload.\n//\n// The first return value is the raw signature in binary format.\n// The second return value s the full three-segment signature\n// (e.g. \"eyXXXX.XXXXX.XXXX\")\nfunc (s *Signature) Sign(payload []byte, signer Signer, key interface{}) ([]byte, []byte, error) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\thdrs, err := mergeHeaders(ctx, s.headers, s.protected)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to merge headers: %w`, err)\n\t}\n\n\tif err := hdrs.Set(AlgorithmKey, signer.Algorithm()); err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to set \"alg\": %w`, err)\n\t}\n\n\t// If the key is a jwk.Key instance, obtain the raw key\n\tif jwkKey, ok := key.(jwk.Key); ok {\n\t\t// If we have a key ID specified by this jwk.Key, use that in the header\n\t\tif kid := jwkKey.KeyID(); kid != \"\" {\n\t\t\tif err := hdrs.Set(jwk.KeyIDKey, kid); err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`set key ID from jwk.Key: %w`, err)\n\t\t\t}\n\t\t}\n\t}\n\thdrbuf, err := json.Marshal(hdrs)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to marshal headers: %w`, err)\n\t}\n\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.ReleaseBytesBuffer(buf)\n\n\tbuf.WriteString(base64.EncodeToString(hdrbuf))\n\tbuf.WriteByte('.')\n\n\tvar plen int\n\tb64 := getB64Value(hdrs)\n\tif b64 {\n\t\tencoded := base64.EncodeToString(payload)\n\t\tplen = len(encoded)\n\t\tbuf.WriteString(encoded)\n\t} else {\n\t\tif !s.detached {\n\t\t\tif bytes.Contains(payload, []byte{'.'}) {\n\t\t\t\treturn nil, nil, fmt.Errorf(`payload must not contain a \".\"`)\n\t\t\t}\n\t\t}\n\t\tplen = len(payload)\n\t\tbuf.Write(payload)\n\t}\n\n\tsignature, err := signer.Sign(buf.Bytes(), key)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to sign payload: %w`, err)\n\t}\n\ts.signature = signature\n\n\t// Detached payload, this should be removed from the end result\n\tif s.detached {\n\t\tbuf.Truncate(buf.Len() - plen)\n\t}\n\n\tbuf.WriteByte('.')\n\tbuf.WriteString(base64.EncodeToString(signature))\n\tret := make([]byte, buf.Len())\n\tcopy(ret, buf.Bytes())\n\n\treturn signature, ret, nil\n}\n\nfunc NewMessage() *Message {\n\treturn &Message{}\n}\n\n// Clears the internal raw buffer that was accumulated during\n// the verify phase\nfunc (m *Message) clearRaw() {\n\tfor _, sig := range m.signatures {\n\t\tif protected := sig.protected; protected != nil {\n\t\t\tif cr, ok := protected.(*stdHeaders); ok {\n\t\t\t\tcr.raw = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (m *Message) SetDecodeCtx(dc DecodeCtx) {\n\tm.dc = dc\n}\n\nfunc (m *Message) DecodeCtx() DecodeCtx {\n\treturn m.dc\n}\n\n// Payload returns the decoded payload\nfunc (m Message) Payload() []byte {\n\treturn m.payload\n}\n\nfunc (m *Message) SetPayload(v []byte) *Message {\n\tm.payload = v\n\treturn m\n}\n\nfunc (m Message) Signatures() []*Signature {\n\treturn m.signatures\n}\n\nfunc (m *Message) AppendSignature(v *Signature) *Message {\n\tm.signatures = append(m.signatures, v)\n\treturn m\n}\n\nfunc (m *Message) ClearSignatures() *Message {\n\tm.signatures = nil\n\treturn m\n}\n\n// LookupSignature looks up a particular signature entry using\n// the `kid` value\nfunc (m Message) LookupSignature(kid string) []*Signature {\n\tvar sigs []*Signature\n\tfor _, sig := range m.signatures {\n\t\tif hdr := sig.PublicHeaders(); hdr != nil {\n\t\t\thdrKeyID := hdr.KeyID()\n\t\t\tif hdrKeyID == kid {\n\t\t\t\tsigs = append(sigs, sig)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif hdr := sig.ProtectedHeaders(); hdr != nil {\n\t\t\thdrKeyID := hdr.KeyID()\n\t\t\tif hdrKeyID == kid {\n\t\t\t\tsigs = append(sigs, sig)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\treturn sigs\n}\n\n// This struct is used to first probe for the structure of the\n// incoming JSON object. We then decide how to parse it\n// from the fields that are populated.\ntype messageUnmarshalProbe struct {\n\tPayload    *string           `json:\"payload\"`\n\tSignatures []json.RawMessage `json:\"signatures,omitempty\"`\n\tHeader     Headers           `json:\"header,omitempty\"`\n\tProtected  *string           `json:\"protected,omitempty\"`\n\tSignature  *string           `json:\"signature,omitempty\"`\n}\n\nfunc (m *Message) UnmarshalJSON(buf []byte) error {\n\tm.payload = nil\n\tm.signatures = nil\n\tm.b64 = true\n\n\tvar mup messageUnmarshalProbe\n\tmup.Header = NewHeaders()\n\tif err := json.Unmarshal(buf, &mup); err != nil {\n\t\treturn fmt.Errorf(`failed to unmarshal into temporary structure: %w`, err)\n\t}\n\n\tb64 := true\n\tif mup.Signature == nil { // flattened signature is NOT present\n\t\tif len(mup.Signatures) == 0 {\n\t\t\treturn fmt.Errorf(`required field \"signatures\" not present`)\n\t\t}\n\n\t\tm.signatures = make([]*Signature, 0, len(mup.Signatures))\n\t\tfor i, rawsig := range mup.Signatures {\n\t\t\tvar sig Signature\n\t\t\tsig.SetDecodeCtx(m.DecodeCtx())\n\t\t\tif err := json.Unmarshal(rawsig, &sig); err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to unmarshal signature #%d: %w`, i+1, err)\n\t\t\t}\n\t\t\tsig.SetDecodeCtx(nil)\n\n\t\t\tif i == 0 {\n\t\t\t\tif !getB64Value(sig.protected) {\n\t\t\t\t\tb64 = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif b64 != getB64Value(sig.protected) {\n\t\t\t\t\treturn fmt.Errorf(`b64 value must be the same for all signatures`)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm.signatures = append(m.signatures, &sig)\n\t\t}\n\t} else { // .signature is present, it's a flattened structure\n\t\tif len(mup.Signatures) != 0 {\n\t\t\treturn fmt.Errorf(`invalid format (\"signatures\" and \"signature\" keys cannot both be present)`)\n\t\t}\n\n\t\tvar sig Signature\n\t\tsig.headers = mup.Header\n\t\tif src := mup.Protected; src != nil {\n\t\t\tdecoded, err := base64.DecodeString(*src)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to base64 decode flattened protected headers: %w`, err)\n\t\t\t}\n\t\t\tprt := NewHeaders()\n\t\t\t//nolint:forcetypeassert\n\t\t\tprt.(*stdHeaders).SetDecodeCtx(m.DecodeCtx())\n\t\t\tif err := json.Unmarshal(decoded, prt); err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to unmarshal flattened protected headers: %w`, err)\n\t\t\t}\n\t\t\t//nolint:forcetypeassert\n\t\t\tprt.(*stdHeaders).SetDecodeCtx(nil)\n\t\t\tsig.protected = prt\n\t\t}\n\n\t\tdecoded, err := base64.DecodeString(*mup.Signature)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(`failed to base64 decode flattened signature: %w`, err)\n\t\t}\n\t\tsig.signature = decoded\n\n\t\tm.signatures = []*Signature{&sig}\n\t\tb64 = getB64Value(sig.protected)\n\t}\n\n\tif mup.Payload != nil {\n\t\tif !b64 { // NOT base64 encoded\n\t\t\tm.payload = []byte(*mup.Payload)\n\t\t} else {\n\t\t\tdecoded, err := base64.DecodeString(*mup.Payload)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to base64 decode payload: %w`, err)\n\t\t\t}\n\t\t\tm.payload = decoded\n\t\t}\n\t}\n\tm.b64 = b64\n\treturn nil\n}\n\nfunc (m Message) MarshalJSON() ([]byte, error) {\n\tif len(m.signatures) == 1 {\n\t\treturn m.marshalFlattened()\n\t}\n\treturn m.marshalFull()\n}\n\nfunc (m Message) marshalFlattened() ([]byte, error) {\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.ReleaseBytesBuffer(buf)\n\n\tsig := m.signatures[0]\n\n\tbuf.WriteRune('{')\n\tvar wrote bool\n\n\tif hdr := sig.headers; hdr != nil {\n\t\thdrjs, err := hdr.MarshalJSON()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to marshal \"header\" (flattened format): %w`, err)\n\t\t}\n\t\tbuf.WriteString(`\"header\":`)\n\t\tbuf.Write(hdrjs)\n\t\twrote = true\n\t}\n\n\tif wrote {\n\t\tbuf.WriteRune(',')\n\t}\n\tbuf.WriteString(`\"payload\":\"`)\n\tbuf.WriteString(base64.EncodeToString(m.payload))\n\tbuf.WriteRune('\"')\n\n\tif protected := sig.protected; protected != nil {\n\t\tprotectedbuf, err := protected.MarshalJSON()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to marshal \"protected\" (flattened format): %w`, err)\n\t\t}\n\t\tbuf.WriteString(`,\"protected\":\"`)\n\t\tbuf.WriteString(base64.EncodeToString(protectedbuf))\n\t\tbuf.WriteRune('\"')\n\t}\n\n\tbuf.WriteString(`,\"signature\":\"`)\n\tbuf.WriteString(base64.EncodeToString(sig.signature))\n\tbuf.WriteRune('\"')\n\tbuf.WriteRune('}')\n\n\tret := make([]byte, buf.Len())\n\tcopy(ret, buf.Bytes())\n\treturn ret, nil\n}\n\nfunc (m Message) marshalFull() ([]byte, error) {\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.ReleaseBytesBuffer(buf)\n\n\tbuf.WriteString(`{\"payload\":\"`)\n\tbuf.WriteString(base64.EncodeToString(m.payload))\n\tbuf.WriteString(`\",\"signatures\":[`)\n\tfor i, sig := range m.signatures {\n\t\tif i > 0 {\n\t\t\tbuf.WriteRune(',')\n\t\t}\n\n\t\tbuf.WriteRune('{')\n\t\tvar wrote bool\n\t\tif hdr := sig.headers; hdr != nil {\n\t\t\thdrbuf, err := hdr.MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to marshal \"header\" for signature #%d: %w`, i+1, err)\n\t\t\t}\n\t\t\tbuf.WriteString(`\"header\":`)\n\t\t\tbuf.Write(hdrbuf)\n\t\t\twrote = true\n\t\t}\n\n\t\tif protected := sig.protected; protected != nil {\n\t\t\tprotectedbuf, err := protected.MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to marshal \"protected\" for signature #%d: %w`, i+1, err)\n\t\t\t}\n\t\t\tif wrote {\n\t\t\t\tbuf.WriteRune(',')\n\t\t\t}\n\t\t\tbuf.WriteString(`\"protected\":\"`)\n\t\t\tbuf.WriteString(base64.EncodeToString(protectedbuf))\n\t\t\tbuf.WriteRune('\"')\n\t\t\twrote = true\n\t\t}\n\n\t\tif len(sig.signature) > 0 {\n\t\t\t// If InsecureNoSignature is enabled, signature may not exist\n\t\t\tif wrote {\n\t\t\t\tbuf.WriteRune(',')\n\t\t\t}\n\t\t\tbuf.WriteString(`\"signature\":\"`)\n\t\t\tbuf.WriteString(base64.EncodeToString(sig.signature))\n\t\t\tbuf.WriteString(`\"`)\n\t\t}\n\t\tbuf.WriteString(`}`)\n\t}\n\tbuf.WriteString(`]}`)\n\n\tret := make([]byte, buf.Len())\n\tcopy(ret, buf.Bytes())\n\treturn ret, nil\n}\n\n// Compact generates a JWS message in compact serialization format from\n// `*jws.Message` object. The object contain exactly one signature, or\n// an error is returned.\n//\n// If using a detached payload, the payload must already be stored in\n// the `*jws.Message` object, and the `jws.WithDetached()` option\n// must be passed to the function.\nfunc Compact(msg *Message, options ...CompactOption) ([]byte, error) {\n\tif l := len(msg.signatures); l != 1 {\n\t\treturn nil, fmt.Errorf(`jws.Compact: cannot serialize message with %d signatures (must be one)`, l)\n\t}\n\n\tvar detached bool\n\tfor _, option := range options {\n\t\t//nolint:forcetypeassert\n\t\tswitch option.Ident() {\n\t\tcase identDetached{}:\n\t\t\tdetached = option.Value().(bool)\n\t\t}\n\t}\n\n\ts := msg.signatures[0]\n\t// XXX check if this is correct\n\thdrs := s.ProtectedHeaders()\n\n\thdrbuf, err := json.Marshal(hdrs)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`jws.Compress: failed to marshal headers: %w`, err)\n\t}\n\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.ReleaseBytesBuffer(buf)\n\n\tbuf.WriteString(base64.EncodeToString(hdrbuf))\n\tbuf.WriteByte('.')\n\n\tif !detached {\n\t\tif getB64Value(hdrs) {\n\t\t\tencoded := base64.EncodeToString(msg.payload)\n\t\t\tbuf.WriteString(encoded)\n\t\t} else {\n\t\t\tif bytes.Contains(msg.payload, []byte{'.'}) {\n\t\t\t\treturn nil, fmt.Errorf(`jws.Compress: payload must not contain a \".\"`)\n\t\t\t}\n\t\t\tbuf.Write(msg.payload)\n\t\t}\n\t}\n\n\tbuf.WriteByte('.')\n\tbuf.WriteString(base64.EncodeToString(s.signature))\n\tret := make([]byte, buf.Len())\n\tcopy(ret, buf.Bytes())\n\treturn ret, nil\n}\n"], "fixing_code": ["Changes\n=======\n\nv2 has many incompatibilities with v1. To see the full list of differences between\nv1 and v2, please read the Changes-v2.md file (https://github.com/lestrrat-go/jwx/blob/develop/v2/Changes-v2.md)\n\nv2.0.19 UNRELEASED\n[New Features]\n  * [jws] Added jws.IsVerificationError to check if the error returned by `jws.Verify`\n    was caused by actual verification step or something else, for example, while fetching\n    a key from datasource\n\n[Security Fixes]\n  * [jws] JWS messages formated in full JSON format (i.e. not the compact format, which\n    consists of three base64 strings concatenated with a '.') with missing \"protected\"\n    headers could cause a panic, thereby introducing a possiblity of a DoS.\n\n    This has been fixed so that the `jws.Parse` function succeeds in parsing a JWS message\n    lacking a protected header. Calling `jws.Verify` on this same JWS message will result\n    in a failed verification attempt. Note that this behavior will differ slightly when\n    parsing JWS messages in compact form, which result in an error. \n\nv2.0.18 03 Dec 2023\n[Security Fixes]\n  * [jwe] A large number in p2c parameter for PBKDF2 based encryptions could cause a DoS attack,\n    similar to https://nvd.nist.gov/vuln/detail/CVE-2022-36083.  All users who use JWE via this\n    package should upgrade. While the JOSE spec allows for encryption using JWE on JWTs, users of\n    the `jwt` package are not immediately susceptible unless they explicitly try to decrypt\n    JWTs -- by default the `jwt` package verifies signatures, but does not decrypt messages.\n    [GHSA-7f9x-gw85-8grf]\n\nv2.0.17 20 Nov 2023\n[Bug Fixes]\n  * [jws] Previously, `jws.UnregisterSigner` did not remove the previous signer instance when\n    the signer was registered and unregistered multiple times (#1016). This has been fixed.\n\n[New Features]\n  * [jwe] (EXPERIMENTAL) `jwe.WithCEK` has been added to extract the content encryption key (CEK) from the Decrypt operation.\n  * [jwe] (EXPERIMENTAL) `jwe.EncryptStatic` has been added to encrypt content using a static CEK.\n    Using static CEKs has serious security implications, and you should not use\n    this unless you completely understand the risks involved.\n\nv2.0.16 31 Oct 2023\n[Security]\n  * [jws] ECDSA signature verification requires us to check if the signature\n    is of the desired length of bytes, but this check that used to exist before\n    had been removed in #65, resulting in certain malformed signatures to pass\n    verification.\n\n    One of the ways this could happen if R is a 31 byte integer and S is 32 byte integer,\n    both containing the correct signature values, but R is not zero-padded.\n\n       Correct = R: [ 0 , ... ] (32 bytes) S: [ ... ] (32 bytes)\n       Wrong   = R: [ ... ] (31 bytes)     S: [ ... ] (32 bytes)\n\n    In order for this check to pass, you would still need to have all 63 bytes\n    populated with the correct signature. The only modification a bad actor\n    may be able to do is to add one more byte at the end, in which case the\n    first 32 bytes (including what would have been S's first byte) is used for R,\n    and S would contain the rest. But this will only result in the verification to\n    fail. Therefore this in itself should not pose any security risk, albeit\n    allowing some illegally formated messages to be verified.\n\n  * [jwk] `jwk.Key` objects now have a `Validate()` method to validate the data\n    stored in the keys. However, this still does not necessarily mean that the key's\n    are valid for use in cryptographic operations. If `Validate()` is successful,\n    it only means that the keys are in the right _format_, including the presence\n    of required fields and that certain fields have proper length, etc.\n\n[New Features]\n  * [jws] Added `jws.WithValidateKey()` to force calling `key.Validate()` before\n    signing or verification.\n\n  * [jws] `jws.Sign()` now returns a special type of error that can hold the\n    individual errors from the signers. The stringification is still the same\n    as before to preserve backwards compatibility.\n\n  * [jwk] Added `jwk.IsKeyValidationError` that checks if an error is an error\n    from `key.Validate()`.\n\n[Bug Fixes]\n  * [jwt] `jwt.ParseInsecure()` was running verification if you provided a key\n    via `jwt.WithKey()` or `jwt.WithKeySet()` (#1007)\n\nv2.0.15 19 20 Oct 2023\n[Bug fixes]\n  * [jws] jws.Sign() now properly check for valid algorithm / key type pair when\n    the key implements crypto.Signer. This was caused by the fact that when \n    jws.WithKey() accepted keys that implemented crypto.Signer, there really\n    is no way to robustly check what algorithm the crypto.Signer implements.\n\n    The code has now been modified to check for KNOWN key types, i.e. those\n    that are defined in Go standard library, and those that are defined in\n    this library. For example, now calling jws.Sign() with jws.WithKey(jwa.RS256, ecdsaKey)\n    where ecdsaKey is either an instance of *ecdsa.PrivateKey or jwk.ECDSAPrivateKey\n    will produce an error.\n\n    However, if you use a separate library that wraps some KMS library which implements\n    crypto.Signer, this same check will not be performed due to the fact that\n    it is an unknown library to us. And there's no way to query a crypto.Signer\n    for its algorithm family.\n\nv2.0.14 17 Oct 2023\n[New Features]\n  * [jwk] jwk.IsPrivateKey(), as well as jwk.AsymmetricKey has been added.\n    The function can be used to tell if a jwk.Key is a private key of an\n    asymmetric key pair.\n[Security]\n  * golang.org/x/crypto has been updated to 0.14.0. The update contains a fix for HTTP/2\n    rapid reset DoS vulnerability, which some security scanning softwares may flag.\n    However, do note that this library is NOT affected by the issue, as it does not have\n    the capability to serve as an HTTP/2 server. This is included in this release\n    document so that users will be able to tell why this library may be flagged\n    when/if their scanning software do so.\n\nv2.0.13 26 Sep 2023\n[New Features]\n  * [jwk] jwk.Equal has been added. Please note that this is equivalent to\n  comparing the keys' thumbprints, therefore it does NOT take in consideration\n  non-essential fields.\n\n[Miscellaneous]\n  * Various documentation fixes and additions.\n\nv2.0.12 - 11 Aug 2023\n[Bug fixes]\n  * [jwt] jwt.Serializer was ignoring JWE flags (#951)\n\n[Miscellaneous]\n  * [jwk] Check for seed length on OKP JWKs to avoid panics (#947)\n  * [jws] Documentation for jws.WithKeySet()\n\nv2.0.11 - 14 Jun 2023\n[Security]\n  * Potential Padding Oracle Attack Vulnerability and Timing Attack Vulnerability \n    for JWE AES-CBC encrypted payloads affecting all v2 releases up to v2.0.10,\n    all v1 releases up to v1.2.25, and all v0 releases up to v0.9.2 have been reported by\n    @shogo82148.\n\n    Please note that v0 versions will NOT receive fixes.\n    This release fixes these vulnerabilities for the v2 series.\n\nv2.0.10 - 12 Jun 2023\n[New Features]\n  * [jwe] (EXPERIMENTAL) Added `jwe.KeyEncrypter` and `jwe.KeyDecrypter` interfaces\n    that works in similar ways as how `crypto.Signer` works for signature\n    generation and verification. It can act as the interface for your encryption/decryption\n    keys that are for example stored in an hardware device.\n\n    This feature is labeled experimental because the API for the above interfaces have not\n    been battle tested, and may need to changed yet. Please be aware that until the API\n    is deemed stable, you may have to adapat our code to these possible changes,\n    _even_ during minor version upgrades of this library.\n   \n[Bug fixes]\n  * Registering JWS signers/verifiers did not work since v2.0.0, because the\n    way we handle algorithm names changed in 2aa98ce6884187180a7145b73da78c859dd46c84.\n    (We previously thought that this would be checked by the example code, but it\n     apparently failed to flag us properly)\n\n    The logic behind managing the internal database has been fixed, and\n    `jws.RegisterSigner` and `jws.RegisterVerifier` now properly hooks into the new\n    `jwa.RegisterSignatureAlgorithm` to automatically register new algorithm names\n    (#910, #911)\n[Miscellaneous]\n  * Added limited support for github.com/segmentio/asm/base64. Compile your code\n    with the `jwx_asmbase64` build tag. This feature is EXPERIMENTAL.\n\n    Through limited testing, the use of a faster base64 library provide 1~5% increase\n    in throughput on average. It might make more difference if the input/output is large.\n    If you care about this performance improvement, you should probably enable\n    `goccy` JSON parser as well, by specifying `jwx_goccy,jwx_asmbase64` in your build call.\n  * Slightly changed the way global variables underneath `jwk.Fetch` are initialized and\n    configured. `jwk.Fetch` creates an object that spawns wokers to fetch JWKS when it's\n    first called.\n    You can now also use `jwk.SetGlobalFetcher()` to set a fetcher object which you can\n    control.\n\nv2.0.9 - 21 Mar 2023\n[Security Fixes]\n  * Updated use of golang.org/x/crypto to v0.7.0\n[Bug fixes]\n  * Emitted PEM file for EC private key types used the wrong PEM armor (#875)\n[Miscellaneous]\n  * Banners for generated files have been modified to allow tools to pick them up (#867)\n  * Remove unused variables around ReadFileOption (#866)\n  * Fix test failures\n  * Support bazel out of the box\n  * Now you can create JWS messages using `{\"alg\":\"none\"}`, by calling `jws.Sign()`\n    with `jws.WithInsecureNoSignature()` option. (#888, #890).\n\n    Note that there is no way to call\n    `jws.Verify()` while allowing `{\"alg\":\"none\"}` as you wouldn't be _verifying_\n    the message if we allowed the \"none\" algorithm. `jws.Parse()` will parse such\n    messages witout verification.\n\n    `jwt` also allows you to sign using alg=\"none\", but there's no symmetrical\n    way to verify such messages.\n\nv2.0.8 - 25 Nov 2022\n[Security Fixes]\n  * [jws][jwe] Starting from go 1.19, code related to elliptic algorithms\n    panics (instead of returning an error) when certain methods\n    such as `ScalarMult` are called using points that are not on the\n    elliptic curve being used.\n\n    Using inputs that cause this condition, and you accept unverified JWK\n    from the outside it may be possible for a third-party to cause panics\n    in your program.\n\n    This has been fixed by verifying that the point being used is actually\n    on the curve before such computations (#840)\n[Miscellaneous]\n  * `jwx.GuessFormat` now returns `jwx.InvalidFormat` when the heuristics\n    is sure that the buffer format is invalid.\n\nv2.0.7 - 15 Nov 2022\n[New features]\n  * [jwt] Each `jwt.Token` now has an `Options()` method\n  * [jwt] `jwt.Settings(jwt.WithFlattenedAudience(true))` has a slightly\n    different semantic than before. Instead of changing a global variable,\n    it now specifies that the default value of each per-token option for\n    `jwt.FlattenAudience` is true.\n\n    Therefore, this is what happens:\n\n       // No global settings\n       tok := jwt.New()\n       tok.Options.IsEnabled(jwt.FlattenAudience) // false\n\n       // With global settings\n       jwt.Settings(jwt.WithFlattenedAudience(true))\n       tok := jwt.New()\n       tok.Options.IsEnabled(jwt.FlattenAudience) // true\n       // But you can still turn FlattenAudience off for this\n       // token alone\n       tok.Options.Disable(jwt.FlattenAudience)\n\n    Note that while unlikely to happen for users relying on the old behavior,\n    this change DOES introduce timing issues: whereas old versions switched the\n    JSON marshaling for ALL tokens immediately after calling `jwt.Settings`,\n    the new behavior does NOT affect tokens that have been created before the\n    call to `jwt.Settings` (but marshaled afterwards).\n\n    So the following may happen:\n\n      // < v2.0.7\n      tok := jwt.New() \n      jwt.Settings(jwt.WithFlattenedAudience(true))\n      json.Marshal(tok) // flatten = on\n\n      // >= v2.0.7\n      tok := jwt.New() // flatten = off\n      jwt.Settings(jwt.WithFlattenedAudience(true))\n      json.Marshal(tok) // flatten is still off\n\n    It is recommended that you only set the global setting once at the\n    very beginning of your program to avoid problems.\n\n    Also note that `Clone()` copies the settings as well.\n\n[Miscellaneous]\n  * WithCompact's stringification should have been that of the\n    internal indentity struct (\"WithSerialization\"), but it was\n    wrongly producing \"WithCompact\". This has been fixed.\n  * Go Workspaces have been enabled within this module.\n    - When developing, modules will refer to the main jwx module that they\n      are part of. This allows us to explicitly specify the dependency version\n      in, for example, ./cmd/jwx/go.mod but still develop against the local version.\n    - If you are using `goimports` and other tools, you might want to upgrade\n      binaries -- for example, when using vim-go's auto-format-on-save feature,\n      my old binaries took well over 5~10 seconds to compute the import paths.\n      This was fixed when I switched to using go1.19, and upgraded the binaries\n      used by vim-go\n\nv2.0.6 - 25 Aug 2022\n[Bug fixes][Security]\n  * [jwe] Agreement Party UInfo and VInfo (apv/apu) were not properly being\n    passed to the functions to compute the aad when encrypting using ECDH-ES\n    family of algorithms. Therefore, when using apu/apv, messages encrypted\n    via this module would have failed to be properly decrypted.\n\n    Please note that bogus encrypted messages would not have succeed being\n    decrypted (i.e. this problem does not allow spoofed messages to be decrypted).\n    Therefore this would not have caused unwanted data to to creep in --\n    however it did pose problems for data to be sent and decrypted from this module\n    when using ECDH-ES with apu/apv.\n\n    While not extensively tested, we believe this regression was introduced\n    with the v2 release.\n\nv2.0.5 - 11 Aug 2022\n[Bug fixes]\n  * [jwt] Remove stray debug log\n  * [jwk] Fix x5u field name, caused by a typo\n  * [misc] Update golangci-lint action to v3; v2 was causing weird problems\n\nv2.0.4 - 19 Jul 2022\n[Bug Fixes]\n  * [jwk] github.com/lestrrat-go/httprc, which jwk.Cache depends on,\n    had a problem with inserting URLs to be re-fetched into its queue.\n    As a result it could have been the case that some JWKS were not\n    updated properly. Please upgrade if you use jwk.Cache.\n\n  * [jwk] cert.Get could fail with an out of bounds index look up\n\n  * [jwk] Fix doc buglet in `KeyType()` method\n\n[New Features]\n  * [jws] Add `jws.WithMultipleKeysPerKeyID()` sub-option to allow non-unique\n    key IDs in a given JWK set. By default we assume that a key ID is unique\n    within a key set, but enabling this option allows you to handle JWK sets\n    that contain multiple keys that contain the same key ID.\n\n  * [jwt] Before v2.0.1, sub-second accuracy for time based fields\n    (i.e. `iat`, `exp`, `nbf`) were not respected. Because of this the code\n    to evaluate this code had always truncated any-subsecond portion\n    of these fields, and therefore no sub-second comparisons worked.\n    A new option for validation `jwt.WithTruncation()` has been added\n    to workaround this. This option controls the value used to truncate\n    the time fields. When set to 0, sub-second comparison would be\n    possible.\n    FIY, truncatation will still happen because we do not want to\n    use the monotonic clocks when making comparisons. It's just that\n    truncating using `0` as its argument effectively only strips out\n    the monotonic clock\n\nv2.0.3 - 13 Jun 2022\n[Bug Fixes]\n  * [jwk] Update dependency on github.com/lestrrat-go/httprc to v1.0.2 to\n    avoid unintended blocking in the update goroutine for jwk.Cache\n\nv2.0.2 - 23 May 2022\n[Bug Fixes][Security]\n  * [jwe] An old bug from at least 7 years ago existed in handling AES-CBC unpadding,\n    where the unpad operation might remove more bytes than necessary (#744)\n    This affects all jwx code that is available before v2.0.2 and v1.2.25.\n\n[New Features]\n  * [jwt] RFC3339 timestamps are also accepted for Numeric Date types in JWT tokens.\n    This allows users to parse servers that errnously use RFC3339 timestamps in\n    some pre-defined fields. You can change this behavior by setting \n    `jwt.WithNumericDateParsePedantic` to `false`\n  * [jwt] `jwt.WithNumericDateParsePedantic` has been added. This is a global\n    option that is set using `jwt.Settings`\n\nv2.0.1 - 06 May 2022\n  * [jwk] `jwk.Set` had erronously been documented as not returning an error\n    when the same key already exists in the set. This is a behavior change\n    since v2, and it was missing in the docs (#730)\n  * [jwt] `jwt.ErrMissingRequiredClaim` has been deprecated. Please use\n    `jwt.ErrRequiredClaim` instead.\n  * [jwt] `jwt.WithNumericDateParsePrecision` and `jwt.WithNumericDateFormatPrecision`\n    have been added to parse and format fractional seconds. These options can be\n    passed to `jwt.Settings`.\n    The default precision is set to 0, and fractional portions are not parsed nor\n    formatted. The precision may be set up to 9.\n  * `golang.org/x/crypto` has been upgraded (#724)\n  * `io/ioutil` has been removed from the source code.\n\nv2.0.0 - 24 Apr 2022\n  * This i the first v2 release, which represents a set of design changes\n    that were learnt over the previous 2 years. As a result the v2 API\n    should be much more consistent and uniform across packages, and\n    should be much more flexible to accomodate real-world needs.\n    \n    For a complete list of changes, please see the Changes-v2.md file,\n    or check the diff at https://github.com/lestrrat-go/jwx/compare/v1...v2\n\n[Miscellaneous]\n  * Minor house cleaning on code generation tools\n\n[jwt]\n  * `jwt.ErrMissingRequiredClaim()` has been added\n\nv2.0.0-beta2 - 16 Apr 2022\n[jwk]\n  * Updated `jwk.Set` API and reflected pending changes from v1 which were\n    left over. Please see Changes-v2.md file for details.\n\n  * Added `jwk.CachedSet`, a shim over `jwk.Cache` that allows you to\n    have to write wrappers around `jwk.Cache` that retrieves a particular\n    `jwk.Set` out of it. You can use it to, for example, pass `jwk.CachedSet`\n    to a `jws.Verify`\n\n      cache := jwk.NewCache(ctx)\n      cache.Register(ctx, jwksURL)\n      cachedSet := jwk.NewCachedSet(cache, jwksURL)\n      jws.Verify(signed, jws.WithKeySet(cachedSet))\n\nv2.0.0-beta1 - 09 Apr 2022\n[Miscellaneous]\n  * Renamed Changes.v2 to Changes-v2.md\n  * Housecleaning for lint action.\n  * While v2 was not affected, ported over equivalent test for #681 to catch\n    regressions in the future.\n  * Please note that there is no stability guarantees on pre-releases.\n\nv2.0.0-alpha1 - 04 Apr 2022\n  * Initial pre-release of v2 line. Please note that there is no stability guarantees\n    on pre-releases.\n", "package jws_test\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"encoding/asn1\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/lestrrat-go/httprc\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/base64\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/json\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/jwxtest\"\n\t\"github.com/lestrrat-go/jwx/v2/jwa\"\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\t\"github.com/lestrrat-go/jwx/v2/jws\"\n\t\"github.com/lestrrat-go/jwx/v2/jwt\"\n\t\"github.com/lestrrat-go/jwx/v2/x25519\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst examplePayload = `{\"iss\":\"joe\",` + \"\\r\\n\" + ` \"exp\":1300819380,` + \"\\r\\n\" + ` \"http://example.com/is_root\":true}`\nconst exampleCompactSerialization = `eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk`\nconst badValue = \"%badvalue%\"\n\nvar hasES256K bool\n\nfunc TestSanity(t *testing.T) {\n\tt.Run(\"sanity: Verify with single key\", func(t *testing.T) {\n\t\tkey, err := jwk.ParseKey([]byte(`{\n    \"kty\": \"oct\",\n    \"k\": \"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow\"\n  }`))\n\t\trequire.NoError(t, err, `jwk.ParseKey should succeed`)\n\t\tpayload, err := jws.Verify([]byte(exampleCompactSerialization), jws.WithKey(jwa.HS256, key))\n\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\trequire.Equal(t, []byte(examplePayload), payload, `payloads should match`)\n\t})\n}\n\nfunc TestParseReader(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"Empty []byte\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t_, err := jws.Parse(nil)\n\t\trequire.Error(t, err, \"Parsing an empty byte slice should result in an error\")\n\t})\n\tt.Run(\"Empty bytes.Buffer\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t_, err := jws.ParseReader(&bytes.Buffer{})\n\t\trequire.Error(t, err, \"Parsing an empty buffer should result in an error\")\n\t})\n\tt.Run(\"Compact detached payload\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsplit := strings.Split(exampleCompactSerialization, \".\")\n\t\tincoming := strings.Join([]string{split[0], \"\", split[2]}, \".\")\n\t\t_, err := jws.ParseString(incoming)\n\t\trequire.NoError(t, err, `jws.ParseString should succeed`)\n\t})\n\tt.Run(\"Compact missing header\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tincoming := strings.Join(\n\t\t\t(strings.Split(\n\t\t\t\texampleCompactSerialization,\n\t\t\t\t\".\",\n\t\t\t))[:2],\n\t\t\t\".\",\n\t\t)\n\n\t\tfor _, useReader := range []bool{true, false} {\n\t\t\tvar err error\n\t\t\tif useReader {\n\t\t\t\t// Force ParseReader() to choose un-optimized path by using bufio.NewReader\n\t\t\t\t_, err = jws.ParseReader(bufio.NewReader(strings.NewReader(incoming)))\n\t\t\t} else {\n\t\t\t\t_, err = jws.ParseString(incoming)\n\t\t\t}\n\t\t\trequire.Error(t, err, \"Parsing compact serialization with less than 3 parts should be an error\")\n\t\t}\n\t})\n\tt.Run(\"Compact bad header\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tparts := strings.Split(exampleCompactSerialization, \".\")\n\t\tparts[0] = badValue\n\t\tincoming := strings.Join(parts, \".\")\n\n\t\tfor _, useReader := range []bool{true, false} {\n\t\t\tvar err error\n\t\t\tif useReader {\n\t\t\t\t_, err = jws.ParseReader(bufio.NewReader(strings.NewReader(incoming)))\n\t\t\t} else {\n\t\t\t\t_, err = jws.ParseString(incoming)\n\t\t\t}\n\t\t\trequire.Error(t, err, \"Parsing compact serialization with bad header should be an error\")\n\t\t}\n\t})\n\tt.Run(\"Compact bad payload\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tparts := strings.Split(exampleCompactSerialization, \".\")\n\t\tparts[1] = badValue\n\t\tincoming := strings.Join(parts, \".\")\n\n\t\tfor _, useReader := range []bool{true, false} {\n\t\t\tvar err error\n\t\t\tif useReader {\n\t\t\t\t_, err = jws.ParseReader(bufio.NewReader(strings.NewReader(incoming)))\n\t\t\t} else {\n\t\t\t\t_, err = jws.ParseString(incoming)\n\t\t\t}\n\t\t\trequire.Error(t, err, \"Parsing compact serialization with bad payload should be an error\")\n\t\t}\n\t})\n\tt.Run(\"Compact bad signature\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tparts := strings.Split(exampleCompactSerialization, \".\")\n\t\tparts[2] = badValue\n\t\tincoming := strings.Join(parts, \".\")\n\n\t\tfor _, useReader := range []bool{true, false} {\n\t\t\tvar err error\n\t\t\tif useReader {\n\t\t\t\t_, err = jws.ParseReader(bufio.NewReader(strings.NewReader(incoming)))\n\t\t\t} else {\n\t\t\t\t_, err = jws.ParseString(incoming)\n\t\t\t}\n\t\t\trequire.Error(t, err, \"Parsing compact serialization with bad signature should be an error\")\n\t\t}\n\t})\n}\n\ntype dummyCryptoSigner struct {\n\traw crypto.Signer\n}\n\nfunc (s *dummyCryptoSigner) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error) {\n\treturn s.raw.Sign(rand, digest, opts)\n}\n\nfunc (s *dummyCryptoSigner) Public() crypto.PublicKey {\n\treturn s.raw.Public()\n}\n\nvar _ crypto.Signer = &dummyCryptoSigner{}\n\ntype dummyECDSACryptoSigner struct {\n\traw *ecdsa.PrivateKey\n}\n\nfunc (es *dummyECDSACryptoSigner) Public() crypto.PublicKey {\n\treturn es.raw.Public()\n}\n\nfunc (es *dummyECDSACryptoSigner) Sign(rand io.Reader, digest []byte, _ crypto.SignerOpts) ([]byte, error) {\n\t// The implementation is the same as ecdsaCryptoSigner.\n\t// This is just here to test the interface conversion\n\tr, s, err := ecdsa.Sign(rand, es.raw, digest)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`failed to sign payload using ecdsa: %w`, err)\n\t}\n\n\treturn asn1.Marshal(struct {\n\t\tR *big.Int\n\t\tS *big.Int\n\t}{R: r, S: s})\n}\n\nvar _ crypto.Signer = &dummyECDSACryptoSigner{}\n\nfunc testRoundtrip(t *testing.T, payload []byte, alg jwa.SignatureAlgorithm, signKey interface{}, keys map[string]interface{}) {\n\tjwkKey, err := jwk.FromRaw(signKey)\n\trequire.NoError(t, err, `jwk.New should succeed`)\n\tsignKeys := []struct {\n\t\tName string\n\t\tKey  interface{}\n\t}{\n\t\t{\n\t\t\tName: \"Raw Key\",\n\t\t\tKey:  signKey,\n\t\t},\n\t\t{\n\t\t\tName: \"JWK Key\",\n\t\t\tKey:  jwkKey,\n\t\t},\n\t}\n\n\tif es, ok := signKey.(*ecdsa.PrivateKey); ok {\n\t\tsignKeys = append(signKeys, struct {\n\t\t\tName string\n\t\t\tKey  interface{}\n\t\t}{\n\t\t\tName: \"crypto.Hash\",\n\t\t\tKey:  &dummyECDSACryptoSigner{raw: es},\n\t\t})\n\t} else if cs, ok := signKey.(crypto.Signer); ok {\n\t\tsignKeys = append(signKeys, struct {\n\t\t\tName string\n\t\t\tKey  interface{}\n\t\t}{\n\t\t\tName: \"crypto.Hash\",\n\t\t\tKey:  &dummyCryptoSigner{raw: cs},\n\t\t})\n\t}\n\n\tfor _, key := range signKeys {\n\t\tkey := key\n\t\tt.Run(key.Name, func(t *testing.T) {\n\t\t\tsigned, err := jws.Sign(payload, jws.WithKey(alg, key.Key))\n\t\t\trequire.NoError(t, err, \"jws.Sign should succeed\")\n\n\t\t\tparsers := map[string]func([]byte) (*jws.Message, error){\n\t\t\t\t\"ParseReader(io.Reader)\": func(b []byte) (*jws.Message, error) { return jws.ParseReader(bufio.NewReader(bytes.NewReader(b))) },\n\t\t\t\t\"Parse([]byte)\":          func(b []byte) (*jws.Message, error) { return jws.Parse(b) },\n\t\t\t\t\"ParseString(string)\":    func(b []byte) (*jws.Message, error) { return jws.ParseString(string(b)) },\n\t\t\t}\n\t\t\tfor name, f := range parsers {\n\t\t\t\tname := name\n\t\t\t\tf := f\n\t\t\t\tt.Run(name, func(t *testing.T) {\n\t\t\t\t\tt.Parallel()\n\t\t\t\t\tm, err := f(signed)\n\t\t\t\t\trequire.NoError(t, err, \"(%s) %s is successful\", alg, name)\n\t\t\t\t\trequire.Equal(t, payload, m.Payload(), \"(%s) %s: Payload is decoded\", alg, name)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tfor name, testKey := range keys {\n\t\t\t\tname := name\n\t\t\t\ttestKey := testKey\n\t\t\t\tt.Run(name, func(t *testing.T) {\n\t\t\t\t\tverified, err := jws.Verify(signed, jws.WithKey(alg, testKey))\n\t\t\t\t\trequire.NoError(t, err, \"(%s) Verify is successful\", alg)\n\t\t\t\t\trequire.Equal(t, payload, verified, \"(%s) Verified payload is the same\", alg)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRoundtrip(t *testing.T) {\n\tt.Parallel()\n\tpayload := []byte(\"Lorem ipsum\")\n\n\tt.Run(\"HMAC\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsharedkey := []byte(\"Avracadabra\")\n\t\tjwkKey, _ := jwk.FromRaw(sharedkey)\n\t\tkeys := map[string]interface{}{\n\t\t\t\"[]byte\":  sharedkey,\n\t\t\t\"jwk.Key\": jwkKey,\n\t\t}\n\t\thmacAlgorithms := []jwa.SignatureAlgorithm{jwa.HS256, jwa.HS384, jwa.HS512}\n\t\tfor _, alg := range hmacAlgorithms {\n\t\t\talg := alg\n\t\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttestRoundtrip(t, payload, alg, sharedkey, keys)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"ECDSA\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tkey, err := jwxtest.GenerateEcdsaKey(jwa.P521)\n\t\trequire.NoError(t, err, \"ECDSA key generated\")\n\t\tjwkKey, _ := jwk.FromRaw(key.PublicKey)\n\t\tkeys := map[string]interface{}{\n\t\t\t\"Verify(ecdsa.PublicKey)\":  key.PublicKey,\n\t\t\t\"Verify(*ecdsa.PublicKey)\": &key.PublicKey,\n\t\t\t\"Verify(jwk.Key)\":          jwkKey,\n\t\t}\n\t\tfor _, alg := range []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512} {\n\t\t\talg := alg\n\t\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttestRoundtrip(t, payload, alg, key, keys)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"RSA\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tkey, err := jwxtest.GenerateRsaKey()\n\t\trequire.NoError(t, err, \"RSA key generated\")\n\t\tjwkKey, _ := jwk.FromRaw(key.PublicKey)\n\t\tkeys := map[string]interface{}{\n\t\t\t\"Verify(rsa.PublicKey)\":  key.PublicKey,\n\t\t\t\"Verify(*rsa.PublicKey)\": &key.PublicKey,\n\t\t\t\"Verify(jwk.Key)\":        jwkKey,\n\t\t}\n\t\tfor _, alg := range []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512} {\n\t\t\talg := alg\n\t\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttestRoundtrip(t, payload, alg, key, keys)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"EdDSA\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tkey, err := jwxtest.GenerateEd25519Key()\n\t\trequire.NoError(t, err, \"ed25519 key generated\")\n\t\tpubkey := key.Public()\n\t\tjwkKey, _ := jwk.FromRaw(pubkey)\n\t\tkeys := map[string]interface{}{\n\t\t\t\"Verify(ed25519.Public())\": pubkey,\n\t\t\t// Meh, this doesn't work\n\t\t\t// \"Verify(*ed25519.Public())\": &pubkey,\n\t\t\t\"Verify(jwk.Key)\": jwkKey,\n\t\t}\n\t\tfor _, alg := range []jwa.SignatureAlgorithm{jwa.EdDSA} {\n\t\t\talg := alg\n\t\t\tt.Run(alg.String(), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttestRoundtrip(t, payload, alg, key, keys)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestSignMulti2(t *testing.T) {\n\tsharedkey := []byte(\"Avracadabra\")\n\tpayload := []byte(\"Lorem ipsum\")\n\thmacAlgorithms := []jwa.SignatureAlgorithm{jwa.HS256, jwa.HS384, jwa.HS512}\n\tvar signed []byte\n\tt.Run(\"Sign\", func(t *testing.T) {\n\t\tvar options = []jws.SignOption{jws.WithJSON()}\n\t\tfor _, alg := range hmacAlgorithms {\n\t\t\toptions = append(options, jws.WithKey(alg, sharedkey)) // (signer, sharedkey, nil, nil))\n\t\t}\n\t\tvar err error\n\t\tsigned, err = jws.Sign(payload, options...)\n\t\trequire.NoError(t, err, `jws.SignMulti should succeed`)\n\t})\n\tfor _, alg := range hmacAlgorithms {\n\t\talg := alg\n\t\tt.Run(\"Verify \"+alg.String(), func(t *testing.T) {\n\t\t\tm := jws.NewMessage()\n\t\t\tverified, err := jws.Verify(signed, jws.WithKey(alg, sharedkey), jws.WithMessage(m))\n\t\t\trequire.NoError(t, err, \"Verify succeeded\")\n\t\t\trequire.Equal(t, payload, verified, \"verified payload matches\")\n\n\t\t\t// XXX This actally doesn't really test much, but if there was anything\n\t\t\t// wrong, the process should have failed well before reaching here\n\t\t\trequire.Equal(t, payload, m.Payload(), \"message payload matches\")\n\t\t})\n\t}\n}\n\nfunc TestEncode(t *testing.T) {\n\tt.Parallel()\n\n\t// HS256Compact tests that https://tools.ietf.org/html/rfc7515#appendix-A.1 works\n\tt.Run(\"HS256Compact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tconst hdr = `{\"typ\":\"JWT\",` + \"\\r\\n\" + ` \"alg\":\"HS256\"}`\n\t\tconst hmacKey = `AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow`\n\t\tconst expected = `eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk`\n\n\t\thmacKeyDecoded, err := base64.DecodeString(hmacKey)\n\t\trequire.NoError(t, err, \"HMAC base64 decoded successful\")\n\n\t\thdrbuf := base64.Encode([]byte(hdr))\n\t\tpayload := base64.Encode([]byte(examplePayload))\n\n\t\tsigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\thdrbuf,\n\t\t\t\tpayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\tsign, err := jws.NewSigner(jwa.HS256)\n\t\trequire.NoError(t, err, \"HMAC signer created successfully\")\n\n\t\tsignature, err := sign.Sign(signingInput, hmacKeyDecoded)\n\t\trequire.NoError(t, err, \"PayloadSign is successful\")\n\t\tsigbuf := base64.Encode(signature)\n\n\t\tencoded := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningInput,\n\t\t\t\tsigbuf,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\t\trequire.Equal(t, expected, string(encoded), \"generated compact serialization should match\")\n\n\t\tmsg, err := jws.ParseReader(bytes.NewReader(encoded))\n\t\trequire.NoError(t, err, \"Parsing compact encoded serialization succeeds\")\n\n\t\tsignatures := msg.Signatures()\n\t\trequire.Len(t, signatures, 1, `there should be exactly one signature`)\n\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.HS256 {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\tv, err := jws.NewVerifier(jwa.HS256)\n\t\trequire.NoError(t, err, \"HmacVerify created\")\n\n\t\trequire.NoError(t, v.Verify(signingInput, signature, hmacKeyDecoded), \"Verify succeeds\")\n\t})\n\tt.Run(\"ES512Compact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t// ES256Compact tests that https://tools.ietf.org/html/rfc7515#appendix-A.3 works\n\t\thdr := []byte{123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 53, 49, 50, 34, 125}\n\t\tconst jwksrc = `{\n\"kty\":\"EC\",\n\"crv\":\"P-521\",\n\"x\":\"AekpBQ8ST8a8VcfVOTNl353vSrDCLLJXmPk06wTjxrrjcBpXp5EOnYG_NjFZ6OvLFV1jSfS9tsz4qUxcWceqwQGk\",\n\"y\":\"ADSmRA43Z1DSNx_RvcLI87cdL07l6jQyyBXMoxVg_l2Th-x3S1WDhjDly79ajL4Kkd0AZMaZmh9ubmf63e3kyMj2\",\n\"d\":\"AY5pb7A0UFiB3RELSD64fTLOSV_jazdF7fLYyuTw8lOfRhWg6Y6rUrPAxerEzgdRhajnu0ferB0d53vM9mE15j2C\"\n}`\n\n\t\t// \"Payload\"\n\t\tjwsPayload := []byte{80, 97, 121, 108, 111, 97, 100}\n\n\t\tstandardHeaders := jws.NewHeaders()\n\t\trequire.NoError(t, json.Unmarshal(hdr, standardHeaders), `parsing headers should succeed`)\n\n\t\talg := standardHeaders.Algorithm()\n\n\t\tjwkKey, err := jwk.ParseKey([]byte(jwksrc))\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to parse JWK\")\n\t\t}\n\t\tvar key interface{}\n\t\trequire.NoError(t, jwkKey.Raw(&key), `jwk.Raw should succeed`)\n\t\tvar jwsCompact []byte\n\t\tjwsCompact, err = jws.Sign(jwsPayload, jws.WithKey(alg, key))\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to sign message\")\n\t\t}\n\n\t\t// Verify with standard ecdsa library\n\t\t_, _, jwsSignature, err := jws.SplitCompact(jwsCompact)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to split compact JWT\")\n\t\t}\n\n\t\tdecodedJwsSignature, err := base64.Decode(jwsSignature)\n\t\trequire.NoError(t, err, `base64.Decode should succeed`)\n\t\tr, s := &big.Int{}, &big.Int{}\n\t\tn := len(decodedJwsSignature) / 2\n\t\tr.SetBytes(decodedJwsSignature[:n])\n\t\ts.SetBytes(decodedJwsSignature[n:])\n\t\tsigningHdr := base64.Encode(hdr)\n\t\tsigningPayload := base64.Encode(jwsPayload)\n\n\t\tjwsSigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningHdr,\n\t\t\t\tsigningPayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\t\thashed512 := sha512.Sum512(jwsSigningInput)\n\t\tecdsaPrivateKey := key.(*ecdsa.PrivateKey)\n\t\trequire.True(t, ecdsa.Verify(&ecdsaPrivateKey.PublicKey, hashed512[:], r, s), \"ecdsa.Verify should succeed\")\n\n\t\t// Verify with API library\n\t\tpublicKey, err := jwk.PublicRawKeyOf(key)\n\t\trequire.NoError(t, err, `jwk.PublicRawKeyOf should succeed`)\n\t\tverifiedPayload, err := jws.Verify(jwsCompact, jws.WithKey(alg, publicKey))\n\t\tif err != nil || string(verifiedPayload) != string(jwsPayload) {\n\t\t\tt.Fatal(\"Failed to verify message\")\n\t\t}\n\t})\n\tt.Run(\"RS256Compact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t// RS256Compact tests that https://tools.ietf.org/html/rfc7515#appendix-A.2 works\n\t\tconst hdr = `{\"alg\":\"RS256\"}`\n\t\tconst expected = `eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw`\n\t\tconst jwksrc = `{\n    \"kty\":\"RSA\",\n    \"n\":\"ofgWCuLjybRlzo0tZWJjNiuSfb4p4fAkd_wWJcyQoTbji9k0l8W26mPddxHmfHQp-Vaw-4qPCJrcS2mJPMEzP1Pt0Bm4d4QlL-yRT-SFd2lZS-pCgNMsD1W_YpRPEwOWvG6b32690r2jZ47soMZo9wGzjb_7OMg0LOL-bSf63kpaSHSXndS5z5rexMdbBYUsLA9e-KXBdQOS-UTo7WTBEMa2R2CapHg665xsmtdVMTBQY4uDZlxvb3qCo5ZwKh9kG4LT6_I5IhlJH7aGhyxXFvUK-DWNmoudF8NAco9_h9iaGNj8q2ethFkMLs91kzk2PAcDTW9gb54h4FRWyuXpoQ\",\n    \"e\":\"AQAB\",\n    \"d\":\"Eq5xpGnNCivDflJsRQBXHx1hdR1k6Ulwe2JZD50LpXyWPEAeP88vLNO97IjlA7_GQ5sLKMgvfTeXZx9SE-7YwVol2NXOoAJe46sui395IW_GO-pWJ1O0BkTGoVEn2bKVRUCgu-GjBVaYLU6f3l9kJfFNS3E0QbVdxzubSu3Mkqzjkn439X0M_V51gfpRLI9JYanrC4D4qAdGcopV_0ZHHzQlBjudU2QvXt4ehNYTCBr6XCLQUShb1juUO1ZdiYoFaFQT5Tw8bGUl_x_jTj3ccPDVZFD9pIuhLhBOneufuBiB4cS98l2SR_RQyGWSeWjnczT0QU91p1DhOVRuOopznQ\",\n    \"p\":\"4BzEEOtIpmVdVEZNCqS7baC4crd0pqnRH_5IB3jw3bcxGn6QLvnEtfdUdiYrqBdss1l58BQ3KhooKeQTa9AB0Hw_Py5PJdTJNPY8cQn7ouZ2KKDcmnPGBY5t7yLc1QlQ5xHdwW1VhvKn-nXqhJTBgIPgtldC-KDV5z-y2XDwGUc\",\n    \"q\":\"uQPEfgmVtjL0Uyyx88GZFF1fOunH3-7cepKmtH4pxhtCoHqpWmT8YAmZxaewHgHAjLYsp1ZSe7zFYHj7C6ul7TjeLQeZD_YwD66t62wDmpe_HlB-TnBA-njbglfIsRLtXlnDzQkv5dTltRJ11BKBBypeeF6689rjcJIDEz9RWdc\",\n    \"dp\":\"BwKfV3Akq5_MFZDFZCnW-wzl-CCo83WoZvnLQwCTeDv8uzluRSnm71I3QCLdhrqE2e9YkxvuxdBfpT_PI7Yz-FOKnu1R6HsJeDCjn12Sk3vmAktV2zb34MCdy7cpdTh_YVr7tss2u6vneTwrA86rZtu5Mbr1C1XsmvkxHQAdYo0\",\n    \"dq\":\"h_96-mK1R_7glhsum81dZxjTnYynPbZpHziZjeeHcXYsXaaMwkOlODsWa7I9xXDoRwbKgB719rrmI2oKr6N3Do9U0ajaHF-NKJnwgjMd2w9cjz3_-kyNlxAr2v4IKhGNpmM5iIgOS1VZnOZ68m6_pbLBSp3nssTdlqvd0tIiTHU\",\n    \"qi\":\"IYd7DHOhrWvxkwPQsRM2tOgrjbcrfvtQJipd-DlcxyVuuM9sQLdgjVk2oy26F0EmpScGLq2MowX7fhd_QJQ3ydy5cY7YIBi87w93IKLEdfnbJtoOPLUW0ITrJReOgo1cq9SbsxYawBgfp_gh6A5603k2-ZQwVK0JKSHuLFkuQ3U\"\n  }`\n\n\t\tprivkey, err := jwk.ParseKey([]byte(jwksrc))\n\t\trequire.NoError(t, err, `parsing jwk should be successful`)\n\n\t\tvar rawkey rsa.PrivateKey\n\t\trequire.NoError(t, privkey.Raw(&rawkey), `obtaining raw key should succeed`)\n\n\t\tsign, err := jws.NewSigner(jwa.RS256)\n\t\trequire.NoError(t, err, \"RsaSign created successfully\")\n\n\t\thdrbuf := base64.Encode([]byte(hdr))\n\t\tpayload := base64.Encode([]byte(examplePayload))\n\t\tsigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\thdrbuf,\n\t\t\t\tpayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\t\tsignature, err := sign.Sign(signingInput, rawkey)\n\t\trequire.NoError(t, err, \"PayloadSign is successful\")\n\t\tsigbuf := base64.Encode(signature)\n\n\t\tencoded := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningInput,\n\t\t\t\tsigbuf,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\trequire.Equal(t, expected, string(encoded), \"generated compact serialization should match\")\n\n\t\tmsg, err := jws.ParseReader(bytes.NewReader(encoded))\n\t\trequire.NoError(t, err, \"Parsing compact encoded serialization succeeds\")\n\n\t\tsignatures := msg.Signatures()\n\t\trequire.Len(t, signatures, 1, `there should be exactly one signature`)\n\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.RS256 {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\tv, err := jws.NewVerifier(jwa.RS256)\n\t\trequire.NoError(t, err, \"Verify created\")\n\t\trequire.NoError(t, v.Verify(signingInput, signature, rawkey.PublicKey), \"Verify succeeds\")\n\t})\n\tt.Run(\"ES256Compact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t// ES256Compact tests that https://tools.ietf.org/html/rfc7515#appendix-A.3 works\n\t\tconst hdr = `{\"alg\":\"ES256\"}`\n\t\tconst jwksrc = `{\n    \"kty\":\"EC\",\n    \"crv\":\"P-256\",\n    \"x\":\"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU\",\n    \"y\":\"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0\",\n    \"d\":\"jpsQnnGQmL-YBIffH1136cspYG6-0iY7X1fCE9-E9LI\"\n  }`\n\t\tprivkey, err := jwk.ParseKey([]byte(jwksrc))\n\t\trequire.NoError(t, err, `parsing jwk should succeed`)\n\n\t\tvar rawkey ecdsa.PrivateKey\n\t\trequire.NoError(t, privkey.Raw(&rawkey), `obtaining raw key should succeed`)\n\n\t\tsigner, err := jws.NewSigner(jwa.ES256)\n\t\trequire.NoError(t, err, \"RsaSign created successfully\")\n\n\t\thdrbuf := base64.Encode([]byte(hdr))\n\t\tpayload := base64.Encode([]byte(examplePayload))\n\t\tsigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\thdrbuf,\n\t\t\t\tpayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\t\tsignature, err := signer.Sign(signingInput, &rawkey)\n\t\trequire.NoError(t, err, \"PayloadSign is successful\")\n\t\tsigbuf := base64.Encode(signature)\n\t\trequire.NoError(t, err, \"base64 encode successful\")\n\n\t\tencoded := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningInput,\n\t\t\t\tsigbuf,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\t// The signature contains random factor, so unfortunately we can't match\n\t\t// the output against a fixed expected outcome. We'll wave doing an\n\t\t// exact match, and just try to verify using the signature\n\n\t\tmsg, err := jws.ParseReader(bytes.NewReader(encoded))\n\t\trequire.NoError(t, err, \"Parsing compact encoded serialization succeeds\")\n\n\t\tsignatures := msg.Signatures()\n\t\trequire.Len(t, signatures, 1, `there should be exactly one signature`)\n\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.ES256 {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\tv, err := jws.NewVerifier(jwa.ES256)\n\t\trequire.NoError(t, err, \"EcdsaVerify created\")\n\t\trequire.NoError(t, v.Verify(signingInput, signature, rawkey.PublicKey), \"Verify succeeds\")\n\t})\n\tt.Run(\"EdDSACompact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t// EdDSACompact tests that https://tools.ietf.org/html/rfc8037#appendix-A.1-5 works\n\t\tconst hdr = `{\"alg\":\"EdDSA\"}`\n\t\tconst jwksrc = `{\n    \"kty\":\"OKP\",\n    \"crv\":\"Ed25519\",\n    \"d\":\"nWGxne_9WmC6hEr0kuwsxERJxWl7MmkZcDusAxyuf2A\",\n    \"x\":\"11qYAYKxCrfVS_7TyWQHOg7hcvPapiMlrwIaaPcHURo\"\n  }`\n\t\tconst examplePayload = `Example of Ed25519 signing`\n\t\tconst expected = `hgyY0il_MGCjP0JzlnLWG1PPOt7-09PGcvMg3AIbQR6dWbhijcNR4ki4iylGjg5BhVsPt9g7sVvpAr_MuM0KAg`\n\t\texpectedDecoded, err := base64.Decode([]byte(expected))\n\t\trequire.NoError(t, err, \"Expected Signature decode successful\")\n\n\t\tprivkey, err := jwk.ParseKey([]byte(jwksrc))\n\t\trequire.NoError(t, err, `parsing jwk should succeed`)\n\n\t\tvar rawkey ed25519.PrivateKey\n\t\trequire.NoError(t, privkey.Raw(&rawkey), `obtaining raw key should succeed`)\n\n\t\tsigner, err := jws.NewSigner(jwa.EdDSA)\n\t\trequire.NoError(t, err, \"EdDSASign created successfully\")\n\n\t\thdrbuf := base64.Encode([]byte(hdr))\n\t\tpayload := base64.Encode([]byte(examplePayload))\n\t\tsigningInput := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\thdrbuf,\n\t\t\t\tpayload,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\tsignature, err := signer.Sign(signingInput, rawkey)\n\t\trequire.NoError(t, err, \"PayloadSign is successful\")\n\t\tsigbuf := base64.Encode(signature)\n\t\tencoded := bytes.Join(\n\t\t\t[][]byte{\n\t\t\t\tsigningInput,\n\t\t\t\tsigbuf,\n\t\t\t},\n\t\t\t[]byte{'.'},\n\t\t)\n\n\t\t// The signature contains random factor, so unfortunately we can't match\n\t\t// the output against a fixed expected outcome. We'll wave doing an\n\t\t// exact match, and just try to verify using the signature\n\n\t\tmsg, err := jws.ParseReader(bytes.NewReader(encoded))\n\t\trequire.NoError(t, err, \"Parsing compact encoded serialization succeeds\")\n\n\t\tsignatures := msg.Signatures()\n\t\trequire.Len(t, signatures, 1, `there should be exactly one signature`)\n\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.EdDSA {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\tv, err := jws.NewVerifier(jwa.EdDSA)\n\t\trequire.NoError(t, err, \"EcdsaVerify created\")\n\t\trequire.NoError(t, v.Verify(signingInput, signature, rawkey.Public()), \"Verify succeeds\")\n\t\trequire.Equal(t, signature, expectedDecoded, \"signatures match\")\n\t})\n\tt.Run(\"UnsecuredCompact\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ts := `eyJhbGciOiJub25lIn0.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.`\n\n\t\tm, err := jws.ParseReader(strings.NewReader(s))\n\t\trequire.NoError(t, err, \"Parsing compact serialization\")\n\n\t\t{\n\t\t\tv := map[string]interface{}{}\n\t\t\trequire.NoError(t, json.Unmarshal(m.Payload(), &v), \"Unmarshal payload\")\n\t\t\trequire.Equal(t, v[\"iss\"], \"joe\", \"iss matches\")\n\t\t\trequire.Equal(t, int(v[\"exp\"].(float64)), 1300819380, \"exp matches\")\n\t\t\trequire.Equal(t, v[\"http://example.com/is_root\"], true, \"'http://example.com/is_root' matches\")\n\t\t}\n\n\t\trequire.Len(t, m.Signatures(), 1, \"There should be 1 signature\")\n\n\t\tsignatures := m.Signatures()\n\t\talgorithm := signatures[0].ProtectedHeaders().Algorithm()\n\t\tif algorithm != jwa.NoSignature {\n\t\t\tt.Fatal(\"Algorithm in header does not match\")\n\t\t}\n\n\t\trequire.Empty(t, signatures[0].Signature(), \"Signature should be empty\")\n\t})\n\tt.Run(\"CompleteJSON\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ts := `{\n    \"payload\": \"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\",\n    \"signatures\":[\n      {\n        \"header\": {\"kid\":\"2010-12-29\"},\n        \"protected\":\"eyJhbGciOiJSUzI1NiJ9\",\n        \"signature\": \"cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw\"\n      },\n      {\n        \"header\": {\"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"},\n        \"protected\":\"eyJhbGciOiJFUzI1NiJ9\",\n        \"signature\": \"DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q\"\n      }\n    ]\n  }`\n\n\t\tm, err := jws.ParseReader(strings.NewReader(s))\n\t\trequire.NoError(t, err, \"Unmarshal complete json serialization\")\n\t\trequire.Len(t, m.Signatures(), 2, \"There should be 2 signatures\")\n\n\t\tsigs := m.LookupSignature(\"2010-12-29\")\n\t\trequire.Len(t, sigs, 1, \"There should be 1 signature with kid = '2010-12-29'\")\n\t})\n\tt.Run(\"Protected Header lookup\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ts := `{\n    \"payload\": \"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\",\n    \"signatures\":[\n      {\n        \"header\": {\"cty\":\"example\"},\n        \"protected\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6ImU5YmMwOTdhLWNlNTEtNDAzNi05NTYyLWQyYWRlODgyZGIwZCJ9\",\n        \"signature\": \"JcLb1udPAV72TayGv6eawZKlIQQ3K1NzB0fU7wwYoFypGxEczdCQU-V9jp4WwY2ueJKYeE4fF6jigB0PdSKR0Q\"\n      }\n    ]\n  }`\n\n\t\t// Protected Header is {\"alg\":\"ES256\",\"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"}\n\t\t// This protected header combination forces the parser/unmarshal to go trough the code path to populate and look for protected header fields.\n\t\t// The signature is valid.\n\n\t\tm, err := jws.ParseReader(strings.NewReader(s))\n\t\trequire.NoError(t, err, \"Unmarshal complete json serialization\")\n\t\trequire.Len(t, m.Signatures(), 1, \"There should be 1 signature\")\n\n\t\tsigs := m.LookupSignature(\"e9bc097a-ce51-4036-9562-d2ade882db0d\")\n\t\trequire.Len(t, sigs, 1, \"There should be 1 signature with kid = '2010-12-29'\")\n\t})\n\tt.Run(\"FlattenedJSON\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ts := `{\n    \"payload\": \"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\",\n    \"protected\":\"eyJhbGciOiJFUzI1NiJ9\",\n    \"header\": {\n      \"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"\n    },\n    \"signature\": \"DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q\"\n  }`\n\n\t\tm, err := jws.ParseReader(strings.NewReader(s))\n\t\trequire.NoError(t, err, \"Parsing flattened json serialization\")\n\t\trequire.Len(t, m.Signatures(), 1, \"There should be 1 signature\")\n\n\t\tjsonbuf, _ := json.MarshalIndent(m, \"\", \"  \")\n\t\tt.Logf(\"%s\", jsonbuf)\n\t})\n\tt.Run(\"SplitCompact\", func(t *testing.T) {\n\t\ttestcases := []struct {\n\t\t\tName string\n\t\t\tSize int\n\t\t}{\n\t\t\t{Name: \"Short\", Size: 100},\n\t\t\t{Name: \"Long\", Size: 8000},\n\t\t}\n\t\tfor _, tc := range testcases {\n\t\t\tsize := tc.Size\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\t// Create payload with X.Y.Z\n\t\t\t\tvar payload []byte\n\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\tpayload = append(payload, 'X')\n\t\t\t\t}\n\t\t\t\tpayload = append(payload, '.')\n\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\tpayload = append(payload, 'Y')\n\t\t\t\t}\n\t\t\t\tpayload = append(payload, '.')\n\n\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\tpayload = append(payload, 'Y')\n\t\t\t\t}\n\n\t\t\t\t// Test using bytes, reader optimized and non-optimized path\n\t\t\t\tfor _, method := range []int{0, 1, 2} {\n\t\t\t\t\tvar x, y, z []byte\n\t\t\t\t\tvar err error\n\t\t\t\t\tswitch method {\n\t\t\t\t\tcase 0: // bytes\n\t\t\t\t\t\tx, y, z, err = jws.SplitCompact(payload)\n\t\t\t\t\tcase 1: // un-optimized io.Reader\n\t\t\t\t\t\tx, y, z, err = jws.SplitCompactReader(bytes.NewReader(payload))\n\t\t\t\t\tdefault: // optimized io.Reader\n\t\t\t\t\t\tx, y, z, err = jws.SplitCompactReader(bufio.NewReader(bytes.NewReader(payload)))\n\t\t\t\t\t}\n\t\t\t\t\trequire.NoError(t, err, \"SplitCompact should succeed\")\n\t\t\t\t\trequire.Len(t, x, size, \"Length of header\")\n\t\t\t\t\trequire.Len(t, y, size, \"Length of payload\")\n\t\t\t\t\trequire.Len(t, z, size, \"Length of signature\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestPublicHeaders(t *testing.T) {\n\tkey, err := jwxtest.GenerateRsaKey()\n\trequire.NoError(t, err, \"GenerateKey should succeed\")\n\n\tsigner, err := jws.NewSigner(jwa.RS256)\n\trequire.NoError(t, err, \"jws.NewSigner should succeed\")\n\t_ = signer // TODO\n\n\tpubkey := key.PublicKey\n\tpubjwk, err := jwk.FromRaw(&pubkey)\n\trequire.NoError(t, err, \"NewRsaPublicKey should succeed\")\n\t_ = pubjwk // TODO\n}\n\nfunc TestDecode_ES384Compact_NoSigTrim(t *testing.T) {\n\tincoming := \"eyJhbGciOiJFUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6IjE5MzFmZTQ0YmFhMWNhZTkyZWUzNzYzOTQ0MDU1OGMwODdlMTRlNjk5ZWU5NjVhM2Q1OGU1MmU2NGY4MDE0NWIifQ.eyJpc3MiOiJicmt0LWNsaS0xLjAuN3ByZTEiLCJpYXQiOjE0ODQ2OTU1MjAsImp0aSI6IjgxYjczY2Y3In0.DdFi0KmPHSv4PfIMGcWGMSRLmZsfRPQ3muLFW6Ly2HpiLFFQWZ0VEanyrFV263wjlp3udfedgw_vrBLz3XC8CkbvCo_xeHMzaTr_yfhjoheSj8gWRLwB-22rOnUX_M0A\"\n\tt.Logf(\"incoming = '%s'\", incoming)\n\tconst jwksrc = `{\n    \"kty\":\"EC\",\n    \"crv\":\"P-384\",\n    \"x\":\"YHVZ4gc1RDoqxKm4NzaN_Y1r7R7h3RM3JMteC478apSKUiLVb4UNytqWaLoE6ygH\",\n    \"y\":\"CRKSqP-aYTIsqJfg_wZEEYUayUR5JhZaS2m4NLk2t1DfXZgfApAJ2lBO0vWKnUMp\"\n  }`\n\n\tpubkey, err := jwk.ParseKey([]byte(jwksrc))\n\trequire.NoError(t, err, `parsing jwk should be successful`)\n\n\tvar rawkey ecdsa.PublicKey\n\trequire.NoError(t, pubkey.Raw(&rawkey), `obtaining raw key should succeed`)\n\n\tv, err := jws.NewVerifier(jwa.ES384)\n\trequire.NoError(t, err, \"EcdsaVerify created\")\n\n\tprotected, payload, signature, err := jws.SplitCompact([]byte(incoming))\n\trequire.NoError(t, err, `jws.SplitCompact should succeed`)\n\n\tvar buf bytes.Buffer\n\tbuf.Write(protected)\n\tbuf.WriteByte('.')\n\tbuf.Write(payload)\n\n\tdecodedSignature, err := base64.Decode(signature)\n\trequire.NoError(t, err, `decoding signature should succeed`)\n\trequire.NoError(t, v.Verify(buf.Bytes(), decodedSignature, rawkey), \"Verify succeeds\")\n}\n\nfunc TestReadFile(t *testing.T) {\n\tt.Parallel()\n\n\tf, err := os.CreateTemp(\"\", \"test-read-file-*.jws\")\n\trequire.NoError(t, err, `io.CreateTemp should succeed`)\n\tdefer f.Close()\n\n\tfmt.Fprintf(f, \"%s\", exampleCompactSerialization)\n\n\tif _, err := jws.ReadFile(f.Name()); !assert.NoError(t, err, `jws.ReadFile should succeed`) {\n\t\treturn\n\t}\n}\n\nfunc TestVerifyNonUniqueKid(t *testing.T) {\n\tconst payload = \"Lorem ipsum\"\n\tconst kid = \"notUniqueKid\"\n\tprivateKey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, \"jwxtest.GenerateJwk should succeed\")\n\t_ = privateKey.Set(jwk.KeyIDKey, kid)\n\tsigned, err := jws.Sign([]byte(payload), jws.WithKey(jwa.RS256, privateKey))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\tcorrectKey, _ := jwk.PublicKeyOf(privateKey)\n\t_ = correctKey.Set(jwk.AlgorithmKey, jwa.RS256)\n\n\tmakeSet := func(keys ...jwk.Key) jwk.Set {\n\t\tset := jwk.NewSet()\n\t\tfor _, key := range keys {\n\t\t\t_ = set.AddKey(key)\n\t\t}\n\t\treturn set\n\t}\n\n\ttestcases := []struct {\n\t\tName string\n\t\tKey  func() jwk.Key // Generates the \"wrong\" key\n\t}{\n\t\t{\n\t\t\tName: `match 2 keys via same \"kid\"`,\n\t\t\tKey: func() jwk.Key {\n\t\t\t\tprivateKey, _ := jwxtest.GenerateRsaJwk()\n\t\t\t\twrongKey, _ := jwk.PublicKeyOf(privateKey)\n\t\t\t\t_ = wrongKey.Set(jwk.KeyIDKey, kid)\n\t\t\t\t_ = wrongKey.Set(jwk.AlgorithmKey, jwa.RS256)\n\t\t\t\treturn wrongKey\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: `match 2 keys via same \"kid\", same key value but different alg`,\n\t\t\tKey: func() jwk.Key {\n\t\t\t\twrongKey, _ := correctKey.Clone()\n\t\t\t\t_ = wrongKey.Set(jwk.KeyIDKey, kid)\n\t\t\t\t_ = wrongKey.Set(jwk.AlgorithmKey, jwa.RS512)\n\t\t\t\treturn wrongKey\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: `match 2 keys via same \"kid\", same key type but different alg`,\n\t\t\tKey: func() jwk.Key {\n\t\t\t\tprivateKey, _ := jwxtest.GenerateRsaJwk()\n\t\t\t\twrongKey, _ := jwk.PublicKeyOf(privateKey)\n\t\t\t\t_ = wrongKey.Set(jwk.KeyIDKey, kid)\n\t\t\t\t_ = wrongKey.Set(jwk.AlgorithmKey, jwa.RS512)\n\t\t\t\treturn wrongKey\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: `match 2 keys via same \"kid\" and different key type / alg`,\n\t\t\tKey: func() jwk.Key {\n\t\t\t\tprivateKey, _ := jwxtest.GenerateEcdsaKey(jwa.P256)\n\t\t\t\twrongKey, err := jwk.PublicKeyOf(privateKey)\n\t\t\t\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\t\t\t\t_ = wrongKey.Set(jwk.KeyIDKey, kid)\n\t\t\t\t_ = wrongKey.Set(jwk.AlgorithmKey, jwa.ES256K)\n\t\t\t\treturn wrongKey\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\t\twrongKey, err := tc.Key().Clone()\n\t\trequire.NoError(t, err, `cloning wrong key should succeed`)\n\t\tfor _, set := range []jwk.Set{makeSet(wrongKey, correctKey), makeSet(correctKey, wrongKey)} {\n\t\t\tset := set\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\t// Try matching in different orders\n\t\t\t\tvar usedKey jwk.Key\n\t\t\t\t_, err = jws.Verify(signed, jws.WithKeySet(set, jws.WithMultipleKeysPerKeyID(true)), jws.WithKeyUsed(&usedKey))\n\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\trequire.Equal(t, usedKey, correctKey)\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestVerifySet(t *testing.T) {\n\tt.Parallel()\n\tconst payload = \"Lorem ipsum\"\n\n\tmakeSet := func(privkey jwk.Key) jwk.Set {\n\t\tset := jwk.NewSet()\n\t\tk1, _ := jwk.FromRaw([]byte(\"abracadabra\"))\n\t\tset.AddKey(k1)\n\t\tk2, _ := jwk.FromRaw([]byte(\"opensesame\"))\n\t\tset.AddKey(k2)\n\t\tpubkey, _ := jwk.PublicKeyOf(privkey)\n\t\tpubkey.Set(jwk.AlgorithmKey, jwa.RS256)\n\t\tset.AddKey(pubkey)\n\t\treturn set\n\t}\n\n\tfor _, useJSON := range []bool{true, false} {\n\t\tuseJSON := useJSON\n\t\tt.Run(fmt.Sprintf(\"useJSON=%t\", useJSON), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tt.Run(`match via \"alg\"`, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\tkey, err := jwxtest.GenerateRsaJwk()\n\t\t\t\trequire.NoError(t, err, \"jwxtest.GenerateJwk should succeed\")\n\n\t\t\t\tset := makeSet(key)\n\t\t\t\tsigned, err := jws.Sign([]byte(payload), jws.WithKey(jwa.RS256, key))\n\t\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\t\t\t\tif useJSON {\n\t\t\t\t\tm, err := jws.Parse(signed)\n\t\t\t\t\trequire.NoError(t, err, `jws.Parse should succeed`)\n\t\t\t\t\tsigned, err = json.Marshal(m)\n\t\t\t\t\trequire.NoError(t, err, `json.Marshal should succeed`)\n\t\t\t\t}\n\n\t\t\t\tvar used jwk.Key\n\t\t\t\tverified, err := jws.Verify(signed, jws.WithKeySet(set, jws.WithRequireKid(false)), jws.WithKeyUsed(&used))\n\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\trequire.Equal(t, []byte(payload), verified, `payload should match`)\n\t\t\t\texpected, _ := jwk.PublicKeyOf(key)\n\t\t\t\tthumb1, _ := expected.Thumbprint(crypto.SHA1)\n\t\t\t\tthumb2, _ := used.Thumbprint(crypto.SHA1)\n\t\t\t\trequire.Equal(t, thumb1, thumb2, `keys should match`)\n\t\t\t})\n\t\t\tt.Run(`match via \"kid\"`, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tkey, err := jwxtest.GenerateRsaJwk()\n\t\t\t\trequire.NoError(t, err, \"jwxtest.GenerateJwk should succeed\")\n\t\t\t\tkey.Set(jwk.KeyIDKey, `mykey`)\n\n\t\t\t\tset := makeSet(key)\n\t\t\t\tsigned, err := jws.Sign([]byte(payload), jws.WithKey(jwa.RS256, key))\n\t\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\t\t\t\tif useJSON {\n\t\t\t\t\tm, err := jws.Parse(signed)\n\t\t\t\t\trequire.NoError(t, err, `jws.Parse should succeed`)\n\t\t\t\t\tsigned, err = json.Marshal(m)\n\t\t\t\t\trequire.NoError(t, err, `json.Marshal should succeed`)\n\t\t\t\t}\n\n\t\t\t\tvar used jwk.Key\n\t\t\t\tverified, err := jws.Verify(signed, jws.WithKeySet(set), jws.WithKeyUsed(&used))\n\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\trequire.Equal(t, []byte(payload), verified, `payload should match`)\n\t\t\t\texpected, _ := jwk.PublicKeyOf(key)\n\t\t\t\tthumb1, _ := expected.Thumbprint(crypto.SHA1)\n\t\t\t\tthumb2, _ := used.Thumbprint(crypto.SHA1)\n\t\t\t\trequire.Equal(t, thumb1, thumb2, `keys should match`)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestCustomField(t *testing.T) {\n\t// XXX has global effect!!!\n\tjws.RegisterCustomField(`x-birthday`, time.Time{})\n\tdefer jws.RegisterCustomField(`x-birthday`, nil)\n\n\texpected := time.Date(2015, 11, 4, 5, 12, 52, 0, time.UTC)\n\tbdaybytes, _ := expected.MarshalText() // RFC3339\n\n\tpayload := \"Hello, World!\"\n\tprivkey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk() should succeed`)\n\n\thdrs := jws.NewHeaders()\n\thdrs.Set(`x-birthday`, string(bdaybytes))\n\n\tsigned, err := jws.Sign([]byte(payload), jws.WithKey(jwa.RS256, privkey, jws.WithProtectedHeaders(hdrs)))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\tt.Run(\"jws.Parse + json.Unmarshal\", func(t *testing.T) {\n\t\tmsg, err := jws.Parse(signed)\n\t\trequire.NoError(t, err, `jws.Parse should succeed`)\n\n\t\tv, ok := msg.Signatures()[0].ProtectedHeaders().Get(`x-birthday`)\n\t\trequire.True(t, ok, `msg.Signatures()[0].ProtectedHeaders().Get(\"x-birthday\") should succeed`)\n\t\trequire.Equal(t, expected, v, `values should match`)\n\n\t\t// Create JSON from jws.Message\n\t\tbuf, err := json.Marshal(msg)\n\t\trequire.NoError(t, err, `json.Marshal should succeed`)\n\n\t\tvar msg2 jws.Message\n\t\trequire.NoError(t, json.Unmarshal(buf, &msg2), `json.Unmarshal should succeed`)\n\n\t\tv, ok = msg2.Signatures()[0].ProtectedHeaders().Get(`x-birthday`)\n\t\trequire.True(t, ok, `msg2.Signatures()[0].ProtectedHeaders().Get(\"x-birthday\") should succeed`)\n\t\trequire.Equal(t, expected, v, `values should match`)\n\t})\n}\n\nfunc TestWithMessage(t *testing.T) {\n\tkey, err := jwxtest.GenerateRsaKey()\n\trequire.NoError(t, err, \"jwxtest.Generate should succeed\")\n\n\tconst text = \"hello, world\"\n\tsigned, err := jws.Sign([]byte(text), jws.WithKey(jwa.RS256, key))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\tm := jws.NewMessage()\n\tpayload, err := jws.Verify(signed, jws.WithKey(jwa.RS256, key.PublicKey), jws.WithMessage(m))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, payload, []byte(text), `jws.Verify should produce the correct payload`)\n\n\tparsed, err := jws.Parse(signed)\n\trequire.NoError(t, err, `jws.Parse should succeed`)\n\n\t// The result of using jws.WithMessage should match the result of jws.Parse\n\tbuf1, _ := json.Marshal(m)\n\tbuf2, _ := json.Marshal(parsed)\n\n\trequire.Equal(t, buf1, buf2, `result of jws.PArse and jws.Verify(..., jws.WithMessage()) should match`)\n}\n\nfunc TestRFC7797(t *testing.T) {\n\tconst keysrc = `{\"kty\":\"oct\",\n      \"k\":\"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow\"\n     }`\n\n\tkey, err := jwk.ParseKey([]byte(keysrc))\n\trequire.NoError(t, err, `jwk.Parse should succeed`)\n\n\tt.Run(\"Invalid payload when b64 = false and NOT detached\", func(t *testing.T) {\n\t\tconst payload = `$.02`\n\t\thdrs := jws.NewHeaders()\n\t\thdrs.Set(\"b64\", false)\n\t\thdrs.Set(\"crit\", \"b64\")\n\n\t\t_, err := jws.Sign([]byte(payload), jws.WithKey(jwa.HS256, key, jws.WithProtectedHeaders(hdrs)))\n\t\trequire.Error(t, err, `jws.Sign should fail`)\n\t})\n\tt.Run(\"Invalid usage when b64 = false and NOT detached\", func(t *testing.T) {\n\t\tconst payload = `$.02`\n\t\thdrs := jws.NewHeaders()\n\t\thdrs.Set(\"b64\", false)\n\t\thdrs.Set(\"crit\", \"b64\")\n\n\t\t_, err := jws.Sign([]byte(payload), jws.WithKey(jwa.HS256, key, jws.WithProtectedHeaders(hdrs)), jws.WithDetachedPayload([]byte(payload)))\n\t\trequire.Error(t, err, `jws.Sign should fail`)\n\t})\n\tt.Run(\"Valid payload when b64 = false\", func(t *testing.T) {\n\t\ttestcases := []struct {\n\t\t\tName     string\n\t\t\tPayload  []byte\n\t\t\tDetached bool\n\t\t}{\n\t\t\t{\n\t\t\t\tName:     `(Detached) payload contains a period`,\n\t\t\t\tPayload:  []byte(`$.02`),\n\t\t\t\tDetached: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    `(NOT detached) payload does not contain a period`,\n\t\t\t\tPayload: []byte(`hell0w0rld`),\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testcases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\thdrs := jws.NewHeaders()\n\t\t\t\thdrs.Set(\"b64\", false)\n\t\t\t\thdrs.Set(\"crit\", \"b64\")\n\n\t\t\t\tpayload := tc.Payload\n\t\t\t\tsignOptions := []jws.SignOption{jws.WithKey(jwa.HS256, key, jws.WithProtectedHeaders(hdrs))}\n\t\t\t\tvar verifyOptions []jws.VerifyOption\n\t\t\t\tverifyOptions = append(verifyOptions, jws.WithKey(jwa.HS256, key))\n\t\t\t\tif tc.Detached {\n\t\t\t\t\tsignOptions = append(signOptions, jws.WithDetachedPayload(payload))\n\t\t\t\t\tverifyOptions = append(verifyOptions, jws.WithDetachedPayload(payload))\n\t\t\t\t\tpayload = nil\n\t\t\t\t}\n\t\t\t\tsigned, err := jws.Sign(payload, signOptions...)\n\t\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t\t\t\tverified, err := jws.Verify(signed, verifyOptions...)\n\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\trequire.Equal(t, tc.Payload, verified, `payload should match`)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"Verify\", func(t *testing.T) {\n\t\tdetached := []byte(`$.02`)\n\t\ttestcases := []struct {\n\t\t\tName          string\n\t\t\tInput         []byte\n\t\t\tVerifyOptions []jws.VerifyOption\n\t\t\tError         bool\n\t\t}{\n\t\t\t{\n\t\t\t\tName: \"JSON format\",\n\t\t\t\tInput: []byte(`{\n      \"protected\": \"eyJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19\",\n      \"payload\": \"$.02\",\n      \"signature\": \"A5dxf2s96_n5FLueVuW1Z_vh161FwXZC4YLPff6dmDY\"\n     }`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"JSON format (detached payload)\",\n\t\t\t\tVerifyOptions: []jws.VerifyOption{\n\t\t\t\t\tjws.WithDetachedPayload(detached),\n\t\t\t\t},\n\t\t\t\tInput: []byte(`{\n      \"protected\": \"eyJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19\",\n      \"signature\": \"A5dxf2s96_n5FLueVuW1Z_vh161FwXZC4YLPff6dmDY\"\n     }`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"JSON Format (b64 does not match)\",\n\t\t\t\tError: true,\n\t\t\t\tInput: []byte(`{\n\t\t\t\t\t\"signatures\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"protected\": \"eyJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19\",\n\t\t\t\t            \"signature\": \"A5dxf2s96_n5FLueVuW1Z_vh161FwXZC4YLPff6dmDY\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"protected\": \"eyJhbGciOiJIUzI1NiIsImI2NCI6dHJ1ZSwiY3JpdCI6WyJiNjQiXX0\", \n\t\t\t\t\t\t\t\"signature\": \"6BjugbC8MfrT_yy5WxWVFZrEHVPDtpdsV9u-wbzQDV8\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"payload\":\"$.02\"\n\t\t\t\t}`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"Compact (detached payload)\",\n\t\t\t\tInput: []byte(`eyJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..A5dxf2s96_n5FLueVuW1Z_vh161FwXZC4YLPff6dmDY`),\n\t\t\t\tVerifyOptions: []jws.VerifyOption{\n\t\t\t\t\tjws.WithDetachedPayload(detached),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testcases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\toptions := tc.VerifyOptions\n\t\t\t\toptions = append(options, jws.WithKey(jwa.HS256, key))\n\t\t\t\tpayload, err := jws.Verify(tc.Input, options...)\n\t\t\t\tif tc.Error {\n\t\t\t\t\trequire.Error(t, err, `jws.Verify should fail`)\n\t\t\t\t\trequire.False(t, jws.IsVerificationError(err), `jws.IsVerifyError should return false`)\n\t\t\t\t} else {\n\t\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\t\trequire.Equal(t, detached, payload, `payload should match`)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestGH485(t *testing.T) {\n\tconst payload = `eyJhIjoiYiJ9`\n\tconst protected = `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImNyaXQiOlsiZXhwIl0sImV4cCI6MCwiaXNzIjoiZm9vIiwibmJmIjowLCJpYXQiOjB9`\n\tconst signature = `qM0CdRcyR4hw03J2ThJDat3Af40U87wVCF3Tp3xsyOg`\n\tconst expected = `{\"a\":\"b\"}`\n\tsigned := fmt.Sprintf(`{\n    \"payload\": %q,\n    \"signatures\": [{\"protected\": %q, \"signature\": %q}]\n}`, payload, protected, signature)\n\n\tverified, err := jws.Verify([]byte(signed), jws.WithKey(jwa.HS256, []byte(\"secret\")))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, expected, string(verified), `verified payload should match`)\n\n\tcompact := strings.Join([]string{protected, payload, signature}, \".\")\n\tverified, err = jws.Verify([]byte(compact), jws.WithKey(jwa.HS256, []byte(\"secret\")))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, expected, string(verified), `verified payload should match`)\n}\n\nfunc TestJKU(t *testing.T) {\n\tkey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\n\tkey.Set(jwk.KeyIDKey, `my-awesome-key`)\n\n\tpubkey, err := jwk.PublicKeyOf(key)\n\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\tset := jwk.NewSet()\n\tset.AddKey(pubkey)\n\tsrv := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tjson.NewEncoder(w).Encode(set)\n\t}))\n\tdefer srv.Close()\n\n\tpayload := []byte(\"Lorem Ipsum\")\n\n\tt.Run(\"Compact\", func(t *testing.T) {\n\t\ttestcases := []struct {\n\t\t\tName         string\n\t\t\tError        bool\n\t\t\tQuery        string\n\t\t\tFetcher      func() jwk.Fetcher\n\t\t\tFetchOptions func() []jwk.FetchOption\n\t\t}{\n\t\t\t{\n\t\t\t\tName:  \"Fail without whitelist\",\n\t\t\t\tError: true,\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\treturn []jwk.FetchOption{jwk.WithHTTPClient(srv.Client())}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Success\",\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\treturn []jwk.FetchOption{\n\t\t\t\t\t\tjwk.WithFetchWhitelist(jwk.InsecureWhitelist{}),\n\t\t\t\t\t\tjwk.WithHTTPClient(srv.Client()),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"Rejected by whitelist\",\n\t\t\t\tError: true,\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\twl := jwk.NewMapWhitelist().Add(`https://github.com/lestrrat-go/jwx/v2`)\n\t\t\t\t\treturn []jwk.FetchOption{\n\t\t\t\t\t\tjwk.WithFetchWhitelist(wl),\n\t\t\t\t\t\tjwk.WithHTTPClient(srv.Client()),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"JWKFetcher\",\n\t\t\t\tFetcher: func() jwk.Fetcher {\n\t\t\t\t\tc := jwk.NewCache(context.TODO())\n\t\t\t\t\treturn jwk.FetchFunc(func(ctx context.Context, u string, options ...jwk.FetchOption) (jwk.Set, error) {\n\t\t\t\t\t\tvar cacheopts []jwk.RegisterOption\n\t\t\t\t\t\tfor _, option := range options {\n\t\t\t\t\t\t\tcacheopts = append(cacheopts, option)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcacheopts = append(cacheopts, jwk.WithHTTPClient(srv.Client()))\n\t\t\t\t\t\tcacheopts = append(cacheopts, jwk.WithFetchWhitelist(httprc.InsecureWhitelist{}))\n\t\t\t\t\t\tc.Register(u, cacheopts...)\n\n\t\t\t\t\t\treturn c.Get(ctx, u)\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testcases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\thdr := jws.NewHeaders()\n\t\t\t\tu := srv.URL\n\t\t\t\tif tc.Query != \"\" {\n\t\t\t\t\tu += \"?\" + tc.Query\n\t\t\t\t}\n\t\t\t\thdr.Set(jws.JWKSetURLKey, u)\n\t\t\t\tsigned, err := jws.Sign(payload, jws.WithKey(jwa.RS256, key, jws.WithProtectedHeaders(hdr)))\n\t\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t\t\t\tvar options []jwk.FetchOption\n\t\t\t\tif f := tc.FetchOptions; f != nil {\n\t\t\t\t\toptions = append(options, f()...)\n\t\t\t\t}\n\n\t\t\t\tvar fetcher jwk.Fetcher\n\t\t\t\tif f := tc.Fetcher; f != nil {\n\t\t\t\t\tfetcher = f()\n\t\t\t\t}\n\t\t\t\tdecoded, err := jws.Verify(signed, jws.WithVerifyAuto(fetcher, options...))\n\t\t\t\tif tc.Error {\n\t\t\t\t\trequire.Error(t, err, `jws.Verify should fail`)\n\t\t\t\t} else {\n\t\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\t\trequire.Equal(t, payload, decoded, `decoded payload should match`)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"JSON\", func(t *testing.T) {\n\t\t// scenario: create a JSON message, which contains 3 signature entries.\n\t\t// 1st and 3rd signatures are valid, but signed using keys that are not\n\t\t// present in the JWKS.\n\t\t// Only the second signature uses a key found in the JWKS\n\t\tvar keys []jwk.Key\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tkey, err := jwxtest.GenerateRsaJwk()\n\t\t\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\t\t\tkey.Set(jwk.KeyIDKey, fmt.Sprintf(`used-%d`, i))\n\t\t\tkeys = append(keys, key)\n\t\t}\n\n\t\tvar unusedKeys []jwk.Key\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tkey, err := jwxtest.GenerateRsaJwk()\n\t\t\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\t\t\tkey.Set(jwk.KeyIDKey, fmt.Sprintf(`unused-%d`, i))\n\t\t\tunusedKeys = append(unusedKeys, key)\n\t\t}\n\n\t\t// The set should contain unused key, used key, and unused key.\n\t\t// ...but they need to be public keys\n\t\tset := jwk.NewSet()\n\t\tfor _, key := range []jwk.Key{unusedKeys[0], keys[1], unusedKeys[1]} {\n\t\t\tpubkey, err := jwk.PublicKeyOf(key)\n\t\t\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\t\t\trequire.Equal(t, pubkey.KeyID(), key.KeyID(), `key ID should be populated`)\n\t\t\tset.AddKey(pubkey)\n\t\t}\n\t\tsrv := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tjson.NewEncoder(w).Encode(set)\n\t\t}))\n\t\tdefer srv.Close()\n\n\t\t// Sign the payload using the three keys\n\t\tvar signOptions = []jws.SignOption{jws.WithJSON()}\n\t\tfor _, key := range keys {\n\t\t\thdr := jws.NewHeaders()\n\t\t\thdr.Set(jws.JWKSetURLKey, srv.URL)\n\t\t\tsignOptions = append(signOptions, jws.WithKey(jwa.RS256, key, jws.WithProtectedHeaders(hdr)))\n\t\t}\n\n\t\tsigned, err := jws.Sign(payload, signOptions...)\n\t\trequire.NoError(t, err, `jws.SignMulti should succeed`)\n\n\t\ttestcases := []struct {\n\t\t\tName         string\n\t\t\tFetchOptions func() []jwk.FetchOption\n\t\t\tError        bool\n\t\t}{\n\t\t\t{\n\t\t\t\tName:  \"Fail without whitelist\",\n\t\t\t\tError: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Success\",\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\treturn []jwk.FetchOption{\n\t\t\t\t\t\tjwk.WithFetchWhitelist(jwk.InsecureWhitelist{}),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"Rejected by whitelist\",\n\t\t\t\tError: true,\n\t\t\t\tFetchOptions: func() []jwk.FetchOption {\n\t\t\t\t\twl := jwk.NewMapWhitelist().Add(`https://github.com/lestrrat-go/jwx/v2`)\n\t\t\t\t\treturn []jwk.FetchOption{\n\t\t\t\t\t\tjwk.WithFetchWhitelist(wl),\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testcases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\t\tm := jws.NewMessage()\n\t\t\t\tvar options []jwk.FetchOption\n\t\t\t\tif fn := tc.FetchOptions; fn != nil {\n\t\t\t\t\toptions = fn()\n\t\t\t\t}\n\t\t\t\toptions = append(options, jwk.WithHTTPClient(srv.Client()))\n\n\t\t\t\tdecoded, err := jws.Verify(signed, jws.WithVerifyAuto(nil, options...), jws.WithMessage(m))\n\t\t\t\tif tc.Error {\n\t\t\t\t\trequire.Error(t, err, `jws.Verify should fail`)\n\t\t\t\t} else {\n\t\t\t\t\tif !assert.NoError(t, err, `jws.Verify should succeed`) {\n\t\t\t\t\t\tset, _ := jwk.Fetch(context.Background(), srv.URL, options...)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbuf, _ := json.MarshalIndent(set, \"\", \"  \")\n\t\t\t\t\t\t\tt.Logf(\"%s\", buf)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\trequire.Equal(t, payload, decoded, `decoded payload should match`)\n\t\t\t\t\t// XXX This actally doesn't really test much, but if there was anything\n\t\t\t\t\t// wrong, the process should have failed well before reaching here\n\t\t\t\t\trequire.Equal(t, payload, m.Payload(), \"message payload matches\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestAlgorithmsForKey(t *testing.T) {\n\trsaprivkey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaPrivateKey should succeed`)\n\trsapubkey, err := rsaprivkey.PublicKey()\n\trequire.NoError(t, err, `jwk (RSA) PublicKey() should succeed`)\n\n\tecdsaprivkey, err := jwxtest.GenerateEcdsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateEcdsaPrivateKey should succeed`)\n\tecdsapubkey, err := ecdsaprivkey.PublicKey()\n\trequire.NoError(t, err, `jwk (ECDSA) PublicKey() should succeed`)\n\n\ttestcases := []struct {\n\t\tName     string\n\t\tKey      interface{}\n\t\tExpected []jwa.SignatureAlgorithm\n\t}{\n\t\t{\n\t\t\tName:     \"Octet sequence\",\n\t\t\tKey:      []byte(\"hello\"),\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.HS256, jwa.HS384, jwa.HS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"rsa.PublicKey\",\n\t\t\tKey:      rsa.PublicKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"*rsa.PublicKey\",\n\t\t\tKey:      &rsa.PublicKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"jwk.RSAPublicKey\",\n\t\t\tKey:      rsapubkey,\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"ecdsa.PublicKey\",\n\t\t\tKey:      ecdsa.PublicKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"*ecdsa.PublicKey\",\n\t\t\tKey:      &ecdsa.PublicKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"jwk.ECDSAPublicKey\",\n\t\t\tKey:      ecdsapubkey,\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"rsa.PrivateKey\",\n\t\t\tKey:      rsa.PrivateKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"*rsa.PrivateKey\",\n\t\t\tKey:      &rsa.PrivateKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"jwk.RSAPrivateKey\",\n\t\t\tKey:      rsapubkey,\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.RS256, jwa.RS384, jwa.RS512, jwa.PS256, jwa.PS384, jwa.PS512},\n\t\t},\n\t\t{\n\t\t\tName:     \"ecdsa.PrivateKey\",\n\t\t\tKey:      ecdsa.PrivateKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"*ecdsa.PrivateKey\",\n\t\t\tKey:      &ecdsa.PrivateKey{},\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"jwk.ECDSAPrivateKey\",\n\t\t\tKey:      ecdsaprivkey,\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.ES256, jwa.ES384, jwa.ES512},\n\t\t},\n\t\t{\n\t\t\tName:     \"ed25519.PublicKey\",\n\t\t\tKey:      ed25519.PublicKey(nil),\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.EdDSA},\n\t\t},\n\t\t{\n\t\t\tName:     \"x25519.PublicKey\",\n\t\t\tKey:      x25519.PublicKey(nil),\n\t\t\tExpected: []jwa.SignatureAlgorithm{jwa.EdDSA},\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\ttc := tc\n\n\t\tif hasES256K {\n\t\t\tif strings.Contains(strings.ToLower(tc.Name), `ecdsa`) {\n\t\t\t\ttc.Expected = append(tc.Expected, jwa.ES256K)\n\t\t\t}\n\t\t}\n\n\t\tsort.Slice(tc.Expected, func(i, j int) bool {\n\t\t\treturn tc.Expected[i].String() < tc.Expected[j].String()\n\t\t})\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\talgs, err := jws.AlgorithmsForKey(tc.Key)\n\t\t\trequire.NoError(t, err, `jws.AlgorithmsForKey should succeed`)\n\n\t\t\tsort.Slice(algs, func(i, j int) bool {\n\t\t\t\treturn algs[i].String() < algs[j].String()\n\t\t\t})\n\t\t\trequire.Equal(t, tc.Expected, algs, `results should match`)\n\t\t})\n\t}\n}\n\nfunc TestGH681(t *testing.T) {\n\tprivkey, err := jwxtest.GenerateRsaKey()\n\trequire.NoError(t, err, \"failed to create private key\")\n\n\tbuf, err := jws.Sign(nil, jws.WithKey(jwa.RS256, privkey), jws.WithDetachedPayload([]byte(\"Lorem ipsum\")))\n\trequire.NoError(t, err, \"failed to sign payload\")\n\n\tt.Logf(\"%s\", buf)\n\n\t_, err = jws.Verify(buf, jws.WithKey(jwa.RS256, &privkey.PublicKey), jws.WithDetachedPayload([]byte(\"Lorem ipsum\")))\n\trequire.NoError(t, err, \"failed to verify JWS message\")\n}\n\nfunc TestGH840(t *testing.T) {\n\t// Go 1.19+ panics if elliptic curve operations are called against\n\t// a point that's _NOT_ on the curve\n\tuntrustedJWK := []byte(`{\n\t\t\"kty\": \"EC\",\n\t\t\"crv\": \"P-256\",\n\t\t\"x\": \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqx7D4\",\n\t\t\"y\": \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n\t\t\"d\": \"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\"\n\t}`)\n\n\t// Parse, serialize, slice and dice JWKs!\n\tprivkey, err := jwk.ParseKey(untrustedJWK)\n\trequire.NoError(t, err, `jwk.ParseKey should succeed`)\n\n\tpubkey, err := jwk.PublicKeyOf(privkey)\n\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\n\ttok, err := jwt.NewBuilder().\n\t\tIssuer(`github.com/lestrrat-go/jwx`).\n\t\tIssuedAt(time.Now()).\n\t\tBuild()\n\trequire.NoError(t, err, `jwt.NewBuilder should succeed`)\n\n\tsigned, err := jwt.Sign(tok, jwt.WithKey(jwa.ES256, privkey))\n\trequire.NoError(t, err, `jwt.Sign should succeed`)\n\n\t_, err = jwt.Parse(signed, jwt.WithKey(jwa.ES256, pubkey))\n\trequire.Error(t, err, `jwt.Parse should FAIL`) // pubkey's X/Y is not on the curve\n}\n\nfunc TestGH888(t *testing.T) {\n\t// This should fail because we're passing multiple keys (i.e. multiple signatures)\n\t// and yet we haven't specified JSON serialization\n\t_, err := jws.Sign([]byte(`foo`), jws.WithInsecureNoSignature(), jws.WithKey(jwa.HS256, []byte(`bar`)))\n\trequire.Error(t, err, `jws.Sign with multiple keys (including alg=none) should fail`)\n\n\t// This should pass because we can now have multiple signaures with JSON serialization\n\tsigned, err := jws.Sign([]byte(`foo`), jws.WithInsecureNoSignature(), jws.WithKey(jwa.HS256, []byte(`bar`)), jws.WithJSON())\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\tmessage, err := jws.Parse(signed)\n\trequire.NoError(t, err, `jws.Parse should succeed`)\n\n\t// Look for alg=none signature\n\tvar foundNoSignature bool\n\tfor _, sig := range message.Signatures() {\n\t\tif sig.ProtectedHeaders().Algorithm() != jwa.NoSignature {\n\t\t\tcontinue\n\t\t}\n\n\t\trequire.Nil(t, sig.Signature(), `signature must be nil for alg=none`)\n\t\tfoundNoSignature = true\n\t}\n\trequire.True(t, foundNoSignature, `signature with no signature was found`)\n\n\t_, err = jws.Verify(signed)\n\trequire.Error(t, err, `jws.Verify should fail`)\n\n\t_, err = jws.Verify(signed, jws.WithKey(jwa.NoSignature, nil))\n\trequire.Error(t, err, `jws.Verify should fail`)\n\n\t// Note: you can't do jws.Verify(..., jws.WithInsecureNoSignature())\n\n\tverified, err := jws.Verify(signed, jws.WithKey(jwa.HS256, []byte(`bar`)))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, []byte(`foo`), verified)\n}\n\n// Some stuff required for testing #910\n// The original code used an external library to sign/verify, but here\n// we just use a simple SHA256 digest here so that we don't force\n// users to download an optional dependency\ntype s256SignerVerifier struct{}\n\nconst sha256Algo jwa.SignatureAlgorithm = \"SillyTest256\"\n\nfunc (s256SignerVerifier) Algorithm() jwa.SignatureAlgorithm {\n\treturn sha256Algo\n}\n\nfunc (s256SignerVerifier) Sign(payload []byte, _ interface{}) ([]byte, error) {\n\th := sha256.Sum256(payload)\n\treturn h[:], nil\n}\n\nfunc (s256SignerVerifier) Verify(payload, signature []byte, _ interface{}) error {\n\th := sha256.Sum256(payload)\n\tif !bytes.Equal(h[:], signature) {\n\t\treturn errors.New(\"invalid signature\")\n\t}\n\treturn nil\n}\n\nfunc TestGH910(t *testing.T) {\n\t// Note: This has global effect. You can't run this in parallel with other tests\n\tjws.RegisterSigner(sha256Algo, jws.SignerFactoryFn(func() (jws.Signer, error) {\n\t\treturn s256SignerVerifier{}, nil\n\t}))\n\tdefer jws.UnregisterSigner(sha256Algo)\n\n\tjws.RegisterVerifier(sha256Algo, jws.VerifierFactoryFn(func() (jws.Verifier, error) {\n\t\treturn s256SignerVerifier{}, nil\n\t}))\n\tdefer jws.UnregisterVerifier(sha256Algo)\n\tdefer jwa.UnregisterSignatureAlgorithm(sha256Algo)\n\n\tvar sa jwa.SignatureAlgorithm\n\trequire.NoError(t, sa.Accept(sha256Algo.String()), `jwa.SignatureAlgorithm.Accept should succeed`)\n\n\t// Now that we have established that the signature algorithm works,\n\t// we can proceed with the test\n\tconst src = `Lorem Ipsum`\n\tsigned, err := jws.Sign([]byte(src), jws.WithKey(sha256Algo, nil))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\tverified, err := jws.Verify(signed, jws.WithKey(sha256Algo, nil))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\n\trequire.Equal(t, src, string(verified), `verified payload should match`)\n\n\tjws.UnregisterSigner(sha256Algo)\n\n\t// Now try after unregistering the signer for the algorithm\n\t_, err = jws.Sign([]byte(src), jws.WithKey(sha256Algo, nil))\n\trequire.Error(t, err, `jws.Sign should succeed`)\n\n\tjws.RegisterSigner(sha256Algo, jws.SignerFactoryFn(func() (jws.Signer, error) {\n\t\treturn s256SignerVerifier{}, nil\n\t}))\n\n\t_, err = jws.Sign([]byte(src), jws.WithKey(sha256Algo, nil))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n}\n\nfunc TestUnpaddedSignatureR(t *testing.T) {\n\t// I brute-forced generating a key and signature where the R portion\n\t// of the signature was not padded by using the following code in the\n\t// first run, then copied the result to the test\n\t/*\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\trawKey, err := jwxtest.GenerateEcdsaKey(jwa.P256)\n\t\t\trequire.NoError(t, err, `jwxtest.GenerateEcdsaJwk should succeed`)\n\n\t\t\tkey, err := jwk.FromRaw(rawKey)\n\t\t\trequire.NoError(t, err, `jwk.FromRaw should succeed`)\n\n\t\t\tpubkey, _ := key.PublicKey()\n\n\t\t\tsigned, err := jws.Sign([]byte(\"Lorem Ipsum\"), jws.WithKey(jwa.ES256, key))\n\t\t\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t\t\tmessage, err := jws.Parse(signed)\n\t\t\trequire.NoError(t, err, `jws.Parse should succeed`)\n\n\t\t\tasJson, _ := json.Marshal(message)\n\t\t\tt.Logf(\"%s\", asJson)\n\n\t\t\tfor _, sig := range message.Signatures() {\n\t\t\t\tsigBytes := sig.Signature()\n\t\t\t\tif sigBytes[0] == 0x00 {\n\t\t\t\t\t// Found it!\n\t\t\t\t\tt.Logf(\"Found signature that can be unpadded.\")\n\t\t\t\t\tt.Logf(\"Original signature: %q\", base64.EncodeToString(sigBytes))\n\n\t\t\t\t\t//\t\t\t\tunpaddedSig := append(sigBytes[1:31], sigBytes[32:]...)\n\t\t\t\t\tunpaddedSig := sigBytes[1:]\n\t\t\t\t\tt.Logf(\"Signature with first byte of R removed: %q\", base64.EncodeToString(unpaddedSig))\n\t\t\t\t\tt.Logf(\"Original JWS payload: %q\", signed)\n\t\t\t\t\trequire.Len(t, unpaddedSig, 63)\n\n\t\t\t\t\ti := bytes.LastIndexByte(signed, '.')\n\t\t\t\t\tmodified := append(signed[:i+1], base64.Encode(unpaddedSig)...)\n\t\t\t\t\tt.Logf(\"JWS payload with unpadded signature: %q\", modified)\n\n\t\t\t\t\t// jws.Verify for sanity\n\t\t\t\t\tverified, err := jws.Verify(modified, jws.WithKey(jwa.ES256, pubkey))\n\t\t\t\t\trequire.NoError(t, err, `jws.Verify should succeed`)\n\t\t\t\t\tt.Logf(\"verified payload: %q\", verified)\n\n\t\t\t\t\tbuf, _ := json.Marshal(key)\n\t\t\t\t\tt.Logf(\"Private JWK: %s\", buf)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t*/\n\t// Padded has R with a leading 0 (as it should)\n\tpadded := \"eyJhbGciOiJFUzI1NiJ9.TG9yZW0gSXBzdW0.ALFru4CRZDiAlVKyyHtlLGtXIAWxC3lXIlZuYO8G8a5ePzCwyw6c2FzWBZwrLaoLFZb_TcYs3TcZ8mhONPaavQ\"\n\t// Unpadded has R with a leading 0 removed (31 bytes, WRONG)\n\tunpadded := \"eyJhbGciOiJFUzI1NiJ9.TG9yZW0gSXBzdW0.sWu7gJFkOICVUrLIe2Usa1cgBbELeVciVm5g7wbxrl4_MLDLDpzYXNYFnCstqgsVlv9NxizdNxnyaE409pq9\"\n\n\t// This is the private key used to sign the payload\n\tkeySrc := `{\"crv\":\"P-256\",\"d\":\"MqGwMl-dlJFrMnu7rFyslPV8EdsVC7I4V19N-ADVqaU\",\"kty\":\"EC\",\"x\":\"Anf1p2lRrcXgZKpVRRC1xLxPiw_45PbOlygfbxvD8Es\",\"y\":\"d0HiZq-aurVVLLtK-xqXPpzpWloZJNwKNve7akBDuvg\"}`\n\n\tprivKey, err := jwk.ParseKey([]byte(keySrc))\n\trequire.NoError(t, err, `jwk.ParseKey should succeed`)\n\n\tpubKey, err := jwk.PublicKeyOf(privKey)\n\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\n\t// Should always succeed\n\tpayload, err := jws.Verify([]byte(padded), jws.WithKey(jwa.ES256, pubKey))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n\trequire.Equal(t, \"Lorem Ipsum\", string(payload))\n\n\t// Should fail\n\t_, err = jws.Verify([]byte(unpadded), jws.WithKey(jwa.ES256, pubKey))\n\trequire.Error(t, err, `jws.Verify should fail`)\n}\n\nfunc TestValidateKey(t *testing.T) {\n\tprivKey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\n\tsigned, err := jws.Sign([]byte(\"Lorem Ipsum\"), jws.WithKey(jwa.RS256, privKey), jws.WithValidateKey(true))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t// This should fail because D is empty\n\trequire.NoError(t, privKey.Set(jwk.RSADKey, []byte(nil)), `jwk.Set should succeed`)\n\t_, err = jws.Sign([]byte(\"Lorem Ipsum\"), jws.WithKey(jwa.RS256, privKey), jws.WithValidateKey(true))\n\trequire.Error(t, err, `jws.Sign should fail`)\n\n\tpubKey, err := jwk.PublicKeyOf(privKey)\n\trequire.NoError(t, err, `jwk.PublicKeyOf should succeed`)\n\n\tn := pubKey.(jwk.RSAPublicKey).N()\n\n\t// Set N to an empty value\n\trequire.NoError(t, pubKey.Set(jwk.RSANKey, []byte(nil)), `jwk.Set should succeed`)\n\n\t// This is going to fail regardless, because the public key is now\n\t// invalid (empty N), but we want to make sure that it fails because\n\t// of the validation failing\n\t_, err = jws.Verify(signed, jws.WithKey(jwa.RS256, pubKey), jws.WithValidateKey(true))\n\trequire.Error(t, err, `jws.Verify should fail`)\n\trequire.True(t, jwk.IsKeyValidationError(err), `jwk.IsKeyValidationError should return true`)\n\n\t// The following should now succeed, because N has been reinstated\n\trequire.NoError(t, pubKey.Set(jwk.RSANKey, n), `jwk.Set should succeed`)\n\t_, err = jws.Verify(signed, jws.WithKey(jwa.RS256, pubKey), jws.WithValidateKey(true))\n\trequire.NoError(t, err, `jws.Verify should succeed`)\n}\n\nfunc TestEmptyProtectedField(t *testing.T) {\n\t// MEMO: this was the only test case from the original report\n\t// This passes. It should produce an invalid JWS message, but\n\t// that's not `jws.Parse`'s problem.\n\t_, err := jws.Parse([]byte(`{\"signature\": \"\"}`))\n\trequire.NoError(t, err, `jws.Parse should fail`)\n\n\t// Also test that non-flattened serialization passes.\n\t_, err = jws.Parse([]byte(`{\"signatures\": [{}]}`))\n\trequire.NoError(t, err, `jws.Parse should fail`)\n\n\t// MEMO: rest of the cases are present to be extra pedantic about it\n\n\tprivKey, err := jwxtest.GenerateRsaJwk()\n\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n\n\t// This fails. `jws.Parse` works, but the subsequent verification\n\t// workflow fails to verify anything without the presense of a signature or\n\t// a protected header.\n\t_, err = jws.Verify([]byte(`{\"signature\": \"\"}`), jws.WithKey(jwa.RS256, privKey))\n\trequire.Error(t, err, `jws.Parse should fail`)\n\n\t// Create a valid signatre.\n\tsigned, err := jws.Sign([]byte(\"Lorem Ipsum\"), jws.WithKey(jwa.RS256, privKey))\n\trequire.NoError(t, err, `jws.Sign should succeed`)\n\n\t_, payload, signature, err := jws.SplitCompact(signed)\n\trequire.NoError(t, err, `jws.SplitCompact should succeed`)\n\n\t// This fails as well. we have a valid signature and a valid\n\t// key to verify it, but no protected headers\n\t_, err = jws.Verify(\n\t\t[]byte(fmt.Sprintf(`{\"signature\": \"%s\"}`, signature)),\n\t\tjws.WithKey(jwa.RS256, privKey),\n\t)\n\trequire.Error(t, err, `jws.Verify should fail`)\n\n\t// Test for cases when we have an incomplete compact form JWS\n\tvar buf bytes.Buffer\n\tbuf.WriteRune('.')\n\tbuf.Write(payload)\n\tbuf.WriteRune('.')\n\tbuf.Write(signature)\n\tinvalidMessage := buf.Bytes()\n\n\t// This is an error because the format is simply wrong.\n\t// Whereas in the other JSON-based JWS's case the lack of protected field\n\t// is not a SYNTAX error, this one is, and therefore we barf.\n\t_, err = jws.Parse(invalidMessage)\n\trequire.Error(t, err, `jws.Parse should fail`)\n}\n", "package jws\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/lestrrat-go/jwx/v2/internal/base64\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/json\"\n\t\"github.com/lestrrat-go/jwx/v2/internal/pool\"\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n)\n\nfunc NewSignature() *Signature {\n\treturn &Signature{}\n}\n\nfunc (s *Signature) DecodeCtx() DecodeCtx {\n\treturn s.dc\n}\n\nfunc (s *Signature) SetDecodeCtx(dc DecodeCtx) {\n\ts.dc = dc\n}\n\nfunc (s Signature) PublicHeaders() Headers {\n\treturn s.headers\n}\n\nfunc (s *Signature) SetPublicHeaders(v Headers) *Signature {\n\ts.headers = v\n\treturn s\n}\n\nfunc (s Signature) ProtectedHeaders() Headers {\n\treturn s.protected\n}\n\nfunc (s *Signature) SetProtectedHeaders(v Headers) *Signature {\n\ts.protected = v\n\treturn s\n}\n\nfunc (s Signature) Signature() []byte {\n\treturn s.signature\n}\n\nfunc (s *Signature) SetSignature(v []byte) *Signature {\n\ts.signature = v\n\treturn s\n}\n\ntype signatureUnmarshalProbe struct {\n\tHeader    Headers `json:\"header,omitempty\"`\n\tProtected *string `json:\"protected,omitempty\"`\n\tSignature *string `json:\"signature,omitempty\"`\n}\n\nfunc (s *Signature) UnmarshalJSON(data []byte) error {\n\tvar sup signatureUnmarshalProbe\n\tsup.Header = NewHeaders()\n\tif err := json.Unmarshal(data, &sup); err != nil {\n\t\treturn fmt.Errorf(`failed to unmarshal signature into temporary struct: %w`, err)\n\t}\n\n\ts.headers = sup.Header\n\tif buf := sup.Protected; buf != nil {\n\t\tsrc := []byte(*buf)\n\t\tif !bytes.HasPrefix(src, []byte{'{'}) {\n\t\t\tdecoded, err := base64.Decode(src)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to base64 decode protected headers: %w`, err)\n\t\t\t}\n\t\t\tsrc = decoded\n\t\t}\n\n\t\tprt := NewHeaders()\n\t\t//nolint:forcetypeassert\n\t\tprt.(*stdHeaders).SetDecodeCtx(s.DecodeCtx())\n\t\tif err := json.Unmarshal(src, prt); err != nil {\n\t\t\treturn fmt.Errorf(`failed to unmarshal protected headers: %w`, err)\n\t\t}\n\t\t//nolint:forcetypeassert\n\t\tprt.(*stdHeaders).SetDecodeCtx(nil)\n\t\ts.protected = prt\n\t}\n\n\tif sup.Signature != nil {\n\t\tdecoded, err := base64.DecodeString(*sup.Signature)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(`failed to base decode signature: %w`, err)\n\t\t}\n\t\ts.signature = decoded\n\t}\n\treturn nil\n}\n\n// Sign populates the signature field, with a signature generated by\n// given the signer object and payload.\n//\n// The first return value is the raw signature in binary format.\n// The second return value s the full three-segment signature\n// (e.g. \"eyXXXX.XXXXX.XXXX\")\nfunc (s *Signature) Sign(payload []byte, signer Signer, key interface{}) ([]byte, []byte, error) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\thdrs, err := mergeHeaders(ctx, s.headers, s.protected)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to merge headers: %w`, err)\n\t}\n\n\tif err := hdrs.Set(AlgorithmKey, signer.Algorithm()); err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to set \"alg\": %w`, err)\n\t}\n\n\t// If the key is a jwk.Key instance, obtain the raw key\n\tif jwkKey, ok := key.(jwk.Key); ok {\n\t\t// If we have a key ID specified by this jwk.Key, use that in the header\n\t\tif kid := jwkKey.KeyID(); kid != \"\" {\n\t\t\tif err := hdrs.Set(jwk.KeyIDKey, kid); err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(`set key ID from jwk.Key: %w`, err)\n\t\t\t}\n\t\t}\n\t}\n\thdrbuf, err := json.Marshal(hdrs)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to marshal headers: %w`, err)\n\t}\n\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.ReleaseBytesBuffer(buf)\n\n\tbuf.WriteString(base64.EncodeToString(hdrbuf))\n\tbuf.WriteByte('.')\n\n\tvar plen int\n\tb64 := getB64Value(hdrs)\n\tif b64 {\n\t\tencoded := base64.EncodeToString(payload)\n\t\tplen = len(encoded)\n\t\tbuf.WriteString(encoded)\n\t} else {\n\t\tif !s.detached {\n\t\t\tif bytes.Contains(payload, []byte{'.'}) {\n\t\t\t\treturn nil, nil, fmt.Errorf(`payload must not contain a \".\"`)\n\t\t\t}\n\t\t}\n\t\tplen = len(payload)\n\t\tbuf.Write(payload)\n\t}\n\n\tsignature, err := signer.Sign(buf.Bytes(), key)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(`failed to sign payload: %w`, err)\n\t}\n\ts.signature = signature\n\n\t// Detached payload, this should be removed from the end result\n\tif s.detached {\n\t\tbuf.Truncate(buf.Len() - plen)\n\t}\n\n\tbuf.WriteByte('.')\n\tbuf.WriteString(base64.EncodeToString(signature))\n\tret := make([]byte, buf.Len())\n\tcopy(ret, buf.Bytes())\n\n\treturn signature, ret, nil\n}\n\nfunc NewMessage() *Message {\n\treturn &Message{}\n}\n\n// Clears the internal raw buffer that was accumulated during\n// the verify phase\nfunc (m *Message) clearRaw() {\n\tfor _, sig := range m.signatures {\n\t\tif protected := sig.protected; protected != nil {\n\t\t\tif cr, ok := protected.(*stdHeaders); ok {\n\t\t\t\tcr.raw = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (m *Message) SetDecodeCtx(dc DecodeCtx) {\n\tm.dc = dc\n}\n\nfunc (m *Message) DecodeCtx() DecodeCtx {\n\treturn m.dc\n}\n\n// Payload returns the decoded payload\nfunc (m Message) Payload() []byte {\n\treturn m.payload\n}\n\nfunc (m *Message) SetPayload(v []byte) *Message {\n\tm.payload = v\n\treturn m\n}\n\nfunc (m Message) Signatures() []*Signature {\n\treturn m.signatures\n}\n\nfunc (m *Message) AppendSignature(v *Signature) *Message {\n\tm.signatures = append(m.signatures, v)\n\treturn m\n}\n\nfunc (m *Message) ClearSignatures() *Message {\n\tm.signatures = nil\n\treturn m\n}\n\n// LookupSignature looks up a particular signature entry using\n// the `kid` value\nfunc (m Message) LookupSignature(kid string) []*Signature {\n\tvar sigs []*Signature\n\tfor _, sig := range m.signatures {\n\t\tif hdr := sig.PublicHeaders(); hdr != nil {\n\t\t\thdrKeyID := hdr.KeyID()\n\t\t\tif hdrKeyID == kid {\n\t\t\t\tsigs = append(sigs, sig)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif hdr := sig.ProtectedHeaders(); hdr != nil {\n\t\t\thdrKeyID := hdr.KeyID()\n\t\t\tif hdrKeyID == kid {\n\t\t\t\tsigs = append(sigs, sig)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\treturn sigs\n}\n\n// This struct is used to first probe for the structure of the\n// incoming JSON object. We then decide how to parse it\n// from the fields that are populated.\ntype messageUnmarshalProbe struct {\n\tPayload    *string           `json:\"payload\"`\n\tSignatures []json.RawMessage `json:\"signatures,omitempty\"`\n\tHeader     Headers           `json:\"header,omitempty\"`\n\tProtected  *string           `json:\"protected,omitempty\"`\n\tSignature  *string           `json:\"signature,omitempty\"`\n}\n\nfunc (m *Message) UnmarshalJSON(buf []byte) error {\n\tm.payload = nil\n\tm.signatures = nil\n\tm.b64 = true\n\n\tvar mup messageUnmarshalProbe\n\tmup.Header = NewHeaders()\n\tif err := json.Unmarshal(buf, &mup); err != nil {\n\t\treturn fmt.Errorf(`failed to unmarshal into temporary structure: %w`, err)\n\t}\n\n\tb64 := true\n\tif mup.Signature == nil { // flattened signature is NOT present\n\t\tif len(mup.Signatures) == 0 {\n\t\t\treturn fmt.Errorf(`required field \"signatures\" not present`)\n\t\t}\n\n\t\tm.signatures = make([]*Signature, 0, len(mup.Signatures))\n\t\tfor i, rawsig := range mup.Signatures {\n\t\t\tvar sig Signature\n\t\t\tsig.SetDecodeCtx(m.DecodeCtx())\n\t\t\tif err := json.Unmarshal(rawsig, &sig); err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to unmarshal signature #%d: %w`, i+1, err)\n\t\t\t}\n\t\t\tsig.SetDecodeCtx(nil)\n\n\t\t\tif sig.protected == nil {\n\t\t\t\t// Instead of barfing on a nil protected header, use an empty header\n\t\t\t\tsig.protected = NewHeaders()\n\t\t\t}\n\n\t\t\tif i == 0 {\n\t\t\t\tif !getB64Value(sig.protected) {\n\t\t\t\t\tb64 = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif b64 != getB64Value(sig.protected) {\n\t\t\t\t\treturn fmt.Errorf(`b64 value must be the same for all signatures`)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm.signatures = append(m.signatures, &sig)\n\t\t}\n\t} else { // .signature is present, it's a flattened structure\n\t\tif len(mup.Signatures) != 0 {\n\t\t\treturn fmt.Errorf(`invalid format (\"signatures\" and \"signature\" keys cannot both be present)`)\n\t\t}\n\n\t\tvar sig Signature\n\t\tsig.headers = mup.Header\n\t\tif src := mup.Protected; src != nil {\n\t\t\tdecoded, err := base64.DecodeString(*src)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to base64 decode flattened protected headers: %w`, err)\n\t\t\t}\n\t\t\tprt := NewHeaders()\n\t\t\t//nolint:forcetypeassert\n\t\t\tprt.(*stdHeaders).SetDecodeCtx(m.DecodeCtx())\n\t\t\tif err := json.Unmarshal(decoded, prt); err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to unmarshal flattened protected headers: %w`, err)\n\t\t\t}\n\t\t\t//nolint:forcetypeassert\n\t\t\tprt.(*stdHeaders).SetDecodeCtx(nil)\n\t\t\tsig.protected = prt\n\t\t}\n\n\t\tif sig.protected == nil {\n\t\t\t// Instead of barfing on a nil protected header, use an empty header\n\t\t\tsig.protected = NewHeaders()\n\t\t}\n\n\t\tdecoded, err := base64.DecodeString(*mup.Signature)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(`failed to base64 decode flattened signature: %w`, err)\n\t\t}\n\t\tsig.signature = decoded\n\n\t\tm.signatures = []*Signature{&sig}\n\t\tb64 = getB64Value(sig.protected)\n\t}\n\n\tif mup.Payload != nil {\n\t\tif !b64 { // NOT base64 encoded\n\t\t\tm.payload = []byte(*mup.Payload)\n\t\t} else {\n\t\t\tdecoded, err := base64.DecodeString(*mup.Payload)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(`failed to base64 decode payload: %w`, err)\n\t\t\t}\n\t\t\tm.payload = decoded\n\t\t}\n\t}\n\tm.b64 = b64\n\treturn nil\n}\n\nfunc (m Message) MarshalJSON() ([]byte, error) {\n\tif len(m.signatures) == 1 {\n\t\treturn m.marshalFlattened()\n\t}\n\treturn m.marshalFull()\n}\n\nfunc (m Message) marshalFlattened() ([]byte, error) {\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.ReleaseBytesBuffer(buf)\n\n\tsig := m.signatures[0]\n\n\tbuf.WriteRune('{')\n\tvar wrote bool\n\n\tif hdr := sig.headers; hdr != nil {\n\t\thdrjs, err := hdr.MarshalJSON()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to marshal \"header\" (flattened format): %w`, err)\n\t\t}\n\t\tbuf.WriteString(`\"header\":`)\n\t\tbuf.Write(hdrjs)\n\t\twrote = true\n\t}\n\n\tif wrote {\n\t\tbuf.WriteRune(',')\n\t}\n\tbuf.WriteString(`\"payload\":\"`)\n\tbuf.WriteString(base64.EncodeToString(m.payload))\n\tbuf.WriteRune('\"')\n\n\tif protected := sig.protected; protected != nil {\n\t\tprotectedbuf, err := protected.MarshalJSON()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(`failed to marshal \"protected\" (flattened format): %w`, err)\n\t\t}\n\t\tbuf.WriteString(`,\"protected\":\"`)\n\t\tbuf.WriteString(base64.EncodeToString(protectedbuf))\n\t\tbuf.WriteRune('\"')\n\t}\n\n\tbuf.WriteString(`,\"signature\":\"`)\n\tbuf.WriteString(base64.EncodeToString(sig.signature))\n\tbuf.WriteRune('\"')\n\tbuf.WriteRune('}')\n\n\tret := make([]byte, buf.Len())\n\tcopy(ret, buf.Bytes())\n\treturn ret, nil\n}\n\nfunc (m Message) marshalFull() ([]byte, error) {\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.ReleaseBytesBuffer(buf)\n\n\tbuf.WriteString(`{\"payload\":\"`)\n\tbuf.WriteString(base64.EncodeToString(m.payload))\n\tbuf.WriteString(`\",\"signatures\":[`)\n\tfor i, sig := range m.signatures {\n\t\tif i > 0 {\n\t\t\tbuf.WriteRune(',')\n\t\t}\n\n\t\tbuf.WriteRune('{')\n\t\tvar wrote bool\n\t\tif hdr := sig.headers; hdr != nil {\n\t\t\thdrbuf, err := hdr.MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to marshal \"header\" for signature #%d: %w`, i+1, err)\n\t\t\t}\n\t\t\tbuf.WriteString(`\"header\":`)\n\t\t\tbuf.Write(hdrbuf)\n\t\t\twrote = true\n\t\t}\n\n\t\tif protected := sig.protected; protected != nil {\n\t\t\tprotectedbuf, err := protected.MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(`failed to marshal \"protected\" for signature #%d: %w`, i+1, err)\n\t\t\t}\n\t\t\tif wrote {\n\t\t\t\tbuf.WriteRune(',')\n\t\t\t}\n\t\t\tbuf.WriteString(`\"protected\":\"`)\n\t\t\tbuf.WriteString(base64.EncodeToString(protectedbuf))\n\t\t\tbuf.WriteRune('\"')\n\t\t\twrote = true\n\t\t}\n\n\t\tif len(sig.signature) > 0 {\n\t\t\t// If InsecureNoSignature is enabled, signature may not exist\n\t\t\tif wrote {\n\t\t\t\tbuf.WriteRune(',')\n\t\t\t}\n\t\t\tbuf.WriteString(`\"signature\":\"`)\n\t\t\tbuf.WriteString(base64.EncodeToString(sig.signature))\n\t\t\tbuf.WriteString(`\"`)\n\t\t}\n\t\tbuf.WriteString(`}`)\n\t}\n\tbuf.WriteString(`]}`)\n\n\tret := make([]byte, buf.Len())\n\tcopy(ret, buf.Bytes())\n\treturn ret, nil\n}\n\n// Compact generates a JWS message in compact serialization format from\n// `*jws.Message` object. The object contain exactly one signature, or\n// an error is returned.\n//\n// If using a detached payload, the payload must already be stored in\n// the `*jws.Message` object, and the `jws.WithDetached()` option\n// must be passed to the function.\nfunc Compact(msg *Message, options ...CompactOption) ([]byte, error) {\n\tif l := len(msg.signatures); l != 1 {\n\t\treturn nil, fmt.Errorf(`jws.Compact: cannot serialize message with %d signatures (must be one)`, l)\n\t}\n\n\tvar detached bool\n\tfor _, option := range options {\n\t\t//nolint:forcetypeassert\n\t\tswitch option.Ident() {\n\t\tcase identDetached{}:\n\t\t\tdetached = option.Value().(bool)\n\t\t}\n\t}\n\n\ts := msg.signatures[0]\n\t// XXX check if this is correct\n\thdrs := s.ProtectedHeaders()\n\n\thdrbuf, err := json.Marshal(hdrs)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(`jws.Compress: failed to marshal headers: %w`, err)\n\t}\n\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.ReleaseBytesBuffer(buf)\n\n\tbuf.WriteString(base64.EncodeToString(hdrbuf))\n\tbuf.WriteByte('.')\n\n\tif !detached {\n\t\tif getB64Value(hdrs) {\n\t\t\tencoded := base64.EncodeToString(msg.payload)\n\t\t\tbuf.WriteString(encoded)\n\t\t} else {\n\t\t\tif bytes.Contains(msg.payload, []byte{'.'}) {\n\t\t\t\treturn nil, fmt.Errorf(`jws.Compress: payload must not contain a \".\"`)\n\t\t\t}\n\t\t\tbuf.Write(msg.payload)\n\t\t}\n\t}\n\n\tbuf.WriteByte('.')\n\tbuf.WriteString(base64.EncodeToString(s.signature))\n\tret := make([]byte, buf.Len())\n\tcopy(ret, buf.Bytes())\n\treturn ret, nil\n}\n"], "filenames": ["Changes", "jws/jws_test.go", "jws/message.go"], "buggy_code_start_loc": [11, 1837, 280], "buggy_code_end_loc": [11, 1837, 313], "fixing_code_start_loc": [12, 1838, 281], "fixing_code_end_loc": [22, 1890, 324], "type": "CWE-476", "message": "jwx is a Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies. Calling `jws.Parse` with a JSON serialized payload where the `signature` field is present while `protected` is absent can lead to a nil pointer dereference. The vulnerability can be used to crash/DOS a system doing JWS verification. This vulnerability has been patched in versions 2.0.19 and 1.2.28.\n", "other": {"cve": {"id": "CVE-2024-21664", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-09T20:15:43.740", "lastModified": "2024-02-05T16:15:55.207", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "jwx is a Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies. Calling `jws.Parse` with a JSON serialized payload where the `signature` field is present while `protected` is absent can lead to a nil pointer dereference. The vulnerability can be used to crash/DOS a system doing JWS verification. This vulnerability has been patched in versions 2.0.19 and 1.2.28.\n"}, {"lang": "es", "value": "jwx es un m\u00f3dulo Go que implementa varias tecnolog\u00edas JWx (JWA/JWE/JWK/JWS/JWT, tambi\u00e9n conocidas como JOSE). Llamar a `jws.Parse` con un payload serializado JSON donde el campo `signature` est\u00e1 presente mientras que `protected` est\u00e1 ausente puede provocar una desreferencia del puntero nulo. La vulnerabilidad se puede utilizar para bloquear/DOS un sistema que realiza la verificaci\u00f3n JWS. Esta vulnerabilidad ha sido parcheada en la versi\u00f3n 2.0.19."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lestrrat-go:jwx:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.19", "matchCriteriaId": "5BC42760-3661-434C-8568-AF4B49498561"}]}]}], "references": [{"url": "https://github.com/lestrrat-go/jwx/commit/0e8802ce6842625845d651456493e7c87625601f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/lestrrat-go/jwx/commit/8c53d0ae52d5ab1e2b37c5abb67def9e7958fd65", "source": "security-advisories@github.com"}, {"url": "https://github.com/lestrrat-go/jwx/commit/d69a721931a5c48b9850a42404f18e143704adcd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/lestrrat-go/jwx/security/advisories/GHSA-pvcr-v8j8-j5q3", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/lestrrat-go/jwx/commit/0e8802ce6842625845d651456493e7c87625601f"}}