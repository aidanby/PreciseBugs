{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/sdp_neg.h>\n#include <pjmedia/sdp.h>\n#include <pjmedia/errno.h>\n#include <pj/assert.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/ctype.h>\n#include <pj/array.h>\n\n/**\n * This structure describes SDP media negotiator.\n */\nstruct pjmedia_sdp_neg\n{\n    pjmedia_sdp_neg_state state;\t    /**< Negotiator state.\t     */\n    pj_bool_t\t\t  prefer_remote_codec_order;\n    pj_bool_t             answer_with_multiple_codecs;\n    pj_bool_t\t\t  has_remote_answer;\n    pj_bool_t\t\t  answer_was_remote;\n\n    pjmedia_sdp_session\t*initial_sdp,\t    /**< Initial local SDP\t     */\n\t\t\t*initial_sdp_tmp,   /**< Temporary initial local SDP */\n\t\t\t*active_local_sdp,  /**< Currently active local SDP. */\n\t\t\t*active_remote_sdp, /**< Currently active remote's.  */\n\t\t\t*neg_local_sdp,\t    /**< Temporary local SDP.\t     */\n\t\t\t*neg_remote_sdp;    /**< Temporary remote SDP.\t     */\n};\n\nstatic const char *state_str[] = \n{\n    \"STATE_NULL\",\n    \"STATE_LOCAL_OFFER\",\n    \"STATE_REMOTE_OFFER\",\n    \"STATE_WAIT_NEGO\",\n    \"STATE_DONE\",\n};\n\n/* Definition of customized SDP format negotiation callback */\nstruct fmt_match_cb_t\n{\n    pj_str_t\t\t\t    fmt_name;\n    pjmedia_sdp_neg_fmt_match_cb    cb;\n};\n\n/* Number of registered customized SDP format negotiation callbacks */\nstatic unsigned fmt_match_cb_cnt;\n\n/* The registered customized SDP format negotiation callbacks */\nstatic struct fmt_match_cb_t \n\t      fmt_match_cb[PJMEDIA_SDP_NEG_MAX_CUSTOM_FMT_NEG_CB];\n\n/* Redefining a very long identifier name, just for convenience */\n#define ALLOW_MODIFY_ANSWER PJMEDIA_SDP_NEG_FMT_MATCH_ALLOW_MODIFY_ANSWER\n\nstatic pj_status_t custom_fmt_match( pj_pool_t *pool,\n\t\t\t\t   const pj_str_t *fmt_name,\n\t\t\t\t   pjmedia_sdp_media *offer,\n\t\t\t\t   unsigned o_fmt_idx,\n\t\t\t\t   pjmedia_sdp_media *answer,\n\t\t\t\t   unsigned a_fmt_idx,\n\t\t\t\t   unsigned option);\n\n\n/*\n * Get string representation of negotiator state.\n */\nPJ_DEF(const char*) pjmedia_sdp_neg_state_str(pjmedia_sdp_neg_state state)\n{\n    if ((int)state >=0 && state < (pjmedia_sdp_neg_state)PJ_ARRAY_SIZE(state_str))\n\treturn state_str[state];\n\n    return \"<?UNKNOWN?>\";\n}\n\n\n/*\n * Create with local offer.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_create_w_local_offer( pj_pool_t *pool,\n\t\t\t\t      const pjmedia_sdp_session *local,\n\t\t\t\t      pjmedia_sdp_neg **p_neg)\n{\n    pjmedia_sdp_neg *neg;\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && local && p_neg, PJ_EINVAL);\n\n    *p_neg = NULL;\n\n    /* Validate local offer. */\n    PJ_ASSERT_RETURN((status=pjmedia_sdp_validate(local))==PJ_SUCCESS, status);\n\n    /* Create and initialize negotiator. */\n    neg = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_neg);\n    PJ_ASSERT_RETURN(neg != NULL, PJ_ENOMEM);\n\n    neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n    neg->prefer_remote_codec_order = PJMEDIA_SDP_NEG_PREFER_REMOTE_CODEC_ORDER;\n    neg->answer_with_multiple_codecs = PJMEDIA_SDP_NEG_ANSWER_MULTIPLE_CODECS;\n    neg->initial_sdp = pjmedia_sdp_session_clone(pool, local);\n    neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);\n\n    *p_neg = neg;\n    return PJ_SUCCESS;\n}\n\n/*\n * Create with remote offer and initial local offer/answer.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_create_w_remote_offer(pj_pool_t *pool,\n\t\t\t\t      const pjmedia_sdp_session *initial,\n\t\t\t\t      const pjmedia_sdp_session *remote,\n\t\t\t\t      pjmedia_sdp_neg **p_neg)\n{\n    pjmedia_sdp_neg *neg;\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && remote && p_neg, PJ_EINVAL);\n\n    *p_neg = NULL;\n\n    /* Validate remote offer and initial answer */\n    status = pjmedia_sdp_validate2(remote, PJ_FALSE);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Create and initialize negotiator. */\n    neg = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_neg);\n    PJ_ASSERT_RETURN(neg != NULL, PJ_ENOMEM);\n\n    neg->prefer_remote_codec_order = PJMEDIA_SDP_NEG_PREFER_REMOTE_CODEC_ORDER;\n    neg->answer_with_multiple_codecs = PJMEDIA_SDP_NEG_ANSWER_MULTIPLE_CODECS;\n    neg->neg_remote_sdp = pjmedia_sdp_session_clone(pool, remote);\n\n    if (initial) {\n\tPJ_ASSERT_RETURN((status=pjmedia_sdp_validate(initial))==PJ_SUCCESS, \n\t\t\t status);\n\n\tneg->initial_sdp = pjmedia_sdp_session_clone(pool, initial);\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, initial);\n\n\tneg->state = PJMEDIA_SDP_NEG_STATE_WAIT_NEGO;\n\n    } else {\n\t\n\tneg->state = PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER;\n\n    }\n\n    *p_neg = neg;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Set codec order preference.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_prefer_remote_codec_order(\n\t\t\t\t\t\tpjmedia_sdp_neg *neg,\n\t\t\t\t\t\tpj_bool_t prefer_remote)\n{\n    PJ_ASSERT_RETURN(neg, PJ_EINVAL);\n    neg->prefer_remote_codec_order = prefer_remote;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Set multiple codec answering.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_answer_multiple_codecs(\n                        pjmedia_sdp_neg *neg,\n                        pj_bool_t answer_multiple)\n{\n    PJ_ASSERT_RETURN(neg, PJ_EINVAL);\n    neg->answer_with_multiple_codecs = answer_multiple;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get SDP negotiator state.\n */\nPJ_DEF(pjmedia_sdp_neg_state) pjmedia_sdp_neg_get_state( pjmedia_sdp_neg *neg )\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(neg != NULL, PJMEDIA_SDP_NEG_STATE_NULL);\n    return neg->state;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_get_active_local( pjmedia_sdp_neg *neg,\n\t\t\t\t\tconst pjmedia_sdp_session **local)\n{\n    PJ_ASSERT_RETURN(neg && local, PJ_EINVAL);\n    PJ_ASSERT_RETURN(neg->active_local_sdp, PJMEDIA_SDPNEG_ENOACTIVE);\n\n    *local = neg->active_local_sdp;\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_get_active_remote( pjmedia_sdp_neg *neg,\n\t\t\t\t   const pjmedia_sdp_session **remote)\n{\n    PJ_ASSERT_RETURN(neg && remote, PJ_EINVAL);\n    PJ_ASSERT_RETURN(neg->active_remote_sdp, PJMEDIA_SDPNEG_ENOACTIVE);\n\n    *remote = neg->active_remote_sdp;\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_bool_t) pjmedia_sdp_neg_was_answer_remote(pjmedia_sdp_neg *neg)\n{\n    PJ_ASSERT_RETURN(neg, PJ_FALSE);\n\n    return neg->answer_was_remote;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_get_neg_remote( pjmedia_sdp_neg *neg,\n\t\t\t\tconst pjmedia_sdp_session **remote)\n{\n    PJ_ASSERT_RETURN(neg && remote, PJ_EINVAL);\n    PJ_ASSERT_RETURN(neg->neg_remote_sdp, PJMEDIA_SDPNEG_ENONEG);\n\n    *remote = neg->neg_remote_sdp;\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_get_neg_local( pjmedia_sdp_neg *neg,\n\t\t\t       const pjmedia_sdp_session **local)\n{\n    PJ_ASSERT_RETURN(neg && local, PJ_EINVAL);\n    PJ_ASSERT_RETURN(neg->neg_local_sdp, PJMEDIA_SDPNEG_ENONEG);\n\n    *local = neg->neg_local_sdp;\n    return PJ_SUCCESS;\n}\n\nstatic pjmedia_sdp_media *sdp_media_clone_deactivate(\n\t\t\t\t    pj_pool_t *pool,\n                                    const pjmedia_sdp_media *rem_med,\n                                    const pjmedia_sdp_media *local_med,\n                                    const pjmedia_sdp_session *local_sess)\n{\n    pjmedia_sdp_media *res;\n\n    res = pjmedia_sdp_media_clone_deactivate(pool, rem_med);\n    if (!res)\n\treturn NULL;\n\n    if (!res->conn && (!local_sess || !local_sess->conn)) {\n\tif (local_med && local_med->conn)\n\t    res->conn = pjmedia_sdp_conn_clone(pool, local_med->conn);\n\telse {\n\t    res->conn = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_conn);\n\t    res->conn->net_type = pj_str(\"IN\");\n\t    res->conn->addr_type = pj_str(\"IP4\");\n\t    res->conn->addr = pj_str(\"127.0.0.1\");\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Modify local SDP and wait for remote answer.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer( pj_pool_t *pool,\n\t\t\t\t    pjmedia_sdp_neg *neg,\n\t\t\t\t    const pjmedia_sdp_session *local)\n{\n    return pjmedia_sdp_neg_modify_local_offer2(pool, neg, 0, local);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(\n                                    pj_pool_t *pool,\n\t\t\t\t    pjmedia_sdp_neg *neg,\n                                    unsigned flags,\n\t\t\t\t    const pjmedia_sdp_session *local)\n{\n    pjmedia_sdp_session *new_offer;\n    pjmedia_sdp_session *old_offer;\n    char media_used[PJMEDIA_MAX_SDP_MEDIA];\n    unsigned oi; /* old offer media index */\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);\n\n    /* Can only do this in STATE_DONE. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* Validate the new offer */\n    status = pjmedia_sdp_validate(local);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Change state to STATE_LOCAL_OFFER */\n    neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n\n    /* Init vars */\n    pj_bzero(media_used, sizeof(media_used));\n    old_offer = neg->active_local_sdp;\n    new_offer = pjmedia_sdp_session_clone(pool, local);\n\n    /* RFC 3264 Section 8: When issuing an offer that modifies the session,\n     * the \"o=\" line of the new SDP MUST be identical to that in the\n     * previous SDP, except that the version in the origin field MUST\n     * increment by one from the previous SDP.\n     */\n    pj_strdup(pool, &new_offer->origin.user, &old_offer->origin.user);\n    new_offer->origin.id = old_offer->origin.id;\n\n    pj_strdup(pool, &new_offer->origin.net_type, &old_offer->origin.net_type);\n    pj_strdup(pool, &new_offer->origin.addr_type,&old_offer->origin.addr_type);\n    pj_strdup(pool, &new_offer->origin.addr, &old_offer->origin.addr);\n\n    if ((flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE) == 0) {\n       /* Generating the new offer, in the case media lines doesn't match the\n        * active SDP (e.g. current/active SDP's have m=audio and m=video lines,\n        * and the new offer only has m=audio line), the negotiator will fix \n        * the new offer by reordering and adding the missing media line with \n        * port number set to zero.\n        */\n        for (oi = 0; oi < old_offer->media_count; ++oi) {\n\t    pjmedia_sdp_media *om;\n\t    pjmedia_sdp_media *nm;\n\t    unsigned ni; /* new offer media index */\n\t    pj_bool_t found = PJ_FALSE;\n\n\t    om = old_offer->media[oi];\n\t    for (ni = oi; ni < new_offer->media_count; ++ni) {\n\t        nm = new_offer->media[ni];\n\t        if (pj_strcmp(&nm->desc.media, &om->desc.media) == 0) {\n\t\t    if (ni != oi) {\n\t\t        /* The same media found but the position unmatched to\n                         * the old offer, so let's put this media in the right\n                         * place, and keep the order of the rest.\n\t\t         */\n\t\t        pj_array_insert(\n                            new_offer->media,\t\t /* array    */\n\t\t\t    sizeof(new_offer->media[0]), /* elmt size*/\n\t\t\t    ni,\t\t\t\t /* count    */\n\t\t            oi,\t\t\t\t /* pos      */\n\t\t\t    &nm);\t\t\t /* new elmt */\n\t\t    }\n\t\t    found = PJ_TRUE;\n\t\t    break;\n\t        }\n\t    }\n\t    if (!found) {\n\t        pjmedia_sdp_media *m;\n\n\t        m = sdp_media_clone_deactivate(pool, om, om, local);\n\n\t        pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n\t\t\t        new_offer->media_count++, oi, &m);\n\t    }\n        }\n    } else {\n        /* If media type change is allowed, the negotiator only needs to fix \n         * the new offer by adding the missing media line(s) with port number\n         * set to zero.\n         */\n        for (oi = new_offer->media_count; oi < old_offer->media_count; ++oi) {\n            pjmedia_sdp_media *m;\n\n\t    m = sdp_media_clone_deactivate(pool, old_offer->media[oi],\n                                           old_offer->media[oi], local);\n\n\t    pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n\t                    new_offer->media_count++, oi, &m);\n\n        }\n    }\n\n    /* New_offer fixed */\n#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n    new_offer->origin.version = old_offer->origin.version;\n\n    if (pjmedia_sdp_session_cmp(new_offer, neg->initial_sdp, 0) != PJ_SUCCESS)\n    {\n\t++new_offer->origin.version;\n    }    \n#else\n    new_offer->origin.version = old_offer->origin.version + 1;\n#endif\n    \n    neg->initial_sdp_tmp = neg->initial_sdp;\n    neg->initial_sdp = new_offer;\n    neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, new_offer);\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_send_local_offer( pj_pool_t *pool,\n\t\t\t\t  pjmedia_sdp_neg *neg,\n\t\t\t\t  const pjmedia_sdp_session **offer)\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(neg && offer, PJ_EINVAL);\n\n    *offer = NULL;\n\n    /* Can only do this in STATE_DONE or STATE_LOCAL_OFFER. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE ||\n\t\t     neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    if (neg->state == PJMEDIA_SDP_NEG_STATE_DONE) {\n\t/* If in STATE_DONE, set the active SDP as the offer. */\n\tPJ_ASSERT_RETURN(neg->active_local_sdp, PJMEDIA_SDPNEG_ENOACTIVE);\n\n\t/* Retain initial SDP */\n\tif (neg->initial_sdp) {\n\t    neg->initial_sdp_tmp = neg->initial_sdp;\n    \t    neg->initial_sdp = pjmedia_sdp_session_clone(pool,\n\t\t\t\t\t\t\t neg->initial_sdp);\n\t}\n\n\tneg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, \n\t\t\t\t\t\t       neg->active_local_sdp);\n\n#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n    \tif (pjmedia_sdp_session_cmp(neg->neg_local_sdp, \n    \t\t\t\t    neg->initial_sdp, 0) != PJ_SUCCESS)\n    \t{\n\t    neg->neg_local_sdp->origin.version++;\n    \t}    \n#else\n    \tneg->neg_local_sdp->origin.version++;\n#endif\n\n\t*offer = neg->neg_local_sdp;\n\n    } else {\n\t/* We assume that we're in STATE_LOCAL_OFFER.\n\t * In this case set the neg_local_sdp as the offer.\n\t */\n\t*offer = neg->neg_local_sdp;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_remote_answer( pj_pool_t *pool,\n\t\t\t\t   pjmedia_sdp_neg *neg,\n\t\t\t\t   const pjmedia_sdp_session *remote)\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && remote, PJ_EINVAL);\n\n    /* Can only do this in STATE_LOCAL_OFFER.\n     * If we haven't provided local offer, then rx_remote_offer() should\n     * be called instead of this function.\n     */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* We're ready to negotiate. */\n    neg->state = PJMEDIA_SDP_NEG_STATE_WAIT_NEGO;\n    neg->has_remote_answer = PJ_TRUE;\n    neg->neg_remote_sdp = pjmedia_sdp_session_clone(pool, remote);\n \n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_remote_offer( pj_pool_t *pool,\n\t\t\t\t  pjmedia_sdp_neg *neg,\n\t\t\t\t  const pjmedia_sdp_session *remote)\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && remote, PJ_EINVAL);\n\n    /* Can only do this in STATE_DONE.\n     * If we already provide local offer, then rx_remote_answer() should\n     * be called instead of this function.\n     */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* State now is STATE_REMOTE_OFFER. */\n    neg->state = PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER;\n    neg->neg_remote_sdp = pjmedia_sdp_session_clone(pool, remote);\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_local_answer( pj_pool_t *pool,\n\t\t\t\t  pjmedia_sdp_neg *neg,\n\t\t\t\t  const pjmedia_sdp_session *local)\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);\n\n    /* Can only do this in STATE_REMOTE_OFFER or WAIT_NEGO.\n     * If we already provide local offer, then set_remote_answer() should\n     * be called instead of this function.\n     */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER ||\n    \t\t     neg->state == PJMEDIA_SDP_NEG_STATE_WAIT_NEGO, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* State now is STATE_WAIT_NEGO. */\n    neg->state = PJMEDIA_SDP_NEG_STATE_WAIT_NEGO;\n    if (local) {\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);\n\tif (neg->initial_sdp) {\n\t    /* Retain initial_sdp value. */\n\t    neg->initial_sdp_tmp = neg->initial_sdp;\n\t    neg->initial_sdp = pjmedia_sdp_session_clone(pool,\n\t\t\t\t\t\t\t neg->initial_sdp);\n        \n\t    /* I don't think there is anything in RFC 3264 that mandates\n\t     * answerer to place the same origin (and increment version)\n\t     * in the answer, but probably it won't hurt either.\n\t     * Note that the version will be incremented in \n\t     * pjmedia_sdp_neg_negotiate()\n\t     */\n\t    neg->neg_local_sdp->origin.id = neg->initial_sdp->origin.id;\n\t} else {\n\t    neg->initial_sdp = pjmedia_sdp_session_clone(pool, local);\n\t}\n    } else {\n\tPJ_ASSERT_RETURN(neg->initial_sdp, PJMEDIA_SDPNEG_ENOINITIAL);\n\tneg->initial_sdp_tmp = neg->initial_sdp;\n\tneg->initial_sdp = pjmedia_sdp_session_clone(pool, neg->initial_sdp);\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, neg->initial_sdp);\n    }\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_bool_t) pjmedia_sdp_neg_has_local_answer(pjmedia_sdp_neg *neg)\n{\n    pj_assert(neg && neg->state==PJMEDIA_SDP_NEG_STATE_WAIT_NEGO);\n    return !neg->has_remote_answer;\n}\n\n\n/* Swap string. */\nstatic void str_swap(pj_str_t *str1, pj_str_t *str2)\n{\n    pj_str_t tmp = *str1;\n    *str1 = *str2;\n    *str2 = tmp;\n}\n\nstatic void remove_all_media_directions(pjmedia_sdp_media *m)\n{\n    pjmedia_sdp_media_remove_all_attr(m, \"inactive\");\n    pjmedia_sdp_media_remove_all_attr(m, \"sendrecv\");\n    pjmedia_sdp_media_remove_all_attr(m, \"sendonly\");\n    pjmedia_sdp_media_remove_all_attr(m, \"recvonly\");\n}\n\n/* Update media direction based on peer's media direction */\nstatic void update_media_direction(pj_pool_t *pool,\n\t\t\t\t   const pjmedia_sdp_media *remote,\n\t\t\t\t   pjmedia_sdp_media *local)\n{\n    pjmedia_dir old_dir = PJMEDIA_DIR_ENCODING_DECODING,\n\t        new_dir;\n\n    /* Get the media direction of local SDP */\n    if (pjmedia_sdp_media_find_attr2(local, \"sendonly\", NULL))\n\told_dir = PJMEDIA_DIR_ENCODING;\n    else if (pjmedia_sdp_media_find_attr2(local, \"recvonly\", NULL))\n\told_dir = PJMEDIA_DIR_DECODING;\n    else if (pjmedia_sdp_media_find_attr2(local, \"inactive\", NULL))\n\told_dir = PJMEDIA_DIR_NONE;\n\n    new_dir = old_dir;\n\n    /* Adjust local media direction based on remote media direction */\n    if (pjmedia_sdp_media_find_attr2(remote, \"inactive\", NULL) != NULL) {\n\t/* If remote has \"a=inactive\", then local is inactive too */\n\n\tnew_dir = PJMEDIA_DIR_NONE;\n\n    } else if(pjmedia_sdp_media_find_attr2(remote, \"sendonly\", NULL) != NULL) {\n\t/* If remote has \"a=sendonly\", then set local to \"recvonly\" if\n\t * it is currently \"sendrecv\". Otherwise if local is NOT \"recvonly\",\n\t * then set local direction to \"inactive\".\n\t */\n\tswitch (old_dir) {\n\tcase PJMEDIA_DIR_ENCODING_DECODING:\n\t    new_dir = PJMEDIA_DIR_DECODING;\n\t    break;\n\tcase PJMEDIA_DIR_DECODING:\n\t    /* No change */\n\t    break;\n\tdefault:\n\t    new_dir = PJMEDIA_DIR_NONE;\n\t    break;\n\t}\n\n    } else if(pjmedia_sdp_media_find_attr2(remote, \"recvonly\", NULL) != NULL) {\n\t/* If remote has \"a=recvonly\", then set local to \"sendonly\" if\n\t * it is currently \"sendrecv\". Otherwise if local is NOT \"sendonly\",\n\t * then set local direction to \"inactive\"\n\t */\n    \n\tswitch (old_dir) {\n\tcase PJMEDIA_DIR_ENCODING_DECODING:\n\t    new_dir = PJMEDIA_DIR_ENCODING;\n\t    break;\n\tcase PJMEDIA_DIR_ENCODING:\n\t    /* No change */\n\t    break;\n\tdefault:\n\t    new_dir = PJMEDIA_DIR_NONE;\n\t    break;\n\t}\n\n    } else {\n\t/* Remote indicates \"sendrecv\" capability. No change to local \n\t * direction \n\t */\n    }\n\n    if (new_dir != old_dir) {\n\tpjmedia_sdp_attr *a = NULL;\n\n\tremove_all_media_directions(local);\n\n\tswitch (new_dir) {\n\tcase PJMEDIA_DIR_NONE:\n\t    a = pjmedia_sdp_attr_create(pool, \"inactive\", NULL);\n\t    break;\n\tcase PJMEDIA_DIR_ENCODING:\n\t    a = pjmedia_sdp_attr_create(pool, \"sendonly\", NULL);\n\t    break;\n\tcase PJMEDIA_DIR_DECODING:\n\t    a = pjmedia_sdp_attr_create(pool, \"recvonly\", NULL);\n\t    break;\n\tdefault:\n\t    /* sendrecv */\n\t    break;\n\t}\n\t\n\tif (a) {\n\t    pjmedia_sdp_media_add_attr(local, a);\n\t}\n    }\n}\n\n\n/* Update single local media description to after receiving answer\n * from remote.\n */\nstatic pj_status_t process_m_answer( pj_pool_t *pool,\n\t\t\t\t     pjmedia_sdp_media *offer,\n\t\t\t\t     pjmedia_sdp_media *answer,\n\t\t\t\t     pj_bool_t allow_asym)\n{\n    unsigned i;\n\n    /* Check that the media type match our offer. */\n\n    if (pj_strcmp(&answer->desc.media, &offer->desc.media)!=0) {\n\t/* The media type in the answer is different than the offer! */\n\treturn PJMEDIA_SDPNEG_EINVANSMEDIA;\n    }\n\n\n    /* Check that transport in the answer match our offer. */\n\n    /* At this point, transport type must be compatible, \n     * the transport instance will do more validation later.\n     */\n    if (pjmedia_sdp_transport_cmp(&answer->desc.transport, \n\t\t\t\t  &offer->desc.transport) \n\t!= PJ_SUCCESS)\n    {\n\treturn PJMEDIA_SDPNEG_EINVANSTP;\n    }\n\n\n    /* Check if remote has rejected our offer */\n    if (answer->desc.port == 0) {\n\t\n\t/* Remote has rejected our offer. \n\t * Deactivate our media too.\n\t */\n\tpjmedia_sdp_media_deactivate(pool, offer);\n\n\t/* Don't need to proceed */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Ticket #1148: check if remote answer does not set port to zero when\n     * offered with port zero. Let's just tolerate it.\n     */\n    if (offer->desc.port == 0) {\n\t/* Don't need to proceed */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Process direction attributes */\n    update_media_direction(pool, answer, offer);\n \n    /* If asymetric media is allowed, then just check that remote answer has \n     * codecs that are within the offer. \n     *\n     * Otherwise if asymetric media is not allowed, then we will choose only\n     * one codec in our initial offer to match the answer.\n     */\n    if (allow_asym) {\n\tfor (i=0; i<answer->desc.fmt_count; ++i) {\n\t    unsigned j;\n\t    pj_str_t *rem_fmt = &answer->desc.fmt[i];\n\n\t    for (j=0; j<offer->desc.fmt_count; ++j) {\n\t\tif (pj_strcmp(rem_fmt, &answer->desc.fmt[j])==0)\n\t\t    break;\n\t    }\n\n\t    if (j != offer->desc.fmt_count) {\n\t\t/* Found at least one common codec. */\n\t\tbreak;\n\t    }\n\t}\n\n\tif (i == answer->desc.fmt_count) {\n\t    /* No common codec in the answer! */\n\t    return PJMEDIA_SDPNEG_EANSNOMEDIA;\n\t}\n\n\tPJ_TODO(CHECK_SDP_NEGOTIATION_WHEN_ASYMETRIC_MEDIA_IS_ALLOWED);\n\n    } else {\n\t/* Offer format priority based on answer format index/priority */\n\tunsigned offer_fmt_prior[PJMEDIA_MAX_SDP_FMT];\n\n\t/* Remove all format in the offer that has no matching answer */\n\tfor (i=0; i<offer->desc.fmt_count;) {\n\t    unsigned pt;\n\t    pj_uint32_t j;\n\t    pj_str_t *fmt = &offer->desc.fmt[i];\n\t    \n\n\t    /* Find matching answer */\n\t    pt = pj_strtoul(fmt);\n\n\t    if (pt < 96) {\n\t\tfor (j=0; j<answer->desc.fmt_count; ++j) {\n\t\t    if (pj_strcmp(fmt, &answer->desc.fmt[j])==0)\n\t\t\tbreak;\n\t\t}\n\t    } else {\n\t\t/* This is dynamic payload type.\n\t\t * For dynamic payload type, we must look the rtpmap and\n\t\t * compare the encoding name.\n\t\t */\n\t\tconst pjmedia_sdp_attr *a;\n\t\tpjmedia_sdp_rtpmap or_;\n\n\t\t/* Get the rtpmap for the payload type in the offer. */\n\t\ta = pjmedia_sdp_media_find_attr2(offer, \"rtpmap\", fmt);\n\t\tif (!a) {\n\t\t    pj_assert(!\"Bug! Offer should have been validated\");\n\t\t    return PJ_EBUG;\n\t\t}\n\t\tpjmedia_sdp_attr_get_rtpmap(a, &or_);\n\n\t\t/* Find paylaod in answer SDP with matching \n\t\t * encoding name and clock rate.\n\t\t */\n\t\tfor (j=0; j<answer->desc.fmt_count; ++j) {\n\t\t    a = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", \n\t\t\t\t\t\t     &answer->desc.fmt[j]);\n\t\t    if (a) {\n\t\t\tpjmedia_sdp_rtpmap ar;\n\t\t\tpjmedia_sdp_attr_get_rtpmap(a, &ar);\n\n\t\t\t/* See if encoding name, clock rate, and channel\n\t\t\t * count match \n\t\t\t */\n\t\t\tif (!pj_stricmp(&or_.enc_name, &ar.enc_name) &&\n\t\t\t    or_.clock_rate == ar.clock_rate &&\n\t\t\t    (pj_stricmp(&or_.param, &ar.param)==0 ||\n\t\t\t     (ar.param.slen==1 && *ar.param.ptr=='1')))\n\t\t\t{\n\t\t\t    /* Call custom format matching callbacks */\n\t\t\t    if (custom_fmt_match(pool, &or_.enc_name,\n\t\t\t\t\t\t offer, i, answer, j, 0) ==\n\t\t\t\tPJ_SUCCESS)\n\t\t\t    {\n\t\t\t\t/* Match! */\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (j == answer->desc.fmt_count) {\n\t\t/* This format has no matching answer.\n\t\t * Remove it from our offer.\n\t\t */\n\t\tpjmedia_sdp_attr *a;\n\n\t\t/* Remove rtpmap associated with this format */\n\t\ta = pjmedia_sdp_media_find_attr2(offer, \"rtpmap\", fmt);\n\t\tif (a)\n\t\t    pjmedia_sdp_media_remove_attr(offer, a);\n\n\t\t/* Remove fmtp associated with this format */\n\t\ta = pjmedia_sdp_media_find_attr2(offer, \"fmtp\", fmt);\n\t\tif (a)\n\t\t    pjmedia_sdp_media_remove_attr(offer, a);\n\n\t\t/* Remove this format from offer's array */\n\t\tpj_array_erase(offer->desc.fmt, sizeof(offer->desc.fmt[0]),\n\t\t\t       offer->desc.fmt_count, i);\n\t\t--offer->desc.fmt_count;\n\n\t    } else {\n\t\toffer_fmt_prior[i] = j;\n\t\t++i;\n\t    }\n\t}\n\n\tif (0 == offer->desc.fmt_count) {\n\t    /* No common codec in the answer! */\n\t    return PJMEDIA_SDPNEG_EANSNOMEDIA;\n\t}\n\n\t/* Post process:\n\t * - Resort offer formats so the order match to the answer.\n\t * - Remove answer formats that unmatches to the offer.\n\t */\n\t\n\t/* Resort offer formats */\n\tfor (i=0; i<offer->desc.fmt_count; ++i) {\n\t    unsigned j;\n\t    for (j=i+1; j<offer->desc.fmt_count; ++j) {\n\t\tif (offer_fmt_prior[i] > offer_fmt_prior[j]) {\n\t\t    unsigned tmp = offer_fmt_prior[i];\n\t\t    offer_fmt_prior[i] = offer_fmt_prior[j];\n\t\t    offer_fmt_prior[j] = tmp;\n\t\t    str_swap(&offer->desc.fmt[i], &offer->desc.fmt[j]);\n\t\t}\n\t    }\n\t}\n\n\t/* Remove unmatched answer formats */\n\t{\n\t    unsigned del_cnt = 0;\n\t    for (i=0; i<answer->desc.fmt_count;) {\n\t\t/* The offer is ordered now, also the offer_fmt_prior */\n\t\tif (i >= offer->desc.fmt_count || \n\t\t    offer_fmt_prior[i]-del_cnt != i)\n\t\t{\n\t\t    pj_str_t *fmt = &answer->desc.fmt[i];\n\t\t    pjmedia_sdp_attr *a;\n\n\t\t    /* Remove rtpmap associated with this format */\n\t\t    a = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", fmt);\n\t\t    if (a)\n\t\t\tpjmedia_sdp_media_remove_attr(answer, a);\n\n\t\t    /* Remove fmtp associated with this format */\n\t\t    a = pjmedia_sdp_media_find_attr2(answer, \"fmtp\", fmt);\n\t\t    if (a)\n\t\t\tpjmedia_sdp_media_remove_attr(answer, a);\n\n\t\t    /* Remove this format from answer's array */\n\t\t    pj_array_erase(answer->desc.fmt, \n\t\t\t\t   sizeof(answer->desc.fmt[0]),\n\t\t\t\t   answer->desc.fmt_count, i);\n\t\t    --answer->desc.fmt_count;\n\n\t\t    ++del_cnt;\n\t\t} else {\n\t\t    ++i;\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Looks okay */\n    return PJ_SUCCESS;\n}\n\n\n/* Update local media session (offer) to create active local session\n * after receiving remote answer.\n */\nstatic pj_status_t process_answer(pj_pool_t *pool,\n\t\t\t\t  pjmedia_sdp_session *local_offer,\n\t\t\t\t  pjmedia_sdp_session *answer,\n\t\t\t\t  pj_bool_t allow_asym,\n\t\t\t\t  pjmedia_sdp_session **p_active)\n{\n    unsigned omi = 0; /* Offer media index */\n    unsigned ami = 0; /* Answer media index */\n    pj_bool_t has_active = PJ_FALSE;\n    pjmedia_sdp_session *offer;\n    pj_status_t status;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && local_offer && answer && p_active, PJ_EINVAL);\n\n    /* Duplicate local offer SDP. */\n    offer = pjmedia_sdp_session_clone(pool, local_offer);\n\n    /* Check that media count match between offer and answer */\n    // Ticket #527, different media count is allowed for more interoperability,\n    // however, the media order must be same between offer and answer.\n    // if (offer->media_count != answer->media_count)\n    //\t   return PJMEDIA_SDPNEG_EMISMEDIA;\n\n    /* Now update each media line in the offer with the answer. */\n    for (; omi<offer->media_count; ++omi) {\n\tif (ami == answer->media_count) {\n\t    /* The answer has less media than the offer */\n\t    pjmedia_sdp_media *am;\n\n\t    /* Generate matching-but-disabled-media for the answer */\n\t    am = sdp_media_clone_deactivate(pool, offer->media[omi],\n\t                                    offer->media[omi], offer);\n\t    answer->media[answer->media_count++] = am;\n\t    ++ami;\n\n\t    /* Deactivate our media offer too */\n\t    pjmedia_sdp_media_deactivate(pool, offer->media[omi]);\n\n\t    /* No answer media to be negotiated */\n\t    continue;\n\t}\n\n\tstatus = process_m_answer(pool, offer->media[omi], answer->media[ami],\n\t\t\t\t  allow_asym);\n\n\t/* If media type is mismatched, just disable the media. */\n\tif (status == PJMEDIA_SDPNEG_EINVANSMEDIA) {\n\t    pjmedia_sdp_media_deactivate(pool, offer->media[omi]);\n\t    continue;\n\t}\n\t/* No common format in the answer media. */\n\telse if (status == PJMEDIA_SDPNEG_EANSNOMEDIA) {\n\t    pjmedia_sdp_media_deactivate(pool, offer->media[omi]);\n\t    pjmedia_sdp_media_deactivate(pool, answer->media[ami]);\n\t} \n\t/* Return the error code, for other errors. */\n\telse if (status != PJ_SUCCESS) {\n\t    return status;\n\t}\n\n\tif (offer->media[omi]->desc.port != 0)\n\t    has_active = PJ_TRUE;\n\n\t++ami;\n    }\n\n    *p_active = offer;\n\n    return has_active ? PJ_SUCCESS : PJMEDIA_SDPNEG_ENOMEDIA;\n}\n\n\n/* Internal function to rewrite the format string in SDP attribute rtpmap\n * and fmtp.\n */\nPJ_INLINE(void) rewrite_pt(pj_pool_t *pool, pj_str_t *attr_val,\n\t\t\t   const pj_str_t *old_pt, const pj_str_t *new_pt)\n{\n    int len_diff = (int)(new_pt->slen - old_pt->slen);\n\n    /* Note that attribute value should be null-terminated. */\n    if (len_diff > 0) {\n\tpj_str_t new_val;\n\tnew_val.ptr = (char*)pj_pool_alloc(pool, attr_val->slen+len_diff+1);\n\tnew_val.slen = attr_val->slen + len_diff;\n\tpj_memcpy(new_val.ptr + len_diff, attr_val->ptr, attr_val->slen + 1);\n\t*attr_val = new_val;\n    } else if (len_diff < 0) {\n\tattr_val->slen += len_diff;\n\tpj_memmove(attr_val->ptr, attr_val->ptr - len_diff,\n\t\t   attr_val->slen + 1);\n    }\n    pj_memcpy(attr_val->ptr, new_pt->ptr, new_pt->slen);\n}\n\n\n/* Internal function to apply symmetric PT for the local answer. */\nstatic void apply_answer_symmetric_pt(pj_pool_t *pool,\n\t\t\t\t      pjmedia_sdp_media *answer,\n\t\t\t\t      unsigned pt_cnt,\n\t\t\t\t      const pj_str_t pt_offer[],\n\t\t\t\t      const pj_str_t pt_answer[])\n{\n    pjmedia_sdp_attr *a_tmp[PJMEDIA_MAX_SDP_ATTR];\n    unsigned i, a_tmp_cnt = 0;\n\n    /* Rewrite the payload types in the answer if different to\n     * the ones in the offer.\n     */\n    for (i = 0; i < pt_cnt; ++i) {\n\tpjmedia_sdp_attr *a;\n\n\t/* Skip if the PTs are the same already, e.g: static PT. */\n\tif (pj_strcmp(&pt_answer[i], &pt_offer[i]) == 0)\n\t    continue;\n\n\t/* Rewrite payload type in the answer to match to the offer */\n\tpj_strdup(pool, &answer->desc.fmt[i], &pt_offer[i]);\n\n\t/* Also update payload type in rtpmap */\n\ta = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", &pt_answer[i]);\n\tif (a) {\n\t    rewrite_pt(pool, &a->value, &pt_answer[i], &pt_offer[i]);\n\t    /* Temporarily remove the attribute in case the new payload\n\t     * type is being used by another format in the media.\n\t     */\n\t    pjmedia_sdp_media_remove_attr(answer, a);\n\t    a_tmp[a_tmp_cnt++] = a;\n\t}\n\n\t/* Also update payload type in fmtp */\n\ta = pjmedia_sdp_media_find_attr2(answer, \"fmtp\", &pt_answer[i]);\n\tif (a) {\n\t    rewrite_pt(pool, &a->value, &pt_answer[i], &pt_offer[i]);\n\t    /* Temporarily remove the attribute in case the new payload\n\t     * type is being used by another format in the media.\n\t     */\n\t    pjmedia_sdp_media_remove_attr(answer, a);\n\t    a_tmp[a_tmp_cnt++] = a;\n\t}\n    }\n\n    /* Return back 'rtpmap' and 'fmtp' attributes */\n    for (i = 0; i < a_tmp_cnt; ++i)\n\tpjmedia_sdp_media_add_attr(answer, a_tmp[i]);\n}\n\n\n/* Try to match offer with answer. */\nstatic pj_status_t match_offer(pj_pool_t *pool,\n\t\t\t       pj_bool_t prefer_remote_codec_order,\n                               pj_bool_t answer_with_multiple_codecs,\n\t\t\t       const pjmedia_sdp_media *offer,\n\t\t\t       const pjmedia_sdp_media *preanswer,\n\t\t\t       const pjmedia_sdp_session *preanswer_sdp,\n\t\t\t       pjmedia_sdp_media **p_answer)\n{\n    unsigned i;\n    pj_bool_t master_has_codec = 0,\n\t      master_has_other = 0,\n\t      found_matching_codec = 0,\n\t      found_matching_telephone_event = 0,\n\t      found_matching_other = 0;\n    unsigned pt_answer_count = 0;\n    pj_str_t pt_answer[PJMEDIA_MAX_SDP_FMT];\n    pj_str_t pt_offer[PJMEDIA_MAX_SDP_FMT];\n    pjmedia_sdp_media *answer;\n    const pjmedia_sdp_media *master, *slave;\n    unsigned nclockrate = 0, clockrate[PJMEDIA_MAX_SDP_FMT];\n    unsigned ntel_clockrate = 0, tel_clockrate[PJMEDIA_MAX_SDP_FMT];\n\n    /* If offer has zero port, just clone the offer */\n    if (offer->desc.port == 0) {\n\tanswer = sdp_media_clone_deactivate(pool, offer, preanswer,\n\t\t\t\t\t    preanswer_sdp);\n\t*p_answer = answer;\n\treturn PJ_SUCCESS;\n    }\n\n    /* If the preanswer define zero port, this media is being rejected,\n     * just clone the preanswer.\n     */\n    if (preanswer->desc.port == 0) {\n\tanswer = pjmedia_sdp_media_clone(pool, preanswer);\n\t*p_answer = answer;\n\treturn PJ_SUCCESS;\n    }\n\n    /* Set master/slave negotiator based on prefer_remote_codec_order. */\n    if (prefer_remote_codec_order) {\n\tmaster = offer;\n\tslave  = preanswer;\n    } else {\n\tmaster = preanswer;\n\tslave  = offer;\n    }\n    \n    /* With the addition of telephone-event and dodgy MS RTC SDP, \n     * the answer generation algorithm looks really shitty...\n     */\n    for (i=0; i<master->desc.fmt_count; ++i) {\n\tunsigned j;\n\t\n\tif (pj_isdigit(*master->desc.fmt[i].ptr)) {\n\t    /* This is normal/standard payload type, where it's identified\n\t     * by payload number.\n\t     */\n\t    unsigned pt;\n\n\t    pt = pj_strtoul(&master->desc.fmt[i]);\n\t    \n\t    if (pt < 96) {\n\t\t/* For static payload type, it's enough to compare just\n\t\t * the payload number.\n\t\t */\n\n\t\tmaster_has_codec = 1;\n\n\t\t/* We just need to select one codec if not allowing multiple.\n\t\t * Continue if we have selected matching codec for previous \n\t\t * payload.\n\t\t */\n\t\tif (!answer_with_multiple_codecs && found_matching_codec)\n\t\t    continue;\n\n\t\t/* Find matching codec in local descriptor. */\n\t\tfor (j=0; j<slave->desc.fmt_count; ++j) {\n\t\t    unsigned p;\n\t\t    p = pj_strtoul(&slave->desc.fmt[j]);\n\t\t    if (p == pt && pj_isdigit(*slave->desc.fmt[j].ptr)) {\n\t\t\tunsigned k;\n\n\t\t\tfound_matching_codec = 1;\n\t\t\tpt_offer[pt_answer_count] = slave->desc.fmt[j];\n\t\t\tpt_answer[pt_answer_count++] = slave->desc.fmt[j];\n\n\t\t\t/* Take note of clock rate for tel-event. Note: for\n\t\t\t * static PT, we assume the clock rate is 8000.\n\t\t\t */\n\t\t\tfor (k=0; k<nclockrate; ++k)\n\t\t\t    if (clockrate[k] == 8000)\n\t\t\t\tbreak;\n\t\t\tif (k == nclockrate)\n\t\t\t    clockrate[nclockrate++] = 8000;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    } else {\n\t\t/* This is dynamic payload type.\n\t\t * For dynamic payload type, we must look the rtpmap and\n\t\t * compare the encoding name.\n\t\t */\n\t\tconst pjmedia_sdp_attr *a;\n\t\tpjmedia_sdp_rtpmap or_;\n\t\tpj_bool_t is_codec = 0;\n\n\t\t/* Get the rtpmap for the payload type in the master. */\n\t\ta = pjmedia_sdp_media_find_attr2(master, \"rtpmap\", \n\t\t\t\t\t\t &master->desc.fmt[i]);\n\t\tif (!a) {\n\t\t    pj_assert(!\"Bug! Offer should have been validated\");\n\t\t    return PJMEDIA_SDP_EMISSINGRTPMAP;\n\t\t}\n\t\tpjmedia_sdp_attr_get_rtpmap(a, &or_);\n\n\t\tif (pj_stricmp2(&or_.enc_name, \"telephone-event\")) {\n\t\t    master_has_codec = 1;\n\t\t    if (!answer_with_multiple_codecs && found_matching_codec)\n\t\t\tcontinue;\n\t\t    is_codec = 1;\n\t\t}\n\t\t\n\t\t/* Find paylaod in our initial SDP with matching \n\t\t * encoding name and clock rate.\n\t\t */\n\t\tfor (j=0; j<slave->desc.fmt_count; ++j) {\n\t\t    a = pjmedia_sdp_media_find_attr2(slave, \"rtpmap\", \n\t\t\t\t\t\t     &slave->desc.fmt[j]);\n\t\t    if (a) {\n\t\t\tpjmedia_sdp_rtpmap lr;\n\t\t\tpjmedia_sdp_attr_get_rtpmap(a, &lr);\n\n\t\t\t/* See if encoding name, clock rate, and\n\t\t\t * channel count  match \n\t\t\t */\n\t\t\tif (!pj_stricmp(&or_.enc_name, &lr.enc_name) &&\n\t\t\t    or_.clock_rate == lr.clock_rate &&\n\t\t\t    (pj_stricmp(&or_.param, &lr.param)==0 ||\n\t\t\t     (lr.param.slen==0 && or_.param.slen==1 && \n\t\t\t\t\t\t *or_.param.ptr=='1') || \n\t\t\t     (or_.param.slen==0 && lr.param.slen==1 && \n\t\t\t\t\t\t  *lr.param.ptr=='1'))) \n\t\t\t{\n\t\t\t    /* Match! */\n\t\t\t    if (is_codec) {\n\t\t\t\tpjmedia_sdp_media *o_med, *a_med;\n\t\t\t\tunsigned o_fmt_idx, a_fmt_idx;\n\t\t\t\tunsigned k;\n\n\t\t\t\to_med = (pjmedia_sdp_media*)offer;\n\t\t\t\ta_med = (pjmedia_sdp_media*)preanswer;\n\t\t\t\to_fmt_idx = prefer_remote_codec_order? i:j;\n\t\t\t\ta_fmt_idx = prefer_remote_codec_order? j:i;\n\n\t\t\t\t/* Call custom format matching callbacks */\n\t\t\t\tif (custom_fmt_match(pool, &or_.enc_name,\n\t\t\t\t\t\t     o_med, o_fmt_idx,\n\t\t\t\t\t\t     a_med, a_fmt_idx,\n\t\t\t\t\t\t     ALLOW_MODIFY_ANSWER) !=\n\t\t\t\t    PJ_SUCCESS)\n\t\t\t\t{\n\t\t\t\t    continue;\n\t\t\t\t}\n\t\t\t\tfound_matching_codec = 1;\n\n\t\t\t\t/* Take note of clock rate for tel-event */\n\t\t\t\tfor (k=0; k<nclockrate; ++k)\n\t\t\t\t    if (clockrate[k] == or_.clock_rate)\n\t\t\t\t\tbreak;\n\t\t\t\tif (k == nclockrate)\n\t\t\t\t    clockrate[nclockrate++] = or_.clock_rate;\n\t\t\t    } else {\n\t\t\t    \tunsigned k;\n\n\t\t\t\t/* Keep track of tel-event clock rate,\n\t\t\t\t * to prevent duplicate.\n\t\t\t\t */\n\t\t\t\tfor (k=0; k<ntel_clockrate; ++k)\n\t\t\t\t    if (tel_clockrate[k] == or_.clock_rate)\n\t\t\t\t\tbreak;\n\t\t\t\tif (k < ntel_clockrate)\n\t\t\t\t    continue;\n\t\t\t\t\n\t\t\t\ttel_clockrate[ntel_clockrate++] = or_.clock_rate;\n\t\t\t\tfound_matching_telephone_event = 1;\n\t\t\t    }\n\n\t\t\t    pt_offer[pt_answer_count] = \n\t\t\t\t\t\tprefer_remote_codec_order?\n\t\t\t\t\t\toffer->desc.fmt[i]:\n\t\t\t\t\t\toffer->desc.fmt[j];\n\t\t\t    pt_answer[pt_answer_count++] = \n\t\t\t\t\t\tprefer_remote_codec_order? \n\t\t\t\t\t\tpreanswer->desc.fmt[j]:\n\t\t\t\t\t\tpreanswer->desc.fmt[i];\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t} else {\n\t    /* This is a non-standard, brain damaged SDP where the payload\n\t     * type is non-numeric. It exists e.g. in Microsoft RTC based\n\t     * UA, to indicate instant messaging capability.\n\t     * Example:\n\t     *\t- m=x-ms-message 5060 sip null\n\t     */\n\t    master_has_other = 1;\n\t    if (found_matching_other)\n\t\tcontinue;\n\n\t    for (j=0; j<slave->desc.fmt_count; ++j) {\n\t\tif (!pj_strcmp(&master->desc.fmt[i], &slave->desc.fmt[j])) {\n\t\t    /* Match */\n\t\t    found_matching_other = 1;\n\t\t    pt_offer[pt_answer_count] = prefer_remote_codec_order?\n\t\t\t\t\t\toffer->desc.fmt[i]:\n\t\t\t\t\t\toffer->desc.fmt[j];\n\t\t    pt_answer[pt_answer_count++] = prefer_remote_codec_order? \n\t\t\t\t\t\t   preanswer->desc.fmt[j]:\n\t\t\t\t\t\t   preanswer->desc.fmt[i];\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    /* See if all types of master can be matched. */\n    if (master_has_codec && !found_matching_codec) {\n\treturn PJMEDIA_SDPNEG_NOANSCODEC;\n    }\n\n    /* If this comment is removed, negotiation will fail if remote has offered\n       telephone-event and local is not configured with telephone-event\n\n    if (offer_has_telephone_event && !found_matching_telephone_event) {\n\treturn PJMEDIA_SDPNEG_NOANSTELEVENT;\n    }\n    */\n\n    if (master_has_other && !found_matching_other) {\n\treturn PJMEDIA_SDPNEG_NOANSUNKNOWN;\n    }\n\n    /* Seems like everything is in order. */\n\n    /* Remove unwanted telephone-event formats. */\n    if (found_matching_telephone_event) {\n\tpj_str_t first_televent_offer = {0};\n\tpj_str_t first_televent_answer = {0};\n\tunsigned matched_cnt = 0;\n\n\tfor (i=0; i<pt_answer_count; ) {\n\t    const pjmedia_sdp_attr *a;\n\t    pjmedia_sdp_rtpmap r;\n\t    unsigned j;\n\n\t    /* Skip static PT, as telephone-event uses dynamic PT */\n\t    if (!pj_isdigit(*pt_answer[i].ptr) || pj_strtol(&pt_answer[i])<96)\n\t    {\n\t\t++i;\n\t\tcontinue;\n\t    }\n\n\t    /* Get the rtpmap for format. */\n\t    a = pjmedia_sdp_media_find_attr2(preanswer, \"rtpmap\",\n\t\t\t\t\t     &pt_answer[i]);\n\t    pj_assert(a);\n\t    pjmedia_sdp_attr_get_rtpmap(a, &r);\n\n\t    /* Only care for telephone-event format */\n\t    if (pj_stricmp2(&r.enc_name, \"telephone-event\")) {\n\t\t++i;\n\t\tcontinue;\n\t    }\n\n\t    if (first_televent_offer.slen == 0) {\n\t\tfirst_televent_offer = pt_offer[i];\n\t\tfirst_televent_answer = pt_answer[i];\n\t    }\n\n\t    for (j=0; j<nclockrate; ++j) {\n\t\tif (r.clock_rate==clockrate[j])\n\t\t    break;\n\t    }\n\n\t    /* This tel-event's clockrate is unwanted, remove the tel-event */\n\t    if (j==nclockrate) {\n\t\tpj_array_erase(pt_answer, sizeof(pt_answer[0]),\n\t\t\t       pt_answer_count, i);\n\t\tpj_array_erase(pt_offer, sizeof(pt_offer[0]),\n\t\t\t       pt_answer_count, i);\n\t\tpt_answer_count--;\n\t    } else {\n\t\t++matched_cnt;\n\t\t++i;\n\t    }\n\t}\n\n\t/* Tel-event is wanted, but no matched clock rate (to the selected\n\t * audio codec), just put back any first matched tel-event formats.\n\t */\n\tif (!matched_cnt) {\n\t    pt_offer[pt_answer_count] = first_televent_offer;\n\t    pt_answer[pt_answer_count++] = first_televent_answer;\n\t}\n    }\n\n    /* Build the answer by cloning from preanswer, and reorder the payload\n     * to suit the offer.\n     */\n    answer = pjmedia_sdp_media_clone(pool, preanswer);\n    for (i=0; i<pt_answer_count; ++i) {\n\tunsigned j;\n\tfor (j=i; j<answer->desc.fmt_count; ++j) {\n\t    if (!pj_strcmp(&answer->desc.fmt[j], &pt_answer[i]))\n\t\tbreak;\n\t}\n\tpj_assert(j != answer->desc.fmt_count);\n\tstr_swap(&answer->desc.fmt[i], &answer->desc.fmt[j]);\n    }\n    \n    /* Remove unwanted local formats. */\n    for (i=pt_answer_count; i<answer->desc.fmt_count; ++i) {\n\tpjmedia_sdp_attr *a;\n\n\t/* Remove rtpmap for this format */\n\ta = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", \n\t\t\t\t\t &answer->desc.fmt[i]);\n\tif (a) {\n\t    pjmedia_sdp_media_remove_attr(answer, a);\n\t}\n\n\t/* Remove fmtp for this format */\n\ta = pjmedia_sdp_media_find_attr2(answer, \"fmtp\", \n\t\t\t\t\t &answer->desc.fmt[i]);\n\tif (a) {\n\t    pjmedia_sdp_media_remove_attr(answer, a);\n\t}\n    }\n    answer->desc.fmt_count = pt_answer_count;\n\n#if PJMEDIA_SDP_NEG_ANSWER_SYMMETRIC_PT\n    apply_answer_symmetric_pt(pool, answer, pt_answer_count,\n\t\t\t      pt_offer, pt_answer);\n#endif\n\n    /* Update media direction. */\n    update_media_direction(pool, offer, answer);\n\n    *p_answer = answer;\n    return PJ_SUCCESS;\n}\n\n/* Create complete answer for remote's offer. */\nstatic pj_status_t create_answer( pj_pool_t *pool,\n\t\t\t\t  pj_bool_t prefer_remote_codec_order,\n                                  pj_bool_t answer_with_multiple_codecs,\n\t\t\t\t  const pjmedia_sdp_session *initial,\n\t\t\t\t  const pjmedia_sdp_session *offer,\n\t\t\t\t  pjmedia_sdp_session **p_answer)\n{\n    pj_status_t status = PJMEDIA_SDPNEG_ENOMEDIA;\n    pj_bool_t has_active = PJ_FALSE;\n    pjmedia_sdp_session *answer;\n    char media_used[PJMEDIA_MAX_SDP_MEDIA];\n    unsigned i;\n\n    /* Validate remote offer. \n     * This should have been validated before.\n     */\n    PJ_ASSERT_RETURN((status=pjmedia_sdp_validate(offer))==PJ_SUCCESS, status);\n\n    /* Create initial answer by duplicating initial SDP,\n     * but clear all media lines. The media lines will be filled up later.\n     */\n    answer = pjmedia_sdp_session_clone(pool, initial);\n    PJ_ASSERT_RETURN(answer != NULL, PJ_ENOMEM);\n\n    answer->media_count = 0;\n\n    pj_bzero(media_used, sizeof(media_used));\n\n    /* For each media line, create our answer based on our initial\n     * capability.\n     */\n    for (i=0; i<offer->media_count; ++i) {\n\tconst pjmedia_sdp_media *om;\t/* offer */\n\tconst pjmedia_sdp_media *im;\t/* initial media */\n\tpjmedia_sdp_media *am = NULL;\t/* answer/result */\n\tunsigned j;\n\n\tom = offer->media[i];\n\n\t/* Find media description in our initial capability that matches\n\t * the media type and transport type of offer's media, has\n\t * matching codec, and has not been used to answer other offer.\n\t */\n\tfor (im=NULL, j=0; j<initial->media_count; ++j) {\n\t    im = initial->media[j];\n\t    if (pj_strcmp(&om->desc.media, &im->desc.media)==0 &&\n\t\tpj_strcmp(&om->desc.transport, &im->desc.transport)==0 &&\n\t\tmedia_used[j] == 0)\n\t    {\n                pj_status_t status2;\n\n\t\t/* See if it has matching codec. */\n\t\tstatus2 = match_offer(pool, prefer_remote_codec_order,\n                                      answer_with_multiple_codecs,\n\t\t\t\t      om, im, initial, &am);\n\t\tif (status2 == PJ_SUCCESS) {\n\t\t    /* Mark media as used. */\n\t\t    media_used[j] = 1;\n\t\t    break;\n                } else {\n                    status = status2;\n                }\n\t    }\n\t}\n\n\tif (j==initial->media_count) {\n\t    /* No matching media.\n\t     * Reject the offer by setting the port to zero in the answer.\n\t     */\n\t    /* For simplicity in the construction of the answer, we'll\n\t     * just clone the media from the offer. Anyway receiver will\n\t     * ignore anything in the media once it sees that the port\n\t     * number is zero.\n\t     */\n\t    am = sdp_media_clone_deactivate(pool, om, om, answer);\n\t} else {\n\t    /* The answer is in am */\n\t    pj_assert(am != NULL);\n\t}\n\n\t/* Add the media answer */\n\tanswer->media[answer->media_count++] = am;\n\n\t/* Check if this media is active.*/\n\tif (am->desc.port != 0)\n\t    has_active = PJ_TRUE;\n    }\n\n    *p_answer = answer;\n\n    return has_active ? PJ_SUCCESS : status;\n}\n\n/* Cancel offer */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_cancel_offer(pjmedia_sdp_neg *neg)\n{\n    PJ_ASSERT_RETURN(neg, PJ_EINVAL);\n\n    /* Must be in LOCAL_OFFER state. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER ||\n\t\t     neg->state == PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER,\n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    if (neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER &&\n\tneg->active_local_sdp) \n    {\n\t/* Increment next version number. This happens if for example\n\t * the reinvite offer is rejected by 488. If we don't increment\n\t * the version here, the next offer will have the same version.\n\t */\n\tneg->active_local_sdp->origin.version++;\n    }\n\n    /* Revert back initial SDP */\n    if (neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER)\n\tneg->initial_sdp = neg->initial_sdp_tmp;\n\n    /* Clear temporary SDP */\n    neg->initial_sdp_tmp = NULL;\n    neg->neg_local_sdp = neg->neg_remote_sdp = NULL;\n    neg->has_remote_answer = PJ_FALSE;\n\n    /* Reset state to done */\n    neg->state = PJMEDIA_SDP_NEG_STATE_DONE;\n\n    return PJ_SUCCESS;\n}\n\n\n/* The best bit: SDP negotiation function! */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_negotiate( pj_pool_t *pool,\n\t\t\t\t\t       pjmedia_sdp_neg *neg,\n\t\t\t\t\t       pj_bool_t allow_asym)\n{\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg, PJ_EINVAL);\n\n    /* Must be in STATE_WAIT_NEGO state. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_WAIT_NEGO, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* Must have remote offer. */\n    PJ_ASSERT_RETURN(neg->neg_remote_sdp, PJ_EBUG);\n\n    if (neg->has_remote_answer) {\n\tpjmedia_sdp_session *active;\n\tstatus = process_answer(pool, neg->neg_local_sdp, neg->neg_remote_sdp,\n\t\t\t        allow_asym, &active);\n\tif (status == PJ_SUCCESS) {\n\t    /* Only update active SDPs when negotiation is successfull */\n\t    neg->active_local_sdp = active;\n\t    neg->active_remote_sdp = neg->neg_remote_sdp;\n\t}\n    } else {\n\tpjmedia_sdp_session *answer = NULL;\n\n\tstatus = create_answer(pool, neg->prefer_remote_codec_order,\n                               neg->answer_with_multiple_codecs,\n\t\t\t       neg->neg_local_sdp, neg->neg_remote_sdp,\n\t\t\t       &answer);\n\tif (status == PJ_SUCCESS) {\n\t    pj_uint32_t active_ver;\n\n\t    if (neg->active_local_sdp)\n\t\tactive_ver = neg->active_local_sdp->origin.version;\n\t    else\n\t\tactive_ver = neg->initial_sdp->origin.version;\n\n#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n\t    answer->origin.version = active_ver;\n\n\t    if ((neg->active_local_sdp == NULL) || \n\t\t(pjmedia_sdp_session_cmp(answer, neg->active_local_sdp, 0) \n\t\t\t\t\t\t\t\t!= PJ_SUCCESS))\n\t    {\n\t\t++answer->origin.version;\n\t    }\n#else\n\t    answer->origin.version = active_ver + 1;\n#endif\t    \n\t    /* Only update active SDPs when negotiation is successfull */\n\t    neg->active_local_sdp = answer;\n\t    neg->active_remote_sdp = neg->neg_remote_sdp;\n\t}\n    }\n\n    /* State is DONE regardless */\n    neg->state = PJMEDIA_SDP_NEG_STATE_DONE;\n\n    /* Save state */\n    neg->answer_was_remote = neg->has_remote_answer;\n\n    /* Revert back initial SDP if nego fails */\n    if (status != PJ_SUCCESS)\n\tneg->initial_sdp = neg->initial_sdp_tmp;\n\n    /* Clear temporary SDP */\n    neg->initial_sdp_tmp = NULL;\n    neg->neg_local_sdp = neg->neg_remote_sdp = NULL;\n    neg->has_remote_answer = PJ_FALSE;\n\n    return status;\n}\n\n\nstatic pj_status_t custom_fmt_match(pj_pool_t *pool,\n\t\t\t\t    const pj_str_t *fmt_name,\n\t\t\t\t    pjmedia_sdp_media *offer,\n\t\t\t\t    unsigned o_fmt_idx,\n\t\t\t\t    pjmedia_sdp_media *answer,\n\t\t\t\t    unsigned a_fmt_idx,\n\t\t\t\t    unsigned option)\n{\n    unsigned i;\n\n    for (i = 0; i < fmt_match_cb_cnt; ++i) {\n\tif (pj_stricmp(fmt_name, &fmt_match_cb[i].fmt_name) == 0) {\n\t    pj_assert(fmt_match_cb[i].cb);\n\t    return (*fmt_match_cb[i].cb)(pool, offer, o_fmt_idx,\n\t\t\t\t\t answer, a_fmt_idx,\n\t\t\t\t\t option);\n\t}\n    }\n\n    /* Not customized format matching found, should be matched */\n    return PJ_SUCCESS;\n}\n\n/* Register customized SDP format negotiation callback function. */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\tconst pj_str_t *fmt_name,\n\t\t\t\t\tpjmedia_sdp_neg_fmt_match_cb cb)\n{\n    struct fmt_match_cb_t *f = NULL;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(fmt_name, PJ_EINVAL);\n\n    /* Check if the callback for the format name has been registered */\n    for (i = 0; i < fmt_match_cb_cnt; ++i) {\n\tif (pj_stricmp(fmt_name, &fmt_match_cb[i].fmt_name) == 0)\n\t    break;\n    }\n\n    /* Unregistration */\n    \n    if (cb == NULL) {\n\tif (i == fmt_match_cb_cnt)\n\t    return PJ_ENOTFOUND;\n\n\tpj_array_erase(fmt_match_cb, sizeof(fmt_match_cb[0]),\n\t\t       fmt_match_cb_cnt, i);\n\tfmt_match_cb_cnt--;\n\n\treturn PJ_SUCCESS;\n    }\n\n    /* Registration */\n\n    if (i < fmt_match_cb_cnt) {\n\t/* The same format name has been registered before */\n\tif (cb != fmt_match_cb[i].cb)\n\t    return PJ_EEXISTS;\n\telse\n\t    return PJ_SUCCESS;\n    }\n\n    if (fmt_match_cb_cnt >= PJ_ARRAY_SIZE(fmt_match_cb))\n\treturn PJ_ETOOMANY;\n\n    f = &fmt_match_cb[fmt_match_cb_cnt++];\n    f->fmt_name = *fmt_name;\n    f->cb = cb;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Match format in the SDP media offer and answer. */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_fmt_match(pj_pool_t *pool,\n\t\t\t\t\t      pjmedia_sdp_media *offer,\n\t\t\t\t\t      unsigned o_fmt_idx,\n\t\t\t\t\t      pjmedia_sdp_media *answer,\n\t\t\t\t\t      unsigned a_fmt_idx,\n\t\t\t\t\t      unsigned option)\n{\n    const pjmedia_sdp_attr *attr;\n    pjmedia_sdp_rtpmap o_rtpmap, a_rtpmap;\n    unsigned o_pt;\n    unsigned a_pt;\n\n    o_pt = pj_strtoul(&offer->desc.fmt[o_fmt_idx]);\n    a_pt = pj_strtoul(&answer->desc.fmt[a_fmt_idx]);\n\n    if (o_pt < 96 || a_pt < 96) {\n\tif (o_pt == a_pt)\n\t    return PJ_SUCCESS;\n\telse\n\t    return PJMEDIA_SDP_EFORMATNOTEQUAL;\n    }\n\n    /* Get the format rtpmap from the offer. */\n    attr = pjmedia_sdp_media_find_attr2(offer, \"rtpmap\", \n\t\t\t\t\t&offer->desc.fmt[o_fmt_idx]);\n    if (!attr) {\n\tpj_assert(!\"Bug! Offer haven't been validated\");\n\treturn PJ_EBUG;\n    }\n    pjmedia_sdp_attr_get_rtpmap(attr, &o_rtpmap);\n\n    /* Get the format rtpmap from the answer. */\n    attr = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", \n\t\t\t\t\t&answer->desc.fmt[a_fmt_idx]);\n    if (!attr) {\n\tpj_assert(!\"Bug! Answer haven't been validated\");\n\treturn PJ_EBUG;\n    }\n    pjmedia_sdp_attr_get_rtpmap(attr, &a_rtpmap);\n\n    if (pj_stricmp(&o_rtpmap.enc_name, &a_rtpmap.enc_name) != 0 ||\n\t(o_rtpmap.clock_rate != a_rtpmap.clock_rate) ||\n\t(!(pj_stricmp(&o_rtpmap.param, &a_rtpmap.param) == 0 ||\n\t   (a_rtpmap.param.slen == 0 && o_rtpmap.param.slen == 1 &&\n\t    *o_rtpmap.param.ptr == '1') ||\n\t   (o_rtpmap.param.slen == 0 && a_rtpmap.param.slen == 1 &&\n\t    *a_rtpmap.param.ptr=='1'))))\n    {\n\treturn PJMEDIA_SDP_EFORMATNOTEQUAL;\n    }\n\n    return custom_fmt_match(pool, &o_rtpmap.enc_name,\n\t\t\t    offer, o_fmt_idx, answer, a_fmt_idx, option);\n}\n\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/sdp_neg.h>\n#include <pjmedia/sdp.h>\n#include <pjmedia/errno.h>\n#include <pj/assert.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/ctype.h>\n#include <pj/array.h>\n\n/**\n * This structure describes SDP media negotiator.\n */\nstruct pjmedia_sdp_neg\n{\n    pjmedia_sdp_neg_state state;\t    /**< Negotiator state.\t     */\n    pj_bool_t\t\t  prefer_remote_codec_order;\n    pj_bool_t             answer_with_multiple_codecs;\n    pj_bool_t\t\t  has_remote_answer;\n    pj_bool_t\t\t  answer_was_remote;\n\n    pjmedia_sdp_session\t*initial_sdp,\t    /**< Initial local SDP\t     */\n\t\t\t*initial_sdp_tmp,   /**< Temporary initial local SDP */\n\t\t\t*active_local_sdp,  /**< Currently active local SDP. */\n\t\t\t*active_remote_sdp, /**< Currently active remote's.  */\n\t\t\t*neg_local_sdp,\t    /**< Temporary local SDP.\t     */\n\t\t\t*neg_remote_sdp;    /**< Temporary remote SDP.\t     */\n};\n\nstatic const char *state_str[] = \n{\n    \"STATE_NULL\",\n    \"STATE_LOCAL_OFFER\",\n    \"STATE_REMOTE_OFFER\",\n    \"STATE_WAIT_NEGO\",\n    \"STATE_DONE\",\n};\n\n/* Definition of customized SDP format negotiation callback */\nstruct fmt_match_cb_t\n{\n    pj_str_t\t\t\t    fmt_name;\n    pjmedia_sdp_neg_fmt_match_cb    cb;\n};\n\n/* Number of registered customized SDP format negotiation callbacks */\nstatic unsigned fmt_match_cb_cnt;\n\n/* The registered customized SDP format negotiation callbacks */\nstatic struct fmt_match_cb_t \n\t      fmt_match_cb[PJMEDIA_SDP_NEG_MAX_CUSTOM_FMT_NEG_CB];\n\n/* Redefining a very long identifier name, just for convenience */\n#define ALLOW_MODIFY_ANSWER PJMEDIA_SDP_NEG_FMT_MATCH_ALLOW_MODIFY_ANSWER\n\nstatic pj_status_t custom_fmt_match( pj_pool_t *pool,\n\t\t\t\t   const pj_str_t *fmt_name,\n\t\t\t\t   pjmedia_sdp_media *offer,\n\t\t\t\t   unsigned o_fmt_idx,\n\t\t\t\t   pjmedia_sdp_media *answer,\n\t\t\t\t   unsigned a_fmt_idx,\n\t\t\t\t   unsigned option);\n\n\n/*\n * Get string representation of negotiator state.\n */\nPJ_DEF(const char*) pjmedia_sdp_neg_state_str(pjmedia_sdp_neg_state state)\n{\n    if ((int)state >=0 && state < (pjmedia_sdp_neg_state)PJ_ARRAY_SIZE(state_str))\n\treturn state_str[state];\n\n    return \"<?UNKNOWN?>\";\n}\n\n\n/*\n * Create with local offer.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_create_w_local_offer( pj_pool_t *pool,\n\t\t\t\t      const pjmedia_sdp_session *local,\n\t\t\t\t      pjmedia_sdp_neg **p_neg)\n{\n    pjmedia_sdp_neg *neg;\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && local && p_neg, PJ_EINVAL);\n\n    *p_neg = NULL;\n\n    /* Validate local offer. */\n    PJ_ASSERT_RETURN((status=pjmedia_sdp_validate(local))==PJ_SUCCESS, status);\n\n    /* Create and initialize negotiator. */\n    neg = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_neg);\n    PJ_ASSERT_RETURN(neg != NULL, PJ_ENOMEM);\n\n    neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n    neg->prefer_remote_codec_order = PJMEDIA_SDP_NEG_PREFER_REMOTE_CODEC_ORDER;\n    neg->answer_with_multiple_codecs = PJMEDIA_SDP_NEG_ANSWER_MULTIPLE_CODECS;\n    neg->initial_sdp = pjmedia_sdp_session_clone(pool, local);\n    neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);\n\n    *p_neg = neg;\n    return PJ_SUCCESS;\n}\n\n/*\n * Create with remote offer and initial local offer/answer.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_create_w_remote_offer(pj_pool_t *pool,\n\t\t\t\t      const pjmedia_sdp_session *initial,\n\t\t\t\t      const pjmedia_sdp_session *remote,\n\t\t\t\t      pjmedia_sdp_neg **p_neg)\n{\n    pjmedia_sdp_neg *neg;\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && remote && p_neg, PJ_EINVAL);\n\n    *p_neg = NULL;\n\n    /* Validate remote offer and initial answer */\n    status = pjmedia_sdp_validate2(remote, PJ_FALSE);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Create and initialize negotiator. */\n    neg = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_neg);\n    PJ_ASSERT_RETURN(neg != NULL, PJ_ENOMEM);\n\n    neg->prefer_remote_codec_order = PJMEDIA_SDP_NEG_PREFER_REMOTE_CODEC_ORDER;\n    neg->answer_with_multiple_codecs = PJMEDIA_SDP_NEG_ANSWER_MULTIPLE_CODECS;\n    neg->neg_remote_sdp = pjmedia_sdp_session_clone(pool, remote);\n\n    if (initial) {\n\tPJ_ASSERT_RETURN((status=pjmedia_sdp_validate(initial))==PJ_SUCCESS, \n\t\t\t status);\n\n\tneg->initial_sdp = pjmedia_sdp_session_clone(pool, initial);\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, initial);\n\n\tneg->state = PJMEDIA_SDP_NEG_STATE_WAIT_NEGO;\n\n    } else {\n\t\n\tneg->state = PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER;\n\n    }\n\n    *p_neg = neg;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Set codec order preference.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_prefer_remote_codec_order(\n\t\t\t\t\t\tpjmedia_sdp_neg *neg,\n\t\t\t\t\t\tpj_bool_t prefer_remote)\n{\n    PJ_ASSERT_RETURN(neg, PJ_EINVAL);\n    neg->prefer_remote_codec_order = prefer_remote;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Set multiple codec answering.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_answer_multiple_codecs(\n                        pjmedia_sdp_neg *neg,\n                        pj_bool_t answer_multiple)\n{\n    PJ_ASSERT_RETURN(neg, PJ_EINVAL);\n    neg->answer_with_multiple_codecs = answer_multiple;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get SDP negotiator state.\n */\nPJ_DEF(pjmedia_sdp_neg_state) pjmedia_sdp_neg_get_state( pjmedia_sdp_neg *neg )\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(neg != NULL, PJMEDIA_SDP_NEG_STATE_NULL);\n    return neg->state;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_get_active_local( pjmedia_sdp_neg *neg,\n\t\t\t\t\tconst pjmedia_sdp_session **local)\n{\n    PJ_ASSERT_RETURN(neg && local, PJ_EINVAL);\n    PJ_ASSERT_RETURN(neg->active_local_sdp, PJMEDIA_SDPNEG_ENOACTIVE);\n\n    *local = neg->active_local_sdp;\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_get_active_remote( pjmedia_sdp_neg *neg,\n\t\t\t\t   const pjmedia_sdp_session **remote)\n{\n    PJ_ASSERT_RETURN(neg && remote, PJ_EINVAL);\n    PJ_ASSERT_RETURN(neg->active_remote_sdp, PJMEDIA_SDPNEG_ENOACTIVE);\n\n    *remote = neg->active_remote_sdp;\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_bool_t) pjmedia_sdp_neg_was_answer_remote(pjmedia_sdp_neg *neg)\n{\n    PJ_ASSERT_RETURN(neg, PJ_FALSE);\n\n    return neg->answer_was_remote;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_get_neg_remote( pjmedia_sdp_neg *neg,\n\t\t\t\tconst pjmedia_sdp_session **remote)\n{\n    PJ_ASSERT_RETURN(neg && remote, PJ_EINVAL);\n    PJ_ASSERT_RETURN(neg->neg_remote_sdp, PJMEDIA_SDPNEG_ENONEG);\n\n    *remote = neg->neg_remote_sdp;\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_get_neg_local( pjmedia_sdp_neg *neg,\n\t\t\t       const pjmedia_sdp_session **local)\n{\n    PJ_ASSERT_RETURN(neg && local, PJ_EINVAL);\n    PJ_ASSERT_RETURN(neg->neg_local_sdp, PJMEDIA_SDPNEG_ENONEG);\n\n    *local = neg->neg_local_sdp;\n    return PJ_SUCCESS;\n}\n\nstatic pjmedia_sdp_media *sdp_media_clone_deactivate(\n\t\t\t\t    pj_pool_t *pool,\n                                    const pjmedia_sdp_media *rem_med,\n                                    const pjmedia_sdp_media *local_med,\n                                    const pjmedia_sdp_session *local_sess)\n{\n    pjmedia_sdp_media *res;\n\n    res = pjmedia_sdp_media_clone_deactivate(pool, rem_med);\n    if (!res)\n\treturn NULL;\n\n    if (!res->conn && (!local_sess || !local_sess->conn)) {\n\tif (local_med && local_med->conn)\n\t    res->conn = pjmedia_sdp_conn_clone(pool, local_med->conn);\n\telse {\n\t    res->conn = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_conn);\n\t    res->conn->net_type = pj_str(\"IN\");\n\t    res->conn->addr_type = pj_str(\"IP4\");\n\t    res->conn->addr = pj_str(\"127.0.0.1\");\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Modify local SDP and wait for remote answer.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer( pj_pool_t *pool,\n\t\t\t\t    pjmedia_sdp_neg *neg,\n\t\t\t\t    const pjmedia_sdp_session *local)\n{\n    return pjmedia_sdp_neg_modify_local_offer2(pool, neg, 0, local);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(\n                                    pj_pool_t *pool,\n\t\t\t\t    pjmedia_sdp_neg *neg,\n                                    unsigned flags,\n\t\t\t\t    const pjmedia_sdp_session *local)\n{\n    pjmedia_sdp_session *new_offer;\n    pjmedia_sdp_session *old_offer;\n    unsigned oi; /* old offer media index */\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);\n\n    /* Can only do this in STATE_DONE. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* Validate the new offer */\n    status = pjmedia_sdp_validate(local);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Change state to STATE_LOCAL_OFFER */\n    neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n\n    /* When there is no active local SDP in state PJMEDIA_SDP_NEG_STATE_DONE,\n     * it means that the previous initial SDP nego must have been failed,\n     * so we'll just set the local SDP offer here.\n     */\n    if (!neg->active_local_sdp) {\n\tneg->initial_sdp_tmp = NULL;\n\tneg->initial_sdp = pjmedia_sdp_session_clone(pool, local);\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);\n\n\treturn PJ_SUCCESS;\n    }\n\n    /* Init vars */\n    old_offer = neg->active_local_sdp;\n    new_offer = pjmedia_sdp_session_clone(pool, local);\n\n    /* RFC 3264 Section 8: When issuing an offer that modifies the session,\n     * the \"o=\" line of the new SDP MUST be identical to that in the\n     * previous SDP, except that the version in the origin field MUST\n     * increment by one from the previous SDP.\n     */\n    pj_strdup(pool, &new_offer->origin.user, &old_offer->origin.user);\n    new_offer->origin.id = old_offer->origin.id;\n\n    pj_strdup(pool, &new_offer->origin.net_type, &old_offer->origin.net_type);\n    pj_strdup(pool, &new_offer->origin.addr_type,&old_offer->origin.addr_type);\n    pj_strdup(pool, &new_offer->origin.addr, &old_offer->origin.addr);\n\n    if ((flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE) == 0) {\n       /* Generating the new offer, in the case media lines doesn't match the\n        * active SDP (e.g. current/active SDP's have m=audio and m=video lines,\n        * and the new offer only has m=audio line), the negotiator will fix \n        * the new offer by reordering and adding the missing media line with \n        * port number set to zero.\n        */\n        for (oi = 0; oi < old_offer->media_count; ++oi) {\n\t    pjmedia_sdp_media *om;\n\t    pjmedia_sdp_media *nm;\n\t    unsigned ni; /* new offer media index */\n\t    pj_bool_t found = PJ_FALSE;\n\n\t    om = old_offer->media[oi];\n\t    for (ni = oi; ni < new_offer->media_count; ++ni) {\n\t        nm = new_offer->media[ni];\n\t        if (pj_strcmp(&nm->desc.media, &om->desc.media) == 0) {\n\t\t    if (ni != oi) {\n\t\t        /* The same media found but the position unmatched to\n                         * the old offer, so let's put this media in the right\n                         * place, and keep the order of the rest.\n\t\t         */\n\t\t        pj_array_insert(\n                            new_offer->media,\t\t /* array    */\n\t\t\t    sizeof(new_offer->media[0]), /* elmt size*/\n\t\t\t    ni,\t\t\t\t /* count    */\n\t\t            oi,\t\t\t\t /* pos      */\n\t\t\t    &nm);\t\t\t /* new elmt */\n\t\t    }\n\t\t    found = PJ_TRUE;\n\t\t    break;\n\t        }\n\t    }\n\t    if (!found) {\n\t        pjmedia_sdp_media *m;\n\n\t        m = sdp_media_clone_deactivate(pool, om, om, local);\n\n\t        pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n\t\t\t        new_offer->media_count++, oi, &m);\n\t    }\n        }\n    } else {\n        /* If media type change is allowed, the negotiator only needs to fix \n         * the new offer by adding the missing media line(s) with port number\n         * set to zero.\n         */\n        for (oi = new_offer->media_count; oi < old_offer->media_count; ++oi) {\n            pjmedia_sdp_media *m;\n\n\t    m = sdp_media_clone_deactivate(pool, old_offer->media[oi],\n                                           old_offer->media[oi], local);\n\n\t    pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n\t                    new_offer->media_count++, oi, &m);\n\n        }\n    }\n\n    /* New_offer fixed */\n#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n    new_offer->origin.version = old_offer->origin.version;\n\n    if (pjmedia_sdp_session_cmp(new_offer, neg->initial_sdp, 0) != PJ_SUCCESS)\n    {\n\t++new_offer->origin.version;\n    }    \n#else\n    new_offer->origin.version = old_offer->origin.version + 1;\n#endif\n    \n    neg->initial_sdp_tmp = neg->initial_sdp;\n    neg->initial_sdp = new_offer;\n    neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, new_offer);\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_send_local_offer( pj_pool_t *pool,\n\t\t\t\t  pjmedia_sdp_neg *neg,\n\t\t\t\t  const pjmedia_sdp_session **offer)\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(neg && offer, PJ_EINVAL);\n\n    *offer = NULL;\n\n    /* Can only do this in STATE_DONE or STATE_LOCAL_OFFER. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE ||\n\t\t     neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    if (neg->state == PJMEDIA_SDP_NEG_STATE_DONE) {\n\t/* If in STATE_DONE, set the active SDP as the offer. */\n\tPJ_ASSERT_RETURN(neg->active_local_sdp, PJMEDIA_SDPNEG_ENOACTIVE);\n\n\t/* Retain initial SDP */\n\tif (neg->initial_sdp) {\n\t    neg->initial_sdp_tmp = neg->initial_sdp;\n    \t    neg->initial_sdp = pjmedia_sdp_session_clone(pool,\n\t\t\t\t\t\t\t neg->initial_sdp);\n\t}\n\n\tneg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, \n\t\t\t\t\t\t       neg->active_local_sdp);\n\n#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n    \tif (pjmedia_sdp_session_cmp(neg->neg_local_sdp, \n    \t\t\t\t    neg->initial_sdp, 0) != PJ_SUCCESS)\n    \t{\n\t    neg->neg_local_sdp->origin.version++;\n    \t}    \n#else\n    \tneg->neg_local_sdp->origin.version++;\n#endif\n\n\t*offer = neg->neg_local_sdp;\n\n    } else {\n\t/* We assume that we're in STATE_LOCAL_OFFER.\n\t * In this case set the neg_local_sdp as the offer.\n\t */\n\t*offer = neg->neg_local_sdp;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_remote_answer( pj_pool_t *pool,\n\t\t\t\t   pjmedia_sdp_neg *neg,\n\t\t\t\t   const pjmedia_sdp_session *remote)\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && remote, PJ_EINVAL);\n\n    /* Can only do this in STATE_LOCAL_OFFER.\n     * If we haven't provided local offer, then rx_remote_offer() should\n     * be called instead of this function.\n     */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* We're ready to negotiate. */\n    neg->state = PJMEDIA_SDP_NEG_STATE_WAIT_NEGO;\n    neg->has_remote_answer = PJ_TRUE;\n    neg->neg_remote_sdp = pjmedia_sdp_session_clone(pool, remote);\n \n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_remote_offer( pj_pool_t *pool,\n\t\t\t\t  pjmedia_sdp_neg *neg,\n\t\t\t\t  const pjmedia_sdp_session *remote)\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && remote, PJ_EINVAL);\n\n    /* Can only do this in STATE_DONE.\n     * If we already provide local offer, then rx_remote_answer() should\n     * be called instead of this function.\n     */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* State now is STATE_REMOTE_OFFER. */\n    neg->state = PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER;\n    neg->neg_remote_sdp = pjmedia_sdp_session_clone(pool, remote);\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_set_local_answer( pj_pool_t *pool,\n\t\t\t\t  pjmedia_sdp_neg *neg,\n\t\t\t\t  const pjmedia_sdp_session *local)\n{\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);\n\n    /* Can only do this in STATE_REMOTE_OFFER or WAIT_NEGO.\n     * If we already provide local offer, then set_remote_answer() should\n     * be called instead of this function.\n     */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER ||\n    \t\t     neg->state == PJMEDIA_SDP_NEG_STATE_WAIT_NEGO, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* State now is STATE_WAIT_NEGO. */\n    neg->state = PJMEDIA_SDP_NEG_STATE_WAIT_NEGO;\n    if (local) {\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);\n\tif (neg->initial_sdp) {\n\t    /* Retain initial_sdp value. */\n\t    neg->initial_sdp_tmp = neg->initial_sdp;\n\t    neg->initial_sdp = pjmedia_sdp_session_clone(pool,\n\t\t\t\t\t\t\t neg->initial_sdp);\n        \n\t    /* I don't think there is anything in RFC 3264 that mandates\n\t     * answerer to place the same origin (and increment version)\n\t     * in the answer, but probably it won't hurt either.\n\t     * Note that the version will be incremented in \n\t     * pjmedia_sdp_neg_negotiate()\n\t     */\n\t    neg->neg_local_sdp->origin.id = neg->initial_sdp->origin.id;\n\t} else {\n\t    neg->initial_sdp = pjmedia_sdp_session_clone(pool, local);\n\t}\n    } else {\n\tPJ_ASSERT_RETURN(neg->initial_sdp, PJMEDIA_SDPNEG_ENOINITIAL);\n\tneg->initial_sdp_tmp = neg->initial_sdp;\n\tneg->initial_sdp = pjmedia_sdp_session_clone(pool, neg->initial_sdp);\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, neg->initial_sdp);\n    }\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_bool_t) pjmedia_sdp_neg_has_local_answer(pjmedia_sdp_neg *neg)\n{\n    pj_assert(neg && neg->state==PJMEDIA_SDP_NEG_STATE_WAIT_NEGO);\n    return !neg->has_remote_answer;\n}\n\n\n/* Swap string. */\nstatic void str_swap(pj_str_t *str1, pj_str_t *str2)\n{\n    pj_str_t tmp = *str1;\n    *str1 = *str2;\n    *str2 = tmp;\n}\n\nstatic void remove_all_media_directions(pjmedia_sdp_media *m)\n{\n    pjmedia_sdp_media_remove_all_attr(m, \"inactive\");\n    pjmedia_sdp_media_remove_all_attr(m, \"sendrecv\");\n    pjmedia_sdp_media_remove_all_attr(m, \"sendonly\");\n    pjmedia_sdp_media_remove_all_attr(m, \"recvonly\");\n}\n\n/* Update media direction based on peer's media direction */\nstatic void update_media_direction(pj_pool_t *pool,\n\t\t\t\t   const pjmedia_sdp_media *remote,\n\t\t\t\t   pjmedia_sdp_media *local)\n{\n    pjmedia_dir old_dir = PJMEDIA_DIR_ENCODING_DECODING,\n\t        new_dir;\n\n    /* Get the media direction of local SDP */\n    if (pjmedia_sdp_media_find_attr2(local, \"sendonly\", NULL))\n\told_dir = PJMEDIA_DIR_ENCODING;\n    else if (pjmedia_sdp_media_find_attr2(local, \"recvonly\", NULL))\n\told_dir = PJMEDIA_DIR_DECODING;\n    else if (pjmedia_sdp_media_find_attr2(local, \"inactive\", NULL))\n\told_dir = PJMEDIA_DIR_NONE;\n\n    new_dir = old_dir;\n\n    /* Adjust local media direction based on remote media direction */\n    if (pjmedia_sdp_media_find_attr2(remote, \"inactive\", NULL) != NULL) {\n\t/* If remote has \"a=inactive\", then local is inactive too */\n\n\tnew_dir = PJMEDIA_DIR_NONE;\n\n    } else if(pjmedia_sdp_media_find_attr2(remote, \"sendonly\", NULL) != NULL) {\n\t/* If remote has \"a=sendonly\", then set local to \"recvonly\" if\n\t * it is currently \"sendrecv\". Otherwise if local is NOT \"recvonly\",\n\t * then set local direction to \"inactive\".\n\t */\n\tswitch (old_dir) {\n\tcase PJMEDIA_DIR_ENCODING_DECODING:\n\t    new_dir = PJMEDIA_DIR_DECODING;\n\t    break;\n\tcase PJMEDIA_DIR_DECODING:\n\t    /* No change */\n\t    break;\n\tdefault:\n\t    new_dir = PJMEDIA_DIR_NONE;\n\t    break;\n\t}\n\n    } else if(pjmedia_sdp_media_find_attr2(remote, \"recvonly\", NULL) != NULL) {\n\t/* If remote has \"a=recvonly\", then set local to \"sendonly\" if\n\t * it is currently \"sendrecv\". Otherwise if local is NOT \"sendonly\",\n\t * then set local direction to \"inactive\"\n\t */\n    \n\tswitch (old_dir) {\n\tcase PJMEDIA_DIR_ENCODING_DECODING:\n\t    new_dir = PJMEDIA_DIR_ENCODING;\n\t    break;\n\tcase PJMEDIA_DIR_ENCODING:\n\t    /* No change */\n\t    break;\n\tdefault:\n\t    new_dir = PJMEDIA_DIR_NONE;\n\t    break;\n\t}\n\n    } else {\n\t/* Remote indicates \"sendrecv\" capability. No change to local \n\t * direction \n\t */\n    }\n\n    if (new_dir != old_dir) {\n\tpjmedia_sdp_attr *a = NULL;\n\n\tremove_all_media_directions(local);\n\n\tswitch (new_dir) {\n\tcase PJMEDIA_DIR_NONE:\n\t    a = pjmedia_sdp_attr_create(pool, \"inactive\", NULL);\n\t    break;\n\tcase PJMEDIA_DIR_ENCODING:\n\t    a = pjmedia_sdp_attr_create(pool, \"sendonly\", NULL);\n\t    break;\n\tcase PJMEDIA_DIR_DECODING:\n\t    a = pjmedia_sdp_attr_create(pool, \"recvonly\", NULL);\n\t    break;\n\tdefault:\n\t    /* sendrecv */\n\t    break;\n\t}\n\t\n\tif (a) {\n\t    pjmedia_sdp_media_add_attr(local, a);\n\t}\n    }\n}\n\n\n/* Update single local media description to after receiving answer\n * from remote.\n */\nstatic pj_status_t process_m_answer( pj_pool_t *pool,\n\t\t\t\t     pjmedia_sdp_media *offer,\n\t\t\t\t     pjmedia_sdp_media *answer,\n\t\t\t\t     pj_bool_t allow_asym)\n{\n    unsigned i;\n\n    /* Check that the media type match our offer. */\n\n    if (pj_strcmp(&answer->desc.media, &offer->desc.media)!=0) {\n\t/* The media type in the answer is different than the offer! */\n\treturn PJMEDIA_SDPNEG_EINVANSMEDIA;\n    }\n\n\n    /* Check that transport in the answer match our offer. */\n\n    /* At this point, transport type must be compatible, \n     * the transport instance will do more validation later.\n     */\n    if (pjmedia_sdp_transport_cmp(&answer->desc.transport, \n\t\t\t\t  &offer->desc.transport) \n\t!= PJ_SUCCESS)\n    {\n\treturn PJMEDIA_SDPNEG_EINVANSTP;\n    }\n\n\n    /* Check if remote has rejected our offer */\n    if (answer->desc.port == 0) {\n\t\n\t/* Remote has rejected our offer. \n\t * Deactivate our media too.\n\t */\n\tpjmedia_sdp_media_deactivate(pool, offer);\n\n\t/* Don't need to proceed */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Ticket #1148: check if remote answer does not set port to zero when\n     * offered with port zero. Let's just tolerate it.\n     */\n    if (offer->desc.port == 0) {\n\t/* Don't need to proceed */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Process direction attributes */\n    update_media_direction(pool, answer, offer);\n \n    /* If asymetric media is allowed, then just check that remote answer has \n     * codecs that are within the offer. \n     *\n     * Otherwise if asymetric media is not allowed, then we will choose only\n     * one codec in our initial offer to match the answer.\n     */\n    if (allow_asym) {\n\tfor (i=0; i<answer->desc.fmt_count; ++i) {\n\t    unsigned j;\n\t    pj_str_t *rem_fmt = &answer->desc.fmt[i];\n\n\t    for (j=0; j<offer->desc.fmt_count; ++j) {\n\t\tif (pj_strcmp(rem_fmt, &answer->desc.fmt[j])==0)\n\t\t    break;\n\t    }\n\n\t    if (j != offer->desc.fmt_count) {\n\t\t/* Found at least one common codec. */\n\t\tbreak;\n\t    }\n\t}\n\n\tif (i == answer->desc.fmt_count) {\n\t    /* No common codec in the answer! */\n\t    return PJMEDIA_SDPNEG_EANSNOMEDIA;\n\t}\n\n\tPJ_TODO(CHECK_SDP_NEGOTIATION_WHEN_ASYMETRIC_MEDIA_IS_ALLOWED);\n\n    } else {\n\t/* Offer format priority based on answer format index/priority */\n\tunsigned offer_fmt_prior[PJMEDIA_MAX_SDP_FMT];\n\n\t/* Remove all format in the offer that has no matching answer */\n\tfor (i=0; i<offer->desc.fmt_count;) {\n\t    unsigned pt;\n\t    pj_uint32_t j;\n\t    pj_str_t *fmt = &offer->desc.fmt[i];\n\t    \n\n\t    /* Find matching answer */\n\t    pt = pj_strtoul(fmt);\n\n\t    if (pt < 96) {\n\t\tfor (j=0; j<answer->desc.fmt_count; ++j) {\n\t\t    if (pj_strcmp(fmt, &answer->desc.fmt[j])==0)\n\t\t\tbreak;\n\t\t}\n\t    } else {\n\t\t/* This is dynamic payload type.\n\t\t * For dynamic payload type, we must look the rtpmap and\n\t\t * compare the encoding name.\n\t\t */\n\t\tconst pjmedia_sdp_attr *a;\n\t\tpjmedia_sdp_rtpmap or_;\n\n\t\t/* Get the rtpmap for the payload type in the offer. */\n\t\ta = pjmedia_sdp_media_find_attr2(offer, \"rtpmap\", fmt);\n\t\tif (!a) {\n\t\t    pj_assert(!\"Bug! Offer should have been validated\");\n\t\t    return PJ_EBUG;\n\t\t}\n\t\tpjmedia_sdp_attr_get_rtpmap(a, &or_);\n\n\t\t/* Find paylaod in answer SDP with matching \n\t\t * encoding name and clock rate.\n\t\t */\n\t\tfor (j=0; j<answer->desc.fmt_count; ++j) {\n\t\t    a = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", \n\t\t\t\t\t\t     &answer->desc.fmt[j]);\n\t\t    if (a) {\n\t\t\tpjmedia_sdp_rtpmap ar;\n\t\t\tpjmedia_sdp_attr_get_rtpmap(a, &ar);\n\n\t\t\t/* See if encoding name, clock rate, and channel\n\t\t\t * count match \n\t\t\t */\n\t\t\tif (!pj_stricmp(&or_.enc_name, &ar.enc_name) &&\n\t\t\t    or_.clock_rate == ar.clock_rate &&\n\t\t\t    (pj_stricmp(&or_.param, &ar.param)==0 ||\n\t\t\t     (ar.param.slen==1 && *ar.param.ptr=='1')))\n\t\t\t{\n\t\t\t    /* Call custom format matching callbacks */\n\t\t\t    if (custom_fmt_match(pool, &or_.enc_name,\n\t\t\t\t\t\t offer, i, answer, j, 0) ==\n\t\t\t\tPJ_SUCCESS)\n\t\t\t    {\n\t\t\t\t/* Match! */\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (j == answer->desc.fmt_count) {\n\t\t/* This format has no matching answer.\n\t\t * Remove it from our offer.\n\t\t */\n\t\tpjmedia_sdp_attr *a;\n\n\t\t/* Remove rtpmap associated with this format */\n\t\ta = pjmedia_sdp_media_find_attr2(offer, \"rtpmap\", fmt);\n\t\tif (a)\n\t\t    pjmedia_sdp_media_remove_attr(offer, a);\n\n\t\t/* Remove fmtp associated with this format */\n\t\ta = pjmedia_sdp_media_find_attr2(offer, \"fmtp\", fmt);\n\t\tif (a)\n\t\t    pjmedia_sdp_media_remove_attr(offer, a);\n\n\t\t/* Remove this format from offer's array */\n\t\tpj_array_erase(offer->desc.fmt, sizeof(offer->desc.fmt[0]),\n\t\t\t       offer->desc.fmt_count, i);\n\t\t--offer->desc.fmt_count;\n\n\t    } else {\n\t\toffer_fmt_prior[i] = j;\n\t\t++i;\n\t    }\n\t}\n\n\tif (0 == offer->desc.fmt_count) {\n\t    /* No common codec in the answer! */\n\t    return PJMEDIA_SDPNEG_EANSNOMEDIA;\n\t}\n\n\t/* Post process:\n\t * - Resort offer formats so the order match to the answer.\n\t * - Remove answer formats that unmatches to the offer.\n\t */\n\t\n\t/* Resort offer formats */\n\tfor (i=0; i<offer->desc.fmt_count; ++i) {\n\t    unsigned j;\n\t    for (j=i+1; j<offer->desc.fmt_count; ++j) {\n\t\tif (offer_fmt_prior[i] > offer_fmt_prior[j]) {\n\t\t    unsigned tmp = offer_fmt_prior[i];\n\t\t    offer_fmt_prior[i] = offer_fmt_prior[j];\n\t\t    offer_fmt_prior[j] = tmp;\n\t\t    str_swap(&offer->desc.fmt[i], &offer->desc.fmt[j]);\n\t\t}\n\t    }\n\t}\n\n\t/* Remove unmatched answer formats */\n\t{\n\t    unsigned del_cnt = 0;\n\t    for (i=0; i<answer->desc.fmt_count;) {\n\t\t/* The offer is ordered now, also the offer_fmt_prior */\n\t\tif (i >= offer->desc.fmt_count || \n\t\t    offer_fmt_prior[i]-del_cnt != i)\n\t\t{\n\t\t    pj_str_t *fmt = &answer->desc.fmt[i];\n\t\t    pjmedia_sdp_attr *a;\n\n\t\t    /* Remove rtpmap associated with this format */\n\t\t    a = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", fmt);\n\t\t    if (a)\n\t\t\tpjmedia_sdp_media_remove_attr(answer, a);\n\n\t\t    /* Remove fmtp associated with this format */\n\t\t    a = pjmedia_sdp_media_find_attr2(answer, \"fmtp\", fmt);\n\t\t    if (a)\n\t\t\tpjmedia_sdp_media_remove_attr(answer, a);\n\n\t\t    /* Remove this format from answer's array */\n\t\t    pj_array_erase(answer->desc.fmt, \n\t\t\t\t   sizeof(answer->desc.fmt[0]),\n\t\t\t\t   answer->desc.fmt_count, i);\n\t\t    --answer->desc.fmt_count;\n\n\t\t    ++del_cnt;\n\t\t} else {\n\t\t    ++i;\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Looks okay */\n    return PJ_SUCCESS;\n}\n\n\n/* Update local media session (offer) to create active local session\n * after receiving remote answer.\n */\nstatic pj_status_t process_answer(pj_pool_t *pool,\n\t\t\t\t  pjmedia_sdp_session *local_offer,\n\t\t\t\t  pjmedia_sdp_session *answer,\n\t\t\t\t  pj_bool_t allow_asym,\n\t\t\t\t  pjmedia_sdp_session **p_active)\n{\n    unsigned omi = 0; /* Offer media index */\n    unsigned ami = 0; /* Answer media index */\n    pj_bool_t has_active = PJ_FALSE;\n    pjmedia_sdp_session *offer;\n    pj_status_t status;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && local_offer && answer && p_active, PJ_EINVAL);\n\n    /* Duplicate local offer SDP. */\n    offer = pjmedia_sdp_session_clone(pool, local_offer);\n\n    /* Check that media count match between offer and answer */\n    // Ticket #527, different media count is allowed for more interoperability,\n    // however, the media order must be same between offer and answer.\n    // if (offer->media_count != answer->media_count)\n    //\t   return PJMEDIA_SDPNEG_EMISMEDIA;\n\n    /* Now update each media line in the offer with the answer. */\n    for (; omi<offer->media_count; ++omi) {\n\tif (ami == answer->media_count) {\n\t    /* The answer has less media than the offer */\n\t    pjmedia_sdp_media *am;\n\n\t    /* Generate matching-but-disabled-media for the answer */\n\t    am = sdp_media_clone_deactivate(pool, offer->media[omi],\n\t                                    offer->media[omi], offer);\n\t    answer->media[answer->media_count++] = am;\n\t    ++ami;\n\n\t    /* Deactivate our media offer too */\n\t    pjmedia_sdp_media_deactivate(pool, offer->media[omi]);\n\n\t    /* No answer media to be negotiated */\n\t    continue;\n\t}\n\n\tstatus = process_m_answer(pool, offer->media[omi], answer->media[ami],\n\t\t\t\t  allow_asym);\n\n\t/* If media type is mismatched, just disable the media. */\n\tif (status == PJMEDIA_SDPNEG_EINVANSMEDIA) {\n\t    pjmedia_sdp_media_deactivate(pool, offer->media[omi]);\n\t    continue;\n\t}\n\t/* No common format in the answer media. */\n\telse if (status == PJMEDIA_SDPNEG_EANSNOMEDIA) {\n\t    pjmedia_sdp_media_deactivate(pool, offer->media[omi]);\n\t    pjmedia_sdp_media_deactivate(pool, answer->media[ami]);\n\t} \n\t/* Return the error code, for other errors. */\n\telse if (status != PJ_SUCCESS) {\n\t    return status;\n\t}\n\n\tif (offer->media[omi]->desc.port != 0)\n\t    has_active = PJ_TRUE;\n\n\t++ami;\n    }\n\n    *p_active = offer;\n\n    return has_active ? PJ_SUCCESS : PJMEDIA_SDPNEG_ENOMEDIA;\n}\n\n\n/* Internal function to rewrite the format string in SDP attribute rtpmap\n * and fmtp.\n */\nPJ_INLINE(void) rewrite_pt(pj_pool_t *pool, pj_str_t *attr_val,\n\t\t\t   const pj_str_t *old_pt, const pj_str_t *new_pt)\n{\n    int len_diff = (int)(new_pt->slen - old_pt->slen);\n\n    /* Note that attribute value should be null-terminated. */\n    if (len_diff > 0) {\n\tpj_str_t new_val;\n\tnew_val.ptr = (char*)pj_pool_alloc(pool, attr_val->slen+len_diff+1);\n\tnew_val.slen = attr_val->slen + len_diff;\n\tpj_memcpy(new_val.ptr + len_diff, attr_val->ptr, attr_val->slen + 1);\n\t*attr_val = new_val;\n    } else if (len_diff < 0) {\n\tattr_val->slen += len_diff;\n\tpj_memmove(attr_val->ptr, attr_val->ptr - len_diff,\n\t\t   attr_val->slen + 1);\n    }\n    pj_memcpy(attr_val->ptr, new_pt->ptr, new_pt->slen);\n}\n\n\n/* Internal function to apply symmetric PT for the local answer. */\nstatic void apply_answer_symmetric_pt(pj_pool_t *pool,\n\t\t\t\t      pjmedia_sdp_media *answer,\n\t\t\t\t      unsigned pt_cnt,\n\t\t\t\t      const pj_str_t pt_offer[],\n\t\t\t\t      const pj_str_t pt_answer[])\n{\n    pjmedia_sdp_attr *a_tmp[PJMEDIA_MAX_SDP_ATTR];\n    unsigned i, a_tmp_cnt = 0;\n\n    /* Rewrite the payload types in the answer if different to\n     * the ones in the offer.\n     */\n    for (i = 0; i < pt_cnt; ++i) {\n\tpjmedia_sdp_attr *a;\n\n\t/* Skip if the PTs are the same already, e.g: static PT. */\n\tif (pj_strcmp(&pt_answer[i], &pt_offer[i]) == 0)\n\t    continue;\n\n\t/* Rewrite payload type in the answer to match to the offer */\n\tpj_strdup(pool, &answer->desc.fmt[i], &pt_offer[i]);\n\n\t/* Also update payload type in rtpmap */\n\ta = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", &pt_answer[i]);\n\tif (a) {\n\t    rewrite_pt(pool, &a->value, &pt_answer[i], &pt_offer[i]);\n\t    /* Temporarily remove the attribute in case the new payload\n\t     * type is being used by another format in the media.\n\t     */\n\t    pjmedia_sdp_media_remove_attr(answer, a);\n\t    a_tmp[a_tmp_cnt++] = a;\n\t}\n\n\t/* Also update payload type in fmtp */\n\ta = pjmedia_sdp_media_find_attr2(answer, \"fmtp\", &pt_answer[i]);\n\tif (a) {\n\t    rewrite_pt(pool, &a->value, &pt_answer[i], &pt_offer[i]);\n\t    /* Temporarily remove the attribute in case the new payload\n\t     * type is being used by another format in the media.\n\t     */\n\t    pjmedia_sdp_media_remove_attr(answer, a);\n\t    a_tmp[a_tmp_cnt++] = a;\n\t}\n    }\n\n    /* Return back 'rtpmap' and 'fmtp' attributes */\n    for (i = 0; i < a_tmp_cnt; ++i)\n\tpjmedia_sdp_media_add_attr(answer, a_tmp[i]);\n}\n\n\n/* Try to match offer with answer. */\nstatic pj_status_t match_offer(pj_pool_t *pool,\n\t\t\t       pj_bool_t prefer_remote_codec_order,\n                               pj_bool_t answer_with_multiple_codecs,\n\t\t\t       const pjmedia_sdp_media *offer,\n\t\t\t       const pjmedia_sdp_media *preanswer,\n\t\t\t       const pjmedia_sdp_session *preanswer_sdp,\n\t\t\t       pjmedia_sdp_media **p_answer)\n{\n    unsigned i;\n    pj_bool_t master_has_codec = 0,\n\t      master_has_other = 0,\n\t      found_matching_codec = 0,\n\t      found_matching_telephone_event = 0,\n\t      found_matching_other = 0;\n    unsigned pt_answer_count = 0;\n    pj_str_t pt_answer[PJMEDIA_MAX_SDP_FMT];\n    pj_str_t pt_offer[PJMEDIA_MAX_SDP_FMT];\n    pjmedia_sdp_media *answer;\n    const pjmedia_sdp_media *master, *slave;\n    unsigned nclockrate = 0, clockrate[PJMEDIA_MAX_SDP_FMT];\n    unsigned ntel_clockrate = 0, tel_clockrate[PJMEDIA_MAX_SDP_FMT];\n\n    /* If offer has zero port, just clone the offer */\n    if (offer->desc.port == 0) {\n\tanswer = sdp_media_clone_deactivate(pool, offer, preanswer,\n\t\t\t\t\t    preanswer_sdp);\n\t*p_answer = answer;\n\treturn PJ_SUCCESS;\n    }\n\n    /* If the preanswer define zero port, this media is being rejected,\n     * just clone the preanswer.\n     */\n    if (preanswer->desc.port == 0) {\n\tanswer = pjmedia_sdp_media_clone(pool, preanswer);\n\t*p_answer = answer;\n\treturn PJ_SUCCESS;\n    }\n\n    /* Set master/slave negotiator based on prefer_remote_codec_order. */\n    if (prefer_remote_codec_order) {\n\tmaster = offer;\n\tslave  = preanswer;\n    } else {\n\tmaster = preanswer;\n\tslave  = offer;\n    }\n    \n    /* With the addition of telephone-event and dodgy MS RTC SDP, \n     * the answer generation algorithm looks really shitty...\n     */\n    for (i=0; i<master->desc.fmt_count; ++i) {\n\tunsigned j;\n\t\n\tif (pj_isdigit(*master->desc.fmt[i].ptr)) {\n\t    /* This is normal/standard payload type, where it's identified\n\t     * by payload number.\n\t     */\n\t    unsigned pt;\n\n\t    pt = pj_strtoul(&master->desc.fmt[i]);\n\t    \n\t    if (pt < 96) {\n\t\t/* For static payload type, it's enough to compare just\n\t\t * the payload number.\n\t\t */\n\n\t\tmaster_has_codec = 1;\n\n\t\t/* We just need to select one codec if not allowing multiple.\n\t\t * Continue if we have selected matching codec for previous \n\t\t * payload.\n\t\t */\n\t\tif (!answer_with_multiple_codecs && found_matching_codec)\n\t\t    continue;\n\n\t\t/* Find matching codec in local descriptor. */\n\t\tfor (j=0; j<slave->desc.fmt_count; ++j) {\n\t\t    unsigned p;\n\t\t    p = pj_strtoul(&slave->desc.fmt[j]);\n\t\t    if (p == pt && pj_isdigit(*slave->desc.fmt[j].ptr)) {\n\t\t\tunsigned k;\n\n\t\t\tfound_matching_codec = 1;\n\t\t\tpt_offer[pt_answer_count] = slave->desc.fmt[j];\n\t\t\tpt_answer[pt_answer_count++] = slave->desc.fmt[j];\n\n\t\t\t/* Take note of clock rate for tel-event. Note: for\n\t\t\t * static PT, we assume the clock rate is 8000.\n\t\t\t */\n\t\t\tfor (k=0; k<nclockrate; ++k)\n\t\t\t    if (clockrate[k] == 8000)\n\t\t\t\tbreak;\n\t\t\tif (k == nclockrate)\n\t\t\t    clockrate[nclockrate++] = 8000;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    } else {\n\t\t/* This is dynamic payload type.\n\t\t * For dynamic payload type, we must look the rtpmap and\n\t\t * compare the encoding name.\n\t\t */\n\t\tconst pjmedia_sdp_attr *a;\n\t\tpjmedia_sdp_rtpmap or_;\n\t\tpj_bool_t is_codec = 0;\n\n\t\t/* Get the rtpmap for the payload type in the master. */\n\t\ta = pjmedia_sdp_media_find_attr2(master, \"rtpmap\", \n\t\t\t\t\t\t &master->desc.fmt[i]);\n\t\tif (!a) {\n\t\t    pj_assert(!\"Bug! Offer should have been validated\");\n\t\t    return PJMEDIA_SDP_EMISSINGRTPMAP;\n\t\t}\n\t\tpjmedia_sdp_attr_get_rtpmap(a, &or_);\n\n\t\tif (pj_stricmp2(&or_.enc_name, \"telephone-event\")) {\n\t\t    master_has_codec = 1;\n\t\t    if (!answer_with_multiple_codecs && found_matching_codec)\n\t\t\tcontinue;\n\t\t    is_codec = 1;\n\t\t}\n\t\t\n\t\t/* Find paylaod in our initial SDP with matching \n\t\t * encoding name and clock rate.\n\t\t */\n\t\tfor (j=0; j<slave->desc.fmt_count; ++j) {\n\t\t    a = pjmedia_sdp_media_find_attr2(slave, \"rtpmap\", \n\t\t\t\t\t\t     &slave->desc.fmt[j]);\n\t\t    if (a) {\n\t\t\tpjmedia_sdp_rtpmap lr;\n\t\t\tpjmedia_sdp_attr_get_rtpmap(a, &lr);\n\n\t\t\t/* See if encoding name, clock rate, and\n\t\t\t * channel count  match \n\t\t\t */\n\t\t\tif (!pj_stricmp(&or_.enc_name, &lr.enc_name) &&\n\t\t\t    or_.clock_rate == lr.clock_rate &&\n\t\t\t    (pj_stricmp(&or_.param, &lr.param)==0 ||\n\t\t\t     (lr.param.slen==0 && or_.param.slen==1 && \n\t\t\t\t\t\t *or_.param.ptr=='1') || \n\t\t\t     (or_.param.slen==0 && lr.param.slen==1 && \n\t\t\t\t\t\t  *lr.param.ptr=='1'))) \n\t\t\t{\n\t\t\t    /* Match! */\n\t\t\t    if (is_codec) {\n\t\t\t\tpjmedia_sdp_media *o_med, *a_med;\n\t\t\t\tunsigned o_fmt_idx, a_fmt_idx;\n\t\t\t\tunsigned k;\n\n\t\t\t\to_med = (pjmedia_sdp_media*)offer;\n\t\t\t\ta_med = (pjmedia_sdp_media*)preanswer;\n\t\t\t\to_fmt_idx = prefer_remote_codec_order? i:j;\n\t\t\t\ta_fmt_idx = prefer_remote_codec_order? j:i;\n\n\t\t\t\t/* Call custom format matching callbacks */\n\t\t\t\tif (custom_fmt_match(pool, &or_.enc_name,\n\t\t\t\t\t\t     o_med, o_fmt_idx,\n\t\t\t\t\t\t     a_med, a_fmt_idx,\n\t\t\t\t\t\t     ALLOW_MODIFY_ANSWER) !=\n\t\t\t\t    PJ_SUCCESS)\n\t\t\t\t{\n\t\t\t\t    continue;\n\t\t\t\t}\n\t\t\t\tfound_matching_codec = 1;\n\n\t\t\t\t/* Take note of clock rate for tel-event */\n\t\t\t\tfor (k=0; k<nclockrate; ++k)\n\t\t\t\t    if (clockrate[k] == or_.clock_rate)\n\t\t\t\t\tbreak;\n\t\t\t\tif (k == nclockrate)\n\t\t\t\t    clockrate[nclockrate++] = or_.clock_rate;\n\t\t\t    } else {\n\t\t\t    \tunsigned k;\n\n\t\t\t\t/* Keep track of tel-event clock rate,\n\t\t\t\t * to prevent duplicate.\n\t\t\t\t */\n\t\t\t\tfor (k=0; k<ntel_clockrate; ++k)\n\t\t\t\t    if (tel_clockrate[k] == or_.clock_rate)\n\t\t\t\t\tbreak;\n\t\t\t\tif (k < ntel_clockrate)\n\t\t\t\t    continue;\n\t\t\t\t\n\t\t\t\ttel_clockrate[ntel_clockrate++] = or_.clock_rate;\n\t\t\t\tfound_matching_telephone_event = 1;\n\t\t\t    }\n\n\t\t\t    pt_offer[pt_answer_count] = \n\t\t\t\t\t\tprefer_remote_codec_order?\n\t\t\t\t\t\toffer->desc.fmt[i]:\n\t\t\t\t\t\toffer->desc.fmt[j];\n\t\t\t    pt_answer[pt_answer_count++] = \n\t\t\t\t\t\tprefer_remote_codec_order? \n\t\t\t\t\t\tpreanswer->desc.fmt[j]:\n\t\t\t\t\t\tpreanswer->desc.fmt[i];\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t} else {\n\t    /* This is a non-standard, brain damaged SDP where the payload\n\t     * type is non-numeric. It exists e.g. in Microsoft RTC based\n\t     * UA, to indicate instant messaging capability.\n\t     * Example:\n\t     *\t- m=x-ms-message 5060 sip null\n\t     */\n\t    master_has_other = 1;\n\t    if (found_matching_other)\n\t\tcontinue;\n\n\t    for (j=0; j<slave->desc.fmt_count; ++j) {\n\t\tif (!pj_strcmp(&master->desc.fmt[i], &slave->desc.fmt[j])) {\n\t\t    /* Match */\n\t\t    found_matching_other = 1;\n\t\t    pt_offer[pt_answer_count] = prefer_remote_codec_order?\n\t\t\t\t\t\toffer->desc.fmt[i]:\n\t\t\t\t\t\toffer->desc.fmt[j];\n\t\t    pt_answer[pt_answer_count++] = prefer_remote_codec_order? \n\t\t\t\t\t\t   preanswer->desc.fmt[j]:\n\t\t\t\t\t\t   preanswer->desc.fmt[i];\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    /* See if all types of master can be matched. */\n    if (master_has_codec && !found_matching_codec) {\n\treturn PJMEDIA_SDPNEG_NOANSCODEC;\n    }\n\n    /* If this comment is removed, negotiation will fail if remote has offered\n       telephone-event and local is not configured with telephone-event\n\n    if (offer_has_telephone_event && !found_matching_telephone_event) {\n\treturn PJMEDIA_SDPNEG_NOANSTELEVENT;\n    }\n    */\n\n    if (master_has_other && !found_matching_other) {\n\treturn PJMEDIA_SDPNEG_NOANSUNKNOWN;\n    }\n\n    /* Seems like everything is in order. */\n\n    /* Remove unwanted telephone-event formats. */\n    if (found_matching_telephone_event) {\n\tpj_str_t first_televent_offer = {0};\n\tpj_str_t first_televent_answer = {0};\n\tunsigned matched_cnt = 0;\n\n\tfor (i=0; i<pt_answer_count; ) {\n\t    const pjmedia_sdp_attr *a;\n\t    pjmedia_sdp_rtpmap r;\n\t    unsigned j;\n\n\t    /* Skip static PT, as telephone-event uses dynamic PT */\n\t    if (!pj_isdigit(*pt_answer[i].ptr) || pj_strtol(&pt_answer[i])<96)\n\t    {\n\t\t++i;\n\t\tcontinue;\n\t    }\n\n\t    /* Get the rtpmap for format. */\n\t    a = pjmedia_sdp_media_find_attr2(preanswer, \"rtpmap\",\n\t\t\t\t\t     &pt_answer[i]);\n\t    pj_assert(a);\n\t    pjmedia_sdp_attr_get_rtpmap(a, &r);\n\n\t    /* Only care for telephone-event format */\n\t    if (pj_stricmp2(&r.enc_name, \"telephone-event\")) {\n\t\t++i;\n\t\tcontinue;\n\t    }\n\n\t    if (first_televent_offer.slen == 0) {\n\t\tfirst_televent_offer = pt_offer[i];\n\t\tfirst_televent_answer = pt_answer[i];\n\t    }\n\n\t    for (j=0; j<nclockrate; ++j) {\n\t\tif (r.clock_rate==clockrate[j])\n\t\t    break;\n\t    }\n\n\t    /* This tel-event's clockrate is unwanted, remove the tel-event */\n\t    if (j==nclockrate) {\n\t\tpj_array_erase(pt_answer, sizeof(pt_answer[0]),\n\t\t\t       pt_answer_count, i);\n\t\tpj_array_erase(pt_offer, sizeof(pt_offer[0]),\n\t\t\t       pt_answer_count, i);\n\t\tpt_answer_count--;\n\t    } else {\n\t\t++matched_cnt;\n\t\t++i;\n\t    }\n\t}\n\n\t/* Tel-event is wanted, but no matched clock rate (to the selected\n\t * audio codec), just put back any first matched tel-event formats.\n\t */\n\tif (!matched_cnt) {\n\t    pt_offer[pt_answer_count] = first_televent_offer;\n\t    pt_answer[pt_answer_count++] = first_televent_answer;\n\t}\n    }\n\n    /* Build the answer by cloning from preanswer, and reorder the payload\n     * to suit the offer.\n     */\n    answer = pjmedia_sdp_media_clone(pool, preanswer);\n    for (i=0; i<pt_answer_count; ++i) {\n\tunsigned j;\n\tfor (j=i; j<answer->desc.fmt_count; ++j) {\n\t    if (!pj_strcmp(&answer->desc.fmt[j], &pt_answer[i]))\n\t\tbreak;\n\t}\n\tpj_assert(j != answer->desc.fmt_count);\n\tstr_swap(&answer->desc.fmt[i], &answer->desc.fmt[j]);\n    }\n    \n    /* Remove unwanted local formats. */\n    for (i=pt_answer_count; i<answer->desc.fmt_count; ++i) {\n\tpjmedia_sdp_attr *a;\n\n\t/* Remove rtpmap for this format */\n\ta = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", \n\t\t\t\t\t &answer->desc.fmt[i]);\n\tif (a) {\n\t    pjmedia_sdp_media_remove_attr(answer, a);\n\t}\n\n\t/* Remove fmtp for this format */\n\ta = pjmedia_sdp_media_find_attr2(answer, \"fmtp\", \n\t\t\t\t\t &answer->desc.fmt[i]);\n\tif (a) {\n\t    pjmedia_sdp_media_remove_attr(answer, a);\n\t}\n    }\n    answer->desc.fmt_count = pt_answer_count;\n\n#if PJMEDIA_SDP_NEG_ANSWER_SYMMETRIC_PT\n    apply_answer_symmetric_pt(pool, answer, pt_answer_count,\n\t\t\t      pt_offer, pt_answer);\n#endif\n\n    /* Update media direction. */\n    update_media_direction(pool, offer, answer);\n\n    *p_answer = answer;\n    return PJ_SUCCESS;\n}\n\n/* Create complete answer for remote's offer. */\nstatic pj_status_t create_answer( pj_pool_t *pool,\n\t\t\t\t  pj_bool_t prefer_remote_codec_order,\n                                  pj_bool_t answer_with_multiple_codecs,\n\t\t\t\t  const pjmedia_sdp_session *initial,\n\t\t\t\t  const pjmedia_sdp_session *offer,\n\t\t\t\t  pjmedia_sdp_session **p_answer)\n{\n    pj_status_t status = PJMEDIA_SDPNEG_ENOMEDIA;\n    pj_bool_t has_active = PJ_FALSE;\n    pjmedia_sdp_session *answer;\n    char media_used[PJMEDIA_MAX_SDP_MEDIA];\n    unsigned i;\n\n    /* Validate remote offer. \n     * This should have been validated before.\n     */\n    PJ_ASSERT_RETURN((status=pjmedia_sdp_validate(offer))==PJ_SUCCESS, status);\n\n    /* Create initial answer by duplicating initial SDP,\n     * but clear all media lines. The media lines will be filled up later.\n     */\n    answer = pjmedia_sdp_session_clone(pool, initial);\n    PJ_ASSERT_RETURN(answer != NULL, PJ_ENOMEM);\n\n    answer->media_count = 0;\n\n    pj_bzero(media_used, sizeof(media_used));\n\n    /* For each media line, create our answer based on our initial\n     * capability.\n     */\n    for (i=0; i<offer->media_count; ++i) {\n\tconst pjmedia_sdp_media *om;\t/* offer */\n\tconst pjmedia_sdp_media *im;\t/* initial media */\n\tpjmedia_sdp_media *am = NULL;\t/* answer/result */\n\tunsigned j;\n\n\tom = offer->media[i];\n\n\t/* Find media description in our initial capability that matches\n\t * the media type and transport type of offer's media, has\n\t * matching codec, and has not been used to answer other offer.\n\t */\n\tfor (im=NULL, j=0; j<initial->media_count; ++j) {\n\t    im = initial->media[j];\n\t    if (pj_strcmp(&om->desc.media, &im->desc.media)==0 &&\n\t\tpj_strcmp(&om->desc.transport, &im->desc.transport)==0 &&\n\t\tmedia_used[j] == 0)\n\t    {\n                pj_status_t status2;\n\n\t\t/* See if it has matching codec. */\n\t\tstatus2 = match_offer(pool, prefer_remote_codec_order,\n                                      answer_with_multiple_codecs,\n\t\t\t\t      om, im, initial, &am);\n\t\tif (status2 == PJ_SUCCESS) {\n\t\t    /* Mark media as used. */\n\t\t    media_used[j] = 1;\n\t\t    break;\n                } else {\n                    status = status2;\n                }\n\t    }\n\t}\n\n\tif (j==initial->media_count) {\n\t    /* No matching media.\n\t     * Reject the offer by setting the port to zero in the answer.\n\t     */\n\t    /* For simplicity in the construction of the answer, we'll\n\t     * just clone the media from the offer. Anyway receiver will\n\t     * ignore anything in the media once it sees that the port\n\t     * number is zero.\n\t     */\n\t    am = sdp_media_clone_deactivate(pool, om, om, answer);\n\t} else {\n\t    /* The answer is in am */\n\t    pj_assert(am != NULL);\n\t}\n\n\t/* Add the media answer */\n\tanswer->media[answer->media_count++] = am;\n\n\t/* Check if this media is active.*/\n\tif (am->desc.port != 0)\n\t    has_active = PJ_TRUE;\n    }\n\n    *p_answer = answer;\n\n    return has_active ? PJ_SUCCESS : status;\n}\n\n/* Cancel offer */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_cancel_offer(pjmedia_sdp_neg *neg)\n{\n    PJ_ASSERT_RETURN(neg, PJ_EINVAL);\n\n    /* Must be in LOCAL_OFFER state. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER ||\n\t\t     neg->state == PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER,\n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    if (neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER &&\n\tneg->active_local_sdp) \n    {\n\t/* Increment next version number. This happens if for example\n\t * the reinvite offer is rejected by 488. If we don't increment\n\t * the version here, the next offer will have the same version.\n\t */\n\tneg->active_local_sdp->origin.version++;\n    }\n\n    /* Revert back initial SDP */\n    if (neg->state == PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER)\n\tneg->initial_sdp = neg->initial_sdp_tmp;\n\n    /* Clear temporary SDP */\n    neg->initial_sdp_tmp = NULL;\n    neg->neg_local_sdp = neg->neg_remote_sdp = NULL;\n    neg->has_remote_answer = PJ_FALSE;\n\n    /* Reset state to done */\n    neg->state = PJMEDIA_SDP_NEG_STATE_DONE;\n\n    return PJ_SUCCESS;\n}\n\n\n/* The best bit: SDP negotiation function! */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_negotiate( pj_pool_t *pool,\n\t\t\t\t\t       pjmedia_sdp_neg *neg,\n\t\t\t\t\t       pj_bool_t allow_asym)\n{\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg, PJ_EINVAL);\n\n    /* Must be in STATE_WAIT_NEGO state. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_WAIT_NEGO, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* Must have remote offer. */\n    PJ_ASSERT_RETURN(neg->neg_remote_sdp, PJ_EBUG);\n\n    if (neg->has_remote_answer) {\n\tpjmedia_sdp_session *active;\n\tstatus = process_answer(pool, neg->neg_local_sdp, neg->neg_remote_sdp,\n\t\t\t        allow_asym, &active);\n\tif (status == PJ_SUCCESS) {\n\t    /* Only update active SDPs when negotiation is successfull */\n\t    neg->active_local_sdp = active;\n\t    neg->active_remote_sdp = neg->neg_remote_sdp;\n\t}\n    } else {\n\tpjmedia_sdp_session *answer = NULL;\n\n\tstatus = create_answer(pool, neg->prefer_remote_codec_order,\n                               neg->answer_with_multiple_codecs,\n\t\t\t       neg->neg_local_sdp, neg->neg_remote_sdp,\n\t\t\t       &answer);\n\tif (status == PJ_SUCCESS) {\n\t    pj_uint32_t active_ver;\n\n\t    if (neg->active_local_sdp)\n\t\tactive_ver = neg->active_local_sdp->origin.version;\n\t    else\n\t\tactive_ver = neg->initial_sdp->origin.version;\n\n#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n\t    answer->origin.version = active_ver;\n\n\t    if ((neg->active_local_sdp == NULL) || \n\t\t(pjmedia_sdp_session_cmp(answer, neg->active_local_sdp, 0) \n\t\t\t\t\t\t\t\t!= PJ_SUCCESS))\n\t    {\n\t\t++answer->origin.version;\n\t    }\n#else\n\t    answer->origin.version = active_ver + 1;\n#endif\t    \n\t    /* Only update active SDPs when negotiation is successfull */\n\t    neg->active_local_sdp = answer;\n\t    neg->active_remote_sdp = neg->neg_remote_sdp;\n\t}\n    }\n\n    /* State is DONE regardless */\n    neg->state = PJMEDIA_SDP_NEG_STATE_DONE;\n\n    /* Save state */\n    neg->answer_was_remote = neg->has_remote_answer;\n\n    /* Revert back initial SDP if nego fails */\n    if (status != PJ_SUCCESS)\n\tneg->initial_sdp = neg->initial_sdp_tmp;\n\n    /* Clear temporary SDP */\n    neg->initial_sdp_tmp = NULL;\n    neg->neg_local_sdp = neg->neg_remote_sdp = NULL;\n    neg->has_remote_answer = PJ_FALSE;\n\n    return status;\n}\n\n\nstatic pj_status_t custom_fmt_match(pj_pool_t *pool,\n\t\t\t\t    const pj_str_t *fmt_name,\n\t\t\t\t    pjmedia_sdp_media *offer,\n\t\t\t\t    unsigned o_fmt_idx,\n\t\t\t\t    pjmedia_sdp_media *answer,\n\t\t\t\t    unsigned a_fmt_idx,\n\t\t\t\t    unsigned option)\n{\n    unsigned i;\n\n    for (i = 0; i < fmt_match_cb_cnt; ++i) {\n\tif (pj_stricmp(fmt_name, &fmt_match_cb[i].fmt_name) == 0) {\n\t    pj_assert(fmt_match_cb[i].cb);\n\t    return (*fmt_match_cb[i].cb)(pool, offer, o_fmt_idx,\n\t\t\t\t\t answer, a_fmt_idx,\n\t\t\t\t\t option);\n\t}\n    }\n\n    /* Not customized format matching found, should be matched */\n    return PJ_SUCCESS;\n}\n\n/* Register customized SDP format negotiation callback function. */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\tconst pj_str_t *fmt_name,\n\t\t\t\t\tpjmedia_sdp_neg_fmt_match_cb cb)\n{\n    struct fmt_match_cb_t *f = NULL;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(fmt_name, PJ_EINVAL);\n\n    /* Check if the callback for the format name has been registered */\n    for (i = 0; i < fmt_match_cb_cnt; ++i) {\n\tif (pj_stricmp(fmt_name, &fmt_match_cb[i].fmt_name) == 0)\n\t    break;\n    }\n\n    /* Unregistration */\n    \n    if (cb == NULL) {\n\tif (i == fmt_match_cb_cnt)\n\t    return PJ_ENOTFOUND;\n\n\tpj_array_erase(fmt_match_cb, sizeof(fmt_match_cb[0]),\n\t\t       fmt_match_cb_cnt, i);\n\tfmt_match_cb_cnt--;\n\n\treturn PJ_SUCCESS;\n    }\n\n    /* Registration */\n\n    if (i < fmt_match_cb_cnt) {\n\t/* The same format name has been registered before */\n\tif (cb != fmt_match_cb[i].cb)\n\t    return PJ_EEXISTS;\n\telse\n\t    return PJ_SUCCESS;\n    }\n\n    if (fmt_match_cb_cnt >= PJ_ARRAY_SIZE(fmt_match_cb))\n\treturn PJ_ETOOMANY;\n\n    f = &fmt_match_cb[fmt_match_cb_cnt++];\n    f->fmt_name = *fmt_name;\n    f->cb = cb;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Match format in the SDP media offer and answer. */\nPJ_DEF(pj_status_t) pjmedia_sdp_neg_fmt_match(pj_pool_t *pool,\n\t\t\t\t\t      pjmedia_sdp_media *offer,\n\t\t\t\t\t      unsigned o_fmt_idx,\n\t\t\t\t\t      pjmedia_sdp_media *answer,\n\t\t\t\t\t      unsigned a_fmt_idx,\n\t\t\t\t\t      unsigned option)\n{\n    const pjmedia_sdp_attr *attr;\n    pjmedia_sdp_rtpmap o_rtpmap, a_rtpmap;\n    unsigned o_pt;\n    unsigned a_pt;\n\n    o_pt = pj_strtoul(&offer->desc.fmt[o_fmt_idx]);\n    a_pt = pj_strtoul(&answer->desc.fmt[a_fmt_idx]);\n\n    if (o_pt < 96 || a_pt < 96) {\n\tif (o_pt == a_pt)\n\t    return PJ_SUCCESS;\n\telse\n\t    return PJMEDIA_SDP_EFORMATNOTEQUAL;\n    }\n\n    /* Get the format rtpmap from the offer. */\n    attr = pjmedia_sdp_media_find_attr2(offer, \"rtpmap\", \n\t\t\t\t\t&offer->desc.fmt[o_fmt_idx]);\n    if (!attr) {\n\tpj_assert(!\"Bug! Offer haven't been validated\");\n\treturn PJ_EBUG;\n    }\n    pjmedia_sdp_attr_get_rtpmap(attr, &o_rtpmap);\n\n    /* Get the format rtpmap from the answer. */\n    attr = pjmedia_sdp_media_find_attr2(answer, \"rtpmap\", \n\t\t\t\t\t&answer->desc.fmt[a_fmt_idx]);\n    if (!attr) {\n\tpj_assert(!\"Bug! Answer haven't been validated\");\n\treturn PJ_EBUG;\n    }\n    pjmedia_sdp_attr_get_rtpmap(attr, &a_rtpmap);\n\n    if (pj_stricmp(&o_rtpmap.enc_name, &a_rtpmap.enc_name) != 0 ||\n\t(o_rtpmap.clock_rate != a_rtpmap.clock_rate) ||\n\t(!(pj_stricmp(&o_rtpmap.param, &a_rtpmap.param) == 0 ||\n\t   (a_rtpmap.param.slen == 0 && o_rtpmap.param.slen == 1 &&\n\t    *o_rtpmap.param.ptr == '1') ||\n\t   (o_rtpmap.param.slen == 0 && a_rtpmap.param.slen == 1 &&\n\t    *a_rtpmap.param.ptr=='1'))))\n    {\n\treturn PJMEDIA_SDP_EFORMATNOTEQUAL;\n    }\n\n    return custom_fmt_match(pool, &o_rtpmap.enc_name,\n\t\t\t    offer, o_fmt_idx, answer, a_fmt_idx, option);\n}\n\n"], "filenames": ["pjmedia/src/pjmedia/sdp_neg.c"], "buggy_code_start_loc": [307], "buggy_code_end_loc": [328], "fixing_code_start_loc": [306], "fixing_code_end_loc": [337], "type": "CWE-754", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP version 2.10 and earlier, after an initial INVITE has been sent, when two 183 responses are received, with the first one causing negotiation failure, a crash will occur. This results in a denial of service.", "other": {"cve": {"id": "CVE-2021-21375", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-10T23:15:12.520", "lastModified": "2022-10-21T22:40:21.120", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP version 2.10 and earlier, after an initial INVITE has been sent, when two 183 responses are received, with the first one causing negotiation failure, a crash will occur. This results in a denial of service."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia de c\u00f3digo abierto y gratuita escrita en lenguaje C que implementa protocolos basados ??en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE.&#xa0;En PJSIP versiones 2.10 y anteriores, despu\u00e9s de que se haya enviado una INVITE inicial, cuando son recibidas dos respuestas 183, con la primera causando un fallo en la negociaci\u00f3n, y se producir\u00e1 un bloqueo.&#xa0;Esto resulta en una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.10", "matchCriteriaId": "107D71AA-CD87-4682-B600-D583CB865E6F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/97b3d7addbaa720b7ddb0af9bf6f3e443e664365", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-hvq6-f89p-frvp", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/04/msg00023.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/05/msg00020.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-42", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/97b3d7addbaa720b7ddb0af9bf6f3e443e664365"}}