{"buggy_code": ["# encoding: utf-8\n\nrequire 'set'\n\nclass Sanitize; module Transformers; class CleanElement\n\n  # Matches a valid HTML5 data attribute name. The unicode ranges included here\n  # are a conservative subset of the full range of characters that are\n  # technically allowed, with the intent of matching the most common characters\n  # used in data attribute names while excluding uncommon or potentially\n  # misleading characters, or characters with the potential to be normalized\n  # into unsafe or confusing forms.\n  #\n  # If you need data attr names with characters that aren't included here (such\n  # as combining marks, full-width characters, or CJK), please consider creating\n  # a custom transformer to validate attributes according to your needs.\n  #\n  # http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#embedding-custom-non-visible-data-with-the-data-*-attributes\n  REGEX_DATA_ATTR = /\\Adata-(?!xml)[a-z_][\\w.\\u00E0-\\u00F6\\u00F8-\\u017F\\u01DD-\\u02AF-]*\\z/u\n\n  def initialize(config)\n    @add_attributes          = config[:add_attributes]\n    @attributes              = config[:attributes].dup\n    @elements                = config[:elements]\n    @protocols               = config[:protocols]\n    @remove_all_contents     = false\n    @remove_element_contents = Set.new\n    @whitespace_elements     = {}\n\n    @attributes.each do |element_name, attrs|\n      unless element_name == :all\n        @attributes[element_name] = Set.new(attrs).merge(@attributes[:all] || [])\n      end\n    end\n\n    # Backcompat: if :whitespace_elements is a Set, convert it to a hash.\n    if config[:whitespace_elements].is_a?(Set)\n      config[:whitespace_elements].each do |element|\n        @whitespace_elements[element] = {:before => ' ', :after => ' '}\n      end\n    else\n      @whitespace_elements = config[:whitespace_elements]\n    end\n\n    if config[:remove_contents].is_a?(Set)\n      @remove_element_contents.merge(config[:remove_contents].map(&:to_s))\n    else\n      @remove_all_contents = !!config[:remove_contents]\n    end\n  end\n\n  def call(env)\n    node = env[:node]\n    return if node.type != Nokogiri::XML::Node::ELEMENT_NODE || env[:is_whitelisted]\n\n    name = env[:node_name]\n\n    # Delete any element that isn't in the config whitelist, unless the node has\n    # already been deleted from the document.\n    #\n    # It's important that we not try to reparent the children of a node that has\n    # already been deleted, since that seems to trigger a memory leak in\n    # Nokogiri.\n    unless @elements.include?(name) || node.parent.nil?\n      # Elements like br, div, p, etc. need to be replaced with whitespace in\n      # order to preserve readability.\n      if @whitespace_elements.include?(name)\n        node.add_previous_sibling(Nokogiri::XML::Text.new(@whitespace_elements[name][:before].to_s, node.document))\n\n        unless node.children.empty?\n          node.add_next_sibling(Nokogiri::XML::Text.new(@whitespace_elements[name][:after].to_s, node.document))\n        end\n      end\n\n      unless @remove_all_contents || @remove_element_contents.include?(name)\n        node.add_previous_sibling(node.children)\n      end\n\n      node.unlink\n      return\n    end\n\n    attr_whitelist = @attributes[name] || @attributes[:all]\n\n    if attr_whitelist.nil?\n      # Delete all attributes from elements with no whitelisted attributes.\n      node.attribute_nodes.each {|attr| attr.unlink }\n    else\n      allow_data_attributes = attr_whitelist.include?(:data)\n\n      # Delete any attribute that isn't allowed on this element.\n      node.attribute_nodes.each do |attr|\n        attr_name = attr.name.downcase\n\n        if attr_whitelist.include?(attr_name)\n          # The attribute is whitelisted.\n\n          # Remove any attributes that use unacceptable protocols.\n          if @protocols.include?(name) && @protocols[name].include?(attr_name)\n            attr_protocols = @protocols[name][attr_name]\n\n            if attr.value =~ REGEX_PROTOCOL\n              attr.unlink unless attr_protocols.include?($1.downcase)\n            else\n              attr.unlink unless attr_protocols.include?(:relative)\n            end\n          end\n        else\n          # The attribute isn't whitelisted.\n\n          if allow_data_attributes && attr_name.start_with?('data-')\n            # Arbitrary data attributes are allowed. Verify that the attribute\n            # is a valid data attribute.\n            attr.unlink unless attr_name =~ REGEX_DATA_ATTR\n          else\n            # Either the attribute isn't a data attribute, or arbitrary data\n            # attributes aren't allowed. Remove the attribute.\n            attr.unlink\n          end\n        end\n      end\n    end\n\n    # Add required attributes.\n    if @add_attributes.include?(name)\n      @add_attributes[name].each {|key, val| node[key] = val }\n    end\n  end\n\nend; end; end\n", "# encoding: utf-8\nrequire_relative 'common'\n\ndescribe 'Sanitize::Transformers::CleanElement' do\n  make_my_diffs_pretty!\n  parallelize_me!\n\n  strings = {\n    :basic => {\n      :html       => '<b>Lo<!-- comment -->rem</b> <a href=\"pants\" title=\"foo\" style=\"text-decoration: underline;\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br/>amet <style>.foo { color: #fff; }</style> <script>alert(\"hello world\");</script>',\n\n      :default    => 'Lorem ipsum dolor sit amet .foo { color: #fff; } alert(\"hello world\");',\n      :restricted => '<b>Lorem</b> ipsum <strong>dolor</strong> sit amet .foo { color: #fff; } alert(\"hello world\");',\n      :basic      => '<b>Lorem</b> <a href=\"pants\" rel=\"nofollow\">ipsum</a> <a href=\"http://foo.com/\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet .foo { color: #fff; } alert(\"hello world\");',\n      :relaxed    => '<b>Lorem</b> <a href=\"pants\" title=\"foo\" style=\"text-decoration: underline;\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br>amet <style>.foo { color: #fff; }</style> alert(\"hello world\");'\n    },\n\n    :malformed => {\n      :html       => 'Lo<!-- comment -->rem</b> <a href=pants title=\"foo>ipsum <a href=\"http://foo.com/\"><strong>dolor</a></strong> sit<br/>amet <script>alert(\"hello world\");',\n\n      :default    => 'Lorem dolor sit amet alert(\"hello world\");',\n      :restricted => 'Lorem <strong>dolor</strong> sit amet alert(\"hello world\");',\n      :basic      => 'Lorem <a href=\"pants\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet alert(\"hello world\");',\n      :relaxed    => 'Lorem <a href=\"pants\" title=\"foo&gt;ipsum &lt;a href=\"><strong>dolor</strong></a> sit<br>amet alert(\"hello world\");',\n    },\n\n    :unclosed => {\n      :html       => '<p>a</p><blockquote>b',\n\n      :default    => ' a  b ',\n      :restricted => ' a  b ',\n      :basic      => '<p>a</p><blockquote>b</blockquote>',\n      :relaxed    => '<p>a</p><blockquote>b</blockquote>'\n    },\n\n    :malicious => {\n      :html       => '<b>Lo<!-- comment -->rem</b> <a href=\"javascript:pants\" title=\"foo\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br/>amet <<foo>script>alert(\"hello world\");</script>',\n\n      :default    => 'Lorem ipsum dolor sit amet &lt;script&gt;alert(\"hello world\");',\n      :restricted => '<b>Lorem</b> ipsum <strong>dolor</strong> sit amet &lt;script&gt;alert(\"hello world\");',\n      :basic      => '<b>Lorem</b> <a rel=\"nofollow\">ipsum</a> <a href=\"http://foo.com/\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet &lt;script&gt;alert(\"hello world\");',\n      :relaxed    => '<b>Lorem</b> <a title=\"foo\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br>amet &lt;script&gt;alert(\"hello world\");'\n    }\n  }\n\n  protocols = {\n    'protocol-based JS injection: simple, no spaces' => {\n      :html       => '<a href=\"javascript:alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces before' => {\n      :html       => '<a href=\"javascript    :alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces after' => {\n      :html       => '<a href=\"javascript:    alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces before and after' => {\n      :html       => '<a href=\"javascript    :   alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: preceding colon' => {\n      :html       => '<a href=\":javascript:alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: UTF-8 encoding' => {\n      :html       => '<a href=\"javascript&#58;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long UTF-8 encoding' => {\n      :html       => '<a href=\"javascript&#0058;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long UTF-8 encoding without semicolons' => {\n      :html       => '<a href=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: hex encoding' => {\n      :html       => '<a href=\"javascript&#x3A;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long hex encoding' => {\n      :html       => '<a href=\"javascript&#x003A;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: hex encoding without semicolons' => {\n      :html       => '<a href=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: null char' => {\n      :html       => \"<img src=java\\0script:alert(\\\"XSS\\\")>\",\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol-based JS injection: invalid URL char' => {\n      :html       => '<img src=java\\script:alert(\"XSS\")>',\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol-based JS injection: spaces and entities' => {\n      :html       => '<img src=\" &#14;  javascript:alert(\\'XSS\\');\">',\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol whitespace' => {\n      :html       => '<a href=\" http://example.com/\"></a>',\n      :default    => '',\n      :restricted => '',\n      :basic      => '<a href=\"http://example.com/\" rel=\"nofollow\"></a>',\n      :relaxed    => '<a href=\"http://example.com/\"></a>'\n    }\n  }\n\n  describe 'Default config' do\n    it 'should remove non-whitelisted elements, leaving safe contents behind' do\n      Sanitize.fragment('foo <b>bar</b> <strong><a href=\"#a\">baz</a></strong> quux')\n        .must_equal 'foo bar baz quux'\n\n      Sanitize.fragment('<script>alert(\"<xss>\");</script>')\n        .must_equal 'alert(\"&lt;xss&gt;\");'\n\n      Sanitize.fragment('<<script>script>alert(\"<xss>\");</<script>>')\n        .must_equal '&lt;script&gt;alert(\"&lt;xss&gt;\");&lt;/&lt;script&gt;&gt;'\n\n      Sanitize.fragment('< script <>> alert(\"<xss>\");</script>')\n        .must_equal '&lt; script &lt;&gt;&gt; alert(\"\");'\n    end\n\n    it 'should surround the contents of :whitespace_elements with space characters when removing the element' do\n      Sanitize.fragment('foo<div>bar</div>baz')\n        .must_equal 'foo bar baz'\n\n      Sanitize.fragment('foo<br>bar<br>baz')\n        .must_equal 'foo bar baz'\n\n      Sanitize.fragment('foo<hr>bar<hr>baz')\n        .must_equal 'foo bar baz'\n    end\n\n    it 'should not choke on several instances of the same element in a row' do\n      Sanitize.fragment('<img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\">')\n        .must_equal ''\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        Sanitize.fragment(data[:html]).must_equal(data[:default])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        Sanitize.fragment(data[:html]).must_equal(data[:default])\n      end\n    end\n  end\n\n  describe 'Restricted config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::RESTRICTED)\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:restricted])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:restricted])\n      end\n    end\n  end\n\n  describe 'Basic config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::BASIC)\n    end\n\n    it 'should not choke on valueless attributes' do\n      @s.fragment('foo <a href>foo</a> bar')\n        .must_equal 'foo <a href=\"\" rel=\"nofollow\">foo</a> bar'\n    end\n\n    it 'should downcase attribute names' do\n      @s.fragment('<a HREF=\"javascript:alert(\\'foo\\')\">bar</a>')\n        .must_equal '<a rel=\"nofollow\">bar</a>'\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:basic])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:basic])\n      end\n    end\n  end\n\n  describe 'Relaxed config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::RELAXED)\n    end\n\n    it 'should encode special chars in attribute values' do\n      @s.fragment('<a href=\"http://example.com\" title=\"<b>&eacute;xamples</b> & things\">foo</a>')\n        .must_equal '<a href=\"http://example.com\" title=\"&lt;b&gt;\u00e9xamples&lt;/b&gt; &amp; things\">foo</a>'\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:relaxed])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:relaxed])\n      end\n    end\n  end\n\n  describe 'Custom configs' do\n    it 'should allow attributes on all elements if whitelisted under :all' do\n      input = '<p class=\"foo\">bar</p>'\n\n      Sanitize.fragment(input).must_equal ' bar '\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {:all => ['class']}\n      }).must_equal input\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {'div' => ['class']}\n      }).must_equal '<p>bar</p>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {'p' => ['title'], :all => ['class']}\n      }).must_equal input\n    end\n\n    it 'should allow relative URLs containing colons when the colon is not in the first path segment' do\n      input = '<a href=\"/wiki/Special:Random\">Random Page</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n    end\n\n    it 'should allow relative URLs containing colons when the colon is part of an anchor' do\n      input = '<a href=\"#fn:1\">Footnote 1</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n\n      input = '<a href=\"somepage#fn:1\">Footnote 1</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n    end\n\n    it 'should remove the contents of filtered nodes when :remove_contents is true' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span></div>',\n        :remove_contents => true\n      ).must_equal 'foo bar   '\n    end\n\n    it 'should remove the contents of specified nodes when :remove_contents is an Array of element names as strings' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span><script>alert(\"hello!\");</script></div>',\n        :remove_contents => ['script', 'span']\n      ).must_equal 'foo bar  baz '\n    end\n\n    it 'should remove the contents of specified nodes when :remove_contents is an Array of element names as symbols' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span><script>alert(\"hello!\");</script></div>',\n        :remove_contents => [:script, :span]\n      ).must_equal 'foo bar  baz '\n    end\n\n    it 'should not allow arbitrary HTML5 data attributes by default' do\n      Sanitize.fragment('<b data-foo=\"bar\"></b>',\n        :elements => ['b']\n      ).must_equal '<b></b>'\n\n      Sanitize.fragment('<b class=\"foo\" data-foo=\"bar\"></b>',\n        :attributes => {'b' => ['class']},\n        :elements   => ['b']\n      ).must_equal '<b class=\"foo\"></b>'\n    end\n\n    it 'should allow arbitrary HTML5 data attributes when the :attributes config includes :data' do\n      s = Sanitize.new(\n        :attributes => {'b' => [:data]},\n        :elements   => ['b']\n      )\n\n      s.fragment('<b data-foo=\"valid\" data-bar=\"valid\"></b>')\n        .must_equal '<b data-foo=\"valid\" data-bar=\"valid\"></b>'\n\n      s.fragment('<b data-=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-xml=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-xmlfoo=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-f:oo=\"valid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-f/oo=\"partial\"></b>')\n        .must_equal '<b data-f=\"\"></b>' # Nokogiri quirk; not ideal, but harmless\n\n      s.fragment('<b data-\u00e9foo=\"valid\"></b>')\n        .must_equal '<b></b>' # Another annoying Nokogiri quirk.\n    end\n\n    it 'should replace whitespace_elements with configured :before and :after values' do\n      s = Sanitize.new(\n        :whitespace_elements => {\n          'p'   => { :before => \"\\n\", :after => \"\\n\" },\n          'div' => { :before => \"\\n\", :after => \"\\n\" },\n          'br'  => { :before => \"\\n\", :after => \"\\n\" },\n        }\n      )\n\n      s.fragment('<p>foo</p>').must_equal \"\\nfoo\\n\"\n      s.fragment('<p>foo</p><p>bar</p>').must_equal \"\\nfoo\\n\\nbar\\n\"\n      s.fragment('foo<div>bar</div>baz').must_equal \"foo\\nbar\\nbaz\"\n      s.fragment('foo<br>bar<br>baz').must_equal \"foo\\nbar\\nbaz\"\n    end\n\n    it 'handles protocols correctly regardless of case' do\n      input = '<a href=\"hTTpS://foo.com/\">Text</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['https']}}\n      }).must_equal input\n\n      input = '<a href=\"mailto:someone@example.com?Subject=Hello\">Text</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['https']}}\n      }).must_equal \"<a>Text</a>\"\n    end\n  end\nend\n", "# encoding: utf-8\nrequire_relative 'common'\n\n# Miscellaneous attempts to sneak maliciously crafted HTML past Sanitize. Many\n# of these are courtesy of (or inspired by) the OWASP XSS Filter Evasion Cheat\n# Sheet.\n#\n# https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n\ndescribe 'Malicious HTML' do\n  make_my_diffs_pretty!\n  parallelize_me!\n\n  before do\n    @s = Sanitize.new(Sanitize::Config::RELAXED)\n  end\n\n  describe 'comments' do\n    it 'should not allow script injection via conditional comments' do\n      @s.fragment(%[<!--[if gte IE 4]>\\n<script>alert('XSS');</script>\\n<![endif]-->]).\n        must_equal ''\n    end\n  end\n\n  describe 'interpolation (ERB, PHP, etc.)' do\n    it 'should escape ERB-style tags' do\n      @s.fragment('<% naughty_ruby_code %>').\n        must_equal '&lt;% naughty_ruby_code %&gt;'\n\n      @s.fragment('<%= naughty_ruby_code %>').\n        must_equal '&lt;%= naughty_ruby_code %&gt;'\n    end\n\n    it 'should remove PHP-style tags' do\n      @s.fragment('<? naughtyPHPCode(); ?>').\n        must_equal ''\n\n      @s.fragment('<?= naughtyPHPCode(); ?>').\n        must_equal ''\n    end\n  end\n\n  describe '<body>' do\n    it 'should not be possible to inject JS via a malformed event attribute' do\n      @s.document('<html><head></head><body onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\"XSS\")></body></html>').\n        must_equal \"<html><head></head><body></body></html>\\n\"\n    end\n  end\n\n  describe '<iframe>' do\n    it 'should not be possible to inject an iframe using an improperly closed tag' do\n      @s.fragment(%[<iframe src=http://ha.ckers.org/scriptlet.html <]).\n        must_equal ''\n    end\n  end\n\n  describe '<img>' do\n    it 'should not be possible to inject JS via an unquoted <img> src attribute' do\n      @s.fragment(\"<img src=javascript:alert('XSS')>\").must_equal '<img>'\n    end\n\n    it 'should not be possible to inject JS using grave accents as <img> src delimiters' do\n      @s.fragment(\"<img src=`javascript:alert('XSS')`>\").must_equal '<img>'\n    end\n\n    it 'should not be possible to inject <script> via a malformed <img> tag' do\n      @s.fragment('<img \"\"\"><script>alert(\"XSS\")</script>\">').\n        must_equal '<img>alert(\"XSS\")\"&gt;'\n    end\n\n    it 'should not be possible to inject protocol-based JS' do\n      @s.fragment('<img src=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>').\n        must_equal '<img>'\n\n      @s.fragment('<img src=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>').\n        must_equal '<img>'\n\n      @s.fragment('<img src=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>').\n        must_equal '<img>'\n\n      # Encoded tab character.\n      @s.fragment(%[<img src=\"jav&#x09;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Encoded newline.\n      @s.fragment(%[<img src=\"jav&#x0A;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Encoded carriage return.\n      @s.fragment(%[<img src=\"jav&#x0D;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Null byte.\n      @s.fragment(%[<img src=java\\0script:alert(\"XSS\")>]).\n        must_equal '<img>'\n\n      # Spaces plus meta char.\n      @s.fragment(%[<img src=\" &#14;  javascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Mixed spaces and tabs.\n      @s.fragment(%[<img src=\"j\\na v\\tascript://alert('XSS');\">]).\n        must_equal '<img>'\n    end\n\n    it 'should not be possible to inject protocol-based JS via whitespace' do\n      @s.fragment(%[<img src=\"jav\\tascript:alert('XSS');\">]).\n        must_equal '<img>'\n    end\n\n    it 'should not be possible to inject JS using a half-open <img> tag' do\n      @s.fragment(%[<img src=\"javascript:alert('XSS')\"]).\n        must_equal ''\n    end\n  end\n\n  describe '<script>' do\n    it 'should not be possible to inject <script> using a malformed non-alphanumeric tag name' do\n      @s.fragment(%[<script/xss src=\"http://ha.ckers.org/xss.js\">alert(1)</script>]).\n        must_equal 'alert(1)'\n    end\n\n    it 'should not be possible to inject <script> via extraneous open brackets' do\n      @s.fragment(%[<<script>alert(\"XSS\");//<</script>]).\n        must_equal '&lt;alert(\"XSS\");//&lt;'\n    end\n  end\nend\n"], "fixing_code": ["# encoding: utf-8\n\nrequire 'set'\n\nclass Sanitize; module Transformers; class CleanElement\n\n  # Matches a valid HTML5 data attribute name. The unicode ranges included here\n  # are a conservative subset of the full range of characters that are\n  # technically allowed, with the intent of matching the most common characters\n  # used in data attribute names while excluding uncommon or potentially\n  # misleading characters, or characters with the potential to be normalized\n  # into unsafe or confusing forms.\n  #\n  # If you need data attr names with characters that aren't included here (such\n  # as combining marks, full-width characters, or CJK), please consider creating\n  # a custom transformer to validate attributes according to your needs.\n  #\n  # http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#embedding-custom-non-visible-data-with-the-data-*-attributes\n  REGEX_DATA_ATTR = /\\Adata-(?!xml)[a-z_][\\w.\\u00E0-\\u00F6\\u00F8-\\u017F\\u01DD-\\u02AF-]*\\z/u\n\n  # Attributes that need additional escaping on `<a>` elements due to unsafe\n  # libxml2 behavior.\n  UNSAFE_LIBXML_ATTRS_A = Set.new(%w[\n    name\n  ])\n\n  # Attributes that need additional escaping on all elements due to unsafe\n  # libxml2 behavior.\n  UNSAFE_LIBXML_ATTRS_GLOBAL = Set.new(%w[\n    action\n    href\n    src\n  ])\n\n  # Mapping of original characters to escape sequences for characters that\n  # should be escaped in attributes affected by unsafe libxml2 behavior.\n  UNSAFE_LIBXML_ESCAPE_CHARS = {\n    ' ' => '%20',\n    '\"' => '%22'\n  }\n\n  # Regex that matches any single character that needs to be escaped in\n  # attributes affected by unsafe libxml2 behavior.\n  UNSAFE_LIBXML_ESCAPE_REGEX = /[ \"]/\n\n  def initialize(config)\n    @add_attributes          = config[:add_attributes]\n    @attributes              = config[:attributes].dup\n    @elements                = config[:elements]\n    @protocols               = config[:protocols]\n    @remove_all_contents     = false\n    @remove_element_contents = Set.new\n    @whitespace_elements     = {}\n\n    @attributes.each do |element_name, attrs|\n      unless element_name == :all\n        @attributes[element_name] = Set.new(attrs).merge(@attributes[:all] || [])\n      end\n    end\n\n    # Backcompat: if :whitespace_elements is a Set, convert it to a hash.\n    if config[:whitespace_elements].is_a?(Set)\n      config[:whitespace_elements].each do |element|\n        @whitespace_elements[element] = {:before => ' ', :after => ' '}\n      end\n    else\n      @whitespace_elements = config[:whitespace_elements]\n    end\n\n    if config[:remove_contents].is_a?(Set)\n      @remove_element_contents.merge(config[:remove_contents].map(&:to_s))\n    else\n      @remove_all_contents = !!config[:remove_contents]\n    end\n  end\n\n  def call(env)\n    node = env[:node]\n    return if node.type != Nokogiri::XML::Node::ELEMENT_NODE || env[:is_whitelisted]\n\n    name = env[:node_name]\n\n    # Delete any element that isn't in the config whitelist, unless the node has\n    # already been deleted from the document.\n    #\n    # It's important that we not try to reparent the children of a node that has\n    # already been deleted, since that seems to trigger a memory leak in\n    # Nokogiri.\n    unless @elements.include?(name) || node.parent.nil?\n      # Elements like br, div, p, etc. need to be replaced with whitespace in\n      # order to preserve readability.\n      if @whitespace_elements.include?(name)\n        node.add_previous_sibling(Nokogiri::XML::Text.new(@whitespace_elements[name][:before].to_s, node.document))\n\n        unless node.children.empty?\n          node.add_next_sibling(Nokogiri::XML::Text.new(@whitespace_elements[name][:after].to_s, node.document))\n        end\n      end\n\n      unless @remove_all_contents || @remove_element_contents.include?(name)\n        node.add_previous_sibling(node.children)\n      end\n\n      node.unlink\n      return\n    end\n\n    attr_whitelist = @attributes[name] || @attributes[:all]\n\n    if attr_whitelist.nil?\n      # Delete all attributes from elements with no whitelisted attributes.\n      node.attribute_nodes.each {|attr| attr.unlink }\n    else\n      allow_data_attributes = attr_whitelist.include?(:data)\n\n      # Delete any attribute that isn't allowed on this element.\n      node.attribute_nodes.each do |attr|\n        attr_name = attr.name.downcase\n\n        unless attr_whitelist.include?(attr_name)\n          # The attribute isn't whitelisted.\n\n          if allow_data_attributes && attr_name.start_with?('data-')\n            # Arbitrary data attributes are allowed. If this is a data\n            # attribute, continue.\n            next if attr_name =~ REGEX_DATA_ATTR\n          end\n\n          # Either the attribute isn't a data attribute or arbitrary data\n          # attributes aren't allowed. Remove the attribute.\n          attr.unlink\n          next\n        end\n\n        # The attribute is whitelisted.\n\n        # Remove any attributes that use unacceptable protocols.\n        if @protocols.include?(name) && @protocols[name].include?(attr_name)\n          attr_protocols = @protocols[name][attr_name]\n\n          if attr.value =~ REGEX_PROTOCOL\n            unless attr_protocols.include?($1.downcase)\n              attr.unlink\n              next\n            end\n\n          else\n            unless attr_protocols.include?(:relative)\n              attr.unlink\n              next\n            end\n          end\n\n          # Leading and trailing whitespace around URLs is ignored at parse\n          # time. Stripping it here prevents it from being escaped by the\n          # libxml2 workaround below.\n          attr.value = attr.value.strip\n        end\n\n        # libxml2 >= 2.9.2 doesn't escape comments within some attributes, in an\n        # attempt to preserve server-side includes. This can result in XSS since\n        # an unescaped double quote can allow an attacker to inject a\n        # non-whitelisted attribute.\n        #\n        # Sanitize works around this by implementing its own escaping for\n        # affected attributes, some of which can exist on any element and some\n        # of which can only exist on `<a>` elements.\n        #\n        # The relevant libxml2 code is here:\n        # <https://github.com/GNOME/libxml2/commit/960f0e275616cadc29671a218d7fb9b69eb35588>\n        if UNSAFE_LIBXML_ATTRS_GLOBAL.include?(attr_name) ||\n            (name == 'a' && UNSAFE_LIBXML_ATTRS_A.include?(attr_name))\n\n          attr.value = attr.value.gsub(UNSAFE_LIBXML_ESCAPE_REGEX, UNSAFE_LIBXML_ESCAPE_CHARS)\n        end\n      end\n    end\n\n    # Add required attributes.\n    if @add_attributes.include?(name)\n      @add_attributes[name].each {|key, val| node[key] = val }\n    end\n  end\n\nend; end; end\n", "# encoding: utf-8\nrequire_relative 'common'\n\ndescribe 'Sanitize::Transformers::CleanElement' do\n  make_my_diffs_pretty!\n  parallelize_me!\n\n  strings = {\n    :basic => {\n      :html       => '<b>Lo<!-- comment -->rem</b> <a href=\"pants\" title=\"foo\" style=\"text-decoration: underline;\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br/>amet <style>.foo { color: #fff; }</style> <script>alert(\"hello world\");</script>',\n\n      :default    => 'Lorem ipsum dolor sit amet .foo { color: #fff; } alert(\"hello world\");',\n      :restricted => '<b>Lorem</b> ipsum <strong>dolor</strong> sit amet .foo { color: #fff; } alert(\"hello world\");',\n      :basic      => '<b>Lorem</b> <a href=\"pants\" rel=\"nofollow\">ipsum</a> <a href=\"http://foo.com/\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet .foo { color: #fff; } alert(\"hello world\");',\n      :relaxed    => '<b>Lorem</b> <a href=\"pants\" title=\"foo\" style=\"text-decoration: underline;\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br>amet <style>.foo { color: #fff; }</style> alert(\"hello world\");'\n    },\n\n    :malformed => {\n      :html       => 'Lo<!-- comment -->rem</b> <a href=pants title=\"foo>ipsum <a href=\"http://foo.com/\"><strong>dolor</a></strong> sit<br/>amet <script>alert(\"hello world\");',\n\n      :default    => 'Lorem dolor sit amet alert(\"hello world\");',\n      :restricted => 'Lorem <strong>dolor</strong> sit amet alert(\"hello world\");',\n      :basic      => 'Lorem <a href=\"pants\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet alert(\"hello world\");',\n      :relaxed    => 'Lorem <a href=\"pants\" title=\"foo&gt;ipsum &lt;a href=\"><strong>dolor</strong></a> sit<br>amet alert(\"hello world\");',\n    },\n\n    :unclosed => {\n      :html       => '<p>a</p><blockquote>b',\n\n      :default    => ' a  b ',\n      :restricted => ' a  b ',\n      :basic      => '<p>a</p><blockquote>b</blockquote>',\n      :relaxed    => '<p>a</p><blockquote>b</blockquote>'\n    },\n\n    :malicious => {\n      :html       => '<b>Lo<!-- comment -->rem</b> <a href=\"javascript:pants\" title=\"foo\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br/>amet <<foo>script>alert(\"hello world\");</script>',\n\n      :default    => 'Lorem ipsum dolor sit amet &lt;script&gt;alert(\"hello world\");',\n      :restricted => '<b>Lorem</b> ipsum <strong>dolor</strong> sit amet &lt;script&gt;alert(\"hello world\");',\n      :basic      => '<b>Lorem</b> <a rel=\"nofollow\">ipsum</a> <a href=\"http://foo.com/\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet &lt;script&gt;alert(\"hello world\");',\n      :relaxed    => '<b>Lorem</b> <a title=\"foo\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br>amet &lt;script&gt;alert(\"hello world\");'\n    }\n  }\n\n  protocols = {\n    'protocol-based JS injection: simple, no spaces' => {\n      :html       => '<a href=\"javascript:alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces before' => {\n      :html       => '<a href=\"javascript    :alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces after' => {\n      :html       => '<a href=\"javascript:    alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces before and after' => {\n      :html       => '<a href=\"javascript    :   alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: preceding colon' => {\n      :html       => '<a href=\":javascript:alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: UTF-8 encoding' => {\n      :html       => '<a href=\"javascript&#58;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long UTF-8 encoding' => {\n      :html       => '<a href=\"javascript&#0058;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long UTF-8 encoding without semicolons' => {\n      :html       => '<a href=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: hex encoding' => {\n      :html       => '<a href=\"javascript&#x3A;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long hex encoding' => {\n      :html       => '<a href=\"javascript&#x003A;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: hex encoding without semicolons' => {\n      :html       => '<a href=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: null char' => {\n      :html       => \"<img src=java\\0script:alert(\\\"XSS\\\")>\",\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol-based JS injection: invalid URL char' => {\n      :html       => '<img src=java\\script:alert(\"XSS\")>',\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol-based JS injection: spaces and entities' => {\n      :html       => '<img src=\" &#14;  javascript:alert(\\'XSS\\');\">',\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol whitespace' => {\n      :html       => '<a href=\" http://example.com/\"></a>',\n      :default    => '',\n      :restricted => '',\n      :basic      => '<a href=\"http://example.com/\" rel=\"nofollow\"></a>',\n      :relaxed    => '<a href=\"http://example.com/\"></a>'\n    }\n  }\n\n  describe 'Default config' do\n    it 'should remove non-whitelisted elements, leaving safe contents behind' do\n      Sanitize.fragment('foo <b>bar</b> <strong><a href=\"#a\">baz</a></strong> quux')\n        .must_equal 'foo bar baz quux'\n\n      Sanitize.fragment('<script>alert(\"<xss>\");</script>')\n        .must_equal 'alert(\"&lt;xss&gt;\");'\n\n      Sanitize.fragment('<<script>script>alert(\"<xss>\");</<script>>')\n        .must_equal '&lt;script&gt;alert(\"&lt;xss&gt;\");&lt;/&lt;script&gt;&gt;'\n\n      Sanitize.fragment('< script <>> alert(\"<xss>\");</script>')\n        .must_equal '&lt; script &lt;&gt;&gt; alert(\"\");'\n    end\n\n    it 'should surround the contents of :whitespace_elements with space characters when removing the element' do\n      Sanitize.fragment('foo<div>bar</div>baz')\n        .must_equal 'foo bar baz'\n\n      Sanitize.fragment('foo<br>bar<br>baz')\n        .must_equal 'foo bar baz'\n\n      Sanitize.fragment('foo<hr>bar<hr>baz')\n        .must_equal 'foo bar baz'\n    end\n\n    it 'should not choke on several instances of the same element in a row' do\n      Sanitize.fragment('<img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\">')\n        .must_equal ''\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        Sanitize.fragment(data[:html]).must_equal(data[:default])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        Sanitize.fragment(data[:html]).must_equal(data[:default])\n      end\n    end\n  end\n\n  describe 'Restricted config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::RESTRICTED)\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:restricted])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:restricted])\n      end\n    end\n  end\n\n  describe 'Basic config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::BASIC)\n    end\n\n    it 'should not choke on valueless attributes' do\n      @s.fragment('foo <a href>foo</a> bar')\n        .must_equal 'foo <a href rel=\"nofollow\">foo</a> bar'\n    end\n\n    it 'should downcase attribute names' do\n      @s.fragment('<a HREF=\"javascript:alert(\\'foo\\')\">bar</a>')\n        .must_equal '<a rel=\"nofollow\">bar</a>'\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:basic])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:basic])\n      end\n    end\n  end\n\n  describe 'Relaxed config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::RELAXED)\n    end\n\n    it 'should encode special chars in attribute values' do\n      @s.fragment('<a href=\"http://example.com\" title=\"<b>&eacute;xamples</b> & things\">foo</a>')\n        .must_equal '<a href=\"http://example.com\" title=\"&lt;b&gt;\u00e9xamples&lt;/b&gt; &amp; things\">foo</a>'\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:relaxed])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:relaxed])\n      end\n    end\n  end\n\n  describe 'Custom configs' do\n    it 'should allow attributes on all elements if whitelisted under :all' do\n      input = '<p class=\"foo\">bar</p>'\n\n      Sanitize.fragment(input).must_equal ' bar '\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {:all => ['class']}\n      }).must_equal input\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {'div' => ['class']}\n      }).must_equal '<p>bar</p>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {'p' => ['title'], :all => ['class']}\n      }).must_equal input\n    end\n\n    it \"should not allow relative URLs when relative URLs aren't whitelisted\" do\n      input = '<a href=\"/foo/bar\">Link</a>'\n\n      Sanitize.fragment(input,\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['http']}}\n      ).must_equal '<a>Link</a>'\n    end\n\n    it 'should allow relative URLs containing colons when the colon is not in the first path segment' do\n      input = '<a href=\"/wiki/Special:Random\">Random Page</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n    end\n\n    it 'should allow relative URLs containing colons when the colon is part of an anchor' do\n      input = '<a href=\"#fn:1\">Footnote 1</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n\n      input = '<a href=\"somepage#fn:1\">Footnote 1</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n    end\n\n    it 'should remove the contents of filtered nodes when :remove_contents is true' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span></div>',\n        :remove_contents => true\n      ).must_equal 'foo bar   '\n    end\n\n    it 'should remove the contents of specified nodes when :remove_contents is an Array of element names as strings' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span><script>alert(\"hello!\");</script></div>',\n        :remove_contents => ['script', 'span']\n      ).must_equal 'foo bar  baz '\n    end\n\n    it 'should remove the contents of specified nodes when :remove_contents is an Array of element names as symbols' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span><script>alert(\"hello!\");</script></div>',\n        :remove_contents => [:script, :span]\n      ).must_equal 'foo bar  baz '\n    end\n\n    it 'should not allow arbitrary HTML5 data attributes by default' do\n      Sanitize.fragment('<b data-foo=\"bar\"></b>',\n        :elements => ['b']\n      ).must_equal '<b></b>'\n\n      Sanitize.fragment('<b class=\"foo\" data-foo=\"bar\"></b>',\n        :attributes => {'b' => ['class']},\n        :elements   => ['b']\n      ).must_equal '<b class=\"foo\"></b>'\n    end\n\n    it 'should allow arbitrary HTML5 data attributes when the :attributes config includes :data' do\n      s = Sanitize.new(\n        :attributes => {'b' => [:data]},\n        :elements   => ['b']\n      )\n\n      s.fragment('<b data-foo=\"valid\" data-bar=\"valid\"></b>')\n        .must_equal '<b data-foo=\"valid\" data-bar=\"valid\"></b>'\n\n      s.fragment('<b data-=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-xml=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-xmlfoo=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-f:oo=\"valid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-f/oo=\"partial\"></b>')\n        .must_equal '<b data-f=\"\"></b>' # Nokogiri quirk; not ideal, but harmless\n\n      s.fragment('<b data-\u00e9foo=\"valid\"></b>')\n        .must_equal '<b></b>' # Another annoying Nokogiri quirk.\n    end\n\n    it 'should replace whitespace_elements with configured :before and :after values' do\n      s = Sanitize.new(\n        :whitespace_elements => {\n          'p'   => { :before => \"\\n\", :after => \"\\n\" },\n          'div' => { :before => \"\\n\", :after => \"\\n\" },\n          'br'  => { :before => \"\\n\", :after => \"\\n\" },\n        }\n      )\n\n      s.fragment('<p>foo</p>').must_equal \"\\nfoo\\n\"\n      s.fragment('<p>foo</p><p>bar</p>').must_equal \"\\nfoo\\n\\nbar\\n\"\n      s.fragment('foo<div>bar</div>baz').must_equal \"foo\\nbar\\nbaz\"\n      s.fragment('foo<br>bar<br>baz').must_equal \"foo\\nbar\\nbaz\"\n    end\n\n    it 'handles protocols correctly regardless of case' do\n      input = '<a href=\"hTTpS://foo.com/\">Text</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['https']}}\n      }).must_equal input\n\n      input = '<a href=\"mailto:someone@example.com?Subject=Hello\">Text</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['https']}}\n      }).must_equal \"<a>Text</a>\"\n    end\n  end\nend\n", "# encoding: utf-8\nrequire_relative 'common'\n\n# Miscellaneous attempts to sneak maliciously crafted HTML past Sanitize. Many\n# of these are courtesy of (or inspired by) the OWASP XSS Filter Evasion Cheat\n# Sheet.\n#\n# https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n\ndescribe 'Malicious HTML' do\n  make_my_diffs_pretty!\n  parallelize_me!\n\n  before do\n    @s = Sanitize.new(Sanitize::Config::RELAXED)\n  end\n\n  describe 'comments' do\n    it 'should not allow script injection via conditional comments' do\n      @s.fragment(%[<!--[if gte IE 4]>\\n<script>alert('XSS');</script>\\n<![endif]-->]).\n        must_equal ''\n    end\n  end\n\n  describe 'interpolation (ERB, PHP, etc.)' do\n    it 'should escape ERB-style tags' do\n      @s.fragment('<% naughty_ruby_code %>').\n        must_equal '&lt;% naughty_ruby_code %&gt;'\n\n      @s.fragment('<%= naughty_ruby_code %>').\n        must_equal '&lt;%= naughty_ruby_code %&gt;'\n    end\n\n    it 'should remove PHP-style tags' do\n      @s.fragment('<? naughtyPHPCode(); ?>').\n        must_equal ''\n\n      @s.fragment('<?= naughtyPHPCode(); ?>').\n        must_equal ''\n    end\n  end\n\n  describe '<body>' do\n    it 'should not be possible to inject JS via a malformed event attribute' do\n      @s.document('<html><head></head><body onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\"XSS\")></body></html>').\n        must_equal \"<html><head></head><body></body></html>\\n\"\n    end\n  end\n\n  describe '<iframe>' do\n    it 'should not be possible to inject an iframe using an improperly closed tag' do\n      @s.fragment(%[<iframe src=http://ha.ckers.org/scriptlet.html <]).\n        must_equal ''\n    end\n  end\n\n  describe '<img>' do\n    it 'should not be possible to inject JS via an unquoted <img> src attribute' do\n      @s.fragment(\"<img src=javascript:alert('XSS')>\").must_equal '<img>'\n    end\n\n    it 'should not be possible to inject JS using grave accents as <img> src delimiters' do\n      @s.fragment(\"<img src=`javascript:alert('XSS')`>\").must_equal '<img>'\n    end\n\n    it 'should not be possible to inject <script> via a malformed <img> tag' do\n      @s.fragment('<img \"\"\"><script>alert(\"XSS\")</script>\">').\n        must_equal '<img>alert(\"XSS\")\"&gt;'\n    end\n\n    it 'should not be possible to inject protocol-based JS' do\n      @s.fragment('<img src=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>').\n        must_equal '<img>'\n\n      @s.fragment('<img src=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>').\n        must_equal '<img>'\n\n      @s.fragment('<img src=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>').\n        must_equal '<img>'\n\n      # Encoded tab character.\n      @s.fragment(%[<img src=\"jav&#x09;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Encoded newline.\n      @s.fragment(%[<img src=\"jav&#x0A;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Encoded carriage return.\n      @s.fragment(%[<img src=\"jav&#x0D;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Null byte.\n      @s.fragment(%[<img src=java\\0script:alert(\"XSS\")>]).\n        must_equal '<img>'\n\n      # Spaces plus meta char.\n      @s.fragment(%[<img src=\" &#14;  javascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Mixed spaces and tabs.\n      @s.fragment(%[<img src=\"j\\na v\\tascript://alert('XSS');\">]).\n        must_equal '<img>'\n    end\n\n    it 'should not be possible to inject protocol-based JS via whitespace' do\n      @s.fragment(%[<img src=\"jav\\tascript:alert('XSS');\">]).\n        must_equal '<img>'\n    end\n\n    it 'should not be possible to inject JS using a half-open <img> tag' do\n      @s.fragment(%[<img src=\"javascript:alert('XSS')\"]).\n        must_equal ''\n    end\n  end\n\n  describe '<script>' do\n    it 'should not be possible to inject <script> using a malformed non-alphanumeric tag name' do\n      @s.fragment(%[<script/xss src=\"http://ha.ckers.org/xss.js\">alert(1)</script>]).\n        must_equal 'alert(1)'\n    end\n\n    it 'should not be possible to inject <script> via extraneous open brackets' do\n      @s.fragment(%[<<script>alert(\"XSS\");//<</script>]).\n        must_equal '&lt;alert(\"XSS\");//&lt;'\n    end\n  end\n\n  # libxml2 >= 2.9.2 doesn't escape comments within some attributes, in an\n  # attempt to preserve server-side includes. This can result in XSS since an\n  # unescaped double quote can allow an attacker to inject a non-whitelisted\n  # attribute. Sanitize works around this by implementing its own escaping for\n  # affected attributes.\n  #\n  # The relevant libxml2 code is here:\n  # <https://github.com/GNOME/libxml2/commit/960f0e275616cadc29671a218d7fb9b69eb35588>\n  describe 'unsafe libxml2 server-side includes in attributes' do\n    tag_configs = [\n      {\n        tag_name: 'a',\n        escaped_attrs: %w[ action href src name ],\n        unescaped_attrs: []\n      },\n\n      {\n        tag_name: 'div',\n        escaped_attrs: %w[ action href src ],\n        unescaped_attrs: %w[ name ]\n      }\n    ]\n\n    before do\n      @s = Sanitize.new({\n        elements: %w[ a div ],\n\n        attributes: {\n          all: %w[ action href src name ]\n        }\n      })\n    end\n\n    tag_configs.each do |tag_config|\n      tag_name = tag_config[:tag_name]\n\n      tag_config[:escaped_attrs].each do |attr_name|\n        input = %[<#{tag_name} #{attr_name}='examp<!--\" onmouseover=alert(1)>-->le.com'>foo</#{tag_name}>]\n\n        it 'should escape unsafe characters in attributes' do\n          @s.fragment(input).must_equal(%[<#{tag_name} #{attr_name}=\"examp<!--%22%20onmouseover=alert(1)>-->le.com\">foo</#{tag_name}>])\n        end\n\n        it 'should round-trip to the same output' do\n          output = @s.fragment(input)\n          @s.fragment(output).must_equal(output)\n        end\n      end\n\n      tag_config[:unescaped_attrs].each do |attr_name|\n        input = %[<#{tag_name} #{attr_name}='examp<!--\" onmouseover=alert(1)>-->le.com'>foo</#{tag_name}>]\n\n        it 'should not escape characters unnecessarily' do\n          @s.fragment(input).must_equal(input)\n        end\n\n        it 'should round-trip to the same output' do\n          output = @s.fragment(input)\n          @s.fragment(output).must_equal(output)\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["lib/sanitize/transformers/clean_element.rb", "test/test_clean_element.rb", "test/test_malicious_html.rb"], "buggy_code_start_loc": [19, 237, 127], "buggy_code_end_loc": [119, 300, 127], "fixing_code_start_loc": [20, 237, 128], "fixing_code_end_loc": [175, 311, 192], "type": "CWE-20", "message": "A specially crafted HTML fragment can cause Sanitize gem for Ruby to allow non-whitelisted attributes to be used on a whitelisted HTML element.", "other": {"cve": {"id": "CVE-2018-3740", "sourceIdentifier": "support@hackerone.com", "published": "2018-03-30T19:29:00.270", "lastModified": "2018-12-28T16:29:05.927", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A specially crafted HTML fragment can cause Sanitize gem for Ruby to allow non-whitelisted attributes to be used on a whitelisted HTML element."}, {"lang": "es", "value": "Un fragmento HTML especialmente manipulado puede provocar que una gema Sanitize para Ruby permita que se utilicen atributos que no est\u00e1n en una lista blanca en un elemento HTML que s\u00ed est\u00e1 en una lista blanca."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sanitize_project:sanitize:*:*:*:*:*:ruby:*:*", "versionEndIncluding": "4.6.0", "matchCriteriaId": "1F93BF3E-5C64-4376-9EE6-5638B5BCE8B8"}]}]}], "references": [{"url": "https://about.gitlab.com/2018/06/25/security-release-gitlab-11-dot-0-dot-1-released/", "source": "support@hackerone.com"}, {"url": "https://github.com/rgrove/sanitize/commit/01629a162e448a83d901456d0ba8b65f3b03d46e", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rgrove/sanitize/issues/176", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4358", "source": "support@hackerone.com"}]}, "github_commit_url": "https://github.com/rgrove/sanitize/commit/01629a162e448a83d901456d0ba8b65f3b03d46e"}}