{"buggy_code": ["##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\nimport socket\nimport threading\nimport time\nimport traceback\n\nfrom waitress.buffers import OverflowableBuffer, ReadOnlyFileBasedBuffer\nfrom waitress.parser import HTTPRequestParser\nfrom waitress.task import ErrorTask, WSGITask\nfrom waitress.utilities import InternalServerError\n\nfrom . import wasyncore\n\n\nclass ClientDisconnected(Exception):\n    \"\"\"Raised when attempting to write to a closed socket.\"\"\"\n\n\nclass HTTPChannel(wasyncore.dispatcher):\n    \"\"\"\n    Setting self.requests = [somerequest] prevents more requests from being\n    received until the out buffers have been flushed.\n\n    Setting self.requests = [] allows more requests to be received.\n    \"\"\"\n\n    task_class = WSGITask\n    error_task_class = ErrorTask\n    parser_class = HTTPRequestParser\n\n    # A request that has not been received yet completely is stored here\n    request = None\n    last_activity = 0  # Time of last activity\n    will_close = False  # set to True to close the socket.\n    close_when_flushed = False  # set to True to close the socket when flushed\n    sent_continue = False  # used as a latch after sending 100 continue\n    total_outbufs_len = 0  # total bytes ready to send\n    current_outbuf_count = 0  # total bytes written to current outbuf\n\n    #\n    # ASYNCHRONOUS METHODS (including __init__)\n    #\n\n    def __init__(self, server, sock, addr, adj, map=None):\n        self.server = server\n        self.adj = adj\n        self.outbufs = [OverflowableBuffer(adj.outbuf_overflow)]\n        self.creation_time = self.last_activity = time.time()\n        self.sendbuf_len = sock.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)\n\n        # requests_lock used to push/pop requests and modify the request that is\n        # currently being created\n        self.requests_lock = threading.Lock()\n        # outbuf_lock used to access any outbuf (expected to use an RLock)\n        self.outbuf_lock = threading.Condition()\n\n        wasyncore.dispatcher.__init__(self, sock, map=map)\n\n        # Don't let wasyncore.dispatcher throttle self.addr on us.\n        self.addr = addr\n        self.requests = []\n\n    def check_client_disconnected(self):\n        \"\"\"\n        This method is inserted into the environment of any created task so it\n        may occasionally check if the client has disconnected and interrupt\n        execution.\n        \"\"\"\n\n        return not self.connected\n\n    def writable(self):\n        # if there's data in the out buffer or we've been instructed to close\n        # the channel (possibly by our server maintenance logic), run\n        # handle_write\n\n        return self.total_outbufs_len or self.will_close or self.close_when_flushed\n\n    def handle_write(self):\n        # Precondition: there's data in the out buffer to be sent, or\n        # there's a pending will_close request\n\n        if not self.connected:\n            # we dont want to close the channel twice\n\n            return\n\n        # try to flush any pending output\n\n        if not self.requests:\n            # 1. There are no running tasks, so we don't need to try to lock\n            #    the outbuf before sending\n            # 2. The data in the out buffer should be sent as soon as possible\n            #    because it's either data left over from task output\n            #    or a 100 Continue line sent within \"received\".\n            flush = self._flush_some\n        elif self.total_outbufs_len >= self.adj.send_bytes:\n            # 1. There's a running task, so we need to try to lock\n            #    the outbuf before sending\n            # 2. Only try to send if the data in the out buffer is larger\n            #    than self.adj_bytes to avoid TCP fragmentation\n            flush = self._flush_some_if_lockable\n        else:\n            # 1. There's not enough data in the out buffer to bother to send\n            #    right now.\n            flush = None\n\n        self._flush_exception(flush)\n\n        if self.close_when_flushed and not self.total_outbufs_len:\n            self.close_when_flushed = False\n            self.will_close = True\n\n        if self.will_close:\n            self.handle_close()\n\n    def _flush_exception(self, flush):\n        if flush:\n            try:\n                return (flush(), False)\n            except OSError:\n                if self.adj.log_socket_errors:\n                    self.logger.exception(\"Socket error\")\n                self.will_close = True\n\n                return (False, True)\n            except Exception:  # pragma: nocover\n                self.logger.exception(\"Unexpected exception when flushing\")\n                self.will_close = True\n\n                return (False, True)\n\n    def readable(self):\n        # We might want to read more requests. We can only do this if:\n        # 1. We're not already about to close the connection.\n        # 2. We're not waiting to flush remaining data before closing the\n        #    connection\n        # 3. There are not too many tasks already queued\n        # 4. There's no data in the output buffer that needs to be sent\n        #    before we potentially create a new task.\n\n        return not (\n            self.will_close\n            or self.close_when_flushed\n            or len(self.requests) > self.adj.channel_request_lookahead\n            or self.total_outbufs_len\n        )\n\n    def handle_read(self):\n        try:\n            data = self.recv(self.adj.recv_bytes)\n        except OSError:\n            if self.adj.log_socket_errors:\n                self.logger.exception(\"Socket error\")\n            self.handle_close()\n\n            return\n\n        if data:\n            self.last_activity = time.time()\n            self.received(data)\n        else:\n            # Client disconnected.\n            self.connected = False\n\n    def send_continue(self):\n        \"\"\"\n        Send a 100-Continue header to the client. This is either called from\n        receive (if no requests are running and the client expects it) or at\n        the end of service (if no more requests are queued and a request has\n        been read partially that expects it).\n        \"\"\"\n        self.request.expect_continue = False\n        outbuf_payload = b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"\n        num_bytes = len(outbuf_payload)\n        with self.outbuf_lock:\n            self.outbufs[-1].append(outbuf_payload)\n            self.current_outbuf_count += num_bytes\n            self.total_outbufs_len += num_bytes\n            self.sent_continue = True\n            self._flush_some()\n        self.request.completed = False\n\n    def received(self, data):\n        \"\"\"\n        Receives input asynchronously and assigns one or more requests to the\n        channel.\n        \"\"\"\n\n        if not data:\n            return False\n\n        with self.requests_lock:\n            while data:\n                if self.request is None:\n                    self.request = self.parser_class(self.adj)\n                n = self.request.received(data)\n\n                # if there are requests queued, we can not send the continue\n                # header yet since the responses need to be kept in order\n\n                if (\n                    self.request.expect_continue\n                    and self.request.headers_finished\n                    and not self.requests\n                    and not self.sent_continue\n                ):\n                    self.send_continue()\n\n                if self.request.completed:\n                    # The request (with the body) is ready to use.\n                    self.sent_continue = False\n\n                    if not self.request.empty:\n                        self.requests.append(self.request)\n\n                        if len(self.requests) == 1:\n                            # self.requests was empty before so the main thread\n                            # is in charge of starting the task. Otherwise,\n                            # service() will add a new task after each request\n                            # has been processed\n                            self.server.add_task(self)\n                    self.request = None\n\n                if n >= len(data):\n                    break\n                data = data[n:]\n\n        return True\n\n    def _flush_some_if_lockable(self):\n        # Since our task may be appending to the outbuf, we try to acquire\n        # the lock, but we don't block if we can't.\n\n        if self.outbuf_lock.acquire(False):\n            try:\n                self._flush_some()\n\n                if self.total_outbufs_len < self.adj.outbuf_high_watermark:\n                    self.outbuf_lock.notify()\n            finally:\n                self.outbuf_lock.release()\n\n    def _flush_some(self):\n        # Send as much data as possible to our client\n\n        sent = 0\n        dobreak = False\n\n        while True:\n            outbuf = self.outbufs[0]\n            # use outbuf.__len__ rather than len(outbuf) FBO of not getting\n            # OverflowError on 32-bit Python\n            outbuflen = outbuf.__len__()\n\n            while outbuflen > 0:\n                chunk = outbuf.get(self.sendbuf_len)\n                num_sent = self.send(chunk)\n\n                if num_sent:\n                    outbuf.skip(num_sent, True)\n                    outbuflen -= num_sent\n                    sent += num_sent\n                    self.total_outbufs_len -= num_sent\n                else:\n                    # failed to write anything, break out entirely\n                    dobreak = True\n\n                    break\n            else:\n                # self.outbufs[-1] must always be a writable outbuf\n\n                if len(self.outbufs) > 1:\n                    toclose = self.outbufs.pop(0)\n                    try:\n                        toclose.close()\n                    except Exception:\n                        self.logger.exception(\"Unexpected error when closing an outbuf\")\n                else:\n                    # caught up, done flushing for now\n                    dobreak = True\n\n            if dobreak:\n                break\n\n        if sent:\n            self.last_activity = time.time()\n\n            return True\n\n        return False\n\n    def handle_close(self):\n        with self.outbuf_lock:\n            for outbuf in self.outbufs:\n                try:\n                    outbuf.close()\n                except Exception:\n                    self.logger.exception(\n                        \"Unknown exception while trying to close outbuf\"\n                    )\n            self.total_outbufs_len = 0\n            self.connected = False\n            self.outbuf_lock.notify()\n        wasyncore.dispatcher.close(self)\n\n    def add_channel(self, map=None):\n        \"\"\"See wasyncore.dispatcher\n\n        This hook keeps track of opened channels.\n        \"\"\"\n        wasyncore.dispatcher.add_channel(self, map)\n        self.server.active_channels[self._fileno] = self\n\n    def del_channel(self, map=None):\n        \"\"\"See wasyncore.dispatcher\n\n        This hook keeps track of closed channels.\n        \"\"\"\n        fd = self._fileno  # next line sets this to None\n        wasyncore.dispatcher.del_channel(self, map)\n        ac = self.server.active_channels\n\n        if fd in ac:\n            del ac[fd]\n\n    #\n    # SYNCHRONOUS METHODS\n    #\n\n    def write_soon(self, data):\n        if not self.connected:\n            # if the socket is closed then interrupt the task so that it\n            # can cleanup possibly before the app_iter is exhausted\n            raise ClientDisconnected\n\n        if data:\n            # the async mainloop might be popping data off outbuf; we can\n            # block here waiting for it because we're in a task thread\n            with self.outbuf_lock:\n                self._flush_outbufs_below_high_watermark()\n\n                if not self.connected:\n                    raise ClientDisconnected\n                num_bytes = len(data)\n\n                if data.__class__ is ReadOnlyFileBasedBuffer:\n                    # they used wsgi.file_wrapper\n                    self.outbufs.append(data)\n                    nextbuf = OverflowableBuffer(self.adj.outbuf_overflow)\n                    self.outbufs.append(nextbuf)\n                    self.current_outbuf_count = 0\n                else:\n                    if self.current_outbuf_count >= self.adj.outbuf_high_watermark:\n                        # rotate to a new buffer if the current buffer has hit\n                        # the watermark to avoid it growing unbounded\n                        nextbuf = OverflowableBuffer(self.adj.outbuf_overflow)\n                        self.outbufs.append(nextbuf)\n                        self.current_outbuf_count = 0\n                    self.outbufs[-1].append(data)\n                    self.current_outbuf_count += num_bytes\n                self.total_outbufs_len += num_bytes\n\n                if self.total_outbufs_len >= self.adj.send_bytes:\n                    (flushed, exception) = self._flush_exception(self._flush_some)\n\n                    if (\n                        exception\n                        or not flushed\n                        or self.total_outbufs_len >= self.adj.send_bytes\n                    ):\n                        self.server.pull_trigger()\n\n            return num_bytes\n\n        return 0\n\n    def _flush_outbufs_below_high_watermark(self):\n        # check first to avoid locking if possible\n\n        if self.total_outbufs_len > self.adj.outbuf_high_watermark:\n            with self.outbuf_lock:\n                (_, exception) = self._flush_exception(self._flush_some)\n\n                if exception:\n                    # An exception happened while flushing, wake up the main\n                    # thread, then wait for it to decide what to do next\n                    # (probably close the socket, and then just return)\n                    self.server.pull_trigger()\n                    self.outbuf_lock.wait()\n\n                    return\n\n                while (\n                    self.connected\n                    and self.total_outbufs_len > self.adj.outbuf_high_watermark\n                ):\n                    self.server.pull_trigger()\n                    self.outbuf_lock.wait()\n\n    def service(self):\n        \"\"\"Execute one request. If there are more, we add another task to the\n        server at the end.\"\"\"\n\n        request = self.requests[0]\n\n        if request.error:\n            task = self.error_task_class(self, request)\n        else:\n            task = self.task_class(self, request)\n\n        try:\n            if self.connected:\n                task.service()\n            else:\n                task.close_on_finish = True\n        except ClientDisconnected:\n            self.logger.info(\"Client disconnected while serving %s\" % task.request.path)\n            task.close_on_finish = True\n        except Exception:\n            self.logger.exception(\"Exception while serving %s\" % task.request.path)\n\n            if not task.wrote_header:\n                if self.adj.expose_tracebacks:\n                    body = traceback.format_exc()\n                else:\n                    body = \"The server encountered an unexpected internal server error\"\n                req_version = request.version\n                req_headers = request.headers\n                err_request = self.parser_class(self.adj)\n                err_request.error = InternalServerError(body)\n                # copy some original request attributes to fulfill\n                # HTTP 1.1 requirements\n                err_request.version = req_version\n                try:\n                    err_request.headers[\"CONNECTION\"] = req_headers[\"CONNECTION\"]\n                except KeyError:\n                    pass\n                task = self.error_task_class(self, err_request)\n                try:\n                    task.service()  # must not fail\n                except ClientDisconnected:\n                    task.close_on_finish = True\n            else:\n                task.close_on_finish = True\n\n        if task.close_on_finish:\n            with self.requests_lock:\n                self.close_when_flushed = True\n\n                for request in self.requests:\n                    request.close()\n                self.requests = []\n        else:\n            # before processing a new request, ensure there is not too\n            # much data in the outbufs waiting to be flushed\n            # NB: currently readable() returns False while we are\n            # flushing data so we know no new requests will come in\n            # that we need to account for, otherwise it'd be better\n            # to do this check at the start of the request instead of\n            # at the end to account for consecutive service() calls\n\n            if len(self.requests) > 1:\n                self._flush_outbufs_below_high_watermark()\n\n            # this is a little hacky but basically it's forcing the\n            # next request to create a new outbuf to avoid sharing\n            # outbufs across requests which can cause outbufs to\n            # not be deallocated regularly when a connection is open\n            # for a long time\n\n            if self.current_outbuf_count > 0:\n                self.current_outbuf_count = self.adj.outbuf_high_watermark\n\n            request.close()\n\n            # Add new task to process the next request\n            with self.requests_lock:\n                self.requests.pop(0)\n\n                if self.connected and self.requests:\n                    self.server.add_task(self)\n                elif (\n                    self.connected\n                    and self.request is not None\n                    and self.request.expect_continue\n                    and self.request.headers_finished\n                    and not self.sent_continue\n                ):\n                    # A request waits for a signal to continue, but we could\n                    # not send it until now because requests were being\n                    # processed and the output needs to be kept in order\n                    self.send_continue()\n\n        if self.connected:\n            self.server.pull_trigger()\n\n        self.last_activity = time.time()\n\n    def cancel(self):\n        \"\"\"Cancels all pending / active requests\"\"\"\n        self.will_close = True\n        self.connected = False\n        self.last_activity = time.time()\n        self.requests = []\n", "# -*- Mode: Python -*-\n#   Id: asyncore.py,v 2.51 2000/09/07 22:29:26 rushing Exp\n#   Author: Sam Rushing <rushing@nightmare.com>\n\n# ======================================================================\n# Copyright 1996 by Sam Rushing\n#\n#                         All Rights Reserved\n#\n# Permission to use, copy, modify, and distribute this software and\n# its documentation for any purpose and without fee is hereby\n# granted, provided that the above copyright notice appear in all\n# copies and that both that copyright notice and this permission\n# notice appear in supporting documentation, and that the name of Sam\n# Rushing not be used in advertising or publicity pertaining to\n# distribution of the software without specific, written prior\n# permission.\n#\n# SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN\n# NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n# ======================================================================\n\n\"\"\"Basic infrastructure for asynchronous socket service clients and servers.\n\nThere are only two ways to have a program on a single processor do \"more\nthan one thing at a time\".  Multi-threaded programming is the simplest and\nmost popular way to do it, but there is another very different technique,\nthat lets you have nearly all the advantages of multi-threading, without\nactually using multiple threads. it's really only practical if your program\nis largely I/O bound. If your program is CPU bound, then pre-emptive\nscheduled threads are probably what you really need. Network servers are\nrarely CPU-bound, however.\n\nIf your operating system supports the select() system call in its I/O\nlibrary (and nearly all do), then you can use it to juggle multiple\ncommunication channels at once; doing other work while your I/O is taking\nplace in the \"background.\"  Although this strategy can seem strange and\ncomplex, especially at first, it is in many ways easier to understand and\ncontrol than multi-threaded programming. The module documented here solves\nmany of the difficult problems for you, making the task of building\nsophisticated high-performance network servers and clients a snap.\n\nNB: this is a fork of asyncore from the stdlib that we've (the waitress\ndevelopers) named 'wasyncore' to ensure forward compatibility, as asyncore\nin the stdlib will be dropped soon.  It is neither a copy of the 2.7 asyncore\nnor the 3.X asyncore; it is a version compatible with either 2.7 or 3.X.\n\"\"\"\n\nfrom errno import (\n    EAGAIN,\n    EALREADY,\n    EBADF,\n    ECONNABORTED,\n    ECONNRESET,\n    EINPROGRESS,\n    EINTR,\n    EINVAL,\n    EISCONN,\n    ENOTCONN,\n    EPIPE,\n    ESHUTDOWN,\n    EWOULDBLOCK,\n    errorcode,\n)\nimport logging\nimport os\nimport select\nimport socket\nimport sys\nimport time\nimport warnings\n\nfrom . import compat, utilities\n\n_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE, EBADF})\n\ntry:\n    socket_map\nexcept NameError:\n    socket_map = {}\n\n\ndef _strerror(err):\n    try:\n        return os.strerror(err)\n    except (TypeError, ValueError, OverflowError, NameError):\n        return \"Unknown error %s\" % err\n\n\nclass ExitNow(Exception):\n    pass\n\n\n_reraised_exceptions = (ExitNow, KeyboardInterrupt, SystemExit)\n\n\ndef read(obj):\n    try:\n        obj.handle_read_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\n\n\ndef write(obj):\n    try:\n        obj.handle_write_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\n\n\ndef _exception(obj):\n    try:\n        obj.handle_expt_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\n\n\ndef readwrite(obj, flags):\n    try:\n        if flags & select.POLLIN:\n            obj.handle_read_event()\n        if flags & select.POLLOUT:\n            obj.handle_write_event()\n        if flags & select.POLLPRI:\n            obj.handle_expt_event()\n        if flags & (select.POLLHUP | select.POLLERR | select.POLLNVAL):\n            obj.handle_close()\n    except OSError as e:\n        if e.args[0] not in _DISCONNECTED:\n            obj.handle_error()\n        else:\n            obj.handle_close()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\n\n\ndef poll(timeout=0.0, map=None):\n    if map is None:  # pragma: no cover\n        map = socket_map\n    if map:\n        r = []\n        w = []\n        e = []\n        for fd, obj in list(map.items()):  # list() call FBO py3\n            is_r = obj.readable()\n            is_w = obj.writable()\n            if is_r:\n                r.append(fd)\n            # accepting sockets should not be writable\n            if is_w and not obj.accepting:\n                w.append(fd)\n            if is_r or is_w:\n                e.append(fd)\n        if [] == r == w == e:\n            time.sleep(timeout)\n            return\n\n        try:\n            r, w, e = select.select(r, w, e, timeout)\n        except OSError as err:\n            if err.args[0] != EINTR:\n                raise\n            else:\n                return\n\n        for fd in r:\n            obj = map.get(fd)\n            if obj is None:  # pragma: no cover\n                continue\n            read(obj)\n\n        for fd in w:\n            obj = map.get(fd)\n            if obj is None:  # pragma: no cover\n                continue\n            write(obj)\n\n        for fd in e:\n            obj = map.get(fd)\n            if obj is None:  # pragma: no cover\n                continue\n            _exception(obj)\n\n\ndef poll2(timeout=0.0, map=None):\n    # Use the poll() support added to the select module in Python 2.0\n    if map is None:  # pragma: no cover\n        map = socket_map\n    if timeout is not None:\n        # timeout is in milliseconds\n        timeout = int(timeout * 1000)\n    pollster = select.poll()\n    if map:\n        for fd, obj in list(map.items()):\n            flags = 0\n            if obj.readable():\n                flags |= select.POLLIN | select.POLLPRI\n            # accepting sockets should not be writable\n            if obj.writable() and not obj.accepting:\n                flags |= select.POLLOUT\n            if flags:\n                pollster.register(fd, flags)\n\n        try:\n            r = pollster.poll(timeout)\n        except OSError as err:\n            if err.args[0] != EINTR:\n                raise\n            r = []\n\n        for fd, flags in r:\n            obj = map.get(fd)\n            if obj is None:  # pragma: no cover\n                continue\n            readwrite(obj, flags)\n\n\npoll3 = poll2  # Alias for backward compatibility\n\n\ndef loop(timeout=30.0, use_poll=False, map=None, count=None):\n    if map is None:  # pragma: no cover\n        map = socket_map\n\n    if use_poll and hasattr(select, \"poll\"):\n        poll_fun = poll2\n    else:\n        poll_fun = poll\n\n    if count is None:  # pragma: no cover\n        while map:\n            poll_fun(timeout, map)\n\n    else:\n        while map and count > 0:\n            poll_fun(timeout, map)\n            count = count - 1\n\n\ndef compact_traceback():\n    t, v, tb = sys.exc_info()\n    tbinfo = []\n    if not tb:  # pragma: no cover\n        raise AssertionError(\"traceback does not exist\")\n    while tb:\n        tbinfo.append(\n            (\n                tb.tb_frame.f_code.co_filename,\n                tb.tb_frame.f_code.co_name,\n                str(tb.tb_lineno),\n            )\n        )\n        tb = tb.tb_next\n\n    # just to be safe\n    del tb\n\n    file, function, line = tbinfo[-1]\n    info = \" \".join([\"[%s|%s|%s]\" % x for x in tbinfo])\n    return (file, function, line), t, v, info\n\n\nclass dispatcher:\n\n    debug = False\n    connected = False\n    accepting = False\n    connecting = False\n    closing = False\n    addr = None\n    ignore_log_types = frozenset({\"warning\"})\n    logger = utilities.logger\n    compact_traceback = staticmethod(compact_traceback)  # for testing\n\n    def __init__(self, sock=None, map=None):\n        if map is None:  # pragma: no cover\n            self._map = socket_map\n        else:\n            self._map = map\n\n        self._fileno = None\n\n        if sock:\n            # Set to nonblocking just to make sure for cases where we\n            # get a socket from a blocking source.\n            sock.setblocking(0)\n            self.set_socket(sock, map)\n            self.connected = True\n            # The constructor no longer requires that the socket\n            # passed be connected.\n            try:\n                self.addr = sock.getpeername()\n            except OSError as err:\n                if err.args[0] in (ENOTCONN, EINVAL):\n                    # To handle the case where we got an unconnected\n                    # socket.\n                    self.connected = False\n                else:\n                    # The socket is broken in some unknown way, alert\n                    # the user and remove it from the map (to prevent\n                    # polling of broken sockets).\n                    self.del_channel(map)\n                    raise\n        else:\n            self.socket = None\n\n    def __repr__(self):\n        status = [self.__class__.__module__ + \".\" + self.__class__.__qualname__]\n        if self.accepting and self.addr:\n            status.append(\"listening\")\n        elif self.connected:\n            status.append(\"connected\")\n        if self.addr is not None:\n            try:\n                status.append(\"%s:%d\" % self.addr)\n            except TypeError:  # pragma: no cover\n                status.append(repr(self.addr))\n        return \"<{} at {:#x}>\".format(\" \".join(status), id(self))\n\n    __str__ = __repr__\n\n    def add_channel(self, map=None):\n        # self.log_info('adding channel %s' % self)\n        if map is None:\n            map = self._map\n        map[self._fileno] = self\n\n    def del_channel(self, map=None):\n        fd = self._fileno\n        if map is None:\n            map = self._map\n        if fd in map:\n            # self.log_info('closing channel %d:%s' % (fd, self))\n            del map[fd]\n        self._fileno = None\n\n    def create_socket(self, family=socket.AF_INET, type=socket.SOCK_STREAM):\n        self.family_and_type = family, type\n        sock = socket.socket(family, type)\n        sock.setblocking(0)\n        self.set_socket(sock)\n\n    def set_socket(self, sock, map=None):\n        self.socket = sock\n        self._fileno = sock.fileno()\n        self.add_channel(map)\n\n    def set_reuse_addr(self):\n        # try to re-use a server port if possible\n        try:\n            self.socket.setsockopt(\n                socket.SOL_SOCKET,\n                socket.SO_REUSEADDR,\n                self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) | 1,\n            )\n        except OSError:\n            pass\n\n    # ==================================================\n    # predicates for select()\n    # these are used as filters for the lists of sockets\n    # to pass to select().\n    # ==================================================\n\n    def readable(self):\n        return True\n\n    def writable(self):\n        return True\n\n    # ==================================================\n    # socket object methods.\n    # ==================================================\n\n    def listen(self, num):\n        self.accepting = True\n        if os.name == \"nt\" and num > 5:  # pragma: no cover\n            num = 5\n        return self.socket.listen(num)\n\n    def bind(self, addr):\n        self.addr = addr\n        return self.socket.bind(addr)\n\n    def connect(self, address):\n        self.connected = False\n        self.connecting = True\n        err = self.socket.connect_ex(address)\n        if (\n            err in (EINPROGRESS, EALREADY, EWOULDBLOCK)\n            or err == EINVAL\n            and os.name == \"nt\"\n        ):  # pragma: no cover\n            self.addr = address\n            return\n        if err in (0, EISCONN):\n            self.addr = address\n            self.handle_connect_event()\n        else:\n            raise OSError(err, errorcode[err])\n\n    def accept(self):\n        # XXX can return either an address pair or None\n        try:\n            conn, addr = self.socket.accept()\n        except TypeError:\n            return None\n        except OSError as why:\n            if why.args[0] in (EWOULDBLOCK, ECONNABORTED, EAGAIN):\n                return None\n            else:\n                raise\n        else:\n            return conn, addr\n\n    def send(self, data):\n        try:\n            result = self.socket.send(data)\n            return result\n        except OSError as why:\n            if why.args[0] == EWOULDBLOCK:\n                return 0\n            elif why.args[0] in _DISCONNECTED:\n                self.handle_close()\n                return 0\n            else:\n                raise\n\n    def recv(self, buffer_size):\n        try:\n            data = self.socket.recv(buffer_size)\n            if not data:\n                # a closed connection is indicated by signaling\n                # a read condition, and having recv() return 0.\n                self.handle_close()\n                return b\"\"\n            else:\n                return data\n        except OSError as why:\n            # winsock sometimes raises ENOTCONN\n            if why.args[0] in _DISCONNECTED:\n                self.handle_close()\n                return b\"\"\n            else:\n                raise\n\n    def close(self):\n        self.connected = False\n        self.accepting = False\n        self.connecting = False\n        self.del_channel()\n        if self.socket is not None:\n            try:\n                self.socket.close()\n            except OSError as why:\n                if why.args[0] not in (ENOTCONN, EBADF):\n                    raise\n\n    # log and log_info may be overridden to provide more sophisticated\n    # logging and warning methods. In general, log is for 'hit' logging\n    # and 'log_info' is for informational, warning and error logging.\n\n    def log(self, message):\n        self.logger.log(logging.DEBUG, message)\n\n    def log_info(self, message, type=\"info\"):\n        severity = {\n            \"info\": logging.INFO,\n            \"warning\": logging.WARN,\n            \"error\": logging.ERROR,\n        }\n        self.logger.log(severity.get(type, logging.INFO), message)\n\n    def handle_read_event(self):\n        if self.accepting:\n            # accepting sockets are never connected, they \"spawn\" new\n            # sockets that are connected\n            self.handle_accept()\n        elif not self.connected:\n            if self.connecting:\n                self.handle_connect_event()\n            self.handle_read()\n        else:\n            self.handle_read()\n\n    def handle_connect_event(self):\n        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n        if err != 0:\n            raise OSError(err, _strerror(err))\n        self.handle_connect()\n        self.connected = True\n        self.connecting = False\n\n    def handle_write_event(self):\n        if self.accepting:\n            # Accepting sockets shouldn't get a write event.\n            # We will pretend it didn't happen.\n            return\n\n        if not self.connected:\n            if self.connecting:\n                self.handle_connect_event()\n        self.handle_write()\n\n    def handle_expt_event(self):\n        # handle_expt_event() is called if there might be an error on the\n        # socket, or if there is OOB data\n        # check for the error condition first\n        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n        if err != 0:\n            # we can get here when select.select() says that there is an\n            # exceptional condition on the socket\n            # since there is an error, we'll go ahead and close the socket\n            # like we would in a subclassed handle_read() that received no\n            # data\n            self.handle_close()\n        else:\n            self.handle_expt()\n\n    def handle_error(self):\n        nil, t, v, tbinfo = self.compact_traceback()\n\n        # sometimes a user repr method will crash.\n        try:\n            self_repr = repr(self)\n        except:  # pragma: no cover\n            self_repr = \"<__repr__(self) failed for object at %0x>\" % id(self)\n\n        self.log_info(\n            \"uncaptured python exception, closing channel %s (%s:%s %s)\"\n            % (self_repr, t, v, tbinfo),\n            \"error\",\n        )\n        self.handle_close()\n\n    def handle_expt(self):\n        self.log_info(\"unhandled incoming priority event\", \"warning\")\n\n    def handle_read(self):\n        self.log_info(\"unhandled read event\", \"warning\")\n\n    def handle_write(self):\n        self.log_info(\"unhandled write event\", \"warning\")\n\n    def handle_connect(self):\n        self.log_info(\"unhandled connect event\", \"warning\")\n\n    def handle_accept(self):\n        pair = self.accept()\n        if pair is not None:\n            self.handle_accepted(*pair)\n\n    def handle_accepted(self, sock, addr):\n        sock.close()\n        self.log_info(\"unhandled accepted event\", \"warning\")\n\n    def handle_close(self):\n        self.log_info(\"unhandled close event\", \"warning\")\n        self.close()\n\n\n# ---------------------------------------------------------------------------\n# adds simple buffered output capability, useful for simple clients.\n# [for more sophisticated usage use asynchat.async_chat]\n# ---------------------------------------------------------------------------\n\n\nclass dispatcher_with_send(dispatcher):\n    def __init__(self, sock=None, map=None):\n        dispatcher.__init__(self, sock, map)\n        self.out_buffer = b\"\"\n\n    def initiate_send(self):\n        num_sent = 0\n        num_sent = dispatcher.send(self, self.out_buffer[:65536])\n        self.out_buffer = self.out_buffer[num_sent:]\n\n    handle_write = initiate_send\n\n    def writable(self):\n        return (not self.connected) or len(self.out_buffer)\n\n    def send(self, data):\n        if self.debug:  # pragma: no cover\n            self.log_info(\"sending %s\" % repr(data))\n        self.out_buffer = self.out_buffer + data\n        self.initiate_send()\n\n\ndef close_all(map=None, ignore_all=False):\n    if map is None:  # pragma: no cover\n        map = socket_map\n    for x in list(map.values()):  # list() FBO py3\n        try:\n            x.close()\n        except OSError as x:\n            if x.args[0] == EBADF:\n                pass\n            elif not ignore_all:\n                raise\n        except _reraised_exceptions:\n            raise\n        except:\n            if not ignore_all:\n                raise\n    map.clear()\n\n\n# Asynchronous File I/O:\n#\n# After a little research (reading man pages on various unixen, and\n# digging through the linux kernel), I've determined that select()\n# isn't meant for doing asynchronous file i/o.\n# Heartening, though - reading linux/mm/filemap.c shows that linux\n# supports asynchronous read-ahead.  So _MOST_ of the time, the data\n# will be sitting in memory for us already when we go to read it.\n#\n# What other OS's (besides NT) support async file i/o?  [VMS?]\n#\n# Regardless, this is useful for pipes, and stdin/stdout...\n\nif os.name == \"posix\":\n\n    class file_wrapper:\n        # Here we override just enough to make a file\n        # look like a socket for the purposes of asyncore.\n        # The passed fd is automatically os.dup()'d\n\n        def __init__(self, fd):\n            self.fd = os.dup(fd)\n\n        def __del__(self):\n            if self.fd >= 0:\n                warnings.warn(\"unclosed file %r\" % self, ResourceWarning)\n            self.close()\n\n        def recv(self, *args):\n            return os.read(self.fd, *args)\n\n        def send(self, *args):\n            return os.write(self.fd, *args)\n\n        def getsockopt(self, level, optname, buflen=None):  # pragma: no cover\n            if level == socket.SOL_SOCKET and optname == socket.SO_ERROR and not buflen:\n                return 0\n            raise NotImplementedError(\n                \"Only asyncore specific behaviour \" \"implemented.\"\n            )\n\n        read = recv\n        write = send\n\n        def close(self):\n            if self.fd < 0:\n                return\n            fd = self.fd\n            self.fd = -1\n            os.close(fd)\n\n        def fileno(self):\n            return self.fd\n\n    class file_dispatcher(dispatcher):\n        def __init__(self, fd, map=None):\n            dispatcher.__init__(self, None, map)\n            self.connected = True\n            try:\n                fd = fd.fileno()\n            except AttributeError:\n                pass\n            self.set_file(fd)\n            # set it to non-blocking mode\n            os.set_blocking(fd, False)\n\n        def set_file(self, fd):\n            self.socket = file_wrapper(fd)\n            self._fileno = self.socket.fileno()\n            self.add_channel()\n", "import io\nimport unittest\n\nimport pytest\n\n\nclass TestHTTPChannel(unittest.TestCase):\n    def _makeOne(self, sock, addr, adj, map=None):\n        from waitress.channel import HTTPChannel\n\n        server = DummyServer()\n        return HTTPChannel(server, sock, addr, adj=adj, map=map)\n\n    def _makeOneWithMap(self, adj=None):\n        if adj is None:\n            adj = DummyAdjustments()\n        sock = DummySock()\n        map = {}\n        inst = self._makeOne(sock, \"127.0.0.1\", adj, map=map)\n        inst.outbuf_lock = DummyLock()\n        return inst, sock, map\n\n    def test_ctor(self):\n        inst, _, map = self._makeOneWithMap()\n        self.assertEqual(inst.addr, \"127.0.0.1\")\n        self.assertEqual(inst.sendbuf_len, 2048)\n        self.assertEqual(map[100], inst)\n\n    def test_total_outbufs_len_an_outbuf_size_gt_sys_maxint(self):\n        from waitress.compat import MAXINT\n\n        inst, _, map = self._makeOneWithMap()\n\n        class DummyBuffer:\n            chunks = []\n\n            def append(self, data):\n                self.chunks.append(data)\n\n        class DummyData:\n            def __len__(self):\n                return MAXINT\n\n        inst.total_outbufs_len = 1\n        inst.outbufs = [DummyBuffer()]\n        inst.write_soon(DummyData())\n        # we are testing that this method does not raise an OverflowError\n        # (see https://github.com/Pylons/waitress/issues/47)\n        self.assertEqual(inst.total_outbufs_len, MAXINT + 1)\n\n    def test_writable_something_in_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.total_outbufs_len = 3\n        self.assertTrue(inst.writable())\n\n    def test_writable_nothing_in_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        self.assertFalse(inst.writable())\n\n    def test_writable_nothing_in_outbuf_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = True\n        self.assertTrue(inst.writable())\n\n    def test_handle_write_not_connected(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.connected = False\n        self.assertFalse(inst.handle_write())\n\n    def test_handle_write_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n\n    def test_handle_write_no_request_with_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertNotEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_outbuf_raises_socketerror(self):\n        import socket\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"abc\", socket.error)\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_outbuf_raises_othererror(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"abc\", IOError)\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_no_requests_no_outbuf_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"\")\n        inst.outbufs = [outbuf]\n        inst.will_close = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_no_requests_outbuf_gt_send_bytes(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 2\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_close_when_flushed(self):\n        inst, sock, map = self._makeOneWithMap()\n        outbuf = DummyBuffer(b\"abc\")\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.will_close = False\n        inst.close_when_flushed = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, True)\n        self.assertEqual(inst.close_when_flushed, False)\n        self.assertEqual(sock.sent, b\"abc\")\n        self.assertTrue(outbuf.closed)\n\n    def test_readable_no_requests_not_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.will_close = False\n        self.assertEqual(inst.readable(), True)\n\n    def test_readable_no_requests_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.will_close = True\n        self.assertEqual(inst.readable(), False)\n\n    def test_readable_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        self.assertEqual(inst.readable(), False)\n\n    def test_handle_read_no_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = False\n        inst.recv = lambda *arg: b\"abc\"\n        inst.last_activity = 0\n        L = []\n        inst.received = lambda x: L.append(x)\n        result = inst.handle_read()\n        self.assertEqual(result, None)\n        self.assertNotEqual(inst.last_activity, 0)\n        self.assertEqual(L, [b\"abc\"])\n\n    def test_handle_read_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = False\n\n        def recv(b):\n            raise OSError\n\n        inst.recv = recv\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_read()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test_write_soon_empty_byte(self):\n        inst, sock, map = self._makeOneWithMap()\n        wrote = inst.write_soon(b\"\")\n        self.assertEqual(wrote, 0)\n        self.assertEqual(len(inst.outbufs[0]), 0)\n\n    def test_write_soon_nonempty_byte(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush\n        def send(_):\n            return 0\n\n        sock.send = send\n\n        wrote = inst.write_soon(b\"a\")\n        self.assertEqual(wrote, 1)\n        self.assertEqual(len(inst.outbufs[0]), 1)\n\n    def test_write_soon_filewrapper(self):\n        from waitress.buffers import ReadOnlyFileBasedBuffer\n\n        f = io.BytesIO(b\"abc\")\n        wrapper = ReadOnlyFileBasedBuffer(f, 8192)\n        wrapper.prepare()\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush\n        def send(_):\n            return 0\n\n        sock.send = send\n\n        outbufs = inst.outbufs\n        wrote = inst.write_soon(wrapper)\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(outbufs), 2)\n        self.assertEqual(outbufs[0], wrapper)\n        self.assertEqual(outbufs[1].__class__.__name__, \"OverflowableBuffer\")\n\n    def test_write_soon_disconnected(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.connected = False\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"stuff\"))\n\n    def test_write_soon_disconnected_while_over_watermark(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n\n        def dummy_flush():\n            inst.connected = False\n\n        inst._flush_outbufs_below_high_watermark = dummy_flush\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"stuff\"))\n\n    def test_write_soon_rotates_outbuf_on_overflow(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush\n        def send(_):\n            return 0\n\n        sock.send = send\n\n        inst.adj.outbuf_high_watermark = 3\n        inst.current_outbuf_count = 4\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(inst.outbufs), 1)\n        self.assertEqual(inst.outbufs[0].get(), b\"xyz\")\n\n    def test_write_soon_waits_on_backpressure(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush\n        def send(_):\n            return 0\n\n        sock.send = send\n\n        inst.adj.outbuf_high_watermark = 3\n        inst.total_outbufs_len = 4\n        inst.current_outbuf_count = 4\n\n        class Lock(DummyLock):\n            def wait(self):\n                inst.total_outbufs_len = 0\n                super().wait()\n\n        inst.outbuf_lock = Lock()\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(inst.outbufs), 1)\n        self.assertEqual(inst.outbufs[0].get(), b\"xyz\")\n        self.assertTrue(inst.outbuf_lock.waited)\n\n    def test_write_soon_attempts_flush_high_water_and_exception(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush, it will raise Exception, which\n        # disconnects the remote end\n        def send(_):\n            inst.connected = False\n            raise Exception()\n\n        sock.send = send\n\n        inst.adj.outbuf_high_watermark = 3\n        inst.total_outbufs_len = 4\n        inst.current_outbuf_count = 4\n\n        inst.outbufs[0].append(b\"test\")\n\n        class Lock(DummyLock):\n            def wait(self):\n                inst.total_outbufs_len = 0\n                super().wait()\n\n        inst.outbuf_lock = Lock()\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"xyz\"))\n\n        # Validate we woke up the main thread to deal with the exception of\n        # trying to send\n        self.assertTrue(inst.outbuf_lock.waited)\n        self.assertTrue(inst.server.trigger_pulled)\n\n    def test_write_soon_flush_and_exception(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush, it will raise Exception, which\n        # disconnects the remote end\n        def send(_):\n            inst.connected = False\n            raise Exception()\n\n        sock.send = send\n\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        # Validate we woke up the main thread to deal with the exception of\n        # trying to send\n        self.assertTrue(inst.server.trigger_pulled)\n\n    def test_handle_write_notify_after_flush(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 1\n        inst.adj.outbuf_high_watermark = 5\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertTrue(inst.outbuf_lock.notified)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_no_notify_after_flush(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 1\n        inst.adj.outbuf_high_watermark = 2\n        sock.send = lambda x: False\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertFalse(inst.outbuf_lock.notified)\n        self.assertEqual(sock.sent, b\"\")\n\n    def test__flush_some_empty_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        result = inst._flush_some()\n        self.assertEqual(result, False)\n\n    def test__flush_some_full_outbuf_socket_returns_nonzero(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.outbufs[0].append(b\"abc\")\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n\n    def test__flush_some_full_outbuf_socket_returns_zero(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: False\n        inst.outbufs[0].append(b\"abc\")\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, False)\n\n    def test_flush_some_multiple_buffers_first_empty(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: len(x)\n        buffer = DummyBuffer(b\"abc\")\n        inst.outbufs.append(buffer)\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n        self.assertEqual(buffer.skipped, 3)\n        self.assertEqual(inst.outbufs, [buffer])\n\n    def test_flush_some_multiple_buffers_close_raises(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: len(x)\n        buffer = DummyBuffer(b\"abc\")\n        inst.outbufs.append(buffer)\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        inst.logger = DummyLogger()\n\n        def doraise():\n            raise NotImplementedError\n\n        inst.outbufs[0].close = doraise\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n        self.assertEqual(buffer.skipped, 3)\n        self.assertEqual(inst.outbufs, [buffer])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test__flush_some_outbuf_len_gt_sys_maxint(self):\n        from waitress.compat import MAXINT\n\n        inst, sock, map = self._makeOneWithMap()\n\n        class DummyHugeOutbuffer:\n            def __init__(self):\n                self.length = MAXINT + 1\n\n            def __len__(self):\n                return self.length\n\n            def get(self, numbytes):\n                self.length = 0\n                return b\"123\"\n\n        buf = DummyHugeOutbuffer()\n        inst.outbufs = [buf]\n        inst.send = lambda *arg: 0\n        result = inst._flush_some()\n        # we are testing that _flush_some doesn't raise an OverflowError\n        # when one of its outbufs has a __len__ that returns gt sys.maxint\n        self.assertEqual(result, False)\n\n    def test_handle_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.handle_close()\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n\n    def test_handle_close_outbuf_raises_on_close(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        def doraise():\n            raise NotImplementedError\n\n        inst.outbufs[0].close = doraise\n        inst.logger = DummyLogger()\n        inst.handle_close()\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test_add_channel(self):\n        inst, sock, map = self._makeOneWithMap()\n        fileno = inst._fileno\n        inst.add_channel(map)\n        self.assertEqual(map[fileno], inst)\n        self.assertEqual(inst.server.active_channels[fileno], inst)\n\n    def test_del_channel(self):\n        inst, sock, map = self._makeOneWithMap()\n        fileno = inst._fileno\n        inst.server.active_channels[fileno] = True\n        inst.del_channel(map)\n        self.assertEqual(map.get(fileno), None)\n        self.assertEqual(inst.server.active_channels.get(fileno), None)\n\n    def test_received(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.server.tasks, [inst])\n        self.assertTrue(inst.requests)\n\n    def test_received_no_chunk(self):\n        inst, sock, map = self._makeOneWithMap()\n        self.assertEqual(inst.received(b\"\"), False)\n\n    def test_received_preq_not_completed(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = False\n        preq.empty = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_completed_empty(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, None)\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.error = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, None)\n        self.assertEqual(len(inst.server.tasks), 1)\n        self.assertTrue(inst.requests)\n\n    def test_received_preq_completed_connection_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = True\n        preq.connection_close = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\" + b\"a\" * 50000)\n        self.assertEqual(inst.request, None)\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_headers_finished_expect_continue_false(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = False\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        preq.retval = 1\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(inst.outbufs[0].get(100), b\"\")\n\n    def test_received_headers_finished_expect_continue_true(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = True\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(sock.sent, b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n        self.assertEqual(inst.sent_continue, True)\n        self.assertEqual(preq.completed, False)\n\n    def test_received_headers_finished_expect_continue_true_sent_true(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = True\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        inst.sent_continue = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(inst.sent_continue, True)\n        self.assertEqual(preq.completed, False)\n\n    def test_service_with_one_request(self):\n        inst, sock, map = self._makeOneWithMap()\n        request = DummyRequest()\n        inst.task_class = DummyTaskClass()\n        inst.requests = [request]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request.serviced)\n        self.assertTrue(request.closed)\n\n    def test_service_with_one_error_request(self):\n        inst, sock, map = self._makeOneWithMap()\n        request = DummyRequest()\n        request.error = DummyError()\n        inst.error_task_class = DummyTaskClass()\n        inst.requests = [request]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request.serviced)\n        self.assertTrue(request.closed)\n\n    def test_service_with_multiple_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        request1 = DummyRequest()\n        request2 = DummyRequest()\n        inst.task_class = DummyTaskClass()\n        inst.requests = [request1, request2]\n        inst.service()\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request1.serviced)\n        self.assertTrue(request2.serviced)\n        self.assertTrue(request1.closed)\n        self.assertTrue(request2.closed)\n\n    def test_service_with_request_raises(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_already_wrote_header(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertTrue(inst.close_when_flushed)\n        self.assertEqual(inst.error_task_class.serviced, False)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_didnt_write_header_expose_tbs(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = True\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_didnt_write_header(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertTrue(inst.close_when_flushed)\n        self.assertTrue(request.closed)\n\n    def test_service_with_request_raises_disconnect(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ClientDisconnected)\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.infos), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.error_task_class.serviced, False)\n        self.assertTrue(request.closed)\n\n    def test_service_with_request_error_raises_disconnect(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        err_request = DummyRequest()\n        inst.requests = [request]\n        inst.parser_class = lambda x: err_request\n        inst.task_class = DummyTaskClass(RuntimeError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass(ClientDisconnected)\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertTrue(err_request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertEqual(len(inst.logger.infos), 0)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.task_class.serviced, True)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_cancel_no_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = ()\n        inst.cancel()\n        self.assertEqual(inst.requests, [])\n\n    def test_cancel_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [None]\n        inst.cancel()\n        self.assertEqual(inst.requests, [])\n\n\nclass TestHTTPChannelLookahead(TestHTTPChannel):\n    def app_check_disconnect(self, environ, start_response):\n        \"\"\"\n        Application that checks for client disconnection every\n        second for up to two seconds.\n        \"\"\"\n        import time\n\n        if hasattr(self, \"app_started\"):\n            self.app_started.set()\n\n        try:\n            request_body_size = int(environ.get(\"CONTENT_LENGTH\", 0))\n        except ValueError:\n            request_body_size = 0\n        self.request_body = environ[\"wsgi.input\"].read(request_body_size)\n\n        self.disconnect_detected = False\n        check = environ[\"waitress.client_disconnected\"]\n        if environ[\"PATH_INFO\"] == \"/sleep\":\n            for i in range(3):\n                if i != 0:\n                    time.sleep(1)\n                if check():\n                    self.disconnect_detected = True\n                    break\n\n        body = b\"finished\"\n        cl = str(len(body))\n        start_response(\n            \"200 OK\", [(\"Content-Length\", cl), (\"Content-Type\", \"text/plain\")]\n        )\n        return [body]\n\n    def _make_app_with_lookahead(self):\n        \"\"\"\n        Setup a channel with lookahead and store it and the socket in self\n        \"\"\"\n        adj = DummyAdjustments()\n        adj.channel_request_lookahead = 5\n        channel, sock, map = self._makeOneWithMap(adj=adj)\n        channel.server.application = self.app_check_disconnect\n\n        self.channel = channel\n        self.sock = sock\n\n    def _send(self, *lines):\n        \"\"\"\n        Send lines through the socket with correct line endings\n        \"\"\"\n        self.sock.send(\"\".join(line + \"\\r\\n\" for line in lines).encode(\"ascii\"))\n\n    def test_client_disconnect(self, close_before_start=False):\n        \"\"\"Disconnect the socket after starting the task.\"\"\"\n        import threading\n\n        self._make_app_with_lookahead()\n        self._send(\n            \"GET /sleep HTTP/1.1\",\n            \"Host: localhost:8080\",\n            \"\",\n        )\n        self.assertTrue(self.channel.readable())\n        self.channel.handle_read()\n        self.assertEqual(len(self.channel.server.tasks), 1)\n        self.app_started = threading.Event()\n        self.disconnect_detected = False\n        thread = threading.Thread(target=self.channel.server.tasks[0].service)\n\n        if not close_before_start:\n            thread.start()\n            self.assertTrue(self.app_started.wait(timeout=5))\n\n        # Close the socket, check that the channel is still readable due to the\n        # lookahead and read it, which marks the channel as closed.\n        self.sock.close()\n        self.assertTrue(self.channel.readable())\n        self.channel.handle_read()\n\n        if close_before_start:\n            thread.start()\n\n        thread.join()\n\n        if close_before_start:\n            self.assertFalse(self.app_started.is_set())\n        else:\n            self.assertTrue(self.disconnect_detected)\n\n    def test_client_disconnect_immediate(self):\n        \"\"\"\n        The same test, but this time we close the socket even before processing\n        started. The app should not be executed.\n        \"\"\"\n        self.test_client_disconnect(close_before_start=True)\n\n    def test_lookahead_continue(self):\n        \"\"\"\n        Send two requests to a channel with lookahead and use an\n        expect-continue on the second one, making sure the responses still come\n        in the right order.\n        \"\"\"\n        self._make_app_with_lookahead()\n        self._send(\n            \"POST / HTTP/1.1\",\n            \"Host: localhost:8080\",\n            \"Content-Length: 1\",\n            \"\",\n            \"x\",\n            \"POST / HTTP/1.1\",\n            \"Host: localhost:8080\",\n            \"Content-Length: 1\",\n            \"Expect: 100-continue\",\n            \"\",\n        )\n        self.channel.handle_read()\n        self.assertEqual(len(self.channel.requests), 1)\n        self.channel.server.tasks[0].service()\n        data = self.sock.recv(256).decode(\"ascii\")\n        self.assertTrue(data.endswith(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"))\n\n        self.sock.send(b\"x\")\n        self.channel.handle_read()\n        self.assertEqual(len(self.channel.requests), 1)\n        self.channel.server.tasks[0].service()\n        self.channel._flush_some()\n        data = self.sock.recv(256).decode(\"ascii\")\n        self.assertEqual(data.split(\"\\r\\n\")[-1], \"finished\")\n        self.assertEqual(self.request_body, b\"x\")\n\n\nclass DummySock:\n    blocking = False\n    closed = False\n\n    def __init__(self):\n        self.sent = b\"\"\n\n    def setblocking(self, *arg):\n        self.blocking = True\n\n    def fileno(self):\n        return 100\n\n    def getpeername(self):\n        return \"127.0.0.1\"\n\n    def getsockopt(self, level, option):\n        return 2048\n\n    def close(self):\n        self.closed = True\n\n    def send(self, data):\n        self.sent += data\n        return len(data)\n\n    def recv(self, buffer_size):\n        result = self.sent[:buffer_size]\n        self.sent = self.sent[buffer_size:]\n        return result\n\n\nclass DummyLock:\n    notified = False\n\n    def __init__(self, acquirable=True):\n        self.acquirable = acquirable\n\n    def acquire(self, val):\n        self.val = val\n        self.acquired = True\n        return self.acquirable\n\n    def release(self):\n        self.released = True\n\n    def notify(self):\n        self.notified = True\n\n    def wait(self):\n        self.waited = True\n\n    def __exit__(self, type, val, traceback):\n        self.acquire(True)\n\n    def __enter__(self):\n        pass\n\n\nclass DummyBuffer:\n    closed = False\n\n    def __init__(self, data, toraise=None):\n        self.data = data\n        self.toraise = toraise\n\n    def get(self, *arg):\n        if self.toraise:\n            raise self.toraise\n        data = self.data\n        self.data = b\"\"\n        return data\n\n    def skip(self, num, x):\n        self.skipped = num\n\n    def __len__(self):\n        return len(self.data)\n\n    def close(self):\n        self.closed = True\n\n\nclass DummyAdjustments:\n    outbuf_overflow = 1048576\n    outbuf_high_watermark = 1048576\n    inbuf_overflow = 512000\n    cleanup_interval = 900\n    url_scheme = \"http\"\n    channel_timeout = 300\n    log_socket_errors = True\n    recv_bytes = 8192\n    send_bytes = 1\n    expose_tracebacks = True\n    ident = \"waitress\"\n    max_request_header_size = 10000\n    url_prefix = \"\"\n    channel_request_lookahead = 0\n    max_request_body_size = 1048576\n\n\nclass DummyServer:\n    trigger_pulled = False\n    adj = DummyAdjustments()\n    effective_port = 8080\n    server_name = \"\"\n\n    def __init__(self):\n        self.tasks = []\n        self.active_channels = {}\n\n    def add_task(self, task):\n        self.tasks.append(task)\n\n    def pull_trigger(self):\n        self.trigger_pulled = True\n\n\nclass DummyParser:\n    version = 1\n    data = None\n    completed = True\n    empty = False\n    headers_finished = False\n    expect_continue = False\n    retval = None\n    error = None\n    connection_close = False\n\n    def received(self, data):\n        self.data = data\n        if self.retval is not None:\n            return self.retval\n        return len(data)\n\n\nclass DummyRequest:\n    error = None\n    path = \"/\"\n    version = \"1.0\"\n    closed = False\n\n    def __init__(self):\n        self.headers = {}\n\n    def close(self):\n        self.closed = True\n\n\nclass DummyLogger:\n    def __init__(self):\n        self.exceptions = []\n        self.infos = []\n        self.warnings = []\n\n    def info(self, msg):\n        self.infos.append(msg)\n\n    def exception(self, msg):\n        self.exceptions.append(msg)\n\n\nclass DummyError:\n    code = \"431\"\n    reason = \"Bleh\"\n    body = \"My body\"\n\n\nclass DummyTaskClass:\n    wrote_header = True\n    close_on_finish = False\n    serviced = False\n\n    def __init__(self, toraise=None):\n        self.toraise = toraise\n\n    def __call__(self, channel, request):\n        self.request = request\n        return self\n\n    def service(self):\n        self.serviced = True\n        self.request.serviced = True\n        if self.toraise:\n            raise self.toraise\n"], "fixing_code": ["##############################################################################\n#\n# Copyright (c) 2001, 2002 Zope Foundation and Contributors.\n# All Rights Reserved.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE.\n#\n##############################################################################\nimport socket\nimport threading\nimport time\nimport traceback\n\nfrom waitress.buffers import OverflowableBuffer, ReadOnlyFileBasedBuffer\nfrom waitress.parser import HTTPRequestParser\nfrom waitress.task import ErrorTask, WSGITask\nfrom waitress.utilities import InternalServerError\n\nfrom . import wasyncore\n\n\nclass ClientDisconnected(Exception):\n    \"\"\"Raised when attempting to write to a closed socket.\"\"\"\n\n\nclass HTTPChannel(wasyncore.dispatcher):\n    \"\"\"\n    Setting self.requests = [somerequest] prevents more requests from being\n    received until the out buffers have been flushed.\n\n    Setting self.requests = [] allows more requests to be received.\n    \"\"\"\n\n    task_class = WSGITask\n    error_task_class = ErrorTask\n    parser_class = HTTPRequestParser\n\n    # A request that has not been received yet completely is stored here\n    request = None\n    last_activity = 0  # Time of last activity\n    will_close = False  # set to True to close the socket.\n    close_when_flushed = False  # set to True to close the socket when flushed\n    sent_continue = False  # used as a latch after sending 100 continue\n    total_outbufs_len = 0  # total bytes ready to send\n    current_outbuf_count = 0  # total bytes written to current outbuf\n\n    #\n    # ASYNCHRONOUS METHODS (including __init__)\n    #\n\n    def __init__(self, server, sock, addr, adj, map=None):\n        self.server = server\n        self.adj = adj\n        self.outbufs = [OverflowableBuffer(adj.outbuf_overflow)]\n        self.creation_time = self.last_activity = time.time()\n        self.sendbuf_len = sock.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)\n\n        # requests_lock used to push/pop requests and modify the request that is\n        # currently being created\n        self.requests_lock = threading.Lock()\n        # outbuf_lock used to access any outbuf (expected to use an RLock)\n        self.outbuf_lock = threading.Condition()\n\n        wasyncore.dispatcher.__init__(self, sock, map=map)\n\n        # Don't let wasyncore.dispatcher throttle self.addr on us.\n        self.addr = addr\n        self.requests = []\n\n    def check_client_disconnected(self):\n        \"\"\"\n        This method is inserted into the environment of any created task so it\n        may occasionally check if the client has disconnected and interrupt\n        execution.\n        \"\"\"\n\n        return not self.connected\n\n    def writable(self):\n        # if there's data in the out buffer or we've been instructed to close\n        # the channel (possibly by our server maintenance logic), run\n        # handle_write\n\n        return self.total_outbufs_len or self.will_close or self.close_when_flushed\n\n    def handle_write(self):\n        # Precondition: there's data in the out buffer to be sent, or\n        # there's a pending will_close request\n\n        if not self.connected:\n            # we dont want to close the channel twice\n\n            return\n\n        # try to flush any pending output\n\n        if not self.requests:\n            # 1. There are no running tasks, so we don't need to try to lock\n            #    the outbuf before sending\n            # 2. The data in the out buffer should be sent as soon as possible\n            #    because it's either data left over from task output\n            #    or a 100 Continue line sent within \"received\".\n            flush = self._flush_some\n        elif self.total_outbufs_len >= self.adj.send_bytes:\n            # 1. There's a running task, so we need to try to lock\n            #    the outbuf before sending\n            # 2. Only try to send if the data in the out buffer is larger\n            #    than self.adj_bytes to avoid TCP fragmentation\n            flush = self._flush_some_if_lockable\n        else:\n            # 1. There's not enough data in the out buffer to bother to send\n            #    right now.\n            flush = None\n\n        self._flush_exception(flush)\n\n        if self.close_when_flushed and not self.total_outbufs_len:\n            self.close_when_flushed = False\n            self.will_close = True\n\n        if self.will_close:\n            self.handle_close()\n\n    def _flush_exception(self, flush, do_close=True):\n        if flush:\n            try:\n                return (flush(do_close=do_close), False)\n            except OSError:\n                if self.adj.log_socket_errors:\n                    self.logger.exception(\"Socket error\")\n                self.will_close = True\n\n                return (False, True)\n            except Exception:  # pragma: nocover\n                self.logger.exception(\"Unexpected exception when flushing\")\n                self.will_close = True\n\n                return (False, True)\n\n    def readable(self):\n        # We might want to read more requests. We can only do this if:\n        # 1. We're not already about to close the connection.\n        # 2. We're not waiting to flush remaining data before closing the\n        #    connection\n        # 3. There are not too many tasks already queued\n        # 4. There's no data in the output buffer that needs to be sent\n        #    before we potentially create a new task.\n\n        return not (\n            self.will_close\n            or self.close_when_flushed\n            or len(self.requests) > self.adj.channel_request_lookahead\n            or self.total_outbufs_len\n        )\n\n    def handle_read(self):\n        try:\n            data = self.recv(self.adj.recv_bytes)\n        except OSError:\n            if self.adj.log_socket_errors:\n                self.logger.exception(\"Socket error\")\n            self.handle_close()\n\n            return\n\n        if data:\n            self.last_activity = time.time()\n            self.received(data)\n        else:\n            # Client disconnected.\n            self.connected = False\n\n    def send_continue(self):\n        \"\"\"\n        Send a 100-Continue header to the client. This is either called from\n        receive (if no requests are running and the client expects it) or at\n        the end of service (if no more requests are queued and a request has\n        been read partially that expects it).\n        \"\"\"\n        self.request.expect_continue = False\n        outbuf_payload = b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"\n        num_bytes = len(outbuf_payload)\n        with self.outbuf_lock:\n            self.outbufs[-1].append(outbuf_payload)\n            self.current_outbuf_count += num_bytes\n            self.total_outbufs_len += num_bytes\n            self.sent_continue = True\n            self._flush_some()\n        self.request.completed = False\n\n    def received(self, data):\n        \"\"\"\n        Receives input asynchronously and assigns one or more requests to the\n        channel.\n        \"\"\"\n\n        if not data:\n            return False\n\n        with self.requests_lock:\n            while data:\n                if self.request is None:\n                    self.request = self.parser_class(self.adj)\n                n = self.request.received(data)\n\n                # if there are requests queued, we can not send the continue\n                # header yet since the responses need to be kept in order\n\n                if (\n                    self.request.expect_continue\n                    and self.request.headers_finished\n                    and not self.requests\n                    and not self.sent_continue\n                ):\n                    self.send_continue()\n\n                if self.request.completed:\n                    # The request (with the body) is ready to use.\n                    self.sent_continue = False\n\n                    if not self.request.empty:\n                        self.requests.append(self.request)\n\n                        if len(self.requests) == 1:\n                            # self.requests was empty before so the main thread\n                            # is in charge of starting the task. Otherwise,\n                            # service() will add a new task after each request\n                            # has been processed\n                            self.server.add_task(self)\n                    self.request = None\n\n                if n >= len(data):\n                    break\n                data = data[n:]\n\n        return True\n\n    def _flush_some_if_lockable(self, do_close=True):\n        # Since our task may be appending to the outbuf, we try to acquire\n        # the lock, but we don't block if we can't.\n\n        if self.outbuf_lock.acquire(False):\n            try:\n                self._flush_some(do_close=do_close)\n\n                if self.total_outbufs_len < self.adj.outbuf_high_watermark:\n                    self.outbuf_lock.notify()\n            finally:\n                self.outbuf_lock.release()\n\n    def _flush_some(self, do_close=True):\n        # Send as much data as possible to our client\n\n        sent = 0\n        dobreak = False\n\n        while True:\n            outbuf = self.outbufs[0]\n            # use outbuf.__len__ rather than len(outbuf) FBO of not getting\n            # OverflowError on 32-bit Python\n            outbuflen = outbuf.__len__()\n\n            while outbuflen > 0:\n                chunk = outbuf.get(self.sendbuf_len)\n                num_sent = self.send(chunk, do_close=do_close)\n\n                if num_sent:\n                    outbuf.skip(num_sent, True)\n                    outbuflen -= num_sent\n                    sent += num_sent\n                    self.total_outbufs_len -= num_sent\n                else:\n                    # failed to write anything, break out entirely\n                    dobreak = True\n\n                    break\n            else:\n                # self.outbufs[-1] must always be a writable outbuf\n\n                if len(self.outbufs) > 1:\n                    toclose = self.outbufs.pop(0)\n                    try:\n                        toclose.close()\n                    except Exception:\n                        self.logger.exception(\"Unexpected error when closing an outbuf\")\n                else:\n                    # caught up, done flushing for now\n                    dobreak = True\n\n            if dobreak:\n                break\n\n        if sent:\n            self.last_activity = time.time()\n\n            return True\n\n        return False\n\n    def handle_close(self):\n        with self.outbuf_lock:\n            for outbuf in self.outbufs:\n                try:\n                    outbuf.close()\n                except Exception:\n                    self.logger.exception(\n                        \"Unknown exception while trying to close outbuf\"\n                    )\n            self.total_outbufs_len = 0\n            self.connected = False\n            self.outbuf_lock.notify()\n        wasyncore.dispatcher.close(self)\n\n    def add_channel(self, map=None):\n        \"\"\"See wasyncore.dispatcher\n\n        This hook keeps track of opened channels.\n        \"\"\"\n        wasyncore.dispatcher.add_channel(self, map)\n        self.server.active_channels[self._fileno] = self\n\n    def del_channel(self, map=None):\n        \"\"\"See wasyncore.dispatcher\n\n        This hook keeps track of closed channels.\n        \"\"\"\n        fd = self._fileno  # next line sets this to None\n        wasyncore.dispatcher.del_channel(self, map)\n        ac = self.server.active_channels\n\n        if fd in ac:\n            del ac[fd]\n\n    #\n    # SYNCHRONOUS METHODS\n    #\n\n    def write_soon(self, data):\n        if not self.connected:\n            # if the socket is closed then interrupt the task so that it\n            # can cleanup possibly before the app_iter is exhausted\n            raise ClientDisconnected\n\n        if data:\n            # the async mainloop might be popping data off outbuf; we can\n            # block here waiting for it because we're in a task thread\n            with self.outbuf_lock:\n                self._flush_outbufs_below_high_watermark()\n\n                if not self.connected:\n                    raise ClientDisconnected\n                num_bytes = len(data)\n\n                if data.__class__ is ReadOnlyFileBasedBuffer:\n                    # they used wsgi.file_wrapper\n                    self.outbufs.append(data)\n                    nextbuf = OverflowableBuffer(self.adj.outbuf_overflow)\n                    self.outbufs.append(nextbuf)\n                    self.current_outbuf_count = 0\n                else:\n                    if self.current_outbuf_count >= self.adj.outbuf_high_watermark:\n                        # rotate to a new buffer if the current buffer has hit\n                        # the watermark to avoid it growing unbounded\n                        nextbuf = OverflowableBuffer(self.adj.outbuf_overflow)\n                        self.outbufs.append(nextbuf)\n                        self.current_outbuf_count = 0\n                    self.outbufs[-1].append(data)\n                    self.current_outbuf_count += num_bytes\n                self.total_outbufs_len += num_bytes\n\n                if self.total_outbufs_len >= self.adj.send_bytes:\n                    (flushed, exception) = self._flush_exception(\n                        self._flush_some, do_close=False\n                    )\n\n                    if (\n                        exception\n                        or not flushed\n                        or self.total_outbufs_len >= self.adj.send_bytes\n                    ):\n                        self.server.pull_trigger()\n\n            return num_bytes\n\n        return 0\n\n    def _flush_outbufs_below_high_watermark(self):\n        # check first to avoid locking if possible\n\n        if self.total_outbufs_len > self.adj.outbuf_high_watermark:\n            with self.outbuf_lock:\n                (_, exception) = self._flush_exception(self._flush_some, do_close=False)\n\n                if exception:\n                    # An exception happened while flushing, wake up the main\n                    # thread, then wait for it to decide what to do next\n                    # (probably close the socket, and then just return)\n                    self.server.pull_trigger()\n                    self.outbuf_lock.wait()\n\n                    return\n\n                while (\n                    self.connected\n                    and self.total_outbufs_len > self.adj.outbuf_high_watermark\n                ):\n                    self.server.pull_trigger()\n                    self.outbuf_lock.wait()\n\n    def service(self):\n        \"\"\"Execute one request. If there are more, we add another task to the\n        server at the end.\"\"\"\n\n        request = self.requests[0]\n\n        if request.error:\n            task = self.error_task_class(self, request)\n        else:\n            task = self.task_class(self, request)\n\n        try:\n            if self.connected:\n                task.service()\n            else:\n                task.close_on_finish = True\n        except ClientDisconnected:\n            self.logger.info(\"Client disconnected while serving %s\" % task.request.path)\n            task.close_on_finish = True\n        except Exception:\n            self.logger.exception(\"Exception while serving %s\" % task.request.path)\n\n            if not task.wrote_header:\n                if self.adj.expose_tracebacks:\n                    body = traceback.format_exc()\n                else:\n                    body = \"The server encountered an unexpected internal server error\"\n                req_version = request.version\n                req_headers = request.headers\n                err_request = self.parser_class(self.adj)\n                err_request.error = InternalServerError(body)\n                # copy some original request attributes to fulfill\n                # HTTP 1.1 requirements\n                err_request.version = req_version\n                try:\n                    err_request.headers[\"CONNECTION\"] = req_headers[\"CONNECTION\"]\n                except KeyError:\n                    pass\n                task = self.error_task_class(self, err_request)\n                try:\n                    task.service()  # must not fail\n                except ClientDisconnected:\n                    task.close_on_finish = True\n            else:\n                task.close_on_finish = True\n\n        if task.close_on_finish:\n            with self.requests_lock:\n                self.close_when_flushed = True\n\n                for request in self.requests:\n                    request.close()\n                self.requests = []\n        else:\n            # before processing a new request, ensure there is not too\n            # much data in the outbufs waiting to be flushed\n            # NB: currently readable() returns False while we are\n            # flushing data so we know no new requests will come in\n            # that we need to account for, otherwise it'd be better\n            # to do this check at the start of the request instead of\n            # at the end to account for consecutive service() calls\n\n            if len(self.requests) > 1:\n                self._flush_outbufs_below_high_watermark()\n\n            # this is a little hacky but basically it's forcing the\n            # next request to create a new outbuf to avoid sharing\n            # outbufs across requests which can cause outbufs to\n            # not be deallocated regularly when a connection is open\n            # for a long time\n\n            if self.current_outbuf_count > 0:\n                self.current_outbuf_count = self.adj.outbuf_high_watermark\n\n            request.close()\n\n            # Add new task to process the next request\n            with self.requests_lock:\n                self.requests.pop(0)\n\n                if self.connected and self.requests:\n                    self.server.add_task(self)\n                elif (\n                    self.connected\n                    and self.request is not None\n                    and self.request.expect_continue\n                    and self.request.headers_finished\n                    and not self.sent_continue\n                ):\n                    # A request waits for a signal to continue, but we could\n                    # not send it until now because requests were being\n                    # processed and the output needs to be kept in order\n                    self.send_continue()\n\n        if self.connected:\n            self.server.pull_trigger()\n\n        self.last_activity = time.time()\n\n    def cancel(self):\n        \"\"\"Cancels all pending / active requests\"\"\"\n        self.will_close = True\n        self.connected = False\n        self.last_activity = time.time()\n        self.requests = []\n", "# -*- Mode: Python -*-\n#   Id: asyncore.py,v 2.51 2000/09/07 22:29:26 rushing Exp\n#   Author: Sam Rushing <rushing@nightmare.com>\n\n# ======================================================================\n# Copyright 1996 by Sam Rushing\n#\n#                         All Rights Reserved\n#\n# Permission to use, copy, modify, and distribute this software and\n# its documentation for any purpose and without fee is hereby\n# granted, provided that the above copyright notice appear in all\n# copies and that both that copyright notice and this permission\n# notice appear in supporting documentation, and that the name of Sam\n# Rushing not be used in advertising or publicity pertaining to\n# distribution of the software without specific, written prior\n# permission.\n#\n# SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN\n# NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n# ======================================================================\n\n\"\"\"Basic infrastructure for asynchronous socket service clients and servers.\n\nThere are only two ways to have a program on a single processor do \"more\nthan one thing at a time\".  Multi-threaded programming is the simplest and\nmost popular way to do it, but there is another very different technique,\nthat lets you have nearly all the advantages of multi-threading, without\nactually using multiple threads. it's really only practical if your program\nis largely I/O bound. If your program is CPU bound, then pre-emptive\nscheduled threads are probably what you really need. Network servers are\nrarely CPU-bound, however.\n\nIf your operating system supports the select() system call in its I/O\nlibrary (and nearly all do), then you can use it to juggle multiple\ncommunication channels at once; doing other work while your I/O is taking\nplace in the \"background.\"  Although this strategy can seem strange and\ncomplex, especially at first, it is in many ways easier to understand and\ncontrol than multi-threaded programming. The module documented here solves\nmany of the difficult problems for you, making the task of building\nsophisticated high-performance network servers and clients a snap.\n\nNB: this is a fork of asyncore from the stdlib that we've (the waitress\ndevelopers) named 'wasyncore' to ensure forward compatibility, as asyncore\nin the stdlib will be dropped soon.  It is neither a copy of the 2.7 asyncore\nnor the 3.X asyncore; it is a version compatible with either 2.7 or 3.X.\n\"\"\"\n\nfrom errno import (\n    EAGAIN,\n    EALREADY,\n    EBADF,\n    ECONNABORTED,\n    ECONNRESET,\n    EINPROGRESS,\n    EINTR,\n    EINVAL,\n    EISCONN,\n    ENOTCONN,\n    EPIPE,\n    ESHUTDOWN,\n    EWOULDBLOCK,\n    errorcode,\n)\nimport logging\nimport os\nimport select\nimport socket\nimport sys\nimport time\nimport warnings\n\nfrom . import compat, utilities\n\n_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE, EBADF})\n\ntry:\n    socket_map\nexcept NameError:\n    socket_map = {}\n\n\ndef _strerror(err):\n    try:\n        return os.strerror(err)\n    except (TypeError, ValueError, OverflowError, NameError):\n        return \"Unknown error %s\" % err\n\n\nclass ExitNow(Exception):\n    pass\n\n\n_reraised_exceptions = (ExitNow, KeyboardInterrupt, SystemExit)\n\n\ndef read(obj):\n    try:\n        obj.handle_read_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\n\n\ndef write(obj):\n    try:\n        obj.handle_write_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\n\n\ndef _exception(obj):\n    try:\n        obj.handle_expt_event()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\n\n\ndef readwrite(obj, flags):\n    try:\n        if flags & select.POLLIN:\n            obj.handle_read_event()\n        if flags & select.POLLOUT:\n            obj.handle_write_event()\n        if flags & select.POLLPRI:\n            obj.handle_expt_event()\n        if flags & (select.POLLHUP | select.POLLERR | select.POLLNVAL):\n            obj.handle_close()\n    except OSError as e:\n        if e.args[0] not in _DISCONNECTED:\n            obj.handle_error()\n        else:\n            obj.handle_close()\n    except _reraised_exceptions:\n        raise\n    except:\n        obj.handle_error()\n\n\ndef poll(timeout=0.0, map=None):\n    if map is None:  # pragma: no cover\n        map = socket_map\n    if map:\n        r = []\n        w = []\n        e = []\n        for fd, obj in list(map.items()):  # list() call FBO py3\n            is_r = obj.readable()\n            is_w = obj.writable()\n            if is_r:\n                r.append(fd)\n            # accepting sockets should not be writable\n            if is_w and not obj.accepting:\n                w.append(fd)\n            if is_r or is_w:\n                e.append(fd)\n        if [] == r == w == e:\n            time.sleep(timeout)\n            return\n\n        try:\n            r, w, e = select.select(r, w, e, timeout)\n        except OSError as err:\n            if err.args[0] != EINTR:\n                raise\n            else:\n                return\n\n        for fd in r:\n            obj = map.get(fd)\n            if obj is None:  # pragma: no cover\n                continue\n            read(obj)\n\n        for fd in w:\n            obj = map.get(fd)\n            if obj is None:  # pragma: no cover\n                continue\n            write(obj)\n\n        for fd in e:\n            obj = map.get(fd)\n            if obj is None:  # pragma: no cover\n                continue\n            _exception(obj)\n\n\ndef poll2(timeout=0.0, map=None):\n    # Use the poll() support added to the select module in Python 2.0\n    if map is None:  # pragma: no cover\n        map = socket_map\n    if timeout is not None:\n        # timeout is in milliseconds\n        timeout = int(timeout * 1000)\n    pollster = select.poll()\n    if map:\n        for fd, obj in list(map.items()):\n            flags = 0\n            if obj.readable():\n                flags |= select.POLLIN | select.POLLPRI\n            # accepting sockets should not be writable\n            if obj.writable() and not obj.accepting:\n                flags |= select.POLLOUT\n            if flags:\n                pollster.register(fd, flags)\n\n        try:\n            r = pollster.poll(timeout)\n        except OSError as err:\n            if err.args[0] != EINTR:\n                raise\n            r = []\n\n        for fd, flags in r:\n            obj = map.get(fd)\n            if obj is None:  # pragma: no cover\n                continue\n            readwrite(obj, flags)\n\n\npoll3 = poll2  # Alias for backward compatibility\n\n\ndef loop(timeout=30.0, use_poll=False, map=None, count=None):\n    if map is None:  # pragma: no cover\n        map = socket_map\n\n    if use_poll and hasattr(select, \"poll\"):\n        poll_fun = poll2\n    else:\n        poll_fun = poll\n\n    if count is None:  # pragma: no cover\n        while map:\n            poll_fun(timeout, map)\n\n    else:\n        while map and count > 0:\n            poll_fun(timeout, map)\n            count = count - 1\n\n\ndef compact_traceback():\n    t, v, tb = sys.exc_info()\n    tbinfo = []\n    if not tb:  # pragma: no cover\n        raise AssertionError(\"traceback does not exist\")\n    while tb:\n        tbinfo.append(\n            (\n                tb.tb_frame.f_code.co_filename,\n                tb.tb_frame.f_code.co_name,\n                str(tb.tb_lineno),\n            )\n        )\n        tb = tb.tb_next\n\n    # just to be safe\n    del tb\n\n    file, function, line = tbinfo[-1]\n    info = \" \".join([\"[%s|%s|%s]\" % x for x in tbinfo])\n    return (file, function, line), t, v, info\n\n\nclass dispatcher:\n\n    debug = False\n    connected = False\n    accepting = False\n    connecting = False\n    closing = False\n    addr = None\n    ignore_log_types = frozenset({\"warning\"})\n    logger = utilities.logger\n    compact_traceback = staticmethod(compact_traceback)  # for testing\n\n    def __init__(self, sock=None, map=None):\n        if map is None:  # pragma: no cover\n            self._map = socket_map\n        else:\n            self._map = map\n\n        self._fileno = None\n\n        if sock:\n            # Set to nonblocking just to make sure for cases where we\n            # get a socket from a blocking source.\n            sock.setblocking(0)\n            self.set_socket(sock, map)\n            self.connected = True\n            # The constructor no longer requires that the socket\n            # passed be connected.\n            try:\n                self.addr = sock.getpeername()\n            except OSError as err:\n                if err.args[0] in (ENOTCONN, EINVAL):\n                    # To handle the case where we got an unconnected\n                    # socket.\n                    self.connected = False\n                else:\n                    # The socket is broken in some unknown way, alert\n                    # the user and remove it from the map (to prevent\n                    # polling of broken sockets).\n                    self.del_channel(map)\n                    raise\n        else:\n            self.socket = None\n\n    def __repr__(self):\n        status = [self.__class__.__module__ + \".\" + self.__class__.__qualname__]\n        if self.accepting and self.addr:\n            status.append(\"listening\")\n        elif self.connected:\n            status.append(\"connected\")\n        if self.addr is not None:\n            try:\n                status.append(\"%s:%d\" % self.addr)\n            except TypeError:  # pragma: no cover\n                status.append(repr(self.addr))\n        return \"<{} at {:#x}>\".format(\" \".join(status), id(self))\n\n    __str__ = __repr__\n\n    def add_channel(self, map=None):\n        # self.log_info('adding channel %s' % self)\n        if map is None:\n            map = self._map\n        map[self._fileno] = self\n\n    def del_channel(self, map=None):\n        fd = self._fileno\n        if map is None:\n            map = self._map\n        if fd in map:\n            # self.log_info('closing channel %d:%s' % (fd, self))\n            del map[fd]\n        self._fileno = None\n\n    def create_socket(self, family=socket.AF_INET, type=socket.SOCK_STREAM):\n        self.family_and_type = family, type\n        sock = socket.socket(family, type)\n        sock.setblocking(0)\n        self.set_socket(sock)\n\n    def set_socket(self, sock, map=None):\n        self.socket = sock\n        self._fileno = sock.fileno()\n        self.add_channel(map)\n\n    def set_reuse_addr(self):\n        # try to re-use a server port if possible\n        try:\n            self.socket.setsockopt(\n                socket.SOL_SOCKET,\n                socket.SO_REUSEADDR,\n                self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) | 1,\n            )\n        except OSError:\n            pass\n\n    # ==================================================\n    # predicates for select()\n    # these are used as filters for the lists of sockets\n    # to pass to select().\n    # ==================================================\n\n    def readable(self):\n        return True\n\n    def writable(self):\n        return True\n\n    # ==================================================\n    # socket object methods.\n    # ==================================================\n\n    def listen(self, num):\n        self.accepting = True\n        if os.name == \"nt\" and num > 5:  # pragma: no cover\n            num = 5\n        return self.socket.listen(num)\n\n    def bind(self, addr):\n        self.addr = addr\n        return self.socket.bind(addr)\n\n    def connect(self, address):\n        self.connected = False\n        self.connecting = True\n        err = self.socket.connect_ex(address)\n        if (\n            err in (EINPROGRESS, EALREADY, EWOULDBLOCK)\n            or err == EINVAL\n            and os.name == \"nt\"\n        ):  # pragma: no cover\n            self.addr = address\n            return\n        if err in (0, EISCONN):\n            self.addr = address\n            self.handle_connect_event()\n        else:\n            raise OSError(err, errorcode[err])\n\n    def accept(self):\n        # XXX can return either an address pair or None\n        try:\n            conn, addr = self.socket.accept()\n        except TypeError:\n            return None\n        except OSError as why:\n            if why.args[0] in (EWOULDBLOCK, ECONNABORTED, EAGAIN):\n                return None\n            else:\n                raise\n        else:\n            return conn, addr\n\n    def send(self, data, do_close=True):\n        try:\n            result = self.socket.send(data)\n            return result\n        except OSError as why:\n            if why.args[0] == EWOULDBLOCK:\n                return 0\n            elif why.args[0] in _DISCONNECTED:\n                if do_close:\n                    self.handle_close()\n                return 0\n            else:\n                raise\n\n    def recv(self, buffer_size):\n        try:\n            data = self.socket.recv(buffer_size)\n            if not data:\n                # a closed connection is indicated by signaling\n                # a read condition, and having recv() return 0.\n                self.handle_close()\n                return b\"\"\n            else:\n                return data\n        except OSError as why:\n            # winsock sometimes raises ENOTCONN\n            if why.args[0] in _DISCONNECTED:\n                self.handle_close()\n                return b\"\"\n            else:\n                raise\n\n    def close(self):\n        self.connected = False\n        self.accepting = False\n        self.connecting = False\n        self.del_channel()\n        if self.socket is not None:\n            try:\n                self.socket.close()\n            except OSError as why:\n                if why.args[0] not in (ENOTCONN, EBADF):\n                    raise\n\n    # log and log_info may be overridden to provide more sophisticated\n    # logging and warning methods. In general, log is for 'hit' logging\n    # and 'log_info' is for informational, warning and error logging.\n\n    def log(self, message):\n        self.logger.log(logging.DEBUG, message)\n\n    def log_info(self, message, type=\"info\"):\n        severity = {\n            \"info\": logging.INFO,\n            \"warning\": logging.WARN,\n            \"error\": logging.ERROR,\n        }\n        self.logger.log(severity.get(type, logging.INFO), message)\n\n    def handle_read_event(self):\n        if self.accepting:\n            # accepting sockets are never connected, they \"spawn\" new\n            # sockets that are connected\n            self.handle_accept()\n        elif not self.connected:\n            if self.connecting:\n                self.handle_connect_event()\n            self.handle_read()\n        else:\n            self.handle_read()\n\n    def handle_connect_event(self):\n        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n        if err != 0:\n            raise OSError(err, _strerror(err))\n        self.handle_connect()\n        self.connected = True\n        self.connecting = False\n\n    def handle_write_event(self):\n        if self.accepting:\n            # Accepting sockets shouldn't get a write event.\n            # We will pretend it didn't happen.\n            return\n\n        if not self.connected:\n            if self.connecting:\n                self.handle_connect_event()\n        self.handle_write()\n\n    def handle_expt_event(self):\n        # handle_expt_event() is called if there might be an error on the\n        # socket, or if there is OOB data\n        # check for the error condition first\n        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n        if err != 0:\n            # we can get here when select.select() says that there is an\n            # exceptional condition on the socket\n            # since there is an error, we'll go ahead and close the socket\n            # like we would in a subclassed handle_read() that received no\n            # data\n            self.handle_close()\n        else:\n            self.handle_expt()\n\n    def handle_error(self):\n        nil, t, v, tbinfo = self.compact_traceback()\n\n        # sometimes a user repr method will crash.\n        try:\n            self_repr = repr(self)\n        except:  # pragma: no cover\n            self_repr = \"<__repr__(self) failed for object at %0x>\" % id(self)\n\n        self.log_info(\n            \"uncaptured python exception, closing channel %s (%s:%s %s)\"\n            % (self_repr, t, v, tbinfo),\n            \"error\",\n        )\n        self.handle_close()\n\n    def handle_expt(self):\n        self.log_info(\"unhandled incoming priority event\", \"warning\")\n\n    def handle_read(self):\n        self.log_info(\"unhandled read event\", \"warning\")\n\n    def handle_write(self):\n        self.log_info(\"unhandled write event\", \"warning\")\n\n    def handle_connect(self):\n        self.log_info(\"unhandled connect event\", \"warning\")\n\n    def handle_accept(self):\n        pair = self.accept()\n        if pair is not None:\n            self.handle_accepted(*pair)\n\n    def handle_accepted(self, sock, addr):\n        sock.close()\n        self.log_info(\"unhandled accepted event\", \"warning\")\n\n    def handle_close(self):\n        self.log_info(\"unhandled close event\", \"warning\")\n        self.close()\n\n\n# ---------------------------------------------------------------------------\n# adds simple buffered output capability, useful for simple clients.\n# [for more sophisticated usage use asynchat.async_chat]\n# ---------------------------------------------------------------------------\n\n\nclass dispatcher_with_send(dispatcher):\n    def __init__(self, sock=None, map=None):\n        dispatcher.__init__(self, sock, map)\n        self.out_buffer = b\"\"\n\n    def initiate_send(self):\n        num_sent = 0\n        num_sent = dispatcher.send(self, self.out_buffer[:65536])\n        self.out_buffer = self.out_buffer[num_sent:]\n\n    handle_write = initiate_send\n\n    def writable(self):\n        return (not self.connected) or len(self.out_buffer)\n\n    def send(self, data):\n        if self.debug:  # pragma: no cover\n            self.log_info(\"sending %s\" % repr(data))\n        self.out_buffer = self.out_buffer + data\n        self.initiate_send()\n\n\ndef close_all(map=None, ignore_all=False):\n    if map is None:  # pragma: no cover\n        map = socket_map\n    for x in list(map.values()):  # list() FBO py3\n        try:\n            x.close()\n        except OSError as x:\n            if x.args[0] == EBADF:\n                pass\n            elif not ignore_all:\n                raise\n        except _reraised_exceptions:\n            raise\n        except:\n            if not ignore_all:\n                raise\n    map.clear()\n\n\n# Asynchronous File I/O:\n#\n# After a little research (reading man pages on various unixen, and\n# digging through the linux kernel), I've determined that select()\n# isn't meant for doing asynchronous file i/o.\n# Heartening, though - reading linux/mm/filemap.c shows that linux\n# supports asynchronous read-ahead.  So _MOST_ of the time, the data\n# will be sitting in memory for us already when we go to read it.\n#\n# What other OS's (besides NT) support async file i/o?  [VMS?]\n#\n# Regardless, this is useful for pipes, and stdin/stdout...\n\nif os.name == \"posix\":\n\n    class file_wrapper:\n        # Here we override just enough to make a file\n        # look like a socket for the purposes of asyncore.\n        # The passed fd is automatically os.dup()'d\n\n        def __init__(self, fd):\n            self.fd = os.dup(fd)\n\n        def __del__(self):\n            if self.fd >= 0:\n                warnings.warn(\"unclosed file %r\" % self, ResourceWarning)\n            self.close()\n\n        def recv(self, *args):\n            return os.read(self.fd, *args)\n\n        def send(self, *args):\n            return os.write(self.fd, *args)\n\n        def getsockopt(self, level, optname, buflen=None):  # pragma: no cover\n            if level == socket.SOL_SOCKET and optname == socket.SO_ERROR and not buflen:\n                return 0\n            raise NotImplementedError(\n                \"Only asyncore specific behaviour \" \"implemented.\"\n            )\n\n        read = recv\n        write = send\n\n        def close(self):\n            if self.fd < 0:\n                return\n            fd = self.fd\n            self.fd = -1\n            os.close(fd)\n\n        def fileno(self):\n            return self.fd\n\n    class file_dispatcher(dispatcher):\n        def __init__(self, fd, map=None):\n            dispatcher.__init__(self, None, map)\n            self.connected = True\n            try:\n                fd = fd.fileno()\n            except AttributeError:\n                pass\n            self.set_file(fd)\n            # set it to non-blocking mode\n            os.set_blocking(fd, False)\n\n        def set_file(self, fd):\n            self.socket = file_wrapper(fd)\n            self._fileno = self.socket.fileno()\n            self.add_channel()\n", "import io\nimport unittest\n\nimport pytest\n\n\nclass TestHTTPChannel(unittest.TestCase):\n    def _makeOne(self, sock, addr, adj, map=None):\n        from waitress.channel import HTTPChannel\n\n        server = DummyServer()\n        return HTTPChannel(server, sock, addr, adj=adj, map=map)\n\n    def _makeOneWithMap(self, adj=None):\n        if adj is None:\n            adj = DummyAdjustments()\n        sock = DummySock()\n        map = {}\n        inst = self._makeOne(sock, \"127.0.0.1\", adj, map=map)\n        inst.outbuf_lock = DummyLock()\n        return inst, sock, map\n\n    def test_ctor(self):\n        inst, _, map = self._makeOneWithMap()\n        self.assertEqual(inst.addr, \"127.0.0.1\")\n        self.assertEqual(inst.sendbuf_len, 2048)\n        self.assertEqual(map[100], inst)\n\n    def test_total_outbufs_len_an_outbuf_size_gt_sys_maxint(self):\n        from waitress.compat import MAXINT\n\n        inst, _, map = self._makeOneWithMap()\n\n        class DummyBuffer:\n            chunks = []\n\n            def append(self, data):\n                self.chunks.append(data)\n\n        class DummyData:\n            def __len__(self):\n                return MAXINT\n\n        inst.total_outbufs_len = 1\n        inst.outbufs = [DummyBuffer()]\n        inst.write_soon(DummyData())\n        # we are testing that this method does not raise an OverflowError\n        # (see https://github.com/Pylons/waitress/issues/47)\n        self.assertEqual(inst.total_outbufs_len, MAXINT + 1)\n\n    def test_writable_something_in_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.total_outbufs_len = 3\n        self.assertTrue(inst.writable())\n\n    def test_writable_nothing_in_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        self.assertFalse(inst.writable())\n\n    def test_writable_nothing_in_outbuf_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = True\n        self.assertTrue(inst.writable())\n\n    def test_handle_write_not_connected(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.connected = False\n        self.assertFalse(inst.handle_write())\n\n    def test_handle_write_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n\n    def test_handle_write_no_request_with_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertNotEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_outbuf_raises_socketerror(self):\n        import socket\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"abc\", socket.error)\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_outbuf_raises_othererror(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"abc\", IOError)\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_no_requests_no_outbuf_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        outbuf = DummyBuffer(b\"\")\n        inst.outbufs = [outbuf]\n        inst.will_close = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertTrue(outbuf.closed)\n\n    def test_handle_write_no_requests_outbuf_gt_send_bytes(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 2\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_close_when_flushed(self):\n        inst, sock, map = self._makeOneWithMap()\n        outbuf = DummyBuffer(b\"abc\")\n        inst.outbufs = [outbuf]\n        inst.total_outbufs_len = len(outbuf)\n        inst.will_close = False\n        inst.close_when_flushed = True\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, True)\n        self.assertEqual(inst.close_when_flushed, False)\n        self.assertEqual(sock.sent, b\"abc\")\n        self.assertTrue(outbuf.closed)\n\n    def test_readable_no_requests_not_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.will_close = False\n        self.assertEqual(inst.readable(), True)\n\n    def test_readable_no_requests_will_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = []\n        inst.will_close = True\n        self.assertEqual(inst.readable(), False)\n\n    def test_readable_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        self.assertEqual(inst.readable(), False)\n\n    def test_handle_read_no_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = False\n        inst.recv = lambda *arg: b\"abc\"\n        inst.last_activity = 0\n        L = []\n        inst.received = lambda x: L.append(x)\n        result = inst.handle_read()\n        self.assertEqual(result, None)\n        self.assertNotEqual(inst.last_activity, 0)\n        self.assertEqual(L, [b\"abc\"])\n\n    def test_handle_read_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.will_close = False\n\n        def recv(b):\n            raise OSError\n\n        inst.recv = recv\n        inst.last_activity = 0\n        inst.logger = DummyLogger()\n        result = inst.handle_read()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.last_activity, 0)\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test_write_soon_empty_byte(self):\n        inst, sock, map = self._makeOneWithMap()\n        wrote = inst.write_soon(b\"\")\n        self.assertEqual(wrote, 0)\n        self.assertEqual(len(inst.outbufs[0]), 0)\n\n    def test_write_soon_nonempty_byte(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush\n        def send(_):\n            return 0\n\n        sock.send = send\n\n        wrote = inst.write_soon(b\"a\")\n        self.assertEqual(wrote, 1)\n        self.assertEqual(len(inst.outbufs[0]), 1)\n\n    def test_write_soon_filewrapper(self):\n        from waitress.buffers import ReadOnlyFileBasedBuffer\n\n        f = io.BytesIO(b\"abc\")\n        wrapper = ReadOnlyFileBasedBuffer(f, 8192)\n        wrapper.prepare()\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush\n        def send(_):\n            return 0\n\n        sock.send = send\n\n        outbufs = inst.outbufs\n        wrote = inst.write_soon(wrapper)\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(outbufs), 2)\n        self.assertEqual(outbufs[0], wrapper)\n        self.assertEqual(outbufs[1].__class__.__name__, \"OverflowableBuffer\")\n\n    def test_write_soon_disconnected(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.connected = False\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"stuff\"))\n\n    def test_write_soon_disconnected_while_over_watermark(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n\n        def dummy_flush():\n            inst.connected = False\n\n        inst._flush_outbufs_below_high_watermark = dummy_flush\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"stuff\"))\n\n    def test_write_soon_rotates_outbuf_on_overflow(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush\n        def send(_):\n            return 0\n\n        sock.send = send\n\n        inst.adj.outbuf_high_watermark = 3\n        inst.current_outbuf_count = 4\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(inst.outbufs), 1)\n        self.assertEqual(inst.outbufs[0].get(), b\"xyz\")\n\n    def test_write_soon_waits_on_backpressure(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush\n        def send(_):\n            return 0\n\n        sock.send = send\n\n        inst.adj.outbuf_high_watermark = 3\n        inst.total_outbufs_len = 4\n        inst.current_outbuf_count = 4\n\n        class Lock(DummyLock):\n            def wait(self):\n                inst.total_outbufs_len = 0\n                super().wait()\n\n        inst.outbuf_lock = Lock()\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        self.assertEqual(len(inst.outbufs), 1)\n        self.assertEqual(inst.outbufs[0].get(), b\"xyz\")\n        self.assertTrue(inst.outbuf_lock.waited)\n\n    def test_write_soon_attempts_flush_high_water_and_exception(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush, it will raise Exception, which\n        # disconnects the remote end\n        def send(_):\n            inst.connected = False\n            raise Exception()\n\n        sock.send = send\n\n        inst.adj.outbuf_high_watermark = 3\n        inst.total_outbufs_len = 4\n        inst.current_outbuf_count = 4\n\n        inst.outbufs[0].append(b\"test\")\n\n        class Lock(DummyLock):\n            def wait(self):\n                inst.total_outbufs_len = 0\n                super().wait()\n\n        inst.outbuf_lock = Lock()\n        self.assertRaises(ClientDisconnected, lambda: inst.write_soon(b\"xyz\"))\n\n        # Validate we woke up the main thread to deal with the exception of\n        # trying to send\n        self.assertTrue(inst.outbuf_lock.waited)\n        self.assertTrue(inst.server.trigger_pulled)\n\n    def test_write_soon_flush_and_exception(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        # _flush_some will no longer flush, it will raise Exception, which\n        # disconnects the remote end\n        def send(_):\n            inst.connected = False\n            raise Exception()\n\n        sock.send = send\n\n        wrote = inst.write_soon(b\"xyz\")\n        self.assertEqual(wrote, 3)\n        # Validate we woke up the main thread to deal with the exception of\n        # trying to send\n        self.assertTrue(inst.server.trigger_pulled)\n\n    def test_handle_write_notify_after_flush(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 1\n        inst.adj.outbuf_high_watermark = 5\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertTrue(inst.outbuf_lock.notified)\n        self.assertEqual(sock.sent, b\"abc\")\n\n    def test_handle_write_no_notify_after_flush(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [True]\n        inst.outbufs = [DummyBuffer(b\"abc\")]\n        inst.total_outbufs_len = len(inst.outbufs[0])\n        inst.adj.send_bytes = 1\n        inst.adj.outbuf_high_watermark = 2\n        sock.send = lambda x, do_close=True: False\n        inst.will_close = False\n        inst.last_activity = 0\n        result = inst.handle_write()\n        self.assertEqual(result, None)\n        self.assertEqual(inst.will_close, False)\n        self.assertTrue(inst.outbuf_lock.acquired)\n        self.assertFalse(inst.outbuf_lock.notified)\n        self.assertEqual(sock.sent, b\"\")\n\n    def test__flush_some_empty_outbuf(self):\n        inst, sock, map = self._makeOneWithMap()\n        result = inst._flush_some()\n        self.assertEqual(result, False)\n\n    def test__flush_some_full_outbuf_socket_returns_nonzero(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.outbufs[0].append(b\"abc\")\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n\n    def test__flush_some_full_outbuf_socket_returns_zero(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: False\n        inst.outbufs[0].append(b\"abc\")\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, False)\n\n    def test_flush_some_multiple_buffers_first_empty(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: len(x)\n        buffer = DummyBuffer(b\"abc\")\n        inst.outbufs.append(buffer)\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n        self.assertEqual(buffer.skipped, 3)\n        self.assertEqual(inst.outbufs, [buffer])\n\n    def test_flush_some_multiple_buffers_close_raises(self):\n        inst, sock, map = self._makeOneWithMap()\n        sock.send = lambda x: len(x)\n        buffer = DummyBuffer(b\"abc\")\n        inst.outbufs.append(buffer)\n        inst.total_outbufs_len = sum(len(x) for x in inst.outbufs)\n        inst.logger = DummyLogger()\n\n        def doraise():\n            raise NotImplementedError\n\n        inst.outbufs[0].close = doraise\n        result = inst._flush_some()\n        self.assertEqual(result, True)\n        self.assertEqual(buffer.skipped, 3)\n        self.assertEqual(inst.outbufs, [buffer])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test__flush_some_outbuf_len_gt_sys_maxint(self):\n        from waitress.compat import MAXINT\n\n        inst, sock, map = self._makeOneWithMap()\n\n        class DummyHugeOutbuffer:\n            def __init__(self):\n                self.length = MAXINT + 1\n\n            def __len__(self):\n                return self.length\n\n            def get(self, numbytes):\n                self.length = 0\n                return b\"123\"\n\n        buf = DummyHugeOutbuffer()\n        inst.outbufs = [buf]\n        inst.send = lambda *arg, do_close: 0\n        result = inst._flush_some()\n        # we are testing that _flush_some doesn't raise an OverflowError\n        # when one of its outbufs has a __len__ that returns gt sys.maxint\n        self.assertEqual(result, False)\n\n    def test_handle_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.handle_close()\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n\n    def test_handle_close_outbuf_raises_on_close(self):\n        inst, sock, map = self._makeOneWithMap()\n\n        def doraise():\n            raise NotImplementedError\n\n        inst.outbufs[0].close = doraise\n        inst.logger = DummyLogger()\n        inst.handle_close()\n        self.assertEqual(inst.connected, False)\n        self.assertEqual(sock.closed, True)\n        self.assertEqual(len(inst.logger.exceptions), 1)\n\n    def test_add_channel(self):\n        inst, sock, map = self._makeOneWithMap()\n        fileno = inst._fileno\n        inst.add_channel(map)\n        self.assertEqual(map[fileno], inst)\n        self.assertEqual(inst.server.active_channels[fileno], inst)\n\n    def test_del_channel(self):\n        inst, sock, map = self._makeOneWithMap()\n        fileno = inst._fileno\n        inst.server.active_channels[fileno] = True\n        inst.del_channel(map)\n        self.assertEqual(map.get(fileno), None)\n        self.assertEqual(inst.server.active_channels.get(fileno), None)\n\n    def test_received(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.server.tasks, [inst])\n        self.assertTrue(inst.requests)\n\n    def test_received_no_chunk(self):\n        inst, sock, map = self._makeOneWithMap()\n        self.assertEqual(inst.received(b\"\"), False)\n\n    def test_received_preq_not_completed(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = False\n        preq.empty = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_completed_empty(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, None)\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_preq_error(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.error = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, None)\n        self.assertEqual(len(inst.server.tasks), 1)\n        self.assertTrue(inst.requests)\n\n    def test_received_preq_completed_connection_close(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.completed = True\n        preq.empty = True\n        preq.connection_close = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\" + b\"a\" * 50000)\n        self.assertEqual(inst.request, None)\n        self.assertEqual(inst.server.tasks, [])\n\n    def test_received_headers_finished_expect_continue_false(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = False\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        preq.retval = 1\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(inst.outbufs[0].get(100), b\"\")\n\n    def test_received_headers_finished_expect_continue_true(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = True\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(sock.sent, b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n        self.assertEqual(inst.sent_continue, True)\n        self.assertEqual(preq.completed, False)\n\n    def test_received_headers_finished_expect_continue_true_sent_true(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.server = DummyServer()\n        preq = DummyParser()\n        inst.request = preq\n        preq.expect_continue = True\n        preq.headers_finished = True\n        preq.completed = False\n        preq.empty = False\n        inst.sent_continue = True\n        inst.received(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        self.assertEqual(inst.request, preq)\n        self.assertEqual(inst.server.tasks, [])\n        self.assertEqual(sock.sent, b\"\")\n        self.assertEqual(inst.sent_continue, True)\n        self.assertEqual(preq.completed, False)\n\n    def test_service_with_one_request(self):\n        inst, sock, map = self._makeOneWithMap()\n        request = DummyRequest()\n        inst.task_class = DummyTaskClass()\n        inst.requests = [request]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request.serviced)\n        self.assertTrue(request.closed)\n\n    def test_service_with_one_error_request(self):\n        inst, sock, map = self._makeOneWithMap()\n        request = DummyRequest()\n        request.error = DummyError()\n        inst.error_task_class = DummyTaskClass()\n        inst.requests = [request]\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request.serviced)\n        self.assertTrue(request.closed)\n\n    def test_service_with_multiple_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        request1 = DummyRequest()\n        request2 = DummyRequest()\n        inst.task_class = DummyTaskClass()\n        inst.requests = [request1, request2]\n        inst.service()\n        inst.service()\n        self.assertEqual(inst.requests, [])\n        self.assertTrue(request1.serviced)\n        self.assertTrue(request2.serviced)\n        self.assertTrue(request1.closed)\n        self.assertTrue(request2.closed)\n\n    def test_service_with_request_raises(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_already_wrote_header(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertTrue(inst.close_when_flushed)\n        self.assertEqual(inst.error_task_class.serviced, False)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_didnt_write_header_expose_tbs(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = True\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_service_with_requests_raises_didnt_write_header(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ValueError)\n        inst.task_class.wrote_header = False\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertTrue(inst.close_when_flushed)\n        self.assertTrue(request.closed)\n\n    def test_service_with_request_raises_disconnect(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        inst.requests = [request]\n        inst.task_class = DummyTaskClass(ClientDisconnected)\n        inst.error_task_class = DummyTaskClass()\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.infos), 1)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.error_task_class.serviced, False)\n        self.assertTrue(request.closed)\n\n    def test_service_with_request_error_raises_disconnect(self):\n        from waitress.channel import ClientDisconnected\n\n        inst, sock, map = self._makeOneWithMap()\n        inst.adj.expose_tracebacks = False\n        inst.server = DummyServer()\n        request = DummyRequest()\n        err_request = DummyRequest()\n        inst.requests = [request]\n        inst.parser_class = lambda x: err_request\n        inst.task_class = DummyTaskClass(RuntimeError)\n        inst.task_class.wrote_header = False\n        inst.error_task_class = DummyTaskClass(ClientDisconnected)\n        inst.logger = DummyLogger()\n        inst.service()\n        self.assertTrue(request.serviced)\n        self.assertTrue(err_request.serviced)\n        self.assertEqual(inst.requests, [])\n        self.assertEqual(len(inst.logger.exceptions), 1)\n        self.assertEqual(len(inst.logger.infos), 0)\n        self.assertTrue(inst.server.trigger_pulled)\n        self.assertTrue(inst.last_activity)\n        self.assertFalse(inst.will_close)\n        self.assertEqual(inst.task_class.serviced, True)\n        self.assertEqual(inst.error_task_class.serviced, True)\n        self.assertTrue(request.closed)\n\n    def test_cancel_no_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = ()\n        inst.cancel()\n        self.assertEqual(inst.requests, [])\n\n    def test_cancel_with_requests(self):\n        inst, sock, map = self._makeOneWithMap()\n        inst.requests = [None]\n        inst.cancel()\n        self.assertEqual(inst.requests, [])\n\n\nclass TestHTTPChannelLookahead(TestHTTPChannel):\n    def app_check_disconnect(self, environ, start_response):\n        \"\"\"\n        Application that checks for client disconnection every\n        second for up to two seconds.\n        \"\"\"\n        import time\n\n        if hasattr(self, \"app_started\"):\n            self.app_started.set()\n\n        try:\n            request_body_size = int(environ.get(\"CONTENT_LENGTH\", 0))\n        except ValueError:\n            request_body_size = 0\n        self.request_body = environ[\"wsgi.input\"].read(request_body_size)\n\n        self.disconnect_detected = False\n        check = environ[\"waitress.client_disconnected\"]\n        if environ[\"PATH_INFO\"] == \"/sleep\":\n            for i in range(3):\n                if i != 0:\n                    time.sleep(1)\n                if check():\n                    self.disconnect_detected = True\n                    break\n\n        body = b\"finished\"\n        cl = str(len(body))\n        start_response(\n            \"200 OK\", [(\"Content-Length\", cl), (\"Content-Type\", \"text/plain\")]\n        )\n        return [body]\n\n    def _make_app_with_lookahead(self):\n        \"\"\"\n        Setup a channel with lookahead and store it and the socket in self\n        \"\"\"\n        adj = DummyAdjustments()\n        adj.channel_request_lookahead = 5\n        channel, sock, map = self._makeOneWithMap(adj=adj)\n        channel.server.application = self.app_check_disconnect\n\n        self.channel = channel\n        self.sock = sock\n\n    def _send(self, *lines):\n        \"\"\"\n        Send lines through the socket with correct line endings\n        \"\"\"\n        self.sock.send(\"\".join(line + \"\\r\\n\" for line in lines).encode(\"ascii\"))\n\n    def test_client_disconnect(self, close_before_start=False):\n        \"\"\"Disconnect the socket after starting the task.\"\"\"\n        import threading\n\n        self._make_app_with_lookahead()\n        self._send(\n            \"GET /sleep HTTP/1.1\",\n            \"Host: localhost:8080\",\n            \"\",\n        )\n        self.assertTrue(self.channel.readable())\n        self.channel.handle_read()\n        self.assertEqual(len(self.channel.server.tasks), 1)\n        self.app_started = threading.Event()\n        self.disconnect_detected = False\n        thread = threading.Thread(target=self.channel.server.tasks[0].service)\n\n        if not close_before_start:\n            thread.start()\n            self.assertTrue(self.app_started.wait(timeout=5))\n\n        # Close the socket, check that the channel is still readable due to the\n        # lookahead and read it, which marks the channel as closed.\n        self.sock.close()\n        self.assertTrue(self.channel.readable())\n        self.channel.handle_read()\n\n        if close_before_start:\n            thread.start()\n\n        thread.join()\n\n        if close_before_start:\n            self.assertFalse(self.app_started.is_set())\n        else:\n            self.assertTrue(self.disconnect_detected)\n\n    def test_client_disconnect_immediate(self):\n        \"\"\"\n        The same test, but this time we close the socket even before processing\n        started. The app should not be executed.\n        \"\"\"\n        self.test_client_disconnect(close_before_start=True)\n\n    def test_lookahead_continue(self):\n        \"\"\"\n        Send two requests to a channel with lookahead and use an\n        expect-continue on the second one, making sure the responses still come\n        in the right order.\n        \"\"\"\n        self._make_app_with_lookahead()\n        self._send(\n            \"POST / HTTP/1.1\",\n            \"Host: localhost:8080\",\n            \"Content-Length: 1\",\n            \"\",\n            \"x\",\n            \"POST / HTTP/1.1\",\n            \"Host: localhost:8080\",\n            \"Content-Length: 1\",\n            \"Expect: 100-continue\",\n            \"\",\n        )\n        self.channel.handle_read()\n        self.assertEqual(len(self.channel.requests), 1)\n        self.channel.server.tasks[0].service()\n        data = self.sock.recv(256).decode(\"ascii\")\n        self.assertTrue(data.endswith(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"))\n\n        self.sock.send(b\"x\")\n        self.channel.handle_read()\n        self.assertEqual(len(self.channel.requests), 1)\n        self.channel.server.tasks[0].service()\n        self.channel._flush_some()\n        data = self.sock.recv(256).decode(\"ascii\")\n        self.assertEqual(data.split(\"\\r\\n\")[-1], \"finished\")\n        self.assertEqual(self.request_body, b\"x\")\n\n\nclass DummySock:\n    blocking = False\n    closed = False\n\n    def __init__(self):\n        self.sent = b\"\"\n\n    def setblocking(self, *arg):\n        self.blocking = True\n\n    def fileno(self):\n        return 100\n\n    def getpeername(self):\n        return \"127.0.0.1\"\n\n    def getsockopt(self, level, option):\n        return 2048\n\n    def close(self):\n        self.closed = True\n\n    def send(self, data):\n        self.sent += data\n        return len(data)\n\n    def recv(self, buffer_size):\n        result = self.sent[:buffer_size]\n        self.sent = self.sent[buffer_size:]\n        return result\n\n\nclass DummyLock:\n    notified = False\n\n    def __init__(self, acquirable=True):\n        self.acquirable = acquirable\n\n    def acquire(self, val):\n        self.val = val\n        self.acquired = True\n        return self.acquirable\n\n    def release(self):\n        self.released = True\n\n    def notify(self):\n        self.notified = True\n\n    def wait(self):\n        self.waited = True\n\n    def __exit__(self, type, val, traceback):\n        self.acquire(True)\n\n    def __enter__(self):\n        pass\n\n\nclass DummyBuffer:\n    closed = False\n\n    def __init__(self, data, toraise=None):\n        self.data = data\n        self.toraise = toraise\n\n    def get(self, *arg):\n        if self.toraise:\n            raise self.toraise\n        data = self.data\n        self.data = b\"\"\n        return data\n\n    def skip(self, num, x):\n        self.skipped = num\n\n    def __len__(self):\n        return len(self.data)\n\n    def close(self):\n        self.closed = True\n\n\nclass DummyAdjustments:\n    outbuf_overflow = 1048576\n    outbuf_high_watermark = 1048576\n    inbuf_overflow = 512000\n    cleanup_interval = 900\n    url_scheme = \"http\"\n    channel_timeout = 300\n    log_socket_errors = True\n    recv_bytes = 8192\n    send_bytes = 1\n    expose_tracebacks = True\n    ident = \"waitress\"\n    max_request_header_size = 10000\n    url_prefix = \"\"\n    channel_request_lookahead = 0\n    max_request_body_size = 1048576\n\n\nclass DummyServer:\n    trigger_pulled = False\n    adj = DummyAdjustments()\n    effective_port = 8080\n    server_name = \"\"\n\n    def __init__(self):\n        self.tasks = []\n        self.active_channels = {}\n\n    def add_task(self, task):\n        self.tasks.append(task)\n\n    def pull_trigger(self):\n        self.trigger_pulled = True\n\n\nclass DummyParser:\n    version = 1\n    data = None\n    completed = True\n    empty = False\n    headers_finished = False\n    expect_continue = False\n    retval = None\n    error = None\n    connection_close = False\n\n    def received(self, data):\n        self.data = data\n        if self.retval is not None:\n            return self.retval\n        return len(data)\n\n\nclass DummyRequest:\n    error = None\n    path = \"/\"\n    version = \"1.0\"\n    closed = False\n\n    def __init__(self):\n        self.headers = {}\n\n    def close(self):\n        self.closed = True\n\n\nclass DummyLogger:\n    def __init__(self):\n        self.exceptions = []\n        self.infos = []\n        self.warnings = []\n\n    def info(self, msg):\n        self.infos.append(msg)\n\n    def exception(self, msg):\n        self.exceptions.append(msg)\n\n\nclass DummyError:\n    code = \"431\"\n    reason = \"Bleh\"\n    body = \"My body\"\n\n\nclass DummyTaskClass:\n    wrote_header = True\n    close_on_finish = False\n    serviced = False\n\n    def __init__(self, toraise=None):\n        self.toraise = toraise\n\n    def __call__(self, channel, request):\n        self.request = request\n        return self\n\n    def service(self):\n        self.serviced = True\n        self.request.serviced = True\n        if self.toraise:\n            raise self.toraise\n"], "filenames": ["src/waitress/channel.py", "src/waitress/wasyncore.py", "tests/test_channel.py"], "buggy_code_start_loc": [129, 429, 379], "buggy_code_end_loc": [396, 438, 457], "fixing_code_start_loc": [129, 429, 379], "fixing_code_end_loc": [398, 439, 457], "type": "CWE-248", "message": "Waitress is a Web Server Gateway Interface server for Python 2 and 3. Waitress versions 2.1.0 and 2.1.1 may terminate early due to a thread closing a socket while the main thread is about to call select(). This will lead to the main thread raising an exception that is not handled and then causing the entire application to be killed. This issue has been fixed in Waitress 2.1.2 by no longer allowing the WSGI thread to close the socket. Instead, that is always delegated to the main thread. There is no work-around for this issue. However, users using waitress behind a reverse proxy server are less likely to have issues if the reverse proxy always reads the full response.", "other": {"cve": {"id": "CVE-2022-31015", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-31T23:15:07.960", "lastModified": "2022-06-14T19:12:08.833", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Waitress is a Web Server Gateway Interface server for Python 2 and 3. Waitress versions 2.1.0 and 2.1.1 may terminate early due to a thread closing a socket while the main thread is about to call select(). This will lead to the main thread raising an exception that is not handled and then causing the entire application to be killed. This issue has been fixed in Waitress 2.1.2 by no longer allowing the WSGI thread to close the socket. Instead, that is always delegated to the main thread. There is no work-around for this issue. However, users using waitress behind a reverse proxy server are less likely to have issues if the reverse proxy always reads the full response."}, {"lang": "es", "value": "Waitress es un servidor de Interfaz de Pasarela del Servidor Web para Python versiones 2 y 3. Las versiones 2.1.0 y 2.1.1 de Waitress pueden terminar antes de tiempo debido a que un hilo cierra un socket mientras el hilo principal est\u00e1 a punto de llamar a select(). Esto conllevaba a que el hilo principal lanzara una excepci\u00f3n que no es manejada y que causaba la muerte de toda la aplicaci\u00f3n. Este problema ha sido corregido en Waitress versi\u00f3n 2.1.2, al no permitir que el hilo WSGI cierre el socket. En su lugar, esto es delegado siempre en el hilo principal. No se presenta ninguna mitigaci\u00f3n para este problema. Sin embargo, los usuarios usando waitress detr\u00e1s de un servidor proxy inverso presentan menos probabilidades de tener problemas si el proxy inverso siempre lee la respuesta completa"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-248"}, {"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:agendaless:waitress:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.1.2", "matchCriteriaId": "28ACA413-8CCD-46B0-A6E3-FEE97B303242"}]}]}], "references": [{"url": "https://github.com/Pylons/waitress/commit/4f6789b035610e0552738cdc4b35ca809a592d48", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Pylons/waitress/issues/374", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Pylons/waitress/pull/377", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Pylons/waitress/security/advisories/GHSA-f5x9-8jwc-25rw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Pylons/waitress/commit/4f6789b035610e0552738cdc4b35ca809a592d48"}}