{"buggy_code": ["class Ticket::ArticlePolicy < ApplicationPolicy\n\n  def show?\n    access?(__method__)\n  end\n\n  def create?\n    access?(__method__)\n  end\n\n  def update?\n    return false if !access?(__method__)\n    return true if user.permissions?(['ticket.agent', 'admin'])\n\n    not_authorized('ticket.agent or admin permission required')\n  end\n\n  def destroy?\n    return false if !access?('show?')\n\n    # agents can destroy articles of type 'note'\n    # which were created by themselves within the last x minutes\n\n    if !user.permissions?('ticket.agent')\n      return not_authorized('agent permission required')\n    end\n\n    if record.created_by_id != user.id\n      return not_authorized('you can only delete your own notes')\n    end\n\n    if record.type.communication?\n      return not_authorized('communication articles cannot be deleted')\n    end\n\n    if deletable_timeframe? && record.created_at <= deletable_timeframe.ago\n      return not_authorized('note is too old to be deleted')\n    end\n\n    true\n  end\n\n  private\n\n  def deletable_timeframe_setting\n    Setting.get('ui_ticket_zoom_article_delete_timeframe')\n  end\n\n  def deletable_timeframe?\n    deletable_timeframe_setting&.positive?\n  end\n\n  def deletable_timeframe\n    deletable_timeframe_setting.seconds\n  end\n\n  def access?(query)\n    return false if record.internal == true && !user.permissions?('ticket.agent')\n\n    ticket = Ticket.lookup(id: record.ticket_id)\n    Pundit.authorize(user, ticket, query)\n  end\nend\n", "class TicketPolicy < ApplicationPolicy\n\n  def show?\n    access?('read')\n  end\n\n  def create?\n    ensure_group!\n    access?('create')\n  end\n\n  def update?\n    access?('change')\n  end\n\n  def destroy?\n    return true if user.permissions?('admin')\n\n    # This might look like a bug is actually just defining\n    # what exception is being raised and shown to the user.\n    return false if !access?('delete')\n\n    not_authorized('admin permission required')\n  end\n\n  def full?\n    access?('full')\n  end\n\n  def ensure_group!\n    return if record.group_id\n\n    raise Exceptions::UnprocessableEntity, \"Group can't be blank\"\n  end\n\n  def follow_up?\n    return true if user.permissions?('ticket.agent') # agents can always reopen tickets, regardless of group configuration\n    return true if record.group.follow_up_possible != 'new_ticket' # check if the setting for follow_up_possible is disabled\n    return true if record.state.name != 'closed' # check if the ticket state is already closed\n\n    raise Exceptions::UnprocessableEntity, 'Cannot follow-up on a closed ticket. Please create a new ticket.'\n  end\n\n  private\n\n  def access?(access)\n    return true if agent_access?(access)\n\n    customer_access?\n  end\n\n  def agent_access?(access)\n    return false if !user.permissions?('ticket.agent')\n    return true if owner?\n\n    user.group_access?(record.group.id, access)\n  end\n\n  def owner?\n    record.owner_id == user.id\n  end\n\n  def customer_access?\n    return false if !user.permissions?('ticket.customer')\n    return true if customer?\n\n    shared_organization?\n  end\n\n  def customer?\n    record.customer_id == user.id\n  end\n\n  def shared_organization?\n    return false if record.organization_id.blank?\n    return false if user.organization_id.blank?\n    return false if record.organization_id != user.organization_id\n\n    record.organization.shared?\n  end\nend\n", "FactoryBot.define do\n  factory :role do\n    sequence(:name) { |n| \"TestRole#{n}\" }\n    created_by_id   { 1 }\n    updated_by_id   { 1 }\n\n    factory :agent_role do\n      permissions { Permission.where(name: 'ticket.agent') }\n    end\n\n    trait :admin do\n      permissions { Permission.where(name: 'admin') }\n    end\n  end\nend\n", "require 'rails_helper'\n\ndescribe Ticket::ArticlePolicy do\n  subject { described_class.new(user, record) }\n\n  let!(:group) { create(:group) }\n  let!(:ticket_customer) { create(:customer) }\n\n  let(:record) do\n    ticket = create(:ticket, group: group, customer: ticket_customer)\n    create(:ticket_article, ticket: ticket)\n  end\n\n  context 'when article internal' do\n    let(:record) do\n      ticket = create(:ticket, group: group, customer: ticket_customer)\n      create(:ticket_article, ticket: ticket, internal: true)\n    end\n\n    context 'when agent' do\n      let(:user) { create(:agent, groups: [group]) }\n\n      it { is_expected.to permit_actions(%i[show]) }\n    end\n\n    context 'when agent and customer' do\n      let(:user) { create(:agent_and_customer, groups: [group]) }\n\n      it { is_expected.to permit_actions(%i[show]) }\n    end\n\n    context 'when customer' do\n      let(:user) { ticket_customer }\n\n      it { is_expected.not_to permit_actions(%i[show]) }\n    end\n  end\n\n  context 'when agent' do\n    let(:user) { create(:agent, groups: [group]) }\n\n    it { is_expected.to permit_actions(%i[show]) }\n  end\n\n  context 'when agent and customer' do\n    let(:user) { create(:agent_and_customer, groups: [group]) }\n\n    it { is_expected.to permit_actions(%i[show]) }\n  end\n\n  context 'when customer' do\n    let(:user) { ticket_customer }\n\n    it { is_expected.to permit_actions(%i[show]) }\n  end\n\nend\n"], "fixing_code": ["class Ticket::ArticlePolicy < ApplicationPolicy\n\n  def show?\n    access?(__method__)\n  end\n\n  def create?\n    access?(__method__)\n  end\n\n  def update?\n    return false if !access?(__method__)\n    return true if user.permissions?(['ticket.agent', 'admin'])\n\n    not_authorized('ticket.agent or admin permission required')\n  end\n\n  def destroy?\n    return false if !access?('show?')\n\n    # agents can destroy articles of type 'note'\n    # which were created by themselves within the last x minutes\n\n    if !user.permissions?('ticket.agent')\n      return not_authorized('agent permission required')\n    end\n\n    if record.created_by_id != user.id\n      return not_authorized('you can only delete your own notes')\n    end\n\n    if record.type.communication?\n      return not_authorized('communication articles cannot be deleted')\n    end\n\n    if deletable_timeframe? && record.created_at <= deletable_timeframe.ago\n      return not_authorized('note is too old to be deleted')\n    end\n\n    true\n  end\n\n  private\n\n  def deletable_timeframe_setting\n    Setting.get('ui_ticket_zoom_article_delete_timeframe')\n  end\n\n  def deletable_timeframe?\n    deletable_timeframe_setting&.positive?\n  end\n\n  def deletable_timeframe\n    deletable_timeframe_setting.seconds\n  end\n\n  def access?(query)\n    ticket = Ticket.lookup(id: record.ticket_id)\n    return false if record.internal == true && !TicketPolicy.new(user, ticket).agent_read_access?\n\n    Pundit.authorize(user, ticket, query)\n  end\nend\n", "class TicketPolicy < ApplicationPolicy\n\n  def show?\n    access?('read')\n  end\n\n  def create?\n    ensure_group!\n    access?('create')\n  end\n\n  def update?\n    access?('change')\n  end\n\n  def destroy?\n    return true if user.permissions?('admin')\n\n    # This might look like a bug is actually just defining\n    # what exception is being raised and shown to the user.\n    return false if !access?('delete')\n\n    not_authorized('admin permission required')\n  end\n\n  def full?\n    access?('full')\n  end\n\n  def ensure_group!\n    return if record.group_id\n\n    raise Exceptions::UnprocessableEntity, \"Group can't be blank\"\n  end\n\n  def follow_up?\n    return true if user.permissions?('ticket.agent') # agents can always reopen tickets, regardless of group configuration\n    return true if record.group.follow_up_possible != 'new_ticket' # check if the setting for follow_up_possible is disabled\n    return true if record.state.name != 'closed' # check if the ticket state is already closed\n\n    raise Exceptions::UnprocessableEntity, 'Cannot follow-up on a closed ticket. Please create a new ticket.'\n  end\n\n  def agent_read_access?\n    agent_access?('read')\n  end\n\n  private\n\n  def access?(access)\n    return true if agent_access?(access)\n\n    customer_access?\n  end\n\n  def agent_access?(access)\n    return false if !user.permissions?('ticket.agent')\n    return true if owner?\n\n    user.group_access?(record.group.id, access)\n  end\n\n  def owner?\n    record.owner_id == user.id\n  end\n\n  def customer_access?\n    return false if !user.permissions?('ticket.customer')\n    return true if customer?\n\n    shared_organization?\n  end\n\n  def customer?\n    record.customer_id == user.id\n  end\n\n  def shared_organization?\n    return false if record.organization_id.blank?\n    return false if user.organization_id.blank?\n    return false if record.organization_id != user.organization_id\n\n    record.organization.shared?\n  end\nend\n", "FactoryBot.define do\n  factory :role do\n    sequence(:name) { |n| \"TestRole#{n}\" }\n    created_by_id   { 1 }\n    updated_by_id   { 1 }\n\n    factory :agent_role do\n      permissions { Permission.where(name: 'ticket.agent') }\n    end\n\n    trait :customer do\n      permissions { Permission.where(name: 'ticket.customer') }\n    end\n\n    trait :admin do\n      permissions { Permission.where(name: 'admin') }\n    end\n  end\nend\n", "require 'rails_helper'\n\ndescribe Ticket::ArticlePolicy do\n  subject { described_class.new(user, record) }\n\n  let!(:group) { create(:group) }\n  let!(:ticket_customer) { create(:customer) }\n\n  let(:record) do\n    ticket = create(:ticket, group: group, customer: ticket_customer)\n    create(:ticket_article, ticket: ticket)\n  end\n\n  context 'when article internal' do\n    let(:record) do\n      ticket = create(:ticket, group: group, customer: ticket_customer)\n      create(:ticket_article, ticket: ticket, internal: true)\n    end\n\n    context 'when agent' do\n      let(:user) { create(:agent, groups: [group]) }\n\n      it { is_expected.to permit_actions(%i[show]) }\n    end\n\n    context 'when agent and customer' do\n      let(:user) { create(:agent_and_customer, groups: [group]) }\n\n      it { is_expected.to permit_actions(%i[show]) }\n    end\n\n    context 'when agent and customer but no agent group access' do\n      let(:user) do\n        customer_role = create(:role, :customer)\n        create(:agent_and_customer, roles: [customer_role])\n      end\n\n      it { is_expected.not_to permit_actions(%i[show]) }\n    end\n\n    context 'when customer' do\n      let(:user) { ticket_customer }\n\n      it { is_expected.not_to permit_actions(%i[show]) }\n    end\n  end\n\n  context 'when agent' do\n    let(:user) { create(:agent, groups: [group]) }\n\n    it { is_expected.to permit_actions(%i[show]) }\n  end\n\n  context 'when agent and customer' do\n    let(:user) { create(:agent_and_customer, groups: [group]) }\n\n    it { is_expected.to permit_actions(%i[show]) }\n  end\n\n  context 'when customer' do\n    let(:user) { ticket_customer }\n\n    it { is_expected.to permit_actions(%i[show]) }\n  end\n\nend\n"], "filenames": ["app/policies/ticket/article_policy.rb", "app/policies/ticket_policy.rb", "spec/factories/role.rb", "spec/policies/ticket/article_policy_spec.rb"], "buggy_code_start_loc": [58, 43, 10, 31], "buggy_code_end_loc": [61, 43, 10, 31], "fixing_code_start_loc": [58, 44, 11, 32], "fixing_code_end_loc": [60, 48, 15, 41], "type": "CWE-862", "message": "An issue was discovered in Zammad before 3.5.1. An Agent with Customer permissions in a Group can bypass intended access control on internal Articles via the Ticket detail view.", "other": {"cve": {"id": "CVE-2020-29158", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-28T08:15:11.523", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Zammad before 3.5.1. An Agent with Customer permissions in a Group can bypass intended access control on internal Articles via the Ticket detail view."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Zammad versiones anteriores a 3.5.1.&#xa0;Un Agente con permisos de Cliente en un Grupo puede omitir un control de acceso previsto en los Art\u00edculos internos por medio de la vista de detalles del Ticket"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zammad:zammad:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.5.1", "matchCriteriaId": "E145AE87-39C7-4B83-B785-46FF419E2B9D"}]}]}], "references": [{"url": "https://github.com/zammad/zammad/commit/cf5a5e396058d4b134dd33d0a62b11c1733c98ab", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://zammad.com/en/advisories/zaa-2020-23", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zammad/zammad/commit/cf5a5e396058d4b134dd33d0a62b11c1733c98ab"}}