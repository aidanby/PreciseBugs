{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            SSSSS  V   V   GGGG                              %\n%                            SS     V   V  G                                  %\n%                             SSS   V   V  G GG                               %\n%                               SS   V V   G   G                              %\n%                            SSSSS    V     GGG                               %\n%                                                                             %\n%                                                                             %\n%                  Read/Write Scalable Vector Graphics Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                             William Radcliffe                               %\n%                                March 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/delegate-private.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n\n#if defined(MAGICKCORE_XML_DELEGATE)\n#  if defined(MAGICKCORE_WINDOWS_SUPPORT)\n#    if !defined(__MINGW32__)\n#      include <win32config.h>\n#    endif\n#  endif\n#  include <libxml/xmlmemory.h>\n#  include <libxml/parserInternals.h>\n#  include <libxml/xmlerror.h>\n#endif\n\n#if defined(MAGICKCORE_AUTOTRACE_DELEGATE)\n#include \"autotrace/autotrace.h\"\n#endif\n\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#include \"librsvg/rsvg.h\"\n#if !defined(LIBRSVG_CHECK_VERSION)\n#include \"librsvg/rsvg-cairo.h\"\n#include \"librsvg/librsvg-features.h\"\n#elif !LIBRSVG_CHECK_VERSION(2,36,2)\n#include \"librsvg/rsvg-cairo.h\"\n#include \"librsvg/librsvg-features.h\"\n#endif\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define DefaultSVGDensity  96.0\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _BoundingBox\n{\n  double\n    x,\n    y,\n    width,\n    height;\n} BoundingBox;\n\ntypedef struct _ElementInfo\n{\n  double\n    cx,\n    cy,\n    major,\n    minor,\n    angle;\n} ElementInfo;\n\ntypedef struct _SVGInfo\n{\n  FILE\n    *file;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  const ImageInfo\n    *image_info;\n\n  AffineMatrix\n    affine;\n\n  size_t\n    width,\n    height;\n\n  char\n    *size,\n    *title,\n    *comment;\n\n  int\n    n;\n\n  double\n    *scale,\n    pointsize;\n\n  ElementInfo\n    element;\n\n  SegmentInfo\n    segment;\n\n  BoundingBox\n    bounds,\n    text_offset,\n    view_box;\n\n  PointInfo\n    radius;\n\n  char\n    *stop_color,\n    *offset,\n    *text,\n    *vertices,\n    *url;\n\n#if defined(MAGICKCORE_XML_DELEGATE)\n  xmlParserCtxtPtr\n    parser;\n\n  xmlDocPtr\n    document;\n#endif\n\n  ssize_t\n    svgDepth;\n} SVGInfo;\n\f\n/*\n  Static declarations.\n*/\nstatic char\n  SVGDensityGeometry[] = \"96.0x96.0\";\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSVGImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S V G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSVG()() returns MagickTrue if the image format type, identified by the\n%  magick string, is SVG.\n%\n%  The format of the IsSVG method is:\n%\n%      MagickBooleanType IsSVG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSVG(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick+1,\"svg\",3) == 0)\n    return(MagickTrue);\n  if (length < 5)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick+1,\"?xml\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S V G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSVGImage() reads a Scalable Vector Gaphics file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadSVGImage method is:\n%\n%      Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *RenderSVGImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    background[MagickPathExtent],\n    command[MagickPathExtent],\n    *density,\n    input_filename[MagickPathExtent],\n    opacity[MagickPathExtent],\n    output_filename[MagickPathExtent],\n    unique[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *next;\n\n  int\n    status;\n\n  struct stat\n    attributes;\n\n  /*\n    Our best hope for compliance with the SVG standard.\n  */\n  delegate_info=GetDelegateInfo(\"svg:decode\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    return((Image *) NULL);\n  status=AcquireUniqueSymbolicLink(image->filename,input_filename);\n  (void) AcquireUniqueFilename(output_filename);\n  (void) AcquireUniqueFilename(unique);\n  density=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%.20g,%.20g\",\n    image->resolution.x,image->resolution.y);\n  (void) FormatLocaleString(background,MagickPathExtent,\n    \"rgb(%.20g%%,%.20g%%,%.20g%%)\",\n    100.0*QuantumScale*image->background_color.red,\n    100.0*QuantumScale*image->background_color.green,\n    100.0*QuantumScale*image->background_color.blue);\n  (void) FormatLocaleString(opacity,MagickPathExtent,\"%.20g\",QuantumScale*\n    image->background_color.alpha);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),input_filename,output_filename,density,\n    background,opacity,unique);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,image_info->verbose,command,\n    (char *) NULL,exception);\n  (void) RelinquishUniqueFileResource(unique);\n  (void) RelinquishUniqueFileResource(input_filename);\n  if ((status == 0) && (stat(output_filename,&attributes) == 0) &&\n      (attributes.st_size > 0))\n    {\n      Image\n        *svg_image;\n\n      ImageInfo\n        *read_info;\n\n      read_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(read_info->filename,output_filename,\n        MagickPathExtent);\n      svg_image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (svg_image != (Image *) NULL)\n        {\n          (void) RelinquishUniqueFileResource(output_filename);\n          for (next=GetFirstImageInList(svg_image); next != (Image *) NULL; )\n          {\n            (void) CopyMagickString(next->filename,image->filename,\n              MaxTextExtent);\n            (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n            next=GetNextImageInList(next);\n          }\n          return(svg_image);\n        }\n    }\n  (void) RelinquishUniqueFileResource(output_filename);\n  return((Image *) NULL);\n}\n\n#if defined(MAGICKCORE_XML_DELEGATE)\nstatic SVGInfo *AcquireSVGInfo(void)\n{\n  SVGInfo\n    *svg_info;\n\n  svg_info=(SVGInfo *) AcquireMagickMemory(sizeof(*svg_info));\n  if (svg_info == (SVGInfo *) NULL)\n    return((SVGInfo *) NULL);\n  (void) memset(svg_info,0,sizeof(*svg_info));\n  svg_info->text=AcquireString(\"\");\n  svg_info->scale=(double *) AcquireCriticalMemory(sizeof(*svg_info->scale));\n  GetAffineMatrix(&svg_info->affine);\n  svg_info->scale[0]=ExpandAffine(&svg_info->affine);\n  return(svg_info);\n}\n\nstatic SVGInfo *DestroySVGInfo(SVGInfo *svg_info)\n{\n  if (svg_info->text != (char *) NULL)\n    svg_info->text=DestroyString(svg_info->text);\n  if (svg_info->scale != (double *) NULL)\n    svg_info->scale=(double *) RelinquishMagickMemory(svg_info->scale);\n  if (svg_info->title != (char *) NULL)\n    svg_info->title=DestroyString(svg_info->title);\n  if (svg_info->comment != (char *) NULL)\n    svg_info->comment=DestroyString(svg_info->comment);\n  return((SVGInfo *) RelinquishMagickMemory(svg_info));\n}\n\nstatic double GetUserSpaceCoordinateValue(const SVGInfo *svg_info,int type,\n  const char *string)\n{\n  char\n    *next_token,\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    value;\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",string);\n  assert(string != (const char *) NULL);\n  p=(const char *) string;\n  (void) GetNextToken(p,&p,MagickPathExtent,token);\n  value=StringToDouble(token,&next_token);\n  if (strchr(token,'%') != (char *) NULL)\n    {\n      double\n        alpha,\n        beta;\n\n      if (type > 0)\n        {\n          if (svg_info->view_box.width == 0.0)\n            return(0.0);\n          return(svg_info->view_box.width*value/100.0);\n        }\n      if (type < 0)\n        {\n          if (svg_info->view_box.height == 0.0)\n            return(0.0);\n          return(svg_info->view_box.height*value/100.0);\n        }\n      alpha=value-svg_info->view_box.width;\n      beta=value-svg_info->view_box.height;\n      return(hypot(alpha,beta)/sqrt(2.0)/100.0);\n    }\n  (void) GetNextToken(p,&p,MagickPathExtent,token);\n  if (LocaleNCompare(token,\"cm\",2) == 0)\n    return(DefaultSVGDensity*svg_info->scale[0]/2.54*value);\n  if (LocaleNCompare(token,\"em\",2) == 0)\n    return(svg_info->pointsize*value);\n  if (LocaleNCompare(token,\"ex\",2) == 0)\n    return(svg_info->pointsize*value/2.0);\n  if (LocaleNCompare(token,\"in\",2) == 0)\n    return(DefaultSVGDensity*svg_info->scale[0]*value);\n  if (LocaleNCompare(token,\"mm\",2) == 0)\n    return(DefaultSVGDensity*svg_info->scale[0]/25.4*value);\n  if (LocaleNCompare(token,\"pc\",2) == 0)\n    return(DefaultSVGDensity*svg_info->scale[0]/6.0*value);\n  if (LocaleNCompare(token,\"pt\",2) == 0)\n    return(svg_info->scale[0]*value);\n  if (LocaleNCompare(token,\"px\",2) == 0)\n    return(value);\n  return(value);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int SVGIsStandalone(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Is this document tagged standalone?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.SVGIsStandalone()\");\n  svg_info=(SVGInfo *) context;\n  return(svg_info->document->standalone == 1);\n}\n\nstatic int SVGHasInternalSubset(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Does this document has an internal subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.SVGHasInternalSubset()\");\n  svg_info=(SVGInfo *) context;\n  return(svg_info->document->intSubset != NULL);\n}\n\nstatic int SVGHasExternalSubset(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Does this document has an external subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.SVGHasExternalSubset()\");\n  svg_info=(SVGInfo *) context;\n  return(svg_info->document->extSubset != NULL);\n}\n\nstatic void SVGInternalSubset(void *context,const xmlChar *name,\n  const xmlChar *external_id,const xmlChar *system_id)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Does this document has an internal subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.internalSubset(%s, %s, %s)\",(const char *) name,\n    (external_id != (const xmlChar *) NULL ? (const char *) external_id : \"none\"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\"));\n  svg_info=(SVGInfo *) context;\n  (void) xmlCreateIntSubset(svg_info->document,name,external_id,system_id);\n}\n\nstatic xmlParserInputPtr SVGResolveEntity(void *context,\n  const xmlChar *public_id,const xmlChar *system_id)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserInputPtr\n    stream;\n\n  /*\n    Special entity resolver, better left to the parser, it has more\n    context than the application layer.  The default behaviour is to\n    not resolve the entities, in that case the ENTITY_REF nodes are\n    built in the structure (and the parameter values).\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.resolveEntity(%s, %s)\",\n    (public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\"));\n  svg_info=(SVGInfo *) context;\n  stream=xmlLoadExternalEntity((const char *) system_id,(const char *)\n    public_id,svg_info->parser);\n  return(stream);\n}\n\nstatic xmlEntityPtr SVGGetEntity(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Get an entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.SVGGetEntity(%s)\",\n    name);\n  svg_info=(SVGInfo *) context;\n  return(xmlGetDocEntity(svg_info->document,name));\n}\n\nstatic xmlEntityPtr SVGGetParameterEntity(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Get a parameter entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.getParameterEntity(%s)\",name);\n  svg_info=(SVGInfo *) context;\n  return(xmlGetParameterEntity(svg_info->document,name));\n}\n\nstatic void SVGEntityDeclaration(void *context,const xmlChar *name,int type,\n  const xmlChar *public_id,const xmlChar *system_id,xmlChar *content)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    An entity definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.entityDecl(%s, %d, %s, %s, %s)\",name,type,\n    public_id != (xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (xmlChar *) NULL ? (const char *) system_id : \"none\",content);\n  svg_info=(SVGInfo *) context;\n  if (svg_info->parser->inSubset == 1)\n    (void) xmlAddDocEntity(svg_info->document,name,type,public_id,system_id,\n      content);\n  else\n    if (svg_info->parser->inSubset == 2)\n      (void) xmlAddDtdEntity(svg_info->document,name,type,public_id,system_id,\n        content);\n}\n\nstatic void SVGAttributeDeclaration(void *context,const xmlChar *element,\n  const xmlChar *name,int type,int value,const xmlChar *default_value,\n  xmlEnumerationPtr tree)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlChar\n    *fullname,\n    *prefix;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    An attribute definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.attributeDecl(%s, %s, %d, %d, %s, ...)\",element,name,type,value,\n    default_value);\n  svg_info=(SVGInfo *) context;\n  fullname=(xmlChar *) NULL;\n  prefix=(xmlChar *) NULL;\n  parser=svg_info->parser;\n  fullname=(xmlChar *) xmlSplitQName(parser,name,&prefix);\n  if (parser->inSubset == 1)\n    (void) xmlAddAttributeDecl(&parser->vctxt,svg_info->document->intSubset,\n      element,fullname,prefix,(xmlAttributeType) type,\n      (xmlAttributeDefault) value,default_value,tree);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddAttributeDecl(&parser->vctxt,svg_info->document->extSubset,\n        element,fullname,prefix,(xmlAttributeType) type,\n        (xmlAttributeDefault) value,default_value,tree);\n  if (prefix != (xmlChar *) NULL)\n    xmlFree(prefix);\n  if (fullname != (xmlChar *) NULL)\n    xmlFree(fullname);\n}\n\nstatic void SVGElementDeclaration(void *context,const xmlChar *name,int type,\n  xmlElementContentPtr content)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    An element definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.elementDecl(%s, %d, ...)\",name,type);\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  if (parser->inSubset == 1)\n    (void) xmlAddElementDecl(&parser->vctxt,svg_info->document->intSubset,\n      name,(xmlElementTypeVal) type,content);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddElementDecl(&parser->vctxt,svg_info->document->extSubset,\n        name,(xmlElementTypeVal) type,content);\n}\n\nstatic void SVGStripString(const MagickBooleanType trim,char *message)\n{\n  register char\n    *p,\n    *q;\n\n  size_t\n    length;\n\n  assert(message != (char *) NULL);\n  if (*message == '\\0')\n    return;\n  /*\n    Remove comment.\n  */\n  q=message;\n  for (p=message; *p != '\\0'; p++)\n  {\n    if ((*p == '/') && (*(p+1) == '*'))\n      {\n        for ( ; *p != '\\0'; p++)\n          if ((*p == '*') && (*(p+1) == '/'))\n            {\n              p+=2;\n              break;\n            }\n        if (*p == '\\0')\n          break;\n      }\n    *q++=(*p);\n  }\n  *q='\\0';\n  length=strlen(message);\n  if ((trim != MagickFalse) && (length != 0))\n    {\n      /*\n        Remove whitespace.\n      */\n      p=message;\n      while (isspace((int) ((unsigned char) *p)) != 0)\n        p++;\n      if ((*p == '\\'') || (*p == '\"'))\n        p++;\n      q=message+length-1;\n      while ((isspace((int) ((unsigned char) *q)) != 0) && (q > p))\n        q--;\n      if (q > p)\n        if ((*q == '\\'') || (*q == '\"'))\n          q--;\n      (void) memmove(message,p,(size_t) (q-p+1));\n      message[q-p+1]='\\0';\n    }\n  /*\n    Convert newlines to a space.\n  */\n  for (p=message; *p != '\\0'; p++)\n    if (*p == '\\n')\n      *p=' ';\n}\n\nstatic char **SVGKeyValuePairs(void *context,const int key_sentinel,\n  const int value_sentinel,const char *text,size_t *number_tokens)\n{\n  char\n    **tokens;\n\n  register const char\n    *p,\n    *q;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  SVGInfo\n    *svg_info;\n\n  svg_info=(SVGInfo *) context;\n  *number_tokens=0;\n  if (text == (const char *) NULL)\n    return((char **) NULL);\n  extent=8;\n  tokens=(char **) AcquireQuantumMemory(extent+2UL,sizeof(*tokens));\n  if (tokens == (char **) NULL)\n    {\n      (void) ThrowMagickException(svg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",text);\n      return((char **) NULL);\n    }\n  /*\n    Convert string to an ASCII list.\n  */\n  i=0;\n  p=text;\n  for (q=p; *q != '\\0'; q++)\n  {\n    if ((*q != key_sentinel) && (*q != value_sentinel) && (*q != '\\0'))\n      continue;\n    if (i == (ssize_t) extent)\n      {\n        extent<<=1;\n        tokens=(char **) ResizeQuantumMemory(tokens,extent+2,sizeof(*tokens));\n        if (tokens == (char **) NULL)\n          {\n            (void) ThrowMagickException(svg_info->exception,GetMagickModule(),\n              ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",text);\n            return((char **) NULL);\n          }\n      }\n    tokens[i]=AcquireString(p);\n    (void) CopyMagickString(tokens[i],p,(size_t) (q-p+1));\n    SVGStripString(MagickTrue,tokens[i]);\n    i++;\n    p=q+1;\n  }\n  tokens[i]=AcquireString(p);\n  (void) CopyMagickString(tokens[i],p,(size_t) (q-p+1));\n  SVGStripString(MagickTrue,tokens[i++]);\n  tokens[i]=(char *) NULL;\n  *number_tokens=(size_t) i;\n  return(tokens);\n}\n\nstatic void SVGNotationDeclaration(void *context,const xmlChar *name,\n  const xmlChar *public_id,const xmlChar *system_id)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    What to do when a notation declaration has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.notationDecl(%s, %s, %s)\",name,\n    public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\");\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  if (parser->inSubset == 1)\n    (void) xmlAddNotationDecl(&parser->vctxt,svg_info->document->intSubset,\n      name,public_id,system_id);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddNotationDecl(&parser->vctxt,svg_info->document->intSubset,\n        name,public_id,system_id);\n}\n\nstatic void SVGProcessStyleElement(void *context,const xmlChar *name,\n  const char *style)\n{\n  char\n    background[MagickPathExtent],\n    *color,\n    *keyword,\n    *units,\n    *value;\n\n  char\n    **tokens;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_tokens;\n\n  SVGInfo\n    *svg_info;\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  \");\n  svg_info=(SVGInfo *) context;\n  tokens=SVGKeyValuePairs(context,':',';',style,&number_tokens);\n  if (tokens == (char **) NULL)\n    return;\n  for (i=0; i < (ssize_t) (number_tokens-1); i+=2)\n  {\n    keyword=(char *) tokens[i];\n    value=(char *) tokens[i+1];\n    if (LocaleCompare(keyword,\"font-size\") != 0)\n      continue;\n    svg_info->pointsize=GetUserSpaceCoordinateValue(svg_info,0,value);\n    (void) FormatLocaleFile(svg_info->file,\"font-size %g\\n\",\n      svg_info->pointsize);\n  }\n  color=AcquireString(\"none\");\n  units=AcquireString(\"userSpaceOnUse\");\n  for (i=0; i < (ssize_t) (number_tokens-1); i+=2)\n  {\n    keyword=(char *) tokens[i];\n    value=(char *) tokens[i+1];\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    %s: %s\",keyword,\n      value);\n    switch (*keyword)\n    {\n      case 'B':\n      case 'b':\n      {\n        if (LocaleCompare((const char *) name,\"background\") == 0)\n          {\n            if (LocaleCompare((const char *) name,\"svg\") == 0)\n              (void) CopyMagickString(background,value,MagickPathExtent);\n            break;\n          }\n        break;\n      }\n      case 'C':\n      case 'c':\n      {\n         if (LocaleCompare(keyword,\"clip-path\") == 0)\n           {\n             (void) FormatLocaleFile(svg_info->file,\"clip-path \\\"%s\\\"\\n\",value);\n             break;\n           }\n        if (LocaleCompare(keyword,\"clip-rule\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"clip-rule \\\"%s\\\"\\n\",value);\n            break;\n          }\n         if (LocaleCompare(keyword,\"clipPathUnits\") == 0)\n           {\n             (void) CloneString(&units,value);\n             (void) FormatLocaleFile(svg_info->file,\"clip-units \\\"%s\\\"\\n\",\n               value);\n             break;\n           }\n        if (LocaleCompare(keyword,\"color\") == 0)\n          {\n            (void) CloneString(&color,value);\n            break;\n          }\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(keyword,\"fill\") == 0)\n          {\n             if (LocaleCompare(value,\"currentColor\") == 0)\n               {\n                 (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",color);\n                 break;\n               }\n            if (LocaleCompare(value,\"#000000ff\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"fill '#000000'\\n\");\n            else\n              (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"fillcolor\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"fill-rule\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"fill-rule \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"fill-opacity\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"fill-opacity \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font\") == 0)\n          {\n            char\n              family[MagickPathExtent],\n              size[MagickPathExtent],\n              style[MagickPathExtent];\n\n            if (sscanf(value,\"%2048s %2048s %2048s\",style,size,family) != 3)\n              break;\n            if (GetUserSpaceCoordinateValue(svg_info,0,style) == 0)\n              (void) FormatLocaleFile(svg_info->file,\"font-style \\\"%s\\\"\\n\",\n                style);\n            else\n              if (sscanf(value,\"%2048s %2048s\",size,family) != 2)\n                break;\n            (void) FormatLocaleFile(svg_info->file,\"font-size \\\"%s\\\"\\n\",size);\n            (void) FormatLocaleFile(svg_info->file,\"font-family \\\"%s\\\"\\n\",\n              family);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-family\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"font-family \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-stretch\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"font-stretch \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-style\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"font-style \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-size\") == 0)\n          {\n            svg_info->pointsize=GetUserSpaceCoordinateValue(svg_info,0,value);\n            (void) FormatLocaleFile(svg_info->file,\"font-size %g\\n\",\n              svg_info->pointsize);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-weight\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"font-weight \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        break;\n      }\n      case 'K':\n      case 'k':\n      {\n        if (LocaleCompare(keyword,\"kerning\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"kerning \\\"%s\\\"\\n\",value);\n            break;\n          }\n        break;\n      }\n      case 'L':\n      case 'l':\n      {\n        if (LocaleCompare(keyword,\"letter-spacing\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"letter-spacing \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        break;\n      }\n      case 'M':\n      case 'm':\n      {\n        if (LocaleCompare(keyword,\"mask\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"mask \\\"%s\\\"\\n\",value);\n            break;\n          }\n        break;\n      }\n      case 'O':\n      case 'o':\n      {\n        if (LocaleCompare(keyword,\"offset\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"offset %g\\n\",\n              GetUserSpaceCoordinateValue(svg_info,1,value));\n            break;\n          }\n        if (LocaleCompare(keyword,\"opacity\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"opacity \\\"%s\\\"\\n\",value);\n            break;\n          }\n        break;\n      }\n      case 'S':\n      case 's':\n      {\n        if (LocaleCompare(keyword,\"stop-color\") == 0)\n          {\n            (void) CloneString(&svg_info->stop_color,value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke\") == 0)\n          {\n            if (LocaleCompare(value,\"currentColor\") == 0)\n              {\n                (void) FormatLocaleFile(svg_info->file,\"stroke \\\"%s\\\"\\n\",color);\n                break;\n              }\n            if (LocaleCompare(value,\"#000000ff\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"fill '#000000'\\n\");\n            else\n              (void) FormatLocaleFile(svg_info->file,\n                \"stroke \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-antialiasing\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-antialias %d\\n\",\n              LocaleCompare(value,\"true\") == 0);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-dasharray\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-dasharray %s\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-dashoffset\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-dashoffset %g\\n\",\n              GetUserSpaceCoordinateValue(svg_info,1,value));\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-linecap\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-linecap \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-linejoin\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-linejoin \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-miterlimit\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-miterlimit \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-opacity\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-opacity \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-width\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-width %g\\n\",\n              GetUserSpaceCoordinateValue(svg_info,1,value));\n            break;\n          }\n        break;\n      }\n      case 't':\n      case 'T':\n      {\n        if (LocaleCompare(keyword,\"text-align\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"text-align \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"text-anchor\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"text-anchor \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"text-decoration\") == 0)\n          {\n            if (LocaleCompare(value,\"underline\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"decorate underline\\n\");\n            if (LocaleCompare(value,\"line-through\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"decorate line-through\\n\");\n            if (LocaleCompare(value,\"overline\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"decorate overline\\n\");\n            break;\n          }\n        if (LocaleCompare(keyword,\"text-antialiasing\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"text-antialias %d\\n\",\n              LocaleCompare(value,\"true\") == 0);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  if (units != (char *) NULL)\n    units=DestroyString(units);\n  if (color != (char *) NULL)\n    color=DestroyString(color);\n  for (i=0; tokens[i] != (char *) NULL; i++)\n    tokens[i]=DestroyString(tokens[i]);\n  tokens=(char **) RelinquishMagickMemory(tokens);\n}\n\nstatic void SVGUnparsedEntityDeclaration(void *context,const xmlChar *name,\n  const xmlChar *public_id,const xmlChar *system_id,const xmlChar *notation)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    What to do when an unparsed entity declaration is parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.unparsedEntityDecl(%s, %s, %s, %s)\",name,\n    public_id != (xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (xmlChar *) NULL ? (const char *) system_id : \"none\",notation);\n  svg_info=(SVGInfo *) context;\n  (void) xmlAddDocEntity(svg_info->document,name,\n    XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,public_id,system_id,notation);\n\n}\n\nstatic void SVGSetDocumentLocator(void *context,xmlSAXLocatorPtr location)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Receive the document locator at startup, actually xmlDefaultSAXLocator.\n  */\n  (void) location;\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.setDocumentLocator()\");\n  svg_info=(SVGInfo *) context;\n  (void) svg_info;\n}\n\nstatic void SVGStartDocument(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when the document start being processed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.startDocument()\");\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  svg_info->document=xmlNewDoc(parser->version);\n  if (svg_info->document == (xmlDocPtr) NULL)\n    return;\n  if (parser->encoding == NULL)\n    svg_info->document->encoding=(const xmlChar *) NULL;\n  else\n    svg_info->document->encoding=xmlStrdup(parser->encoding);\n  svg_info->document->standalone=parser->standalone;\n}\n\nstatic void SVGEndDocument(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when the document end has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.endDocument()\");\n  svg_info=(SVGInfo *) context;\n  if (svg_info->offset != (char *) NULL)\n    svg_info->offset=DestroyString(svg_info->offset);\n  if (svg_info->stop_color != (char *) NULL)\n    svg_info->stop_color=DestroyString(svg_info->stop_color);\n  if (svg_info->scale != (double *) NULL)\n    svg_info->scale=(double *) RelinquishMagickMemory(svg_info->scale);\n  if (svg_info->text != (char *) NULL)\n    svg_info->text=DestroyString(svg_info->text);\n  if (svg_info->vertices != (char *) NULL)\n    svg_info->vertices=DestroyString(svg_info->vertices);\n  if (svg_info->url != (char *) NULL)\n    svg_info->url=DestroyString(svg_info->url);\n#if defined(MAGICKCORE_XML_DELEGATE)\n  if (svg_info->document != (xmlDocPtr) NULL)\n    {\n      xmlFreeDoc(svg_info->document);\n      svg_info->document=(xmlDocPtr) NULL;\n    }\n#endif\n}\n\nstatic void SVGStartElement(void *context,const xmlChar *name,\n  const xmlChar **attributes)\n{\n#define PushGraphicContext(id) \\\n{ \\\n  if (*id == '\\0') \\\n    (void) FormatLocaleFile(svg_info->file,\"push graphic-context\\n\"); \\\n  else \\\n    (void) FormatLocaleFile(svg_info->file,\"push graphic-context \\\"%s\\\"\\n\", \\\n      id); \\\n}\n\n  char\n    *color,\n    background[MagickPathExtent],\n    id[MagickPathExtent],\n    *next_token,\n    token[MagickPathExtent],\n    **tokens,\n    *units;\n\n  const char\n    *keyword,\n    *p,\n    *value;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    number_tokens;\n\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when an opening tag has been processed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.startElement(%s\",\n    name);\n  svg_info=(SVGInfo *) context;\n  svg_info->n++;\n  svg_info->scale=(double *) ResizeQuantumMemory(svg_info->scale,\n    svg_info->n+1UL,sizeof(*svg_info->scale));\n  if (svg_info->scale == (double *) NULL)\n    {\n      (void) ThrowMagickException(svg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",name);\n      return;\n    }\n  svg_info->scale[svg_info->n]=svg_info->scale[svg_info->n-1];\n  color=AcquireString(\"none\");\n  units=AcquireString(\"userSpaceOnUse\");\n  *id='\\0';\n  *token='\\0';\n  *background='\\0';\n  value=(const char *) NULL;\n  if ((LocaleCompare((char *) name,\"image\") == 0) ||\n      (LocaleCompare((char *) name,\"pattern\") == 0) ||\n      (LocaleCompare((char *) name,\"rect\") == 0) ||\n      (LocaleCompare((char *) name,\"text\") == 0) ||\n      (LocaleCompare((char *) name,\"use\") == 0))\n    {\n      svg_info->bounds.x=0.0;\n      svg_info->bounds.y=0.0;\n    }\n  if (attributes != (const xmlChar **) NULL)\n    for (i=0; (attributes[i] != (const xmlChar *) NULL); i+=2)\n    {\n      keyword=(const char *) attributes[i];\n      value=(const char *) attributes[i+1];\n      switch (*keyword)\n      {\n        case 'C':\n        case 'c':\n        {\n          if (LocaleCompare(keyword,\"cx\") == 0)\n            {\n              svg_info->element.cx=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"cy\") == 0)\n            {\n              svg_info->element.cy=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'F':\n        case 'f':\n        {\n          if (LocaleCompare(keyword,\"fx\") == 0)\n            {\n              svg_info->element.major=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"fy\") == 0)\n            {\n              svg_info->element.minor=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'H':\n        case 'h':\n        {\n          if (LocaleCompare(keyword,\"height\") == 0)\n            {\n              svg_info->bounds.height=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'I':\n        case 'i':\n        {\n          if (LocaleCompare(keyword,\"id\") == 0)\n            {\n              (void) CopyMagickString(id,value,MagickPathExtent);\n              break;\n            }\n          break;\n        }\n        case 'R':\n        case 'r':\n        {\n          if (LocaleCompare(keyword,\"r\") == 0)\n            {\n              svg_info->element.angle=\n                GetUserSpaceCoordinateValue(svg_info,0,value);\n              break;\n            }\n          break;\n        }\n        case 'W':\n        case 'w':\n        {\n          if (LocaleCompare(keyword,\"width\") == 0)\n            {\n              svg_info->bounds.width=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          break;\n        }\n        case 'X':\n        case 'x':\n        {\n          if (LocaleCompare(keyword,\"x\") == 0)\n            {\n              svg_info->bounds.x=GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"x1\") == 0)\n            {\n              svg_info->segment.x1=GetUserSpaceCoordinateValue(svg_info,1,\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"x2\") == 0)\n            {\n              svg_info->segment.x2=GetUserSpaceCoordinateValue(svg_info,1,\n                value);\n              break;\n            }\n          break;\n        }\n        case 'Y':\n        case 'y':\n        {\n          if (LocaleCompare(keyword,\"y\") == 0)\n            {\n              svg_info->bounds.y=GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"y1\") == 0)\n            {\n              svg_info->segment.y1=GetUserSpaceCoordinateValue(svg_info,-1,\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"y2\") == 0)\n            {\n              svg_info->segment.y2=GetUserSpaceCoordinateValue(svg_info,-1,\n                value);\n              break;\n            }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  if (strchr((char *) name,':') != (char *) NULL)\n    {\n      /*\n        Skip over namespace.\n      */\n      for ( ; *name != ':'; name++) ;\n      name++;\n    }\n  switch (*name)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) name,\"circle\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"clipPath\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"push clip-path \\\"%s\\\"\\n\",id);\n          break;\n        }\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) name,\"defs\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"push defs\\n\");\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) name,\"foreignObject\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) name,\"g\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) name,\"image\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) name,\"line\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"linearGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"push gradient \\\"%s\\\" linear %g,%g %g,%g\\n\",id,\n            svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2,\n            svg_info->segment.y2);\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) name,\"mask\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"push mask \\\"%s\\\"\\n\",id);\n          break;\n        }\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) name,\"path\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"pattern\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"push pattern \\\"%s\\\" %g,%g %g,%g\\n\",id,\n            svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.width,\n            svg_info->bounds.height);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polygon\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polyline\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) name,\"radialGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"push gradient \\\"%s\\\" radial %g,%g %g,%g %g\\n\",\n            id,svg_info->element.cx,svg_info->element.cy,\n            svg_info->element.major,svg_info->element.minor,\n            svg_info->element.angle);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"rect\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((char *) name,\"style\") == 0)\n        break;\n      if (LocaleCompare((const char *) name,\"svg\") == 0)\n        {\n          svg_info->svgDepth++;\n          PushGraphicContext(id);\n          (void) FormatLocaleFile(svg_info->file,\"compliance \\\"SVG\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"fill \\\"black\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"fill-opacity 1\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"stroke \\\"none\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"stroke-width 1\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"stroke-opacity 1\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"fill-rule nonzero\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"symbol\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"push symbol\\n\");\n          break;\n        }\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) name,\"text\") == 0)\n        {\n          PushGraphicContext(id);\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"text\\\"\\n\");\n          svg_info->text_offset.x=svg_info->bounds.x;\n          svg_info->text_offset.y=svg_info->bounds.y;\n          svg_info->bounds.x=0.0;\n          svg_info->bounds.y=0.0;\n          svg_info->bounds.width=0.0;\n          svg_info->bounds.height=0.0;\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"tspan\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->text_offset.x,svg_info->text_offset.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare((char *) name,\"use\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  if (attributes != (const xmlChar **) NULL)\n    for (i=0; (attributes[i] != (const xmlChar *) NULL); i+=2)\n    {\n      keyword=(const char *) attributes[i];\n      value=(const char *) attributes[i+1];\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    %s = %s\",keyword,value);\n      switch (*keyword)\n      {\n        case 'A':\n        case 'a':\n        {\n          if (LocaleCompare(keyword,\"angle\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"angle %g\\n\",\n                GetUserSpaceCoordinateValue(svg_info,0,value));\n              break;\n            }\n          break;\n        }\n        case 'C':\n        case 'c':\n        {\n          if (LocaleCompare(keyword,\"class\") == 0)\n            {\n              const char\n                *p;\n\n              for (p=value; ; )\n              {\n                (void) GetNextToken(p,&p,MagickPathExtent,token);\n                if (*token == ',')\n                  (void) GetNextToken(p,&p,MagickPathExtent,token);\n                if (*token != '\\0')\n                  {\n                    (void) FormatLocaleFile(svg_info->file,\"class \\\"%s\\\"\\n\",\n                      value);\n                    break;\n                  }\n              }\n              break;\n            }\n          if (LocaleCompare(keyword,\"clip-path\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"clip-path \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"clip-rule\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"clip-rule \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"clipPathUnits\") == 0)\n            {\n              (void) CloneString(&units,value);\n              (void) FormatLocaleFile(svg_info->file,\"clip-units \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"color\") == 0)\n            {\n              (void) CloneString(&color,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"cx\") == 0)\n            {\n              svg_info->element.cx=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"cy\") == 0)\n            {\n              svg_info->element.cy=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'D':\n        case 'd':\n        {\n          if (LocaleCompare(keyword,\"d\") == 0)\n            {\n              (void) CloneString(&svg_info->vertices,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"dx\") == 0)\n            {\n              double\n                dx;\n\n              dx=GetUserSpaceCoordinateValue(svg_info,1,value);\n              svg_info->bounds.x+=dx;\n              svg_info->text_offset.x+=dx;\n              if (LocaleCompare((char *) name,\"text\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\"translate %g,0.0\\n\",dx);\n              break;\n            }\n          if (LocaleCompare(keyword,\"dy\") == 0)\n            {\n              double\n                dy;\n\n              dy=GetUserSpaceCoordinateValue(svg_info,-1,value);\n              svg_info->bounds.y+=dy;\n              svg_info->text_offset.y+=dy;\n              if (LocaleCompare((char *) name,\"text\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\"translate 0.0,%g\\n\",dy);\n              break;\n            }\n          break;\n        }\n        case 'F':\n        case 'f':\n        {\n          if (LocaleCompare(keyword,\"fill\") == 0)\n            {\n              if (LocaleCompare(value,\"currentColor\") == 0)\n                {\n                  (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",color);\n                  break;\n                }\n              (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"fillcolor\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"fill-rule\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"fill-rule \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"fill-opacity\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"fill-opacity \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-family\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"font-family \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-stretch\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"font-stretch \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-style\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"font-style \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-size\") == 0)\n            {\n              if (LocaleCompare(value,\"xx-small\") == 0)\n                svg_info->pointsize=6.144;\n              else if (LocaleCompare(value,\"x-small\") == 0)\n                svg_info->pointsize=7.68;\n              else if (LocaleCompare(value,\"small\") == 0)\n                svg_info->pointsize=9.6;\n              else if (LocaleCompare(value,\"medium\") == 0)\n                svg_info->pointsize=12.0;\n              else if (LocaleCompare(value,\"large\") == 0)\n                svg_info->pointsize=14.4;\n              else if (LocaleCompare(value,\"x-large\") == 0)\n                svg_info->pointsize=17.28;\n              else if (LocaleCompare(value,\"xx-large\") == 0)\n                svg_info->pointsize=20.736;\n              else\n                svg_info->pointsize=GetUserSpaceCoordinateValue(svg_info,0,\n                  value);\n              (void) FormatLocaleFile(svg_info->file,\"font-size %g\\n\",\n                svg_info->pointsize);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-weight\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"font-weight \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          break;\n        }\n        case 'G':\n        case 'g':\n        {\n          if (LocaleCompare(keyword,\"gradientTransform\") == 0)\n            {\n              AffineMatrix\n                affine,\n                current,\n                transform;\n\n              GetAffineMatrix(&transform);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  \");\n              tokens=SVGKeyValuePairs(context,'(',')',value,&number_tokens);\n              if (tokens == (char **) NULL)\n                break;\n              for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n              {\n                keyword=(char *) tokens[j];\n                if (keyword == (char *) NULL)\n                  continue;\n                value=(char *) tokens[j+1];\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    %s: %s\",keyword,value);\n                current=transform;\n                GetAffineMatrix(&affine);\n                switch (*keyword)\n                {\n                  case 'M':\n                  case 'm':\n                  {\n                    if (LocaleCompare(keyword,\"matrix\") == 0)\n                      {\n                        p=(const char *) value;\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.sx=StringToDouble(value,(char **) NULL);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.rx=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.ry=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.sy=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.tx=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.ty=StringToDouble(token,&next_token);\n                        break;\n                      }\n                    break;\n                  }\n                  case 'R':\n                  case 'r':\n                  {\n                    if (LocaleCompare(keyword,\"rotate\") == 0)\n                      {\n                        double\n                          angle;\n\n                        angle=GetUserSpaceCoordinateValue(svg_info,0,value);\n                        affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                        affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                        affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                        affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                        break;\n                      }\n                    break;\n                  }\n                  case 'S':\n                  case 's':\n                  {\n                    if (LocaleCompare(keyword,\"scale\") == 0)\n                      {\n                        for (p=(const char *) value; *p != '\\0'; p++)\n                          if ((isspace((int) ((unsigned char) *p)) != 0) ||\n                              (*p == ','))\n                            break;\n                        affine.sx=GetUserSpaceCoordinateValue(svg_info,1,value);\n                        affine.sy=affine.sx;\n                        if (*p != '\\0')\n                          affine.sy=\n                            GetUserSpaceCoordinateValue(svg_info,-1,p+1);\n                        svg_info->scale[svg_info->n]=ExpandAffine(&affine);\n                        break;\n                      }\n                    if (LocaleCompare(keyword,\"skewX\") == 0)\n                      {\n                        affine.sx=svg_info->affine.sx;\n                        affine.ry=tan(DegreesToRadians(fmod(\n                          GetUserSpaceCoordinateValue(svg_info,1,value),\n                          360.0)));\n                        affine.sy=svg_info->affine.sy;\n                        break;\n                      }\n                    if (LocaleCompare(keyword,\"skewY\") == 0)\n                      {\n                        affine.sx=svg_info->affine.sx;\n                        affine.rx=tan(DegreesToRadians(fmod(\n                          GetUserSpaceCoordinateValue(svg_info,-1,value),\n                          360.0)));\n                        affine.sy=svg_info->affine.sy;\n                        break;\n                      }\n                    break;\n                  }\n                  case 'T':\n                  case 't':\n                  {\n                    if (LocaleCompare(keyword,\"translate\") == 0)\n                      {\n                        for (p=(const char *) value; *p != '\\0'; p++)\n                          if ((isspace((int) ((unsigned char) *p)) != 0) ||\n                              (*p == ','))\n                            break;\n                        affine.tx=GetUserSpaceCoordinateValue(svg_info,1,value);\n                        affine.ty=affine.tx;\n                        if (*p != '\\0')\n                          affine.ty=\n                            GetUserSpaceCoordinateValue(svg_info,-1,p+1);\n                        break;\n                      }\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                transform.sx=affine.sx*current.sx+affine.ry*current.rx;\n                transform.rx=affine.rx*current.sx+affine.sy*current.rx;\n                transform.ry=affine.sx*current.ry+affine.ry*current.sy;\n                transform.sy=affine.rx*current.ry+affine.sy*current.sy;\n                transform.tx=affine.tx*current.sx+affine.ty*current.ry+\n                  current.tx;\n                transform.ty=affine.tx*current.rx+affine.ty*current.sy+\n                  current.ty;\n              }\n              (void) FormatLocaleFile(svg_info->file,\n                \"affine %g %g %g %g %g %g\\n\",transform.sx,\n                transform.rx,transform.ry,transform.sy,transform.tx,\n                transform.ty);\n              for (j=0; tokens[j] != (char *) NULL; j++)\n                tokens[j]=DestroyString(tokens[j]);\n              tokens=(char **) RelinquishMagickMemory(tokens);\n              break;\n            }\n          if (LocaleCompare(keyword,\"gradientUnits\") == 0)\n            {\n              (void) CloneString(&units,value);\n              (void) FormatLocaleFile(svg_info->file,\"gradient-units \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          break;\n        }\n        case 'H':\n        case 'h':\n        {\n          if (LocaleCompare(keyword,\"height\") == 0)\n            {\n              svg_info->bounds.height=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"href\") == 0)\n            {\n              (void) CloneString(&svg_info->url,value);\n              break;\n            }\n          break;\n        }\n        case 'K':\n        case 'k':\n        {\n          if (LocaleCompare(keyword,\"kerning\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"kerning \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          break;\n        }\n        case 'L':\n        case 'l':\n        {\n          if (LocaleCompare(keyword,\"letter-spacing\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"letter-spacing \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          break;\n        }\n        case 'M':\n        case 'm':\n        {\n          if (LocaleCompare(keyword,\"major\") == 0)\n            {\n              svg_info->element.major=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"mask\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"mask \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"minor\") == 0)\n            {\n              svg_info->element.minor=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'O':\n        case 'o':\n        {\n          if (LocaleCompare(keyword,\"offset\") == 0)\n            {\n              (void) CloneString(&svg_info->offset,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"opacity\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"opacity \\\"%s\\\"\\n\",value);\n              break;\n            }\n          break;\n        }\n        case 'P':\n        case 'p':\n        {\n          if (LocaleCompare(keyword,\"path\") == 0)\n            {\n              (void) CloneString(&svg_info->url,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"points\") == 0)\n            {\n              (void) CloneString(&svg_info->vertices,value);\n              break;\n            }\n          break;\n        }\n        case 'R':\n        case 'r':\n        {\n          if (LocaleCompare(keyword,\"r\") == 0)\n            {\n              svg_info->element.major=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              svg_info->element.minor=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"rotate\") == 0)\n            {\n              double\n                angle;\n\n              angle=GetUserSpaceCoordinateValue(svg_info,0,value);\n              (void) FormatLocaleFile(svg_info->file,\"translate %g,%g\\n\",\n                svg_info->bounds.x,svg_info->bounds.y);\n              svg_info->bounds.x=0;\n              svg_info->bounds.y=0;\n              (void) FormatLocaleFile(svg_info->file,\"rotate %g\\n\",angle);\n              break;\n            }\n          if (LocaleCompare(keyword,\"rx\") == 0)\n            {\n              if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n                svg_info->element.major=\n                  GetUserSpaceCoordinateValue(svg_info,1,value);\n              else\n                svg_info->radius.x=\n                  GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"ry\") == 0)\n            {\n              if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n                svg_info->element.minor=\n                  GetUserSpaceCoordinateValue(svg_info,-1,value);\n              else\n                svg_info->radius.y=\n                  GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'S':\n        case 's':\n        {\n          if (LocaleCompare(keyword,\"stop-color\") == 0)\n            {\n              (void) CloneString(&svg_info->stop_color,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke\") == 0)\n            {\n              if (LocaleCompare(value,\"currentColor\") == 0)\n                {\n                  (void) FormatLocaleFile(svg_info->file,\"stroke \\\"%s\\\"\\n\",\n                    color);\n                  break;\n                }\n              (void) FormatLocaleFile(svg_info->file,\"stroke \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-antialiasing\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-antialias %d\\n\",\n                LocaleCompare(value,\"true\") == 0);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-dasharray\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-dasharray %s\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-dashoffset\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-dashoffset %g\\n\",\n                GetUserSpaceCoordinateValue(svg_info,1,value));\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-linecap\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-linecap \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-linejoin\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-linejoin \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-miterlimit\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\n                \"stroke-miterlimit \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-opacity\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-opacity \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-width\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-width %g\\n\",\n                GetUserSpaceCoordinateValue(svg_info,1,value));\n              break;\n            }\n          if (LocaleCompare(keyword,\"style\") == 0)\n            {\n              SVGProcessStyleElement(context,name,value);\n              break;\n            }\n          break;\n        }\n        case 'T':\n        case 't':\n        {\n          if (LocaleCompare(keyword,\"text-align\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"text-align \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"text-anchor\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"text-anchor \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"text-decoration\") == 0)\n            {\n              if (LocaleCompare(value,\"underline\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\"decorate underline\\n\");\n              if (LocaleCompare(value,\"line-through\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\n                  \"decorate line-through\\n\");\n              if (LocaleCompare(value,\"overline\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\"decorate overline\\n\");\n              break;\n            }\n          if (LocaleCompare(keyword,\"text-antialiasing\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"text-antialias %d\\n\",\n                LocaleCompare(value,\"true\") == 0);\n              break;\n            }\n          if (LocaleCompare(keyword,\"transform\") == 0)\n            {\n              AffineMatrix\n                affine,\n                current,\n                transform;\n\n              GetAffineMatrix(&transform);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  \");\n              tokens=SVGKeyValuePairs(context,'(',')',value,&number_tokens);\n              if (tokens == (char **) NULL)\n                break;\n              for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n              {\n                keyword=(char *) tokens[j];\n                value=(char *) tokens[j+1];\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    %s: %s\",keyword,value);\n                current=transform;\n                GetAffineMatrix(&affine);\n                switch (*keyword)\n                {\n                  case 'M':\n                  case 'm':\n                  {\n                    if (LocaleCompare(keyword,\"matrix\") == 0)\n                      {\n                        p=(const char *) value;\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.sx=StringToDouble(value,(char **) NULL);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.rx=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.ry=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.sy=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.tx=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.ty=StringToDouble(token,&next_token);\n                        break;\n                      }\n                    break;\n                  }\n                  case 'R':\n                  case 'r':\n                  {\n                    if (LocaleCompare(keyword,\"rotate\") == 0)\n                      {\n                        double\n                          angle,\n                          x,\n                          y;\n\n                        p=(const char *) value;\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        angle=StringToDouble(value,(char **) NULL);\n                        affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                        affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                        affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                        affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        x=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        y=StringToDouble(token,&next_token);\n                        affine.tx=svg_info->bounds.x+x*\n                          cos(DegreesToRadians(fmod(angle,360.0)))+y*\n                          sin(DegreesToRadians(fmod(angle,360.0)));\n                        affine.ty=svg_info->bounds.y-x*\n                          sin(DegreesToRadians(fmod(angle,360.0)))+y*\n                          cos(DegreesToRadians(fmod(angle,360.0)));\n                        affine.tx-=x;\n                        affine.ty-=y;\n                        break;\n                      }\n                    break;\n                  }\n                  case 'S':\n                  case 's':\n                  {\n                    if (LocaleCompare(keyword,\"scale\") == 0)\n                      {\n                        for (p=(const char *) value; *p != '\\0'; p++)\n                          if ((isspace((int) ((unsigned char) *p)) != 0) ||\n                              (*p == ','))\n                            break;\n                        affine.sx=GetUserSpaceCoordinateValue(svg_info,1,value);\n                        affine.sy=affine.sx;\n                        if (*p != '\\0')\n                          affine.sy=GetUserSpaceCoordinateValue(svg_info,-1,\n                            p+1);\n                        svg_info->scale[svg_info->n]=ExpandAffine(&affine);\n                        break;\n                      }\n                    if (LocaleCompare(keyword,\"skewX\") == 0)\n                      {\n                        affine.sx=svg_info->affine.sx;\n                        affine.ry=tan(DegreesToRadians(fmod(\n                          GetUserSpaceCoordinateValue(svg_info,1,value),\n                          360.0)));\n                        affine.sy=svg_info->affine.sy;\n                        break;\n                      }\n                    if (LocaleCompare(keyword,\"skewY\") == 0)\n                      {\n                        affine.sx=svg_info->affine.sx;\n                        affine.rx=tan(DegreesToRadians(fmod(\n                          GetUserSpaceCoordinateValue(svg_info,-1,value),\n                          360.0)));\n                        affine.sy=svg_info->affine.sy;\n                        break;\n                      }\n                    break;\n                  }\n                  case 'T':\n                  case 't':\n                  {\n                    if (LocaleCompare(keyword,\"translate\") == 0)\n                      {\n                        for (p=(const char *) value; *p != '\\0'; p++)\n                          if ((isspace((int) ((unsigned char) *p)) != 0) ||\n                              (*p == ','))\n                            break;\n                        affine.tx=GetUserSpaceCoordinateValue(svg_info,1,value);\n                        affine.ty=0;\n                        if (*p != '\\0')\n                          affine.ty=GetUserSpaceCoordinateValue(svg_info,-1,\n                            p+1);\n                        break;\n                      }\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                transform.sx=affine.sx*current.sx+affine.ry*current.rx;\n                transform.rx=affine.rx*current.sx+affine.sy*current.rx;\n                transform.ry=affine.sx*current.ry+affine.ry*current.sy;\n                transform.sy=affine.rx*current.ry+affine.sy*current.sy;\n                transform.tx=affine.tx*current.sx+affine.ty*current.ry+\n                  current.tx;\n                transform.ty=affine.tx*current.rx+affine.ty*current.sy+\n                  current.ty;\n              }\n              (void) FormatLocaleFile(svg_info->file,\n                \"affine %g %g %g %g %g %g\\n\",transform.sx,transform.rx,\n                transform.ry,transform.sy,transform.tx,transform.ty);\n              for (j=0; tokens[j] != (char *) NULL; j++)\n                tokens[j]=DestroyString(tokens[j]);\n              tokens=(char **) RelinquishMagickMemory(tokens);\n              break;\n            }\n          break;\n        }\n        case 'V':\n        case 'v':\n        {\n          if (LocaleCompare(keyword,\"verts\") == 0)\n            {\n              (void) CloneString(&svg_info->vertices,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"viewBox\") == 0)\n            {\n              p=(const char *) value;\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n              svg_info->view_box.x=StringToDouble(token,&next_token);\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                (void) GetNextToken(p,&p,MagickPathExtent,token);\n              svg_info->view_box.y=StringToDouble(token,&next_token);\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                (void) GetNextToken(p,&p,MagickPathExtent,token);\n              svg_info->view_box.width=StringToDouble(token,\n                (char **) NULL);\n              if (svg_info->bounds.width == 0)\n                svg_info->bounds.width=svg_info->view_box.width;\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                (void) GetNextToken(p,&p,MagickPathExtent,token);\n              svg_info->view_box.height=StringToDouble(token,\n                (char **) NULL);\n              if (svg_info->bounds.height == 0)\n                svg_info->bounds.height=svg_info->view_box.height;\n              break;\n            }\n          break;\n        }\n        case 'W':\n        case 'w':\n        {\n          if (LocaleCompare(keyword,\"width\") == 0)\n            {\n              svg_info->bounds.width=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          break;\n        }\n        case 'X':\n        case 'x':\n        {\n          if (LocaleCompare(keyword,\"x\") == 0)\n            {\n              svg_info->bounds.x=GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"xlink:href\") == 0)\n            {\n              (void) CloneString(&svg_info->url,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"x1\") == 0)\n            {\n              svg_info->segment.x1=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"x2\") == 0)\n            {\n              svg_info->segment.x2=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          break;\n        }\n        case 'Y':\n        case 'y':\n        {\n          if (LocaleCompare(keyword,\"y\") == 0)\n            {\n              svg_info->bounds.y=GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"y1\") == 0)\n            {\n              svg_info->segment.y1=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"y2\") == 0)\n            {\n              svg_info->segment.y2=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  if (LocaleCompare((const char *) name,\"svg\") == 0)\n    {\n      if (svg_info->document->encoding != (const xmlChar *) NULL)\n        (void) FormatLocaleFile(svg_info->file,\"encoding \\\"%s\\\"\\n\",\n          (const char *) svg_info->document->encoding);\n      if (attributes != (const xmlChar **) NULL)\n        {\n          double\n            sx,\n            sy,\n            tx,\n            ty;\n\n          if ((svg_info->view_box.width == 0.0) ||\n              (svg_info->view_box.height == 0.0))\n            svg_info->view_box=svg_info->bounds;\n          svg_info->width=0;\n          if (svg_info->bounds.width > 0.0)\n            svg_info->width=(size_t) floor(svg_info->bounds.width+0.5);\n          svg_info->height=0;\n          if (svg_info->bounds.height > 0.0)\n            svg_info->height=(size_t) floor(svg_info->bounds.height+0.5);\n          (void) FormatLocaleFile(svg_info->file,\"viewbox 0 0 %.20g %.20g\\n\",\n            (double) svg_info->width,(double) svg_info->height);\n          sx=PerceptibleReciprocal(svg_info->view_box.width)*svg_info->width;\n          sy=PerceptibleReciprocal(svg_info->view_box.height)*svg_info->height;\n          tx=svg_info->view_box.x != 0.0 ? (double) -sx*svg_info->view_box.x :\n            0.0;\n          ty=svg_info->view_box.y != 0.0 ? (double) -sy*svg_info->view_box.y :\n            0.0;\n          (void) FormatLocaleFile(svg_info->file,\"affine %g 0 0 %g %g %g\\n\",\n            sx,sy,tx,ty);\n          if ((svg_info->svgDepth == 1) && (*background != '\\0'))\n            {\n              PushGraphicContext(id);\n              (void) FormatLocaleFile(svg_info->file,\"fill %s\\n\",background);\n              (void) FormatLocaleFile(svg_info->file,\n                \"rectangle 0,0 %g,%g\\n\",svg_info->view_box.width,\n                svg_info->view_box.height);\n              (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n            }\n        }\n    }\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  )\");\n  if (units != (char *) NULL)\n    units=DestroyString(units);\n  if (color != (char *) NULL)\n    color=DestroyString(color);\n}\n\nstatic void SVGEndElement(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when the end of an element has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.endElement(%s)\",name);\n  svg_info=(SVGInfo *) context;\n  if (strchr((char *) name,':') != (char *) NULL)\n    {\n      /*\n        Skip over namespace.\n      */\n      for ( ; *name != ':'; name++) ;\n      name++;\n    }\n  switch (*name)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) name,\"circle\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"circle\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"circle %g,%g %g,%g\\n\",\n            svg_info->element.cx,svg_info->element.cy,svg_info->element.cx,\n            svg_info->element.cy+svg_info->element.minor);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"clipPath\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop clip-path\\n\");\n          break;\n        }\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) name,\"defs\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop defs\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"desc\") == 0)\n        {\n          register char\n            *p;\n\n          if (*svg_info->text == '\\0')\n            break;\n          (void) fputc('#',svg_info->file);\n          for (p=svg_info->text; *p != '\\0'; p++)\n          {\n            (void) fputc(*p,svg_info->file);\n            if (*p == '\\n')\n              (void) fputc('#',svg_info->file);\n          }\n          (void) fputc('\\n',svg_info->file);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n        {\n          double\n            angle;\n\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"ellipse\\\"\\n\");\n          angle=svg_info->element.angle;\n          (void) FormatLocaleFile(svg_info->file,\"ellipse %g,%g %g,%g 0,360\\n\",\n            svg_info->element.cx,svg_info->element.cy,\n            angle == 0.0 ? svg_info->element.major : svg_info->element.minor,\n            angle == 0.0 ? svg_info->element.minor : svg_info->element.major);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) name,\"foreignObject\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) name,\"g\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) name,\"image\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"image Over %g,%g %g,%g \\\"%s\\\"\\n\",svg_info->bounds.x,\n            svg_info->bounds.y,svg_info->bounds.width,svg_info->bounds.height,\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) name,\"line\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"line\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"line %g,%g %g,%g\\n\",\n            svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2,\n            svg_info->segment.y2);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"linearGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) name,\"mask\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop mask\\n\");\n          break;\n        }\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) name,\"pattern\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop pattern\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"path\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"path\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"path \\\"%s\\\"\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polygon\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polygon\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polygon %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polyline\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polyline\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polyline %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) name,\"radialGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"rect\") == 0)\n        {\n          if ((svg_info->radius.x == 0.0) && (svg_info->radius.y == 0.0))\n            {\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"rect\\\"\\n\");\n              if ((fabs(svg_info->bounds.width-1.0) < MagickEpsilon) &&\n                  (fabs(svg_info->bounds.height-1.0) < MagickEpsilon))\n                (void) FormatLocaleFile(svg_info->file,\"point %g,%g\\n\",\n                  svg_info->bounds.x,svg_info->bounds.y);\n              else\n                (void) FormatLocaleFile(svg_info->file,\n                  \"rectangle %g,%g %g,%g\\n\",svg_info->bounds.x,\n                  svg_info->bounds.y,svg_info->bounds.x+svg_info->bounds.width,\n                  svg_info->bounds.y+svg_info->bounds.height);\n              (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n              break;\n            }\n          if (svg_info->radius.x == 0.0)\n            svg_info->radius.x=svg_info->radius.y;\n          if (svg_info->radius.y == 0.0)\n            svg_info->radius.y=svg_info->radius.x;\n          (void) FormatLocaleFile(svg_info->file,\n            \"roundRectangle %g,%g %g,%g %g,%g\\n\",\n            svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.x+\n            svg_info->bounds.width,svg_info->bounds.y+svg_info->bounds.height,\n            svg_info->radius.x,svg_info->radius.y);\n          svg_info->radius.x=0.0;\n          svg_info->radius.y=0.0;\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((const char *) name,\"stop\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"stop-color \\\"%s\\\" %s\\n\",\n            svg_info->stop_color,svg_info->offset);\n          break;\n        }\n      if (LocaleCompare((char *) name,\"style\") == 0)\n        {\n          char\n            *keyword,\n            **tokens,\n            *value;\n\n          register ssize_t\n            j;\n\n          size_t\n            number_tokens;\n\n          /*\n            Find style definitions in svg_info->text.\n          */\n          tokens=SVGKeyValuePairs(context,'{','}',svg_info->text,\n            &number_tokens);\n          if (tokens == (char **) NULL)\n            break;\n          for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n          {\n            keyword=(char *) tokens[j];\n            value=(char *) tokens[j+1];\n            (void) FormatLocaleFile(svg_info->file,\"push class \\\"%s\\\"\\n\",\n              *keyword == '.' ? keyword+1 : keyword);\n            SVGProcessStyleElement(context,name,value);\n            (void) FormatLocaleFile(svg_info->file,\"pop class\\n\");\n          }\n          for (j=0; tokens[j] != (char *) NULL; j++)\n            tokens[j]=DestroyString(tokens[j]);\n          tokens=(char **) RelinquishMagickMemory(tokens);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"svg\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          svg_info->svgDepth--;\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"symbol\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop symbol\\n\");\n          break;\n        }\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) name,\"text\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              SVGStripString(MagickTrue,svg_info->text);\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->text_offset.x,svg_info->text_offset.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"tspan\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"tspan\\\"\\n\");\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->bounds.x,svg_info->bounds.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"title\") == 0)\n        {\n          if (*svg_info->text == '\\0')\n            break;\n          (void) CloneString(&svg_info->title,svg_info->text);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare((char *) name,\"use\") == 0)\n        {\n          if ((svg_info->bounds.x != 0.0) || (svg_info->bounds.y != 0.0))\n            (void) FormatLocaleFile(svg_info->file,\"translate %g,%g\\n\",\n              svg_info->bounds.x,svg_info->bounds.y);\n          (void) FormatLocaleFile(svg_info->file,\"use \\\"url(%s)\\\"\\n\",\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  *svg_info->text='\\0';\n  (void) memset(&svg_info->element,0,sizeof(svg_info->element));\n  (void) memset(&svg_info->segment,0,sizeof(svg_info->segment));\n  svg_info->n--;\n}\n\nstatic void SVGCharacters(void *context,const xmlChar *c,int length)\n{\n  char\n    *text;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SVGInfo\n    *svg_info;\n\n  /*\n    Receiving some characters from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.characters(%s,%.20g)\",c,(double) length);\n  svg_info=(SVGInfo *) context;\n  text=(char *) AcquireQuantumMemory(length+1,sizeof(*text));\n  if (text == (char *) NULL)\n    return;\n  p=text;\n  for (i=0; i < (ssize_t) length; i++)\n    *p++=c[i];\n  *p='\\0';\n  SVGStripString(MagickFalse,text);\n  if (svg_info->text == (char *) NULL)\n    svg_info->text=text;\n  else\n    {\n      (void) ConcatenateString(&svg_info->text,text);\n      text=DestroyString(text);\n    }\n}\n\nstatic void SVGReference(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when an entity reference is detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.reference(%s)\",\n    name);\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  if (parser == (xmlParserCtxtPtr) NULL)\n    return;\n  if (parser->node == (xmlNodePtr) NULL)\n    return;\n  if (*name == '#')\n    (void) xmlAddChild(parser->node,xmlNewCharRef(svg_info->document,name));\n  else\n    (void) xmlAddChild(parser->node,xmlNewReference(svg_info->document,name));\n}\n\nstatic void SVGIgnorableWhitespace(void *context,const xmlChar *c,int length)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Receiving some ignorable whitespaces from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.ignorableWhitespace(%.30s, %d)\",c,length);\n  svg_info=(SVGInfo *) context;\n  (void) svg_info;\n}\n\nstatic void SVGProcessingInstructions(void *context,const xmlChar *target,\n  const xmlChar *data)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    A processing instruction has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.processingInstruction(%s, %s)\",target,data);\n  svg_info=(SVGInfo *) context;\n  (void) svg_info;\n}\n\nstatic void SVGComment(void *context,const xmlChar *value)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    A comment has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.comment(%s)\",\n    value);\n  svg_info=(SVGInfo *) context;\n  if (svg_info->comment != (char *) NULL)\n    (void) ConcatenateString(&svg_info->comment,\"\\n\");\n  (void) ConcatenateString(&svg_info->comment,(const char *) value);\n}\n\nstatic void SVGWarning(void *,const char *,...)\n  magick_attribute((__format__ (__printf__,2,3)));\n\nstatic void SVGWarning(void *context,const char *format,...)\n{\n  char\n    *message,\n    reason[MagickPathExtent];\n\n  SVGInfo\n    *svg_info;\n\n  va_list\n    operands;\n\n  /**\n    Display and format a warning messages, gives file, line, position and\n    extra parameters.\n  */\n  va_start(operands,format);\n  svg_info=(SVGInfo *) context;\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.warning: \");\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);\n#if !defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsprintf(reason,format,operands);\n#else\n  (void) vsnprintf(reason,MagickPathExtent,format,operands);\n#endif\n  message=GetExceptionMessage(errno);\n  (void) ThrowMagickException(svg_info->exception,GetMagickModule(),\n    DelegateWarning,reason,\"`%s`\",message);\n  message=DestroyString(message);\n  va_end(operands);\n}\n\nstatic void SVGError(void *,const char *,...)\n  magick_attribute((__format__ (__printf__,2,3)));\n\nstatic void SVGError(void *context,const char *format,...)\n{\n  char\n    *message,\n    reason[MagickPathExtent];\n\n  SVGInfo\n    *svg_info;\n\n  va_list\n    operands;\n\n  /*\n    Display and format a error formats, gives file, line, position and\n    extra parameters.\n  */\n  va_start(operands,format);\n  svg_info=(SVGInfo *) context;\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.error: \");\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);\n#if !defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsprintf(reason,format,operands);\n#else\n  (void) vsnprintf(reason,MagickPathExtent,format,operands);\n#endif\n  message=GetExceptionMessage(errno);\n  (void) ThrowMagickException(svg_info->exception,GetMagickModule(),CoderError,\n    reason,\"`%s`\",message);\n  message=DestroyString(message);\n  va_end(operands);\n}\n\nstatic void SVGCDataBlock(void *context,const xmlChar *value,int length)\n{\n  SVGInfo\n    *svg_info;\n\n   xmlNodePtr\n     child;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when a pcdata block has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.pcdata(%s, %d)\",\n    value,length);\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  child=xmlGetLastChild(parser->node);\n  if ((child != (xmlNodePtr) NULL) && (child->type == XML_CDATA_SECTION_NODE))\n    {\n      xmlTextConcat(child,value,length);\n      return;\n    }\n  (void) xmlAddChild(parser->node,xmlNewCDataBlock(parser->myDoc,value,length));\n}\n\nstatic void SVGExternalSubset(void *context,const xmlChar *name,\n  const xmlChar *external_id,const xmlChar *system_id)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxt\n    parser_context;\n\n  xmlParserCtxtPtr\n    parser;\n\n  xmlParserInputPtr\n    input;\n\n  /*\n    Does this document has an external subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.externalSubset(%s, %s, %s)\",name,\n    (external_id != (const xmlChar *) NULL ? (const char *) external_id : \"none\"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\"));\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  if (((external_id == NULL) && (system_id == NULL)) ||\n      ((parser->validate == 0) || (parser->wellFormed == 0) ||\n      (svg_info->document == 0)))\n    return;\n  input=SVGResolveEntity(context,external_id,system_id);\n  if (input == NULL)\n    return;\n  (void) xmlNewDtd(svg_info->document,name,external_id,system_id);\n  parser_context=(*parser);\n  parser->inputTab=(xmlParserInputPtr *) xmlMalloc(5*sizeof(*parser->inputTab));\n  if (parser->inputTab == (xmlParserInputPtr *) NULL)\n    {\n      parser->errNo=XML_ERR_NO_MEMORY;\n      parser->input=parser_context.input;\n      parser->inputNr=parser_context.inputNr;\n      parser->inputMax=parser_context.inputMax;\n      parser->inputTab=parser_context.inputTab;\n      return;\n  }\n  parser->inputNr=0;\n  parser->inputMax=5;\n  parser->input=NULL;\n  xmlPushInput(parser,input);\n  (void) xmlSwitchEncoding(parser,xmlDetectCharEncoding(parser->input->cur,4));\n  if (input->filename == (char *) NULL)\n    input->filename=(char *) xmlStrdup(system_id);\n  input->line=1;\n  input->col=1;\n  input->base=parser->input->cur;\n  input->cur=parser->input->cur;\n  input->free=NULL;\n  xmlParseExternalSubset(parser,external_id,system_id);\n  while (parser->inputNr > 1)\n    (void) xmlPopInput(parser);\n  xmlFreeInputStream(parser->input);\n  xmlFree(parser->inputTab);\n  parser->input=parser_context.input;\n  parser->inputNr=parser_context.inputNr;\n  parser->inputMax=parser_context.inputMax;\n  parser->inputTab=parser_context.inputTab;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next;\n\n  int\n    status,\n    unique_file;\n\n  ssize_t\n    n;\n\n  SVGInfo\n    *svg_info;\n\n  unsigned char\n    message[MagickPathExtent];\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->resolution.x) < MagickEpsilon) ||\n      (fabs(image->resolution.y) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n    {\n      Image\n        *svg_image;\n\n      svg_image=RenderSVGImage(image_info,image,exception);\n      if (svg_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          return(svg_image);\n        }\n      {\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        cairo_surface_t\n          *cairo_surface;\n\n        cairo_t\n          *cairo_image;\n\n        MagickBooleanType\n          apply_density;\n\n        MemoryInfo\n          *pixel_info;\n\n        register unsigned char\n          *p;\n\n        RsvgDimensionData\n          dimension_info;\n\n        unsigned char\n          *pixels;\n\n#else\n        GdkPixbuf\n          *pixel_buffer;\n\n        register const guchar\n          *p;\n#endif\n\n        GError\n          *error;\n\n        PixelInfo\n          fill_color;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *q;\n\n        RsvgHandle\n          *svg_handle;\n\n        ssize_t\n          y;\n\n        svg_handle=rsvg_handle_new();\n        if (svg_handle == (RsvgHandle *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        rsvg_handle_set_base_uri(svg_handle,image_info->filename);\n        if ((fabs(image->resolution.x) > MagickEpsilon) &&\n            (fabs(image->resolution.y) > MagickEpsilon))\n          rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n            image->resolution.y);\n        while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n        {\n          message[n]='\\0';\n          error=(GError *) NULL;\n          (void) rsvg_handle_write(svg_handle,message,n,&error);\n          if (error != (GError *) NULL)\n            g_error_free(error);\n        }\n        error=(GError *) NULL;\n        rsvg_handle_close(svg_handle,&error);\n        if (error != (GError *) NULL)\n          g_error_free(error);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        apply_density=MagickTrue;\n        rsvg_handle_get_dimensions(svg_handle,&dimension_info);\n        if ((image->resolution.x > 0.0) && (image->resolution.y > 0.0))\n          {\n            RsvgDimensionData\n              dpi_dimension_info;\n\n            /*\n              We should not apply the density when the internal 'factor' is 'i'.\n              This can be checked by using the trick below.\n            */\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x*256,\n              image->resolution.y*256);\n            rsvg_handle_get_dimensions(svg_handle,&dpi_dimension_info);\n            if ((dpi_dimension_info.width != dimension_info.width) ||\n                (dpi_dimension_info.height != dimension_info.height))\n              apply_density=MagickFalse;\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n              image->resolution.y);\n          }\n        if (image_info->size != (char *) NULL)\n          {\n            (void) GetGeometry(image_info->size,(ssize_t *) NULL,\n              (ssize_t *) NULL,&image->columns,&image->rows);\n            if ((image->columns != 0) || (image->rows != 0))\n              {\n                image->resolution.x=DefaultSVGDensity*image->columns/\n                  dimension_info.width;\n                image->resolution.y=DefaultSVGDensity*image->rows/\n                  dimension_info.height;\n                if (fabs(image->resolution.x) < MagickEpsilon)\n                  image->resolution.x=image->resolution.y;\n                else\n                  if (fabs(image->resolution.y) < MagickEpsilon)\n                    image->resolution.y=image->resolution.x;\n                  else\n                    image->resolution.x=image->resolution.y=MagickMin(\n                      image->resolution.x,image->resolution.y);\n                apply_density=MagickTrue;\n              }\n          }\n        if (apply_density != MagickFalse)\n          {\n            image->columns=image->resolution.x*dimension_info.width/\n              DefaultSVGDensity;\n            image->rows=image->resolution.y*dimension_info.height/\n              DefaultSVGDensity;\n          }\n        else\n          {\n            image->columns=dimension_info.width;\n            image->rows=dimension_info.height;\n          }\n        pixel_info=(MemoryInfo *) NULL;\n#else\n        pixel_buffer=rsvg_handle_get_pixbuf(svg_handle);\n        rsvg_handle_free(svg_handle);\n        image->columns=gdk_pixbuf_get_width(pixel_buffer);\n        image->rows=gdk_pixbuf_get_height(pixel_buffer);\n#endif\n        image->alpha_trait=BlendPixelTrait;\n        if (image_info->ping == MagickFalse)\n          {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            size_t\n              stride;\n#endif\n\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              {\n#if !defined(MAGICKCORE_CAIRO_DELEGATE)\n                g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n                g_object_unref(svg_handle);\n                ThrowReaderException(MissingDelegateError,\n                  \"NoDecodeDelegateForThisImageFormat\");\n              }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            stride=4*image->columns;\n#if defined(MAGICKCORE_PANGOCAIRO_DELEGATE)\n            stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n              (int) image->columns);\n#endif\n            pixel_info=AcquireVirtualMemory(stride,image->rows*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n#endif\n            (void) SetImageBackgroundColor(image,exception);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            cairo_surface=cairo_image_surface_create_for_data(pixels,\n              CAIRO_FORMAT_ARGB32,(int) image->columns,(int) image->rows,(int)\n              stride);\n            if ((cairo_surface == (cairo_surface_t *) NULL) ||\n                (cairo_surface_status(cairo_surface) != CAIRO_STATUS_SUCCESS))\n              {\n                if (cairo_surface != (cairo_surface_t *) NULL)\n                  cairo_surface_destroy(cairo_surface);\n                pixel_info=RelinquishVirtualMemory(pixel_info);\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            cairo_image=cairo_create(cairo_surface);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n            cairo_paint(cairo_image);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n            if (apply_density != MagickFalse)\n              cairo_scale(cairo_image,image->resolution.x/DefaultSVGDensity,\n                image->resolution.y/DefaultSVGDensity);\n            rsvg_handle_render_cairo(svg_handle,cairo_image);\n            cairo_destroy(cairo_image);\n            cairo_surface_destroy(cairo_surface);\n            g_object_unref(svg_handle);\n            p=pixels;\n#else\n            p=gdk_pixbuf_get_pixels(pixel_buffer);\n#endif\n            GetPixelInfo(image,&fill_color);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                fill_color.blue=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.red=ScaleCharToQuantum(*p++);\n#else\n                fill_color.red=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.blue=ScaleCharToQuantum(*p++);\n#endif\n                fill_color.alpha=ScaleCharToQuantum(*p++);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                {\n                  double\n                    gamma;\n\n                  gamma=QuantumScale*fill_color.alpha;\n                  gamma=PerceptibleReciprocal(gamma);\n                  fill_color.blue*=gamma;\n                  fill_color.green*=gamma;\n                  fill_color.red*=gamma;\n                }\n#endif\n                CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n                  GetPixelAlpha(image,q),q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n#else\n        g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n        (void) CloseBlob(image);\n        for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n        {\n          (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n          (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n          next=GetNextImageInList(next);\n        }\n        return(GetFirstImageInList(image));\n#endif\n      }\n    }\n  /*\n    Open draw file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"w\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Parse SVG file.\n  */\n  svg_info=AcquireSVGInfo();\n  if (svg_info == (SVGInfo *) NULL)\n    {\n      (void) fclose(file);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  svg_info->file=file;\n  svg_info->exception=exception;\n  svg_info->image=image;\n  svg_info->image_info=image_info;\n  svg_info->bounds.width=image->columns;\n  svg_info->bounds.height=image->rows;\n  svg_info->svgDepth=0;\n  if (image_info->size != (char *) NULL)\n    (void) CloneString(&svg_info->size,image_info->size);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"begin SAX\");\n  xmlInitParser();\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) memset(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=SVGInternalSubset;\n  sax_modules.isStandalone=SVGIsStandalone;\n  sax_modules.hasInternalSubset=SVGHasInternalSubset;\n  sax_modules.hasExternalSubset=SVGHasExternalSubset;\n  sax_modules.resolveEntity=SVGResolveEntity;\n  sax_modules.getEntity=SVGGetEntity;\n  sax_modules.entityDecl=SVGEntityDeclaration;\n  sax_modules.notationDecl=SVGNotationDeclaration;\n  sax_modules.attributeDecl=SVGAttributeDeclaration;\n  sax_modules.elementDecl=SVGElementDeclaration;\n  sax_modules.unparsedEntityDecl=SVGUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=SVGSetDocumentLocator;\n  sax_modules.startDocument=SVGStartDocument;\n  sax_modules.endDocument=SVGEndDocument;\n  sax_modules.startElement=SVGStartElement;\n  sax_modules.endElement=SVGEndElement;\n  sax_modules.reference=SVGReference;\n  sax_modules.characters=SVGCharacters;\n  sax_modules.ignorableWhitespace=SVGIgnorableWhitespace;\n  sax_modules.processingInstruction=SVGProcessingInstructions;\n  sax_modules.comment=SVGComment;\n  sax_modules.warning=SVGWarning;\n  sax_modules.error=SVGError;\n  sax_modules.fatalError=SVGError;\n  sax_modules.getParameterEntity=SVGGetParameterEntity;\n  sax_modules.cdataBlock=SVGCDataBlock;\n  sax_modules.externalSubset=SVGExternalSubset;\n  sax_handler=(&sax_modules);\n  n=ReadBlob(image,MagickPathExtent-1,message);\n  message[n]='\\0';\n  if (n > 0)\n    {\n      svg_info->parser=xmlCreatePushParserCtxt(sax_handler,svg_info,(char *)\n        message,n,image->filename);\n      (void) xmlCtxtUseOptions(svg_info->parser,XML_PARSE_HUGE);\n      while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n      {\n        message[n]='\\0';\n        status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n        if (status != 0)\n          break;\n      }\n    }\n  (void) xmlParseChunk(svg_info->parser,(char *) message,0,1);\n  SVGEndDocument(svg_info);\n  xmlFreeParserCtxt(svg_info->parser);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image->columns=svg_info->width;\n  image->rows=svg_info->height;\n  if (exception->severity >= ErrorException)\n    {\n      svg_info=DestroySVGInfo(svg_info);\n      (void) RelinquishUniqueFileResource(filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (image_info->ping == MagickFalse)\n    {\n      ImageInfo\n        *read_info;\n\n      /*\n        Draw image.\n      */\n      image=DestroyImage(image);\n      image=(Image *) NULL;\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"mvg:%s\",\n        filename);\n      image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MagickPathExtent);\n    }\n  /*\n    Relinquish resources.\n  */\n  if (image != (Image *) NULL)\n    {\n      if (svg_info->title != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:title\",svg_info->title,exception);\n      if (svg_info->comment != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:comment\",svg_info->comment,\n          exception);\n    }\n  for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n  {\n    (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n    (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n    next=GetNextImageInList(next);\n  }\n  svg_info=DestroySVGInfo(svg_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}\n#else\nstatic Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image,\n    *svg_image;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->resolution.x) < MagickEpsilon) ||\n      (fabs(image->resolution.y) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  svg_image=RenderSVGImage(image_info,image,exception);\n  image=DestroyImage(image);\n  return(svg_image);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S V G I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSVGImage() adds attributes for the SVG image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSVGImage method is:\n%\n%      size_t RegisterSVGImage(void)\n%\n*/\nModuleExport size_t RegisterSVGImage(void)\n{\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(LIBXML_DOTTED_VERSION)\n  (void) CopyMagickString(version,\"XML \" LIBXML_DOTTED_VERSION,\n    MagickPathExtent);\n#endif\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if !GLIB_CHECK_VERSION(2,35,0)\n  g_type_init();\n#endif\n  (void) FormatLocaleString(version,MagickPathExtent,\"RSVG %d.%d.%d\",\n    LIBRSVG_MAJOR_VERSION,LIBRSVG_MINOR_VERSION,LIBRSVG_MICRO_VERSION);\n#endif\n  entry=AcquireMagickInfo(\"SVG\",\"SVG\",\"Scalable Vector Graphics\");\n  entry->decoder=(DecodeImageHandler *) ReadSVGImage;\n  entry->encoder=(EncodeImageHandler *) WriteSVGImage;\n  entry->flags^=CoderBlobSupportFlag;\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n  entry->mime_type=ConstantString(\"image/svg+xml\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->magick=(IsImageFormatHandler *) IsSVG;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"SVG\",\"SVGZ\",\"Compressed Scalable Vector Graphics\");\n#if defined(MAGICKCORE_XML_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadSVGImage;\n#endif\n  entry->encoder=(EncodeImageHandler *) WriteSVGImage;\n  entry->flags^=CoderBlobSupportFlag;\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n  entry->mime_type=ConstantString(\"image/svg+xml\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->magick=(IsImageFormatHandler *) IsSVG;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"SVG\",\"MSVG\",\n    \"ImageMagick's own SVG internal renderer\");\n#if defined(MAGICKCORE_XML_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadSVGImage;\n#endif\n  entry->encoder=(EncodeImageHandler *) WriteSVGImage;\n  entry->flags^=CoderBlobSupportFlag;\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsSVG;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S V G I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSVGImage() removes format registrations made by the\n%  SVG module from the list of supported formats.\n%\n%  The format of the UnregisterSVGImage method is:\n%\n%      UnregisterSVGImage(void)\n%\n*/\nModuleExport void UnregisterSVGImage(void)\n{\n  (void) UnregisterMagickInfo(\"SVGZ\");\n  (void) UnregisterMagickInfo(\"SVG\");\n  (void) UnregisterMagickInfo(\"MSVG\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S V G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSVGImage() writes a image in the SVG - XML based W3C standard\n%  format.\n%\n%  The format of the WriteSVGImage method is:\n%\n%      MagickBooleanType WriteSVGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void AffineToTransform(Image *image,AffineMatrix *affine)\n{\n  char\n    transform[MagickPathExtent];\n\n  if ((fabs(affine->tx) < MagickEpsilon) && (fabs(affine->ty) < MagickEpsilon))\n    {\n      if ((fabs(affine->rx) < MagickEpsilon) &&\n          (fabs(affine->ry) < MagickEpsilon))\n        {\n          if ((fabs(affine->sx-1.0) < MagickEpsilon) &&\n              (fabs(affine->sy-1.0) < MagickEpsilon))\n            {\n              (void) WriteBlobString(image,\"\\\">\\n\");\n              return;\n            }\n          (void) FormatLocaleString(transform,MagickPathExtent,\n            \"\\\" transform=\\\"scale(%g,%g)\\\">\\n\",affine->sx,affine->sy);\n          (void) WriteBlobString(image,transform);\n          return;\n        }\n      else\n        {\n          if ((fabs(affine->sx-affine->sy) < MagickEpsilon) &&\n              (fabs(affine->rx+affine->ry) < MagickEpsilon) &&\n              (fabs(affine->sx*affine->sx+affine->rx*affine->rx-1.0) <\n               2*MagickEpsilon))\n            {\n              double\n                theta;\n\n              theta=(180.0/MagickPI)*atan2(affine->rx,affine->sx);\n              (void) FormatLocaleString(transform,MagickPathExtent,\n                \"\\\" transform=\\\"rotate(%g)\\\">\\n\",theta);\n              (void) WriteBlobString(image,transform);\n              return;\n            }\n        }\n    }\n  else\n    {\n      if ((fabs(affine->sx-1.0) < MagickEpsilon) &&\n          (fabs(affine->rx) < MagickEpsilon) &&\n          (fabs(affine->ry) < MagickEpsilon) &&\n          (fabs(affine->sy-1.0) < MagickEpsilon))\n        {\n          (void) FormatLocaleString(transform,MagickPathExtent,\n            \"\\\" transform=\\\"translate(%g,%g)\\\">\\n\",affine->tx,affine->ty);\n          (void) WriteBlobString(image,transform);\n          return;\n        }\n    }\n  (void) FormatLocaleString(transform,MagickPathExtent,\n    \"\\\" transform=\\\"matrix(%g %g %g %g %g %g)\\\">\\n\",\n    affine->sx,affine->rx,affine->ry,affine->sy,affine->tx,affine->ty);\n  (void) WriteBlobString(image,transform);\n}\n\nstatic MagickBooleanType IsPoint(const char *point)\n{\n  char\n    *p;\n\n  ssize_t\n    value;\n\n  value=(ssize_t) strtol(point,&p,10);\n  (void) value;\n  return(p != point ? MagickTrue : MagickFalse);\n}\n\nstatic MagickBooleanType TraceSVGImage(Image *image,ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_AUTOTRACE_DELEGATE)\n  {\n    at_bitmap_type\n      *trace;\n\n    at_fitting_opts_type\n      *fitting_options;\n\n    at_output_opts_type\n      *output_options;\n\n    at_splines_type\n      *splines;\n\n    ImageType\n      type;\n\n    register const Quantum\n      *p;\n\n    register ssize_t\n      i,\n      x;\n\n    size_t\n      number_planes;\n\n    ssize_t\n      y;\n\n    /*\n      Trace image and write as SVG.\n    */\n    fitting_options=at_fitting_opts_new();\n    output_options=at_output_opts_new();\n    (void) SetImageGray(image,exception);\n    type=GetImageType(image);\n    number_planes=3;\n    if ((type == BilevelType) || (type == GrayscaleType))\n      number_planes=1;\n    trace=at_bitmap_new(image->columns,image->rows,number_planes);\n    i=0;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        trace->bitmap[i++]=GetPixelRed(image,p);\n        if (number_planes == 3)\n          {\n            trace->bitmap[i++]=GetPixelGreen(image,p);\n            trace->bitmap[i++]=GetPixelBlue(image,p);\n          }\n        p+=GetPixelChannels(image);\n      }\n    }\n    splines=at_splines_new_full(trace,fitting_options,NULL,NULL,NULL,NULL,NULL,\n      NULL);\n    at_splines_write(at_output_get_handler_by_suffix((char *) \"svg\"),\n      GetBlobFileHandle(image),image->filename,output_options,splines,NULL,\n      NULL);\n    /*\n      Free resources.\n    */\n    at_splines_free(splines);\n    at_bitmap_free(trace);\n    at_output_opts_free(output_options);\n    at_fitting_opts_free(fitting_options);\n  }\n#else\n  {\n    char\n      *base64,\n      filename[MagickPathExtent],\n      message[MagickPathExtent];\n\n    const DelegateInfo\n      *delegate_info;\n\n    Image\n      *clone_image;\n\n    ImageInfo\n      *image_info;\n\n    MagickBooleanType\n      status;\n\n    register char\n      *p;\n\n    size_t\n      blob_length,\n      encode_length;\n\n    ssize_t\n      i;\n\n    unsigned char\n      *blob;\n\n    delegate_info=GetDelegateInfo((char *) NULL,\"TRACE\",exception);\n    if (delegate_info != (DelegateInfo *) NULL)\n      {\n        /*\n          Trace SVG with tracing delegate.\n        */\n        image_info=AcquireImageInfo();\n        (void) CopyMagickString(image_info->magick,\"TRACE\",MagickPathExtent);\n        (void) FormatLocaleString(filename,MagickPathExtent,\"trace:%s\",\n          image_info->filename);\n        (void) CopyMagickString(image_info->filename,filename,MagickPathExtent);\n        status=WriteImage(image_info,image,exception);\n        image_info=DestroyImageInfo(image_info);\n        return(status);\n      }\n    (void) WriteBlobString(image,\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\");\n    (void) WriteBlobString(image,\n      \"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\"\");\n    (void) WriteBlobString(image,\n      \" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n\");\n    (void) FormatLocaleString(message,MagickPathExtent,\n      \"<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" \"\n      \"xmlns=\\\"http://www.w3.org/2000/svg\\\" \"\n      \"xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" \"\n      \"width=\\\"%.20gpx\\\" height=\\\"%.20gpx\\\" viewBox=\\\"0 0 %.20g %.20g\\\" \"\n      \"enable-background=\\\"new 0 0 %.20g %.20g\\\" xml:space=\\\"preserve\\\">\",\n      (double) image->columns,(double) image->rows,\n      (double) image->columns,(double) image->rows,\n      (double) image->columns,(double) image->rows);\n    (void) WriteBlobString(image,message);\n    clone_image=CloneImage(image,0,0,MagickTrue,exception);\n    if (clone_image == (Image *) NULL)\n      return(MagickFalse);\n    image_info=AcquireImageInfo();\n    (void) CopyMagickString(image_info->magick,\"PNG\",MagickPathExtent);\n    blob_length=2048;\n    blob=(unsigned char *) ImageToBlob(image_info,clone_image,&blob_length,\n      exception);\n    clone_image=DestroyImage(clone_image);\n    image_info=DestroyImageInfo(image_info);\n    if (blob == (unsigned char *) NULL)\n      return(MagickFalse);\n    encode_length=0;\n    base64=Base64Encode(blob,blob_length,&encode_length);\n    blob=(unsigned char *) RelinquishMagickMemory(blob);\n    (void) FormatLocaleString(message,MagickPathExtent,\n      \"  <image id=\\\"image%.20g\\\" width=\\\"%.20g\\\" height=\\\"%.20g\\\" \"\n      \"x=\\\"%.20g\\\" y=\\\"%.20g\\\"\\n    href=\\\"data:image/png;base64,\",\n      (double) image->scene,(double) image->columns,(double) image->rows,\n      (double) image->page.x,(double) image->page.y);\n    (void) WriteBlobString(image,message);\n    p=base64;\n    for (i=(ssize_t) encode_length; i > 0; i-=76)\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%.76s\",p);\n      (void) WriteBlobString(image,message);\n      p+=76;\n      if (i > 76)\n        (void) WriteBlobString(image,\"\\n\");\n    }\n    base64=DestroyString(base64);\n    (void) WriteBlobString(image,\"\\\" />\\n\");\n    (void) WriteBlobString(image,\"</svg>\\n\");\n  }\n#endif\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType WriteSVGImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define BezierQuantum  200\n\n  AffineMatrix\n    affine;\n\n  char\n    keyword[MagickPathExtent],\n    message[MagickPathExtent],\n    name[MagickPathExtent],\n    *next_token,\n    *token,\n    type[MagickPathExtent];\n\n  const char\n    *p,\n    *q,\n    *value;\n\n  int\n    n;\n\n  ssize_t\n    j;\n\n  MagickBooleanType\n    active,\n    status;\n\n  PointInfo\n    point;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveType\n    primitive_type;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent,\n    length,\n    number_points;\n\n  SVGInfo\n    svg_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  value=GetImageArtifact(image,\"SVG\");\n  if (value != (char *) NULL)\n    {\n      (void) WriteBlobString(image,value);\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  value=GetImageArtifact(image,\"mvg:vector-graphics\");\n  if (value == (char *) NULL)\n    return(TraceSVGImage(image,exception));\n  /*\n    Write SVG header.\n  */\n  (void) WriteBlobString(image,\"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?>\\n\");\n  (void) WriteBlobString(image,\n    \"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 20010904//EN\\\"\\n\");\n  (void) WriteBlobString(image,\n    \"  \\\"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\\\">\\n\");\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"<svg width=\\\"%.20g\\\" height=\\\"%.20g\\\">\\n\",(double) image->columns,(double)\n    image->rows);\n  (void) WriteBlobString(image,message);\n  /*\n    Allocate primitive info memory.\n  */\n  number_points=2047;\n  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,\n    sizeof(*primitive_info));\n  if (primitive_info == (PrimitiveInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  GetAffineMatrix(&affine);\n  token=AcquireString(value);\n  extent=strlen(token)+MagickPathExtent;\n  active=MagickFalse;\n  n=0;\n  status=MagickTrue;\n  for (q=(const char *) value; *q != '\\0'; )\n  {\n    /*\n      Interpret graphic primitive.\n    */\n    (void) GetNextToken(q,&q,MagickPathExtent,keyword);\n    if (*keyword == '\\0')\n      break;\n    if (*keyword == '#')\n      {\n        /*\n          Comment.\n        */\n        if (active != MagickFalse)\n          {\n            AffineToTransform(image,&affine);\n            active=MagickFalse;\n          }\n        (void) WriteBlobString(image,\"<desc>\");\n        (void) WriteBlobString(image,keyword+1);\n        for ( ; (*q != '\\n') && (*q != '\\0'); q++)\n          switch (*q)\n          {\n            case '<': (void) WriteBlobString(image,\"&lt;\"); break;\n            case '>': (void) WriteBlobString(image,\"&gt;\"); break;\n            case '&': (void) WriteBlobString(image,\"&amp;\"); break;\n            default: (void) WriteBlobByte(image,(unsigned char) *q); break;\n          }\n        (void) WriteBlobString(image,\"</desc>\\n\");\n        continue;\n      }\n    primitive_type=UndefinedPrimitive;\n    switch (*keyword)\n    {\n      case ';':\n        break;\n      case 'a':\n      case 'A':\n      {\n        if (LocaleCompare(\"affine\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.sx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.rx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ry=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.sy=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.tx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ty=StringToDouble(token,&next_token);\n            break;\n          }\n        if (LocaleCompare(\"alpha\",keyword) == 0)\n          {\n            primitive_type=AlphaPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"angle\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.rx=StringToDouble(token,&next_token);\n            affine.ry=StringToDouble(token,&next_token);\n            break;\n          }\n        if (LocaleCompare(\"arc\",keyword) == 0)\n          {\n            primitive_type=ArcPrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'b':\n      case 'B':\n      {\n        if (LocaleCompare(\"bezier\",keyword) == 0)\n          {\n            primitive_type=BezierPrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'c':\n      case 'C':\n      {\n        if (LocaleCompare(\"clip-path\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"clip-path:url(#%s);\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"clip-rule\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"clip-rule:%s;\",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"clip-units\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"clipPathUnits=%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"circle\",keyword) == 0)\n          {\n            primitive_type=CirclePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"color\",keyword) == 0)\n          {\n            primitive_type=ColorPrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'd':\n      case 'D':\n      {\n        if (LocaleCompare(\"decorate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"text-decoration:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'e':\n      case 'E':\n      {\n        if (LocaleCompare(\"ellipse\",keyword) == 0)\n          {\n            primitive_type=EllipsePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'f':\n      case 'F':\n      {\n        if (LocaleCompare(\"fill\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"fill:%s;\",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"fill-rule\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"fill-rule:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"fill-opacity\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"fill-opacity:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-family\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-family:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-stretch\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-stretch:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-style\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-style:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-size\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-size:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-weight\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-weight:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'g':\n      case 'G':\n      {\n        if (LocaleCompare(\"gradient-units\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        if (LocaleCompare(\"text-align\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"text-align %s \",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"text-anchor\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"text-anchor %s \",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'i':\n      case 'I':\n      {\n        if (LocaleCompare(\"image\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            primitive_type=ImagePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'k':\n      case 'K':\n      {\n        if (LocaleCompare(\"kerning\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"kerning:%s;\",\n              token);\n            (void) WriteBlobString(image,message);\n          }\n        break;\n      }\n      case 'l':\n      case 'L':\n      {\n        if (LocaleCompare(\"letter-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"letter-spacing:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"line\",keyword) == 0)\n          {\n            primitive_type=LinePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'o':\n      case 'O':\n      {\n        if (LocaleCompare(\"opacity\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"opacity %s \",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'p':\n      case 'P':\n      {\n        if (LocaleCompare(\"path\",keyword) == 0)\n          {\n            primitive_type=PathPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"point\",keyword) == 0)\n          {\n            primitive_type=PointPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"polyline\",keyword) == 0)\n          {\n            primitive_type=PolylinePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"polygon\",keyword) == 0)\n          {\n            primitive_type=PolygonPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"pop\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (LocaleCompare(\"clip-path\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"</clipPath>\\n\");\n                break;\n              }\n            if (LocaleCompare(\"defs\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"</defs>\\n\");\n                break;\n              }\n            if (LocaleCompare(\"gradient\",token) == 0)\n              {\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"</%sGradient>\\n\",type);\n                (void) WriteBlobString(image,message);\n                break;\n              }\n            if (LocaleCompare(\"graphic-context\",token) == 0)\n              {\n                n--;\n                if (n < 0)\n                  ThrowWriterException(DrawError,\n                    \"UnbalancedGraphicContextPushPop\");\n                (void) WriteBlobString(image,\"</g>\\n\");\n              }\n            if (LocaleCompare(\"pattern\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"</pattern>\\n\");\n                break;\n              }\n            if (LocaleCompare(\"symbol\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"</symbol>\\n\");\n                break;\n              }\n            if ((LocaleCompare(\"defs\",token) == 0) ||\n                (LocaleCompare(\"symbol\",token) == 0))\n              (void) WriteBlobString(image,\"</g>\\n\");\n            break;\n          }\n        if (LocaleCompare(\"push\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (LocaleCompare(\"clip-path\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"<clipPath id=\\\"%s\\\">\\n\",token);\n                (void) WriteBlobString(image,message);\n                break;\n              }\n            if (LocaleCompare(\"defs\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"<defs>\\n\");\n                break;\n              }\n            if (LocaleCompare(\"gradient\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(name,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(type,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                svg_info.segment.x1=StringToDouble(token,&next_token);\n                svg_info.element.cx=StringToDouble(token,&next_token);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.segment.y1=StringToDouble(token,&next_token);\n                svg_info.element.cy=StringToDouble(token,&next_token);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.segment.x2=StringToDouble(token,&next_token);\n                svg_info.element.major=StringToDouble(token,\n                  (char **) NULL);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.segment.y2=StringToDouble(token,&next_token);\n                svg_info.element.minor=StringToDouble(token,\n                  (char **) NULL);\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"<%sGradient id=\\\"%s\\\" x1=\\\"%g\\\" y1=\\\"%g\\\" x2=\\\"%g\\\" \"\n                  \"y2=\\\"%g\\\">\\n\",type,name,svg_info.segment.x1,\n                  svg_info.segment.y1,svg_info.segment.x2,svg_info.segment.y2);\n                if (LocaleCompare(type,\"radial\") == 0)\n                  {\n                    (void) GetNextToken(q,&q,extent,token);\n                    if (*token == ',')\n                      (void) GetNextToken(q,&q,extent,token);\n                    svg_info.element.angle=StringToDouble(token,\n                      (char **) NULL);\n                    (void) FormatLocaleString(message,MagickPathExtent,\n                      \"<%sGradient id=\\\"%s\\\" cx=\\\"%g\\\" cy=\\\"%g\\\" r=\\\"%g\\\" \"\n                      \"fx=\\\"%g\\\" fy=\\\"%g\\\">\\n\",type,name,\n                      svg_info.element.cx,svg_info.element.cy,\n                      svg_info.element.angle,svg_info.element.major,\n                      svg_info.element.minor);\n                  }\n                (void) WriteBlobString(image,message);\n                break;\n              }\n            if (LocaleCompare(\"graphic-context\",token) == 0)\n              {\n                n++;\n                if (active)\n                  {\n                    AffineToTransform(image,&affine);\n                    active=MagickFalse;\n                  }\n                (void) WriteBlobString(image,\"<g style=\\\"\");\n                active=MagickTrue;\n              }\n            if (LocaleCompare(\"pattern\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(name,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                svg_info.bounds.x=StringToDouble(token,&next_token);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.bounds.y=StringToDouble(token,&next_token);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.bounds.width=StringToDouble(token,\n                  (char **) NULL);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.bounds.height=StringToDouble(token,(char **) NULL);\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"<pattern id=\\\"%s\\\" x=\\\"%g\\\" y=\\\"%g\\\" width=\\\"%g\\\" \"\n                  \"height=\\\"%g\\\">\\n\",name,svg_info.bounds.x,svg_info.bounds.y,\n                  svg_info.bounds.width,svg_info.bounds.height);\n                (void) WriteBlobString(image,message);\n                break;\n              }\n            if (LocaleCompare(\"symbol\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"<symbol>\\n\");\n                break;\n              }\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'r':\n      case 'R':\n      {\n        if (LocaleCompare(\"rectangle\",keyword) == 0)\n          {\n            primitive_type=RectanglePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"roundRectangle\",keyword) == 0)\n          {\n            primitive_type=RoundRectanglePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"rotate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"rotate(%s) \",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 's':\n      case 'S':\n      {\n        if (LocaleCompare(\"scale\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.sx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.sy=StringToDouble(token,&next_token);\n            break;\n          }\n        if (LocaleCompare(\"skewX\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"skewX(%s) \",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"skewY\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"skewY(%s) \",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stop-color\",keyword) == 0)\n          {\n            char\n              color[MagickPathExtent];\n\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CopyMagickString(color,token,MagickPathExtent);\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"  <stop offset=\\\"%s\\\" stop-color=\\\"%s\\\" />\\n\",token,color);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"stroke:%s;\",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-antialias\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-antialias:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-dasharray\",keyword) == 0)\n          {\n            if (IsPoint(q))\n              {\n                ssize_t\n                  k;\n\n                p=q;\n                (void) GetNextToken(p,&p,extent,token);\n                for (k=0; IsPoint(token); k++)\n                  (void) GetNextToken(p,&p,extent,token);\n                (void) WriteBlobString(image,\"stroke-dasharray:\");\n                for (j=0; j < k; j++)\n                {\n                  (void) GetNextToken(q,&q,extent,token);\n                  (void) FormatLocaleString(message,MagickPathExtent,\"%s \",\n                    token);\n                  (void) WriteBlobString(image,message);\n                }\n                (void) WriteBlobString(image,\";\");\n                break;\n              }\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-dasharray:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-dashoffset\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-dashoffset:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-linecap\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-linecap:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-linejoin\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-linejoin:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-miterlimit\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-miterlimit:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-opacity\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-opacity:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-width\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-width:%s;\",token);\n            (void) WriteBlobString(image,message);\n            continue;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 't':\n      case 'T':\n      {\n        if (LocaleCompare(\"text\",keyword) == 0)\n          {\n            primitive_type=TextPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"text-antialias\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"text-antialias:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"tspan\",keyword) == 0)\n          {\n            primitive_type=TextPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"translate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.tx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ty=StringToDouble(token,&next_token);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'v':\n      case 'V':\n      {\n        if (LocaleCompare(\"viewbox\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      default:\n      {\n        status=MagickFalse;\n        break;\n      }\n    }\n    if (status == MagickFalse)\n      break;\n    if (primitive_type == UndefinedPrimitive)\n      continue;\n    /*\n      Parse the primitive attributes.\n    */\n    i=0;\n    j=0;\n    for (x=0; *q != '\\0'; x++)\n    {\n      /*\n        Define points.\n      */\n      if (IsPoint(q) == MagickFalse)\n        break;\n      (void) GetNextToken(q,&q,extent,token);\n      point.x=StringToDouble(token,&next_token);\n      (void) GetNextToken(q,&q,extent,token);\n      if (*token == ',')\n        (void) GetNextToken(q,&q,extent,token);\n      point.y=StringToDouble(token,&next_token);\n      (void) GetNextToken(q,(const char **) NULL,extent,token);\n      if (*token == ',')\n        (void) GetNextToken(q,&q,extent,token);\n      primitive_info[i].primitive=primitive_type;\n      primitive_info[i].point=point;\n      primitive_info[i].coordinates=0;\n      primitive_info[i].method=FloodfillMethod;\n      i++;\n      if (i < (ssize_t) (number_points-6*BezierQuantum-360))\n        continue;\n      number_points+=6*BezierQuantum+360;\n      primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,\n        number_points,sizeof(*primitive_info));\n      if (primitive_info == (PrimitiveInfo *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          break;\n        }\n    }\n    primitive_info[j].primitive=primitive_type;\n    primitive_info[j].coordinates=(size_t) x;\n    primitive_info[j].method=FloodfillMethod;\n    primitive_info[j].text=(char *) NULL;\n    if (active)\n      {\n        AffineToTransform(image,&affine);\n        active=MagickFalse;\n      }\n    active=MagickFalse;\n    switch (primitive_type)\n    {\n      case PointPrimitive:\n      default:\n      {\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        break;\n      }\n      case LinePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n          (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <line x1=\\\"%g\\\" y1=\\\"%g\\\" x2=\\\"%g\\\" y2=\\\"%g\\\"/>\\n\",\n          primitive_info[j].point.x,primitive_info[j].point.y,\n          primitive_info[j+1].point.x,primitive_info[j+1].point.y);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case RectanglePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n          (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <rect x=\\\"%g\\\" y=\\\"%g\\\" width=\\\"%g\\\" height=\\\"%g\\\"/>\\n\",\n          primitive_info[j].point.x,primitive_info[j].point.y,\n          primitive_info[j+1].point.x-primitive_info[j].point.x,\n          primitive_info[j+1].point.y-primitive_info[j].point.y);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case RoundRectanglePrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <rect x=\\\"%g\\\" y=\\\"%g\\\" width=\\\"%g\\\" height=\\\"%g\\\" rx=\\\"%g\\\" \"\n          \"ry=\\\"%g\\\"/>\\n\",primitive_info[j].point.x,\n          primitive_info[j].point.y,primitive_info[j+1].point.x-\n          primitive_info[j].point.x,primitive_info[j+1].point.y-\n          primitive_info[j].point.y,primitive_info[j+2].point.x,\n          primitive_info[j+2].point.y);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case ArcPrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        break;\n      }\n      case EllipsePrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n          (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <ellipse cx=\\\"%g\\\" cy=\\\"%g\\\" rx=\\\"%g\\\" ry=\\\"%g\\\"/>\\n\",\n          primitive_info[j].point.x,primitive_info[j].point.y,\n          primitive_info[j+1].point.x,primitive_info[j+1].point.y);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case CirclePrimitive:\n      {\n        double\n          alpha,\n          beta;\n\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        alpha=primitive_info[j+1].point.x-primitive_info[j].point.x;\n        beta=primitive_info[j+1].point.y-primitive_info[j].point.y;\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <circle cx=\\\"%g\\\" cy=\\\"%g\\\" r=\\\"%g\\\"/>\\n\",\n          primitive_info[j].point.x,primitive_info[j].point.y,\n          hypot(alpha,beta));\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case PolylinePrimitive:\n      {\n        if (primitive_info[j].coordinates < 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) CopyMagickString(message,\"  <polyline points=\\\"\",\n           MagickPathExtent);\n        (void) WriteBlobString(image,message);\n        length=strlen(message);\n        for ( ; j < i; j++)\n        {\n          (void) FormatLocaleString(message,MagickPathExtent,\"%g,%g \",\n            primitive_info[j].point.x,primitive_info[j].point.y);\n          length+=strlen(message);\n          if (length >= 80)\n            {\n              (void) WriteBlobString(image,\"\\n    \");\n              length=strlen(message)+5;\n            }\n          (void) WriteBlobString(image,message);\n        }\n        (void) WriteBlobString(image,\"\\\"/>\\n\");\n        break;\n      }\n      case PolygonPrimitive:\n      {\n        if (primitive_info[j].coordinates < 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        primitive_info[i]=primitive_info[j];\n        primitive_info[i].coordinates=0;\n        primitive_info[j].coordinates++;\n        i++;\n        (void) CopyMagickString(message,\"  <polygon points=\\\"\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,message);\n        length=strlen(message);\n        for ( ; j < i; j++)\n        {\n          (void) FormatLocaleString(message,MagickPathExtent,\"%g,%g \",\n            primitive_info[j].point.x,primitive_info[j].point.y);\n          length+=strlen(message);\n          if (length >= 80)\n            {\n              (void) WriteBlobString(image,\"\\n    \");\n              length=strlen(message)+5;\n            }\n          (void) WriteBlobString(image,message);\n        }\n        (void) WriteBlobString(image,\"\\\"/>\\n\");\n        break;\n      }\n      case BezierPrimitive:\n      {\n        if (primitive_info[j].coordinates < 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        break;\n      }\n      case PathPrimitive:\n      {\n        int\n          number_attributes;\n\n        (void) GetNextToken(q,&q,extent,token);\n        number_attributes=1;\n        for (p=token; *p != '\\0'; p++)\n          if (isalpha((int) ((unsigned char) *p)) != 0)\n            number_attributes++;\n        if (i > (ssize_t) (number_points-6*BezierQuantum*number_attributes-1))\n          {\n            number_points+=6*BezierQuantum*number_attributes;\n            primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,\n              number_points,sizeof(*primitive_info));\n            if (primitive_info == (PrimitiveInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                  image->filename);\n                break;\n              }\n          }\n        (void) WriteBlobString(image,\"  <path d=\\\"\");\n        (void) WriteBlobString(image,token);\n        (void) WriteBlobString(image,\"\\\"/>\\n\");\n        break;\n      }\n      case AlphaPrimitive:\n      case ColorPrimitive:\n      {\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        if (LocaleCompare(\"point\",token) == 0)\n          primitive_info[j].method=PointMethod;\n        if (LocaleCompare(\"replace\",token) == 0)\n          primitive_info[j].method=ReplaceMethod;\n        if (LocaleCompare(\"floodfill\",token) == 0)\n          primitive_info[j].method=FloodfillMethod;\n        if (LocaleCompare(\"filltoborder\",token) == 0)\n          primitive_info[j].method=FillToBorderMethod;\n        if (LocaleCompare(\"reset\",token) == 0)\n          primitive_info[j].method=ResetMethod;\n        break;\n      }\n      case TextPrimitive:\n      {\n        register char\n          *p;\n\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <text x=\\\"%g\\\" y=\\\"%g\\\">\",primitive_info[j].point.x,\n          primitive_info[j].point.y);\n        (void) WriteBlobString(image,message);\n        for (p=token; *p != '\\0'; p++)\n          switch (*p)\n          {\n            case '<': (void) WriteBlobString(image,\"&lt;\"); break;\n            case '>': (void) WriteBlobString(image,\"&gt;\"); break;\n            case '&': (void) WriteBlobString(image,\"&amp;\"); break;\n            default: (void) WriteBlobByte(image,(unsigned char) *p); break;\n          }\n        (void) WriteBlobString(image,\"</text>\\n\");\n        break;\n      }\n      case ImagePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <image x=\\\"%g\\\" y=\\\"%g\\\" width=\\\"%g\\\" height=\\\"%g\\\" \"\n          \"href=\\\"%s\\\"/>\\n\",primitive_info[j].point.x,\n          primitive_info[j].point.y,primitive_info[j+1].point.x,\n          primitive_info[j+1].point.y,token);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n    }\n    if (primitive_info == (PrimitiveInfo *) NULL)\n      break;\n    primitive_info[i].primitive=UndefinedPrimitive;\n    if (status == MagickFalse)\n      break;\n  }\n  (void) WriteBlobString(image,\"</svg>\\n\");\n  /*\n    Relinquish resources.\n  */\n  token=DestroyString(token);\n  if (primitive_info != (PrimitiveInfo *) NULL)\n    primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            SSSSS  V   V   GGGG                              %\n%                            SS     V   V  G                                  %\n%                             SSS   V   V  G GG                               %\n%                               SS   V V   G   G                              %\n%                            SSSSS    V     GGG                               %\n%                                                                             %\n%                                                                             %\n%                  Read/Write Scalable Vector Graphics Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                             William Radcliffe                               %\n%                                March 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/delegate-private.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n\n#if defined(MAGICKCORE_XML_DELEGATE)\n#  if defined(MAGICKCORE_WINDOWS_SUPPORT)\n#    if !defined(__MINGW32__)\n#      include <win32config.h>\n#    endif\n#  endif\n#  include <libxml/xmlmemory.h>\n#  include <libxml/parserInternals.h>\n#  include <libxml/xmlerror.h>\n#endif\n\n#if defined(MAGICKCORE_AUTOTRACE_DELEGATE)\n#include \"autotrace/autotrace.h\"\n#endif\n\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#include \"librsvg/rsvg.h\"\n#if !defined(LIBRSVG_CHECK_VERSION)\n#include \"librsvg/rsvg-cairo.h\"\n#include \"librsvg/librsvg-features.h\"\n#elif !LIBRSVG_CHECK_VERSION(2,36,2)\n#include \"librsvg/rsvg-cairo.h\"\n#include \"librsvg/librsvg-features.h\"\n#endif\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define DefaultSVGDensity  96.0\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _BoundingBox\n{\n  double\n    x,\n    y,\n    width,\n    height;\n} BoundingBox;\n\ntypedef struct _ElementInfo\n{\n  double\n    cx,\n    cy,\n    major,\n    minor,\n    angle;\n} ElementInfo;\n\ntypedef struct _SVGInfo\n{\n  FILE\n    *file;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  const ImageInfo\n    *image_info;\n\n  AffineMatrix\n    affine;\n\n  size_t\n    width,\n    height;\n\n  char\n    *size,\n    *title,\n    *comment;\n\n  int\n    n;\n\n  double\n    *scale,\n    pointsize;\n\n  ElementInfo\n    element;\n\n  SegmentInfo\n    segment;\n\n  BoundingBox\n    bounds,\n    text_offset,\n    view_box;\n\n  PointInfo\n    radius;\n\n  char\n    *stop_color,\n    *offset,\n    *text,\n    *vertices,\n    *url;\n\n#if defined(MAGICKCORE_XML_DELEGATE)\n  xmlParserCtxtPtr\n    parser;\n\n  xmlDocPtr\n    document;\n#endif\n\n  ssize_t\n    svgDepth;\n} SVGInfo;\n\f\n/*\n  Static declarations.\n*/\nstatic char\n  SVGDensityGeometry[] = \"96.0x96.0\";\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSVGImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S V G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSVG()() returns MagickTrue if the image format type, identified by the\n%  magick string, is SVG.\n%\n%  The format of the IsSVG method is:\n%\n%      MagickBooleanType IsSVG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSVG(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick+1,\"svg\",3) == 0)\n    return(MagickTrue);\n  if (length < 5)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick+1,\"?xml\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S V G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSVGImage() reads a Scalable Vector Gaphics file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadSVGImage method is:\n%\n%      Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *RenderSVGImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    background[MagickPathExtent],\n    command[MagickPathExtent],\n    *density,\n    input_filename[MagickPathExtent],\n    opacity[MagickPathExtent],\n    output_filename[MagickPathExtent],\n    unique[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *next;\n\n  int\n    status;\n\n  struct stat\n    attributes;\n\n  /*\n    Our best hope for compliance with the SVG standard.\n  */\n  delegate_info=GetDelegateInfo(\"svg:decode\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    return((Image *) NULL);\n  status=AcquireUniqueSymbolicLink(image->filename,input_filename);\n  (void) AcquireUniqueFilename(output_filename);\n  (void) AcquireUniqueFilename(unique);\n  density=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%.20g,%.20g\",\n    image->resolution.x,image->resolution.y);\n  (void) FormatLocaleString(background,MagickPathExtent,\n    \"rgb(%.20g%%,%.20g%%,%.20g%%)\",\n    100.0*QuantumScale*image->background_color.red,\n    100.0*QuantumScale*image->background_color.green,\n    100.0*QuantumScale*image->background_color.blue);\n  (void) FormatLocaleString(opacity,MagickPathExtent,\"%.20g\",QuantumScale*\n    image->background_color.alpha);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),input_filename,output_filename,density,\n    background,opacity,unique);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,image_info->verbose,command,\n    (char *) NULL,exception);\n  (void) RelinquishUniqueFileResource(unique);\n  (void) RelinquishUniqueFileResource(input_filename);\n  if ((status == 0) && (stat(output_filename,&attributes) == 0) &&\n      (attributes.st_size > 0))\n    {\n      Image\n        *svg_image;\n\n      ImageInfo\n        *read_info;\n\n      read_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(read_info->filename,output_filename,\n        MagickPathExtent);\n      svg_image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (svg_image != (Image *) NULL)\n        {\n          (void) RelinquishUniqueFileResource(output_filename);\n          for (next=GetFirstImageInList(svg_image); next != (Image *) NULL; )\n          {\n            (void) CopyMagickString(next->filename,image->filename,\n              MaxTextExtent);\n            (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n            next=GetNextImageInList(next);\n          }\n          return(svg_image);\n        }\n    }\n  (void) RelinquishUniqueFileResource(output_filename);\n  return((Image *) NULL);\n}\n\n#if defined(MAGICKCORE_XML_DELEGATE)\nstatic SVGInfo *AcquireSVGInfo(void)\n{\n  SVGInfo\n    *svg_info;\n\n  svg_info=(SVGInfo *) AcquireMagickMemory(sizeof(*svg_info));\n  if (svg_info == (SVGInfo *) NULL)\n    return((SVGInfo *) NULL);\n  (void) memset(svg_info,0,sizeof(*svg_info));\n  svg_info->text=AcquireString(\"\");\n  svg_info->scale=(double *) AcquireCriticalMemory(sizeof(*svg_info->scale));\n  GetAffineMatrix(&svg_info->affine);\n  svg_info->scale[0]=ExpandAffine(&svg_info->affine);\n  return(svg_info);\n}\n\nstatic SVGInfo *DestroySVGInfo(SVGInfo *svg_info)\n{\n  if (svg_info->text != (char *) NULL)\n    svg_info->text=DestroyString(svg_info->text);\n  if (svg_info->scale != (double *) NULL)\n    svg_info->scale=(double *) RelinquishMagickMemory(svg_info->scale);\n  if (svg_info->title != (char *) NULL)\n    svg_info->title=DestroyString(svg_info->title);\n  if (svg_info->comment != (char *) NULL)\n    svg_info->comment=DestroyString(svg_info->comment);\n  return((SVGInfo *) RelinquishMagickMemory(svg_info));\n}\n\nstatic double GetUserSpaceCoordinateValue(const SVGInfo *svg_info,int type,\n  const char *string)\n{\n  char\n    *next_token,\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    value;\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",string);\n  assert(string != (const char *) NULL);\n  p=(const char *) string;\n  (void) GetNextToken(p,&p,MagickPathExtent,token);\n  value=StringToDouble(token,&next_token);\n  if (strchr(token,'%') != (char *) NULL)\n    {\n      double\n        alpha,\n        beta;\n\n      if (type > 0)\n        {\n          if (svg_info->view_box.width == 0.0)\n            return(0.0);\n          return(svg_info->view_box.width*value/100.0);\n        }\n      if (type < 0)\n        {\n          if (svg_info->view_box.height == 0.0)\n            return(0.0);\n          return(svg_info->view_box.height*value/100.0);\n        }\n      alpha=value-svg_info->view_box.width;\n      beta=value-svg_info->view_box.height;\n      return(hypot(alpha,beta)/sqrt(2.0)/100.0);\n    }\n  (void) GetNextToken(p,&p,MagickPathExtent,token);\n  if (LocaleNCompare(token,\"cm\",2) == 0)\n    return(DefaultSVGDensity*svg_info->scale[0]/2.54*value);\n  if (LocaleNCompare(token,\"em\",2) == 0)\n    return(svg_info->pointsize*value);\n  if (LocaleNCompare(token,\"ex\",2) == 0)\n    return(svg_info->pointsize*value/2.0);\n  if (LocaleNCompare(token,\"in\",2) == 0)\n    return(DefaultSVGDensity*svg_info->scale[0]*value);\n  if (LocaleNCompare(token,\"mm\",2) == 0)\n    return(DefaultSVGDensity*svg_info->scale[0]/25.4*value);\n  if (LocaleNCompare(token,\"pc\",2) == 0)\n    return(DefaultSVGDensity*svg_info->scale[0]/6.0*value);\n  if (LocaleNCompare(token,\"pt\",2) == 0)\n    return(svg_info->scale[0]*value);\n  if (LocaleNCompare(token,\"px\",2) == 0)\n    return(value);\n  return(value);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int SVGIsStandalone(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Is this document tagged standalone?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.SVGIsStandalone()\");\n  svg_info=(SVGInfo *) context;\n  return(svg_info->document->standalone == 1);\n}\n\nstatic int SVGHasInternalSubset(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Does this document has an internal subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.SVGHasInternalSubset()\");\n  svg_info=(SVGInfo *) context;\n  return(svg_info->document->intSubset != NULL);\n}\n\nstatic int SVGHasExternalSubset(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Does this document has an external subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.SVGHasExternalSubset()\");\n  svg_info=(SVGInfo *) context;\n  return(svg_info->document->extSubset != NULL);\n}\n\nstatic void SVGInternalSubset(void *context,const xmlChar *name,\n  const xmlChar *external_id,const xmlChar *system_id)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Does this document has an internal subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.internalSubset(%s, %s, %s)\",(const char *) name,\n    (external_id != (const xmlChar *) NULL ? (const char *) external_id : \"none\"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\"));\n  svg_info=(SVGInfo *) context;\n  (void) xmlCreateIntSubset(svg_info->document,name,external_id,system_id);\n}\n\nstatic xmlParserInputPtr SVGResolveEntity(void *context,\n  const xmlChar *public_id,const xmlChar *system_id)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserInputPtr\n    stream;\n\n  /*\n    Special entity resolver, better left to the parser, it has more\n    context than the application layer.  The default behaviour is to\n    not resolve the entities, in that case the ENTITY_REF nodes are\n    built in the structure (and the parameter values).\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.resolveEntity(%s, %s)\",\n    (public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\"));\n  svg_info=(SVGInfo *) context;\n  stream=xmlLoadExternalEntity((const char *) system_id,(const char *)\n    public_id,svg_info->parser);\n  return(stream);\n}\n\nstatic xmlEntityPtr SVGGetEntity(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Get an entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.SVGGetEntity(%s)\",\n    name);\n  svg_info=(SVGInfo *) context;\n  return(xmlGetDocEntity(svg_info->document,name));\n}\n\nstatic xmlEntityPtr SVGGetParameterEntity(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Get a parameter entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.getParameterEntity(%s)\",name);\n  svg_info=(SVGInfo *) context;\n  return(xmlGetParameterEntity(svg_info->document,name));\n}\n\nstatic void SVGEntityDeclaration(void *context,const xmlChar *name,int type,\n  const xmlChar *public_id,const xmlChar *system_id,xmlChar *content)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    An entity definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.entityDecl(%s, %d, %s, %s, %s)\",name,type,\n    public_id != (xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (xmlChar *) NULL ? (const char *) system_id : \"none\",content);\n  svg_info=(SVGInfo *) context;\n  if (svg_info->parser->inSubset == 1)\n    (void) xmlAddDocEntity(svg_info->document,name,type,public_id,system_id,\n      content);\n  else\n    if (svg_info->parser->inSubset == 2)\n      (void) xmlAddDtdEntity(svg_info->document,name,type,public_id,system_id,\n        content);\n}\n\nstatic void SVGAttributeDeclaration(void *context,const xmlChar *element,\n  const xmlChar *name,int type,int value,const xmlChar *default_value,\n  xmlEnumerationPtr tree)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlChar\n    *fullname,\n    *prefix;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    An attribute definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.attributeDecl(%s, %s, %d, %d, %s, ...)\",element,name,type,value,\n    default_value);\n  svg_info=(SVGInfo *) context;\n  fullname=(xmlChar *) NULL;\n  prefix=(xmlChar *) NULL;\n  parser=svg_info->parser;\n  fullname=(xmlChar *) xmlSplitQName(parser,name,&prefix);\n  if (parser->inSubset == 1)\n    (void) xmlAddAttributeDecl(&parser->vctxt,svg_info->document->intSubset,\n      element,fullname,prefix,(xmlAttributeType) type,\n      (xmlAttributeDefault) value,default_value,tree);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddAttributeDecl(&parser->vctxt,svg_info->document->extSubset,\n        element,fullname,prefix,(xmlAttributeType) type,\n        (xmlAttributeDefault) value,default_value,tree);\n  if (prefix != (xmlChar *) NULL)\n    xmlFree(prefix);\n  if (fullname != (xmlChar *) NULL)\n    xmlFree(fullname);\n}\n\nstatic void SVGElementDeclaration(void *context,const xmlChar *name,int type,\n  xmlElementContentPtr content)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    An element definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.elementDecl(%s, %d, ...)\",name,type);\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  if (parser->inSubset == 1)\n    (void) xmlAddElementDecl(&parser->vctxt,svg_info->document->intSubset,\n      name,(xmlElementTypeVal) type,content);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddElementDecl(&parser->vctxt,svg_info->document->extSubset,\n        name,(xmlElementTypeVal) type,content);\n}\n\nstatic void SVGStripString(const MagickBooleanType trim,char *message)\n{\n  register char\n    *p,\n    *q;\n\n  size_t\n    length;\n\n  assert(message != (char *) NULL);\n  if (*message == '\\0')\n    return;\n  /*\n    Remove comment.\n  */\n  q=message;\n  for (p=message; *p != '\\0'; p++)\n  {\n    if ((*p == '/') && (*(p+1) == '*'))\n      {\n        for ( ; *p != '\\0'; p++)\n          if ((*p == '*') && (*(p+1) == '/'))\n            {\n              p+=2;\n              break;\n            }\n        if (*p == '\\0')\n          break;\n      }\n    *q++=(*p);\n  }\n  *q='\\0';\n  length=strlen(message);\n  if ((trim != MagickFalse) && (length != 0))\n    {\n      /*\n        Remove whitespace.\n      */\n      p=message;\n      while (isspace((int) ((unsigned char) *p)) != 0)\n        p++;\n      if ((*p == '\\'') || (*p == '\"'))\n        p++;\n      q=message+length-1;\n      while ((isspace((int) ((unsigned char) *q)) != 0) && (q > p))\n        q--;\n      if (q > p)\n        if ((*q == '\\'') || (*q == '\"'))\n          q--;\n      (void) memmove(message,p,(size_t) (q-p+1));\n      message[q-p+1]='\\0';\n    }\n  /*\n    Convert newlines to a space.\n  */\n  for (p=message; *p != '\\0'; p++)\n    if (*p == '\\n')\n      *p=' ';\n}\n\nstatic char **SVGKeyValuePairs(void *context,const int key_sentinel,\n  const int value_sentinel,const char *text,size_t *number_tokens)\n{\n  char\n    **tokens;\n\n  register const char\n    *p,\n    *q;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  SVGInfo\n    *svg_info;\n\n  svg_info=(SVGInfo *) context;\n  *number_tokens=0;\n  if (text == (const char *) NULL)\n    return((char **) NULL);\n  extent=8;\n  tokens=(char **) AcquireQuantumMemory(extent+2UL,sizeof(*tokens));\n  if (tokens == (char **) NULL)\n    {\n      (void) ThrowMagickException(svg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",text);\n      return((char **) NULL);\n    }\n  /*\n    Convert string to an ASCII list.\n  */\n  i=0;\n  p=text;\n  for (q=p; *q != '\\0'; q++)\n  {\n    if ((*q != key_sentinel) && (*q != value_sentinel) && (*q != '\\0'))\n      continue;\n    if (i == (ssize_t) extent)\n      {\n        extent<<=1;\n        tokens=(char **) ResizeQuantumMemory(tokens,extent+2,sizeof(*tokens));\n        if (tokens == (char **) NULL)\n          {\n            (void) ThrowMagickException(svg_info->exception,GetMagickModule(),\n              ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",text);\n            return((char **) NULL);\n          }\n      }\n    tokens[i]=AcquireString(p);\n    (void) CopyMagickString(tokens[i],p,(size_t) (q-p+1));\n    SVGStripString(MagickTrue,tokens[i]);\n    i++;\n    p=q+1;\n  }\n  tokens[i]=AcquireString(p);\n  (void) CopyMagickString(tokens[i],p,(size_t) (q-p+1));\n  SVGStripString(MagickTrue,tokens[i++]);\n  tokens[i]=(char *) NULL;\n  *number_tokens=(size_t) i;\n  return(tokens);\n}\n\nstatic void SVGNotationDeclaration(void *context,const xmlChar *name,\n  const xmlChar *public_id,const xmlChar *system_id)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    What to do when a notation declaration has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.notationDecl(%s, %s, %s)\",name,\n    public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\");\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  if (parser->inSubset == 1)\n    (void) xmlAddNotationDecl(&parser->vctxt,svg_info->document->intSubset,\n      name,public_id,system_id);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddNotationDecl(&parser->vctxt,svg_info->document->intSubset,\n        name,public_id,system_id);\n}\n\nstatic void SVGProcessStyleElement(void *context,const xmlChar *name,\n  const char *style)\n{\n  char\n    background[MagickPathExtent],\n    *color,\n    *keyword,\n    *units,\n    *value;\n\n  char\n    **tokens;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_tokens;\n\n  SVGInfo\n    *svg_info;\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  \");\n  svg_info=(SVGInfo *) context;\n  tokens=SVGKeyValuePairs(context,':',';',style,&number_tokens);\n  if (tokens == (char **) NULL)\n    return;\n  for (i=0; i < (ssize_t) (number_tokens-1); i+=2)\n  {\n    keyword=(char *) tokens[i];\n    value=(char *) tokens[i+1];\n    if (LocaleCompare(keyword,\"font-size\") != 0)\n      continue;\n    svg_info->pointsize=GetUserSpaceCoordinateValue(svg_info,0,value);\n    (void) FormatLocaleFile(svg_info->file,\"font-size %g\\n\",\n      svg_info->pointsize);\n  }\n  color=AcquireString(\"none\");\n  units=AcquireString(\"userSpaceOnUse\");\n  for (i=0; i < (ssize_t) (number_tokens-1); i+=2)\n  {\n    keyword=(char *) tokens[i];\n    value=(char *) tokens[i+1];\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    %s: %s\",keyword,\n      value);\n    switch (*keyword)\n    {\n      case 'B':\n      case 'b':\n      {\n        if (LocaleCompare((const char *) name,\"background\") == 0)\n          {\n            if (LocaleCompare((const char *) name,\"svg\") == 0)\n              (void) CopyMagickString(background,value,MagickPathExtent);\n            break;\n          }\n        break;\n      }\n      case 'C':\n      case 'c':\n      {\n         if (LocaleCompare(keyword,\"clip-path\") == 0)\n           {\n             (void) FormatLocaleFile(svg_info->file,\"clip-path \\\"%s\\\"\\n\",value);\n             break;\n           }\n        if (LocaleCompare(keyword,\"clip-rule\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"clip-rule \\\"%s\\\"\\n\",value);\n            break;\n          }\n         if (LocaleCompare(keyword,\"clipPathUnits\") == 0)\n           {\n             (void) CloneString(&units,value);\n             (void) FormatLocaleFile(svg_info->file,\"clip-units \\\"%s\\\"\\n\",\n               value);\n             break;\n           }\n        if (LocaleCompare(keyword,\"color\") == 0)\n          {\n            (void) CloneString(&color,value);\n            break;\n          }\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(keyword,\"fill\") == 0)\n          {\n             if (LocaleCompare(value,\"currentColor\") == 0)\n               {\n                 (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",color);\n                 break;\n               }\n            if (LocaleCompare(value,\"#000000ff\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"fill '#000000'\\n\");\n            else\n              (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"fillcolor\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"fill-rule\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"fill-rule \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"fill-opacity\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"fill-opacity \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font\") == 0)\n          {\n            char\n              family[MagickPathExtent],\n              size[MagickPathExtent],\n              style[MagickPathExtent];\n\n            if (sscanf(value,\"%2048s %2048s %2048s\",style,size,family) != 3)\n              break;\n            if (GetUserSpaceCoordinateValue(svg_info,0,style) == 0)\n              (void) FormatLocaleFile(svg_info->file,\"font-style \\\"%s\\\"\\n\",\n                style);\n            else\n              if (sscanf(value,\"%2048s %2048s\",size,family) != 2)\n                break;\n            (void) FormatLocaleFile(svg_info->file,\"font-size \\\"%s\\\"\\n\",size);\n            (void) FormatLocaleFile(svg_info->file,\"font-family \\\"%s\\\"\\n\",\n              family);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-family\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"font-family \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-stretch\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"font-stretch \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-style\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"font-style \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-size\") == 0)\n          {\n            svg_info->pointsize=GetUserSpaceCoordinateValue(svg_info,0,value);\n            (void) FormatLocaleFile(svg_info->file,\"font-size %g\\n\",\n              svg_info->pointsize);\n            break;\n          }\n        if (LocaleCompare(keyword,\"font-weight\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"font-weight \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        break;\n      }\n      case 'K':\n      case 'k':\n      {\n        if (LocaleCompare(keyword,\"kerning\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"kerning \\\"%s\\\"\\n\",value);\n            break;\n          }\n        break;\n      }\n      case 'L':\n      case 'l':\n      {\n        if (LocaleCompare(keyword,\"letter-spacing\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"letter-spacing \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        break;\n      }\n      case 'M':\n      case 'm':\n      {\n        if (LocaleCompare(keyword,\"mask\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"mask \\\"%s\\\"\\n\",value);\n            break;\n          }\n        break;\n      }\n      case 'O':\n      case 'o':\n      {\n        if (LocaleCompare(keyword,\"offset\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"offset %g\\n\",\n              GetUserSpaceCoordinateValue(svg_info,1,value));\n            break;\n          }\n        if (LocaleCompare(keyword,\"opacity\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"opacity \\\"%s\\\"\\n\",value);\n            break;\n          }\n        break;\n      }\n      case 'S':\n      case 's':\n      {\n        if (LocaleCompare(keyword,\"stop-color\") == 0)\n          {\n            (void) CloneString(&svg_info->stop_color,value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke\") == 0)\n          {\n            if (LocaleCompare(value,\"currentColor\") == 0)\n              {\n                (void) FormatLocaleFile(svg_info->file,\"stroke \\\"%s\\\"\\n\",color);\n                break;\n              }\n            if (LocaleCompare(value,\"#000000ff\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"fill '#000000'\\n\");\n            else\n              (void) FormatLocaleFile(svg_info->file,\n                \"stroke \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-antialiasing\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-antialias %d\\n\",\n              LocaleCompare(value,\"true\") == 0);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-dasharray\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-dasharray %s\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-dashoffset\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-dashoffset %g\\n\",\n              GetUserSpaceCoordinateValue(svg_info,1,value));\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-linecap\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-linecap \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-linejoin\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-linejoin \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-miterlimit\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-miterlimit \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-opacity\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-opacity \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"stroke-width\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"stroke-width %g\\n\",\n              GetUserSpaceCoordinateValue(svg_info,1,value));\n            break;\n          }\n        break;\n      }\n      case 't':\n      case 'T':\n      {\n        if (LocaleCompare(keyword,\"text-align\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"text-align \\\"%s\\\"\\n\",value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"text-anchor\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"text-anchor \\\"%s\\\"\\n\",\n              value);\n            break;\n          }\n        if (LocaleCompare(keyword,\"text-decoration\") == 0)\n          {\n            if (LocaleCompare(value,\"underline\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"decorate underline\\n\");\n            if (LocaleCompare(value,\"line-through\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"decorate line-through\\n\");\n            if (LocaleCompare(value,\"overline\") == 0)\n              (void) FormatLocaleFile(svg_info->file,\"decorate overline\\n\");\n            break;\n          }\n        if (LocaleCompare(keyword,\"text-antialiasing\") == 0)\n          {\n            (void) FormatLocaleFile(svg_info->file,\"text-antialias %d\\n\",\n              LocaleCompare(value,\"true\") == 0);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  if (units != (char *) NULL)\n    units=DestroyString(units);\n  if (color != (char *) NULL)\n    color=DestroyString(color);\n  for (i=0; tokens[i] != (char *) NULL; i++)\n    tokens[i]=DestroyString(tokens[i]);\n  tokens=(char **) RelinquishMagickMemory(tokens);\n}\n\nstatic void SVGUnparsedEntityDeclaration(void *context,const xmlChar *name,\n  const xmlChar *public_id,const xmlChar *system_id,const xmlChar *notation)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    What to do when an unparsed entity declaration is parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.unparsedEntityDecl(%s, %s, %s, %s)\",name,\n    public_id != (xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (xmlChar *) NULL ? (const char *) system_id : \"none\",notation);\n  svg_info=(SVGInfo *) context;\n  (void) xmlAddDocEntity(svg_info->document,name,\n    XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,public_id,system_id,notation);\n\n}\n\nstatic void SVGSetDocumentLocator(void *context,xmlSAXLocatorPtr location)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Receive the document locator at startup, actually xmlDefaultSAXLocator.\n  */\n  (void) location;\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.setDocumentLocator()\");\n  svg_info=(SVGInfo *) context;\n  (void) svg_info;\n}\n\nstatic void SVGStartDocument(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when the document start being processed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.startDocument()\");\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  svg_info->document=xmlNewDoc(parser->version);\n  if (svg_info->document == (xmlDocPtr) NULL)\n    return;\n  if (parser->encoding == NULL)\n    svg_info->document->encoding=(const xmlChar *) NULL;\n  else\n    svg_info->document->encoding=xmlStrdup(parser->encoding);\n  svg_info->document->standalone=parser->standalone;\n}\n\nstatic void SVGEndDocument(void *context)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when the document end has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.endDocument()\");\n  svg_info=(SVGInfo *) context;\n  if (svg_info->offset != (char *) NULL)\n    svg_info->offset=DestroyString(svg_info->offset);\n  if (svg_info->stop_color != (char *) NULL)\n    svg_info->stop_color=DestroyString(svg_info->stop_color);\n  if (svg_info->scale != (double *) NULL)\n    svg_info->scale=(double *) RelinquishMagickMemory(svg_info->scale);\n  if (svg_info->text != (char *) NULL)\n    svg_info->text=DestroyString(svg_info->text);\n  if (svg_info->vertices != (char *) NULL)\n    svg_info->vertices=DestroyString(svg_info->vertices);\n  if (svg_info->url != (char *) NULL)\n    svg_info->url=DestroyString(svg_info->url);\n#if defined(MAGICKCORE_XML_DELEGATE)\n  if (svg_info->document != (xmlDocPtr) NULL)\n    {\n      xmlFreeDoc(svg_info->document);\n      svg_info->document=(xmlDocPtr) NULL;\n    }\n#endif\n}\n\nstatic void SVGStartElement(void *context,const xmlChar *name,\n  const xmlChar **attributes)\n{\n#define PushGraphicContext(id) \\\n{ \\\n  if (*id == '\\0') \\\n    (void) FormatLocaleFile(svg_info->file,\"push graphic-context\\n\"); \\\n  else \\\n    (void) FormatLocaleFile(svg_info->file,\"push graphic-context \\\"%s\\\"\\n\", \\\n      id); \\\n}\n\n  char\n    *color,\n    background[MagickPathExtent],\n    id[MagickPathExtent],\n    *next_token,\n    token[MagickPathExtent],\n    **tokens,\n    *units;\n\n  const char\n    *keyword,\n    *p,\n    *value;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    number_tokens;\n\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when an opening tag has been processed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.startElement(%s\",\n    name);\n  svg_info=(SVGInfo *) context;\n  svg_info->n++;\n  svg_info->scale=(double *) ResizeQuantumMemory(svg_info->scale,\n    svg_info->n+1UL,sizeof(*svg_info->scale));\n  if (svg_info->scale == (double *) NULL)\n    {\n      (void) ThrowMagickException(svg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",name);\n      return;\n    }\n  svg_info->scale[svg_info->n]=svg_info->scale[svg_info->n-1];\n  color=AcquireString(\"none\");\n  units=AcquireString(\"userSpaceOnUse\");\n  *id='\\0';\n  *token='\\0';\n  *background='\\0';\n  value=(const char *) NULL;\n  if ((LocaleCompare((char *) name,\"image\") == 0) ||\n      (LocaleCompare((char *) name,\"pattern\") == 0) ||\n      (LocaleCompare((char *) name,\"rect\") == 0) ||\n      (LocaleCompare((char *) name,\"text\") == 0) ||\n      (LocaleCompare((char *) name,\"use\") == 0))\n    {\n      svg_info->bounds.x=0.0;\n      svg_info->bounds.y=0.0;\n    }\n  if (attributes != (const xmlChar **) NULL)\n    for (i=0; (attributes[i] != (const xmlChar *) NULL); i+=2)\n    {\n      keyword=(const char *) attributes[i];\n      value=(const char *) attributes[i+1];\n      switch (*keyword)\n      {\n        case 'C':\n        case 'c':\n        {\n          if (LocaleCompare(keyword,\"cx\") == 0)\n            {\n              svg_info->element.cx=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"cy\") == 0)\n            {\n              svg_info->element.cy=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'F':\n        case 'f':\n        {\n          if (LocaleCompare(keyword,\"fx\") == 0)\n            {\n              svg_info->element.major=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"fy\") == 0)\n            {\n              svg_info->element.minor=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'H':\n        case 'h':\n        {\n          if (LocaleCompare(keyword,\"height\") == 0)\n            {\n              svg_info->bounds.height=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'I':\n        case 'i':\n        {\n          if (LocaleCompare(keyword,\"id\") == 0)\n            {\n              (void) CopyMagickString(id,value,MagickPathExtent);\n              break;\n            }\n          break;\n        }\n        case 'R':\n        case 'r':\n        {\n          if (LocaleCompare(keyword,\"r\") == 0)\n            {\n              svg_info->element.angle=\n                GetUserSpaceCoordinateValue(svg_info,0,value);\n              break;\n            }\n          break;\n        }\n        case 'W':\n        case 'w':\n        {\n          if (LocaleCompare(keyword,\"width\") == 0)\n            {\n              svg_info->bounds.width=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          break;\n        }\n        case 'X':\n        case 'x':\n        {\n          if (LocaleCompare(keyword,\"x\") == 0)\n            {\n              svg_info->bounds.x=GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"x1\") == 0)\n            {\n              svg_info->segment.x1=GetUserSpaceCoordinateValue(svg_info,1,\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"x2\") == 0)\n            {\n              svg_info->segment.x2=GetUserSpaceCoordinateValue(svg_info,1,\n                value);\n              break;\n            }\n          break;\n        }\n        case 'Y':\n        case 'y':\n        {\n          if (LocaleCompare(keyword,\"y\") == 0)\n            {\n              svg_info->bounds.y=GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"y1\") == 0)\n            {\n              svg_info->segment.y1=GetUserSpaceCoordinateValue(svg_info,-1,\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"y2\") == 0)\n            {\n              svg_info->segment.y2=GetUserSpaceCoordinateValue(svg_info,-1,\n                value);\n              break;\n            }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  if (strchr((char *) name,':') != (char *) NULL)\n    {\n      /*\n        Skip over namespace.\n      */\n      for ( ; *name != ':'; name++) ;\n      name++;\n    }\n  switch (*name)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) name,\"circle\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"clipPath\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"push clip-path \\\"%s\\\"\\n\",id);\n          break;\n        }\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) name,\"defs\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"push defs\\n\");\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) name,\"foreignObject\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) name,\"g\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) name,\"image\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) name,\"line\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"linearGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"push gradient \\\"%s\\\" linear %g,%g %g,%g\\n\",id,\n            svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2,\n            svg_info->segment.y2);\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) name,\"mask\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"push mask \\\"%s\\\"\\n\",id);\n          break;\n        }\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) name,\"path\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"pattern\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"push pattern \\\"%s\\\" %g,%g %g,%g\\n\",id,\n            svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.width,\n            svg_info->bounds.height);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polygon\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polyline\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) name,\"radialGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"push gradient \\\"%s\\\" radial %g,%g %g,%g %g\\n\",\n            id,svg_info->element.cx,svg_info->element.cy,\n            svg_info->element.major,svg_info->element.minor,\n            svg_info->element.angle);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"rect\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((char *) name,\"style\") == 0)\n        break;\n      if (LocaleCompare((const char *) name,\"svg\") == 0)\n        {\n          svg_info->svgDepth++;\n          PushGraphicContext(id);\n          (void) FormatLocaleFile(svg_info->file,\"compliance \\\"SVG\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"fill \\\"black\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"fill-opacity 1\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"stroke \\\"none\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"stroke-width 1\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"stroke-opacity 1\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"fill-rule nonzero\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"symbol\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"push symbol\\n\");\n          break;\n        }\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) name,\"text\") == 0)\n        {\n          PushGraphicContext(id);\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"text\\\"\\n\");\n          svg_info->text_offset.x=svg_info->bounds.x;\n          svg_info->text_offset.y=svg_info->bounds.y;\n          svg_info->bounds.x=0.0;\n          svg_info->bounds.y=0.0;\n          svg_info->bounds.width=0.0;\n          svg_info->bounds.height=0.0;\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"tspan\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->text_offset.x,svg_info->text_offset.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare((char *) name,\"use\") == 0)\n        {\n          PushGraphicContext(id);\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  if (attributes != (const xmlChar **) NULL)\n    for (i=0; (attributes[i] != (const xmlChar *) NULL); i+=2)\n    {\n      keyword=(const char *) attributes[i];\n      value=(const char *) attributes[i+1];\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    %s = %s\",keyword,value);\n      switch (*keyword)\n      {\n        case 'A':\n        case 'a':\n        {\n          if (LocaleCompare(keyword,\"angle\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"angle %g\\n\",\n                GetUserSpaceCoordinateValue(svg_info,0,value));\n              break;\n            }\n          break;\n        }\n        case 'C':\n        case 'c':\n        {\n          if (LocaleCompare(keyword,\"class\") == 0)\n            {\n              const char\n                *p;\n\n              for (p=value; ; )\n              {\n                (void) GetNextToken(p,&p,MagickPathExtent,token);\n                if (*token == ',')\n                  (void) GetNextToken(p,&p,MagickPathExtent,token);\n                if (*token != '\\0')\n                  {\n                    (void) FormatLocaleFile(svg_info->file,\"class \\\"%s\\\"\\n\",\n                      value);\n                    break;\n                  }\n              }\n              break;\n            }\n          if (LocaleCompare(keyword,\"clip-path\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"clip-path \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"clip-rule\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"clip-rule \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"clipPathUnits\") == 0)\n            {\n              (void) CloneString(&units,value);\n              (void) FormatLocaleFile(svg_info->file,\"clip-units \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"color\") == 0)\n            {\n              (void) CloneString(&color,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"cx\") == 0)\n            {\n              svg_info->element.cx=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"cy\") == 0)\n            {\n              svg_info->element.cy=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'D':\n        case 'd':\n        {\n          if (LocaleCompare(keyword,\"d\") == 0)\n            {\n              (void) CloneString(&svg_info->vertices,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"dx\") == 0)\n            {\n              double\n                dx;\n\n              dx=GetUserSpaceCoordinateValue(svg_info,1,value);\n              svg_info->bounds.x+=dx;\n              svg_info->text_offset.x+=dx;\n              if (LocaleCompare((char *) name,\"text\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\"translate %g,0.0\\n\",dx);\n              break;\n            }\n          if (LocaleCompare(keyword,\"dy\") == 0)\n            {\n              double\n                dy;\n\n              dy=GetUserSpaceCoordinateValue(svg_info,-1,value);\n              svg_info->bounds.y+=dy;\n              svg_info->text_offset.y+=dy;\n              if (LocaleCompare((char *) name,\"text\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\"translate 0.0,%g\\n\",dy);\n              break;\n            }\n          break;\n        }\n        case 'F':\n        case 'f':\n        {\n          if (LocaleCompare(keyword,\"fill\") == 0)\n            {\n              if (LocaleCompare(value,\"currentColor\") == 0)\n                {\n                  (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",color);\n                  break;\n                }\n              (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"fillcolor\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"fill \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"fill-rule\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"fill-rule \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"fill-opacity\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"fill-opacity \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-family\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"font-family \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-stretch\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"font-stretch \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-style\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"font-style \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-size\") == 0)\n            {\n              if (LocaleCompare(value,\"xx-small\") == 0)\n                svg_info->pointsize=6.144;\n              else if (LocaleCompare(value,\"x-small\") == 0)\n                svg_info->pointsize=7.68;\n              else if (LocaleCompare(value,\"small\") == 0)\n                svg_info->pointsize=9.6;\n              else if (LocaleCompare(value,\"medium\") == 0)\n                svg_info->pointsize=12.0;\n              else if (LocaleCompare(value,\"large\") == 0)\n                svg_info->pointsize=14.4;\n              else if (LocaleCompare(value,\"x-large\") == 0)\n                svg_info->pointsize=17.28;\n              else if (LocaleCompare(value,\"xx-large\") == 0)\n                svg_info->pointsize=20.736;\n              else\n                svg_info->pointsize=GetUserSpaceCoordinateValue(svg_info,0,\n                  value);\n              (void) FormatLocaleFile(svg_info->file,\"font-size %g\\n\",\n                svg_info->pointsize);\n              break;\n            }\n          if (LocaleCompare(keyword,\"font-weight\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"font-weight \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          break;\n        }\n        case 'G':\n        case 'g':\n        {\n          if (LocaleCompare(keyword,\"gradientTransform\") == 0)\n            {\n              AffineMatrix\n                affine,\n                current,\n                transform;\n\n              GetAffineMatrix(&transform);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  \");\n              tokens=SVGKeyValuePairs(context,'(',')',value,&number_tokens);\n              if (tokens == (char **) NULL)\n                break;\n              for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n              {\n                keyword=(char *) tokens[j];\n                if (keyword == (char *) NULL)\n                  continue;\n                value=(char *) tokens[j+1];\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    %s: %s\",keyword,value);\n                current=transform;\n                GetAffineMatrix(&affine);\n                switch (*keyword)\n                {\n                  case 'M':\n                  case 'm':\n                  {\n                    if (LocaleCompare(keyword,\"matrix\") == 0)\n                      {\n                        p=(const char *) value;\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.sx=StringToDouble(value,(char **) NULL);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.rx=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.ry=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.sy=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.tx=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.ty=StringToDouble(token,&next_token);\n                        break;\n                      }\n                    break;\n                  }\n                  case 'R':\n                  case 'r':\n                  {\n                    if (LocaleCompare(keyword,\"rotate\") == 0)\n                      {\n                        double\n                          angle;\n\n                        angle=GetUserSpaceCoordinateValue(svg_info,0,value);\n                        affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                        affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                        affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                        affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                        break;\n                      }\n                    break;\n                  }\n                  case 'S':\n                  case 's':\n                  {\n                    if (LocaleCompare(keyword,\"scale\") == 0)\n                      {\n                        for (p=(const char *) value; *p != '\\0'; p++)\n                          if ((isspace((int) ((unsigned char) *p)) != 0) ||\n                              (*p == ','))\n                            break;\n                        affine.sx=GetUserSpaceCoordinateValue(svg_info,1,value);\n                        affine.sy=affine.sx;\n                        if (*p != '\\0')\n                          affine.sy=\n                            GetUserSpaceCoordinateValue(svg_info,-1,p+1);\n                        svg_info->scale[svg_info->n]=ExpandAffine(&affine);\n                        break;\n                      }\n                    if (LocaleCompare(keyword,\"skewX\") == 0)\n                      {\n                        affine.sx=svg_info->affine.sx;\n                        affine.ry=tan(DegreesToRadians(fmod(\n                          GetUserSpaceCoordinateValue(svg_info,1,value),\n                          360.0)));\n                        affine.sy=svg_info->affine.sy;\n                        break;\n                      }\n                    if (LocaleCompare(keyword,\"skewY\") == 0)\n                      {\n                        affine.sx=svg_info->affine.sx;\n                        affine.rx=tan(DegreesToRadians(fmod(\n                          GetUserSpaceCoordinateValue(svg_info,-1,value),\n                          360.0)));\n                        affine.sy=svg_info->affine.sy;\n                        break;\n                      }\n                    break;\n                  }\n                  case 'T':\n                  case 't':\n                  {\n                    if (LocaleCompare(keyword,\"translate\") == 0)\n                      {\n                        for (p=(const char *) value; *p != '\\0'; p++)\n                          if ((isspace((int) ((unsigned char) *p)) != 0) ||\n                              (*p == ','))\n                            break;\n                        affine.tx=GetUserSpaceCoordinateValue(svg_info,1,value);\n                        affine.ty=affine.tx;\n                        if (*p != '\\0')\n                          affine.ty=\n                            GetUserSpaceCoordinateValue(svg_info,-1,p+1);\n                        break;\n                      }\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                transform.sx=affine.sx*current.sx+affine.ry*current.rx;\n                transform.rx=affine.rx*current.sx+affine.sy*current.rx;\n                transform.ry=affine.sx*current.ry+affine.ry*current.sy;\n                transform.sy=affine.rx*current.ry+affine.sy*current.sy;\n                transform.tx=affine.tx*current.sx+affine.ty*current.ry+\n                  current.tx;\n                transform.ty=affine.tx*current.rx+affine.ty*current.sy+\n                  current.ty;\n              }\n              (void) FormatLocaleFile(svg_info->file,\n                \"affine %g %g %g %g %g %g\\n\",transform.sx,\n                transform.rx,transform.ry,transform.sy,transform.tx,\n                transform.ty);\n              for (j=0; tokens[j] != (char *) NULL; j++)\n                tokens[j]=DestroyString(tokens[j]);\n              tokens=(char **) RelinquishMagickMemory(tokens);\n              break;\n            }\n          if (LocaleCompare(keyword,\"gradientUnits\") == 0)\n            {\n              (void) CloneString(&units,value);\n              (void) FormatLocaleFile(svg_info->file,\"gradient-units \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          break;\n        }\n        case 'H':\n        case 'h':\n        {\n          if (LocaleCompare(keyword,\"height\") == 0)\n            {\n              svg_info->bounds.height=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"href\") == 0)\n            {\n              (void) CloneString(&svg_info->url,value);\n              break;\n            }\n          break;\n        }\n        case 'K':\n        case 'k':\n        {\n          if (LocaleCompare(keyword,\"kerning\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"kerning \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          break;\n        }\n        case 'L':\n        case 'l':\n        {\n          if (LocaleCompare(keyword,\"letter-spacing\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"letter-spacing \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          break;\n        }\n        case 'M':\n        case 'm':\n        {\n          if (LocaleCompare(keyword,\"major\") == 0)\n            {\n              svg_info->element.major=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"mask\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"mask \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"minor\") == 0)\n            {\n              svg_info->element.minor=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'O':\n        case 'o':\n        {\n          if (LocaleCompare(keyword,\"offset\") == 0)\n            {\n              (void) CloneString(&svg_info->offset,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"opacity\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"opacity \\\"%s\\\"\\n\",value);\n              break;\n            }\n          break;\n        }\n        case 'P':\n        case 'p':\n        {\n          if (LocaleCompare(keyword,\"path\") == 0)\n            {\n              (void) CloneString(&svg_info->url,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"points\") == 0)\n            {\n              (void) CloneString(&svg_info->vertices,value);\n              break;\n            }\n          break;\n        }\n        case 'R':\n        case 'r':\n        {\n          if (LocaleCompare(keyword,\"r\") == 0)\n            {\n              svg_info->element.major=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              svg_info->element.minor=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"rotate\") == 0)\n            {\n              double\n                angle;\n\n              angle=GetUserSpaceCoordinateValue(svg_info,0,value);\n              (void) FormatLocaleFile(svg_info->file,\"translate %g,%g\\n\",\n                svg_info->bounds.x,svg_info->bounds.y);\n              svg_info->bounds.x=0;\n              svg_info->bounds.y=0;\n              (void) FormatLocaleFile(svg_info->file,\"rotate %g\\n\",angle);\n              break;\n            }\n          if (LocaleCompare(keyword,\"rx\") == 0)\n            {\n              if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n                svg_info->element.major=\n                  GetUserSpaceCoordinateValue(svg_info,1,value);\n              else\n                svg_info->radius.x=\n                  GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"ry\") == 0)\n            {\n              if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n                svg_info->element.minor=\n                  GetUserSpaceCoordinateValue(svg_info,-1,value);\n              else\n                svg_info->radius.y=\n                  GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        case 'S':\n        case 's':\n        {\n          if (LocaleCompare(keyword,\"stop-color\") == 0)\n            {\n              (void) CloneString(&svg_info->stop_color,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke\") == 0)\n            {\n              if (LocaleCompare(value,\"currentColor\") == 0)\n                {\n                  (void) FormatLocaleFile(svg_info->file,\"stroke \\\"%s\\\"\\n\",\n                    color);\n                  break;\n                }\n              (void) FormatLocaleFile(svg_info->file,\"stroke \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-antialiasing\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-antialias %d\\n\",\n                LocaleCompare(value,\"true\") == 0);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-dasharray\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-dasharray %s\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-dashoffset\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-dashoffset %g\\n\",\n                GetUserSpaceCoordinateValue(svg_info,1,value));\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-linecap\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-linecap \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-linejoin\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-linejoin \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-miterlimit\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\n                \"stroke-miterlimit \\\"%s\\\"\\n\",value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-opacity\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-opacity \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"stroke-width\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"stroke-width %g\\n\",\n                GetUserSpaceCoordinateValue(svg_info,1,value));\n              break;\n            }\n          if (LocaleCompare(keyword,\"style\") == 0)\n            {\n              SVGProcessStyleElement(context,name,value);\n              break;\n            }\n          break;\n        }\n        case 'T':\n        case 't':\n        {\n          if (LocaleCompare(keyword,\"text-align\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"text-align \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"text-anchor\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"text-anchor \\\"%s\\\"\\n\",\n                value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"text-decoration\") == 0)\n            {\n              if (LocaleCompare(value,\"underline\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\"decorate underline\\n\");\n              if (LocaleCompare(value,\"line-through\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\n                  \"decorate line-through\\n\");\n              if (LocaleCompare(value,\"overline\") == 0)\n                (void) FormatLocaleFile(svg_info->file,\"decorate overline\\n\");\n              break;\n            }\n          if (LocaleCompare(keyword,\"text-antialiasing\") == 0)\n            {\n              (void) FormatLocaleFile(svg_info->file,\"text-antialias %d\\n\",\n                LocaleCompare(value,\"true\") == 0);\n              break;\n            }\n          if (LocaleCompare(keyword,\"transform\") == 0)\n            {\n              AffineMatrix\n                affine,\n                current,\n                transform;\n\n              GetAffineMatrix(&transform);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  \");\n              tokens=SVGKeyValuePairs(context,'(',')',value,&number_tokens);\n              if (tokens == (char **) NULL)\n                break;\n              for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n              {\n                keyword=(char *) tokens[j];\n                value=(char *) tokens[j+1];\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    %s: %s\",keyword,value);\n                current=transform;\n                GetAffineMatrix(&affine);\n                switch (*keyword)\n                {\n                  case 'M':\n                  case 'm':\n                  {\n                    if (LocaleCompare(keyword,\"matrix\") == 0)\n                      {\n                        p=(const char *) value;\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.sx=StringToDouble(value,(char **) NULL);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.rx=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.ry=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.sy=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.tx=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        affine.ty=StringToDouble(token,&next_token);\n                        break;\n                      }\n                    break;\n                  }\n                  case 'R':\n                  case 'r':\n                  {\n                    if (LocaleCompare(keyword,\"rotate\") == 0)\n                      {\n                        double\n                          angle,\n                          x,\n                          y;\n\n                        p=(const char *) value;\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        angle=StringToDouble(value,(char **) NULL);\n                        affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                        affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                        affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                        affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        x=StringToDouble(token,&next_token);\n                        (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        if (*token == ',')\n                          (void) GetNextToken(p,&p,MagickPathExtent,token);\n                        y=StringToDouble(token,&next_token);\n                        affine.tx=svg_info->bounds.x+x*\n                          cos(DegreesToRadians(fmod(angle,360.0)))+y*\n                          sin(DegreesToRadians(fmod(angle,360.0)));\n                        affine.ty=svg_info->bounds.y-x*\n                          sin(DegreesToRadians(fmod(angle,360.0)))+y*\n                          cos(DegreesToRadians(fmod(angle,360.0)));\n                        affine.tx-=x;\n                        affine.ty-=y;\n                        break;\n                      }\n                    break;\n                  }\n                  case 'S':\n                  case 's':\n                  {\n                    if (LocaleCompare(keyword,\"scale\") == 0)\n                      {\n                        for (p=(const char *) value; *p != '\\0'; p++)\n                          if ((isspace((int) ((unsigned char) *p)) != 0) ||\n                              (*p == ','))\n                            break;\n                        affine.sx=GetUserSpaceCoordinateValue(svg_info,1,value);\n                        affine.sy=affine.sx;\n                        if (*p != '\\0')\n                          affine.sy=GetUserSpaceCoordinateValue(svg_info,-1,\n                            p+1);\n                        svg_info->scale[svg_info->n]=ExpandAffine(&affine);\n                        break;\n                      }\n                    if (LocaleCompare(keyword,\"skewX\") == 0)\n                      {\n                        affine.sx=svg_info->affine.sx;\n                        affine.ry=tan(DegreesToRadians(fmod(\n                          GetUserSpaceCoordinateValue(svg_info,1,value),\n                          360.0)));\n                        affine.sy=svg_info->affine.sy;\n                        break;\n                      }\n                    if (LocaleCompare(keyword,\"skewY\") == 0)\n                      {\n                        affine.sx=svg_info->affine.sx;\n                        affine.rx=tan(DegreesToRadians(fmod(\n                          GetUserSpaceCoordinateValue(svg_info,-1,value),\n                          360.0)));\n                        affine.sy=svg_info->affine.sy;\n                        break;\n                      }\n                    break;\n                  }\n                  case 'T':\n                  case 't':\n                  {\n                    if (LocaleCompare(keyword,\"translate\") == 0)\n                      {\n                        for (p=(const char *) value; *p != '\\0'; p++)\n                          if ((isspace((int) ((unsigned char) *p)) != 0) ||\n                              (*p == ','))\n                            break;\n                        affine.tx=GetUserSpaceCoordinateValue(svg_info,1,value);\n                        affine.ty=0;\n                        if (*p != '\\0')\n                          affine.ty=GetUserSpaceCoordinateValue(svg_info,-1,\n                            p+1);\n                        break;\n                      }\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                transform.sx=affine.sx*current.sx+affine.ry*current.rx;\n                transform.rx=affine.rx*current.sx+affine.sy*current.rx;\n                transform.ry=affine.sx*current.ry+affine.ry*current.sy;\n                transform.sy=affine.rx*current.ry+affine.sy*current.sy;\n                transform.tx=affine.tx*current.sx+affine.ty*current.ry+\n                  current.tx;\n                transform.ty=affine.tx*current.rx+affine.ty*current.sy+\n                  current.ty;\n              }\n              (void) FormatLocaleFile(svg_info->file,\n                \"affine %g %g %g %g %g %g\\n\",transform.sx,transform.rx,\n                transform.ry,transform.sy,transform.tx,transform.ty);\n              for (j=0; tokens[j] != (char *) NULL; j++)\n                tokens[j]=DestroyString(tokens[j]);\n              tokens=(char **) RelinquishMagickMemory(tokens);\n              break;\n            }\n          break;\n        }\n        case 'V':\n        case 'v':\n        {\n          if (LocaleCompare(keyword,\"verts\") == 0)\n            {\n              (void) CloneString(&svg_info->vertices,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"viewBox\") == 0)\n            {\n              p=(const char *) value;\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n              svg_info->view_box.x=StringToDouble(token,&next_token);\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                (void) GetNextToken(p,&p,MagickPathExtent,token);\n              svg_info->view_box.y=StringToDouble(token,&next_token);\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                (void) GetNextToken(p,&p,MagickPathExtent,token);\n              svg_info->view_box.width=StringToDouble(token,\n                (char **) NULL);\n              if (svg_info->bounds.width == 0)\n                svg_info->bounds.width=svg_info->view_box.width;\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                (void) GetNextToken(p,&p,MagickPathExtent,token);\n              svg_info->view_box.height=StringToDouble(token,\n                (char **) NULL);\n              if (svg_info->bounds.height == 0)\n                svg_info->bounds.height=svg_info->view_box.height;\n              break;\n            }\n          break;\n        }\n        case 'W':\n        case 'w':\n        {\n          if (LocaleCompare(keyword,\"width\") == 0)\n            {\n              svg_info->bounds.width=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          break;\n        }\n        case 'X':\n        case 'x':\n        {\n          if (LocaleCompare(keyword,\"x\") == 0)\n            {\n              svg_info->bounds.x=GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"xlink:href\") == 0)\n            {\n              (void) CloneString(&svg_info->url,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"x1\") == 0)\n            {\n              svg_info->segment.x1=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"x2\") == 0)\n            {\n              svg_info->segment.x2=\n                GetUserSpaceCoordinateValue(svg_info,1,value);\n              break;\n            }\n          break;\n        }\n        case 'Y':\n        case 'y':\n        {\n          if (LocaleCompare(keyword,\"y\") == 0)\n            {\n              svg_info->bounds.y=GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"y1\") == 0)\n            {\n              svg_info->segment.y1=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          if (LocaleCompare(keyword,\"y2\") == 0)\n            {\n              svg_info->segment.y2=\n                GetUserSpaceCoordinateValue(svg_info,-1,value);\n              break;\n            }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  if (LocaleCompare((const char *) name,\"svg\") == 0)\n    {\n      if (svg_info->document->encoding != (const xmlChar *) NULL)\n        (void) FormatLocaleFile(svg_info->file,\"encoding \\\"%s\\\"\\n\",\n          (const char *) svg_info->document->encoding);\n      if (attributes != (const xmlChar **) NULL)\n        {\n          double\n            sx,\n            sy,\n            tx,\n            ty;\n\n          if ((svg_info->view_box.width == 0.0) ||\n              (svg_info->view_box.height == 0.0))\n            svg_info->view_box=svg_info->bounds;\n          svg_info->width=0;\n          if (svg_info->bounds.width > 0.0)\n            svg_info->width=(size_t) floor(svg_info->bounds.width+0.5);\n          svg_info->height=0;\n          if (svg_info->bounds.height > 0.0)\n            svg_info->height=(size_t) floor(svg_info->bounds.height+0.5);\n          (void) FormatLocaleFile(svg_info->file,\"viewbox 0 0 %.20g %.20g\\n\",\n            (double) svg_info->width,(double) svg_info->height);\n          sx=PerceptibleReciprocal(svg_info->view_box.width)*svg_info->width;\n          sy=PerceptibleReciprocal(svg_info->view_box.height)*svg_info->height;\n          tx=svg_info->view_box.x != 0.0 ? (double) -sx*svg_info->view_box.x :\n            0.0;\n          ty=svg_info->view_box.y != 0.0 ? (double) -sy*svg_info->view_box.y :\n            0.0;\n          (void) FormatLocaleFile(svg_info->file,\"affine %g 0 0 %g %g %g\\n\",\n            sx,sy,tx,ty);\n          if ((svg_info->svgDepth == 1) && (*background != '\\0'))\n            {\n              PushGraphicContext(id);\n              (void) FormatLocaleFile(svg_info->file,\"fill %s\\n\",background);\n              (void) FormatLocaleFile(svg_info->file,\n                \"rectangle 0,0 %g,%g\\n\",svg_info->view_box.width,\n                svg_info->view_box.height);\n              (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n            }\n        }\n    }\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  )\");\n  if (units != (char *) NULL)\n    units=DestroyString(units);\n  if (color != (char *) NULL)\n    color=DestroyString(color);\n}\n\nstatic void SVGEndElement(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when the end of an element has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.endElement(%s)\",name);\n  svg_info=(SVGInfo *) context;\n  if (strchr((char *) name,':') != (char *) NULL)\n    {\n      /*\n        Skip over namespace.\n      */\n      for ( ; *name != ':'; name++) ;\n      name++;\n    }\n  switch (*name)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) name,\"circle\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"circle\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"circle %g,%g %g,%g\\n\",\n            svg_info->element.cx,svg_info->element.cy,svg_info->element.cx,\n            svg_info->element.cy+svg_info->element.minor);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"clipPath\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop clip-path\\n\");\n          break;\n        }\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) name,\"defs\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop defs\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"desc\") == 0)\n        {\n          register char\n            *p;\n\n          if (*svg_info->text == '\\0')\n            break;\n          (void) fputc('#',svg_info->file);\n          for (p=svg_info->text; *p != '\\0'; p++)\n          {\n            (void) fputc(*p,svg_info->file);\n            if (*p == '\\n')\n              (void) fputc('#',svg_info->file);\n          }\n          (void) fputc('\\n',svg_info->file);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n        {\n          double\n            angle;\n\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"ellipse\\\"\\n\");\n          angle=svg_info->element.angle;\n          (void) FormatLocaleFile(svg_info->file,\"ellipse %g,%g %g,%g 0,360\\n\",\n            svg_info->element.cx,svg_info->element.cy,\n            angle == 0.0 ? svg_info->element.major : svg_info->element.minor,\n            angle == 0.0 ? svg_info->element.minor : svg_info->element.major);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) name,\"foreignObject\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) name,\"g\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) name,\"image\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"image Over %g,%g %g,%g \\\"%s\\\"\\n\",svg_info->bounds.x,\n            svg_info->bounds.y,svg_info->bounds.width,svg_info->bounds.height,\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) name,\"line\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"line\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"line %g,%g %g,%g\\n\",\n            svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2,\n            svg_info->segment.y2);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"linearGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) name,\"mask\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop mask\\n\");\n          break;\n        }\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) name,\"pattern\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop pattern\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"path\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"path\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"path \\\"%s\\\"\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polygon\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polygon\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polygon %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polyline\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polyline\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polyline %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) name,\"radialGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"rect\") == 0)\n        {\n          if ((svg_info->radius.x == 0.0) && (svg_info->radius.y == 0.0))\n            {\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"rect\\\"\\n\");\n              if ((fabs(svg_info->bounds.width-1.0) < MagickEpsilon) &&\n                  (fabs(svg_info->bounds.height-1.0) < MagickEpsilon))\n                (void) FormatLocaleFile(svg_info->file,\"point %g,%g\\n\",\n                  svg_info->bounds.x,svg_info->bounds.y);\n              else\n                (void) FormatLocaleFile(svg_info->file,\n                  \"rectangle %g,%g %g,%g\\n\",svg_info->bounds.x,\n                  svg_info->bounds.y,svg_info->bounds.x+svg_info->bounds.width,\n                  svg_info->bounds.y+svg_info->bounds.height);\n              (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n              break;\n            }\n          if (svg_info->radius.x == 0.0)\n            svg_info->radius.x=svg_info->radius.y;\n          if (svg_info->radius.y == 0.0)\n            svg_info->radius.y=svg_info->radius.x;\n          (void) FormatLocaleFile(svg_info->file,\n            \"roundRectangle %g,%g %g,%g %g,%g\\n\",\n            svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.x+\n            svg_info->bounds.width,svg_info->bounds.y+svg_info->bounds.height,\n            svg_info->radius.x,svg_info->radius.y);\n          svg_info->radius.x=0.0;\n          svg_info->radius.y=0.0;\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((const char *) name,\"stop\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"stop-color \\\"%s\\\" %s\\n\",\n            svg_info->stop_color,svg_info->offset);\n          break;\n        }\n      if (LocaleCompare((char *) name,\"style\") == 0)\n        {\n          char\n            *keyword,\n            **tokens,\n            *value;\n\n          register ssize_t\n            j;\n\n          size_t\n            number_tokens;\n\n          /*\n            Find style definitions in svg_info->text.\n          */\n          tokens=SVGKeyValuePairs(context,'{','}',svg_info->text,\n            &number_tokens);\n          if (tokens == (char **) NULL)\n            break;\n          for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n          {\n            keyword=(char *) tokens[j];\n            value=(char *) tokens[j+1];\n            (void) FormatLocaleFile(svg_info->file,\"push class \\\"%s\\\"\\n\",\n              *keyword == '.' ? keyword+1 : keyword);\n            SVGProcessStyleElement(context,name,value);\n            (void) FormatLocaleFile(svg_info->file,\"pop class\\n\");\n          }\n          for (j=0; tokens[j] != (char *) NULL; j++)\n            tokens[j]=DestroyString(tokens[j]);\n          tokens=(char **) RelinquishMagickMemory(tokens);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"svg\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          svg_info->svgDepth--;\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"symbol\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop symbol\\n\");\n          break;\n        }\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) name,\"text\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              SVGStripString(MagickTrue,svg_info->text);\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->text_offset.x,svg_info->text_offset.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"tspan\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"tspan\\\"\\n\");\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->bounds.x,svg_info->bounds.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"title\") == 0)\n        {\n          if (*svg_info->text == '\\0')\n            break;\n          (void) CloneString(&svg_info->title,svg_info->text);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare((char *) name,\"use\") == 0)\n        {\n          if ((svg_info->bounds.x != 0.0) || (svg_info->bounds.y != 0.0))\n            (void) FormatLocaleFile(svg_info->file,\"translate %g,%g\\n\",\n              svg_info->bounds.x,svg_info->bounds.y);\n          (void) FormatLocaleFile(svg_info->file,\"use \\\"url(%s)\\\"\\n\",\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  *svg_info->text='\\0';\n  (void) memset(&svg_info->element,0,sizeof(svg_info->element));\n  (void) memset(&svg_info->segment,0,sizeof(svg_info->segment));\n  svg_info->n--;\n}\n\nstatic void SVGCharacters(void *context,const xmlChar *c,int length)\n{\n  char\n    *text;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SVGInfo\n    *svg_info;\n\n  /*\n    Receiving some characters from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.characters(%s,%.20g)\",c,(double) length);\n  svg_info=(SVGInfo *) context;\n  text=(char *) AcquireQuantumMemory(length+1,sizeof(*text));\n  if (text == (char *) NULL)\n    return;\n  p=text;\n  for (i=0; i < (ssize_t) length; i++)\n    *p++=c[i];\n  *p='\\0';\n  SVGStripString(MagickFalse,text);\n  if (svg_info->text == (char *) NULL)\n    svg_info->text=text;\n  else\n    {\n      (void) ConcatenateString(&svg_info->text,text);\n      text=DestroyString(text);\n    }\n}\n\nstatic void SVGReference(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when an entity reference is detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.reference(%s)\",\n    name);\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  if (parser == (xmlParserCtxtPtr) NULL)\n    return;\n  if (parser->node == (xmlNodePtr) NULL)\n    return;\n  if (*name == '#')\n    (void) xmlAddChild(parser->node,xmlNewCharRef(svg_info->document,name));\n  else\n    (void) xmlAddChild(parser->node,xmlNewReference(svg_info->document,name));\n}\n\nstatic void SVGIgnorableWhitespace(void *context,const xmlChar *c,int length)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Receiving some ignorable whitespaces from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.ignorableWhitespace(%.30s, %d)\",c,length);\n  svg_info=(SVGInfo *) context;\n  (void) svg_info;\n}\n\nstatic void SVGProcessingInstructions(void *context,const xmlChar *target,\n  const xmlChar *data)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    A processing instruction has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.processingInstruction(%s, %s)\",target,data);\n  svg_info=(SVGInfo *) context;\n  (void) svg_info;\n}\n\nstatic void SVGComment(void *context,const xmlChar *value)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    A comment has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.comment(%s)\",\n    value);\n  svg_info=(SVGInfo *) context;\n  if (svg_info->comment != (char *) NULL)\n    (void) ConcatenateString(&svg_info->comment,\"\\n\");\n  (void) ConcatenateString(&svg_info->comment,(const char *) value);\n}\n\nstatic void SVGWarning(void *,const char *,...)\n  magick_attribute((__format__ (__printf__,2,3)));\n\nstatic void SVGWarning(void *context,const char *format,...)\n{\n  char\n    *message,\n    reason[MagickPathExtent];\n\n  SVGInfo\n    *svg_info;\n\n  va_list\n    operands;\n\n  /**\n    Display and format a warning messages, gives file, line, position and\n    extra parameters.\n  */\n  va_start(operands,format);\n  svg_info=(SVGInfo *) context;\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.warning: \");\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);\n#if !defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsprintf(reason,format,operands);\n#else\n  (void) vsnprintf(reason,MagickPathExtent,format,operands);\n#endif\n  message=GetExceptionMessage(errno);\n  (void) ThrowMagickException(svg_info->exception,GetMagickModule(),\n    DelegateWarning,reason,\"`%s`\",message);\n  message=DestroyString(message);\n  va_end(operands);\n}\n\nstatic void SVGError(void *,const char *,...)\n  magick_attribute((__format__ (__printf__,2,3)));\n\nstatic void SVGError(void *context,const char *format,...)\n{\n  char\n    *message,\n    reason[MagickPathExtent];\n\n  SVGInfo\n    *svg_info;\n\n  va_list\n    operands;\n\n  /*\n    Display and format a error formats, gives file, line, position and\n    extra parameters.\n  */\n  va_start(operands,format);\n  svg_info=(SVGInfo *) context;\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.error: \");\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);\n#if !defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsprintf(reason,format,operands);\n#else\n  (void) vsnprintf(reason,MagickPathExtent,format,operands);\n#endif\n  message=GetExceptionMessage(errno);\n  (void) ThrowMagickException(svg_info->exception,GetMagickModule(),CoderError,\n    reason,\"`%s`\",message);\n  message=DestroyString(message);\n  va_end(operands);\n}\n\nstatic void SVGCDataBlock(void *context,const xmlChar *value,int length)\n{\n  SVGInfo\n    *svg_info;\n\n   xmlNodePtr\n     child;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when a pcdata block has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.pcdata(%s, %d)\",\n    value,length);\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  child=xmlGetLastChild(parser->node);\n  if ((child != (xmlNodePtr) NULL) && (child->type == XML_CDATA_SECTION_NODE))\n    {\n      xmlTextConcat(child,value,length);\n      return;\n    }\n  (void) xmlAddChild(parser->node,xmlNewCDataBlock(parser->myDoc,value,length));\n}\n\nstatic void SVGExternalSubset(void *context,const xmlChar *name,\n  const xmlChar *external_id,const xmlChar *system_id)\n{\n  SVGInfo\n    *svg_info;\n\n  xmlParserCtxt\n    parser_context;\n\n  xmlParserCtxtPtr\n    parser;\n\n  xmlParserInputPtr\n    input;\n\n  /*\n    Does this document has an external subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.externalSubset(%s, %s, %s)\",name,\n    (external_id != (const xmlChar *) NULL ? (const char *) external_id : \"none\"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\"));\n  svg_info=(SVGInfo *) context;\n  parser=svg_info->parser;\n  if (((external_id == NULL) && (system_id == NULL)) ||\n      ((parser->validate == 0) || (parser->wellFormed == 0) ||\n      (svg_info->document == 0)))\n    return;\n  input=SVGResolveEntity(context,external_id,system_id);\n  if (input == NULL)\n    return;\n  (void) xmlNewDtd(svg_info->document,name,external_id,system_id);\n  parser_context=(*parser);\n  parser->inputTab=(xmlParserInputPtr *) xmlMalloc(5*sizeof(*parser->inputTab));\n  if (parser->inputTab == (xmlParserInputPtr *) NULL)\n    {\n      parser->errNo=XML_ERR_NO_MEMORY;\n      parser->input=parser_context.input;\n      parser->inputNr=parser_context.inputNr;\n      parser->inputMax=parser_context.inputMax;\n      parser->inputTab=parser_context.inputTab;\n      return;\n  }\n  parser->inputNr=0;\n  parser->inputMax=5;\n  parser->input=NULL;\n  xmlPushInput(parser,input);\n  (void) xmlSwitchEncoding(parser,xmlDetectCharEncoding(parser->input->cur,4));\n  if (input->filename == (char *) NULL)\n    input->filename=(char *) xmlStrdup(system_id);\n  input->line=1;\n  input->col=1;\n  input->base=parser->input->cur;\n  input->cur=parser->input->cur;\n  input->free=NULL;\n  xmlParseExternalSubset(parser,external_id,system_id);\n  while (parser->inputNr > 1)\n    (void) xmlPopInput(parser);\n  xmlFreeInputStream(parser->input);\n  xmlFree(parser->inputTab);\n  parser->input=parser_context.input;\n  parser->inputNr=parser_context.inputNr;\n  parser->inputMax=parser_context.inputMax;\n  parser->inputTab=parser_context.inputTab;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next;\n\n  int\n    status,\n    unique_file;\n\n  ssize_t\n    n;\n\n  SVGInfo\n    *svg_info;\n\n  unsigned char\n    message[MagickPathExtent];\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->resolution.x) < MagickEpsilon) ||\n      (fabs(image->resolution.y) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n    {\n      Image\n        *svg_image;\n\n      svg_image=RenderSVGImage(image_info,image,exception);\n      if (svg_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          return(svg_image);\n        }\n      {\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        cairo_surface_t\n          *cairo_surface;\n\n        cairo_t\n          *cairo_image;\n\n        MagickBooleanType\n          apply_density;\n\n        MemoryInfo\n          *pixel_info;\n\n        register unsigned char\n          *p;\n\n        RsvgDimensionData\n          dimension_info;\n\n        unsigned char\n          *pixels;\n\n#else\n        GdkPixbuf\n          *pixel_buffer;\n\n        register const guchar\n          *p;\n#endif\n\n        GError\n          *error;\n\n        PixelInfo\n          fill_color;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *q;\n\n        RsvgHandle\n          *svg_handle;\n\n        ssize_t\n          y;\n\n        svg_handle=rsvg_handle_new();\n        if (svg_handle == (RsvgHandle *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        rsvg_handle_set_base_uri(svg_handle,image_info->filename);\n        if ((fabs(image->resolution.x) > MagickEpsilon) &&\n            (fabs(image->resolution.y) > MagickEpsilon))\n          rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n            image->resolution.y);\n        while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n        {\n          message[n]='\\0';\n          error=(GError *) NULL;\n          (void) rsvg_handle_write(svg_handle,message,n,&error);\n          if (error != (GError *) NULL)\n            g_error_free(error);\n        }\n        error=(GError *) NULL;\n        rsvg_handle_close(svg_handle,&error);\n        if (error != (GError *) NULL)\n          g_error_free(error);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        apply_density=MagickTrue;\n        rsvg_handle_get_dimensions(svg_handle,&dimension_info);\n        if ((image->resolution.x > 0.0) && (image->resolution.y > 0.0))\n          {\n            RsvgDimensionData\n              dpi_dimension_info;\n\n            /*\n              We should not apply the density when the internal 'factor' is 'i'.\n              This can be checked by using the trick below.\n            */\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x*256,\n              image->resolution.y*256);\n            rsvg_handle_get_dimensions(svg_handle,&dpi_dimension_info);\n            if ((dpi_dimension_info.width != dimension_info.width) ||\n                (dpi_dimension_info.height != dimension_info.height))\n              apply_density=MagickFalse;\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n              image->resolution.y);\n          }\n        if (image_info->size != (char *) NULL)\n          {\n            (void) GetGeometry(image_info->size,(ssize_t *) NULL,\n              (ssize_t *) NULL,&image->columns,&image->rows);\n            if ((image->columns != 0) || (image->rows != 0))\n              {\n                image->resolution.x=DefaultSVGDensity*image->columns/\n                  dimension_info.width;\n                image->resolution.y=DefaultSVGDensity*image->rows/\n                  dimension_info.height;\n                if (fabs(image->resolution.x) < MagickEpsilon)\n                  image->resolution.x=image->resolution.y;\n                else\n                  if (fabs(image->resolution.y) < MagickEpsilon)\n                    image->resolution.y=image->resolution.x;\n                  else\n                    image->resolution.x=image->resolution.y=MagickMin(\n                      image->resolution.x,image->resolution.y);\n                apply_density=MagickTrue;\n              }\n          }\n        if (apply_density != MagickFalse)\n          {\n            image->columns=image->resolution.x*dimension_info.width/\n              DefaultSVGDensity;\n            image->rows=image->resolution.y*dimension_info.height/\n              DefaultSVGDensity;\n          }\n        else\n          {\n            image->columns=dimension_info.width;\n            image->rows=dimension_info.height;\n          }\n        pixel_info=(MemoryInfo *) NULL;\n#else\n        pixel_buffer=rsvg_handle_get_pixbuf(svg_handle);\n        rsvg_handle_free(svg_handle);\n        image->columns=gdk_pixbuf_get_width(pixel_buffer);\n        image->rows=gdk_pixbuf_get_height(pixel_buffer);\n#endif\n        image->alpha_trait=BlendPixelTrait;\n        if (image_info->ping == MagickFalse)\n          {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            size_t\n              stride;\n#endif\n\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              {\n#if !defined(MAGICKCORE_CAIRO_DELEGATE)\n                g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n                g_object_unref(svg_handle);\n                ThrowReaderException(MissingDelegateError,\n                  \"NoDecodeDelegateForThisImageFormat\");\n              }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            stride=4*image->columns;\n#if defined(MAGICKCORE_PANGOCAIRO_DELEGATE)\n            stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n              (int) image->columns);\n#endif\n            pixel_info=AcquireVirtualMemory(stride,image->rows*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n#endif\n            (void) SetImageBackgroundColor(image,exception);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            cairo_surface=cairo_image_surface_create_for_data(pixels,\n              CAIRO_FORMAT_ARGB32,(int) image->columns,(int) image->rows,(int)\n              stride);\n            if ((cairo_surface == (cairo_surface_t *) NULL) ||\n                (cairo_surface_status(cairo_surface) != CAIRO_STATUS_SUCCESS))\n              {\n                if (cairo_surface != (cairo_surface_t *) NULL)\n                  cairo_surface_destroy(cairo_surface);\n                pixel_info=RelinquishVirtualMemory(pixel_info);\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            cairo_image=cairo_create(cairo_surface);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n            cairo_paint(cairo_image);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n            if (apply_density != MagickFalse)\n              cairo_scale(cairo_image,image->resolution.x/DefaultSVGDensity,\n                image->resolution.y/DefaultSVGDensity);\n            rsvg_handle_render_cairo(svg_handle,cairo_image);\n            cairo_destroy(cairo_image);\n            cairo_surface_destroy(cairo_surface);\n            g_object_unref(svg_handle);\n            p=pixels;\n#else\n            p=gdk_pixbuf_get_pixels(pixel_buffer);\n#endif\n            GetPixelInfo(image,&fill_color);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                fill_color.blue=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.red=ScaleCharToQuantum(*p++);\n#else\n                fill_color.red=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.blue=ScaleCharToQuantum(*p++);\n#endif\n                fill_color.alpha=ScaleCharToQuantum(*p++);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                {\n                  double\n                    gamma;\n\n                  gamma=QuantumScale*fill_color.alpha;\n                  gamma=PerceptibleReciprocal(gamma);\n                  fill_color.blue*=gamma;\n                  fill_color.green*=gamma;\n                  fill_color.red*=gamma;\n                }\n#endif\n                CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n                  GetPixelAlpha(image,q),q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n#else\n        g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n        (void) CloseBlob(image);\n        for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n        {\n          (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n          (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n          next=GetNextImageInList(next);\n        }\n        return(GetFirstImageInList(image));\n#endif\n      }\n    }\n  /*\n    Open draw file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"w\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Parse SVG file.\n  */\n  svg_info=AcquireSVGInfo();\n  if (svg_info == (SVGInfo *) NULL)\n    {\n      (void) fclose(file);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  svg_info->file=file;\n  svg_info->exception=exception;\n  svg_info->image=image;\n  svg_info->image_info=image_info;\n  svg_info->bounds.width=image->columns;\n  svg_info->bounds.height=image->rows;\n  svg_info->svgDepth=0;\n  if (image_info->size != (char *) NULL)\n    (void) CloneString(&svg_info->size,image_info->size);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"begin SAX\");\n  xmlInitParser();\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) memset(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=SVGInternalSubset;\n  sax_modules.isStandalone=SVGIsStandalone;\n  sax_modules.hasInternalSubset=SVGHasInternalSubset;\n  sax_modules.hasExternalSubset=SVGHasExternalSubset;\n  sax_modules.resolveEntity=SVGResolveEntity;\n  sax_modules.getEntity=SVGGetEntity;\n  sax_modules.entityDecl=SVGEntityDeclaration;\n  sax_modules.notationDecl=SVGNotationDeclaration;\n  sax_modules.attributeDecl=SVGAttributeDeclaration;\n  sax_modules.elementDecl=SVGElementDeclaration;\n  sax_modules.unparsedEntityDecl=SVGUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=SVGSetDocumentLocator;\n  sax_modules.startDocument=SVGStartDocument;\n  sax_modules.endDocument=SVGEndDocument;\n  sax_modules.startElement=SVGStartElement;\n  sax_modules.endElement=SVGEndElement;\n  sax_modules.reference=SVGReference;\n  sax_modules.characters=SVGCharacters;\n  sax_modules.ignorableWhitespace=SVGIgnorableWhitespace;\n  sax_modules.processingInstruction=SVGProcessingInstructions;\n  sax_modules.comment=SVGComment;\n  sax_modules.warning=SVGWarning;\n  sax_modules.error=SVGError;\n  sax_modules.fatalError=SVGError;\n  sax_modules.getParameterEntity=SVGGetParameterEntity;\n  sax_modules.cdataBlock=SVGCDataBlock;\n  sax_modules.externalSubset=SVGExternalSubset;\n  sax_handler=(&sax_modules);\n  n=ReadBlob(image,MagickPathExtent-1,message);\n  message[n]='\\0';\n  if (n > 0)\n    {\n      const char\n        *value;\n\n      svg_info->parser=xmlCreatePushParserCtxt(sax_handler,svg_info,(char *)\n        message,n,image->filename);\n      value=GetImageOption(image_info,\"svg:xml-parse-huge\");\n      if ((value != (char *) NULL) && (IsStringTrue(value) != MagickFalse))\n        (void) xmlCtxtUseOptions(svg_info->parser,XML_PARSE_HUGE);\n      while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n      {\n        message[n]='\\0';\n        status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n        if (status != 0)\n          break;\n      }\n    }\n  (void) xmlParseChunk(svg_info->parser,(char *) message,0,1);\n  SVGEndDocument(svg_info);\n  xmlFreeParserCtxt(svg_info->parser);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image->columns=svg_info->width;\n  image->rows=svg_info->height;\n  if (exception->severity >= ErrorException)\n    {\n      svg_info=DestroySVGInfo(svg_info);\n      (void) RelinquishUniqueFileResource(filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (image_info->ping == MagickFalse)\n    {\n      ImageInfo\n        *read_info;\n\n      /*\n        Draw image.\n      */\n      image=DestroyImage(image);\n      image=(Image *) NULL;\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"mvg:%s\",\n        filename);\n      image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MagickPathExtent);\n    }\n  /*\n    Relinquish resources.\n  */\n  if (image != (Image *) NULL)\n    {\n      if (svg_info->title != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:title\",svg_info->title,exception);\n      if (svg_info->comment != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:comment\",svg_info->comment,\n          exception);\n    }\n  for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n  {\n    (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n    (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n    next=GetNextImageInList(next);\n  }\n  svg_info=DestroySVGInfo(svg_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}\n#else\nstatic Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image,\n    *svg_image;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->resolution.x) < MagickEpsilon) ||\n      (fabs(image->resolution.y) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  svg_image=RenderSVGImage(image_info,image,exception);\n  image=DestroyImage(image);\n  return(svg_image);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S V G I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSVGImage() adds attributes for the SVG image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSVGImage method is:\n%\n%      size_t RegisterSVGImage(void)\n%\n*/\nModuleExport size_t RegisterSVGImage(void)\n{\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(LIBXML_DOTTED_VERSION)\n  (void) CopyMagickString(version,\"XML \" LIBXML_DOTTED_VERSION,\n    MagickPathExtent);\n#endif\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if !GLIB_CHECK_VERSION(2,35,0)\n  g_type_init();\n#endif\n  (void) FormatLocaleString(version,MagickPathExtent,\"RSVG %d.%d.%d\",\n    LIBRSVG_MAJOR_VERSION,LIBRSVG_MINOR_VERSION,LIBRSVG_MICRO_VERSION);\n#endif\n  entry=AcquireMagickInfo(\"SVG\",\"SVG\",\"Scalable Vector Graphics\");\n  entry->decoder=(DecodeImageHandler *) ReadSVGImage;\n  entry->encoder=(EncodeImageHandler *) WriteSVGImage;\n  entry->flags^=CoderBlobSupportFlag;\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n  entry->mime_type=ConstantString(\"image/svg+xml\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->magick=(IsImageFormatHandler *) IsSVG;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"SVG\",\"SVGZ\",\"Compressed Scalable Vector Graphics\");\n#if defined(MAGICKCORE_XML_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadSVGImage;\n#endif\n  entry->encoder=(EncodeImageHandler *) WriteSVGImage;\n  entry->flags^=CoderBlobSupportFlag;\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n  entry->mime_type=ConstantString(\"image/svg+xml\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->magick=(IsImageFormatHandler *) IsSVG;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"SVG\",\"MSVG\",\n    \"ImageMagick's own SVG internal renderer\");\n#if defined(MAGICKCORE_XML_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadSVGImage;\n#endif\n  entry->encoder=(EncodeImageHandler *) WriteSVGImage;\n  entry->flags^=CoderBlobSupportFlag;\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsSVG;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S V G I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSVGImage() removes format registrations made by the\n%  SVG module from the list of supported formats.\n%\n%  The format of the UnregisterSVGImage method is:\n%\n%      UnregisterSVGImage(void)\n%\n*/\nModuleExport void UnregisterSVGImage(void)\n{\n  (void) UnregisterMagickInfo(\"SVGZ\");\n  (void) UnregisterMagickInfo(\"SVG\");\n  (void) UnregisterMagickInfo(\"MSVG\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S V G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSVGImage() writes a image in the SVG - XML based W3C standard\n%  format.\n%\n%  The format of the WriteSVGImage method is:\n%\n%      MagickBooleanType WriteSVGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void AffineToTransform(Image *image,AffineMatrix *affine)\n{\n  char\n    transform[MagickPathExtent];\n\n  if ((fabs(affine->tx) < MagickEpsilon) && (fabs(affine->ty) < MagickEpsilon))\n    {\n      if ((fabs(affine->rx) < MagickEpsilon) &&\n          (fabs(affine->ry) < MagickEpsilon))\n        {\n          if ((fabs(affine->sx-1.0) < MagickEpsilon) &&\n              (fabs(affine->sy-1.0) < MagickEpsilon))\n            {\n              (void) WriteBlobString(image,\"\\\">\\n\");\n              return;\n            }\n          (void) FormatLocaleString(transform,MagickPathExtent,\n            \"\\\" transform=\\\"scale(%g,%g)\\\">\\n\",affine->sx,affine->sy);\n          (void) WriteBlobString(image,transform);\n          return;\n        }\n      else\n        {\n          if ((fabs(affine->sx-affine->sy) < MagickEpsilon) &&\n              (fabs(affine->rx+affine->ry) < MagickEpsilon) &&\n              (fabs(affine->sx*affine->sx+affine->rx*affine->rx-1.0) <\n               2*MagickEpsilon))\n            {\n              double\n                theta;\n\n              theta=(180.0/MagickPI)*atan2(affine->rx,affine->sx);\n              (void) FormatLocaleString(transform,MagickPathExtent,\n                \"\\\" transform=\\\"rotate(%g)\\\">\\n\",theta);\n              (void) WriteBlobString(image,transform);\n              return;\n            }\n        }\n    }\n  else\n    {\n      if ((fabs(affine->sx-1.0) < MagickEpsilon) &&\n          (fabs(affine->rx) < MagickEpsilon) &&\n          (fabs(affine->ry) < MagickEpsilon) &&\n          (fabs(affine->sy-1.0) < MagickEpsilon))\n        {\n          (void) FormatLocaleString(transform,MagickPathExtent,\n            \"\\\" transform=\\\"translate(%g,%g)\\\">\\n\",affine->tx,affine->ty);\n          (void) WriteBlobString(image,transform);\n          return;\n        }\n    }\n  (void) FormatLocaleString(transform,MagickPathExtent,\n    \"\\\" transform=\\\"matrix(%g %g %g %g %g %g)\\\">\\n\",\n    affine->sx,affine->rx,affine->ry,affine->sy,affine->tx,affine->ty);\n  (void) WriteBlobString(image,transform);\n}\n\nstatic MagickBooleanType IsPoint(const char *point)\n{\n  char\n    *p;\n\n  ssize_t\n    value;\n\n  value=(ssize_t) strtol(point,&p,10);\n  (void) value;\n  return(p != point ? MagickTrue : MagickFalse);\n}\n\nstatic MagickBooleanType TraceSVGImage(Image *image,ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_AUTOTRACE_DELEGATE)\n  {\n    at_bitmap_type\n      *trace;\n\n    at_fitting_opts_type\n      *fitting_options;\n\n    at_output_opts_type\n      *output_options;\n\n    at_splines_type\n      *splines;\n\n    ImageType\n      type;\n\n    register const Quantum\n      *p;\n\n    register ssize_t\n      i,\n      x;\n\n    size_t\n      number_planes;\n\n    ssize_t\n      y;\n\n    /*\n      Trace image and write as SVG.\n    */\n    fitting_options=at_fitting_opts_new();\n    output_options=at_output_opts_new();\n    (void) SetImageGray(image,exception);\n    type=GetImageType(image);\n    number_planes=3;\n    if ((type == BilevelType) || (type == GrayscaleType))\n      number_planes=1;\n    trace=at_bitmap_new(image->columns,image->rows,number_planes);\n    i=0;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        trace->bitmap[i++]=GetPixelRed(image,p);\n        if (number_planes == 3)\n          {\n            trace->bitmap[i++]=GetPixelGreen(image,p);\n            trace->bitmap[i++]=GetPixelBlue(image,p);\n          }\n        p+=GetPixelChannels(image);\n      }\n    }\n    splines=at_splines_new_full(trace,fitting_options,NULL,NULL,NULL,NULL,NULL,\n      NULL);\n    at_splines_write(at_output_get_handler_by_suffix((char *) \"svg\"),\n      GetBlobFileHandle(image),image->filename,output_options,splines,NULL,\n      NULL);\n    /*\n      Free resources.\n    */\n    at_splines_free(splines);\n    at_bitmap_free(trace);\n    at_output_opts_free(output_options);\n    at_fitting_opts_free(fitting_options);\n  }\n#else\n  {\n    char\n      *base64,\n      filename[MagickPathExtent],\n      message[MagickPathExtent];\n\n    const DelegateInfo\n      *delegate_info;\n\n    Image\n      *clone_image;\n\n    ImageInfo\n      *image_info;\n\n    MagickBooleanType\n      status;\n\n    register char\n      *p;\n\n    size_t\n      blob_length,\n      encode_length;\n\n    ssize_t\n      i;\n\n    unsigned char\n      *blob;\n\n    delegate_info=GetDelegateInfo((char *) NULL,\"TRACE\",exception);\n    if (delegate_info != (DelegateInfo *) NULL)\n      {\n        /*\n          Trace SVG with tracing delegate.\n        */\n        image_info=AcquireImageInfo();\n        (void) CopyMagickString(image_info->magick,\"TRACE\",MagickPathExtent);\n        (void) FormatLocaleString(filename,MagickPathExtent,\"trace:%s\",\n          image_info->filename);\n        (void) CopyMagickString(image_info->filename,filename,MagickPathExtent);\n        status=WriteImage(image_info,image,exception);\n        image_info=DestroyImageInfo(image_info);\n        return(status);\n      }\n    (void) WriteBlobString(image,\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\");\n    (void) WriteBlobString(image,\n      \"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\"\");\n    (void) WriteBlobString(image,\n      \" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n\");\n    (void) FormatLocaleString(message,MagickPathExtent,\n      \"<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" \"\n      \"xmlns=\\\"http://www.w3.org/2000/svg\\\" \"\n      \"xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" \"\n      \"width=\\\"%.20gpx\\\" height=\\\"%.20gpx\\\" viewBox=\\\"0 0 %.20g %.20g\\\" \"\n      \"enable-background=\\\"new 0 0 %.20g %.20g\\\" xml:space=\\\"preserve\\\">\",\n      (double) image->columns,(double) image->rows,\n      (double) image->columns,(double) image->rows,\n      (double) image->columns,(double) image->rows);\n    (void) WriteBlobString(image,message);\n    clone_image=CloneImage(image,0,0,MagickTrue,exception);\n    if (clone_image == (Image *) NULL)\n      return(MagickFalse);\n    image_info=AcquireImageInfo();\n    (void) CopyMagickString(image_info->magick,\"PNG\",MagickPathExtent);\n    blob_length=2048;\n    blob=(unsigned char *) ImageToBlob(image_info,clone_image,&blob_length,\n      exception);\n    clone_image=DestroyImage(clone_image);\n    image_info=DestroyImageInfo(image_info);\n    if (blob == (unsigned char *) NULL)\n      return(MagickFalse);\n    encode_length=0;\n    base64=Base64Encode(blob,blob_length,&encode_length);\n    blob=(unsigned char *) RelinquishMagickMemory(blob);\n    (void) FormatLocaleString(message,MagickPathExtent,\n      \"  <image id=\\\"image%.20g\\\" width=\\\"%.20g\\\" height=\\\"%.20g\\\" \"\n      \"x=\\\"%.20g\\\" y=\\\"%.20g\\\"\\n    href=\\\"data:image/png;base64,\",\n      (double) image->scene,(double) image->columns,(double) image->rows,\n      (double) image->page.x,(double) image->page.y);\n    (void) WriteBlobString(image,message);\n    p=base64;\n    for (i=(ssize_t) encode_length; i > 0; i-=76)\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%.76s\",p);\n      (void) WriteBlobString(image,message);\n      p+=76;\n      if (i > 76)\n        (void) WriteBlobString(image,\"\\n\");\n    }\n    base64=DestroyString(base64);\n    (void) WriteBlobString(image,\"\\\" />\\n\");\n    (void) WriteBlobString(image,\"</svg>\\n\");\n  }\n#endif\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType WriteSVGImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define BezierQuantum  200\n\n  AffineMatrix\n    affine;\n\n  char\n    keyword[MagickPathExtent],\n    message[MagickPathExtent],\n    name[MagickPathExtent],\n    *next_token,\n    *token,\n    type[MagickPathExtent];\n\n  const char\n    *p,\n    *q,\n    *value;\n\n  int\n    n;\n\n  ssize_t\n    j;\n\n  MagickBooleanType\n    active,\n    status;\n\n  PointInfo\n    point;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveType\n    primitive_type;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent,\n    length,\n    number_points;\n\n  SVGInfo\n    svg_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  value=GetImageArtifact(image,\"SVG\");\n  if (value != (char *) NULL)\n    {\n      (void) WriteBlobString(image,value);\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  value=GetImageArtifact(image,\"mvg:vector-graphics\");\n  if (value == (char *) NULL)\n    return(TraceSVGImage(image,exception));\n  /*\n    Write SVG header.\n  */\n  (void) WriteBlobString(image,\"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?>\\n\");\n  (void) WriteBlobString(image,\n    \"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 20010904//EN\\\"\\n\");\n  (void) WriteBlobString(image,\n    \"  \\\"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\\\">\\n\");\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"<svg width=\\\"%.20g\\\" height=\\\"%.20g\\\">\\n\",(double) image->columns,(double)\n    image->rows);\n  (void) WriteBlobString(image,message);\n  /*\n    Allocate primitive info memory.\n  */\n  number_points=2047;\n  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,\n    sizeof(*primitive_info));\n  if (primitive_info == (PrimitiveInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  GetAffineMatrix(&affine);\n  token=AcquireString(value);\n  extent=strlen(token)+MagickPathExtent;\n  active=MagickFalse;\n  n=0;\n  status=MagickTrue;\n  for (q=(const char *) value; *q != '\\0'; )\n  {\n    /*\n      Interpret graphic primitive.\n    */\n    (void) GetNextToken(q,&q,MagickPathExtent,keyword);\n    if (*keyword == '\\0')\n      break;\n    if (*keyword == '#')\n      {\n        /*\n          Comment.\n        */\n        if (active != MagickFalse)\n          {\n            AffineToTransform(image,&affine);\n            active=MagickFalse;\n          }\n        (void) WriteBlobString(image,\"<desc>\");\n        (void) WriteBlobString(image,keyword+1);\n        for ( ; (*q != '\\n') && (*q != '\\0'); q++)\n          switch (*q)\n          {\n            case '<': (void) WriteBlobString(image,\"&lt;\"); break;\n            case '>': (void) WriteBlobString(image,\"&gt;\"); break;\n            case '&': (void) WriteBlobString(image,\"&amp;\"); break;\n            default: (void) WriteBlobByte(image,(unsigned char) *q); break;\n          }\n        (void) WriteBlobString(image,\"</desc>\\n\");\n        continue;\n      }\n    primitive_type=UndefinedPrimitive;\n    switch (*keyword)\n    {\n      case ';':\n        break;\n      case 'a':\n      case 'A':\n      {\n        if (LocaleCompare(\"affine\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.sx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.rx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ry=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.sy=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.tx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ty=StringToDouble(token,&next_token);\n            break;\n          }\n        if (LocaleCompare(\"alpha\",keyword) == 0)\n          {\n            primitive_type=AlphaPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"angle\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.rx=StringToDouble(token,&next_token);\n            affine.ry=StringToDouble(token,&next_token);\n            break;\n          }\n        if (LocaleCompare(\"arc\",keyword) == 0)\n          {\n            primitive_type=ArcPrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'b':\n      case 'B':\n      {\n        if (LocaleCompare(\"bezier\",keyword) == 0)\n          {\n            primitive_type=BezierPrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'c':\n      case 'C':\n      {\n        if (LocaleCompare(\"clip-path\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"clip-path:url(#%s);\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"clip-rule\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"clip-rule:%s;\",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"clip-units\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"clipPathUnits=%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"circle\",keyword) == 0)\n          {\n            primitive_type=CirclePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"color\",keyword) == 0)\n          {\n            primitive_type=ColorPrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'd':\n      case 'D':\n      {\n        if (LocaleCompare(\"decorate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"text-decoration:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'e':\n      case 'E':\n      {\n        if (LocaleCompare(\"ellipse\",keyword) == 0)\n          {\n            primitive_type=EllipsePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'f':\n      case 'F':\n      {\n        if (LocaleCompare(\"fill\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"fill:%s;\",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"fill-rule\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"fill-rule:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"fill-opacity\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"fill-opacity:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-family\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-family:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-stretch\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-stretch:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-style\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-style:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-size\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-size:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"font-weight\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"font-weight:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'g':\n      case 'G':\n      {\n        if (LocaleCompare(\"gradient-units\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        if (LocaleCompare(\"text-align\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"text-align %s \",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"text-anchor\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"text-anchor %s \",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'i':\n      case 'I':\n      {\n        if (LocaleCompare(\"image\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            primitive_type=ImagePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'k':\n      case 'K':\n      {\n        if (LocaleCompare(\"kerning\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"kerning:%s;\",\n              token);\n            (void) WriteBlobString(image,message);\n          }\n        break;\n      }\n      case 'l':\n      case 'L':\n      {\n        if (LocaleCompare(\"letter-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"letter-spacing:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"line\",keyword) == 0)\n          {\n            primitive_type=LinePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'o':\n      case 'O':\n      {\n        if (LocaleCompare(\"opacity\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"opacity %s \",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'p':\n      case 'P':\n      {\n        if (LocaleCompare(\"path\",keyword) == 0)\n          {\n            primitive_type=PathPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"point\",keyword) == 0)\n          {\n            primitive_type=PointPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"polyline\",keyword) == 0)\n          {\n            primitive_type=PolylinePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"polygon\",keyword) == 0)\n          {\n            primitive_type=PolygonPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"pop\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (LocaleCompare(\"clip-path\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"</clipPath>\\n\");\n                break;\n              }\n            if (LocaleCompare(\"defs\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"</defs>\\n\");\n                break;\n              }\n            if (LocaleCompare(\"gradient\",token) == 0)\n              {\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"</%sGradient>\\n\",type);\n                (void) WriteBlobString(image,message);\n                break;\n              }\n            if (LocaleCompare(\"graphic-context\",token) == 0)\n              {\n                n--;\n                if (n < 0)\n                  ThrowWriterException(DrawError,\n                    \"UnbalancedGraphicContextPushPop\");\n                (void) WriteBlobString(image,\"</g>\\n\");\n              }\n            if (LocaleCompare(\"pattern\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"</pattern>\\n\");\n                break;\n              }\n            if (LocaleCompare(\"symbol\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"</symbol>\\n\");\n                break;\n              }\n            if ((LocaleCompare(\"defs\",token) == 0) ||\n                (LocaleCompare(\"symbol\",token) == 0))\n              (void) WriteBlobString(image,\"</g>\\n\");\n            break;\n          }\n        if (LocaleCompare(\"push\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (LocaleCompare(\"clip-path\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"<clipPath id=\\\"%s\\\">\\n\",token);\n                (void) WriteBlobString(image,message);\n                break;\n              }\n            if (LocaleCompare(\"defs\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"<defs>\\n\");\n                break;\n              }\n            if (LocaleCompare(\"gradient\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(name,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(type,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                svg_info.segment.x1=StringToDouble(token,&next_token);\n                svg_info.element.cx=StringToDouble(token,&next_token);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.segment.y1=StringToDouble(token,&next_token);\n                svg_info.element.cy=StringToDouble(token,&next_token);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.segment.x2=StringToDouble(token,&next_token);\n                svg_info.element.major=StringToDouble(token,\n                  (char **) NULL);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.segment.y2=StringToDouble(token,&next_token);\n                svg_info.element.minor=StringToDouble(token,\n                  (char **) NULL);\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"<%sGradient id=\\\"%s\\\" x1=\\\"%g\\\" y1=\\\"%g\\\" x2=\\\"%g\\\" \"\n                  \"y2=\\\"%g\\\">\\n\",type,name,svg_info.segment.x1,\n                  svg_info.segment.y1,svg_info.segment.x2,svg_info.segment.y2);\n                if (LocaleCompare(type,\"radial\") == 0)\n                  {\n                    (void) GetNextToken(q,&q,extent,token);\n                    if (*token == ',')\n                      (void) GetNextToken(q,&q,extent,token);\n                    svg_info.element.angle=StringToDouble(token,\n                      (char **) NULL);\n                    (void) FormatLocaleString(message,MagickPathExtent,\n                      \"<%sGradient id=\\\"%s\\\" cx=\\\"%g\\\" cy=\\\"%g\\\" r=\\\"%g\\\" \"\n                      \"fx=\\\"%g\\\" fy=\\\"%g\\\">\\n\",type,name,\n                      svg_info.element.cx,svg_info.element.cy,\n                      svg_info.element.angle,svg_info.element.major,\n                      svg_info.element.minor);\n                  }\n                (void) WriteBlobString(image,message);\n                break;\n              }\n            if (LocaleCompare(\"graphic-context\",token) == 0)\n              {\n                n++;\n                if (active)\n                  {\n                    AffineToTransform(image,&affine);\n                    active=MagickFalse;\n                  }\n                (void) WriteBlobString(image,\"<g style=\\\"\");\n                active=MagickTrue;\n              }\n            if (LocaleCompare(\"pattern\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(name,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                svg_info.bounds.x=StringToDouble(token,&next_token);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.bounds.y=StringToDouble(token,&next_token);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.bounds.width=StringToDouble(token,\n                  (char **) NULL);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                svg_info.bounds.height=StringToDouble(token,(char **) NULL);\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"<pattern id=\\\"%s\\\" x=\\\"%g\\\" y=\\\"%g\\\" width=\\\"%g\\\" \"\n                  \"height=\\\"%g\\\">\\n\",name,svg_info.bounds.x,svg_info.bounds.y,\n                  svg_info.bounds.width,svg_info.bounds.height);\n                (void) WriteBlobString(image,message);\n                break;\n              }\n            if (LocaleCompare(\"symbol\",token) == 0)\n              {\n                (void) WriteBlobString(image,\"<symbol>\\n\");\n                break;\n              }\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'r':\n      case 'R':\n      {\n        if (LocaleCompare(\"rectangle\",keyword) == 0)\n          {\n            primitive_type=RectanglePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"roundRectangle\",keyword) == 0)\n          {\n            primitive_type=RoundRectanglePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"rotate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"rotate(%s) \",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 's':\n      case 'S':\n      {\n        if (LocaleCompare(\"scale\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.sx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.sy=StringToDouble(token,&next_token);\n            break;\n          }\n        if (LocaleCompare(\"skewX\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"skewX(%s) \",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"skewY\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"skewY(%s) \",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stop-color\",keyword) == 0)\n          {\n            char\n              color[MagickPathExtent];\n\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CopyMagickString(color,token,MagickPathExtent);\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"  <stop offset=\\\"%s\\\" stop-color=\\\"%s\\\" />\\n\",token,color);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\"stroke:%s;\",\n              token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-antialias\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-antialias:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-dasharray\",keyword) == 0)\n          {\n            if (IsPoint(q))\n              {\n                ssize_t\n                  k;\n\n                p=q;\n                (void) GetNextToken(p,&p,extent,token);\n                for (k=0; IsPoint(token); k++)\n                  (void) GetNextToken(p,&p,extent,token);\n                (void) WriteBlobString(image,\"stroke-dasharray:\");\n                for (j=0; j < k; j++)\n                {\n                  (void) GetNextToken(q,&q,extent,token);\n                  (void) FormatLocaleString(message,MagickPathExtent,\"%s \",\n                    token);\n                  (void) WriteBlobString(image,message);\n                }\n                (void) WriteBlobString(image,\";\");\n                break;\n              }\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-dasharray:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-dashoffset\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-dashoffset:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-linecap\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-linecap:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-linejoin\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-linejoin:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-miterlimit\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-miterlimit:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-opacity\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-opacity:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"stroke-width\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"stroke-width:%s;\",token);\n            (void) WriteBlobString(image,message);\n            continue;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 't':\n      case 'T':\n      {\n        if (LocaleCompare(\"text\",keyword) == 0)\n          {\n            primitive_type=TextPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"text-antialias\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) FormatLocaleString(message,MagickPathExtent,\n              \"text-antialias:%s;\",token);\n            (void) WriteBlobString(image,message);\n            break;\n          }\n        if (LocaleCompare(\"tspan\",keyword) == 0)\n          {\n            primitive_type=TextPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"translate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.tx=StringToDouble(token,&next_token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ty=StringToDouble(token,&next_token);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'v':\n      case 'V':\n      {\n        if (LocaleCompare(\"viewbox\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      default:\n      {\n        status=MagickFalse;\n        break;\n      }\n    }\n    if (status == MagickFalse)\n      break;\n    if (primitive_type == UndefinedPrimitive)\n      continue;\n    /*\n      Parse the primitive attributes.\n    */\n    i=0;\n    j=0;\n    for (x=0; *q != '\\0'; x++)\n    {\n      /*\n        Define points.\n      */\n      if (IsPoint(q) == MagickFalse)\n        break;\n      (void) GetNextToken(q,&q,extent,token);\n      point.x=StringToDouble(token,&next_token);\n      (void) GetNextToken(q,&q,extent,token);\n      if (*token == ',')\n        (void) GetNextToken(q,&q,extent,token);\n      point.y=StringToDouble(token,&next_token);\n      (void) GetNextToken(q,(const char **) NULL,extent,token);\n      if (*token == ',')\n        (void) GetNextToken(q,&q,extent,token);\n      primitive_info[i].primitive=primitive_type;\n      primitive_info[i].point=point;\n      primitive_info[i].coordinates=0;\n      primitive_info[i].method=FloodfillMethod;\n      i++;\n      if (i < (ssize_t) (number_points-6*BezierQuantum-360))\n        continue;\n      number_points+=6*BezierQuantum+360;\n      primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,\n        number_points,sizeof(*primitive_info));\n      if (primitive_info == (PrimitiveInfo *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          break;\n        }\n    }\n    primitive_info[j].primitive=primitive_type;\n    primitive_info[j].coordinates=(size_t) x;\n    primitive_info[j].method=FloodfillMethod;\n    primitive_info[j].text=(char *) NULL;\n    if (active)\n      {\n        AffineToTransform(image,&affine);\n        active=MagickFalse;\n      }\n    active=MagickFalse;\n    switch (primitive_type)\n    {\n      case PointPrimitive:\n      default:\n      {\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        break;\n      }\n      case LinePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n          (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <line x1=\\\"%g\\\" y1=\\\"%g\\\" x2=\\\"%g\\\" y2=\\\"%g\\\"/>\\n\",\n          primitive_info[j].point.x,primitive_info[j].point.y,\n          primitive_info[j+1].point.x,primitive_info[j+1].point.y);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case RectanglePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n          (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <rect x=\\\"%g\\\" y=\\\"%g\\\" width=\\\"%g\\\" height=\\\"%g\\\"/>\\n\",\n          primitive_info[j].point.x,primitive_info[j].point.y,\n          primitive_info[j+1].point.x-primitive_info[j].point.x,\n          primitive_info[j+1].point.y-primitive_info[j].point.y);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case RoundRectanglePrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <rect x=\\\"%g\\\" y=\\\"%g\\\" width=\\\"%g\\\" height=\\\"%g\\\" rx=\\\"%g\\\" \"\n          \"ry=\\\"%g\\\"/>\\n\",primitive_info[j].point.x,\n          primitive_info[j].point.y,primitive_info[j+1].point.x-\n          primitive_info[j].point.x,primitive_info[j+1].point.y-\n          primitive_info[j].point.y,primitive_info[j+2].point.x,\n          primitive_info[j+2].point.y);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case ArcPrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        break;\n      }\n      case EllipsePrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n          (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <ellipse cx=\\\"%g\\\" cy=\\\"%g\\\" rx=\\\"%g\\\" ry=\\\"%g\\\"/>\\n\",\n          primitive_info[j].point.x,primitive_info[j].point.y,\n          primitive_info[j+1].point.x,primitive_info[j+1].point.y);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case CirclePrimitive:\n      {\n        double\n          alpha,\n          beta;\n\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        alpha=primitive_info[j+1].point.x-primitive_info[j].point.x;\n        beta=primitive_info[j+1].point.y-primitive_info[j].point.y;\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <circle cx=\\\"%g\\\" cy=\\\"%g\\\" r=\\\"%g\\\"/>\\n\",\n          primitive_info[j].point.x,primitive_info[j].point.y,\n          hypot(alpha,beta));\n        (void) WriteBlobString(image,message);\n        break;\n      }\n      case PolylinePrimitive:\n      {\n        if (primitive_info[j].coordinates < 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) CopyMagickString(message,\"  <polyline points=\\\"\",\n           MagickPathExtent);\n        (void) WriteBlobString(image,message);\n        length=strlen(message);\n        for ( ; j < i; j++)\n        {\n          (void) FormatLocaleString(message,MagickPathExtent,\"%g,%g \",\n            primitive_info[j].point.x,primitive_info[j].point.y);\n          length+=strlen(message);\n          if (length >= 80)\n            {\n              (void) WriteBlobString(image,\"\\n    \");\n              length=strlen(message)+5;\n            }\n          (void) WriteBlobString(image,message);\n        }\n        (void) WriteBlobString(image,\"\\\"/>\\n\");\n        break;\n      }\n      case PolygonPrimitive:\n      {\n        if (primitive_info[j].coordinates < 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        primitive_info[i]=primitive_info[j];\n        primitive_info[i].coordinates=0;\n        primitive_info[j].coordinates++;\n        i++;\n        (void) CopyMagickString(message,\"  <polygon points=\\\"\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,message);\n        length=strlen(message);\n        for ( ; j < i; j++)\n        {\n          (void) FormatLocaleString(message,MagickPathExtent,\"%g,%g \",\n            primitive_info[j].point.x,primitive_info[j].point.y);\n          length+=strlen(message);\n          if (length >= 80)\n            {\n              (void) WriteBlobString(image,\"\\n    \");\n              length=strlen(message)+5;\n            }\n          (void) WriteBlobString(image,message);\n        }\n        (void) WriteBlobString(image,\"\\\"/>\\n\");\n        break;\n      }\n      case BezierPrimitive:\n      {\n        if (primitive_info[j].coordinates < 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        break;\n      }\n      case PathPrimitive:\n      {\n        int\n          number_attributes;\n\n        (void) GetNextToken(q,&q,extent,token);\n        number_attributes=1;\n        for (p=token; *p != '\\0'; p++)\n          if (isalpha((int) ((unsigned char) *p)) != 0)\n            number_attributes++;\n        if (i > (ssize_t) (number_points-6*BezierQuantum*number_attributes-1))\n          {\n            number_points+=6*BezierQuantum*number_attributes;\n            primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,\n              number_points,sizeof(*primitive_info));\n            if (primitive_info == (PrimitiveInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                  image->filename);\n                break;\n              }\n          }\n        (void) WriteBlobString(image,\"  <path d=\\\"\");\n        (void) WriteBlobString(image,token);\n        (void) WriteBlobString(image,\"\\\"/>\\n\");\n        break;\n      }\n      case AlphaPrimitive:\n      case ColorPrimitive:\n      {\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        if (LocaleCompare(\"point\",token) == 0)\n          primitive_info[j].method=PointMethod;\n        if (LocaleCompare(\"replace\",token) == 0)\n          primitive_info[j].method=ReplaceMethod;\n        if (LocaleCompare(\"floodfill\",token) == 0)\n          primitive_info[j].method=FloodfillMethod;\n        if (LocaleCompare(\"filltoborder\",token) == 0)\n          primitive_info[j].method=FillToBorderMethod;\n        if (LocaleCompare(\"reset\",token) == 0)\n          primitive_info[j].method=ResetMethod;\n        break;\n      }\n      case TextPrimitive:\n      {\n        register char\n          *p;\n\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <text x=\\\"%g\\\" y=\\\"%g\\\">\",primitive_info[j].point.x,\n          primitive_info[j].point.y);\n        (void) WriteBlobString(image,message);\n        for (p=token; *p != '\\0'; p++)\n          switch (*p)\n          {\n            case '<': (void) WriteBlobString(image,\"&lt;\"); break;\n            case '>': (void) WriteBlobString(image,\"&gt;\"); break;\n            case '&': (void) WriteBlobString(image,\"&amp;\"); break;\n            default: (void) WriteBlobByte(image,(unsigned char) *p); break;\n          }\n        (void) WriteBlobString(image,\"</text>\\n\");\n        break;\n      }\n      case ImagePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"  <image x=\\\"%g\\\" y=\\\"%g\\\" width=\\\"%g\\\" height=\\\"%g\\\" \"\n          \"href=\\\"%s\\\"/>\\n\",primitive_info[j].point.x,\n          primitive_info[j].point.y,primitive_info[j+1].point.x,\n          primitive_info[j+1].point.y,token);\n        (void) WriteBlobString(image,message);\n        break;\n      }\n    }\n    if (primitive_info == (PrimitiveInfo *) NULL)\n      break;\n    primitive_info[i].primitive=UndefinedPrimitive;\n    if (status == MagickFalse)\n      break;\n  }\n  (void) WriteBlobString(image,\"</svg>\\n\");\n  /*\n    Relinquish resources.\n  */\n  token=DestroyString(token);\n  if (primitive_info != (PrimitiveInfo *) NULL)\n    primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/svg.c"], "buggy_code_start_loc": [69], "buggy_code_end_loc": [3592], "fixing_code_start_loc": [69], "fixing_code_end_loc": [3598], "type": "CWE-674", "message": "ImageMagick before 7.0.9-0 allows remote attackers to cause a denial of service because XML_PARSE_HUGE is not properly restricted in coders/svg.c, related to SVG and libxml2.", "other": {"cve": {"id": "CVE-2019-18853", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-11T15:15:12.203", "lastModified": "2021-04-28T18:29:07.470", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick before 7.0.9-0 allows remote attackers to cause a denial of service because XML_PARSE_HUGE is not properly restricted in coders/svg.c, related to SVG and libxml2."}, {"lang": "es", "value": "ImageMagick versiones anteriores a 7.0.9-0, permite a atacantes remotos causar una denegaci\u00f3n de servicio porque XML_PARSE_HUGE no est\u00e1 restringido apropiadamente en el archivo coders/svg.c, relacionado con SVG y libxml2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.9-0", "matchCriteriaId": "010CA5D7-72FB-40D2-B832-30482C376823"}]}]}], "references": [{"url": "https://fortiguard.com/zeroday/FG-VD-19-136", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/ec9c8944af2bfc65c697ca44f93a727a99b405f1", "source": "cve@mitre.org", "tags": ["Patch", "Tool Signature"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/ec9c8944af2bfc65c697ca44f93a727a99b405f1"}}