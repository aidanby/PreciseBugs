{"buggy_code": ["/*-\n * Copyright (c) 2014 Nahanni Systems Inc.\n * Copyright (c) 2015 xhyve developers\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer\n *    in this position and unchanged.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * virtio entropy device emulation.\n * Randomness is sourced from /dev/random which does not block\n * once it has been seeded at bootup.\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <pthread.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/param.h>\n#include <sys/uio.h>\n#include <xhyve/support/misc.h>\n#include <xhyve/support/linker_set.h>\n#include <xhyve/xhyve.h>\n#include <xhyve/pci_emul.h>\n#include <xhyve/virtio.h>\n\n#define VTRND_RINGSZ 64\n\n\nstatic int pci_vtrnd_debug;\n#define DPRINTF(params) if (pci_vtrnd_debug) printf params\n#define WPRINTF(params) printf params\n\n/*\n * Per-device softc\n */\nstruct pci_vtrnd_softc {\n\tstruct virtio_softc vrsc_vs;\n\tstruct vqueue_info  vrsc_vq;\n\tpthread_mutex_t     vrsc_mtx;\n\tuint64_t            vrsc_cfg;\n\tint                 vrsc_fd;\n};\n\nstatic void pci_vtrnd_reset(void *);\nstatic void pci_vtrnd_notify(void *, struct vqueue_info *);\n\nstatic struct virtio_consts vtrnd_vi_consts = {\n\t\"vtrnd\",\t\t/* our name */\n\t1,\t\t\t/* we support 1 virtqueue */\n\t0,\t\t\t/* config reg size */\n\tpci_vtrnd_reset,\t/* reset */\n\tpci_vtrnd_notify,\t/* device-wide qnotify */\n\tNULL,\t\t\t/* read virtio config */\n\tNULL,\t\t\t/* write virtio config */\n\tNULL,\t\t\t/* apply negotiated features */\n\t0,\t\t\t/* our capabilities */\n};\n\n\nstatic void\npci_vtrnd_reset(void *vsc)\n{\n\tstruct pci_vtrnd_softc *sc;\n\n\tsc = vsc;\n\n\tDPRINTF((\"vtrnd: device reset requested !\\n\"));\n\tvi_reset_dev(&sc->vrsc_vs);\n}\n\n\nstatic void\npci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\n\tsc = vsc;\n\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\n\t\t/* Catastrophe if unable to read from /dev/random */\n\t\tassert(len > 0);\n\n\t\t/*\n\t\t * Release this chain and handle more\n\t\t */\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t/* Generate interrupt if appropriate. */\n}\n\n\nstatic int\npci_vtrnd_init(struct pci_devinst *pi, UNUSED char *opts)\n{\n\tstruct pci_vtrnd_softc *sc;\n\tint fd;\n\tint len;\n\tuint8_t v;\n\n\t/*\n\t * Should always be able to open /dev/random.\n\t */\n\tfd = open(\"/dev/random\", O_RDONLY | O_NONBLOCK);\n\n\tassert(fd >= 0);\n\n\t/*\n\t * Check that device is seeded and non-blocking.\n\t */\n\tlen = (int) read(fd, &v, sizeof(v));\n\tif (len <= 0) {\n\t\tWPRINTF((\"vtrnd: /dev/random not ready, read(): %d\", len));\n\t\treturn (1);\n\t}\n\n\tsc = calloc(1, sizeof(struct pci_vtrnd_softc));\n\n\tvi_softc_linkup(&sc->vrsc_vs, &vtrnd_vi_consts, sc, pi, &sc->vrsc_vq);\n\tsc->vrsc_vs.vs_mtx = &sc->vrsc_mtx;\n\n\tsc->vrsc_vq.vq_qsize = VTRND_RINGSZ;\n\n\t/* keep /dev/random opened while emulating */\n\tsc->vrsc_fd = fd;\n\n\t/* initialize config space */\n\tpci_set_cfgdata16(pi, PCIR_DEVICE, VIRTIO_DEV_RANDOM);\n\tpci_set_cfgdata16(pi, PCIR_VENDOR, VIRTIO_VENDOR);\n\tpci_set_cfgdata8(pi, PCIR_CLASS, PCIC_CRYPTO);\n\tpci_set_cfgdata16(pi, PCIR_SUBDEV_0, VIRTIO_TYPE_ENTROPY);\n\tpci_set_cfgdata16(pi, PCIR_SUBVEND_0, VIRTIO_VENDOR);\n\n\tif (vi_intr_init(&sc->vrsc_vs, 1, fbsdrun_virtio_msix()))\n\t\treturn (1);\n\tvi_set_io_bar(&sc->vrsc_vs, 0);\n\n\treturn (0);\n}\n\n\nstatic struct pci_devemu pci_de_vrnd = {\n\t.pe_emu =\t\"virtio-rnd\",\n\t.pe_init =\tpci_vtrnd_init,\n\t.pe_barwrite =\tvi_pci_write,\n\t.pe_barread =\tvi_pci_read\n};\nPCI_EMUL_SET(pci_de_vrnd);\n"], "fixing_code": ["/*-\n * Copyright (c) 2014 Nahanni Systems Inc.\n * Copyright (c) 2015 xhyve developers\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer\n *    in this position and unchanged.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * virtio entropy device emulation.\n * Randomness is sourced from /dev/random which does not block\n * once it has been seeded at bootup.\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <pthread.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/param.h>\n#include <sys/uio.h>\n#include <xhyve/support/misc.h>\n#include <xhyve/support/linker_set.h>\n#include <xhyve/xhyve.h>\n#include <xhyve/pci_emul.h>\n#include <xhyve/virtio.h>\n\n#define VTRND_RINGSZ 64\n\n\nstatic int pci_vtrnd_debug;\n#define DPRINTF(params) if (pci_vtrnd_debug) printf params\n#define WPRINTF(params) printf params\n\n/*\n * Per-device softc\n */\nstruct pci_vtrnd_softc {\n\tstruct virtio_softc vrsc_vs;\n\tstruct vqueue_info  vrsc_vq;\n\tpthread_mutex_t     vrsc_mtx;\n\tuint64_t            vrsc_cfg;\n\tint                 vrsc_fd;\n};\n\nstatic void pci_vtrnd_reset(void *);\nstatic void pci_vtrnd_notify(void *, struct vqueue_info *);\n\nstatic struct virtio_consts vtrnd_vi_consts = {\n\t\"vtrnd\",\t\t/* our name */\n\t1,\t\t\t/* we support 1 virtqueue */\n\t0,\t\t\t/* config reg size */\n\tpci_vtrnd_reset,\t/* reset */\n\tpci_vtrnd_notify,\t/* device-wide qnotify */\n\tNULL,\t\t\t/* read virtio config */\n\tNULL,\t\t\t/* write virtio config */\n\tNULL,\t\t\t/* apply negotiated features */\n\t0,\t\t\t/* our capabilities */\n};\n\n\nstatic void\npci_vtrnd_reset(void *vsc)\n{\n\tstruct pci_vtrnd_softc *sc;\n\n\tsc = vsc;\n\n\tDPRINTF((\"vtrnd: device reset requested !\\n\"));\n\tvi_reset_dev(&sc->vrsc_vs);\n}\n\n\nstatic void\npci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len, n;\n\tuint16_t idx;\n\n\tsc = vsc;\n\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\n\twhile (vq_has_descs(vq)) {\n\t\tn = vq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tif (n < 0) {\n\t\t\tfprintf(stderr, \"vtrnd: vtrnd_notify(): n %d\\r\\n\", n);\n\t\t\treturn;\n\t\t}\n\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\n\t\t/* Catastrophe if unable to read from /dev/random */\n\t\tassert(len > 0);\n\n\t\t/*\n\t\t * Release this chain and handle more\n\t\t */\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t/* Generate interrupt if appropriate. */\n}\n\n\nstatic int\npci_vtrnd_init(struct pci_devinst *pi, UNUSED char *opts)\n{\n\tstruct pci_vtrnd_softc *sc;\n\tint fd;\n\tint len;\n\tuint8_t v;\n\n\t/*\n\t * Should always be able to open /dev/random.\n\t */\n\tfd = open(\"/dev/random\", O_RDONLY | O_NONBLOCK);\n\n\tassert(fd >= 0);\n\n\t/*\n\t * Check that device is seeded and non-blocking.\n\t */\n\tlen = (int) read(fd, &v, sizeof(v));\n\tif (len <= 0) {\n\t\tWPRINTF((\"vtrnd: /dev/random not ready, read(): %d\", len));\n\t\treturn (1);\n\t}\n\n\tsc = calloc(1, sizeof(struct pci_vtrnd_softc));\n\n\tvi_softc_linkup(&sc->vrsc_vs, &vtrnd_vi_consts, sc, pi, &sc->vrsc_vq);\n\tsc->vrsc_vs.vs_mtx = &sc->vrsc_mtx;\n\n\tsc->vrsc_vq.vq_qsize = VTRND_RINGSZ;\n\n\t/* keep /dev/random opened while emulating */\n\tsc->vrsc_fd = fd;\n\n\t/* initialize config space */\n\tpci_set_cfgdata16(pi, PCIR_DEVICE, VIRTIO_DEV_RANDOM);\n\tpci_set_cfgdata16(pi, PCIR_VENDOR, VIRTIO_VENDOR);\n\tpci_set_cfgdata8(pi, PCIR_CLASS, PCIC_CRYPTO);\n\tpci_set_cfgdata16(pi, PCIR_SUBDEV_0, VIRTIO_TYPE_ENTROPY);\n\tpci_set_cfgdata16(pi, PCIR_SUBVEND_0, VIRTIO_VENDOR);\n\n\tif (vi_intr_init(&sc->vrsc_vs, 1, fbsdrun_virtio_msix()))\n\t\treturn (1);\n\tvi_set_io_bar(&sc->vrsc_vs, 0);\n\n\treturn (0);\n}\n\n\nstatic struct pci_devemu pci_de_vrnd = {\n\t.pe_emu =\t\"virtio-rnd\",\n\t.pe_init =\tpci_vtrnd_init,\n\t.pe_barwrite =\tvi_pci_write,\n\t.pe_barread =\tvi_pci_read\n};\nPCI_EMUL_SET(pci_de_vrnd);\n"], "filenames": ["src/lib/pci_virtio_rnd.c"], "buggy_code_start_loc": [103], "buggy_code_end_loc": [115], "fixing_code_start_loc": [103], "fixing_code_end_loc": [119], "type": "CWE-908", "message": "HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107 and prior of HyperKit, the implementation of `qnotify` at `pci_vtrnd_notify` fails to check the return value of `vq_getchain`. This leads to `struct iovec iov;` being uninitialized and used to read memory in `len = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);` when an attacker is able to make `vq_getchain` fail. This issue may lead to a guest crashing the host causing a denial of service and, under certain circumstance, memory corruption. This issue is fixed in commit 41272a980197917df8e58ff90642d14dec8fe948.", "other": {"cve": {"id": "CVE-2021-32845", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-17T23:15:11.963", "lastModified": "2023-02-28T20:29:26.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107 and prior of HyperKit, the implementation of `qnotify` at `pci_vtrnd_notify` fails to check the return value of `vq_getchain`. This leads to `struct iovec iov;` being uninitialized and used to read memory in `len = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);` when an attacker is able to make `vq_getchain` fail. This issue may lead to a guest crashing the host causing a denial of service and, under certain circumstance, memory corruption. This issue is fixed in commit 41272a980197917df8e58ff90642d14dec8fe948."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mobyproject:hyperkit:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.20210107", "matchCriteriaId": "0AE32831-24E2-44FD-939C-E6F799A5D632"}]}]}], "references": [{"url": "https://github.com/moby/hyperkit/commit/41272a980197917df8e58ff90642d14dec8fe948", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/moby/hyperkit/pull/313", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2021-054_057-moby-hyperkit/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/moby/hyperkit/commit/41272a980197917df8e58ff90642d14dec8fe948"}}