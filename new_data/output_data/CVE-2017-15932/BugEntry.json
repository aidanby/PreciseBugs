{"buggy_code": ["/* radare - LGPL - Copyright 2008-2017 - nibble, pancake, alvaro_fe */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"elf.h\"\n\n#ifdef IFDBG\n#undef IFDBG\n#endif\n\n#define DO_THE_DBG 0\n#define IFDBG if (DO_THE_DBG)\n#define IFINT if (0)\n\n#define ELF_PAGE_MASK 0xFFFFFFFFFFFFF000LL\n#define ELF_PAGE_SIZE 12\n\n#define R_ELF_NO_RELRO 0\n#define R_ELF_PART_RELRO 1\n#define R_ELF_FULL_RELRO 2\n\n#define bprintf if(bin->verbose)eprintf\n\n#define READ8(x, i) r_read_ble8(x + i); i += 1;\n#define READ16(x, i) r_read_ble16(x + i, bin->endian); i += 2;\n#define READ32(x, i) r_read_ble32(x + i, bin->endian); i += 4;\n#define READ64(x, i) r_read_ble64(x + i, bin->endian); i += 8;\n\n#define GROWTH_FACTOR (1.5)\n\nstatic inline int __strnlen(const char *str, int len) {\n\tint l = 0;\n\twhile (IS_PRINTABLE (*str) && --len) {\n\t\tif (((ut8)*str) == 0xff) {\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t\tl++;\n\t}\n\treturn l + 1;\n}\n\nstatic int handle_e_ident(ELFOBJ *bin) {\n\treturn !strncmp ((char *)bin->ehdr.e_ident, ELFMAG, SELFMAG) ||\n\t\t   !strncmp ((char *)bin->ehdr.e_ident, CGCMAG, SCGCMAG);\n}\n\nstatic int init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tbprintf (\"Warning: read (magic)\\n\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine{EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_486=6, \"\n\t\t\t\" EM_860=7, EM_MIPS=8, EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11,\"\n\t\t\t\" EM_UNKNOWN12=12, EM_UNKNOWN13=13, EM_UNKNOWN14=14, \"\n\t\t\t\" EM_PA_RISC=15, EM_PARISC=EM_PA_RISC, EM_nCUBE=16, EM_VPP500=17,\"\n\t\t\t\" EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, \"\n\t\t\t\" EM_S390=22, EM_UNKNOWN22=EM_S390, EM_UNKNOWN23=23, EM_UNKNOWN24=24,\"\n\t\t\t\" EM_UNKNOWN25=25, EM_UNKNOWN26=26, EM_UNKNOWN27=27, EM_UNKNOWN28=28,\"\n\t\t\t\" EM_UNKNOWN29=29, EM_UNKNOWN30=30, EM_UNKNOWN31=31, EM_UNKNOWN32=32,\"\n\t\t\t\" EM_UNKNOWN33=33, EM_UNKNOWN34=34, EM_UNKNOWN35=35, EM_V800=36,\"\n\t\t\t\" EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40, EM_ALPHA=41, EM_SH=42,\"\n\t\t\t\" EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46, EM_H8_300H=47,\"\n\t\t\t\" EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51, EM_COLDFIRE=52,\"\n\t\t\t\" EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_AMD64=62,\"\n\t\t\t\" EM_X86_64=EM_AMD64, EM_PDSP=63, EM_UNKNOWN64=64, EM_UNKNOWN65=65,\"\n\t\t\t\" EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69, EM_68HC11=70,\"\n\t\t\t\" EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75, \"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80,\"\n\t\t\t\" EM_HUANY=81, EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86,\"\n\t\t\t\" EM_V850=87, EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91,\"\n\t\t\t\" EM_OPENRISC=92, EM_ARC_A5=93, EM_XTENSA=94, EM_NUM=95};\", 0);\n\tsdb_num_set (bin->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (bin->kv, \"elf_header.size\", sizeof (Elf_(Ehdr)), 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_header.format\", \"[16]z[2]E[2]Exqqqxwwwwww\"\n\t\t\" ident (elf_type)type (elf_machine)machine version entry phoff shoff flags ehsize\"\n\t\t\" phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"[16]z[2]E[2]Exxxxxwwwwww\"\n\t\t\" ident (elf_type)type (elf_machine)machine version entry phoff shoff flags ehsize\"\n\t\t\" phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (Elf_(Ehdr)));\n\tif (len < 1) {\n\t\tbprintf (\"Warning: read (ehdr)\\n\");\n\t\treturn false;\n\t}\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\ti = 16;\n\tbin->ehdr.e_type = READ16 (ehdr, i)\n\tbin->ehdr.e_machine = READ16 (ehdr, i)\n\tbin->ehdr.e_version = READ32 (ehdr, i)\n#if R_BIN_ELF64\n\tbin->ehdr.e_entry = READ64 (ehdr, i)\n\tbin->ehdr.e_phoff = READ64 (ehdr, i)\n\tbin->ehdr.e_shoff = READ64 (ehdr, i)\n#else\n\tbin->ehdr.e_entry = READ32 (ehdr, i)\n\tbin->ehdr.e_phoff = READ32 (ehdr, i)\n\tbin->ehdr.e_shoff = READ32 (ehdr, i)\n#endif\n\tbin->ehdr.e_flags = READ32 (ehdr, i)\n\tbin->ehdr.e_ehsize = READ16 (ehdr, i)\n\tbin->ehdr.e_phentsize = READ16 (ehdr, i)\n\tbin->ehdr.e_phnum = READ16 (ehdr, i)\n\tbin->ehdr.e_shentsize = READ16 (ehdr, i)\n\tbin->ehdr.e_shnum = READ16 (ehdr, i)\n\tbin->ehdr.e_shstrndx = READ16 (ehdr, i)\n\treturn handle_e_ident (bin);\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_type.cparse`; td `k bin/cur/info/elf_machine.cparse`\n\t// > pf `k bin/cur/info/elf_header.format` @ `k bin/cur/info/elf_header.offset`\n}\n\nstatic int init_phdr(ELFOBJ *bin) {\n\tut32 phdr_size;\n\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\tint i, j, len;\n\tif (!bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\tif (bin->phdr) {\n\t\treturn true;\n\t}\n\tif (!UT32_MUL (&phdr_size, (ut32)bin->ehdr.e_phnum, sizeof (Elf_(Phdr)))) {\n\t\treturn false;\n\t}\n\tif (!phdr_size) {\n\t\treturn false;\n\t}\n\tif (phdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (phdr_size > (ut32)bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_phoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_phoff + phdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->phdr = calloc (phdr_size, 1))) {\n\t\tperror (\"malloc (phdr)\");\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr)), phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Warning: read (phdr)\\n\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j)\n#if R_BIN_ELF64\n\t\tbin->phdr[i].p_flags = READ32 (phdr, j)\n\t\tbin->phdr[i].p_offset = READ64 (phdr, j)\n\t\tbin->phdr[i].p_vaddr = READ64 (phdr, j)\n\t\tbin->phdr[i].p_paddr = READ64 (phdr, j)\n\t\tbin->phdr[i].p_filesz = READ64 (phdr, j)\n\t\tbin->phdr[i].p_memsz = READ64 (phdr, j)\n\t\tbin->phdr[i].p_align = READ64 (phdr, j)\n#else\n\t\tbin->phdr[i].p_offset = READ32 (phdr, j)\n\t\tbin->phdr[i].p_vaddr = READ32 (phdr, j)\n\t\tbin->phdr[i].p_paddr = READ32 (phdr, j)\n\t\tbin->phdr[i].p_filesz = READ32 (phdr, j)\n\t\tbin->phdr[i].p_memsz = READ32 (phdr, j)\n\t\tbin->phdr[i].p_flags = READ32 (phdr, j)\n\t\tbin->phdr[i].p_align = READ32 (phdr, j)\n#endif\n\t}\n\tsdb_num_set (bin->kv, \"elf_phdr.offset\", bin->ehdr.e_phoff, 0);\n\tsdb_num_set (bin->kv, \"elf_phdr.size\", sizeof (Elf_(Phdr)), 0);\n\tsdb_set (bin->kv, \"elf_p_type.cparse\", \"enum elf_p_type {PT_NULL=0,PT_LOAD=1,PT_DYNAMIC=2,\"\n\t\t\t\"PT_INTERP=3,PT_NOTE=4,PT_SHLIB=5,PT_PHDR=6,PT_LOOS=0x60000000,\"\n\t\t\t\"PT_HIOS=0x6fffffff,PT_LOPROC=0x70000000,PT_HIPROC=0x7fffffff};\", 0);\n\tsdb_set (bin->kv, \"elf_p_flags.cparse\", \"enum elf_p_flags {PF_None=0,PF_Exec=1,\"\n\t\t\t\"PF_Write=2,PF_Write_Exec=3,PF_Read=4,PF_Read_Exec=5,PF_Read_Write=6,\"\n\t\t\t\"PF_Read_Write_Exec=7};\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_phdr.format\", \"[4]E[4]Eqqqqqq (elf_p_type)type (elf_p_flags)flags\"\n\t\t\t\" offset vaddr paddr filesz memsz align\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_phdr.format\", \"[4]Exxxxx[4]Ex (elf_p_type)type offset vaddr paddr\"\n\t\t\t\" filesz memsz (elf_p_flags)flags align\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_p_type.cparse`; td `k bin/cur/info/elf_p_flags.cparse`\n\t// > pf `k bin/cur/info/elf_phdr.format` @ `k bin/cur/info/elf_phdr.offset`\n}\n\n\nstatic int init_shdr(ELFOBJ *bin) {\n\tut32 shdr_size;\n\tut8 shdr[sizeof (Elf_(Shdr))] = {0};\n\tint i, j, len;\n\n\tif (!bin || bin->shdr) {\n\t\treturn true;\n\t}\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size < 1) {\n\t\treturn false;\n\t}\n\tif (shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff + shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shdr = calloc (1, shdr_size + 1))) {\n\t\tperror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"elf_shdr.offset\", bin->ehdr.e_shoff, 0);\n\tsdb_num_set (bin->kv, \"elf_shdr.size\", sizeof (Elf_(Shdr)), 0);\n\tsdb_set (bin->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Warning: read (shdr) at 0x%\"PFMT64x\"\\n\", (ut64) bin->ehdr.e_shoff);\n\t\t\tR_FREE (bin->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->shdr[i].sh_name = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_type = READ32 (shdr, j)\n#if R_BIN_ELF64\n\t\tbin->shdr[i].sh_flags = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_addr = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_offset = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_size = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_addralign = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_entsize = READ64 (shdr, j)\n#else\n\t\tbin->shdr[i].sh_flags = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_addr = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_offset = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_size = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_addralign = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_entsize = READ32 (shdr, j)\n#endif\n\t}\n\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_s_type.cparse`; td `k bin/cur/info/elf_s_flags_64.cparse`\n\t// > pf `k bin/cur/info/elf_shdr.format` @ `k bin/cur/info/elf_shdr.offset`\n}\n\nstatic int init_strtab(ELFOBJ *bin) {\n\tif (bin->strtab || !bin->shdr) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shstrndx != SHN_UNDEF &&\n\t\t(bin->ehdr.e_shstrndx >= bin->ehdr.e_shnum ||\n\t\t(bin->ehdr.e_shstrndx >= SHN_LORESERVE &&\n\t\tbin->ehdr.e_shstrndx < SHN_HIRESERVE)))\n\t\treturn false;\n\n\t/* sh_size must be lower than UT32_MAX and not equal to zero, to avoid bugs on malloc() */\n\tif (bin->shdr[bin->ehdr.e_shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[bin->ehdr.e_shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[bin->ehdr.e_shstrndx];\n\tbin->shstrtab_size = bin->strtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tperror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\n\tif (bin->shstrtab_section->sh_offset +\n\t\tbin->shstrtab_section->sh_size  > bin->size) {\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\t\t\tbin->shstrtab_section->sh_size + 1) < 1) {\n\t\tbprintf (\"Warning: read (shstrtab) at 0x%\"PFMT64x\"\\n\",\n\t\t\t\t(ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\n\treturn true;\n}\n\nstatic int init_dynamic_section(struct Elf_(r_bin_elf_obj_t) *bin) {\n\tElf_(Dyn) *dyn = NULL;\n\tElf_(Dyn) d = {0};\n\tElf_(Addr) strtabaddr = 0;\n\tut64 offset = 0;\n\tchar *strtab = NULL;\n\tsize_t relentry = 0, strsize = 0;\n\tint entries;\n\tint i, j, len, r;\n\tut8 sdyn[sizeof (Elf_(Dyn))] = {0};\n\tut32 dyn_size = 0;\n\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum ; i++) {\n\t\tif (bin->phdr[i].p_type == PT_DYNAMIC) {\n\t\t\tdyn_size = bin->phdr[i].p_filesz;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\tif (bin->phdr[i].p_filesz > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->phdr[i].p_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->phdr[i].p_offset + sizeof(Elf_(Dyn)) > bin->size) {\n\t\treturn false;\n\t}\n\tfor (entries = 0; entries < (dyn_size / sizeof (Elf_(Dyn))); entries++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->phdr[i].p_offset + entries * sizeof (Elf_(Dyn)), sdyn, sizeof (Elf_(Dyn)));\n\t\tif (len < 1) {\n\t\t\tgoto beach;\n\t\t}\n#if R_BIN_ELF64\n\t\td.d_tag = READ64 (sdyn, j)\n#else\n\t\td.d_tag = READ32 (sdyn, j)\n#endif\n\t\tif (d.d_tag == DT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (entries < 1) {\n\t\treturn false;\n\t}\n\tdyn = (Elf_(Dyn)*)calloc (entries, sizeof (Elf_(Dyn)));\n\tif (!dyn) {\n\t\treturn false;\n\t}\n\tif (!UT32_MUL (&dyn_size, entries, sizeof (Elf_(Dyn)))) {\n\t\tgoto beach;\n\t}\n\tif (!dyn_size) {\n\t\tgoto beach;\n\t}\n\toffset = Elf_(r_bin_elf_v2p) (bin, bin->phdr[i].p_vaddr);\n\tif (offset > bin->size || offset + dyn_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tfor (i = 0; i < entries; i++) {\n\t\tj = 0;\n\t\tr_buf_read_at (bin->b, offset + i * sizeof (Elf_(Dyn)), sdyn, sizeof (Elf_(Dyn)));\n\t\tif (len < 1) {\n\t\t\tbprintf(\"Warning: read (dyn)\\n\");\n\t\t}\n#if R_BIN_ELF64\n\t\tdyn[i].d_tag = READ64 (sdyn, j)\n\t\tdyn[i].d_un.d_ptr = READ64 (sdyn, j)\n#else\n\t\tdyn[i].d_tag = READ32 (sdyn, j)\n\t\tdyn[i].d_un.d_ptr = READ32 (sdyn, j)\n#endif\n\n\t\tswitch (dyn[i].d_tag) {\n\t\tcase DT_STRTAB: strtabaddr = Elf_(r_bin_elf_v2p) (bin, dyn[i].d_un.d_ptr); break;\n\t\tcase DT_STRSZ: strsize = dyn[i].d_un.d_val; break;\n\t\tcase DT_PLTREL: bin->is_rela = dyn[i].d_un.d_val; break;\n\t\tcase DT_RELAENT: relentry = dyn[i].d_un.d_val; break;\n\t\tdefault:\n\t\t\tif ((dyn[i].d_tag >= DT_VERSYM) && (dyn[i].d_tag <= DT_VERNEEDNUM)) {\n\t\t\t\tbin->version_info[DT_VERSIONTAGIDX (dyn[i].d_tag)] = dyn[i].d_un.d_val;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bin->is_rela) {\n\t\tbin->is_rela = sizeof (Elf_(Rela)) == relentry? DT_RELA : DT_REL;\n\t}\n\tif (!strtabaddr || strtabaddr > bin->size || strsize > ST32_MAX || !strsize || strsize > bin->size) {\n\t\tif (!strtabaddr) {\n\t\t\tbprintf (\"Warning: section.shstrtab not found or invalid\\n\");\n\t\t}\n\t\tgoto beach;\n\t}\n\tstrtab = (char *)calloc (1, strsize + 1);\n\tif (!strtab) {\n\t\tgoto beach;\n\t}\n\tif (strtabaddr + strsize > bin->size) {\n\t\tfree (strtab);\n\t\tgoto beach;\n\t}\n\tr = r_buf_read_at (bin->b, strtabaddr, (ut8 *)strtab, strsize);\n\tif (r < 1) {\n\t\tfree (strtab);\n\t\tgoto beach;\n\t}\n\tbin->dyn_buf = dyn;\n\tbin->dyn_entries = entries;\n\tbin->strtab = strtab;\n\tbin->strtab_size = strsize;\n\tr = Elf_(r_bin_elf_has_relro)(bin);\n\tswitch (r) {\n\tcase R_ELF_FULL_RELRO:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"full\", 0);\n\t\tbreak;\n\tcase R_ELF_PART_RELRO:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"partial\", 0);\n\t\tbreak;\n\tdefault:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"no\", 0);\n\t\tbreak;\n\t}\n\tsdb_num_set (bin->kv, \"elf_strtab.offset\", strtabaddr, 0);\n\tsdb_num_set (bin->kv, \"elf_strtab.size\", strsize, 0);\n\treturn true;\nbeach:\n\tfree (dyn);\n\treturn false;\n}\n\nstatic RBinElfSection* get_section_by_name(ELFOBJ *bin, const char *section_name) {\n\tint i;\n\tif (!bin->g_sections) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\tif (!strncmp (bin->g_sections[i].name, section_name, ELF_STRING_LENGTH-1)) {\n\t\t\treturn &bin->g_sections[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic char *get_ver_flags(ut32 flags) {\n\tstatic char buff[32];\n\tbuff[0] = 0;\n\n\tif (!flags) {\n\t\treturn \"none\";\n\t}\n\tif (flags & VER_FLG_BASE) {\n\t\tstrcpy (buff, \"BASE \");\n\t}\n\tif (flags & VER_FLG_WEAK) {\n\t\tif (flags & VER_FLG_BASE) {\n\t\t\tstrcat (buff, \"| \");\n\t\t}\n\t\tstrcat (buff, \"WEAK \");\n\t}\n\n\tif (flags & ~(VER_FLG_BASE | VER_FLG_WEAK)) {\n\t\tstrcat (buff, \"| <unknown>\");\n\t}\n\treturn buff;\n}\n\nstatic Sdb *store_versioninfo_gnu_versym(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tint i;\n\tconst ut64 num_entries = sz / sizeof (Elf_(Versym));\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (!bin->version_info[DT_VERSIONTAGIDX (DT_VERSYM)]) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tut8 *edata = (ut8*) calloc (R_MAX (1, num_entries), sizeof (ut16));\n\tif (!edata) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tut16 *data = (ut16*) calloc (R_MAX (1, num_entries), sizeof (ut16));\n\tif (!data) {\n\t\tfree (edata);\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tut64 off = Elf_(r_bin_elf_v2p) (bin, bin->version_info[DT_VERSIONTAGIDX (DT_VERSYM)]);\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tr_buf_read_at (bin->b, off, edata, sizeof (ut16) * num_entries);\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", num_entries, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\tfor (i = num_entries; i--;) {\n\t\tdata[i] = r_read_ble16 (&edata[i * sizeof (ut16)], bin->endian);\n\t}\n\tR_FREE (edata);\n\tfor (i = 0; i < num_entries; i += 4) {\n\t\tint j;\n\t\tint check_def;\n\t\tchar key[32] = {0};\n\t\tSdb *sdb_entry = sdb_new0 ();\n\t\tsnprintf (key, sizeof (key), \"entry%d\", i / 4);\n\t\tsdb_ns_set (sdb, key, sdb_entry);\n\t\tsdb_num_set (sdb_entry, \"idx\", i, 0);\n\n\t\tfor (j = 0; (j < 4) && (i + j) < num_entries; ++j) {\n\t\t\tint k;\n\t\t\tchar *tmp_val = NULL;\n\t\t\tsnprintf (key, sizeof (key), \"value%d\", j);\n\t\t\tswitch (data[i + j]) {\n\t\t\tcase 0:\n\t\t\t\tsdb_set (sdb_entry, key, \"0 (*local*)\", 0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tsdb_set (sdb_entry, key, \"1 (*global*)\", 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttmp_val = sdb_fmt (0, \"%x \", data[i+j] & 0x7FFF);\n\t\t\t\tcheck_def = true;\n\t\t\t\tif (bin->version_info[DT_VERSIONTAGIDX (DT_VERNEED)]) {\n\t\t\t\t\tElf_(Verneed) vn;\n\t\t\t\t\tut8 svn[sizeof (Elf_(Verneed))] = {0};\n\t\t\t\t\tut64 offset = Elf_(r_bin_elf_v2p) (bin, bin->version_info[DT_VERSIONTAGIDX (DT_VERNEED)]);\n\t\t\t\t\tdo {\n\t\t\t\t\t\tElf_(Vernaux) vna;\n\t\t\t\t\t\tut8 svna[sizeof (Elf_(Vernaux))] = {0};\n\t\t\t\t\t\tut64 a_off;\n\t\t\t\t\t\tif (offset > bin->size || offset + sizeof (vn) > bin->size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, offset, svn, sizeof (svn)) < 0) {\n\t\t\t\t\t\t\tbprintf (\"Warning: Cannot read Verneed for Versym\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvn.vn_version = READ16 (svn, k)\n\t\t\t\t\t\tvn.vn_cnt = READ16 (svn, k)\n\t\t\t\t\t\tvn.vn_file = READ32 (svn, k)\n\t\t\t\t\t\tvn.vn_aux = READ32 (svn, k)\n\t\t\t\t\t\tvn.vn_next = READ32 (svn, k)\n\t\t\t\t\t\ta_off = offset + vn.vn_aux;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (a_off > bin->size || a_off + sizeof (vna) > bin->size) {\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (r_buf_read_at (bin->b, a_off, svna, sizeof (svna)) < 0) {\n\t\t\t\t\t\t\t\tbprintf (\"Warning: Cannot read Vernaux for Versym\\n\");\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\t\tvna.vna_hash = READ32 (svna, k)\n\t\t\t\t\t\t\tvna.vna_flags = READ16 (svna, k)\n\t\t\t\t\t\t\tvna.vna_other = READ16 (svna, k)\n\t\t\t\t\t\t\tvna.vna_name = READ32 (svna, k)\n\t\t\t\t\t\t\tvna.vna_next = READ32 (svna, k)\n\t\t\t\t\t\t\ta_off += vna.vna_next;\n\t\t\t\t\t\t} while (vna.vna_other != data[i + j] && vna.vna_next != 0);\n\n\t\t\t\t\t\tif (vna.vna_other == data[i + j]) {\n\t\t\t\t\t\t\tif (vna.vna_name > bin->strtab_size) {\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsdb_set (sdb_entry, key, sdb_fmt (0, \"%s(%s)\", tmp_val, bin->strtab + vna.vna_name), 0);\n\t\t\t\t\t\t\tcheck_def = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += vn.vn_next;\n\t\t\t\t\t} while (vn.vn_next);\n\t\t\t\t}\n\n\t\t\t\tut64 vinfoaddr = bin->version_info[DT_VERSIONTAGIDX (DT_VERDEF)];\n\t\t\t\tif (check_def && data[i + j] != 0x8001 && vinfoaddr) {\n\t\t\t\t\tElf_(Verdef) vd;\n\t\t\t\t\tut8 svd[sizeof (Elf_(Verdef))] = {0};\n\t\t\t\t\tut64 offset = Elf_(r_bin_elf_v2p) (bin, vinfoaddr);\n\t\t\t\t\tif (offset > bin->size || offset + sizeof (vd) > bin->size) {\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, offset, svd, sizeof (svd)) < 0) {\n\t\t\t\t\t\t\tbprintf (\"Warning: Cannot read Verdef for Versym\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvd.vd_version = READ16 (svd, k)\n\t\t\t\t\t\tvd.vd_flags = READ16 (svd, k)\n\t\t\t\t\t\tvd.vd_ndx = READ16 (svd, k)\n\t\t\t\t\t\tvd.vd_cnt = READ16 (svd, k)\n\t\t\t\t\t\tvd.vd_hash = READ32 (svd, k)\n\t\t\t\t\t\tvd.vd_aux = READ32 (svd, k)\n\t\t\t\t\t\tvd.vd_next = READ32 (svd, k)\n\t\t\t\t\t\toffset += vd.vd_next;\n\t\t\t\t\t} while (vd.vd_ndx != (data[i + j] & 0x7FFF) && vd.vd_next != 0);\n\n\t\t\t\t\tif (vd.vd_ndx == (data[i + j] & 0x7FFF)) {\n\t\t\t\t\t\tElf_(Verdaux) vda;\n\t\t\t\t\t\tut8 svda[sizeof (Elf_(Verdaux))] = {0};\n\t\t\t\t\t\tut64 off_vda = offset - vd.vd_next + vd.vd_aux;\n\t\t\t\t\t\tif (off_vda > bin->size || off_vda + sizeof (vda) > bin->size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, off_vda, svda, sizeof (svda)) < 0) {\n\t\t\t\t\t\t\tbprintf (\"Warning: Cannot read Verdaux for Versym\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvda.vda_name = READ32 (svda, k)\n\t\t\t\t\t\tvda.vda_next = READ32 (svda, k)\n\t\t\t\t\t\tif (vda.vda_name > bin->strtab_size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *name = bin->strtab + vda.vda_name;\n\t\t\t\t\t\tsdb_set (sdb_entry, key, sdb_fmt (0,\"%s(%s%-*s)\", tmp_val, name, (int)(12 - strlen (name)),\")\") , 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\tfree (data);\n\treturn sdb;\n}\n\nstatic Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tvstart += verdef->vd_aux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n\nstatic Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tut8 *end, *need = NULL;\n\tconst char *section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tconst char *link_section_name = \"\";\n\tSdb *sdb_vernaux = NULL;\n\tSdb *sdb_version = NULL;\n\tSdb *sdb = NULL;\n\tint i, cnt;\n\n\tif (!bin || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_size < 1) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {\n\t\tbprintf (\"Warning: Cannot allocate memory for Elf_(Verneed)\\n\");\n\t\tgoto beach;\n\t}\n\tend = need + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tif (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (shdr->sh_offset + shdr->sh_size < shdr->sh_size) {\n\t\tgoto beach;\n\t}\n\ti = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size);\n\tif (i < 0)\n\t\tgoto beach;\n\t//XXX we should use DT_VERNEEDNUM instead of sh_info\n\t//TODO https://sourceware.org/ml/binutils/2014-11/msg00353.html\n\tfor (i = 0, cnt = 0; cnt < shdr->sh_info; ++cnt) {\n\t\tint j, isum;\n\t\tut8 *vstart = need + i;\n\t\tElf_(Verneed) vvn = {0};\n\t\tif (vstart + sizeof (Elf_(Verneed)) > end) {\n\t\t\tgoto beach;\n\t\t}\n\t\tElf_(Verneed) *entry = &vvn;\n\t\tchar key[32] = {0};\n\t\tsdb_version = sdb_new0 ();\n\t\tif (!sdb_version) {\n\t\t\tgoto beach;\n\t\t}\n\t\tj = 0;\n\t\tvvn.vn_version = READ16 (vstart, j)\n\t\tvvn.vn_cnt = READ16 (vstart, j)\n\t\tvvn.vn_file = READ32 (vstart, j)\n\t\tvvn.vn_aux = READ32 (vstart, j)\n\t\tvvn.vn_next = READ32 (vstart, j)\n\n\t\tsdb_num_set (sdb_version, \"vn_version\", entry->vn_version, 0);\n\t\tsdb_num_set (sdb_version, \"idx\", i, 0);\n\t\tif (entry->vn_file > bin->dynstr_size) {\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\tchar *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16);\n\t\t\tsdb_set (sdb_version, \"file_name\", s, 0);\n\t\t\tfree (s);\n\t\t}\n\t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n\t\tst32 vnaux = entry->vn_aux;\n\t\tif (vnaux < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tvstart += vnaux;\n\t\tfor (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) {\n\t\t\tint k;\n\t\t\tElf_(Vernaux) * aux = NULL;\n\t\t\tElf_(Vernaux) vaux = {0};\n\t\t\tsdb_vernaux = sdb_new0 ();\n\t\t\tif (!sdb_vernaux) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\taux = (Elf_(Vernaux)*)&vaux;\n\t\t\tk = 0;\n\t\t\tvaux.vna_hash = READ32 (vstart, k)\n\t\t\tvaux.vna_flags = READ16 (vstart, k)\n\t\t\tvaux.vna_other = READ16 (vstart, k)\n\t\t\tvaux.vna_name = READ32 (vstart, k)\n\t\t\tvaux.vna_next = READ32 (vstart, k)\n\t\t\tif (aux->vna_name > bin->dynstr_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_vernaux, \"idx\", isum, 0);\n\t\t\tif (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) {\n\t\t\t\tchar name [16];\n\t\t\t\tstrncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1);\n\t\t\t\tname[sizeof(name)-1] = 0;\n\t\t\t\tsdb_set (sdb_vernaux, \"name\", name, 0);\n\t\t\t}\n\t\t\tsdb_set (sdb_vernaux, \"flags\", get_ver_flags (aux->vna_flags), 0);\n\t\t\tsdb_num_set (sdb_vernaux, \"version\", aux->vna_other, 0);\n\t\t\tisum += aux->vna_next;\n\t\t\tvstart += aux->vna_next;\n\t\t\tsnprintf (key, sizeof (key), \"vernaux%d\", j);\n\t\t\tsdb_ns_set (sdb_version, key, sdb_vernaux);\n\t\t}\n\t\tif ((int)entry->vn_next < 0) {\n\t\t\tbprintf (\"Invalid vn_next\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += entry->vn_next;\n\t\tsnprintf (key, sizeof (key), \"version%d\", cnt );\n\t\tsdb_ns_set (sdb, key, sdb_version);\n\t\t//if entry->vn_next is 0 it iterate infinitely\n\t\tif (!entry->vn_next) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (need);\n\treturn sdb;\nbeach:\n\tfree (need);\n\tsdb_free (sdb_vernaux);\n\tsdb_free (sdb_version);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n\nstatic Sdb *store_versioninfo(ELFOBJ *bin) {\n\tSdb *sdb_versioninfo = NULL;\n\tint num_verdef = 0;\n\tint num_verneed = 0;\n\tint num_versym = 0;\n\tint i;\n\n\tif (!bin || !bin->shdr) {\n\t\treturn NULL;\n\t}\n\tif (!(sdb_versioninfo = sdb_new0 ())) {\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tSdb *sdb = NULL;\n\t\tchar key[32] = {0};\n\t\tint size = bin->shdr[i].sh_size;\n\n\t\tif (size - (i*sizeof(Elf_(Shdr)) > bin->size)) {\n\t\t\tsize = bin->size - (i*sizeof(Elf_(Shdr)));\n\t\t}\n\t\tint left = size - (i * sizeof (Elf_(Shdr)));\n\t\tleft = R_MIN (left, bin->shdr[i].sh_size);\n\t\tif (left < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (bin->shdr[i].sh_type) {\n\t\tcase SHT_GNU_verdef:\n\t\t\tsdb = store_versioninfo_gnu_verdef (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"verdef%d\", num_verdef++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\tcase SHT_GNU_verneed:\n\t\t\tsdb = store_versioninfo_gnu_verneed (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"verneed%d\", num_verneed++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\tcase SHT_GNU_versym:\n\t\t\tsdb = store_versioninfo_gnu_versym (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"versym%d\", num_versym++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sdb_versioninfo;\n}\n\nstatic bool init_dynstr(ELFOBJ *bin) {\n\tint i, r;\n\tconst char *section_name = NULL;\n\tif (!bin || !bin->shdr) {\n\t\treturn false;\n\t}\n\tif (!bin->shstrtab) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; ++i) {\n\t\tif (bin->shdr[i].sh_name > bin->shstrtab_size) {\n\t\t\treturn false;\n\t\t}\n\t\tsection_name = &bin->shstrtab[bin->shdr[i].sh_name];\n\t\tif (bin->shdr[i].sh_type == SHT_STRTAB && !strcmp (section_name, \".dynstr\")) {\n\t\t\tif (!(bin->dynstr = (char*) calloc (bin->shdr[i].sh_size + 1, sizeof (char)))) {\n\t\t\t\tbprintf(\"Warning: Cannot allocate memory for dynamic strings\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + bin->shdr[i].sh_size > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + bin->shdr[i].sh_size < bin->shdr[i].sh_size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr = r_buf_read_at (bin->b, bin->shdr[i].sh_offset, (ut8*)bin->dynstr, bin->shdr[i].sh_size);\n\t\t\tif (r < 1) {\n\t\t\t\tR_FREE (bin->dynstr);\n\t\t\t\tbin->dynstr_size = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->dynstr_size = bin->shdr[i].sh_size;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int elf_init(ELFOBJ *bin) {\n\tbin->phdr = NULL;\n\tbin->shdr = NULL;\n\tbin->strtab = NULL;\n\tbin->shstrtab = NULL;\n\tbin->strtab_size = 0;\n\tbin->strtab_section = NULL;\n\tbin->dyn_buf = NULL;\n\tbin->dynstr = NULL;\n\tZERO_FILL (bin->version_info);\n\n\tbin->g_sections = NULL;\n\tbin->g_symbols = NULL;\n\tbin->g_imports = NULL;\n\t/* bin is not an ELF */\n\tif (!init_ehdr (bin)) {\n\t\treturn false;\n\t}\n\tif (!init_phdr (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize program headers\\n\");\n\t}\n\tif (!init_shdr (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize section headers\\n\");\n\t}\n\tif (!init_strtab (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize strings table\\n\");\n\t}\n\tif (!init_dynstr (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize dynamic strings\\n\");\n\t}\n\tbin->baddr = Elf_(r_bin_elf_get_baddr) (bin);\n\tif (!init_dynamic_section (bin) && !Elf_(r_bin_elf_get_static)(bin))\n\t\tbprintf (\"Warning: Cannot initialize dynamic section\\n\");\n\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\tbin->symbols_by_ord_size = 0;\n\tbin->symbols_by_ord = NULL;\n\tbin->g_sections = Elf_(r_bin_elf_get_sections) (bin);\n\tbin->boffset = Elf_(r_bin_elf_get_boffset) (bin);\n\tsdb_ns_set (bin->kv, \"versioninfo\", store_versioninfo (bin));\n\n\treturn true;\n}\n\nut64 Elf_(r_bin_elf_get_section_offset)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\tif (!section) return UT64_MAX;\n\treturn section->offset;\n}\n\nut64 Elf_(r_bin_elf_get_section_addr)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva: UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_section_addr_end)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva + section->size: UT64_MAX;\n}\n#define REL (is_rela ? (void*)rela : (void*)rel)\n#define REL_BUF is_rela ? (ut8*)(&rela[k]) : (ut8*)(&rel[k])\n#define REL_OFFSET is_rela ? rela[k].r_offset : rel[k].r_offset\n#define REL_TYPE is_rela ? rela[k].r_info  : rel[k].r_info\n\nstatic ut64 get_import_addr(ELFOBJ *bin, int sym) {\n\tElf_(Rel) *rel = NULL;\n\tElf_(Rela) *rela = NULL;\n\tut8 rl[sizeof (Elf_(Rel))] = {0};\n\tut8 rla[sizeof (Elf_(Rela))] = {0};\n\tRBinElfSection *rel_sec = NULL;\n\tElf_(Addr) plt_sym_addr = -1;\n\tut64 got_addr, got_offset;\n\tut64 plt_addr;\n\tint j, k, tsize, len, nrel;\n\tbool is_rela = false;\n\tconst char *rel_sect[] = { \".rel.plt\", \".rela.plt\", \".rel.dyn\", \".rela.dyn\", NULL };\n\tconst char *rela_sect[] = { \".rela.plt\", \".rel.plt\", \".rela.dyn\", \".rel.dyn\", NULL };\n\n\tif ((!bin->shdr || !bin->strtab) && !bin->phdr) {\n\t\treturn -1;\n\t}\n\tif ((got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got\")) == -1 &&\n\t\t(got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got.plt\")) == -1) {\n\t\treturn -1;\n\t}\n\tif ((got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got\")) == -1 &&\n\t\t(got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.plt\")) == -1) {\n\t\treturn -1;\n\t}\n\tif (bin->is_rela == DT_REL) {\n\t\tj = 0;\n\t\twhile (!rel_sec && rel_sect[j]) {\n\t\t\trel_sec = get_section_by_name (bin, rel_sect[j++]);\n\t\t}\n\t\ttsize = sizeof (Elf_(Rel));\n\t} else if (bin->is_rela == DT_RELA) {\n\t\tj = 0;\n\t\twhile (!rel_sec && rela_sect[j]) {\n\t\t\trel_sec = get_section_by_name (bin, rela_sect[j++]);\n\t\t}\n\t\tis_rela = true;\n\t\ttsize = sizeof (Elf_(Rela));\n\t}\n\tif (!rel_sec) {\n\t\treturn -1;\n\t}\n\tif (rel_sec->size < 1) {\n\t\treturn -1;\n\t}\n\tnrel = (ut32)((int)rel_sec->size / (int)tsize);\n\tif (nrel < 1) {\n\t\treturn -1;\n\t}\n\tif (is_rela) {\n\t\trela = calloc (nrel, tsize);\n\t\tif (!rela) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\trel = calloc (nrel, tsize);\n\t\tif (!rel) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (j = k = 0; j < rel_sec->size && k < nrel; j += tsize, k++) {\n\t\tint l = 0;\n\t\tif (rel_sec->offset + j > bin->size) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (rel_sec->offset + j + tsize > bin->size) {\n\t\t\tgoto out;\n\t\t}\n\t\tlen = r_buf_read_at (\n\t\t\tbin->b, rel_sec->offset + j, is_rela ? rla : rl,\n\t\t\tis_rela ? sizeof (Elf_ (Rela)) : sizeof (Elf_ (Rel)));\n\t\tif (len < 1) {\n\t\t\tgoto out;\n\t\t}\n#if R_BIN_ELF64\n\t\tif (is_rela) {\n\t\t\trela[k].r_offset = READ64 (rla, l)\n\t\t\trela[k].r_info = READ64 (rla, l)\n\t\t\trela[k].r_addend = READ64 (rla, l)\n\t\t} else {\n\t\t\trel[k].r_offset = READ64 (rl, l)\n\t\t\trel[k].r_info = READ64 (rl, l)\n\t\t}\n#else\n\t\tif (is_rela) {\n\t\t\trela[k].r_offset = READ32 (rla, l)\n\t\t\trela[k].r_info = READ32 (rla, l)\n\t\t\trela[k].r_addend = READ32 (rla, l)\n\t\t} else {\n\t\t\trel[k].r_offset = READ32 (rl, l)\n\t\t\trel[k].r_info = READ32 (rl, l)\n\t\t}\n#endif\n\t\tint reloc_type = ELF_R_TYPE (REL_TYPE);\n\t\tint reloc_sym = ELF_R_SYM (REL_TYPE);\n\n\t\tif (reloc_sym == sym) {\n\t\t\tint of = REL_OFFSET;\n\t\t\tof = of - got_addr + got_offset;\n\t\t\tswitch (bin->ehdr.e_machine) {\n\t\t\tcase EM_PPC:\n\t\t\tcase EM_PPC64:\n\t\t\t\t{\n\t\t\t\t\tRBinElfSection *s = get_section_by_name (bin, \".plt\");\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tut8 buf[4];\n\t\t\t\t\t\tut64 base;\n\t\t\t\t\t\tlen = r_buf_read_at (bin->b, s->offset, buf, sizeof (buf));\n\t\t\t\t\t\tif (len < 4) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbase = r_read_be32 (buf);\n\t\t\t\t\t\tbase -= (nrel * 16);\n\t\t\t\t\t\tbase += (k * 16);\n\t\t\t\t\t\tplt_addr = base;\n\t\t\t\t\t\tfree (REL);\n\t\t\t\t\t\treturn plt_addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase EM_SPARC:\n\t\t\tcase EM_SPARCV9:\n\t\t\tcase EM_SPARC32PLUS:\n\t\t\t\tplt_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".plt\");\n\t\t\t\tif (plt_addr == -1) {\n\t\t\t\t\tfree (rela);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (reloc_type == R_386_PC16) {\n\t\t\t\t\tplt_addr += k * 12 + 20;\n\t\t\t\t\t// thumb symbol\n\t\t\t\t\tif (plt_addr & 1) {\n\t\t\t\t\t\tplt_addr--;\n\t\t\t\t\t}\n\t\t\t\t\tfree (REL);\n\t\t\t\t\treturn plt_addr;\n\t\t\t\t} else {\n\t\t\t\t\tbprintf (\"Unknown sparc reloc type %d\\n\", reloc_type);\n\t\t\t\t}\n\t\t\t\t/* SPARC */\n\t\t\t\tbreak;\n\t\t\tcase EM_ARM:\n\t\t\tcase EM_AARCH64:\n\t\t\t\tplt_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".plt\");\n\t\t\t\tif (plt_addr == -1) {\n\t\t\t\t\tfree (rela);\n\t\t\t\t\treturn UT32_MAX;\n\t\t\t\t}\n\t\t\t\tswitch (reloc_type) {\n\t\t\t\tcase R_386_8:\n\t\t\t\t\t{\n\t\t\t\t\t\tplt_addr += k * 12 + 20;\n\t\t\t\t\t\t// thumb symbol\n\t\t\t\t\t\tif (plt_addr & 1) {\n\t\t\t\t\t\t\tplt_addr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (REL);\n\t\t\t\t\t\treturn plt_addr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1026: // arm64 aarch64\n\t\t\t\t\tplt_sym_addr = plt_addr + k * 16 + 32;\n\t\t\t\t\tgoto done;\n\t\t\t\tdefault:\n\t\t\t\t\tbprintf (\"Unsupported relocation type for imports %d\\n\", reloc_type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase EM_386:\n\t\t\tcase EM_X86_64:\n\t\t\t\tswitch (reloc_type) {\n\t\t\t\tcase 1: // unknown relocs found in voidlinux for x86-64\n\t\t\t\t\t// break;\n\t\t\t\tcase R_386_GLOB_DAT:\n\t\t\t\tcase R_386_JMP_SLOT:\n\t\t\t\t\t{\n\t\t\t\t\tut8 buf[8];\n\t\t\t\t\tif (of + sizeof(Elf_(Addr)) < bin->size) {\n\t\t\t\t\t\t// ONLY FOR X86\n\t\t\t\t\t\tif (of > bin->size || of + sizeof (Elf_(Addr)) > bin->size) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = r_buf_read_at (bin->b, of, buf, sizeof (Elf_(Addr)));\n\t\t\t\t\t\tif (len < -1) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplt_sym_addr = sizeof (Elf_(Addr)) == 4\n\t\t\t\t\t\t\t\t\t ? r_read_le32 (buf)\n\t\t\t\t\t\t\t\t\t : r_read_le64 (buf);\n\n\t\t\t\t\t\tif (!plt_sym_addr) {\n\t\t\t\t\t\t\t//XXX HACK ALERT!!!! full relro?? try to fix it \n\t\t\t\t\t\t\t//will there always be .plt.got, what would happen if is .got.plt?\n\t\t\t\t\t\t\tRBinElfSection *s = get_section_by_name (bin, \".plt.got\");\n \t\t\t\t\t\t\tif (Elf_(r_bin_elf_has_relro)(bin) < R_ELF_PART_RELRO || !s) {\n\t\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tplt_addr = s->offset;\n\t\t\t\t\t\t\tof = of + got_addr - got_offset;\n\t\t\t\t\t\t\twhile (plt_addr + 2 + 4 < s->offset + s->size) {\n\t\t\t\t\t\t\t\t/*we try to locate the plt entry that correspond with the relocation\n\t\t\t\t\t\t\t\t  since got does not point back to .plt. In this case it has the following \n\t\t\t\t\t\t\t\t  form\n\n\t\t\t\t\t\t\t\t  ff253a152000   JMP QWORD [RIP + 0x20153A]\n\t\t\t\t\t\t\t\t  6690\t\t     NOP\n\t\t\t\t\t\t\t\t  ----\n\t\t\t\t\t\t\t\t  ff25ec9f0408   JMP DWORD [reloc.puts_236]\n\n\t\t\t\t\t\t\t\t  plt_addr + 2 to remove jmp opcode and get the imm reading 4\n\t\t\t\t\t\t\t\t  and if RIP (plt_addr + 6) + imm == rel->offset \n\t\t\t\t\t\t\t\t  return plt_addr, that will be our sym addr\n\n\t\t\t\t\t\t\t\t  perhaps this hack doesn't work on 32 bits\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tlen = r_buf_read_at (bin->b, plt_addr + 2, buf, 4);\n\t\t\t\t\t\t\t\tif (len < -1) {\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tplt_sym_addr = sizeof (Elf_(Addr)) == 4\n\t\t\t\t\t\t\t\t\t\t? r_read_le32 (buf)\n\t\t\t\t\t\t\t\t\t\t: r_read_le64 (buf);\n\n\t\t\t\t\t\t\t\t//relative address\n\t\t\t\t\t\t\t\tif ((plt_addr + 6 + Elf_(r_bin_elf_v2p) (bin, plt_sym_addr)) == of) {\n\t\t\t\t\t\t\t\t\tplt_sym_addr = plt_addr;\n\t\t\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t\t\t} else if (plt_sym_addr == of) {\n\t\t\t\t\t\t\t\t\tplt_sym_addr = plt_addr;\n\t\t\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tplt_addr += 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tplt_sym_addr -= 6;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbprintf (\"Unsupported relocation type for imports %d\\n\", reloc_type);\n\t\t\t\t\tfree (REL);\n\t\t\t\t\treturn of;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\t// MIPS32 BIG ENDIAN relocs\n\t\t\t\t{\n\t\t\t\t\tRBinElfSection *s = get_section_by_name (bin, \".rela.plt\");\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tut8 buf[1024];\n\t\t\t\t\t\tconst ut8 *base;\n\t\t\t\t\t\tplt_addr = s->rva + s->size;\n\t\t\t\t\t\tlen = r_buf_read_at (bin->b, s->offset + s->size, buf, sizeof (buf));\n\t\t\t\t\t\tif (len != sizeof (buf)) {\n\t\t\t\t\t\t\t// oops\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbase = r_mem_mem_aligned (buf, sizeof (buf), (const ut8*)\"\\x3c\\x0f\\x00\", 3, 4);\n\t\t\t\t\t\tif (base) {\n\t\t\t\t\t\t\tplt_addr += (int)(size_t)(base - buf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tplt_addr += 108 + 8; // HARDCODED HACK\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplt_addr += k * 16;\n\t\t\t\t\t\tfree (REL);\n\t\t\t\t\t\treturn plt_addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Unsupported relocs type %d for arch %d\\n\",\n\t\t\t\t\treloc_type, bin->ehdr.e_machine);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tfree (REL);\n\treturn plt_sym_addr;\nout:\n\tfree (REL);\n\treturn -1;\n}\n\nint Elf_(r_bin_elf_has_nx)(ELFOBJ *bin) {\n\tint i;\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_STACK) {\n\t\t\t\treturn (!(bin->phdr[i].p_flags & 1))? 1: 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Elf_(r_bin_elf_has_relro)(ELFOBJ *bin) {\n\tint i;\n\tbool haveBindNow = false;\n\tbool haveGnuRelro = false;\n\tif (bin && bin->dyn_buf) {\n\t\tfor (i = 0; i < bin->dyn_entries; i++) {\n\t\t\tswitch (bin->dyn_buf[i].d_tag) {\n\t\t\tcase DT_BIND_NOW:\n\t\t\t\thaveBindNow = true;\n\t\t\t\tbreak;\n\t\t\tcase DT_FLAGS:\n\t\t\t\tfor (i++; i < bin->dyn_entries ; i++) {\n\t\t\t\t\tut32 dTag = bin->dyn_buf[i].d_tag;\n\t\t\t\t\tif (!dTag) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (dTag) {\n\t\t\t\t\tcase DT_FLAGS_1:\n\t\t\t\t\t\tif (bin->dyn_buf[i].d_un.d_val & DF_1_NOW) {\n\t\t\t\t\t\t\thaveBindNow = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_RELRO) {\n\t\t\t\thaveGnuRelro = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (haveGnuRelro) {\n\t\tif (haveBindNow) {\n\t\t\treturn R_ELF_FULL_RELRO;\n\t\t}\n\t\treturn R_ELF_PART_RELRO;\n\t}\n\treturn R_ELF_NO_RELRO;\n}\n\n/*\nTo compute the base address, one determines the memory\naddress associated with the lowest p_vaddr value for a\nPT_LOAD segment. One then obtains the base address by\ntruncating the memory address to the nearest multiple\nof the maximum page size\n*/\n\nut64 Elf_(r_bin_elf_get_baddr)(ELFOBJ *bin) {\n\tint i;\n\tut64 tmp, base = UT64_MAX;\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\tif (bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_LOAD) {\n\t\t\t\ttmp = (ut64)bin->phdr[i].p_vaddr & ELF_PAGE_MASK;\n\t\t\t\ttmp = tmp - (tmp % (1 << ELF_PAGE_SIZE));\n\t\t\t\tif (tmp < base) {\n\t\t\t\t\tbase = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (base == UT64_MAX && bin->ehdr.e_type == ET_REL) {\n\t\t//we return our own base address for ET_REL type\n\t\t//we act as a loader for ELF\n\t\treturn 0x08000000;\n\t}\n\treturn base == UT64_MAX ? 0 : base;\n}\n\nut64 Elf_(r_bin_elf_get_boffset)(ELFOBJ *bin) {\n\tint i;\n\tut64 tmp, base = UT64_MAX;\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_LOAD) {\n\t\t\t\ttmp =  (ut64)bin->phdr[i].p_offset & ELF_PAGE_MASK;\n\t\t\t\ttmp = tmp - (tmp % (1 << ELF_PAGE_SIZE));\n\t\t\t\tif (tmp < base) {\n\t\t\t\t\tbase = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn base == UT64_MAX ? 0 : base;\n}\n\nut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[512];\n\tif (!bin) {\n\t\treturn 0LL;\n\t}\n\tif (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {\n\t\tbprintf (\"Warning: read (init_offset)\\n\");\n\t\treturn 0;\n\t}\n\tif (buf[0] == 0x68) { // push // x86 only\n\t\tut64 addr;\n\t\tmemmove (buf, buf+1, 4);\n\t\taddr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n\nut64 Elf_(r_bin_elf_get_fini_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[512];\n\tif (!bin) {\n\t\treturn 0LL;\n\t}\n\n\tif (r_buf_read_at (bin->b, entry+11, buf, sizeof (buf)) == -1) {\n\t\tbprintf (\"Warning: read (get_fini)\\n\");\n\t\treturn 0;\n\t}\n\tif (*buf == 0x68) { // push // x86/32 only\n\t\tut64 addr;\n\t\tmemmove (buf, buf+1, 4);\n\t\taddr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n\nut64 Elf_(r_bin_elf_get_entry_offset)(ELFOBJ *bin) {\n\tut64 entry;\n\tif (!bin) {\n\t\treturn 0LL;\n\t}\n\tentry = bin->ehdr.e_entry;\n\tif (!entry) {\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".init.text\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".text\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".init\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\tif (entry == UT64_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn Elf_(r_bin_elf_v2p) (bin, entry);\n}\n\nstatic ut64 getmainsymbol(ELFOBJ *bin) {\n\tstruct r_bin_elf_symbol_t *symbol;\n\tint i;\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\treturn UT64_MAX;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tif (!strcmp (symbol[i].name, \"main\")) {\n\t\t\tut64 paddr = symbol[i].offset;\n\t\t\treturn Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_main_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[512];\n\tif (!bin) {\n\t\treturn 0LL;\n\t}\n\tif (entry > bin->size || (entry + sizeof (buf)) > bin->size) {\n\t\treturn 0;\n\t}\n\tif (r_buf_read_at (bin->b, entry, buf, sizeof (buf)) < 1) {\n\t\tbprintf (\"Warning: read (main)\\n\");\n\t\treturn 0;\n\t}\n\t// ARM64\n\tif (buf[0x18+3] == 0x58 && buf[0x2f] == 0x00) {\n\t\tut32 entry_vaddr = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tut32 main_addr = r_read_le32 (&buf[0x30]);\n\t\tif ((main_addr >> 16) == (entry_vaddr >> 16)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, main_addr);\n\t\t}\n\t}\n\n\t// TODO: Use arch to identify arch before memcmp's\n\t// ARM\n\tut64 text = Elf_(r_bin_elf_get_section_offset)(bin, \".text\");\n\tut64 text_end = text + bin->size;\n\n\t// ARM-Thumb-Linux\n\tif (entry & 1 && !memcmp (buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\", 6)) {\n\t\tut32 * ptr = (ut32*)(buf+40-1);\n\t\tif (*ptr &1) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, *ptr -1);\n\t\t}\n\t}\n\tif (!memcmp (buf, \"\\x00\\xb0\\xa0\\xe3\\x00\\xe0\\xa0\\xe3\", 8)) {\n\t\t// endian stuff here\n\t\tut32 *addr = (ut32*)(buf+0x34);\n\t\t/*\n\t\t   0x00012000    00b0a0e3     mov fp, 0\n\t\t   0x00012004    00e0a0e3     mov lr, 0\n\t\t*/\n\t\tif (*addr > text && *addr < (text_end)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, *addr);\n\t\t}\n\t}\n\n\t// MIPS\n\t/* get .got, calculate offset of main symbol */\n\tif (!memcmp (buf, \"\\x21\\x00\\xe0\\x03\\x01\\x00\\x11\\x04\", 8)) {\n\n\t\t/*\n\t\t    assuming the startup code looks like\n\t\t        got = gp-0x7ff0\n\t\t        got[index__libc_start_main] ( got[index_main] );\n\n\t\t    looking for the instruction generating the first argument to find main\n\t\t        lw a0, offset(gp)\n\t\t*/\n\n\t\tut64 got_offset;\n\t\tif ((got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got\")) != -1 ||\n\t\t    (got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got.plt\")) != -1)\n\t\t{\n\t\t\tconst ut64 gp = got_offset + 0x7ff0;\n\t\t\tunsigned i;\n\t\t\tfor (i = 0; i < sizeof(buf) / sizeof(buf[0]); i += 4) {\n\t\t\t\tconst ut32 instr = r_read_le32 (&buf[i]);\n\t\t\t\tif ((instr & 0xffff0000) == 0x8f840000) { // lw a0, offset(gp)\n\t\t\t\t\tconst short delta = instr & 0x0000ffff;\n\t\t\t\t\tr_buf_read_at (bin->b, /* got_entry_offset = */ gp + delta, buf, 4);\n\t\t\t\t\treturn Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\t// ARM\n\tif (!memcmp (buf, \"\\x24\\xc0\\x9f\\xe5\\x00\\xb0\\xa0\\xe3\", 8)) {\n\t\tut64 addr = r_read_le32 (&buf[48]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\t// X86-CGC\n\tif (buf[0] == 0xe8 && !memcmp (buf + 5, \"\\x50\\xe8\\x00\\x00\\x00\\x00\\xb8\\x01\\x00\\x00\\x00\\x53\", 12)) {\n\t\tsize_t SIZEOF_CALL = 5;\n\t\tut64 rel_addr = (ut64)((int)(buf[1] + (buf[2] << 8) + (buf[3] << 16) + (buf[4] << 24)));\n\t\tut64 addr = Elf_(r_bin_elf_p2v)(bin, entry + SIZEOF_CALL);\n\t\taddr += rel_addr;\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\t// X86-PIE\n\tif (buf[0x00] == 0x48 && buf[0x1e] == 0x8d && buf[0x11] == 0xe8) {\n\t\tut32 *pmain = (ut32*)(buf + 0x30);\n\t\tut64 vmain = Elf_(r_bin_elf_p2v) (bin, (ut64)*pmain);\n\t\tut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tif (vmain >> 16 == ventry >> 16) {\n\t\t\treturn (ut64)vmain;\n\t\t}\n\t}\n\t// X86-PIE\n\tif (buf[0x1d] == 0x48 && buf[0x1e] == 0x8b) {\n\t\tif (!memcmp (buf, \"\\x31\\xed\\x49\\x89\", 4)) {// linux\n\t\t\tut64 maddr, baddr;\n\t\t\tut8 n32s[sizeof (ut32)] = {0};\n\t\t\tmaddr = entry + 0x24 + r_read_le32 (buf + 0x20);\n\t\t\tif (r_buf_read_at (bin->b, maddr, n32s, sizeof (ut32)) == -1) {\n\t\t\t\tbprintf (\"Warning: read (maddr) 2\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmaddr = (ut64)r_read_le32 (&n32s[0]);\n\t\t\tbaddr = (bin->ehdr.e_entry >> 16) << 16;\n\t\t\tif (bin->phdr) {\n\t\t\t\tbaddr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\t\t}\n\t\t\tmaddr += baddr;\n\t\t\treturn maddr;\n\t\t}\n\t}\n\t// X86-NONPIE\n#if R_BIN_ELF64\n\tif (!memcmp (buf, \"\\x49\\x89\\xd9\", 3) && buf[156] == 0xe8) { // openbsd\n\t\treturn r_read_le32 (&buf[157]) + entry + 156 + 5;\n\t}\n\tif (!memcmp (buf+29, \"\\x48\\xc7\\xc7\", 3)) { // linux\n\t\tut64 addr = (ut64)r_read_le32 (&buf[29 + 3]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n#else\n\tif (buf[23] == '\\x68') {\n\t\tut64 addr = (ut64)r_read_le32 (&buf[23 + 1]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n#endif\n\t/* linux64 pie main -- probably buggy in some cases */\n\tif (buf[29] == 0x48 && buf[30] == 0x8d) { // lea rdi, qword [rip-0x21c4]\n\t\tut8 *p = buf + 32;\n\t\tst32 maindelta = (st32)r_read_le32 (p);\n\t\tut64 vmain = (ut64)(entry + 29 + maindelta) + 7;\n\t\tut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tif (vmain>>16 == ventry>>16) {\n\t\t\treturn (ut64)vmain;\n\t\t}\n\t}\n\t/* find sym.main if possible */\n\t{\n\t\tut64 m = getmainsymbol (bin);\n\t\tif (m != UT64_MAX) return m;\n\t}\n\treturn UT64_MAX;\n}\n\nint Elf_(r_bin_elf_get_stripped)(ELFOBJ *bin) {\n\tint i;\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif (bin->shdr[i].sh_type == SHT_SYMTAB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar *Elf_(r_bin_elf_intrp)(ELFOBJ *bin) {\n\tint i;\n\tif (!bin || !bin->phdr) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\tchar *str = NULL;\n\t\t\tut64 addr = bin->phdr[i].p_offset;\n\t\t\tint sz = bin->phdr[i].p_memsz;\n\t\t\tsdb_num_set (bin->kv, \"elf_header.intrp_addr\", addr, 0);\n\t\t\tsdb_num_set (bin->kv, \"elf_header.intrp_size\", sz, 0);\n\t\t\tif (sz < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstr = malloc (sz + 1);\n\t\t\tif (!str) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, addr, (ut8*)str, sz) < 1) {\n\t\t\t\tbprintf (\"Warning: read (main)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstr[sz] = 0;\n\t\t\tsdb_set (bin->kv, \"elf_header.intrp\", str, 0);\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint Elf_(r_bin_elf_get_static)(ELFOBJ *bin) {\n\tint i;\n\tif (!bin->phdr) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar* Elf_(r_bin_elf_get_data_encoding)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_DATA]) {\n\tcase ELFDATANONE: return strdup (\"none\");\n\tcase ELFDATA2LSB: return strdup (\"2's complement, little endian\");\n\tcase ELFDATA2MSB: return strdup (\"2's complement, big endian\");\n\tdefault: return r_str_newf (\"<unknown: %x>\", bin->ehdr.e_ident[EI_DATA]);\n\t}\n}\n\nint Elf_(r_bin_elf_has_va)(ELFOBJ *bin) {\n\treturn true;\n}\n\nchar* Elf_(r_bin_elf_get_arch)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_ARC:\n\tcase EM_ARC_A5:\n\t\treturn strdup (\"arc\");\n\tcase EM_AVR: return strdup (\"avr\");\n\tcase EM_CRIS: return strdup (\"cris\");\n\tcase EM_68K: return strdup (\"m68k\");\n\tcase EM_MIPS:\n\tcase EM_MIPS_RS3_LE:\n\tcase EM_MIPS_X:\n\t\treturn strdup (\"mips\");\n\tcase EM_MCST_ELBRUS:\n\t\treturn strdup (\"elbrus\");\n\tcase EM_TRICORE:\n\t\treturn strdup (\"tricore\");\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\t\treturn strdup (\"arm\");\n\tcase EM_HEXAGON:\n\t\treturn strdup (\"hexagon\");\n\tcase EM_BLACKFIN:\n\t\treturn strdup (\"blackfin\");\n\tcase EM_SPARC:\n\tcase EM_SPARC32PLUS:\n\tcase EM_SPARCV9:\n\t\treturn strdup (\"sparc\");\n\tcase EM_PPC:\n\tcase EM_PPC64:\n\t\treturn strdup (\"ppc\");\n\tcase EM_PARISC:\n\t\treturn strdup (\"hppa\");\n\tcase EM_PROPELLER:\n\t\treturn strdup (\"propeller\");\n\tcase EM_MICROBLAZE:\n\t\treturn strdup (\"microblaze.gnu\");\n\tcase EM_RISCV:\n\t\treturn strdup (\"riscv\");\n\tcase EM_VAX:\n\t\treturn strdup (\"vax\");\n\tcase EM_XTENSA:\n\t\treturn strdup (\"xtensa\");\n\tcase EM_LANAI:\n\t\treturn strdup (\"lanai\");\n\tcase EM_VIDEOCORE3:\n\tcase EM_VIDEOCORE4:\n\t\treturn strdup (\"vc4\");\n\tcase EM_SH:\n\t\treturn strdup (\"sh\");\n\tcase EM_V850:\n\t\treturn strdup (\"v850\");\n\tcase EM_IA_64:\n\t\treturn strdup(\"ia64\");\n\tdefault: return strdup (\"x86\");\n\t}\n}\n\nchar* Elf_(r_bin_elf_get_machine_name)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_NONE:        return strdup (\"No machine\");\n\tcase EM_M32:         return strdup (\"AT&T WE 32100\");\n\tcase EM_SPARC:       return strdup (\"SUN SPARC\");\n\tcase EM_386:         return strdup (\"Intel 80386\");\n\tcase EM_68K:         return strdup (\"Motorola m68k family\");\n\tcase EM_88K:         return strdup (\"Motorola m88k family\");\n\tcase EM_860:         return strdup (\"Intel 80860\");\n\tcase EM_MIPS:        return strdup (\"MIPS R3000\");\n\tcase EM_S370:        return strdup (\"IBM System/370\");\n\tcase EM_MIPS_RS3_LE: return strdup (\"MIPS R3000 little-endian\");\n\tcase EM_PARISC:      return strdup (\"HPPA\");\n\tcase EM_VPP500:      return strdup (\"Fujitsu VPP500\");\n\tcase EM_SPARC32PLUS: return strdup (\"Sun's \\\"v8plus\\\"\");\n\tcase EM_960:         return strdup (\"Intel 80960\");\n\tcase EM_PPC:         return strdup (\"PowerPC\");\n\tcase EM_PPC64:       return strdup (\"PowerPC 64-bit\");\n\tcase EM_S390:        return strdup (\"IBM S390\");\n\tcase EM_V800:        return strdup (\"NEC V800 series\");\n\tcase EM_FR20:        return strdup (\"Fujitsu FR20\");\n\tcase EM_RH32:        return strdup (\"TRW RH-32\");\n\tcase EM_RCE:         return strdup (\"Motorola RCE\");\n\tcase EM_ARM:         return strdup (\"ARM\");\n\tcase EM_BLACKFIN:    return strdup (\"Analog Devices Blackfin\");\n\tcase EM_FAKE_ALPHA:  return strdup (\"Digital Alpha\");\n\tcase EM_SH:          return strdup (\"Hitachi SH\");\n\tcase EM_SPARCV9:     return strdup (\"SPARC v9 64-bit\");\n\tcase EM_TRICORE:     return strdup (\"Siemens Tricore\");\n\tcase EM_ARC:         return strdup (\"Argonaut RISC Core\");\n\tcase EM_H8_300:      return strdup (\"Hitachi H8/300\");\n\tcase EM_H8_300H:     return strdup (\"Hitachi H8/300H\");\n\tcase EM_H8S:         return strdup (\"Hitachi H8S\");\n\tcase EM_H8_500:      return strdup (\"Hitachi H8/500\");\n\tcase EM_IA_64:       return strdup (\"Intel Merced\");\n\tcase EM_MIPS_X:      return strdup (\"Stanford MIPS-X\");\n\tcase EM_COLDFIRE:    return strdup (\"Motorola Coldfire\");\n\tcase EM_68HC12:      return strdup (\"Motorola M68HC12\");\n\tcase EM_MMA:         return strdup (\"Fujitsu MMA Multimedia Accelerator\");\n\tcase EM_PCP:         return strdup (\"Siemens PCP\");\n\tcase EM_NCPU:        return strdup (\"Sony nCPU embeeded RISC\");\n\tcase EM_NDR1:        return strdup (\"Denso NDR1 microprocessor\");\n\tcase EM_STARCORE:    return strdup (\"Motorola Start*Core processor\");\n\tcase EM_ME16:        return strdup (\"Toyota ME16 processor\");\n\tcase EM_ST100:       return strdup (\"STMicroelectronic ST100 processor\");\n\tcase EM_TINYJ:       return strdup (\"Advanced Logic Corp. Tinyj emb.fam\");\n\tcase EM_X86_64:      return strdup (\"AMD x86-64 architecture\");\n\tcase EM_LANAI:       return strdup (\"32bit LANAI architecture\");\n\tcase EM_PDSP:        return strdup (\"Sony DSP Processor\");\n\tcase EM_FX66:        return strdup (\"Siemens FX66 microcontroller\");\n\tcase EM_ST9PLUS:     return strdup (\"STMicroelectronics ST9+ 8/16 mc\");\n\tcase EM_ST7:         return strdup (\"STmicroelectronics ST7 8 bit mc\");\n\tcase EM_68HC16:      return strdup (\"Motorola MC68HC16 microcontroller\");\n\tcase EM_68HC11:      return strdup (\"Motorola MC68HC11 microcontroller\");\n\tcase EM_68HC08:      return strdup (\"Motorola MC68HC08 microcontroller\");\n\tcase EM_68HC05:      return strdup (\"Motorola MC68HC05 microcontroller\");\n\tcase EM_SVX:         return strdup (\"Silicon Graphics SVx\");\n\tcase EM_ST19:        return strdup (\"STMicroelectronics ST19 8 bit mc\");\n\tcase EM_VAX:         return strdup (\"Digital VAX\");\n\tcase EM_CRIS:        return strdup (\"Axis Communications 32-bit embedded processor\");\n\tcase EM_JAVELIN:     return strdup (\"Infineon Technologies 32-bit embedded processor\");\n\tcase EM_FIREPATH:    return strdup (\"Element 14 64-bit DSP Processor\");\n\tcase EM_ZSP:         return strdup (\"LSI Logic 16-bit DSP Processor\");\n\tcase EM_MMIX:        return strdup (\"Donald Knuth's educational 64-bit processor\");\n\tcase EM_HUANY:       return strdup (\"Harvard University machine-independent object files\");\n\tcase EM_PRISM:       return strdup (\"SiTera Prism\");\n\tcase EM_AVR:         return strdup (\"Atmel AVR 8-bit microcontroller\");\n\tcase EM_FR30:        return strdup (\"Fujitsu FR30\");\n\tcase EM_D10V:        return strdup (\"Mitsubishi D10V\");\n\tcase EM_D30V:        return strdup (\"Mitsubishi D30V\");\n\tcase EM_V850:        return strdup (\"NEC v850\");\n\tcase EM_M32R:        return strdup (\"Mitsubishi M32R\");\n\tcase EM_MN10300:     return strdup (\"Matsushita MN10300\");\n\tcase EM_MN10200:     return strdup (\"Matsushita MN10200\");\n\tcase EM_PJ:          return strdup (\"picoJava\");\n\tcase EM_OPENRISC:    return strdup (\"OpenRISC 32-bit embedded processor\");\n\tcase EM_ARC_A5:      return strdup (\"ARC Cores Tangent-A5\");\n\tcase EM_XTENSA:      return strdup (\"Tensilica Xtensa Architecture\");\n\tcase EM_AARCH64:     return strdup (\"ARM aarch64\");\n\tcase EM_PROPELLER:   return strdup (\"Parallax Propeller\");\n\tcase EM_MICROBLAZE:  return strdup (\"Xilinx MicroBlaze\");\n\tcase EM_RISCV:       return strdup (\"RISC V\");\n\tcase EM_VIDEOCORE3:  return strdup (\"VideoCore III\");\n\tcase EM_VIDEOCORE4:  return strdup (\"VideoCore IV\");\n\tdefault:             return r_str_newf (\"<unknown>: 0x%x\", bin->ehdr.e_machine);\n\t}\n}\n\nchar* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tut32 e_type;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\te_type = (ut32)bin->ehdr.e_type; // cast to avoid warn in iphone-gcc, must be ut16\n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}\n\nchar* Elf_(r_bin_elf_get_elf_class)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASSNONE: return strdup (\"none\");\n\tcase ELFCLASS32:   return strdup (\"ELF32\");\n\tcase ELFCLASS64:   return strdup (\"ELF64\");\n\tdefault:           return r_str_newf (\"<unknown: %x>\", bin->ehdr.e_ident[EI_CLASS]);\n\t}\n}\n\nint Elf_(r_bin_elf_get_bits)(ELFOBJ *bin) {\n\t/* Hack for ARCompact */\n\tif (bin->ehdr.e_machine == EM_ARC_A5) {\n\t\treturn 16;\n\t}\n\t/* Hack for Ps2 */\n\tif (bin->phdr && bin->ehdr.e_machine == EM_MIPS) {\n\t\tconst ut32 mipsType = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\t\tif (bin->ehdr.e_type == ET_EXEC) {\n\t\t\tint i;\n\t\t\tbool haveInterp = false;\n\t\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\t\t\thaveInterp = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!haveInterp && mipsType == EF_MIPS_ARCH_3) {\n\t\t\t\t// Playstation2 Hack\n\t\t\t\treturn 64;\n\t\t\t}\n\t\t}\n\t\t// TODO: show this specific asm.cpu somewhere in bininfo (mips1, mips2, mips3, mips32r2, ...)\n\t\tswitch (mipsType) {\n\t\tcase EF_MIPS_ARCH_1:\n\t\tcase EF_MIPS_ARCH_2:\n\t\tcase EF_MIPS_ARCH_3:\n\t\tcase EF_MIPS_ARCH_4:\n\t\tcase EF_MIPS_ARCH_5:\n\t\tcase EF_MIPS_ARCH_32:\n\t\t\treturn 32;\n\t\tcase EF_MIPS_ARCH_64:\n\t\t\treturn 64;\n\t\tcase EF_MIPS_ARCH_32R2:\n\t\t\treturn 32;\n\t\tcase EF_MIPS_ARCH_64R2:\n\t\t\treturn 64;\n\t\t\tbreak;\n\t\t}\n\t\treturn 32;\n\t}\n\t/* Hack for Thumb */\n\tif (bin->ehdr.e_machine == EM_ARM) {\n\t\tif (bin->ehdr.e_type != ET_EXEC) {\n\t\t\tstruct r_bin_elf_symbol_t *symbol;\n\t\t\tif ((symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\t\t\tint i = 0;\n\t\t\t\tfor (i = 0; !symbol[i].last; i++) {\n\t\t\t\t\tut64 paddr = symbol[i].offset;\n\t\t\t\t\tif (paddr & 1) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\t\t\tif (entry & 1) {\n\t\t\t\treturn 16;\n\t\t\t}\n\t\t}\n\t}\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASS32:   return 32;\n\tcase ELFCLASS64:   return 64;\n\tcase ELFCLASSNONE:\n\tdefault:           return 32; // defaults\n\t}\n}\n\nstatic inline int noodle(ELFOBJ *bin, const char *s) {\n\tconst ut8 *p = bin->b->buf;\n\tif (bin->b->length > 64)  {\n\t\tp += bin->b->length - 64;\n\t} else {\n\t\treturn 0;\n\t}\n\treturn r_mem_mem (p, 64, (const ut8 *)s, strlen (s)) != NULL;\n}\n\nstatic inline int needle(ELFOBJ *bin, const char *s) {\n\tif (bin->shstrtab) {\n\t\tut32 len = bin->shstrtab_size;\n\t\tif (len > 4096) {\n\t\t\tlen = 4096; // avoid slow loading .. can be buggy?\n\t\t}\n\t\treturn r_mem_mem ((const ut8*)bin->shstrtab, len,\n\t\t\t\t(const ut8*)s, strlen (s)) != NULL;\n\t}\n\treturn 0;\n}\n\n// TODO: must return const char * all those strings must be const char os[LINUX] or so\nchar* Elf_(r_bin_elf_get_osabi_name)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_OSABI]) {\n\tcase ELFOSABI_LINUX: return strdup(\"linux\");\n\tcase ELFOSABI_SOLARIS: return strdup(\"solaris\");\n\tcase ELFOSABI_FREEBSD: return strdup(\"freebsd\");\n\tcase ELFOSABI_HPUX: return strdup(\"hpux\");\n\t}\n\t/* Hack to identify OS */\n\tif (needle (bin, \"openbsd\")) return strdup (\"openbsd\");\n\tif (needle (bin, \"netbsd\")) return strdup (\"netbsd\");\n\tif (needle (bin, \"freebsd\")) return strdup (\"freebsd\");\n\tif (noodle (bin, \"BEOS:APP_VERSION\")) return strdup (\"beos\");\n\tif (needle (bin, \"GNU\")) return strdup (\"linux\");\n\treturn strdup (\"linux\");\n}\n\nut8 *Elf_(r_bin_elf_grab_regstate)(ELFOBJ *bin, int *len) {\n\tif (bin->phdr) {\n\t\tint i;\n\t\tint num = bin->ehdr.e_phnum;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (bin->phdr[i].p_type != PT_NOTE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint bits = Elf_(r_bin_elf_get_bits)(bin);\n\t\t\tint regdelta = (bits == 64)? 0x84: 0x40; // x64 vs x32\n\t\t\tint regsize = 160; // for x86-64\n\t\t\tut8 *buf = malloc (regsize);\n\t\t\tif (r_buf_read_at (bin->b, bin->phdr[i].p_offset + regdelta, buf, regsize) != regsize) {\n\t\t\t\tfree (buf);\n\t\t\t\tbprintf (\"Cannot read register state from CORE file\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (len) {\n\t\t\t\t*len = regsize;\n\t\t\t}\n\t\t\treturn buf;\n\t\t}\n\t}\n\tbprintf (\"Cannot find NOTE section\\n\");\n\treturn NULL;\n}\n\nint Elf_(r_bin_elf_is_big_endian)(ELFOBJ *bin) {\n\treturn (bin->ehdr.e_ident[EI_DATA] == ELFDATA2MSB);\n}\n\n/* XXX Init dt_strtab? */\nchar *Elf_(r_bin_elf_get_rpath)(ELFOBJ *bin) {\n\tchar *ret = NULL;\n\tint j;\n\n\tif (!bin || !bin->phdr || !bin->dyn_buf || !bin->strtab) {\n\t\treturn NULL;\n\t}\n\tfor (j = 0; j< bin->dyn_entries; j++) {\n\t\tif (bin->dyn_buf[j].d_tag == DT_RPATH || bin->dyn_buf[j].d_tag == DT_RUNPATH) {\n\t\t\tif (!(ret = calloc (1, ELF_STRING_LENGTH))) {\n\t\t\t\tperror (\"malloc (rpath)\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->dyn_buf[j].d_un.d_val > bin->strtab_size) {\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrncpy (ret, bin->strtab + bin->dyn_buf[j].d_un.d_val, ELF_STRING_LENGTH);\n\t\t\tret[ELF_STRING_LENGTH - 1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstatic size_t get_relocs_num(ELFOBJ *bin) {\n\tsize_t i, size, ret = 0;\n\t/* we need to be careful here, in malformed files the section size might\n\t * not be a multiple of a Rel/Rela size; round up so we allocate enough\n\t * space.\n\t */\n#define NUMENTRIES_ROUNDUP(sectionsize, entrysize) (((sectionsize)+(entrysize)-1)/(entrysize))\n\tif (!bin->g_sections) {\n\t\treturn 0;\n\t}\n\tsize = bin->is_rela == DT_REL ? sizeof (Elf_(Rel)) : sizeof (Elf_(Rela));\n\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\tif (!strncmp (bin->g_sections[i].name, \".rela.\", strlen (\".rela.\"))) {\n\t\t\tif (!bin->is_rela) {\n\t\t\t\tsize = sizeof (Elf_(Rela));\n\t\t\t}\n\t\t\tret += NUMENTRIES_ROUNDUP (bin->g_sections[i].size, size);\n\t\t} else if (!strncmp (bin->g_sections[i].name, \".rel.\", strlen (\".rel.\"))){\n\t\t\tif (!bin->is_rela) {\n\t\t\t\tsize = sizeof (Elf_(Rel));\n\t\t\t}\n\t\t\tret += NUMENTRIES_ROUNDUP (bin->g_sections[i].size, size);\n\t\t}\n\t}\n\treturn ret;\n#undef NUMENTRIES_ROUNDUP\n}\n\nstatic int read_reloc(ELFOBJ *bin, RBinElfReloc *r, int is_rela, ut64 offset) {\n\tut8 *buf = bin->b->buf;\n\tint j = 0;\n\tif (offset + sizeof (Elf_ (Rela)) >\n\t\t    bin->size || offset + sizeof (Elf_(Rela)) < offset) {\n\t\treturn -1;\n\t}\n\tif (is_rela == DT_RELA) {\n\t\tElf_(Rela) rela;\n#if R_BIN_ELF64\n\t\trela.r_offset = READ64 (buf + offset, j)\n\t\trela.r_info = READ64 (buf + offset, j)\n\t\trela.r_addend = READ64 (buf + offset, j)\n#else\n\t\trela.r_offset = READ32 (buf + offset, j)\n\t\trela.r_info = READ32 (buf + offset, j)\n\t\trela.r_addend = READ32 (buf + offset, j)\n#endif\n\t\tr->is_rela = is_rela;\n\t\tr->offset = rela.r_offset;\n\t\tr->type = ELF_R_TYPE (rela.r_info);\n\t\tr->sym = ELF_R_SYM (rela.r_info);\n\t\tr->last = 0;\n\t\tr->addend = rela.r_addend;\n\t\treturn sizeof (Elf_(Rela));\n\t} else {\n\t\tElf_(Rel) rel;\n#if R_BIN_ELF64\n\t\trel.r_offset = READ64 (buf + offset, j)\n\t\trel.r_info = READ64 (buf + offset, j)\n#else\n\t\trel.r_offset = READ32 (buf + offset, j)\n\t\trel.r_info = READ32 (buf + offset, j)\n#endif\n\t\tr->is_rela = is_rela;\n\t\tr->offset = rel.r_offset;\n\t\tr->type = ELF_R_TYPE (rel.r_info);\n\t\tr->sym = ELF_R_SYM (rel.r_info);\n\t\tr->last = 0;\n\t\treturn sizeof (Elf_(Rel));\n\t}\n}\n\nRBinElfReloc* Elf_(r_bin_elf_get_relocs)(ELFOBJ *bin) {\n\tint res, rel, rela, i, j;\n\tsize_t reloc_num = 0;\n\tRBinElfReloc *ret = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\treloc_num = get_relocs_num (bin);\n\tif (!reloc_num)\t{\n\t\treturn NULL;\n\t}\n\tbin->reloc_num = reloc_num;\n\tret = (RBinElfReloc*)calloc ((size_t)reloc_num + 1, sizeof(RBinElfReloc));\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n#if DEAD_CODE\n\tut64 section_text_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".text\");\n\tif (section_text_offset == -1) {\n\t\tsection_text_offset = 0;\n\t}\n#endif\n\tfor (i = 0, rel = 0; !bin->g_sections[i].last && rel < reloc_num ; i++) {\n\t\tbool is_rela = 0 == strncmp (bin->g_sections[i].name, \".rela.\", strlen (\".rela.\"));\n\t\tbool is_rel  = 0 == strncmp (bin->g_sections[i].name, \".rel.\",  strlen (\".rel.\"));\n\t\tif (!is_rela && !is_rel) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < bin->g_sections[i].size; j += res) {\n\t\t\tif (bin->g_sections[i].size > bin->size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bin->g_sections[i].offset > bin->size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rel >= reloc_num) {\n\t\t\t\tbprintf (\"Internal error: ELF relocation buffer too small,\"\n\t\t\t\t         \"please file a bug report.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!bin->is_rela) {\n\t\t\t\trela = is_rela? DT_RELA : DT_REL;\n\t\t\t} else {\n\t\t\t\trela = bin->is_rela;\n\t\t\t}\n\t\t\tres = read_reloc (bin, &ret[rel], rela, bin->g_sections[i].offset + j);\n\t\t\tif (j + res > bin->g_sections[i].size) {\n\t\t\t\tbprintf (\"Warning: malformed file, relocation entry #%u is partially beyond the end of section %u.\\n\", rel, i);\n\t\t\t}\n\t\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\t\tif (bin->g_sections[i].info < bin->ehdr.e_shnum && bin->shdr) {\n\t\t\t\t\tret[rel].rva = bin->shdr[bin->g_sections[i].info].sh_offset + ret[rel].offset;\n\t\t\t\t\tret[rel].rva = Elf_(r_bin_elf_p2v) (bin, ret[rel].rva);\n\t\t\t\t} else {\n\t\t\t\t\tret[rel].rva = ret[rel].offset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret[rel].rva = ret[rel].offset;\n\t\t\t\tret[rel].offset = Elf_(r_bin_elf_v2p) (bin, ret[rel].offset);\n\t\t\t}\n\t\t\tret[rel].last = 0;\n\t\t\tif (res < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trel++;\n\t\t}\n\t}\n\tret[reloc_num].last = 1;\n\treturn ret;\n}\n\nRBinElfLib* Elf_(r_bin_elf_get_libs)(ELFOBJ *bin) {\n\tRBinElfLib *ret = NULL;\n\tint j, k;\n\n\tif (!bin || !bin->phdr || !bin->dyn_buf || !bin->strtab || *(bin->strtab+1) == '0') {\n\t\treturn NULL;\n\t}\n\tfor (j = 0, k = 0; j < bin->dyn_entries; j++)\n\t\tif (bin->dyn_buf[j].d_tag == DT_NEEDED) {\n\t\t\tRBinElfLib *r = realloc (ret, (k + 1) * sizeof (RBinElfLib));\n\t\t\tif (!r) {\n\t\t\t\tperror (\"realloc (libs)\");\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret = r;\n\t\t\tif (bin->dyn_buf[j].d_un.d_val > bin->strtab_size) {\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrncpy (ret[k].name, bin->strtab + bin->dyn_buf[j].d_un.d_val, ELF_STRING_LENGTH);\n\t\t\tret[k].name[ELF_STRING_LENGTH - 1] = '\\0';\n   \t\t\tret[k].last = 0;\n\t\t\tif (ret[k].name[0]) {\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\tRBinElfLib *r = realloc (ret, (k + 1) * sizeof (RBinElfLib));\n\tif (!r) {\n\t\tperror (\"realloc (libs)\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret = r;\n\tret[k].last = 1;\n\treturn ret;\n}\n\nstatic RBinElfSection* get_sections_from_phdr(ELFOBJ *bin) {\n\tRBinElfSection *ret;\n\tint i, num_sections = 0;\n\tut64 reldyn = 0, relava = 0, pltgotva = 0, relva = 0;\n\tut64 reldynsz = 0, relasz = 0, pltgotsz = 0;\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum)\n\t\treturn NULL;\n\n\tfor (i = 0; i < bin->dyn_entries; i++) {\n\t\tswitch (bin->dyn_buf[i].d_tag) {\n\t\tcase DT_REL:\n\t\t\treldyn = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_RELA:\n\t\t\trelva = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_RELSZ:\n\t\t\treldynsz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RELASZ:\n\t\t\trelasz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_PLTGOT:\n\t\t\tpltgotva = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_PLTRELSZ:\n\t\t\tpltgotsz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_JMPREL:\n\t\t\trelava = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tdefault: break;\n\t\t}\n\t}\n\tret = calloc (num_sections + 1, sizeof(RBinElfSection));\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\ti = 0;\n\tif (reldyn) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, reldyn);\n\t\tret[i].rva = reldyn;\n\t\tret[i].size = reldynsz;\n\t\tstrcpy (ret[i].name, \".rel.dyn\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (relava) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, relava);\n\t\tret[i].rva = relava;\n\t\tret[i].size = pltgotsz;\n\t\tstrcpy (ret[i].name, \".rela.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (relva) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, relva);\n\t\tret[i].rva = relva;\n\t\tret[i].size = relasz;\n\t\tstrcpy (ret[i].name, \".rel.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (pltgotva) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, pltgotva);\n\t\tret[i].rva = pltgotva;\n\t\tret[i].size = pltgotsz;\n\t\tstrcpy (ret[i].name, \".got.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tret[i].last = 1;\n\n\treturn ret;\n}\n\nRBinElfSection* Elf_(r_bin_elf_get_sections)(ELFOBJ *bin) {\n\tRBinElfSection *ret = NULL;\n\tchar unknown_s[20], invalid_s[20];\n\tint i, nidx, unknown_c=0, invalid_c=0;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->g_sections) {\n\t\treturn bin->g_sections;\n\t}\n\tif (!bin->shdr) {\n\t\t//we don't give up search in phdr section\n\t\treturn get_sections_from_phdr (bin);\n\t}\n\tif (!(ret = calloc ((bin->ehdr.e_shnum + 1), sizeof (RBinElfSection)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tret[i].offset = bin->shdr[i].sh_offset;\n\t\tret[i].size = bin->shdr[i].sh_size;\n\t\tret[i].align = bin->shdr[i].sh_addralign;\n\t\tret[i].flags = bin->shdr[i].sh_flags;\n\t\tret[i].link = bin->shdr[i].sh_link;\n\t\tret[i].info = bin->shdr[i].sh_info;\n\t\tret[i].type = bin->shdr[i].sh_type;\n\t\tif (bin->ehdr.e_type == ET_REL)\t{\n\t\t\tret[i].rva = bin->baddr + bin->shdr[i].sh_offset;\n\t\t} else {\n\t\t\tret[i].rva = bin->shdr[i].sh_addr;\n\t\t}\n\t\tnidx = bin->shdr[i].sh_name;\n#define SHNAME (int)bin->shdr[i].sh_name\n#define SHNLEN ELF_STRING_LENGTH - 4\n#define SHSIZE (int)bin->shstrtab_size\n\t\tif (nidx < 0 || !bin->shstrtab_section || !bin->shstrtab_size || nidx > bin->shstrtab_size) {\n\t\t\tsnprintf (invalid_s, sizeof (invalid_s) - 4, \"invalid%d\", invalid_c);\n\t\t\tstrncpy (ret[i].name, invalid_s, SHNLEN);\n\t\t\tinvalid_c++;\n\t\t} else {\n\t\t\tif (bin->shstrtab && (SHNAME > 0) && (SHNAME < SHSIZE)) {\n\t\t\t\tstrncpy (ret[i].name, &bin->shstrtab[SHNAME], SHNLEN);\n\t\t\t} else {\n\t\t\t\tif (bin->shdr[i].sh_type == SHT_NULL) {\n\t\t\t\t\t//to follow the same behaviour as readelf\n\t\t\t\t\tstrncpy (ret[i].name, \"\", sizeof (ret[i].name) - 4);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (unknown_s, sizeof (unknown_s)-4, \"unknown%d\", unknown_c);\n\t\t\t\t\tstrncpy (ret[i].name, unknown_s, sizeof (ret[i].name)-4);\n\t\t\t\t\tunknown_c++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret[i].name[ELF_STRING_LENGTH-2] = '\\0';\n\t\tret[i].last = 0;\n\t}\n\tret[i].last = 1;\n\treturn ret;\n}\n\nstatic void fill_symbol_bind_and_type (struct r_bin_elf_symbol_t *ret, Elf_(Sym) *sym) {\n\t#define s_bind(x) ret->bind = x\n\t#define s_type(x) ret->type = x\n\tswitch (ELF_ST_BIND(sym->st_info)) {\n\tcase STB_LOCAL:  s_bind (\"LOCAL\"); break;\n\tcase STB_GLOBAL: s_bind (\"GLOBAL\"); break;\n\tcase STB_WEAK:   s_bind (\"WEAK\"); break;\n\tcase STB_NUM:    s_bind (\"NUM\"); break;\n\tcase STB_LOOS:   s_bind (\"LOOS\"); break;\n\tcase STB_HIOS:   s_bind (\"HIOS\"); break;\n\tcase STB_LOPROC: s_bind (\"LOPROC\"); break;\n\tcase STB_HIPROC: s_bind (\"HIPROC\"); break;\n\tdefault:         s_bind (\"UNKNOWN\");\n\t}\n\tswitch (ELF_ST_TYPE (sym->st_info)) {\n\tcase STT_NOTYPE:  s_type (\"NOTYPE\"); break;\n\tcase STT_OBJECT:  s_type (\"OBJECT\"); break;\n\tcase STT_FUNC:    s_type (\"FUNC\"); break;\n\tcase STT_SECTION: s_type (\"SECTION\"); break;\n\tcase STT_FILE:    s_type (\"FILE\"); break;\n\tcase STT_COMMON:  s_type (\"COMMON\"); break;\n\tcase STT_TLS:     s_type (\"TLS\"); break;\n\tcase STT_NUM:     s_type (\"NUM\"); break;\n\tcase STT_LOOS:    s_type (\"LOOS\"); break;\n\tcase STT_HIOS:    s_type (\"HIOS\"); break;\n\tcase STT_LOPROC:  s_type (\"LOPROC\"); break;\n\tcase STT_HIPROC:  s_type (\"HIPROC\"); break;\n\tdefault:          s_type (\"UNKNOWN\");\n\t}\n}\n\nstatic RBinElfSymbol* get_symbols_from_phdr(ELFOBJ *bin, int type) {\n\tElf_(Sym) *sym = NULL;\n\tElf_(Addr) addr_sym_table = 0;\n\tut8 s[sizeof (Elf_(Sym))] = {0};\n\tRBinElfSymbol *ret = NULL;\n\tint i, j, r, tsize, nsym, ret_ctr;\n\tut64 toffset = 0, tmp_offset;\n\tut32 size, sym_size = 0;\n\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum) {\n\t\treturn NULL;\n\t}\n\tfor (j = 0; j < bin->dyn_entries; j++) {\n\t\tswitch (bin->dyn_buf[j].d_tag) {\n\t\tcase (DT_SYMTAB):\n\t\t\taddr_sym_table = Elf_(r_bin_elf_v2p) (bin, bin->dyn_buf[j].d_un.d_ptr);\n\t\t\tbreak;\n\t\tcase (DT_SYMENT):\n\t\t\tsym_size = bin->dyn_buf[j].d_un.d_val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!addr_sym_table) {\n\t\treturn NULL;\n\t}\n\tif (!sym_size) {\n\t\treturn NULL;\n\t}\n\t//since ELF doesn't specify the symbol table size we may read until the end of the buffer\n\tnsym = (bin->size - addr_sym_table) / sym_size;\n\tif (!UT32_MUL (&size, nsym, sizeof (Elf_ (Sym)))) {\n\t\tgoto beach;\n\t}\n\tif (size < 1) {\n\t\tgoto beach;\n\t}\n\tif (addr_sym_table > bin->size || addr_sym_table + size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (nsym < 1) {\n\t\treturn NULL;\n\t}\n\t// we reserve room for 4096 and grow as needed.\n\tsize_t capacity1 = 4096;\n\tsize_t capacity2 = 4096;\n\tsym = (Elf_(Sym)*) calloc (capacity1, sym_size);\n\tret = (RBinElfSymbol *) calloc (capacity2, sizeof (struct r_bin_elf_symbol_t));\n\tif (!sym || !ret) {\n\t\tgoto beach;\n\t}\n\tfor (i = 1, ret_ctr = 0; i < nsym; i++) {\n\t\tif (i >= capacity1) { // maybe grow\n\t\t\t// You take what you want, but you eat what you take.\n\t\t\tElf_(Sym)* temp_sym = (Elf_(Sym)*) realloc(sym, (capacity1 * GROWTH_FACTOR) * sym_size);\n\t\t\tif (!temp_sym) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsym = temp_sym;\n\t\t\tcapacity1 *= GROWTH_FACTOR;\n\t\t}\n\t\tif (ret_ctr >= capacity2) { // maybe grow\n\t\t\tRBinElfSymbol *temp_ret = realloc (ret, capacity2 * GROWTH_FACTOR * sizeof (struct r_bin_elf_symbol_t));\n\t\t\tif (!temp_ret) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tret = temp_ret;\n\t\t\tcapacity2 *= GROWTH_FACTOR;\n\t\t}\n\t\t// read in one entry\n\t\tr = r_buf_read_at (bin->b, addr_sym_table + i * sizeof (Elf_ (Sym)), s, sizeof (Elf_ (Sym)));\n\t\tif (r < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tint j = 0;\n#if R_BIN_ELF64\n\t\tsym[i].st_name = READ32 (s, j);\n\t\tsym[i].st_info = READ8 (s, j);\n\t\tsym[i].st_other = READ8 (s, j);\n\t\tsym[i].st_shndx = READ16 (s, j);\n\t\tsym[i].st_value = READ64 (s, j);\n\t\tsym[i].st_size = READ64 (s, j);\n#else\n\t\tsym[i].st_name = READ32 (s, j);\n\t\tsym[i].st_value = READ32 (s, j);\n\t\tsym[i].st_size = READ32 (s, j);\n\t\tsym[i].st_info = READ8 (s, j);\n\t\tsym[i].st_other = READ8 (s, j);\n\t\tsym[i].st_shndx = READ16 (s, j);\n#endif\n\t\t// zero symbol is always empty\n\t\t// Examine entry and maybe store\n\t\tif (type == R_BIN_ELF_IMPORTS && sym[i].st_shndx == STN_UNDEF) {\n\t\t\tif (sym[i].st_value) {\n\t\t\t\ttoffset = sym[i].st_value;\n\t\t\t} else if ((toffset = get_import_addr (bin, i)) == -1){\n\t\t\t\ttoffset = 0;\n\t\t\t}\n\t\t\ttsize = 16;\n\t\t} else if (type == R_BIN_ELF_SYMBOLS &&\n\t\t           sym[i].st_shndx != STN_UNDEF &&\n\t\t           ELF_ST_TYPE (sym[i].st_info) != STT_SECTION &&\n\t\t           ELF_ST_TYPE (sym[i].st_info) != STT_FILE) {\n\t\t\ttsize = sym[i].st_size;\n\t\t\ttoffset = (ut64) sym[i].st_value;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\ttmp_offset = Elf_(r_bin_elf_v2p) (bin, toffset);\n\t\tif (tmp_offset > bin->size) {\n\t\t\tgoto done;\n\t\t}\n\t\tif (sym[i].st_name + 2 > bin->strtab_size) {\n\t\t\t// Since we are reading beyond the symbol table what's happening\n\t\t\t// is that some entry is trying to dereference the strtab beyond its capacity\n\t\t\t// is not a symbol so is the end\n\t\t\tgoto done;\n\t\t}\n\t\tret[ret_ctr].offset = tmp_offset;\n\t\tret[ret_ctr].size = tsize;\n\t\t{\n\t\t\tint rest = ELF_STRING_LENGTH - 1;\n\t\t\tint st_name = sym[i].st_name;\n\t\t\tint maxsize = R_MIN (bin->size, bin->strtab_size);\n\t\t\tif (st_name < 0 || st_name >= maxsize) {\n\t\t\t\tret[ret_ctr].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tconst int len = __strnlen (bin->strtab + st_name, rest);\n\t\t\t\tmemcpy (ret[ret_ctr].name, &bin->strtab[st_name], len);\n\t\t\t}\n\t\t}\n\t\tret[ret_ctr].ordinal = i;\n\t\tret[ret_ctr].in_shdr = false;\n\t\tret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\\0';\n\t\tfill_symbol_bind_and_type (&ret[ret_ctr], &sym[i]);\n\t\tret[ret_ctr].last = 0;\n\t\tret_ctr++;\n\t}\ndone:\n\tret[ret_ctr].last = 1;\n\t// Size everything down to only what is used\n\t{\n\t\tnsym = i > 0 ? i : 1;\n\t\tElf_ (Sym) * temp_sym = (Elf_ (Sym)*) realloc (sym, (nsym * GROWTH_FACTOR) * sym_size);\n\t\tif (!temp_sym) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsym = temp_sym;\n\t}\n\t{\n\t\tret_ctr = ret_ctr > 0 ? ret_ctr : 1;\n\t\tRBinElfSymbol *p = (RBinElfSymbol *) realloc (ret, (ret_ctr + 1) * sizeof (RBinElfSymbol));\n\t\tif (!p) {\n\t\t\tgoto beach;\n\t\t}\n\t\tret = p;\n\t}\n\tif (type == R_BIN_ELF_IMPORTS && !bin->imports_by_ord_size) {\n\t\tbin->imports_by_ord_size = ret_ctr + 1;\n\t\tif (ret_ctr > 0) {\n\t\t\tbin->imports_by_ord = (RBinImport * *) calloc (ret_ctr + 1, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t} else if (type == R_BIN_ELF_SYMBOLS && !bin->symbols_by_ord_size && ret_ctr) {\n\t\tbin->symbols_by_ord_size = ret_ctr + 1;\n\t\tif (ret_ctr > 0) {\n\t\t\tbin->symbols_by_ord = (RBinSymbol * *) calloc (ret_ctr + 1, sizeof (RBinSymbol*));\n\t\t}else {\n\t\t\tbin->symbols_by_ord = NULL;\n\t\t}\n\t}\n\tfree (sym);\n\treturn ret;\nbeach:\n\tfree (sym);\n\tfree (ret);\n\treturn NULL;\n}\n\nstatic RBinElfSymbol *Elf_(r_bin_elf_get_phdr_symbols)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_symbols) {\n\t\treturn bin->phdr_symbols;\n\t}\n\tbin->phdr_symbols = get_symbols_from_phdr (bin, R_BIN_ELF_SYMBOLS);\n\treturn bin->phdr_symbols;\n}\n\nstatic RBinElfSymbol *Elf_(r_bin_elf_get_phdr_imports)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_imports) {\n\t\treturn bin->phdr_imports;\n\t}\n\tbin->phdr_imports = get_symbols_from_phdr (bin, R_BIN_ELF_IMPORTS);\n\treturn bin->phdr_imports;\n}\n\nstatic int Elf_(fix_symbols)(ELFOBJ *bin, int nsym, int type, RBinElfSymbol **sym) {\n\tint count = 0;\n\tRBinElfSymbol *ret = *sym;\n\tRBinElfSymbol *phdr_symbols = (type == R_BIN_ELF_SYMBOLS)\n\t\t\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n\tRBinElfSymbol *tmp, *p;\n\tif (phdr_symbols) {\n\t\tRBinElfSymbol *d = ret;\n\t\twhile (!d->last) {\n\t\t\t/* find match in phdr */\n\t\t\tp = phdr_symbols;\n\t\t\twhile (!p->last) {\n\t\t\t\tif (p->offset && d->offset == p->offset) {\n\t\t\t\t\tp->in_shdr = true;\n\t\t\t\t\tif (*p->name && strcmp (d->name, p->name)) {\n\t\t\t\t\t\tstrcpy (d->name, p->name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\td++;\n\t\t}\n\t\tp = phdr_symbols;\n\t\twhile (!p->last) {\n\t\t\tif (!p->in_shdr) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\t/*Take those symbols that are not present in the shdr but yes in phdr*/\n\t\t/*This should only should happen with fucked up binaries*/\n\t\tif (count > 0) {\n\t\t\t/*what happens if a shdr says it has only one symbol? we should look anyway into phdr*/\n\t\t\ttmp = (RBinElfSymbol*)realloc (ret, (nsym + count + 1) * sizeof (RBinElfSymbol));\n\t\t\tif (!tmp) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = tmp;\n\t\t\tret[nsym--].last = 0;\n\t\t\tp = phdr_symbols;\n\t\t\twhile (!p->last) {\n\t\t\t\tif (!p->in_shdr) {\n\t\t\t\t\tmemcpy (&ret[++nsym], p, sizeof (RBinElfSymbol));\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret[nsym + 1].last = 1;\n\t\t}\n\t\t*sym = ret;\n\t\treturn nsym + 1;\n\t}\n\treturn nsym;\n}\n\nstatic RBinElfSymbol* Elf_(_r_bin_elf_get_symbols_imports)(ELFOBJ *bin, int type) {\n\tut32 shdr_size;\n\tint tsize, nsym, ret_ctr = 0, i, j, r, k, newsize;\n\tut64 toffset;\n\tut32 size = 0;\n\tRBinElfSymbol  *ret = NULL;\n\tElf_(Shdr) *strtab_section = NULL;\n\tElf_(Sym) *sym = NULL;\n\tut8 s[sizeof (Elf_(Sym))] = { 0 };\n\tchar *strtab = NULL;\n\n\tif (!bin || !bin->shdr || !bin->ehdr.e_shnum || bin->ehdr.e_shnum == 0xffff) {\n\t\treturn (type == R_BIN_ELF_SYMBOLS)\n\t\t\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n\t}\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size + 8 > bin->size) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif ((type == R_BIN_ELF_IMPORTS && bin->shdr[i].sh_type == (bin->ehdr.e_type == ET_REL ? SHT_SYMTAB : SHT_DYNSYM)) ||\n\t\t\t\t(type == R_BIN_ELF_SYMBOLS && bin->shdr[i].sh_type == (Elf_(r_bin_elf_get_stripped) (bin) ? SHT_DYNSYM : SHT_SYMTAB))) {\n\t\t\tif (bin->shdr[i].sh_link < 1) {\n\t\t\t\t/* oops. fix out of range pointers */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// hack to avoid asan cry\n\t\t\tif ((bin->shdr[i].sh_link * sizeof(Elf_(Shdr))) >= shdr_size) {\n\t\t\t\t/* oops. fix out of range pointers */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrtab_section = &bin->shdr[bin->shdr[i].sh_link];\n\t\t\tif (strtab_section->sh_size > ST32_MAX || strtab_section->sh_size+8 > bin->size) {\n\t\t\t\tbprintf (\"size (syms strtab)\");\n\t\t\t\tfree (ret);\n\t\t\t\tfree (strtab);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!strtab) {\n\t\t\t\tif (!(strtab = (char *)calloc (1, 8 + strtab_section->sh_size))) {\n\t\t\t\t\tbprintf (\"malloc (syms strtab)\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (strtab_section->sh_offset > bin->size ||\n\t\t\t\t\t\tstrtab_section->sh_offset + strtab_section->sh_size > bin->size) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, strtab_section->sh_offset,\n\t\t\t\t\t\t\t(ut8*)strtab, strtab_section->sh_size) == -1) {\n\t\t\t\t\tbprintf (\"Warning: read (syms strtab)\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnewsize = 1 + bin->shdr[i].sh_size;\n\t\t\tif (newsize < 0 || newsize > bin->size) {\n\t\t\t\tbprintf (\"invalid shdr %d size\\n\", i);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tnsym = (int)(bin->shdr[i].sh_size / sizeof (Elf_(Sym)));\n\t\t\tif (nsym < 0) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!(sym = (Elf_(Sym) *)calloc (nsym, sizeof (Elf_(Sym))))) {\n\t\t\t\tbprintf (\"calloc (syms)\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!UT32_MUL (&size, nsym, sizeof (Elf_(Sym)))) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (size < 1 || size > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + size > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfor (j = 0; j < nsym; j++) {\n\t\t\t\tint k = 0;\n\t\t\t\tr = r_buf_read_at (bin->b, bin->shdr[i].sh_offset + j * sizeof (Elf_(Sym)), s, sizeof (Elf_(Sym)));\n\t\t\t\tif (r < 1) {\n\t\t\t\t\tbprintf (\"Warning: read (sym)\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n#if R_BIN_ELF64\n\t\t\t\tsym[j].st_name = READ32 (s, k)\n\t\t\t\tsym[j].st_info = READ8 (s, k)\n\t\t\t\tsym[j].st_other = READ8 (s, k)\n\t\t\t\tsym[j].st_shndx = READ16 (s, k)\n\t\t\t\tsym[j].st_value = READ64 (s, k)\n\t\t\t\tsym[j].st_size = READ64 (s, k)\n#else\n\t\t\t\tsym[j].st_name = READ32 (s, k)\n\t\t\t\tsym[j].st_value = READ32 (s, k)\n\t\t\t\tsym[j].st_size = READ32 (s, k)\n\t\t\t\tsym[j].st_info = READ8 (s, k)\n\t\t\t\tsym[j].st_other = READ8 (s, k)\n\t\t\t\tsym[j].st_shndx = READ16 (s, k)\n#endif\n\t\t\t}\n\t\t\tfree (ret);\n\t\t\tret = calloc (nsym, sizeof (RBinElfSymbol));\n\t\t\tif (!ret) {\n\t\t\t\tbprintf (\"Cannot allocate %d symbols\\n\", nsym);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfor (k = 1, ret_ctr = 0; k < nsym; k++) {\n\t\t\t\tif (type == R_BIN_ELF_IMPORTS && sym[k].st_shndx == STN_UNDEF) {\n\t\t\t\t\tif (sym[k].st_value) {\n\t\t\t\t\t\ttoffset = sym[k].st_value;\n\t\t\t\t\t} else if ((toffset = get_import_addr (bin, k)) == -1){\n\t\t\t\t\t\ttoffset = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttsize = 16;\n\t\t\t\t} else if (type == R_BIN_ELF_SYMBOLS &&\n\t\t\t\t\t   sym[k].st_shndx != STN_UNDEF &&\n\t\t\t\t\t   ELF_ST_TYPE (sym[k].st_info) != STT_SECTION &&\n\t\t\t\t\t   ELF_ST_TYPE (sym[k].st_info) != STT_FILE) {\n\t\t\t\t\t//int idx = sym[k].st_shndx;\n\t\t\t\t\ttsize = sym[k].st_size;\n\t\t\t\t\ttoffset = (ut64)sym[k].st_value; \n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\t\t\tif (sym[k].st_shndx < bin->ehdr.e_shnum)\n\t\t\t\t\t\tret[ret_ctr].offset = sym[k].st_value + bin->shdr[sym[k].st_shndx].sh_offset;\n\t\t\t\t} else {\n\t\t\t\t\tret[ret_ctr].offset = Elf_(r_bin_elf_v2p) (bin, toffset);\n\t\t\t\t}\n\t\t\t\tret[ret_ctr].size = tsize;\n\t\t\t\tif (sym[k].st_name + 2 > strtab_section->sh_size) {\n\t\t\t\t\tbprintf (\"Warning: index out of strtab range\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tint rest = ELF_STRING_LENGTH - 1;\n\t\t\t\t\tint st_name = sym[k].st_name;\n\t\t\t\t\tint maxsize = R_MIN (bin->b->length, strtab_section->sh_size);\n\t\t\t\t\tif (st_name < 0 || st_name >= maxsize) {\n\t\t\t\t\t\tret[ret_ctr].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst size_t len = __strnlen (strtab + sym[k].st_name, rest);\n\t\t\t\t\t\tmemcpy (ret[ret_ctr].name, &strtab[sym[k].st_name], len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret[ret_ctr].ordinal = k;\n\t\t\t\tret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\\0';\n\t\t\t\tfill_symbol_bind_and_type (&ret[ret_ctr], &sym[k]);\n\t\t\t\tret[ret_ctr].last = 0;\n\t\t\t\tret_ctr++;\n\t\t\t}\n\t\t\tret[ret_ctr].last = 1; // ugly dirty hack :D\n\t\t\tR_FREE (strtab);\n\t\t\tR_FREE (sym);\n\t\t}\n\t}\n\tif (!ret) {\n\t\treturn (type == R_BIN_ELF_SYMBOLS)\n\t\t\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n\t}\n\tint max = -1;\n\tRBinElfSymbol *aux = NULL;\n\tnsym = Elf_(fix_symbols) (bin, ret_ctr, type, &ret);\n\tif (nsym == -1) {\n\t\tgoto beach;\n\t}\n\taux = ret;\n\twhile (!aux->last) {\n\t\tif ((int)aux->ordinal > max) {\n\t\t\tmax = aux->ordinal;\n\t\t}\n\t\taux++;\n\t}\n\tnsym = max;\n\tif (type == R_BIN_ELF_IMPORTS) {\n\t\tR_FREE (bin->imports_by_ord);\n\t\tbin->imports_by_ord_size = nsym + 1;\n\t\tbin->imports_by_ord = (RBinImport**)calloc (R_MAX (1, nsym + 1), sizeof (RBinImport*));\n\t} else if (type == R_BIN_ELF_SYMBOLS) {\n\t\tR_FREE (bin->symbols_by_ord);\n\t\tbin->symbols_by_ord_size = nsym + 1;\n\t\tbin->symbols_by_ord = (RBinSymbol**)calloc (R_MAX (1, nsym + 1), sizeof (RBinSymbol*));\n\t}\n\treturn ret;\nbeach:\n\tfree (ret);\n\tfree (sym);\n\tfree (strtab);\n\treturn NULL;\n}\n\nRBinElfSymbol *Elf_(r_bin_elf_get_symbols)(ELFOBJ *bin) {\n\tif (!bin->g_symbols) {\n\t\tbin->g_symbols = Elf_(_r_bin_elf_get_symbols_imports) (bin, R_BIN_ELF_SYMBOLS);\n\t}\n\treturn bin->g_symbols;\n}\n\n\nRBinElfSymbol *Elf_(r_bin_elf_get_imports)(ELFOBJ *bin) {\n\tif (!bin->g_imports) {\n\t\tbin->g_imports = Elf_(_r_bin_elf_get_symbols_imports) (bin, R_BIN_ELF_IMPORTS);\n\t}\n\treturn bin->g_imports;\n}\n\nRBinElfField* Elf_(r_bin_elf_get_fields)(ELFOBJ *bin) {\n\tRBinElfField *ret = NULL;\n\tint i = 0, j;\n\tif (!bin || !(ret = calloc ((bin->ehdr.e_phnum + 3 + 1), sizeof (RBinElfField)))) {\n\t\treturn NULL;\n\t}\n\tstrncpy (ret[i].name, \"ehdr\", ELF_STRING_LENGTH);\n\tret[i].offset = 0;\n\tret[i++].last = 0;\n\tstrncpy (ret[i].name, \"shoff\", ELF_STRING_LENGTH);\n\tret[i].offset = bin->ehdr.e_shoff;\n\tret[i++].last = 0;\n\tstrncpy (ret[i].name, \"phoff\", ELF_STRING_LENGTH);\n\tret[i].offset = bin->ehdr.e_phoff;\n\tret[i++].last = 0;\n\tfor (j = 0; bin->phdr && j < bin->ehdr.e_phnum; i++, j++) {\n\t\tsnprintf (ret[i].name, ELF_STRING_LENGTH, \"phdr_%i\", j);\n\t\tret[i].offset = bin->phdr[j].p_offset;\n\t\tret[i].last = 0;\n\t}\n\tret[i].last = 1;\n\treturn ret;\n}\n\nvoid* Elf_(r_bin_elf_free)(ELFOBJ* bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tfree (bin->phdr);\n\tfree (bin->shdr);\n\tfree (bin->strtab);\n\tfree (bin->dyn_buf);\n\tfree (bin->shstrtab);\n\tfree (bin->dynstr);\n\t//free (bin->strtab_section);\n\tif (bin->imports_by_ord) {\n\t\tfor (i = 0; i<bin->imports_by_ord_size; i++) {\n\t\t\tfree (bin->imports_by_ord[i]);\n\t\t}\n\t\tfree (bin->imports_by_ord);\n\t}\n\tif (bin->symbols_by_ord) {\n\t\tfor (i = 0; i<bin->symbols_by_ord_size; i++) {\n\t\t\tfree (bin->symbols_by_ord[i]);\n\t\t}\n\t\tfree (bin->symbols_by_ord);\n\t}\n\tr_buf_free (bin->b);\n\tif (bin->g_symbols != bin->phdr_symbols) {\n\t\tR_FREE (bin->phdr_symbols);\n\t}\n\tif (bin->g_imports != bin->phdr_imports) {\n\t\tR_FREE (bin->phdr_imports);\n\t}\n\tR_FREE (bin->g_sections);\n\tR_FREE (bin->g_symbols);\n\tR_FREE (bin->g_imports);\n\tfree (bin);\n\treturn NULL;\n}\n\nELFOBJ* Elf_(r_bin_elf_new)(const char* file, bool verbose) {\n\tut8 *buf;\n\tint size;\n\tELFOBJ *bin = R_NEW0 (ELFOBJ);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (ELFOBJ));\n\tbin->file = file;\n\tif (!(buf = (ut8*)r_file_slurp (file, &size))) {\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tbin->size = size;\n\tbin->verbose = verbose;\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tif (!elf_init (bin)) {\n\t\tfree (buf);\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tfree (buf);\n\treturn bin;\n}\n\nELFOBJ* Elf_(r_bin_elf_new_buf)(RBuffer *buf, bool verbose) {\n\tELFOBJ *bin = R_NEW0 (ELFOBJ);\n\tbin->kv = sdb_new0 ();\n\tbin->b = r_buf_new ();\n\tbin->size = (ut32)buf->length;\n\tbin->verbose = verbose;\n\tif (!r_buf_set_bytes (bin->b, buf->buf, buf->length)) {\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tif (!elf_init (bin)) {\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\treturn bin;\n}\n\nstatic int is_in_pphdr (Elf_(Phdr) *p, ut64 addr) {\n\treturn addr >= p->p_offset && addr < p->p_offset + p->p_memsz;\n}\n\nstatic int is_in_vphdr (Elf_(Phdr) *p, ut64 addr) {\n\treturn addr >= p->p_vaddr && addr < p->p_vaddr + p->p_memsz;\n}\n\n\n/* converts a physical address to the virtual address, looking\n * at the program headers in the binary bin */\nut64 Elf_(r_bin_elf_p2v) (ELFOBJ *bin, ut64 paddr) {\n\tint i;\n\n\tif (!bin) return 0;\n\n\tif (!bin->phdr) {\n\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\treturn bin->baddr + paddr;\n\t\t}\n\t\treturn paddr;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; ++i) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\tif (p->p_type == PT_LOAD && is_in_pphdr (p, paddr)) {\n\t\t\tif (!p->p_vaddr && !p->p_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_vaddr + paddr - p->p_offset;\n\t\t}\n\t}\n\n\treturn paddr;\n}\n\n/* converts a virtual address to the relative physical address, looking\n * at the program headers in the binary bin */\nut64 Elf_(r_bin_elf_v2p) (ELFOBJ *bin, ut64 vaddr) {\n\tint i;\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\tif (!bin->phdr) {\n\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\treturn vaddr - bin->baddr;\n\t\t}\n\t\treturn vaddr;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; ++i) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\tif (p->p_type == PT_LOAD && is_in_vphdr (p, vaddr)) {\n\t\t\tif (!p->p_offset && !p->p_vaddr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_offset + vaddr - p->p_vaddr;\n\t\t}\n\t}\n\treturn vaddr;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2008-2017 - nibble, pancake, alvaro_fe */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"elf.h\"\n\n#ifdef IFDBG\n#undef IFDBG\n#endif\n\n#define DO_THE_DBG 0\n#define IFDBG if (DO_THE_DBG)\n#define IFINT if (0)\n\n#define ELF_PAGE_MASK 0xFFFFFFFFFFFFF000LL\n#define ELF_PAGE_SIZE 12\n\n#define R_ELF_NO_RELRO 0\n#define R_ELF_PART_RELRO 1\n#define R_ELF_FULL_RELRO 2\n\n#define bprintf if(bin->verbose)eprintf\n\n#define READ8(x, i) r_read_ble8(x + i); i += 1;\n#define READ16(x, i) r_read_ble16(x + i, bin->endian); i += 2;\n#define READ32(x, i) r_read_ble32(x + i, bin->endian); i += 4;\n#define READ64(x, i) r_read_ble64(x + i, bin->endian); i += 8;\n\n#define GROWTH_FACTOR (1.5)\n\nstatic inline int __strnlen(const char *str, int len) {\n\tint l = 0;\n\twhile (IS_PRINTABLE (*str) && --len) {\n\t\tif (((ut8)*str) == 0xff) {\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t\tl++;\n\t}\n\treturn l + 1;\n}\n\nstatic int handle_e_ident(ELFOBJ *bin) {\n\treturn !strncmp ((char *)bin->ehdr.e_ident, ELFMAG, SELFMAG) ||\n\t\t   !strncmp ((char *)bin->ehdr.e_ident, CGCMAG, SCGCMAG);\n}\n\nstatic int init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tbprintf (\"Warning: read (magic)\\n\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine{EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_486=6, \"\n\t\t\t\" EM_860=7, EM_MIPS=8, EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11,\"\n\t\t\t\" EM_UNKNOWN12=12, EM_UNKNOWN13=13, EM_UNKNOWN14=14, \"\n\t\t\t\" EM_PA_RISC=15, EM_PARISC=EM_PA_RISC, EM_nCUBE=16, EM_VPP500=17,\"\n\t\t\t\" EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, \"\n\t\t\t\" EM_S390=22, EM_UNKNOWN22=EM_S390, EM_UNKNOWN23=23, EM_UNKNOWN24=24,\"\n\t\t\t\" EM_UNKNOWN25=25, EM_UNKNOWN26=26, EM_UNKNOWN27=27, EM_UNKNOWN28=28,\"\n\t\t\t\" EM_UNKNOWN29=29, EM_UNKNOWN30=30, EM_UNKNOWN31=31, EM_UNKNOWN32=32,\"\n\t\t\t\" EM_UNKNOWN33=33, EM_UNKNOWN34=34, EM_UNKNOWN35=35, EM_V800=36,\"\n\t\t\t\" EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40, EM_ALPHA=41, EM_SH=42,\"\n\t\t\t\" EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46, EM_H8_300H=47,\"\n\t\t\t\" EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51, EM_COLDFIRE=52,\"\n\t\t\t\" EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_AMD64=62,\"\n\t\t\t\" EM_X86_64=EM_AMD64, EM_PDSP=63, EM_UNKNOWN64=64, EM_UNKNOWN65=65,\"\n\t\t\t\" EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69, EM_68HC11=70,\"\n\t\t\t\" EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75, \"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80,\"\n\t\t\t\" EM_HUANY=81, EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86,\"\n\t\t\t\" EM_V850=87, EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91,\"\n\t\t\t\" EM_OPENRISC=92, EM_ARC_A5=93, EM_XTENSA=94, EM_NUM=95};\", 0);\n\tsdb_num_set (bin->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (bin->kv, \"elf_header.size\", sizeof (Elf_(Ehdr)), 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_header.format\", \"[16]z[2]E[2]Exqqqxwwwwww\"\n\t\t\" ident (elf_type)type (elf_machine)machine version entry phoff shoff flags ehsize\"\n\t\t\" phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"[16]z[2]E[2]Exxxxxwwwwww\"\n\t\t\" ident (elf_type)type (elf_machine)machine version entry phoff shoff flags ehsize\"\n\t\t\" phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (Elf_(Ehdr)));\n\tif (len < 1) {\n\t\tbprintf (\"Warning: read (ehdr)\\n\");\n\t\treturn false;\n\t}\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\ti = 16;\n\tbin->ehdr.e_type = READ16 (ehdr, i)\n\tbin->ehdr.e_machine = READ16 (ehdr, i)\n\tbin->ehdr.e_version = READ32 (ehdr, i)\n#if R_BIN_ELF64\n\tbin->ehdr.e_entry = READ64 (ehdr, i)\n\tbin->ehdr.e_phoff = READ64 (ehdr, i)\n\tbin->ehdr.e_shoff = READ64 (ehdr, i)\n#else\n\tbin->ehdr.e_entry = READ32 (ehdr, i)\n\tbin->ehdr.e_phoff = READ32 (ehdr, i)\n\tbin->ehdr.e_shoff = READ32 (ehdr, i)\n#endif\n\tbin->ehdr.e_flags = READ32 (ehdr, i)\n\tbin->ehdr.e_ehsize = READ16 (ehdr, i)\n\tbin->ehdr.e_phentsize = READ16 (ehdr, i)\n\tbin->ehdr.e_phnum = READ16 (ehdr, i)\n\tbin->ehdr.e_shentsize = READ16 (ehdr, i)\n\tbin->ehdr.e_shnum = READ16 (ehdr, i)\n\tbin->ehdr.e_shstrndx = READ16 (ehdr, i)\n\treturn handle_e_ident (bin);\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_type.cparse`; td `k bin/cur/info/elf_machine.cparse`\n\t// > pf `k bin/cur/info/elf_header.format` @ `k bin/cur/info/elf_header.offset`\n}\n\nstatic int init_phdr(ELFOBJ *bin) {\n\tut32 phdr_size;\n\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\tint i, j, len;\n\tif (!bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\tif (bin->phdr) {\n\t\treturn true;\n\t}\n\tif (!UT32_MUL (&phdr_size, (ut32)bin->ehdr.e_phnum, sizeof (Elf_(Phdr)))) {\n\t\treturn false;\n\t}\n\tif (!phdr_size) {\n\t\treturn false;\n\t}\n\tif (phdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (phdr_size > (ut32)bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_phoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_phoff + phdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->phdr = calloc (phdr_size, 1))) {\n\t\tperror (\"malloc (phdr)\");\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr)), phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Warning: read (phdr)\\n\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j)\n#if R_BIN_ELF64\n\t\tbin->phdr[i].p_flags = READ32 (phdr, j)\n\t\tbin->phdr[i].p_offset = READ64 (phdr, j)\n\t\tbin->phdr[i].p_vaddr = READ64 (phdr, j)\n\t\tbin->phdr[i].p_paddr = READ64 (phdr, j)\n\t\tbin->phdr[i].p_filesz = READ64 (phdr, j)\n\t\tbin->phdr[i].p_memsz = READ64 (phdr, j)\n\t\tbin->phdr[i].p_align = READ64 (phdr, j)\n#else\n\t\tbin->phdr[i].p_offset = READ32 (phdr, j)\n\t\tbin->phdr[i].p_vaddr = READ32 (phdr, j)\n\t\tbin->phdr[i].p_paddr = READ32 (phdr, j)\n\t\tbin->phdr[i].p_filesz = READ32 (phdr, j)\n\t\tbin->phdr[i].p_memsz = READ32 (phdr, j)\n\t\tbin->phdr[i].p_flags = READ32 (phdr, j)\n\t\tbin->phdr[i].p_align = READ32 (phdr, j)\n#endif\n\t}\n\tsdb_num_set (bin->kv, \"elf_phdr.offset\", bin->ehdr.e_phoff, 0);\n\tsdb_num_set (bin->kv, \"elf_phdr.size\", sizeof (Elf_(Phdr)), 0);\n\tsdb_set (bin->kv, \"elf_p_type.cparse\", \"enum elf_p_type {PT_NULL=0,PT_LOAD=1,PT_DYNAMIC=2,\"\n\t\t\t\"PT_INTERP=3,PT_NOTE=4,PT_SHLIB=5,PT_PHDR=6,PT_LOOS=0x60000000,\"\n\t\t\t\"PT_HIOS=0x6fffffff,PT_LOPROC=0x70000000,PT_HIPROC=0x7fffffff};\", 0);\n\tsdb_set (bin->kv, \"elf_p_flags.cparse\", \"enum elf_p_flags {PF_None=0,PF_Exec=1,\"\n\t\t\t\"PF_Write=2,PF_Write_Exec=3,PF_Read=4,PF_Read_Exec=5,PF_Read_Write=6,\"\n\t\t\t\"PF_Read_Write_Exec=7};\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_phdr.format\", \"[4]E[4]Eqqqqqq (elf_p_type)type (elf_p_flags)flags\"\n\t\t\t\" offset vaddr paddr filesz memsz align\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_phdr.format\", \"[4]Exxxxx[4]Ex (elf_p_type)type offset vaddr paddr\"\n\t\t\t\" filesz memsz (elf_p_flags)flags align\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_p_type.cparse`; td `k bin/cur/info/elf_p_flags.cparse`\n\t// > pf `k bin/cur/info/elf_phdr.format` @ `k bin/cur/info/elf_phdr.offset`\n}\n\n\nstatic int init_shdr(ELFOBJ *bin) {\n\tut32 shdr_size;\n\tut8 shdr[sizeof (Elf_(Shdr))] = {0};\n\tint i, j, len;\n\n\tif (!bin || bin->shdr) {\n\t\treturn true;\n\t}\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size < 1) {\n\t\treturn false;\n\t}\n\tif (shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff + shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shdr = calloc (1, shdr_size + 1))) {\n\t\tperror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"elf_shdr.offset\", bin->ehdr.e_shoff, 0);\n\tsdb_num_set (bin->kv, \"elf_shdr.size\", sizeof (Elf_(Shdr)), 0);\n\tsdb_set (bin->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Warning: read (shdr) at 0x%\"PFMT64x\"\\n\", (ut64) bin->ehdr.e_shoff);\n\t\t\tR_FREE (bin->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->shdr[i].sh_name = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_type = READ32 (shdr, j)\n#if R_BIN_ELF64\n\t\tbin->shdr[i].sh_flags = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_addr = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_offset = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_size = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_addralign = READ64 (shdr, j)\n\t\tbin->shdr[i].sh_entsize = READ64 (shdr, j)\n#else\n\t\tbin->shdr[i].sh_flags = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_addr = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_offset = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_size = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_addralign = READ32 (shdr, j)\n\t\tbin->shdr[i].sh_entsize = READ32 (shdr, j)\n#endif\n\t}\n\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_s_type.cparse`; td `k bin/cur/info/elf_s_flags_64.cparse`\n\t// > pf `k bin/cur/info/elf_shdr.format` @ `k bin/cur/info/elf_shdr.offset`\n}\n\nstatic int init_strtab(ELFOBJ *bin) {\n\tif (bin->strtab || !bin->shdr) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shstrndx != SHN_UNDEF &&\n\t\t(bin->ehdr.e_shstrndx >= bin->ehdr.e_shnum ||\n\t\t(bin->ehdr.e_shstrndx >= SHN_LORESERVE &&\n\t\tbin->ehdr.e_shstrndx < SHN_HIRESERVE)))\n\t\treturn false;\n\n\t/* sh_size must be lower than UT32_MAX and not equal to zero, to avoid bugs on malloc() */\n\tif (bin->shdr[bin->ehdr.e_shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[bin->ehdr.e_shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[bin->ehdr.e_shstrndx];\n\tbin->shstrtab_size = bin->strtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tperror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\n\tif (bin->shstrtab_section->sh_offset +\n\t\tbin->shstrtab_section->sh_size  > bin->size) {\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\t\t\tbin->shstrtab_section->sh_size + 1) < 1) {\n\t\tbprintf (\"Warning: read (shstrtab) at 0x%\"PFMT64x\"\\n\",\n\t\t\t\t(ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\n\treturn true;\n}\n\nstatic int init_dynamic_section(struct Elf_(r_bin_elf_obj_t) *bin) {\n\tElf_(Dyn) *dyn = NULL;\n\tElf_(Dyn) d = {0};\n\tElf_(Addr) strtabaddr = 0;\n\tut64 offset = 0;\n\tchar *strtab = NULL;\n\tsize_t relentry = 0, strsize = 0;\n\tint entries;\n\tint i, j, len, r;\n\tut8 sdyn[sizeof (Elf_(Dyn))] = {0};\n\tut32 dyn_size = 0;\n\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum ; i++) {\n\t\tif (bin->phdr[i].p_type == PT_DYNAMIC) {\n\t\t\tdyn_size = bin->phdr[i].p_filesz;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == bin->ehdr.e_phnum) {\n\t\treturn false;\n\t}\n\tif (bin->phdr[i].p_filesz > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->phdr[i].p_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->phdr[i].p_offset + sizeof(Elf_(Dyn)) > bin->size) {\n\t\treturn false;\n\t}\n\tfor (entries = 0; entries < (dyn_size / sizeof (Elf_(Dyn))); entries++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->phdr[i].p_offset + entries * sizeof (Elf_(Dyn)), sdyn, sizeof (Elf_(Dyn)));\n\t\tif (len < 1) {\n\t\t\tgoto beach;\n\t\t}\n#if R_BIN_ELF64\n\t\td.d_tag = READ64 (sdyn, j)\n#else\n\t\td.d_tag = READ32 (sdyn, j)\n#endif\n\t\tif (d.d_tag == DT_NULL) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (entries < 1) {\n\t\treturn false;\n\t}\n\tdyn = (Elf_(Dyn)*)calloc (entries, sizeof (Elf_(Dyn)));\n\tif (!dyn) {\n\t\treturn false;\n\t}\n\tif (!UT32_MUL (&dyn_size, entries, sizeof (Elf_(Dyn)))) {\n\t\tgoto beach;\n\t}\n\tif (!dyn_size) {\n\t\tgoto beach;\n\t}\n\toffset = Elf_(r_bin_elf_v2p) (bin, bin->phdr[i].p_vaddr);\n\tif (offset > bin->size || offset + dyn_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tfor (i = 0; i < entries; i++) {\n\t\tj = 0;\n\t\tr_buf_read_at (bin->b, offset + i * sizeof (Elf_(Dyn)), sdyn, sizeof (Elf_(Dyn)));\n\t\tif (len < 1) {\n\t\t\tbprintf(\"Warning: read (dyn)\\n\");\n\t\t}\n#if R_BIN_ELF64\n\t\tdyn[i].d_tag = READ64 (sdyn, j)\n\t\tdyn[i].d_un.d_ptr = READ64 (sdyn, j)\n#else\n\t\tdyn[i].d_tag = READ32 (sdyn, j)\n\t\tdyn[i].d_un.d_ptr = READ32 (sdyn, j)\n#endif\n\n\t\tswitch (dyn[i].d_tag) {\n\t\tcase DT_STRTAB: strtabaddr = Elf_(r_bin_elf_v2p) (bin, dyn[i].d_un.d_ptr); break;\n\t\tcase DT_STRSZ: strsize = dyn[i].d_un.d_val; break;\n\t\tcase DT_PLTREL: bin->is_rela = dyn[i].d_un.d_val; break;\n\t\tcase DT_RELAENT: relentry = dyn[i].d_un.d_val; break;\n\t\tdefault:\n\t\t\tif ((dyn[i].d_tag >= DT_VERSYM) && (dyn[i].d_tag <= DT_VERNEEDNUM)) {\n\t\t\t\tbin->version_info[DT_VERSIONTAGIDX (dyn[i].d_tag)] = dyn[i].d_un.d_val;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bin->is_rela) {\n\t\tbin->is_rela = sizeof (Elf_(Rela)) == relentry? DT_RELA : DT_REL;\n\t}\n\tif (!strtabaddr || strtabaddr > bin->size || strsize > ST32_MAX || !strsize || strsize > bin->size) {\n\t\tif (!strtabaddr) {\n\t\t\tbprintf (\"Warning: section.shstrtab not found or invalid\\n\");\n\t\t}\n\t\tgoto beach;\n\t}\n\tstrtab = (char *)calloc (1, strsize + 1);\n\tif (!strtab) {\n\t\tgoto beach;\n\t}\n\tif (strtabaddr + strsize > bin->size) {\n\t\tfree (strtab);\n\t\tgoto beach;\n\t}\n\tr = r_buf_read_at (bin->b, strtabaddr, (ut8 *)strtab, strsize);\n\tif (r < 1) {\n\t\tfree (strtab);\n\t\tgoto beach;\n\t}\n\tbin->dyn_buf = dyn;\n\tbin->dyn_entries = entries;\n\tbin->strtab = strtab;\n\tbin->strtab_size = strsize;\n\tr = Elf_(r_bin_elf_has_relro)(bin);\n\tswitch (r) {\n\tcase R_ELF_FULL_RELRO:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"full\", 0);\n\t\tbreak;\n\tcase R_ELF_PART_RELRO:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"partial\", 0);\n\t\tbreak;\n\tdefault:\n\t\tsdb_set (bin->kv, \"elf.relro\", \"no\", 0);\n\t\tbreak;\n\t}\n\tsdb_num_set (bin->kv, \"elf_strtab.offset\", strtabaddr, 0);\n\tsdb_num_set (bin->kv, \"elf_strtab.size\", strsize, 0);\n\treturn true;\nbeach:\n\tfree (dyn);\n\treturn false;\n}\n\nstatic RBinElfSection* get_section_by_name(ELFOBJ *bin, const char *section_name) {\n\tint i;\n\tif (!bin->g_sections) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\tif (!strncmp (bin->g_sections[i].name, section_name, ELF_STRING_LENGTH-1)) {\n\t\t\treturn &bin->g_sections[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic char *get_ver_flags(ut32 flags) {\n\tstatic char buff[32];\n\tbuff[0] = 0;\n\n\tif (!flags) {\n\t\treturn \"none\";\n\t}\n\tif (flags & VER_FLG_BASE) {\n\t\tstrcpy (buff, \"BASE \");\n\t}\n\tif (flags & VER_FLG_WEAK) {\n\t\tif (flags & VER_FLG_BASE) {\n\t\t\tstrcat (buff, \"| \");\n\t\t}\n\t\tstrcat (buff, \"WEAK \");\n\t}\n\n\tif (flags & ~(VER_FLG_BASE | VER_FLG_WEAK)) {\n\t\tstrcat (buff, \"| <unknown>\");\n\t}\n\treturn buff;\n}\n\nstatic Sdb *store_versioninfo_gnu_versym(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tint i;\n\tconst ut64 num_entries = sz / sizeof (Elf_(Versym));\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (!bin->version_info[DT_VERSIONTAGIDX (DT_VERSYM)]) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tut8 *edata = (ut8*) calloc (R_MAX (1, num_entries), sizeof (ut16));\n\tif (!edata) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tut16 *data = (ut16*) calloc (R_MAX (1, num_entries), sizeof (ut16));\n\tif (!data) {\n\t\tfree (edata);\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tut64 off = Elf_(r_bin_elf_v2p) (bin, bin->version_info[DT_VERSIONTAGIDX (DT_VERSYM)]);\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tr_buf_read_at (bin->b, off, edata, sizeof (ut16) * num_entries);\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", num_entries, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\tfor (i = num_entries; i--;) {\n\t\tdata[i] = r_read_ble16 (&edata[i * sizeof (ut16)], bin->endian);\n\t}\n\tR_FREE (edata);\n\tfor (i = 0; i < num_entries; i += 4) {\n\t\tint j;\n\t\tint check_def;\n\t\tchar key[32] = {0};\n\t\tSdb *sdb_entry = sdb_new0 ();\n\t\tsnprintf (key, sizeof (key), \"entry%d\", i / 4);\n\t\tsdb_ns_set (sdb, key, sdb_entry);\n\t\tsdb_num_set (sdb_entry, \"idx\", i, 0);\n\n\t\tfor (j = 0; (j < 4) && (i + j) < num_entries; ++j) {\n\t\t\tint k;\n\t\t\tchar *tmp_val = NULL;\n\t\t\tsnprintf (key, sizeof (key), \"value%d\", j);\n\t\t\tswitch (data[i + j]) {\n\t\t\tcase 0:\n\t\t\t\tsdb_set (sdb_entry, key, \"0 (*local*)\", 0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tsdb_set (sdb_entry, key, \"1 (*global*)\", 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttmp_val = sdb_fmt (0, \"%x \", data[i+j] & 0x7FFF);\n\t\t\t\tcheck_def = true;\n\t\t\t\tif (bin->version_info[DT_VERSIONTAGIDX (DT_VERNEED)]) {\n\t\t\t\t\tElf_(Verneed) vn;\n\t\t\t\t\tut8 svn[sizeof (Elf_(Verneed))] = {0};\n\t\t\t\t\tut64 offset = Elf_(r_bin_elf_v2p) (bin, bin->version_info[DT_VERSIONTAGIDX (DT_VERNEED)]);\n\t\t\t\t\tdo {\n\t\t\t\t\t\tElf_(Vernaux) vna;\n\t\t\t\t\t\tut8 svna[sizeof (Elf_(Vernaux))] = {0};\n\t\t\t\t\t\tut64 a_off;\n\t\t\t\t\t\tif (offset > bin->size || offset + sizeof (vn) > bin->size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, offset, svn, sizeof (svn)) < 0) {\n\t\t\t\t\t\t\tbprintf (\"Warning: Cannot read Verneed for Versym\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvn.vn_version = READ16 (svn, k)\n\t\t\t\t\t\tvn.vn_cnt = READ16 (svn, k)\n\t\t\t\t\t\tvn.vn_file = READ32 (svn, k)\n\t\t\t\t\t\tvn.vn_aux = READ32 (svn, k)\n\t\t\t\t\t\tvn.vn_next = READ32 (svn, k)\n\t\t\t\t\t\ta_off = offset + vn.vn_aux;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (a_off > bin->size || a_off + sizeof (vna) > bin->size) {\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (r_buf_read_at (bin->b, a_off, svna, sizeof (svna)) < 0) {\n\t\t\t\t\t\t\t\tbprintf (\"Warning: Cannot read Vernaux for Versym\\n\");\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\t\tvna.vna_hash = READ32 (svna, k)\n\t\t\t\t\t\t\tvna.vna_flags = READ16 (svna, k)\n\t\t\t\t\t\t\tvna.vna_other = READ16 (svna, k)\n\t\t\t\t\t\t\tvna.vna_name = READ32 (svna, k)\n\t\t\t\t\t\t\tvna.vna_next = READ32 (svna, k)\n\t\t\t\t\t\t\ta_off += vna.vna_next;\n\t\t\t\t\t\t} while (vna.vna_other != data[i + j] && vna.vna_next != 0);\n\n\t\t\t\t\t\tif (vna.vna_other == data[i + j]) {\n\t\t\t\t\t\t\tif (vna.vna_name > bin->strtab_size) {\n\t\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsdb_set (sdb_entry, key, sdb_fmt (0, \"%s(%s)\", tmp_val, bin->strtab + vna.vna_name), 0);\n\t\t\t\t\t\t\tcheck_def = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += vn.vn_next;\n\t\t\t\t\t} while (vn.vn_next);\n\t\t\t\t}\n\n\t\t\t\tut64 vinfoaddr = bin->version_info[DT_VERSIONTAGIDX (DT_VERDEF)];\n\t\t\t\tif (check_def && data[i + j] != 0x8001 && vinfoaddr) {\n\t\t\t\t\tElf_(Verdef) vd;\n\t\t\t\t\tut8 svd[sizeof (Elf_(Verdef))] = {0};\n\t\t\t\t\tut64 offset = Elf_(r_bin_elf_v2p) (bin, vinfoaddr);\n\t\t\t\t\tif (offset > bin->size || offset + sizeof (vd) > bin->size) {\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, offset, svd, sizeof (svd)) < 0) {\n\t\t\t\t\t\t\tbprintf (\"Warning: Cannot read Verdef for Versym\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvd.vd_version = READ16 (svd, k)\n\t\t\t\t\t\tvd.vd_flags = READ16 (svd, k)\n\t\t\t\t\t\tvd.vd_ndx = READ16 (svd, k)\n\t\t\t\t\t\tvd.vd_cnt = READ16 (svd, k)\n\t\t\t\t\t\tvd.vd_hash = READ32 (svd, k)\n\t\t\t\t\t\tvd.vd_aux = READ32 (svd, k)\n\t\t\t\t\t\tvd.vd_next = READ32 (svd, k)\n\t\t\t\t\t\toffset += vd.vd_next;\n\t\t\t\t\t} while (vd.vd_ndx != (data[i + j] & 0x7FFF) && vd.vd_next != 0);\n\n\t\t\t\t\tif (vd.vd_ndx == (data[i + j] & 0x7FFF)) {\n\t\t\t\t\t\tElf_(Verdaux) vda;\n\t\t\t\t\t\tut8 svda[sizeof (Elf_(Verdaux))] = {0};\n\t\t\t\t\t\tut64 off_vda = offset - vd.vd_next + vd.vd_aux;\n\t\t\t\t\t\tif (off_vda > bin->size || off_vda + sizeof (vda) > bin->size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, off_vda, svda, sizeof (svda)) < 0) {\n\t\t\t\t\t\t\tbprintf (\"Warning: Cannot read Verdaux for Versym\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tvda.vda_name = READ32 (svda, k)\n\t\t\t\t\t\tvda.vda_next = READ32 (svda, k)\n\t\t\t\t\t\tif (vda.vda_name > bin->strtab_size) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *name = bin->strtab + vda.vda_name;\n\t\t\t\t\t\tsdb_set (sdb_entry, key, sdb_fmt (0,\"%s(%s%-*s)\", tmp_val, name, (int)(12 - strlen (name)),\")\") , 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\tfree (data);\n\treturn sdb;\n}\n\nstatic Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n\nstatic Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tut8 *end, *need = NULL;\n\tconst char *section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tconst char *link_section_name = \"\";\n\tSdb *sdb_vernaux = NULL;\n\tSdb *sdb_version = NULL;\n\tSdb *sdb = NULL;\n\tint i, cnt;\n\n\tif (!bin || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_size < 1) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {\n\t\tbprintf (\"Warning: Cannot allocate memory for Elf_(Verneed)\\n\");\n\t\tgoto beach;\n\t}\n\tend = need + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tif (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (shdr->sh_offset + shdr->sh_size < shdr->sh_size) {\n\t\tgoto beach;\n\t}\n\ti = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size);\n\tif (i < 0)\n\t\tgoto beach;\n\t//XXX we should use DT_VERNEEDNUM instead of sh_info\n\t//TODO https://sourceware.org/ml/binutils/2014-11/msg00353.html\n\tfor (i = 0, cnt = 0; cnt < shdr->sh_info; ++cnt) {\n\t\tint j, isum;\n\t\tut8 *vstart = need + i;\n\t\tElf_(Verneed) vvn = {0};\n\t\tif (vstart + sizeof (Elf_(Verneed)) > end) {\n\t\t\tgoto beach;\n\t\t}\n\t\tElf_(Verneed) *entry = &vvn;\n\t\tchar key[32] = {0};\n\t\tsdb_version = sdb_new0 ();\n\t\tif (!sdb_version) {\n\t\t\tgoto beach;\n\t\t}\n\t\tj = 0;\n\t\tvvn.vn_version = READ16 (vstart, j)\n\t\tvvn.vn_cnt = READ16 (vstart, j)\n\t\tvvn.vn_file = READ32 (vstart, j)\n\t\tvvn.vn_aux = READ32 (vstart, j)\n\t\tvvn.vn_next = READ32 (vstart, j)\n\n\t\tsdb_num_set (sdb_version, \"vn_version\", entry->vn_version, 0);\n\t\tsdb_num_set (sdb_version, \"idx\", i, 0);\n\t\tif (entry->vn_file > bin->dynstr_size) {\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\tchar *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16);\n\t\t\tsdb_set (sdb_version, \"file_name\", s, 0);\n\t\t\tfree (s);\n\t\t}\n\t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n\t\tst32 vnaux = entry->vn_aux;\n\t\tif (vnaux < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tvstart += vnaux;\n\t\tfor (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) {\n\t\t\tint k;\n\t\t\tElf_(Vernaux) * aux = NULL;\n\t\t\tElf_(Vernaux) vaux = {0};\n\t\t\tsdb_vernaux = sdb_new0 ();\n\t\t\tif (!sdb_vernaux) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\taux = (Elf_(Vernaux)*)&vaux;\n\t\t\tk = 0;\n\t\t\tvaux.vna_hash = READ32 (vstart, k)\n\t\t\tvaux.vna_flags = READ16 (vstart, k)\n\t\t\tvaux.vna_other = READ16 (vstart, k)\n\t\t\tvaux.vna_name = READ32 (vstart, k)\n\t\t\tvaux.vna_next = READ32 (vstart, k)\n\t\t\tif (aux->vna_name > bin->dynstr_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_vernaux, \"idx\", isum, 0);\n\t\t\tif (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) {\n\t\t\t\tchar name [16];\n\t\t\t\tstrncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1);\n\t\t\t\tname[sizeof(name)-1] = 0;\n\t\t\t\tsdb_set (sdb_vernaux, \"name\", name, 0);\n\t\t\t}\n\t\t\tsdb_set (sdb_vernaux, \"flags\", get_ver_flags (aux->vna_flags), 0);\n\t\t\tsdb_num_set (sdb_vernaux, \"version\", aux->vna_other, 0);\n\t\t\tisum += aux->vna_next;\n\t\t\tvstart += aux->vna_next;\n\t\t\tsnprintf (key, sizeof (key), \"vernaux%d\", j);\n\t\t\tsdb_ns_set (sdb_version, key, sdb_vernaux);\n\t\t}\n\t\tif ((int)entry->vn_next < 0) {\n\t\t\tbprintf (\"Invalid vn_next\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += entry->vn_next;\n\t\tsnprintf (key, sizeof (key), \"version%d\", cnt );\n\t\tsdb_ns_set (sdb, key, sdb_version);\n\t\t//if entry->vn_next is 0 it iterate infinitely\n\t\tif (!entry->vn_next) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (need);\n\treturn sdb;\nbeach:\n\tfree (need);\n\tsdb_free (sdb_vernaux);\n\tsdb_free (sdb_version);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n\nstatic Sdb *store_versioninfo(ELFOBJ *bin) {\n\tSdb *sdb_versioninfo = NULL;\n\tint num_verdef = 0;\n\tint num_verneed = 0;\n\tint num_versym = 0;\n\tint i;\n\n\tif (!bin || !bin->shdr) {\n\t\treturn NULL;\n\t}\n\tif (!(sdb_versioninfo = sdb_new0 ())) {\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tSdb *sdb = NULL;\n\t\tchar key[32] = {0};\n\t\tint size = bin->shdr[i].sh_size;\n\n\t\tif (size - (i*sizeof(Elf_(Shdr)) > bin->size)) {\n\t\t\tsize = bin->size - (i*sizeof(Elf_(Shdr)));\n\t\t}\n\t\tint left = size - (i * sizeof (Elf_(Shdr)));\n\t\tleft = R_MIN (left, bin->shdr[i].sh_size);\n\t\tif (left < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (bin->shdr[i].sh_type) {\n\t\tcase SHT_GNU_verdef:\n\t\t\tsdb = store_versioninfo_gnu_verdef (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"verdef%d\", num_verdef++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\tcase SHT_GNU_verneed:\n\t\t\tsdb = store_versioninfo_gnu_verneed (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"verneed%d\", num_verneed++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\tcase SHT_GNU_versym:\n\t\t\tsdb = store_versioninfo_gnu_versym (bin, &bin->shdr[i], left);\n\t\t\tsnprintf (key, sizeof (key), \"versym%d\", num_versym++);\n\t\t\tsdb_ns_set (sdb_versioninfo, key, sdb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sdb_versioninfo;\n}\n\nstatic bool init_dynstr(ELFOBJ *bin) {\n\tint i, r;\n\tconst char *section_name = NULL;\n\tif (!bin || !bin->shdr) {\n\t\treturn false;\n\t}\n\tif (!bin->shstrtab) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; ++i) {\n\t\tif (bin->shdr[i].sh_name > bin->shstrtab_size) {\n\t\t\treturn false;\n\t\t}\n\t\tsection_name = &bin->shstrtab[bin->shdr[i].sh_name];\n\t\tif (bin->shdr[i].sh_type == SHT_STRTAB && !strcmp (section_name, \".dynstr\")) {\n\t\t\tif (!(bin->dynstr = (char*) calloc (bin->shdr[i].sh_size + 1, sizeof (char)))) {\n\t\t\t\tbprintf(\"Warning: Cannot allocate memory for dynamic strings\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + bin->shdr[i].sh_size > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + bin->shdr[i].sh_size < bin->shdr[i].sh_size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr = r_buf_read_at (bin->b, bin->shdr[i].sh_offset, (ut8*)bin->dynstr, bin->shdr[i].sh_size);\n\t\t\tif (r < 1) {\n\t\t\t\tR_FREE (bin->dynstr);\n\t\t\t\tbin->dynstr_size = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->dynstr_size = bin->shdr[i].sh_size;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int elf_init(ELFOBJ *bin) {\n\tbin->phdr = NULL;\n\tbin->shdr = NULL;\n\tbin->strtab = NULL;\n\tbin->shstrtab = NULL;\n\tbin->strtab_size = 0;\n\tbin->strtab_section = NULL;\n\tbin->dyn_buf = NULL;\n\tbin->dynstr = NULL;\n\tZERO_FILL (bin->version_info);\n\n\tbin->g_sections = NULL;\n\tbin->g_symbols = NULL;\n\tbin->g_imports = NULL;\n\t/* bin is not an ELF */\n\tif (!init_ehdr (bin)) {\n\t\treturn false;\n\t}\n\tif (!init_phdr (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize program headers\\n\");\n\t}\n\tif (!init_shdr (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize section headers\\n\");\n\t}\n\tif (!init_strtab (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize strings table\\n\");\n\t}\n\tif (!init_dynstr (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize dynamic strings\\n\");\n\t}\n\tbin->baddr = Elf_(r_bin_elf_get_baddr) (bin);\n\tif (!init_dynamic_section (bin) && !Elf_(r_bin_elf_get_static)(bin))\n\t\tbprintf (\"Warning: Cannot initialize dynamic section\\n\");\n\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\tbin->symbols_by_ord_size = 0;\n\tbin->symbols_by_ord = NULL;\n\tbin->g_sections = Elf_(r_bin_elf_get_sections) (bin);\n\tbin->boffset = Elf_(r_bin_elf_get_boffset) (bin);\n\tsdb_ns_set (bin->kv, \"versioninfo\", store_versioninfo (bin));\n\n\treturn true;\n}\n\nut64 Elf_(r_bin_elf_get_section_offset)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\tif (!section) return UT64_MAX;\n\treturn section->offset;\n}\n\nut64 Elf_(r_bin_elf_get_section_addr)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva: UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_section_addr_end)(ELFOBJ *bin, const char *section_name) {\n\tRBinElfSection *section = get_section_by_name (bin, section_name);\n\treturn section? section->rva + section->size: UT64_MAX;\n}\n#define REL (is_rela ? (void*)rela : (void*)rel)\n#define REL_BUF is_rela ? (ut8*)(&rela[k]) : (ut8*)(&rel[k])\n#define REL_OFFSET is_rela ? rela[k].r_offset : rel[k].r_offset\n#define REL_TYPE is_rela ? rela[k].r_info  : rel[k].r_info\n\nstatic ut64 get_import_addr(ELFOBJ *bin, int sym) {\n\tElf_(Rel) *rel = NULL;\n\tElf_(Rela) *rela = NULL;\n\tut8 rl[sizeof (Elf_(Rel))] = {0};\n\tut8 rla[sizeof (Elf_(Rela))] = {0};\n\tRBinElfSection *rel_sec = NULL;\n\tElf_(Addr) plt_sym_addr = -1;\n\tut64 got_addr, got_offset;\n\tut64 plt_addr;\n\tint j, k, tsize, len, nrel;\n\tbool is_rela = false;\n\tconst char *rel_sect[] = { \".rel.plt\", \".rela.plt\", \".rel.dyn\", \".rela.dyn\", NULL };\n\tconst char *rela_sect[] = { \".rela.plt\", \".rel.plt\", \".rela.dyn\", \".rel.dyn\", NULL };\n\n\tif ((!bin->shdr || !bin->strtab) && !bin->phdr) {\n\t\treturn -1;\n\t}\n\tif ((got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got\")) == -1 &&\n\t\t(got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got.plt\")) == -1) {\n\t\treturn -1;\n\t}\n\tif ((got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got\")) == -1 &&\n\t\t(got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.plt\")) == -1) {\n\t\treturn -1;\n\t}\n\tif (bin->is_rela == DT_REL) {\n\t\tj = 0;\n\t\twhile (!rel_sec && rel_sect[j]) {\n\t\t\trel_sec = get_section_by_name (bin, rel_sect[j++]);\n\t\t}\n\t\ttsize = sizeof (Elf_(Rel));\n\t} else if (bin->is_rela == DT_RELA) {\n\t\tj = 0;\n\t\twhile (!rel_sec && rela_sect[j]) {\n\t\t\trel_sec = get_section_by_name (bin, rela_sect[j++]);\n\t\t}\n\t\tis_rela = true;\n\t\ttsize = sizeof (Elf_(Rela));\n\t}\n\tif (!rel_sec) {\n\t\treturn -1;\n\t}\n\tif (rel_sec->size < 1) {\n\t\treturn -1;\n\t}\n\tnrel = (ut32)((int)rel_sec->size / (int)tsize);\n\tif (nrel < 1) {\n\t\treturn -1;\n\t}\n\tif (is_rela) {\n\t\trela = calloc (nrel, tsize);\n\t\tif (!rela) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\trel = calloc (nrel, tsize);\n\t\tif (!rel) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (j = k = 0; j < rel_sec->size && k < nrel; j += tsize, k++) {\n\t\tint l = 0;\n\t\tif (rel_sec->offset + j > bin->size) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (rel_sec->offset + j + tsize > bin->size) {\n\t\t\tgoto out;\n\t\t}\n\t\tlen = r_buf_read_at (\n\t\t\tbin->b, rel_sec->offset + j, is_rela ? rla : rl,\n\t\t\tis_rela ? sizeof (Elf_ (Rela)) : sizeof (Elf_ (Rel)));\n\t\tif (len < 1) {\n\t\t\tgoto out;\n\t\t}\n#if R_BIN_ELF64\n\t\tif (is_rela) {\n\t\t\trela[k].r_offset = READ64 (rla, l)\n\t\t\trela[k].r_info = READ64 (rla, l)\n\t\t\trela[k].r_addend = READ64 (rla, l)\n\t\t} else {\n\t\t\trel[k].r_offset = READ64 (rl, l)\n\t\t\trel[k].r_info = READ64 (rl, l)\n\t\t}\n#else\n\t\tif (is_rela) {\n\t\t\trela[k].r_offset = READ32 (rla, l)\n\t\t\trela[k].r_info = READ32 (rla, l)\n\t\t\trela[k].r_addend = READ32 (rla, l)\n\t\t} else {\n\t\t\trel[k].r_offset = READ32 (rl, l)\n\t\t\trel[k].r_info = READ32 (rl, l)\n\t\t}\n#endif\n\t\tint reloc_type = ELF_R_TYPE (REL_TYPE);\n\t\tint reloc_sym = ELF_R_SYM (REL_TYPE);\n\n\t\tif (reloc_sym == sym) {\n\t\t\tint of = REL_OFFSET;\n\t\t\tof = of - got_addr + got_offset;\n\t\t\tswitch (bin->ehdr.e_machine) {\n\t\t\tcase EM_PPC:\n\t\t\tcase EM_PPC64:\n\t\t\t\t{\n\t\t\t\t\tRBinElfSection *s = get_section_by_name (bin, \".plt\");\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tut8 buf[4];\n\t\t\t\t\t\tut64 base;\n\t\t\t\t\t\tlen = r_buf_read_at (bin->b, s->offset, buf, sizeof (buf));\n\t\t\t\t\t\tif (len < 4) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbase = r_read_be32 (buf);\n\t\t\t\t\t\tbase -= (nrel * 16);\n\t\t\t\t\t\tbase += (k * 16);\n\t\t\t\t\t\tplt_addr = base;\n\t\t\t\t\t\tfree (REL);\n\t\t\t\t\t\treturn plt_addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase EM_SPARC:\n\t\t\tcase EM_SPARCV9:\n\t\t\tcase EM_SPARC32PLUS:\n\t\t\t\tplt_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".plt\");\n\t\t\t\tif (plt_addr == -1) {\n\t\t\t\t\tfree (rela);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (reloc_type == R_386_PC16) {\n\t\t\t\t\tplt_addr += k * 12 + 20;\n\t\t\t\t\t// thumb symbol\n\t\t\t\t\tif (plt_addr & 1) {\n\t\t\t\t\t\tplt_addr--;\n\t\t\t\t\t}\n\t\t\t\t\tfree (REL);\n\t\t\t\t\treturn plt_addr;\n\t\t\t\t} else {\n\t\t\t\t\tbprintf (\"Unknown sparc reloc type %d\\n\", reloc_type);\n\t\t\t\t}\n\t\t\t\t/* SPARC */\n\t\t\t\tbreak;\n\t\t\tcase EM_ARM:\n\t\t\tcase EM_AARCH64:\n\t\t\t\tplt_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".plt\");\n\t\t\t\tif (plt_addr == -1) {\n\t\t\t\t\tfree (rela);\n\t\t\t\t\treturn UT32_MAX;\n\t\t\t\t}\n\t\t\t\tswitch (reloc_type) {\n\t\t\t\tcase R_386_8:\n\t\t\t\t\t{\n\t\t\t\t\t\tplt_addr += k * 12 + 20;\n\t\t\t\t\t\t// thumb symbol\n\t\t\t\t\t\tif (plt_addr & 1) {\n\t\t\t\t\t\t\tplt_addr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (REL);\n\t\t\t\t\t\treturn plt_addr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1026: // arm64 aarch64\n\t\t\t\t\tplt_sym_addr = plt_addr + k * 16 + 32;\n\t\t\t\t\tgoto done;\n\t\t\t\tdefault:\n\t\t\t\t\tbprintf (\"Unsupported relocation type for imports %d\\n\", reloc_type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase EM_386:\n\t\t\tcase EM_X86_64:\n\t\t\t\tswitch (reloc_type) {\n\t\t\t\tcase 1: // unknown relocs found in voidlinux for x86-64\n\t\t\t\t\t// break;\n\t\t\t\tcase R_386_GLOB_DAT:\n\t\t\t\tcase R_386_JMP_SLOT:\n\t\t\t\t\t{\n\t\t\t\t\tut8 buf[8];\n\t\t\t\t\tif (of + sizeof(Elf_(Addr)) < bin->size) {\n\t\t\t\t\t\t// ONLY FOR X86\n\t\t\t\t\t\tif (of > bin->size || of + sizeof (Elf_(Addr)) > bin->size) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = r_buf_read_at (bin->b, of, buf, sizeof (Elf_(Addr)));\n\t\t\t\t\t\tif (len < -1) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplt_sym_addr = sizeof (Elf_(Addr)) == 4\n\t\t\t\t\t\t\t\t\t ? r_read_le32 (buf)\n\t\t\t\t\t\t\t\t\t : r_read_le64 (buf);\n\n\t\t\t\t\t\tif (!plt_sym_addr) {\n\t\t\t\t\t\t\t//XXX HACK ALERT!!!! full relro?? try to fix it \n\t\t\t\t\t\t\t//will there always be .plt.got, what would happen if is .got.plt?\n\t\t\t\t\t\t\tRBinElfSection *s = get_section_by_name (bin, \".plt.got\");\n \t\t\t\t\t\t\tif (Elf_(r_bin_elf_has_relro)(bin) < R_ELF_PART_RELRO || !s) {\n\t\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tplt_addr = s->offset;\n\t\t\t\t\t\t\tof = of + got_addr - got_offset;\n\t\t\t\t\t\t\twhile (plt_addr + 2 + 4 < s->offset + s->size) {\n\t\t\t\t\t\t\t\t/*we try to locate the plt entry that correspond with the relocation\n\t\t\t\t\t\t\t\t  since got does not point back to .plt. In this case it has the following \n\t\t\t\t\t\t\t\t  form\n\n\t\t\t\t\t\t\t\t  ff253a152000   JMP QWORD [RIP + 0x20153A]\n\t\t\t\t\t\t\t\t  6690\t\t     NOP\n\t\t\t\t\t\t\t\t  ----\n\t\t\t\t\t\t\t\t  ff25ec9f0408   JMP DWORD [reloc.puts_236]\n\n\t\t\t\t\t\t\t\t  plt_addr + 2 to remove jmp opcode and get the imm reading 4\n\t\t\t\t\t\t\t\t  and if RIP (plt_addr + 6) + imm == rel->offset \n\t\t\t\t\t\t\t\t  return plt_addr, that will be our sym addr\n\n\t\t\t\t\t\t\t\t  perhaps this hack doesn't work on 32 bits\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tlen = r_buf_read_at (bin->b, plt_addr + 2, buf, 4);\n\t\t\t\t\t\t\t\tif (len < -1) {\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tplt_sym_addr = sizeof (Elf_(Addr)) == 4\n\t\t\t\t\t\t\t\t\t\t? r_read_le32 (buf)\n\t\t\t\t\t\t\t\t\t\t: r_read_le64 (buf);\n\n\t\t\t\t\t\t\t\t//relative address\n\t\t\t\t\t\t\t\tif ((plt_addr + 6 + Elf_(r_bin_elf_v2p) (bin, plt_sym_addr)) == of) {\n\t\t\t\t\t\t\t\t\tplt_sym_addr = plt_addr;\n\t\t\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t\t\t} else if (plt_sym_addr == of) {\n\t\t\t\t\t\t\t\t\tplt_sym_addr = plt_addr;\n\t\t\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tplt_addr += 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tplt_sym_addr -= 6;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbprintf (\"Unsupported relocation type for imports %d\\n\", reloc_type);\n\t\t\t\t\tfree (REL);\n\t\t\t\t\treturn of;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\t// MIPS32 BIG ENDIAN relocs\n\t\t\t\t{\n\t\t\t\t\tRBinElfSection *s = get_section_by_name (bin, \".rela.plt\");\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tut8 buf[1024];\n\t\t\t\t\t\tconst ut8 *base;\n\t\t\t\t\t\tplt_addr = s->rva + s->size;\n\t\t\t\t\t\tlen = r_buf_read_at (bin->b, s->offset + s->size, buf, sizeof (buf));\n\t\t\t\t\t\tif (len != sizeof (buf)) {\n\t\t\t\t\t\t\t// oops\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbase = r_mem_mem_aligned (buf, sizeof (buf), (const ut8*)\"\\x3c\\x0f\\x00\", 3, 4);\n\t\t\t\t\t\tif (base) {\n\t\t\t\t\t\t\tplt_addr += (int)(size_t)(base - buf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tplt_addr += 108 + 8; // HARDCODED HACK\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplt_addr += k * 16;\n\t\t\t\t\t\tfree (REL);\n\t\t\t\t\t\treturn plt_addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Unsupported relocs type %d for arch %d\\n\",\n\t\t\t\t\treloc_type, bin->ehdr.e_machine);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tfree (REL);\n\treturn plt_sym_addr;\nout:\n\tfree (REL);\n\treturn -1;\n}\n\nint Elf_(r_bin_elf_has_nx)(ELFOBJ *bin) {\n\tint i;\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_STACK) {\n\t\t\t\treturn (!(bin->phdr[i].p_flags & 1))? 1: 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Elf_(r_bin_elf_has_relro)(ELFOBJ *bin) {\n\tint i;\n\tbool haveBindNow = false;\n\tbool haveGnuRelro = false;\n\tif (bin && bin->dyn_buf) {\n\t\tfor (i = 0; i < bin->dyn_entries; i++) {\n\t\t\tswitch (bin->dyn_buf[i].d_tag) {\n\t\t\tcase DT_BIND_NOW:\n\t\t\t\thaveBindNow = true;\n\t\t\t\tbreak;\n\t\t\tcase DT_FLAGS:\n\t\t\t\tfor (i++; i < bin->dyn_entries ; i++) {\n\t\t\t\t\tut32 dTag = bin->dyn_buf[i].d_tag;\n\t\t\t\t\tif (!dTag) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (dTag) {\n\t\t\t\t\tcase DT_FLAGS_1:\n\t\t\t\t\t\tif (bin->dyn_buf[i].d_un.d_val & DF_1_NOW) {\n\t\t\t\t\t\t\thaveBindNow = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_RELRO) {\n\t\t\t\thaveGnuRelro = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (haveGnuRelro) {\n\t\tif (haveBindNow) {\n\t\t\treturn R_ELF_FULL_RELRO;\n\t\t}\n\t\treturn R_ELF_PART_RELRO;\n\t}\n\treturn R_ELF_NO_RELRO;\n}\n\n/*\nTo compute the base address, one determines the memory\naddress associated with the lowest p_vaddr value for a\nPT_LOAD segment. One then obtains the base address by\ntruncating the memory address to the nearest multiple\nof the maximum page size\n*/\n\nut64 Elf_(r_bin_elf_get_baddr)(ELFOBJ *bin) {\n\tint i;\n\tut64 tmp, base = UT64_MAX;\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\tif (bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_LOAD) {\n\t\t\t\ttmp = (ut64)bin->phdr[i].p_vaddr & ELF_PAGE_MASK;\n\t\t\t\ttmp = tmp - (tmp % (1 << ELF_PAGE_SIZE));\n\t\t\t\tif (tmp < base) {\n\t\t\t\t\tbase = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (base == UT64_MAX && bin->ehdr.e_type == ET_REL) {\n\t\t//we return our own base address for ET_REL type\n\t\t//we act as a loader for ELF\n\t\treturn 0x08000000;\n\t}\n\treturn base == UT64_MAX ? 0 : base;\n}\n\nut64 Elf_(r_bin_elf_get_boffset)(ELFOBJ *bin) {\n\tint i;\n\tut64 tmp, base = UT64_MAX;\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_LOAD) {\n\t\t\t\ttmp =  (ut64)bin->phdr[i].p_offset & ELF_PAGE_MASK;\n\t\t\t\ttmp = tmp - (tmp % (1 << ELF_PAGE_SIZE));\n\t\t\t\tif (tmp < base) {\n\t\t\t\t\tbase = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn base == UT64_MAX ? 0 : base;\n}\n\nut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[512];\n\tif (!bin) {\n\t\treturn 0LL;\n\t}\n\tif (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {\n\t\tbprintf (\"Warning: read (init_offset)\\n\");\n\t\treturn 0;\n\t}\n\tif (buf[0] == 0x68) { // push // x86 only\n\t\tut64 addr;\n\t\tmemmove (buf, buf+1, 4);\n\t\taddr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n\nut64 Elf_(r_bin_elf_get_fini_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[512];\n\tif (!bin) {\n\t\treturn 0LL;\n\t}\n\n\tif (r_buf_read_at (bin->b, entry+11, buf, sizeof (buf)) == -1) {\n\t\tbprintf (\"Warning: read (get_fini)\\n\");\n\t\treturn 0;\n\t}\n\tif (*buf == 0x68) { // push // x86/32 only\n\t\tut64 addr;\n\t\tmemmove (buf, buf+1, 4);\n\t\taddr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n\nut64 Elf_(r_bin_elf_get_entry_offset)(ELFOBJ *bin) {\n\tut64 entry;\n\tif (!bin) {\n\t\treturn 0LL;\n\t}\n\tentry = bin->ehdr.e_entry;\n\tif (!entry) {\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".init.text\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".text\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\tentry = Elf_(r_bin_elf_get_section_offset)(bin, \".init\");\n\t\tif (entry != UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\t\tif (entry == UT64_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn Elf_(r_bin_elf_v2p) (bin, entry);\n}\n\nstatic ut64 getmainsymbol(ELFOBJ *bin) {\n\tstruct r_bin_elf_symbol_t *symbol;\n\tint i;\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\treturn UT64_MAX;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tif (!strcmp (symbol[i].name, \"main\")) {\n\t\t\tut64 paddr = symbol[i].offset;\n\t\t\treturn Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nut64 Elf_(r_bin_elf_get_main_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[512];\n\tif (!bin) {\n\t\treturn 0LL;\n\t}\n\tif (entry > bin->size || (entry + sizeof (buf)) > bin->size) {\n\t\treturn 0;\n\t}\n\tif (r_buf_read_at (bin->b, entry, buf, sizeof (buf)) < 1) {\n\t\tbprintf (\"Warning: read (main)\\n\");\n\t\treturn 0;\n\t}\n\t// ARM64\n\tif (buf[0x18+3] == 0x58 && buf[0x2f] == 0x00) {\n\t\tut32 entry_vaddr = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tut32 main_addr = r_read_le32 (&buf[0x30]);\n\t\tif ((main_addr >> 16) == (entry_vaddr >> 16)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, main_addr);\n\t\t}\n\t}\n\n\t// TODO: Use arch to identify arch before memcmp's\n\t// ARM\n\tut64 text = Elf_(r_bin_elf_get_section_offset)(bin, \".text\");\n\tut64 text_end = text + bin->size;\n\n\t// ARM-Thumb-Linux\n\tif (entry & 1 && !memcmp (buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\", 6)) {\n\t\tut32 * ptr = (ut32*)(buf+40-1);\n\t\tif (*ptr &1) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, *ptr -1);\n\t\t}\n\t}\n\tif (!memcmp (buf, \"\\x00\\xb0\\xa0\\xe3\\x00\\xe0\\xa0\\xe3\", 8)) {\n\t\t// endian stuff here\n\t\tut32 *addr = (ut32*)(buf+0x34);\n\t\t/*\n\t\t   0x00012000    00b0a0e3     mov fp, 0\n\t\t   0x00012004    00e0a0e3     mov lr, 0\n\t\t*/\n\t\tif (*addr > text && *addr < (text_end)) {\n\t\t\treturn Elf_(r_bin_elf_v2p) (bin, *addr);\n\t\t}\n\t}\n\n\t// MIPS\n\t/* get .got, calculate offset of main symbol */\n\tif (!memcmp (buf, \"\\x21\\x00\\xe0\\x03\\x01\\x00\\x11\\x04\", 8)) {\n\n\t\t/*\n\t\t    assuming the startup code looks like\n\t\t        got = gp-0x7ff0\n\t\t        got[index__libc_start_main] ( got[index_main] );\n\n\t\t    looking for the instruction generating the first argument to find main\n\t\t        lw a0, offset(gp)\n\t\t*/\n\n\t\tut64 got_offset;\n\t\tif ((got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got\")) != -1 ||\n\t\t    (got_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".got.plt\")) != -1)\n\t\t{\n\t\t\tconst ut64 gp = got_offset + 0x7ff0;\n\t\t\tunsigned i;\n\t\t\tfor (i = 0; i < sizeof(buf) / sizeof(buf[0]); i += 4) {\n\t\t\t\tconst ut32 instr = r_read_le32 (&buf[i]);\n\t\t\t\tif ((instr & 0xffff0000) == 0x8f840000) { // lw a0, offset(gp)\n\t\t\t\t\tconst short delta = instr & 0x0000ffff;\n\t\t\t\t\tr_buf_read_at (bin->b, /* got_entry_offset = */ gp + delta, buf, 4);\n\t\t\t\t\treturn Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\t// ARM\n\tif (!memcmp (buf, \"\\x24\\xc0\\x9f\\xe5\\x00\\xb0\\xa0\\xe3\", 8)) {\n\t\tut64 addr = r_read_le32 (&buf[48]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\t// X86-CGC\n\tif (buf[0] == 0xe8 && !memcmp (buf + 5, \"\\x50\\xe8\\x00\\x00\\x00\\x00\\xb8\\x01\\x00\\x00\\x00\\x53\", 12)) {\n\t\tsize_t SIZEOF_CALL = 5;\n\t\tut64 rel_addr = (ut64)((int)(buf[1] + (buf[2] << 8) + (buf[3] << 16) + (buf[4] << 24)));\n\t\tut64 addr = Elf_(r_bin_elf_p2v)(bin, entry + SIZEOF_CALL);\n\t\taddr += rel_addr;\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\t// X86-PIE\n\tif (buf[0x00] == 0x48 && buf[0x1e] == 0x8d && buf[0x11] == 0xe8) {\n\t\tut32 *pmain = (ut32*)(buf + 0x30);\n\t\tut64 vmain = Elf_(r_bin_elf_p2v) (bin, (ut64)*pmain);\n\t\tut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tif (vmain >> 16 == ventry >> 16) {\n\t\t\treturn (ut64)vmain;\n\t\t}\n\t}\n\t// X86-PIE\n\tif (buf[0x1d] == 0x48 && buf[0x1e] == 0x8b) {\n\t\tif (!memcmp (buf, \"\\x31\\xed\\x49\\x89\", 4)) {// linux\n\t\t\tut64 maddr, baddr;\n\t\t\tut8 n32s[sizeof (ut32)] = {0};\n\t\t\tmaddr = entry + 0x24 + r_read_le32 (buf + 0x20);\n\t\t\tif (r_buf_read_at (bin->b, maddr, n32s, sizeof (ut32)) == -1) {\n\t\t\t\tbprintf (\"Warning: read (maddr) 2\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmaddr = (ut64)r_read_le32 (&n32s[0]);\n\t\t\tbaddr = (bin->ehdr.e_entry >> 16) << 16;\n\t\t\tif (bin->phdr) {\n\t\t\t\tbaddr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\t\t}\n\t\t\tmaddr += baddr;\n\t\t\treturn maddr;\n\t\t}\n\t}\n\t// X86-NONPIE\n#if R_BIN_ELF64\n\tif (!memcmp (buf, \"\\x49\\x89\\xd9\", 3) && buf[156] == 0xe8) { // openbsd\n\t\treturn r_read_le32 (&buf[157]) + entry + 156 + 5;\n\t}\n\tif (!memcmp (buf+29, \"\\x48\\xc7\\xc7\", 3)) { // linux\n\t\tut64 addr = (ut64)r_read_le32 (&buf[29 + 3]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n#else\n\tif (buf[23] == '\\x68') {\n\t\tut64 addr = (ut64)r_read_le32 (&buf[23 + 1]);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n#endif\n\t/* linux64 pie main -- probably buggy in some cases */\n\tif (buf[29] == 0x48 && buf[30] == 0x8d) { // lea rdi, qword [rip-0x21c4]\n\t\tut8 *p = buf + 32;\n\t\tst32 maindelta = (st32)r_read_le32 (p);\n\t\tut64 vmain = (ut64)(entry + 29 + maindelta) + 7;\n\t\tut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);\n\t\tif (vmain>>16 == ventry>>16) {\n\t\t\treturn (ut64)vmain;\n\t\t}\n\t}\n\t/* find sym.main if possible */\n\t{\n\t\tut64 m = getmainsymbol (bin);\n\t\tif (m != UT64_MAX) return m;\n\t}\n\treturn UT64_MAX;\n}\n\nint Elf_(r_bin_elf_get_stripped)(ELFOBJ *bin) {\n\tint i;\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif (bin->shdr[i].sh_type == SHT_SYMTAB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar *Elf_(r_bin_elf_intrp)(ELFOBJ *bin) {\n\tint i;\n\tif (!bin || !bin->phdr) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\tchar *str = NULL;\n\t\t\tut64 addr = bin->phdr[i].p_offset;\n\t\t\tint sz = bin->phdr[i].p_memsz;\n\t\t\tsdb_num_set (bin->kv, \"elf_header.intrp_addr\", addr, 0);\n\t\t\tsdb_num_set (bin->kv, \"elf_header.intrp_size\", sz, 0);\n\t\t\tif (sz < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstr = malloc (sz + 1);\n\t\t\tif (!str) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, addr, (ut8*)str, sz) < 1) {\n\t\t\t\tbprintf (\"Warning: read (main)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstr[sz] = 0;\n\t\t\tsdb_set (bin->kv, \"elf_header.intrp\", str, 0);\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint Elf_(r_bin_elf_get_static)(ELFOBJ *bin) {\n\tint i;\n\tif (!bin->phdr) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar* Elf_(r_bin_elf_get_data_encoding)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_DATA]) {\n\tcase ELFDATANONE: return strdup (\"none\");\n\tcase ELFDATA2LSB: return strdup (\"2's complement, little endian\");\n\tcase ELFDATA2MSB: return strdup (\"2's complement, big endian\");\n\tdefault: return r_str_newf (\"<unknown: %x>\", bin->ehdr.e_ident[EI_DATA]);\n\t}\n}\n\nint Elf_(r_bin_elf_has_va)(ELFOBJ *bin) {\n\treturn true;\n}\n\nchar* Elf_(r_bin_elf_get_arch)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_ARC:\n\tcase EM_ARC_A5:\n\t\treturn strdup (\"arc\");\n\tcase EM_AVR: return strdup (\"avr\");\n\tcase EM_CRIS: return strdup (\"cris\");\n\tcase EM_68K: return strdup (\"m68k\");\n\tcase EM_MIPS:\n\tcase EM_MIPS_RS3_LE:\n\tcase EM_MIPS_X:\n\t\treturn strdup (\"mips\");\n\tcase EM_MCST_ELBRUS:\n\t\treturn strdup (\"elbrus\");\n\tcase EM_TRICORE:\n\t\treturn strdup (\"tricore\");\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\t\treturn strdup (\"arm\");\n\tcase EM_HEXAGON:\n\t\treturn strdup (\"hexagon\");\n\tcase EM_BLACKFIN:\n\t\treturn strdup (\"blackfin\");\n\tcase EM_SPARC:\n\tcase EM_SPARC32PLUS:\n\tcase EM_SPARCV9:\n\t\treturn strdup (\"sparc\");\n\tcase EM_PPC:\n\tcase EM_PPC64:\n\t\treturn strdup (\"ppc\");\n\tcase EM_PARISC:\n\t\treturn strdup (\"hppa\");\n\tcase EM_PROPELLER:\n\t\treturn strdup (\"propeller\");\n\tcase EM_MICROBLAZE:\n\t\treturn strdup (\"microblaze.gnu\");\n\tcase EM_RISCV:\n\t\treturn strdup (\"riscv\");\n\tcase EM_VAX:\n\t\treturn strdup (\"vax\");\n\tcase EM_XTENSA:\n\t\treturn strdup (\"xtensa\");\n\tcase EM_LANAI:\n\t\treturn strdup (\"lanai\");\n\tcase EM_VIDEOCORE3:\n\tcase EM_VIDEOCORE4:\n\t\treturn strdup (\"vc4\");\n\tcase EM_SH:\n\t\treturn strdup (\"sh\");\n\tcase EM_V850:\n\t\treturn strdup (\"v850\");\n\tcase EM_IA_64:\n\t\treturn strdup(\"ia64\");\n\tdefault: return strdup (\"x86\");\n\t}\n}\n\nchar* Elf_(r_bin_elf_get_machine_name)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_NONE:        return strdup (\"No machine\");\n\tcase EM_M32:         return strdup (\"AT&T WE 32100\");\n\tcase EM_SPARC:       return strdup (\"SUN SPARC\");\n\tcase EM_386:         return strdup (\"Intel 80386\");\n\tcase EM_68K:         return strdup (\"Motorola m68k family\");\n\tcase EM_88K:         return strdup (\"Motorola m88k family\");\n\tcase EM_860:         return strdup (\"Intel 80860\");\n\tcase EM_MIPS:        return strdup (\"MIPS R3000\");\n\tcase EM_S370:        return strdup (\"IBM System/370\");\n\tcase EM_MIPS_RS3_LE: return strdup (\"MIPS R3000 little-endian\");\n\tcase EM_PARISC:      return strdup (\"HPPA\");\n\tcase EM_VPP500:      return strdup (\"Fujitsu VPP500\");\n\tcase EM_SPARC32PLUS: return strdup (\"Sun's \\\"v8plus\\\"\");\n\tcase EM_960:         return strdup (\"Intel 80960\");\n\tcase EM_PPC:         return strdup (\"PowerPC\");\n\tcase EM_PPC64:       return strdup (\"PowerPC 64-bit\");\n\tcase EM_S390:        return strdup (\"IBM S390\");\n\tcase EM_V800:        return strdup (\"NEC V800 series\");\n\tcase EM_FR20:        return strdup (\"Fujitsu FR20\");\n\tcase EM_RH32:        return strdup (\"TRW RH-32\");\n\tcase EM_RCE:         return strdup (\"Motorola RCE\");\n\tcase EM_ARM:         return strdup (\"ARM\");\n\tcase EM_BLACKFIN:    return strdup (\"Analog Devices Blackfin\");\n\tcase EM_FAKE_ALPHA:  return strdup (\"Digital Alpha\");\n\tcase EM_SH:          return strdup (\"Hitachi SH\");\n\tcase EM_SPARCV9:     return strdup (\"SPARC v9 64-bit\");\n\tcase EM_TRICORE:     return strdup (\"Siemens Tricore\");\n\tcase EM_ARC:         return strdup (\"Argonaut RISC Core\");\n\tcase EM_H8_300:      return strdup (\"Hitachi H8/300\");\n\tcase EM_H8_300H:     return strdup (\"Hitachi H8/300H\");\n\tcase EM_H8S:         return strdup (\"Hitachi H8S\");\n\tcase EM_H8_500:      return strdup (\"Hitachi H8/500\");\n\tcase EM_IA_64:       return strdup (\"Intel Merced\");\n\tcase EM_MIPS_X:      return strdup (\"Stanford MIPS-X\");\n\tcase EM_COLDFIRE:    return strdup (\"Motorola Coldfire\");\n\tcase EM_68HC12:      return strdup (\"Motorola M68HC12\");\n\tcase EM_MMA:         return strdup (\"Fujitsu MMA Multimedia Accelerator\");\n\tcase EM_PCP:         return strdup (\"Siemens PCP\");\n\tcase EM_NCPU:        return strdup (\"Sony nCPU embeeded RISC\");\n\tcase EM_NDR1:        return strdup (\"Denso NDR1 microprocessor\");\n\tcase EM_STARCORE:    return strdup (\"Motorola Start*Core processor\");\n\tcase EM_ME16:        return strdup (\"Toyota ME16 processor\");\n\tcase EM_ST100:       return strdup (\"STMicroelectronic ST100 processor\");\n\tcase EM_TINYJ:       return strdup (\"Advanced Logic Corp. Tinyj emb.fam\");\n\tcase EM_X86_64:      return strdup (\"AMD x86-64 architecture\");\n\tcase EM_LANAI:       return strdup (\"32bit LANAI architecture\");\n\tcase EM_PDSP:        return strdup (\"Sony DSP Processor\");\n\tcase EM_FX66:        return strdup (\"Siemens FX66 microcontroller\");\n\tcase EM_ST9PLUS:     return strdup (\"STMicroelectronics ST9+ 8/16 mc\");\n\tcase EM_ST7:         return strdup (\"STmicroelectronics ST7 8 bit mc\");\n\tcase EM_68HC16:      return strdup (\"Motorola MC68HC16 microcontroller\");\n\tcase EM_68HC11:      return strdup (\"Motorola MC68HC11 microcontroller\");\n\tcase EM_68HC08:      return strdup (\"Motorola MC68HC08 microcontroller\");\n\tcase EM_68HC05:      return strdup (\"Motorola MC68HC05 microcontroller\");\n\tcase EM_SVX:         return strdup (\"Silicon Graphics SVx\");\n\tcase EM_ST19:        return strdup (\"STMicroelectronics ST19 8 bit mc\");\n\tcase EM_VAX:         return strdup (\"Digital VAX\");\n\tcase EM_CRIS:        return strdup (\"Axis Communications 32-bit embedded processor\");\n\tcase EM_JAVELIN:     return strdup (\"Infineon Technologies 32-bit embedded processor\");\n\tcase EM_FIREPATH:    return strdup (\"Element 14 64-bit DSP Processor\");\n\tcase EM_ZSP:         return strdup (\"LSI Logic 16-bit DSP Processor\");\n\tcase EM_MMIX:        return strdup (\"Donald Knuth's educational 64-bit processor\");\n\tcase EM_HUANY:       return strdup (\"Harvard University machine-independent object files\");\n\tcase EM_PRISM:       return strdup (\"SiTera Prism\");\n\tcase EM_AVR:         return strdup (\"Atmel AVR 8-bit microcontroller\");\n\tcase EM_FR30:        return strdup (\"Fujitsu FR30\");\n\tcase EM_D10V:        return strdup (\"Mitsubishi D10V\");\n\tcase EM_D30V:        return strdup (\"Mitsubishi D30V\");\n\tcase EM_V850:        return strdup (\"NEC v850\");\n\tcase EM_M32R:        return strdup (\"Mitsubishi M32R\");\n\tcase EM_MN10300:     return strdup (\"Matsushita MN10300\");\n\tcase EM_MN10200:     return strdup (\"Matsushita MN10200\");\n\tcase EM_PJ:          return strdup (\"picoJava\");\n\tcase EM_OPENRISC:    return strdup (\"OpenRISC 32-bit embedded processor\");\n\tcase EM_ARC_A5:      return strdup (\"ARC Cores Tangent-A5\");\n\tcase EM_XTENSA:      return strdup (\"Tensilica Xtensa Architecture\");\n\tcase EM_AARCH64:     return strdup (\"ARM aarch64\");\n\tcase EM_PROPELLER:   return strdup (\"Parallax Propeller\");\n\tcase EM_MICROBLAZE:  return strdup (\"Xilinx MicroBlaze\");\n\tcase EM_RISCV:       return strdup (\"RISC V\");\n\tcase EM_VIDEOCORE3:  return strdup (\"VideoCore III\");\n\tcase EM_VIDEOCORE4:  return strdup (\"VideoCore IV\");\n\tdefault:             return r_str_newf (\"<unknown>: 0x%x\", bin->ehdr.e_machine);\n\t}\n}\n\nchar* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tut32 e_type;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\te_type = (ut32)bin->ehdr.e_type; // cast to avoid warn in iphone-gcc, must be ut16\n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}\n\nchar* Elf_(r_bin_elf_get_elf_class)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASSNONE: return strdup (\"none\");\n\tcase ELFCLASS32:   return strdup (\"ELF32\");\n\tcase ELFCLASS64:   return strdup (\"ELF64\");\n\tdefault:           return r_str_newf (\"<unknown: %x>\", bin->ehdr.e_ident[EI_CLASS]);\n\t}\n}\n\nint Elf_(r_bin_elf_get_bits)(ELFOBJ *bin) {\n\t/* Hack for ARCompact */\n\tif (bin->ehdr.e_machine == EM_ARC_A5) {\n\t\treturn 16;\n\t}\n\t/* Hack for Ps2 */\n\tif (bin->phdr && bin->ehdr.e_machine == EM_MIPS) {\n\t\tconst ut32 mipsType = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\t\tif (bin->ehdr.e_type == ET_EXEC) {\n\t\t\tint i;\n\t\t\tbool haveInterp = false;\n\t\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\t\tif (bin->phdr[i].p_type == PT_INTERP) {\n\t\t\t\t\thaveInterp = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!haveInterp && mipsType == EF_MIPS_ARCH_3) {\n\t\t\t\t// Playstation2 Hack\n\t\t\t\treturn 64;\n\t\t\t}\n\t\t}\n\t\t// TODO: show this specific asm.cpu somewhere in bininfo (mips1, mips2, mips3, mips32r2, ...)\n\t\tswitch (mipsType) {\n\t\tcase EF_MIPS_ARCH_1:\n\t\tcase EF_MIPS_ARCH_2:\n\t\tcase EF_MIPS_ARCH_3:\n\t\tcase EF_MIPS_ARCH_4:\n\t\tcase EF_MIPS_ARCH_5:\n\t\tcase EF_MIPS_ARCH_32:\n\t\t\treturn 32;\n\t\tcase EF_MIPS_ARCH_64:\n\t\t\treturn 64;\n\t\tcase EF_MIPS_ARCH_32R2:\n\t\t\treturn 32;\n\t\tcase EF_MIPS_ARCH_64R2:\n\t\t\treturn 64;\n\t\t\tbreak;\n\t\t}\n\t\treturn 32;\n\t}\n\t/* Hack for Thumb */\n\tif (bin->ehdr.e_machine == EM_ARM) {\n\t\tif (bin->ehdr.e_type != ET_EXEC) {\n\t\t\tstruct r_bin_elf_symbol_t *symbol;\n\t\t\tif ((symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\t\t\tint i = 0;\n\t\t\t\tfor (i = 0; !symbol[i].last; i++) {\n\t\t\t\t\tut64 paddr = symbol[i].offset;\n\t\t\t\t\tif (paddr & 1) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\t\t\tif (entry & 1) {\n\t\t\t\treturn 16;\n\t\t\t}\n\t\t}\n\t}\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASS32:   return 32;\n\tcase ELFCLASS64:   return 64;\n\tcase ELFCLASSNONE:\n\tdefault:           return 32; // defaults\n\t}\n}\n\nstatic inline int noodle(ELFOBJ *bin, const char *s) {\n\tconst ut8 *p = bin->b->buf;\n\tif (bin->b->length > 64)  {\n\t\tp += bin->b->length - 64;\n\t} else {\n\t\treturn 0;\n\t}\n\treturn r_mem_mem (p, 64, (const ut8 *)s, strlen (s)) != NULL;\n}\n\nstatic inline int needle(ELFOBJ *bin, const char *s) {\n\tif (bin->shstrtab) {\n\t\tut32 len = bin->shstrtab_size;\n\t\tif (len > 4096) {\n\t\t\tlen = 4096; // avoid slow loading .. can be buggy?\n\t\t}\n\t\treturn r_mem_mem ((const ut8*)bin->shstrtab, len,\n\t\t\t\t(const ut8*)s, strlen (s)) != NULL;\n\t}\n\treturn 0;\n}\n\n// TODO: must return const char * all those strings must be const char os[LINUX] or so\nchar* Elf_(r_bin_elf_get_osabi_name)(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_OSABI]) {\n\tcase ELFOSABI_LINUX: return strdup(\"linux\");\n\tcase ELFOSABI_SOLARIS: return strdup(\"solaris\");\n\tcase ELFOSABI_FREEBSD: return strdup(\"freebsd\");\n\tcase ELFOSABI_HPUX: return strdup(\"hpux\");\n\t}\n\t/* Hack to identify OS */\n\tif (needle (bin, \"openbsd\")) return strdup (\"openbsd\");\n\tif (needle (bin, \"netbsd\")) return strdup (\"netbsd\");\n\tif (needle (bin, \"freebsd\")) return strdup (\"freebsd\");\n\tif (noodle (bin, \"BEOS:APP_VERSION\")) return strdup (\"beos\");\n\tif (needle (bin, \"GNU\")) return strdup (\"linux\");\n\treturn strdup (\"linux\");\n}\n\nut8 *Elf_(r_bin_elf_grab_regstate)(ELFOBJ *bin, int *len) {\n\tif (bin->phdr) {\n\t\tint i;\n\t\tint num = bin->ehdr.e_phnum;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (bin->phdr[i].p_type != PT_NOTE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint bits = Elf_(r_bin_elf_get_bits)(bin);\n\t\t\tint regdelta = (bits == 64)? 0x84: 0x40; // x64 vs x32\n\t\t\tint regsize = 160; // for x86-64\n\t\t\tut8 *buf = malloc (regsize);\n\t\t\tif (r_buf_read_at (bin->b, bin->phdr[i].p_offset + regdelta, buf, regsize) != regsize) {\n\t\t\t\tfree (buf);\n\t\t\t\tbprintf (\"Cannot read register state from CORE file\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (len) {\n\t\t\t\t*len = regsize;\n\t\t\t}\n\t\t\treturn buf;\n\t\t}\n\t}\n\tbprintf (\"Cannot find NOTE section\\n\");\n\treturn NULL;\n}\n\nint Elf_(r_bin_elf_is_big_endian)(ELFOBJ *bin) {\n\treturn (bin->ehdr.e_ident[EI_DATA] == ELFDATA2MSB);\n}\n\n/* XXX Init dt_strtab? */\nchar *Elf_(r_bin_elf_get_rpath)(ELFOBJ *bin) {\n\tchar *ret = NULL;\n\tint j;\n\n\tif (!bin || !bin->phdr || !bin->dyn_buf || !bin->strtab) {\n\t\treturn NULL;\n\t}\n\tfor (j = 0; j< bin->dyn_entries; j++) {\n\t\tif (bin->dyn_buf[j].d_tag == DT_RPATH || bin->dyn_buf[j].d_tag == DT_RUNPATH) {\n\t\t\tif (!(ret = calloc (1, ELF_STRING_LENGTH))) {\n\t\t\t\tperror (\"malloc (rpath)\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->dyn_buf[j].d_un.d_val > bin->strtab_size) {\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrncpy (ret, bin->strtab + bin->dyn_buf[j].d_un.d_val, ELF_STRING_LENGTH);\n\t\t\tret[ELF_STRING_LENGTH - 1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstatic size_t get_relocs_num(ELFOBJ *bin) {\n\tsize_t i, size, ret = 0;\n\t/* we need to be careful here, in malformed files the section size might\n\t * not be a multiple of a Rel/Rela size; round up so we allocate enough\n\t * space.\n\t */\n#define NUMENTRIES_ROUNDUP(sectionsize, entrysize) (((sectionsize)+(entrysize)-1)/(entrysize))\n\tif (!bin->g_sections) {\n\t\treturn 0;\n\t}\n\tsize = bin->is_rela == DT_REL ? sizeof (Elf_(Rel)) : sizeof (Elf_(Rela));\n\tfor (i = 0; !bin->g_sections[i].last; i++) {\n\t\tif (!strncmp (bin->g_sections[i].name, \".rela.\", strlen (\".rela.\"))) {\n\t\t\tif (!bin->is_rela) {\n\t\t\t\tsize = sizeof (Elf_(Rela));\n\t\t\t}\n\t\t\tret += NUMENTRIES_ROUNDUP (bin->g_sections[i].size, size);\n\t\t} else if (!strncmp (bin->g_sections[i].name, \".rel.\", strlen (\".rel.\"))){\n\t\t\tif (!bin->is_rela) {\n\t\t\t\tsize = sizeof (Elf_(Rel));\n\t\t\t}\n\t\t\tret += NUMENTRIES_ROUNDUP (bin->g_sections[i].size, size);\n\t\t}\n\t}\n\treturn ret;\n#undef NUMENTRIES_ROUNDUP\n}\n\nstatic int read_reloc(ELFOBJ *bin, RBinElfReloc *r, int is_rela, ut64 offset) {\n\tut8 *buf = bin->b->buf;\n\tint j = 0;\n\tif (offset + sizeof (Elf_ (Rela)) >\n\t\t    bin->size || offset + sizeof (Elf_(Rela)) < offset) {\n\t\treturn -1;\n\t}\n\tif (is_rela == DT_RELA) {\n\t\tElf_(Rela) rela;\n#if R_BIN_ELF64\n\t\trela.r_offset = READ64 (buf + offset, j)\n\t\trela.r_info = READ64 (buf + offset, j)\n\t\trela.r_addend = READ64 (buf + offset, j)\n#else\n\t\trela.r_offset = READ32 (buf + offset, j)\n\t\trela.r_info = READ32 (buf + offset, j)\n\t\trela.r_addend = READ32 (buf + offset, j)\n#endif\n\t\tr->is_rela = is_rela;\n\t\tr->offset = rela.r_offset;\n\t\tr->type = ELF_R_TYPE (rela.r_info);\n\t\tr->sym = ELF_R_SYM (rela.r_info);\n\t\tr->last = 0;\n\t\tr->addend = rela.r_addend;\n\t\treturn sizeof (Elf_(Rela));\n\t} else {\n\t\tElf_(Rel) rel;\n#if R_BIN_ELF64\n\t\trel.r_offset = READ64 (buf + offset, j)\n\t\trel.r_info = READ64 (buf + offset, j)\n#else\n\t\trel.r_offset = READ32 (buf + offset, j)\n\t\trel.r_info = READ32 (buf + offset, j)\n#endif\n\t\tr->is_rela = is_rela;\n\t\tr->offset = rel.r_offset;\n\t\tr->type = ELF_R_TYPE (rel.r_info);\n\t\tr->sym = ELF_R_SYM (rel.r_info);\n\t\tr->last = 0;\n\t\treturn sizeof (Elf_(Rel));\n\t}\n}\n\nRBinElfReloc* Elf_(r_bin_elf_get_relocs)(ELFOBJ *bin) {\n\tint res, rel, rela, i, j;\n\tsize_t reloc_num = 0;\n\tRBinElfReloc *ret = NULL;\n\n\tif (!bin || !bin->g_sections) {\n\t\treturn NULL;\n\t}\n\treloc_num = get_relocs_num (bin);\n\tif (!reloc_num)\t{\n\t\treturn NULL;\n\t}\n\tbin->reloc_num = reloc_num;\n\tret = (RBinElfReloc*)calloc ((size_t)reloc_num + 1, sizeof(RBinElfReloc));\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n#if DEAD_CODE\n\tut64 section_text_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".text\");\n\tif (section_text_offset == -1) {\n\t\tsection_text_offset = 0;\n\t}\n#endif\n\tfor (i = 0, rel = 0; !bin->g_sections[i].last && rel < reloc_num ; i++) {\n\t\tbool is_rela = 0 == strncmp (bin->g_sections[i].name, \".rela.\", strlen (\".rela.\"));\n\t\tbool is_rel  = 0 == strncmp (bin->g_sections[i].name, \".rel.\",  strlen (\".rel.\"));\n\t\tif (!is_rela && !is_rel) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < bin->g_sections[i].size; j += res) {\n\t\t\tif (bin->g_sections[i].size > bin->size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bin->g_sections[i].offset > bin->size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rel >= reloc_num) {\n\t\t\t\tbprintf (\"Internal error: ELF relocation buffer too small,\"\n\t\t\t\t         \"please file a bug report.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!bin->is_rela) {\n\t\t\t\trela = is_rela? DT_RELA : DT_REL;\n\t\t\t} else {\n\t\t\t\trela = bin->is_rela;\n\t\t\t}\n\t\t\tres = read_reloc (bin, &ret[rel], rela, bin->g_sections[i].offset + j);\n\t\t\tif (j + res > bin->g_sections[i].size) {\n\t\t\t\tbprintf (\"Warning: malformed file, relocation entry #%u is partially beyond the end of section %u.\\n\", rel, i);\n\t\t\t}\n\t\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\t\tif (bin->g_sections[i].info < bin->ehdr.e_shnum && bin->shdr) {\n\t\t\t\t\tret[rel].rva = bin->shdr[bin->g_sections[i].info].sh_offset + ret[rel].offset;\n\t\t\t\t\tret[rel].rva = Elf_(r_bin_elf_p2v) (bin, ret[rel].rva);\n\t\t\t\t} else {\n\t\t\t\t\tret[rel].rva = ret[rel].offset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret[rel].rva = ret[rel].offset;\n\t\t\t\tret[rel].offset = Elf_(r_bin_elf_v2p) (bin, ret[rel].offset);\n\t\t\t}\n\t\t\tret[rel].last = 0;\n\t\t\tif (res < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trel++;\n\t\t}\n\t}\n\tret[reloc_num].last = 1;\n\treturn ret;\n}\n\nRBinElfLib* Elf_(r_bin_elf_get_libs)(ELFOBJ *bin) {\n\tRBinElfLib *ret = NULL;\n\tint j, k;\n\n\tif (!bin || !bin->phdr || !bin->dyn_buf || !bin->strtab || *(bin->strtab+1) == '0') {\n\t\treturn NULL;\n\t}\n\tfor (j = 0, k = 0; j < bin->dyn_entries; j++)\n\t\tif (bin->dyn_buf[j].d_tag == DT_NEEDED) {\n\t\t\tRBinElfLib *r = realloc (ret, (k + 1) * sizeof (RBinElfLib));\n\t\t\tif (!r) {\n\t\t\t\tperror (\"realloc (libs)\");\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret = r;\n\t\t\tif (bin->dyn_buf[j].d_un.d_val > bin->strtab_size) {\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrncpy (ret[k].name, bin->strtab + bin->dyn_buf[j].d_un.d_val, ELF_STRING_LENGTH);\n\t\t\tret[k].name[ELF_STRING_LENGTH - 1] = '\\0';\n   \t\t\tret[k].last = 0;\n\t\t\tif (ret[k].name[0]) {\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\tRBinElfLib *r = realloc (ret, (k + 1) * sizeof (RBinElfLib));\n\tif (!r) {\n\t\tperror (\"realloc (libs)\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret = r;\n\tret[k].last = 1;\n\treturn ret;\n}\n\nstatic RBinElfSection* get_sections_from_phdr(ELFOBJ *bin) {\n\tRBinElfSection *ret;\n\tint i, num_sections = 0;\n\tut64 reldyn = 0, relava = 0, pltgotva = 0, relva = 0;\n\tut64 reldynsz = 0, relasz = 0, pltgotsz = 0;\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum)\n\t\treturn NULL;\n\n\tfor (i = 0; i < bin->dyn_entries; i++) {\n\t\tswitch (bin->dyn_buf[i].d_tag) {\n\t\tcase DT_REL:\n\t\t\treldyn = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_RELA:\n\t\t\trelva = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_RELSZ:\n\t\t\treldynsz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RELASZ:\n\t\t\trelasz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_PLTGOT:\n\t\t\tpltgotva = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_PLTRELSZ:\n\t\t\tpltgotsz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_JMPREL:\n\t\t\trelava = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tdefault: break;\n\t\t}\n\t}\n\tret = calloc (num_sections + 1, sizeof(RBinElfSection));\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\ti = 0;\n\tif (reldyn) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, reldyn);\n\t\tret[i].rva = reldyn;\n\t\tret[i].size = reldynsz;\n\t\tstrcpy (ret[i].name, \".rel.dyn\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (relava) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, relava);\n\t\tret[i].rva = relava;\n\t\tret[i].size = pltgotsz;\n\t\tstrcpy (ret[i].name, \".rela.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (relva) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, relva);\n\t\tret[i].rva = relva;\n\t\tret[i].size = relasz;\n\t\tstrcpy (ret[i].name, \".rel.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (pltgotva) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, pltgotva);\n\t\tret[i].rva = pltgotva;\n\t\tret[i].size = pltgotsz;\n\t\tstrcpy (ret[i].name, \".got.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tret[i].last = 1;\n\n\treturn ret;\n}\n\nRBinElfSection* Elf_(r_bin_elf_get_sections)(ELFOBJ *bin) {\n\tRBinElfSection *ret = NULL;\n\tchar unknown_s[20], invalid_s[20];\n\tint i, nidx, unknown_c=0, invalid_c=0;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->g_sections) {\n\t\treturn bin->g_sections;\n\t}\n\tif (!bin->shdr) {\n\t\t//we don't give up search in phdr section\n\t\treturn get_sections_from_phdr (bin);\n\t}\n\tif (!(ret = calloc ((bin->ehdr.e_shnum + 1), sizeof (RBinElfSection)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tret[i].offset = bin->shdr[i].sh_offset;\n\t\tret[i].size = bin->shdr[i].sh_size;\n\t\tret[i].align = bin->shdr[i].sh_addralign;\n\t\tret[i].flags = bin->shdr[i].sh_flags;\n\t\tret[i].link = bin->shdr[i].sh_link;\n\t\tret[i].info = bin->shdr[i].sh_info;\n\t\tret[i].type = bin->shdr[i].sh_type;\n\t\tif (bin->ehdr.e_type == ET_REL)\t{\n\t\t\tret[i].rva = bin->baddr + bin->shdr[i].sh_offset;\n\t\t} else {\n\t\t\tret[i].rva = bin->shdr[i].sh_addr;\n\t\t}\n\t\tnidx = bin->shdr[i].sh_name;\n#define SHNAME (int)bin->shdr[i].sh_name\n#define SHNLEN ELF_STRING_LENGTH - 4\n#define SHSIZE (int)bin->shstrtab_size\n\t\tif (nidx < 0 || !bin->shstrtab_section || !bin->shstrtab_size || nidx > bin->shstrtab_size) {\n\t\t\tsnprintf (invalid_s, sizeof (invalid_s) - 4, \"invalid%d\", invalid_c);\n\t\t\tstrncpy (ret[i].name, invalid_s, SHNLEN);\n\t\t\tinvalid_c++;\n\t\t} else {\n\t\t\tif (bin->shstrtab && (SHNAME > 0) && (SHNAME < SHSIZE)) {\n\t\t\t\tstrncpy (ret[i].name, &bin->shstrtab[SHNAME], SHNLEN);\n\t\t\t} else {\n\t\t\t\tif (bin->shdr[i].sh_type == SHT_NULL) {\n\t\t\t\t\t//to follow the same behaviour as readelf\n\t\t\t\t\tstrncpy (ret[i].name, \"\", sizeof (ret[i].name) - 4);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (unknown_s, sizeof (unknown_s)-4, \"unknown%d\", unknown_c);\n\t\t\t\t\tstrncpy (ret[i].name, unknown_s, sizeof (ret[i].name)-4);\n\t\t\t\t\tunknown_c++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret[i].name[ELF_STRING_LENGTH-2] = '\\0';\n\t\tret[i].last = 0;\n\t}\n\tret[i].last = 1;\n\treturn ret;\n}\n\nstatic void fill_symbol_bind_and_type (struct r_bin_elf_symbol_t *ret, Elf_(Sym) *sym) {\n\t#define s_bind(x) ret->bind = x\n\t#define s_type(x) ret->type = x\n\tswitch (ELF_ST_BIND(sym->st_info)) {\n\tcase STB_LOCAL:  s_bind (\"LOCAL\"); break;\n\tcase STB_GLOBAL: s_bind (\"GLOBAL\"); break;\n\tcase STB_WEAK:   s_bind (\"WEAK\"); break;\n\tcase STB_NUM:    s_bind (\"NUM\"); break;\n\tcase STB_LOOS:   s_bind (\"LOOS\"); break;\n\tcase STB_HIOS:   s_bind (\"HIOS\"); break;\n\tcase STB_LOPROC: s_bind (\"LOPROC\"); break;\n\tcase STB_HIPROC: s_bind (\"HIPROC\"); break;\n\tdefault:         s_bind (\"UNKNOWN\");\n\t}\n\tswitch (ELF_ST_TYPE (sym->st_info)) {\n\tcase STT_NOTYPE:  s_type (\"NOTYPE\"); break;\n\tcase STT_OBJECT:  s_type (\"OBJECT\"); break;\n\tcase STT_FUNC:    s_type (\"FUNC\"); break;\n\tcase STT_SECTION: s_type (\"SECTION\"); break;\n\tcase STT_FILE:    s_type (\"FILE\"); break;\n\tcase STT_COMMON:  s_type (\"COMMON\"); break;\n\tcase STT_TLS:     s_type (\"TLS\"); break;\n\tcase STT_NUM:     s_type (\"NUM\"); break;\n\tcase STT_LOOS:    s_type (\"LOOS\"); break;\n\tcase STT_HIOS:    s_type (\"HIOS\"); break;\n\tcase STT_LOPROC:  s_type (\"LOPROC\"); break;\n\tcase STT_HIPROC:  s_type (\"HIPROC\"); break;\n\tdefault:          s_type (\"UNKNOWN\");\n\t}\n}\n\nstatic RBinElfSymbol* get_symbols_from_phdr(ELFOBJ *bin, int type) {\n\tElf_(Sym) *sym = NULL;\n\tElf_(Addr) addr_sym_table = 0;\n\tut8 s[sizeof (Elf_(Sym))] = {0};\n\tRBinElfSymbol *ret = NULL;\n\tint i, j, r, tsize, nsym, ret_ctr;\n\tut64 toffset = 0, tmp_offset;\n\tut32 size, sym_size = 0;\n\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum) {\n\t\treturn NULL;\n\t}\n\tfor (j = 0; j < bin->dyn_entries; j++) {\n\t\tswitch (bin->dyn_buf[j].d_tag) {\n\t\tcase (DT_SYMTAB):\n\t\t\taddr_sym_table = Elf_(r_bin_elf_v2p) (bin, bin->dyn_buf[j].d_un.d_ptr);\n\t\t\tbreak;\n\t\tcase (DT_SYMENT):\n\t\t\tsym_size = bin->dyn_buf[j].d_un.d_val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!addr_sym_table) {\n\t\treturn NULL;\n\t}\n\tif (!sym_size) {\n\t\treturn NULL;\n\t}\n\t//since ELF doesn't specify the symbol table size we may read until the end of the buffer\n\tnsym = (bin->size - addr_sym_table) / sym_size;\n\tif (!UT32_MUL (&size, nsym, sizeof (Elf_ (Sym)))) {\n\t\tgoto beach;\n\t}\n\tif (size < 1) {\n\t\tgoto beach;\n\t}\n\tif (addr_sym_table > bin->size || addr_sym_table + size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (nsym < 1) {\n\t\treturn NULL;\n\t}\n\t// we reserve room for 4096 and grow as needed.\n\tsize_t capacity1 = 4096;\n\tsize_t capacity2 = 4096;\n\tsym = (Elf_(Sym)*) calloc (capacity1, sym_size);\n\tret = (RBinElfSymbol *) calloc (capacity2, sizeof (struct r_bin_elf_symbol_t));\n\tif (!sym || !ret) {\n\t\tgoto beach;\n\t}\n\tfor (i = 1, ret_ctr = 0; i < nsym; i++) {\n\t\tif (i >= capacity1) { // maybe grow\n\t\t\t// You take what you want, but you eat what you take.\n\t\t\tElf_(Sym)* temp_sym = (Elf_(Sym)*) realloc(sym, (capacity1 * GROWTH_FACTOR) * sym_size);\n\t\t\tif (!temp_sym) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsym = temp_sym;\n\t\t\tcapacity1 *= GROWTH_FACTOR;\n\t\t}\n\t\tif (ret_ctr >= capacity2) { // maybe grow\n\t\t\tRBinElfSymbol *temp_ret = realloc (ret, capacity2 * GROWTH_FACTOR * sizeof (struct r_bin_elf_symbol_t));\n\t\t\tif (!temp_ret) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tret = temp_ret;\n\t\t\tcapacity2 *= GROWTH_FACTOR;\n\t\t}\n\t\t// read in one entry\n\t\tr = r_buf_read_at (bin->b, addr_sym_table + i * sizeof (Elf_ (Sym)), s, sizeof (Elf_ (Sym)));\n\t\tif (r < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tint j = 0;\n#if R_BIN_ELF64\n\t\tsym[i].st_name = READ32 (s, j);\n\t\tsym[i].st_info = READ8 (s, j);\n\t\tsym[i].st_other = READ8 (s, j);\n\t\tsym[i].st_shndx = READ16 (s, j);\n\t\tsym[i].st_value = READ64 (s, j);\n\t\tsym[i].st_size = READ64 (s, j);\n#else\n\t\tsym[i].st_name = READ32 (s, j);\n\t\tsym[i].st_value = READ32 (s, j);\n\t\tsym[i].st_size = READ32 (s, j);\n\t\tsym[i].st_info = READ8 (s, j);\n\t\tsym[i].st_other = READ8 (s, j);\n\t\tsym[i].st_shndx = READ16 (s, j);\n#endif\n\t\t// zero symbol is always empty\n\t\t// Examine entry and maybe store\n\t\tif (type == R_BIN_ELF_IMPORTS && sym[i].st_shndx == STN_UNDEF) {\n\t\t\tif (sym[i].st_value) {\n\t\t\t\ttoffset = sym[i].st_value;\n\t\t\t} else if ((toffset = get_import_addr (bin, i)) == -1){\n\t\t\t\ttoffset = 0;\n\t\t\t}\n\t\t\ttsize = 16;\n\t\t} else if (type == R_BIN_ELF_SYMBOLS &&\n\t\t           sym[i].st_shndx != STN_UNDEF &&\n\t\t           ELF_ST_TYPE (sym[i].st_info) != STT_SECTION &&\n\t\t           ELF_ST_TYPE (sym[i].st_info) != STT_FILE) {\n\t\t\ttsize = sym[i].st_size;\n\t\t\ttoffset = (ut64) sym[i].st_value;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\ttmp_offset = Elf_(r_bin_elf_v2p) (bin, toffset);\n\t\tif (tmp_offset > bin->size) {\n\t\t\tgoto done;\n\t\t}\n\t\tif (sym[i].st_name + 2 > bin->strtab_size) {\n\t\t\t// Since we are reading beyond the symbol table what's happening\n\t\t\t// is that some entry is trying to dereference the strtab beyond its capacity\n\t\t\t// is not a symbol so is the end\n\t\t\tgoto done;\n\t\t}\n\t\tret[ret_ctr].offset = tmp_offset;\n\t\tret[ret_ctr].size = tsize;\n\t\t{\n\t\t\tint rest = ELF_STRING_LENGTH - 1;\n\t\t\tint st_name = sym[i].st_name;\n\t\t\tint maxsize = R_MIN (bin->size, bin->strtab_size);\n\t\t\tif (st_name < 0 || st_name >= maxsize) {\n\t\t\t\tret[ret_ctr].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tconst int len = __strnlen (bin->strtab + st_name, rest);\n\t\t\t\tmemcpy (ret[ret_ctr].name, &bin->strtab[st_name], len);\n\t\t\t}\n\t\t}\n\t\tret[ret_ctr].ordinal = i;\n\t\tret[ret_ctr].in_shdr = false;\n\t\tret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\\0';\n\t\tfill_symbol_bind_and_type (&ret[ret_ctr], &sym[i]);\n\t\tret[ret_ctr].last = 0;\n\t\tret_ctr++;\n\t}\ndone:\n\tret[ret_ctr].last = 1;\n\t// Size everything down to only what is used\n\t{\n\t\tnsym = i > 0 ? i : 1;\n\t\tElf_ (Sym) * temp_sym = (Elf_ (Sym)*) realloc (sym, (nsym * GROWTH_FACTOR) * sym_size);\n\t\tif (!temp_sym) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsym = temp_sym;\n\t}\n\t{\n\t\tret_ctr = ret_ctr > 0 ? ret_ctr : 1;\n\t\tRBinElfSymbol *p = (RBinElfSymbol *) realloc (ret, (ret_ctr + 1) * sizeof (RBinElfSymbol));\n\t\tif (!p) {\n\t\t\tgoto beach;\n\t\t}\n\t\tret = p;\n\t}\n\tif (type == R_BIN_ELF_IMPORTS && !bin->imports_by_ord_size) {\n\t\tbin->imports_by_ord_size = ret_ctr + 1;\n\t\tif (ret_ctr > 0) {\n\t\t\tbin->imports_by_ord = (RBinImport * *) calloc (ret_ctr + 1, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t} else if (type == R_BIN_ELF_SYMBOLS && !bin->symbols_by_ord_size && ret_ctr) {\n\t\tbin->symbols_by_ord_size = ret_ctr + 1;\n\t\tif (ret_ctr > 0) {\n\t\t\tbin->symbols_by_ord = (RBinSymbol * *) calloc (ret_ctr + 1, sizeof (RBinSymbol*));\n\t\t}else {\n\t\t\tbin->symbols_by_ord = NULL;\n\t\t}\n\t}\n\tfree (sym);\n\treturn ret;\nbeach:\n\tfree (sym);\n\tfree (ret);\n\treturn NULL;\n}\n\nstatic RBinElfSymbol *Elf_(r_bin_elf_get_phdr_symbols)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_symbols) {\n\t\treturn bin->phdr_symbols;\n\t}\n\tbin->phdr_symbols = get_symbols_from_phdr (bin, R_BIN_ELF_SYMBOLS);\n\treturn bin->phdr_symbols;\n}\n\nstatic RBinElfSymbol *Elf_(r_bin_elf_get_phdr_imports)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_imports) {\n\t\treturn bin->phdr_imports;\n\t}\n\tbin->phdr_imports = get_symbols_from_phdr (bin, R_BIN_ELF_IMPORTS);\n\treturn bin->phdr_imports;\n}\n\nstatic int Elf_(fix_symbols)(ELFOBJ *bin, int nsym, int type, RBinElfSymbol **sym) {\n\tint count = 0;\n\tRBinElfSymbol *ret = *sym;\n\tRBinElfSymbol *phdr_symbols = (type == R_BIN_ELF_SYMBOLS)\n\t\t\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n\tRBinElfSymbol *tmp, *p;\n\tif (phdr_symbols) {\n\t\tRBinElfSymbol *d = ret;\n\t\twhile (!d->last) {\n\t\t\t/* find match in phdr */\n\t\t\tp = phdr_symbols;\n\t\t\twhile (!p->last) {\n\t\t\t\tif (p->offset && d->offset == p->offset) {\n\t\t\t\t\tp->in_shdr = true;\n\t\t\t\t\tif (*p->name && strcmp (d->name, p->name)) {\n\t\t\t\t\t\tstrcpy (d->name, p->name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\td++;\n\t\t}\n\t\tp = phdr_symbols;\n\t\twhile (!p->last) {\n\t\t\tif (!p->in_shdr) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\t/*Take those symbols that are not present in the shdr but yes in phdr*/\n\t\t/*This should only should happen with fucked up binaries*/\n\t\tif (count > 0) {\n\t\t\t/*what happens if a shdr says it has only one symbol? we should look anyway into phdr*/\n\t\t\ttmp = (RBinElfSymbol*)realloc (ret, (nsym + count + 1) * sizeof (RBinElfSymbol));\n\t\t\tif (!tmp) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = tmp;\n\t\t\tret[nsym--].last = 0;\n\t\t\tp = phdr_symbols;\n\t\t\twhile (!p->last) {\n\t\t\t\tif (!p->in_shdr) {\n\t\t\t\t\tmemcpy (&ret[++nsym], p, sizeof (RBinElfSymbol));\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret[nsym + 1].last = 1;\n\t\t}\n\t\t*sym = ret;\n\t\treturn nsym + 1;\n\t}\n\treturn nsym;\n}\n\nstatic RBinElfSymbol* Elf_(_r_bin_elf_get_symbols_imports)(ELFOBJ *bin, int type) {\n\tut32 shdr_size;\n\tint tsize, nsym, ret_ctr = 0, i, j, r, k, newsize;\n\tut64 toffset;\n\tut32 size = 0;\n\tRBinElfSymbol  *ret = NULL;\n\tElf_(Shdr) *strtab_section = NULL;\n\tElf_(Sym) *sym = NULL;\n\tut8 s[sizeof (Elf_(Sym))] = { 0 };\n\tchar *strtab = NULL;\n\n\tif (!bin || !bin->shdr || !bin->ehdr.e_shnum || bin->ehdr.e_shnum == 0xffff) {\n\t\treturn (type == R_BIN_ELF_SYMBOLS)\n\t\t\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n\t}\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size + 8 > bin->size) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tif ((type == R_BIN_ELF_IMPORTS && bin->shdr[i].sh_type == (bin->ehdr.e_type == ET_REL ? SHT_SYMTAB : SHT_DYNSYM)) ||\n\t\t\t\t(type == R_BIN_ELF_SYMBOLS && bin->shdr[i].sh_type == (Elf_(r_bin_elf_get_stripped) (bin) ? SHT_DYNSYM : SHT_SYMTAB))) {\n\t\t\tif (bin->shdr[i].sh_link < 1) {\n\t\t\t\t/* oops. fix out of range pointers */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// hack to avoid asan cry\n\t\t\tif ((bin->shdr[i].sh_link * sizeof(Elf_(Shdr))) >= shdr_size) {\n\t\t\t\t/* oops. fix out of range pointers */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrtab_section = &bin->shdr[bin->shdr[i].sh_link];\n\t\t\tif (strtab_section->sh_size > ST32_MAX || strtab_section->sh_size+8 > bin->size) {\n\t\t\t\tbprintf (\"size (syms strtab)\");\n\t\t\t\tfree (ret);\n\t\t\t\tfree (strtab);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (!strtab) {\n\t\t\t\tif (!(strtab = (char *)calloc (1, 8 + strtab_section->sh_size))) {\n\t\t\t\t\tbprintf (\"malloc (syms strtab)\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (strtab_section->sh_offset > bin->size ||\n\t\t\t\t\t\tstrtab_section->sh_offset + strtab_section->sh_size > bin->size) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, strtab_section->sh_offset,\n\t\t\t\t\t\t\t(ut8*)strtab, strtab_section->sh_size) == -1) {\n\t\t\t\t\tbprintf (\"Warning: read (syms strtab)\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnewsize = 1 + bin->shdr[i].sh_size;\n\t\t\tif (newsize < 0 || newsize > bin->size) {\n\t\t\t\tbprintf (\"invalid shdr %d size\\n\", i);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tnsym = (int)(bin->shdr[i].sh_size / sizeof (Elf_(Sym)));\n\t\t\tif (nsym < 0) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!(sym = (Elf_(Sym) *)calloc (nsym, sizeof (Elf_(Sym))))) {\n\t\t\t\tbprintf (\"calloc (syms)\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!UT32_MUL (&size, nsym, sizeof (Elf_(Sym)))) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (size < 1 || size > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (bin->shdr[i].sh_offset + size > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfor (j = 0; j < nsym; j++) {\n\t\t\t\tint k = 0;\n\t\t\t\tr = r_buf_read_at (bin->b, bin->shdr[i].sh_offset + j * sizeof (Elf_(Sym)), s, sizeof (Elf_(Sym)));\n\t\t\t\tif (r < 1) {\n\t\t\t\t\tbprintf (\"Warning: read (sym)\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n#if R_BIN_ELF64\n\t\t\t\tsym[j].st_name = READ32 (s, k)\n\t\t\t\tsym[j].st_info = READ8 (s, k)\n\t\t\t\tsym[j].st_other = READ8 (s, k)\n\t\t\t\tsym[j].st_shndx = READ16 (s, k)\n\t\t\t\tsym[j].st_value = READ64 (s, k)\n\t\t\t\tsym[j].st_size = READ64 (s, k)\n#else\n\t\t\t\tsym[j].st_name = READ32 (s, k)\n\t\t\t\tsym[j].st_value = READ32 (s, k)\n\t\t\t\tsym[j].st_size = READ32 (s, k)\n\t\t\t\tsym[j].st_info = READ8 (s, k)\n\t\t\t\tsym[j].st_other = READ8 (s, k)\n\t\t\t\tsym[j].st_shndx = READ16 (s, k)\n#endif\n\t\t\t}\n\t\t\tfree (ret);\n\t\t\tret = calloc (nsym, sizeof (RBinElfSymbol));\n\t\t\tif (!ret) {\n\t\t\t\tbprintf (\"Cannot allocate %d symbols\\n\", nsym);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfor (k = 1, ret_ctr = 0; k < nsym; k++) {\n\t\t\t\tif (type == R_BIN_ELF_IMPORTS && sym[k].st_shndx == STN_UNDEF) {\n\t\t\t\t\tif (sym[k].st_value) {\n\t\t\t\t\t\ttoffset = sym[k].st_value;\n\t\t\t\t\t} else if ((toffset = get_import_addr (bin, k)) == -1){\n\t\t\t\t\t\ttoffset = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttsize = 16;\n\t\t\t\t} else if (type == R_BIN_ELF_SYMBOLS &&\n\t\t\t\t\t   sym[k].st_shndx != STN_UNDEF &&\n\t\t\t\t\t   ELF_ST_TYPE (sym[k].st_info) != STT_SECTION &&\n\t\t\t\t\t   ELF_ST_TYPE (sym[k].st_info) != STT_FILE) {\n\t\t\t\t\t//int idx = sym[k].st_shndx;\n\t\t\t\t\ttsize = sym[k].st_size;\n\t\t\t\t\ttoffset = (ut64)sym[k].st_value; \n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\t\t\tif (sym[k].st_shndx < bin->ehdr.e_shnum)\n\t\t\t\t\t\tret[ret_ctr].offset = sym[k].st_value + bin->shdr[sym[k].st_shndx].sh_offset;\n\t\t\t\t} else {\n\t\t\t\t\tret[ret_ctr].offset = Elf_(r_bin_elf_v2p) (bin, toffset);\n\t\t\t\t}\n\t\t\t\tret[ret_ctr].size = tsize;\n\t\t\t\tif (sym[k].st_name + 2 > strtab_section->sh_size) {\n\t\t\t\t\tbprintf (\"Warning: index out of strtab range\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tint rest = ELF_STRING_LENGTH - 1;\n\t\t\t\t\tint st_name = sym[k].st_name;\n\t\t\t\t\tint maxsize = R_MIN (bin->b->length, strtab_section->sh_size);\n\t\t\t\t\tif (st_name < 0 || st_name >= maxsize) {\n\t\t\t\t\t\tret[ret_ctr].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst size_t len = __strnlen (strtab + sym[k].st_name, rest);\n\t\t\t\t\t\tmemcpy (ret[ret_ctr].name, &strtab[sym[k].st_name], len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret[ret_ctr].ordinal = k;\n\t\t\t\tret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\\0';\n\t\t\t\tfill_symbol_bind_and_type (&ret[ret_ctr], &sym[k]);\n\t\t\t\tret[ret_ctr].last = 0;\n\t\t\t\tret_ctr++;\n\t\t\t}\n\t\t\tret[ret_ctr].last = 1; // ugly dirty hack :D\n\t\t\tR_FREE (strtab);\n\t\t\tR_FREE (sym);\n\t\t}\n\t}\n\tif (!ret) {\n\t\treturn (type == R_BIN_ELF_SYMBOLS)\n\t\t\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n\t}\n\tint max = -1;\n\tRBinElfSymbol *aux = NULL;\n\tnsym = Elf_(fix_symbols) (bin, ret_ctr, type, &ret);\n\tif (nsym == -1) {\n\t\tgoto beach;\n\t}\n\taux = ret;\n\twhile (!aux->last) {\n\t\tif ((int)aux->ordinal > max) {\n\t\t\tmax = aux->ordinal;\n\t\t}\n\t\taux++;\n\t}\n\tnsym = max;\n\tif (type == R_BIN_ELF_IMPORTS) {\n\t\tR_FREE (bin->imports_by_ord);\n\t\tbin->imports_by_ord_size = nsym + 1;\n\t\tbin->imports_by_ord = (RBinImport**)calloc (R_MAX (1, nsym + 1), sizeof (RBinImport*));\n\t} else if (type == R_BIN_ELF_SYMBOLS) {\n\t\tR_FREE (bin->symbols_by_ord);\n\t\tbin->symbols_by_ord_size = nsym + 1;\n\t\tbin->symbols_by_ord = (RBinSymbol**)calloc (R_MAX (1, nsym + 1), sizeof (RBinSymbol*));\n\t}\n\treturn ret;\nbeach:\n\tfree (ret);\n\tfree (sym);\n\tfree (strtab);\n\treturn NULL;\n}\n\nRBinElfSymbol *Elf_(r_bin_elf_get_symbols)(ELFOBJ *bin) {\n\tif (!bin->g_symbols) {\n\t\tbin->g_symbols = Elf_(_r_bin_elf_get_symbols_imports) (bin, R_BIN_ELF_SYMBOLS);\n\t}\n\treturn bin->g_symbols;\n}\n\n\nRBinElfSymbol *Elf_(r_bin_elf_get_imports)(ELFOBJ *bin) {\n\tif (!bin->g_imports) {\n\t\tbin->g_imports = Elf_(_r_bin_elf_get_symbols_imports) (bin, R_BIN_ELF_IMPORTS);\n\t}\n\treturn bin->g_imports;\n}\n\nRBinElfField* Elf_(r_bin_elf_get_fields)(ELFOBJ *bin) {\n\tRBinElfField *ret = NULL;\n\tint i = 0, j;\n\tif (!bin || !(ret = calloc ((bin->ehdr.e_phnum + 3 + 1), sizeof (RBinElfField)))) {\n\t\treturn NULL;\n\t}\n\tstrncpy (ret[i].name, \"ehdr\", ELF_STRING_LENGTH);\n\tret[i].offset = 0;\n\tret[i++].last = 0;\n\tstrncpy (ret[i].name, \"shoff\", ELF_STRING_LENGTH);\n\tret[i].offset = bin->ehdr.e_shoff;\n\tret[i++].last = 0;\n\tstrncpy (ret[i].name, \"phoff\", ELF_STRING_LENGTH);\n\tret[i].offset = bin->ehdr.e_phoff;\n\tret[i++].last = 0;\n\tfor (j = 0; bin->phdr && j < bin->ehdr.e_phnum; i++, j++) {\n\t\tsnprintf (ret[i].name, ELF_STRING_LENGTH, \"phdr_%i\", j);\n\t\tret[i].offset = bin->phdr[j].p_offset;\n\t\tret[i].last = 0;\n\t}\n\tret[i].last = 1;\n\treturn ret;\n}\n\nvoid* Elf_(r_bin_elf_free)(ELFOBJ* bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tfree (bin->phdr);\n\tfree (bin->shdr);\n\tfree (bin->strtab);\n\tfree (bin->dyn_buf);\n\tfree (bin->shstrtab);\n\tfree (bin->dynstr);\n\t//free (bin->strtab_section);\n\tif (bin->imports_by_ord) {\n\t\tfor (i = 0; i<bin->imports_by_ord_size; i++) {\n\t\t\tfree (bin->imports_by_ord[i]);\n\t\t}\n\t\tfree (bin->imports_by_ord);\n\t}\n\tif (bin->symbols_by_ord) {\n\t\tfor (i = 0; i<bin->symbols_by_ord_size; i++) {\n\t\t\tfree (bin->symbols_by_ord[i]);\n\t\t}\n\t\tfree (bin->symbols_by_ord);\n\t}\n\tr_buf_free (bin->b);\n\tif (bin->g_symbols != bin->phdr_symbols) {\n\t\tR_FREE (bin->phdr_symbols);\n\t}\n\tif (bin->g_imports != bin->phdr_imports) {\n\t\tR_FREE (bin->phdr_imports);\n\t}\n\tR_FREE (bin->g_sections);\n\tR_FREE (bin->g_symbols);\n\tR_FREE (bin->g_imports);\n\tfree (bin);\n\treturn NULL;\n}\n\nELFOBJ* Elf_(r_bin_elf_new)(const char* file, bool verbose) {\n\tut8 *buf;\n\tint size;\n\tELFOBJ *bin = R_NEW0 (ELFOBJ);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (ELFOBJ));\n\tbin->file = file;\n\tif (!(buf = (ut8*)r_file_slurp (file, &size))) {\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tbin->size = size;\n\tbin->verbose = verbose;\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tif (!elf_init (bin)) {\n\t\tfree (buf);\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tfree (buf);\n\treturn bin;\n}\n\nELFOBJ* Elf_(r_bin_elf_new_buf)(RBuffer *buf, bool verbose) {\n\tELFOBJ *bin = R_NEW0 (ELFOBJ);\n\tbin->kv = sdb_new0 ();\n\tbin->b = r_buf_new ();\n\tbin->size = (ut32)buf->length;\n\tbin->verbose = verbose;\n\tif (!r_buf_set_bytes (bin->b, buf->buf, buf->length)) {\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tif (!elf_init (bin)) {\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\treturn bin;\n}\n\nstatic int is_in_pphdr (Elf_(Phdr) *p, ut64 addr) {\n\treturn addr >= p->p_offset && addr < p->p_offset + p->p_memsz;\n}\n\nstatic int is_in_vphdr (Elf_(Phdr) *p, ut64 addr) {\n\treturn addr >= p->p_vaddr && addr < p->p_vaddr + p->p_memsz;\n}\n\n\n/* converts a physical address to the virtual address, looking\n * at the program headers in the binary bin */\nut64 Elf_(r_bin_elf_p2v) (ELFOBJ *bin, ut64 paddr) {\n\tint i;\n\n\tif (!bin) return 0;\n\n\tif (!bin->phdr) {\n\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\treturn bin->baddr + paddr;\n\t\t}\n\t\treturn paddr;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; ++i) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\tif (p->p_type == PT_LOAD && is_in_pphdr (p, paddr)) {\n\t\t\tif (!p->p_vaddr && !p->p_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_vaddr + paddr - p->p_offset;\n\t\t}\n\t}\n\n\treturn paddr;\n}\n\n/* converts a virtual address to the relative physical address, looking\n * at the program headers in the binary bin */\nut64 Elf_(r_bin_elf_v2p) (ELFOBJ *bin, ut64 vaddr) {\n\tint i;\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\tif (!bin->phdr) {\n\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\treturn vaddr - bin->baddr;\n\t\t}\n\t\treturn vaddr;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; ++i) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\tif (p->p_type == PT_LOAD && is_in_vphdr (p, vaddr)) {\n\t\t\tif (!p->p_offset && !p->p_vaddr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_offset + vaddr - p->p_vaddr;\n\t\t}\n\t}\n\treturn vaddr;\n}\n"], "filenames": ["libr/bin/format/elf/elf.c"], "buggy_code_start_loc": [751], "buggy_code_end_loc": [752], "fixing_code_start_loc": [751], "fixing_code_end_loc": [757], "type": "CWE-125", "message": "In radare2 2.0.1, an integer exception (negative number leading to an invalid memory access) exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c via crafted ELF files when parsing the ELF version on 32bit systems.", "other": {"cve": {"id": "CVE-2017-15932", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-27T18:29:00.370", "lastModified": "2017-11-02T01:29:01.780", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In radare2 2.0.1, an integer exception (negative number leading to an invalid memory access) exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c via crafted ELF files when parsing the ELF version on 32bit systems."}, {"lang": "es", "value": "En radare2 2.0.1, existe una excepci\u00f3n de enteros (n\u00famero negativo que provoca un acceso de memoria no v\u00e1lido) en store_versioninfo_gnu_verdef() en libr/bin/format/elf/elf.c mediante archivos ELF manipulados cuando se analiza la versi\u00f3n ELF en sistemas de 32 bits."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "E5B4DFB4-18C8-413E-8953-1E7359DAC6EE"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/101614", "source": "cve@mitre.org"}, {"url": "https://github.com/radare/radare2/commit/44ded3ff35b8264f54b5a900cab32ec489d9e5b9", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/8743", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/44ded3ff35b8264f54b5a900cab32ec489d9e5b9"}}