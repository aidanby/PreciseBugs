{"buggy_code": ["import certifi\nimport requests\n\n\nfrom flask import request, session as flask_session, redirect\nimport flask_login\nfrom requests_oauthlib import OAuth2Session\n\nfrom app.db import with_session, DBSession\nfrom env import QuerybookSettings\nfrom lib.logger import get_logger\nfrom logic.user import (\n    get_user_by_name,\n    create_user,\n)\nfrom .utils import (\n    AuthenticationError,\n    AuthUser,\n    abort_unauthorized,\n    QuerybookLoginManager,\n)\n\nLOG = get_logger(__file__)\n\nOAUTH_CALLBACK_PATH = \"/oauth2callback\"\n\n\nclass OAuthLoginManager(object):\n    def __init__(self):\n        self.login_manager = QuerybookLoginManager()\n        self.flask_app = None\n\n    @property\n    def oauth_session(self):\n        oauth_config = self.oauth_config\n        return OAuth2Session(\n            oauth_config[\"client_id\"],\n            scope=oauth_config[\"scope\"],\n            redirect_uri=oauth_config[\"callback_url\"],\n        )\n\n    @property\n    def oauth_config(self):\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": QuerybookSettings.OAUTH_AUTHORIZATION_URL,\n            \"token_url\": QuerybookSettings.OAUTH_TOKEN_URL,\n            \"profile_url\": QuerybookSettings.OAUTH_USER_PROFILE,\n            \"scope\": \"user\",\n        }\n\n    def init_app(self, flask_app):\n        self.flask_app = flask_app\n\n        self.login_manager.init_app(self.flask_app)\n        self.flask_app.add_url_rule(\n            OAUTH_CALLBACK_PATH, \"oauth_callback\", self.oauth_callback\n        )\n\n    def login(self, request):\n        oauth_url, _ = self._get_authn_url()\n        flask_session[\"next\"] = request.path\n        return redirect(oauth_url)\n\n    def _get_authn_url(self):\n        return self.oauth_session.authorization_url(\n            self.oauth_config[\"authorization_url\"]\n        )\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(self.login_user(username, email, session=session))\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def _parse_user_profile(self, profile_response):\n        user = profile_response.json()[\"user\"]\n        return user[\"username\"], user[\"email\"]\n\n    @with_session\n    def login_user(self, username, email, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=username, email=email, session=session\n            )\n        return user\n\n\nlogin_manager = OAuthLoginManager()\n\nignore_paths = [OAUTH_CALLBACK_PATH]\n\n\ndef init_app(app):\n    login_manager.init_app(app)\n\n\ndef login(request):\n    return login_manager.login(request)\n\n\ndef oauth_authorization_url():\n    return login_manager._get_authn_url()\n", "import certifi\nimport requests\nimport flask_login\n\nfrom app.auth.oauth_auth import OAuthLoginManager, OAUTH_CALLBACK_PATH\nfrom app.db import with_session, DBSession\nfrom env import QuerybookSettings, get_env_config\nfrom flask import request, session as flask_session, redirect\nfrom lib.logger import get_logger\nfrom lib.utils.decorators import in_mem_memoized\nfrom logic.user import (\n    get_user_by_name,\n    create_user,\n)\nfrom .utils import AuthenticationError, abort_unauthorized, AuthUser\n\nLOG = get_logger(__file__)\n\n\nclass NoopAuth(requests.auth.AuthBase):\n    \"\"\"\n    This auth doesn't do anything.\n    It only used to override oauthlib's behavior.\n    \"\"\"\n\n    def __call__(self, r):\n        return r\n\n\nclass OktaLoginManager(OAuthLoginManager):\n    def get_okta_urls(self):\n        okta_base_url = get_env_config(\"OKTA_BASE_URL\")\n        authorization_url = f\"{okta_base_url}/v1/authorize\"\n        token_url = f\"{okta_base_url}/v1/token\"\n        profile_url = f\"{okta_base_url}/v1/userinfo\"\n        return authorization_url, token_url, profile_url\n\n    @property\n    @in_mem_memoized()\n    def oauth_config(self):\n        authorization_url, token_url, profile_url = self.get_okta_urls()\n\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": authorization_url,\n            \"token_url\": token_url,\n            \"profile_url\": profile_url,\n            \"scope\": [\"openid\", \"email\", \"profile\"],\n        }\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n            # This Authentication is needed because Okta would throw error\n            # about passing client_secret and client_id in request.header\n            # which is the default behavior of oauthlib\n            auth=NoopAuth(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email, fullname = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(\n                        self.login_user(username, email, fullname, session=session)\n                    )\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _parse_user_profile(self, resp):\n        user = resp.json()\n        username = user[\"email\"].split(\"@\")[0]\n        return username, user[\"email\"], user[\"name\"]\n\n    @with_session\n    def login_user(self, username, email, fullname, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=fullname, email=email, session=session\n            )\n        return user\n\n\nlogin_manager = OktaLoginManager()\n\nignore_paths = [OAUTH_CALLBACK_PATH]\n\n\ndef init_app(app):\n    login_manager.init_app(app)\n\n\ndef login(request):\n    return login_manager.login(request)\n"], "fixing_code": ["import certifi\nimport requests\n\n\nfrom flask import Markup, request, session as flask_session, redirect\nimport flask_login\nfrom requests_oauthlib import OAuth2Session\n\nfrom app.db import with_session, DBSession\nfrom env import QuerybookSettings\nfrom lib.logger import get_logger\nfrom logic.user import (\n    get_user_by_name,\n    create_user,\n)\nfrom .utils import (\n    AuthenticationError,\n    AuthUser,\n    abort_unauthorized,\n    QuerybookLoginManager,\n)\n\nLOG = get_logger(__file__)\n\nOAUTH_CALLBACK_PATH = \"/oauth2callback\"\n\n\nclass OAuthLoginManager(object):\n    def __init__(self):\n        self.login_manager = QuerybookLoginManager()\n        self.flask_app = None\n\n    @property\n    def oauth_session(self):\n        oauth_config = self.oauth_config\n        return OAuth2Session(\n            oauth_config[\"client_id\"],\n            scope=oauth_config[\"scope\"],\n            redirect_uri=oauth_config[\"callback_url\"],\n        )\n\n    @property\n    def oauth_config(self):\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": QuerybookSettings.OAUTH_AUTHORIZATION_URL,\n            \"token_url\": QuerybookSettings.OAUTH_TOKEN_URL,\n            \"profile_url\": QuerybookSettings.OAUTH_USER_PROFILE,\n            \"scope\": \"user\",\n        }\n\n    def init_app(self, flask_app):\n        self.flask_app = flask_app\n\n        self.login_manager.init_app(self.flask_app)\n        self.flask_app.add_url_rule(\n            OAUTH_CALLBACK_PATH, \"oauth_callback\", self.oauth_callback\n        )\n\n    def login(self, request):\n        oauth_url, _ = self._get_authn_url()\n        flask_session[\"next\"] = request.path\n        return redirect(oauth_url)\n\n    def _get_authn_url(self):\n        return self.oauth_session.authorization_url(\n            self.oauth_config[\"authorization_url\"]\n        )\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(self.login_user(username, email, session=session))\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def _parse_user_profile(self, profile_response):\n        user = profile_response.json()[\"user\"]\n        return user[\"username\"], user[\"email\"]\n\n    @with_session\n    def login_user(self, username, email, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=username, email=email, session=session\n            )\n        return user\n\n\nlogin_manager = OAuthLoginManager()\n\nignore_paths = [OAUTH_CALLBACK_PATH]\n\n\ndef init_app(app):\n    login_manager.init_app(app)\n\n\ndef login(request):\n    return login_manager.login(request)\n\n\ndef oauth_authorization_url():\n    return login_manager._get_authn_url()\n", "import certifi\nimport requests\nimport flask_login\n\nfrom app.auth.oauth_auth import OAuthLoginManager, OAUTH_CALLBACK_PATH\nfrom app.db import with_session, DBSession\nfrom env import QuerybookSettings, get_env_config\nfrom flask import Markup, request, session as flask_session, redirect\nfrom lib.logger import get_logger\nfrom lib.utils.decorators import in_mem_memoized\nfrom logic.user import (\n    get_user_by_name,\n    create_user,\n)\nfrom .utils import AuthenticationError, abort_unauthorized, AuthUser\n\nLOG = get_logger(__file__)\n\n\nclass NoopAuth(requests.auth.AuthBase):\n    \"\"\"\n    This auth doesn't do anything.\n    It only used to override oauthlib's behavior.\n    \"\"\"\n\n    def __call__(self, r):\n        return r\n\n\nclass OktaLoginManager(OAuthLoginManager):\n    def get_okta_urls(self):\n        okta_base_url = get_env_config(\"OKTA_BASE_URL\")\n        authorization_url = f\"{okta_base_url}/v1/authorize\"\n        token_url = f\"{okta_base_url}/v1/token\"\n        profile_url = f\"{okta_base_url}/v1/userinfo\"\n        return authorization_url, token_url, profile_url\n\n    @property\n    @in_mem_memoized()\n    def oauth_config(self):\n        authorization_url, token_url, profile_url = self.get_okta_urls()\n\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": authorization_url,\n            \"token_url\": token_url,\n            \"profile_url\": profile_url,\n            \"scope\": [\"openid\", \"email\", \"profile\"],\n        }\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n            # This Authentication is needed because Okta would throw error\n            # about passing client_secret and client_id in request.header\n            # which is the default behavior of oauthlib\n            auth=NoopAuth(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email, fullname = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(\n                        self.login_user(username, email, fullname, session=session)\n                    )\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _parse_user_profile(self, resp):\n        user = resp.json()\n        username = user[\"email\"].split(\"@\")[0]\n        return username, user[\"email\"], user[\"name\"]\n\n    @with_session\n    def login_user(self, username, email, fullname, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=fullname, email=email, session=session\n            )\n        return user\n\n\nlogin_manager = OktaLoginManager()\n\nignore_paths = [OAUTH_CALLBACK_PATH]\n\n\ndef init_app(app):\n    login_manager.init_app(app)\n\n\ndef login(request):\n    return login_manager.login(request)\n"], "filenames": ["querybook/server/app/auth/oauth_auth.py", "querybook/server/app/auth/okta_auth.py"], "buggy_code_start_loc": [5, 8], "buggy_code_end_loc": [79, 89], "fixing_code_start_loc": [5, 8], "fixing_code_end_loc": [79, 89], "type": "CWE-79", "message": "Querybook is an open source data querying UI. In affected versions user provided data is not escaped in the error field of the auth callback url in `querybook/server/app/auth/oauth_auth.py` and `querybook/server/app/auth/okta_auth.py`. This may allow attackers to perform reflected cross site scripting (XSS) if Content Security Policy (CSP) is not enabled or `unsafe-inline` is allowed. Users are advised to upgrade to the latest, patched version of querybook (version 3.14.2 or greater). Users unable to upgrade may enable CSP and not allow unsafe-inline or manually escape query parameters in a reverse proxy.", "other": {"cve": {"id": "CVE-2022-46151", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-06T01:15:09.813", "lastModified": "2022-12-07T15:23:27.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Querybook is an open source data querying UI. In affected versions user provided data is not escaped in the error field of the auth callback url in `querybook/server/app/auth/oauth_auth.py` and `querybook/server/app/auth/okta_auth.py`. This may allow attackers to perform reflected cross site scripting (XSS) if Content Security Policy (CSP) is not enabled or `unsafe-inline` is allowed. Users are advised to upgrade to the latest, patched version of querybook (version 3.14.2 or greater). Users unable to upgrade may enable CSP and not allow unsafe-inline or manually escape query parameters in a reverse proxy."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pinterest:querybook:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.14.2", "matchCriteriaId": "01CEA186-46D3-4EC5-AA59-D643B007274C"}]}]}], "references": [{"url": "https://github.com/pinterest/querybook/commit/88a7f10495bf5ed1a556ade51a2f2794e403c063", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pinterest/querybook/security/advisories/GHSA-mrrw-9wf7-xq6w", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pinterest/querybook/commit/88a7f10495bf5ed1a556ade51a2f2794e403c063"}}