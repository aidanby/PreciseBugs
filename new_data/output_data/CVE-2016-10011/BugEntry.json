{"buggy_code": ["/* $OpenBSD: authfile.c,v 1.121 2016/04/09 12:39:30 djm Exp $ */\n/*\n * Copyright (c) 2000, 2013 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"cipher.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"authfile.h\"\n#include \"rsa.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"krl.h\"\n\n#define MAX_KEY_FILE_SIZE\t(1024 * 1024)\n\n/* Save a key blob to a file */\nstatic int\nsshkey_save_private_blob(struct sshbuf *keybuf, const char *filename)\n{\n\tint fd, oerrno;\n\n\tif ((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (atomicio(vwrite, fd, (u_char *)sshbuf_ptr(keybuf),\n\t    sshbuf_len(keybuf)) != sshbuf_len(keybuf)) {\n\t\toerrno = errno;\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tclose(fd);\n\treturn 0;\n}\n\nint\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}\n\n/* Load a key from a fd into a buffer */\nint\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}\n\n#ifdef WITH_SSH1\n/*\n * Loads the public part of the ssh v1 key file.  Returns NULL if an error was\n * encountered (the file does not exist or is not readable), and the key\n * otherwise.\n */\nstatic int\nsshkey_load_public_rsa1(int fd, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *b = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_load_file(fd, b)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_parse_public_rsa1_fileblob(b, keyp, commentp)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n#endif /* WITH_SSH1 */\n\n/* XXX remove error() calls from here? */\nint\nsshkey_perm_ok(int fd, const char *filename)\n{\n\tstruct stat st;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t/*\n\t * if a key owned by the user is accessed, then we check the\n\t * permissions of the file. if the key owned by a different user,\n\t * then we don't care.\n\t */\n\tif ((st.st_uid == getuid()) && (st.st_mode & 077) != 0) {\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"Permissions 0%3.3o for '%s' are too open.\",\n\t\t    (u_int)st.st_mode & 0777, filename);\n\t\terror(\"It is required that your private key files are NOT accessible by others.\");\n\t\terror(\"This private key will be ignored.\");\n\t\treturn SSH_ERR_KEY_BAD_PERMISSIONS;\n\t}\n\treturn 0;\n}\n\n/* XXX kill perm_ok now that we have SSH_ERR_KEY_BAD_PERMISSIONS? */\nint\nsshkey_load_private_type(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp, int *perm_ok)\n{\n\tint fd, r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0) {\n\t\tif (perm_ok != NULL)\n\t\t\t*perm_ok = 0;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tif (perm_ok != NULL)\n\t\t\t*perm_ok = 0;\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\tif (perm_ok != NULL)\n\t\t*perm_ok = 1;\n\n\tr = sshkey_load_private_type_fd(fd, type, passphrase, keyp, commentp);\n out:\n\tclose(fd);\n\treturn r;\n}\n\nint\nsshkey_load_private_type_fd(int fd, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob_type(buffer, type,\n\t    passphrase, keyp, commentp)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(buffer);\n\treturn r;\n}\n\n/* XXX this is almost identical to sshkey_load_private_type() */\nint\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}\n\nstatic int\nsshkey_try_load_public(struct sshkey *k, const char *filename, char **commentp)\n{\n\tFILE *f;\n\tchar line[SSH_MAX_PUBKEY_BYTES];\n\tchar *cp;\n\tu_long linenum = 0;\n\tint r;\n\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\twhile (read_keyfile_line(f, filename, line, sizeof(line),\n\t\t    &linenum) != -1) {\n\t\tcp = line;\n\t\tswitch (*cp) {\n\t\tcase '#':\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcontinue;\n\t\t}\n\t\t/* Abort loading if this looks like a private key */\n\t\tif (strncmp(cp, \"-----BEGIN\", 10) == 0 ||\n\t\t    strcmp(cp, \"SSH PRIVATE KEY FILE\") == 0)\n\t\t\tbreak;\n\t\t/* Skip leading whitespace. */\n\t\tfor (; *cp && (*cp == ' ' || *cp == '\\t'); cp++)\n\t\t\t;\n\t\tif (*cp) {\n\t\t\tif ((r = sshkey_read(k, &cp)) == 0) {\n\t\t\t\tcp[strcspn(cp, \"\\r\\n\")] = '\\0';\n\t\t\t\tif (commentp) {\n\t\t\t\t\t*commentp = strdup(*cp ?\n\t\t\t\t\t    cp : filename);\n\t\t\t\t\tif (*commentp == NULL)\n\t\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn SSH_ERR_INVALID_FORMAT;\n}\n\n/* load public key from ssh v1 private or any pubkey file */\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar file[PATH_MAX];\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\t/* XXX should load file once and attempt to parse each format */\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\tgoto skip;\n#ifdef WITH_SSH1\n\t/* try rsa1 private key */\n\tr = sshkey_load_public_rsa1(fd, keyp, commentp);\n\tclose(fd);\n\tswitch (r) {\n\tcase SSH_ERR_INTERNAL_ERROR:\n\tcase SSH_ERR_ALLOC_FAIL:\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\tcase SSH_ERR_SYSTEM_ERROR:\n\tcase 0:\n\t\treturn r;\n\t}\n#else /* WITH_SSH1 */\n\tclose(fd);\n#endif /* WITH_SSH1 */\n\n\t/* try ssh2 public key */\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL)\n\t\t\t*keyp = pub;\n\t\treturn 0;\n\t}\n\tsshkey_free(pub);\n\n#ifdef WITH_SSH1\n\t/* try rsa1 public key */\n\tif ((pub = sshkey_new(KEY_RSA1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL)\n\t\t\t*keyp = pub;\n\t\treturn 0;\n\t}\n\tsshkey_free(pub);\n#endif /* WITH_SSH1 */\n\n skip:\n\t/* try .pub suffix */\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = SSH_ERR_ALLOC_FAIL;\t/* in case strlcpy or strlcat fail */\n\tif ((strlcpy(file, filename, sizeof file) < sizeof(file)) &&\n\t    (strlcat(file, \".pub\", sizeof file) < sizeof(file)) &&\n\t    (r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL)\n\t\t\t*keyp = pub;\n\t\treturn 0;\n\t}\n\tsshkey_free(pub);\n\n\treturn r;\n}\n\n/* Load the certificate associated with the named private key */\nint\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (keyp != NULL) {\n\t\t*keyp = pub;\n\t\tpub = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}\n\n/* Load private key and certificate */\nint\nsshkey_load_private_cert(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp, int *perm_ok)\n{\n\tstruct sshkey *key = NULL, *cert = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\n\tif ((r = sshkey_load_private_type(type, filename,\n\t    passphrase, &key, NULL, perm_ok)) != 0 ||\n\t    (r = sshkey_load_cert(filename, &cert)) != 0)\n\t\tgoto out;\n\n\t/* Make sure the private key matches the certificate */\n\tif (sshkey_equal_public(key, cert) == 0) {\n\t\tr = SSH_ERR_KEY_CERT_MISMATCH;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_certified(key)) != 0 ||\n\t    (r = sshkey_cert_copy(cert, key)) != 0)\n\t\tgoto out;\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshkey_free(key);\n\tsshkey_free(cert);\n\treturn r;\n}\n\n/*\n * Returns success if the specified \"key\" is listed in the file \"filename\",\n * SSH_ERR_KEY_NOT_FOUND: if the key is not listed or another error.\n * If \"strict_type\" is set then the key type must match exactly,\n * otherwise a comparison that ignores certficiate data is performed.\n * If \"check_ca\" is set and \"key\" is a certificate, then its CA key is\n * also checked and sshkey_in_file() will return success if either is found.\n */\nint\nsshkey_in_file(struct sshkey *key, const char *filename, int strict_type,\n    int check_ca)\n{\n\tFILE *f;\n\tchar line[SSH_MAX_PUBKEY_BYTES];\n\tchar *cp;\n\tu_long linenum = 0;\n\tint r = 0;\n\tstruct sshkey *pub = NULL;\n\tint (*sshkey_compare)(const struct sshkey *, const struct sshkey *) =\n\t    strict_type ?  sshkey_equal : sshkey_equal_public;\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\twhile (read_keyfile_line(f, filename, line, sizeof(line),\n\t    &linenum) != -1) {\n\t\tcp = line;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (; *cp && (*cp == ' ' || *cp == '\\t'); cp++)\n\t\t\t;\n\n\t\t/* Skip comments and empty lines */\n\t\tswitch (*cp) {\n\t\tcase '#':\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_read(pub, &cp)) != 0)\n\t\t\tgoto out;\n\t\tif (sshkey_compare(key, pub) ||\n\t\t    (check_ca && sshkey_is_cert(key) &&\n\t\t    sshkey_compare(key->cert->signature_key, pub))) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tsshkey_free(pub);\n\t\tpub = NULL;\n\t}\n\tr = SSH_ERR_KEY_NOT_FOUND;\n out:\n\tsshkey_free(pub);\n\tfclose(f);\n\treturn r;\n}\n\n/*\n * Checks whether the specified key is revoked, returning 0 if not,\n * SSH_ERR_KEY_REVOKED if it is or another error code if something\n * unexpected happened.\n * This will check both the key and, if it is a certificate, its CA key too.\n * \"revoked_keys_file\" may be a KRL or a one-per-line list of public keys.\n */\nint\nsshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file)\n{\n\tint r;\n\n\tr = ssh_krl_file_contains_key(revoked_keys_file, key);\n\t/* If this was not a KRL to begin with then continue below */\n\tif (r != SSH_ERR_KRL_BAD_MAGIC)\n\t\treturn r;\n\n\t/*\n\t * If the file is not a KRL or we can't handle KRLs then attempt to\n\t * parse the file as a flat list of keys.\n\t */\n\tswitch ((r = sshkey_in_file(key, revoked_keys_file, 0, 1))) {\n\tcase 0:\n\t\t/* Key found => revoked */\n\t\treturn SSH_ERR_KEY_REVOKED;\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\t/* Key not found => not revoked */\n\t\treturn 0;\n\tdefault:\n\t\t/* Some other error occurred */\n\t\treturn r;\n\t}\n}\n\n"], "fixing_code": ["/* $OpenBSD: authfile.c,v 1.122 2016/11/25 23:24:45 djm Exp $ */\n/*\n * Copyright (c) 2000, 2013 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"cipher.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"authfile.h\"\n#include \"rsa.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"krl.h\"\n\n#define MAX_KEY_FILE_SIZE\t(1024 * 1024)\n\n/* Save a key blob to a file */\nstatic int\nsshkey_save_private_blob(struct sshbuf *keybuf, const char *filename)\n{\n\tint fd, oerrno;\n\n\tif ((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (atomicio(vwrite, fd, (u_char *)sshbuf_ptr(keybuf),\n\t    sshbuf_len(keybuf)) != sshbuf_len(keybuf)) {\n\t\toerrno = errno;\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tclose(fd);\n\treturn 0;\n}\n\nint\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int force_new_format, const char *new_format_cipher, int new_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    force_new_format, new_format_cipher, new_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}\n\n/* Load a key from a fd into a buffer */\nint\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r, dontmax = 0;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t/*\n\t * Pre-allocate the buffer used for the key contents and clamp its\n\t * maximum size. This ensures that key contents are never leaked via\n\t * implicit realloc() in the sshbuf code.\n\t */\n\tif ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {\n\t\tst.st_size = 64*1024; /* 64k should be enough for anyone :) */\n\t\tdontmax = 1;\n\t}\n\tif ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||\n\t    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))\n\t\treturn r;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}\n\n#ifdef WITH_SSH1\n/*\n * Loads the public part of the ssh v1 key file.  Returns NULL if an error was\n * encountered (the file does not exist or is not readable), and the key\n * otherwise.\n */\nstatic int\nsshkey_load_public_rsa1(int fd, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *b = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_load_file(fd, b)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_parse_public_rsa1_fileblob(b, keyp, commentp)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n#endif /* WITH_SSH1 */\n\n/* XXX remove error() calls from here? */\nint\nsshkey_perm_ok(int fd, const char *filename)\n{\n\tstruct stat st;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t/*\n\t * if a key owned by the user is accessed, then we check the\n\t * permissions of the file. if the key owned by a different user,\n\t * then we don't care.\n\t */\n\tif ((st.st_uid == getuid()) && (st.st_mode & 077) != 0) {\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"Permissions 0%3.3o for '%s' are too open.\",\n\t\t    (u_int)st.st_mode & 0777, filename);\n\t\terror(\"It is required that your private key files are NOT accessible by others.\");\n\t\terror(\"This private key will be ignored.\");\n\t\treturn SSH_ERR_KEY_BAD_PERMISSIONS;\n\t}\n\treturn 0;\n}\n\n/* XXX kill perm_ok now that we have SSH_ERR_KEY_BAD_PERMISSIONS? */\nint\nsshkey_load_private_type(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp, int *perm_ok)\n{\n\tint fd, r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0) {\n\t\tif (perm_ok != NULL)\n\t\t\t*perm_ok = 0;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tif (perm_ok != NULL)\n\t\t\t*perm_ok = 0;\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\tif (perm_ok != NULL)\n\t\t*perm_ok = 1;\n\n\tr = sshkey_load_private_type_fd(fd, type, passphrase, keyp, commentp);\n out:\n\tclose(fd);\n\treturn r;\n}\n\nint\nsshkey_load_private_type_fd(int fd, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob_type(buffer, type,\n\t    passphrase, keyp, commentp)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(buffer);\n\treturn r;\n}\n\n/* XXX this is almost identical to sshkey_load_private_type() */\nint\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,\n\t    commentp)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\treturn r;\n}\n\nstatic int\nsshkey_try_load_public(struct sshkey *k, const char *filename, char **commentp)\n{\n\tFILE *f;\n\tchar line[SSH_MAX_PUBKEY_BYTES];\n\tchar *cp;\n\tu_long linenum = 0;\n\tint r;\n\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\twhile (read_keyfile_line(f, filename, line, sizeof(line),\n\t\t    &linenum) != -1) {\n\t\tcp = line;\n\t\tswitch (*cp) {\n\t\tcase '#':\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcontinue;\n\t\t}\n\t\t/* Abort loading if this looks like a private key */\n\t\tif (strncmp(cp, \"-----BEGIN\", 10) == 0 ||\n\t\t    strcmp(cp, \"SSH PRIVATE KEY FILE\") == 0)\n\t\t\tbreak;\n\t\t/* Skip leading whitespace. */\n\t\tfor (; *cp && (*cp == ' ' || *cp == '\\t'); cp++)\n\t\t\t;\n\t\tif (*cp) {\n\t\t\tif ((r = sshkey_read(k, &cp)) == 0) {\n\t\t\t\tcp[strcspn(cp, \"\\r\\n\")] = '\\0';\n\t\t\t\tif (commentp) {\n\t\t\t\t\t*commentp = strdup(*cp ?\n\t\t\t\t\t    cp : filename);\n\t\t\t\t\tif (*commentp == NULL)\n\t\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn SSH_ERR_INVALID_FORMAT;\n}\n\n/* load public key from ssh v1 private or any pubkey file */\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar file[PATH_MAX];\n\tint r, fd;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\t/* XXX should load file once and attempt to parse each format */\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t\tgoto skip;\n#ifdef WITH_SSH1\n\t/* try rsa1 private key */\n\tr = sshkey_load_public_rsa1(fd, keyp, commentp);\n\tclose(fd);\n\tswitch (r) {\n\tcase SSH_ERR_INTERNAL_ERROR:\n\tcase SSH_ERR_ALLOC_FAIL:\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\tcase SSH_ERR_SYSTEM_ERROR:\n\tcase 0:\n\t\treturn r;\n\t}\n#else /* WITH_SSH1 */\n\tclose(fd);\n#endif /* WITH_SSH1 */\n\n\t/* try ssh2 public key */\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL)\n\t\t\t*keyp = pub;\n\t\treturn 0;\n\t}\n\tsshkey_free(pub);\n\n#ifdef WITH_SSH1\n\t/* try rsa1 public key */\n\tif ((pub = sshkey_new(KEY_RSA1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL)\n\t\t\t*keyp = pub;\n\t\treturn 0;\n\t}\n\tsshkey_free(pub);\n#endif /* WITH_SSH1 */\n\n skip:\n\t/* try .pub suffix */\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = SSH_ERR_ALLOC_FAIL;\t/* in case strlcpy or strlcat fail */\n\tif ((strlcpy(file, filename, sizeof file) < sizeof(file)) &&\n\t    (strlcat(file, \".pub\", sizeof file) < sizeof(file)) &&\n\t    (r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL)\n\t\t\t*keyp = pub;\n\t\treturn 0;\n\t}\n\tsshkey_free(pub);\n\n\treturn r;\n}\n\n/* Load the certificate associated with the named private key */\nint\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (keyp != NULL) {\n\t\t*keyp = pub;\n\t\tpub = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}\n\n/* Load private key and certificate */\nint\nsshkey_load_private_cert(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp, int *perm_ok)\n{\n\tstruct sshkey *key = NULL, *cert = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\n\tif ((r = sshkey_load_private_type(type, filename,\n\t    passphrase, &key, NULL, perm_ok)) != 0 ||\n\t    (r = sshkey_load_cert(filename, &cert)) != 0)\n\t\tgoto out;\n\n\t/* Make sure the private key matches the certificate */\n\tif (sshkey_equal_public(key, cert) == 0) {\n\t\tr = SSH_ERR_KEY_CERT_MISMATCH;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_certified(key)) != 0 ||\n\t    (r = sshkey_cert_copy(cert, key)) != 0)\n\t\tgoto out;\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshkey_free(key);\n\tsshkey_free(cert);\n\treturn r;\n}\n\n/*\n * Returns success if the specified \"key\" is listed in the file \"filename\",\n * SSH_ERR_KEY_NOT_FOUND: if the key is not listed or another error.\n * If \"strict_type\" is set then the key type must match exactly,\n * otherwise a comparison that ignores certficiate data is performed.\n * If \"check_ca\" is set and \"key\" is a certificate, then its CA key is\n * also checked and sshkey_in_file() will return success if either is found.\n */\nint\nsshkey_in_file(struct sshkey *key, const char *filename, int strict_type,\n    int check_ca)\n{\n\tFILE *f;\n\tchar line[SSH_MAX_PUBKEY_BYTES];\n\tchar *cp;\n\tu_long linenum = 0;\n\tint r = 0;\n\tstruct sshkey *pub = NULL;\n\tint (*sshkey_compare)(const struct sshkey *, const struct sshkey *) =\n\t    strict_type ?  sshkey_equal : sshkey_equal_public;\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\twhile (read_keyfile_line(f, filename, line, sizeof(line),\n\t    &linenum) != -1) {\n\t\tcp = line;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (; *cp && (*cp == ' ' || *cp == '\\t'); cp++)\n\t\t\t;\n\n\t\t/* Skip comments and empty lines */\n\t\tswitch (*cp) {\n\t\tcase '#':\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_read(pub, &cp)) != 0)\n\t\t\tgoto out;\n\t\tif (sshkey_compare(key, pub) ||\n\t\t    (check_ca && sshkey_is_cert(key) &&\n\t\t    sshkey_compare(key->cert->signature_key, pub))) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tsshkey_free(pub);\n\t\tpub = NULL;\n\t}\n\tr = SSH_ERR_KEY_NOT_FOUND;\n out:\n\tsshkey_free(pub);\n\tfclose(f);\n\treturn r;\n}\n\n/*\n * Checks whether the specified key is revoked, returning 0 if not,\n * SSH_ERR_KEY_REVOKED if it is or another error code if something\n * unexpected happened.\n * This will check both the key and, if it is a certificate, its CA key too.\n * \"revoked_keys_file\" may be a KRL or a one-per-line list of public keys.\n */\nint\nsshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file)\n{\n\tint r;\n\n\tr = ssh_krl_file_contains_key(revoked_keys_file, key);\n\t/* If this was not a KRL to begin with then continue below */\n\tif (r != SSH_ERR_KRL_BAD_MAGIC)\n\t\treturn r;\n\n\t/*\n\t * If the file is not a KRL or we can't handle KRLs then attempt to\n\t * parse the file as a flat list of keys.\n\t */\n\tswitch ((r = sshkey_in_file(key, revoked_keys_file, 0, 1))) {\n\tcase 0:\n\t\t/* Key found => revoked */\n\t\treturn SSH_ERR_KEY_REVOKED;\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\t/* Key not found => not revoked */\n\t\treturn 0;\n\tdefault:\n\t\t/* Some other error occurred */\n\t\treturn r;\n\t}\n}\n\n"], "filenames": ["usr.bin/ssh/authfile.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [107], "fixing_code_start_loc": [1], "fixing_code_end_loc": [120], "type": "CWE-320", "message": "authfile.c in sshd in OpenSSH before 7.4 does not properly consider the effects of realloc on buffer contents, which might allow local users to obtain sensitive private-key information by leveraging access to a privilege-separated child process.", "other": {"cve": {"id": "CVE-2016-10011", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-05T02:59:03.120", "lastModified": "2022-12-13T12:15:20.083", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "authfile.c in sshd in OpenSSH before 7.4 does not properly consider the effects of realloc on buffer contents, which might allow local users to obtain sensitive private-key information by leveraging access to a privilege-separated child process."}, {"lang": "es", "value": "authfile.c en sshd en OpenSSH en versiones anteriores a 7.4 no considera apropiadamente los efectos de realloc en el contenido de b\u00fafer, lo que podr\u00eda permitir a usuarios locales obtener informaci\u00f3n sensible de clave privada aprovechando el acceso a un subproceso separado de privilegios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-320"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.3", "matchCriteriaId": "B5D52975-3CB0-4BF7-975F-66EF9BF42A06"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/12/19/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes"]}, {"url": "http://www.securityfocus.com/bid/94977", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1037490", "source": "cve@mitre.org"}, {"url": "http://www.slackware.com/security/viewer.php?l=slackware-security&y=2016&m=slackware-security.647637", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2029", "source": "cve@mitre.org"}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-412672.pdf", "source": "cve@mitre.org"}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-676336.pdf", "source": "cve@mitre.org"}, {"url": "https://github.com/openbsd/src/commit/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/09/msg00010.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20171130-0002/", "source": "cve@mitre.org"}, {"url": "https://support.hpe.com/hpsc/doc/public/display?docLocale=en_US&docId=emr_na-hpesbux03818en_us", "source": "cve@mitre.org"}, {"url": "https://www.openssh.com/txt/release-7.4", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/openbsd/src/commit/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9"}}