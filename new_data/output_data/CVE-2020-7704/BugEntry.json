{"buggy_code": ["function reducer(result, arg)\n{\n  arg = arg.split('=')\n\n  // Get key node\n  const keypath = arg.shift().split('.')\n\n  let key = keypath.shift()\n  let node = result\n\n  while(keypath.length)\n  {\n    node[key] = node[key] || {}\n    node = node[key]\n\n    key = keypath.shift()\n  }\n\n  // Get value\n  let val = true\n  if(arg.length)\n  {\n    val = arg.join('=').split(',')\n    if(val.length === 1) val = val[0]\n  }\n\n  // Store value\n  node[key] = val\n\n  return result\n}\n\n\n/**\n * This function takes the `cmdline` from `/proc/cmdline` **showed below in\n * the example** and splits it into key/value pairs\n * @access private\n * @param  {String} cmdline This string contains information about the\n *                          initrd and the root partition\n * @return {Object}         It returns a object containing key/value pairs\n *                          if there is no value for the key then its just true.\n *                          **For more Information, look at the example**\n * @example\n *   var cmdline1 = 'initrd=/initramfs-linux.img root=PARTUUID=someuuidhere\\n'\n *   var cmdline2 = 'somevar root=PARTUUID=someuuidhere\\n'\n *\n * \t var res1 = linuxCmdline(cmdline1)\n * \t var res2 = linuxCmdline(cmdline2)\n * \t console.log(res1)\n * \t //-> { initrd: '/initramfs-linux.img',root: 'PARTUUID=someuuidhere' }\n * \t console.log(res2)\n * \t //-> { somevar: true, root: 'PARTUUID=someuuidhere' }\n */\nfunction linuxCmdline(cmdline)\n{\n  return cmdline.trim().split(' ').reduce(reducer, {})\n}\n\n\nmodule.exports = linuxCmdline\n", "#!/usr/bin/env node\n\nconst {deepStrictEqual} = require('assert')\n\nconst linuxCmdline = require('.')\n\n\nconst cmdline = 'initrd=/init-lin.img root=UUID=uuid someflag a.b=c d.e f=g,h'\nconst expected =\n{\n  initrd: '/init-lin.img',\n  root: 'UUID=uuid',\n  someflag: true,\n  a: { b: 'c' },\n  d: { e: true },\n  f: [ 'g', 'h' ]\n}\n\nconst result = linuxCmdline(cmdline)\n\ndeepStrictEqual(result, expected)\n"], "fixing_code": ["function reducer(result, arg)\n{\n  arg = arg.split('=')\n\n  // Get key node\n  const keypath = arg.shift().split('.')\n\n  // Get value\n  let val = true\n  if(arg.length)\n  {\n    val = arg.join('=').split(',')\n    if(val.length === 1) val = val[0]\n  }\n\n  let key = keypath.shift()\n\n  if(!keypath.length) return {...result, [key]: val}\n\n  if(!result.hasOwnProperty(key)) result = {...result, [key]: {}}\n\n  let newKey\n  let newNode\n  let node = result\n\n  while(true)\n  {\n    newKey = keypath.shift()\n    newNode = node[key]\n\n    if(!keypath.length) break\n\n    node = node[key] = {...newNode, [newKey]: newNode[newKey] || {}}\n    key = newKey\n  }\n\n  // Store value\n  node[key] = {...newNode, [newKey]: val}\n\n  return result\n}\n\n\n/**\n * This function takes the `cmdline` from `/proc/cmdline` **showed below in\n * the example** and splits it into key/value pairs\n * @access private\n * @param  {String} cmdline This string contains information about the\n *                          initrd and the root partition\n * @return {Object}         It returns a object containing key/value pairs\n *                          if there is no value for the key then its just true.\n *                          **For more Information, look at the example**\n * @example\n *   var cmdline1 = 'initrd=/initramfs-linux.img root=PARTUUID=someuuidhere\\n'\n *   var cmdline2 = 'somevar root=PARTUUID=someuuidhere\\n'\n *\n * \t var res1 = linuxCmdline(cmdline1)\n * \t var res2 = linuxCmdline(cmdline2)\n * \t console.log(res1)\n * \t //-> { initrd: '/initramfs-linux.img',root: 'PARTUUID=someuuidhere' }\n * \t console.log(res2)\n * \t //-> { somevar: true, root: 'PARTUUID=someuuidhere' }\n */\nfunction linuxCmdline(cmdline)\n{\n  return cmdline.trim().split(' ').reduce(reducer, {})\n}\n\n\nmodule.exports = linuxCmdline\n", "#!/usr/bin/env node\n\nconst {deepStrictEqual} = require('assert')\n\nconst linuxCmdline = require('.')\n\n\nconst cmdline = 'initrd=/init-lin.img root=UUID=uuid someflag a.b=c d.e f=g,h'\nconst expected =\n{\n  initrd: '/init-lin.img',\n  root: 'UUID=uuid',\n  someflag: true,\n  a: { b: 'c' },\n  d: { e: true },\n  f: [ 'g', 'h' ]\n}\n\nconst result = linuxCmdline(cmdline)\n\ndeepStrictEqual(result, expected)\n\n\n// Don't pollute prototype\nconst result2 = linuxCmdline('__proto__.polluted=foo')\nconst expected2 =\n{\n  ['__proto__']:\n  {\n    polluted: 'foo'\n  }\n}\n\ndeepStrictEqual(result2, expected2)\n\ndeepStrictEqual({}.__proto__.polluted, undefined)\n"], "filenames": ["index.js", "test.js"], "buggy_code_start_loc": [7, 21], "buggy_code_end_loc": [29, 21], "fixing_code_start_loc": [6, 22], "fixing_code_end_loc": [39, 37], "type": "CWE-1321", "message": "The package linux-cmdline before 1.0.1 are vulnerable to Prototype Pollution via the constructor.", "other": {"cve": {"id": "CVE-2020-7704", "sourceIdentifier": "report@snyk.io", "published": "2020-08-17T17:15:14.097", "lastModified": "2022-12-02T19:56:33.063", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package linux-cmdline before 1.0.1 are vulnerable to Prototype Pollution via the constructor."}, {"lang": "es", "value": "El paquete linux-cmdline versiones anteriores a 1.0.1, es vulnerable a un ataque de Contaminaci\u00f3n de Prototipo por medio del constructor."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linux-cmdline_project:linux-cmdline:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1", "matchCriteriaId": "EF39E750-7D21-4E05-83E4-B3E96FED7F21"}]}]}], "references": [{"url": "https://github.com/piranna/linux-cmdline/commit/53c61a88bc47eb25d71832205056beaab95cf677", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/piranna/linux-cmdline/commit/53c61a88bc47eb25d71832205056beaab95cf677"}}