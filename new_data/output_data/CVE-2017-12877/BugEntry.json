{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                  M   M   AAA   TTTTT  L       AAA   BBBB                    %\n%                  MM MM  A   A    T    L      A   A  B   B                   %\n%                  M M M  AAAAA    T    L      AAAAA  BBBB                    %\n%                  M   M  A   A    T    L      A   A  B   B                   %\n%                  M   M  A   A    T    LLLLL  A   A  BBBB                    %\n%                                                                             %\n%                                                                             %\n%                        Read MATLAB Image Format                             %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                2001-2008                                    %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n #include \"zlib.h\"\n#endif\n\f\n/*\n  Forward declaration.\n*/\nstatic MagickBooleanType\n  WriteMATImage(const ImageInfo *,Image *,ExceptionInfo *);\n\n\n/* Auto coloring method, sorry this creates some artefact inside data\nMinReal+j*MaxComplex = red  MaxReal+j*MaxComplex = black\nMinReal+j*0 = white          MaxReal+j*0 = black\nMinReal+j*MinComplex = blue  MaxReal+j*MinComplex = black\n*/\n\ntypedef struct\n{\n  char identific[124];\n  unsigned short Version;\n  char EndianIndicator[2];\n  unsigned long DataType;\n  unsigned int ObjectSize;\n  unsigned long unknown1;\n  unsigned long unknown2;\n\n  unsigned short unknown5;\n  unsigned char StructureFlag;\n  unsigned char StructureClass;\n  unsigned long unknown3;\n  unsigned long unknown4;\n  unsigned long DimFlag;\n\n  unsigned long SizeX;\n  unsigned long SizeY;\n  unsigned short Flag1;\n  unsigned short NameFlag;\n}\nMATHeader;\n\nstatic const char *MonthsTab[12]={\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nstatic const char *DayOfWTab[7]={\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"};\nstatic const char *OsDesc=\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    \"PCWIN\";\n#else\n #ifdef __APPLE__\n    \"MAC\";\n #else\n    \"LNX86\";\n #endif\n#endif\n\ntypedef enum\n  {\n    miINT8 = 1,      /* 8 bit signed */\n    miUINT8,      /* 8 bit unsigned */\n    miINT16,      /* 16 bit signed */\n    miUINT16,      /* 16 bit unsigned */\n    miINT32,      /* 32 bit signed */\n    miUINT32,      /* 32 bit unsigned */\n    miSINGLE,      /* IEEE 754 single precision float */\n    miRESERVE1,\n    miDOUBLE,      /* IEEE 754 double precision float */\n    miRESERVE2,\n    miRESERVE3,\n    miINT64,      /* 64 bit signed */\n    miUINT64,      /* 64 bit unsigned */\n    miMATRIX,            /* MATLAB array */\n    miCOMPRESSED,          /* Compressed Data */\n    miUTF8,            /* Unicode UTF-8 Encoded Character Data */\n    miUTF16,            /* Unicode UTF-16 Encoded Character Data */\n    miUTF32      /* Unicode UTF-32 Encoded Character Data */\n  } mat5_data_type;\n\ntypedef enum\n  {\n    mxCELL_CLASS=1,    /* cell array */\n    mxSTRUCT_CLASS,    /* structure */\n    mxOBJECT_CLASS,    /* object */\n    mxCHAR_CLASS,    /* character array */\n    mxSPARSE_CLASS,    /* sparse array */\n    mxDOUBLE_CLASS,    /* double precision array */\n    mxSINGLE_CLASS,    /* single precision floating point */\n    mxINT8_CLASS,    /* 8 bit signed integer */\n    mxUINT8_CLASS,    /* 8 bit unsigned integer */\n    mxINT16_CLASS,    /* 16 bit signed integer */\n    mxUINT16_CLASS,    /* 16 bit unsigned integer */\n    mxINT32_CLASS,    /* 32 bit signed integer */\n    mxUINT32_CLASS,    /* 32 bit unsigned integer */\n    mxINT64_CLASS,    /* 64 bit signed integer */\n    mxUINT64_CLASS,    /* 64 bit unsigned integer */\n    mxFUNCTION_CLASS            /* Function handle */\n  } arrayclasstype;\n\n#define FLAG_COMPLEX 0x8\n#define FLAG_GLOBAL  0x4\n#define FLAG_LOGICAL 0x2\n\nstatic const QuantumType z2qtype[4] = {GrayQuantum, BlueQuantum, GreenQuantum, RedQuantum};\n\n\nstatic void InsertComplexDoubleRow(Image *image,double *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f + GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelBlue(image,q));\n      if (f+GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelRed(image,0,q);\n          SetPixelGreen(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q+=GetPixelChannels(image);\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\nstatic void InsertComplexFloatRow(Image *image,float *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q = QueueAuthenticPixels(image, 0, y, image->columns, 1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f+GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange - GetPixelBlue(image,q));\n      if (f + GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+\n          (int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelRed(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q++;\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\n/************** READERS ******************/\n\n/* This function reads one block of floats*/\nstatic void ReadBlobFloatsLSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobFloatsMSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* This function reads one block of doubles*/\nstatic void ReadBlobDoublesLSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobDoublesMSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* Calculate minimum and maximum from a given block of data */\nstatic void CalcMinMax(Image *image, int endian_indicator, int SizeX, int SizeY, size_t CellType, unsigned ldblk, void *BImgBuff, double *Min, double *Max)\n{\nMagickOffsetType filepos;\nint i, x;\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\ndouble *dblrow;\nfloat *fltrow;\n\n  if (endian_indicator == LSBEndian)\n  {\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n  }\n  else    /* MI */\n  {\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n  }\n\n  filepos = TellBlob(image);     /* Please note that file seeking occurs only in the case of doubles */\n  for (i = 0; i < SizeY; i++)\n  {\n    if (CellType==miDOUBLE)\n    {\n      ReadBlobDoublesXXX(image, ldblk, (double *)BImgBuff);\n      dblrow = (double *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *dblrow;\n      }\n      for (x = 0; x < SizeX; x++)\n      {\n        if (*Min > *dblrow)\n          *Min = *dblrow;\n        if (*Max < *dblrow)\n          *Max = *dblrow;\n        dblrow++;\n      }\n    }\n    if (CellType==miSINGLE)\n    {\n      ReadBlobFloatsXXX(image, ldblk, (float *)BImgBuff);\n      fltrow = (float *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *fltrow;\n      }\n    for (x = 0; x < (ssize_t) SizeX; x++)\n      {\n        if (*Min > *fltrow)\n          *Min = *fltrow;\n        if (*Max < *fltrow)\n          *Max = *fltrow;\n        fltrow++;\n      }\n    }\n  }\n  (void) SeekBlob(image, filepos, SEEK_SET);\n}\n\n\nstatic void FixSignedValues(const Image *image,Quantum *q, int y)\n{\n  while(y-->0)\n  {\n     /* Please note that negative values will overflow\n        Q=8; QuantumRange=255: <0;127> + 127+1 = <128; 255>\n           <-1;-128> + 127+1 = <0; 127> */\n    SetPixelRed(image,GetPixelRed(image,q)+QuantumRange/2+1,q);\n    SetPixelGreen(image,GetPixelGreen(image,q)+QuantumRange/2+1,q);\n    SetPixelBlue(image,GetPixelBlue(image,q)+QuantumRange/2+1,q);\n    q++;\n  }\n}\n\n\n/** Fix whole row of logical/binary data. It means pack it. */\nstatic void FixLogical(unsigned char *Buff,int ldblk)\n{\nunsigned char mask=128;\nunsigned char *BuffL = Buff;\nunsigned char val = 0;\n\n  while(ldblk-->0)\n  {\n    if(*Buff++ != 0)\n      val |= mask;\n\n    mask >>= 1;\n    if(mask==0)\n    {\n      *BuffL++ = val;\n      val = 0;\n      mask = 128;\n    }\n\n  }\n  *BuffL = val;\n}\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nstatic voidpf AcquireZIPMemory(voidpf context,unsigned int items,\n  unsigned int size)\n{\n  (void) context;\n  return((voidpf) AcquireQuantumMemory(items,size));\n}\n\nstatic void RelinquishZIPMemory(voidpf context,voidpf memory)\n{\n  (void) context;\n  memory=RelinquishMagickMemory(memory);\n}\n#endif\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n/** This procedure decompreses an image block for a new MATLAB format. */\nstatic Image *decompress_block(Image *orig, unsigned int *Size, ImageInfo *clone_info, ExceptionInfo *exception)\n{\n\nImage *image2;\nvoid *cache_block, *decompress_block;\nz_stream zip_info;\nFILE *mat_file;\nsize_t magick_size;\nsize_t extent;\nint file;\n\nint status;\nint zip_status;\nssize_t TotalSize = 0;\n\n  if(clone_info==NULL) return NULL;\n  if(clone_info->file)    /* Close file opened from previous transaction. */\n  {\n    fclose(clone_info->file);\n    clone_info->file = NULL;\n    (void) remove_utf8(clone_info->filename);\n  }\n\n  cache_block = AcquireQuantumMemory((size_t)(*Size < 16384) ? *Size: 16384,sizeof(unsigned char *));\n  if(cache_block==NULL) return NULL;\n  decompress_block = AcquireQuantumMemory((size_t)(4096),sizeof(unsigned char *));\n  if(decompress_block==NULL)\n  {\n    RelinquishMagickMemory(cache_block);\n    return NULL;\n  }\n\n  mat_file=0;\n  file = AcquireUniqueFileResource(clone_info->filename);\n  if (file != -1)\n    mat_file = fdopen(file,\"w\");\n  if(!mat_file)\n  {\n    RelinquishMagickMemory(cache_block);\n    RelinquishMagickMemory(decompress_block);\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Cannot create file stream for decompressed image\");\n    return NULL;\n  }\n\n  zip_info.zalloc=AcquireZIPMemory;\n  zip_info.zfree=RelinquishZIPMemory;\n  zip_info.opaque = (voidpf) NULL;\n  zip_status = inflateInit(&zip_info);\n  if (zip_status != Z_OK)\n    {\n      RelinquishMagickMemory(cache_block);\n      RelinquishMagickMemory(decompress_block);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnableToUncompressImage\",\"`%s'\",clone_info->filename);\n      (void) fclose(mat_file);\n      RelinquishUniqueFileResource(clone_info->filename);\n      return NULL;\n    }\n  /* zip_info.next_out = 8*4;*/\n\n  zip_info.avail_in = 0;\n  zip_info.total_out = 0;\n  while(*Size>0 && !EOFBlob(orig))\n  {\n    magick_size = ReadBlob(orig, (*Size < 16384) ? *Size : 16384, (unsigned char *) cache_block);\n    zip_info.next_in = (Bytef *) cache_block;\n    zip_info.avail_in = (uInt) magick_size;\n\n    while(zip_info.avail_in>0)\n    {\n      zip_info.avail_out = 4096;\n      zip_info.next_out = (Bytef *) decompress_block;\n      zip_status = inflate(&zip_info,Z_NO_FLUSH);\n      if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n        break;\n      extent=fwrite(decompress_block, 4096-zip_info.avail_out, 1, mat_file);\n      (void) extent;\n      TotalSize += 4096-zip_info.avail_out;\n\n      if(zip_status == Z_STREAM_END) goto DblBreak;\n    }\n    if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n      break;\n\n    *Size -= magick_size;\n  }\nDblBreak:\n\n  inflateEnd(&zip_info);\n  (void)fclose(mat_file);\n  RelinquishMagickMemory(cache_block);\n  RelinquishMagickMemory(decompress_block);\n  *Size = TotalSize;\n\n  if((clone_info->file=fopen(clone_info->filename,\"rb\"))==NULL) goto UnlinkFile;\n  if( (image2 = AcquireImage(clone_info,exception))==NULL ) goto EraseFile;\n  status = OpenBlob(clone_info,image2,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    DeleteImageFromList(&image2);\nEraseFile:\n    fclose(clone_info->file);\n    clone_info->file = NULL;\nUnlinkFile:\n    RelinquishUniqueFileResource(clone_info->filename);\n    return NULL;\n  }\n\n  return image2;\n}\n#endif\n\nstatic Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return((Image *) NULL);\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    SetImageColorspace(image,GRAYColorspace,exception);\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return((Image *) NULL);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return((Image *) NULL);\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M A T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterMATImage adds attributes for the MAT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMATImage method is:\n%\n%      size_t RegisterMATImage(void)\n%\n*/\nModuleExport size_t RegisterMATImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MAT\",\"MAT\",\"MATLAB level 5 image format\");\n  entry->decoder=(DecodeImageHandler *) ReadMATImage;\n  entry->encoder=(EncodeImageHandler *) WriteMATImage;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M A T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterMATImage removes format registrations made by the\n%  MAT module from the list of supported formats.\n%\n%  The format of the UnregisterMATImage method is:\n%\n%      UnregisterMATImage(void)\n%\n*/\nModuleExport void UnregisterMATImage(void)\n{\n  (void) UnregisterMagickInfo(\"MAT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M A T L A B I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Function WriteMATImage writes an Matlab matrix to a file.\n%\n%  The format of the WriteMATImage method is:\n%\n%      MagickBooleanType WriteMATImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o image:  A pointer to an Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMATImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    MATLAB_HDR[0x80];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  struct tm\n    local_time;\n\n  time_t\n    current_time;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"enter MAT\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->depth=8;\n\n  current_time=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&current_time,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&current_time),sizeof(local_time));\n#endif\n  (void) memset(MATLAB_HDR,' ',MagickMin(sizeof(MATLAB_HDR),124));\n  FormatLocaleString(MATLAB_HDR,sizeof(MATLAB_HDR),\n    \"MATLAB 5.0 MAT-file, Platform: %s, Created on: %s %s %2d %2d:%2d:%2d %d\",\n    OsDesc,DayOfWTab[local_time.tm_wday],MonthsTab[local_time.tm_mon],\n    local_time.tm_mday,local_time.tm_hour,local_time.tm_min,\n    local_time.tm_sec,local_time.tm_year+1900);\n  MATLAB_HDR[0x7C]=0;\n  MATLAB_HDR[0x7D]=1;\n  MATLAB_HDR[0x7E]='I';\n  MATLAB_HDR[0x7F]='M';\n  (void) WriteBlob(image,sizeof(MATLAB_HDR),(unsigned char *) MATLAB_HDR);\n  scene=0;\n  do\n  {\n    char\n      padding;\n\n    MagickBooleanType\n      is_gray;\n\n    QuantumInfo\n      *quantum_info;\n\n    size_t\n      data_size;\n\n    unsigned char\n      *pixels;\n\n    unsigned int\n      z;\n\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    is_gray=SetImageGray(image,exception);\n    z=(is_gray != MagickFalse) ? 0 : 3;\n\n    /*\n      Store MAT header.\n    */\n    data_size = image->rows * image->columns;\n    if (is_gray == MagickFalse)\n      data_size*=3;\n    padding=((unsigned char)(data_size-1) & 0x7) ^ 0x7;\n\n    (void) WriteBlobLSBLong(image,miMATRIX);\n    (void) WriteBlobLSBLong(image,(unsigned int) data_size+padding+\n      ((is_gray != MagickFalse) ? 48 : 56));\n    (void) WriteBlobLSBLong(image,0x6); /* 0x88 */\n    (void) WriteBlobLSBLong(image,0x8); /* 0x8C */\n    (void) WriteBlobLSBLong(image,0x6); /* 0x90 */\n    (void) WriteBlobLSBLong(image,0);\n    (void) WriteBlobLSBLong(image,0x5); /* 0x98 */\n    (void) WriteBlobLSBLong(image,(is_gray != MagickFalse) ? 0x8 : 0xC); /* 0x9C - DimFlag */\n    (void) WriteBlobLSBLong(image,(unsigned int) image->rows);    /* x: 0xA0 */\n    (void) WriteBlobLSBLong(image,(unsigned int) image->columns); /* y: 0xA4 */\n    if (is_gray == MagickFalse)\n      {\n        (void) WriteBlobLSBLong(image,3); /* z: 0xA8 */\n        (void) WriteBlobLSBLong(image,0);\n      }\n    (void) WriteBlobLSBShort(image,1);  /* 0xB0 */\n    (void) WriteBlobLSBShort(image,1);  /* 0xB2 */\n    (void) WriteBlobLSBLong(image,'M'); /* 0xB4 */\n    (void) WriteBlobLSBLong(image,0x2); /* 0xB8 */\n    (void) WriteBlobLSBLong(image,(unsigned int) data_size); /* 0xBC */\n\n    /*\n      Store image data.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    do\n    {\n      const Quantum\n        *p;\n\n      ssize_t\n        y;\n\n      for (y=0; y < (ssize_t)image->columns; y++)\n      {\n        p=GetVirtualPixels(image,y,0,1,image->rows,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          z2qtype[z],pixels,exception);\n        (void) WriteBlob(image,image->rows,pixels);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    } while (z-- >= 2);\n    while (padding-- > 0)\n      (void) WriteBlobByte(image,0);\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                  M   M   AAA   TTTTT  L       AAA   BBBB                    %\n%                  MM MM  A   A    T    L      A   A  B   B                   %\n%                  M M M  AAAAA    T    L      AAAAA  BBBB                    %\n%                  M   M  A   A    T    L      A   A  B   B                   %\n%                  M   M  A   A    T    LLLLL  A   A  BBBB                    %\n%                                                                             %\n%                                                                             %\n%                        Read MATLAB Image Format                             %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                2001-2008                                    %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n #include \"zlib.h\"\n#endif\n\f\n/*\n  Forward declaration.\n*/\nstatic MagickBooleanType\n  WriteMATImage(const ImageInfo *,Image *,ExceptionInfo *);\n\n\n/* Auto coloring method, sorry this creates some artefact inside data\nMinReal+j*MaxComplex = red  MaxReal+j*MaxComplex = black\nMinReal+j*0 = white          MaxReal+j*0 = black\nMinReal+j*MinComplex = blue  MaxReal+j*MinComplex = black\n*/\n\ntypedef struct\n{\n  char identific[124];\n  unsigned short Version;\n  char EndianIndicator[2];\n  unsigned long DataType;\n  unsigned int ObjectSize;\n  unsigned long unknown1;\n  unsigned long unknown2;\n\n  unsigned short unknown5;\n  unsigned char StructureFlag;\n  unsigned char StructureClass;\n  unsigned long unknown3;\n  unsigned long unknown4;\n  unsigned long DimFlag;\n\n  unsigned long SizeX;\n  unsigned long SizeY;\n  unsigned short Flag1;\n  unsigned short NameFlag;\n}\nMATHeader;\n\nstatic const char *MonthsTab[12]={\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nstatic const char *DayOfWTab[7]={\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"};\nstatic const char *OsDesc=\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    \"PCWIN\";\n#else\n #ifdef __APPLE__\n    \"MAC\";\n #else\n    \"LNX86\";\n #endif\n#endif\n\ntypedef enum\n  {\n    miINT8 = 1,      /* 8 bit signed */\n    miUINT8,      /* 8 bit unsigned */\n    miINT16,      /* 16 bit signed */\n    miUINT16,      /* 16 bit unsigned */\n    miINT32,      /* 32 bit signed */\n    miUINT32,      /* 32 bit unsigned */\n    miSINGLE,      /* IEEE 754 single precision float */\n    miRESERVE1,\n    miDOUBLE,      /* IEEE 754 double precision float */\n    miRESERVE2,\n    miRESERVE3,\n    miINT64,      /* 64 bit signed */\n    miUINT64,      /* 64 bit unsigned */\n    miMATRIX,            /* MATLAB array */\n    miCOMPRESSED,          /* Compressed Data */\n    miUTF8,            /* Unicode UTF-8 Encoded Character Data */\n    miUTF16,            /* Unicode UTF-16 Encoded Character Data */\n    miUTF32      /* Unicode UTF-32 Encoded Character Data */\n  } mat5_data_type;\n\ntypedef enum\n  {\n    mxCELL_CLASS=1,    /* cell array */\n    mxSTRUCT_CLASS,    /* structure */\n    mxOBJECT_CLASS,    /* object */\n    mxCHAR_CLASS,    /* character array */\n    mxSPARSE_CLASS,    /* sparse array */\n    mxDOUBLE_CLASS,    /* double precision array */\n    mxSINGLE_CLASS,    /* single precision floating point */\n    mxINT8_CLASS,    /* 8 bit signed integer */\n    mxUINT8_CLASS,    /* 8 bit unsigned integer */\n    mxINT16_CLASS,    /* 16 bit signed integer */\n    mxUINT16_CLASS,    /* 16 bit unsigned integer */\n    mxINT32_CLASS,    /* 32 bit signed integer */\n    mxUINT32_CLASS,    /* 32 bit unsigned integer */\n    mxINT64_CLASS,    /* 64 bit signed integer */\n    mxUINT64_CLASS,    /* 64 bit unsigned integer */\n    mxFUNCTION_CLASS            /* Function handle */\n  } arrayclasstype;\n\n#define FLAG_COMPLEX 0x8\n#define FLAG_GLOBAL  0x4\n#define FLAG_LOGICAL 0x2\n\nstatic const QuantumType z2qtype[4] = {GrayQuantum, BlueQuantum, GreenQuantum, RedQuantum};\n\n\nstatic void InsertComplexDoubleRow(Image *image,double *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f + GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelBlue(image,q));\n      if (f+GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelRed(image,0,q);\n          SetPixelGreen(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q+=GetPixelChannels(image);\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\nstatic void InsertComplexFloatRow(Image *image,float *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q = QueueAuthenticPixels(image, 0, y, image->columns, 1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f+GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange - GetPixelBlue(image,q));\n      if (f + GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+\n          (int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelRed(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q++;\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\n/************** READERS ******************/\n\n/* This function reads one block of floats*/\nstatic void ReadBlobFloatsLSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobFloatsMSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* This function reads one block of doubles*/\nstatic void ReadBlobDoublesLSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobDoublesMSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* Calculate minimum and maximum from a given block of data */\nstatic void CalcMinMax(Image *image, int endian_indicator, int SizeX, int SizeY, size_t CellType, unsigned ldblk, void *BImgBuff, double *Min, double *Max)\n{\nMagickOffsetType filepos;\nint i, x;\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\ndouble *dblrow;\nfloat *fltrow;\n\n  if (endian_indicator == LSBEndian)\n  {\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n  }\n  else    /* MI */\n  {\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n  }\n\n  filepos = TellBlob(image);     /* Please note that file seeking occurs only in the case of doubles */\n  for (i = 0; i < SizeY; i++)\n  {\n    if (CellType==miDOUBLE)\n    {\n      ReadBlobDoublesXXX(image, ldblk, (double *)BImgBuff);\n      dblrow = (double *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *dblrow;\n      }\n      for (x = 0; x < SizeX; x++)\n      {\n        if (*Min > *dblrow)\n          *Min = *dblrow;\n        if (*Max < *dblrow)\n          *Max = *dblrow;\n        dblrow++;\n      }\n    }\n    if (CellType==miSINGLE)\n    {\n      ReadBlobFloatsXXX(image, ldblk, (float *)BImgBuff);\n      fltrow = (float *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *fltrow;\n      }\n    for (x = 0; x < (ssize_t) SizeX; x++)\n      {\n        if (*Min > *fltrow)\n          *Min = *fltrow;\n        if (*Max < *fltrow)\n          *Max = *fltrow;\n        fltrow++;\n      }\n    }\n  }\n  (void) SeekBlob(image, filepos, SEEK_SET);\n}\n\n\nstatic void FixSignedValues(const Image *image,Quantum *q, int y)\n{\n  while(y-->0)\n  {\n     /* Please note that negative values will overflow\n        Q=8; QuantumRange=255: <0;127> + 127+1 = <128; 255>\n           <-1;-128> + 127+1 = <0; 127> */\n    SetPixelRed(image,GetPixelRed(image,q)+QuantumRange/2+1,q);\n    SetPixelGreen(image,GetPixelGreen(image,q)+QuantumRange/2+1,q);\n    SetPixelBlue(image,GetPixelBlue(image,q)+QuantumRange/2+1,q);\n    q++;\n  }\n}\n\n\n/** Fix whole row of logical/binary data. It means pack it. */\nstatic void FixLogical(unsigned char *Buff,int ldblk)\n{\nunsigned char mask=128;\nunsigned char *BuffL = Buff;\nunsigned char val = 0;\n\n  while(ldblk-->0)\n  {\n    if(*Buff++ != 0)\n      val |= mask;\n\n    mask >>= 1;\n    if(mask==0)\n    {\n      *BuffL++ = val;\n      val = 0;\n      mask = 128;\n    }\n\n  }\n  *BuffL = val;\n}\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nstatic voidpf AcquireZIPMemory(voidpf context,unsigned int items,\n  unsigned int size)\n{\n  (void) context;\n  return((voidpf) AcquireQuantumMemory(items,size));\n}\n\nstatic void RelinquishZIPMemory(voidpf context,voidpf memory)\n{\n  (void) context;\n  memory=RelinquishMagickMemory(memory);\n}\n#endif\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n/** This procedure decompreses an image block for a new MATLAB format. */\nstatic Image *decompress_block(Image *orig, unsigned int *Size, ImageInfo *clone_info, ExceptionInfo *exception)\n{\n\nImage *image2;\nvoid *cache_block, *decompress_block;\nz_stream zip_info;\nFILE *mat_file;\nsize_t magick_size;\nsize_t extent;\nint file;\n\nint status;\nint zip_status;\nssize_t TotalSize = 0;\n\n  if(clone_info==NULL) return NULL;\n  if(clone_info->file)    /* Close file opened from previous transaction. */\n  {\n    fclose(clone_info->file);\n    clone_info->file = NULL;\n    (void) remove_utf8(clone_info->filename);\n  }\n\n  cache_block = AcquireQuantumMemory((size_t)(*Size < 16384) ? *Size: 16384,sizeof(unsigned char *));\n  if(cache_block==NULL) return NULL;\n  decompress_block = AcquireQuantumMemory((size_t)(4096),sizeof(unsigned char *));\n  if(decompress_block==NULL)\n  {\n    RelinquishMagickMemory(cache_block);\n    return NULL;\n  }\n\n  mat_file=0;\n  file = AcquireUniqueFileResource(clone_info->filename);\n  if (file != -1)\n    mat_file = fdopen(file,\"w\");\n  if(!mat_file)\n  {\n    RelinquishMagickMemory(cache_block);\n    RelinquishMagickMemory(decompress_block);\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Cannot create file stream for decompressed image\");\n    return NULL;\n  }\n\n  zip_info.zalloc=AcquireZIPMemory;\n  zip_info.zfree=RelinquishZIPMemory;\n  zip_info.opaque = (voidpf) NULL;\n  zip_status = inflateInit(&zip_info);\n  if (zip_status != Z_OK)\n    {\n      RelinquishMagickMemory(cache_block);\n      RelinquishMagickMemory(decompress_block);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnableToUncompressImage\",\"`%s'\",clone_info->filename);\n      (void) fclose(mat_file);\n      RelinquishUniqueFileResource(clone_info->filename);\n      return NULL;\n    }\n  /* zip_info.next_out = 8*4;*/\n\n  zip_info.avail_in = 0;\n  zip_info.total_out = 0;\n  while(*Size>0 && !EOFBlob(orig))\n  {\n    magick_size = ReadBlob(orig, (*Size < 16384) ? *Size : 16384, (unsigned char *) cache_block);\n    zip_info.next_in = (Bytef *) cache_block;\n    zip_info.avail_in = (uInt) magick_size;\n\n    while(zip_info.avail_in>0)\n    {\n      zip_info.avail_out = 4096;\n      zip_info.next_out = (Bytef *) decompress_block;\n      zip_status = inflate(&zip_info,Z_NO_FLUSH);\n      if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n        break;\n      extent=fwrite(decompress_block, 4096-zip_info.avail_out, 1, mat_file);\n      (void) extent;\n      TotalSize += 4096-zip_info.avail_out;\n\n      if(zip_status == Z_STREAM_END) goto DblBreak;\n    }\n    if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n      break;\n\n    *Size -= magick_size;\n  }\nDblBreak:\n\n  inflateEnd(&zip_info);\n  (void)fclose(mat_file);\n  RelinquishMagickMemory(cache_block);\n  RelinquishMagickMemory(decompress_block);\n  *Size = TotalSize;\n\n  if((clone_info->file=fopen(clone_info->filename,\"rb\"))==NULL) goto UnlinkFile;\n  if( (image2 = AcquireImage(clone_info,exception))==NULL ) goto EraseFile;\n  status = OpenBlob(clone_info,image2,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    DeleteImageFromList(&image2);\nEraseFile:\n    fclose(clone_info->file);\n    clone_info->file = NULL;\nUnlinkFile:\n    RelinquishUniqueFileResource(clone_info->filename);\n    return NULL;\n  }\n\n  return image2;\n}\n#endif\n\nstatic Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return((Image *) NULL);\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    SetImageColorspace(image,GRAYColorspace,exception);\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return((Image *) NULL);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return((Image *) NULL);\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M A T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterMATImage adds attributes for the MAT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMATImage method is:\n%\n%      size_t RegisterMATImage(void)\n%\n*/\nModuleExport size_t RegisterMATImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MAT\",\"MAT\",\"MATLAB level 5 image format\");\n  entry->decoder=(DecodeImageHandler *) ReadMATImage;\n  entry->encoder=(EncodeImageHandler *) WriteMATImage;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M A T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterMATImage removes format registrations made by the\n%  MAT module from the list of supported formats.\n%\n%  The format of the UnregisterMATImage method is:\n%\n%      UnregisterMATImage(void)\n%\n*/\nModuleExport void UnregisterMATImage(void)\n{\n  (void) UnregisterMagickInfo(\"MAT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M A T L A B I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Function WriteMATImage writes an Matlab matrix to a file.\n%\n%  The format of the WriteMATImage method is:\n%\n%      MagickBooleanType WriteMATImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o image:  A pointer to an Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMATImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    MATLAB_HDR[0x80];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  struct tm\n    local_time;\n\n  time_t\n    current_time;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"enter MAT\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->depth=8;\n\n  current_time=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&current_time,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&current_time),sizeof(local_time));\n#endif\n  (void) memset(MATLAB_HDR,' ',MagickMin(sizeof(MATLAB_HDR),124));\n  FormatLocaleString(MATLAB_HDR,sizeof(MATLAB_HDR),\n    \"MATLAB 5.0 MAT-file, Platform: %s, Created on: %s %s %2d %2d:%2d:%2d %d\",\n    OsDesc,DayOfWTab[local_time.tm_wday],MonthsTab[local_time.tm_mon],\n    local_time.tm_mday,local_time.tm_hour,local_time.tm_min,\n    local_time.tm_sec,local_time.tm_year+1900);\n  MATLAB_HDR[0x7C]=0;\n  MATLAB_HDR[0x7D]=1;\n  MATLAB_HDR[0x7E]='I';\n  MATLAB_HDR[0x7F]='M';\n  (void) WriteBlob(image,sizeof(MATLAB_HDR),(unsigned char *) MATLAB_HDR);\n  scene=0;\n  do\n  {\n    char\n      padding;\n\n    MagickBooleanType\n      is_gray;\n\n    QuantumInfo\n      *quantum_info;\n\n    size_t\n      data_size;\n\n    unsigned char\n      *pixels;\n\n    unsigned int\n      z;\n\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    is_gray=SetImageGray(image,exception);\n    z=(is_gray != MagickFalse) ? 0 : 3;\n\n    /*\n      Store MAT header.\n    */\n    data_size = image->rows * image->columns;\n    if (is_gray == MagickFalse)\n      data_size*=3;\n    padding=((unsigned char)(data_size-1) & 0x7) ^ 0x7;\n\n    (void) WriteBlobLSBLong(image,miMATRIX);\n    (void) WriteBlobLSBLong(image,(unsigned int) data_size+padding+\n      ((is_gray != MagickFalse) ? 48 : 56));\n    (void) WriteBlobLSBLong(image,0x6); /* 0x88 */\n    (void) WriteBlobLSBLong(image,0x8); /* 0x8C */\n    (void) WriteBlobLSBLong(image,0x6); /* 0x90 */\n    (void) WriteBlobLSBLong(image,0);\n    (void) WriteBlobLSBLong(image,0x5); /* 0x98 */\n    (void) WriteBlobLSBLong(image,(is_gray != MagickFalse) ? 0x8 : 0xC); /* 0x9C - DimFlag */\n    (void) WriteBlobLSBLong(image,(unsigned int) image->rows);    /* x: 0xA0 */\n    (void) WriteBlobLSBLong(image,(unsigned int) image->columns); /* y: 0xA4 */\n    if (is_gray == MagickFalse)\n      {\n        (void) WriteBlobLSBLong(image,3); /* z: 0xA8 */\n        (void) WriteBlobLSBLong(image,0);\n      }\n    (void) WriteBlobLSBShort(image,1);  /* 0xB0 */\n    (void) WriteBlobLSBShort(image,1);  /* 0xB2 */\n    (void) WriteBlobLSBLong(image,'M'); /* 0xB4 */\n    (void) WriteBlobLSBLong(image,0x2); /* 0xB8 */\n    (void) WriteBlobLSBLong(image,(unsigned int) data_size); /* 0xBC */\n\n    /*\n      Store image data.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    do\n    {\n      const Quantum\n        *p;\n\n      ssize_t\n        y;\n\n      for (y=0; y < (ssize_t)image->columns; y++)\n      {\n        p=GetVirtualPixels(image,y,0,1,image->rows,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          z2qtype[z],pixels,exception);\n        (void) WriteBlob(image,image->rows,pixels);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    } while (z-- >= 2);\n    while (padding-- > 0)\n      (void) WriteBlobByte(image,0);\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/mat.c"], "buggy_code_start_loc": [1336], "buggy_code_end_loc": [1354], "fixing_code_start_loc": [1335], "fixing_code_end_loc": [1355], "type": "CWE-416", "message": "Use-after-free vulnerability in the DestroyImage function in image.c in ImageMagick before 7.0.6-6 allows remote attackers to cause a denial of service via a crafted file.", "other": {"cve": {"id": "CVE-2017-12877", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-28T19:29:00.790", "lastModified": "2021-04-28T18:12:36.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in the DestroyImage function in image.c in ImageMagick before 7.0.6-6 allows remote attackers to cause a denial of service via a crafted file."}, {"lang": "es", "value": "Una vulnerabilidad de uso de memoria antes de liberaci\u00f3n (use-after-free)en la funci\u00f3n DestroyImage en image.c de ImageMagick para versiones anteriores a la 7.0.6-6 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio mediante un archivo manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.9-6", "matchCriteriaId": "1CC65CC8-1DD1-4576-ABD7-939E3A8DEF50"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.6-6", "matchCriteriaId": "7E545DED-03D1-40A4-83C6-35FE50868C26"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/08/16/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://blogs.gentoo.org/ago/2017/08/10/imagemagick-use-after-free-in-destroyimage-image-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/04178de2247e353fc095846784b9a10fefdbf890", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201711-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3681-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4040", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4074", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/04178de2247e353fc095846784b9a10fefdbf890"}}