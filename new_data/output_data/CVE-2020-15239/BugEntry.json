{"buggy_code": ["########################################################################\n# File name: xhu.py\n# This file is part of: xmpp-http-upload\n#\n# LICENSE\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as\n# published by the Free Software Foundation, either version 3 of the\n# License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public\n# License along with this program.  If not, see\n# <http://www.gnu.org/licenses/>.\n#\n########################################################################\nimport contextlib\nimport errno\nimport fnmatch\nimport json\nimport hashlib\nimport hmac\nimport pathlib\nimport typing\n\nimport flask\n\napp = flask.Flask(\"xmpp-http-upload\")\napp.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")\napplication = app\n\nif app.config['ENABLE_CORS']:\n    from flask_cors import CORS\n    CORS(app)\n\n\ndef sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:\n    result = (root / path).absolute()\n    if not str(result).startswith(str(root) + \"/\"):\n        raise ValueError(\"resulting path is outside root\")\n    return result\n\n\ndef get_paths(base_path: pathlib.Path):\n    data_file = pathlib.Path(str(base_path) + \".data\")\n    metadata_file = pathlib.Path(str(base_path) + \".meta\")\n\n    return data_file, metadata_file\n\n\ndef load_metadata(metadata_file):\n    with metadata_file.open(\"r\") as f:\n        return json.load(f)\n\n\ndef get_info(path: str, root: pathlib.Path) -> typing.Tuple[\n        pathlib.Path,\n        dict]:\n    dest_path = sanitized_join(\n        path,\n        pathlib.Path(app.config[\"DATA_ROOT\"]),\n    )\n\n    data_file, metadata_file = get_paths(dest_path)\n\n    return data_file, load_metadata(metadata_file)\n\n\n@contextlib.contextmanager\ndef write_file(at: pathlib.Path):\n    with at.open(\"xb\") as f:\n        try:\n            yield f\n        except:  # NOQA\n            at.unlink()\n            raise\n\n\n@app.route(\"/\")\ndef index():\n    return flask.Response(\n        \"Welcome to XMPP HTTP Upload. State your business.\",\n        mimetype=\"text/plain\",\n    )\n\n\ndef stream_file(src, dest, nbytes):\n    while nbytes > 0:\n        data = src.read(min(nbytes, 4096))\n        if not data:\n            break\n        dest.write(data)\n        nbytes -= len(data)\n\n    if nbytes > 0:\n        raise EOFError\n\n\n@app.route(\"/<path:path>\", methods=[\"PUT\"])\ndef put_file(path):\n    try:\n        dest_path = sanitized_join(\n            path,\n            pathlib.Path(app.config[\"DATA_ROOT\"]),\n        )\n    except ValueError:\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    verification_key = flask.request.args.get(\"v\", \"\")\n    length = int(flask.request.headers.get(\"Content-Length\", 0))\n    hmac_input = \"{} {}\".format(path, length).encode(\"utf-8\")\n    key = app.config[\"SECRET_KEY\"]\n    mac = hmac.new(key, hmac_input, hashlib.sha256)\n    digest = mac.hexdigest()\n\n    if not hmac.compare_digest(digest, verification_key):\n        return flask.Response(\n            \"Invalid verification key\",\n            403,\n            mimetype=\"text/plain\",\n        )\n\n    content_type = flask.request.headers.get(\n        \"Content-Type\",\n        \"application/octet-stream\",\n    )\n\n    dest_path.parent.mkdir(parents=True, exist_ok=True, mode=0o770)\n    data_file, metadata_file = get_paths(dest_path)\n\n    try:\n        with write_file(data_file) as fout:\n            stream_file(flask.request.stream, fout, length)\n\n            with metadata_file.open(\"x\") as f:\n                json.dump(\n                    {\n                        \"headers\": {\"Content-Type\": content_type},\n                    },\n                    f,\n                )\n    except EOFError:\n        return flask.Response(\n            \"Bad Request\",\n            400,\n            mimetype=\"text/plain\",\n        )\n    except OSError as exc:\n        if exc.errno == errno.EEXIST:\n            return flask.Response(\n                \"Conflict\",\n                409,\n                mimetype=\"text/plain\",\n            )\n        raise\n\n    return flask.Response(\n        \"Created\",\n        201,\n        mimetype=\"text/plain\",\n    )\n\n\ndef generate_headers(response_headers, metadata_headers):\n    for key, value in metadata_headers.items():\n        response_headers[key] = value\n\n    content_type = metadata_headers[\"Content-Type\"]\n    for mimetype_glob in app.config.get(\"NON_ATTACHMENT_MIME_TYPES\", []):\n        if fnmatch.fnmatch(content_type, mimetype_glob):\n            break\n    else:\n        response_headers[\"Content-Disposition\"] = \"attachment\"\n\n    response_headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response_headers[\"X-Frame-Options\"] = \"DENY\"\n    response_headers[\"Content-Security-Policy\"] = \"default-src 'none'; frame-ancestors 'none'; sandbox\"\n\n\n@app.route(\"/<path:path>\", methods=[\"HEAD\"])\ndef head_file(path):\n    try:\n        data_file, metadata = get_info(\n            path,\n            pathlib.Path(app.config[\"DATA_ROOT\"])\n        )\n\n        stat = data_file.stat()\n    except (OSError, ValueError):\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    response = flask.Response()\n    response.headers[\"Content-Length\"] = str(stat.st_size)\n    generate_headers(\n        response.headers,\n        metadata[\"headers\"],\n    )\n    return response\n\n\n@app.route(\"/<path:path>\", methods=[\"GET\"])\ndef get_file(path):\n    try:\n        data_file, metadata = get_info(\n            path,\n            pathlib.Path(app.config[\"DATA_ROOT\"])\n        )\n    except (OSError, ValueError):\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    response = flask.make_response(flask.send_file(\n        str(data_file),\n    ))\n    generate_headers(\n        response.headers,\n        metadata[\"headers\"],\n    )\n    return response\n"], "fixing_code": ["########################################################################\n# File name: xhu.py\n# This file is part of: xmpp-http-upload\n#\n# LICENSE\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as\n# published by the Free Software Foundation, either version 3 of the\n# License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public\n# License along with this program.  If not, see\n# <http://www.gnu.org/licenses/>.\n#\n########################################################################\nimport contextlib\nimport errno\nimport fnmatch\nimport json\nimport hashlib\nimport hmac\nimport pathlib\nimport typing\n\nimport flask\nimport werkzeug.exceptions\n\napp = flask.Flask(\"xmpp-http-upload\")\napp.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")\napplication = app\n\nif app.config['ENABLE_CORS']:\n    from flask_cors import CORS\n    CORS(app)\n\n\ndef get_paths(root: str, sub_path: str) \\\n        -> typing.Tuple[pathlib.Path, pathlib.Path]:\n    base_path = flask.safe_join(root, sub_path)\n    data_file = pathlib.Path(base_path + \".data\")\n    metadata_file = pathlib.Path(base_path + \".meta\")\n\n    return data_file, metadata_file\n\n\ndef load_metadata(metadata_file):\n    with metadata_file.open(\"r\") as f:\n        return json.load(f)\n\n\ndef get_info(path: str) -> typing.Tuple[\n        pathlib.Path,\n        dict]:\n    data_file, metadata_file = get_paths(app.config[\"DATA_ROOT\"], path)\n\n    return data_file, load_metadata(metadata_file)\n\n\n@contextlib.contextmanager\ndef write_file(at: pathlib.Path):\n    with at.open(\"xb\") as f:\n        try:\n            yield f\n        except:  # NOQA\n            at.unlink()\n            raise\n\n\n@app.route(\"/\")\ndef index():\n    return flask.Response(\n        \"Welcome to XMPP HTTP Upload. State your business.\",\n        mimetype=\"text/plain\",\n    )\n\n\ndef stream_file(src, dest, nbytes):\n    while nbytes > 0:\n        data = src.read(min(nbytes, 4096))\n        if not data:\n            break\n        dest.write(data)\n        nbytes -= len(data)\n\n    if nbytes > 0:\n        raise EOFError\n\n\n@app.route(\"/<path:path>\", methods=[\"PUT\"])\ndef put_file(path):\n    try:\n        data_file, metadata_file = get_paths(app.config[\"DATA_ROOT\"], path)\n    except werkzeug.exceptions.NotFound:\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    verification_key = flask.request.args.get(\"v\", \"\")\n    length = int(flask.request.headers.get(\"Content-Length\", 0))\n    hmac_input = \"{} {}\".format(path, length).encode(\"utf-8\")\n    key = app.config[\"SECRET_KEY\"]\n    mac = hmac.new(key, hmac_input, hashlib.sha256)\n    digest = mac.hexdigest()\n\n    if not hmac.compare_digest(digest, verification_key):\n        return flask.Response(\n            \"Invalid verification key\",\n            403,\n            mimetype=\"text/plain\",\n        )\n\n    content_type = flask.request.headers.get(\n        \"Content-Type\",\n        \"application/octet-stream\",\n    )\n\n    data_file.parent.mkdir(parents=True, exist_ok=True, mode=0o770)\n\n    try:\n        with write_file(data_file) as fout:\n            stream_file(flask.request.stream, fout, length)\n\n            with metadata_file.open(\"x\") as f:\n                json.dump(\n                    {\n                        \"headers\": {\"Content-Type\": content_type},\n                    },\n                    f,\n                )\n    except EOFError:\n        return flask.Response(\n            \"Bad Request\",\n            400,\n            mimetype=\"text/plain\",\n        )\n    except OSError as exc:\n        if exc.errno == errno.EEXIST:\n            return flask.Response(\n                \"Conflict\",\n                409,\n                mimetype=\"text/plain\",\n            )\n        raise\n\n    return flask.Response(\n        \"Created\",\n        201,\n        mimetype=\"text/plain\",\n    )\n\n\ndef generate_headers(response_headers, metadata_headers):\n    for key, value in metadata_headers.items():\n        response_headers[key] = value\n\n    content_type = metadata_headers[\"Content-Type\"]\n    for mimetype_glob in app.config.get(\"NON_ATTACHMENT_MIME_TYPES\", []):\n        if fnmatch.fnmatch(content_type, mimetype_glob):\n            break\n    else:\n        response_headers[\"Content-Disposition\"] = \"attachment\"\n\n    response_headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response_headers[\"X-Frame-Options\"] = \"DENY\"\n    response_headers[\"Content-Security-Policy\"] = \"default-src 'none'; frame-ancestors 'none'; sandbox\"\n\n\n@app.route(\"/<path:path>\", methods=[\"HEAD\"])\ndef head_file(path):\n    try:\n        data_file, metadata = get_info(path)\n\n        stat = data_file.stat()\n    except (OSError, werkzeug.exceptions.NotFound):\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    response = flask.Response()\n    response.headers[\"Content-Length\"] = str(stat.st_size)\n    generate_headers(\n        response.headers,\n        metadata[\"headers\"],\n    )\n    return response\n\n\n@app.route(\"/<path:path>\", methods=[\"GET\"])\ndef get_file(path):\n    try:\n        data_file, metadata = get_info(path)\n    except (OSError, werkzeug.exceptions.NotFound):\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    response = flask.make_response(flask.send_file(\n        str(data_file),\n    ))\n    generate_headers(\n        response.headers,\n        metadata[\"headers\"],\n    )\n    return response\n"], "filenames": ["xhu.py"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [222], "fixing_code_start_loc": [32], "fixing_code_end_loc": [203], "type": "CWE-22", "message": "In xmpp-http-upload before version 0.4.0, when the GET method is attacked, attackers can read files which have a `.data` suffix and which are accompanied by a JSON file with the `.meta` suffix. This can lead to Information Disclosure and in some shared-hosting scenarios also to circumvention of authentication or other limitations on the outbound (GET) traffic. For example, in a scenario where a single server has multiple instances of the application running (with separate DATA_ROOT settings), an attacker who has knowledge about the directory structure is able to read files from any other instance to which the process has read access. If instances have individual authentication (for example, HTTP authentication via a reverse proxy, source IP based filtering) or other restrictions (such as quotas), attackers may circumvent those limits in such a scenario by using the Directory Traversal to retrieve data from the other instances. If the associated XMPP server (or anyone knowing the SECRET_KEY) is malicious, they can write files outside the DATA_ROOT. The files which are written are constrained to have the `.meta` and the `.data` suffixes; the `.meta` file will contain the JSON with the Content-Type of the original request and the `.data` file will contain the payload. The issue is patched in version 0.4.0.", "other": {"cve": {"id": "CVE-2020-15239", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-06T19:15:13.633", "lastModified": "2020-10-23T03:09:55.120", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In xmpp-http-upload before version 0.4.0, when the GET method is attacked, attackers can read files which have a `.data` suffix and which are accompanied by a JSON file with the `.meta` suffix. This can lead to Information Disclosure and in some shared-hosting scenarios also to circumvention of authentication or other limitations on the outbound (GET) traffic. For example, in a scenario where a single server has multiple instances of the application running (with separate DATA_ROOT settings), an attacker who has knowledge about the directory structure is able to read files from any other instance to which the process has read access. If instances have individual authentication (for example, HTTP authentication via a reverse proxy, source IP based filtering) or other restrictions (such as quotas), attackers may circumvent those limits in such a scenario by using the Directory Traversal to retrieve data from the other instances. If the associated XMPP server (or anyone knowing the SECRET_KEY) is malicious, they can write files outside the DATA_ROOT. The files which are written are constrained to have the `.meta` and the `.data` suffixes; the `.meta` file will contain the JSON with the Content-Type of the original request and the `.data` file will contain the payload. The issue is patched in version 0.4.0."}, {"lang": "es", "value": "En xmpp-http-upload anterior a la versi\u00f3n 0.4.0, cuando el m\u00e9todo GET es atacado, los atacantes pueden leer archivos que tienen un sufijo \".data\" y que est\u00e1n acompa\u00f1ados de un archivo JSON con el sufijo \".meta\".&#xa0;Esto puede conducir a una divulgaci\u00f3n de informaci\u00f3n y, en algunos escenarios de hosting compartido, tambi\u00e9n a una omisi\u00f3n de autenticaci\u00f3n u otras limitaciones en el tr\u00e1fico saliente (GET).&#xa0;Por ejemplo, en un escenario en el que un solo servidor posee varias instancias de la aplicaci\u00f3n en ejecuci\u00f3n (con configuraciones DATA_ROOT separadas), un atacante que tenga conocimiento sobre la estructura del directorio puede leer archivos de cualquier otra instancia a la que el proceso tenga acceso de lectura.&#xa0;Si las instancias tienen autenticaci\u00f3n individual (por ejemplo, autenticaci\u00f3n HTTP por medio de un proxy inverso, filtrado basado en IP de origen) u otras restricciones (como cuotas),&#xa0;los atacantes pueden omitir esos l\u00edmites en tal escenario usando un Salto de Directorio para recuperar datos de las otras instancias.&#xa0;Si el servidor XMPP asociado (o cualquier persona que conozca la SECRET_KEY) es malicioso, puede escribir archivos fuera de DATA_ROOT.&#xa0;Los archivos que se escriben est\u00e1n limitados a tener los sufijos \".meta\" y \".data\";&#xa0;el archivo \".meta\" contendr\u00e1 el JSON con el tipo de contenido de la petici\u00f3n original y el archivo \".data\" contendr\u00e1 la carga \u00fatil.&#xa0;El problema est\u00e1 parcheado en la versi\u00f3n 0.4.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xmpp-http-upload_project:xmpp-http-upload:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.0", "matchCriteriaId": "103FED28-C896-42E2-8C47-863D84A841C3"}]}]}], "references": [{"url": "https://github.com/horazont/xmpp-http-upload/commit/82056540191e89f0cd697c81f57714c00962ed75", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/horazont/xmpp-http-upload/pull/12", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/horazont/xmpp-http-upload/security/advisories/GHSA-hwv5-w8gm-fq9f", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pypi.org/project/xmpp-http-upload/#history", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/horazont/xmpp-http-upload/commit/82056540191e89f0cd697c81f57714c00962ed75"}}