{"buggy_code": ["/*\n * Copyright (c) 2006-2012 Red Hat, Inc.\n *\n * All rights reserved.\n *\n * Author: Steven Dake (sdake@redhat.com)\n *         Christine Caulfield (ccaulfie@redhat.com)\n *         Jan Friesse (jfriesse@redhat.com)\n *         Fabio M. Di Nitto (fdinitto@redhat.com)\n *\n * This software licensed under BSD license, the text of which follows:\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the MontaVista Software, Inc. nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <nss.h>\n#include <pk11pub.h>\n#include <pkcs11.h>\n#include <prerror.h>\n#include <blapit.h>\n#include <hasht.h>\n\n#define LOGSYS_UTILS_ONLY 1\n#include <corosync/logsys.h>\n#include <corosync/totem/totem.h>\n#include \"totemcrypto.h\"\n\n/*\n * define onwire crypto header\n */\n\nstruct crypto_config_header {\n\tuint8_t\tcrypto_cipher_type;\n\tuint8_t\tcrypto_hash_type;\n\tuint8_t __pad0;\n\tuint8_t __pad1;\n} __attribute__((packed));\n\n/*\n * crypto definitions and conversion tables\n */\n\n#define SALT_SIZE 16\n\n/*\n * This are defined in new NSS. For older one, we will define our own\n */\n#ifndef AES_256_KEY_LENGTH\n#define AES_256_KEY_LENGTH 32\n#endif\n\n#ifndef AES_192_KEY_LENGTH\n#define AES_192_KEY_LENGTH 24\n#endif\n\n#ifndef AES_128_KEY_LENGTH\n#define AES_128_KEY_LENGTH 16\n#endif\n\n/*\n * while CRYPTO_CIPHER_TYPE_2_2 is not a real cipher at all,\n * we still allocate a value for it because we use crypto_crypt_t\n * internally and we don't want overlaps\n */\n\nenum crypto_crypt_t {\n\tCRYPTO_CIPHER_TYPE_NONE = 0,\n\tCRYPTO_CIPHER_TYPE_AES256 = 1,\n\tCRYPTO_CIPHER_TYPE_AES192 = 2,\n\tCRYPTO_CIPHER_TYPE_AES128 = 3,\n\tCRYPTO_CIPHER_TYPE_3DES = 4,\n\tCRYPTO_CIPHER_TYPE_2_2 = UINT8_MAX\n};\n\nCK_MECHANISM_TYPE cipher_to_nss[] = {\n\t0,\t\t\t\t/* CRYPTO_CIPHER_TYPE_NONE */\n\tCKM_AES_CBC_PAD,\t\t/* CRYPTO_CIPHER_TYPE_AES256 */\n\tCKM_AES_CBC_PAD,\t\t/* CRYPTO_CIPHER_TYPE_AES192 */\n\tCKM_AES_CBC_PAD,\t\t/* CRYPTO_CIPHER_TYPE_AES128 */\n\tCKM_DES3_CBC_PAD\t\t/* CRYPTO_CIPHER_TYPE_3DES */\n};\n\nsize_t cipher_key_len[] = {\n\t0,\t\t\t\t/* CRYPTO_CIPHER_TYPE_NONE */\n\tAES_256_KEY_LENGTH,\t\t/* CRYPTO_CIPHER_TYPE_AES256 */\n\tAES_192_KEY_LENGTH,\t\t/* CRYPTO_CIPHER_TYPE_AES192 */\n\tAES_128_KEY_LENGTH,\t\t/* CRYPTO_CIPHER_TYPE_AES128 */\n\t24\t\t\t\t/* CRYPTO_CIPHER_TYPE_3DES - no magic in nss headers */\n};\n\nsize_t cypher_block_len[] = {\n\t0,\t\t\t\t/* CRYPTO_CIPHER_TYPE_NONE */\n\tAES_BLOCK_SIZE,\t\t\t/* CRYPTO_CIPHER_TYPE_AES256 */\n\tAES_BLOCK_SIZE,\t\t\t/* CRYPTO_CIPHER_TYPE_AES192 */\n\tAES_BLOCK_SIZE,\t\t\t/* CRYPTO_CIPHER_TYPE_AES128 */\n\t0\t\t\t\t/* CRYPTO_CIPHER_TYPE_3DES */\n};\n\n/*\n * hash definitions and conversion tables\n */\n\n/*\n * while CRYPTO_HASH_TYPE_2_2 is not a real hash mechanism at all,\n * we still allocate a value for it because we use crypto_hash_t\n * internally and we don't want overlaps\n */\n\nenum crypto_hash_t {\n\tCRYPTO_HASH_TYPE_NONE\t= 0,\n\tCRYPTO_HASH_TYPE_MD5\t= 1,\n\tCRYPTO_HASH_TYPE_SHA1\t= 2,\n\tCRYPTO_HASH_TYPE_SHA256\t= 3,\n\tCRYPTO_HASH_TYPE_SHA384\t= 4,\n\tCRYPTO_HASH_TYPE_SHA512\t= 5,\n\tCRYPTO_HASH_TYPE_2_2\t= UINT8_MAX\n};\n\nCK_MECHANISM_TYPE hash_to_nss[] = {\n\t0,\t\t\t\t/* CRYPTO_HASH_TYPE_NONE */\n\tCKM_MD5_HMAC,\t\t\t/* CRYPTO_HASH_TYPE_MD5 */\n\tCKM_SHA_1_HMAC,\t\t\t/* CRYPTO_HASH_TYPE_SHA1 */\n\tCKM_SHA256_HMAC,\t\t/* CRYPTO_HASH_TYPE_SHA256 */\n\tCKM_SHA384_HMAC,\t\t/* CRYPTO_HASH_TYPE_SHA384 */\n\tCKM_SHA512_HMAC\t\t\t/* CRYPTO_HASH_TYPE_SHA512 */\n};\n\nsize_t hash_len[] = {\n\t0,\t\t\t\t/* CRYPTO_HASH_TYPE_NONE */\n\tMD5_LENGTH,\t\t\t/* CRYPTO_HASH_TYPE_MD5 */\n\tSHA1_LENGTH,\t\t\t/* CRYPTO_HASH_TYPE_SHA1 */\n\tSHA256_LENGTH,\t\t\t/* CRYPTO_HASH_TYPE_SHA256 */\n\tSHA384_LENGTH,\t\t\t/* CRYPTO_HASH_TYPE_SHA384 */\n\tSHA512_LENGTH\t\t\t/* CRYPTO_HASH_TYPE_SHA512 */\n};\n\nsize_t hash_block_len[] = {\n\t0,\t\t\t\t/* CRYPTO_HASH_TYPE_NONE */\n\tMD5_BLOCK_LENGTH,\t\t/* CRYPTO_HASH_TYPE_MD5 */\n\tSHA1_BLOCK_LENGTH,\t\t/* CRYPTO_HASH_TYPE_SHA1 */\n\tSHA256_BLOCK_LENGTH,\t\t/* CRYPTO_HASH_TYPE_SHA256 */\n\tSHA384_BLOCK_LENGTH,\t\t/* CRYPTO_HASH_TYPE_SHA384 */\n\tSHA512_BLOCK_LENGTH\t\t/* CRYPTO_HASH_TYPE_SHA512 */\n};\n\n/*\n * crypto on-wire compat\n */\n\nenum crypto_compat_t {\n\tCRYPTO_COMPAT_2_0\t= 0,\n\tCRYPTO_COMPAT_2_2\t= 1\n};\n\nstruct crypto_instance {\n\tPK11SymKey   *nss_sym_key;\n\tPK11SymKey   *nss_sym_key_sign;\n\n\tunsigned char private_key[1024];\n\n\tunsigned int private_key_len;\n\n\tenum crypto_crypt_t crypto_cipher_type;\n\n\tenum crypto_hash_t crypto_hash_type;\n\n\tenum crypto_compat_t crypto_compat_type;\n\n\tunsigned int crypto_header_size;\n\n\tvoid (*log_printf_func) (\n\t\tint level,\n\t\tint subsys,\n\t\tconst char *function,\n\t\tconst char *file,\n\t\tint line,\n\t\tconst char *format,\n\t\t...)__attribute__((format(printf, 6, 7)));\n\n\tint log_level_security;\n\tint log_level_notice;\n\tint log_level_error;\n\tint log_subsys_id;\n};\n\n#define log_printf(level, format, args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tinstance->log_printf_func (\t\t\t\t\t\\\n\t\tlevel, instance->log_subsys_id,\t\t\t\t\\\n\t\t__FUNCTION__, __FILE__, __LINE__,\t\t\t\\\n\t\t(const char *)format, ##args);\t\t\t\t\\\n} while (0);\n\n/*\n * compat functions\n */\n\nstatic int string_to_crypto_compat_type(const char* crypto_compat_type)\n{\n\tif (strcmp(crypto_compat_type, \"2.0\") == 0) {\n\t\treturn CRYPTO_COMPAT_2_0;\n\t} else if (strcmp(crypto_compat_type, \"2.1\") == 0) {\n\t\treturn CRYPTO_COMPAT_2_2;\n\t}\n\treturn CRYPTO_COMPAT_2_2;\n}\n\n/*\n * crypt/decrypt functions\n */\n\nstatic int string_to_crypto_cipher_type(const char* crypto_cipher_type)\n{\n\tif (strcmp(crypto_cipher_type, \"none\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_NONE;\n\t} else if (strcmp(crypto_cipher_type, \"aes256\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_AES256;\n\t} else if (strcmp(crypto_cipher_type, \"aes192\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_AES192;\n\t} else if (strcmp(crypto_cipher_type, \"aes128\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_AES128;\n\t} else if (strcmp(crypto_cipher_type, \"3des\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_3DES;\n\t}\n\treturn CRYPTO_CIPHER_TYPE_AES256;\n}\n\nstatic int init_nss_crypto(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\tcrypt_slot = NULL;\n\tSECItem\t\tcrypt_param;\n\n\tif (!cipher_to_nss[instance->crypto_cipher_type]) {\n\t\treturn 0;\n\t}\n\n\tcrypt_param.type = siBuffer;\n\tcrypt_param.data = instance->private_key;\n\tcrypt_param.len = cipher_key_len[instance->crypto_cipher_type];\n\n\tcrypt_slot = PK11_GetBestSlot(cipher_to_nss[instance->crypto_cipher_type], NULL);\n\tif (crypt_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key = PK11_ImportSymKey(crypt_slot,\n\t\t\t\t\t\t  cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t\t  PK11_OriginUnwrap, CKA_ENCRYPT|CKA_DECRYPT,\n\t\t\t\t\t\t  &crypt_param, NULL);\n\tif (instance->nss_sym_key == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(crypt_slot);\n\n\treturn 0;\n}\n\nstatic int encrypt_nss(\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tPK11Context*\tcrypt_context = NULL;\n\tSECItem\t\tcrypt_param;\n\tSECItem\t\t*nss_sec_param = NULL;\n\tint\t\ttmp1_outlen = 0;\n\tunsigned int\ttmp2_outlen = 0;\n\tunsigned char\t*salt = buf_out;\n\tunsigned char\t*data = buf_out + SALT_SIZE;\n\tint\t\terr = -1;\n\n\tif (!cipher_to_nss[instance->crypto_cipher_type]) {\n\t\tmemcpy(buf_out, buf_in, buf_in_len);\n\t\t*buf_out_len = buf_in_len;\n\t\treturn 0;\n\t}\n\n\tif (PK11_GenerateRandom (salt, SALT_SIZE) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t\"Failure to generate a random number %d\",\n\t\t\tPR_GetError());\n\t\tgoto out;\n\t}\n\n\tcrypt_param.type = siBuffer;\n\tcrypt_param.data = salt;\n\tcrypt_param.len = SALT_SIZE;\n\n\tnss_sec_param = PK11_ParamFromIV (cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t  &crypt_param);\n\tif (nss_sec_param == NULL) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"Failure to set up PKCS11 param (err %d)\",\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Create cipher context for encryption\n\t */\n\tcrypt_context = PK11_CreateContextBySymKey (cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t\t    CKA_ENCRYPT,\n\t\t\t\t\t\t    instance->nss_sym_key,\n\t\t\t\t\t\t    nss_sec_param);\n\tif (!crypt_context) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CreateContext failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_CipherOp(crypt_context, data,\n\t\t\t  &tmp1_outlen,\n\t\t\t  FRAME_SIZE_MAX - instance->crypto_header_size,\n\t\t\t  (unsigned char *)buf_in, buf_in_len) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CipherOp failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestFinal(crypt_context, data + tmp1_outlen,\n\t\t\t     &tmp2_outlen, FRAME_SIZE_MAX - tmp1_outlen) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestFinal failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\n\t}\n\n\t*buf_out_len = tmp1_outlen + tmp2_outlen + SALT_SIZE;\n\n\terr = 0;\n\nout:\n\tif (crypt_context) {\n\t\tPK11_DestroyContext(crypt_context, PR_TRUE);\n\t}\n\tif (nss_sec_param) {\n\t\tSECITEM_FreeItem(nss_sec_param, PR_TRUE);\n\t}\n\treturn err;\n}\n\nstatic int decrypt_nss (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tPK11Context*\tdecrypt_context = NULL;\n\tSECItem\t\tdecrypt_param;\n\tint\t\ttmp1_outlen = 0;\n\tunsigned int\ttmp2_outlen = 0;\n\tunsigned char\t*salt = buf;\n\tunsigned char\t*data = salt + SALT_SIZE;\n\tint\t\tdatalen = *buf_len - SALT_SIZE;\n\tunsigned char\toutbuf[FRAME_SIZE_MAX];\n\tint\t\toutbuf_len;\n\tint\t\terr = -1;\n\n\tif (!cipher_to_nss[instance->crypto_cipher_type]) {\n\t\treturn 0;\n\t}\n\n\t/* Create cipher context for decryption */\n\tdecrypt_param.type = siBuffer;\n\tdecrypt_param.data = salt;\n\tdecrypt_param.len = SALT_SIZE;\n\n\tdecrypt_context = PK11_CreateContextBySymKey(cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t\t     CKA_DECRYPT,\n\t\t\t\t\t\t     instance->nss_sym_key, &decrypt_param);\n\tif (!decrypt_context) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CreateContext (decrypt) failed (err %d)\",\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_CipherOp(decrypt_context, outbuf, &tmp1_outlen,\n\t\t\t  sizeof(outbuf), data, datalen) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CipherOp (decrypt) failed (err %d)\",\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestFinal(decrypt_context, outbuf + tmp1_outlen, &tmp2_outlen,\n\t\t\t     sizeof(outbuf) - tmp1_outlen) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestFinal (decrypt) failed (err %d)\",\n\t\t\t   PR_GetError()); \n\t\tgoto out;\n\t}\n\n\toutbuf_len = tmp1_outlen + tmp2_outlen;\n\n\tmemset(buf, 0, *buf_len);\n\tmemcpy(buf, outbuf, outbuf_len);\n\n\t*buf_len = outbuf_len;\n\n\terr = 0;\n\nout:\n\tif (decrypt_context) {\n\t\tPK11_DestroyContext(decrypt_context, PR_TRUE);\n\t}\n\n\treturn err;\n}\n\n\n/*\n * hash/hmac/digest functions\n */\n\nstatic int string_to_crypto_hash_type(const char* crypto_hash_type)\n{\n\tif (strcmp(crypto_hash_type, \"none\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_NONE;\n\t} else if (strcmp(crypto_hash_type, \"md5\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_MD5;\n\t} else if (strcmp(crypto_hash_type, \"sha1\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_SHA1;\n\t} else if (strcmp(crypto_hash_type, \"sha256\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_SHA256;\n\t} else if (strcmp(crypto_hash_type, \"sha384\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_SHA384;\n\t} else if (strcmp(crypto_hash_type, \"sha512\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_SHA512;\n\t}\n\n\treturn CRYPTO_HASH_TYPE_SHA1;\n}\n\nstatic int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}\n\nstatic int calculate_nss_hash(\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf,\n\tconst size_t buf_len,\n\tunsigned char *hash)\n{\n\tPK11Context*\thash_context = NULL;\n\tSECItem\t\thash_param;\n\tunsigned int\thash_tmp_outlen = 0;\n\tunsigned char\thash_block[hash_block_len[instance->crypto_hash_type]];\n\tint\t\terr = -1;\n\n\t/* Now do the digest */\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\n\thash_context = PK11_CreateContextBySymKey(hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t CKA_SIGN,\n\t\t\t\t\t\t instance->nss_sym_key_sign,\n\t\t\t\t\t\t &hash_param);\n\n\tif (!hash_context) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CreateContext failed (hash) hash_type=%d (err %d)\",\n\t\t\t   (int)hash_to_nss[instance->crypto_hash_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestBegin(hash_context) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestBegin failed (hash) hash_type=%d (err %d)\",\n\t\t\t   (int)hash_to_nss[instance->crypto_hash_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestOp(hash_context,\n\t\t\t  buf,\n\t\t\t  buf_len) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestOp failed (hash) hash_type=%d (err %d)\",\n\t\t\t   (int)hash_to_nss[instance->crypto_hash_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestFinal(hash_context,\n\t\t\t     hash_block,\n\t\t\t     &hash_tmp_outlen,\n\t\t\t     hash_block_len[instance->crypto_hash_type]) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestFinale failed (hash) hash_type=%d (err %d)\",\n\t\t\t   (int)hash_to_nss[instance->crypto_hash_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tmemcpy(hash, hash_block, hash_len[instance->crypto_hash_type]);\n\terr = 0;\n\nout:\n\tif (hash_context) {\n\t\tPK11_DestroyContext(hash_context, PR_TRUE);\n\t}\n\n\treturn err;\n}\n\n/*\n * global/glue nss functions\n */\n\nstatic int init_nss_db(struct crypto_instance *instance)\n{\n\tif ((!cipher_to_nss[instance->crypto_cipher_type]) &&\n\t    (!hash_to_nss[instance->crypto_hash_type])) {\n\t\treturn 0;\n\t}\n\n\tif (NSS_NoDB_Init(\".\") != SECSuccess) {\n\t\tlog_printf(instance->log_level_security, \"NSS DB initialization failed (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_nss(struct crypto_instance *instance,\n\t\t    const char *crypto_cipher_type,\n\t\t    const char *crypto_hash_type,\n\t\t    const char *crypto_compat_type)\n{\n\tlog_printf(instance->log_level_notice,\n\t\t   \"Initializing transmit/receive security (NSS) crypto: %s hash: %s compat: %s\",\n\t\t   crypto_cipher_type, crypto_hash_type, crypto_compat_type);\n\n\tif (init_nss_db(instance) < 0) {\n\t\treturn -1;\n\t}\n\n\tif (init_nss_crypto(instance) < 0) {\n\t\treturn -1;\n\t}\n\n\tif (init_nss_hash(instance) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int encrypt_and_sign_nss_2_0 (\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tunsigned char\t*hash = buf_out;\n\tunsigned char\t*data = hash + hash_len[instance->crypto_hash_type];\n\n\tif (encrypt_nss(instance, buf_in, buf_in_len, data, buf_out_len) < 0) {\n\t\treturn -1;\n\t}\n\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tif (calculate_nss_hash(instance, data, *buf_out_len, hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t*buf_out_len = *buf_out_len + hash_len[instance->crypto_hash_type];\n\t}\n\n\treturn 0;\n}\n\nstatic int encrypt_and_sign_nss_2_2 (\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tif (encrypt_nss(instance,\n\t\t\tbuf_in, buf_in_len,\n\t\t\tbuf_out + sizeof(struct crypto_config_header), buf_out_len) < 0) {\n\t\treturn -1;\n\t}\n\n\t*buf_out_len += sizeof(struct crypto_config_header);\n\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tif (calculate_nss_hash(instance, buf_out, *buf_out_len, buf_out + *buf_out_len) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t*buf_out_len += hash_len[instance->crypto_hash_type];\n\t}\n\n\treturn 0;\n}\n\nstatic int authenticate_and_decrypt_nss_2_0 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tunsigned char\ttmp_hash[hash_len[instance->crypto_hash_type]];\n\t\tunsigned char\t*hash = buf;\n\t\tunsigned char\t*data = hash + hash_len[instance->crypto_hash_type];\n\t\tint\t\tdatalen = *buf_len - hash_len[instance->crypto_hash_type];\n\n\t\tif (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {\n\t\t\tlog_printf(instance->log_level_error, \"Digest does not match\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(buf, data, datalen);\n\t\t*buf_len = datalen;\n\t}\n\n\tif (decrypt_nss(instance, buf, buf_len) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int authenticate_nss_2_2 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tunsigned char\ttmp_hash[hash_len[instance->crypto_hash_type]];\n\t\tint             datalen = *buf_len - hash_len[instance->crypto_hash_type];\n\n\t\tif (calculate_nss_hash(instance, buf, datalen, tmp_hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (memcmp(tmp_hash, buf + datalen, hash_len[instance->crypto_hash_type]) != 0) {\n\t\t\tlog_printf(instance->log_level_error, \"Digest does not match\");\n\t\t\treturn -1;\n\t\t}\n\t\t*buf_len = datalen;\n\t}\n\n\treturn 0;\n}\n\nstatic int decrypt_nss_2_2 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\t*buf_len -= sizeof(struct crypto_config_header);\n\n\tif (decrypt_nss(instance, buf + sizeof(struct crypto_config_header), buf_len) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * exported API\n */\n\nsize_t crypto_sec_header_size(\n\tconst char *crypto_cipher_type,\n\tconst char *crypto_hash_type)\n{\n\tint crypto_cipher = string_to_crypto_cipher_type(crypto_cipher_type);\n\tint crypto_hash = string_to_crypto_hash_type(crypto_hash_type);\n\tsize_t hdr_size = 0;\n\n\thdr_size = sizeof(struct crypto_config_header);\n\n\tif (crypto_hash) {\n\t\thdr_size += hash_len[crypto_hash];\n\t}\n\n\tif (crypto_cipher) {\n\t\thdr_size += SALT_SIZE;\n\t\thdr_size += cypher_block_len[crypto_cipher];\n\t}\n\n\treturn hdr_size;\n}\n\n/*\n * 2.0 packet format:\n *   crypto_cipher_type | crypto_hash_type | __pad0 | __pad1 | hash | salt | data\n *   only data is encrypted, hash only covers salt + data\n *\n * 2.2 packet format\n *   fake_crypto_cipher_type | fake_crypto_hash_type | __pad0 | __pad1 | salt | data | hash\n *   only data is encrypted, hash covers the whole packet\n *\n *  we need to leave fake_* unencrypted for older versions of corosync to reject the packets,\n *  we need to leave __pad0|1 unencrypted for performance reasons (saves at least 2 memcpy and\n *  and extra buffer but values are hashed and verified.\n */\n\nint crypto_encrypt_and_sign (\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tstruct crypto_config_header *cch = (struct crypto_config_header *)buf_out;\n\tint err;\n\n\tswitch (instance->crypto_compat_type) {\n\t\tcase CRYPTO_COMPAT_2_0:\n\t\t\tcch->crypto_cipher_type = instance->crypto_cipher_type;\n\t\t\tcch->crypto_hash_type = instance->crypto_hash_type;\n\t\t\tcch->__pad0 = 0;\n\t\t\tcch->__pad1 = 0;\n\n\t\t\tbuf_out += sizeof(struct crypto_config_header);\n\n\t\t\terr = encrypt_and_sign_nss_2_0(instance,\n\t\t\t\t\t\t       buf_in, buf_in_len,\n\t\t\t\t\t\t       buf_out, buf_out_len);\n\n\t\t\t*buf_out_len = *buf_out_len + sizeof(struct crypto_config_header);\n\t\t\tbreak;\n\t\tcase CRYPTO_COMPAT_2_2:\n\t\t\tcch->crypto_cipher_type = CRYPTO_CIPHER_TYPE_2_2;\n\t\t\tcch->crypto_hash_type = CRYPTO_HASH_TYPE_2_2;\n\t\t\tcch->__pad0 = 0;\n\t\t\tcch->__pad1 = 0;\n\n\t\t\terr = encrypt_and_sign_nss_2_2(instance,\n\t\t\t\t\t\t   buf_in, buf_in_len,\n\t\t\t\t\t\t   buf_out, buf_out_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -1;\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint crypto_authenticate_and_decrypt (struct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tstruct crypto_config_header *cch = (struct crypto_config_header *)buf;\n\n\tswitch (instance->crypto_compat_type) {\n\t\tcase CRYPTO_COMPAT_2_0:\n\n\t\t\t/*\n\t\t\t * decode crypto config of incoming packets\n\t\t\t */\n\n\t\t\tif (cch->crypto_cipher_type != instance->crypto_cipher_type) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet has different crypto type. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (cch->crypto_hash_type != instance->crypto_hash_type) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet has different hash type. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((cch->__pad0 != 0) || (cch->__pad1 != 0)) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet appears to have features not supported by this version of corosync. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * invalidate config header and kill it\n\t\t\t */\n\n\t\t\tcch = NULL;\n\t\t\t*buf_len -= sizeof(struct crypto_config_header);\n\t\t\tmemmove(buf, buf + sizeof(struct crypto_config_header), *buf_len);\n\n\t\t\treturn authenticate_and_decrypt_nss_2_0(instance, buf, buf_len);\n\t\t\tbreak;\n\t\tcase CRYPTO_COMPAT_2_2:\n\t\t\tif (cch->crypto_cipher_type != CRYPTO_CIPHER_TYPE_2_2) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet has different crypto type. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (cch->crypto_hash_type != CRYPTO_HASH_TYPE_2_2) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet has different hash type. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * authenticate packet first\n\t\t\t */\n\n\t\t\tif (authenticate_nss_2_2(instance, buf, buf_len) != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * now we can \"trust\" the padding bytes/future features\n\t\t\t */\n\n\t\t\tif ((cch->__pad0 != 0) || (cch->__pad1 != 0)) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet appears to have features not supported by this version of corosync. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * decrypt\n\t\t\t */\n\n\t\t\tif (decrypt_nss_2_2(instance, buf, buf_len) != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * invalidate config header and kill it\n\t\t\t */\n\t\t\tcch = NULL;\n\t\t\tmemmove(buf, buf + sizeof(struct crypto_config_header), *buf_len);\n\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t\tbreak;\n\t}\n}\n\nstruct crypto_instance *crypto_init(\n\tconst unsigned char *private_key,\n\tunsigned int private_key_len,\n\tconst char *crypto_cipher_type,\n\tconst char *crypto_hash_type,\n\tconst char *crypto_compat_type,\n\tvoid (*log_printf_func) (\n\t\tint level,\n\t\tint subsys,\n                const char *function,\n                const char *file,\n                int line,\n                const char *format,\n                ...)__attribute__((format(printf, 6, 7))),\n\tint log_level_security,\n\tint log_level_notice,\n\tint log_level_error,\n\tint log_subsys_id)\n{\n\tstruct crypto_instance *instance;\n\tinstance = malloc(sizeof(*instance));\n\tif (instance == NULL) {\n\t\treturn (NULL);\n\t}\n\tmemset(instance, 0, sizeof(struct crypto_instance));\n\n\tmemcpy(instance->private_key, private_key, private_key_len);\n\tinstance->private_key_len = private_key_len;\n\n\tinstance->crypto_cipher_type = string_to_crypto_cipher_type(crypto_cipher_type);\n\tinstance->crypto_hash_type = string_to_crypto_hash_type(crypto_hash_type);\n\tinstance->crypto_compat_type = string_to_crypto_compat_type(crypto_compat_type);\n\n\tinstance->crypto_header_size = crypto_sec_header_size(crypto_cipher_type, crypto_hash_type);\n\n\tinstance->log_printf_func = log_printf_func;\n\tinstance->log_level_security = log_level_security;\n\tinstance->log_level_notice = log_level_notice;\n\tinstance->log_level_error = log_level_error;\n\tinstance->log_subsys_id = log_subsys_id;\n\n\tif (init_nss(instance, crypto_cipher_type, crypto_hash_type, crypto_compat_type) < 0) {\n\t\tfree(instance);\n\t\treturn(NULL);\n\t}\n\n\treturn (instance);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2006-2012 Red Hat, Inc.\n *\n * All rights reserved.\n *\n * Author: Steven Dake (sdake@redhat.com)\n *         Christine Caulfield (ccaulfie@redhat.com)\n *         Jan Friesse (jfriesse@redhat.com)\n *         Fabio M. Di Nitto (fdinitto@redhat.com)\n *\n * This software licensed under BSD license, the text of which follows:\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the MontaVista Software, Inc. nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include <nss.h>\n#include <pk11pub.h>\n#include <pkcs11.h>\n#include <prerror.h>\n#include <blapit.h>\n#include <hasht.h>\n\n#define LOGSYS_UTILS_ONLY 1\n#include <corosync/logsys.h>\n#include <corosync/totem/totem.h>\n#include \"totemcrypto.h\"\n\n/*\n * define onwire crypto header\n */\n\nstruct crypto_config_header {\n\tuint8_t\tcrypto_cipher_type;\n\tuint8_t\tcrypto_hash_type;\n\tuint8_t __pad0;\n\tuint8_t __pad1;\n} __attribute__((packed));\n\n/*\n * crypto definitions and conversion tables\n */\n\n#define SALT_SIZE 16\n\n/*\n * This are defined in new NSS. For older one, we will define our own\n */\n#ifndef AES_256_KEY_LENGTH\n#define AES_256_KEY_LENGTH 32\n#endif\n\n#ifndef AES_192_KEY_LENGTH\n#define AES_192_KEY_LENGTH 24\n#endif\n\n#ifndef AES_128_KEY_LENGTH\n#define AES_128_KEY_LENGTH 16\n#endif\n\n/*\n * while CRYPTO_CIPHER_TYPE_2_2 is not a real cipher at all,\n * we still allocate a value for it because we use crypto_crypt_t\n * internally and we don't want overlaps\n */\n\nenum crypto_crypt_t {\n\tCRYPTO_CIPHER_TYPE_NONE = 0,\n\tCRYPTO_CIPHER_TYPE_AES256 = 1,\n\tCRYPTO_CIPHER_TYPE_AES192 = 2,\n\tCRYPTO_CIPHER_TYPE_AES128 = 3,\n\tCRYPTO_CIPHER_TYPE_3DES = 4,\n\tCRYPTO_CIPHER_TYPE_2_2 = UINT8_MAX\n};\n\nCK_MECHANISM_TYPE cipher_to_nss[] = {\n\t0,\t\t\t\t/* CRYPTO_CIPHER_TYPE_NONE */\n\tCKM_AES_CBC_PAD,\t\t/* CRYPTO_CIPHER_TYPE_AES256 */\n\tCKM_AES_CBC_PAD,\t\t/* CRYPTO_CIPHER_TYPE_AES192 */\n\tCKM_AES_CBC_PAD,\t\t/* CRYPTO_CIPHER_TYPE_AES128 */\n\tCKM_DES3_CBC_PAD\t\t/* CRYPTO_CIPHER_TYPE_3DES */\n};\n\nsize_t cipher_key_len[] = {\n\t0,\t\t\t\t/* CRYPTO_CIPHER_TYPE_NONE */\n\tAES_256_KEY_LENGTH,\t\t/* CRYPTO_CIPHER_TYPE_AES256 */\n\tAES_192_KEY_LENGTH,\t\t/* CRYPTO_CIPHER_TYPE_AES192 */\n\tAES_128_KEY_LENGTH,\t\t/* CRYPTO_CIPHER_TYPE_AES128 */\n\t24\t\t\t\t/* CRYPTO_CIPHER_TYPE_3DES - no magic in nss headers */\n};\n\nsize_t cypher_block_len[] = {\n\t0,\t\t\t\t/* CRYPTO_CIPHER_TYPE_NONE */\n\tAES_BLOCK_SIZE,\t\t\t/* CRYPTO_CIPHER_TYPE_AES256 */\n\tAES_BLOCK_SIZE,\t\t\t/* CRYPTO_CIPHER_TYPE_AES192 */\n\tAES_BLOCK_SIZE,\t\t\t/* CRYPTO_CIPHER_TYPE_AES128 */\n\t0\t\t\t\t/* CRYPTO_CIPHER_TYPE_3DES */\n};\n\n/*\n * hash definitions and conversion tables\n */\n\n/*\n * while CRYPTO_HASH_TYPE_2_2 is not a real hash mechanism at all,\n * we still allocate a value for it because we use crypto_hash_t\n * internally and we don't want overlaps\n */\n\nenum crypto_hash_t {\n\tCRYPTO_HASH_TYPE_NONE\t= 0,\n\tCRYPTO_HASH_TYPE_MD5\t= 1,\n\tCRYPTO_HASH_TYPE_SHA1\t= 2,\n\tCRYPTO_HASH_TYPE_SHA256\t= 3,\n\tCRYPTO_HASH_TYPE_SHA384\t= 4,\n\tCRYPTO_HASH_TYPE_SHA512\t= 5,\n\tCRYPTO_HASH_TYPE_2_2\t= UINT8_MAX\n};\n\nCK_MECHANISM_TYPE hash_to_nss[] = {\n\t0,\t\t\t\t/* CRYPTO_HASH_TYPE_NONE */\n\tCKM_MD5_HMAC,\t\t\t/* CRYPTO_HASH_TYPE_MD5 */\n\tCKM_SHA_1_HMAC,\t\t\t/* CRYPTO_HASH_TYPE_SHA1 */\n\tCKM_SHA256_HMAC,\t\t/* CRYPTO_HASH_TYPE_SHA256 */\n\tCKM_SHA384_HMAC,\t\t/* CRYPTO_HASH_TYPE_SHA384 */\n\tCKM_SHA512_HMAC\t\t\t/* CRYPTO_HASH_TYPE_SHA512 */\n};\n\nsize_t hash_len[] = {\n\t0,\t\t\t\t/* CRYPTO_HASH_TYPE_NONE */\n\tMD5_LENGTH,\t\t\t/* CRYPTO_HASH_TYPE_MD5 */\n\tSHA1_LENGTH,\t\t\t/* CRYPTO_HASH_TYPE_SHA1 */\n\tSHA256_LENGTH,\t\t\t/* CRYPTO_HASH_TYPE_SHA256 */\n\tSHA384_LENGTH,\t\t\t/* CRYPTO_HASH_TYPE_SHA384 */\n\tSHA512_LENGTH\t\t\t/* CRYPTO_HASH_TYPE_SHA512 */\n};\n\nsize_t hash_block_len[] = {\n\t0,\t\t\t\t/* CRYPTO_HASH_TYPE_NONE */\n\tMD5_BLOCK_LENGTH,\t\t/* CRYPTO_HASH_TYPE_MD5 */\n\tSHA1_BLOCK_LENGTH,\t\t/* CRYPTO_HASH_TYPE_SHA1 */\n\tSHA256_BLOCK_LENGTH,\t\t/* CRYPTO_HASH_TYPE_SHA256 */\n\tSHA384_BLOCK_LENGTH,\t\t/* CRYPTO_HASH_TYPE_SHA384 */\n\tSHA512_BLOCK_LENGTH\t\t/* CRYPTO_HASH_TYPE_SHA512 */\n};\n\n/*\n * crypto on-wire compat\n */\n\nenum crypto_compat_t {\n\tCRYPTO_COMPAT_2_0\t= 0,\n\tCRYPTO_COMPAT_2_2\t= 1\n};\n\nstruct crypto_instance {\n\tPK11SymKey   *nss_sym_key;\n\tPK11SymKey   *nss_sym_key_sign;\n\n\tunsigned char private_key[1024];\n\n\tunsigned int private_key_len;\n\n\tenum crypto_crypt_t crypto_cipher_type;\n\n\tenum crypto_hash_t crypto_hash_type;\n\n\tenum crypto_compat_t crypto_compat_type;\n\n\tunsigned int crypto_header_size;\n\n\tvoid (*log_printf_func) (\n\t\tint level,\n\t\tint subsys,\n\t\tconst char *function,\n\t\tconst char *file,\n\t\tint line,\n\t\tconst char *format,\n\t\t...)__attribute__((format(printf, 6, 7)));\n\n\tint log_level_security;\n\tint log_level_notice;\n\tint log_level_error;\n\tint log_subsys_id;\n};\n\n#define log_printf(level, format, args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tinstance->log_printf_func (\t\t\t\t\t\\\n\t\tlevel, instance->log_subsys_id,\t\t\t\t\\\n\t\t__FUNCTION__, __FILE__, __LINE__,\t\t\t\\\n\t\t(const char *)format, ##args);\t\t\t\t\\\n} while (0);\n\n/*\n * compat functions\n */\n\nstatic int string_to_crypto_compat_type(const char* crypto_compat_type)\n{\n\tif (strcmp(crypto_compat_type, \"2.0\") == 0) {\n\t\treturn CRYPTO_COMPAT_2_0;\n\t} else if (strcmp(crypto_compat_type, \"2.1\") == 0) {\n\t\treturn CRYPTO_COMPAT_2_2;\n\t}\n\treturn CRYPTO_COMPAT_2_2;\n}\n\n/*\n * crypt/decrypt functions\n */\n\nstatic int string_to_crypto_cipher_type(const char* crypto_cipher_type)\n{\n\tif (strcmp(crypto_cipher_type, \"none\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_NONE;\n\t} else if (strcmp(crypto_cipher_type, \"aes256\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_AES256;\n\t} else if (strcmp(crypto_cipher_type, \"aes192\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_AES192;\n\t} else if (strcmp(crypto_cipher_type, \"aes128\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_AES128;\n\t} else if (strcmp(crypto_cipher_type, \"3des\") == 0) {\n\t\treturn CRYPTO_CIPHER_TYPE_3DES;\n\t}\n\treturn CRYPTO_CIPHER_TYPE_AES256;\n}\n\nstatic int init_nss_crypto(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\tcrypt_slot = NULL;\n\tSECItem\t\tcrypt_param;\n\n\tif (!cipher_to_nss[instance->crypto_cipher_type]) {\n\t\treturn 0;\n\t}\n\n\tcrypt_param.type = siBuffer;\n\tcrypt_param.data = instance->private_key;\n\tcrypt_param.len = cipher_key_len[instance->crypto_cipher_type];\n\n\tcrypt_slot = PK11_GetBestSlot(cipher_to_nss[instance->crypto_cipher_type], NULL);\n\tif (crypt_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key = PK11_ImportSymKey(crypt_slot,\n\t\t\t\t\t\t  cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t\t  PK11_OriginUnwrap, CKA_ENCRYPT|CKA_DECRYPT,\n\t\t\t\t\t\t  &crypt_param, NULL);\n\tif (instance->nss_sym_key == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(crypt_slot);\n\n\treturn 0;\n}\n\nstatic int encrypt_nss(\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tPK11Context*\tcrypt_context = NULL;\n\tSECItem\t\tcrypt_param;\n\tSECItem\t\t*nss_sec_param = NULL;\n\tint\t\ttmp1_outlen = 0;\n\tunsigned int\ttmp2_outlen = 0;\n\tunsigned char\t*salt = buf_out;\n\tunsigned char\t*data = buf_out + SALT_SIZE;\n\tint\t\terr = -1;\n\n\tif (!cipher_to_nss[instance->crypto_cipher_type]) {\n\t\tmemcpy(buf_out, buf_in, buf_in_len);\n\t\t*buf_out_len = buf_in_len;\n\t\treturn 0;\n\t}\n\n\tif (PK11_GenerateRandom (salt, SALT_SIZE) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t\"Failure to generate a random number %d\",\n\t\t\tPR_GetError());\n\t\tgoto out;\n\t}\n\n\tcrypt_param.type = siBuffer;\n\tcrypt_param.data = salt;\n\tcrypt_param.len = SALT_SIZE;\n\n\tnss_sec_param = PK11_ParamFromIV (cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t  &crypt_param);\n\tif (nss_sec_param == NULL) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"Failure to set up PKCS11 param (err %d)\",\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Create cipher context for encryption\n\t */\n\tcrypt_context = PK11_CreateContextBySymKey (cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t\t    CKA_ENCRYPT,\n\t\t\t\t\t\t    instance->nss_sym_key,\n\t\t\t\t\t\t    nss_sec_param);\n\tif (!crypt_context) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CreateContext failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_CipherOp(crypt_context, data,\n\t\t\t  &tmp1_outlen,\n\t\t\t  FRAME_SIZE_MAX - instance->crypto_header_size,\n\t\t\t  (unsigned char *)buf_in, buf_in_len) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CipherOp failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestFinal(crypt_context, data + tmp1_outlen,\n\t\t\t     &tmp2_outlen, FRAME_SIZE_MAX - tmp1_outlen) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestFinal failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\n\t}\n\n\t*buf_out_len = tmp1_outlen + tmp2_outlen + SALT_SIZE;\n\n\terr = 0;\n\nout:\n\tif (crypt_context) {\n\t\tPK11_DestroyContext(crypt_context, PR_TRUE);\n\t}\n\tif (nss_sec_param) {\n\t\tSECITEM_FreeItem(nss_sec_param, PR_TRUE);\n\t}\n\treturn err;\n}\n\nstatic int decrypt_nss (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tPK11Context*\tdecrypt_context = NULL;\n\tSECItem\t\tdecrypt_param;\n\tint\t\ttmp1_outlen = 0;\n\tunsigned int\ttmp2_outlen = 0;\n\tunsigned char\t*salt = buf;\n\tunsigned char\t*data = salt + SALT_SIZE;\n\tint\t\tdatalen = *buf_len - SALT_SIZE;\n\tunsigned char\toutbuf[FRAME_SIZE_MAX];\n\tint\t\toutbuf_len;\n\tint\t\terr = -1;\n\n\tif (!cipher_to_nss[instance->crypto_cipher_type]) {\n\t\treturn 0;\n\t}\n\n\t/* Create cipher context for decryption */\n\tdecrypt_param.type = siBuffer;\n\tdecrypt_param.data = salt;\n\tdecrypt_param.len = SALT_SIZE;\n\n\tdecrypt_context = PK11_CreateContextBySymKey(cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t\t     CKA_DECRYPT,\n\t\t\t\t\t\t     instance->nss_sym_key, &decrypt_param);\n\tif (!decrypt_context) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CreateContext (decrypt) failed (err %d)\",\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_CipherOp(decrypt_context, outbuf, &tmp1_outlen,\n\t\t\t  sizeof(outbuf), data, datalen) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CipherOp (decrypt) failed (err %d)\",\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestFinal(decrypt_context, outbuf + tmp1_outlen, &tmp2_outlen,\n\t\t\t     sizeof(outbuf) - tmp1_outlen) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestFinal (decrypt) failed (err %d)\",\n\t\t\t   PR_GetError()); \n\t\tgoto out;\n\t}\n\n\toutbuf_len = tmp1_outlen + tmp2_outlen;\n\n\tmemset(buf, 0, *buf_len);\n\tmemcpy(buf, outbuf, outbuf_len);\n\n\t*buf_len = outbuf_len;\n\n\terr = 0;\n\nout:\n\tif (decrypt_context) {\n\t\tPK11_DestroyContext(decrypt_context, PR_TRUE);\n\t}\n\n\treturn err;\n}\n\n\n/*\n * hash/hmac/digest functions\n */\n\nstatic int string_to_crypto_hash_type(const char* crypto_hash_type)\n{\n\tif (strcmp(crypto_hash_type, \"none\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_NONE;\n\t} else if (strcmp(crypto_hash_type, \"md5\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_MD5;\n\t} else if (strcmp(crypto_hash_type, \"sha1\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_SHA1;\n\t} else if (strcmp(crypto_hash_type, \"sha256\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_SHA256;\n\t} else if (strcmp(crypto_hash_type, \"sha384\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_SHA384;\n\t} else if (strcmp(crypto_hash_type, \"sha512\") == 0) {\n\t\treturn CRYPTO_HASH_TYPE_SHA512;\n\t}\n\n\treturn CRYPTO_HASH_TYPE_SHA1;\n}\n\nstatic int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\n\thash_param.type = siBuffer;\n\thash_param.data = instance->private_key;\n\thash_param.len = instance->private_key_len;\n\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}\n\nstatic int calculate_nss_hash(\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf,\n\tconst size_t buf_len,\n\tunsigned char *hash)\n{\n\tPK11Context*\thash_context = NULL;\n\tSECItem\t\thash_param;\n\tunsigned int\thash_tmp_outlen = 0;\n\tunsigned char\thash_block[hash_block_len[instance->crypto_hash_type]];\n\tint\t\terr = -1;\n\n\t/* Now do the digest */\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\n\thash_context = PK11_CreateContextBySymKey(hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t CKA_SIGN,\n\t\t\t\t\t\t instance->nss_sym_key_sign,\n\t\t\t\t\t\t &hash_param);\n\n\tif (!hash_context) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CreateContext failed (hash) hash_type=%d (err %d)\",\n\t\t\t   (int)hash_to_nss[instance->crypto_hash_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestBegin(hash_context) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestBegin failed (hash) hash_type=%d (err %d)\",\n\t\t\t   (int)hash_to_nss[instance->crypto_hash_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestOp(hash_context,\n\t\t\t  buf,\n\t\t\t  buf_len) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestOp failed (hash) hash_type=%d (err %d)\",\n\t\t\t   (int)hash_to_nss[instance->crypto_hash_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestFinal(hash_context,\n\t\t\t     hash_block,\n\t\t\t     &hash_tmp_outlen,\n\t\t\t     hash_block_len[instance->crypto_hash_type]) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestFinale failed (hash) hash_type=%d (err %d)\",\n\t\t\t   (int)hash_to_nss[instance->crypto_hash_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tmemcpy(hash, hash_block, hash_len[instance->crypto_hash_type]);\n\terr = 0;\n\nout:\n\tif (hash_context) {\n\t\tPK11_DestroyContext(hash_context, PR_TRUE);\n\t}\n\n\treturn err;\n}\n\n/*\n * global/glue nss functions\n */\n\nstatic int init_nss_db(struct crypto_instance *instance)\n{\n\tif ((!cipher_to_nss[instance->crypto_cipher_type]) &&\n\t    (!hash_to_nss[instance->crypto_hash_type])) {\n\t\treturn 0;\n\t}\n\n\tif (NSS_NoDB_Init(\".\") != SECSuccess) {\n\t\tlog_printf(instance->log_level_security, \"NSS DB initialization failed (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_nss(struct crypto_instance *instance,\n\t\t    const char *crypto_cipher_type,\n\t\t    const char *crypto_hash_type,\n\t\t    const char *crypto_compat_type)\n{\n\tlog_printf(instance->log_level_notice,\n\t\t   \"Initializing transmit/receive security (NSS) crypto: %s hash: %s compat: %s\",\n\t\t   crypto_cipher_type, crypto_hash_type, crypto_compat_type);\n\n\tif (init_nss_db(instance) < 0) {\n\t\treturn -1;\n\t}\n\n\tif (init_nss_crypto(instance) < 0) {\n\t\treturn -1;\n\t}\n\n\tif (init_nss_hash(instance) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int encrypt_and_sign_nss_2_0 (\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tunsigned char\t*hash = buf_out;\n\tunsigned char\t*data = hash + hash_len[instance->crypto_hash_type];\n\n\tif (encrypt_nss(instance, buf_in, buf_in_len, data, buf_out_len) < 0) {\n\t\treturn -1;\n\t}\n\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tif (calculate_nss_hash(instance, data, *buf_out_len, hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t*buf_out_len = *buf_out_len + hash_len[instance->crypto_hash_type];\n\t}\n\n\treturn 0;\n}\n\nstatic int encrypt_and_sign_nss_2_2 (\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tif (encrypt_nss(instance,\n\t\t\tbuf_in, buf_in_len,\n\t\t\tbuf_out + sizeof(struct crypto_config_header), buf_out_len) < 0) {\n\t\treturn -1;\n\t}\n\n\t*buf_out_len += sizeof(struct crypto_config_header);\n\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tif (calculate_nss_hash(instance, buf_out, *buf_out_len, buf_out + *buf_out_len) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t*buf_out_len += hash_len[instance->crypto_hash_type];\n\t}\n\n\treturn 0;\n}\n\nstatic int authenticate_and_decrypt_nss_2_0 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tunsigned char\ttmp_hash[hash_len[instance->crypto_hash_type]];\n\t\tunsigned char\t*hash = buf;\n\t\tunsigned char\t*data = hash + hash_len[instance->crypto_hash_type];\n\t\tint\t\tdatalen = *buf_len - hash_len[instance->crypto_hash_type];\n\n\t\tif (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {\n\t\t\tlog_printf(instance->log_level_error, \"Digest does not match\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(buf, data, datalen);\n\t\t*buf_len = datalen;\n\t}\n\n\tif (decrypt_nss(instance, buf, buf_len) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int authenticate_nss_2_2 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tunsigned char\ttmp_hash[hash_len[instance->crypto_hash_type]];\n\t\tint             datalen = *buf_len - hash_len[instance->crypto_hash_type];\n\n\t\tif (calculate_nss_hash(instance, buf, datalen, tmp_hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (memcmp(tmp_hash, buf + datalen, hash_len[instance->crypto_hash_type]) != 0) {\n\t\t\tlog_printf(instance->log_level_error, \"Digest does not match\");\n\t\t\treturn -1;\n\t\t}\n\t\t*buf_len = datalen;\n\t}\n\n\treturn 0;\n}\n\nstatic int decrypt_nss_2_2 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\t*buf_len -= sizeof(struct crypto_config_header);\n\n\tif (decrypt_nss(instance, buf + sizeof(struct crypto_config_header), buf_len) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * exported API\n */\n\nsize_t crypto_sec_header_size(\n\tconst char *crypto_cipher_type,\n\tconst char *crypto_hash_type)\n{\n\tint crypto_cipher = string_to_crypto_cipher_type(crypto_cipher_type);\n\tint crypto_hash = string_to_crypto_hash_type(crypto_hash_type);\n\tsize_t hdr_size = 0;\n\n\thdr_size = sizeof(struct crypto_config_header);\n\n\tif (crypto_hash) {\n\t\thdr_size += hash_len[crypto_hash];\n\t}\n\n\tif (crypto_cipher) {\n\t\thdr_size += SALT_SIZE;\n\t\thdr_size += cypher_block_len[crypto_cipher];\n\t}\n\n\treturn hdr_size;\n}\n\n/*\n * 2.0 packet format:\n *   crypto_cipher_type | crypto_hash_type | __pad0 | __pad1 | hash | salt | data\n *   only data is encrypted, hash only covers salt + data\n *\n * 2.2 packet format\n *   fake_crypto_cipher_type | fake_crypto_hash_type | __pad0 | __pad1 | salt | data | hash\n *   only data is encrypted, hash covers the whole packet\n *\n *  we need to leave fake_* unencrypted for older versions of corosync to reject the packets,\n *  we need to leave __pad0|1 unencrypted for performance reasons (saves at least 2 memcpy and\n *  and extra buffer but values are hashed and verified.\n */\n\nint crypto_encrypt_and_sign (\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tstruct crypto_config_header *cch = (struct crypto_config_header *)buf_out;\n\tint err;\n\n\tswitch (instance->crypto_compat_type) {\n\t\tcase CRYPTO_COMPAT_2_0:\n\t\t\tcch->crypto_cipher_type = instance->crypto_cipher_type;\n\t\t\tcch->crypto_hash_type = instance->crypto_hash_type;\n\t\t\tcch->__pad0 = 0;\n\t\t\tcch->__pad1 = 0;\n\n\t\t\tbuf_out += sizeof(struct crypto_config_header);\n\n\t\t\terr = encrypt_and_sign_nss_2_0(instance,\n\t\t\t\t\t\t       buf_in, buf_in_len,\n\t\t\t\t\t\t       buf_out, buf_out_len);\n\n\t\t\t*buf_out_len = *buf_out_len + sizeof(struct crypto_config_header);\n\t\t\tbreak;\n\t\tcase CRYPTO_COMPAT_2_2:\n\t\t\tcch->crypto_cipher_type = CRYPTO_CIPHER_TYPE_2_2;\n\t\t\tcch->crypto_hash_type = CRYPTO_HASH_TYPE_2_2;\n\t\t\tcch->__pad0 = 0;\n\t\t\tcch->__pad1 = 0;\n\n\t\t\terr = encrypt_and_sign_nss_2_2(instance,\n\t\t\t\t\t\t   buf_in, buf_in_len,\n\t\t\t\t\t\t   buf_out, buf_out_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -1;\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint crypto_authenticate_and_decrypt (struct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tstruct crypto_config_header *cch = (struct crypto_config_header *)buf;\n\n\tswitch (instance->crypto_compat_type) {\n\t\tcase CRYPTO_COMPAT_2_0:\n\n\t\t\t/*\n\t\t\t * decode crypto config of incoming packets\n\t\t\t */\n\n\t\t\tif (cch->crypto_cipher_type != instance->crypto_cipher_type) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet has different crypto type. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (cch->crypto_hash_type != instance->crypto_hash_type) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet has different hash type. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((cch->__pad0 != 0) || (cch->__pad1 != 0)) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet appears to have features not supported by this version of corosync. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * invalidate config header and kill it\n\t\t\t */\n\n\t\t\tcch = NULL;\n\t\t\t*buf_len -= sizeof(struct crypto_config_header);\n\t\t\tmemmove(buf, buf + sizeof(struct crypto_config_header), *buf_len);\n\n\t\t\treturn authenticate_and_decrypt_nss_2_0(instance, buf, buf_len);\n\t\t\tbreak;\n\t\tcase CRYPTO_COMPAT_2_2:\n\t\t\tif (cch->crypto_cipher_type != CRYPTO_CIPHER_TYPE_2_2) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet has different crypto type. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (cch->crypto_hash_type != CRYPTO_HASH_TYPE_2_2) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet has different hash type. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * authenticate packet first\n\t\t\t */\n\n\t\t\tif (authenticate_nss_2_2(instance, buf, buf_len) != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * now we can \"trust\" the padding bytes/future features\n\t\t\t */\n\n\t\t\tif ((cch->__pad0 != 0) || (cch->__pad1 != 0)) {\n\t\t\t\tlog_printf(instance->log_level_security,\n\t\t\t\t\t   \"Incoming packet appears to have features not supported by this version of corosync. Rejecting\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * decrypt\n\t\t\t */\n\n\t\t\tif (decrypt_nss_2_2(instance, buf, buf_len) != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * invalidate config header and kill it\n\t\t\t */\n\t\t\tcch = NULL;\n\t\t\tmemmove(buf, buf + sizeof(struct crypto_config_header), *buf_len);\n\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t\tbreak;\n\t}\n}\n\nstruct crypto_instance *crypto_init(\n\tconst unsigned char *private_key,\n\tunsigned int private_key_len,\n\tconst char *crypto_cipher_type,\n\tconst char *crypto_hash_type,\n\tconst char *crypto_compat_type,\n\tvoid (*log_printf_func) (\n\t\tint level,\n\t\tint subsys,\n                const char *function,\n                const char *file,\n                int line,\n                const char *format,\n                ...)__attribute__((format(printf, 6, 7))),\n\tint log_level_security,\n\tint log_level_notice,\n\tint log_level_error,\n\tint log_subsys_id)\n{\n\tstruct crypto_instance *instance;\n\tinstance = malloc(sizeof(*instance));\n\tif (instance == NULL) {\n\t\treturn (NULL);\n\t}\n\tmemset(instance, 0, sizeof(struct crypto_instance));\n\n\tmemcpy(instance->private_key, private_key, private_key_len);\n\tinstance->private_key_len = private_key_len;\n\n\tinstance->crypto_cipher_type = string_to_crypto_cipher_type(crypto_cipher_type);\n\tinstance->crypto_hash_type = string_to_crypto_hash_type(crypto_hash_type);\n\tinstance->crypto_compat_type = string_to_crypto_compat_type(crypto_compat_type);\n\n\tinstance->crypto_header_size = crypto_sec_header_size(crypto_cipher_type, crypto_hash_type);\n\n\tinstance->log_printf_func = log_printf_func;\n\tinstance->log_level_security = log_level_security;\n\tinstance->log_level_notice = log_level_notice;\n\tinstance->log_level_error = log_level_error;\n\tinstance->log_subsys_id = log_subsys_id;\n\n\tif (init_nss(instance, crypto_cipher_type, crypto_hash_type, crypto_compat_type) < 0) {\n\t\tfree(instance);\n\t\treturn(NULL);\n\t}\n\n\treturn (instance);\n}\n"], "filenames": ["exec/totemcrypto.c"], "buggy_code_start_loc": [481], "buggy_code_end_loc": [483], "fixing_code_start_loc": [481], "fixing_code_end_loc": [483], "type": "NVD-CWE-Other", "message": "The init_nss_hash function in exec/totemcrypto.c in Corosync 2.0 before 2.3 does not properly initialize the HMAC key, which allows remote attackers to cause a denial of service (crash) via a crafted packet.", "other": {"cve": {"id": "CVE-2013-0250", "sourceIdentifier": "secalert@redhat.com", "published": "2014-06-06T14:55:03.837", "lastModified": "2014-06-09T13:34:15.860", "vulnStatus": "Analyzed", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/665.html\n\n\"CWE-665: Improper Initialization\"", "descriptions": [{"lang": "en", "value": "The init_nss_hash function in exec/totemcrypto.c in Corosync 2.0 before 2.3 does not properly initialize the HMAC key, which allows remote attackers to cause a denial of service (crash) via a crafted packet."}, {"lang": "es", "value": "La funci\u00f3n init_nss_hash en exec/totemcrypto.c en Corosync 2.0 anterior a 2.3 no inicializa debidamente la clave HMAC, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de un paquete manipulado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:corosync:corosync:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A4C7B7D-B867-4C44-A69B-33416963FC8A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:corosync:corosync:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "3C35467E-767B-4E37-969A-A5C90291ABB3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:corosync:corosync:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "744A653A-BD3D-49C1-94B2-D1C2A7226993"}, {"vulnerable": true, "criteria": "cpe:2.3:a:corosync:corosync:2.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "12BCD2CB-C926-476B-AE95-4CA973258746"}, {"vulnerable": true, "criteria": "cpe:2.3:a:corosync:corosync:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "61262BFE-ED90-4A5B-947F-E34E2E258252"}, {"vulnerable": true, "criteria": "cpe:2.3:a:corosync:corosync:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "81E5A2B0-8364-4891-BAF2-0EEB6F640B3C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:corosync:corosync:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "D31DD511-22D3-43CF-9CD5-6D6A649A1791"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2013/q1/212", "source": "secalert@redhat.com"}, {"url": "http://seclists.org/oss-sec/2013/q1/213", "source": "secalert@redhat.com"}, {"url": "http://seclists.org/oss-sec/2013/q1/214", "source": "secalert@redhat.com"}, {"url": "https://github.com/corosync/corosync/commit/b3f456a8ceefac6e9f2e9acc2ea0c159d412b595", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/corosync/corosync/commit/b3f456a8ceefac6e9f2e9acc2ea0c159d412b595"}}