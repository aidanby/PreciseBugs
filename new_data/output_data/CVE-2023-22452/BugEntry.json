{"buggy_code": ["import os\nimport re\nimport time\nfrom html import escape\nfrom urllib.parse import quote_plus as urlquote\nimport sqlite3 as sql\nfrom hashlib import sha256\nimport asyncio\nimport mimetypes\nfrom aiohttp import web, ClientSession\nfrom kenny2automate.utils import DummyCtx\nfrom kenny2automate.i18n import LANG, i18n\n\nDISCORD_API = 'https://discordapp.com/api/v6'\nLANG = {i: i18n(i, 'qqq') for i in LANG}\nONE_YEAR = 31557600\nGLOBAL_GAMES = [\n    'Go Fish', 'Connect 4',\n    'Fight', 'Boggle', 'Uno',\n    'Blackjack', 'Set', 'Chess',\n    '007', 'Big Two'\n]\n\nclass Handler:\n    dtx = DummyCtx(author=DummyCtx(name='(server)'))\n\n    def __init__(\n            self, bot, db, logger, prefix,\n            client_id, client_secret, web_root,\n            document_root=os.path.abspath(os.path.dirname(__file__))\n    ):\n        self.bot = bot\n        self.db = db\n        self.logger = logger\n        self.prefix = prefix\n        self.sessions = {}\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.web_root = web_root\n        self.root = document_root\n        self.app = web.Application()\n        self.app.add_routes([\n            web.get('/', self.index),\n            web.get('/login', self.login),\n            web.get('/settings', self.settings),\n            web.post('/settings', self.save_settings),\n            web.get('/servers', self.servers),\n            web.get(r'/servers/{server:\\d+}', self.server),\n            web.post(r'/servers/{server:\\d+}', self.save_server),\n            web.get(r'/{name:.+(?<!\\.html|..\\.py)$}', self.file),\n            web.get(r'/{name:.*}', self.notfound)\n        ])\n\n    def fil(self, path):\n        return os.path.join(self.root, path)\n\n    async def run(self):\n        for k in self.db.execute('SELECT session_id FROM server_sessions').fetchall():\n            self.sessions[k[0]] = ClientSession()\n        self.runner = web.AppRunner(self.app)\n        await self.runner.setup()\n        site = web.TCPSite(self.runner, '0.0.0.0', 8080)\n        await site.start()\n\n    def run_sync(self):\n        async def wakeup():\n            while 1:\n                try:\n                    await asyncio.sleep(1)\n                except:\n                    return\n        asyncio.get_event_loop().run_until_complete(self.run())\n        asyncio.get_event_loop().run_until_complete(wakeup())\n        asyncio.get_event_loop().run_until_complete(self.stop())\n\n    async def stop(self):\n        await self.runner.cleanup()\n        for s in self.sessions.values():\n            await s.close()\n\n    async def checksesh(self, request, resp=None):\n        sesh = request.cookies.get('session', sha256((request.remote + str(time.time())).encode('ascii')).hexdigest())\n        sess = self.getsesh(sesh)\n        if (\n                not sess\n                or time.time() - sess['last_use'] > ONE_YEAR\n        ):\n            sess = {\n                'logged_in': None,\n                'last_use': time.time(),\n                'state': str(time.time())\n            }\n            if resp is not None:\n                resp.set_cookie('session', sesh, max_age=ONE_YEAR)\n                resp.set_cookie('state', sess['state'], max_age=ONE_YEAR)\n            self.setsesh(sesh, sess)\n            return sesh\n        if sess['logged_in'] is not None:\n            if time.time() > sess['logged_in'] + sess['expires_in']:\n                data = {\n                    'client_id': self.client_id,\n                    'client_secret': self.client_secret,\n                    'grant_type': 'refresh_token',\n                    'refresh_token': sess['refresh_token'],\n                    'redirect_uri': self.web_root + '/login',\n                    'scope': 'identify guilds'\n                }\n                async with self.sessions[sesh].post(\n                    DISCORD_API + '/oauth2/token',\n                    data=data,\n                    headers={'Content-Type':'application/x-www-form-urlencoded'}\n                ) as r:\n                    body = await r.json()\n                    body['logged_in'] = time.time()\n                    sess.update(body)\n                await self.sessions[sesh].close()\n                self.sessions[sesh] = ClientSession(headers={\n                    'Authorization': '{} {}'.format(\n                        sess['token_type'], sess['access_token']\n                    )\n                })\n        sess['last_use'] = time.time()\n        self.setsesh(sesh, sess)\n        return None\n\n    def getsesh(self, request):\n        if not isinstance(request, str):\n            request = request.cookies.get('session', None)\n            if request is None:\n                return {}\n        return (self.db.execute(\n            'SELECT session FROM server_sessions WHERE session_id=?',\n            (request,)\n        ).fetchone() or ([{}],))[0][0]\n\n    def setsesh(self, request, sesh):\n        if not isinstance(request, str):\n            request = request.cookies.get('session', None)\n            if request is None:\n                return\n        if not self.getsesh(request):\n            self.db.execute(\n                'INSERT INTO server_sessions VALUES (?, ?)',\n                (request, [sesh])\n            )\n            self.sessions[request] = ClientSession()\n        else:\n            self.db.execute(\n                'UPDATE server_sessions SET session=? WHERE session_id=?',\n                ([sesh], request)\n            )\n\n    def checkuser(self, user_id):\n        res = self.db.execute(\n            'SELECT user_id FROM users WHERE user_id=?',\n            (user_id,)\n        ).fetchone()\n        if res is None:\n            self.db.execute(\n                'INSERT INTO users (user_id) VALUES (?)',\n                (user_id,)\n            )\n\n    def logged_in(self, request):\n        return self.getsesh(request).get('logged_in', None) is not None\n\n    def notfound(self, *_):\n        raise web.HTTPNotFound(\n            text=self.letext('404.html'),\n            content_type='text/html'\n        )\n\n    async def elg(self, request):\n        if (await self.checksesh(request)) is not None:\n            if request.method != 'GET':\n                raise web.HTTPSeeOther(str(request.path))\n            self.notfound()\n        if not self.logged_in(request):\n            self.notfound()\n\n    def lang(self, request):\n        if not self.logged_in(request):\n            available = set(LANG.keys())\n            preferred = (j[0] for j in sorted((\n                (i.group(1), float(i.group(2) or '1'))\n                for i in re.finditer(\n                    r'(?<![a-z])([a-z][a-z](?:-[a-z]+|[a-z])?)(?:\\s*;\\s*q=('\n                    r'[01](?:\\.[0-9])?))?(?:,\\s*|$)',\n                    request.headers.get('Accept-Language') or '',\n                    re.I\n                )\n            ), key=lambda i: i[1], reverse=True))\n            for i in preferred:\n                if i in available:\n                    return i\n            return 'en'\n        sesh = self.getsesh(request)\n        self.checkuser(sesh['client']['id'])\n        res = self.db.execute(\n            'SELECT lang FROM users WHERE user_id=?',\n            (sesh['client']['id'],)\n        ).fetchone()\n        if res is None or res['lang'] is None:\n            return 'en'\n        return res['lang']\n\n    def letext(self, filename, title='kenny2automate'):\n        with open(self.fil('template.html')) as f1, open(self.fil(filename)) as f2:\n            return f1.read().format(title, f2.read())\n\n    async def index(self, request):\n        resp = web.Response(content_type='text/html')\n        sesh = await self.checksesh(request, resp)\n        lan = self.lang(request)\n        if not self.logged_in(request):\n            resp.text = self.letext(\n                'notloggedin.html',\n                i18n(lan, 'server/notloggedin;h1')\n            ).format(\n                self.getsesh(sesh or request)['state'],\n                self.client_id,\n                urlquote(self.web_root + '/login'),\n                h1=i18n(lan, 'server/notloggedin;h1'),\n                p=i18n(lan, 'server/notloggedin;p'),\n                login=i18n(lan, 'server/notloggedin;login')\n            )\n            return resp\n        h1 = i18n(\n            lan, 'server/index;h1',\n            self.getsesh(request)['client']['username']\n        )\n        resp.text = self.letext(\n            'index.html',\n            h1\n        ).format(\n            h1=h1,\n            settings=i18n(lan, 'server/index;settings'),\n            servers=i18n(lan, 'server/index;servers')\n        )\n        return resp\n\n    async def login(self, request):\n        #if (\n        #        (await self.checksesh(request)) is not None\n        #        or 'code' not in request.query\n        #        or self.getsesh(request)['state'] != request.query.get('state', '')\n        #):\n        #    self.notfound()\n        sesh = await self.checksesh(request)\n        if sesh is not None:\n            self.notfound()\n        if 'code' not in request.query:\n            self.notfound()\n        if self.getsesh(request)['state'] != request.query.get('state', ''):\n            self.notfound()\n        sesh = request.cookies['session']\n        sess = self.getsesh(request)\n        data = {\n            'client_id': self.client_id,\n            'client_secret': self.client_secret,\n            'grant_type': 'authorization_code',\n            'code': request.query['code'],\n            'redirect_uri': self.web_root + '/login',\n            'scope': 'identify guilds'\n        }\n        async with self.sessions[sesh].post(\n                DISCORD_API + '/oauth2/token',\n                data=data\n        ) as resp:\n            body = await resp.json()\n            body['logged_in'] = time.time()\n            sess.update(body)\n        await self.sessions[sesh].close()\n        self.sessions[sesh] = ClientSession(headers={\n            'Authorization': '{} {}'.format(\n                sess['token_type'], sess['access_token']\n            )\n        })\n        async with self.sessions[sesh].get(DISCORD_API + '/users/@me') as resp:\n            sess['client'] = await resp.json()\n            sess['client']['id'] = int(sess['client']['id'])\n        async with self.sessions[sesh].get(DISCORD_API + '/users/@me/guilds') as resp:\n            sess['servers'] = await resp.json()\n        self.setsesh(request, sess)\n        resp = web.HTTPSeeOther('/')\n        resp.set_cookie('code', request.query['code'])\n        raise resp\n\n    async def settings(self, request):\n        await self.elg(request)\n        user_id = self.getsesh(request)['client']['id']\n        self.checkuser(user_id)\n        data = self.db.execute(\n            'SELECT prefix, lang, games_ping FROM users WHERE user_id=?',\n            (user_id,)\n        ).fetchone()\n        if data is not None:\n            prefix, lang, games = data\n        else:\n            prefix, lang, games = data, data, data\n        if prefix is None:\n            prefix = self.prefix\n        games = (games or '').split('|')\n        options = ''.join('<option value=\"{}\"{}>{}</option>'.format(\n            i, ' selected' if i == lang else '', j\n        ) for i, j in LANG.items())\n        options = '<option value=\"\"{}>{}</option>'.format(\n            ' selected' if lang is None else '',\n            i18n(lang or 'en', 'server/lang-auto')\n        ) + options\n        ping_th = ''.join(\n            '<th>{}</th>'.format(i)\n            for i in GLOBAL_GAMES\n        )\n        ping_th = '<tr><th colspan=\"{}\">{}</th></tr>\\n<tr>'.format(\n            len(GLOBAL_GAMES),\n            i18n(lang or 'en', 'server/ping-message')\n        ) + ping_th + '</tr>'\n        ping_options = '\\n'.join(\n            \"\"\"        <td><label class=\"switch\">\n        <input name=\"ping\" type=\"checkbox\" value=\"{}\" {}/>\n        <span class=\"slider\"></span>\n    </label></td>\"\"\".format(g, 'checked ' if g in games else '')\n            for g in GLOBAL_GAMES\n        )\n        return web.Response(\n            text=self.letext(\n                'settings.html',\n                i18n(lang or 'en', 'server/settings;h1')\n            ).format(\n                escape(prefix),\n                options,\n                ping_th,\n                ping_options,\n                h1=i18n(lang or 'en', 'server/settings;h1'),\n                prefix=i18n(lang or 'en', 'server/settings;prefix'),\n                lang=i18n(lang or 'en', 'server/settings;lang'),\n                save=i18n(lang or 'en', 'server/server;save'),\n                back=i18n(lang or 'en', 'server/server;back'),\n            ),\n            content_type='text/html'\n        )\n\n    async def save_settings(self, request):\n        await self.elg(request)\n        data = await request.post()\n        for k in ('prefix', 'lang', 'ping'):\n            if k not in data:\n                self.notfound()\n        user_id = self.getsesh(request)['client']['id']\n        self.checkuser(user_id)\n        with self.db.connection:\n            self.db.execute(\n                'UPDATE users SET prefix=?, lang=?, games_ping=? WHERE user_id=?',\n                (\n                    data['prefix'] if data['prefix'].strip() else None,\n                    data['lang'].strip() or None,\n                    '|'.join(data.getall('ping')),\n                    user_id\n                )\n            )\n        raise web.HTTPSeeOther(str(request.path))\n\n    async def servers(self, request):\n        await self.elg(request)\n        sess = self.getsesh(request)\n        lan = self.lang(request)\n        guilds = tuple(filter(\n            lambda i: (\n                i and i.get_member(\n                    int(sess['client']['id'])\n                ).guild_permissions.administrator\n            ), (\n                self.bot.get_guild(int(i['id']))\n                for i in sess['servers']\n            )\n        ))\n        options = '<span class=\"spacer\"></span>'.join(\"\"\"\n<a class=\"guild\" href=\"{}/{}\" title=\"{}\">\n    <img src=\"{}\" />\n</a>\n\"\"\".strip().format(\n            str(request.path), i.id, escape(i.name), i.icon_url_as(format='png', size=64)\n        ) for i in guilds)\n        return web.Response(\n            text=self.letext(\n                'servers.html',\n                i18n(lan, 'server/servers;h1')\n            ).format(\n                options,\n                h1=i18n(lan, 'server/servers;h1'),\n                div=i18n(lan, 'server/servers;div'),\n                back=i18n(lan, 'server/server;back'),\n            ),\n            content_type='text/html'\n        )\n\n    async def server(self, request):\n        await self.elg(request)\n        guild = self.bot.get_guild(int(request.match_info.get('server', '0')))\n        if guild is None:\n            self.notfound()\n        if not guild.get_member(\n            int(self.getsesh(request)['client']['id'])\n        ).guild_permissions.administrator:\n            self.notfound()\n        lan = self.lang(request)\n        options = \"\"\"\n        <tr>\n            <th rowspan=\"2\">{}</th>\n            <th rowspan=\"2\">{}</th>\n            <th colspan=\"{}\">{}</th>\n        </tr><tr>\n            {}\n        </tr>\"\"\".format(\n            i18n(lan, 'server/server;channel'),\n            i18n(lan, 'server/server;language'),\n            len(GLOBAL_GAMES),\n            i18n(lan, 'server/ping-message'),\n            '\\n'.join('<td>{}</td>'.format(i) for i in GLOBAL_GAMES),\n        )\n        non = i18n(lan, 'server/lang-none')\n        for i in guild.text_channels:\n            lang = self.db.execute(\n                'SELECT lang, games_ping FROM channels WHERE channel_id=?',\n                (i.id,)\n            ).fetchone()\n            if lang is None:\n                self.db.execute(\n                    'INSERT INTO channels (channel_id) VALUES (?)',\n                    (i.id,)\n                )\n                lang, games = lang, []\n            else:\n                lang, games = lang\n                games = (games or '').split('|')\n            lang_options = '\\n'.join('<option value=\"lang={}\"{}>{}</option>'.format(\n                a, ' selected' if a == lang else '', b\n            ) for a, b in LANG.items())\n            lang_options = '<option value=\"lang=\"{}>{}</option>\\n'.format(\n                ' selected' if lang is None else '', non\n            ) + lang_options\n            ping_options = '\\n'.join(\n                \"\"\"        <td><label class=\"switch\">\n            <input name=\"channel-{0}\" type=\"checkbox\" value=\"ping={1}\" {2}/>\n            <span class=\"slider\"></span>\n        </label></td>\"\"\".format(i.id, g, 'checked ' if g in games else '')\n                for g in GLOBAL_GAMES\n            )\n            options += \"\"\"\n    <tr>\n        <td class=\"channel\"><div># {0}</div></td>\n        <td><select name=\"channel-{1}\">\n            {2}\n        </select></td>\n        {3}\n    </div></td></tr>\"\"\".format(\n                i.name, i.id, lang_options, ping_options\n            )\n        res = self.db.execute(\n            'SELECT guild_disabled_commands, guild_disabled_cogs, words_censor \\\nFROM guilds WHERE guild_id=?',\n            (guild.id,)\n        ).fetchone()\n        if res is None:\n            cmds, cogs, censor = [], [], ''\n            self.db.execute(\n                'INSERT INTO guilds (guild_id) VALUES (?)',\n                (guild.id,)\n            )\n        else:\n            cmds, cogs, censor = res\n            cmds = (cmds or '').split(',')\n            cogs = (cogs or '').split(',')\n            censor = censor or ''\n        dcmds = ''\n        def recurse_commands(thing):\n            nonlocal dcmds\n            if hasattr(thing, 'commands'):\n                for cmd in thing.commands:\n                    hide = False\n                    parent = cmd.parent\n                    while parent:\n                        if parent.qualified_name in cmds:\n                            hide = True\n                            break\n                        parent = parent.parent\n                    dcmds += \"\"\"\n            <option\n                data-parent=\"{parent}\"\n                data-cog=\"{cog}\"\n                value=\"{option}\"\n                style=\"{display}\"\n            >\n                {prefix}{option}\n            </option>\"\"\".format(\n                        option=cmd.qualified_name,\n                        parent=cmd.parent.qualified_name if cmd.parent else '',\n                        cog=cmd.cog_name or 'None',\n                        display=(\n                            'display: none'\n                            if (\n                                hide or cmd.cog_name in cogs\n                            )\n                            else ''\n                        ),\n                        prefix=self.bot.command_prefix(self.bot, None)\n                    )\n                    recurse_commands(cmd)\n        recurse_commands(self.bot)\n        dcogs = \"\"\"\n    <option value=\"None\">\n        {}\n    </option>\"\"\".format(non)\n        for cog in self.bot.cogs.keys():\n            dcogs += \"\"\"\n    <option value={option}>\n        {option}\n    </option>\"\"\".format(option=cog)\n        h1 = i18n(lan, 'server/server;h1', escape(guild.name))\n        return web.Response(\n            text=self.letext(\n                'server.html',\n                h1\n            ).format(\n                channels=options,\n                cmds=dcmds,\n                cogs=dcogs,\n                dcmds=cmds,\n                dcogs=cogs,\n                jcmds=','.join(cmds),\n                jcogs=','.join(cogs),\n                words_censor=i18n(\n                    lan, 'words/server-censor-title',\n                    '<code>{}{}</code>'.format(\n                        self.bot.command_prefix(self.bot, None),\n                        'words'\n                    ),\n                ),\n                censor=censor,\n                cmd=i18n(lan, 'server/server;command'),\n                cog=i18n(lan, 'server/server;cog'),\n                disabled=i18n(lan, 'server/server;disabled'),\n                h1=h1,\n                save=i18n(lan, 'server/server;save'),\n                back=i18n(lan, 'server/server;back'),\n            ),\n            content_type='text/html'\n        )\n\n    async def save_server(self, request):\n        await self.elg(request)\n        guild = self.bot.get_guild(int(request.match_info.get('server', '0')))\n        if guild is None:\n            self.notfound()\n        if not guild.get_member(\n            int(self.getsesh(request)['client']['id'])\n        ).guild_permissions.administrator:\n            self.notfound()\n        data = await request.post()\n        params = []\n        otherparams = {}\n        for k in data.keys():\n            if not k.startswith('channel-'):\n                otherparams[k] = ','.join(data.getall(k))\n                continue\n            param = {'channel_id': int(k[len('channel-'):])}\n            for v in data.getall(k):\n                v = v.partition('=')\n                if v[0] == 'ping':\n                    if 'ping' not in param:\n                        param['ping'] = set()\n                    param['ping'].add(v[-1])\n                else:\n                    param[v[0]] = v[-1] or None\n            param['ping'] = '|'.join(param.get('ping', ())) or None\n            params.append(param)\n        otherparams['guild_id'] = guild.id\n        try:\n            with self.db.connection:\n                self.db.executemany(\n                    'UPDATE channels SET lang=:lang, games_ping=:ping \\\nWHERE channel_id=:channel_id',\n                    params\n                )\n                self.db.execute(\n                    'UPDATE guilds SET guild_disabled_commands=:disable_cmd, \\\nguild_disabled_cogs=:disable_cog, words_censor=:words_censor WHERE guild_id=:guild_id',\n                    otherparams\n                )\n        except sql.ProgrammingError as exc:\n            raise web.HTTPBadRequest(reason=str(exc))\n        raise web.HTTPSeeOther(request.path)\n\n    async def file(self, request):\n        path = request.match_info.get('name', '.html') or '.html'\n        fullpath = self.fil(path)\n        if os.path.isfile(fullpath):\n            with open(fullpath, 'rb') as f:\n                #self.logger.info('Request serving: {}'.format(path), extra={'ctx': self.dtx})\n                return web.Response(\n                    status=200,\n                    body=f.read(),\n                    content_type=mimetypes.guess_type(fullpath)[0]\n                )\n        else:\n            #self.logger.error('Request not served, 404: {}'.format(path), extra={'ctx': self.dtx})\n            self.notfound()\n\n#Handler(None, None, None, 512581527343726592, 't5jgg5udqQrdiJe_bKHrn0VrEDMztpZ7').run_sync()\n"], "fixing_code": ["import os\nimport re\nimport time\nfrom html import escape\nfrom urllib.parse import quote_plus as urlquote\nimport sqlite3 as sql\nfrom hashlib import sha256\nimport asyncio\nimport mimetypes\nfrom aiohttp import web, ClientSession\nfrom kenny2automate.utils import DummyCtx\nfrom kenny2automate.i18n import LANG, i18n\n\nDISCORD_API = 'https://discordapp.com/api/v6'\nLANG = {i: i18n(i, 'qqq') for i in LANG}\nONE_YEAR = 31557600\nGLOBAL_GAMES = [\n    'Go Fish', 'Connect 4',\n    'Fight', 'Boggle', 'Uno',\n    'Blackjack', 'Set', 'Chess',\n    '007', 'Big Two'\n]\n\nclass Handler:\n    dtx = DummyCtx(author=DummyCtx(name='(server)'))\n\n    def __init__(\n            self, bot, db, logger, prefix,\n            client_id, client_secret, web_root,\n            document_root=os.path.abspath(os.path.dirname(__file__))\n    ):\n        self.bot = bot\n        self.db = db\n        self.logger = logger\n        self.prefix = prefix\n        self.sessions = {}\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.web_root = web_root\n        self.root = document_root\n        self.app = web.Application()\n        self.app.add_routes([\n            web.get('/', self.index),\n            web.get('/login', self.login),\n            web.get('/settings', self.settings),\n            web.post('/settings', self.save_settings),\n            web.get('/servers', self.servers),\n            web.get(r'/servers/{server:\\d+}', self.server),\n            web.post(r'/servers/{server:\\d+}', self.save_server),\n            web.get(r'/{name:.+(?<!\\.html|..\\.py)$}', self.file),\n            web.get(r'/{name:.*}', self.notfound)\n        ])\n\n    def fil(self, path):\n        return os.path.join(self.root, path)\n\n    async def run(self):\n        for k in self.db.execute('SELECT session_id FROM server_sessions').fetchall():\n            self.sessions[k[0]] = ClientSession()\n        self.runner = web.AppRunner(self.app)\n        await self.runner.setup()\n        site = web.TCPSite(self.runner, '0.0.0.0', 8080)\n        await site.start()\n\n    def run_sync(self):\n        async def wakeup():\n            while 1:\n                try:\n                    await asyncio.sleep(1)\n                except:\n                    return\n        asyncio.get_event_loop().run_until_complete(self.run())\n        asyncio.get_event_loop().run_until_complete(wakeup())\n        asyncio.get_event_loop().run_until_complete(self.stop())\n\n    async def stop(self):\n        await self.runner.cleanup()\n        for s in self.sessions.values():\n            await s.close()\n\n    async def checksesh(self, request, resp=None):\n        sesh = request.cookies.get('session', sha256((request.remote + str(time.time())).encode('ascii')).hexdigest())\n        sess = self.getsesh(sesh)\n        if (\n                not sess\n                or time.time() - sess['last_use'] > ONE_YEAR\n        ):\n            sess = {\n                'logged_in': None,\n                'last_use': time.time(),\n                'state': str(time.time())\n            }\n            if resp is not None:\n                resp.set_cookie('session', sesh, max_age=ONE_YEAR)\n                resp.set_cookie('state', sess['state'], max_age=ONE_YEAR)\n            self.setsesh(sesh, sess)\n            return sesh\n        if sess['logged_in'] is not None:\n            if time.time() > sess['logged_in'] + sess['expires_in']:\n                data = {\n                    'client_id': self.client_id,\n                    'client_secret': self.client_secret,\n                    'grant_type': 'refresh_token',\n                    'refresh_token': sess['refresh_token'],\n                    'redirect_uri': self.web_root + '/login',\n                    'scope': 'identify guilds'\n                }\n                async with self.sessions[sesh].post(\n                    DISCORD_API + '/oauth2/token',\n                    data=data,\n                    headers={'Content-Type':'application/x-www-form-urlencoded'}\n                ) as r:\n                    body = await r.json()\n                    body['logged_in'] = time.time()\n                    sess.update(body)\n                await self.sessions[sesh].close()\n                self.sessions[sesh] = ClientSession(headers={\n                    'Authorization': '{} {}'.format(\n                        sess['token_type'], sess['access_token']\n                    )\n                })\n        sess['last_use'] = time.time()\n        self.setsesh(sesh, sess)\n        return None\n\n    def getsesh(self, request):\n        if not isinstance(request, str):\n            request = request.cookies.get('session', None)\n            if request is None:\n                return {}\n        return (self.db.execute(\n            'SELECT session FROM server_sessions WHERE session_id=?',\n            (request,)\n        ).fetchone() or ([{}],))[0][0]\n\n    def setsesh(self, request, sesh):\n        if not isinstance(request, str):\n            request = request.cookies.get('session', None)\n            if request is None:\n                return\n        if not self.getsesh(request):\n            self.db.execute(\n                'INSERT INTO server_sessions VALUES (?, ?)',\n                (request, [sesh])\n            )\n            self.sessions[request] = ClientSession()\n        else:\n            self.db.execute(\n                'UPDATE server_sessions SET session=? WHERE session_id=?',\n                ([sesh], request)\n            )\n\n    def checkuser(self, user_id):\n        res = self.db.execute(\n            'SELECT user_id FROM users WHERE user_id=?',\n            (user_id,)\n        ).fetchone()\n        if res is None:\n            self.db.execute(\n                'INSERT INTO users (user_id) VALUES (?)',\n                (user_id,)\n            )\n\n    def logged_in(self, request):\n        return self.getsesh(request).get('logged_in', None) is not None\n\n    def notfound(self, *_):\n        raise web.HTTPNotFound(\n            text=self.letext('404.html'),\n            content_type='text/html'\n        )\n\n    async def elg(self, request):\n        if (await self.checksesh(request)) is not None:\n            if request.method != 'GET':\n                raise web.HTTPSeeOther(str(request.path))\n            self.notfound()\n        if not self.logged_in(request):\n            self.notfound()\n\n    def lang(self, request):\n        if not self.logged_in(request):\n            available = set(LANG.keys())\n            preferred = (j[0] for j in sorted((\n                (i.group(1), float(i.group(2) or '1'))\n                for i in re.finditer(\n                    r'(?<![a-z])([a-z][a-z](?:-[a-z]+|[a-z])?)(?:\\s*;\\s*q=('\n                    r'[01](?:\\.[0-9])?))?(?:,\\s*|$)',\n                    request.headers.get('Accept-Language') or '',\n                    re.I\n                )\n            ), key=lambda i: i[1], reverse=True))\n            for i in preferred:\n                if i in available:\n                    return i\n            return 'en'\n        sesh = self.getsesh(request)\n        self.checkuser(sesh['client']['id'])\n        res = self.db.execute(\n            'SELECT lang FROM users WHERE user_id=?',\n            (sesh['client']['id'],)\n        ).fetchone()\n        if res is None or res['lang'] is None:\n            return 'en'\n        return res['lang']\n\n    def letext(self, filename, title='kenny2automate'):\n        with open(self.fil('template.html')) as f1, open(self.fil(filename)) as f2:\n            return f1.read().format(title, f2.read())\n\n    async def index(self, request):\n        resp = web.Response(content_type='text/html')\n        sesh = await self.checksesh(request, resp)\n        lan = self.lang(request)\n        if not self.logged_in(request):\n            resp.text = self.letext(\n                'notloggedin.html',\n                i18n(lan, 'server/notloggedin;h1')\n            ).format(\n                self.getsesh(sesh or request)['state'],\n                self.client_id,\n                urlquote(self.web_root + '/login'),\n                h1=i18n(lan, 'server/notloggedin;h1'),\n                p=i18n(lan, 'server/notloggedin;p'),\n                login=i18n(lan, 'server/notloggedin;login')\n            )\n            return resp\n        h1 = i18n(\n            lan, 'server/index;h1',\n            self.getsesh(request)['client']['username']\n        )\n        resp.text = self.letext(\n            'index.html',\n            h1\n        ).format(\n            h1=h1,\n            settings=i18n(lan, 'server/index;settings'),\n            servers=i18n(lan, 'server/index;servers')\n        )\n        return resp\n\n    async def login(self, request):\n        #if (\n        #        (await self.checksesh(request)) is not None\n        #        or 'code' not in request.query\n        #        or self.getsesh(request)['state'] != request.query.get('state', '')\n        #):\n        #    self.notfound()\n        sesh = await self.checksesh(request)\n        if sesh is not None:\n            self.notfound()\n        if 'code' not in request.query:\n            self.notfound()\n        if self.getsesh(request)['state'] != request.query.get('state', ''):\n            self.notfound()\n        sesh = request.cookies['session']\n        sess = self.getsesh(request)\n        data = {\n            'client_id': self.client_id,\n            'client_secret': self.client_secret,\n            'grant_type': 'authorization_code',\n            'code': request.query['code'],\n            'redirect_uri': self.web_root + '/login',\n            'scope': 'identify guilds'\n        }\n        async with self.sessions[sesh].post(\n                DISCORD_API + '/oauth2/token',\n                data=data\n        ) as resp:\n            body = await resp.json()\n            body['logged_in'] = time.time()\n            sess.update(body)\n        await self.sessions[sesh].close()\n        self.sessions[sesh] = ClientSession(headers={\n            'Authorization': '{} {}'.format(\n                sess['token_type'], sess['access_token']\n            )\n        })\n        async with self.sessions[sesh].get(DISCORD_API + '/users/@me') as resp:\n            sess['client'] = await resp.json()\n            sess['client']['id'] = int(sess['client']['id'])\n        async with self.sessions[sesh].get(DISCORD_API + '/users/@me/guilds') as resp:\n            sess['servers'] = await resp.json()\n        self.setsesh(request, sess)\n        resp = web.HTTPSeeOther('/')\n        resp.set_cookie('code', request.query['code'])\n        raise resp\n\n    async def settings(self, request):\n        await self.elg(request)\n        user_id = self.getsesh(request)['client']['id']\n        self.checkuser(user_id)\n        data = self.db.execute(\n            'SELECT prefix, lang, games_ping FROM users WHERE user_id=?',\n            (user_id,)\n        ).fetchone()\n        if data is not None:\n            prefix, lang, games = data\n        else:\n            prefix, lang, games = data, data, data\n        if prefix is None:\n            prefix = self.prefix\n        games = (games or '').split('|')\n        options = ''.join('<option value=\"{}\"{}>{}</option>'.format(\n            i, ' selected' if i == lang else '', j\n        ) for i, j in LANG.items())\n        options = '<option value=\"\"{}>{}</option>'.format(\n            ' selected' if lang is None else '',\n            i18n(lang or 'en', 'server/lang-auto')\n        ) + options\n        ping_th = ''.join(\n            '<th>{}</th>'.format(i)\n            for i in GLOBAL_GAMES\n        )\n        ping_th = '<tr><th colspan=\"{}\">{}</th></tr>\\n<tr>'.format(\n            len(GLOBAL_GAMES),\n            i18n(lang or 'en', 'server/ping-message')\n        ) + ping_th + '</tr>'\n        ping_options = '\\n'.join(\n            \"\"\"        <td><label class=\"switch\">\n        <input name=\"ping\" type=\"checkbox\" value=\"{}\" {}/>\n        <span class=\"slider\"></span>\n    </label></td>\"\"\".format(g, 'checked ' if g in games else '')\n            for g in GLOBAL_GAMES\n        )\n        return web.Response(\n            text=self.letext(\n                'settings.html',\n                i18n(lang or 'en', 'server/settings;h1')\n            ).format(\n                escape(prefix),\n                options,\n                ping_th,\n                ping_options,\n                h1=i18n(lang or 'en', 'server/settings;h1'),\n                prefix=i18n(lang or 'en', 'server/settings;prefix'),\n                lang=i18n(lang or 'en', 'server/settings;lang'),\n                save=i18n(lang or 'en', 'server/server;save'),\n                back=i18n(lang or 'en', 'server/server;back'),\n            ),\n            content_type='text/html'\n        )\n\n    async def save_settings(self, request):\n        await self.elg(request)\n        data = await request.post()\n        for k in ('prefix', 'lang', 'ping'):\n            if k not in data:\n                self.notfound()\n        user_id = self.getsesh(request)['client']['id']\n        self.checkuser(user_id)\n        with self.db.connection:\n            self.db.execute(\n                'UPDATE users SET prefix=?, lang=?, games_ping=? WHERE user_id=?',\n                (\n                    data['prefix'] if data['prefix'].strip() else None,\n                    data['lang'].strip() or None,\n                    '|'.join(data.getall('ping')),\n                    user_id\n                )\n            )\n        raise web.HTTPSeeOther(str(request.path))\n\n    async def servers(self, request):\n        await self.elg(request)\n        sess = self.getsesh(request)\n        lan = self.lang(request)\n        guilds = tuple(filter(\n            lambda i: (\n                i and i.get_member(\n                    int(sess['client']['id'])\n                ).guild_permissions.administrator\n            ), (\n                self.bot.get_guild(int(i['id']))\n                for i in sess['servers']\n            )\n        ))\n        options = '<span class=\"spacer\"></span>'.join(\"\"\"\n<a class=\"guild\" href=\"{}/{}\" title=\"{}\">\n    <img src=\"{}\" />\n</a>\n\"\"\".strip().format(\n            str(request.path), i.id, escape(i.name), i.icon_url_as(format='png', size=64)\n        ) for i in guilds)\n        return web.Response(\n            text=self.letext(\n                'servers.html',\n                i18n(lan, 'server/servers;h1')\n            ).format(\n                options,\n                h1=i18n(lan, 'server/servers;h1'),\n                div=i18n(lan, 'server/servers;div'),\n                back=i18n(lan, 'server/server;back'),\n            ),\n            content_type='text/html'\n        )\n\n    async def server(self, request):\n        await self.elg(request)\n        guild = self.bot.get_guild(int(request.match_info.get('server', '0')))\n        if guild is None:\n            self.notfound()\n        if not guild.get_member(\n            int(self.getsesh(request)['client']['id'])\n        ).guild_permissions.administrator:\n            self.notfound()\n        lan = self.lang(request)\n        options = \"\"\"\n        <tr>\n            <th rowspan=\"2\">{}</th>\n            <th rowspan=\"2\">{}</th>\n            <th colspan=\"{}\">{}</th>\n        </tr><tr>\n            {}\n        </tr>\"\"\".format(\n            i18n(lan, 'server/server;channel'),\n            i18n(lan, 'server/server;language'),\n            len(GLOBAL_GAMES),\n            i18n(lan, 'server/ping-message'),\n            '\\n'.join('<td>{}</td>'.format(i) for i in GLOBAL_GAMES),\n        )\n        non = i18n(lan, 'server/lang-none')\n        for i in guild.text_channels:\n            lang = self.db.execute(\n                'SELECT lang, games_ping FROM channels WHERE channel_id=?',\n                (i.id,)\n            ).fetchone()\n            if lang is None:\n                self.db.execute(\n                    'INSERT INTO channels (channel_id) VALUES (?)',\n                    (i.id,)\n                )\n                lang, games = lang, []\n            else:\n                lang, games = lang\n                games = (games or '').split('|')\n            lang_options = '\\n'.join('<option value=\"lang={}\"{}>{}</option>'.format(\n                a, ' selected' if a == lang else '', b\n            ) for a, b in LANG.items())\n            lang_options = '<option value=\"lang=\"{}>{}</option>\\n'.format(\n                ' selected' if lang is None else '', non\n            ) + lang_options\n            ping_options = '\\n'.join(\n                \"\"\"        <td><label class=\"switch\">\n            <input name=\"channel-{0}\" type=\"checkbox\" value=\"ping={1}\" {2}/>\n            <span class=\"slider\"></span>\n        </label></td>\"\"\".format(i.id, g, 'checked ' if g in games else '')\n                for g in GLOBAL_GAMES\n            )\n            options += \"\"\"\n    <tr>\n        <td class=\"channel\"><div># {0}</div></td>\n        <td><select name=\"channel-{1}\">\n            {2}\n        </select></td>\n        {3}\n    </div></td></tr>\"\"\".format(\n                i.name, i.id, lang_options, ping_options\n            )\n        res = self.db.execute(\n            'SELECT guild_disabled_commands, guild_disabled_cogs, words_censor \\\nFROM guilds WHERE guild_id=?',\n            (guild.id,)\n        ).fetchone()\n        if res is None:\n            cmds, cogs, censor = [], [], ''\n            self.db.execute(\n                'INSERT INTO guilds (guild_id) VALUES (?)',\n                (guild.id,)\n            )\n        else:\n            cmds, cogs, censor = res\n            cmds = (cmds or '').split(',')\n            cogs = (cogs or '').split(',')\n            censor = censor or ''\n        dcmds = ''\n        def recurse_commands(thing):\n            nonlocal dcmds\n            if hasattr(thing, 'commands'):\n                for cmd in thing.commands:\n                    hide = False\n                    parent = cmd.parent\n                    while parent:\n                        if parent.qualified_name in cmds:\n                            hide = True\n                            break\n                        parent = parent.parent\n                    dcmds += \"\"\"\n            <option\n                data-parent=\"{parent}\"\n                data-cog=\"{cog}\"\n                value=\"{option}\"\n                style=\"{display}\"\n            >\n                {prefix}{option}\n            </option>\"\"\".format(\n                        option=cmd.qualified_name,\n                        parent=cmd.parent.qualified_name if cmd.parent else '',\n                        cog=cmd.cog_name or 'None',\n                        display=(\n                            'display: none'\n                            if (\n                                hide or cmd.cog_name in cogs\n                            )\n                            else ''\n                        ),\n                        prefix=self.bot.command_prefix(self.bot, None)\n                    )\n                    recurse_commands(cmd)\n        recurse_commands(self.bot)\n        dcogs = \"\"\"\n    <option value=\"None\">\n        {}\n    </option>\"\"\".format(non)\n        for cog in self.bot.cogs.keys():\n            dcogs += \"\"\"\n    <option value={option}>\n        {option}\n    </option>\"\"\".format(option=cog)\n        h1 = i18n(lan, 'server/server;h1', escape(guild.name))\n        return web.Response(\n            text=self.letext(\n                'server.html',\n                h1\n            ).format(\n                channels=options,\n                cmds=dcmds,\n                cogs=dcogs,\n                dcmds=cmds,\n                dcogs=cogs,\n                jcmds=','.join(cmds),\n                jcogs=','.join(cogs),\n                words_censor=i18n(\n                    lan, 'words/server-censor-title',\n                    '<code>{}{}</code>'.format(\n                        self.bot.command_prefix(self.bot, None),\n                        'words'\n                    ),\n                ),\n                censor=censor,\n                cmd=i18n(lan, 'server/server;command'),\n                cog=i18n(lan, 'server/server;cog'),\n                disabled=i18n(lan, 'server/server;disabled'),\n                h1=h1,\n                save=i18n(lan, 'server/server;save'),\n                back=i18n(lan, 'server/server;back'),\n            ),\n            content_type='text/html'\n        )\n\n    async def save_server(self, request):\n        await self.elg(request)\n        guild = self.bot.get_guild(int(request.match_info.get('server', '0')))\n        if guild is None:\n            self.notfound()\n        if not guild.get_member(\n            int(self.getsesh(request)['client']['id'])\n        ).guild_permissions.administrator:\n            self.notfound()\n        data = await request.post()\n        params = []\n        otherparams = {}\n        for k in data.keys():\n            if not k.startswith('channel-'):\n                otherparams[k] = ','.join(data.getall(k))\n                continue\n            param = {'channel_id': int(k[len('channel-'):])}\n            for v in data.getall(k):\n                v = v.partition('=')\n                if v[0] == 'ping':\n                    if 'ping' not in param:\n                        param['ping'] = set()\n                    param['ping'].add(v[-1])\n                else:\n                    param[v[0]] = v[-1] or None\n            param['ping'] = '|'.join(param.get('ping', ())) or None\n            params.append(param)\n        otherparams['guild_id'] = guild.id\n        if set(param['channel_id'] for param in params) \\\n                - set(channel.id for channel in guild.channels): # is not empty\n            raise web.HTTPBadRequest\n        try:\n            with self.db.connection:\n                self.db.executemany(\n                    'UPDATE channels SET lang=:lang, games_ping=:ping \\\nWHERE channel_id=:channel_id',\n                    params\n                )\n                self.db.execute(\n                    'UPDATE guilds SET guild_disabled_commands=:disable_cmd, \\\nguild_disabled_cogs=:disable_cog, words_censor=:words_censor WHERE guild_id=:guild_id',\n                    otherparams\n                )\n        except sql.ProgrammingError as exc:\n            raise web.HTTPBadRequest(reason=str(exc))\n        raise web.HTTPSeeOther(request.path)\n\n    async def file(self, request):\n        path = request.match_info.get('name', '.html') or '.html'\n        fullpath = self.fil(path)\n        if os.path.isfile(fullpath):\n            with open(fullpath, 'rb') as f:\n                #self.logger.info('Request serving: {}'.format(path), extra={'ctx': self.dtx})\n                return web.Response(\n                    status=200,\n                    body=f.read(),\n                    content_type=mimetypes.guess_type(fullpath)[0]\n                )\n        else:\n            #self.logger.error('Request not served, 404: {}'.format(path), extra={'ctx': self.dtx})\n            self.notfound()\n\n#Handler(None, None, None, 512581527343726592, 't5jgg5udqQrdiJe_bKHrn0VrEDMztpZ7').run_sync()\n"], "filenames": ["kenny2automate/server/__init__.py"], "buggy_code_start_loc": [578], "buggy_code_end_loc": [578], "fixing_code_start_loc": [579], "fixing_code_end_loc": [582], "type": "CWE-20", "message": "kenny2automate is a Discord bot. In the web interface for server settings, form elements were generated with Discord channel IDs as part of input names. Prior to commit a947d7c, no validation was performed to ensure that the channel IDs submitted actually belonged to the server being configured. Thus anyone who has access to the channel ID they wish to change settings for and the server settings panel for any server could change settings for the requested channel no matter which server it belonged to. Commit a947d7c resolves the issue and has been deployed to the official instance of the bot. The only workaround that exists is to disable the web config entirely by changing it to run on localhost. Note that a workaround is only necessary for those who run their own instance of the bot.", "other": {"cve": {"id": "CVE-2023-22452", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-02T20:15:10.163", "lastModified": "2023-01-09T19:53:15.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "kenny2automate is a Discord bot. In the web interface for server settings, form elements were generated with Discord channel IDs as part of input names. Prior to commit a947d7c, no validation was performed to ensure that the channel IDs submitted actually belonged to the server being configured. Thus anyone who has access to the channel ID they wish to change settings for and the server settings panel for any server could change settings for the requested channel no matter which server it belonged to. Commit a947d7c resolves the issue and has been deployed to the official instance of the bot. The only workaround that exists is to disable the web config entirely by changing it to run on localhost. Note that a workaround is only necessary for those who run their own instance of the bot."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kenny2automate_project:kenny2automate:*:*:*:*:*:*:*:*", "versionEndExcluding": "a947d7c", "matchCriteriaId": "096ADE91-2218-4D24-9731-D0B8EA5432FE"}]}]}], "references": [{"url": "https://github.com/Kenny2github/kenny2automate/commit/a947d7ce408687b587c7e6dfd6026f7c4ee31ac2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Kenny2github/kenny2automate/security/advisories/GHSA-73j8-xrcr-q6j7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Kenny2github/kenny2automate/commit/a947d7ce408687b587c7e6dfd6026f7c4ee31ac2"}}