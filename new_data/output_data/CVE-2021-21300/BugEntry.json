{"buggy_code": ["#ifndef CACHE_H\n#define CACHE_H\n\n#include \"git-compat-util.h\"\n#include \"strbuf.h\"\n#include \"hashmap.h\"\n#include \"list.h\"\n#include \"advice.h\"\n#include \"gettext.h\"\n#include \"convert.h\"\n#include \"trace.h\"\n#include \"string-list.h\"\n#include \"pack-revindex.h\"\n#include \"hash.h\"\n#include \"path.h\"\n#include \"sha1-array.h\"\n#include \"repository.h\"\n\n#include <zlib.h>\ntypedef struct git_zstream {\n\tz_stream z;\n\tunsigned long avail_in;\n\tunsigned long avail_out;\n\tunsigned long total_in;\n\tunsigned long total_out;\n\tunsigned char *next_in;\n\tunsigned char *next_out;\n} git_zstream;\n\nvoid git_inflate_init(git_zstream *);\nvoid git_inflate_init_gzip_only(git_zstream *);\nvoid git_inflate_end(git_zstream *);\nint git_inflate(git_zstream *, int flush);\n\nvoid git_deflate_init(git_zstream *, int level);\nvoid git_deflate_init_gzip(git_zstream *, int level);\nvoid git_deflate_init_raw(git_zstream *, int level);\nvoid git_deflate_end(git_zstream *);\nint git_deflate_abort(git_zstream *);\nint git_deflate_end_gently(git_zstream *);\nint git_deflate(git_zstream *, int flush);\nunsigned long git_deflate_bound(git_zstream *, unsigned long);\n\n/* The length in bytes and in hex digits of an object name (SHA-1 value). */\n#define GIT_SHA1_RAWSZ 20\n#define GIT_SHA1_HEXSZ (2 * GIT_SHA1_RAWSZ)\n\n/* The length in byte and in hex digits of the largest possible hash value. */\n#define GIT_MAX_RAWSZ GIT_SHA1_RAWSZ\n#define GIT_MAX_HEXSZ GIT_SHA1_HEXSZ\n\nstruct object_id {\n\tunsigned char hash[GIT_MAX_RAWSZ];\n};\n\n#define the_hash_algo the_repository->hash_algo\n\n#if defined(DT_UNKNOWN) && !defined(NO_D_TYPE_IN_DIRENT)\n#define DTYPE(de)\t((de)->d_type)\n#else\n#undef DT_UNKNOWN\n#undef DT_DIR\n#undef DT_REG\n#undef DT_LNK\n#define DT_UNKNOWN\t0\n#define DT_DIR\t\t1\n#define DT_REG\t\t2\n#define DT_LNK\t\t3\n#define DTYPE(de)\tDT_UNKNOWN\n#endif\n\n/* unknown mode (impossible combination S_IFIFO|S_IFCHR) */\n#define S_IFINVALID     0030000\n\n/*\n * A \"directory link\" is a link to another git directory.\n *\n * The value 0160000 is not normally a valid mode, and\n * also just happens to be S_IFDIR + S_IFLNK\n */\n#define S_IFGITLINK\t0160000\n#define S_ISGITLINK(m)\t(((m) & S_IFMT) == S_IFGITLINK)\n\n/*\n * Some mode bits are also used internally for computations.\n *\n * They *must* not overlap with any valid modes, and they *must* not be emitted\n * to outside world - i.e. appear on disk or network. In other words, it's just\n * temporary fields, which we internally use, but they have to stay in-house.\n *\n * ( such approach is valid, as standard S_IF* fits into 16 bits, and in Git\n *   codebase mode is `unsigned int` which is assumed to be at least 32 bits )\n */\n\n/* used internally in tree-diff */\n#define S_DIFFTREE_IFXMIN_NEQ\t0x80000000\n\n\n/*\n * Intensive research over the course of many years has shown that\n * port 9418 is totally unused by anything else. Or\n *\n *\tYour search - \"port 9418\" - did not match any documents.\n *\n * as www.google.com puts it.\n *\n * This port has been properly assigned for git use by IANA:\n * git (Assigned-9418) [I06-050728-0001].\n *\n *\tgit  9418/tcp   git pack transfer service\n *\tgit  9418/udp   git pack transfer service\n *\n * with Linus Torvalds <torvalds@osdl.org> as the point of\n * contact. September 2005.\n *\n * See http://www.iana.org/assignments/port-numbers\n */\n#define DEFAULT_GIT_PORT 9418\n\n/*\n * Basic data structures for the directory cache\n */\n\n#define CACHE_SIGNATURE 0x44495243\t/* \"DIRC\" */\nstruct cache_header {\n\tuint32_t hdr_signature;\n\tuint32_t hdr_version;\n\tuint32_t hdr_entries;\n};\n\n#define INDEX_FORMAT_LB 2\n#define INDEX_FORMAT_UB 4\n\n/*\n * The \"cache_time\" is just the low 32 bits of the\n * time. It doesn't matter if it overflows - we only\n * check it for equality in the 32 bits we save.\n */\nstruct cache_time {\n\tuint32_t sec;\n\tuint32_t nsec;\n};\n\nstruct stat_data {\n\tstruct cache_time sd_ctime;\n\tstruct cache_time sd_mtime;\n\tunsigned int sd_dev;\n\tunsigned int sd_ino;\n\tunsigned int sd_uid;\n\tunsigned int sd_gid;\n\tunsigned int sd_size;\n};\n\nstruct cache_entry {\n\tstruct hashmap_entry ent;\n\tstruct stat_data ce_stat_data;\n\tunsigned int ce_mode;\n\tunsigned int ce_flags;\n\tunsigned int ce_namelen;\n\tunsigned int index;\t/* for link extension */\n\tstruct object_id oid;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n#define CE_STAGEMASK (0x3000)\n#define CE_EXTENDED  (0x4000)\n#define CE_VALID     (0x8000)\n#define CE_STAGESHIFT 12\n\n/*\n * Range 0xFFFF0FFF in ce_flags is divided into\n * two parts: in-memory flags and on-disk ones.\n * Flags in CE_EXTENDED_FLAGS will get saved on-disk\n * if you want to save a new flag, add it in\n * CE_EXTENDED_FLAGS\n *\n * In-memory only flags\n */\n#define CE_UPDATE            (1 << 16)\n#define CE_REMOVE            (1 << 17)\n#define CE_UPTODATE          (1 << 18)\n#define CE_ADDED             (1 << 19)\n\n#define CE_HASHED            (1 << 20)\n#define CE_FSMONITOR_VALID   (1 << 21)\n#define CE_WT_REMOVE         (1 << 22) /* remove in work directory */\n#define CE_CONFLICTED        (1 << 23)\n\n#define CE_UNPACKED          (1 << 24)\n#define CE_NEW_SKIP_WORKTREE (1 << 25)\n\n/* used to temporarily mark paths matched by pathspecs */\n#define CE_MATCHED           (1 << 26)\n\n#define CE_UPDATE_IN_BASE    (1 << 27)\n#define CE_STRIP_NAME        (1 << 28)\n\n/*\n * Extended on-disk flags\n */\n#define CE_INTENT_TO_ADD     (1 << 29)\n#define CE_SKIP_WORKTREE     (1 << 30)\n/* CE_EXTENDED2 is for future extension */\n#define CE_EXTENDED2         (1U << 31)\n\n#define CE_EXTENDED_FLAGS (CE_INTENT_TO_ADD | CE_SKIP_WORKTREE)\n\n/*\n * Safeguard to avoid saving wrong flags:\n *  - CE_EXTENDED2 won't get saved until its semantic is known\n *  - Bits in 0x0000FFFF have been saved in ce_flags already\n *  - Bits in 0x003F0000 are currently in-memory flags\n */\n#if CE_EXTENDED_FLAGS & 0x803FFFFF\n#error \"CE_EXTENDED_FLAGS out of range\"\n#endif\n\n/* Forward structure decls */\nstruct pathspec;\nstruct child_process;\n\n/*\n * Copy the sha1 and stat state of a cache entry from one to\n * another. But we never change the name, or the hash state!\n */\nstatic inline void copy_cache_entry(struct cache_entry *dst,\n\t\t\t\t    const struct cache_entry *src)\n{\n\tunsigned int state = dst->ce_flags & CE_HASHED;\n\n\t/* Don't copy hash chain and name */\n\tmemcpy(&dst->ce_stat_data, &src->ce_stat_data,\n\t\t\toffsetof(struct cache_entry, name) -\n\t\t\toffsetof(struct cache_entry, ce_stat_data));\n\n\t/* Restore the hash state */\n\tdst->ce_flags = (dst->ce_flags & ~CE_HASHED) | state;\n}\n\nstatic inline unsigned create_ce_flags(unsigned stage)\n{\n\treturn (stage << CE_STAGESHIFT);\n}\n\n#define ce_namelen(ce) ((ce)->ce_namelen)\n#define ce_size(ce) cache_entry_size(ce_namelen(ce))\n#define ce_stage(ce) ((CE_STAGEMASK & (ce)->ce_flags) >> CE_STAGESHIFT)\n#define ce_uptodate(ce) ((ce)->ce_flags & CE_UPTODATE)\n#define ce_skip_worktree(ce) ((ce)->ce_flags & CE_SKIP_WORKTREE)\n#define ce_mark_uptodate(ce) ((ce)->ce_flags |= CE_UPTODATE)\n#define ce_intent_to_add(ce) ((ce)->ce_flags & CE_INTENT_TO_ADD)\n\n#define ce_permissions(mode) (((mode) & 0100) ? 0755 : 0644)\nstatic inline unsigned int create_ce_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode) || S_ISGITLINK(mode))\n\t\treturn S_IFGITLINK;\n\treturn S_IFREG | ce_permissions(mode);\n}\nstatic inline unsigned int ce_mode_from_stat(const struct cache_entry *ce,\n\t\t\t\t\t     unsigned int mode)\n{\n\textern int trust_executable_bit, has_symlinks;\n\tif (!has_symlinks && S_ISREG(mode) &&\n\t    ce && S_ISLNK(ce->ce_mode))\n\t\treturn ce->ce_mode;\n\tif (!trust_executable_bit && S_ISREG(mode)) {\n\t\tif (ce && S_ISREG(ce->ce_mode))\n\t\t\treturn ce->ce_mode;\n\t\treturn create_ce_mode(0666);\n\t}\n\treturn create_ce_mode(mode);\n}\nstatic inline int ce_to_dtype(const struct cache_entry *ce)\n{\n\tunsigned ce_mode = ntohl(ce->ce_mode);\n\tif (S_ISREG(ce_mode))\n\t\treturn DT_REG;\n\telse if (S_ISDIR(ce_mode) || S_ISGITLINK(ce_mode))\n\t\treturn DT_DIR;\n\telse if (S_ISLNK(ce_mode))\n\t\treturn DT_LNK;\n\telse\n\t\treturn DT_UNKNOWN;\n}\nstatic inline unsigned int canon_mode(unsigned int mode)\n{\n\tif (S_ISREG(mode))\n\t\treturn S_IFREG | ce_permissions(mode);\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode))\n\t\treturn S_IFDIR;\n\treturn S_IFGITLINK;\n}\n\n#define cache_entry_size(len) (offsetof(struct cache_entry,name) + (len) + 1)\n\n#define SOMETHING_CHANGED\t(1 << 0) /* unclassified changes go here */\n#define CE_ENTRY_CHANGED\t(1 << 1)\n#define CE_ENTRY_REMOVED\t(1 << 2)\n#define CE_ENTRY_ADDED\t\t(1 << 3)\n#define RESOLVE_UNDO_CHANGED\t(1 << 4)\n#define CACHE_TREE_CHANGED\t(1 << 5)\n#define SPLIT_INDEX_ORDERED\t(1 << 6)\n#define UNTRACKED_CHANGED\t(1 << 7)\n#define FSMONITOR_CHANGED\t(1 << 8)\n\nstruct split_index;\nstruct untracked_cache;\n\nstruct index_state {\n\tstruct cache_entry **cache;\n\tunsigned int version;\n\tunsigned int cache_nr, cache_alloc, cache_changed;\n\tstruct string_list *resolve_undo;\n\tstruct cache_tree *cache_tree;\n\tstruct split_index *split_index;\n\tstruct cache_time timestamp;\n\tunsigned name_hash_initialized : 1,\n\t\t initialized : 1,\n\t\t drop_cache_tree : 1;\n\tstruct hashmap name_hash;\n\tstruct hashmap dir_hash;\n\tunsigned char sha1[20];\n\tstruct untracked_cache *untracked;\n\tuint64_t fsmonitor_last_update;\n\tstruct ewah_bitmap *fsmonitor_dirty;\n};\n\nextern struct index_state the_index;\n\n/* Name hashing */\nextern int test_lazy_init_name_hash(struct index_state *istate, int try_threaded);\nextern void add_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void remove_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void free_name_hash(struct index_state *istate);\n\n\n#ifndef NO_THE_INDEX_COMPATIBILITY_MACROS\n#define active_cache (the_index.cache)\n#define active_nr (the_index.cache_nr)\n#define active_alloc (the_index.cache_alloc)\n#define active_cache_changed (the_index.cache_changed)\n#define active_cache_tree (the_index.cache_tree)\n\n#define read_cache() read_index(&the_index)\n#define read_cache_from(path) read_index_from(&the_index, (path), (get_git_dir()))\n#define read_cache_preload(pathspec) read_index_preload(&the_index, (pathspec))\n#define is_cache_unborn() is_index_unborn(&the_index)\n#define read_cache_unmerged() read_index_unmerged(&the_index)\n#define discard_cache() discard_index(&the_index)\n#define unmerged_cache() unmerged_index(&the_index)\n#define cache_name_pos(name, namelen) index_name_pos(&the_index,(name),(namelen))\n#define add_cache_entry(ce, option) add_index_entry(&the_index, (ce), (option))\n#define rename_cache_entry_at(pos, new_name) rename_index_entry_at(&the_index, (pos), (new_name))\n#define remove_cache_entry_at(pos) remove_index_entry_at(&the_index, (pos))\n#define remove_file_from_cache(path) remove_file_from_index(&the_index, (path))\n#define add_to_cache(path, st, flags) add_to_index(&the_index, (path), (st), (flags))\n#define add_file_to_cache(path, flags) add_file_to_index(&the_index, (path), (flags))\n#define chmod_cache_entry(ce, flip) chmod_index_entry(&the_index, (ce), (flip))\n#define refresh_cache(flags) refresh_index(&the_index, (flags), NULL, NULL, NULL)\n#define ce_match_stat(ce, st, options) ie_match_stat(&the_index, (ce), (st), (options))\n#define ce_modified(ce, st, options) ie_modified(&the_index, (ce), (st), (options))\n#define cache_dir_exists(name, namelen) index_dir_exists(&the_index, (name), (namelen))\n#define cache_file_exists(name, namelen, igncase) index_file_exists(&the_index, (name), (namelen), (igncase))\n#define cache_name_is_other(name, namelen) index_name_is_other(&the_index, (name), (namelen))\n#define resolve_undo_clear() resolve_undo_clear_index(&the_index)\n#define unmerge_cache_entry_at(at) unmerge_index_entry_at(&the_index, at)\n#define unmerge_cache(pathspec) unmerge_index(&the_index, pathspec)\n#define read_blob_data_from_cache(path, sz) read_blob_data_from_index(&the_index, (path), (sz))\n#endif\n\nenum object_type {\n\tOBJ_BAD = -1,\n\tOBJ_NONE = 0,\n\tOBJ_COMMIT = 1,\n\tOBJ_TREE = 2,\n\tOBJ_BLOB = 3,\n\tOBJ_TAG = 4,\n\t/* 5 for future expansion */\n\tOBJ_OFS_DELTA = 6,\n\tOBJ_REF_DELTA = 7,\n\tOBJ_ANY,\n\tOBJ_MAX\n};\n\nstatic inline enum object_type object_type(unsigned int mode)\n{\n\treturn S_ISDIR(mode) ? OBJ_TREE :\n\t\tS_ISGITLINK(mode) ? OBJ_COMMIT :\n\t\tOBJ_BLOB;\n}\n\n/* Double-check local_repo_env below if you add to this list. */\n#define GIT_DIR_ENVIRONMENT \"GIT_DIR\"\n#define GIT_COMMON_DIR_ENVIRONMENT \"GIT_COMMON_DIR\"\n#define GIT_NAMESPACE_ENVIRONMENT \"GIT_NAMESPACE\"\n#define GIT_WORK_TREE_ENVIRONMENT \"GIT_WORK_TREE\"\n#define GIT_PREFIX_ENVIRONMENT \"GIT_PREFIX\"\n#define GIT_SUPER_PREFIX_ENVIRONMENT \"GIT_INTERNAL_SUPER_PREFIX\"\n#define DEFAULT_GIT_DIR_ENVIRONMENT \".git\"\n#define DB_ENVIRONMENT \"GIT_OBJECT_DIRECTORY\"\n#define INDEX_ENVIRONMENT \"GIT_INDEX_FILE\"\n#define GRAFT_ENVIRONMENT \"GIT_GRAFT_FILE\"\n#define GIT_SHALLOW_FILE_ENVIRONMENT \"GIT_SHALLOW_FILE\"\n#define TEMPLATE_DIR_ENVIRONMENT \"GIT_TEMPLATE_DIR\"\n#define CONFIG_ENVIRONMENT \"GIT_CONFIG\"\n#define CONFIG_DATA_ENVIRONMENT \"GIT_CONFIG_PARAMETERS\"\n#define EXEC_PATH_ENVIRONMENT \"GIT_EXEC_PATH\"\n#define CEILING_DIRECTORIES_ENVIRONMENT \"GIT_CEILING_DIRECTORIES\"\n#define NO_REPLACE_OBJECTS_ENVIRONMENT \"GIT_NO_REPLACE_OBJECTS\"\n#define GIT_REPLACE_REF_BASE_ENVIRONMENT \"GIT_REPLACE_REF_BASE\"\n#define GITATTRIBUTES_FILE \".gitattributes\"\n#define INFOATTRIBUTES_FILE \"info/attributes\"\n#define ATTRIBUTE_MACRO_PREFIX \"[attr]\"\n#define GITMODULES_FILE \".gitmodules\"\n#define GIT_NOTES_REF_ENVIRONMENT \"GIT_NOTES_REF\"\n#define GIT_NOTES_DEFAULT_REF \"refs/notes/commits\"\n#define GIT_NOTES_DISPLAY_REF_ENVIRONMENT \"GIT_NOTES_DISPLAY_REF\"\n#define GIT_NOTES_REWRITE_REF_ENVIRONMENT \"GIT_NOTES_REWRITE_REF\"\n#define GIT_NOTES_REWRITE_MODE_ENVIRONMENT \"GIT_NOTES_REWRITE_MODE\"\n#define GIT_LITERAL_PATHSPECS_ENVIRONMENT \"GIT_LITERAL_PATHSPECS\"\n#define GIT_GLOB_PATHSPECS_ENVIRONMENT \"GIT_GLOB_PATHSPECS\"\n#define GIT_NOGLOB_PATHSPECS_ENVIRONMENT \"GIT_NOGLOB_PATHSPECS\"\n#define GIT_ICASE_PATHSPECS_ENVIRONMENT \"GIT_ICASE_PATHSPECS\"\n#define GIT_QUARANTINE_ENVIRONMENT \"GIT_QUARANTINE_PATH\"\n#define GIT_OPTIONAL_LOCKS_ENVIRONMENT \"GIT_OPTIONAL_LOCKS\"\n\n/*\n * Environment variable used in handshaking the wire protocol.\n * Contains a colon ':' separated list of keys with optional values\n * 'key[=value]'.  Presence of unknown keys and values must be\n * ignored.\n */\n#define GIT_PROTOCOL_ENVIRONMENT \"GIT_PROTOCOL\"\n/* HTTP header used to handshake the wire protocol */\n#define GIT_PROTOCOL_HEADER \"Git-Protocol\"\n\n/*\n * This environment variable is expected to contain a boolean indicating\n * whether we should or should not treat:\n *\n *   GIT_DIR=foo.git git ...\n *\n * as if GIT_WORK_TREE=. was given. It's not expected that users will make use\n * of this, but we use it internally to communicate to sub-processes that we\n * are in a bare repo. If not set, defaults to true.\n */\n#define GIT_IMPLICIT_WORK_TREE_ENVIRONMENT \"GIT_IMPLICIT_WORK_TREE\"\n\n/*\n * Repository-local GIT_* environment variables; these will be cleared\n * when git spawns a sub-process that runs inside another repository.\n * The array is NULL-terminated, which makes it easy to pass in the \"env\"\n * parameter of a run-command invocation, or to do a simple walk.\n */\nextern const char * const local_repo_env[];\n\nextern void setup_git_env(void);\n\n/*\n * Returns true iff we have a configured git repository (either via\n * setup_git_directory, or in the environment via $GIT_DIR).\n */\nint have_git_dir(void);\n\nextern int is_bare_repository_cfg;\nextern int is_bare_repository(void);\nextern int is_inside_git_dir(void);\nextern char *git_work_tree_cfg;\nextern int is_inside_work_tree(void);\nextern const char *get_git_dir(void);\nextern const char *get_git_common_dir(void);\nextern char *get_object_directory(void);\nextern char *get_index_file(void);\nextern char *get_graft_file(void);\nextern int set_git_dir(const char *path);\nextern int get_common_dir_noenv(struct strbuf *sb, const char *gitdir);\nextern int get_common_dir(struct strbuf *sb, const char *gitdir);\nextern const char *get_git_namespace(void);\nextern const char *strip_namespace(const char *namespaced_ref);\nextern const char *get_super_prefix(void);\nextern const char *get_git_work_tree(void);\n\n/*\n * Return true if the given path is a git directory; note that this _just_\n * looks at the directory itself. If you want to know whether \"foo/.git\"\n * is a repository, you must feed that path, not just \"foo\".\n */\nextern int is_git_directory(const char *path);\n\n/*\n * Return 1 if the given path is the root of a git repository or\n * submodule, else 0. Will not return 1 for bare repositories with the\n * exception of creating a bare repository in \"foo/.git\" and calling\n * is_git_repository(\"foo\").\n *\n * If we run into read errors, we err on the side of saying \"yes, it is\",\n * as we usually consider sub-repos precious, and would prefer to err on the\n * side of not disrupting or deleting them.\n */\nextern int is_nonbare_repository_dir(struct strbuf *path);\n\n#define READ_GITFILE_ERR_STAT_FAILED 1\n#define READ_GITFILE_ERR_NOT_A_FILE 2\n#define READ_GITFILE_ERR_OPEN_FAILED 3\n#define READ_GITFILE_ERR_READ_FAILED 4\n#define READ_GITFILE_ERR_INVALID_FORMAT 5\n#define READ_GITFILE_ERR_NO_PATH 6\n#define READ_GITFILE_ERR_NOT_A_REPO 7\n#define READ_GITFILE_ERR_TOO_LARGE 8\nextern void read_gitfile_error_die(int error_code, const char *path, const char *dir);\nextern const char *read_gitfile_gently(const char *path, int *return_error_code);\n#define read_gitfile(path) read_gitfile_gently((path), NULL)\nextern const char *resolve_gitdir_gently(const char *suspect, int *return_error_code);\n#define resolve_gitdir(path) resolve_gitdir_gently((path), NULL)\n\nextern void set_git_work_tree(const char *tree);\n\n#define ALTERNATE_DB_ENVIRONMENT \"GIT_ALTERNATE_OBJECT_DIRECTORIES\"\n\nextern void setup_work_tree(void);\n/*\n * Find the commondir and gitdir of the repository that contains the current\n * working directory, without changing the working directory or other global\n * state. The result is appended to commondir and gitdir.  If the discovered\n * gitdir does not correspond to a worktree, then 'commondir' and 'gitdir' will\n * both have the same result appended to the buffer.  The return value is\n * either 0 upon success and non-zero if no repository was found.\n */\nextern int discover_git_directory(struct strbuf *commondir,\n\t\t\t\t  struct strbuf *gitdir);\nextern const char *setup_git_directory_gently(int *);\nextern const char *setup_git_directory(void);\nextern char *prefix_path(const char *prefix, int len, const char *path);\nextern char *prefix_path_gently(const char *prefix, int len, int *remaining, const char *path);\n\n/*\n * Concatenate \"prefix\" (if len is non-zero) and \"path\", with no\n * connecting characters (so \"prefix\" should end with a \"/\").\n * Unlike prefix_path, this should be used if the named file does\n * not have to interact with index entry; i.e. name of a random file\n * on the filesystem.\n *\n * The return value is always a newly allocated string (even if the\n * prefix was empty).\n */\nextern char *prefix_filename(const char *prefix, const char *path);\n\nextern int check_filename(const char *prefix, const char *name);\nextern void verify_filename(const char *prefix,\n\t\t\t    const char *name,\n\t\t\t    int diagnose_misspelt_rev);\nextern void verify_non_filename(const char *prefix, const char *name);\nextern int path_inside_repo(const char *prefix, const char *path);\n\n#define INIT_DB_QUIET 0x0001\n#define INIT_DB_EXIST_OK 0x0002\n\nextern int init_db(const char *git_dir, const char *real_git_dir,\n\t\t   const char *template_dir, unsigned int flags);\n\nextern void sanitize_stdfds(void);\nextern int daemonize(void);\n\n#define alloc_nr(x) (((x)+16)*3/2)\n\n/*\n * Realloc the buffer pointed at by variable 'x' so that it can hold\n * at least 'nr' entries; the number of entries currently allocated\n * is 'alloc', using the standard growing factor alloc_nr() macro.\n *\n * DO NOT USE any expression with side-effect for 'x', 'nr', or 'alloc'.\n */\n#define ALLOC_GROW(x, nr, alloc) \\\n\tdo { \\\n\t\tif ((nr) > alloc) { \\\n\t\t\tif (alloc_nr(alloc) < (nr)) \\\n\t\t\t\talloc = (nr); \\\n\t\t\telse \\\n\t\t\t\talloc = alloc_nr(alloc); \\\n\t\t\tREALLOC_ARRAY(x, alloc); \\\n\t\t} \\\n\t} while (0)\n\n/* Initialize and use the cache information */\nstruct lock_file;\nextern int read_index(struct index_state *);\nextern int read_index_preload(struct index_state *, const struct pathspec *pathspec);\nextern int do_read_index(struct index_state *istate, const char *path,\n\t\t\t int must_exist); /* for testting only! */\nextern int read_index_from(struct index_state *, const char *path,\n\t\t\t   const char *gitdir);\nextern int is_index_unborn(struct index_state *);\nextern int read_index_unmerged(struct index_state *);\n\n/* For use with `write_locked_index()`. */\n#define COMMIT_LOCK\t\t(1 << 0)\n#define SKIP_IF_UNCHANGED\t(1 << 1)\n\n/*\n * Write the index while holding an already-taken lock. Close the lock,\n * and if `COMMIT_LOCK` is given, commit it.\n *\n * Unless a split index is in use, write the index into the lockfile.\n *\n * With a split index, write the shared index to a temporary file,\n * adjust its permissions and rename it into place, then write the\n * split index to the lockfile. If the temporary file for the shared\n * index cannot be created, fall back to the behavior described in\n * the previous paragraph.\n *\n * With `COMMIT_LOCK`, the lock is always committed or rolled back.\n * Without it, the lock is closed, but neither committed nor rolled\n * back.\n *\n * If `SKIP_IF_UNCHANGED` is given and the index is unchanged, nothing\n * is written (and the lock is rolled back if `COMMIT_LOCK` is given).\n */\nextern int write_locked_index(struct index_state *, struct lock_file *lock, unsigned flags);\n\nextern int discard_index(struct index_state *);\nextern void move_index_extensions(struct index_state *dst, struct index_state *src);\nextern int unmerged_index(const struct index_state *);\n\n/**\n * Returns 1 if the index differs from HEAD, 0 otherwise. When on an unborn\n * branch, returns 1 if there are entries in the index, 0 otherwise. If an\n * strbuf is provided, the space-separated list of files that differ will be\n * appended to it.\n */\nextern int index_has_changes(struct strbuf *sb);\n\nextern int verify_path(const char *path, unsigned mode);\nextern int strcmp_offset(const char *s1, const char *s2, size_t *first_change);\nextern int index_dir_exists(struct index_state *istate, const char *name, int namelen);\nextern void adjust_dirname_case(struct index_state *istate, char *name);\nextern struct cache_entry *index_file_exists(struct index_state *istate, const char *name, int namelen, int igncase);\n\n/*\n * Searches for an entry defined by name and namelen in the given index.\n * If the return value is positive (including 0) it is the position of an\n * exact match. If the return value is negative, the negated value minus 1\n * is the position where the entry would be inserted.\n * Example: The current index consists of these files and its stages:\n *\n *   b#0, d#0, f#1, f#3\n *\n * index_name_pos(&index, \"a\", 1) -> -1\n * index_name_pos(&index, \"b\", 1) ->  0\n * index_name_pos(&index, \"c\", 1) -> -2\n * index_name_pos(&index, \"d\", 1) ->  1\n * index_name_pos(&index, \"e\", 1) -> -3\n * index_name_pos(&index, \"f\", 1) -> -3\n * index_name_pos(&index, \"g\", 1) -> -5\n */\nextern int index_name_pos(const struct index_state *, const char *name, int namelen);\n\n#define ADD_CACHE_OK_TO_ADD 1\t\t/* Ok to add */\n#define ADD_CACHE_OK_TO_REPLACE 2\t/* Ok to replace file/directory */\n#define ADD_CACHE_SKIP_DFCHECK 4\t/* Ok to skip DF conflict checks */\n#define ADD_CACHE_JUST_APPEND 8\t\t/* Append only; tree.c::read_tree() */\n#define ADD_CACHE_NEW_ONLY 16\t\t/* Do not replace existing ones */\n#define ADD_CACHE_KEEP_CACHE_TREE 32\t/* Do not invalidate cache-tree */\nextern int add_index_entry(struct index_state *, struct cache_entry *ce, int option);\nextern void rename_index_entry_at(struct index_state *, int pos, const char *new_name);\n\n/* Remove entry, return true if there are more entries to go. */\nextern int remove_index_entry_at(struct index_state *, int pos);\n\nextern void remove_marked_cache_entries(struct index_state *istate);\nextern int remove_file_from_index(struct index_state *, const char *path);\n#define ADD_CACHE_VERBOSE 1\n#define ADD_CACHE_PRETEND 2\n#define ADD_CACHE_IGNORE_ERRORS\t4\n#define ADD_CACHE_IGNORE_REMOVAL 8\n#define ADD_CACHE_INTENT 16\n/*\n * These two are used to add the contents of the file at path\n * to the index, marking the working tree up-to-date by storing\n * the cached stat info in the resulting cache entry.  A caller\n * that has already run lstat(2) on the path can call\n * add_to_index(), and all others can call add_file_to_index();\n * the latter will do necessary lstat(2) internally before\n * calling the former.\n */\nextern int add_to_index(struct index_state *, const char *path, struct stat *, int flags);\nextern int add_file_to_index(struct index_state *, const char *path, int flags);\n\nextern struct cache_entry *make_cache_entry(unsigned int mode, const unsigned char *sha1, const char *path, int stage, unsigned int refresh_options);\nextern int chmod_index_entry(struct index_state *, struct cache_entry *ce, char flip);\nextern int ce_same_name(const struct cache_entry *a, const struct cache_entry *b);\nextern void set_object_name_for_intent_to_add_entry(struct cache_entry *ce);\nextern int index_name_is_other(const struct index_state *, const char *, int);\nextern void *read_blob_data_from_index(const struct index_state *, const char *, unsigned long *);\n\n/* do stat comparison even if CE_VALID is true */\n#define CE_MATCH_IGNORE_VALID\t\t01\n/* do not check the contents but report dirty on racily-clean entries */\n#define CE_MATCH_RACY_IS_DIRTY\t\t02\n/* do stat comparison even if CE_SKIP_WORKTREE is true */\n#define CE_MATCH_IGNORE_SKIP_WORKTREE\t04\n/* ignore non-existent files during stat update  */\n#define CE_MATCH_IGNORE_MISSING\t\t0x08\n/* enable stat refresh */\n#define CE_MATCH_REFRESH\t\t0x10\n/* don't refresh_fsmonitor state or do stat comparison even if CE_FSMONITOR_VALID is true */\n#define CE_MATCH_IGNORE_FSMONITOR 0X20\nextern int ie_match_stat(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\nextern int ie_modified(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\n\n#define HASH_WRITE_OBJECT 1\n#define HASH_FORMAT_CHECK 2\n#define HASH_RENORMALIZE  4\nextern int index_fd(struct object_id *oid, int fd, struct stat *st, enum object_type type, const char *path, unsigned flags);\nextern int index_path(struct object_id *oid, const char *path, struct stat *st, unsigned flags);\n\n/*\n * Record to sd the data from st that we use to check whether a file\n * might have changed.\n */\nextern void fill_stat_data(struct stat_data *sd, struct stat *st);\n\n/*\n * Return 0 if st is consistent with a file not having been changed\n * since sd was filled.  If there are differences, return a\n * combination of MTIME_CHANGED, CTIME_CHANGED, OWNER_CHANGED,\n * INODE_CHANGED, and DATA_CHANGED.\n */\nextern int match_stat_data(const struct stat_data *sd, struct stat *st);\nextern int match_stat_data_racy(const struct index_state *istate,\n\t\t\t\tconst struct stat_data *sd, struct stat *st);\n\nextern void fill_stat_cache_info(struct cache_entry *ce, struct stat *st);\n\n#define REFRESH_REALLY\t\t0x0001\t/* ignore_valid */\n#define REFRESH_UNMERGED\t0x0002\t/* allow unmerged */\n#define REFRESH_QUIET\t\t0x0004\t/* be quiet about it */\n#define REFRESH_IGNORE_MISSING\t0x0008\t/* ignore non-existent */\n#define REFRESH_IGNORE_SUBMODULES\t0x0010\t/* ignore submodules */\n#define REFRESH_IN_PORCELAIN\t0x0020\t/* user friendly output, not \"needs update\" */\nextern int refresh_index(struct index_state *, unsigned int flags, const struct pathspec *pathspec, char *seen, const char *header_msg);\nextern struct cache_entry *refresh_cache_entry(struct cache_entry *, unsigned int);\n\n/*\n * Opportunistically update the index but do not complain if we can't.\n * The lockfile is always committed or rolled back.\n */\nextern void update_index_if_able(struct index_state *, struct lock_file *);\n\nextern int hold_locked_index(struct lock_file *, int);\nextern void set_alternate_index_output(const char *);\n\nextern int verify_index_checksum;\nextern int verify_ce_order;\n\n/* Environment bits from configuration mechanism */\nextern int trust_executable_bit;\nextern int trust_ctime;\nextern int check_stat;\nextern int quote_path_fully;\nextern int has_symlinks;\nextern int minimum_abbrev, default_abbrev;\nextern int ignore_case;\nextern int assume_unchanged;\nextern int prefer_symlink_refs;\nextern int warn_ambiguous_refs;\nextern int warn_on_object_refname_ambiguity;\nextern const char *apply_default_whitespace;\nextern const char *apply_default_ignorewhitespace;\nextern const char *git_attributes_file;\nextern const char *git_hooks_path;\nextern int zlib_compression_level;\nextern int core_compression_level;\nextern int pack_compression_level;\nextern size_t packed_git_window_size;\nextern size_t packed_git_limit;\nextern size_t delta_base_cache_limit;\nextern unsigned long big_file_threshold;\nextern unsigned long pack_size_limit_cfg;\n\n/*\n * Accessors for the core.sharedrepository config which lazy-load the value\n * from the config (if not already set). The \"reset\" function can be\n * used to unset \"set\" or cached value, meaning that the value will be loaded\n * fresh from the config file on the next call to get_shared_repository().\n */\nvoid set_shared_repository(int value);\nint get_shared_repository(void);\nvoid reset_shared_repository(void);\n\n/*\n * Do replace refs need to be checked this run?  This variable is\n * initialized to true unless --no-replace-object is used or\n * $GIT_NO_REPLACE_OBJECTS is set, but is set to false by some\n * commands that do not want replace references to be active.  As an\n * optimization it is also set to false if replace references have\n * been sought but there were none.\n */\nextern int check_replace_refs;\nextern char *git_replace_ref_base;\n\nextern int fsync_object_files;\nextern int core_preload_index;\nextern int core_apply_sparse_checkout;\nextern int precomposed_unicode;\nextern int protect_hfs;\nextern int protect_ntfs;\nextern const char *core_fsmonitor;\n\n/*\n * Include broken refs in all ref iterations, which will\n * generally choke dangerous operations rather than letting\n * them silently proceed without taking the broken ref into\n * account.\n */\nextern int ref_paranoia;\n\n/*\n * Returns the boolean value of $GIT_OPTIONAL_LOCKS (or the default value).\n */\nint use_optional_locks(void);\n\n/*\n * The character that begins a commented line in user-editable file\n * that is subject to stripspace.\n */\nextern char comment_line_char;\nextern int auto_comment_line_char;\n\n/* Windows only */\nenum hide_dotfiles_type {\n\tHIDE_DOTFILES_FALSE = 0,\n\tHIDE_DOTFILES_TRUE,\n\tHIDE_DOTFILES_DOTGITONLY\n};\nextern enum hide_dotfiles_type hide_dotfiles;\n\nenum log_refs_config {\n\tLOG_REFS_UNSET = -1,\n\tLOG_REFS_NONE = 0,\n\tLOG_REFS_NORMAL,\n\tLOG_REFS_ALWAYS\n};\nextern enum log_refs_config log_all_ref_updates;\n\nenum branch_track {\n\tBRANCH_TRACK_UNSPECIFIED = -1,\n\tBRANCH_TRACK_NEVER = 0,\n\tBRANCH_TRACK_REMOTE,\n\tBRANCH_TRACK_ALWAYS,\n\tBRANCH_TRACK_EXPLICIT,\n\tBRANCH_TRACK_OVERRIDE\n};\n\nenum rebase_setup_type {\n\tAUTOREBASE_NEVER = 0,\n\tAUTOREBASE_LOCAL,\n\tAUTOREBASE_REMOTE,\n\tAUTOREBASE_ALWAYS\n};\n\nenum push_default_type {\n\tPUSH_DEFAULT_NOTHING = 0,\n\tPUSH_DEFAULT_MATCHING,\n\tPUSH_DEFAULT_SIMPLE,\n\tPUSH_DEFAULT_UPSTREAM,\n\tPUSH_DEFAULT_CURRENT,\n\tPUSH_DEFAULT_UNSPECIFIED\n};\n\nextern enum branch_track git_branch_track;\nextern enum rebase_setup_type autorebase;\nextern enum push_default_type push_default;\n\nenum object_creation_mode {\n\tOBJECT_CREATION_USES_HARDLINKS = 0,\n\tOBJECT_CREATION_USES_RENAMES = 1\n};\n\nextern enum object_creation_mode object_creation_mode;\n\nextern char *notes_ref_name;\n\nextern int grafts_replace_parents;\n\n/*\n * GIT_REPO_VERSION is the version we write by default. The\n * _READ variant is the highest number we know how to\n * handle.\n */\n#define GIT_REPO_VERSION 0\n#define GIT_REPO_VERSION_READ 1\nextern int repository_format_precious_objects;\nextern char *repository_format_partial_clone;\nextern const char *core_partial_clone_filter_default;\n\nstruct repository_format {\n\tint version;\n\tint precious_objects;\n\tchar *partial_clone; /* value of extensions.partialclone */\n\tint is_bare;\n\tint hash_algo;\n\tchar *work_tree;\n\tstruct string_list unknown_extensions;\n};\n\n/*\n * Read the repository format characteristics from the config file \"path\" into\n * \"format\" struct. Returns the numeric version. On error, -1 is returned,\n * format->version is set to -1, and all other fields in the struct are\n * undefined.\n */\nint read_repository_format(struct repository_format *format, const char *path);\n\n/*\n * Verify that the repository described by repository_format is something we\n * can read. If it is, return 0. Otherwise, return -1, and \"err\" will describe\n * any errors encountered.\n */\nint verify_repository_format(const struct repository_format *format,\n\t\t\t     struct strbuf *err);\n\n/*\n * Check the repository format version in the path found in get_git_dir(),\n * and die if it is a version we don't understand. Generally one would\n * set_git_dir() before calling this, and use it only for \"are we in a valid\n * repo?\".\n */\nextern void check_repository_format(void);\n\n#define MTIME_CHANGED\t0x0001\n#define CTIME_CHANGED\t0x0002\n#define OWNER_CHANGED\t0x0004\n#define MODE_CHANGED    0x0008\n#define INODE_CHANGED   0x0010\n#define DATA_CHANGED    0x0020\n#define TYPE_CHANGED    0x0040\n\n/*\n * Put in `buf` the name of the file in the local object database that\n * would be used to store a loose object with the specified sha1.\n */\nextern void sha1_file_name(struct strbuf *buf, const unsigned char *sha1);\n\n/*\n * Return an abbreviated sha1 unique within this repository's object database.\n * The result will be at least `len` characters long, and will be NUL\n * terminated.\n *\n * The non-`_r` version returns a static buffer which remains valid until 4\n * more calls to find_unique_abbrev are made.\n *\n * The `_r` variant writes to a buffer supplied by the caller, which must be at\n * least `GIT_SHA1_HEXSZ + 1` bytes. The return value is the number of bytes\n * written (excluding the NUL terminator).\n *\n * Note that while this version avoids the static buffer, it is not fully\n * reentrant, as it calls into other non-reentrant git code.\n */\nextern const char *find_unique_abbrev(const unsigned char *sha1, int len);\nextern int find_unique_abbrev_r(char *hex, const unsigned char *sha1, int len);\n\nextern const unsigned char null_sha1[GIT_MAX_RAWSZ];\nextern const struct object_id null_oid;\n\nstatic inline int hashcmp(const unsigned char *sha1, const unsigned char *sha2)\n{\n\treturn memcmp(sha1, sha2, GIT_SHA1_RAWSZ);\n}\n\nstatic inline int oidcmp(const struct object_id *oid1, const struct object_id *oid2)\n{\n\treturn hashcmp(oid1->hash, oid2->hash);\n}\n\nstatic inline int is_null_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, null_sha1);\n}\n\nstatic inline int is_null_oid(const struct object_id *oid)\n{\n\treturn !hashcmp(oid->hash, null_sha1);\n}\n\nstatic inline void hashcpy(unsigned char *sha_dst, const unsigned char *sha_src)\n{\n\tmemcpy(sha_dst, sha_src, GIT_SHA1_RAWSZ);\n}\n\nstatic inline void oidcpy(struct object_id *dst, const struct object_id *src)\n{\n\thashcpy(dst->hash, src->hash);\n}\n\nstatic inline struct object_id *oiddup(const struct object_id *src)\n{\n\tstruct object_id *dst = xmalloc(sizeof(struct object_id));\n\toidcpy(dst, src);\n\treturn dst;\n}\n\nstatic inline void hashclr(unsigned char *hash)\n{\n\tmemset(hash, 0, GIT_SHA1_RAWSZ);\n}\n\nstatic inline void oidclr(struct object_id *oid)\n{\n\tmemset(oid->hash, 0, GIT_MAX_RAWSZ);\n}\n\n\n#define EMPTY_TREE_SHA1_HEX \\\n\t\"4b825dc642cb6eb9a060e54bf8d69288fbee4904\"\n#define EMPTY_TREE_SHA1_BIN_LITERAL \\\n\t \"\\x4b\\x82\\x5d\\xc6\\x42\\xcb\\x6e\\xb9\\xa0\\x60\" \\\n\t \"\\xe5\\x4b\\xf8\\xd6\\x92\\x88\\xfb\\xee\\x49\\x04\"\nextern const struct object_id empty_tree_oid;\n#define EMPTY_TREE_SHA1_BIN (empty_tree_oid.hash)\n\n#define EMPTY_BLOB_SHA1_HEX \\\n\t\"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391\"\n#define EMPTY_BLOB_SHA1_BIN_LITERAL \\\n\t\"\\xe6\\x9d\\xe2\\x9b\\xb2\\xd1\\xd6\\x43\\x4b\\x8b\" \\\n\t\"\\x29\\xae\\x77\\x5a\\xd8\\xc2\\xe4\\x8c\\x53\\x91\"\nextern const struct object_id empty_blob_oid;\n\nstatic inline int is_empty_blob_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, the_hash_algo->empty_blob->hash);\n}\n\nstatic inline int is_empty_blob_oid(const struct object_id *oid)\n{\n\treturn !oidcmp(oid, the_hash_algo->empty_blob);\n}\n\nstatic inline int is_empty_tree_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, the_hash_algo->empty_tree->hash);\n}\n\nstatic inline int is_empty_tree_oid(const struct object_id *oid)\n{\n\treturn !oidcmp(oid, the_hash_algo->empty_tree);\n}\n\n/* set default permissions by passing mode arguments to open(2) */\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode);\nint git_mkstemp_mode(char *pattern, int mode);\n\n/*\n * NOTE NOTE NOTE!!\n *\n * PERM_UMASK, OLD_PERM_GROUP and OLD_PERM_EVERYBODY enumerations must\n * not be changed. Old repositories have core.sharedrepository written in\n * numeric format, and therefore these values are preserved for compatibility\n * reasons.\n */\nenum sharedrepo {\n\tPERM_UMASK          = 0,\n\tOLD_PERM_GROUP      = 1,\n\tOLD_PERM_EVERYBODY  = 2,\n\tPERM_GROUP          = 0660,\n\tPERM_EVERYBODY      = 0664\n};\nint git_config_perm(const char *var, const char *value);\nint adjust_shared_perm(const char *path);\n\n/*\n * Create the directory containing the named path, using care to be\n * somewhat safe against races. Return one of the scld_error values to\n * indicate success/failure. On error, set errno to describe the\n * problem.\n *\n * SCLD_VANISHED indicates that one of the ancestor directories of the\n * path existed at one point during the function call and then\n * suddenly vanished, probably because another process pruned the\n * directory while we were working.  To be robust against this kind of\n * race, callers might want to try invoking the function again when it\n * returns SCLD_VANISHED.\n *\n * safe_create_leading_directories() temporarily changes path while it\n * is working but restores it before returning.\n * safe_create_leading_directories_const() doesn't modify path, even\n * temporarily.\n */\nenum scld_error {\n\tSCLD_OK = 0,\n\tSCLD_FAILED = -1,\n\tSCLD_PERMS = -2,\n\tSCLD_EXISTS = -3,\n\tSCLD_VANISHED = -4\n};\nenum scld_error safe_create_leading_directories(char *path);\nenum scld_error safe_create_leading_directories_const(const char *path);\n\n/*\n * Callback function for raceproof_create_file(). This function is\n * expected to do something that makes dirname(path) permanent despite\n * the fact that other processes might be cleaning up empty\n * directories at the same time. Usually it will create a file named\n * path, but alternatively it could create another file in that\n * directory, or even chdir() into that directory. The function should\n * return 0 if the action was completed successfully. On error, it\n * should return a nonzero result and set errno.\n * raceproof_create_file() treats two errno values specially:\n *\n * - ENOENT -- dirname(path) does not exist. In this case,\n *             raceproof_create_file() tries creating dirname(path)\n *             (and any parent directories, if necessary) and calls\n *             the function again.\n *\n * - EISDIR -- the file already exists and is a directory. In this\n *             case, raceproof_create_file() removes the directory if\n *             it is empty (and recursively any empty directories that\n *             it contains) and calls the function again.\n *\n * Any other errno causes raceproof_create_file() to fail with the\n * callback's return value and errno.\n *\n * Obviously, this function should be OK with being called again if it\n * fails with ENOENT or EISDIR. In other scenarios it will not be\n * called again.\n */\ntypedef int create_file_fn(const char *path, void *cb);\n\n/*\n * Create a file in dirname(path) by calling fn, creating leading\n * directories if necessary. Retry a few times in case we are racing\n * with another process that is trying to clean up the directory that\n * contains path. See the documentation for create_file_fn for more\n * details.\n *\n * Return the value and set the errno that resulted from the most\n * recent call of fn. fn is always called at least once, and will be\n * called more than once if it returns ENOENT or EISDIR.\n */\nint raceproof_create_file(const char *path, create_file_fn fn, void *cb);\n\nint mkdir_in_gitdir(const char *path);\nextern char *expand_user_path(const char *path, int real_home);\nconst char *enter_repo(const char *path, int strict);\nstatic inline int is_absolute_path(const char *path)\n{\n\treturn is_dir_sep(path[0]) || has_dos_drive_prefix(path);\n}\nint is_directory(const char *);\nchar *strbuf_realpath(struct strbuf *resolved, const char *path,\n\t\t      int die_on_error);\nconst char *real_path(const char *path);\nconst char *real_path_if_valid(const char *path);\nchar *real_pathdup(const char *path, int die_on_error);\nconst char *absolute_path(const char *path);\nchar *absolute_pathdup(const char *path);\nconst char *remove_leading_path(const char *in, const char *prefix);\nconst char *relative_path(const char *in, const char *prefix, struct strbuf *sb);\nint normalize_path_copy_len(char *dst, const char *src, int *prefix_len);\nint normalize_path_copy(char *dst, const char *src);\nint longest_ancestor_length(const char *path, struct string_list *prefixes);\nchar *strip_path_suffix(const char *path, const char *suffix);\nint daemon_avoid_alias(const char *path);\n\n/*\n * These functions match their is_hfs_dotgit() counterparts; see utf8.h for\n * details.\n */\nint is_ntfs_dotgit(const char *name);\nint is_ntfs_dotgitmodules(const char *name);\nint is_ntfs_dotgitignore(const char *name);\nint is_ntfs_dotgitattributes(const char *name);\n\n/*\n * Returns true iff \"str\" could be confused as a command-line option when\n * passed to a sub-program like \"ssh\". Note that this has nothing to do with\n * shell-quoting, which should be handled separately; we're assuming here that\n * the string makes it verbatim to the sub-program.\n */\nint looks_like_command_line_option(const char *str);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CONFIG_HOME/git/$filename\" if $XDG_CONFIG_HOME is non-empty, otherwise\n * \"$HOME/.config/git/$filename\". Return NULL upon error.\n */\nextern char *xdg_config_home(const char *filename);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CACHE_HOME/git/$filename\" if $XDG_CACHE_HOME is non-empty, otherwise\n * \"$HOME/.cache/git/$filename\". Return NULL upon error.\n */\nextern char *xdg_cache_home(const char *filename);\n\nextern void *read_sha1_file_extended(const unsigned char *sha1,\n\t\t\t\t     enum object_type *type,\n\t\t\t\t     unsigned long *size, int lookup_replace);\nstatic inline void *read_sha1_file(const unsigned char *sha1, enum object_type *type, unsigned long *size)\n{\n\treturn read_sha1_file_extended(sha1, type, size, 1);\n}\n\n/*\n * This internal function is only declared here for the benefit of\n * lookup_replace_object().  Please do not call it directly.\n */\nextern const unsigned char *do_lookup_replace_object(const unsigned char *sha1);\n\n/*\n * If object sha1 should be replaced, return the replacement object's\n * name (replaced recursively, if necessary).  The return value is\n * either sha1 or a pointer to a permanently-allocated value.  When\n * object replacement is suppressed, always return sha1.\n */\nstatic inline const unsigned char *lookup_replace_object(const unsigned char *sha1)\n{\n\tif (!check_replace_refs)\n\t\treturn sha1;\n\treturn do_lookup_replace_object(sha1);\n}\n\n/* Read and unpack a sha1 file into memory, write memory to a sha1 file */\nextern int sha1_object_info(const unsigned char *, unsigned long *);\n\nextern int hash_object_file(const void *buf, unsigned long len,\n\t\t\t    const char *type, struct object_id *oid);\n\nextern int write_object_file(const void *buf, unsigned long len,\n\t\t\t     const char *type, struct object_id *oid);\n\nextern int hash_object_file_literally(const void *buf, unsigned long len,\n\t\t\t\t      const char *type, struct object_id *oid,\n\t\t\t\t      unsigned flags);\n\nextern int pretend_object_file(void *, unsigned long, enum object_type,\n\t\t\t       struct object_id *oid);\n\nextern int force_object_loose(const struct object_id *oid, time_t mtime);\n\nextern int git_open_cloexec(const char *name, int flags);\n#define git_open(name) git_open_cloexec(name, O_RDONLY)\nextern void *map_sha1_file(const unsigned char *sha1, unsigned long *size);\nextern int unpack_sha1_header(git_zstream *stream, unsigned char *map, unsigned long mapsize, void *buffer, unsigned long bufsiz);\nextern int parse_sha1_header(const char *hdr, unsigned long *sizep);\n\nextern int check_sha1_signature(const unsigned char *sha1, void *buf, unsigned long size, const char *type);\n\nextern int finalize_object_file(const char *tmpfile, const char *filename);\n\n/*\n * Open the loose object at path, check its sha1, and return the contents,\n * type, and size. If the object is a blob, then \"contents\" may return NULL,\n * to allow streaming of large blobs.\n *\n * Returns 0 on success, negative on error (details may be written to stderr).\n */\nint read_loose_object(const char *path,\n\t\t      const unsigned char *expected_sha1,\n\t\t      enum object_type *type,\n\t\t      unsigned long *size,\n\t\t      void **contents);\n\n/*\n * Convenience for sha1_object_info_extended() with a NULL struct\n * object_info. OBJECT_INFO_SKIP_CACHED is automatically set; pass\n * nonzero flags to also set other flags.\n */\nextern int has_sha1_file_with_flags(const unsigned char *sha1, int flags);\nstatic inline int has_sha1_file(const unsigned char *sha1)\n{\n\treturn has_sha1_file_with_flags(sha1, 0);\n}\n\n/* Same as the above, except for struct object_id. */\nextern int has_object_file(const struct object_id *oid);\nextern int has_object_file_with_flags(const struct object_id *oid, int flags);\n\n/*\n * Return true iff an alternate object database has a loose object\n * with the specified name.  This function does not respect replace\n * references.\n */\nextern int has_loose_object_nonlocal(const unsigned char *sha1);\n\nextern void assert_sha1_type(const unsigned char *sha1, enum object_type expect);\n\n/* Helper to check and \"touch\" a file */\nextern int check_and_freshen_file(const char *fn, int freshen);\n\nextern const signed char hexval_table[256];\nstatic inline unsigned int hexval(unsigned char c)\n{\n\treturn hexval_table[c];\n}\n\n/*\n * Convert two consecutive hexadecimal digits into a char.  Return a\n * negative value on error.  Don't run over the end of short strings.\n */\nstatic inline int hex2chr(const char *s)\n{\n\tunsigned int val = hexval(s[0]);\n\treturn (val & ~0xf) ? val : (val << 4) | hexval(s[1]);\n}\n\n/* Convert to/from hex/sha1 representation */\n#define MINIMUM_ABBREV minimum_abbrev\n#define DEFAULT_ABBREV default_abbrev\n\n/* used when the code does not know or care what the default abbrev is */\n#define FALLBACK_DEFAULT_ABBREV 7\n\nstruct object_context {\n\tunsigned char tree[20];\n\tunsigned mode;\n\t/*\n\t * symlink_path is only used by get_tree_entry_follow_symlinks,\n\t * and only for symlinks that point outside the repository.\n\t */\n\tstruct strbuf symlink_path;\n\t/*\n\t * If GET_OID_RECORD_PATH is set, this will record path (if any)\n\t * found when resolving the name. The caller is responsible for\n\t * releasing the memory.\n\t */\n\tchar *path;\n};\n\n#define GET_OID_QUIETLY           01\n#define GET_OID_COMMIT            02\n#define GET_OID_COMMITTISH        04\n#define GET_OID_TREE             010\n#define GET_OID_TREEISH          020\n#define GET_OID_BLOB             040\n#define GET_OID_FOLLOW_SYMLINKS 0100\n#define GET_OID_RECORD_PATH     0200\n#define GET_OID_ONLY_TO_DIE    04000\n\n#define GET_OID_DISAMBIGUATORS \\\n\t(GET_OID_COMMIT | GET_OID_COMMITTISH | \\\n\tGET_OID_TREE | GET_OID_TREEISH | \\\n\tGET_OID_BLOB)\n\nextern int get_oid(const char *str, struct object_id *oid);\nextern int get_oid_commit(const char *str, struct object_id *oid);\nextern int get_oid_committish(const char *str, struct object_id *oid);\nextern int get_oid_tree(const char *str, struct object_id *oid);\nextern int get_oid_treeish(const char *str, struct object_id *oid);\nextern int get_oid_blob(const char *str, struct object_id *oid);\nextern void maybe_die_on_misspelt_object_name(const char *name, const char *prefix);\nextern int get_oid_with_context(const char *str, unsigned flags, struct object_id *oid, struct object_context *oc);\n\n\ntypedef int each_abbrev_fn(const struct object_id *oid, void *);\nextern int for_each_abbrev(const char *prefix, each_abbrev_fn, void *);\n\nextern int set_disambiguate_hint_config(const char *var, const char *value);\n\n/*\n * Try to read a SHA1 in hexadecimal format from the 40 characters\n * starting at hex.  Write the 20-byte result to sha1 in binary form.\n * Return 0 on success.  Reading stops if a NUL is encountered in the\n * input, so it is safe to pass this function an arbitrary\n * null-terminated string.\n */\nextern int get_sha1_hex(const char *hex, unsigned char *sha1);\nextern int get_oid_hex(const char *hex, struct object_id *sha1);\n\n/*\n * Read `len` pairs of hexadecimal digits from `hex` and write the\n * values to `binary` as `len` bytes. Return 0 on success, or -1 if\n * the input does not consist of hex digits).\n */\nextern int hex_to_bytes(unsigned char *binary, const char *hex, size_t len);\n\n/*\n * Convert a binary sha1 to its hex equivalent. The `_r` variant is reentrant,\n * and writes the NUL-terminated output to the buffer `out`, which must be at\n * least `GIT_SHA1_HEXSZ + 1` bytes, and returns a pointer to out for\n * convenience.\n *\n * The non-`_r` variant returns a static buffer, but uses a ring of 4\n * buffers, making it safe to make multiple calls for a single statement, like:\n *\n *   printf(\"%s -> %s\", sha1_to_hex(one), sha1_to_hex(two));\n */\nextern char *sha1_to_hex_r(char *out, const unsigned char *sha1);\nextern char *oid_to_hex_r(char *out, const struct object_id *oid);\nextern char *sha1_to_hex(const unsigned char *sha1);\t/* static buffer result! */\nextern char *oid_to_hex(const struct object_id *oid);\t/* same static buffer as sha1_to_hex */\n\n/*\n * Parse a 40-character hexadecimal object ID starting from hex, updating the\n * pointer specified by end when parsing stops.  The resulting object ID is\n * stored in oid.  Returns 0 on success.  Parsing will stop on the first NUL or\n * other invalid character.  end is only updated on success; otherwise, it is\n * unmodified.\n */\nextern int parse_oid_hex(const char *hex, struct object_id *oid, const char **end);\n\n/*\n * This reads short-hand syntax that not only evaluates to a commit\n * object name, but also can act as if the end user spelled the name\n * of the branch from the command line.\n *\n * - \"@{-N}\" finds the name of the Nth previous branch we were on, and\n *   places the name of the branch in the given buf and returns the\n *   number of characters parsed if successful.\n *\n * - \"<branch>@{upstream}\" finds the name of the other ref that\n *   <branch> is configured to merge with (missing <branch> defaults\n *   to the current branch), and places the name of the branch in the\n *   given buf and returns the number of characters parsed if\n *   successful.\n *\n * If the input is not of the accepted format, it returns a negative\n * number to signal an error.\n *\n * If the input was ok but there are not N branch switches in the\n * reflog, it returns 0.\n *\n * If \"allowed\" is non-zero, it is a treated as a bitfield of allowable\n * expansions: local branches (\"refs/heads/\"), remote branches\n * (\"refs/remotes/\"), or \"HEAD\". If no \"allowed\" bits are set, any expansion is\n * allowed, even ones to refs outside of those namespaces.\n */\n#define INTERPRET_BRANCH_LOCAL (1<<0)\n#define INTERPRET_BRANCH_REMOTE (1<<1)\n#define INTERPRET_BRANCH_HEAD (1<<2)\nextern int interpret_branch_name(const char *str, int len, struct strbuf *,\n\t\t\t\t unsigned allowed);\nextern int get_oid_mb(const char *str, struct object_id *oid);\n\nextern int validate_headref(const char *ref);\n\nextern int base_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int df_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int name_compare(const char *name1, size_t len1, const char *name2, size_t len2);\nextern int cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2);\n\nextern void *read_object_with_reference(const unsigned char *sha1,\n\t\t\t\t\tconst char *required_type,\n\t\t\t\t\tunsigned long *size,\n\t\t\t\t\tunsigned char *sha1_ret);\n\nextern struct object *peel_to_type(const char *name, int namelen,\n\t\t\t\t   struct object *o, enum object_type);\n\nstruct date_mode {\n\tenum date_mode_type {\n\t\tDATE_NORMAL = 0,\n\t\tDATE_RELATIVE,\n\t\tDATE_SHORT,\n\t\tDATE_ISO8601,\n\t\tDATE_ISO8601_STRICT,\n\t\tDATE_RFC2822,\n\t\tDATE_STRFTIME,\n\t\tDATE_RAW,\n\t\tDATE_UNIX\n\t} type;\n\tconst char *strftime_fmt;\n\tint local;\n};\n\n/*\n * Convenience helper for passing a constant type, like:\n *\n *   show_date(t, tz, DATE_MODE(NORMAL));\n */\n#define DATE_MODE(t) date_mode_from_type(DATE_##t)\nstruct date_mode *date_mode_from_type(enum date_mode_type type);\n\nconst char *show_date(timestamp_t time, int timezone, const struct date_mode *mode);\nvoid show_date_relative(timestamp_t time, int tz, const struct timeval *now,\n\t\t\tstruct strbuf *timebuf);\nint parse_date(const char *date, struct strbuf *out);\nint parse_date_basic(const char *date, timestamp_t *timestamp, int *offset);\nint parse_expiry_date(const char *date, timestamp_t *timestamp);\nvoid datestamp(struct strbuf *out);\n#define approxidate(s) approxidate_careful((s), NULL)\ntimestamp_t approxidate_careful(const char *, int *);\ntimestamp_t approxidate_relative(const char *date, const struct timeval *now);\nvoid parse_date_format(const char *format, struct date_mode *mode);\nint date_overflows(timestamp_t date);\n\n#define IDENT_STRICT\t       1\n#define IDENT_NO_DATE\t       2\n#define IDENT_NO_NAME\t       4\nextern const char *git_author_info(int);\nextern const char *git_committer_info(int);\nextern const char *fmt_ident(const char *name, const char *email, const char *date_str, int);\nextern const char *fmt_name(const char *name, const char *email);\nextern const char *ident_default_name(void);\nextern const char *ident_default_email(void);\nextern const char *git_editor(void);\nextern const char *git_pager(int stdout_is_tty);\nextern int is_terminal_dumb(void);\nextern int git_ident_config(const char *, const char *, void *);\nextern void reset_ident_date(void);\n\nstruct ident_split {\n\tconst char *name_begin;\n\tconst char *name_end;\n\tconst char *mail_begin;\n\tconst char *mail_end;\n\tconst char *date_begin;\n\tconst char *date_end;\n\tconst char *tz_begin;\n\tconst char *tz_end;\n};\n/*\n * Signals an success with 0, but time part of the result may be NULL\n * if the input lacks timestamp and zone\n */\nextern int split_ident_line(struct ident_split *, const char *, int);\n\n/*\n * Like show_date, but pull the timestamp and tz parameters from\n * the ident_split. It will also sanity-check the values and produce\n * a well-known sentinel date if they appear bogus.\n */\nconst char *show_ident_date(const struct ident_split *id,\n\t\t\t    const struct date_mode *mode);\n\n/*\n * Compare split idents for equality or strict ordering. Note that we\n * compare only the ident part of the line, ignoring any timestamp.\n *\n * Because there are two fields, we must choose one as the primary key; we\n * currently arbitrarily pick the email.\n */\nextern int ident_cmp(const struct ident_split *, const struct ident_split *);\n\nstruct checkout {\n\tstruct index_state *istate;\n\tconst char *base_dir;\n\tint base_dir_len;\n\tstruct delayed_checkout *delayed_checkout;\n\tunsigned force:1,\n\t\t quiet:1,\n\t\t not_new:1,\n\t\t refresh_cache:1;\n};\n#define CHECKOUT_INIT { NULL, \"\" }\n\n#define TEMPORARY_FILENAME_LENGTH 25\nextern int checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath);\nextern void enable_delayed_checkout(struct checkout *state);\nextern int finish_delayed_checkout(struct checkout *state);\n\nstruct cache_def {\n\tstruct strbuf path;\n\tint flags;\n\tint track_flags;\n\tint prefix_len_stat_func;\n};\n#define CACHE_DEF_INIT { STRBUF_INIT, 0, 0, 0 }\nstatic inline void cache_def_clear(struct cache_def *cache)\n{\n\tstrbuf_release(&cache->path);\n}\n\nextern int has_symlink_leading_path(const char *name, int len);\nextern int threaded_has_symlink_leading_path(struct cache_def *, const char *, int);\nextern int check_leading_path(const char *name, int len);\nextern int has_dirs_only_path(const char *name, int len, int prefix_len);\nextern void schedule_dir_for_removal(const char *name, int len);\nextern void remove_scheduled_dirs(void);\n\nextern struct alternate_object_database {\n\tstruct alternate_object_database *next;\n\n\t/* see alt_scratch_buf() */\n\tstruct strbuf scratch;\n\tsize_t base_len;\n\n\t/*\n\t * Used to store the results of readdir(3) calls when searching\n\t * for unique abbreviated hashes.  This cache is never\n\t * invalidated, thus it's racy and not necessarily accurate.\n\t * That's fine for its purpose; don't use it for tasks requiring\n\t * greater accuracy!\n\t */\n\tchar loose_objects_subdir_seen[256];\n\tstruct oid_array loose_objects_cache;\n\n\tchar path[FLEX_ARRAY];\n} *alt_odb_list;\nextern void prepare_alt_odb(void);\nextern char *compute_alternate_path(const char *path, struct strbuf *err);\ntypedef int alt_odb_fn(struct alternate_object_database *, void *);\nextern int foreach_alt_odb(alt_odb_fn, void*);\n\n/*\n * Allocate a \"struct alternate_object_database\" but do _not_ actually\n * add it to the list of alternates.\n */\nstruct alternate_object_database *alloc_alt_odb(const char *dir);\n\n/*\n * Add the directory to the on-disk alternates file; the new entry will also\n * take effect in the current process.\n */\nextern void add_to_alternates_file(const char *dir);\n\n/*\n * Add the directory to the in-memory list of alternates (along with any\n * recursive alternates it points to), but do not modify the on-disk alternates\n * file.\n */\nextern void add_to_alternates_memory(const char *dir);\n\n/*\n * Returns a scratch strbuf pre-filled with the alternate object directory,\n * including a trailing slash, which can be used to access paths in the\n * alternate. Always use this over direct access to alt->scratch, as it\n * cleans up any previous use of the scratch buffer.\n */\nextern struct strbuf *alt_scratch_buf(struct alternate_object_database *alt);\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nextern struct packed_git {\n\tstruct packed_git *next;\n\tstruct list_head mru;\n\tstruct pack_window *windows;\n\toff_t pack_size;\n\tconst void *index_data;\n\tsize_t index_size;\n\tuint32_t num_objects;\n\tuint32_t num_bad_objects;\n\tunsigned char *bad_object_sha1;\n\tint index_version;\n\ttime_t mtime;\n\tint pack_fd;\n\tunsigned pack_local:1,\n\t\t pack_keep:1,\n\t\t freshened:1,\n\t\t do_not_close:1,\n\t\t pack_promisor:1;\n\tunsigned char sha1[20];\n\tstruct revindex_entry *revindex;\n\t/* something like \".git/objects/pack/xxxxx.pack\" */\n\tchar pack_name[FLEX_ARRAY]; /* more */\n} *packed_git;\n\n/*\n * A most-recently-used ordered version of the packed_git list.\n */\nextern struct list_head packed_git_mru;\n\nstruct pack_entry {\n\toff_t offset;\n\tunsigned char sha1[20];\n\tstruct packed_git *p;\n};\n\n/*\n * Create a temporary file rooted in the object database directory, or\n * die on failure. The filename is taken from \"pattern\", which should have the\n * usual \"XXXXXX\" trailer, and the resulting filename is written into the\n * \"template\" buffer. Returns the open descriptor.\n */\nextern int odb_mkstemp(struct strbuf *temp_filename, const char *pattern);\n\n/*\n * Create a pack .keep file named \"name\" (which should generally be the output\n * of odb_pack_name). Returns a file descriptor opened for writing, or -1 on\n * error.\n */\nextern int odb_pack_keep(const char *name);\n\n/*\n * Iterate over the files in the loose-object parts of the object\n * directory \"path\", triggering the following callbacks:\n *\n *  - loose_object is called for each loose object we find.\n *\n *  - loose_cruft is called for any files that do not appear to be\n *    loose objects. Note that we only look in the loose object\n *    directories \"objects/[0-9a-f]{2}/\", so we will not report\n *    \"objects/foobar\" as cruft.\n *\n *  - loose_subdir is called for each top-level hashed subdirectory\n *    of the object directory (e.g., \"$OBJDIR/f0\"). It is called\n *    after the objects in the directory are processed.\n *\n * Any callback that is NULL will be ignored. Callbacks returning non-zero\n * will end the iteration.\n *\n * In the \"buf\" variant, \"path\" is a strbuf which will also be used as a\n * scratch buffer, but restored to its original contents before\n * the function returns.\n */\ntypedef int each_loose_object_fn(const struct object_id *oid,\n\t\t\t\t const char *path,\n\t\t\t\t void *data);\ntypedef int each_loose_cruft_fn(const char *basename,\n\t\t\t\tconst char *path,\n\t\t\t\tvoid *data);\ntypedef int each_loose_subdir_fn(unsigned int nr,\n\t\t\t\t const char *path,\n\t\t\t\t void *data);\nint for_each_file_in_obj_subdir(unsigned int subdir_nr,\n\t\t\t\tstruct strbuf *path,\n\t\t\t\teach_loose_object_fn obj_cb,\n\t\t\t\teach_loose_cruft_fn cruft_cb,\n\t\t\t\teach_loose_subdir_fn subdir_cb,\n\t\t\t\tvoid *data);\nint for_each_loose_file_in_objdir(const char *path,\n\t\t\t\t  each_loose_object_fn obj_cb,\n\t\t\t\t  each_loose_cruft_fn cruft_cb,\n\t\t\t\t  each_loose_subdir_fn subdir_cb,\n\t\t\t\t  void *data);\nint for_each_loose_file_in_objdir_buf(struct strbuf *path,\n\t\t\t\t      each_loose_object_fn obj_cb,\n\t\t\t\t      each_loose_cruft_fn cruft_cb,\n\t\t\t\t      each_loose_subdir_fn subdir_cb,\n\t\t\t\t      void *data);\n\n/*\n * Iterate over loose objects in both the local\n * repository and any alternates repositories (unless the\n * LOCAL_ONLY flag is set).\n */\n#define FOR_EACH_OBJECT_LOCAL_ONLY 0x1\nextern int for_each_loose_object(each_loose_object_fn, void *, unsigned flags);\n\nstruct object_info {\n\t/* Request */\n\tenum object_type *typep;\n\tunsigned long *sizep;\n\toff_t *disk_sizep;\n\tunsigned char *delta_base_sha1;\n\tstruct strbuf *type_name;\n\tvoid **contentp;\n\n\t/* Response */\n\tenum {\n\t\tOI_CACHED,\n\t\tOI_LOOSE,\n\t\tOI_PACKED,\n\t\tOI_DBCACHED\n\t} whence;\n\tunion {\n\t\t/*\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } cached;\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } loose;\n\t\t */\n\t\tstruct {\n\t\t\tstruct packed_git *pack;\n\t\t\toff_t offset;\n\t\t\tunsigned int is_delta;\n\t\t} packed;\n\t} u;\n};\n\n/*\n * Initializer for a \"struct object_info\" that wants no items. You may\n * also memset() the memory to all-zeroes.\n */\n#define OBJECT_INFO_INIT {NULL}\n\n/* Invoke lookup_replace_object() on the given hash */\n#define OBJECT_INFO_LOOKUP_REPLACE 1\n/* Allow reading from a loose object file of unknown/bogus type */\n#define OBJECT_INFO_ALLOW_UNKNOWN_TYPE 2\n/* Do not check cached storage */\n#define OBJECT_INFO_SKIP_CACHED 4\n/* Do not retry packed storage after checking packed and loose storage */\n#define OBJECT_INFO_QUICK 8\nextern int sha1_object_info_extended(const unsigned char *, struct object_info *, unsigned flags);\n\n/*\n * Set this to 0 to prevent sha1_object_info_extended() from fetching missing\n * blobs. This has a difference only if extensions.partialClone is set.\n *\n * Its default value is 1.\n */\nextern int fetch_if_missing;\n\n/* Dumb servers support */\nextern int update_server_info(int);\n\nextern const char *get_log_output_encoding(void);\nextern const char *get_commit_output_encoding(void);\n\n/*\n * This is a hack for test programs like test-dump-untracked-cache to\n * ensure that they do not modify the untracked cache when reading it.\n * Do not use it otherwise!\n */\nextern int ignore_untracked_cache_config;\n\nextern int committer_ident_sufficiently_given(void);\nextern int author_ident_sufficiently_given(void);\n\nextern const char *git_commit_encoding;\nextern const char *git_log_output_encoding;\nextern const char *git_mailmap_file;\nextern const char *git_mailmap_blob;\n\n/* IO helper functions */\nextern void maybe_flush_or_die(FILE *, const char *);\n__attribute__((format (printf, 2, 3)))\nextern void fprintf_or_die(FILE *, const char *fmt, ...);\n\n#define COPY_READ_ERROR (-2)\n#define COPY_WRITE_ERROR (-3)\nextern int copy_fd(int ifd, int ofd);\nextern int copy_file(const char *dst, const char *src, int mode);\nextern int copy_file_with_time(const char *dst, const char *src, int mode);\n\nextern void write_or_die(int fd, const void *buf, size_t count);\nextern void fsync_or_die(int fd, const char *);\n\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\nextern ssize_t write_in_full(int fd, const void *buf, size_t count);\nextern ssize_t pread_in_full(int fd, void *buf, size_t count, off_t offset);\n\nstatic inline ssize_t write_str_in_full(int fd, const char *str)\n{\n\treturn write_in_full(fd, str, strlen(str));\n}\n\n/**\n * Open (and truncate) the file at path, write the contents of buf to it,\n * and close it. Dies if any errors are encountered.\n */\nextern void write_file_buf(const char *path, const char *buf, size_t len);\n\n/**\n * Like write_file_buf(), but format the contents into a buffer first.\n * Additionally, write_file() will append a newline if one is not already\n * present, making it convenient to write text files:\n *\n *   write_file(path, \"counter: %d\", ctr);\n */\n__attribute__((format (printf, 2, 3)))\nextern void write_file(const char *path, const char *fmt, ...);\n\n/* pager.c */\nextern void setup_pager(void);\nextern int pager_in_use(void);\nextern int pager_use_color;\nextern int term_columns(void);\nextern int decimal_width(uintmax_t);\nextern int check_pager_config(const char *cmd);\nextern void prepare_pager_args(struct child_process *, const char *pager);\n\nextern const char *editor_program;\nextern const char *askpass_program;\nextern const char *excludes_file;\n\n/* base85 */\nint decode_85(char *dst, const char *line, int linelen);\nvoid encode_85(char *buf, const unsigned char *data, int bytes);\n\n/* alloc.c */\nextern void *alloc_blob_node(void);\nextern void *alloc_tree_node(void);\nextern void *alloc_commit_node(void);\nextern void *alloc_tag_node(void);\nextern void *alloc_object_node(void);\nextern void alloc_report(void);\nextern unsigned int alloc_commit_index(void);\n\n/* pkt-line.c */\nvoid packet_trace_identity(const char *prog);\n\n/* add */\n/*\n * return 0 if success, 1 - if addition of a file failed and\n * ADD_FILES_IGNORE_ERRORS was specified in flags\n */\nint add_files_to_cache(const char *prefix, const struct pathspec *pathspec, int flags);\n\n/* diff.c */\nextern int diff_auto_refresh_index;\n\n/* match-trees.c */\nvoid shift_tree(const struct object_id *, const struct object_id *, struct object_id *, int);\nvoid shift_tree_by(const struct object_id *, const struct object_id *, struct object_id *, const char *);\n\n/*\n * whitespace rules.\n * used by both diff and apply\n * last two digits are tab width\n */\n#define WS_BLANK_AT_EOL         0100\n#define WS_SPACE_BEFORE_TAB     0200\n#define WS_INDENT_WITH_NON_TAB  0400\n#define WS_CR_AT_EOL           01000\n#define WS_BLANK_AT_EOF        02000\n#define WS_TAB_IN_INDENT       04000\n#define WS_TRAILING_SPACE      (WS_BLANK_AT_EOL|WS_BLANK_AT_EOF)\n#define WS_DEFAULT_RULE (WS_TRAILING_SPACE|WS_SPACE_BEFORE_TAB|8)\n#define WS_TAB_WIDTH_MASK        077\n/* All WS_* -- when extended, adapt diff.c emit_symbol */\n#define WS_RULE_MASK           07777\nextern unsigned whitespace_rule_cfg;\nextern unsigned whitespace_rule(const char *);\nextern unsigned parse_whitespace_rule(const char *);\nextern unsigned ws_check(const char *line, int len, unsigned ws_rule);\nextern void ws_check_emit(const char *line, int len, unsigned ws_rule, FILE *stream, const char *set, const char *reset, const char *ws);\nextern char *whitespace_error_string(unsigned ws);\nextern void ws_fix_copy(struct strbuf *, const char *, int, unsigned, int *);\nextern int ws_blank_line(const char *line, int len, unsigned ws_rule);\n#define ws_tab_width(rule)     ((rule) & WS_TAB_WIDTH_MASK)\n\n/* ls-files */\nvoid overlay_tree_on_index(struct index_state *istate,\n\t\t\t   const char *tree_name, const char *prefix);\n\nchar *alias_lookup(const char *alias);\nint split_cmdline(char *cmdline, const char ***argv);\n/* Takes a negative value returned by split_cmdline */\nconst char *split_cmdline_strerror(int cmdline_errno);\n\n/* setup.c */\nstruct startup_info {\n\tint have_repository;\n\tconst char *prefix;\n};\nextern struct startup_info *startup_info;\n\n/* merge.c */\nstruct commit_list;\nint try_merge_command(const char *strategy, size_t xopts_nr,\n\t\tconst char **xopts, struct commit_list *common,\n\t\tconst char *head_arg, struct commit_list *remotes);\nint checkout_fast_forward(const struct object_id *from,\n\t\t\t  const struct object_id *to,\n\t\t\t  int overwrite_ignore);\n\n\nint sane_execvp(const char *file, char *const argv[]);\n\n/*\n * A struct to encapsulate the concept of whether a file has changed\n * since we last checked it. This uses criteria similar to those used\n * for the index.\n */\nstruct stat_validity {\n\tstruct stat_data *sd;\n};\n\nvoid stat_validity_clear(struct stat_validity *sv);\n\n/*\n * Returns 1 if the path is a regular file (or a symlink to a regular\n * file) and matches the saved stat_validity, 0 otherwise.  A missing\n * or inaccessible file is considered a match if the struct was just\n * initialized, or if the previous update found an inaccessible file.\n */\nint stat_validity_check(struct stat_validity *sv, const char *path);\n\n/*\n * Update the stat_validity from a file opened at descriptor fd. If\n * the file is missing, inaccessible, or not a regular file, then\n * future calls to stat_validity_check will match iff one of those\n * conditions continues to be true.\n */\nvoid stat_validity_update(struct stat_validity *sv, int fd);\n\nint versioncmp(const char *s1, const char *s2);\nvoid sleep_millisec(int millisec);\n\n/*\n * Create a directory and (if share is nonzero) adjust its permissions\n * according to the shared_repository setting. Only use this for\n * directories under $GIT_DIR.  Don't use it for working tree\n * directories.\n */\nvoid safe_create_dir(const char *dir, int share);\n\n/*\n * Should we print an ellipsis after an abbreviated SHA-1 value\n * when doing diff-raw output or indicating a detached HEAD?\n */\nextern int print_sha1_ellipsis(void);\n\n#endif /* CACHE_H */\n", "#include \"../git-compat-util.h\"\n#include \"win32.h\"\n#include <conio.h>\n#include <wchar.h>\n#include \"../strbuf.h\"\n#include \"../run-command.h\"\n#include \"../cache.h\"\n\n#define HCAST(type, handle) ((type)(intptr_t)handle)\n\nstatic const int delay[] = { 0, 1, 10, 20, 40 };\n\nint err_win_to_posix(DWORD winerr)\n{\n\tint error = ENOSYS;\n\tswitch(winerr) {\n\tcase ERROR_ACCESS_DENIED: error = EACCES; break;\n\tcase ERROR_ACCOUNT_DISABLED: error = EACCES; break;\n\tcase ERROR_ACCOUNT_RESTRICTION: error = EACCES; break;\n\tcase ERROR_ALREADY_ASSIGNED: error = EBUSY; break;\n\tcase ERROR_ALREADY_EXISTS: error = EEXIST; break;\n\tcase ERROR_ARITHMETIC_OVERFLOW: error = ERANGE; break;\n\tcase ERROR_BAD_COMMAND: error = EIO; break;\n\tcase ERROR_BAD_DEVICE: error = ENODEV; break;\n\tcase ERROR_BAD_DRIVER_LEVEL: error = ENXIO; break;\n\tcase ERROR_BAD_EXE_FORMAT: error = ENOEXEC; break;\n\tcase ERROR_BAD_FORMAT: error = ENOEXEC; break;\n\tcase ERROR_BAD_LENGTH: error = EINVAL; break;\n\tcase ERROR_BAD_PATHNAME: error = ENOENT; break;\n\tcase ERROR_BAD_PIPE: error = EPIPE; break;\n\tcase ERROR_BAD_UNIT: error = ENODEV; break;\n\tcase ERROR_BAD_USERNAME: error = EINVAL; break;\n\tcase ERROR_BROKEN_PIPE: error = EPIPE; break;\n\tcase ERROR_BUFFER_OVERFLOW: error = ENAMETOOLONG; break;\n\tcase ERROR_BUSY: error = EBUSY; break;\n\tcase ERROR_BUSY_DRIVE: error = EBUSY; break;\n\tcase ERROR_CALL_NOT_IMPLEMENTED: error = ENOSYS; break;\n\tcase ERROR_CANNOT_MAKE: error = EACCES; break;\n\tcase ERROR_CANTOPEN: error = EIO; break;\n\tcase ERROR_CANTREAD: error = EIO; break;\n\tcase ERROR_CANTWRITE: error = EIO; break;\n\tcase ERROR_CRC: error = EIO; break;\n\tcase ERROR_CURRENT_DIRECTORY: error = EACCES; break;\n\tcase ERROR_DEVICE_IN_USE: error = EBUSY; break;\n\tcase ERROR_DEV_NOT_EXIST: error = ENODEV; break;\n\tcase ERROR_DIRECTORY: error = EINVAL; break;\n\tcase ERROR_DIR_NOT_EMPTY: error = ENOTEMPTY; break;\n\tcase ERROR_DISK_CHANGE: error = EIO; break;\n\tcase ERROR_DISK_FULL: error = ENOSPC; break;\n\tcase ERROR_DRIVE_LOCKED: error = EBUSY; break;\n\tcase ERROR_ENVVAR_NOT_FOUND: error = EINVAL; break;\n\tcase ERROR_EXE_MARKED_INVALID: error = ENOEXEC; break;\n\tcase ERROR_FILENAME_EXCED_RANGE: error = ENAMETOOLONG; break;\n\tcase ERROR_FILE_EXISTS: error = EEXIST; break;\n\tcase ERROR_FILE_INVALID: error = ENODEV; break;\n\tcase ERROR_FILE_NOT_FOUND: error = ENOENT; break;\n\tcase ERROR_GEN_FAILURE: error = EIO; break;\n\tcase ERROR_HANDLE_DISK_FULL: error = ENOSPC; break;\n\tcase ERROR_INSUFFICIENT_BUFFER: error = ENOMEM; break;\n\tcase ERROR_INVALID_ACCESS: error = EACCES; break;\n\tcase ERROR_INVALID_ADDRESS: error = EFAULT; break;\n\tcase ERROR_INVALID_BLOCK: error = EFAULT; break;\n\tcase ERROR_INVALID_DATA: error = EINVAL; break;\n\tcase ERROR_INVALID_DRIVE: error = ENODEV; break;\n\tcase ERROR_INVALID_EXE_SIGNATURE: error = ENOEXEC; break;\n\tcase ERROR_INVALID_FLAGS: error = EINVAL; break;\n\tcase ERROR_INVALID_FUNCTION: error = ENOSYS; break;\n\tcase ERROR_INVALID_HANDLE: error = EBADF; break;\n\tcase ERROR_INVALID_LOGON_HOURS: error = EACCES; break;\n\tcase ERROR_INVALID_NAME: error = EINVAL; break;\n\tcase ERROR_INVALID_OWNER: error = EINVAL; break;\n\tcase ERROR_INVALID_PARAMETER: error = EINVAL; break;\n\tcase ERROR_INVALID_PASSWORD: error = EPERM; break;\n\tcase ERROR_INVALID_PRIMARY_GROUP: error = EINVAL; break;\n\tcase ERROR_INVALID_SIGNAL_NUMBER: error = EINVAL; break;\n\tcase ERROR_INVALID_TARGET_HANDLE: error = EIO; break;\n\tcase ERROR_INVALID_WORKSTATION: error = EACCES; break;\n\tcase ERROR_IO_DEVICE: error = EIO; break;\n\tcase ERROR_IO_INCOMPLETE: error = EINTR; break;\n\tcase ERROR_LOCKED: error = EBUSY; break;\n\tcase ERROR_LOCK_VIOLATION: error = EACCES; break;\n\tcase ERROR_LOGON_FAILURE: error = EACCES; break;\n\tcase ERROR_MAPPED_ALIGNMENT: error = EINVAL; break;\n\tcase ERROR_META_EXPANSION_TOO_LONG: error = E2BIG; break;\n\tcase ERROR_MORE_DATA: error = EPIPE; break;\n\tcase ERROR_NEGATIVE_SEEK: error = ESPIPE; break;\n\tcase ERROR_NOACCESS: error = EFAULT; break;\n\tcase ERROR_NONE_MAPPED: error = EINVAL; break;\n\tcase ERROR_NOT_ENOUGH_MEMORY: error = ENOMEM; break;\n\tcase ERROR_NOT_READY: error = EAGAIN; break;\n\tcase ERROR_NOT_SAME_DEVICE: error = EXDEV; break;\n\tcase ERROR_NO_DATA: error = EPIPE; break;\n\tcase ERROR_NO_MORE_SEARCH_HANDLES: error = EIO; break;\n\tcase ERROR_NO_PROC_SLOTS: error = EAGAIN; break;\n\tcase ERROR_NO_SUCH_PRIVILEGE: error = EACCES; break;\n\tcase ERROR_OPEN_FAILED: error = EIO; break;\n\tcase ERROR_OPEN_FILES: error = EBUSY; break;\n\tcase ERROR_OPERATION_ABORTED: error = EINTR; break;\n\tcase ERROR_OUTOFMEMORY: error = ENOMEM; break;\n\tcase ERROR_PASSWORD_EXPIRED: error = EACCES; break;\n\tcase ERROR_PATH_BUSY: error = EBUSY; break;\n\tcase ERROR_PATH_NOT_FOUND: error = ENOENT; break;\n\tcase ERROR_PIPE_BUSY: error = EBUSY; break;\n\tcase ERROR_PIPE_CONNECTED: error = EPIPE; break;\n\tcase ERROR_PIPE_LISTENING: error = EPIPE; break;\n\tcase ERROR_PIPE_NOT_CONNECTED: error = EPIPE; break;\n\tcase ERROR_PRIVILEGE_NOT_HELD: error = EACCES; break;\n\tcase ERROR_READ_FAULT: error = EIO; break;\n\tcase ERROR_SEEK: error = EIO; break;\n\tcase ERROR_SEEK_ON_DEVICE: error = ESPIPE; break;\n\tcase ERROR_SHARING_BUFFER_EXCEEDED: error = ENFILE; break;\n\tcase ERROR_SHARING_VIOLATION: error = EACCES; break;\n\tcase ERROR_STACK_OVERFLOW: error = ENOMEM; break;\n\tcase ERROR_SWAPERROR: error = ENOENT; break;\n\tcase ERROR_TOO_MANY_MODULES: error = EMFILE; break;\n\tcase ERROR_TOO_MANY_OPEN_FILES: error = EMFILE; break;\n\tcase ERROR_UNRECOGNIZED_MEDIA: error = ENXIO; break;\n\tcase ERROR_UNRECOGNIZED_VOLUME: error = ENODEV; break;\n\tcase ERROR_WAIT_NO_CHILDREN: error = ECHILD; break;\n\tcase ERROR_WRITE_FAULT: error = EIO; break;\n\tcase ERROR_WRITE_PROTECT: error = EROFS; break;\n\t}\n\treturn error;\n}\n\nstatic inline int is_file_in_use_error(DWORD errcode)\n{\n\tswitch (errcode) {\n\tcase ERROR_SHARING_VIOLATION:\n\tcase ERROR_ACCESS_DENIED:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_yes_no_answer(void)\n{\n\tchar answer[1024];\n\n\tif (fgets(answer, sizeof(answer), stdin)) {\n\t\tsize_t answer_len = strlen(answer);\n\t\tint got_full_line = 0, c;\n\n\t\t/* remove the newline */\n\t\tif (answer_len >= 2 && answer[answer_len-2] == '\\r') {\n\t\t\tanswer[answer_len-2] = '\\0';\n\t\t\tgot_full_line = 1;\n\t\t} else if (answer_len >= 1 && answer[answer_len-1] == '\\n') {\n\t\t\tanswer[answer_len-1] = '\\0';\n\t\t\tgot_full_line = 1;\n\t\t}\n\t\t/* flush the buffer in case we did not get the full line */\n\t\tif (!got_full_line)\n\t\t\twhile ((c = getchar()) != EOF && c != '\\n')\n\t\t\t\t;\n\t} else\n\t\t/* we could not read, return the\n\t\t * default answer which is no */\n\t\treturn 0;\n\n\tif (tolower(answer[0]) == 'y' && !answer[1])\n\t\treturn 1;\n\tif (!strncasecmp(answer, \"yes\", sizeof(answer)))\n\t\treturn 1;\n\tif (tolower(answer[0]) == 'n' && !answer[1])\n\t\treturn 0;\n\tif (!strncasecmp(answer, \"no\", sizeof(answer)))\n\t\treturn 0;\n\n\t/* did not find an answer we understand */\n\treturn -1;\n}\n\nstatic int ask_yes_no_if_possible(const char *format, ...)\n{\n\tchar question[4096];\n\tconst char *retry_hook[] = { NULL, NULL, NULL };\n\tva_list args;\n\n\tva_start(args, format);\n\tvsnprintf(question, sizeof(question), format, args);\n\tva_end(args);\n\n\tif ((retry_hook[0] = mingw_getenv(\"GIT_ASK_YESNO\"))) {\n\t\tretry_hook[1] = question;\n\t\treturn !run_command_v_opt(retry_hook, 0);\n\t}\n\n\tif (!isatty(_fileno(stdin)) || !isatty(_fileno(stderr)))\n\t\treturn 0;\n\n\twhile (1) {\n\t\tint answer;\n\t\tfprintf(stderr, \"%s (y/n) \", question);\n\n\t\tif ((answer = read_yes_no_answer()) >= 0)\n\t\t\treturn answer;\n\n\t\tfprintf(stderr, \"Sorry, I did not understand your answer. \"\n\t\t\t\t\"Please type 'y' or 'n'\\n\");\n\t}\n}\n\nint mingw_unlink(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\n\t/* read-only files cannot be removed */\n\t_wchmod(wpathname, 0666);\n\twhile ((ret = _wunlink(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\tbreak;\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Unlink of file '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wunlink(wpathname);\n\treturn ret;\n}\n\nstatic int is_dir_empty(const wchar_t *wpath)\n{\n\tWIN32_FIND_DATAW findbuf;\n\tHANDLE handle;\n\twchar_t wbuf[MAX_PATH + 2];\n\twcscpy(wbuf, wpath);\n\twcscat(wbuf, L\"\\\\*\");\n\thandle = FindFirstFileW(wbuf, &findbuf);\n\tif (handle == INVALID_HANDLE_VALUE)\n\t\treturn GetLastError() == ERROR_NO_MORE_FILES;\n\n\twhile (!wcscmp(findbuf.cFileName, L\".\") ||\n\t\t\t!wcscmp(findbuf.cFileName, L\"..\"))\n\t\tif (!FindNextFileW(handle, &findbuf)) {\n\t\t\tDWORD err = GetLastError();\n\t\t\tFindClose(handle);\n\t\t\treturn err == ERROR_NO_MORE_FILES;\n\t\t}\n\tFindClose(handle);\n\treturn 0;\n}\n\nint mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\treturn ret;\n}\n\nstatic inline int needs_hiding(const char *path)\n{\n\tconst char *basename;\n\n\tif (hide_dotfiles == HIDE_DOTFILES_FALSE)\n\t\treturn 0;\n\n\t/* We cannot use basename(), as it would remove trailing slashes */\n\tmingw_skip_dos_drive_prefix((char **)&path);\n\tif (!*path)\n\t\treturn 0;\n\n\tfor (basename = path; *path; path++)\n\t\tif (is_dir_sep(*path)) {\n\t\t\tdo {\n\t\t\t\tpath++;\n\t\t\t} while (is_dir_sep(*path));\n\t\t\t/* ignore trailing slashes */\n\t\t\tif (*path)\n\t\t\t\tbasename = path;\n\t\t}\n\n\tif (hide_dotfiles == HIDE_DOTFILES_TRUE)\n\t\treturn *basename == '.';\n\n\tassert(hide_dotfiles == HIDE_DOTFILES_DOTGITONLY);\n\treturn !strncasecmp(\".git\", basename, 4) &&\n\t\t(!basename[4] || is_dir_sep(basename[4]));\n}\n\nstatic int set_hidden_flag(const wchar_t *path, int set)\n{\n\tDWORD original = GetFileAttributesW(path), modified;\n\tif (set)\n\t\tmodified = original | FILE_ATTRIBUTE_HIDDEN;\n\telse\n\t\tmodified = original & ~FILE_ATTRIBUTE_HIDDEN;\n\tif (original == modified || SetFileAttributesW(path, modified))\n\t\treturn 0;\n\terrno = err_win_to_posix(GetLastError());\n\treturn -1;\n}\n\nint mingw_mkdir(const char *path, int mode)\n{\n\tint ret;\n\twchar_t wpath[MAX_PATH];\n\n\tif (!is_valid_win32_path(path)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (xutftowcs_path(wpath, path) < 0)\n\t\treturn -1;\n\tret = _wmkdir(wpath);\n\tif (!ret && needs_hiding(path))\n\t\treturn set_hidden_flag(wpath, 1);\n\treturn ret;\n}\n\nint mingw_open (const char *filename, int oflags, ...)\n{\n\tva_list args;\n\tunsigned mode;\n\tint fd, create = (oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL);\n\twchar_t wfilename[MAX_PATH];\n\n\tva_start(args, oflags);\n\tmode = va_arg(args, int);\n\tva_end(args);\n\n\tif (!is_valid_win32_path(filename)) {\n\t\terrno = create ? EINVAL : ENOENT;\n\t\treturn -1;\n\t}\n\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\n\tif (xutftowcs_path(wfilename, filename) < 0)\n\t\treturn -1;\n\tfd = _wopen(wfilename, oflags, mode);\n\n\tif (fd < 0 && (oflags & O_ACCMODE) != O_RDONLY && errno == EACCES) {\n\t\tDWORD attrs = GetFileAttributesW(wfilename);\n\t\tif (attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\terrno = EISDIR;\n\t}\n\tif ((oflags & O_CREAT) && needs_hiding(filename)) {\n\t\t/*\n\t\t * Internally, _wopen() uses the CreateFile() API which errors\n\t\t * out with an ERROR_ACCESS_DENIED if CREATE_ALWAYS was\n\t\t * specified and an already existing file's attributes do not\n\t\t * match *exactly*. As there is no mode or flag we can set that\n\t\t * would correspond to FILE_ATTRIBUTE_HIDDEN, let's just try\n\t\t * again *without* the O_CREAT flag (that corresponds to the\n\t\t * CREATE_ALWAYS flag of CreateFile()).\n\t\t */\n\t\tif (fd < 0 && errno == EACCES)\n\t\t\tfd = _wopen(wfilename, oflags & ~O_CREAT, mode);\n\t\tif (fd >= 0 && set_hidden_flag(wfilename, 1))\n\t\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\t}\n\treturn fd;\n}\n\nstatic BOOL WINAPI ctrl_ignore(DWORD type)\n{\n\treturn TRUE;\n}\n\n#undef fgetc\nint mingw_fgetc(FILE *stream)\n{\n\tint ch;\n\tif (!isatty(_fileno(stream)))\n\t\treturn fgetc(stream);\n\n\tSetConsoleCtrlHandler(ctrl_ignore, TRUE);\n\twhile (1) {\n\t\tch = fgetc(stream);\n\t\tif (ch != EOF || GetLastError() != ERROR_OPERATION_ABORTED)\n\t\t\tbreak;\n\n\t\t/* Ctrl+C was pressed, simulate SIGINT and retry */\n\t\tmingw_raise(SIGINT);\n\t}\n\tSetConsoleCtrlHandler(ctrl_ignore, FALSE);\n\treturn ch;\n}\n\n#undef fopen\nFILE *mingw_fopen (const char *filename, const char *otype)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (!is_valid_win32_path(filename)) {\n\t\tint create = otype && strchr(otype, 'w');\n\t\terrno = create ? EINVAL : ENOENT;\n\t\treturn NULL;\n\t}\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfopen(wfilename, wotype);\n\tif (!file && GetLastError() == ERROR_INVALID_NAME)\n\t\terrno = ENOENT;\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}\n\nFILE *mingw_freopen (const char *filename, const char *otype, FILE *stream)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (!is_valid_win32_path(filename)) {\n\t\tint create = otype && strchr(otype, 'w');\n\t\terrno = create ? EINVAL : ENOENT;\n\t\treturn NULL;\n\t}\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfreopen(wfilename, wotype, stream);\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}\n\n#undef fflush\nint mingw_fflush(FILE *stream)\n{\n\tint ret = fflush(stream);\n\n\t/*\n\t * write() is used behind the scenes of stdio output functions.\n\t * Since git code does not check for errors after each stdio write\n\t * operation, it can happen that write() is called by a later\n\t * stdio function even if an earlier write() call failed. In the\n\t * case of a pipe whose readable end was closed, only the first\n\t * call to write() reports EPIPE on Windows. Subsequent write()\n\t * calls report EINVAL. It is impossible to notice whether this\n\t * fflush invocation triggered such a case, therefore, we have to\n\t * catch all EINVAL errors whole-sale.\n\t */\n\tif (ret && errno == EINVAL)\n\t\terrno = EPIPE;\n\n\treturn ret;\n}\n\n#undef write\nssize_t mingw_write(int fd, const void *buf, size_t len)\n{\n\tssize_t result = write(fd, buf, len);\n\n\tif (result < 0 && errno == EINVAL && buf) {\n\t\t/* check if fd is a pipe */\n\t\tHANDLE h = (HANDLE) _get_osfhandle(fd);\n\t\tif (GetFileType(h) == FILE_TYPE_PIPE)\n\t\t\terrno = EPIPE;\n\t\telse\n\t\t\terrno = EINVAL;\n\t}\n\n\treturn result;\n}\n\nint mingw_access(const char *filename, int mode)\n{\n\twchar_t wfilename[MAX_PATH];\n\tif (xutftowcs_path(wfilename, filename) < 0)\n\t\treturn -1;\n\t/* X_OK is not supported by the MSVCRT version */\n\treturn _waccess(wfilename, mode & ~X_OK);\n}\n\nint mingw_chdir(const char *dirname)\n{\n\twchar_t wdirname[MAX_PATH];\n\tif (xutftowcs_path(wdirname, dirname) < 0)\n\t\treturn -1;\n\treturn _wchdir(wdirname);\n}\n\nint mingw_chmod(const char *filename, int mode)\n{\n\twchar_t wfilename[MAX_PATH];\n\tif (xutftowcs_path(wfilename, filename) < 0)\n\t\treturn -1;\n\treturn _wchmod(wfilename, mode);\n}\n\n/*\n * The unit of FILETIME is 100-nanoseconds since January 1, 1601, UTC.\n * Returns the 100-nanoseconds (\"hekto nanoseconds\") since the epoch.\n */\nstatic inline long long filetime_to_hnsec(const FILETIME *ft)\n{\n\tlong long winTime = ((long long)ft->dwHighDateTime << 32) + ft->dwLowDateTime;\n\t/* Windows to Unix Epoch conversion */\n\treturn winTime - 116444736000000000LL;\n}\n\nstatic inline time_t filetime_to_time_t(const FILETIME *ft)\n{\n\treturn (time_t)(filetime_to_hnsec(ft) / 10000000);\n}\n\n/**\n * Verifies that safe_create_leading_directories() would succeed.\n */\nstatic int has_valid_directory_prefix(wchar_t *wfilename)\n{\n\tint n = wcslen(wfilename);\n\n\twhile (n > 0) {\n\t\twchar_t c = wfilename[--n];\n\t\tDWORD attributes;\n\n\t\tif (!is_dir_sep(c))\n\t\t\tcontinue;\n\n\t\twfilename[n] = L'\\0';\n\t\tattributes = GetFileAttributesW(wfilename);\n\t\twfilename[n] = c;\n\t\tif (attributes == FILE_ATTRIBUTE_DIRECTORY ||\n\t\t\t\tattributes == FILE_ATTRIBUTE_DEVICE)\n\t\t\treturn 1;\n\t\tif (attributes == INVALID_FILE_ATTRIBUTES)\n\t\t\tswitch (GetLastError()) {\n\t\t\tcase ERROR_PATH_NOT_FOUND:\n\t\t\t\tcontinue;\n\t\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\t\t/* This implies parent directory exists. */\n\t\t\t\treturn 1;\n\t\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* We keep the do_lstat code in a separate function to avoid recursion.\n * When a path ends with a slash, the stat will fail with ENOENT. In\n * this case, we strip the trailing slashes and stat again.\n *\n * If follow is true then act like stat() and report on the link\n * target. Otherwise report on the link itself.\n */\nstatic int do_lstat(int follow, const char *file_name, struct stat *buf)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\twchar_t wfilename[MAX_PATH];\n\tif (xutftowcs_path(wfilename, file_name) < 0)\n\t\treturn -1;\n\n\tif (GetFileAttributesExW(wfilename, GetFileExInfoStandard, &fdata)) {\n\t\tbuf->st_ino = 0;\n\t\tbuf->st_gid = 0;\n\t\tbuf->st_uid = 0;\n\t\tbuf->st_nlink = 1;\n\t\tbuf->st_mode = file_attr_to_st_mode(fdata.dwFileAttributes);\n\t\tbuf->st_size = fdata.nFileSizeLow |\n\t\t\t(((off_t)fdata.nFileSizeHigh)<<32);\n\t\tbuf->st_dev = buf->st_rdev = 0; /* not used by Git */\n\t\tbuf->st_atime = filetime_to_time_t(&(fdata.ftLastAccessTime));\n\t\tbuf->st_mtime = filetime_to_time_t(&(fdata.ftLastWriteTime));\n\t\tbuf->st_ctime = filetime_to_time_t(&(fdata.ftCreationTime));\n\t\tif (fdata.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {\n\t\t\tWIN32_FIND_DATAW findbuf;\n\t\t\tHANDLE handle = FindFirstFileW(wfilename, &findbuf);\n\t\t\tif (handle != INVALID_HANDLE_VALUE) {\n\t\t\t\tif ((findbuf.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&\n\t\t\t\t\t\t(findbuf.dwReserved0 == IO_REPARSE_TAG_SYMLINK)) {\n\t\t\t\t\tif (follow) {\n\t\t\t\t\t\tchar buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n\t\t\t\t\t\tbuf->st_size = readlink(file_name, buffer, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf->st_mode = S_IFLNK;\n\t\t\t\t\t}\n\t\t\t\t\tbuf->st_mode |= S_IREAD;\n\t\t\t\t\tif (!(findbuf.dwFileAttributes & FILE_ATTRIBUTE_READONLY))\n\t\t\t\t\t\tbuf->st_mode |= S_IWRITE;\n\t\t\t\t}\n\t\t\t\tFindClose(handle);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\tcase ERROR_SHARING_VIOLATION:\n\tcase ERROR_LOCK_VIOLATION:\n\tcase ERROR_SHARING_BUFFER_EXCEEDED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tcase ERROR_BUFFER_OVERFLOW:\n\t\terrno = ENAMETOOLONG;\n\t\tbreak;\n\tcase ERROR_NOT_ENOUGH_MEMORY:\n\t\terrno = ENOMEM;\n\t\tbreak;\n\tcase ERROR_PATH_NOT_FOUND:\n\t\tif (!has_valid_directory_prefix(wfilename)) {\n\t\t\terrno = ENOTDIR;\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthru */\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\n/* We provide our own lstat/fstat functions, since the provided\n * lstat/fstat functions are so slow. These stat functions are\n * tailored for Git's usage (read: fast), and are not meant to be\n * complete. Note that Git stat()s are redirected to mingw_lstat()\n * too, since Windows doesn't really handle symlinks that well.\n */\nstatic int do_stat_internal(int follow, const char *file_name, struct stat *buf)\n{\n\tint namelen;\n\tchar alt_name[PATH_MAX];\n\n\tif (!do_lstat(follow, file_name, buf))\n\t\treturn 0;\n\n\t/* if file_name ended in a '/', Windows returned ENOENT;\n\t * try again without trailing slashes\n\t */\n\tif (errno != ENOENT)\n\t\treturn -1;\n\n\tnamelen = strlen(file_name);\n\tif (namelen && file_name[namelen-1] != '/')\n\t\treturn -1;\n\twhile (namelen && file_name[namelen-1] == '/')\n\t\t--namelen;\n\tif (!namelen || namelen >= PATH_MAX)\n\t\treturn -1;\n\n\tmemcpy(alt_name, file_name, namelen);\n\talt_name[namelen] = 0;\n\treturn do_lstat(follow, alt_name, buf);\n}\n\nint mingw_lstat(const char *file_name, struct stat *buf)\n{\n\treturn do_stat_internal(0, file_name, buf);\n}\nint mingw_stat(const char *file_name, struct stat *buf)\n{\n\treturn do_stat_internal(1, file_name, buf);\n}\n\nint mingw_fstat(int fd, struct stat *buf)\n{\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\tBY_HANDLE_FILE_INFORMATION fdata;\n\n\tif (fh == INVALID_HANDLE_VALUE) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\t/* direct non-file handles to MS's fstat() */\n\tif (GetFileType(fh) != FILE_TYPE_DISK)\n\t\treturn _fstati64(fd, buf);\n\n\tif (GetFileInformationByHandle(fh, &fdata)) {\n\t\tbuf->st_ino = 0;\n\t\tbuf->st_gid = 0;\n\t\tbuf->st_uid = 0;\n\t\tbuf->st_nlink = 1;\n\t\tbuf->st_mode = file_attr_to_st_mode(fdata.dwFileAttributes);\n\t\tbuf->st_size = fdata.nFileSizeLow |\n\t\t\t(((off_t)fdata.nFileSizeHigh)<<32);\n\t\tbuf->st_dev = buf->st_rdev = 0; /* not used by Git */\n\t\tbuf->st_atime = filetime_to_time_t(&(fdata.ftLastAccessTime));\n\t\tbuf->st_mtime = filetime_to_time_t(&(fdata.ftLastWriteTime));\n\t\tbuf->st_ctime = filetime_to_time_t(&(fdata.ftCreationTime));\n\t\treturn 0;\n\t}\n\terrno = EBADF;\n\treturn -1;\n}\n\nstatic inline void time_t_to_filetime(time_t t, FILETIME *ft)\n{\n\tlong long winTime = t * 10000000LL + 116444736000000000LL;\n\tft->dwLowDateTime = winTime;\n\tft->dwHighDateTime = winTime >> 32;\n}\n\nint mingw_utime (const char *file_name, const struct utimbuf *times)\n{\n\tFILETIME mft, aft;\n\tint fh, rc;\n\tDWORD attrs;\n\twchar_t wfilename[MAX_PATH];\n\tif (xutftowcs_path(wfilename, file_name) < 0)\n\t\treturn -1;\n\n\t/* must have write permission */\n\tattrs = GetFileAttributesW(wfilename);\n\tif (attrs != INVALID_FILE_ATTRIBUTES &&\n\t    (attrs & FILE_ATTRIBUTE_READONLY)) {\n\t\t/* ignore errors here; open() will report them */\n\t\tSetFileAttributesW(wfilename, attrs & ~FILE_ATTRIBUTE_READONLY);\n\t}\n\n\tif ((fh = _wopen(wfilename, O_RDWR | O_BINARY)) < 0) {\n\t\trc = -1;\n\t\tgoto revert_attrs;\n\t}\n\n\tif (times) {\n\t\ttime_t_to_filetime(times->modtime, &mft);\n\t\ttime_t_to_filetime(times->actime, &aft);\n\t} else {\n\t\tGetSystemTimeAsFileTime(&mft);\n\t\taft = mft;\n\t}\n\tif (!SetFileTime((HANDLE)_get_osfhandle(fh), NULL, &aft, &mft)) {\n\t\terrno = EINVAL;\n\t\trc = -1;\n\t} else\n\t\trc = 0;\n\tclose(fh);\n\nrevert_attrs:\n\tif (attrs != INVALID_FILE_ATTRIBUTES &&\n\t    (attrs & FILE_ATTRIBUTE_READONLY)) {\n\t\t/* ignore errors again */\n\t\tSetFileAttributesW(wfilename, attrs);\n\t}\n\treturn rc;\n}\n\n#undef strftime\nsize_t mingw_strftime(char *s, size_t max,\n\t\t      const char *format, const struct tm *tm)\n{\n\tsize_t ret = strftime(s, max, format, tm);\n\n\tif (!ret && errno == EINVAL)\n\t\tdie(\"invalid strftime format: '%s'\", format);\n\treturn ret;\n}\n\nunsigned int sleep (unsigned int seconds)\n{\n\tSleep(seconds*1000);\n\treturn 0;\n}\n\nchar *mingw_mktemp(char *template)\n{\n\twchar_t wtemplate[MAX_PATH];\n\tif (xutftowcs_path(wtemplate, template) < 0)\n\t\treturn NULL;\n\tif (!_wmktemp(wtemplate))\n\t\treturn NULL;\n\tif (xwcstoutf(template, wtemplate, strlen(template) + 1) < 0)\n\t\treturn NULL;\n\treturn template;\n}\n\nint mkstemp(char *template)\n{\n\tchar *filename = mktemp(template);\n\tif (filename == NULL)\n\t\treturn -1;\n\treturn open(filename, O_RDWR | O_CREAT, 0600);\n}\n\nint gettimeofday(struct timeval *tv, void *tz)\n{\n\tFILETIME ft;\n\tlong long hnsec;\n\n\tGetSystemTimeAsFileTime(&ft);\n\thnsec = filetime_to_hnsec(&ft);\n\ttv->tv_sec = hnsec / 10000000;\n\ttv->tv_usec = (hnsec % 10000000) / 10;\n\treturn 0;\n}\n\nint pipe(int filedes[2])\n{\n\tHANDLE h[2];\n\n\t/* this creates non-inheritable handles */\n\tif (!CreatePipe(&h[0], &h[1], NULL, 8192)) {\n\t\terrno = err_win_to_posix(GetLastError());\n\t\treturn -1;\n\t}\n\tfiledes[0] = _open_osfhandle(HCAST(int, h[0]), O_NOINHERIT);\n\tif (filedes[0] < 0) {\n\t\tCloseHandle(h[0]);\n\t\tCloseHandle(h[1]);\n\t\treturn -1;\n\t}\n\tfiledes[1] = _open_osfhandle(HCAST(int, h[1]), O_NOINHERIT);\n\tif (filedes[1] < 0) {\n\t\tclose(filedes[0]);\n\t\tCloseHandle(h[1]);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstruct tm *gmtime_r(const time_t *timep, struct tm *result)\n{\n\t/* gmtime() in MSVCRT.DLL is thread-safe, but not reentrant */\n\tmemcpy(result, gmtime(timep), sizeof(struct tm));\n\treturn result;\n}\n\nstruct tm *localtime_r(const time_t *timep, struct tm *result)\n{\n\t/* localtime() in MSVCRT.DLL is thread-safe, but not reentrant */\n\tmemcpy(result, localtime(timep), sizeof(struct tm));\n\treturn result;\n}\n\nchar *mingw_getcwd(char *pointer, int len)\n{\n\twchar_t wpointer[MAX_PATH];\n\tif (!_wgetcwd(wpointer, ARRAY_SIZE(wpointer)))\n\t\treturn NULL;\n\tif (xwcstoutf(pointer, wpointer, len) < 0)\n\t\treturn NULL;\n\tconvert_slashes(pointer);\n\treturn pointer;\n}\n\n/*\n * See http://msdn2.microsoft.com/en-us/library/17w5ykft(vs.71).aspx\n * (Parsing C++ Command-Line Arguments)\n */\nstatic const char *quote_arg(const char *arg)\n{\n\t/* count chars to quote */\n\tint len = 0, n = 0;\n\tint force_quotes = 0;\n\tchar *q, *d;\n\tconst char *p = arg;\n\tif (!*p) force_quotes = 1;\n\twhile (*p) {\n\t\tif (isspace(*p) || *p == '*' || *p == '?' || *p == '{' || *p == '\\'')\n\t\t\tforce_quotes = 1;\n\t\telse if (*p == '\"')\n\t\t\tn++;\n\t\telse if (*p == '\\\\') {\n\t\t\tint count = 0;\n\t\t\twhile (*p == '\\\\') {\n\t\t\t\tcount++;\n\t\t\t\tp++;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (*p == '\"' || !*p)\n\t\t\t\tn += count*2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tlen++;\n\t\tp++;\n\t}\n\tif (!force_quotes && n == 0)\n\t\treturn arg;\n\n\t/* insert \\ where necessary */\n\td = q = xmalloc(st_add3(len, n, 3));\n\t*d++ = '\"';\n\twhile (*arg) {\n\t\tif (*arg == '\"')\n\t\t\t*d++ = '\\\\';\n\t\telse if (*arg == '\\\\') {\n\t\t\tint count = 0;\n\t\t\twhile (*arg == '\\\\') {\n\t\t\t\tcount++;\n\t\t\t\t*d++ = *arg++;\n\t\t\t}\n\t\t\tif (*arg == '\"' || !*arg) {\n\t\t\t\twhile (count-- > 0)\n\t\t\t\t\t*d++ = '\\\\';\n\t\t\t\t/* don't escape the surrounding end quote */\n\t\t\t\tif (!*arg)\n\t\t\t\t\tbreak;\n\t\t\t\t*d++ = '\\\\';\n\t\t\t}\n\t\t}\n\t\t*d++ = *arg++;\n\t}\n\t*d++ = '\"';\n\t*d++ = '\\0';\n\treturn q;\n}\n\nstatic const char *parse_interpreter(const char *cmd)\n{\n\tstatic char buf[100];\n\tchar *p, *opt;\n\tint n, fd;\n\n\t/* don't even try a .exe */\n\tn = strlen(cmd);\n\tif (n >= 4 && !strcasecmp(cmd+n-4, \".exe\"))\n\t\treturn NULL;\n\n\tfd = open(cmd, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\tn = read(fd, buf, sizeof(buf)-1);\n\tclose(fd);\n\tif (n < 4)\t/* at least '#!/x' and not error */\n\t\treturn NULL;\n\n\tif (buf[0] != '#' || buf[1] != '!')\n\t\treturn NULL;\n\tbuf[n] = '\\0';\n\tp = buf + strcspn(buf, \"\\r\\n\");\n\tif (!*p)\n\t\treturn NULL;\n\n\t*p = '\\0';\n\tif (!(p = strrchr(buf+2, '/')) && !(p = strrchr(buf+2, '\\\\')))\n\t\treturn NULL;\n\t/* strip options */\n\tif ((opt = strchr(p+1, ' ')))\n\t\t*opt = '\\0';\n\treturn p+1;\n}\n\n/*\n * exe_only means that we only want to detect .exe files, but not scripts\n * (which do not have an extension)\n */\nstatic char *lookup_prog(const char *dir, int dirlen, const char *cmd,\n\t\t\t int isexe, int exe_only)\n{\n\tchar path[MAX_PATH];\n\tsnprintf(path, sizeof(path), \"%.*s\\\\%s.exe\", dirlen, dir, cmd);\n\n\tif (!isexe && access(path, F_OK) == 0)\n\t\treturn xstrdup(path);\n\tpath[strlen(path)-4] = '\\0';\n\tif ((!exe_only || isexe) && access(path, F_OK) == 0)\n\t\tif (!(GetFileAttributes(path) & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\treturn xstrdup(path);\n\treturn NULL;\n}\n\n/*\n * Determines the absolute path of cmd using the split path in path.\n * If cmd contains a slash or backslash, no lookup is performed.\n */\nstatic char *path_lookup(const char *cmd, int exe_only)\n{\n\tconst char *path;\n\tchar *prog = NULL;\n\tint len = strlen(cmd);\n\tint isexe = len >= 4 && !strcasecmp(cmd+len-4, \".exe\");\n\n\tif (strchr(cmd, '/') || strchr(cmd, '\\\\'))\n\t\treturn xstrdup(cmd);\n\n\tpath = mingw_getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\twhile (!prog) {\n\t\tconst char *sep = strchrnul(path, ';');\n\t\tint dirlen = sep - path;\n\t\tif (dirlen)\n\t\t\tprog = lookup_prog(path, dirlen, cmd, isexe, exe_only);\n\t\tif (!*sep)\n\t\t\tbreak;\n\t\tpath = sep + 1;\n\t}\n\n\treturn prog;\n}\n\nstatic int do_putenv(char **env, const char *name, int size, int free_old);\n\n/* used number of elements of environ array, including terminating NULL */\nstatic int environ_size = 0;\n/* allocated size of environ array, in bytes */\nstatic int environ_alloc = 0;\n\n/*\n * Create environment block suitable for CreateProcess. Merges current\n * process environment and the supplied environment changes.\n */\nstatic wchar_t *make_environment_block(char **deltaenv)\n{\n\twchar_t *wenvblk = NULL;\n\tchar **tmpenv;\n\tint i = 0, size = environ_size, wenvsz = 0, wenvpos = 0;\n\n\twhile (deltaenv && deltaenv[i])\n\t\ti++;\n\n\t/* copy the environment, leaving space for changes */\n\tALLOC_ARRAY(tmpenv, size + i);\n\tmemcpy(tmpenv, environ, size * sizeof(char*));\n\n\t/* merge supplied environment changes into the temporary environment */\n\tfor (i = 0; deltaenv && deltaenv[i]; i++)\n\t\tsize = do_putenv(tmpenv, deltaenv[i], size, 0);\n\n\t/* create environment block from temporary environment */\n\tfor (i = 0; tmpenv[i]; i++) {\n\t\tsize = 2 * strlen(tmpenv[i]) + 2; /* +2 for final \\0 */\n\t\tALLOC_GROW(wenvblk, (wenvpos + size) * sizeof(wchar_t), wenvsz);\n\t\twenvpos += xutftowcs(&wenvblk[wenvpos], tmpenv[i], size) + 1;\n\t}\n\t/* add final \\0 terminator */\n\twenvblk[wenvpos] = 0;\n\tfree(tmpenv);\n\treturn wenvblk;\n}\n\nstruct pinfo_t {\n\tstruct pinfo_t *next;\n\tpid_t pid;\n\tHANDLE proc;\n};\nstatic struct pinfo_t *pinfo = NULL;\nCRITICAL_SECTION pinfo_cs;\n\nstatic pid_t mingw_spawnve_fd(const char *cmd, const char **argv, char **deltaenv,\n\t\t\t      const char *dir,\n\t\t\t      int prepend_cmd, int fhin, int fhout, int fherr)\n{\n\tSTARTUPINFOW si;\n\tPROCESS_INFORMATION pi;\n\tstruct strbuf args;\n\twchar_t wcmd[MAX_PATH], wdir[MAX_PATH], *wargs, *wenvblk = NULL;\n\tunsigned flags = CREATE_UNICODE_ENVIRONMENT;\n\tBOOL ret;\n\n\t/* Determine whether or not we are associated to a console */\n\tHANDLE cons = CreateFile(\"CONOUT$\", GENERIC_WRITE,\n\t\t\tFILE_SHARE_WRITE, NULL, OPEN_EXISTING,\n\t\t\tFILE_ATTRIBUTE_NORMAL, NULL);\n\tif (cons == INVALID_HANDLE_VALUE) {\n\t\t/* There is no console associated with this process.\n\t\t * Since the child is a console process, Windows\n\t\t * would normally create a console window. But\n\t\t * since we'll be redirecting std streams, we do\n\t\t * not need the console.\n\t\t * It is necessary to use DETACHED_PROCESS\n\t\t * instead of CREATE_NO_WINDOW to make ssh\n\t\t * recognize that it has no console.\n\t\t */\n\t\tflags |= DETACHED_PROCESS;\n\t} else {\n\t\t/* There is already a console. If we specified\n\t\t * DETACHED_PROCESS here, too, Windows would\n\t\t * disassociate the child from the console.\n\t\t * The same is true for CREATE_NO_WINDOW.\n\t\t * Go figure!\n\t\t */\n\t\tCloseHandle(cons);\n\t}\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\tsi.dwFlags = STARTF_USESTDHANDLES;\n\tsi.hStdInput = winansi_get_osfhandle(fhin);\n\tsi.hStdOutput = winansi_get_osfhandle(fhout);\n\tsi.hStdError = winansi_get_osfhandle(fherr);\n\n\tif (xutftowcs_path(wcmd, cmd) < 0)\n\t\treturn -1;\n\tif (dir && xutftowcs_path(wdir, dir) < 0)\n\t\treturn -1;\n\n\t/* concatenate argv, quoting args as we go */\n\tstrbuf_init(&args, 0);\n\tif (prepend_cmd) {\n\t\tchar *quoted = (char *)quote_arg(cmd);\n\t\tstrbuf_addstr(&args, quoted);\n\t\tif (quoted != cmd)\n\t\t\tfree(quoted);\n\t}\n\tfor (; *argv; argv++) {\n\t\tchar *quoted = (char *)quote_arg(*argv);\n\t\tif (*args.buf)\n\t\t\tstrbuf_addch(&args, ' ');\n\t\tstrbuf_addstr(&args, quoted);\n\t\tif (quoted != *argv)\n\t\t\tfree(quoted);\n\t}\n\n\tALLOC_ARRAY(wargs, st_add(st_mult(2, args.len), 1));\n\txutftowcs(wargs, args.buf, 2 * args.len + 1);\n\tstrbuf_release(&args);\n\n\twenvblk = make_environment_block(deltaenv);\n\n\tmemset(&pi, 0, sizeof(pi));\n\tret = CreateProcessW(wcmd, wargs, NULL, NULL, TRUE, flags,\n\t\twenvblk, dir ? wdir : NULL, &si, &pi);\n\n\tfree(wenvblk);\n\tfree(wargs);\n\n\tif (!ret) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\tCloseHandle(pi.hThread);\n\n\t/*\n\t * The process ID is the human-readable identifier of the process\n\t * that we want to present in log and error messages. The handle\n\t * is not useful for this purpose. But we cannot close it, either,\n\t * because it is not possible to turn a process ID into a process\n\t * handle after the process terminated.\n\t * Keep the handle in a list for waitpid.\n\t */\n\tEnterCriticalSection(&pinfo_cs);\n\t{\n\t\tstruct pinfo_t *info = xmalloc(sizeof(struct pinfo_t));\n\t\tinfo->pid = pi.dwProcessId;\n\t\tinfo->proc = pi.hProcess;\n\t\tinfo->next = pinfo;\n\t\tpinfo = info;\n\t}\n\tLeaveCriticalSection(&pinfo_cs);\n\n\treturn (pid_t)pi.dwProcessId;\n}\n\nstatic pid_t mingw_spawnv(const char *cmd, const char **argv, int prepend_cmd)\n{\n\treturn mingw_spawnve_fd(cmd, argv, NULL, NULL, prepend_cmd, 0, 1, 2);\n}\n\npid_t mingw_spawnvpe(const char *cmd, const char **argv, char **deltaenv,\n\t\t     const char *dir,\n\t\t     int fhin, int fhout, int fherr)\n{\n\tpid_t pid;\n\tchar *prog = path_lookup(cmd, 0);\n\n\tif (!prog) {\n\t\terrno = ENOENT;\n\t\tpid = -1;\n\t}\n\telse {\n\t\tconst char *interpr = parse_interpreter(prog);\n\n\t\tif (interpr) {\n\t\t\tconst char *argv0 = argv[0];\n\t\t\tchar *iprog = path_lookup(interpr, 1);\n\t\t\targv[0] = prog;\n\t\t\tif (!iprog) {\n\t\t\t\terrno = ENOENT;\n\t\t\t\tpid = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpid = mingw_spawnve_fd(iprog, argv, deltaenv, dir, 1,\n\t\t\t\t\t\t       fhin, fhout, fherr);\n\t\t\t\tfree(iprog);\n\t\t\t}\n\t\t\targv[0] = argv0;\n\t\t}\n\t\telse\n\t\t\tpid = mingw_spawnve_fd(prog, argv, deltaenv, dir, 0,\n\t\t\t\t\t       fhin, fhout, fherr);\n\t\tfree(prog);\n\t}\n\treturn pid;\n}\n\nstatic int try_shell_exec(const char *cmd, char *const *argv)\n{\n\tconst char *interpr = parse_interpreter(cmd);\n\tchar *prog;\n\tint pid = 0;\n\n\tif (!interpr)\n\t\treturn 0;\n\tprog = path_lookup(interpr, 1);\n\tif (prog) {\n\t\tint argc = 0;\n\t\tconst char **argv2;\n\t\twhile (argv[argc]) argc++;\n\t\tALLOC_ARRAY(argv2, argc + 1);\n\t\targv2[0] = (char *)cmd;\t/* full path to the script file */\n\t\tmemcpy(&argv2[1], &argv[1], sizeof(*argv) * argc);\n\t\tpid = mingw_spawnv(prog, argv2, 1);\n\t\tif (pid >= 0) {\n\t\t\tint status;\n\t\t\tif (waitpid(pid, &status, 0) < 0)\n\t\t\t\tstatus = 255;\n\t\t\texit(status);\n\t\t}\n\t\tpid = 1;\t/* indicate that we tried but failed */\n\t\tfree(prog);\n\t\tfree(argv2);\n\t}\n\treturn pid;\n}\n\nint mingw_execv(const char *cmd, char *const *argv)\n{\n\t/* check if git_command is a shell script */\n\tif (!try_shell_exec(cmd, argv)) {\n\t\tint pid, status;\n\n\t\tpid = mingw_spawnv(cmd, (const char **)argv, 0);\n\t\tif (pid < 0)\n\t\t\treturn -1;\n\t\tif (waitpid(pid, &status, 0) < 0)\n\t\t\tstatus = 255;\n\t\texit(status);\n\t}\n\treturn -1;\n}\n\nint mingw_execvp(const char *cmd, char *const *argv)\n{\n\tchar *prog = path_lookup(cmd, 0);\n\n\tif (prog) {\n\t\tmingw_execv(prog, argv);\n\t\tfree(prog);\n\t} else\n\t\terrno = ENOENT;\n\n\treturn -1;\n}\n\nint mingw_kill(pid_t pid, int sig)\n{\n\tif (pid > 0 && sig == SIGTERM) {\n\t\tHANDLE h = OpenProcess(PROCESS_TERMINATE, FALSE, pid);\n\n\t\tif (TerminateProcess(h, -1)) {\n\t\t\tCloseHandle(h);\n\t\t\treturn 0;\n\t\t}\n\n\t\terrno = err_win_to_posix(GetLastError());\n\t\tCloseHandle(h);\n\t\treturn -1;\n\t} else if (pid > 0 && sig == 0) {\n\t\tHANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);\n\t\tif (h) {\n\t\t\tCloseHandle(h);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\terrno = EINVAL;\n\treturn -1;\n}\n\n/*\n * Compare environment entries by key (i.e. stopping at '=' or '\\0').\n */\nstatic int compareenv(const void *v1, const void *v2)\n{\n\tconst char *e1 = *(const char**)v1;\n\tconst char *e2 = *(const char**)v2;\n\n\tfor (;;) {\n\t\tint c1 = *e1++;\n\t\tint c2 = *e2++;\n\t\tc1 = (c1 == '=') ? 0 : tolower(c1);\n\t\tc2 = (c2 == '=') ? 0 : tolower(c2);\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 == 0)\n\t\t\treturn 0;\n\t}\n}\n\nstatic int bsearchenv(char **env, const char *name, size_t size)\n{\n\tunsigned low = 0, high = size;\n\twhile (low < high) {\n\t\tunsigned mid = low + ((high - low) >> 1);\n\t\tint cmp = compareenv(&env[mid], &name);\n\t\tif (cmp < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (cmp > 0)\n\t\t\thigh = mid;\n\t\telse\n\t\t\treturn mid;\n\t}\n\treturn ~low; /* not found, return 1's complement of insert position */\n}\n\n/*\n * If name contains '=', then sets the variable, otherwise it unsets it\n * Size includes the terminating NULL. Env must have room for size + 1 entries\n * (in case of insert). Returns the new size. Optionally frees removed entries.\n */\nstatic int do_putenv(char **env, const char *name, int size, int free_old)\n{\n\tint i = bsearchenv(env, name, size - 1);\n\n\t/* optionally free removed / replaced entry */\n\tif (i >= 0 && free_old)\n\t\tfree(env[i]);\n\n\tif (strchr(name, '=')) {\n\t\t/* if new value ('key=value') is specified, insert or replace entry */\n\t\tif (i < 0) {\n\t\t\ti = ~i;\n\t\t\tmemmove(&env[i + 1], &env[i], (size - i) * sizeof(char*));\n\t\t\tsize++;\n\t\t}\n\t\tenv[i] = (char*) name;\n\t} else if (i >= 0) {\n\t\t/* otherwise ('key') remove existing entry */\n\t\tsize--;\n\t\tmemmove(&env[i], &env[i + 1], (size - i) * sizeof(char*));\n\t}\n\treturn size;\n}\n\nchar *mingw_getenv(const char *name)\n{\n\tchar *value;\n\tint pos = bsearchenv(environ, name, environ_size - 1);\n\tif (pos < 0)\n\t\treturn NULL;\n\tvalue = strchr(environ[pos], '=');\n\treturn value ? &value[1] : NULL;\n}\n\nint mingw_putenv(const char *namevalue)\n{\n\tALLOC_GROW(environ, (environ_size + 1) * sizeof(char*), environ_alloc);\n\tenviron_size = do_putenv(environ, namevalue, environ_size, 1);\n\treturn 0;\n}\n\n/*\n * Note, this isn't a complete replacement for getaddrinfo. It assumes\n * that service contains a numerical port, or that it is null. It\n * does a simple search using gethostbyname, and returns one IPv4 host\n * if one was found.\n */\nstatic int WSAAPI getaddrinfo_stub(const char *node, const char *service,\n\t\t\t\t   const struct addrinfo *hints,\n\t\t\t\t   struct addrinfo **res)\n{\n\tstruct hostent *h = NULL;\n\tstruct addrinfo *ai;\n\tstruct sockaddr_in *sin;\n\n\tif (node) {\n\t\th = gethostbyname(node);\n\t\tif (!h)\n\t\t\treturn WSAGetLastError();\n\t}\n\n\tai = xmalloc(sizeof(struct addrinfo));\n\t*res = ai;\n\tai->ai_flags = 0;\n\tai->ai_family = AF_INET;\n\tai->ai_socktype = hints ? hints->ai_socktype : 0;\n\tswitch (ai->ai_socktype) {\n\tcase SOCK_STREAM:\n\t\tai->ai_protocol = IPPROTO_TCP;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tai->ai_protocol = IPPROTO_UDP;\n\t\tbreak;\n\tdefault:\n\t\tai->ai_protocol = 0;\n\t\tbreak;\n\t}\n\tai->ai_addrlen = sizeof(struct sockaddr_in);\n\tif (hints && (hints->ai_flags & AI_CANONNAME))\n\t\tai->ai_canonname = h ? xstrdup(h->h_name) : NULL;\n\telse\n\t\tai->ai_canonname = NULL;\n\n\tsin = xcalloc(1, ai->ai_addrlen);\n\tsin->sin_family = AF_INET;\n\t/* Note: getaddrinfo is supposed to allow service to be a string,\n\t * which should be looked up using getservbyname. This is\n\t * currently not implemented */\n\tif (service)\n\t\tsin->sin_port = htons(atoi(service));\n\tif (h)\n\t\tsin->sin_addr = *(struct in_addr *)h->h_addr;\n\telse if (hints && (hints->ai_flags & AI_PASSIVE))\n\t\tsin->sin_addr.s_addr = INADDR_ANY;\n\telse\n\t\tsin->sin_addr.s_addr = INADDR_LOOPBACK;\n\tai->ai_addr = (struct sockaddr *)sin;\n\tai->ai_next = NULL;\n\treturn 0;\n}\n\nstatic void WSAAPI freeaddrinfo_stub(struct addrinfo *res)\n{\n\tfree(res->ai_canonname);\n\tfree(res->ai_addr);\n\tfree(res);\n}\n\nstatic int WSAAPI getnameinfo_stub(const struct sockaddr *sa, socklen_t salen,\n\t\t\t\t   char *host, DWORD hostlen,\n\t\t\t\t   char *serv, DWORD servlen, int flags)\n{\n\tconst struct sockaddr_in *sin = (const struct sockaddr_in *)sa;\n\tif (sa->sa_family != AF_INET)\n\t\treturn EAI_FAMILY;\n\tif (!host && !serv)\n\t\treturn EAI_NONAME;\n\n\tif (host && hostlen > 0) {\n\t\tstruct hostent *ent = NULL;\n\t\tif (!(flags & NI_NUMERICHOST))\n\t\t\tent = gethostbyaddr((const char *)&sin->sin_addr,\n\t\t\t\t\t    sizeof(sin->sin_addr), AF_INET);\n\n\t\tif (ent)\n\t\t\tsnprintf(host, hostlen, \"%s\", ent->h_name);\n\t\telse if (flags & NI_NAMEREQD)\n\t\t\treturn EAI_NONAME;\n\t\telse\n\t\t\tsnprintf(host, hostlen, \"%s\", inet_ntoa(sin->sin_addr));\n\t}\n\n\tif (serv && servlen > 0) {\n\t\tstruct servent *ent = NULL;\n\t\tif (!(flags & NI_NUMERICSERV))\n\t\t\tent = getservbyport(sin->sin_port,\n\t\t\t\t\t    flags & NI_DGRAM ? \"udp\" : \"tcp\");\n\n\t\tif (ent)\n\t\t\tsnprintf(serv, servlen, \"%s\", ent->s_name);\n\t\telse\n\t\t\tsnprintf(serv, servlen, \"%d\", ntohs(sin->sin_port));\n\t}\n\n\treturn 0;\n}\n\nstatic HMODULE ipv6_dll = NULL;\nstatic void (WSAAPI *ipv6_freeaddrinfo)(struct addrinfo *res);\nstatic int (WSAAPI *ipv6_getaddrinfo)(const char *node, const char *service,\n\t\t\t\t      const struct addrinfo *hints,\n\t\t\t\t      struct addrinfo **res);\nstatic int (WSAAPI *ipv6_getnameinfo)(const struct sockaddr *sa, socklen_t salen,\n\t\t\t\t      char *host, DWORD hostlen,\n\t\t\t\t      char *serv, DWORD servlen, int flags);\n/*\n * gai_strerror is an inline function in the ws2tcpip.h header, so we\n * don't need to try to load that one dynamically.\n */\n\nstatic void socket_cleanup(void)\n{\n\tWSACleanup();\n\tif (ipv6_dll)\n\t\tFreeLibrary(ipv6_dll);\n\tipv6_dll = NULL;\n\tipv6_freeaddrinfo = freeaddrinfo_stub;\n\tipv6_getaddrinfo = getaddrinfo_stub;\n\tipv6_getnameinfo = getnameinfo_stub;\n}\n\nstatic void ensure_socket_initialization(void)\n{\n\tWSADATA wsa;\n\tstatic int initialized = 0;\n\tconst char *libraries[] = { \"ws2_32.dll\", \"wship6.dll\", NULL };\n\tconst char **name;\n\n\tif (initialized)\n\t\treturn;\n\n\tif (WSAStartup(MAKEWORD(2,2), &wsa))\n\t\tdie(\"unable to initialize winsock subsystem, error %d\",\n\t\t\tWSAGetLastError());\n\n\tfor (name = libraries; *name; name++) {\n\t\tipv6_dll = LoadLibrary(*name);\n\t\tif (!ipv6_dll)\n\t\t\tcontinue;\n\n\t\tipv6_freeaddrinfo = (void (WSAAPI *)(struct addrinfo *))\n\t\t\tGetProcAddress(ipv6_dll, \"freeaddrinfo\");\n\t\tipv6_getaddrinfo = (int (WSAAPI *)(const char *, const char *,\n\t\t\t\t\t\t   const struct addrinfo *,\n\t\t\t\t\t\t   struct addrinfo **))\n\t\t\tGetProcAddress(ipv6_dll, \"getaddrinfo\");\n\t\tipv6_getnameinfo = (int (WSAAPI *)(const struct sockaddr *,\n\t\t\t\t\t\t   socklen_t, char *, DWORD,\n\t\t\t\t\t\t   char *, DWORD, int))\n\t\t\tGetProcAddress(ipv6_dll, \"getnameinfo\");\n\t\tif (!ipv6_freeaddrinfo || !ipv6_getaddrinfo || !ipv6_getnameinfo) {\n\t\t\tFreeLibrary(ipv6_dll);\n\t\t\tipv6_dll = NULL;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (!ipv6_freeaddrinfo || !ipv6_getaddrinfo || !ipv6_getnameinfo) {\n\t\tipv6_freeaddrinfo = freeaddrinfo_stub;\n\t\tipv6_getaddrinfo = getaddrinfo_stub;\n\t\tipv6_getnameinfo = getnameinfo_stub;\n\t}\n\n\tatexit(socket_cleanup);\n\tinitialized = 1;\n}\n\n#undef gethostname\nint mingw_gethostname(char *name, int namelen)\n{\n    ensure_socket_initialization();\n    return gethostname(name, namelen);\n}\n\n#undef gethostbyname\nstruct hostent *mingw_gethostbyname(const char *host)\n{\n\tensure_socket_initialization();\n\treturn gethostbyname(host);\n}\n\nvoid mingw_freeaddrinfo(struct addrinfo *res)\n{\n\tipv6_freeaddrinfo(res);\n}\n\nint mingw_getaddrinfo(const char *node, const char *service,\n\t\t      const struct addrinfo *hints, struct addrinfo **res)\n{\n\tensure_socket_initialization();\n\treturn ipv6_getaddrinfo(node, service, hints, res);\n}\n\nint mingw_getnameinfo(const struct sockaddr *sa, socklen_t salen,\n\t\t      char *host, DWORD hostlen, char *serv, DWORD servlen,\n\t\t      int flags)\n{\n\tensure_socket_initialization();\n\treturn ipv6_getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}\n\nint mingw_socket(int domain, int type, int protocol)\n{\n\tint sockfd;\n\tSOCKET s;\n\n\tensure_socket_initialization();\n\ts = WSASocket(domain, type, protocol, NULL, 0, 0);\n\tif (s == INVALID_SOCKET) {\n\t\t/*\n\t\t * WSAGetLastError() values are regular BSD error codes\n\t\t * biased by WSABASEERR.\n\t\t * However, strerror() does not know about networking\n\t\t * specific errors, which are values beginning at 38 or so.\n\t\t * Therefore, we choose to leave the biased error code\n\t\t * in errno so that _if_ someone looks up the code somewhere,\n\t\t * then it is at least the number that are usually listed.\n\t\t */\n\t\terrno = WSAGetLastError();\n\t\treturn -1;\n\t}\n\t/* convert into a file descriptor */\n\tif ((sockfd = _open_osfhandle(s, O_RDWR|O_BINARY)) < 0) {\n\t\tclosesocket(s);\n\t\treturn error(\"unable to make a socket file descriptor: %s\",\n\t\t\tstrerror(errno));\n\t}\n\treturn sockfd;\n}\n\n#undef connect\nint mingw_connect(int sockfd, struct sockaddr *sa, size_t sz)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn connect(s, sa, sz);\n}\n\n#undef bind\nint mingw_bind(int sockfd, struct sockaddr *sa, size_t sz)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn bind(s, sa, sz);\n}\n\n#undef setsockopt\nint mingw_setsockopt(int sockfd, int lvl, int optname, void *optval, int optlen)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn setsockopt(s, lvl, optname, (const char*)optval, optlen);\n}\n\n#undef shutdown\nint mingw_shutdown(int sockfd, int how)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn shutdown(s, how);\n}\n\n#undef listen\nint mingw_listen(int sockfd, int backlog)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn listen(s, backlog);\n}\n\n#undef accept\nint mingw_accept(int sockfd1, struct sockaddr *sa, socklen_t *sz)\n{\n\tint sockfd2;\n\n\tSOCKET s1 = (SOCKET)_get_osfhandle(sockfd1);\n\tSOCKET s2 = accept(s1, sa, sz);\n\n\t/* convert into a file descriptor */\n\tif ((sockfd2 = _open_osfhandle(s2, O_RDWR|O_BINARY)) < 0) {\n\t\tint err = errno;\n\t\tclosesocket(s2);\n\t\treturn error(\"unable to make a socket file descriptor: %s\",\n\t\t\tstrerror(err));\n\t}\n\treturn sockfd2;\n}\n\n#undef rename\nint mingw_rename(const char *pold, const char *pnew)\n{\n\tDWORD attrs, gle;\n\tint tries = 0;\n\twchar_t wpold[MAX_PATH], wpnew[MAX_PATH];\n\tif (xutftowcs_path(wpold, pold) < 0 || xutftowcs_path(wpnew, pnew) < 0)\n\t\treturn -1;\n\n\t/*\n\t * Try native rename() first to get errno right.\n\t * It is based on MoveFile(), which cannot overwrite existing files.\n\t */\n\tif (!_wrename(wpold, wpnew))\n\t\treturn 0;\n\tif (errno != EEXIST)\n\t\treturn -1;\nrepeat:\n\tif (MoveFileExW(wpold, wpnew, MOVEFILE_REPLACE_EXISTING))\n\t\treturn 0;\n\t/* TODO: translate more errors */\n\tgle = GetLastError();\n\tif (gle == ERROR_ACCESS_DENIED &&\n\t    (attrs = GetFileAttributesW(wpnew)) != INVALID_FILE_ATTRIBUTES) {\n\t\tif (attrs & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t\tDWORD attrsold = GetFileAttributesW(wpold);\n\t\t\tif (attrsold == INVALID_FILE_ATTRIBUTES ||\n\t\t\t    !(attrsold & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\terrno = EISDIR;\n\t\t\telse if (!_wrmdir(wpnew))\n\t\t\t\tgoto repeat;\n\t\t\treturn -1;\n\t\t}\n\t\tif ((attrs & FILE_ATTRIBUTE_READONLY) &&\n\t\t    SetFileAttributesW(wpnew, attrs & ~FILE_ATTRIBUTE_READONLY)) {\n\t\t\tif (MoveFileExW(wpold, wpnew, MOVEFILE_REPLACE_EXISTING))\n\t\t\t\treturn 0;\n\t\t\tgle = GetLastError();\n\t\t\t/* revert file attributes on failure */\n\t\t\tSetFileAttributesW(wpnew, attrs);\n\t\t}\n\t}\n\tif (tries < ARRAY_SIZE(delay) && gle == ERROR_ACCESS_DENIED) {\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t\tgoto repeat;\n\t}\n\tif (gle == ERROR_ACCESS_DENIED &&\n\t       ask_yes_no_if_possible(\"Rename from '%s' to '%s' failed. \"\n\t\t       \"Should I try again?\", pold, pnew))\n\t\tgoto repeat;\n\n\terrno = EACCES;\n\treturn -1;\n}\n\n/*\n * Note that this doesn't return the actual pagesize, but\n * the allocation granularity. If future Windows specific git code\n * needs the real getpagesize function, we need to find another solution.\n */\nint mingw_getpagesize(void)\n{\n\tSYSTEM_INFO si;\n\tGetSystemInfo(&si);\n\treturn si.dwAllocationGranularity;\n}\n\nstruct passwd *getpwuid(int uid)\n{\n\tstatic char user_name[100];\n\tstatic struct passwd p;\n\n\tDWORD len = sizeof(user_name);\n\tif (!GetUserName(user_name, &len))\n\t\treturn NULL;\n\tp.pw_name = user_name;\n\tp.pw_gecos = \"unknown\";\n\tp.pw_dir = NULL;\n\treturn &p;\n}\n\nstatic HANDLE timer_event;\nstatic HANDLE timer_thread;\nstatic int timer_interval;\nstatic int one_shot;\nstatic sig_handler_t timer_fn = SIG_DFL, sigint_fn = SIG_DFL;\n\n/* The timer works like this:\n * The thread, ticktack(), is a trivial routine that most of the time\n * only waits to receive the signal to terminate. The main thread tells\n * the thread to terminate by setting the timer_event to the signalled\n * state.\n * But ticktack() interrupts the wait state after the timer's interval\n * length to call the signal handler.\n */\n\nstatic unsigned __stdcall ticktack(void *dummy)\n{\n\twhile (WaitForSingleObject(timer_event, timer_interval) == WAIT_TIMEOUT) {\n\t\tmingw_raise(SIGALRM);\n\t\tif (one_shot)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int start_timer_thread(void)\n{\n\ttimer_event = CreateEvent(NULL, FALSE, FALSE, NULL);\n\tif (timer_event) {\n\t\ttimer_thread = (HANDLE) _beginthreadex(NULL, 0, ticktack, NULL, 0, NULL);\n\t\tif (!timer_thread )\n\t\t\treturn errno = ENOMEM,\n\t\t\t\terror(\"cannot start timer thread\");\n\t} else\n\t\treturn errno = ENOMEM,\n\t\t\terror(\"cannot allocate resources for timer\");\n\treturn 0;\n}\n\nstatic void stop_timer_thread(void)\n{\n\tif (timer_event)\n\t\tSetEvent(timer_event);\t/* tell thread to terminate */\n\tif (timer_thread) {\n\t\tint rc = WaitForSingleObject(timer_thread, 1000);\n\t\tif (rc == WAIT_TIMEOUT)\n\t\t\terror(\"timer thread did not terminate timely\");\n\t\telse if (rc != WAIT_OBJECT_0)\n\t\t\terror(\"waiting for timer thread failed: %lu\",\n\t\t\t      GetLastError());\n\t\tCloseHandle(timer_thread);\n\t}\n\tif (timer_event)\n\t\tCloseHandle(timer_event);\n\ttimer_event = NULL;\n\ttimer_thread = NULL;\n}\n\nstatic inline int is_timeval_eq(const struct timeval *i1, const struct timeval *i2)\n{\n\treturn i1->tv_sec == i2->tv_sec && i1->tv_usec == i2->tv_usec;\n}\n\nint setitimer(int type, struct itimerval *in, struct itimerval *out)\n{\n\tstatic const struct timeval zero;\n\tstatic int atexit_done;\n\n\tif (out != NULL)\n\t\treturn errno = EINVAL,\n\t\t\terror(\"setitimer param 3 != NULL not implemented\");\n\tif (!is_timeval_eq(&in->it_interval, &zero) &&\n\t    !is_timeval_eq(&in->it_interval, &in->it_value))\n\t\treturn errno = EINVAL,\n\t\t\terror(\"setitimer: it_interval must be zero or eq it_value\");\n\n\tif (timer_thread)\n\t\tstop_timer_thread();\n\n\tif (is_timeval_eq(&in->it_value, &zero) &&\n\t    is_timeval_eq(&in->it_interval, &zero))\n\t\treturn 0;\n\n\ttimer_interval = in->it_value.tv_sec * 1000 + in->it_value.tv_usec / 1000;\n\tone_shot = is_timeval_eq(&in->it_interval, &zero);\n\tif (!atexit_done) {\n\t\tatexit(stop_timer_thread);\n\t\tatexit_done = 1;\n\t}\n\treturn start_timer_thread();\n}\n\nint sigaction(int sig, struct sigaction *in, struct sigaction *out)\n{\n\tif (sig != SIGALRM)\n\t\treturn errno = EINVAL,\n\t\t\terror(\"sigaction only implemented for SIGALRM\");\n\tif (out != NULL)\n\t\treturn errno = EINVAL,\n\t\t\terror(\"sigaction: param 3 != NULL not implemented\");\n\n\ttimer_fn = in->sa_handler;\n\treturn 0;\n}\n\n#undef signal\nsig_handler_t mingw_signal(int sig, sig_handler_t handler)\n{\n\tsig_handler_t old;\n\n\tswitch (sig) {\n\tcase SIGALRM:\n\t\told = timer_fn;\n\t\ttimer_fn = handler;\n\t\tbreak;\n\n\tcase SIGINT:\n\t\told = sigint_fn;\n\t\tsigint_fn = handler;\n\t\tbreak;\n\n\tdefault:\n\t\treturn signal(sig, handler);\n\t}\n\n\treturn old;\n}\n\n#undef raise\nint mingw_raise(int sig)\n{\n\tswitch (sig) {\n\tcase SIGALRM:\n\t\tif (timer_fn == SIG_DFL) {\n\t\t\tif (isatty(STDERR_FILENO))\n\t\t\t\tfputs(\"Alarm clock\\n\", stderr);\n\t\t\texit(128 + SIGALRM);\n\t\t} else if (timer_fn != SIG_IGN)\n\t\t\ttimer_fn(SIGALRM);\n\t\treturn 0;\n\n\tcase SIGINT:\n\t\tif (sigint_fn == SIG_DFL)\n\t\t\texit(128 + SIGINT);\n\t\telse if (sigint_fn != SIG_IGN)\n\t\t\tsigint_fn(SIGINT);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn raise(sig);\n\t}\n}\n\nint link(const char *oldpath, const char *newpath)\n{\n\ttypedef BOOL (WINAPI *T)(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES);\n\tstatic T create_hard_link = NULL;\n\twchar_t woldpath[MAX_PATH], wnewpath[MAX_PATH];\n\tif (xutftowcs_path(woldpath, oldpath) < 0 ||\n\t\txutftowcs_path(wnewpath, newpath) < 0)\n\t\treturn -1;\n\n\tif (!create_hard_link) {\n\t\tcreate_hard_link = (T) GetProcAddress(\n\t\t\tGetModuleHandle(\"kernel32.dll\"), \"CreateHardLinkW\");\n\t\tif (!create_hard_link)\n\t\t\tcreate_hard_link = (T)-1;\n\t}\n\tif (create_hard_link == (T)-1) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n\tif (!create_hard_link(wnewpath, woldpath, NULL)) {\n\t\terrno = err_win_to_posix(GetLastError());\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\npid_t waitpid(pid_t pid, int *status, int options)\n{\n\tHANDLE h = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n\t    FALSE, pid);\n\tif (!h) {\n\t\terrno = ECHILD;\n\t\treturn -1;\n\t}\n\n\tif (pid > 0 && options & WNOHANG) {\n\t\tif (WAIT_OBJECT_0 != WaitForSingleObject(h, 0)) {\n\t\t\tCloseHandle(h);\n\t\t\treturn 0;\n\t\t}\n\t\toptions &= ~WNOHANG;\n\t}\n\n\tif (options == 0) {\n\t\tstruct pinfo_t **ppinfo;\n\t\tif (WaitForSingleObject(h, INFINITE) != WAIT_OBJECT_0) {\n\t\t\tCloseHandle(h);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (status)\n\t\t\tGetExitCodeProcess(h, (LPDWORD)status);\n\n\t\tEnterCriticalSection(&pinfo_cs);\n\n\t\tppinfo = &pinfo;\n\t\twhile (*ppinfo) {\n\t\t\tstruct pinfo_t *info = *ppinfo;\n\t\t\tif (info->pid == pid) {\n\t\t\t\tCloseHandle(info->proc);\n\t\t\t\t*ppinfo = info->next;\n\t\t\t\tfree(info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tppinfo = &info->next;\n\t\t}\n\n\t\tLeaveCriticalSection(&pinfo_cs);\n\n\t\tCloseHandle(h);\n\t\treturn pid;\n\t}\n\tCloseHandle(h);\n\n\terrno = EINVAL;\n\treturn -1;\n}\n\nint mingw_has_dos_drive_prefix(const char *path)\n{\n\tint i;\n\n\t/*\n\t * Does it start with an ASCII letter (i.e. highest bit not set),\n\t * followed by a colon?\n\t */\n\tif (!(0x80 & (unsigned char)*path))\n\t\treturn *path && path[1] == ':' ? 2 : 0;\n\n\t/*\n\t * While drive letters must be letters of the English alphabet, it is\n\t * possible to assign virtually _any_ Unicode character via `subst` as\n\t * a drive letter to \"virtual drives\". Even `1`, or `\u00e4`. Or fun stuff\n\t * like this:\n\t *\n\t *      subst \u058d: %USERPROFILE%\\Desktop\n\t */\n\tfor (i = 1; i < 4 && (0x80 & (unsigned char)path[i]); i++)\n\t\t; /* skip first UTF-8 character */\n\treturn path[i] == ':' ? i + 1 : 0;\n}\n\nint mingw_skip_dos_drive_prefix(char **path)\n{\n\tint ret = has_dos_drive_prefix(*path);\n\t*path += ret;\n\treturn ret;\n}\n\nint mingw_offset_1st_component(const char *path)\n{\n\tchar *pos = (char *)path;\n\n\t/* unc paths */\n\tif (!skip_dos_drive_prefix(&pos) &&\n\t\t\tis_dir_sep(pos[0]) && is_dir_sep(pos[1])) {\n\t\t/* skip server name */\n\t\tpos = strpbrk(pos + 2, \"\\\\/\");\n\t\tif (!pos)\n\t\t\treturn 0; /* Error: malformed unc path */\n\n\t\tdo {\n\t\t\tpos++;\n\t\t} while (*pos && !is_dir_sep(*pos));\n\t}\n\n\treturn pos + is_dir_sep(*pos) - path;\n}\n\nint xutftowcsn(wchar_t *wcs, const char *utfs, size_t wcslen, int utflen)\n{\n\tint upos = 0, wpos = 0;\n\tconst unsigned char *utf = (const unsigned char*) utfs;\n\tif (!utf || !wcs || wcslen < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t/* reserve space for \\0 */\n\twcslen--;\n\tif (utflen < 0)\n\t\tutflen = INT_MAX;\n\n\twhile (upos < utflen) {\n\t\tint c = utf[upos++] & 0xff;\n\t\tif (utflen == INT_MAX && c == 0)\n\t\t\tbreak;\n\n\t\tif (wpos >= wcslen) {\n\t\t\twcs[wpos] = 0;\n\t\t\terrno = ERANGE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (c < 0x80) {\n\t\t\t/* ASCII */\n\t\t\twcs[wpos++] = c;\n\t\t} else if (c >= 0xc2 && c < 0xe0 && upos < utflen &&\n\t\t\t\t(utf[upos] & 0xc0) == 0x80) {\n\t\t\t/* 2-byte utf-8 */\n\t\t\tc = ((c & 0x1f) << 6);\n\t\t\tc |= (utf[upos++] & 0x3f);\n\t\t\twcs[wpos++] = c;\n\t\t} else if (c >= 0xe0 && c < 0xf0 && upos + 1 < utflen &&\n\t\t\t\t!(c == 0xe0 && utf[upos] < 0xa0) && /* over-long encoding */\n\t\t\t\t(utf[upos] & 0xc0) == 0x80 &&\n\t\t\t\t(utf[upos + 1] & 0xc0) == 0x80) {\n\t\t\t/* 3-byte utf-8 */\n\t\t\tc = ((c & 0x0f) << 12);\n\t\t\tc |= ((utf[upos++] & 0x3f) << 6);\n\t\t\tc |= (utf[upos++] & 0x3f);\n\t\t\twcs[wpos++] = c;\n\t\t} else if (c >= 0xf0 && c < 0xf5 && upos + 2 < utflen &&\n\t\t\t\twpos + 1 < wcslen &&\n\t\t\t\t!(c == 0xf0 && utf[upos] < 0x90) && /* over-long encoding */\n\t\t\t\t!(c == 0xf4 && utf[upos] >= 0x90) && /* > \\u10ffff */\n\t\t\t\t(utf[upos] & 0xc0) == 0x80 &&\n\t\t\t\t(utf[upos + 1] & 0xc0) == 0x80 &&\n\t\t\t\t(utf[upos + 2] & 0xc0) == 0x80) {\n\t\t\t/* 4-byte utf-8: convert to \\ud8xx \\udcxx surrogate pair */\n\t\t\tc = ((c & 0x07) << 18);\n\t\t\tc |= ((utf[upos++] & 0x3f) << 12);\n\t\t\tc |= ((utf[upos++] & 0x3f) << 6);\n\t\t\tc |= (utf[upos++] & 0x3f);\n\t\t\tc -= 0x10000;\n\t\t\twcs[wpos++] = 0xd800 | (c >> 10);\n\t\t\twcs[wpos++] = 0xdc00 | (c & 0x3ff);\n\t\t} else if (c >= 0xa0) {\n\t\t\t/* invalid utf-8 byte, printable unicode char: convert 1:1 */\n\t\t\twcs[wpos++] = c;\n\t\t} else {\n\t\t\t/* invalid utf-8 byte, non-printable unicode: convert to hex */\n\t\t\tstatic const char *hex = \"0123456789abcdef\";\n\t\t\twcs[wpos++] = hex[c >> 4];\n\t\t\tif (wpos < wcslen)\n\t\t\t\twcs[wpos++] = hex[c & 0x0f];\n\t\t}\n\t}\n\twcs[wpos] = 0;\n\treturn wpos;\n}\n\nint xwcstoutf(char *utf, const wchar_t *wcs, size_t utflen)\n{\n\tif (!wcs || !utf || utflen < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tutflen = WideCharToMultiByte(CP_UTF8, 0, wcs, -1, utf, utflen, NULL, NULL);\n\tif (utflen)\n\t\treturn utflen - 1;\n\terrno = ERANGE;\n\treturn -1;\n}\n\nstatic void setup_windows_environment(void)\n{\n\tchar *tmp = getenv(\"TMPDIR\");\n\n\t/* on Windows it is TMP and TEMP */\n\tif (!tmp) {\n\t\tif (!(tmp = getenv(\"TMP\")))\n\t\t\ttmp = getenv(\"TEMP\");\n\t\tif (tmp) {\n\t\t\tsetenv(\"TMPDIR\", tmp, 1);\n\t\t\ttmp = getenv(\"TMPDIR\");\n\t\t}\n\t}\n\n\tif (tmp) {\n\t\t/*\n\t\t * Convert all dir separators to forward slashes,\n\t\t * to help shell commands called from the Git\n\t\t * executable (by not mistaking the dir separators\n\t\t * for escape characters).\n\t\t */\n\t\tconvert_slashes(tmp);\n\t}\n\n\t/* simulate TERM to enable auto-color (see color.c) */\n\tif (!getenv(\"TERM\"))\n\t\tsetenv(\"TERM\", \"cygwin\", 1);\n}\n\nint is_valid_win32_path(const char *path)\n{\n\tint preceding_space_or_period = 0, i = 0, periods = 0;\n\n\tif (!protect_ntfs)\n\t\treturn 1;\n\n\tskip_dos_drive_prefix((char **)&path);\n\n\tfor (;;) {\n\t\tchar c = *(path++);\n\t\tswitch (c) {\n\t\tcase '\\0':\n\t\tcase '/': case '\\\\':\n\t\t\t/* cannot end in ` ` or `.`, except for `.` and `..` */\n\t\t\tif (preceding_space_or_period &&\n\t\t\t    (i != periods || periods > 2))\n\t\t\t\treturn 0;\n\t\t\tif (!c)\n\t\t\t\treturn 1;\n\n\t\t\ti = periods = preceding_space_or_period = 0;\n\t\t\tcontinue;\n\t\tcase '.':\n\t\t\tperiods++;\n\t\t\t/* fallthru */\n\t\tcase ' ':\n\t\t\tpreceding_space_or_period = 1;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\tcase ':': /* DOS drive prefix was already skipped */\n\t\tcase '<': case '>': case '\"': case '|': case '?': case '*':\n\t\t\t/* illegal character */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tif (c > '\\0' && c < '\\x20')\n\t\t\t\t/* illegal character */\n\t\t\t\treturn 0;\n\t\t}\n\t\tpreceding_space_or_period = 0;\n\t\ti++;\n\t}\n}\n\n/*\n * Disable MSVCRT command line wildcard expansion (__getmainargs called from\n * mingw startup code, see init.c in mingw runtime).\n */\nint _CRT_glob = 0;\n\ntypedef struct {\n\tint newmode;\n} _startupinfo;\n\nextern int __wgetmainargs(int *argc, wchar_t ***argv, wchar_t ***env, int glob,\n\t\t_startupinfo *si);\n\nstatic NORETURN void die_startup(void)\n{\n\tfputs(\"fatal: not enough memory for initialization\", stderr);\n\texit(128);\n}\n\nstatic void *malloc_startup(size_t size)\n{\n\tvoid *result = malloc(size);\n\tif (!result)\n\t\tdie_startup();\n\treturn result;\n}\n\nstatic char *wcstoutfdup_startup(char *buffer, const wchar_t *wcs, size_t len)\n{\n\tlen = xwcstoutf(buffer, wcs, len) + 1;\n\treturn memcpy(malloc_startup(len), buffer, len);\n}\n\nstatic void maybe_redirect_std_handle(const wchar_t *key, DWORD std_id, int fd,\n\t\t\t\t      DWORD desired_access, DWORD flags)\n{\n\tDWORD create_flag = fd ? OPEN_ALWAYS : OPEN_EXISTING;\n\twchar_t buf[MAX_PATH];\n\tDWORD max = ARRAY_SIZE(buf);\n\tHANDLE handle;\n\tDWORD ret = GetEnvironmentVariableW(key, buf, max);\n\n\tif (!ret || ret >= max)\n\t\treturn;\n\n\t/* make sure this does not leak into child processes */\n\tSetEnvironmentVariableW(key, NULL);\n\tif (!wcscmp(buf, L\"off\")) {\n\t\tclose(fd);\n\t\thandle = GetStdHandle(std_id);\n\t\tif (handle != INVALID_HANDLE_VALUE)\n\t\t\tCloseHandle(handle);\n\t\treturn;\n\t}\n\tif (std_id == STD_ERROR_HANDLE && !wcscmp(buf, L\"2>&1\")) {\n\t\thandle = GetStdHandle(STD_OUTPUT_HANDLE);\n\t\tif (handle == INVALID_HANDLE_VALUE) {\n\t\t\tclose(fd);\n\t\t\thandle = GetStdHandle(std_id);\n\t\t\tif (handle != INVALID_HANDLE_VALUE)\n\t\t\t\tCloseHandle(handle);\n\t\t} else {\n\t\t\tint new_fd = _open_osfhandle((intptr_t)handle, O_BINARY);\n\t\t\tSetStdHandle(std_id, handle);\n\t\t\tdup2(new_fd, fd);\n\t\t\t/* do *not* close the new_fd: that would close stdout */\n\t\t}\n\t\treturn;\n\t}\n\thandle = CreateFileW(buf, desired_access, 0, NULL, create_flag,\n\t\t\t     flags, NULL);\n\tif (handle != INVALID_HANDLE_VALUE) {\n\t\tint new_fd = _open_osfhandle((intptr_t)handle, O_BINARY);\n\t\tSetStdHandle(std_id, handle);\n\t\tdup2(new_fd, fd);\n\t\tclose(new_fd);\n\t}\n}\n\nstatic void maybe_redirect_std_handles(void)\n{\n\tmaybe_redirect_std_handle(L\"GIT_REDIRECT_STDIN\", STD_INPUT_HANDLE, 0,\n\t\t\t\t  GENERIC_READ, FILE_ATTRIBUTE_NORMAL);\n\tmaybe_redirect_std_handle(L\"GIT_REDIRECT_STDOUT\", STD_OUTPUT_HANDLE, 1,\n\t\t\t\t  GENERIC_WRITE, FILE_ATTRIBUTE_NORMAL);\n\tmaybe_redirect_std_handle(L\"GIT_REDIRECT_STDERR\", STD_ERROR_HANDLE, 2,\n\t\t\t\t  GENERIC_WRITE, FILE_FLAG_NO_BUFFERING);\n}\n\nvoid mingw_startup(void)\n{\n\tint i, maxlen, argc;\n\tchar *buffer;\n\twchar_t **wenv, **wargv;\n\t_startupinfo si;\n\n\tmaybe_redirect_std_handles();\n\n\t/* get wide char arguments and environment */\n\tsi.newmode = 0;\n\tif (__wgetmainargs(&argc, &wargv, &wenv, _CRT_glob, &si) < 0)\n\t\tdie_startup();\n\n\t/* determine size of argv and environ conversion buffer */\n\tmaxlen = wcslen(_wpgmptr);\n\tfor (i = 1; i < argc; i++)\n\t\tmaxlen = max(maxlen, wcslen(wargv[i]));\n\tfor (i = 0; wenv[i]; i++)\n\t\tmaxlen = max(maxlen, wcslen(wenv[i]));\n\n\t/*\n\t * nedmalloc can't free CRT memory, allocate resizable environment\n\t * list. Note that xmalloc / xmemdupz etc. call getenv, so we cannot\n\t * use it while initializing the environment itself.\n\t */\n\tenviron_size = i + 1;\n\tenviron_alloc = alloc_nr(environ_size * sizeof(char*));\n\tenviron = malloc_startup(environ_alloc);\n\n\t/* allocate buffer (wchar_t encodes to max 3 UTF-8 bytes) */\n\tmaxlen = 3 * maxlen + 1;\n\tbuffer = malloc_startup(maxlen);\n\n\t/* convert command line arguments and environment to UTF-8 */\n\t__argv[0] = wcstoutfdup_startup(buffer, _wpgmptr, maxlen);\n\tfor (i = 1; i < argc; i++)\n\t\t__argv[i] = wcstoutfdup_startup(buffer, wargv[i], maxlen);\n\tfor (i = 0; wenv[i]; i++)\n\t\tenviron[i] = wcstoutfdup_startup(buffer, wenv[i], maxlen);\n\tenviron[i] = NULL;\n\tfree(buffer);\n\n\t/* sort environment for O(log n) getenv / putenv */\n\tqsort(environ, i, sizeof(char*), compareenv);\n\n\t/* fix Windows specific environment settings */\n\tsetup_windows_environment();\n\n\t/* initialize critical section for waitpid pinfo_t list */\n\tInitializeCriticalSection(&pinfo_cs);\n\n\t/* set up default file mode and file modes for stdin/out/err */\n\t_fmode = _O_BINARY;\n\t_setmode(_fileno(stdin), _O_BINARY);\n\t_setmode(_fileno(stdout), _O_BINARY);\n\t_setmode(_fileno(stderr), _O_BINARY);\n\n\t/* initialize Unicode console */\n\twinansi_init();\n}\n\nint uname(struct utsname *buf)\n{\n\tunsigned v = (unsigned)GetVersion();\n\tmemset(buf, 0, sizeof(*buf));\n\txsnprintf(buf->sysname, sizeof(buf->sysname), \"Windows\");\n\txsnprintf(buf->release, sizeof(buf->release),\n\t\t \"%u.%u\", v & 0xff, (v >> 8) & 0xff);\n\t/* assuming NT variants only.. */\n\txsnprintf(buf->version, sizeof(buf->version),\n\t\t  \"%u\", (v >> 16) & 0x7fff);\n\treturn 0;\n}\n", "#ifndef GIT_COMPAT_UTIL_H\n#define GIT_COMPAT_UTIL_H\n\n#define _FILE_OFFSET_BITS 64\n\n\n/* Derived from Linux \"Features Test Macro\" header\n * Convenience macros to test the versions of gcc (or\n * a compatible compiler).\n * Use them like this:\n *  #if GIT_GNUC_PREREQ (2,8)\n *   ... code requiring gcc 2.8 or later ...\n *  #endif\n*/\n#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n# define GIT_GNUC_PREREQ(maj, min) \\\n\t((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))\n#else\n #define GIT_GNUC_PREREQ(maj, min) 0\n#endif\n\n\n#ifndef FLEX_ARRAY\n/*\n * See if our compiler is known to support flexible array members.\n */\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && (!defined(__SUNPRO_C) || (__SUNPRO_C > 0x580))\n# define FLEX_ARRAY /* empty */\n#elif defined(__GNUC__)\n# if (__GNUC__ >= 3)\n#  define FLEX_ARRAY /* empty */\n# else\n#  define FLEX_ARRAY 0 /* older GNU extension */\n# endif\n#endif\n\n/*\n * Otherwise, default to safer but a bit wasteful traditional style\n */\n#ifndef FLEX_ARRAY\n# define FLEX_ARRAY 1\n#endif\n#endif\n\n\n/*\n * BUILD_ASSERT_OR_ZERO - assert a build-time dependency, as an expression.\n * @cond: the compile-time condition which must be true.\n *\n * Your compile will fail if the condition isn't true, or can't be evaluated\n * by the compiler.  This can be used in an expression: its value is \"0\".\n *\n * Example:\n *\t#define foo_to_char(foo)\t\t\t\t\t\\\n *\t\t ((char *)(foo)\t\t\t\t\t\t\\\n *\t\t  + BUILD_ASSERT_OR_ZERO(offsetof(struct foo, string) == 0))\n */\n#define BUILD_ASSERT_OR_ZERO(cond) \\\n\t(sizeof(char [1 - 2*!(cond)]) - 1)\n\n#if GIT_GNUC_PREREQ(3, 1)\n /* &arr[0] degrades to a pointer: a different type from an array */\n# define BARF_UNLESS_AN_ARRAY(arr)\t\t\t\t\t\t\\\n\tBUILD_ASSERT_OR_ZERO(!__builtin_types_compatible_p(__typeof__(arr), \\\n\t\t\t\t\t\t\t   __typeof__(&(arr)[0])))\n#else\n# define BARF_UNLESS_AN_ARRAY(arr) 0\n#endif\n/*\n * ARRAY_SIZE - get the number of elements in a visible array\n *  <at> x: the array whose size you want.\n *\n * This does not work on pointers, or arrays declared as [], or\n * function parameters.  With correct compiler support, such usage\n * will cause a build error (see the build_assert_or_zero macro).\n */\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]) + BARF_UNLESS_AN_ARRAY(x))\n\n#define bitsizeof(x)  (CHAR_BIT * sizeof(x))\n\n#define maximum_signed_value_of_type(a) \\\n    (INTMAX_MAX >> (bitsizeof(intmax_t) - bitsizeof(a)))\n\n#define maximum_unsigned_value_of_type(a) \\\n    (UINTMAX_MAX >> (bitsizeof(uintmax_t) - bitsizeof(a)))\n\n/*\n * Signed integer overflow is undefined in C, so here's a helper macro\n * to detect if the sum of two integers will overflow.\n *\n * Requires: a >= 0, typeof(a) equals typeof(b)\n */\n#define signed_add_overflows(a, b) \\\n    ((b) > maximum_signed_value_of_type(a) - (a))\n\n#define unsigned_add_overflows(a, b) \\\n    ((b) > maximum_unsigned_value_of_type(a) - (a))\n\n/*\n * Returns true if the multiplication of \"a\" and \"b\" will\n * overflow. The types of \"a\" and \"b\" must match and must be unsigned.\n * Note that this macro evaluates \"a\" twice!\n */\n#define unsigned_mult_overflows(a, b) \\\n    ((a) && (b) > maximum_unsigned_value_of_type(a) / (a))\n\n#ifdef __GNUC__\n#define TYPEOF(x) (__typeof__(x))\n#else\n#define TYPEOF(x)\n#endif\n\n#define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))\n#define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))\n\n/* Approximation of the length of the decimal representation of this type. */\n#define decimal_length(x)\t((int)(sizeof(x) * 2.56 + 0.5) + 1)\n\n#if defined(__sun__)\n /*\n  * On Solaris, when _XOPEN_EXTENDED is set, its header file\n  * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE\n  * setting to say we are XPG5 or XPG6.  Also on Solaris,\n  * XPG6 programs must be compiled with a c99 compiler, while\n  * non XPG6 programs must be compiled with a pre-c99 compiler.\n  */\n# if __STDC_VERSION__ - 0 >= 199901L\n# define _XOPEN_SOURCE 600\n# else\n# define _XOPEN_SOURCE 500\n# endif\n#elif !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__USLC__) && \\\n      !defined(_M_UNIX) && !defined(__sgi) && !defined(__DragonFly__) && \\\n      !defined(__TANDEM) && !defined(__QNX__) && !defined(__MirBSD__) && \\\n      !defined(__CYGWIN__)\n#define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */\n#define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */\n#endif\n#define _ALL_SOURCE 1\n#define _GNU_SOURCE 1\n#define _BSD_SOURCE 1\n#define _DEFAULT_SOURCE 1\n#define _NETBSD_SOURCE 1\n#define _SGI_SOURCE 1\n\n#if defined(WIN32) && !defined(__CYGWIN__) /* Both MinGW and MSVC */\n# if defined (_MSC_VER) && !defined(_WIN32_WINNT)\n#  define _WIN32_WINNT 0x0502\n# endif\n#define WIN32_LEAN_AND_MEAN  /* stops windows.h including winsock.h */\n#include <winsock2.h>\n#include <windows.h>\n#define GIT_WINDOWS_NATIVE\n#endif\n\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef HAVE_STRINGS_H\n#include <strings.h> /* for strcasecmp() */\n#endif\n#include <errno.h>\n#include <limits.h>\n#ifdef NEEDS_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <assert.h>\n#include <regex.h>\n#include <utime.h>\n#include <syslog.h>\n#ifndef NO_SYS_POLL_H\n#include <sys/poll.h>\n#else\n#include <poll.h>\n#endif\n#ifdef HAVE_BSD_SYSCTL\n#include <sys/sysctl.h>\n#endif\n\n#if defined(__CYGWIN__)\n#include \"compat/cygwin.h\"\n#endif\n#if defined(__MINGW32__)\n/* pull in Windows compatibility stuff */\n#include \"compat/mingw.h\"\n#elif defined(_MSC_VER)\n#include \"compat/msvc.h\"\n#else\n#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#ifndef NO_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <sys/un.h>\n#ifndef NO_INTTYPES_H\n#include <inttypes.h>\n#else\n#include <stdint.h>\n#endif\n#ifdef NO_INTPTR_T\n/*\n * On I16LP32, ILP32 and LP64 \"long\" is the save bet, however\n * on LLP86, IL33LLP64 and P64 it needs to be \"long long\",\n * while on IP16 and IP16L32 it is \"int\" (resp. \"short\")\n * Size needs to match (or exceed) 'sizeof(void *)'.\n * We can't take \"long long\" here as not everybody has it.\n */\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\n#endif\n#undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */\n#include <grp.h>\n#define _ALL_SOURCE 1\n#endif\n\n/* used on Mac OS X */\n#ifdef PRECOMPOSE_UNICODE\n#include \"compat/precompose_utf8.h\"\n#else\n#define precompose_str(in,i_nfd2nfc)\n#define precompose_argv(c,v)\n#define probe_utf8_pathname_composition()\n#endif\n\n#ifdef MKDIR_WO_TRAILING_SLASH\n#define mkdir(a,b) compat_mkdir_wo_trailing_slash((a),(b))\nextern int compat_mkdir_wo_trailing_slash(const char*, mode_t);\n#endif\n\n#ifdef NO_STRUCT_ITIMERVAL\nstruct itimerval {\n\tstruct timeval it_interval;\n\tstruct timeval it_value;\n};\n#endif\n\n#ifdef NO_SETITIMER\n#define setitimer(which,value,ovalue)\n#endif\n\n#ifndef NO_LIBGEN_H\n#include <libgen.h>\n#else\n#define basename gitbasename\nextern char *gitbasename(char *);\n#define dirname gitdirname\nextern char *gitdirname(char *);\n#endif\n\n#ifndef NO_ICONV\n#include <iconv.h>\n#endif\n\n#ifndef NO_OPENSSL\n#ifdef __APPLE__\n#define __AVAILABILITY_MACROS_USES_AVAILABILITY 0\n#include <AvailabilityMacros.h>\n#undef DEPRECATED_ATTRIBUTE\n#define DEPRECATED_ATTRIBUTE\n#undef __AVAILABILITY_MACROS_USES_AVAILABILITY\n#endif\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n/* On most systems <netdb.h> would have given us this, but\n * not on some systems (e.g. z/OS).\n */\n#ifndef NI_MAXHOST\n#define NI_MAXHOST 1025\n#endif\n\n#ifndef NI_MAXSERV\n#define NI_MAXSERV 32\n#endif\n\n/* On most systems <limits.h> would have given us this, but\n * not on some systems (e.g. GNU/Hurd).\n */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifndef PRIuMAX\n#define PRIuMAX \"llu\"\n#endif\n\n#ifndef SCNuMAX\n#define SCNuMAX PRIuMAX\n#endif\n\n#ifndef PRIu32\n#define PRIu32 \"u\"\n#endif\n\n#ifndef PRIx32\n#define PRIx32 \"x\"\n#endif\n\n#ifndef PRIo32\n#define PRIo32 \"o\"\n#endif\n\ntypedef uintmax_t timestamp_t;\n#define PRItime PRIuMAX\n#define parse_timestamp strtoumax\n#define TIME_MAX UINTMAX_MAX\n\n#ifndef PATH_SEP\n#define PATH_SEP ':'\n#endif\n\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#ifndef _PATH_DEFPATH\n#define _PATH_DEFPATH \"/usr/local/bin:/usr/bin:/bin\"\n#endif\n\n#ifndef has_dos_drive_prefix\nstatic inline int git_has_dos_drive_prefix(const char *path)\n{\n\treturn 0;\n}\n#define has_dos_drive_prefix git_has_dos_drive_prefix\n#endif\n\n#ifndef skip_dos_drive_prefix\nstatic inline int git_skip_dos_drive_prefix(char **path)\n{\n\treturn 0;\n}\n#define skip_dos_drive_prefix git_skip_dos_drive_prefix\n#endif\n\n#ifndef is_dir_sep\nstatic inline int git_is_dir_sep(int c)\n{\n\treturn c == '/';\n}\n#define is_dir_sep git_is_dir_sep\n#endif\n\n#ifndef offset_1st_component\nstatic inline int git_offset_1st_component(const char *path)\n{\n\treturn is_dir_sep(path[0]);\n}\n#define offset_1st_component git_offset_1st_component\n#endif\n\n#ifndef is_valid_path\n#define is_valid_path(path) 1\n#endif\n\n#ifndef find_last_dir_sep\nstatic inline char *git_find_last_dir_sep(const char *path)\n{\n\treturn strrchr(path, '/');\n}\n#define find_last_dir_sep git_find_last_dir_sep\n#endif\n\n#if defined(__HP_cc) && (__HP_cc >= 61000)\n#define NORETURN __attribute__((noreturn))\n#define NORETURN_PTR\n#elif defined(__GNUC__) && !defined(NO_NORETURN)\n#define NORETURN __attribute__((__noreturn__))\n#define NORETURN_PTR __attribute__((__noreturn__))\n#elif defined(_MSC_VER)\n#define NORETURN __declspec(noreturn)\n#define NORETURN_PTR\n#else\n#define NORETURN\n#define NORETURN_PTR\n#ifndef __GNUC__\n#ifndef __attribute__\n#define __attribute__(x)\n#endif\n#endif\n#endif\n\n/* The sentinel attribute is valid from gcc version 4.0 */\n#if defined(__GNUC__) && (__GNUC__ >= 4)\n#define LAST_ARG_MUST_BE_NULL __attribute__((sentinel))\n#else\n#define LAST_ARG_MUST_BE_NULL\n#endif\n\n#include \"compat/bswap.h\"\n\n#include \"wildmatch.h\"\n\nstruct strbuf;\n\n/* General helper functions */\nextern void vreportf(const char *prefix, const char *err, va_list params);\nextern NORETURN void usage(const char *err);\nextern NORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern int error(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern int error_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\n\n#ifndef NO_OPENSSL\n#ifdef APPLE_COMMON_CRYPTO\n#include \"compat/apple-common-crypto.h\"\n#else\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#endif /* APPLE_COMMON_CRYPTO */\n#include <openssl/x509v3.h>\n#endif /* NO_OPENSSL */\n\n/*\n * Let callers be aware of the constant return value; this can help\n * gcc with -Wuninitialized analysis. We restrict this trick to gcc, though,\n * because some compilers may not support variadic macros. Since we're only\n * trying to help gcc, anyway, it's OK; other compilers will fall back to\n * using the function as usual.\n */\n#if defined(__GNUC__)\nstatic inline int const_error(void)\n{\n\treturn -1;\n}\n#define error(...) (error(__VA_ARGS__), const_error())\n#define error_errno(...) (error_errno(__VA_ARGS__), const_error())\n#endif\n\nextern void set_die_routine(NORETURN_PTR void (*routine)(const char *err, va_list params));\nextern void set_error_routine(void (*routine)(const char *err, va_list params));\nextern void (*get_error_routine(void))(const char *err, va_list params);\nextern void set_warn_routine(void (*routine)(const char *warn, va_list params));\nextern void (*get_warn_routine(void))(const char *warn, va_list params);\nextern void set_die_is_recursing_routine(int (*routine)(void));\n\nextern int starts_with(const char *str, const char *prefix);\n\n/*\n * If the string \"str\" begins with the string found in \"prefix\", return 1.\n * The \"out\" parameter is set to \"str + strlen(prefix)\" (i.e., to the point in\n * the string right after the prefix).\n *\n * Otherwise, return 0 and leave \"out\" untouched.\n *\n * Examples:\n *\n *   [extract branch name, fail if not a branch]\n *   if (!skip_prefix(ref, \"refs/heads/\", &branch)\n *\treturn -1;\n *\n *   [skip prefix if present, otherwise use whole string]\n *   skip_prefix(name, \"refs/heads/\", &name);\n */\nstatic inline int skip_prefix(const char *str, const char *prefix,\n\t\t\t      const char **out)\n{\n\tdo {\n\t\tif (!*prefix) {\n\t\t\t*out = str;\n\t\t\treturn 1;\n\t\t}\n\t} while (*str++ == *prefix++);\n\treturn 0;\n}\n\n/*\n * If the string \"str\" is the same as the string in \"prefix\", then the \"arg\"\n * parameter is set to the \"def\" parameter and 1 is returned.\n * If the string \"str\" begins with the string found in \"prefix\" and then a\n * \"=\" sign, then the \"arg\" parameter is set to \"str + strlen(prefix) + 1\"\n * (i.e., to the point in the string right after the prefix and the \"=\" sign),\n * and 1 is returned.\n *\n * Otherwise, return 0 and leave \"arg\" untouched.\n *\n * When we accept both a \"--key\" and a \"--key=<val>\" option, this function\n * can be used instead of !strcmp(arg, \"--key\") and then\n * skip_prefix(arg, \"--key=\", &arg) to parse such an option.\n */\nint skip_to_optional_arg_default(const char *str, const char *prefix,\n\t\t\t\t const char **arg, const char *def);\n\nstatic inline int skip_to_optional_arg(const char *str, const char *prefix,\n\t\t\t\t       const char **arg)\n{\n\treturn skip_to_optional_arg_default(str, prefix, arg, \"\");\n}\n\n/*\n * Like skip_prefix, but promises never to read past \"len\" bytes of the input\n * buffer, and returns the remaining number of bytes in \"out\" via \"outlen\".\n */\nstatic inline int skip_prefix_mem(const char *buf, size_t len,\n\t\t\t\t  const char *prefix,\n\t\t\t\t  const char **out, size_t *outlen)\n{\n\tsize_t prefix_len = strlen(prefix);\n\tif (prefix_len <= len && !memcmp(buf, prefix, prefix_len)) {\n\t\t*out = buf + prefix_len;\n\t\t*outlen = len - prefix_len;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * If buf ends with suffix, return 1 and subtract the length of the suffix\n * from *len. Otherwise, return 0 and leave *len untouched.\n */\nstatic inline int strip_suffix_mem(const char *buf, size_t *len,\n\t\t\t\t   const char *suffix)\n{\n\tsize_t suflen = strlen(suffix);\n\tif (*len < suflen || memcmp(buf + (*len - suflen), suffix, suflen))\n\t\treturn 0;\n\t*len -= suflen;\n\treturn 1;\n}\n\n/*\n * If str ends with suffix, return 1 and set *len to the size of the string\n * without the suffix. Otherwise, return 0 and set *len to the size of the\n * string.\n *\n * Note that we do _not_ NUL-terminate str to the new length.\n */\nstatic inline int strip_suffix(const char *str, const char *suffix, size_t *len)\n{\n\t*len = strlen(str);\n\treturn strip_suffix_mem(str, len, suffix);\n}\n\nstatic inline int ends_with(const char *str, const char *suffix)\n{\n\tsize_t len;\n\treturn strip_suffix(str, suffix, &len);\n}\n\n#define SWAP(a, b) do {\t\t\t\t\t\t\\\n\tvoid *_swap_a_ptr = &(a);\t\t\t\t\\\n\tvoid *_swap_b_ptr = &(b);\t\t\t\t\\\n\tunsigned char _swap_buffer[sizeof(a)];\t\t\t\\\n\tmemcpy(_swap_buffer, _swap_a_ptr, sizeof(a));\t\t\\\n\tmemcpy(_swap_a_ptr, _swap_b_ptr, sizeof(a) +\t\t\\\n\t       BUILD_ASSERT_OR_ZERO(sizeof(a) == sizeof(b)));\t\\\n\tmemcpy(_swap_b_ptr, _swap_buffer, sizeof(a));\t\t\\\n} while (0)\n\n#if defined(NO_MMAP) || defined(USE_WIN32_MMAP)\n\n#ifndef PROT_READ\n#define PROT_READ 1\n#define PROT_WRITE 2\n#define MAP_PRIVATE 1\n#endif\n\n#define mmap git_mmap\n#define munmap git_munmap\nextern void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int git_munmap(void *start, size_t length);\n\n#else /* NO_MMAP || USE_WIN32_MMAP */\n\n#include <sys/mman.h>\n\n#endif /* NO_MMAP || USE_WIN32_MMAP */\n\n#ifdef NO_MMAP\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)\n\n#else /* NO_MMAP */\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE \\\n\t(sizeof(void*) >= 8 \\\n\t\t?  1 * 1024 * 1024 * 1024 \\\n\t\t: 32 * 1024 * 1024)\n\n#endif /* NO_MMAP */\n\n#ifndef MAP_FAILED\n#define MAP_FAILED ((void *)-1)\n#endif\n\n#ifdef NO_ST_BLOCKS_IN_STRUCT_STAT\n#define on_disk_bytes(st) ((st).st_size)\n#else\n#define on_disk_bytes(st) ((st).st_blocks * 512)\n#endif\n\n#ifdef NEEDS_MODE_TRANSLATION\n#undef S_IFMT\n#undef S_IFREG\n#undef S_IFDIR\n#undef S_IFLNK\n#undef S_IFBLK\n#undef S_IFCHR\n#undef S_IFIFO\n#undef S_IFSOCK\n#define S_IFMT   0170000\n#define S_IFREG  0100000\n#define S_IFDIR  0040000\n#define S_IFLNK  0120000\n#define S_IFBLK  0060000\n#define S_IFCHR  0020000\n#define S_IFIFO  0010000\n#define S_IFSOCK 0140000\n#ifdef stat\n#undef stat\n#endif\n#define stat(path, buf) git_stat(path, buf)\nextern int git_stat(const char *, struct stat *);\n#ifdef fstat\n#undef fstat\n#endif\n#define fstat(fd, buf) git_fstat(fd, buf)\nextern int git_fstat(int, struct stat *);\n#ifdef lstat\n#undef lstat\n#endif\n#define lstat(path, buf) git_lstat(path, buf)\nextern int git_lstat(const char *, struct stat *);\n#endif\n\n#define DEFAULT_PACKED_GIT_LIMIT \\\n\t((1024L * 1024L) * (size_t)(sizeof(void*) >= 8 ? (32 * 1024L * 1024L) : 256))\n\n#ifdef NO_PREAD\n#define pread git_pread\nextern ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);\n#endif\n/*\n * Forward decl that will remind us if its twin in cache.h changes.\n * This function is used in compat/pread.c.  But we can't include\n * cache.h there.\n */\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\n\n#ifdef NO_SETENV\n#define setenv gitsetenv\nextern int gitsetenv(const char *, const char *, int);\n#endif\n\n#ifdef NO_MKDTEMP\n#define mkdtemp gitmkdtemp\nextern char *gitmkdtemp(char *);\n#endif\n\n#ifdef NO_UNSETENV\n#define unsetenv gitunsetenv\nextern void gitunsetenv(const char *);\n#endif\n\n#ifdef NO_STRCASESTR\n#define strcasestr gitstrcasestr\nextern char *gitstrcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifdef NO_STRLCPY\n#define strlcpy gitstrlcpy\nextern size_t gitstrlcpy(char *, const char *, size_t);\n#endif\n\n#ifdef NO_STRTOUMAX\n#define strtoumax gitstrtoumax\nextern uintmax_t gitstrtoumax(const char *, char **, int);\n#define strtoimax gitstrtoimax\nextern intmax_t gitstrtoimax(const char *, char **, int);\n#endif\n\n#ifdef NO_HSTRERROR\n#define hstrerror githstrerror\nextern const char *githstrerror(int herror);\n#endif\n\n#ifdef NO_MEMMEM\n#define memmem gitmemmem\nvoid *gitmemmem(const void *haystack, size_t haystacklen,\n                const void *needle, size_t needlelen);\n#endif\n\n#ifdef OVERRIDE_STRDUP\n#ifdef strdup\n#undef strdup\n#endif\n#define strdup gitstrdup\nchar *gitstrdup(const char *s);\n#endif\n\n#ifdef NO_GETPAGESIZE\n#define getpagesize() sysconf(_SC_PAGESIZE)\n#endif\n\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\n#ifdef FREAD_READS_DIRECTORIES\n# if !defined(SUPPRESS_FOPEN_REDEFINITION)\n#  ifdef fopen\n#   undef fopen\n#  endif\n#  define fopen(a,b) git_fopen(a,b)\n# endif\nextern FILE *git_fopen(const char*, const char*);\n#endif\n\n#ifdef SNPRINTF_RETURNS_BOGUS\n#ifdef snprintf\n#undef snprintf\n#endif\n#define snprintf git_snprintf\nextern int git_snprintf(char *str, size_t maxsize,\n\t\t\tconst char *format, ...);\n#ifdef vsnprintf\n#undef vsnprintf\n#endif\n#define vsnprintf git_vsnprintf\nextern int git_vsnprintf(char *str, size_t maxsize,\n\t\t\t const char *format, va_list ap);\n#endif\n\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 1)\n#define HAVE_STRCHRNUL\n#endif\n#endif\n\n#ifndef HAVE_STRCHRNUL\n#define strchrnul gitstrchrnul\nstatic inline char *gitstrchrnul(const char *s, int c)\n{\n\twhile (*s && *s != c)\n\t\ts++;\n\treturn (char *)s;\n}\n#endif\n\n#ifdef NO_INET_PTON\nint inet_pton(int af, const char *src, void *dst);\n#endif\n\n#ifdef NO_INET_NTOP\nconst char *inet_ntop(int af, const void *src, char *dst, size_t size);\n#endif\n\n#ifdef NO_PTHREADS\n#define atexit git_atexit\nextern int git_atexit(void (*handler)(void));\n#endif\n\ntypedef void (*try_to_free_t)(size_t);\nextern try_to_free_t set_try_to_free_routine(try_to_free_t);\n\nstatic inline size_t st_add(size_t a, size_t b)\n{\n\tif (unsigned_add_overflows(a, b))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" + %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a + b;\n}\n#define st_add3(a,b,c)   st_add(st_add((a),(b)),(c))\n#define st_add4(a,b,c,d) st_add(st_add3((a),(b),(c)),(d))\n\nstatic inline size_t st_mult(size_t a, size_t b)\n{\n\tif (unsigned_mult_overflows(a, b))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" * %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a * b;\n}\n\nstatic inline size_t st_sub(size_t a, size_t b)\n{\n\tif (a < b)\n\t\tdie(\"size_t underflow: %\"PRIuMAX\" - %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a - b;\n}\n\n#ifdef HAVE_ALLOCA_H\n# include <alloca.h>\n# define xalloca(size)      (alloca(size))\n# define xalloca_free(p)    do {} while (0)\n#else\n# define xalloca(size)      (xmalloc(size))\n# define xalloca_free(p)    (free(p))\n#endif\nextern char *xstrdup(const char *str);\nextern void *xmalloc(size_t size);\nextern void *xmallocz(size_t size);\nextern void *xmallocz_gently(size_t size);\nextern void *xmemdupz(const void *data, size_t len);\nextern char *xstrndup(const char *str, size_t len);\nextern void *xrealloc(void *ptr, size_t size);\nextern void *xcalloc(size_t nmemb, size_t size);\nextern void *xmmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern void *xmmap_gently(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int xopen(const char *path, int flags, ...);\nextern ssize_t xread(int fd, void *buf, size_t len);\nextern ssize_t xwrite(int fd, const void *buf, size_t len);\nextern ssize_t xpread(int fd, void *buf, size_t len, off_t offset);\nextern int xdup(int fd);\nextern FILE *xfopen(const char *path, const char *mode);\nextern FILE *xfdopen(int fd, const char *mode);\nextern int xmkstemp(char *temp_filename);\nextern int xmkstemp_mode(char *temp_filename, int mode);\nextern char *xgetcwd(void);\nextern FILE *fopen_for_writing(const char *path);\nextern FILE *fopen_or_warn(const char *path, const char *mode);\n\n/*\n * FREE_AND_NULL(ptr) is like free(ptr) followed by ptr = NULL. Note\n * that ptr is used twice, so don't pass e.g. ptr++.\n */\n#define FREE_AND_NULL(p) do { free(p); (p) = NULL; } while (0)\n\n#define ALLOC_ARRAY(x, alloc) (x) = xmalloc(st_mult(sizeof(*(x)), (alloc)))\n#define REALLOC_ARRAY(x, alloc) (x) = xrealloc((x), st_mult(sizeof(*(x)), (alloc)))\n\n#define COPY_ARRAY(dst, src, n) copy_array((dst), (src), (n), sizeof(*(dst)) + \\\n\tBUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))\nstatic inline void copy_array(void *dst, const void *src, size_t n, size_t size)\n{\n\tif (n)\n\t\tmemcpy(dst, src, st_mult(size, n));\n}\n\n#define MOVE_ARRAY(dst, src, n) move_array((dst), (src), (n), sizeof(*(dst)) + \\\n\tBUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))\nstatic inline void move_array(void *dst, const void *src, size_t n, size_t size)\n{\n\tif (n)\n\t\tmemmove(dst, src, st_mult(size, n));\n}\n\n/*\n * These functions help you allocate structs with flex arrays, and copy\n * the data directly into the array. For example, if you had:\n *\n *   struct foo {\n *     int bar;\n *     char name[FLEX_ARRAY];\n *   };\n *\n * you can do:\n *\n *   struct foo *f;\n *   FLEX_ALLOC_MEM(f, name, src, len);\n *\n * to allocate a \"foo\" with the contents of \"src\" in the \"name\" field.\n * The resulting struct is automatically zero'd, and the flex-array field\n * is NUL-terminated (whether the incoming src buffer was or not).\n *\n * The FLEXPTR_* variants operate on structs that don't use flex-arrays,\n * but do want to store a pointer to some extra data in the same allocated\n * block. For example, if you have:\n *\n *   struct foo {\n *     char *name;\n *     int bar;\n *   };\n *\n * you can do:\n *\n *   struct foo *f;\n *   FLEXPTR_ALLOC_STR(f, name, src);\n *\n * and \"name\" will point to a block of memory after the struct, which will be\n * freed along with the struct (but the pointer can be repointed anywhere).\n *\n * The *_STR variants accept a string parameter rather than a ptr/len\n * combination.\n *\n * Note that these macros will evaluate the first parameter multiple\n * times, and it must be assignable as an lvalue.\n */\n#define FLEX_ALLOC_MEM(x, flexname, buf, len) do { \\\n\tsize_t flex_array_len_ = (len); \\\n\t(x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \\\n\tmemcpy((void *)(x)->flexname, (buf), flex_array_len_); \\\n} while (0)\n#define FLEXPTR_ALLOC_MEM(x, ptrname, buf, len) do { \\\n\tsize_t flex_array_len_ = (len); \\\n\t(x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \\\n\tmemcpy((x) + 1, (buf), flex_array_len_); \\\n\t(x)->ptrname = (void *)((x)+1); \\\n} while(0)\n#define FLEX_ALLOC_STR(x, flexname, str) \\\n\tFLEX_ALLOC_MEM((x), flexname, (str), strlen(str))\n#define FLEXPTR_ALLOC_STR(x, ptrname, str) \\\n\tFLEXPTR_ALLOC_MEM((x), ptrname, (str), strlen(str))\n\nstatic inline char *xstrdup_or_null(const char *str)\n{\n\treturn str ? xstrdup(str) : NULL;\n}\n\nstatic inline size_t xsize_t(off_t len)\n{\n\tsize_t size = (size_t) len;\n\n\tif (len != (off_t) size)\n\t\tdie(\"Cannot handle files this big\");\n\treturn size;\n}\n\n__attribute__((format (printf, 3, 4)))\nextern int xsnprintf(char *dst, size_t max, const char *fmt, ...);\n\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 256\n#endif\n\nextern int xgethostname(char *buf, size_t len);\n\n/* in ctype.c, for kwset users */\nextern const unsigned char tolower_trans_tbl[256];\n\n/* Sane ctype - no locale, and works with signed chars */\n#undef isascii\n#undef isspace\n#undef isdigit\n#undef isalpha\n#undef isalnum\n#undef isprint\n#undef islower\n#undef isupper\n#undef tolower\n#undef toupper\n#undef iscntrl\n#undef ispunct\n#undef isxdigit\n\nextern const unsigned char sane_ctype[256];\n#define GIT_SPACE 0x01\n#define GIT_DIGIT 0x02\n#define GIT_ALPHA 0x04\n#define GIT_GLOB_SPECIAL 0x08\n#define GIT_REGEX_SPECIAL 0x10\n#define GIT_PATHSPEC_MAGIC 0x20\n#define GIT_CNTRL 0x40\n#define GIT_PUNCT 0x80\n#define sane_istest(x,mask) ((sane_ctype[(unsigned char)(x)] & (mask)) != 0)\n#define isascii(x) (((x) & ~0x7f) == 0)\n#define isspace(x) sane_istest(x,GIT_SPACE)\n#define isdigit(x) sane_istest(x,GIT_DIGIT)\n#define isalpha(x) sane_istest(x,GIT_ALPHA)\n#define isalnum(x) sane_istest(x,GIT_ALPHA | GIT_DIGIT)\n#define isprint(x) ((x) >= 0x20 && (x) <= 0x7e)\n#define islower(x) sane_iscase(x, 1)\n#define isupper(x) sane_iscase(x, 0)\n#define is_glob_special(x) sane_istest(x,GIT_GLOB_SPECIAL)\n#define is_regex_special(x) sane_istest(x,GIT_GLOB_SPECIAL | GIT_REGEX_SPECIAL)\n#define iscntrl(x) (sane_istest(x,GIT_CNTRL))\n#define ispunct(x) sane_istest(x, GIT_PUNCT | GIT_REGEX_SPECIAL | \\\n\t\tGIT_GLOB_SPECIAL | GIT_PATHSPEC_MAGIC)\n#define isxdigit(x) (hexval_table[(unsigned char)(x)] != -1)\n#define tolower(x) sane_case((unsigned char)(x), 0x20)\n#define toupper(x) sane_case((unsigned char)(x), 0)\n#define is_pathspec_magic(x) sane_istest(x,GIT_PATHSPEC_MAGIC)\n\nstatic inline int sane_case(int x, int high)\n{\n\tif (sane_istest(x, GIT_ALPHA))\n\t\tx = (x & ~0x20) | high;\n\treturn x;\n}\n\nstatic inline int sane_iscase(int x, int is_lower)\n{\n\tif (!sane_istest(x, GIT_ALPHA))\n\t\treturn 0;\n\n\tif (is_lower)\n\t\treturn (x & 0x20) != 0;\n\telse\n\t\treturn (x & 0x20) == 0;\n}\n\n/*\n * Like skip_prefix, but compare case-insensitively. Note that the comparison\n * is done via tolower(), so it is strictly ASCII (no multi-byte characters or\n * locale-specific conversions).\n */\nstatic inline int skip_iprefix(const char *str, const char *prefix,\n\t\t\t       const char **out)\n{\n\tdo {\n\t\tif (!*prefix) {\n\t\t\t*out = str;\n\t\t\treturn 1;\n\t\t}\n\t} while (tolower(*str++) == tolower(*prefix++));\n\treturn 0;\n}\n\nstatic inline int strtoul_ui(char const *s, int base, unsigned int *result)\n{\n\tunsigned long ul;\n\tchar *p;\n\n\terrno = 0;\n\t/* negative values would be accepted by strtoul */\n\tif (strchr(s, '-'))\n\t\treturn -1;\n\tul = strtoul(s, &p, base);\n\tif (errno || *p || p == s || (unsigned int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\nstatic inline int strtol_i(char const *s, int base, int *result)\n{\n\tlong ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtol(s, &p, base);\n\tif (errno || *p || p == s || (int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\n#ifdef INTERNAL_QSORT\nvoid git_qsort(void *base, size_t nmemb, size_t size,\n\t       int(*compar)(const void *, const void *));\n#define qsort git_qsort\n#endif\n\n#define QSORT(base, n, compar) sane_qsort((base), (n), sizeof(*(base)), compar)\nstatic inline void sane_qsort(void *base, size_t nmemb, size_t size,\n\t\t\t      int(*compar)(const void *, const void *))\n{\n\tif (nmemb > 1)\n\t\tqsort(base, nmemb, size, compar);\n}\n\n#ifndef HAVE_ISO_QSORT_S\nint git_qsort_s(void *base, size_t nmemb, size_t size,\n\t\tint (*compar)(const void *, const void *, void *), void *ctx);\n#define qsort_s git_qsort_s\n#endif\n\n#define QSORT_S(base, n, compar, ctx) do {\t\t\t\\\n\tif (qsort_s((base), (n), sizeof(*(base)), compar, ctx))\t\\\n\t\tdie(\"BUG: qsort_s() failed\");\t\t\t\\\n} while (0)\n\n#ifndef REG_STARTEND\n#error \"Git requires REG_STARTEND support. Compile with NO_REGEX=NeedsStartEnd\"\n#endif\n\nstatic inline int regexec_buf(const regex_t *preg, const char *buf, size_t size,\n\t\t\t      size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n\tassert(nmatch > 0 && pmatch);\n\tpmatch[0].rm_so = 0;\n\tpmatch[0].rm_eo = size;\n\treturn regexec(preg, buf, nmatch, pmatch, eflags | REG_STARTEND);\n}\n\n#ifndef DIR_HAS_BSD_GROUP_SEMANTICS\n# define FORCE_DIR_SET_GID S_ISGID\n#else\n# define FORCE_DIR_SET_GID 0\n#endif\n\n#ifdef NO_NSEC\n#undef USE_NSEC\n#define ST_CTIME_NSEC(st) 0\n#define ST_MTIME_NSEC(st) 0\n#else\n#ifdef USE_ST_TIMESPEC\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))\n#else\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))\n#endif\n#endif\n\n#ifdef UNRELIABLE_FSTAT\n#define fstat_is_reliable() 0\n#else\n#define fstat_is_reliable() 1\n#endif\n\n#ifndef va_copy\n/*\n * Since an obvious implementation of va_list would be to make it a\n * pointer into the stack frame, a simple assignment will work on\n * many systems.  But let's try to be more portable.\n */\n#ifdef __va_copy\n#define va_copy(dst, src) __va_copy(dst, src)\n#else\n#define va_copy(dst, src) ((dst) = (src))\n#endif\n#endif\n\n#if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__C99_MACRO_WITH_VA_ARGS)\n#define HAVE_VARIADIC_MACROS 1\n#endif\n\n#ifdef HAVE_VARIADIC_MACROS\n__attribute__((format (printf, 3, 4))) NORETURN\nvoid BUG_fl(const char *file, int line, const char *fmt, ...);\n#define BUG(...) BUG_fl(__FILE__, __LINE__, __VA_ARGS__)\n#else\n__attribute__((format (printf, 1, 2))) NORETURN\nvoid BUG(const char *fmt, ...);\n#endif\n\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Returns 0 on success, which includes trying to unlink an object that does\n * not exist.\n */\nint unlink_or_warn(const char *path);\n /*\n  * Tries to unlink file.  Returns 0 if unlink succeeded\n  * or the file already didn't exist.  Returns -1 and\n  * appends a message to err suitable for\n  * 'error(\"%s\", err->buf)' on error.\n  */\nint unlink_or_msg(const char *file, struct strbuf *err);\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Returns 0 on success, which includes trying to remove a directory that does\n * not exist.\n */\nint rmdir_or_warn(const char *path);\n/*\n * Calls the correct function out of {unlink,rmdir}_or_warn based on\n * the supplied file mode.\n */\nint remove_or_warn(unsigned int mode, const char *path);\n\n/*\n * Call access(2), but warn for any error except \"missing file\"\n * (ENOENT or ENOTDIR).\n */\n#define ACCESS_EACCES_OK (1U << 0)\nint access_or_warn(const char *path, int mode, unsigned flag);\nint access_or_die(const char *path, int mode, unsigned flag);\n\n/* Warn on an inaccessible file if errno indicates this is an error */\nint warn_on_fopen_errors(const char *path);\n\n#ifdef GMTIME_UNRELIABLE_ERRORS\nstruct tm *git_gmtime(const time_t *);\nstruct tm *git_gmtime_r(const time_t *, struct tm *);\n#define gmtime git_gmtime\n#define gmtime_r git_gmtime_r\n#endif\n\n#if !defined(USE_PARENS_AROUND_GETTEXT_N) && defined(__GNUC__)\n#define USE_PARENS_AROUND_GETTEXT_N 1\n#endif\n\n#ifndef SHELL_PATH\n# define SHELL_PATH \"/bin/sh\"\n#endif\n\n#ifndef _POSIX_THREAD_SAFE_FUNCTIONS\n#define flockfile(fh)\n#define funlockfile(fh)\n#define getc_unlocked(fh) getc(fh)\n#endif\n\n/*\n * Our code often opens a path to an optional file, to work on its\n * contents when we can successfully open it.  We can ignore a failure\n * to open if such an optional file does not exist, but we do want to\n * report a failure in opening for other reasons (e.g. we got an I/O\n * error, or the file is there, but we lack the permission to open).\n *\n * Call this function after seeing an error from open() or fopen() to\n * see if the errno indicates a missing file that we can safely ignore.\n */\nstatic inline int is_missing_file_error(int errno_)\n{\n\treturn (errno_ == ENOENT || errno_ == ENOTDIR);\n}\n\nextern int cmd_main(int, const char **);\n\n/*\n * You can mark a stack variable with UNLEAK(var) to avoid it being\n * reported as a leak by tools like LSAN or valgrind. The argument\n * should generally be the variable itself (not its address and not what\n * it points to). It's safe to use this on pointers which may already\n * have been freed, or on pointers which may still be in use.\n *\n * Use this _only_ for a variable that leaks by going out of scope at\n * program exit (so only from cmd_* functions or their direct helpers).\n * Normal functions, especially those which may be called multiple\n * times, should actually free their memory. This is only meant as\n * an annotation, and does nothing in non-leak-checking builds.\n */\n#ifdef SUPPRESS_ANNOTATED_LEAKS\nextern void unleak_memory(const void *ptr, size_t len);\n#define UNLEAK(var) unleak_memory(&(var), sizeof(var))\n#else\n#define UNLEAK(var) do {} while (0)\n#endif\n\n#endif\n", "#include \"cache.h\"\n\nstatic int threaded_check_leading_path(struct cache_def *cache, const char *name, int len);\nstatic int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len);\n\n/*\n * Returns the length (on a path component basis) of the longest\n * common prefix match of 'name_a' and 'name_b'.\n */\nstatic int longest_path_match(const char *name_a, int len_a,\n\t\t\t      const char *name_b, int len_b,\n\t\t\t      int *previous_slash)\n{\n\tint max_len, match_len = 0, match_len_prev = 0, i = 0;\n\n\tmax_len = len_a < len_b ? len_a : len_b;\n\twhile (i < max_len && name_a[i] == name_b[i]) {\n\t\tif (name_a[i] == '/') {\n\t\t\tmatch_len_prev = match_len;\n\t\t\tmatch_len = i;\n\t\t}\n\t\ti++;\n\t}\n\t/*\n\t * Is 'name_b' a substring of 'name_a', the other way around,\n\t * or is 'name_a' and 'name_b' the exact same string?\n\t */\n\tif (i >= max_len && ((len_a > len_b && name_a[len_b] == '/') ||\n\t\t\t     (len_a < len_b && name_b[len_a] == '/') ||\n\t\t\t     (len_a == len_b))) {\n\t\tmatch_len_prev = match_len;\n\t\tmatch_len = i;\n\t}\n\t*previous_slash = match_len_prev;\n\treturn match_len;\n}\n\nstatic struct cache_def default_cache = CACHE_DEF_INIT;\n\nstatic inline void reset_lstat_cache(struct cache_def *cache)\n{\n\tstrbuf_reset(&cache->path);\n\tcache->flags = 0;\n\t/*\n\t * The track_flags and prefix_len_stat_func members is only\n\t * set by the safeguard rule inside lstat_cache()\n\t */\n}\n\n#define FL_DIR      (1 << 0)\n#define FL_NOENT    (1 << 1)\n#define FL_SYMLINK  (1 << 2)\n#define FL_LSTATERR (1 << 3)\n#define FL_ERR      (1 << 4)\n#define FL_FULLPATH (1 << 5)\n\n/*\n * Check if name 'name' of length 'len' has a symlink leading\n * component, or if the directory exists and is real, or not.\n *\n * To speed up the check, some information is allowed to be cached.\n * This can be indicated by the 'track_flags' argument, which also can\n * be used to indicate that we should check the full path.\n *\n * The 'prefix_len_stat_func' parameter can be used to set the length\n * of the prefix, where the cache should use the stat() function\n * instead of the lstat() function to test each path component.\n */\nstatic int lstat_cache_matchlen(struct cache_def *cache,\n\t\t\t\tconst char *name, int len,\n\t\t\t\tint *ret_flags, int track_flags,\n\t\t\t\tint prefix_len_stat_func)\n{\n\tint match_len, last_slash, last_slash_dir, previous_slash;\n\tint save_flags, ret;\n\tstruct stat st;\n\n\tif (cache->track_flags != track_flags ||\n\t    cache->prefix_len_stat_func != prefix_len_stat_func) {\n\t\t/*\n\t\t * As a safeguard rule we clear the cache if the\n\t\t * values of track_flags and/or prefix_len_stat_func\n\t\t * does not match with the last supplied values.\n\t\t */\n\t\treset_lstat_cache(cache);\n\t\tcache->track_flags = track_flags;\n\t\tcache->prefix_len_stat_func = prefix_len_stat_func;\n\t\tmatch_len = last_slash = 0;\n\t} else {\n\t\t/*\n\t\t * Check to see if we have a match from the cache for\n\t\t * the 2 \"excluding\" path types.\n\t\t */\n\t\tmatch_len = last_slash =\n\t\t\tlongest_path_match(name, len, cache->path.buf,\n\t\t\t\t\t   cache->path.len, &previous_slash);\n\t\t*ret_flags = cache->flags & track_flags & (FL_NOENT|FL_SYMLINK);\n\n\t\tif (!(track_flags & FL_FULLPATH) && match_len == len)\n\t\t\tmatch_len = last_slash = previous_slash;\n\n\t\tif (*ret_flags && match_len == cache->path.len)\n\t\t\treturn match_len;\n\t\t/*\n\t\t * If we now have match_len > 0, we would know that\n\t\t * the matched part will always be a directory.\n\t\t *\n\t\t * Also, if we are tracking directories and 'name' is\n\t\t * a substring of the cache on a path component basis,\n\t\t * we can return immediately.\n\t\t */\n\t\t*ret_flags = track_flags & FL_DIR;\n\t\tif (*ret_flags && len == match_len)\n\t\t\treturn match_len;\n\t}\n\n\t/*\n\t * Okay, no match from the cache so far, so now we have to\n\t * check the rest of the path components.\n\t */\n\t*ret_flags = FL_DIR;\n\tlast_slash_dir = last_slash;\n\tif (len > cache->path.len)\n\t\tstrbuf_grow(&cache->path, len - cache->path.len);\n\twhile (match_len < len) {\n\t\tdo {\n\t\t\tcache->path.buf[match_len] = name[match_len];\n\t\t\tmatch_len++;\n\t\t} while (match_len < len && name[match_len] != '/');\n\t\tif (match_len >= len && !(track_flags & FL_FULLPATH))\n\t\t\tbreak;\n\t\tlast_slash = match_len;\n\t\tcache->path.buf[last_slash] = '\\0';\n\n\t\tif (last_slash <= prefix_len_stat_func)\n\t\t\tret = stat(cache->path.buf, &st);\n\t\telse\n\t\t\tret = lstat(cache->path.buf, &st);\n\n\t\tif (ret) {\n\t\t\t*ret_flags = FL_LSTATERR;\n\t\t\tif (errno == ENOENT)\n\t\t\t\t*ret_flags |= FL_NOENT;\n\t\t} else if (S_ISDIR(st.st_mode)) {\n\t\t\tlast_slash_dir = last_slash;\n\t\t\tcontinue;\n\t\t} else if (S_ISLNK(st.st_mode)) {\n\t\t\t*ret_flags = FL_SYMLINK;\n\t\t} else {\n\t\t\t*ret_flags = FL_ERR;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * At the end update the cache.  Note that max 3 different\n\t * path types, FL_NOENT, FL_SYMLINK and FL_DIR, can be cached\n\t * for the moment!\n\t */\n\tsave_flags = *ret_flags & track_flags & (FL_NOENT|FL_SYMLINK);\n\tif (save_flags && last_slash > 0) {\n\t\tcache->path.buf[last_slash] = '\\0';\n\t\tcache->path.len = last_slash;\n\t\tcache->flags = save_flags;\n\t} else if ((track_flags & FL_DIR) && last_slash_dir > 0) {\n\t\t/*\n\t\t * We have a separate test for the directory case,\n\t\t * since it could be that we have found a symlink or a\n\t\t * non-existing directory and the track_flags says\n\t\t * that we cannot cache this fact, so the cache would\n\t\t * then have been left empty in this case.\n\t\t *\n\t\t * But if we are allowed to track real directories, we\n\t\t * can still cache the path components before the last\n\t\t * one (the found symlink or non-existing component).\n\t\t */\n\t\tcache->path.buf[last_slash_dir] = '\\0';\n\t\tcache->path.len = last_slash_dir;\n\t\tcache->flags = FL_DIR;\n\t} else {\n\t\treset_lstat_cache(cache);\n\t}\n\treturn match_len;\n}\n\nstatic int lstat_cache(struct cache_def *cache, const char *name, int len,\n\t\t       int track_flags, int prefix_len_stat_func)\n{\n\tint flags;\n\t(void)lstat_cache_matchlen(cache, name, len, &flags, track_flags,\n\t\t\tprefix_len_stat_func);\n\treturn flags;\n}\n\n#define USE_ONLY_LSTAT  0\n\n/*\n * Return non-zero if path 'name' has a leading symlink component\n */\nint threaded_has_symlink_leading_path(struct cache_def *cache, const char *name, int len)\n{\n\treturn lstat_cache(cache, name, len, FL_SYMLINK|FL_DIR, USE_ONLY_LSTAT) & FL_SYMLINK;\n}\n\n/*\n * Return non-zero if path 'name' has a leading symlink component\n */\nint has_symlink_leading_path(const char *name, int len)\n{\n\treturn threaded_has_symlink_leading_path(&default_cache, name, len);\n}\n\n/*\n * Return zero if path 'name' has a leading symlink component or\n * if some leading path component does not exists.\n *\n * Return -1 if leading path exists and is a directory.\n *\n * Return path length if leading path exists and is neither a\n * directory nor a symlink.\n */\nint check_leading_path(const char *name, int len)\n{\n    return threaded_check_leading_path(&default_cache, name, len);\n}\n\n/*\n * Return zero if path 'name' has a leading symlink component or\n * if some leading path component does not exists.\n *\n * Return -1 if leading path exists and is a directory.\n *\n * Return path length if leading path exists and is neither a\n * directory nor a symlink.\n */\nstatic int threaded_check_leading_path(struct cache_def *cache, const char *name, int len)\n{\n\tint flags;\n\tint match_len = lstat_cache_matchlen(cache, name, len, &flags,\n\t\t\t   FL_SYMLINK|FL_NOENT|FL_DIR, USE_ONLY_LSTAT);\n\tif (flags & FL_NOENT)\n\t\treturn 0;\n\telse if (flags & FL_DIR)\n\t\treturn -1;\n\telse\n\t\treturn match_len;\n}\n\n/*\n * Return non-zero if all path components of 'name' exists as a\n * directory.  If prefix_len > 0, we will test with the stat()\n * function instead of the lstat() function for a prefix length of\n * 'prefix_len', thus we then allow for symlinks in the prefix part as\n * long as those points to real existing directories.\n */\nint has_dirs_only_path(const char *name, int len, int prefix_len)\n{\n\treturn threaded_has_dirs_only_path(&default_cache, name, len, prefix_len);\n}\n\n/*\n * Return non-zero if all path components of 'name' exists as a\n * directory.  If prefix_len > 0, we will test with the stat()\n * function instead of the lstat() function for a prefix length of\n * 'prefix_len', thus we then allow for symlinks in the prefix part as\n * long as those points to real existing directories.\n */\nstatic int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n{\n\treturn lstat_cache(cache, name, len,\n\t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n\t\tFL_DIR;\n}\n\nstatic struct strbuf removal = STRBUF_INIT;\n\nstatic void do_remove_scheduled_dirs(int new_len)\n{\n\twhile (removal.len > new_len) {\n\t\tremoval.buf[removal.len] = '\\0';\n\t\tif (rmdir(removal.buf))\n\t\t\tbreak;\n\t\tdo {\n\t\t\tremoval.len--;\n\t\t} while (removal.len > new_len &&\n\t\t\t removal.buf[removal.len] != '/');\n\t}\n\tremoval.len = new_len;\n}\n\nvoid schedule_dir_for_removal(const char *name, int len)\n{\n\tint match_len, last_slash, i, previous_slash;\n\n\tmatch_len = last_slash = i =\n\t\tlongest_path_match(name, len, removal.buf, removal.len,\n\t\t\t\t   &previous_slash);\n\t/* Find last slash inside 'name' */\n\twhile (i < len) {\n\t\tif (name[i] == '/')\n\t\t\tlast_slash = i;\n\t\ti++;\n\t}\n\n\t/*\n\t * If we are about to go down the directory tree, we check if\n\t * we must first go upwards the tree, such that we then can\n\t * remove possible empty directories as we go upwards.\n\t */\n\tif (match_len < last_slash && match_len < removal.len)\n\t\tdo_remove_scheduled_dirs(match_len);\n\t/*\n\t * If we go deeper down the directory tree, we only need to\n\t * save the new path components as we go down.\n\t */\n\tif (match_len < last_slash)\n\t\tstrbuf_add(&removal, &name[match_len], last_slash - match_len);\n}\n\nvoid remove_scheduled_dirs(void)\n{\n\tdo_remove_scheduled_dirs(0);\n}\n", "#!/bin/sh\n\ntest_description='blob conversion via gitattributes'\n\n. ./test-lib.sh\n\nTEST_ROOT=\"$PWD\"\nPATH=$TEST_ROOT:$PATH\n\nwrite_script <<\\EOF \"$TEST_ROOT/rot13.sh\"\ntr \\\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' \\\n  'nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'\nEOF\n\nwrite_script rot13-filter.pl \"$PERL_PATH\" \\\n\t<\"$TEST_DIRECTORY\"/t0021/rot13-filter.pl\n\ngenerate_random_characters () {\n\tLEN=$1\n\tNAME=$2\n\ttest-genrandom some-seed $LEN |\n\t\tperl -pe \"s/./chr((ord($&) % 26) + ord('a'))/sge\" >\"$TEST_ROOT/$NAME\"\n}\n\nfile_size () {\n\tperl -e 'print -s $ARGV[0]' \"$1\"\n}\n\nfilter_git () {\n\trm -f *.log &&\n\tgit \"$@\"\n}\n\n# Compare two files and ensure that `clean` and `smudge` respectively are\n# called at least once if specified in the `expect` file. The actual\n# invocation count is not relevant because their number can vary.\n# c.f. http://public-inbox.org/git/xmqqshv18i8i.fsf@gitster.mtv.corp.google.com/\ntest_cmp_count () {\n\texpect=$1\n\tactual=$2\n\tfor FILE in \"$expect\" \"$actual\"\n\tdo\n\t\tsort \"$FILE\" | uniq -c |\n\t\tsed -e \"s/^ *[0-9][0-9]*[ \t]*IN: /x IN: /\" >\"$FILE.tmp\"\n\tdone &&\n\ttest_cmp \"$expect.tmp\" \"$actual.tmp\" &&\n\trm \"$expect.tmp\" \"$actual.tmp\"\n}\n\n# Compare two files but exclude all `clean` invocations because Git can\n# call `clean` zero or more times.\n# c.f. http://public-inbox.org/git/xmqqshv18i8i.fsf@gitster.mtv.corp.google.com/\ntest_cmp_exclude_clean () {\n\texpect=$1\n\tactual=$2\n\tfor FILE in \"$expect\" \"$actual\"\n\tdo\n\t\tgrep -v \"IN: clean\" \"$FILE\" >\"$FILE.tmp\"\n\tdone &&\n\ttest_cmp \"$expect.tmp\" \"$actual.tmp\" &&\n\trm \"$expect.tmp\" \"$actual.tmp\"\n}\n\n# Check that the contents of two files are equal and that their rot13 version\n# is equal to the committed content.\ntest_cmp_committed_rot13 () {\n\ttest_cmp \"$1\" \"$2\" &&\n\trot13.sh <\"$1\" >expected &&\n\tgit cat-file blob :\"$2\" >actual &&\n\ttest_cmp expected actual\n}\n\ntest_expect_success setup '\n\tgit config filter.rot13.smudge ./rot13.sh &&\n\tgit config filter.rot13.clean ./rot13.sh &&\n\n\t{\n\t    echo \"*.t filter=rot13\"\n\t    echo \"*.i ident\"\n\t} >.gitattributes &&\n\n\t{\n\t    echo a b c d e f g h i j k l m\n\t    echo n o p q r s t u v w x y z\n\t    echo '\\''$Id$'\\''\n\t} >test &&\n\tcat test >test.t &&\n\tcat test >test.o &&\n\tcat test >test.i &&\n\tgit add test test.t test.i &&\n\trm -f test test.t test.i &&\n\tgit checkout -- test test.t test.i &&\n\n\techo \"content-test2\" >test2.o &&\n\techo \"content-test3 - filename with special characters\" >\"test3 '\\''sq'\\'',\\$x=.o\"\n'\n\nscript='s/^\\$Id: \\([0-9a-f]*\\) \\$/\\1/p'\n\ntest_expect_success check '\n\n\ttest_cmp test.o test &&\n\ttest_cmp test.o test.t &&\n\n\t# ident should be stripped in the repository\n\tgit diff --raw --exit-code :test :test.i &&\n\tid=$(git rev-parse --verify :test) &&\n\tembedded=$(sed -ne \"$script\" test.i) &&\n\ttest \"z$id\" = \"z$embedded\" &&\n\n\tgit cat-file blob :test.t >test.r &&\n\n\t./rot13.sh <test.o >test.t &&\n\ttest_cmp test.r test.t\n'\n\n# If an expanded ident ever gets into the repository, we want to make sure that\n# it is collapsed before being expanded again on checkout\ntest_expect_success expanded_in_repo '\n\t{\n\t\techo \"File with expanded keywords\"\n\t\techo \"\\$Id\\$\"\n\t\techo \"\\$Id:\\$\"\n\t\techo \"\\$Id: 0000000000000000000000000000000000000000 \\$\"\n\t\techo \"\\$Id: NoSpaceAtEnd\\$\"\n\t\techo \"\\$Id:NoSpaceAtFront \\$\"\n\t\techo \"\\$Id:NoSpaceAtEitherEnd\\$\"\n\t\techo \"\\$Id: NoTerminatingSymbol\"\n\t\techo \"\\$Id: Foreign Commit With Spaces \\$\"\n\t} >expanded-keywords.0 &&\n\n\t{\n\t\tcat expanded-keywords.0 &&\n\t\tprintf \"\\$Id: NoTerminatingSymbolAtEOF\"\n\t} >expanded-keywords &&\n\tcat expanded-keywords >expanded-keywords-crlf &&\n\tgit add expanded-keywords expanded-keywords-crlf &&\n\tgit commit -m \"File with keywords expanded\" &&\n\tid=$(git rev-parse --verify :expanded-keywords) &&\n\n\t{\n\t\techo \"File with expanded keywords\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: NoTerminatingSymbol\"\n\t\techo \"\\$Id: Foreign Commit With Spaces \\$\"\n\t} >expected-output.0 &&\n\t{\n\t\tcat expected-output.0 &&\n\t\tprintf \"\\$Id: NoTerminatingSymbolAtEOF\"\n\t} >expected-output &&\n\t{\n\t\tappend_cr <expected-output.0 &&\n\t\tprintf \"\\$Id: NoTerminatingSymbolAtEOF\"\n\t} >expected-output-crlf &&\n\t{\n\t\techo \"expanded-keywords ident\"\n\t\techo \"expanded-keywords-crlf ident text eol=crlf\"\n\t} >>.gitattributes &&\n\n\trm -f expanded-keywords expanded-keywords-crlf &&\n\n\tgit checkout -- expanded-keywords &&\n\ttest_cmp expanded-keywords expected-output &&\n\n\tgit checkout -- expanded-keywords-crlf &&\n\ttest_cmp expanded-keywords-crlf expected-output-crlf\n'\n\n# The use of %f in a filter definition is expanded to the path to\n# the filename being smudged or cleaned.  It must be shell escaped.\n# First, set up some interesting file names and pet them in\n# .gitattributes.\ntest_expect_success 'filter shell-escaped filenames' '\n\tcat >argc.sh <<-EOF &&\n\t#!$SHELL_PATH\n\tcat >/dev/null\n\techo argc: \\$# \"\\$@\"\n\tEOF\n\tnormal=name-no-magic &&\n\tspecial=\"name  with '\\''sq'\\'' and \\$x\" &&\n\techo some test text >\"$normal\" &&\n\techo some test text >\"$special\" &&\n\tgit add \"$normal\" \"$special\" &&\n\tgit commit -q -m \"add files\" &&\n\techo \"name* filter=argc\" >.gitattributes &&\n\n\t# delete the files and check them out again, using a smudge filter\n\t# that will count the args and echo the command-line back to us\n\ttest_config filter.argc.smudge \"sh ./argc.sh %f\" &&\n\trm \"$normal\" \"$special\" &&\n\tgit checkout -- \"$normal\" \"$special\" &&\n\n\t# make sure argc.sh counted the right number of args\n\techo \"argc: 1 $normal\" >expect &&\n\ttest_cmp expect \"$normal\" &&\n\techo \"argc: 1 $special\" >expect &&\n\ttest_cmp expect \"$special\" &&\n\n\t# do the same thing, but with more args in the filter expression\n\ttest_config filter.argc.smudge \"sh ./argc.sh %f --my-extra-arg\" &&\n\trm \"$normal\" \"$special\" &&\n\tgit checkout -- \"$normal\" \"$special\" &&\n\n\t# make sure argc.sh counted the right number of args\n\techo \"argc: 2 $normal --my-extra-arg\" >expect &&\n\ttest_cmp expect \"$normal\" &&\n\techo \"argc: 2 $special --my-extra-arg\" >expect &&\n\ttest_cmp expect \"$special\" &&\n\t:\n'\n\ntest_expect_success 'required filter should filter data' '\n\ttest_config filter.required.smudge ./rot13.sh &&\n\ttest_config filter.required.clean ./rot13.sh &&\n\ttest_config filter.required.required true &&\n\n\techo \"*.r filter=required\" >.gitattributes &&\n\n\tcat test.o >test.r &&\n\tgit add test.r &&\n\n\trm -f test.r &&\n\tgit checkout -- test.r &&\n\ttest_cmp test.o test.r &&\n\n\t./rot13.sh <test.o >expected &&\n\tgit cat-file blob :test.r >actual &&\n\ttest_cmp expected actual\n'\n\ntest_expect_success 'required filter smudge failure' '\n\ttest_config filter.failsmudge.smudge false &&\n\ttest_config filter.failsmudge.clean cat &&\n\ttest_config filter.failsmudge.required true &&\n\n\techo \"*.fs filter=failsmudge\" >.gitattributes &&\n\n\techo test >test.fs &&\n\tgit add test.fs &&\n\trm -f test.fs &&\n\ttest_must_fail git checkout -- test.fs\n'\n\ntest_expect_success 'required filter clean failure' '\n\ttest_config filter.failclean.smudge cat &&\n\ttest_config filter.failclean.clean false &&\n\ttest_config filter.failclean.required true &&\n\n\techo \"*.fc filter=failclean\" >.gitattributes &&\n\n\techo test >test.fc &&\n\ttest_must_fail git add test.fc\n'\n\ntest_expect_success 'filtering large input to small output should use little memory' '\n\ttest_config filter.devnull.clean \"cat >/dev/null\" &&\n\ttest_config filter.devnull.required true &&\n\tfor i in $(test_seq 1 30); do printf \"%1048576d\" 1; done >30MB &&\n\techo \"30MB filter=devnull\" >.gitattributes &&\n\tGIT_MMAP_LIMIT=1m GIT_ALLOC_LIMIT=1m git add 30MB\n'\n\ntest_expect_success 'filter that does not read is fine' '\n\ttest-genrandom foo $((128 * 1024 + 1)) >big &&\n\techo \"big filter=epipe\" >.gitattributes &&\n\ttest_config filter.epipe.clean \"echo xyzzy\" &&\n\tgit add big &&\n\tgit cat-file blob :big >actual &&\n\techo xyzzy >expect &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success EXPENSIVE 'filter large file' '\n\ttest_config filter.largefile.smudge cat &&\n\ttest_config filter.largefile.clean cat &&\n\tfor i in $(test_seq 1 2048); do printf \"%1048576d\" 1; done >2GB &&\n\techo \"2GB filter=largefile\" >.gitattributes &&\n\tgit add 2GB 2>err &&\n\ttest_must_be_empty err &&\n\trm -f 2GB &&\n\tgit checkout -- 2GB 2>err &&\n\ttest_must_be_empty err\n'\n\ntest_expect_success \"filter: clean empty file\" '\n\ttest_config filter.in-repo-header.clean  \"echo cleaned && cat\" &&\n\ttest_config filter.in-repo-header.smudge \"sed 1d\" &&\n\n\techo \"empty-in-worktree    filter=in-repo-header\" >>.gitattributes &&\n\t>empty-in-worktree &&\n\n\techo cleaned >expected &&\n\tgit add empty-in-worktree &&\n\tgit show :empty-in-worktree >actual &&\n\ttest_cmp expected actual\n'\n\ntest_expect_success \"filter: smudge empty file\" '\n\ttest_config filter.empty-in-repo.clean \"cat >/dev/null\" &&\n\ttest_config filter.empty-in-repo.smudge \"echo smudged && cat\" &&\n\n\techo \"empty-in-repo filter=empty-in-repo\" >>.gitattributes &&\n\techo dead data walking >empty-in-repo &&\n\tgit add empty-in-repo &&\n\n\techo smudged >expected &&\n\tgit checkout-index --prefix=filtered- empty-in-repo &&\n\ttest_cmp expected filtered-empty-in-repo\n'\n\ntest_expect_success 'disable filter with empty override' '\n\ttest_config_global filter.disable.smudge false &&\n\ttest_config_global filter.disable.clean false &&\n\ttest_config filter.disable.smudge false &&\n\ttest_config filter.disable.clean false &&\n\n\techo \"*.disable filter=disable\" >.gitattributes &&\n\n\techo test >test.disable &&\n\tgit -c filter.disable.clean= add test.disable 2>err &&\n\ttest_must_be_empty err &&\n\trm -f test.disable &&\n\tgit -c filter.disable.smudge= checkout -- test.disable 2>err &&\n\ttest_must_be_empty err\n'\n\ntest_expect_success 'diff does not reuse worktree files that need cleaning' '\n\ttest_config filter.counter.clean \"echo . >>count; sed s/^/clean:/\" &&\n\techo \"file filter=counter\" >.gitattributes &&\n\ttest_commit one file &&\n\ttest_commit two file &&\n\n\t>count &&\n\tgit diff-tree -p HEAD &&\n\ttest_line_count = 0 count\n'\n\ntest_expect_success PERL 'required process filter should filter data' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\ttest_config_global filter.protocol.required true &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\t\tgit add . &&\n\t\tgit commit -m \"test commit 1\" &&\n\t\tgit branch empty-branch &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tcp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\tmkdir testsubdir &&\n\t\tcp \"$TEST_ROOT/test3 '\\''sq'\\'',\\$x=.o\" \"testsubdir/test3 '\\''sq'\\'',\\$x=.r\" &&\n\t\t>test4-empty.r &&\n\n\t\tS=$(file_size test.r) &&\n\t\tS2=$(file_size test2.r) &&\n\t\tS3=$(file_size \"testsubdir/test3 '\\''sq'\\'',\\$x=.r\") &&\n\n\t\tfilter_git add . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tIN: clean test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tIN: clean test4-empty.r 0 [OK] -- OUT: 0  [OK]\n\t\t\tIN: clean testsubdir/test3 '\\''sq'\\'',\\$x=.r $S3 [OK] -- OUT: $S3 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_count expected.log debug.log &&\n\n\t\tgit commit -m \"test commit 2\" &&\n\t\trm -f test2.r \"testsubdir/test3 '\\''sq'\\'',\\$x=.r\" &&\n\n\t\tfilter_git checkout --quiet --no-progress . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tIN: smudge testsubdir/test3 '\\''sq'\\'',\\$x=.r $S3 [OK] -- OUT: $S3 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\tfilter_git checkout --quiet --no-progress empty-branch &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\tfilter_git checkout --quiet --no-progress master &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tIN: smudge test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tIN: smudge test4-empty.r 0 [OK] -- OUT: 0  [OK]\n\t\t\tIN: smudge testsubdir/test3 '\\''sq'\\'',\\$x=.r $S3 [OK] -- OUT: $S3 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test2.o\" test2.r &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test3 '\\''sq'\\'',\\$x=.o\" \"testsubdir/test3 '\\''sq'\\'',\\$x=.r\"\n\t)\n'\n\ntest_expect_success PERL 'required process filter takes precedence' '\n\ttest_config_global filter.protocol.clean false &&\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean\" &&\n\ttest_config_global filter.protocol.required true &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tS=$(file_size test.r) &&\n\n\t\t# Check that the process filter is invoked here\n\t\tfilter_git add . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_count expected.log debug.log\n\t)\n'\n\ntest_expect_success PERL 'required process filter should be used only for \"clean\" operation only' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean\" &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tS=$(file_size test.r) &&\n\n\t\tfilter_git add . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_count expected.log debug.log &&\n\n\t\trm test.r &&\n\n\t\tfilter_git checkout --quiet --no-progress . &&\n\t\t# If the filter would be used for \"smudge\", too, we would see\n\t\t# \"IN: smudge test.r 57 [OK] -- OUT: 57 . [OK]\" here\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log\n\t)\n'\n\ntest_expect_success PERL 'required process filter should process multiple packets' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\ttest_config_global filter.protocol.required true &&\n\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\t# Generate data requiring 1, 2, 3 packets\n\t\tS=65516 && # PKTLINE_DATA_MAXLEN -> Maximal size of a packet\n\t\tgenerate_random_characters $(($S    )) 1pkt_1__.file &&\n\t\tgenerate_random_characters $(($S  +1)) 2pkt_1+1.file &&\n\t\tgenerate_random_characters $(($S*2-1)) 2pkt_2-1.file &&\n\t\tgenerate_random_characters $(($S*2  )) 2pkt_2__.file &&\n\t\tgenerate_random_characters $(($S*2+1)) 3pkt_2+1.file &&\n\n\t\tfor FILE in \"$TEST_ROOT\"/*.file\n\t\tdo\n\t\t\tcp \"$FILE\" . &&\n\t\t\trot13.sh <\"$FILE\" >\"$FILE.rot13\"\n\t\tdone &&\n\n\t\techo \"*.file filter=protocol\" >.gitattributes &&\n\t\tfilter_git add *.file .gitattributes &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean 1pkt_1__.file $(($S    )) [OK] -- OUT: $(($S    )) . [OK]\n\t\t\tIN: clean 2pkt_1+1.file $(($S  +1)) [OK] -- OUT: $(($S  +1)) .. [OK]\n\t\t\tIN: clean 2pkt_2-1.file $(($S*2-1)) [OK] -- OUT: $(($S*2-1)) .. [OK]\n\t\t\tIN: clean 2pkt_2__.file $(($S*2  )) [OK] -- OUT: $(($S*2  )) .. [OK]\n\t\t\tIN: clean 3pkt_2+1.file $(($S*2+1)) [OK] -- OUT: $(($S*2+1)) ... [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_count expected.log debug.log &&\n\n\t\trm -f *.file &&\n\n\t\tfilter_git checkout --quiet --no-progress -- *.file &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge 1pkt_1__.file $(($S    )) [OK] -- OUT: $(($S    )) . [OK]\n\t\t\tIN: smudge 2pkt_1+1.file $(($S  +1)) [OK] -- OUT: $(($S  +1)) .. [OK]\n\t\t\tIN: smudge 2pkt_2-1.file $(($S*2-1)) [OK] -- OUT: $(($S*2-1)) .. [OK]\n\t\t\tIN: smudge 2pkt_2__.file $(($S*2  )) [OK] -- OUT: $(($S*2  )) .. [OK]\n\t\t\tIN: smudge 3pkt_2+1.file $(($S*2+1)) [OK] -- OUT: $(($S*2+1)) ... [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\tfor FILE in *.file\n\t\tdo\n\t\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/$FILE\" $FILE\n\t\tdone\n\t)\n'\n\ntest_expect_success PERL 'required process filter with clean error should fail' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\ttest_config_global filter.protocol.required true &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\techo \"this is going to fail\" >clean-write-fail.r &&\n\t\techo \"content-test3-subdir\" >test3.r &&\n\n\t\ttest_must_fail git add .\n\t)\n'\n\ntest_expect_success PERL 'process filter should restart after unexpected write failure' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tcp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\techo \"this is going to fail\" >smudge-write-fail.o &&\n\t\tcp smudge-write-fail.o smudge-write-fail.r &&\n\n\t\tS=$(file_size test.r) &&\n\t\tS2=$(file_size test2.r) &&\n\t\tSF=$(file_size smudge-write-fail.r) &&\n\n\t\tgit add . &&\n\t\trm -f *.r &&\n\n\t\trm -f debug.log &&\n\t\tgit checkout --quiet --no-progress . 2>git-stderr.log &&\n\n\t\tgrep \"smudge write error at\" git-stderr.log &&\n\t\tgrep \"error: external filter\" git-stderr.log &&\n\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge smudge-write-fail.r $SF [OK] -- [WRITE FAIL]\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tIN: smudge test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test2.o\" test2.r &&\n\n\t\t# Smudge failed\n\t\t! test_cmp smudge-write-fail.o smudge-write-fail.r &&\n\t\trot13.sh <smudge-write-fail.o >expected &&\n\t\tgit cat-file blob :smudge-write-fail.r >actual &&\n\t\ttest_cmp expected actual\n\t)\n'\n\ntest_expect_success PERL 'process filter should not be restarted if it signals an error' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tcp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\techo \"this will cause an error\" >error.o &&\n\t\tcp error.o error.r &&\n\n\t\tS=$(file_size test.r) &&\n\t\tS2=$(file_size test2.r) &&\n\t\tSE=$(file_size error.r) &&\n\n\t\tgit add . &&\n\t\trm -f *.r &&\n\n\t\tfilter_git checkout --quiet --no-progress . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge error.r $SE [OK] -- [ERROR]\n\t\t\tIN: smudge test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tIN: smudge test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test2.o\" test2.r &&\n\t\ttest_cmp error.o error.r\n\t)\n'\n\ntest_expect_success PERL 'process filter abort stops processing of all further files' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tcp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\techo \"error this blob and all future blobs\" >abort.o &&\n\t\tcp abort.o abort.r &&\n\n\t\tSA=$(file_size abort.r) &&\n\n\t\tgit add . &&\n\t\trm -f *.r &&\n\n\t\t# Note: This test assumes that Git filters files in alphabetical\n\t\t# order (\"abort.r\" before \"test.r\").\n\t\tfilter_git checkout --quiet --no-progress . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge abort.r $SA [OK] -- [ABORT]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\ttest_cmp \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_cmp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\ttest_cmp abort.o abort.r\n\t)\n'\n\ntest_expect_success PERL 'invalid process filter must fail (and not hang!)' '\n\ttest_config_global filter.protocol.process cat &&\n\ttest_config_global filter.protocol.required true &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_must_fail git add . 2>git-stderr.log &&\n\t\tgrep \"expected git-filter-server\" git-stderr.log\n\t)\n'\n\ntest_expect_success PERL 'delayed checkout in process filter' '\n\ttest_config_global filter.a.process \"rot13-filter.pl a.log clean smudge delay\" &&\n\ttest_config_global filter.a.required true &&\n\ttest_config_global filter.b.process \"rot13-filter.pl b.log clean smudge delay\" &&\n\ttest_config_global filter.b.required true &&\n\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\t\techo \"*.a filter=a\" >.gitattributes &&\n\t\techo \"*.b filter=b\" >>.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" test.a &&\n\t\tcp \"$TEST_ROOT/test.o\" test-delay10.a &&\n\t\tcp \"$TEST_ROOT/test.o\" test-delay11.a &&\n\t\tcp \"$TEST_ROOT/test.o\" test-delay20.a &&\n\t\tcp \"$TEST_ROOT/test.o\" test-delay10.b &&\n\t\tgit add . &&\n\t\tgit commit -m \"test commit\"\n\t) &&\n\n\tS=$(file_size \"$TEST_ROOT/test.o\") &&\n\tcat >a.exp <<-EOF &&\n\t\tSTART\n\t\tinit handshake complete\n\t\tIN: smudge test.a $S [OK] -- OUT: $S . [OK]\n\t\tIN: smudge test-delay10.a $S [OK] -- [DELAYED]\n\t\tIN: smudge test-delay11.a $S [OK] -- [DELAYED]\n\t\tIN: smudge test-delay20.a $S [OK] -- [DELAYED]\n\t\tIN: list_available_blobs test-delay10.a test-delay11.a [OK]\n\t\tIN: smudge test-delay10.a 0 [OK] -- OUT: $S . [OK]\n\t\tIN: smudge test-delay11.a 0 [OK] -- OUT: $S . [OK]\n\t\tIN: list_available_blobs test-delay20.a [OK]\n\t\tIN: smudge test-delay20.a 0 [OK] -- OUT: $S . [OK]\n\t\tIN: list_available_blobs [OK]\n\t\tSTOP\n\tEOF\n\tcat >b.exp <<-EOF &&\n\t\tSTART\n\t\tinit handshake complete\n\t\tIN: smudge test-delay10.b $S [OK] -- [DELAYED]\n\t\tIN: list_available_blobs test-delay10.b [OK]\n\t\tIN: smudge test-delay10.b 0 [OK] -- OUT: $S . [OK]\n\t\tIN: list_available_blobs [OK]\n\t\tSTOP\n\tEOF\n\n\trm -rf repo-cloned &&\n\tfilter_git clone repo repo-cloned &&\n\ttest_cmp_count a.exp repo-cloned/a.log &&\n\ttest_cmp_count b.exp repo-cloned/b.log &&\n\n\t(\n\t\tcd repo-cloned &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay10.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay11.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay20.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay10.b &&\n\n\t\trm *.a *.b &&\n\t\tfilter_git checkout . &&\n\t\ttest_cmp_count ../a.exp a.log &&\n\t\ttest_cmp_count ../b.exp b.log &&\n\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay10.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay11.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay20.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay10.b\n\t)\n'\n\ntest_expect_success PERL 'missing file in delayed checkout' '\n\ttest_config_global filter.bug.process \"rot13-filter.pl bug.log clean smudge delay\" &&\n\ttest_config_global filter.bug.required true &&\n\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\t\techo \"*.a filter=bug\" >.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" missing-delay.a\n\t\tgit add . &&\n\t\tgit commit -m \"test commit\"\n\t) &&\n\n\trm -rf repo-cloned &&\n\ttest_must_fail git clone repo repo-cloned 2>git-stderr.log &&\n\tcat git-stderr.log &&\n\tgrep \"error: .missing-delay\\.a. was not filtered properly\" git-stderr.log\n'\n\ntest_expect_success PERL 'invalid file in delayed checkout' '\n\ttest_config_global filter.bug.process \"rot13-filter.pl bug.log clean smudge delay\" &&\n\ttest_config_global filter.bug.required true &&\n\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\t\techo \"*.a filter=bug\" >.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" invalid-delay.a &&\n\t\tcp \"$TEST_ROOT/test.o\" unfiltered\n\t\tgit add . &&\n\t\tgit commit -m \"test commit\"\n\t) &&\n\n\trm -rf repo-cloned &&\n\ttest_must_fail git clone repo repo-cloned 2>git-stderr.log &&\n\tgrep \"error: external filter .* signaled that .unfiltered. is now available although it has not been delayed earlier\" git-stderr.log\n'\n\ntest_done\n", "#\n# Example implementation for the Git filter protocol version 2\n# See Documentation/gitattributes.txt, section \"Filter Protocol\"\n#\n# The first argument defines a debug log file that the script write to.\n# All remaining arguments define a list of supported protocol\n# capabilities (\"clean\", \"smudge\", etc).\n#\n# This implementation supports special test cases:\n# (1) If data with the pathname \"clean-write-fail.r\" is processed with\n#     a \"clean\" operation then the write operation will die.\n# (2) If data with the pathname \"smudge-write-fail.r\" is processed with\n#     a \"smudge\" operation then the write operation will die.\n# (3) If data with the pathname \"error.r\" is processed with any\n#     operation then the filter signals that it cannot or does not want\n#     to process the file.\n# (4) If data with the pathname \"abort.r\" is processed with any\n#     operation then the filter signals that it cannot or does not want\n#     to process the file and any file after that is processed with the\n#     same command.\n# (5) If data with a pathname that is a key in the DELAY hash is\n#     requested (e.g. \"test-delay10.a\") then the filter responds with\n#     a \"delay\" status and sets the \"requested\" field in the DELAY hash.\n#     The filter will signal the availability of this object after\n#     \"count\" (field in DELAY hash) \"list_available_blobs\" commands.\n# (6) If data with the pathname \"missing-delay.a\" is processed that the\n#     filter will drop the path from the \"list_available_blobs\" response.\n# (7) If data with the pathname \"invalid-delay.a\" is processed that the\n#     filter will add the path \"unfiltered\" which was not delayed before\n#     to the \"list_available_blobs\" response.\n#\n\nuse 5.008;\nsub gitperllib {\n\t# Git assumes that all path lists are Unix-y colon-separated ones. But\n\t# when the Git for Windows executes the test suite, its MSYS2 Bash\n\t# calls git.exe, and colon-separated path lists are converted into\n\t# Windows-y semicolon-separated lists of *Windows* paths (which\n\t# naturally contain a colon after the drive letter, so splitting by\n\t# colons simply does not cut it).\n\t#\n\t# Detect semicolon-separated path list and handle them appropriately.\n\n\tif ($ENV{GITPERLLIB} =~ /;/) {\n\t\treturn split(/;/, $ENV{GITPERLLIB});\n\t}\n\treturn split(/:/, $ENV{GITPERLLIB});\n}\nuse lib (gitperllib());\nuse strict;\nuse warnings;\nuse IO::File;\nuse Git::Packet;\n\nmy $MAX_PACKET_CONTENT_SIZE = 65516;\nmy $log_file                = shift @ARGV;\nmy @capabilities            = @ARGV;\n\nopen my $debug, \">>\", $log_file or die \"cannot open log file: $!\";\n\nmy %DELAY = (\n\t'test-delay10.a' => { \"requested\" => 0, \"count\" => 1 },\n\t'test-delay11.a' => { \"requested\" => 0, \"count\" => 1 },\n\t'test-delay20.a' => { \"requested\" => 0, \"count\" => 2 },\n\t'test-delay10.b' => { \"requested\" => 0, \"count\" => 1 },\n\t'missing-delay.a' => { \"requested\" => 0, \"count\" => 1 },\n\t'invalid-delay.a' => { \"requested\" => 0, \"count\" => 1 },\n);\n\nsub rot13 {\n\tmy $str = shift;\n\t$str =~ y/A-Za-z/N-ZA-Mn-za-m/;\n\treturn $str;\n}\n\nprint $debug \"START\\n\";\n$debug->flush();\n\npacket_initialize(\"git-filter\", 2);\n\nmy %remote_caps = packet_read_and_check_capabilities(\"clean\", \"smudge\", \"delay\");\npacket_check_and_write_capabilities(\\%remote_caps, @capabilities);\n\nprint $debug \"init handshake complete\\n\";\n$debug->flush();\n\nwhile (1) {\n\tmy ( $res, $command ) = packet_key_val_read(\"command\");\n\tif ( $res == -1 ) {\n\t\tprint $debug \"STOP\\n\";\n\t\texit();\n\t}\n\tprint $debug \"IN: $command\";\n\t$debug->flush();\n\n\tif ( $command eq \"list_available_blobs\" ) {\n\t\t# Flush\n\t\tpacket_compare_lists([1, \"\"], packet_bin_read()) ||\n\t\t\tdie \"bad list_available_blobs end\";\n\n\t\tforeach my $pathname ( sort keys %DELAY ) {\n\t\t\tif ( $DELAY{$pathname}{\"requested\"} >= 1 ) {\n\t\t\t\t$DELAY{$pathname}{\"count\"} = $DELAY{$pathname}{\"count\"} - 1;\n\t\t\t\tif ( $pathname eq \"invalid-delay.a\" ) {\n\t\t\t\t\t# Send Git a pathname that was not delayed earlier\n\t\t\t\t\tpacket_txt_write(\"pathname=unfiltered\");\n\t\t\t\t}\n\t\t\t\tif ( $pathname eq \"missing-delay.a\" ) {\n\t\t\t\t\t# Do not signal Git that this file is available\n\t\t\t\t} elsif ( $DELAY{$pathname}{\"count\"} == 0 ) {\n\t\t\t\t\tprint $debug \" $pathname\";\n\t\t\t\t\tpacket_txt_write(\"pathname=$pathname\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpacket_flush();\n\n\t\tprint $debug \" [OK]\\n\";\n\t\t$debug->flush();\n\t\tpacket_txt_write(\"status=success\");\n\t\tpacket_flush();\n\t} else {\n\t\tmy ( $res, $pathname ) = packet_key_val_read(\"pathname\");\n\t\tif ( $res == -1 ) {\n\t\t\tdie \"unexpected EOF while expecting pathname\";\n\t\t}\n\t\tprint $debug \" $pathname\";\n\t\t$debug->flush();\n\n\t\t# Read until flush\n\t\tmy ( $done, $buffer ) = packet_txt_read();\n\t\twhile ( $buffer ne '' ) {\n\t\t\tif ( $buffer eq \"can-delay=1\" ) {\n\t\t\t\tif ( exists $DELAY{$pathname} and $DELAY{$pathname}{\"requested\"} == 0 ) {\n\t\t\t\t\t$DELAY{$pathname}{\"requested\"} = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdie \"Unknown message '$buffer'\";\n\t\t\t}\n\n\t\t\t( $done, $buffer ) = packet_txt_read();\n\t\t}\n\t\tif ( $done == -1 ) {\n\t\t\tdie \"unexpected EOF after pathname '$pathname'\";\n\t\t}\n\n\t\tmy $input = \"\";\n\t\t{\n\t\t\tbinmode(STDIN);\n\t\t\tmy $buffer;\n\t\t\tmy $done = 0;\n\t\t\twhile ( !$done ) {\n\t\t\t\t( $done, $buffer ) = packet_bin_read();\n\t\t\t\t$input .= $buffer;\n\t\t\t}\n\t\t\tif ( $done == -1 ) {\n\t\t\t\tdie \"unexpected EOF while reading input for '$pathname'\";\n\t\t\t}\t\t\t\n\t\t\tprint $debug \" \" . length($input) . \" [OK] -- \";\n\t\t\t$debug->flush();\n\t\t}\n\n\t\tmy $output;\n\t\tif ( exists $DELAY{$pathname} and exists $DELAY{$pathname}{\"output\"} ) {\n\t\t\t$output = $DELAY{$pathname}{\"output\"}\n\t\t} elsif ( $pathname eq \"error.r\" or $pathname eq \"abort.r\" ) {\n\t\t\t$output = \"\";\n\t\t} elsif ( $command eq \"clean\" and grep( /^clean$/, @capabilities ) ) {\n\t\t\t$output = rot13($input);\n\t\t} elsif ( $command eq \"smudge\" and grep( /^smudge$/, @capabilities ) ) {\n\t\t\t$output = rot13($input);\n\t\t} else {\n\t\t\tdie \"bad command '$command'\";\n\t\t}\n\n\t\tif ( $pathname eq \"error.r\" ) {\n\t\t\tprint $debug \"[ERROR]\\n\";\n\t\t\t$debug->flush();\n\t\t\tpacket_txt_write(\"status=error\");\n\t\t\tpacket_flush();\n\t\t} elsif ( $pathname eq \"abort.r\" ) {\n\t\t\tprint $debug \"[ABORT]\\n\";\n\t\t\t$debug->flush();\n\t\t\tpacket_txt_write(\"status=abort\");\n\t\t\tpacket_flush();\n\t\t} elsif ( $command eq \"smudge\" and\n\t\t\texists $DELAY{$pathname} and\n\t\t\t$DELAY{$pathname}{\"requested\"} == 1 ) {\n\t\t\tprint $debug \"[DELAYED]\\n\";\n\t\t\t$debug->flush();\n\t\t\tpacket_txt_write(\"status=delayed\");\n\t\t\tpacket_flush();\n\t\t\t$DELAY{$pathname}{\"requested\"} = 2;\n\t\t\t$DELAY{$pathname}{\"output\"} = $output;\n\t\t} else {\n\t\t\tpacket_txt_write(\"status=success\");\n\t\t\tpacket_flush();\n\n\t\t\tif ( $pathname eq \"${command}-write-fail.r\" ) {\n\t\t\t\tprint $debug \"[WRITE FAIL]\\n\";\n\t\t\t\t$debug->flush();\n\t\t\t\tdie \"${command} write error\";\n\t\t\t}\n\n\t\t\tprint $debug \"OUT: \" . length($output) . \" \";\n\t\t\t$debug->flush();\n\n\t\t\twhile ( length($output) > 0 ) {\n\t\t\t\tmy $packet = substr( $output, 0, $MAX_PACKET_CONTENT_SIZE );\n\t\t\t\tpacket_bin_write($packet);\n\t\t\t\t# dots represent the number of packets\n\t\t\t\tprint $debug \".\";\n\t\t\t\tif ( length($output) > $MAX_PACKET_CONTENT_SIZE ) {\n\t\t\t\t\t$output = substr( $output, $MAX_PACKET_CONTENT_SIZE );\n\t\t\t\t} else {\n\t\t\t\t\t$output = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tpacket_flush();\n\t\t\tprint $debug \" [OK]\\n\";\n\t\t\t$debug->flush();\n\t\t\tpacket_flush();\n\t\t}\n\t}\n}\n", "#!/bin/sh\n\ntest_description='basic checkout-index tests\n'\n\n. ./test-lib.sh\n\ntest_expect_success 'checkout-index --gobbledegook' '\n\ttest_expect_code 129 git checkout-index --gobbledegook 2>err &&\n\ttest_i18ngrep \"[Uu]sage\" err\n'\n\ntest_expect_success 'checkout-index -h in broken repository' '\n\tmkdir broken &&\n\t(\n\t\tcd broken &&\n\t\tgit init &&\n\t\t>.git/index &&\n\t\ttest_expect_code 129 git checkout-index -h >usage 2>&1\n\t) &&\n\ttest_i18ngrep \"[Uu]sage\" broken/usage\n'\n\ntest_done\n"], "fixing_code": ["#ifndef CACHE_H\n#define CACHE_H\n\n#include \"git-compat-util.h\"\n#include \"strbuf.h\"\n#include \"hashmap.h\"\n#include \"list.h\"\n#include \"advice.h\"\n#include \"gettext.h\"\n#include \"convert.h\"\n#include \"trace.h\"\n#include \"string-list.h\"\n#include \"pack-revindex.h\"\n#include \"hash.h\"\n#include \"path.h\"\n#include \"sha1-array.h\"\n#include \"repository.h\"\n\n#include <zlib.h>\ntypedef struct git_zstream {\n\tz_stream z;\n\tunsigned long avail_in;\n\tunsigned long avail_out;\n\tunsigned long total_in;\n\tunsigned long total_out;\n\tunsigned char *next_in;\n\tunsigned char *next_out;\n} git_zstream;\n\nvoid git_inflate_init(git_zstream *);\nvoid git_inflate_init_gzip_only(git_zstream *);\nvoid git_inflate_end(git_zstream *);\nint git_inflate(git_zstream *, int flush);\n\nvoid git_deflate_init(git_zstream *, int level);\nvoid git_deflate_init_gzip(git_zstream *, int level);\nvoid git_deflate_init_raw(git_zstream *, int level);\nvoid git_deflate_end(git_zstream *);\nint git_deflate_abort(git_zstream *);\nint git_deflate_end_gently(git_zstream *);\nint git_deflate(git_zstream *, int flush);\nunsigned long git_deflate_bound(git_zstream *, unsigned long);\n\n/* The length in bytes and in hex digits of an object name (SHA-1 value). */\n#define GIT_SHA1_RAWSZ 20\n#define GIT_SHA1_HEXSZ (2 * GIT_SHA1_RAWSZ)\n\n/* The length in byte and in hex digits of the largest possible hash value. */\n#define GIT_MAX_RAWSZ GIT_SHA1_RAWSZ\n#define GIT_MAX_HEXSZ GIT_SHA1_HEXSZ\n\nstruct object_id {\n\tunsigned char hash[GIT_MAX_RAWSZ];\n};\n\n#define the_hash_algo the_repository->hash_algo\n\n#if defined(DT_UNKNOWN) && !defined(NO_D_TYPE_IN_DIRENT)\n#define DTYPE(de)\t((de)->d_type)\n#else\n#undef DT_UNKNOWN\n#undef DT_DIR\n#undef DT_REG\n#undef DT_LNK\n#define DT_UNKNOWN\t0\n#define DT_DIR\t\t1\n#define DT_REG\t\t2\n#define DT_LNK\t\t3\n#define DTYPE(de)\tDT_UNKNOWN\n#endif\n\n/* unknown mode (impossible combination S_IFIFO|S_IFCHR) */\n#define S_IFINVALID     0030000\n\n/*\n * A \"directory link\" is a link to another git directory.\n *\n * The value 0160000 is not normally a valid mode, and\n * also just happens to be S_IFDIR + S_IFLNK\n */\n#define S_IFGITLINK\t0160000\n#define S_ISGITLINK(m)\t(((m) & S_IFMT) == S_IFGITLINK)\n\n/*\n * Some mode bits are also used internally for computations.\n *\n * They *must* not overlap with any valid modes, and they *must* not be emitted\n * to outside world - i.e. appear on disk or network. In other words, it's just\n * temporary fields, which we internally use, but they have to stay in-house.\n *\n * ( such approach is valid, as standard S_IF* fits into 16 bits, and in Git\n *   codebase mode is `unsigned int` which is assumed to be at least 32 bits )\n */\n\n/* used internally in tree-diff */\n#define S_DIFFTREE_IFXMIN_NEQ\t0x80000000\n\n\n/*\n * Intensive research over the course of many years has shown that\n * port 9418 is totally unused by anything else. Or\n *\n *\tYour search - \"port 9418\" - did not match any documents.\n *\n * as www.google.com puts it.\n *\n * This port has been properly assigned for git use by IANA:\n * git (Assigned-9418) [I06-050728-0001].\n *\n *\tgit  9418/tcp   git pack transfer service\n *\tgit  9418/udp   git pack transfer service\n *\n * with Linus Torvalds <torvalds@osdl.org> as the point of\n * contact. September 2005.\n *\n * See http://www.iana.org/assignments/port-numbers\n */\n#define DEFAULT_GIT_PORT 9418\n\n/*\n * Basic data structures for the directory cache\n */\n\n#define CACHE_SIGNATURE 0x44495243\t/* \"DIRC\" */\nstruct cache_header {\n\tuint32_t hdr_signature;\n\tuint32_t hdr_version;\n\tuint32_t hdr_entries;\n};\n\n#define INDEX_FORMAT_LB 2\n#define INDEX_FORMAT_UB 4\n\n/*\n * The \"cache_time\" is just the low 32 bits of the\n * time. It doesn't matter if it overflows - we only\n * check it for equality in the 32 bits we save.\n */\nstruct cache_time {\n\tuint32_t sec;\n\tuint32_t nsec;\n};\n\nstruct stat_data {\n\tstruct cache_time sd_ctime;\n\tstruct cache_time sd_mtime;\n\tunsigned int sd_dev;\n\tunsigned int sd_ino;\n\tunsigned int sd_uid;\n\tunsigned int sd_gid;\n\tunsigned int sd_size;\n};\n\nstruct cache_entry {\n\tstruct hashmap_entry ent;\n\tstruct stat_data ce_stat_data;\n\tunsigned int ce_mode;\n\tunsigned int ce_flags;\n\tunsigned int ce_namelen;\n\tunsigned int index;\t/* for link extension */\n\tstruct object_id oid;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n#define CE_STAGEMASK (0x3000)\n#define CE_EXTENDED  (0x4000)\n#define CE_VALID     (0x8000)\n#define CE_STAGESHIFT 12\n\n/*\n * Range 0xFFFF0FFF in ce_flags is divided into\n * two parts: in-memory flags and on-disk ones.\n * Flags in CE_EXTENDED_FLAGS will get saved on-disk\n * if you want to save a new flag, add it in\n * CE_EXTENDED_FLAGS\n *\n * In-memory only flags\n */\n#define CE_UPDATE            (1 << 16)\n#define CE_REMOVE            (1 << 17)\n#define CE_UPTODATE          (1 << 18)\n#define CE_ADDED             (1 << 19)\n\n#define CE_HASHED            (1 << 20)\n#define CE_FSMONITOR_VALID   (1 << 21)\n#define CE_WT_REMOVE         (1 << 22) /* remove in work directory */\n#define CE_CONFLICTED        (1 << 23)\n\n#define CE_UNPACKED          (1 << 24)\n#define CE_NEW_SKIP_WORKTREE (1 << 25)\n\n/* used to temporarily mark paths matched by pathspecs */\n#define CE_MATCHED           (1 << 26)\n\n#define CE_UPDATE_IN_BASE    (1 << 27)\n#define CE_STRIP_NAME        (1 << 28)\n\n/*\n * Extended on-disk flags\n */\n#define CE_INTENT_TO_ADD     (1 << 29)\n#define CE_SKIP_WORKTREE     (1 << 30)\n/* CE_EXTENDED2 is for future extension */\n#define CE_EXTENDED2         (1U << 31)\n\n#define CE_EXTENDED_FLAGS (CE_INTENT_TO_ADD | CE_SKIP_WORKTREE)\n\n/*\n * Safeguard to avoid saving wrong flags:\n *  - CE_EXTENDED2 won't get saved until its semantic is known\n *  - Bits in 0x0000FFFF have been saved in ce_flags already\n *  - Bits in 0x003F0000 are currently in-memory flags\n */\n#if CE_EXTENDED_FLAGS & 0x803FFFFF\n#error \"CE_EXTENDED_FLAGS out of range\"\n#endif\n\n/* Forward structure decls */\nstruct pathspec;\nstruct child_process;\n\n/*\n * Copy the sha1 and stat state of a cache entry from one to\n * another. But we never change the name, or the hash state!\n */\nstatic inline void copy_cache_entry(struct cache_entry *dst,\n\t\t\t\t    const struct cache_entry *src)\n{\n\tunsigned int state = dst->ce_flags & CE_HASHED;\n\n\t/* Don't copy hash chain and name */\n\tmemcpy(&dst->ce_stat_data, &src->ce_stat_data,\n\t\t\toffsetof(struct cache_entry, name) -\n\t\t\toffsetof(struct cache_entry, ce_stat_data));\n\n\t/* Restore the hash state */\n\tdst->ce_flags = (dst->ce_flags & ~CE_HASHED) | state;\n}\n\nstatic inline unsigned create_ce_flags(unsigned stage)\n{\n\treturn (stage << CE_STAGESHIFT);\n}\n\n#define ce_namelen(ce) ((ce)->ce_namelen)\n#define ce_size(ce) cache_entry_size(ce_namelen(ce))\n#define ce_stage(ce) ((CE_STAGEMASK & (ce)->ce_flags) >> CE_STAGESHIFT)\n#define ce_uptodate(ce) ((ce)->ce_flags & CE_UPTODATE)\n#define ce_skip_worktree(ce) ((ce)->ce_flags & CE_SKIP_WORKTREE)\n#define ce_mark_uptodate(ce) ((ce)->ce_flags |= CE_UPTODATE)\n#define ce_intent_to_add(ce) ((ce)->ce_flags & CE_INTENT_TO_ADD)\n\n#define ce_permissions(mode) (((mode) & 0100) ? 0755 : 0644)\nstatic inline unsigned int create_ce_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode) || S_ISGITLINK(mode))\n\t\treturn S_IFGITLINK;\n\treturn S_IFREG | ce_permissions(mode);\n}\nstatic inline unsigned int ce_mode_from_stat(const struct cache_entry *ce,\n\t\t\t\t\t     unsigned int mode)\n{\n\textern int trust_executable_bit, has_symlinks;\n\tif (!has_symlinks && S_ISREG(mode) &&\n\t    ce && S_ISLNK(ce->ce_mode))\n\t\treturn ce->ce_mode;\n\tif (!trust_executable_bit && S_ISREG(mode)) {\n\t\tif (ce && S_ISREG(ce->ce_mode))\n\t\t\treturn ce->ce_mode;\n\t\treturn create_ce_mode(0666);\n\t}\n\treturn create_ce_mode(mode);\n}\nstatic inline int ce_to_dtype(const struct cache_entry *ce)\n{\n\tunsigned ce_mode = ntohl(ce->ce_mode);\n\tif (S_ISREG(ce_mode))\n\t\treturn DT_REG;\n\telse if (S_ISDIR(ce_mode) || S_ISGITLINK(ce_mode))\n\t\treturn DT_DIR;\n\telse if (S_ISLNK(ce_mode))\n\t\treturn DT_LNK;\n\telse\n\t\treturn DT_UNKNOWN;\n}\nstatic inline unsigned int canon_mode(unsigned int mode)\n{\n\tif (S_ISREG(mode))\n\t\treturn S_IFREG | ce_permissions(mode);\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode))\n\t\treturn S_IFDIR;\n\treturn S_IFGITLINK;\n}\n\n#define cache_entry_size(len) (offsetof(struct cache_entry,name) + (len) + 1)\n\n#define SOMETHING_CHANGED\t(1 << 0) /* unclassified changes go here */\n#define CE_ENTRY_CHANGED\t(1 << 1)\n#define CE_ENTRY_REMOVED\t(1 << 2)\n#define CE_ENTRY_ADDED\t\t(1 << 3)\n#define RESOLVE_UNDO_CHANGED\t(1 << 4)\n#define CACHE_TREE_CHANGED\t(1 << 5)\n#define SPLIT_INDEX_ORDERED\t(1 << 6)\n#define UNTRACKED_CHANGED\t(1 << 7)\n#define FSMONITOR_CHANGED\t(1 << 8)\n\nstruct split_index;\nstruct untracked_cache;\n\nstruct index_state {\n\tstruct cache_entry **cache;\n\tunsigned int version;\n\tunsigned int cache_nr, cache_alloc, cache_changed;\n\tstruct string_list *resolve_undo;\n\tstruct cache_tree *cache_tree;\n\tstruct split_index *split_index;\n\tstruct cache_time timestamp;\n\tunsigned name_hash_initialized : 1,\n\t\t initialized : 1,\n\t\t drop_cache_tree : 1;\n\tstruct hashmap name_hash;\n\tstruct hashmap dir_hash;\n\tunsigned char sha1[20];\n\tstruct untracked_cache *untracked;\n\tuint64_t fsmonitor_last_update;\n\tstruct ewah_bitmap *fsmonitor_dirty;\n};\n\nextern struct index_state the_index;\n\n/* Name hashing */\nextern int test_lazy_init_name_hash(struct index_state *istate, int try_threaded);\nextern void add_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void remove_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void free_name_hash(struct index_state *istate);\n\n\n#ifndef NO_THE_INDEX_COMPATIBILITY_MACROS\n#define active_cache (the_index.cache)\n#define active_nr (the_index.cache_nr)\n#define active_alloc (the_index.cache_alloc)\n#define active_cache_changed (the_index.cache_changed)\n#define active_cache_tree (the_index.cache_tree)\n\n#define read_cache() read_index(&the_index)\n#define read_cache_from(path) read_index_from(&the_index, (path), (get_git_dir()))\n#define read_cache_preload(pathspec) read_index_preload(&the_index, (pathspec))\n#define is_cache_unborn() is_index_unborn(&the_index)\n#define read_cache_unmerged() read_index_unmerged(&the_index)\n#define discard_cache() discard_index(&the_index)\n#define unmerged_cache() unmerged_index(&the_index)\n#define cache_name_pos(name, namelen) index_name_pos(&the_index,(name),(namelen))\n#define add_cache_entry(ce, option) add_index_entry(&the_index, (ce), (option))\n#define rename_cache_entry_at(pos, new_name) rename_index_entry_at(&the_index, (pos), (new_name))\n#define remove_cache_entry_at(pos) remove_index_entry_at(&the_index, (pos))\n#define remove_file_from_cache(path) remove_file_from_index(&the_index, (path))\n#define add_to_cache(path, st, flags) add_to_index(&the_index, (path), (st), (flags))\n#define add_file_to_cache(path, flags) add_file_to_index(&the_index, (path), (flags))\n#define chmod_cache_entry(ce, flip) chmod_index_entry(&the_index, (ce), (flip))\n#define refresh_cache(flags) refresh_index(&the_index, (flags), NULL, NULL, NULL)\n#define ce_match_stat(ce, st, options) ie_match_stat(&the_index, (ce), (st), (options))\n#define ce_modified(ce, st, options) ie_modified(&the_index, (ce), (st), (options))\n#define cache_dir_exists(name, namelen) index_dir_exists(&the_index, (name), (namelen))\n#define cache_file_exists(name, namelen, igncase) index_file_exists(&the_index, (name), (namelen), (igncase))\n#define cache_name_is_other(name, namelen) index_name_is_other(&the_index, (name), (namelen))\n#define resolve_undo_clear() resolve_undo_clear_index(&the_index)\n#define unmerge_cache_entry_at(at) unmerge_index_entry_at(&the_index, at)\n#define unmerge_cache(pathspec) unmerge_index(&the_index, pathspec)\n#define read_blob_data_from_cache(path, sz) read_blob_data_from_index(&the_index, (path), (sz))\n#endif\n\nenum object_type {\n\tOBJ_BAD = -1,\n\tOBJ_NONE = 0,\n\tOBJ_COMMIT = 1,\n\tOBJ_TREE = 2,\n\tOBJ_BLOB = 3,\n\tOBJ_TAG = 4,\n\t/* 5 for future expansion */\n\tOBJ_OFS_DELTA = 6,\n\tOBJ_REF_DELTA = 7,\n\tOBJ_ANY,\n\tOBJ_MAX\n};\n\nstatic inline enum object_type object_type(unsigned int mode)\n{\n\treturn S_ISDIR(mode) ? OBJ_TREE :\n\t\tS_ISGITLINK(mode) ? OBJ_COMMIT :\n\t\tOBJ_BLOB;\n}\n\n/* Double-check local_repo_env below if you add to this list. */\n#define GIT_DIR_ENVIRONMENT \"GIT_DIR\"\n#define GIT_COMMON_DIR_ENVIRONMENT \"GIT_COMMON_DIR\"\n#define GIT_NAMESPACE_ENVIRONMENT \"GIT_NAMESPACE\"\n#define GIT_WORK_TREE_ENVIRONMENT \"GIT_WORK_TREE\"\n#define GIT_PREFIX_ENVIRONMENT \"GIT_PREFIX\"\n#define GIT_SUPER_PREFIX_ENVIRONMENT \"GIT_INTERNAL_SUPER_PREFIX\"\n#define DEFAULT_GIT_DIR_ENVIRONMENT \".git\"\n#define DB_ENVIRONMENT \"GIT_OBJECT_DIRECTORY\"\n#define INDEX_ENVIRONMENT \"GIT_INDEX_FILE\"\n#define GRAFT_ENVIRONMENT \"GIT_GRAFT_FILE\"\n#define GIT_SHALLOW_FILE_ENVIRONMENT \"GIT_SHALLOW_FILE\"\n#define TEMPLATE_DIR_ENVIRONMENT \"GIT_TEMPLATE_DIR\"\n#define CONFIG_ENVIRONMENT \"GIT_CONFIG\"\n#define CONFIG_DATA_ENVIRONMENT \"GIT_CONFIG_PARAMETERS\"\n#define EXEC_PATH_ENVIRONMENT \"GIT_EXEC_PATH\"\n#define CEILING_DIRECTORIES_ENVIRONMENT \"GIT_CEILING_DIRECTORIES\"\n#define NO_REPLACE_OBJECTS_ENVIRONMENT \"GIT_NO_REPLACE_OBJECTS\"\n#define GIT_REPLACE_REF_BASE_ENVIRONMENT \"GIT_REPLACE_REF_BASE\"\n#define GITATTRIBUTES_FILE \".gitattributes\"\n#define INFOATTRIBUTES_FILE \"info/attributes\"\n#define ATTRIBUTE_MACRO_PREFIX \"[attr]\"\n#define GITMODULES_FILE \".gitmodules\"\n#define GIT_NOTES_REF_ENVIRONMENT \"GIT_NOTES_REF\"\n#define GIT_NOTES_DEFAULT_REF \"refs/notes/commits\"\n#define GIT_NOTES_DISPLAY_REF_ENVIRONMENT \"GIT_NOTES_DISPLAY_REF\"\n#define GIT_NOTES_REWRITE_REF_ENVIRONMENT \"GIT_NOTES_REWRITE_REF\"\n#define GIT_NOTES_REWRITE_MODE_ENVIRONMENT \"GIT_NOTES_REWRITE_MODE\"\n#define GIT_LITERAL_PATHSPECS_ENVIRONMENT \"GIT_LITERAL_PATHSPECS\"\n#define GIT_GLOB_PATHSPECS_ENVIRONMENT \"GIT_GLOB_PATHSPECS\"\n#define GIT_NOGLOB_PATHSPECS_ENVIRONMENT \"GIT_NOGLOB_PATHSPECS\"\n#define GIT_ICASE_PATHSPECS_ENVIRONMENT \"GIT_ICASE_PATHSPECS\"\n#define GIT_QUARANTINE_ENVIRONMENT \"GIT_QUARANTINE_PATH\"\n#define GIT_OPTIONAL_LOCKS_ENVIRONMENT \"GIT_OPTIONAL_LOCKS\"\n\n/*\n * Environment variable used in handshaking the wire protocol.\n * Contains a colon ':' separated list of keys with optional values\n * 'key[=value]'.  Presence of unknown keys and values must be\n * ignored.\n */\n#define GIT_PROTOCOL_ENVIRONMENT \"GIT_PROTOCOL\"\n/* HTTP header used to handshake the wire protocol */\n#define GIT_PROTOCOL_HEADER \"Git-Protocol\"\n\n/*\n * This environment variable is expected to contain a boolean indicating\n * whether we should or should not treat:\n *\n *   GIT_DIR=foo.git git ...\n *\n * as if GIT_WORK_TREE=. was given. It's not expected that users will make use\n * of this, but we use it internally to communicate to sub-processes that we\n * are in a bare repo. If not set, defaults to true.\n */\n#define GIT_IMPLICIT_WORK_TREE_ENVIRONMENT \"GIT_IMPLICIT_WORK_TREE\"\n\n/*\n * Repository-local GIT_* environment variables; these will be cleared\n * when git spawns a sub-process that runs inside another repository.\n * The array is NULL-terminated, which makes it easy to pass in the \"env\"\n * parameter of a run-command invocation, or to do a simple walk.\n */\nextern const char * const local_repo_env[];\n\nextern void setup_git_env(void);\n\n/*\n * Returns true iff we have a configured git repository (either via\n * setup_git_directory, or in the environment via $GIT_DIR).\n */\nint have_git_dir(void);\n\nextern int is_bare_repository_cfg;\nextern int is_bare_repository(void);\nextern int is_inside_git_dir(void);\nextern char *git_work_tree_cfg;\nextern int is_inside_work_tree(void);\nextern const char *get_git_dir(void);\nextern const char *get_git_common_dir(void);\nextern char *get_object_directory(void);\nextern char *get_index_file(void);\nextern char *get_graft_file(void);\nextern int set_git_dir(const char *path);\nextern int get_common_dir_noenv(struct strbuf *sb, const char *gitdir);\nextern int get_common_dir(struct strbuf *sb, const char *gitdir);\nextern const char *get_git_namespace(void);\nextern const char *strip_namespace(const char *namespaced_ref);\nextern const char *get_super_prefix(void);\nextern const char *get_git_work_tree(void);\n\n/*\n * Return true if the given path is a git directory; note that this _just_\n * looks at the directory itself. If you want to know whether \"foo/.git\"\n * is a repository, you must feed that path, not just \"foo\".\n */\nextern int is_git_directory(const char *path);\n\n/*\n * Return 1 if the given path is the root of a git repository or\n * submodule, else 0. Will not return 1 for bare repositories with the\n * exception of creating a bare repository in \"foo/.git\" and calling\n * is_git_repository(\"foo\").\n *\n * If we run into read errors, we err on the side of saying \"yes, it is\",\n * as we usually consider sub-repos precious, and would prefer to err on the\n * side of not disrupting or deleting them.\n */\nextern int is_nonbare_repository_dir(struct strbuf *path);\n\n#define READ_GITFILE_ERR_STAT_FAILED 1\n#define READ_GITFILE_ERR_NOT_A_FILE 2\n#define READ_GITFILE_ERR_OPEN_FAILED 3\n#define READ_GITFILE_ERR_READ_FAILED 4\n#define READ_GITFILE_ERR_INVALID_FORMAT 5\n#define READ_GITFILE_ERR_NO_PATH 6\n#define READ_GITFILE_ERR_NOT_A_REPO 7\n#define READ_GITFILE_ERR_TOO_LARGE 8\nextern void read_gitfile_error_die(int error_code, const char *path, const char *dir);\nextern const char *read_gitfile_gently(const char *path, int *return_error_code);\n#define read_gitfile(path) read_gitfile_gently((path), NULL)\nextern const char *resolve_gitdir_gently(const char *suspect, int *return_error_code);\n#define resolve_gitdir(path) resolve_gitdir_gently((path), NULL)\n\nextern void set_git_work_tree(const char *tree);\n\n#define ALTERNATE_DB_ENVIRONMENT \"GIT_ALTERNATE_OBJECT_DIRECTORIES\"\n\nextern void setup_work_tree(void);\n/*\n * Find the commondir and gitdir of the repository that contains the current\n * working directory, without changing the working directory or other global\n * state. The result is appended to commondir and gitdir.  If the discovered\n * gitdir does not correspond to a worktree, then 'commondir' and 'gitdir' will\n * both have the same result appended to the buffer.  The return value is\n * either 0 upon success and non-zero if no repository was found.\n */\nextern int discover_git_directory(struct strbuf *commondir,\n\t\t\t\t  struct strbuf *gitdir);\nextern const char *setup_git_directory_gently(int *);\nextern const char *setup_git_directory(void);\nextern char *prefix_path(const char *prefix, int len, const char *path);\nextern char *prefix_path_gently(const char *prefix, int len, int *remaining, const char *path);\n\n/*\n * Concatenate \"prefix\" (if len is non-zero) and \"path\", with no\n * connecting characters (so \"prefix\" should end with a \"/\").\n * Unlike prefix_path, this should be used if the named file does\n * not have to interact with index entry; i.e. name of a random file\n * on the filesystem.\n *\n * The return value is always a newly allocated string (even if the\n * prefix was empty).\n */\nextern char *prefix_filename(const char *prefix, const char *path);\n\nextern int check_filename(const char *prefix, const char *name);\nextern void verify_filename(const char *prefix,\n\t\t\t    const char *name,\n\t\t\t    int diagnose_misspelt_rev);\nextern void verify_non_filename(const char *prefix, const char *name);\nextern int path_inside_repo(const char *prefix, const char *path);\n\n#define INIT_DB_QUIET 0x0001\n#define INIT_DB_EXIST_OK 0x0002\n\nextern int init_db(const char *git_dir, const char *real_git_dir,\n\t\t   const char *template_dir, unsigned int flags);\n\nextern void sanitize_stdfds(void);\nextern int daemonize(void);\n\n#define alloc_nr(x) (((x)+16)*3/2)\n\n/*\n * Realloc the buffer pointed at by variable 'x' so that it can hold\n * at least 'nr' entries; the number of entries currently allocated\n * is 'alloc', using the standard growing factor alloc_nr() macro.\n *\n * DO NOT USE any expression with side-effect for 'x', 'nr', or 'alloc'.\n */\n#define ALLOC_GROW(x, nr, alloc) \\\n\tdo { \\\n\t\tif ((nr) > alloc) { \\\n\t\t\tif (alloc_nr(alloc) < (nr)) \\\n\t\t\t\talloc = (nr); \\\n\t\t\telse \\\n\t\t\t\talloc = alloc_nr(alloc); \\\n\t\t\tREALLOC_ARRAY(x, alloc); \\\n\t\t} \\\n\t} while (0)\n\n/* Initialize and use the cache information */\nstruct lock_file;\nextern int read_index(struct index_state *);\nextern int read_index_preload(struct index_state *, const struct pathspec *pathspec);\nextern int do_read_index(struct index_state *istate, const char *path,\n\t\t\t int must_exist); /* for testting only! */\nextern int read_index_from(struct index_state *, const char *path,\n\t\t\t   const char *gitdir);\nextern int is_index_unborn(struct index_state *);\nextern int read_index_unmerged(struct index_state *);\n\n/* For use with `write_locked_index()`. */\n#define COMMIT_LOCK\t\t(1 << 0)\n#define SKIP_IF_UNCHANGED\t(1 << 1)\n\n/*\n * Write the index while holding an already-taken lock. Close the lock,\n * and if `COMMIT_LOCK` is given, commit it.\n *\n * Unless a split index is in use, write the index into the lockfile.\n *\n * With a split index, write the shared index to a temporary file,\n * adjust its permissions and rename it into place, then write the\n * split index to the lockfile. If the temporary file for the shared\n * index cannot be created, fall back to the behavior described in\n * the previous paragraph.\n *\n * With `COMMIT_LOCK`, the lock is always committed or rolled back.\n * Without it, the lock is closed, but neither committed nor rolled\n * back.\n *\n * If `SKIP_IF_UNCHANGED` is given and the index is unchanged, nothing\n * is written (and the lock is rolled back if `COMMIT_LOCK` is given).\n */\nextern int write_locked_index(struct index_state *, struct lock_file *lock, unsigned flags);\n\nextern int discard_index(struct index_state *);\nextern void move_index_extensions(struct index_state *dst, struct index_state *src);\nextern int unmerged_index(const struct index_state *);\n\n/**\n * Returns 1 if the index differs from HEAD, 0 otherwise. When on an unborn\n * branch, returns 1 if there are entries in the index, 0 otherwise. If an\n * strbuf is provided, the space-separated list of files that differ will be\n * appended to it.\n */\nextern int index_has_changes(struct strbuf *sb);\n\nextern int verify_path(const char *path, unsigned mode);\nextern int strcmp_offset(const char *s1, const char *s2, size_t *first_change);\nextern int index_dir_exists(struct index_state *istate, const char *name, int namelen);\nextern void adjust_dirname_case(struct index_state *istate, char *name);\nextern struct cache_entry *index_file_exists(struct index_state *istate, const char *name, int namelen, int igncase);\n\n/*\n * Searches for an entry defined by name and namelen in the given index.\n * If the return value is positive (including 0) it is the position of an\n * exact match. If the return value is negative, the negated value minus 1\n * is the position where the entry would be inserted.\n * Example: The current index consists of these files and its stages:\n *\n *   b#0, d#0, f#1, f#3\n *\n * index_name_pos(&index, \"a\", 1) -> -1\n * index_name_pos(&index, \"b\", 1) ->  0\n * index_name_pos(&index, \"c\", 1) -> -2\n * index_name_pos(&index, \"d\", 1) ->  1\n * index_name_pos(&index, \"e\", 1) -> -3\n * index_name_pos(&index, \"f\", 1) -> -3\n * index_name_pos(&index, \"g\", 1) -> -5\n */\nextern int index_name_pos(const struct index_state *, const char *name, int namelen);\n\n#define ADD_CACHE_OK_TO_ADD 1\t\t/* Ok to add */\n#define ADD_CACHE_OK_TO_REPLACE 2\t/* Ok to replace file/directory */\n#define ADD_CACHE_SKIP_DFCHECK 4\t/* Ok to skip DF conflict checks */\n#define ADD_CACHE_JUST_APPEND 8\t\t/* Append only; tree.c::read_tree() */\n#define ADD_CACHE_NEW_ONLY 16\t\t/* Do not replace existing ones */\n#define ADD_CACHE_KEEP_CACHE_TREE 32\t/* Do not invalidate cache-tree */\nextern int add_index_entry(struct index_state *, struct cache_entry *ce, int option);\nextern void rename_index_entry_at(struct index_state *, int pos, const char *new_name);\n\n/* Remove entry, return true if there are more entries to go. */\nextern int remove_index_entry_at(struct index_state *, int pos);\n\nextern void remove_marked_cache_entries(struct index_state *istate);\nextern int remove_file_from_index(struct index_state *, const char *path);\n#define ADD_CACHE_VERBOSE 1\n#define ADD_CACHE_PRETEND 2\n#define ADD_CACHE_IGNORE_ERRORS\t4\n#define ADD_CACHE_IGNORE_REMOVAL 8\n#define ADD_CACHE_INTENT 16\n/*\n * These two are used to add the contents of the file at path\n * to the index, marking the working tree up-to-date by storing\n * the cached stat info in the resulting cache entry.  A caller\n * that has already run lstat(2) on the path can call\n * add_to_index(), and all others can call add_file_to_index();\n * the latter will do necessary lstat(2) internally before\n * calling the former.\n */\nextern int add_to_index(struct index_state *, const char *path, struct stat *, int flags);\nextern int add_file_to_index(struct index_state *, const char *path, int flags);\n\nextern struct cache_entry *make_cache_entry(unsigned int mode, const unsigned char *sha1, const char *path, int stage, unsigned int refresh_options);\nextern int chmod_index_entry(struct index_state *, struct cache_entry *ce, char flip);\nextern int ce_same_name(const struct cache_entry *a, const struct cache_entry *b);\nextern void set_object_name_for_intent_to_add_entry(struct cache_entry *ce);\nextern int index_name_is_other(const struct index_state *, const char *, int);\nextern void *read_blob_data_from_index(const struct index_state *, const char *, unsigned long *);\n\n/* do stat comparison even if CE_VALID is true */\n#define CE_MATCH_IGNORE_VALID\t\t01\n/* do not check the contents but report dirty on racily-clean entries */\n#define CE_MATCH_RACY_IS_DIRTY\t\t02\n/* do stat comparison even if CE_SKIP_WORKTREE is true */\n#define CE_MATCH_IGNORE_SKIP_WORKTREE\t04\n/* ignore non-existent files during stat update  */\n#define CE_MATCH_IGNORE_MISSING\t\t0x08\n/* enable stat refresh */\n#define CE_MATCH_REFRESH\t\t0x10\n/* don't refresh_fsmonitor state or do stat comparison even if CE_FSMONITOR_VALID is true */\n#define CE_MATCH_IGNORE_FSMONITOR 0X20\nextern int ie_match_stat(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\nextern int ie_modified(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\n\n#define HASH_WRITE_OBJECT 1\n#define HASH_FORMAT_CHECK 2\n#define HASH_RENORMALIZE  4\nextern int index_fd(struct object_id *oid, int fd, struct stat *st, enum object_type type, const char *path, unsigned flags);\nextern int index_path(struct object_id *oid, const char *path, struct stat *st, unsigned flags);\n\n/*\n * Record to sd the data from st that we use to check whether a file\n * might have changed.\n */\nextern void fill_stat_data(struct stat_data *sd, struct stat *st);\n\n/*\n * Return 0 if st is consistent with a file not having been changed\n * since sd was filled.  If there are differences, return a\n * combination of MTIME_CHANGED, CTIME_CHANGED, OWNER_CHANGED,\n * INODE_CHANGED, and DATA_CHANGED.\n */\nextern int match_stat_data(const struct stat_data *sd, struct stat *st);\nextern int match_stat_data_racy(const struct index_state *istate,\n\t\t\t\tconst struct stat_data *sd, struct stat *st);\n\nextern void fill_stat_cache_info(struct cache_entry *ce, struct stat *st);\n\n#define REFRESH_REALLY\t\t0x0001\t/* ignore_valid */\n#define REFRESH_UNMERGED\t0x0002\t/* allow unmerged */\n#define REFRESH_QUIET\t\t0x0004\t/* be quiet about it */\n#define REFRESH_IGNORE_MISSING\t0x0008\t/* ignore non-existent */\n#define REFRESH_IGNORE_SUBMODULES\t0x0010\t/* ignore submodules */\n#define REFRESH_IN_PORCELAIN\t0x0020\t/* user friendly output, not \"needs update\" */\nextern int refresh_index(struct index_state *, unsigned int flags, const struct pathspec *pathspec, char *seen, const char *header_msg);\nextern struct cache_entry *refresh_cache_entry(struct cache_entry *, unsigned int);\n\n/*\n * Opportunistically update the index but do not complain if we can't.\n * The lockfile is always committed or rolled back.\n */\nextern void update_index_if_able(struct index_state *, struct lock_file *);\n\nextern int hold_locked_index(struct lock_file *, int);\nextern void set_alternate_index_output(const char *);\n\nextern int verify_index_checksum;\nextern int verify_ce_order;\n\n/* Environment bits from configuration mechanism */\nextern int trust_executable_bit;\nextern int trust_ctime;\nextern int check_stat;\nextern int quote_path_fully;\nextern int has_symlinks;\nextern int minimum_abbrev, default_abbrev;\nextern int ignore_case;\nextern int assume_unchanged;\nextern int prefer_symlink_refs;\nextern int warn_ambiguous_refs;\nextern int warn_on_object_refname_ambiguity;\nextern const char *apply_default_whitespace;\nextern const char *apply_default_ignorewhitespace;\nextern const char *git_attributes_file;\nextern const char *git_hooks_path;\nextern int zlib_compression_level;\nextern int core_compression_level;\nextern int pack_compression_level;\nextern size_t packed_git_window_size;\nextern size_t packed_git_limit;\nextern size_t delta_base_cache_limit;\nextern unsigned long big_file_threshold;\nextern unsigned long pack_size_limit_cfg;\n\n/*\n * Accessors for the core.sharedrepository config which lazy-load the value\n * from the config (if not already set). The \"reset\" function can be\n * used to unset \"set\" or cached value, meaning that the value will be loaded\n * fresh from the config file on the next call to get_shared_repository().\n */\nvoid set_shared_repository(int value);\nint get_shared_repository(void);\nvoid reset_shared_repository(void);\n\n/*\n * Do replace refs need to be checked this run?  This variable is\n * initialized to true unless --no-replace-object is used or\n * $GIT_NO_REPLACE_OBJECTS is set, but is set to false by some\n * commands that do not want replace references to be active.  As an\n * optimization it is also set to false if replace references have\n * been sought but there were none.\n */\nextern int check_replace_refs;\nextern char *git_replace_ref_base;\n\nextern int fsync_object_files;\nextern int core_preload_index;\nextern int core_apply_sparse_checkout;\nextern int precomposed_unicode;\nextern int protect_hfs;\nextern int protect_ntfs;\nextern const char *core_fsmonitor;\n\n/*\n * Include broken refs in all ref iterations, which will\n * generally choke dangerous operations rather than letting\n * them silently proceed without taking the broken ref into\n * account.\n */\nextern int ref_paranoia;\n\n/*\n * Returns the boolean value of $GIT_OPTIONAL_LOCKS (or the default value).\n */\nint use_optional_locks(void);\n\n/*\n * The character that begins a commented line in user-editable file\n * that is subject to stripspace.\n */\nextern char comment_line_char;\nextern int auto_comment_line_char;\n\n/* Windows only */\nenum hide_dotfiles_type {\n\tHIDE_DOTFILES_FALSE = 0,\n\tHIDE_DOTFILES_TRUE,\n\tHIDE_DOTFILES_DOTGITONLY\n};\nextern enum hide_dotfiles_type hide_dotfiles;\n\nenum log_refs_config {\n\tLOG_REFS_UNSET = -1,\n\tLOG_REFS_NONE = 0,\n\tLOG_REFS_NORMAL,\n\tLOG_REFS_ALWAYS\n};\nextern enum log_refs_config log_all_ref_updates;\n\nenum branch_track {\n\tBRANCH_TRACK_UNSPECIFIED = -1,\n\tBRANCH_TRACK_NEVER = 0,\n\tBRANCH_TRACK_REMOTE,\n\tBRANCH_TRACK_ALWAYS,\n\tBRANCH_TRACK_EXPLICIT,\n\tBRANCH_TRACK_OVERRIDE\n};\n\nenum rebase_setup_type {\n\tAUTOREBASE_NEVER = 0,\n\tAUTOREBASE_LOCAL,\n\tAUTOREBASE_REMOTE,\n\tAUTOREBASE_ALWAYS\n};\n\nenum push_default_type {\n\tPUSH_DEFAULT_NOTHING = 0,\n\tPUSH_DEFAULT_MATCHING,\n\tPUSH_DEFAULT_SIMPLE,\n\tPUSH_DEFAULT_UPSTREAM,\n\tPUSH_DEFAULT_CURRENT,\n\tPUSH_DEFAULT_UNSPECIFIED\n};\n\nextern enum branch_track git_branch_track;\nextern enum rebase_setup_type autorebase;\nextern enum push_default_type push_default;\n\nenum object_creation_mode {\n\tOBJECT_CREATION_USES_HARDLINKS = 0,\n\tOBJECT_CREATION_USES_RENAMES = 1\n};\n\nextern enum object_creation_mode object_creation_mode;\n\nextern char *notes_ref_name;\n\nextern int grafts_replace_parents;\n\n/*\n * GIT_REPO_VERSION is the version we write by default. The\n * _READ variant is the highest number we know how to\n * handle.\n */\n#define GIT_REPO_VERSION 0\n#define GIT_REPO_VERSION_READ 1\nextern int repository_format_precious_objects;\nextern char *repository_format_partial_clone;\nextern const char *core_partial_clone_filter_default;\n\nstruct repository_format {\n\tint version;\n\tint precious_objects;\n\tchar *partial_clone; /* value of extensions.partialclone */\n\tint is_bare;\n\tint hash_algo;\n\tchar *work_tree;\n\tstruct string_list unknown_extensions;\n};\n\n/*\n * Read the repository format characteristics from the config file \"path\" into\n * \"format\" struct. Returns the numeric version. On error, -1 is returned,\n * format->version is set to -1, and all other fields in the struct are\n * undefined.\n */\nint read_repository_format(struct repository_format *format, const char *path);\n\n/*\n * Verify that the repository described by repository_format is something we\n * can read. If it is, return 0. Otherwise, return -1, and \"err\" will describe\n * any errors encountered.\n */\nint verify_repository_format(const struct repository_format *format,\n\t\t\t     struct strbuf *err);\n\n/*\n * Check the repository format version in the path found in get_git_dir(),\n * and die if it is a version we don't understand. Generally one would\n * set_git_dir() before calling this, and use it only for \"are we in a valid\n * repo?\".\n */\nextern void check_repository_format(void);\n\n#define MTIME_CHANGED\t0x0001\n#define CTIME_CHANGED\t0x0002\n#define OWNER_CHANGED\t0x0004\n#define MODE_CHANGED    0x0008\n#define INODE_CHANGED   0x0010\n#define DATA_CHANGED    0x0020\n#define TYPE_CHANGED    0x0040\n\n/*\n * Put in `buf` the name of the file in the local object database that\n * would be used to store a loose object with the specified sha1.\n */\nextern void sha1_file_name(struct strbuf *buf, const unsigned char *sha1);\n\n/*\n * Return an abbreviated sha1 unique within this repository's object database.\n * The result will be at least `len` characters long, and will be NUL\n * terminated.\n *\n * The non-`_r` version returns a static buffer which remains valid until 4\n * more calls to find_unique_abbrev are made.\n *\n * The `_r` variant writes to a buffer supplied by the caller, which must be at\n * least `GIT_SHA1_HEXSZ + 1` bytes. The return value is the number of bytes\n * written (excluding the NUL terminator).\n *\n * Note that while this version avoids the static buffer, it is not fully\n * reentrant, as it calls into other non-reentrant git code.\n */\nextern const char *find_unique_abbrev(const unsigned char *sha1, int len);\nextern int find_unique_abbrev_r(char *hex, const unsigned char *sha1, int len);\n\nextern const unsigned char null_sha1[GIT_MAX_RAWSZ];\nextern const struct object_id null_oid;\n\nstatic inline int hashcmp(const unsigned char *sha1, const unsigned char *sha2)\n{\n\treturn memcmp(sha1, sha2, GIT_SHA1_RAWSZ);\n}\n\nstatic inline int oidcmp(const struct object_id *oid1, const struct object_id *oid2)\n{\n\treturn hashcmp(oid1->hash, oid2->hash);\n}\n\nstatic inline int is_null_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, null_sha1);\n}\n\nstatic inline int is_null_oid(const struct object_id *oid)\n{\n\treturn !hashcmp(oid->hash, null_sha1);\n}\n\nstatic inline void hashcpy(unsigned char *sha_dst, const unsigned char *sha_src)\n{\n\tmemcpy(sha_dst, sha_src, GIT_SHA1_RAWSZ);\n}\n\nstatic inline void oidcpy(struct object_id *dst, const struct object_id *src)\n{\n\thashcpy(dst->hash, src->hash);\n}\n\nstatic inline struct object_id *oiddup(const struct object_id *src)\n{\n\tstruct object_id *dst = xmalloc(sizeof(struct object_id));\n\toidcpy(dst, src);\n\treturn dst;\n}\n\nstatic inline void hashclr(unsigned char *hash)\n{\n\tmemset(hash, 0, GIT_SHA1_RAWSZ);\n}\n\nstatic inline void oidclr(struct object_id *oid)\n{\n\tmemset(oid->hash, 0, GIT_MAX_RAWSZ);\n}\n\n\n#define EMPTY_TREE_SHA1_HEX \\\n\t\"4b825dc642cb6eb9a060e54bf8d69288fbee4904\"\n#define EMPTY_TREE_SHA1_BIN_LITERAL \\\n\t \"\\x4b\\x82\\x5d\\xc6\\x42\\xcb\\x6e\\xb9\\xa0\\x60\" \\\n\t \"\\xe5\\x4b\\xf8\\xd6\\x92\\x88\\xfb\\xee\\x49\\x04\"\nextern const struct object_id empty_tree_oid;\n#define EMPTY_TREE_SHA1_BIN (empty_tree_oid.hash)\n\n#define EMPTY_BLOB_SHA1_HEX \\\n\t\"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391\"\n#define EMPTY_BLOB_SHA1_BIN_LITERAL \\\n\t\"\\xe6\\x9d\\xe2\\x9b\\xb2\\xd1\\xd6\\x43\\x4b\\x8b\" \\\n\t\"\\x29\\xae\\x77\\x5a\\xd8\\xc2\\xe4\\x8c\\x53\\x91\"\nextern const struct object_id empty_blob_oid;\n\nstatic inline int is_empty_blob_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, the_hash_algo->empty_blob->hash);\n}\n\nstatic inline int is_empty_blob_oid(const struct object_id *oid)\n{\n\treturn !oidcmp(oid, the_hash_algo->empty_blob);\n}\n\nstatic inline int is_empty_tree_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, the_hash_algo->empty_tree->hash);\n}\n\nstatic inline int is_empty_tree_oid(const struct object_id *oid)\n{\n\treturn !oidcmp(oid, the_hash_algo->empty_tree);\n}\n\n/* set default permissions by passing mode arguments to open(2) */\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode);\nint git_mkstemp_mode(char *pattern, int mode);\n\n/*\n * NOTE NOTE NOTE!!\n *\n * PERM_UMASK, OLD_PERM_GROUP and OLD_PERM_EVERYBODY enumerations must\n * not be changed. Old repositories have core.sharedrepository written in\n * numeric format, and therefore these values are preserved for compatibility\n * reasons.\n */\nenum sharedrepo {\n\tPERM_UMASK          = 0,\n\tOLD_PERM_GROUP      = 1,\n\tOLD_PERM_EVERYBODY  = 2,\n\tPERM_GROUP          = 0660,\n\tPERM_EVERYBODY      = 0664\n};\nint git_config_perm(const char *var, const char *value);\nint adjust_shared_perm(const char *path);\n\n/*\n * Create the directory containing the named path, using care to be\n * somewhat safe against races. Return one of the scld_error values to\n * indicate success/failure. On error, set errno to describe the\n * problem.\n *\n * SCLD_VANISHED indicates that one of the ancestor directories of the\n * path existed at one point during the function call and then\n * suddenly vanished, probably because another process pruned the\n * directory while we were working.  To be robust against this kind of\n * race, callers might want to try invoking the function again when it\n * returns SCLD_VANISHED.\n *\n * safe_create_leading_directories() temporarily changes path while it\n * is working but restores it before returning.\n * safe_create_leading_directories_const() doesn't modify path, even\n * temporarily.\n */\nenum scld_error {\n\tSCLD_OK = 0,\n\tSCLD_FAILED = -1,\n\tSCLD_PERMS = -2,\n\tSCLD_EXISTS = -3,\n\tSCLD_VANISHED = -4\n};\nenum scld_error safe_create_leading_directories(char *path);\nenum scld_error safe_create_leading_directories_const(const char *path);\n\n/*\n * Callback function for raceproof_create_file(). This function is\n * expected to do something that makes dirname(path) permanent despite\n * the fact that other processes might be cleaning up empty\n * directories at the same time. Usually it will create a file named\n * path, but alternatively it could create another file in that\n * directory, or even chdir() into that directory. The function should\n * return 0 if the action was completed successfully. On error, it\n * should return a nonzero result and set errno.\n * raceproof_create_file() treats two errno values specially:\n *\n * - ENOENT -- dirname(path) does not exist. In this case,\n *             raceproof_create_file() tries creating dirname(path)\n *             (and any parent directories, if necessary) and calls\n *             the function again.\n *\n * - EISDIR -- the file already exists and is a directory. In this\n *             case, raceproof_create_file() removes the directory if\n *             it is empty (and recursively any empty directories that\n *             it contains) and calls the function again.\n *\n * Any other errno causes raceproof_create_file() to fail with the\n * callback's return value and errno.\n *\n * Obviously, this function should be OK with being called again if it\n * fails with ENOENT or EISDIR. In other scenarios it will not be\n * called again.\n */\ntypedef int create_file_fn(const char *path, void *cb);\n\n/*\n * Create a file in dirname(path) by calling fn, creating leading\n * directories if necessary. Retry a few times in case we are racing\n * with another process that is trying to clean up the directory that\n * contains path. See the documentation for create_file_fn for more\n * details.\n *\n * Return the value and set the errno that resulted from the most\n * recent call of fn. fn is always called at least once, and will be\n * called more than once if it returns ENOENT or EISDIR.\n */\nint raceproof_create_file(const char *path, create_file_fn fn, void *cb);\n\nint mkdir_in_gitdir(const char *path);\nextern char *expand_user_path(const char *path, int real_home);\nconst char *enter_repo(const char *path, int strict);\nstatic inline int is_absolute_path(const char *path)\n{\n\treturn is_dir_sep(path[0]) || has_dos_drive_prefix(path);\n}\nint is_directory(const char *);\nchar *strbuf_realpath(struct strbuf *resolved, const char *path,\n\t\t      int die_on_error);\nconst char *real_path(const char *path);\nconst char *real_path_if_valid(const char *path);\nchar *real_pathdup(const char *path, int die_on_error);\nconst char *absolute_path(const char *path);\nchar *absolute_pathdup(const char *path);\nconst char *remove_leading_path(const char *in, const char *prefix);\nconst char *relative_path(const char *in, const char *prefix, struct strbuf *sb);\nint normalize_path_copy_len(char *dst, const char *src, int *prefix_len);\nint normalize_path_copy(char *dst, const char *src);\nint longest_ancestor_length(const char *path, struct string_list *prefixes);\nchar *strip_path_suffix(const char *path, const char *suffix);\nint daemon_avoid_alias(const char *path);\n\n/*\n * These functions match their is_hfs_dotgit() counterparts; see utf8.h for\n * details.\n */\nint is_ntfs_dotgit(const char *name);\nint is_ntfs_dotgitmodules(const char *name);\nint is_ntfs_dotgitignore(const char *name);\nint is_ntfs_dotgitattributes(const char *name);\n\n/*\n * Returns true iff \"str\" could be confused as a command-line option when\n * passed to a sub-program like \"ssh\". Note that this has nothing to do with\n * shell-quoting, which should be handled separately; we're assuming here that\n * the string makes it verbatim to the sub-program.\n */\nint looks_like_command_line_option(const char *str);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CONFIG_HOME/git/$filename\" if $XDG_CONFIG_HOME is non-empty, otherwise\n * \"$HOME/.config/git/$filename\". Return NULL upon error.\n */\nextern char *xdg_config_home(const char *filename);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CACHE_HOME/git/$filename\" if $XDG_CACHE_HOME is non-empty, otherwise\n * \"$HOME/.cache/git/$filename\". Return NULL upon error.\n */\nextern char *xdg_cache_home(const char *filename);\n\nextern void *read_sha1_file_extended(const unsigned char *sha1,\n\t\t\t\t     enum object_type *type,\n\t\t\t\t     unsigned long *size, int lookup_replace);\nstatic inline void *read_sha1_file(const unsigned char *sha1, enum object_type *type, unsigned long *size)\n{\n\treturn read_sha1_file_extended(sha1, type, size, 1);\n}\n\n/*\n * This internal function is only declared here for the benefit of\n * lookup_replace_object().  Please do not call it directly.\n */\nextern const unsigned char *do_lookup_replace_object(const unsigned char *sha1);\n\n/*\n * If object sha1 should be replaced, return the replacement object's\n * name (replaced recursively, if necessary).  The return value is\n * either sha1 or a pointer to a permanently-allocated value.  When\n * object replacement is suppressed, always return sha1.\n */\nstatic inline const unsigned char *lookup_replace_object(const unsigned char *sha1)\n{\n\tif (!check_replace_refs)\n\t\treturn sha1;\n\treturn do_lookup_replace_object(sha1);\n}\n\n/* Read and unpack a sha1 file into memory, write memory to a sha1 file */\nextern int sha1_object_info(const unsigned char *, unsigned long *);\n\nextern int hash_object_file(const void *buf, unsigned long len,\n\t\t\t    const char *type, struct object_id *oid);\n\nextern int write_object_file(const void *buf, unsigned long len,\n\t\t\t     const char *type, struct object_id *oid);\n\nextern int hash_object_file_literally(const void *buf, unsigned long len,\n\t\t\t\t      const char *type, struct object_id *oid,\n\t\t\t\t      unsigned flags);\n\nextern int pretend_object_file(void *, unsigned long, enum object_type,\n\t\t\t       struct object_id *oid);\n\nextern int force_object_loose(const struct object_id *oid, time_t mtime);\n\nextern int git_open_cloexec(const char *name, int flags);\n#define git_open(name) git_open_cloexec(name, O_RDONLY)\nextern void *map_sha1_file(const unsigned char *sha1, unsigned long *size);\nextern int unpack_sha1_header(git_zstream *stream, unsigned char *map, unsigned long mapsize, void *buffer, unsigned long bufsiz);\nextern int parse_sha1_header(const char *hdr, unsigned long *sizep);\n\nextern int check_sha1_signature(const unsigned char *sha1, void *buf, unsigned long size, const char *type);\n\nextern int finalize_object_file(const char *tmpfile, const char *filename);\n\n/*\n * Open the loose object at path, check its sha1, and return the contents,\n * type, and size. If the object is a blob, then \"contents\" may return NULL,\n * to allow streaming of large blobs.\n *\n * Returns 0 on success, negative on error (details may be written to stderr).\n */\nint read_loose_object(const char *path,\n\t\t      const unsigned char *expected_sha1,\n\t\t      enum object_type *type,\n\t\t      unsigned long *size,\n\t\t      void **contents);\n\n/*\n * Convenience for sha1_object_info_extended() with a NULL struct\n * object_info. OBJECT_INFO_SKIP_CACHED is automatically set; pass\n * nonzero flags to also set other flags.\n */\nextern int has_sha1_file_with_flags(const unsigned char *sha1, int flags);\nstatic inline int has_sha1_file(const unsigned char *sha1)\n{\n\treturn has_sha1_file_with_flags(sha1, 0);\n}\n\n/* Same as the above, except for struct object_id. */\nextern int has_object_file(const struct object_id *oid);\nextern int has_object_file_with_flags(const struct object_id *oid, int flags);\n\n/*\n * Return true iff an alternate object database has a loose object\n * with the specified name.  This function does not respect replace\n * references.\n */\nextern int has_loose_object_nonlocal(const unsigned char *sha1);\n\nextern void assert_sha1_type(const unsigned char *sha1, enum object_type expect);\n\n/* Helper to check and \"touch\" a file */\nextern int check_and_freshen_file(const char *fn, int freshen);\n\nextern const signed char hexval_table[256];\nstatic inline unsigned int hexval(unsigned char c)\n{\n\treturn hexval_table[c];\n}\n\n/*\n * Convert two consecutive hexadecimal digits into a char.  Return a\n * negative value on error.  Don't run over the end of short strings.\n */\nstatic inline int hex2chr(const char *s)\n{\n\tunsigned int val = hexval(s[0]);\n\treturn (val & ~0xf) ? val : (val << 4) | hexval(s[1]);\n}\n\n/* Convert to/from hex/sha1 representation */\n#define MINIMUM_ABBREV minimum_abbrev\n#define DEFAULT_ABBREV default_abbrev\n\n/* used when the code does not know or care what the default abbrev is */\n#define FALLBACK_DEFAULT_ABBREV 7\n\nstruct object_context {\n\tunsigned char tree[20];\n\tunsigned mode;\n\t/*\n\t * symlink_path is only used by get_tree_entry_follow_symlinks,\n\t * and only for symlinks that point outside the repository.\n\t */\n\tstruct strbuf symlink_path;\n\t/*\n\t * If GET_OID_RECORD_PATH is set, this will record path (if any)\n\t * found when resolving the name. The caller is responsible for\n\t * releasing the memory.\n\t */\n\tchar *path;\n};\n\n#define GET_OID_QUIETLY           01\n#define GET_OID_COMMIT            02\n#define GET_OID_COMMITTISH        04\n#define GET_OID_TREE             010\n#define GET_OID_TREEISH          020\n#define GET_OID_BLOB             040\n#define GET_OID_FOLLOW_SYMLINKS 0100\n#define GET_OID_RECORD_PATH     0200\n#define GET_OID_ONLY_TO_DIE    04000\n\n#define GET_OID_DISAMBIGUATORS \\\n\t(GET_OID_COMMIT | GET_OID_COMMITTISH | \\\n\tGET_OID_TREE | GET_OID_TREEISH | \\\n\tGET_OID_BLOB)\n\nextern int get_oid(const char *str, struct object_id *oid);\nextern int get_oid_commit(const char *str, struct object_id *oid);\nextern int get_oid_committish(const char *str, struct object_id *oid);\nextern int get_oid_tree(const char *str, struct object_id *oid);\nextern int get_oid_treeish(const char *str, struct object_id *oid);\nextern int get_oid_blob(const char *str, struct object_id *oid);\nextern void maybe_die_on_misspelt_object_name(const char *name, const char *prefix);\nextern int get_oid_with_context(const char *str, unsigned flags, struct object_id *oid, struct object_context *oc);\n\n\ntypedef int each_abbrev_fn(const struct object_id *oid, void *);\nextern int for_each_abbrev(const char *prefix, each_abbrev_fn, void *);\n\nextern int set_disambiguate_hint_config(const char *var, const char *value);\n\n/*\n * Try to read a SHA1 in hexadecimal format from the 40 characters\n * starting at hex.  Write the 20-byte result to sha1 in binary form.\n * Return 0 on success.  Reading stops if a NUL is encountered in the\n * input, so it is safe to pass this function an arbitrary\n * null-terminated string.\n */\nextern int get_sha1_hex(const char *hex, unsigned char *sha1);\nextern int get_oid_hex(const char *hex, struct object_id *sha1);\n\n/*\n * Read `len` pairs of hexadecimal digits from `hex` and write the\n * values to `binary` as `len` bytes. Return 0 on success, or -1 if\n * the input does not consist of hex digits).\n */\nextern int hex_to_bytes(unsigned char *binary, const char *hex, size_t len);\n\n/*\n * Convert a binary sha1 to its hex equivalent. The `_r` variant is reentrant,\n * and writes the NUL-terminated output to the buffer `out`, which must be at\n * least `GIT_SHA1_HEXSZ + 1` bytes, and returns a pointer to out for\n * convenience.\n *\n * The non-`_r` variant returns a static buffer, but uses a ring of 4\n * buffers, making it safe to make multiple calls for a single statement, like:\n *\n *   printf(\"%s -> %s\", sha1_to_hex(one), sha1_to_hex(two));\n */\nextern char *sha1_to_hex_r(char *out, const unsigned char *sha1);\nextern char *oid_to_hex_r(char *out, const struct object_id *oid);\nextern char *sha1_to_hex(const unsigned char *sha1);\t/* static buffer result! */\nextern char *oid_to_hex(const struct object_id *oid);\t/* same static buffer as sha1_to_hex */\n\n/*\n * Parse a 40-character hexadecimal object ID starting from hex, updating the\n * pointer specified by end when parsing stops.  The resulting object ID is\n * stored in oid.  Returns 0 on success.  Parsing will stop on the first NUL or\n * other invalid character.  end is only updated on success; otherwise, it is\n * unmodified.\n */\nextern int parse_oid_hex(const char *hex, struct object_id *oid, const char **end);\n\n/*\n * This reads short-hand syntax that not only evaluates to a commit\n * object name, but also can act as if the end user spelled the name\n * of the branch from the command line.\n *\n * - \"@{-N}\" finds the name of the Nth previous branch we were on, and\n *   places the name of the branch in the given buf and returns the\n *   number of characters parsed if successful.\n *\n * - \"<branch>@{upstream}\" finds the name of the other ref that\n *   <branch> is configured to merge with (missing <branch> defaults\n *   to the current branch), and places the name of the branch in the\n *   given buf and returns the number of characters parsed if\n *   successful.\n *\n * If the input is not of the accepted format, it returns a negative\n * number to signal an error.\n *\n * If the input was ok but there are not N branch switches in the\n * reflog, it returns 0.\n *\n * If \"allowed\" is non-zero, it is a treated as a bitfield of allowable\n * expansions: local branches (\"refs/heads/\"), remote branches\n * (\"refs/remotes/\"), or \"HEAD\". If no \"allowed\" bits are set, any expansion is\n * allowed, even ones to refs outside of those namespaces.\n */\n#define INTERPRET_BRANCH_LOCAL (1<<0)\n#define INTERPRET_BRANCH_REMOTE (1<<1)\n#define INTERPRET_BRANCH_HEAD (1<<2)\nextern int interpret_branch_name(const char *str, int len, struct strbuf *,\n\t\t\t\t unsigned allowed);\nextern int get_oid_mb(const char *str, struct object_id *oid);\n\nextern int validate_headref(const char *ref);\n\nextern int base_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int df_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int name_compare(const char *name1, size_t len1, const char *name2, size_t len2);\nextern int cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2);\n\nextern void *read_object_with_reference(const unsigned char *sha1,\n\t\t\t\t\tconst char *required_type,\n\t\t\t\t\tunsigned long *size,\n\t\t\t\t\tunsigned char *sha1_ret);\n\nextern struct object *peel_to_type(const char *name, int namelen,\n\t\t\t\t   struct object *o, enum object_type);\n\nstruct date_mode {\n\tenum date_mode_type {\n\t\tDATE_NORMAL = 0,\n\t\tDATE_RELATIVE,\n\t\tDATE_SHORT,\n\t\tDATE_ISO8601,\n\t\tDATE_ISO8601_STRICT,\n\t\tDATE_RFC2822,\n\t\tDATE_STRFTIME,\n\t\tDATE_RAW,\n\t\tDATE_UNIX\n\t} type;\n\tconst char *strftime_fmt;\n\tint local;\n};\n\n/*\n * Convenience helper for passing a constant type, like:\n *\n *   show_date(t, tz, DATE_MODE(NORMAL));\n */\n#define DATE_MODE(t) date_mode_from_type(DATE_##t)\nstruct date_mode *date_mode_from_type(enum date_mode_type type);\n\nconst char *show_date(timestamp_t time, int timezone, const struct date_mode *mode);\nvoid show_date_relative(timestamp_t time, int tz, const struct timeval *now,\n\t\t\tstruct strbuf *timebuf);\nint parse_date(const char *date, struct strbuf *out);\nint parse_date_basic(const char *date, timestamp_t *timestamp, int *offset);\nint parse_expiry_date(const char *date, timestamp_t *timestamp);\nvoid datestamp(struct strbuf *out);\n#define approxidate(s) approxidate_careful((s), NULL)\ntimestamp_t approxidate_careful(const char *, int *);\ntimestamp_t approxidate_relative(const char *date, const struct timeval *now);\nvoid parse_date_format(const char *format, struct date_mode *mode);\nint date_overflows(timestamp_t date);\n\n#define IDENT_STRICT\t       1\n#define IDENT_NO_DATE\t       2\n#define IDENT_NO_NAME\t       4\nextern const char *git_author_info(int);\nextern const char *git_committer_info(int);\nextern const char *fmt_ident(const char *name, const char *email, const char *date_str, int);\nextern const char *fmt_name(const char *name, const char *email);\nextern const char *ident_default_name(void);\nextern const char *ident_default_email(void);\nextern const char *git_editor(void);\nextern const char *git_pager(int stdout_is_tty);\nextern int is_terminal_dumb(void);\nextern int git_ident_config(const char *, const char *, void *);\nextern void reset_ident_date(void);\n\nstruct ident_split {\n\tconst char *name_begin;\n\tconst char *name_end;\n\tconst char *mail_begin;\n\tconst char *mail_end;\n\tconst char *date_begin;\n\tconst char *date_end;\n\tconst char *tz_begin;\n\tconst char *tz_end;\n};\n/*\n * Signals an success with 0, but time part of the result may be NULL\n * if the input lacks timestamp and zone\n */\nextern int split_ident_line(struct ident_split *, const char *, int);\n\n/*\n * Like show_date, but pull the timestamp and tz parameters from\n * the ident_split. It will also sanity-check the values and produce\n * a well-known sentinel date if they appear bogus.\n */\nconst char *show_ident_date(const struct ident_split *id,\n\t\t\t    const struct date_mode *mode);\n\n/*\n * Compare split idents for equality or strict ordering. Note that we\n * compare only the ident part of the line, ignoring any timestamp.\n *\n * Because there are two fields, we must choose one as the primary key; we\n * currently arbitrarily pick the email.\n */\nextern int ident_cmp(const struct ident_split *, const struct ident_split *);\n\nstruct checkout {\n\tstruct index_state *istate;\n\tconst char *base_dir;\n\tint base_dir_len;\n\tstruct delayed_checkout *delayed_checkout;\n\tunsigned force:1,\n\t\t quiet:1,\n\t\t not_new:1,\n\t\t refresh_cache:1;\n};\n#define CHECKOUT_INIT { NULL, \"\" }\n\n#define TEMPORARY_FILENAME_LENGTH 25\nextern int checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath);\nextern void enable_delayed_checkout(struct checkout *state);\nextern int finish_delayed_checkout(struct checkout *state);\n\nstruct cache_def {\n\tstruct strbuf path;\n\tint flags;\n\tint track_flags;\n\tint prefix_len_stat_func;\n};\n#define CACHE_DEF_INIT { STRBUF_INIT, 0, 0, 0 }\nstatic inline void cache_def_clear(struct cache_def *cache)\n{\n\tstrbuf_release(&cache->path);\n}\n\nextern int has_symlink_leading_path(const char *name, int len);\nextern int threaded_has_symlink_leading_path(struct cache_def *, const char *, int);\nextern int check_leading_path(const char *name, int len);\nextern int has_dirs_only_path(const char *name, int len, int prefix_len);\nextern void invalidate_lstat_cache(void);\nextern void schedule_dir_for_removal(const char *name, int len);\nextern void remove_scheduled_dirs(void);\n\nextern struct alternate_object_database {\n\tstruct alternate_object_database *next;\n\n\t/* see alt_scratch_buf() */\n\tstruct strbuf scratch;\n\tsize_t base_len;\n\n\t/*\n\t * Used to store the results of readdir(3) calls when searching\n\t * for unique abbreviated hashes.  This cache is never\n\t * invalidated, thus it's racy and not necessarily accurate.\n\t * That's fine for its purpose; don't use it for tasks requiring\n\t * greater accuracy!\n\t */\n\tchar loose_objects_subdir_seen[256];\n\tstruct oid_array loose_objects_cache;\n\n\tchar path[FLEX_ARRAY];\n} *alt_odb_list;\nextern void prepare_alt_odb(void);\nextern char *compute_alternate_path(const char *path, struct strbuf *err);\ntypedef int alt_odb_fn(struct alternate_object_database *, void *);\nextern int foreach_alt_odb(alt_odb_fn, void*);\n\n/*\n * Allocate a \"struct alternate_object_database\" but do _not_ actually\n * add it to the list of alternates.\n */\nstruct alternate_object_database *alloc_alt_odb(const char *dir);\n\n/*\n * Add the directory to the on-disk alternates file; the new entry will also\n * take effect in the current process.\n */\nextern void add_to_alternates_file(const char *dir);\n\n/*\n * Add the directory to the in-memory list of alternates (along with any\n * recursive alternates it points to), but do not modify the on-disk alternates\n * file.\n */\nextern void add_to_alternates_memory(const char *dir);\n\n/*\n * Returns a scratch strbuf pre-filled with the alternate object directory,\n * including a trailing slash, which can be used to access paths in the\n * alternate. Always use this over direct access to alt->scratch, as it\n * cleans up any previous use of the scratch buffer.\n */\nextern struct strbuf *alt_scratch_buf(struct alternate_object_database *alt);\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nextern struct packed_git {\n\tstruct packed_git *next;\n\tstruct list_head mru;\n\tstruct pack_window *windows;\n\toff_t pack_size;\n\tconst void *index_data;\n\tsize_t index_size;\n\tuint32_t num_objects;\n\tuint32_t num_bad_objects;\n\tunsigned char *bad_object_sha1;\n\tint index_version;\n\ttime_t mtime;\n\tint pack_fd;\n\tunsigned pack_local:1,\n\t\t pack_keep:1,\n\t\t freshened:1,\n\t\t do_not_close:1,\n\t\t pack_promisor:1;\n\tunsigned char sha1[20];\n\tstruct revindex_entry *revindex;\n\t/* something like \".git/objects/pack/xxxxx.pack\" */\n\tchar pack_name[FLEX_ARRAY]; /* more */\n} *packed_git;\n\n/*\n * A most-recently-used ordered version of the packed_git list.\n */\nextern struct list_head packed_git_mru;\n\nstruct pack_entry {\n\toff_t offset;\n\tunsigned char sha1[20];\n\tstruct packed_git *p;\n};\n\n/*\n * Create a temporary file rooted in the object database directory, or\n * die on failure. The filename is taken from \"pattern\", which should have the\n * usual \"XXXXXX\" trailer, and the resulting filename is written into the\n * \"template\" buffer. Returns the open descriptor.\n */\nextern int odb_mkstemp(struct strbuf *temp_filename, const char *pattern);\n\n/*\n * Create a pack .keep file named \"name\" (which should generally be the output\n * of odb_pack_name). Returns a file descriptor opened for writing, or -1 on\n * error.\n */\nextern int odb_pack_keep(const char *name);\n\n/*\n * Iterate over the files in the loose-object parts of the object\n * directory \"path\", triggering the following callbacks:\n *\n *  - loose_object is called for each loose object we find.\n *\n *  - loose_cruft is called for any files that do not appear to be\n *    loose objects. Note that we only look in the loose object\n *    directories \"objects/[0-9a-f]{2}/\", so we will not report\n *    \"objects/foobar\" as cruft.\n *\n *  - loose_subdir is called for each top-level hashed subdirectory\n *    of the object directory (e.g., \"$OBJDIR/f0\"). It is called\n *    after the objects in the directory are processed.\n *\n * Any callback that is NULL will be ignored. Callbacks returning non-zero\n * will end the iteration.\n *\n * In the \"buf\" variant, \"path\" is a strbuf which will also be used as a\n * scratch buffer, but restored to its original contents before\n * the function returns.\n */\ntypedef int each_loose_object_fn(const struct object_id *oid,\n\t\t\t\t const char *path,\n\t\t\t\t void *data);\ntypedef int each_loose_cruft_fn(const char *basename,\n\t\t\t\tconst char *path,\n\t\t\t\tvoid *data);\ntypedef int each_loose_subdir_fn(unsigned int nr,\n\t\t\t\t const char *path,\n\t\t\t\t void *data);\nint for_each_file_in_obj_subdir(unsigned int subdir_nr,\n\t\t\t\tstruct strbuf *path,\n\t\t\t\teach_loose_object_fn obj_cb,\n\t\t\t\teach_loose_cruft_fn cruft_cb,\n\t\t\t\teach_loose_subdir_fn subdir_cb,\n\t\t\t\tvoid *data);\nint for_each_loose_file_in_objdir(const char *path,\n\t\t\t\t  each_loose_object_fn obj_cb,\n\t\t\t\t  each_loose_cruft_fn cruft_cb,\n\t\t\t\t  each_loose_subdir_fn subdir_cb,\n\t\t\t\t  void *data);\nint for_each_loose_file_in_objdir_buf(struct strbuf *path,\n\t\t\t\t      each_loose_object_fn obj_cb,\n\t\t\t\t      each_loose_cruft_fn cruft_cb,\n\t\t\t\t      each_loose_subdir_fn subdir_cb,\n\t\t\t\t      void *data);\n\n/*\n * Iterate over loose objects in both the local\n * repository and any alternates repositories (unless the\n * LOCAL_ONLY flag is set).\n */\n#define FOR_EACH_OBJECT_LOCAL_ONLY 0x1\nextern int for_each_loose_object(each_loose_object_fn, void *, unsigned flags);\n\nstruct object_info {\n\t/* Request */\n\tenum object_type *typep;\n\tunsigned long *sizep;\n\toff_t *disk_sizep;\n\tunsigned char *delta_base_sha1;\n\tstruct strbuf *type_name;\n\tvoid **contentp;\n\n\t/* Response */\n\tenum {\n\t\tOI_CACHED,\n\t\tOI_LOOSE,\n\t\tOI_PACKED,\n\t\tOI_DBCACHED\n\t} whence;\n\tunion {\n\t\t/*\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } cached;\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } loose;\n\t\t */\n\t\tstruct {\n\t\t\tstruct packed_git *pack;\n\t\t\toff_t offset;\n\t\t\tunsigned int is_delta;\n\t\t} packed;\n\t} u;\n};\n\n/*\n * Initializer for a \"struct object_info\" that wants no items. You may\n * also memset() the memory to all-zeroes.\n */\n#define OBJECT_INFO_INIT {NULL}\n\n/* Invoke lookup_replace_object() on the given hash */\n#define OBJECT_INFO_LOOKUP_REPLACE 1\n/* Allow reading from a loose object file of unknown/bogus type */\n#define OBJECT_INFO_ALLOW_UNKNOWN_TYPE 2\n/* Do not check cached storage */\n#define OBJECT_INFO_SKIP_CACHED 4\n/* Do not retry packed storage after checking packed and loose storage */\n#define OBJECT_INFO_QUICK 8\nextern int sha1_object_info_extended(const unsigned char *, struct object_info *, unsigned flags);\n\n/*\n * Set this to 0 to prevent sha1_object_info_extended() from fetching missing\n * blobs. This has a difference only if extensions.partialClone is set.\n *\n * Its default value is 1.\n */\nextern int fetch_if_missing;\n\n/* Dumb servers support */\nextern int update_server_info(int);\n\nextern const char *get_log_output_encoding(void);\nextern const char *get_commit_output_encoding(void);\n\n/*\n * This is a hack for test programs like test-dump-untracked-cache to\n * ensure that they do not modify the untracked cache when reading it.\n * Do not use it otherwise!\n */\nextern int ignore_untracked_cache_config;\n\nextern int committer_ident_sufficiently_given(void);\nextern int author_ident_sufficiently_given(void);\n\nextern const char *git_commit_encoding;\nextern const char *git_log_output_encoding;\nextern const char *git_mailmap_file;\nextern const char *git_mailmap_blob;\n\n/* IO helper functions */\nextern void maybe_flush_or_die(FILE *, const char *);\n__attribute__((format (printf, 2, 3)))\nextern void fprintf_or_die(FILE *, const char *fmt, ...);\n\n#define COPY_READ_ERROR (-2)\n#define COPY_WRITE_ERROR (-3)\nextern int copy_fd(int ifd, int ofd);\nextern int copy_file(const char *dst, const char *src, int mode);\nextern int copy_file_with_time(const char *dst, const char *src, int mode);\n\nextern void write_or_die(int fd, const void *buf, size_t count);\nextern void fsync_or_die(int fd, const char *);\n\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\nextern ssize_t write_in_full(int fd, const void *buf, size_t count);\nextern ssize_t pread_in_full(int fd, void *buf, size_t count, off_t offset);\n\nstatic inline ssize_t write_str_in_full(int fd, const char *str)\n{\n\treturn write_in_full(fd, str, strlen(str));\n}\n\n/**\n * Open (and truncate) the file at path, write the contents of buf to it,\n * and close it. Dies if any errors are encountered.\n */\nextern void write_file_buf(const char *path, const char *buf, size_t len);\n\n/**\n * Like write_file_buf(), but format the contents into a buffer first.\n * Additionally, write_file() will append a newline if one is not already\n * present, making it convenient to write text files:\n *\n *   write_file(path, \"counter: %d\", ctr);\n */\n__attribute__((format (printf, 2, 3)))\nextern void write_file(const char *path, const char *fmt, ...);\n\n/* pager.c */\nextern void setup_pager(void);\nextern int pager_in_use(void);\nextern int pager_use_color;\nextern int term_columns(void);\nextern int decimal_width(uintmax_t);\nextern int check_pager_config(const char *cmd);\nextern void prepare_pager_args(struct child_process *, const char *pager);\n\nextern const char *editor_program;\nextern const char *askpass_program;\nextern const char *excludes_file;\n\n/* base85 */\nint decode_85(char *dst, const char *line, int linelen);\nvoid encode_85(char *buf, const unsigned char *data, int bytes);\n\n/* alloc.c */\nextern void *alloc_blob_node(void);\nextern void *alloc_tree_node(void);\nextern void *alloc_commit_node(void);\nextern void *alloc_tag_node(void);\nextern void *alloc_object_node(void);\nextern void alloc_report(void);\nextern unsigned int alloc_commit_index(void);\n\n/* pkt-line.c */\nvoid packet_trace_identity(const char *prog);\n\n/* add */\n/*\n * return 0 if success, 1 - if addition of a file failed and\n * ADD_FILES_IGNORE_ERRORS was specified in flags\n */\nint add_files_to_cache(const char *prefix, const struct pathspec *pathspec, int flags);\n\n/* diff.c */\nextern int diff_auto_refresh_index;\n\n/* match-trees.c */\nvoid shift_tree(const struct object_id *, const struct object_id *, struct object_id *, int);\nvoid shift_tree_by(const struct object_id *, const struct object_id *, struct object_id *, const char *);\n\n/*\n * whitespace rules.\n * used by both diff and apply\n * last two digits are tab width\n */\n#define WS_BLANK_AT_EOL         0100\n#define WS_SPACE_BEFORE_TAB     0200\n#define WS_INDENT_WITH_NON_TAB  0400\n#define WS_CR_AT_EOL           01000\n#define WS_BLANK_AT_EOF        02000\n#define WS_TAB_IN_INDENT       04000\n#define WS_TRAILING_SPACE      (WS_BLANK_AT_EOL|WS_BLANK_AT_EOF)\n#define WS_DEFAULT_RULE (WS_TRAILING_SPACE|WS_SPACE_BEFORE_TAB|8)\n#define WS_TAB_WIDTH_MASK        077\n/* All WS_* -- when extended, adapt diff.c emit_symbol */\n#define WS_RULE_MASK           07777\nextern unsigned whitespace_rule_cfg;\nextern unsigned whitespace_rule(const char *);\nextern unsigned parse_whitespace_rule(const char *);\nextern unsigned ws_check(const char *line, int len, unsigned ws_rule);\nextern void ws_check_emit(const char *line, int len, unsigned ws_rule, FILE *stream, const char *set, const char *reset, const char *ws);\nextern char *whitespace_error_string(unsigned ws);\nextern void ws_fix_copy(struct strbuf *, const char *, int, unsigned, int *);\nextern int ws_blank_line(const char *line, int len, unsigned ws_rule);\n#define ws_tab_width(rule)     ((rule) & WS_TAB_WIDTH_MASK)\n\n/* ls-files */\nvoid overlay_tree_on_index(struct index_state *istate,\n\t\t\t   const char *tree_name, const char *prefix);\n\nchar *alias_lookup(const char *alias);\nint split_cmdline(char *cmdline, const char ***argv);\n/* Takes a negative value returned by split_cmdline */\nconst char *split_cmdline_strerror(int cmdline_errno);\n\n/* setup.c */\nstruct startup_info {\n\tint have_repository;\n\tconst char *prefix;\n};\nextern struct startup_info *startup_info;\n\n/* merge.c */\nstruct commit_list;\nint try_merge_command(const char *strategy, size_t xopts_nr,\n\t\tconst char **xopts, struct commit_list *common,\n\t\tconst char *head_arg, struct commit_list *remotes);\nint checkout_fast_forward(const struct object_id *from,\n\t\t\t  const struct object_id *to,\n\t\t\t  int overwrite_ignore);\n\n\nint sane_execvp(const char *file, char *const argv[]);\n\n/*\n * A struct to encapsulate the concept of whether a file has changed\n * since we last checked it. This uses criteria similar to those used\n * for the index.\n */\nstruct stat_validity {\n\tstruct stat_data *sd;\n};\n\nvoid stat_validity_clear(struct stat_validity *sv);\n\n/*\n * Returns 1 if the path is a regular file (or a symlink to a regular\n * file) and matches the saved stat_validity, 0 otherwise.  A missing\n * or inaccessible file is considered a match if the struct was just\n * initialized, or if the previous update found an inaccessible file.\n */\nint stat_validity_check(struct stat_validity *sv, const char *path);\n\n/*\n * Update the stat_validity from a file opened at descriptor fd. If\n * the file is missing, inaccessible, or not a regular file, then\n * future calls to stat_validity_check will match iff one of those\n * conditions continues to be true.\n */\nvoid stat_validity_update(struct stat_validity *sv, int fd);\n\nint versioncmp(const char *s1, const char *s2);\nvoid sleep_millisec(int millisec);\n\n/*\n * Create a directory and (if share is nonzero) adjust its permissions\n * according to the shared_repository setting. Only use this for\n * directories under $GIT_DIR.  Don't use it for working tree\n * directories.\n */\nvoid safe_create_dir(const char *dir, int share);\n\n/*\n * Should we print an ellipsis after an abbreviated SHA-1 value\n * when doing diff-raw output or indicating a detached HEAD?\n */\nextern int print_sha1_ellipsis(void);\n\n#endif /* CACHE_H */\n", "#include \"../git-compat-util.h\"\n#include \"win32.h\"\n#include <conio.h>\n#include <wchar.h>\n#include \"../strbuf.h\"\n#include \"../run-command.h\"\n#include \"../cache.h\"\n\n#define HCAST(type, handle) ((type)(intptr_t)handle)\n\nstatic const int delay[] = { 0, 1, 10, 20, 40 };\n\nint err_win_to_posix(DWORD winerr)\n{\n\tint error = ENOSYS;\n\tswitch(winerr) {\n\tcase ERROR_ACCESS_DENIED: error = EACCES; break;\n\tcase ERROR_ACCOUNT_DISABLED: error = EACCES; break;\n\tcase ERROR_ACCOUNT_RESTRICTION: error = EACCES; break;\n\tcase ERROR_ALREADY_ASSIGNED: error = EBUSY; break;\n\tcase ERROR_ALREADY_EXISTS: error = EEXIST; break;\n\tcase ERROR_ARITHMETIC_OVERFLOW: error = ERANGE; break;\n\tcase ERROR_BAD_COMMAND: error = EIO; break;\n\tcase ERROR_BAD_DEVICE: error = ENODEV; break;\n\tcase ERROR_BAD_DRIVER_LEVEL: error = ENXIO; break;\n\tcase ERROR_BAD_EXE_FORMAT: error = ENOEXEC; break;\n\tcase ERROR_BAD_FORMAT: error = ENOEXEC; break;\n\tcase ERROR_BAD_LENGTH: error = EINVAL; break;\n\tcase ERROR_BAD_PATHNAME: error = ENOENT; break;\n\tcase ERROR_BAD_PIPE: error = EPIPE; break;\n\tcase ERROR_BAD_UNIT: error = ENODEV; break;\n\tcase ERROR_BAD_USERNAME: error = EINVAL; break;\n\tcase ERROR_BROKEN_PIPE: error = EPIPE; break;\n\tcase ERROR_BUFFER_OVERFLOW: error = ENAMETOOLONG; break;\n\tcase ERROR_BUSY: error = EBUSY; break;\n\tcase ERROR_BUSY_DRIVE: error = EBUSY; break;\n\tcase ERROR_CALL_NOT_IMPLEMENTED: error = ENOSYS; break;\n\tcase ERROR_CANNOT_MAKE: error = EACCES; break;\n\tcase ERROR_CANTOPEN: error = EIO; break;\n\tcase ERROR_CANTREAD: error = EIO; break;\n\tcase ERROR_CANTWRITE: error = EIO; break;\n\tcase ERROR_CRC: error = EIO; break;\n\tcase ERROR_CURRENT_DIRECTORY: error = EACCES; break;\n\tcase ERROR_DEVICE_IN_USE: error = EBUSY; break;\n\tcase ERROR_DEV_NOT_EXIST: error = ENODEV; break;\n\tcase ERROR_DIRECTORY: error = EINVAL; break;\n\tcase ERROR_DIR_NOT_EMPTY: error = ENOTEMPTY; break;\n\tcase ERROR_DISK_CHANGE: error = EIO; break;\n\tcase ERROR_DISK_FULL: error = ENOSPC; break;\n\tcase ERROR_DRIVE_LOCKED: error = EBUSY; break;\n\tcase ERROR_ENVVAR_NOT_FOUND: error = EINVAL; break;\n\tcase ERROR_EXE_MARKED_INVALID: error = ENOEXEC; break;\n\tcase ERROR_FILENAME_EXCED_RANGE: error = ENAMETOOLONG; break;\n\tcase ERROR_FILE_EXISTS: error = EEXIST; break;\n\tcase ERROR_FILE_INVALID: error = ENODEV; break;\n\tcase ERROR_FILE_NOT_FOUND: error = ENOENT; break;\n\tcase ERROR_GEN_FAILURE: error = EIO; break;\n\tcase ERROR_HANDLE_DISK_FULL: error = ENOSPC; break;\n\tcase ERROR_INSUFFICIENT_BUFFER: error = ENOMEM; break;\n\tcase ERROR_INVALID_ACCESS: error = EACCES; break;\n\tcase ERROR_INVALID_ADDRESS: error = EFAULT; break;\n\tcase ERROR_INVALID_BLOCK: error = EFAULT; break;\n\tcase ERROR_INVALID_DATA: error = EINVAL; break;\n\tcase ERROR_INVALID_DRIVE: error = ENODEV; break;\n\tcase ERROR_INVALID_EXE_SIGNATURE: error = ENOEXEC; break;\n\tcase ERROR_INVALID_FLAGS: error = EINVAL; break;\n\tcase ERROR_INVALID_FUNCTION: error = ENOSYS; break;\n\tcase ERROR_INVALID_HANDLE: error = EBADF; break;\n\tcase ERROR_INVALID_LOGON_HOURS: error = EACCES; break;\n\tcase ERROR_INVALID_NAME: error = EINVAL; break;\n\tcase ERROR_INVALID_OWNER: error = EINVAL; break;\n\tcase ERROR_INVALID_PARAMETER: error = EINVAL; break;\n\tcase ERROR_INVALID_PASSWORD: error = EPERM; break;\n\tcase ERROR_INVALID_PRIMARY_GROUP: error = EINVAL; break;\n\tcase ERROR_INVALID_SIGNAL_NUMBER: error = EINVAL; break;\n\tcase ERROR_INVALID_TARGET_HANDLE: error = EIO; break;\n\tcase ERROR_INVALID_WORKSTATION: error = EACCES; break;\n\tcase ERROR_IO_DEVICE: error = EIO; break;\n\tcase ERROR_IO_INCOMPLETE: error = EINTR; break;\n\tcase ERROR_LOCKED: error = EBUSY; break;\n\tcase ERROR_LOCK_VIOLATION: error = EACCES; break;\n\tcase ERROR_LOGON_FAILURE: error = EACCES; break;\n\tcase ERROR_MAPPED_ALIGNMENT: error = EINVAL; break;\n\tcase ERROR_META_EXPANSION_TOO_LONG: error = E2BIG; break;\n\tcase ERROR_MORE_DATA: error = EPIPE; break;\n\tcase ERROR_NEGATIVE_SEEK: error = ESPIPE; break;\n\tcase ERROR_NOACCESS: error = EFAULT; break;\n\tcase ERROR_NONE_MAPPED: error = EINVAL; break;\n\tcase ERROR_NOT_ENOUGH_MEMORY: error = ENOMEM; break;\n\tcase ERROR_NOT_READY: error = EAGAIN; break;\n\tcase ERROR_NOT_SAME_DEVICE: error = EXDEV; break;\n\tcase ERROR_NO_DATA: error = EPIPE; break;\n\tcase ERROR_NO_MORE_SEARCH_HANDLES: error = EIO; break;\n\tcase ERROR_NO_PROC_SLOTS: error = EAGAIN; break;\n\tcase ERROR_NO_SUCH_PRIVILEGE: error = EACCES; break;\n\tcase ERROR_OPEN_FAILED: error = EIO; break;\n\tcase ERROR_OPEN_FILES: error = EBUSY; break;\n\tcase ERROR_OPERATION_ABORTED: error = EINTR; break;\n\tcase ERROR_OUTOFMEMORY: error = ENOMEM; break;\n\tcase ERROR_PASSWORD_EXPIRED: error = EACCES; break;\n\tcase ERROR_PATH_BUSY: error = EBUSY; break;\n\tcase ERROR_PATH_NOT_FOUND: error = ENOENT; break;\n\tcase ERROR_PIPE_BUSY: error = EBUSY; break;\n\tcase ERROR_PIPE_CONNECTED: error = EPIPE; break;\n\tcase ERROR_PIPE_LISTENING: error = EPIPE; break;\n\tcase ERROR_PIPE_NOT_CONNECTED: error = EPIPE; break;\n\tcase ERROR_PRIVILEGE_NOT_HELD: error = EACCES; break;\n\tcase ERROR_READ_FAULT: error = EIO; break;\n\tcase ERROR_SEEK: error = EIO; break;\n\tcase ERROR_SEEK_ON_DEVICE: error = ESPIPE; break;\n\tcase ERROR_SHARING_BUFFER_EXCEEDED: error = ENFILE; break;\n\tcase ERROR_SHARING_VIOLATION: error = EACCES; break;\n\tcase ERROR_STACK_OVERFLOW: error = ENOMEM; break;\n\tcase ERROR_SWAPERROR: error = ENOENT; break;\n\tcase ERROR_TOO_MANY_MODULES: error = EMFILE; break;\n\tcase ERROR_TOO_MANY_OPEN_FILES: error = EMFILE; break;\n\tcase ERROR_UNRECOGNIZED_MEDIA: error = ENXIO; break;\n\tcase ERROR_UNRECOGNIZED_VOLUME: error = ENODEV; break;\n\tcase ERROR_WAIT_NO_CHILDREN: error = ECHILD; break;\n\tcase ERROR_WRITE_FAULT: error = EIO; break;\n\tcase ERROR_WRITE_PROTECT: error = EROFS; break;\n\t}\n\treturn error;\n}\n\nstatic inline int is_file_in_use_error(DWORD errcode)\n{\n\tswitch (errcode) {\n\tcase ERROR_SHARING_VIOLATION:\n\tcase ERROR_ACCESS_DENIED:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_yes_no_answer(void)\n{\n\tchar answer[1024];\n\n\tif (fgets(answer, sizeof(answer), stdin)) {\n\t\tsize_t answer_len = strlen(answer);\n\t\tint got_full_line = 0, c;\n\n\t\t/* remove the newline */\n\t\tif (answer_len >= 2 && answer[answer_len-2] == '\\r') {\n\t\t\tanswer[answer_len-2] = '\\0';\n\t\t\tgot_full_line = 1;\n\t\t} else if (answer_len >= 1 && answer[answer_len-1] == '\\n') {\n\t\t\tanswer[answer_len-1] = '\\0';\n\t\t\tgot_full_line = 1;\n\t\t}\n\t\t/* flush the buffer in case we did not get the full line */\n\t\tif (!got_full_line)\n\t\t\twhile ((c = getchar()) != EOF && c != '\\n')\n\t\t\t\t;\n\t} else\n\t\t/* we could not read, return the\n\t\t * default answer which is no */\n\t\treturn 0;\n\n\tif (tolower(answer[0]) == 'y' && !answer[1])\n\t\treturn 1;\n\tif (!strncasecmp(answer, \"yes\", sizeof(answer)))\n\t\treturn 1;\n\tif (tolower(answer[0]) == 'n' && !answer[1])\n\t\treturn 0;\n\tif (!strncasecmp(answer, \"no\", sizeof(answer)))\n\t\treturn 0;\n\n\t/* did not find an answer we understand */\n\treturn -1;\n}\n\nstatic int ask_yes_no_if_possible(const char *format, ...)\n{\n\tchar question[4096];\n\tconst char *retry_hook[] = { NULL, NULL, NULL };\n\tva_list args;\n\n\tva_start(args, format);\n\tvsnprintf(question, sizeof(question), format, args);\n\tva_end(args);\n\n\tif ((retry_hook[0] = mingw_getenv(\"GIT_ASK_YESNO\"))) {\n\t\tretry_hook[1] = question;\n\t\treturn !run_command_v_opt(retry_hook, 0);\n\t}\n\n\tif (!isatty(_fileno(stdin)) || !isatty(_fileno(stderr)))\n\t\treturn 0;\n\n\twhile (1) {\n\t\tint answer;\n\t\tfprintf(stderr, \"%s (y/n) \", question);\n\n\t\tif ((answer = read_yes_no_answer()) >= 0)\n\t\t\treturn answer;\n\n\t\tfprintf(stderr, \"Sorry, I did not understand your answer. \"\n\t\t\t\t\"Please type 'y' or 'n'\\n\");\n\t}\n}\n\nint mingw_unlink(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\n\t/* read-only files cannot be removed */\n\t_wchmod(wpathname, 0666);\n\twhile ((ret = _wunlink(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\tbreak;\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Unlink of file '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wunlink(wpathname);\n\treturn ret;\n}\n\nstatic int is_dir_empty(const wchar_t *wpath)\n{\n\tWIN32_FIND_DATAW findbuf;\n\tHANDLE handle;\n\twchar_t wbuf[MAX_PATH + 2];\n\twcscpy(wbuf, wpath);\n\twcscat(wbuf, L\"\\\\*\");\n\thandle = FindFirstFileW(wbuf, &findbuf);\n\tif (handle == INVALID_HANDLE_VALUE)\n\t\treturn GetLastError() == ERROR_NO_MORE_FILES;\n\n\twhile (!wcscmp(findbuf.cFileName, L\".\") ||\n\t\t\t!wcscmp(findbuf.cFileName, L\"..\"))\n\t\tif (!FindNextFileW(handle, &findbuf)) {\n\t\t\tDWORD err = GetLastError();\n\t\t\tFindClose(handle);\n\t\t\treturn err == ERROR_NO_MORE_FILES;\n\t\t}\n\tFindClose(handle);\n\treturn 0;\n}\n\nint mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}\n\nstatic inline int needs_hiding(const char *path)\n{\n\tconst char *basename;\n\n\tif (hide_dotfiles == HIDE_DOTFILES_FALSE)\n\t\treturn 0;\n\n\t/* We cannot use basename(), as it would remove trailing slashes */\n\tmingw_skip_dos_drive_prefix((char **)&path);\n\tif (!*path)\n\t\treturn 0;\n\n\tfor (basename = path; *path; path++)\n\t\tif (is_dir_sep(*path)) {\n\t\t\tdo {\n\t\t\t\tpath++;\n\t\t\t} while (is_dir_sep(*path));\n\t\t\t/* ignore trailing slashes */\n\t\t\tif (*path)\n\t\t\t\tbasename = path;\n\t\t}\n\n\tif (hide_dotfiles == HIDE_DOTFILES_TRUE)\n\t\treturn *basename == '.';\n\n\tassert(hide_dotfiles == HIDE_DOTFILES_DOTGITONLY);\n\treturn !strncasecmp(\".git\", basename, 4) &&\n\t\t(!basename[4] || is_dir_sep(basename[4]));\n}\n\nstatic int set_hidden_flag(const wchar_t *path, int set)\n{\n\tDWORD original = GetFileAttributesW(path), modified;\n\tif (set)\n\t\tmodified = original | FILE_ATTRIBUTE_HIDDEN;\n\telse\n\t\tmodified = original & ~FILE_ATTRIBUTE_HIDDEN;\n\tif (original == modified || SetFileAttributesW(path, modified))\n\t\treturn 0;\n\terrno = err_win_to_posix(GetLastError());\n\treturn -1;\n}\n\nint mingw_mkdir(const char *path, int mode)\n{\n\tint ret;\n\twchar_t wpath[MAX_PATH];\n\n\tif (!is_valid_win32_path(path)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (xutftowcs_path(wpath, path) < 0)\n\t\treturn -1;\n\tret = _wmkdir(wpath);\n\tif (!ret && needs_hiding(path))\n\t\treturn set_hidden_flag(wpath, 1);\n\treturn ret;\n}\n\nint mingw_open (const char *filename, int oflags, ...)\n{\n\tva_list args;\n\tunsigned mode;\n\tint fd, create = (oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL);\n\twchar_t wfilename[MAX_PATH];\n\n\tva_start(args, oflags);\n\tmode = va_arg(args, int);\n\tva_end(args);\n\n\tif (!is_valid_win32_path(filename)) {\n\t\terrno = create ? EINVAL : ENOENT;\n\t\treturn -1;\n\t}\n\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\n\tif (xutftowcs_path(wfilename, filename) < 0)\n\t\treturn -1;\n\tfd = _wopen(wfilename, oflags, mode);\n\n\tif (fd < 0 && (oflags & O_ACCMODE) != O_RDONLY && errno == EACCES) {\n\t\tDWORD attrs = GetFileAttributesW(wfilename);\n\t\tif (attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\terrno = EISDIR;\n\t}\n\tif ((oflags & O_CREAT) && needs_hiding(filename)) {\n\t\t/*\n\t\t * Internally, _wopen() uses the CreateFile() API which errors\n\t\t * out with an ERROR_ACCESS_DENIED if CREATE_ALWAYS was\n\t\t * specified and an already existing file's attributes do not\n\t\t * match *exactly*. As there is no mode or flag we can set that\n\t\t * would correspond to FILE_ATTRIBUTE_HIDDEN, let's just try\n\t\t * again *without* the O_CREAT flag (that corresponds to the\n\t\t * CREATE_ALWAYS flag of CreateFile()).\n\t\t */\n\t\tif (fd < 0 && errno == EACCES)\n\t\t\tfd = _wopen(wfilename, oflags & ~O_CREAT, mode);\n\t\tif (fd >= 0 && set_hidden_flag(wfilename, 1))\n\t\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\t}\n\treturn fd;\n}\n\nstatic BOOL WINAPI ctrl_ignore(DWORD type)\n{\n\treturn TRUE;\n}\n\n#undef fgetc\nint mingw_fgetc(FILE *stream)\n{\n\tint ch;\n\tif (!isatty(_fileno(stream)))\n\t\treturn fgetc(stream);\n\n\tSetConsoleCtrlHandler(ctrl_ignore, TRUE);\n\twhile (1) {\n\t\tch = fgetc(stream);\n\t\tif (ch != EOF || GetLastError() != ERROR_OPERATION_ABORTED)\n\t\t\tbreak;\n\n\t\t/* Ctrl+C was pressed, simulate SIGINT and retry */\n\t\tmingw_raise(SIGINT);\n\t}\n\tSetConsoleCtrlHandler(ctrl_ignore, FALSE);\n\treturn ch;\n}\n\n#undef fopen\nFILE *mingw_fopen (const char *filename, const char *otype)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (!is_valid_win32_path(filename)) {\n\t\tint create = otype && strchr(otype, 'w');\n\t\terrno = create ? EINVAL : ENOENT;\n\t\treturn NULL;\n\t}\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfopen(wfilename, wotype);\n\tif (!file && GetLastError() == ERROR_INVALID_NAME)\n\t\terrno = ENOENT;\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}\n\nFILE *mingw_freopen (const char *filename, const char *otype, FILE *stream)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (!is_valid_win32_path(filename)) {\n\t\tint create = otype && strchr(otype, 'w');\n\t\terrno = create ? EINVAL : ENOENT;\n\t\treturn NULL;\n\t}\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfreopen(wfilename, wotype, stream);\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}\n\n#undef fflush\nint mingw_fflush(FILE *stream)\n{\n\tint ret = fflush(stream);\n\n\t/*\n\t * write() is used behind the scenes of stdio output functions.\n\t * Since git code does not check for errors after each stdio write\n\t * operation, it can happen that write() is called by a later\n\t * stdio function even if an earlier write() call failed. In the\n\t * case of a pipe whose readable end was closed, only the first\n\t * call to write() reports EPIPE on Windows. Subsequent write()\n\t * calls report EINVAL. It is impossible to notice whether this\n\t * fflush invocation triggered such a case, therefore, we have to\n\t * catch all EINVAL errors whole-sale.\n\t */\n\tif (ret && errno == EINVAL)\n\t\terrno = EPIPE;\n\n\treturn ret;\n}\n\n#undef write\nssize_t mingw_write(int fd, const void *buf, size_t len)\n{\n\tssize_t result = write(fd, buf, len);\n\n\tif (result < 0 && errno == EINVAL && buf) {\n\t\t/* check if fd is a pipe */\n\t\tHANDLE h = (HANDLE) _get_osfhandle(fd);\n\t\tif (GetFileType(h) == FILE_TYPE_PIPE)\n\t\t\terrno = EPIPE;\n\t\telse\n\t\t\terrno = EINVAL;\n\t}\n\n\treturn result;\n}\n\nint mingw_access(const char *filename, int mode)\n{\n\twchar_t wfilename[MAX_PATH];\n\tif (xutftowcs_path(wfilename, filename) < 0)\n\t\treturn -1;\n\t/* X_OK is not supported by the MSVCRT version */\n\treturn _waccess(wfilename, mode & ~X_OK);\n}\n\nint mingw_chdir(const char *dirname)\n{\n\twchar_t wdirname[MAX_PATH];\n\tif (xutftowcs_path(wdirname, dirname) < 0)\n\t\treturn -1;\n\treturn _wchdir(wdirname);\n}\n\nint mingw_chmod(const char *filename, int mode)\n{\n\twchar_t wfilename[MAX_PATH];\n\tif (xutftowcs_path(wfilename, filename) < 0)\n\t\treturn -1;\n\treturn _wchmod(wfilename, mode);\n}\n\n/*\n * The unit of FILETIME is 100-nanoseconds since January 1, 1601, UTC.\n * Returns the 100-nanoseconds (\"hekto nanoseconds\") since the epoch.\n */\nstatic inline long long filetime_to_hnsec(const FILETIME *ft)\n{\n\tlong long winTime = ((long long)ft->dwHighDateTime << 32) + ft->dwLowDateTime;\n\t/* Windows to Unix Epoch conversion */\n\treturn winTime - 116444736000000000LL;\n}\n\nstatic inline time_t filetime_to_time_t(const FILETIME *ft)\n{\n\treturn (time_t)(filetime_to_hnsec(ft) / 10000000);\n}\n\n/**\n * Verifies that safe_create_leading_directories() would succeed.\n */\nstatic int has_valid_directory_prefix(wchar_t *wfilename)\n{\n\tint n = wcslen(wfilename);\n\n\twhile (n > 0) {\n\t\twchar_t c = wfilename[--n];\n\t\tDWORD attributes;\n\n\t\tif (!is_dir_sep(c))\n\t\t\tcontinue;\n\n\t\twfilename[n] = L'\\0';\n\t\tattributes = GetFileAttributesW(wfilename);\n\t\twfilename[n] = c;\n\t\tif (attributes == FILE_ATTRIBUTE_DIRECTORY ||\n\t\t\t\tattributes == FILE_ATTRIBUTE_DEVICE)\n\t\t\treturn 1;\n\t\tif (attributes == INVALID_FILE_ATTRIBUTES)\n\t\t\tswitch (GetLastError()) {\n\t\t\tcase ERROR_PATH_NOT_FOUND:\n\t\t\t\tcontinue;\n\t\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\t\t/* This implies parent directory exists. */\n\t\t\t\treturn 1;\n\t\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* We keep the do_lstat code in a separate function to avoid recursion.\n * When a path ends with a slash, the stat will fail with ENOENT. In\n * this case, we strip the trailing slashes and stat again.\n *\n * If follow is true then act like stat() and report on the link\n * target. Otherwise report on the link itself.\n */\nstatic int do_lstat(int follow, const char *file_name, struct stat *buf)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\twchar_t wfilename[MAX_PATH];\n\tif (xutftowcs_path(wfilename, file_name) < 0)\n\t\treturn -1;\n\n\tif (GetFileAttributesExW(wfilename, GetFileExInfoStandard, &fdata)) {\n\t\tbuf->st_ino = 0;\n\t\tbuf->st_gid = 0;\n\t\tbuf->st_uid = 0;\n\t\tbuf->st_nlink = 1;\n\t\tbuf->st_mode = file_attr_to_st_mode(fdata.dwFileAttributes);\n\t\tbuf->st_size = fdata.nFileSizeLow |\n\t\t\t(((off_t)fdata.nFileSizeHigh)<<32);\n\t\tbuf->st_dev = buf->st_rdev = 0; /* not used by Git */\n\t\tbuf->st_atime = filetime_to_time_t(&(fdata.ftLastAccessTime));\n\t\tbuf->st_mtime = filetime_to_time_t(&(fdata.ftLastWriteTime));\n\t\tbuf->st_ctime = filetime_to_time_t(&(fdata.ftCreationTime));\n\t\tif (fdata.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {\n\t\t\tWIN32_FIND_DATAW findbuf;\n\t\t\tHANDLE handle = FindFirstFileW(wfilename, &findbuf);\n\t\t\tif (handle != INVALID_HANDLE_VALUE) {\n\t\t\t\tif ((findbuf.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&\n\t\t\t\t\t\t(findbuf.dwReserved0 == IO_REPARSE_TAG_SYMLINK)) {\n\t\t\t\t\tif (follow) {\n\t\t\t\t\t\tchar buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n\t\t\t\t\t\tbuf->st_size = readlink(file_name, buffer, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf->st_mode = S_IFLNK;\n\t\t\t\t\t}\n\t\t\t\t\tbuf->st_mode |= S_IREAD;\n\t\t\t\t\tif (!(findbuf.dwFileAttributes & FILE_ATTRIBUTE_READONLY))\n\t\t\t\t\t\tbuf->st_mode |= S_IWRITE;\n\t\t\t\t}\n\t\t\t\tFindClose(handle);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\tcase ERROR_SHARING_VIOLATION:\n\tcase ERROR_LOCK_VIOLATION:\n\tcase ERROR_SHARING_BUFFER_EXCEEDED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tcase ERROR_BUFFER_OVERFLOW:\n\t\terrno = ENAMETOOLONG;\n\t\tbreak;\n\tcase ERROR_NOT_ENOUGH_MEMORY:\n\t\terrno = ENOMEM;\n\t\tbreak;\n\tcase ERROR_PATH_NOT_FOUND:\n\t\tif (!has_valid_directory_prefix(wfilename)) {\n\t\t\terrno = ENOTDIR;\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthru */\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\n/* We provide our own lstat/fstat functions, since the provided\n * lstat/fstat functions are so slow. These stat functions are\n * tailored for Git's usage (read: fast), and are not meant to be\n * complete. Note that Git stat()s are redirected to mingw_lstat()\n * too, since Windows doesn't really handle symlinks that well.\n */\nstatic int do_stat_internal(int follow, const char *file_name, struct stat *buf)\n{\n\tint namelen;\n\tchar alt_name[PATH_MAX];\n\n\tif (!do_lstat(follow, file_name, buf))\n\t\treturn 0;\n\n\t/* if file_name ended in a '/', Windows returned ENOENT;\n\t * try again without trailing slashes\n\t */\n\tif (errno != ENOENT)\n\t\treturn -1;\n\n\tnamelen = strlen(file_name);\n\tif (namelen && file_name[namelen-1] != '/')\n\t\treturn -1;\n\twhile (namelen && file_name[namelen-1] == '/')\n\t\t--namelen;\n\tif (!namelen || namelen >= PATH_MAX)\n\t\treturn -1;\n\n\tmemcpy(alt_name, file_name, namelen);\n\talt_name[namelen] = 0;\n\treturn do_lstat(follow, alt_name, buf);\n}\n\nint mingw_lstat(const char *file_name, struct stat *buf)\n{\n\treturn do_stat_internal(0, file_name, buf);\n}\nint mingw_stat(const char *file_name, struct stat *buf)\n{\n\treturn do_stat_internal(1, file_name, buf);\n}\n\nint mingw_fstat(int fd, struct stat *buf)\n{\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\tBY_HANDLE_FILE_INFORMATION fdata;\n\n\tif (fh == INVALID_HANDLE_VALUE) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\t/* direct non-file handles to MS's fstat() */\n\tif (GetFileType(fh) != FILE_TYPE_DISK)\n\t\treturn _fstati64(fd, buf);\n\n\tif (GetFileInformationByHandle(fh, &fdata)) {\n\t\tbuf->st_ino = 0;\n\t\tbuf->st_gid = 0;\n\t\tbuf->st_uid = 0;\n\t\tbuf->st_nlink = 1;\n\t\tbuf->st_mode = file_attr_to_st_mode(fdata.dwFileAttributes);\n\t\tbuf->st_size = fdata.nFileSizeLow |\n\t\t\t(((off_t)fdata.nFileSizeHigh)<<32);\n\t\tbuf->st_dev = buf->st_rdev = 0; /* not used by Git */\n\t\tbuf->st_atime = filetime_to_time_t(&(fdata.ftLastAccessTime));\n\t\tbuf->st_mtime = filetime_to_time_t(&(fdata.ftLastWriteTime));\n\t\tbuf->st_ctime = filetime_to_time_t(&(fdata.ftCreationTime));\n\t\treturn 0;\n\t}\n\terrno = EBADF;\n\treturn -1;\n}\n\nstatic inline void time_t_to_filetime(time_t t, FILETIME *ft)\n{\n\tlong long winTime = t * 10000000LL + 116444736000000000LL;\n\tft->dwLowDateTime = winTime;\n\tft->dwHighDateTime = winTime >> 32;\n}\n\nint mingw_utime (const char *file_name, const struct utimbuf *times)\n{\n\tFILETIME mft, aft;\n\tint fh, rc;\n\tDWORD attrs;\n\twchar_t wfilename[MAX_PATH];\n\tif (xutftowcs_path(wfilename, file_name) < 0)\n\t\treturn -1;\n\n\t/* must have write permission */\n\tattrs = GetFileAttributesW(wfilename);\n\tif (attrs != INVALID_FILE_ATTRIBUTES &&\n\t    (attrs & FILE_ATTRIBUTE_READONLY)) {\n\t\t/* ignore errors here; open() will report them */\n\t\tSetFileAttributesW(wfilename, attrs & ~FILE_ATTRIBUTE_READONLY);\n\t}\n\n\tif ((fh = _wopen(wfilename, O_RDWR | O_BINARY)) < 0) {\n\t\trc = -1;\n\t\tgoto revert_attrs;\n\t}\n\n\tif (times) {\n\t\ttime_t_to_filetime(times->modtime, &mft);\n\t\ttime_t_to_filetime(times->actime, &aft);\n\t} else {\n\t\tGetSystemTimeAsFileTime(&mft);\n\t\taft = mft;\n\t}\n\tif (!SetFileTime((HANDLE)_get_osfhandle(fh), NULL, &aft, &mft)) {\n\t\terrno = EINVAL;\n\t\trc = -1;\n\t} else\n\t\trc = 0;\n\tclose(fh);\n\nrevert_attrs:\n\tif (attrs != INVALID_FILE_ATTRIBUTES &&\n\t    (attrs & FILE_ATTRIBUTE_READONLY)) {\n\t\t/* ignore errors again */\n\t\tSetFileAttributesW(wfilename, attrs);\n\t}\n\treturn rc;\n}\n\n#undef strftime\nsize_t mingw_strftime(char *s, size_t max,\n\t\t      const char *format, const struct tm *tm)\n{\n\tsize_t ret = strftime(s, max, format, tm);\n\n\tif (!ret && errno == EINVAL)\n\t\tdie(\"invalid strftime format: '%s'\", format);\n\treturn ret;\n}\n\nunsigned int sleep (unsigned int seconds)\n{\n\tSleep(seconds*1000);\n\treturn 0;\n}\n\nchar *mingw_mktemp(char *template)\n{\n\twchar_t wtemplate[MAX_PATH];\n\tif (xutftowcs_path(wtemplate, template) < 0)\n\t\treturn NULL;\n\tif (!_wmktemp(wtemplate))\n\t\treturn NULL;\n\tif (xwcstoutf(template, wtemplate, strlen(template) + 1) < 0)\n\t\treturn NULL;\n\treturn template;\n}\n\nint mkstemp(char *template)\n{\n\tchar *filename = mktemp(template);\n\tif (filename == NULL)\n\t\treturn -1;\n\treturn open(filename, O_RDWR | O_CREAT, 0600);\n}\n\nint gettimeofday(struct timeval *tv, void *tz)\n{\n\tFILETIME ft;\n\tlong long hnsec;\n\n\tGetSystemTimeAsFileTime(&ft);\n\thnsec = filetime_to_hnsec(&ft);\n\ttv->tv_sec = hnsec / 10000000;\n\ttv->tv_usec = (hnsec % 10000000) / 10;\n\treturn 0;\n}\n\nint pipe(int filedes[2])\n{\n\tHANDLE h[2];\n\n\t/* this creates non-inheritable handles */\n\tif (!CreatePipe(&h[0], &h[1], NULL, 8192)) {\n\t\terrno = err_win_to_posix(GetLastError());\n\t\treturn -1;\n\t}\n\tfiledes[0] = _open_osfhandle(HCAST(int, h[0]), O_NOINHERIT);\n\tif (filedes[0] < 0) {\n\t\tCloseHandle(h[0]);\n\t\tCloseHandle(h[1]);\n\t\treturn -1;\n\t}\n\tfiledes[1] = _open_osfhandle(HCAST(int, h[1]), O_NOINHERIT);\n\tif (filedes[1] < 0) {\n\t\tclose(filedes[0]);\n\t\tCloseHandle(h[1]);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstruct tm *gmtime_r(const time_t *timep, struct tm *result)\n{\n\t/* gmtime() in MSVCRT.DLL is thread-safe, but not reentrant */\n\tmemcpy(result, gmtime(timep), sizeof(struct tm));\n\treturn result;\n}\n\nstruct tm *localtime_r(const time_t *timep, struct tm *result)\n{\n\t/* localtime() in MSVCRT.DLL is thread-safe, but not reentrant */\n\tmemcpy(result, localtime(timep), sizeof(struct tm));\n\treturn result;\n}\n\nchar *mingw_getcwd(char *pointer, int len)\n{\n\twchar_t wpointer[MAX_PATH];\n\tif (!_wgetcwd(wpointer, ARRAY_SIZE(wpointer)))\n\t\treturn NULL;\n\tif (xwcstoutf(pointer, wpointer, len) < 0)\n\t\treturn NULL;\n\tconvert_slashes(pointer);\n\treturn pointer;\n}\n\n/*\n * See http://msdn2.microsoft.com/en-us/library/17w5ykft(vs.71).aspx\n * (Parsing C++ Command-Line Arguments)\n */\nstatic const char *quote_arg(const char *arg)\n{\n\t/* count chars to quote */\n\tint len = 0, n = 0;\n\tint force_quotes = 0;\n\tchar *q, *d;\n\tconst char *p = arg;\n\tif (!*p) force_quotes = 1;\n\twhile (*p) {\n\t\tif (isspace(*p) || *p == '*' || *p == '?' || *p == '{' || *p == '\\'')\n\t\t\tforce_quotes = 1;\n\t\telse if (*p == '\"')\n\t\t\tn++;\n\t\telse if (*p == '\\\\') {\n\t\t\tint count = 0;\n\t\t\twhile (*p == '\\\\') {\n\t\t\t\tcount++;\n\t\t\t\tp++;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (*p == '\"' || !*p)\n\t\t\t\tn += count*2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tlen++;\n\t\tp++;\n\t}\n\tif (!force_quotes && n == 0)\n\t\treturn arg;\n\n\t/* insert \\ where necessary */\n\td = q = xmalloc(st_add3(len, n, 3));\n\t*d++ = '\"';\n\twhile (*arg) {\n\t\tif (*arg == '\"')\n\t\t\t*d++ = '\\\\';\n\t\telse if (*arg == '\\\\') {\n\t\t\tint count = 0;\n\t\t\twhile (*arg == '\\\\') {\n\t\t\t\tcount++;\n\t\t\t\t*d++ = *arg++;\n\t\t\t}\n\t\t\tif (*arg == '\"' || !*arg) {\n\t\t\t\twhile (count-- > 0)\n\t\t\t\t\t*d++ = '\\\\';\n\t\t\t\t/* don't escape the surrounding end quote */\n\t\t\t\tif (!*arg)\n\t\t\t\t\tbreak;\n\t\t\t\t*d++ = '\\\\';\n\t\t\t}\n\t\t}\n\t\t*d++ = *arg++;\n\t}\n\t*d++ = '\"';\n\t*d++ = '\\0';\n\treturn q;\n}\n\nstatic const char *parse_interpreter(const char *cmd)\n{\n\tstatic char buf[100];\n\tchar *p, *opt;\n\tint n, fd;\n\n\t/* don't even try a .exe */\n\tn = strlen(cmd);\n\tif (n >= 4 && !strcasecmp(cmd+n-4, \".exe\"))\n\t\treturn NULL;\n\n\tfd = open(cmd, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\tn = read(fd, buf, sizeof(buf)-1);\n\tclose(fd);\n\tif (n < 4)\t/* at least '#!/x' and not error */\n\t\treturn NULL;\n\n\tif (buf[0] != '#' || buf[1] != '!')\n\t\treturn NULL;\n\tbuf[n] = '\\0';\n\tp = buf + strcspn(buf, \"\\r\\n\");\n\tif (!*p)\n\t\treturn NULL;\n\n\t*p = '\\0';\n\tif (!(p = strrchr(buf+2, '/')) && !(p = strrchr(buf+2, '\\\\')))\n\t\treturn NULL;\n\t/* strip options */\n\tif ((opt = strchr(p+1, ' ')))\n\t\t*opt = '\\0';\n\treturn p+1;\n}\n\n/*\n * exe_only means that we only want to detect .exe files, but not scripts\n * (which do not have an extension)\n */\nstatic char *lookup_prog(const char *dir, int dirlen, const char *cmd,\n\t\t\t int isexe, int exe_only)\n{\n\tchar path[MAX_PATH];\n\tsnprintf(path, sizeof(path), \"%.*s\\\\%s.exe\", dirlen, dir, cmd);\n\n\tif (!isexe && access(path, F_OK) == 0)\n\t\treturn xstrdup(path);\n\tpath[strlen(path)-4] = '\\0';\n\tif ((!exe_only || isexe) && access(path, F_OK) == 0)\n\t\tif (!(GetFileAttributes(path) & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\treturn xstrdup(path);\n\treturn NULL;\n}\n\n/*\n * Determines the absolute path of cmd using the split path in path.\n * If cmd contains a slash or backslash, no lookup is performed.\n */\nstatic char *path_lookup(const char *cmd, int exe_only)\n{\n\tconst char *path;\n\tchar *prog = NULL;\n\tint len = strlen(cmd);\n\tint isexe = len >= 4 && !strcasecmp(cmd+len-4, \".exe\");\n\n\tif (strchr(cmd, '/') || strchr(cmd, '\\\\'))\n\t\treturn xstrdup(cmd);\n\n\tpath = mingw_getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\twhile (!prog) {\n\t\tconst char *sep = strchrnul(path, ';');\n\t\tint dirlen = sep - path;\n\t\tif (dirlen)\n\t\t\tprog = lookup_prog(path, dirlen, cmd, isexe, exe_only);\n\t\tif (!*sep)\n\t\t\tbreak;\n\t\tpath = sep + 1;\n\t}\n\n\treturn prog;\n}\n\nstatic int do_putenv(char **env, const char *name, int size, int free_old);\n\n/* used number of elements of environ array, including terminating NULL */\nstatic int environ_size = 0;\n/* allocated size of environ array, in bytes */\nstatic int environ_alloc = 0;\n\n/*\n * Create environment block suitable for CreateProcess. Merges current\n * process environment and the supplied environment changes.\n */\nstatic wchar_t *make_environment_block(char **deltaenv)\n{\n\twchar_t *wenvblk = NULL;\n\tchar **tmpenv;\n\tint i = 0, size = environ_size, wenvsz = 0, wenvpos = 0;\n\n\twhile (deltaenv && deltaenv[i])\n\t\ti++;\n\n\t/* copy the environment, leaving space for changes */\n\tALLOC_ARRAY(tmpenv, size + i);\n\tmemcpy(tmpenv, environ, size * sizeof(char*));\n\n\t/* merge supplied environment changes into the temporary environment */\n\tfor (i = 0; deltaenv && deltaenv[i]; i++)\n\t\tsize = do_putenv(tmpenv, deltaenv[i], size, 0);\n\n\t/* create environment block from temporary environment */\n\tfor (i = 0; tmpenv[i]; i++) {\n\t\tsize = 2 * strlen(tmpenv[i]) + 2; /* +2 for final \\0 */\n\t\tALLOC_GROW(wenvblk, (wenvpos + size) * sizeof(wchar_t), wenvsz);\n\t\twenvpos += xutftowcs(&wenvblk[wenvpos], tmpenv[i], size) + 1;\n\t}\n\t/* add final \\0 terminator */\n\twenvblk[wenvpos] = 0;\n\tfree(tmpenv);\n\treturn wenvblk;\n}\n\nstruct pinfo_t {\n\tstruct pinfo_t *next;\n\tpid_t pid;\n\tHANDLE proc;\n};\nstatic struct pinfo_t *pinfo = NULL;\nCRITICAL_SECTION pinfo_cs;\n\nstatic pid_t mingw_spawnve_fd(const char *cmd, const char **argv, char **deltaenv,\n\t\t\t      const char *dir,\n\t\t\t      int prepend_cmd, int fhin, int fhout, int fherr)\n{\n\tSTARTUPINFOW si;\n\tPROCESS_INFORMATION pi;\n\tstruct strbuf args;\n\twchar_t wcmd[MAX_PATH], wdir[MAX_PATH], *wargs, *wenvblk = NULL;\n\tunsigned flags = CREATE_UNICODE_ENVIRONMENT;\n\tBOOL ret;\n\n\t/* Determine whether or not we are associated to a console */\n\tHANDLE cons = CreateFile(\"CONOUT$\", GENERIC_WRITE,\n\t\t\tFILE_SHARE_WRITE, NULL, OPEN_EXISTING,\n\t\t\tFILE_ATTRIBUTE_NORMAL, NULL);\n\tif (cons == INVALID_HANDLE_VALUE) {\n\t\t/* There is no console associated with this process.\n\t\t * Since the child is a console process, Windows\n\t\t * would normally create a console window. But\n\t\t * since we'll be redirecting std streams, we do\n\t\t * not need the console.\n\t\t * It is necessary to use DETACHED_PROCESS\n\t\t * instead of CREATE_NO_WINDOW to make ssh\n\t\t * recognize that it has no console.\n\t\t */\n\t\tflags |= DETACHED_PROCESS;\n\t} else {\n\t\t/* There is already a console. If we specified\n\t\t * DETACHED_PROCESS here, too, Windows would\n\t\t * disassociate the child from the console.\n\t\t * The same is true for CREATE_NO_WINDOW.\n\t\t * Go figure!\n\t\t */\n\t\tCloseHandle(cons);\n\t}\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\tsi.dwFlags = STARTF_USESTDHANDLES;\n\tsi.hStdInput = winansi_get_osfhandle(fhin);\n\tsi.hStdOutput = winansi_get_osfhandle(fhout);\n\tsi.hStdError = winansi_get_osfhandle(fherr);\n\n\tif (xutftowcs_path(wcmd, cmd) < 0)\n\t\treturn -1;\n\tif (dir && xutftowcs_path(wdir, dir) < 0)\n\t\treturn -1;\n\n\t/* concatenate argv, quoting args as we go */\n\tstrbuf_init(&args, 0);\n\tif (prepend_cmd) {\n\t\tchar *quoted = (char *)quote_arg(cmd);\n\t\tstrbuf_addstr(&args, quoted);\n\t\tif (quoted != cmd)\n\t\t\tfree(quoted);\n\t}\n\tfor (; *argv; argv++) {\n\t\tchar *quoted = (char *)quote_arg(*argv);\n\t\tif (*args.buf)\n\t\t\tstrbuf_addch(&args, ' ');\n\t\tstrbuf_addstr(&args, quoted);\n\t\tif (quoted != *argv)\n\t\t\tfree(quoted);\n\t}\n\n\tALLOC_ARRAY(wargs, st_add(st_mult(2, args.len), 1));\n\txutftowcs(wargs, args.buf, 2 * args.len + 1);\n\tstrbuf_release(&args);\n\n\twenvblk = make_environment_block(deltaenv);\n\n\tmemset(&pi, 0, sizeof(pi));\n\tret = CreateProcessW(wcmd, wargs, NULL, NULL, TRUE, flags,\n\t\twenvblk, dir ? wdir : NULL, &si, &pi);\n\n\tfree(wenvblk);\n\tfree(wargs);\n\n\tif (!ret) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\tCloseHandle(pi.hThread);\n\n\t/*\n\t * The process ID is the human-readable identifier of the process\n\t * that we want to present in log and error messages. The handle\n\t * is not useful for this purpose. But we cannot close it, either,\n\t * because it is not possible to turn a process ID into a process\n\t * handle after the process terminated.\n\t * Keep the handle in a list for waitpid.\n\t */\n\tEnterCriticalSection(&pinfo_cs);\n\t{\n\t\tstruct pinfo_t *info = xmalloc(sizeof(struct pinfo_t));\n\t\tinfo->pid = pi.dwProcessId;\n\t\tinfo->proc = pi.hProcess;\n\t\tinfo->next = pinfo;\n\t\tpinfo = info;\n\t}\n\tLeaveCriticalSection(&pinfo_cs);\n\n\treturn (pid_t)pi.dwProcessId;\n}\n\nstatic pid_t mingw_spawnv(const char *cmd, const char **argv, int prepend_cmd)\n{\n\treturn mingw_spawnve_fd(cmd, argv, NULL, NULL, prepend_cmd, 0, 1, 2);\n}\n\npid_t mingw_spawnvpe(const char *cmd, const char **argv, char **deltaenv,\n\t\t     const char *dir,\n\t\t     int fhin, int fhout, int fherr)\n{\n\tpid_t pid;\n\tchar *prog = path_lookup(cmd, 0);\n\n\tif (!prog) {\n\t\terrno = ENOENT;\n\t\tpid = -1;\n\t}\n\telse {\n\t\tconst char *interpr = parse_interpreter(prog);\n\n\t\tif (interpr) {\n\t\t\tconst char *argv0 = argv[0];\n\t\t\tchar *iprog = path_lookup(interpr, 1);\n\t\t\targv[0] = prog;\n\t\t\tif (!iprog) {\n\t\t\t\terrno = ENOENT;\n\t\t\t\tpid = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpid = mingw_spawnve_fd(iprog, argv, deltaenv, dir, 1,\n\t\t\t\t\t\t       fhin, fhout, fherr);\n\t\t\t\tfree(iprog);\n\t\t\t}\n\t\t\targv[0] = argv0;\n\t\t}\n\t\telse\n\t\t\tpid = mingw_spawnve_fd(prog, argv, deltaenv, dir, 0,\n\t\t\t\t\t       fhin, fhout, fherr);\n\t\tfree(prog);\n\t}\n\treturn pid;\n}\n\nstatic int try_shell_exec(const char *cmd, char *const *argv)\n{\n\tconst char *interpr = parse_interpreter(cmd);\n\tchar *prog;\n\tint pid = 0;\n\n\tif (!interpr)\n\t\treturn 0;\n\tprog = path_lookup(interpr, 1);\n\tif (prog) {\n\t\tint argc = 0;\n\t\tconst char **argv2;\n\t\twhile (argv[argc]) argc++;\n\t\tALLOC_ARRAY(argv2, argc + 1);\n\t\targv2[0] = (char *)cmd;\t/* full path to the script file */\n\t\tmemcpy(&argv2[1], &argv[1], sizeof(*argv) * argc);\n\t\tpid = mingw_spawnv(prog, argv2, 1);\n\t\tif (pid >= 0) {\n\t\t\tint status;\n\t\t\tif (waitpid(pid, &status, 0) < 0)\n\t\t\t\tstatus = 255;\n\t\t\texit(status);\n\t\t}\n\t\tpid = 1;\t/* indicate that we tried but failed */\n\t\tfree(prog);\n\t\tfree(argv2);\n\t}\n\treturn pid;\n}\n\nint mingw_execv(const char *cmd, char *const *argv)\n{\n\t/* check if git_command is a shell script */\n\tif (!try_shell_exec(cmd, argv)) {\n\t\tint pid, status;\n\n\t\tpid = mingw_spawnv(cmd, (const char **)argv, 0);\n\t\tif (pid < 0)\n\t\t\treturn -1;\n\t\tif (waitpid(pid, &status, 0) < 0)\n\t\t\tstatus = 255;\n\t\texit(status);\n\t}\n\treturn -1;\n}\n\nint mingw_execvp(const char *cmd, char *const *argv)\n{\n\tchar *prog = path_lookup(cmd, 0);\n\n\tif (prog) {\n\t\tmingw_execv(prog, argv);\n\t\tfree(prog);\n\t} else\n\t\terrno = ENOENT;\n\n\treturn -1;\n}\n\nint mingw_kill(pid_t pid, int sig)\n{\n\tif (pid > 0 && sig == SIGTERM) {\n\t\tHANDLE h = OpenProcess(PROCESS_TERMINATE, FALSE, pid);\n\n\t\tif (TerminateProcess(h, -1)) {\n\t\t\tCloseHandle(h);\n\t\t\treturn 0;\n\t\t}\n\n\t\terrno = err_win_to_posix(GetLastError());\n\t\tCloseHandle(h);\n\t\treturn -1;\n\t} else if (pid > 0 && sig == 0) {\n\t\tHANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);\n\t\tif (h) {\n\t\t\tCloseHandle(h);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\terrno = EINVAL;\n\treturn -1;\n}\n\n/*\n * Compare environment entries by key (i.e. stopping at '=' or '\\0').\n */\nstatic int compareenv(const void *v1, const void *v2)\n{\n\tconst char *e1 = *(const char**)v1;\n\tconst char *e2 = *(const char**)v2;\n\n\tfor (;;) {\n\t\tint c1 = *e1++;\n\t\tint c2 = *e2++;\n\t\tc1 = (c1 == '=') ? 0 : tolower(c1);\n\t\tc2 = (c2 == '=') ? 0 : tolower(c2);\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 == 0)\n\t\t\treturn 0;\n\t}\n}\n\nstatic int bsearchenv(char **env, const char *name, size_t size)\n{\n\tunsigned low = 0, high = size;\n\twhile (low < high) {\n\t\tunsigned mid = low + ((high - low) >> 1);\n\t\tint cmp = compareenv(&env[mid], &name);\n\t\tif (cmp < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (cmp > 0)\n\t\t\thigh = mid;\n\t\telse\n\t\t\treturn mid;\n\t}\n\treturn ~low; /* not found, return 1's complement of insert position */\n}\n\n/*\n * If name contains '=', then sets the variable, otherwise it unsets it\n * Size includes the terminating NULL. Env must have room for size + 1 entries\n * (in case of insert). Returns the new size. Optionally frees removed entries.\n */\nstatic int do_putenv(char **env, const char *name, int size, int free_old)\n{\n\tint i = bsearchenv(env, name, size - 1);\n\n\t/* optionally free removed / replaced entry */\n\tif (i >= 0 && free_old)\n\t\tfree(env[i]);\n\n\tif (strchr(name, '=')) {\n\t\t/* if new value ('key=value') is specified, insert or replace entry */\n\t\tif (i < 0) {\n\t\t\ti = ~i;\n\t\t\tmemmove(&env[i + 1], &env[i], (size - i) * sizeof(char*));\n\t\t\tsize++;\n\t\t}\n\t\tenv[i] = (char*) name;\n\t} else if (i >= 0) {\n\t\t/* otherwise ('key') remove existing entry */\n\t\tsize--;\n\t\tmemmove(&env[i], &env[i + 1], (size - i) * sizeof(char*));\n\t}\n\treturn size;\n}\n\nchar *mingw_getenv(const char *name)\n{\n\tchar *value;\n\tint pos = bsearchenv(environ, name, environ_size - 1);\n\tif (pos < 0)\n\t\treturn NULL;\n\tvalue = strchr(environ[pos], '=');\n\treturn value ? &value[1] : NULL;\n}\n\nint mingw_putenv(const char *namevalue)\n{\n\tALLOC_GROW(environ, (environ_size + 1) * sizeof(char*), environ_alloc);\n\tenviron_size = do_putenv(environ, namevalue, environ_size, 1);\n\treturn 0;\n}\n\n/*\n * Note, this isn't a complete replacement for getaddrinfo. It assumes\n * that service contains a numerical port, or that it is null. It\n * does a simple search using gethostbyname, and returns one IPv4 host\n * if one was found.\n */\nstatic int WSAAPI getaddrinfo_stub(const char *node, const char *service,\n\t\t\t\t   const struct addrinfo *hints,\n\t\t\t\t   struct addrinfo **res)\n{\n\tstruct hostent *h = NULL;\n\tstruct addrinfo *ai;\n\tstruct sockaddr_in *sin;\n\n\tif (node) {\n\t\th = gethostbyname(node);\n\t\tif (!h)\n\t\t\treturn WSAGetLastError();\n\t}\n\n\tai = xmalloc(sizeof(struct addrinfo));\n\t*res = ai;\n\tai->ai_flags = 0;\n\tai->ai_family = AF_INET;\n\tai->ai_socktype = hints ? hints->ai_socktype : 0;\n\tswitch (ai->ai_socktype) {\n\tcase SOCK_STREAM:\n\t\tai->ai_protocol = IPPROTO_TCP;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tai->ai_protocol = IPPROTO_UDP;\n\t\tbreak;\n\tdefault:\n\t\tai->ai_protocol = 0;\n\t\tbreak;\n\t}\n\tai->ai_addrlen = sizeof(struct sockaddr_in);\n\tif (hints && (hints->ai_flags & AI_CANONNAME))\n\t\tai->ai_canonname = h ? xstrdup(h->h_name) : NULL;\n\telse\n\t\tai->ai_canonname = NULL;\n\n\tsin = xcalloc(1, ai->ai_addrlen);\n\tsin->sin_family = AF_INET;\n\t/* Note: getaddrinfo is supposed to allow service to be a string,\n\t * which should be looked up using getservbyname. This is\n\t * currently not implemented */\n\tif (service)\n\t\tsin->sin_port = htons(atoi(service));\n\tif (h)\n\t\tsin->sin_addr = *(struct in_addr *)h->h_addr;\n\telse if (hints && (hints->ai_flags & AI_PASSIVE))\n\t\tsin->sin_addr.s_addr = INADDR_ANY;\n\telse\n\t\tsin->sin_addr.s_addr = INADDR_LOOPBACK;\n\tai->ai_addr = (struct sockaddr *)sin;\n\tai->ai_next = NULL;\n\treturn 0;\n}\n\nstatic void WSAAPI freeaddrinfo_stub(struct addrinfo *res)\n{\n\tfree(res->ai_canonname);\n\tfree(res->ai_addr);\n\tfree(res);\n}\n\nstatic int WSAAPI getnameinfo_stub(const struct sockaddr *sa, socklen_t salen,\n\t\t\t\t   char *host, DWORD hostlen,\n\t\t\t\t   char *serv, DWORD servlen, int flags)\n{\n\tconst struct sockaddr_in *sin = (const struct sockaddr_in *)sa;\n\tif (sa->sa_family != AF_INET)\n\t\treturn EAI_FAMILY;\n\tif (!host && !serv)\n\t\treturn EAI_NONAME;\n\n\tif (host && hostlen > 0) {\n\t\tstruct hostent *ent = NULL;\n\t\tif (!(flags & NI_NUMERICHOST))\n\t\t\tent = gethostbyaddr((const char *)&sin->sin_addr,\n\t\t\t\t\t    sizeof(sin->sin_addr), AF_INET);\n\n\t\tif (ent)\n\t\t\tsnprintf(host, hostlen, \"%s\", ent->h_name);\n\t\telse if (flags & NI_NAMEREQD)\n\t\t\treturn EAI_NONAME;\n\t\telse\n\t\t\tsnprintf(host, hostlen, \"%s\", inet_ntoa(sin->sin_addr));\n\t}\n\n\tif (serv && servlen > 0) {\n\t\tstruct servent *ent = NULL;\n\t\tif (!(flags & NI_NUMERICSERV))\n\t\t\tent = getservbyport(sin->sin_port,\n\t\t\t\t\t    flags & NI_DGRAM ? \"udp\" : \"tcp\");\n\n\t\tif (ent)\n\t\t\tsnprintf(serv, servlen, \"%s\", ent->s_name);\n\t\telse\n\t\t\tsnprintf(serv, servlen, \"%d\", ntohs(sin->sin_port));\n\t}\n\n\treturn 0;\n}\n\nstatic HMODULE ipv6_dll = NULL;\nstatic void (WSAAPI *ipv6_freeaddrinfo)(struct addrinfo *res);\nstatic int (WSAAPI *ipv6_getaddrinfo)(const char *node, const char *service,\n\t\t\t\t      const struct addrinfo *hints,\n\t\t\t\t      struct addrinfo **res);\nstatic int (WSAAPI *ipv6_getnameinfo)(const struct sockaddr *sa, socklen_t salen,\n\t\t\t\t      char *host, DWORD hostlen,\n\t\t\t\t      char *serv, DWORD servlen, int flags);\n/*\n * gai_strerror is an inline function in the ws2tcpip.h header, so we\n * don't need to try to load that one dynamically.\n */\n\nstatic void socket_cleanup(void)\n{\n\tWSACleanup();\n\tif (ipv6_dll)\n\t\tFreeLibrary(ipv6_dll);\n\tipv6_dll = NULL;\n\tipv6_freeaddrinfo = freeaddrinfo_stub;\n\tipv6_getaddrinfo = getaddrinfo_stub;\n\tipv6_getnameinfo = getnameinfo_stub;\n}\n\nstatic void ensure_socket_initialization(void)\n{\n\tWSADATA wsa;\n\tstatic int initialized = 0;\n\tconst char *libraries[] = { \"ws2_32.dll\", \"wship6.dll\", NULL };\n\tconst char **name;\n\n\tif (initialized)\n\t\treturn;\n\n\tif (WSAStartup(MAKEWORD(2,2), &wsa))\n\t\tdie(\"unable to initialize winsock subsystem, error %d\",\n\t\t\tWSAGetLastError());\n\n\tfor (name = libraries; *name; name++) {\n\t\tipv6_dll = LoadLibrary(*name);\n\t\tif (!ipv6_dll)\n\t\t\tcontinue;\n\n\t\tipv6_freeaddrinfo = (void (WSAAPI *)(struct addrinfo *))\n\t\t\tGetProcAddress(ipv6_dll, \"freeaddrinfo\");\n\t\tipv6_getaddrinfo = (int (WSAAPI *)(const char *, const char *,\n\t\t\t\t\t\t   const struct addrinfo *,\n\t\t\t\t\t\t   struct addrinfo **))\n\t\t\tGetProcAddress(ipv6_dll, \"getaddrinfo\");\n\t\tipv6_getnameinfo = (int (WSAAPI *)(const struct sockaddr *,\n\t\t\t\t\t\t   socklen_t, char *, DWORD,\n\t\t\t\t\t\t   char *, DWORD, int))\n\t\t\tGetProcAddress(ipv6_dll, \"getnameinfo\");\n\t\tif (!ipv6_freeaddrinfo || !ipv6_getaddrinfo || !ipv6_getnameinfo) {\n\t\t\tFreeLibrary(ipv6_dll);\n\t\t\tipv6_dll = NULL;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (!ipv6_freeaddrinfo || !ipv6_getaddrinfo || !ipv6_getnameinfo) {\n\t\tipv6_freeaddrinfo = freeaddrinfo_stub;\n\t\tipv6_getaddrinfo = getaddrinfo_stub;\n\t\tipv6_getnameinfo = getnameinfo_stub;\n\t}\n\n\tatexit(socket_cleanup);\n\tinitialized = 1;\n}\n\n#undef gethostname\nint mingw_gethostname(char *name, int namelen)\n{\n    ensure_socket_initialization();\n    return gethostname(name, namelen);\n}\n\n#undef gethostbyname\nstruct hostent *mingw_gethostbyname(const char *host)\n{\n\tensure_socket_initialization();\n\treturn gethostbyname(host);\n}\n\nvoid mingw_freeaddrinfo(struct addrinfo *res)\n{\n\tipv6_freeaddrinfo(res);\n}\n\nint mingw_getaddrinfo(const char *node, const char *service,\n\t\t      const struct addrinfo *hints, struct addrinfo **res)\n{\n\tensure_socket_initialization();\n\treturn ipv6_getaddrinfo(node, service, hints, res);\n}\n\nint mingw_getnameinfo(const struct sockaddr *sa, socklen_t salen,\n\t\t      char *host, DWORD hostlen, char *serv, DWORD servlen,\n\t\t      int flags)\n{\n\tensure_socket_initialization();\n\treturn ipv6_getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}\n\nint mingw_socket(int domain, int type, int protocol)\n{\n\tint sockfd;\n\tSOCKET s;\n\n\tensure_socket_initialization();\n\ts = WSASocket(domain, type, protocol, NULL, 0, 0);\n\tif (s == INVALID_SOCKET) {\n\t\t/*\n\t\t * WSAGetLastError() values are regular BSD error codes\n\t\t * biased by WSABASEERR.\n\t\t * However, strerror() does not know about networking\n\t\t * specific errors, which are values beginning at 38 or so.\n\t\t * Therefore, we choose to leave the biased error code\n\t\t * in errno so that _if_ someone looks up the code somewhere,\n\t\t * then it is at least the number that are usually listed.\n\t\t */\n\t\terrno = WSAGetLastError();\n\t\treturn -1;\n\t}\n\t/* convert into a file descriptor */\n\tif ((sockfd = _open_osfhandle(s, O_RDWR|O_BINARY)) < 0) {\n\t\tclosesocket(s);\n\t\treturn error(\"unable to make a socket file descriptor: %s\",\n\t\t\tstrerror(errno));\n\t}\n\treturn sockfd;\n}\n\n#undef connect\nint mingw_connect(int sockfd, struct sockaddr *sa, size_t sz)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn connect(s, sa, sz);\n}\n\n#undef bind\nint mingw_bind(int sockfd, struct sockaddr *sa, size_t sz)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn bind(s, sa, sz);\n}\n\n#undef setsockopt\nint mingw_setsockopt(int sockfd, int lvl, int optname, void *optval, int optlen)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn setsockopt(s, lvl, optname, (const char*)optval, optlen);\n}\n\n#undef shutdown\nint mingw_shutdown(int sockfd, int how)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn shutdown(s, how);\n}\n\n#undef listen\nint mingw_listen(int sockfd, int backlog)\n{\n\tSOCKET s = (SOCKET)_get_osfhandle(sockfd);\n\treturn listen(s, backlog);\n}\n\n#undef accept\nint mingw_accept(int sockfd1, struct sockaddr *sa, socklen_t *sz)\n{\n\tint sockfd2;\n\n\tSOCKET s1 = (SOCKET)_get_osfhandle(sockfd1);\n\tSOCKET s2 = accept(s1, sa, sz);\n\n\t/* convert into a file descriptor */\n\tif ((sockfd2 = _open_osfhandle(s2, O_RDWR|O_BINARY)) < 0) {\n\t\tint err = errno;\n\t\tclosesocket(s2);\n\t\treturn error(\"unable to make a socket file descriptor: %s\",\n\t\t\tstrerror(err));\n\t}\n\treturn sockfd2;\n}\n\n#undef rename\nint mingw_rename(const char *pold, const char *pnew)\n{\n\tDWORD attrs, gle;\n\tint tries = 0;\n\twchar_t wpold[MAX_PATH], wpnew[MAX_PATH];\n\tif (xutftowcs_path(wpold, pold) < 0 || xutftowcs_path(wpnew, pnew) < 0)\n\t\treturn -1;\n\n\t/*\n\t * Try native rename() first to get errno right.\n\t * It is based on MoveFile(), which cannot overwrite existing files.\n\t */\n\tif (!_wrename(wpold, wpnew))\n\t\treturn 0;\n\tif (errno != EEXIST)\n\t\treturn -1;\nrepeat:\n\tif (MoveFileExW(wpold, wpnew, MOVEFILE_REPLACE_EXISTING))\n\t\treturn 0;\n\t/* TODO: translate more errors */\n\tgle = GetLastError();\n\tif (gle == ERROR_ACCESS_DENIED &&\n\t    (attrs = GetFileAttributesW(wpnew)) != INVALID_FILE_ATTRIBUTES) {\n\t\tif (attrs & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t\tDWORD attrsold = GetFileAttributesW(wpold);\n\t\t\tif (attrsold == INVALID_FILE_ATTRIBUTES ||\n\t\t\t    !(attrsold & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\terrno = EISDIR;\n\t\t\telse if (!_wrmdir(wpnew))\n\t\t\t\tgoto repeat;\n\t\t\treturn -1;\n\t\t}\n\t\tif ((attrs & FILE_ATTRIBUTE_READONLY) &&\n\t\t    SetFileAttributesW(wpnew, attrs & ~FILE_ATTRIBUTE_READONLY)) {\n\t\t\tif (MoveFileExW(wpold, wpnew, MOVEFILE_REPLACE_EXISTING))\n\t\t\t\treturn 0;\n\t\t\tgle = GetLastError();\n\t\t\t/* revert file attributes on failure */\n\t\t\tSetFileAttributesW(wpnew, attrs);\n\t\t}\n\t}\n\tif (tries < ARRAY_SIZE(delay) && gle == ERROR_ACCESS_DENIED) {\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t\tgoto repeat;\n\t}\n\tif (gle == ERROR_ACCESS_DENIED &&\n\t       ask_yes_no_if_possible(\"Rename from '%s' to '%s' failed. \"\n\t\t       \"Should I try again?\", pold, pnew))\n\t\tgoto repeat;\n\n\terrno = EACCES;\n\treturn -1;\n}\n\n/*\n * Note that this doesn't return the actual pagesize, but\n * the allocation granularity. If future Windows specific git code\n * needs the real getpagesize function, we need to find another solution.\n */\nint mingw_getpagesize(void)\n{\n\tSYSTEM_INFO si;\n\tGetSystemInfo(&si);\n\treturn si.dwAllocationGranularity;\n}\n\nstruct passwd *getpwuid(int uid)\n{\n\tstatic char user_name[100];\n\tstatic struct passwd p;\n\n\tDWORD len = sizeof(user_name);\n\tif (!GetUserName(user_name, &len))\n\t\treturn NULL;\n\tp.pw_name = user_name;\n\tp.pw_gecos = \"unknown\";\n\tp.pw_dir = NULL;\n\treturn &p;\n}\n\nstatic HANDLE timer_event;\nstatic HANDLE timer_thread;\nstatic int timer_interval;\nstatic int one_shot;\nstatic sig_handler_t timer_fn = SIG_DFL, sigint_fn = SIG_DFL;\n\n/* The timer works like this:\n * The thread, ticktack(), is a trivial routine that most of the time\n * only waits to receive the signal to terminate. The main thread tells\n * the thread to terminate by setting the timer_event to the signalled\n * state.\n * But ticktack() interrupts the wait state after the timer's interval\n * length to call the signal handler.\n */\n\nstatic unsigned __stdcall ticktack(void *dummy)\n{\n\twhile (WaitForSingleObject(timer_event, timer_interval) == WAIT_TIMEOUT) {\n\t\tmingw_raise(SIGALRM);\n\t\tif (one_shot)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int start_timer_thread(void)\n{\n\ttimer_event = CreateEvent(NULL, FALSE, FALSE, NULL);\n\tif (timer_event) {\n\t\ttimer_thread = (HANDLE) _beginthreadex(NULL, 0, ticktack, NULL, 0, NULL);\n\t\tif (!timer_thread )\n\t\t\treturn errno = ENOMEM,\n\t\t\t\terror(\"cannot start timer thread\");\n\t} else\n\t\treturn errno = ENOMEM,\n\t\t\terror(\"cannot allocate resources for timer\");\n\treturn 0;\n}\n\nstatic void stop_timer_thread(void)\n{\n\tif (timer_event)\n\t\tSetEvent(timer_event);\t/* tell thread to terminate */\n\tif (timer_thread) {\n\t\tint rc = WaitForSingleObject(timer_thread, 1000);\n\t\tif (rc == WAIT_TIMEOUT)\n\t\t\terror(\"timer thread did not terminate timely\");\n\t\telse if (rc != WAIT_OBJECT_0)\n\t\t\terror(\"waiting for timer thread failed: %lu\",\n\t\t\t      GetLastError());\n\t\tCloseHandle(timer_thread);\n\t}\n\tif (timer_event)\n\t\tCloseHandle(timer_event);\n\ttimer_event = NULL;\n\ttimer_thread = NULL;\n}\n\nstatic inline int is_timeval_eq(const struct timeval *i1, const struct timeval *i2)\n{\n\treturn i1->tv_sec == i2->tv_sec && i1->tv_usec == i2->tv_usec;\n}\n\nint setitimer(int type, struct itimerval *in, struct itimerval *out)\n{\n\tstatic const struct timeval zero;\n\tstatic int atexit_done;\n\n\tif (out != NULL)\n\t\treturn errno = EINVAL,\n\t\t\terror(\"setitimer param 3 != NULL not implemented\");\n\tif (!is_timeval_eq(&in->it_interval, &zero) &&\n\t    !is_timeval_eq(&in->it_interval, &in->it_value))\n\t\treturn errno = EINVAL,\n\t\t\terror(\"setitimer: it_interval must be zero or eq it_value\");\n\n\tif (timer_thread)\n\t\tstop_timer_thread();\n\n\tif (is_timeval_eq(&in->it_value, &zero) &&\n\t    is_timeval_eq(&in->it_interval, &zero))\n\t\treturn 0;\n\n\ttimer_interval = in->it_value.tv_sec * 1000 + in->it_value.tv_usec / 1000;\n\tone_shot = is_timeval_eq(&in->it_interval, &zero);\n\tif (!atexit_done) {\n\t\tatexit(stop_timer_thread);\n\t\tatexit_done = 1;\n\t}\n\treturn start_timer_thread();\n}\n\nint sigaction(int sig, struct sigaction *in, struct sigaction *out)\n{\n\tif (sig != SIGALRM)\n\t\treturn errno = EINVAL,\n\t\t\terror(\"sigaction only implemented for SIGALRM\");\n\tif (out != NULL)\n\t\treturn errno = EINVAL,\n\t\t\terror(\"sigaction: param 3 != NULL not implemented\");\n\n\ttimer_fn = in->sa_handler;\n\treturn 0;\n}\n\n#undef signal\nsig_handler_t mingw_signal(int sig, sig_handler_t handler)\n{\n\tsig_handler_t old;\n\n\tswitch (sig) {\n\tcase SIGALRM:\n\t\told = timer_fn;\n\t\ttimer_fn = handler;\n\t\tbreak;\n\n\tcase SIGINT:\n\t\told = sigint_fn;\n\t\tsigint_fn = handler;\n\t\tbreak;\n\n\tdefault:\n\t\treturn signal(sig, handler);\n\t}\n\n\treturn old;\n}\n\n#undef raise\nint mingw_raise(int sig)\n{\n\tswitch (sig) {\n\tcase SIGALRM:\n\t\tif (timer_fn == SIG_DFL) {\n\t\t\tif (isatty(STDERR_FILENO))\n\t\t\t\tfputs(\"Alarm clock\\n\", stderr);\n\t\t\texit(128 + SIGALRM);\n\t\t} else if (timer_fn != SIG_IGN)\n\t\t\ttimer_fn(SIGALRM);\n\t\treturn 0;\n\n\tcase SIGINT:\n\t\tif (sigint_fn == SIG_DFL)\n\t\t\texit(128 + SIGINT);\n\t\telse if (sigint_fn != SIG_IGN)\n\t\t\tsigint_fn(SIGINT);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn raise(sig);\n\t}\n}\n\nint link(const char *oldpath, const char *newpath)\n{\n\ttypedef BOOL (WINAPI *T)(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES);\n\tstatic T create_hard_link = NULL;\n\twchar_t woldpath[MAX_PATH], wnewpath[MAX_PATH];\n\tif (xutftowcs_path(woldpath, oldpath) < 0 ||\n\t\txutftowcs_path(wnewpath, newpath) < 0)\n\t\treturn -1;\n\n\tif (!create_hard_link) {\n\t\tcreate_hard_link = (T) GetProcAddress(\n\t\t\tGetModuleHandle(\"kernel32.dll\"), \"CreateHardLinkW\");\n\t\tif (!create_hard_link)\n\t\t\tcreate_hard_link = (T)-1;\n\t}\n\tif (create_hard_link == (T)-1) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n\tif (!create_hard_link(wnewpath, woldpath, NULL)) {\n\t\terrno = err_win_to_posix(GetLastError());\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\npid_t waitpid(pid_t pid, int *status, int options)\n{\n\tHANDLE h = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n\t    FALSE, pid);\n\tif (!h) {\n\t\terrno = ECHILD;\n\t\treturn -1;\n\t}\n\n\tif (pid > 0 && options & WNOHANG) {\n\t\tif (WAIT_OBJECT_0 != WaitForSingleObject(h, 0)) {\n\t\t\tCloseHandle(h);\n\t\t\treturn 0;\n\t\t}\n\t\toptions &= ~WNOHANG;\n\t}\n\n\tif (options == 0) {\n\t\tstruct pinfo_t **ppinfo;\n\t\tif (WaitForSingleObject(h, INFINITE) != WAIT_OBJECT_0) {\n\t\t\tCloseHandle(h);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (status)\n\t\t\tGetExitCodeProcess(h, (LPDWORD)status);\n\n\t\tEnterCriticalSection(&pinfo_cs);\n\n\t\tppinfo = &pinfo;\n\t\twhile (*ppinfo) {\n\t\t\tstruct pinfo_t *info = *ppinfo;\n\t\t\tif (info->pid == pid) {\n\t\t\t\tCloseHandle(info->proc);\n\t\t\t\t*ppinfo = info->next;\n\t\t\t\tfree(info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tppinfo = &info->next;\n\t\t}\n\n\t\tLeaveCriticalSection(&pinfo_cs);\n\n\t\tCloseHandle(h);\n\t\treturn pid;\n\t}\n\tCloseHandle(h);\n\n\terrno = EINVAL;\n\treturn -1;\n}\n\nint mingw_has_dos_drive_prefix(const char *path)\n{\n\tint i;\n\n\t/*\n\t * Does it start with an ASCII letter (i.e. highest bit not set),\n\t * followed by a colon?\n\t */\n\tif (!(0x80 & (unsigned char)*path))\n\t\treturn *path && path[1] == ':' ? 2 : 0;\n\n\t/*\n\t * While drive letters must be letters of the English alphabet, it is\n\t * possible to assign virtually _any_ Unicode character via `subst` as\n\t * a drive letter to \"virtual drives\". Even `1`, or `\u00e4`. Or fun stuff\n\t * like this:\n\t *\n\t *      subst \u058d: %USERPROFILE%\\Desktop\n\t */\n\tfor (i = 1; i < 4 && (0x80 & (unsigned char)path[i]); i++)\n\t\t; /* skip first UTF-8 character */\n\treturn path[i] == ':' ? i + 1 : 0;\n}\n\nint mingw_skip_dos_drive_prefix(char **path)\n{\n\tint ret = has_dos_drive_prefix(*path);\n\t*path += ret;\n\treturn ret;\n}\n\nint mingw_offset_1st_component(const char *path)\n{\n\tchar *pos = (char *)path;\n\n\t/* unc paths */\n\tif (!skip_dos_drive_prefix(&pos) &&\n\t\t\tis_dir_sep(pos[0]) && is_dir_sep(pos[1])) {\n\t\t/* skip server name */\n\t\tpos = strpbrk(pos + 2, \"\\\\/\");\n\t\tif (!pos)\n\t\t\treturn 0; /* Error: malformed unc path */\n\n\t\tdo {\n\t\t\tpos++;\n\t\t} while (*pos && !is_dir_sep(*pos));\n\t}\n\n\treturn pos + is_dir_sep(*pos) - path;\n}\n\nint xutftowcsn(wchar_t *wcs, const char *utfs, size_t wcslen, int utflen)\n{\n\tint upos = 0, wpos = 0;\n\tconst unsigned char *utf = (const unsigned char*) utfs;\n\tif (!utf || !wcs || wcslen < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t/* reserve space for \\0 */\n\twcslen--;\n\tif (utflen < 0)\n\t\tutflen = INT_MAX;\n\n\twhile (upos < utflen) {\n\t\tint c = utf[upos++] & 0xff;\n\t\tif (utflen == INT_MAX && c == 0)\n\t\t\tbreak;\n\n\t\tif (wpos >= wcslen) {\n\t\t\twcs[wpos] = 0;\n\t\t\terrno = ERANGE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (c < 0x80) {\n\t\t\t/* ASCII */\n\t\t\twcs[wpos++] = c;\n\t\t} else if (c >= 0xc2 && c < 0xe0 && upos < utflen &&\n\t\t\t\t(utf[upos] & 0xc0) == 0x80) {\n\t\t\t/* 2-byte utf-8 */\n\t\t\tc = ((c & 0x1f) << 6);\n\t\t\tc |= (utf[upos++] & 0x3f);\n\t\t\twcs[wpos++] = c;\n\t\t} else if (c >= 0xe0 && c < 0xf0 && upos + 1 < utflen &&\n\t\t\t\t!(c == 0xe0 && utf[upos] < 0xa0) && /* over-long encoding */\n\t\t\t\t(utf[upos] & 0xc0) == 0x80 &&\n\t\t\t\t(utf[upos + 1] & 0xc0) == 0x80) {\n\t\t\t/* 3-byte utf-8 */\n\t\t\tc = ((c & 0x0f) << 12);\n\t\t\tc |= ((utf[upos++] & 0x3f) << 6);\n\t\t\tc |= (utf[upos++] & 0x3f);\n\t\t\twcs[wpos++] = c;\n\t\t} else if (c >= 0xf0 && c < 0xf5 && upos + 2 < utflen &&\n\t\t\t\twpos + 1 < wcslen &&\n\t\t\t\t!(c == 0xf0 && utf[upos] < 0x90) && /* over-long encoding */\n\t\t\t\t!(c == 0xf4 && utf[upos] >= 0x90) && /* > \\u10ffff */\n\t\t\t\t(utf[upos] & 0xc0) == 0x80 &&\n\t\t\t\t(utf[upos + 1] & 0xc0) == 0x80 &&\n\t\t\t\t(utf[upos + 2] & 0xc0) == 0x80) {\n\t\t\t/* 4-byte utf-8: convert to \\ud8xx \\udcxx surrogate pair */\n\t\t\tc = ((c & 0x07) << 18);\n\t\t\tc |= ((utf[upos++] & 0x3f) << 12);\n\t\t\tc |= ((utf[upos++] & 0x3f) << 6);\n\t\t\tc |= (utf[upos++] & 0x3f);\n\t\t\tc -= 0x10000;\n\t\t\twcs[wpos++] = 0xd800 | (c >> 10);\n\t\t\twcs[wpos++] = 0xdc00 | (c & 0x3ff);\n\t\t} else if (c >= 0xa0) {\n\t\t\t/* invalid utf-8 byte, printable unicode char: convert 1:1 */\n\t\t\twcs[wpos++] = c;\n\t\t} else {\n\t\t\t/* invalid utf-8 byte, non-printable unicode: convert to hex */\n\t\t\tstatic const char *hex = \"0123456789abcdef\";\n\t\t\twcs[wpos++] = hex[c >> 4];\n\t\t\tif (wpos < wcslen)\n\t\t\t\twcs[wpos++] = hex[c & 0x0f];\n\t\t}\n\t}\n\twcs[wpos] = 0;\n\treturn wpos;\n}\n\nint xwcstoutf(char *utf, const wchar_t *wcs, size_t utflen)\n{\n\tif (!wcs || !utf || utflen < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tutflen = WideCharToMultiByte(CP_UTF8, 0, wcs, -1, utf, utflen, NULL, NULL);\n\tif (utflen)\n\t\treturn utflen - 1;\n\terrno = ERANGE;\n\treturn -1;\n}\n\nstatic void setup_windows_environment(void)\n{\n\tchar *tmp = getenv(\"TMPDIR\");\n\n\t/* on Windows it is TMP and TEMP */\n\tif (!tmp) {\n\t\tif (!(tmp = getenv(\"TMP\")))\n\t\t\ttmp = getenv(\"TEMP\");\n\t\tif (tmp) {\n\t\t\tsetenv(\"TMPDIR\", tmp, 1);\n\t\t\ttmp = getenv(\"TMPDIR\");\n\t\t}\n\t}\n\n\tif (tmp) {\n\t\t/*\n\t\t * Convert all dir separators to forward slashes,\n\t\t * to help shell commands called from the Git\n\t\t * executable (by not mistaking the dir separators\n\t\t * for escape characters).\n\t\t */\n\t\tconvert_slashes(tmp);\n\t}\n\n\t/* simulate TERM to enable auto-color (see color.c) */\n\tif (!getenv(\"TERM\"))\n\t\tsetenv(\"TERM\", \"cygwin\", 1);\n}\n\nint is_valid_win32_path(const char *path)\n{\n\tint preceding_space_or_period = 0, i = 0, periods = 0;\n\n\tif (!protect_ntfs)\n\t\treturn 1;\n\n\tskip_dos_drive_prefix((char **)&path);\n\n\tfor (;;) {\n\t\tchar c = *(path++);\n\t\tswitch (c) {\n\t\tcase '\\0':\n\t\tcase '/': case '\\\\':\n\t\t\t/* cannot end in ` ` or `.`, except for `.` and `..` */\n\t\t\tif (preceding_space_or_period &&\n\t\t\t    (i != periods || periods > 2))\n\t\t\t\treturn 0;\n\t\t\tif (!c)\n\t\t\t\treturn 1;\n\n\t\t\ti = periods = preceding_space_or_period = 0;\n\t\t\tcontinue;\n\t\tcase '.':\n\t\t\tperiods++;\n\t\t\t/* fallthru */\n\t\tcase ' ':\n\t\t\tpreceding_space_or_period = 1;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\tcase ':': /* DOS drive prefix was already skipped */\n\t\tcase '<': case '>': case '\"': case '|': case '?': case '*':\n\t\t\t/* illegal character */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tif (c > '\\0' && c < '\\x20')\n\t\t\t\t/* illegal character */\n\t\t\t\treturn 0;\n\t\t}\n\t\tpreceding_space_or_period = 0;\n\t\ti++;\n\t}\n}\n\n/*\n * Disable MSVCRT command line wildcard expansion (__getmainargs called from\n * mingw startup code, see init.c in mingw runtime).\n */\nint _CRT_glob = 0;\n\ntypedef struct {\n\tint newmode;\n} _startupinfo;\n\nextern int __wgetmainargs(int *argc, wchar_t ***argv, wchar_t ***env, int glob,\n\t\t_startupinfo *si);\n\nstatic NORETURN void die_startup(void)\n{\n\tfputs(\"fatal: not enough memory for initialization\", stderr);\n\texit(128);\n}\n\nstatic void *malloc_startup(size_t size)\n{\n\tvoid *result = malloc(size);\n\tif (!result)\n\t\tdie_startup();\n\treturn result;\n}\n\nstatic char *wcstoutfdup_startup(char *buffer, const wchar_t *wcs, size_t len)\n{\n\tlen = xwcstoutf(buffer, wcs, len) + 1;\n\treturn memcpy(malloc_startup(len), buffer, len);\n}\n\nstatic void maybe_redirect_std_handle(const wchar_t *key, DWORD std_id, int fd,\n\t\t\t\t      DWORD desired_access, DWORD flags)\n{\n\tDWORD create_flag = fd ? OPEN_ALWAYS : OPEN_EXISTING;\n\twchar_t buf[MAX_PATH];\n\tDWORD max = ARRAY_SIZE(buf);\n\tHANDLE handle;\n\tDWORD ret = GetEnvironmentVariableW(key, buf, max);\n\n\tif (!ret || ret >= max)\n\t\treturn;\n\n\t/* make sure this does not leak into child processes */\n\tSetEnvironmentVariableW(key, NULL);\n\tif (!wcscmp(buf, L\"off\")) {\n\t\tclose(fd);\n\t\thandle = GetStdHandle(std_id);\n\t\tif (handle != INVALID_HANDLE_VALUE)\n\t\t\tCloseHandle(handle);\n\t\treturn;\n\t}\n\tif (std_id == STD_ERROR_HANDLE && !wcscmp(buf, L\"2>&1\")) {\n\t\thandle = GetStdHandle(STD_OUTPUT_HANDLE);\n\t\tif (handle == INVALID_HANDLE_VALUE) {\n\t\t\tclose(fd);\n\t\t\thandle = GetStdHandle(std_id);\n\t\t\tif (handle != INVALID_HANDLE_VALUE)\n\t\t\t\tCloseHandle(handle);\n\t\t} else {\n\t\t\tint new_fd = _open_osfhandle((intptr_t)handle, O_BINARY);\n\t\t\tSetStdHandle(std_id, handle);\n\t\t\tdup2(new_fd, fd);\n\t\t\t/* do *not* close the new_fd: that would close stdout */\n\t\t}\n\t\treturn;\n\t}\n\thandle = CreateFileW(buf, desired_access, 0, NULL, create_flag,\n\t\t\t     flags, NULL);\n\tif (handle != INVALID_HANDLE_VALUE) {\n\t\tint new_fd = _open_osfhandle((intptr_t)handle, O_BINARY);\n\t\tSetStdHandle(std_id, handle);\n\t\tdup2(new_fd, fd);\n\t\tclose(new_fd);\n\t}\n}\n\nstatic void maybe_redirect_std_handles(void)\n{\n\tmaybe_redirect_std_handle(L\"GIT_REDIRECT_STDIN\", STD_INPUT_HANDLE, 0,\n\t\t\t\t  GENERIC_READ, FILE_ATTRIBUTE_NORMAL);\n\tmaybe_redirect_std_handle(L\"GIT_REDIRECT_STDOUT\", STD_OUTPUT_HANDLE, 1,\n\t\t\t\t  GENERIC_WRITE, FILE_ATTRIBUTE_NORMAL);\n\tmaybe_redirect_std_handle(L\"GIT_REDIRECT_STDERR\", STD_ERROR_HANDLE, 2,\n\t\t\t\t  GENERIC_WRITE, FILE_FLAG_NO_BUFFERING);\n}\n\nvoid mingw_startup(void)\n{\n\tint i, maxlen, argc;\n\tchar *buffer;\n\twchar_t **wenv, **wargv;\n\t_startupinfo si;\n\n\tmaybe_redirect_std_handles();\n\n\t/* get wide char arguments and environment */\n\tsi.newmode = 0;\n\tif (__wgetmainargs(&argc, &wargv, &wenv, _CRT_glob, &si) < 0)\n\t\tdie_startup();\n\n\t/* determine size of argv and environ conversion buffer */\n\tmaxlen = wcslen(_wpgmptr);\n\tfor (i = 1; i < argc; i++)\n\t\tmaxlen = max(maxlen, wcslen(wargv[i]));\n\tfor (i = 0; wenv[i]; i++)\n\t\tmaxlen = max(maxlen, wcslen(wenv[i]));\n\n\t/*\n\t * nedmalloc can't free CRT memory, allocate resizable environment\n\t * list. Note that xmalloc / xmemdupz etc. call getenv, so we cannot\n\t * use it while initializing the environment itself.\n\t */\n\tenviron_size = i + 1;\n\tenviron_alloc = alloc_nr(environ_size * sizeof(char*));\n\tenviron = malloc_startup(environ_alloc);\n\n\t/* allocate buffer (wchar_t encodes to max 3 UTF-8 bytes) */\n\tmaxlen = 3 * maxlen + 1;\n\tbuffer = malloc_startup(maxlen);\n\n\t/* convert command line arguments and environment to UTF-8 */\n\t__argv[0] = wcstoutfdup_startup(buffer, _wpgmptr, maxlen);\n\tfor (i = 1; i < argc; i++)\n\t\t__argv[i] = wcstoutfdup_startup(buffer, wargv[i], maxlen);\n\tfor (i = 0; wenv[i]; i++)\n\t\tenviron[i] = wcstoutfdup_startup(buffer, wenv[i], maxlen);\n\tenviron[i] = NULL;\n\tfree(buffer);\n\n\t/* sort environment for O(log n) getenv / putenv */\n\tqsort(environ, i, sizeof(char*), compareenv);\n\n\t/* fix Windows specific environment settings */\n\tsetup_windows_environment();\n\n\t/* initialize critical section for waitpid pinfo_t list */\n\tInitializeCriticalSection(&pinfo_cs);\n\n\t/* set up default file mode and file modes for stdin/out/err */\n\t_fmode = _O_BINARY;\n\t_setmode(_fileno(stdin), _O_BINARY);\n\t_setmode(_fileno(stdout), _O_BINARY);\n\t_setmode(_fileno(stderr), _O_BINARY);\n\n\t/* initialize Unicode console */\n\twinansi_init();\n}\n\nint uname(struct utsname *buf)\n{\n\tunsigned v = (unsigned)GetVersion();\n\tmemset(buf, 0, sizeof(*buf));\n\txsnprintf(buf->sysname, sizeof(buf->sysname), \"Windows\");\n\txsnprintf(buf->release, sizeof(buf->release),\n\t\t \"%u.%u\", v & 0xff, (v >> 8) & 0xff);\n\t/* assuming NT variants only.. */\n\txsnprintf(buf->version, sizeof(buf->version),\n\t\t  \"%u\", (v >> 16) & 0x7fff);\n\treturn 0;\n}\n", "#ifndef GIT_COMPAT_UTIL_H\n#define GIT_COMPAT_UTIL_H\n\n#define _FILE_OFFSET_BITS 64\n\n\n/* Derived from Linux \"Features Test Macro\" header\n * Convenience macros to test the versions of gcc (or\n * a compatible compiler).\n * Use them like this:\n *  #if GIT_GNUC_PREREQ (2,8)\n *   ... code requiring gcc 2.8 or later ...\n *  #endif\n*/\n#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n# define GIT_GNUC_PREREQ(maj, min) \\\n\t((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))\n#else\n #define GIT_GNUC_PREREQ(maj, min) 0\n#endif\n\n\n#ifndef FLEX_ARRAY\n/*\n * See if our compiler is known to support flexible array members.\n */\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && (!defined(__SUNPRO_C) || (__SUNPRO_C > 0x580))\n# define FLEX_ARRAY /* empty */\n#elif defined(__GNUC__)\n# if (__GNUC__ >= 3)\n#  define FLEX_ARRAY /* empty */\n# else\n#  define FLEX_ARRAY 0 /* older GNU extension */\n# endif\n#endif\n\n/*\n * Otherwise, default to safer but a bit wasteful traditional style\n */\n#ifndef FLEX_ARRAY\n# define FLEX_ARRAY 1\n#endif\n#endif\n\n\n/*\n * BUILD_ASSERT_OR_ZERO - assert a build-time dependency, as an expression.\n * @cond: the compile-time condition which must be true.\n *\n * Your compile will fail if the condition isn't true, or can't be evaluated\n * by the compiler.  This can be used in an expression: its value is \"0\".\n *\n * Example:\n *\t#define foo_to_char(foo)\t\t\t\t\t\\\n *\t\t ((char *)(foo)\t\t\t\t\t\t\\\n *\t\t  + BUILD_ASSERT_OR_ZERO(offsetof(struct foo, string) == 0))\n */\n#define BUILD_ASSERT_OR_ZERO(cond) \\\n\t(sizeof(char [1 - 2*!(cond)]) - 1)\n\n#if GIT_GNUC_PREREQ(3, 1)\n /* &arr[0] degrades to a pointer: a different type from an array */\n# define BARF_UNLESS_AN_ARRAY(arr)\t\t\t\t\t\t\\\n\tBUILD_ASSERT_OR_ZERO(!__builtin_types_compatible_p(__typeof__(arr), \\\n\t\t\t\t\t\t\t   __typeof__(&(arr)[0])))\n#else\n# define BARF_UNLESS_AN_ARRAY(arr) 0\n#endif\n/*\n * ARRAY_SIZE - get the number of elements in a visible array\n *  <at> x: the array whose size you want.\n *\n * This does not work on pointers, or arrays declared as [], or\n * function parameters.  With correct compiler support, such usage\n * will cause a build error (see the build_assert_or_zero macro).\n */\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]) + BARF_UNLESS_AN_ARRAY(x))\n\n#define bitsizeof(x)  (CHAR_BIT * sizeof(x))\n\n#define maximum_signed_value_of_type(a) \\\n    (INTMAX_MAX >> (bitsizeof(intmax_t) - bitsizeof(a)))\n\n#define maximum_unsigned_value_of_type(a) \\\n    (UINTMAX_MAX >> (bitsizeof(uintmax_t) - bitsizeof(a)))\n\n/*\n * Signed integer overflow is undefined in C, so here's a helper macro\n * to detect if the sum of two integers will overflow.\n *\n * Requires: a >= 0, typeof(a) equals typeof(b)\n */\n#define signed_add_overflows(a, b) \\\n    ((b) > maximum_signed_value_of_type(a) - (a))\n\n#define unsigned_add_overflows(a, b) \\\n    ((b) > maximum_unsigned_value_of_type(a) - (a))\n\n/*\n * Returns true if the multiplication of \"a\" and \"b\" will\n * overflow. The types of \"a\" and \"b\" must match and must be unsigned.\n * Note that this macro evaluates \"a\" twice!\n */\n#define unsigned_mult_overflows(a, b) \\\n    ((a) && (b) > maximum_unsigned_value_of_type(a) / (a))\n\n#ifdef __GNUC__\n#define TYPEOF(x) (__typeof__(x))\n#else\n#define TYPEOF(x)\n#endif\n\n#define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))\n#define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))\n\n/* Approximation of the length of the decimal representation of this type. */\n#define decimal_length(x)\t((int)(sizeof(x) * 2.56 + 0.5) + 1)\n\n#if defined(__sun__)\n /*\n  * On Solaris, when _XOPEN_EXTENDED is set, its header file\n  * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE\n  * setting to say we are XPG5 or XPG6.  Also on Solaris,\n  * XPG6 programs must be compiled with a c99 compiler, while\n  * non XPG6 programs must be compiled with a pre-c99 compiler.\n  */\n# if __STDC_VERSION__ - 0 >= 199901L\n# define _XOPEN_SOURCE 600\n# else\n# define _XOPEN_SOURCE 500\n# endif\n#elif !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__USLC__) && \\\n      !defined(_M_UNIX) && !defined(__sgi) && !defined(__DragonFly__) && \\\n      !defined(__TANDEM) && !defined(__QNX__) && !defined(__MirBSD__) && \\\n      !defined(__CYGWIN__)\n#define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */\n#define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */\n#endif\n#define _ALL_SOURCE 1\n#define _GNU_SOURCE 1\n#define _BSD_SOURCE 1\n#define _DEFAULT_SOURCE 1\n#define _NETBSD_SOURCE 1\n#define _SGI_SOURCE 1\n\n#if defined(WIN32) && !defined(__CYGWIN__) /* Both MinGW and MSVC */\n# if defined (_MSC_VER) && !defined(_WIN32_WINNT)\n#  define _WIN32_WINNT 0x0502\n# endif\n#define WIN32_LEAN_AND_MEAN  /* stops windows.h including winsock.h */\n#include <winsock2.h>\n#include <windows.h>\n#define GIT_WINDOWS_NATIVE\n#endif\n\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef HAVE_STRINGS_H\n#include <strings.h> /* for strcasecmp() */\n#endif\n#include <errno.h>\n#include <limits.h>\n#ifdef NEEDS_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <assert.h>\n#include <regex.h>\n#include <utime.h>\n#include <syslog.h>\n#ifndef NO_SYS_POLL_H\n#include <sys/poll.h>\n#else\n#include <poll.h>\n#endif\n#ifdef HAVE_BSD_SYSCTL\n#include <sys/sysctl.h>\n#endif\n\n#if defined(__CYGWIN__)\n#include \"compat/cygwin.h\"\n#endif\n#if defined(__MINGW32__)\n/* pull in Windows compatibility stuff */\n#include \"compat/mingw.h\"\n#elif defined(_MSC_VER)\n#include \"compat/msvc.h\"\n#else\n#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#ifndef NO_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <sys/un.h>\n#ifndef NO_INTTYPES_H\n#include <inttypes.h>\n#else\n#include <stdint.h>\n#endif\n#ifdef NO_INTPTR_T\n/*\n * On I16LP32, ILP32 and LP64 \"long\" is the save bet, however\n * on LLP86, IL33LLP64 and P64 it needs to be \"long long\",\n * while on IP16 and IP16L32 it is \"int\" (resp. \"short\")\n * Size needs to match (or exceed) 'sizeof(void *)'.\n * We can't take \"long long\" here as not everybody has it.\n */\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\n#endif\n#undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */\n#include <grp.h>\n#define _ALL_SOURCE 1\n#endif\n\n/* used on Mac OS X */\n#ifdef PRECOMPOSE_UNICODE\n#include \"compat/precompose_utf8.h\"\n#else\n#define precompose_str(in,i_nfd2nfc)\n#define precompose_argv(c,v)\n#define probe_utf8_pathname_composition()\n#endif\n\n#ifdef MKDIR_WO_TRAILING_SLASH\n#define mkdir(a,b) compat_mkdir_wo_trailing_slash((a),(b))\nextern int compat_mkdir_wo_trailing_slash(const char*, mode_t);\n#endif\n\n#ifdef NO_STRUCT_ITIMERVAL\nstruct itimerval {\n\tstruct timeval it_interval;\n\tstruct timeval it_value;\n};\n#endif\n\n#ifdef NO_SETITIMER\n#define setitimer(which,value,ovalue)\n#endif\n\n#ifndef NO_LIBGEN_H\n#include <libgen.h>\n#else\n#define basename gitbasename\nextern char *gitbasename(char *);\n#define dirname gitdirname\nextern char *gitdirname(char *);\n#endif\n\n#ifndef NO_ICONV\n#include <iconv.h>\n#endif\n\n#ifndef NO_OPENSSL\n#ifdef __APPLE__\n#define __AVAILABILITY_MACROS_USES_AVAILABILITY 0\n#include <AvailabilityMacros.h>\n#undef DEPRECATED_ATTRIBUTE\n#define DEPRECATED_ATTRIBUTE\n#undef __AVAILABILITY_MACROS_USES_AVAILABILITY\n#endif\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n/* On most systems <netdb.h> would have given us this, but\n * not on some systems (e.g. z/OS).\n */\n#ifndef NI_MAXHOST\n#define NI_MAXHOST 1025\n#endif\n\n#ifndef NI_MAXSERV\n#define NI_MAXSERV 32\n#endif\n\n/* On most systems <limits.h> would have given us this, but\n * not on some systems (e.g. GNU/Hurd).\n */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifndef PRIuMAX\n#define PRIuMAX \"llu\"\n#endif\n\n#ifndef SCNuMAX\n#define SCNuMAX PRIuMAX\n#endif\n\n#ifndef PRIu32\n#define PRIu32 \"u\"\n#endif\n\n#ifndef PRIx32\n#define PRIx32 \"x\"\n#endif\n\n#ifndef PRIo32\n#define PRIo32 \"o\"\n#endif\n\ntypedef uintmax_t timestamp_t;\n#define PRItime PRIuMAX\n#define parse_timestamp strtoumax\n#define TIME_MAX UINTMAX_MAX\n\n#ifndef PATH_SEP\n#define PATH_SEP ':'\n#endif\n\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#ifndef _PATH_DEFPATH\n#define _PATH_DEFPATH \"/usr/local/bin:/usr/bin:/bin\"\n#endif\n\nint lstat_cache_aware_rmdir(const char *path);\n#if !defined(__MINGW32__) && !defined(_MSC_VER)\n#define rmdir lstat_cache_aware_rmdir\n#endif\n\n#ifndef has_dos_drive_prefix\nstatic inline int git_has_dos_drive_prefix(const char *path)\n{\n\treturn 0;\n}\n#define has_dos_drive_prefix git_has_dos_drive_prefix\n#endif\n\n#ifndef skip_dos_drive_prefix\nstatic inline int git_skip_dos_drive_prefix(char **path)\n{\n\treturn 0;\n}\n#define skip_dos_drive_prefix git_skip_dos_drive_prefix\n#endif\n\n#ifndef is_dir_sep\nstatic inline int git_is_dir_sep(int c)\n{\n\treturn c == '/';\n}\n#define is_dir_sep git_is_dir_sep\n#endif\n\n#ifndef offset_1st_component\nstatic inline int git_offset_1st_component(const char *path)\n{\n\treturn is_dir_sep(path[0]);\n}\n#define offset_1st_component git_offset_1st_component\n#endif\n\n#ifndef is_valid_path\n#define is_valid_path(path) 1\n#endif\n\n#ifndef find_last_dir_sep\nstatic inline char *git_find_last_dir_sep(const char *path)\n{\n\treturn strrchr(path, '/');\n}\n#define find_last_dir_sep git_find_last_dir_sep\n#endif\n\n#if defined(__HP_cc) && (__HP_cc >= 61000)\n#define NORETURN __attribute__((noreturn))\n#define NORETURN_PTR\n#elif defined(__GNUC__) && !defined(NO_NORETURN)\n#define NORETURN __attribute__((__noreturn__))\n#define NORETURN_PTR __attribute__((__noreturn__))\n#elif defined(_MSC_VER)\n#define NORETURN __declspec(noreturn)\n#define NORETURN_PTR\n#else\n#define NORETURN\n#define NORETURN_PTR\n#ifndef __GNUC__\n#ifndef __attribute__\n#define __attribute__(x)\n#endif\n#endif\n#endif\n\n/* The sentinel attribute is valid from gcc version 4.0 */\n#if defined(__GNUC__) && (__GNUC__ >= 4)\n#define LAST_ARG_MUST_BE_NULL __attribute__((sentinel))\n#else\n#define LAST_ARG_MUST_BE_NULL\n#endif\n\n#include \"compat/bswap.h\"\n\n#include \"wildmatch.h\"\n\nstruct strbuf;\n\n/* General helper functions */\nextern void vreportf(const char *prefix, const char *err, va_list params);\nextern NORETURN void usage(const char *err);\nextern NORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern int error(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern int error_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\n\n#ifndef NO_OPENSSL\n#ifdef APPLE_COMMON_CRYPTO\n#include \"compat/apple-common-crypto.h\"\n#else\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#endif /* APPLE_COMMON_CRYPTO */\n#include <openssl/x509v3.h>\n#endif /* NO_OPENSSL */\n\n/*\n * Let callers be aware of the constant return value; this can help\n * gcc with -Wuninitialized analysis. We restrict this trick to gcc, though,\n * because some compilers may not support variadic macros. Since we're only\n * trying to help gcc, anyway, it's OK; other compilers will fall back to\n * using the function as usual.\n */\n#if defined(__GNUC__)\nstatic inline int const_error(void)\n{\n\treturn -1;\n}\n#define error(...) (error(__VA_ARGS__), const_error())\n#define error_errno(...) (error_errno(__VA_ARGS__), const_error())\n#endif\n\nextern void set_die_routine(NORETURN_PTR void (*routine)(const char *err, va_list params));\nextern void set_error_routine(void (*routine)(const char *err, va_list params));\nextern void (*get_error_routine(void))(const char *err, va_list params);\nextern void set_warn_routine(void (*routine)(const char *warn, va_list params));\nextern void (*get_warn_routine(void))(const char *warn, va_list params);\nextern void set_die_is_recursing_routine(int (*routine)(void));\n\nextern int starts_with(const char *str, const char *prefix);\n\n/*\n * If the string \"str\" begins with the string found in \"prefix\", return 1.\n * The \"out\" parameter is set to \"str + strlen(prefix)\" (i.e., to the point in\n * the string right after the prefix).\n *\n * Otherwise, return 0 and leave \"out\" untouched.\n *\n * Examples:\n *\n *   [extract branch name, fail if not a branch]\n *   if (!skip_prefix(ref, \"refs/heads/\", &branch)\n *\treturn -1;\n *\n *   [skip prefix if present, otherwise use whole string]\n *   skip_prefix(name, \"refs/heads/\", &name);\n */\nstatic inline int skip_prefix(const char *str, const char *prefix,\n\t\t\t      const char **out)\n{\n\tdo {\n\t\tif (!*prefix) {\n\t\t\t*out = str;\n\t\t\treturn 1;\n\t\t}\n\t} while (*str++ == *prefix++);\n\treturn 0;\n}\n\n/*\n * If the string \"str\" is the same as the string in \"prefix\", then the \"arg\"\n * parameter is set to the \"def\" parameter and 1 is returned.\n * If the string \"str\" begins with the string found in \"prefix\" and then a\n * \"=\" sign, then the \"arg\" parameter is set to \"str + strlen(prefix) + 1\"\n * (i.e., to the point in the string right after the prefix and the \"=\" sign),\n * and 1 is returned.\n *\n * Otherwise, return 0 and leave \"arg\" untouched.\n *\n * When we accept both a \"--key\" and a \"--key=<val>\" option, this function\n * can be used instead of !strcmp(arg, \"--key\") and then\n * skip_prefix(arg, \"--key=\", &arg) to parse such an option.\n */\nint skip_to_optional_arg_default(const char *str, const char *prefix,\n\t\t\t\t const char **arg, const char *def);\n\nstatic inline int skip_to_optional_arg(const char *str, const char *prefix,\n\t\t\t\t       const char **arg)\n{\n\treturn skip_to_optional_arg_default(str, prefix, arg, \"\");\n}\n\n/*\n * Like skip_prefix, but promises never to read past \"len\" bytes of the input\n * buffer, and returns the remaining number of bytes in \"out\" via \"outlen\".\n */\nstatic inline int skip_prefix_mem(const char *buf, size_t len,\n\t\t\t\t  const char *prefix,\n\t\t\t\t  const char **out, size_t *outlen)\n{\n\tsize_t prefix_len = strlen(prefix);\n\tif (prefix_len <= len && !memcmp(buf, prefix, prefix_len)) {\n\t\t*out = buf + prefix_len;\n\t\t*outlen = len - prefix_len;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * If buf ends with suffix, return 1 and subtract the length of the suffix\n * from *len. Otherwise, return 0 and leave *len untouched.\n */\nstatic inline int strip_suffix_mem(const char *buf, size_t *len,\n\t\t\t\t   const char *suffix)\n{\n\tsize_t suflen = strlen(suffix);\n\tif (*len < suflen || memcmp(buf + (*len - suflen), suffix, suflen))\n\t\treturn 0;\n\t*len -= suflen;\n\treturn 1;\n}\n\n/*\n * If str ends with suffix, return 1 and set *len to the size of the string\n * without the suffix. Otherwise, return 0 and set *len to the size of the\n * string.\n *\n * Note that we do _not_ NUL-terminate str to the new length.\n */\nstatic inline int strip_suffix(const char *str, const char *suffix, size_t *len)\n{\n\t*len = strlen(str);\n\treturn strip_suffix_mem(str, len, suffix);\n}\n\nstatic inline int ends_with(const char *str, const char *suffix)\n{\n\tsize_t len;\n\treturn strip_suffix(str, suffix, &len);\n}\n\n#define SWAP(a, b) do {\t\t\t\t\t\t\\\n\tvoid *_swap_a_ptr = &(a);\t\t\t\t\\\n\tvoid *_swap_b_ptr = &(b);\t\t\t\t\\\n\tunsigned char _swap_buffer[sizeof(a)];\t\t\t\\\n\tmemcpy(_swap_buffer, _swap_a_ptr, sizeof(a));\t\t\\\n\tmemcpy(_swap_a_ptr, _swap_b_ptr, sizeof(a) +\t\t\\\n\t       BUILD_ASSERT_OR_ZERO(sizeof(a) == sizeof(b)));\t\\\n\tmemcpy(_swap_b_ptr, _swap_buffer, sizeof(a));\t\t\\\n} while (0)\n\n#if defined(NO_MMAP) || defined(USE_WIN32_MMAP)\n\n#ifndef PROT_READ\n#define PROT_READ 1\n#define PROT_WRITE 2\n#define MAP_PRIVATE 1\n#endif\n\n#define mmap git_mmap\n#define munmap git_munmap\nextern void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int git_munmap(void *start, size_t length);\n\n#else /* NO_MMAP || USE_WIN32_MMAP */\n\n#include <sys/mman.h>\n\n#endif /* NO_MMAP || USE_WIN32_MMAP */\n\n#ifdef NO_MMAP\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)\n\n#else /* NO_MMAP */\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE \\\n\t(sizeof(void*) >= 8 \\\n\t\t?  1 * 1024 * 1024 * 1024 \\\n\t\t: 32 * 1024 * 1024)\n\n#endif /* NO_MMAP */\n\n#ifndef MAP_FAILED\n#define MAP_FAILED ((void *)-1)\n#endif\n\n#ifdef NO_ST_BLOCKS_IN_STRUCT_STAT\n#define on_disk_bytes(st) ((st).st_size)\n#else\n#define on_disk_bytes(st) ((st).st_blocks * 512)\n#endif\n\n#ifdef NEEDS_MODE_TRANSLATION\n#undef S_IFMT\n#undef S_IFREG\n#undef S_IFDIR\n#undef S_IFLNK\n#undef S_IFBLK\n#undef S_IFCHR\n#undef S_IFIFO\n#undef S_IFSOCK\n#define S_IFMT   0170000\n#define S_IFREG  0100000\n#define S_IFDIR  0040000\n#define S_IFLNK  0120000\n#define S_IFBLK  0060000\n#define S_IFCHR  0020000\n#define S_IFIFO  0010000\n#define S_IFSOCK 0140000\n#ifdef stat\n#undef stat\n#endif\n#define stat(path, buf) git_stat(path, buf)\nextern int git_stat(const char *, struct stat *);\n#ifdef fstat\n#undef fstat\n#endif\n#define fstat(fd, buf) git_fstat(fd, buf)\nextern int git_fstat(int, struct stat *);\n#ifdef lstat\n#undef lstat\n#endif\n#define lstat(path, buf) git_lstat(path, buf)\nextern int git_lstat(const char *, struct stat *);\n#endif\n\n#define DEFAULT_PACKED_GIT_LIMIT \\\n\t((1024L * 1024L) * (size_t)(sizeof(void*) >= 8 ? (32 * 1024L * 1024L) : 256))\n\n#ifdef NO_PREAD\n#define pread git_pread\nextern ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);\n#endif\n/*\n * Forward decl that will remind us if its twin in cache.h changes.\n * This function is used in compat/pread.c.  But we can't include\n * cache.h there.\n */\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\n\n#ifdef NO_SETENV\n#define setenv gitsetenv\nextern int gitsetenv(const char *, const char *, int);\n#endif\n\n#ifdef NO_MKDTEMP\n#define mkdtemp gitmkdtemp\nextern char *gitmkdtemp(char *);\n#endif\n\n#ifdef NO_UNSETENV\n#define unsetenv gitunsetenv\nextern void gitunsetenv(const char *);\n#endif\n\n#ifdef NO_STRCASESTR\n#define strcasestr gitstrcasestr\nextern char *gitstrcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifdef NO_STRLCPY\n#define strlcpy gitstrlcpy\nextern size_t gitstrlcpy(char *, const char *, size_t);\n#endif\n\n#ifdef NO_STRTOUMAX\n#define strtoumax gitstrtoumax\nextern uintmax_t gitstrtoumax(const char *, char **, int);\n#define strtoimax gitstrtoimax\nextern intmax_t gitstrtoimax(const char *, char **, int);\n#endif\n\n#ifdef NO_HSTRERROR\n#define hstrerror githstrerror\nextern const char *githstrerror(int herror);\n#endif\n\n#ifdef NO_MEMMEM\n#define memmem gitmemmem\nvoid *gitmemmem(const void *haystack, size_t haystacklen,\n                const void *needle, size_t needlelen);\n#endif\n\n#ifdef OVERRIDE_STRDUP\n#ifdef strdup\n#undef strdup\n#endif\n#define strdup gitstrdup\nchar *gitstrdup(const char *s);\n#endif\n\n#ifdef NO_GETPAGESIZE\n#define getpagesize() sysconf(_SC_PAGESIZE)\n#endif\n\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\n#ifdef FREAD_READS_DIRECTORIES\n# if !defined(SUPPRESS_FOPEN_REDEFINITION)\n#  ifdef fopen\n#   undef fopen\n#  endif\n#  define fopen(a,b) git_fopen(a,b)\n# endif\nextern FILE *git_fopen(const char*, const char*);\n#endif\n\n#ifdef SNPRINTF_RETURNS_BOGUS\n#ifdef snprintf\n#undef snprintf\n#endif\n#define snprintf git_snprintf\nextern int git_snprintf(char *str, size_t maxsize,\n\t\t\tconst char *format, ...);\n#ifdef vsnprintf\n#undef vsnprintf\n#endif\n#define vsnprintf git_vsnprintf\nextern int git_vsnprintf(char *str, size_t maxsize,\n\t\t\t const char *format, va_list ap);\n#endif\n\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 1)\n#define HAVE_STRCHRNUL\n#endif\n#endif\n\n#ifndef HAVE_STRCHRNUL\n#define strchrnul gitstrchrnul\nstatic inline char *gitstrchrnul(const char *s, int c)\n{\n\twhile (*s && *s != c)\n\t\ts++;\n\treturn (char *)s;\n}\n#endif\n\n#ifdef NO_INET_PTON\nint inet_pton(int af, const char *src, void *dst);\n#endif\n\n#ifdef NO_INET_NTOP\nconst char *inet_ntop(int af, const void *src, char *dst, size_t size);\n#endif\n\n#ifdef NO_PTHREADS\n#define atexit git_atexit\nextern int git_atexit(void (*handler)(void));\n#endif\n\ntypedef void (*try_to_free_t)(size_t);\nextern try_to_free_t set_try_to_free_routine(try_to_free_t);\n\nstatic inline size_t st_add(size_t a, size_t b)\n{\n\tif (unsigned_add_overflows(a, b))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" + %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a + b;\n}\n#define st_add3(a,b,c)   st_add(st_add((a),(b)),(c))\n#define st_add4(a,b,c,d) st_add(st_add3((a),(b),(c)),(d))\n\nstatic inline size_t st_mult(size_t a, size_t b)\n{\n\tif (unsigned_mult_overflows(a, b))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" * %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a * b;\n}\n\nstatic inline size_t st_sub(size_t a, size_t b)\n{\n\tif (a < b)\n\t\tdie(\"size_t underflow: %\"PRIuMAX\" - %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a - b;\n}\n\n#ifdef HAVE_ALLOCA_H\n# include <alloca.h>\n# define xalloca(size)      (alloca(size))\n# define xalloca_free(p)    do {} while (0)\n#else\n# define xalloca(size)      (xmalloc(size))\n# define xalloca_free(p)    (free(p))\n#endif\nextern char *xstrdup(const char *str);\nextern void *xmalloc(size_t size);\nextern void *xmallocz(size_t size);\nextern void *xmallocz_gently(size_t size);\nextern void *xmemdupz(const void *data, size_t len);\nextern char *xstrndup(const char *str, size_t len);\nextern void *xrealloc(void *ptr, size_t size);\nextern void *xcalloc(size_t nmemb, size_t size);\nextern void *xmmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern void *xmmap_gently(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int xopen(const char *path, int flags, ...);\nextern ssize_t xread(int fd, void *buf, size_t len);\nextern ssize_t xwrite(int fd, const void *buf, size_t len);\nextern ssize_t xpread(int fd, void *buf, size_t len, off_t offset);\nextern int xdup(int fd);\nextern FILE *xfopen(const char *path, const char *mode);\nextern FILE *xfdopen(int fd, const char *mode);\nextern int xmkstemp(char *temp_filename);\nextern int xmkstemp_mode(char *temp_filename, int mode);\nextern char *xgetcwd(void);\nextern FILE *fopen_for_writing(const char *path);\nextern FILE *fopen_or_warn(const char *path, const char *mode);\n\n/*\n * FREE_AND_NULL(ptr) is like free(ptr) followed by ptr = NULL. Note\n * that ptr is used twice, so don't pass e.g. ptr++.\n */\n#define FREE_AND_NULL(p) do { free(p); (p) = NULL; } while (0)\n\n#define ALLOC_ARRAY(x, alloc) (x) = xmalloc(st_mult(sizeof(*(x)), (alloc)))\n#define REALLOC_ARRAY(x, alloc) (x) = xrealloc((x), st_mult(sizeof(*(x)), (alloc)))\n\n#define COPY_ARRAY(dst, src, n) copy_array((dst), (src), (n), sizeof(*(dst)) + \\\n\tBUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))\nstatic inline void copy_array(void *dst, const void *src, size_t n, size_t size)\n{\n\tif (n)\n\t\tmemcpy(dst, src, st_mult(size, n));\n}\n\n#define MOVE_ARRAY(dst, src, n) move_array((dst), (src), (n), sizeof(*(dst)) + \\\n\tBUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))\nstatic inline void move_array(void *dst, const void *src, size_t n, size_t size)\n{\n\tif (n)\n\t\tmemmove(dst, src, st_mult(size, n));\n}\n\n/*\n * These functions help you allocate structs with flex arrays, and copy\n * the data directly into the array. For example, if you had:\n *\n *   struct foo {\n *     int bar;\n *     char name[FLEX_ARRAY];\n *   };\n *\n * you can do:\n *\n *   struct foo *f;\n *   FLEX_ALLOC_MEM(f, name, src, len);\n *\n * to allocate a \"foo\" with the contents of \"src\" in the \"name\" field.\n * The resulting struct is automatically zero'd, and the flex-array field\n * is NUL-terminated (whether the incoming src buffer was or not).\n *\n * The FLEXPTR_* variants operate on structs that don't use flex-arrays,\n * but do want to store a pointer to some extra data in the same allocated\n * block. For example, if you have:\n *\n *   struct foo {\n *     char *name;\n *     int bar;\n *   };\n *\n * you can do:\n *\n *   struct foo *f;\n *   FLEXPTR_ALLOC_STR(f, name, src);\n *\n * and \"name\" will point to a block of memory after the struct, which will be\n * freed along with the struct (but the pointer can be repointed anywhere).\n *\n * The *_STR variants accept a string parameter rather than a ptr/len\n * combination.\n *\n * Note that these macros will evaluate the first parameter multiple\n * times, and it must be assignable as an lvalue.\n */\n#define FLEX_ALLOC_MEM(x, flexname, buf, len) do { \\\n\tsize_t flex_array_len_ = (len); \\\n\t(x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \\\n\tmemcpy((void *)(x)->flexname, (buf), flex_array_len_); \\\n} while (0)\n#define FLEXPTR_ALLOC_MEM(x, ptrname, buf, len) do { \\\n\tsize_t flex_array_len_ = (len); \\\n\t(x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \\\n\tmemcpy((x) + 1, (buf), flex_array_len_); \\\n\t(x)->ptrname = (void *)((x)+1); \\\n} while(0)\n#define FLEX_ALLOC_STR(x, flexname, str) \\\n\tFLEX_ALLOC_MEM((x), flexname, (str), strlen(str))\n#define FLEXPTR_ALLOC_STR(x, ptrname, str) \\\n\tFLEXPTR_ALLOC_MEM((x), ptrname, (str), strlen(str))\n\nstatic inline char *xstrdup_or_null(const char *str)\n{\n\treturn str ? xstrdup(str) : NULL;\n}\n\nstatic inline size_t xsize_t(off_t len)\n{\n\tsize_t size = (size_t) len;\n\n\tif (len != (off_t) size)\n\t\tdie(\"Cannot handle files this big\");\n\treturn size;\n}\n\n__attribute__((format (printf, 3, 4)))\nextern int xsnprintf(char *dst, size_t max, const char *fmt, ...);\n\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 256\n#endif\n\nextern int xgethostname(char *buf, size_t len);\n\n/* in ctype.c, for kwset users */\nextern const unsigned char tolower_trans_tbl[256];\n\n/* Sane ctype - no locale, and works with signed chars */\n#undef isascii\n#undef isspace\n#undef isdigit\n#undef isalpha\n#undef isalnum\n#undef isprint\n#undef islower\n#undef isupper\n#undef tolower\n#undef toupper\n#undef iscntrl\n#undef ispunct\n#undef isxdigit\n\nextern const unsigned char sane_ctype[256];\n#define GIT_SPACE 0x01\n#define GIT_DIGIT 0x02\n#define GIT_ALPHA 0x04\n#define GIT_GLOB_SPECIAL 0x08\n#define GIT_REGEX_SPECIAL 0x10\n#define GIT_PATHSPEC_MAGIC 0x20\n#define GIT_CNTRL 0x40\n#define GIT_PUNCT 0x80\n#define sane_istest(x,mask) ((sane_ctype[(unsigned char)(x)] & (mask)) != 0)\n#define isascii(x) (((x) & ~0x7f) == 0)\n#define isspace(x) sane_istest(x,GIT_SPACE)\n#define isdigit(x) sane_istest(x,GIT_DIGIT)\n#define isalpha(x) sane_istest(x,GIT_ALPHA)\n#define isalnum(x) sane_istest(x,GIT_ALPHA | GIT_DIGIT)\n#define isprint(x) ((x) >= 0x20 && (x) <= 0x7e)\n#define islower(x) sane_iscase(x, 1)\n#define isupper(x) sane_iscase(x, 0)\n#define is_glob_special(x) sane_istest(x,GIT_GLOB_SPECIAL)\n#define is_regex_special(x) sane_istest(x,GIT_GLOB_SPECIAL | GIT_REGEX_SPECIAL)\n#define iscntrl(x) (sane_istest(x,GIT_CNTRL))\n#define ispunct(x) sane_istest(x, GIT_PUNCT | GIT_REGEX_SPECIAL | \\\n\t\tGIT_GLOB_SPECIAL | GIT_PATHSPEC_MAGIC)\n#define isxdigit(x) (hexval_table[(unsigned char)(x)] != -1)\n#define tolower(x) sane_case((unsigned char)(x), 0x20)\n#define toupper(x) sane_case((unsigned char)(x), 0)\n#define is_pathspec_magic(x) sane_istest(x,GIT_PATHSPEC_MAGIC)\n\nstatic inline int sane_case(int x, int high)\n{\n\tif (sane_istest(x, GIT_ALPHA))\n\t\tx = (x & ~0x20) | high;\n\treturn x;\n}\n\nstatic inline int sane_iscase(int x, int is_lower)\n{\n\tif (!sane_istest(x, GIT_ALPHA))\n\t\treturn 0;\n\n\tif (is_lower)\n\t\treturn (x & 0x20) != 0;\n\telse\n\t\treturn (x & 0x20) == 0;\n}\n\n/*\n * Like skip_prefix, but compare case-insensitively. Note that the comparison\n * is done via tolower(), so it is strictly ASCII (no multi-byte characters or\n * locale-specific conversions).\n */\nstatic inline int skip_iprefix(const char *str, const char *prefix,\n\t\t\t       const char **out)\n{\n\tdo {\n\t\tif (!*prefix) {\n\t\t\t*out = str;\n\t\t\treturn 1;\n\t\t}\n\t} while (tolower(*str++) == tolower(*prefix++));\n\treturn 0;\n}\n\nstatic inline int strtoul_ui(char const *s, int base, unsigned int *result)\n{\n\tunsigned long ul;\n\tchar *p;\n\n\terrno = 0;\n\t/* negative values would be accepted by strtoul */\n\tif (strchr(s, '-'))\n\t\treturn -1;\n\tul = strtoul(s, &p, base);\n\tif (errno || *p || p == s || (unsigned int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\nstatic inline int strtol_i(char const *s, int base, int *result)\n{\n\tlong ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtol(s, &p, base);\n\tif (errno || *p || p == s || (int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\n#ifdef INTERNAL_QSORT\nvoid git_qsort(void *base, size_t nmemb, size_t size,\n\t       int(*compar)(const void *, const void *));\n#define qsort git_qsort\n#endif\n\n#define QSORT(base, n, compar) sane_qsort((base), (n), sizeof(*(base)), compar)\nstatic inline void sane_qsort(void *base, size_t nmemb, size_t size,\n\t\t\t      int(*compar)(const void *, const void *))\n{\n\tif (nmemb > 1)\n\t\tqsort(base, nmemb, size, compar);\n}\n\n#ifndef HAVE_ISO_QSORT_S\nint git_qsort_s(void *base, size_t nmemb, size_t size,\n\t\tint (*compar)(const void *, const void *, void *), void *ctx);\n#define qsort_s git_qsort_s\n#endif\n\n#define QSORT_S(base, n, compar, ctx) do {\t\t\t\\\n\tif (qsort_s((base), (n), sizeof(*(base)), compar, ctx))\t\\\n\t\tdie(\"BUG: qsort_s() failed\");\t\t\t\\\n} while (0)\n\n#ifndef REG_STARTEND\n#error \"Git requires REG_STARTEND support. Compile with NO_REGEX=NeedsStartEnd\"\n#endif\n\nstatic inline int regexec_buf(const regex_t *preg, const char *buf, size_t size,\n\t\t\t      size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n\tassert(nmatch > 0 && pmatch);\n\tpmatch[0].rm_so = 0;\n\tpmatch[0].rm_eo = size;\n\treturn regexec(preg, buf, nmatch, pmatch, eflags | REG_STARTEND);\n}\n\n#ifndef DIR_HAS_BSD_GROUP_SEMANTICS\n# define FORCE_DIR_SET_GID S_ISGID\n#else\n# define FORCE_DIR_SET_GID 0\n#endif\n\n#ifdef NO_NSEC\n#undef USE_NSEC\n#define ST_CTIME_NSEC(st) 0\n#define ST_MTIME_NSEC(st) 0\n#else\n#ifdef USE_ST_TIMESPEC\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))\n#else\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))\n#endif\n#endif\n\n#ifdef UNRELIABLE_FSTAT\n#define fstat_is_reliable() 0\n#else\n#define fstat_is_reliable() 1\n#endif\n\n#ifndef va_copy\n/*\n * Since an obvious implementation of va_list would be to make it a\n * pointer into the stack frame, a simple assignment will work on\n * many systems.  But let's try to be more portable.\n */\n#ifdef __va_copy\n#define va_copy(dst, src) __va_copy(dst, src)\n#else\n#define va_copy(dst, src) ((dst) = (src))\n#endif\n#endif\n\n#if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__C99_MACRO_WITH_VA_ARGS)\n#define HAVE_VARIADIC_MACROS 1\n#endif\n\n#ifdef HAVE_VARIADIC_MACROS\n__attribute__((format (printf, 3, 4))) NORETURN\nvoid BUG_fl(const char *file, int line, const char *fmt, ...);\n#define BUG(...) BUG_fl(__FILE__, __LINE__, __VA_ARGS__)\n#else\n__attribute__((format (printf, 1, 2))) NORETURN\nvoid BUG(const char *fmt, ...);\n#endif\n\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Returns 0 on success, which includes trying to unlink an object that does\n * not exist.\n */\nint unlink_or_warn(const char *path);\n /*\n  * Tries to unlink file.  Returns 0 if unlink succeeded\n  * or the file already didn't exist.  Returns -1 and\n  * appends a message to err suitable for\n  * 'error(\"%s\", err->buf)' on error.\n  */\nint unlink_or_msg(const char *file, struct strbuf *err);\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Returns 0 on success, which includes trying to remove a directory that does\n * not exist.\n */\nint rmdir_or_warn(const char *path);\n/*\n * Calls the correct function out of {unlink,rmdir}_or_warn based on\n * the supplied file mode.\n */\nint remove_or_warn(unsigned int mode, const char *path);\n\n/*\n * Call access(2), but warn for any error except \"missing file\"\n * (ENOENT or ENOTDIR).\n */\n#define ACCESS_EACCES_OK (1U << 0)\nint access_or_warn(const char *path, int mode, unsigned flag);\nint access_or_die(const char *path, int mode, unsigned flag);\n\n/* Warn on an inaccessible file if errno indicates this is an error */\nint warn_on_fopen_errors(const char *path);\n\n#ifdef GMTIME_UNRELIABLE_ERRORS\nstruct tm *git_gmtime(const time_t *);\nstruct tm *git_gmtime_r(const time_t *, struct tm *);\n#define gmtime git_gmtime\n#define gmtime_r git_gmtime_r\n#endif\n\n#if !defined(USE_PARENS_AROUND_GETTEXT_N) && defined(__GNUC__)\n#define USE_PARENS_AROUND_GETTEXT_N 1\n#endif\n\n#ifndef SHELL_PATH\n# define SHELL_PATH \"/bin/sh\"\n#endif\n\n#ifndef _POSIX_THREAD_SAFE_FUNCTIONS\n#define flockfile(fh)\n#define funlockfile(fh)\n#define getc_unlocked(fh) getc(fh)\n#endif\n\n/*\n * Our code often opens a path to an optional file, to work on its\n * contents when we can successfully open it.  We can ignore a failure\n * to open if such an optional file does not exist, but we do want to\n * report a failure in opening for other reasons (e.g. we got an I/O\n * error, or the file is there, but we lack the permission to open).\n *\n * Call this function after seeing an error from open() or fopen() to\n * see if the errno indicates a missing file that we can safely ignore.\n */\nstatic inline int is_missing_file_error(int errno_)\n{\n\treturn (errno_ == ENOENT || errno_ == ENOTDIR);\n}\n\nextern int cmd_main(int, const char **);\n\n/*\n * You can mark a stack variable with UNLEAK(var) to avoid it being\n * reported as a leak by tools like LSAN or valgrind. The argument\n * should generally be the variable itself (not its address and not what\n * it points to). It's safe to use this on pointers which may already\n * have been freed, or on pointers which may still be in use.\n *\n * Use this _only_ for a variable that leaks by going out of scope at\n * program exit (so only from cmd_* functions or their direct helpers).\n * Normal functions, especially those which may be called multiple\n * times, should actually free their memory. This is only meant as\n * an annotation, and does nothing in non-leak-checking builds.\n */\n#ifdef SUPPRESS_ANNOTATED_LEAKS\nextern void unleak_memory(const void *ptr, size_t len);\n#define UNLEAK(var) unleak_memory(&(var), sizeof(var))\n#else\n#define UNLEAK(var) do {} while (0)\n#endif\n\n#endif\n", "#include \"cache.h\"\n\nstatic int threaded_check_leading_path(struct cache_def *cache, const char *name, int len);\nstatic int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len);\n\n/*\n * Returns the length (on a path component basis) of the longest\n * common prefix match of 'name_a' and 'name_b'.\n */\nstatic int longest_path_match(const char *name_a, int len_a,\n\t\t\t      const char *name_b, int len_b,\n\t\t\t      int *previous_slash)\n{\n\tint max_len, match_len = 0, match_len_prev = 0, i = 0;\n\n\tmax_len = len_a < len_b ? len_a : len_b;\n\twhile (i < max_len && name_a[i] == name_b[i]) {\n\t\tif (name_a[i] == '/') {\n\t\t\tmatch_len_prev = match_len;\n\t\t\tmatch_len = i;\n\t\t}\n\t\ti++;\n\t}\n\t/*\n\t * Is 'name_b' a substring of 'name_a', the other way around,\n\t * or is 'name_a' and 'name_b' the exact same string?\n\t */\n\tif (i >= max_len && ((len_a > len_b && name_a[len_b] == '/') ||\n\t\t\t     (len_a < len_b && name_b[len_a] == '/') ||\n\t\t\t     (len_a == len_b))) {\n\t\tmatch_len_prev = match_len;\n\t\tmatch_len = i;\n\t}\n\t*previous_slash = match_len_prev;\n\treturn match_len;\n}\n\nstatic struct cache_def default_cache = CACHE_DEF_INIT;\n\nstatic inline void reset_lstat_cache(struct cache_def *cache)\n{\n\tstrbuf_reset(&cache->path);\n\tcache->flags = 0;\n\t/*\n\t * The track_flags and prefix_len_stat_func members is only\n\t * set by the safeguard rule inside lstat_cache()\n\t */\n}\n\n#define FL_DIR      (1 << 0)\n#define FL_NOENT    (1 << 1)\n#define FL_SYMLINK  (1 << 2)\n#define FL_LSTATERR (1 << 3)\n#define FL_ERR      (1 << 4)\n#define FL_FULLPATH (1 << 5)\n\n/*\n * Check if name 'name' of length 'len' has a symlink leading\n * component, or if the directory exists and is real, or not.\n *\n * To speed up the check, some information is allowed to be cached.\n * This can be indicated by the 'track_flags' argument, which also can\n * be used to indicate that we should check the full path.\n *\n * The 'prefix_len_stat_func' parameter can be used to set the length\n * of the prefix, where the cache should use the stat() function\n * instead of the lstat() function to test each path component.\n */\nstatic int lstat_cache_matchlen(struct cache_def *cache,\n\t\t\t\tconst char *name, int len,\n\t\t\t\tint *ret_flags, int track_flags,\n\t\t\t\tint prefix_len_stat_func)\n{\n\tint match_len, last_slash, last_slash_dir, previous_slash;\n\tint save_flags, ret;\n\tstruct stat st;\n\n\tif (cache->track_flags != track_flags ||\n\t    cache->prefix_len_stat_func != prefix_len_stat_func) {\n\t\t/*\n\t\t * As a safeguard rule we clear the cache if the\n\t\t * values of track_flags and/or prefix_len_stat_func\n\t\t * does not match with the last supplied values.\n\t\t */\n\t\treset_lstat_cache(cache);\n\t\tcache->track_flags = track_flags;\n\t\tcache->prefix_len_stat_func = prefix_len_stat_func;\n\t\tmatch_len = last_slash = 0;\n\t} else {\n\t\t/*\n\t\t * Check to see if we have a match from the cache for\n\t\t * the 2 \"excluding\" path types.\n\t\t */\n\t\tmatch_len = last_slash =\n\t\t\tlongest_path_match(name, len, cache->path.buf,\n\t\t\t\t\t   cache->path.len, &previous_slash);\n\t\t*ret_flags = cache->flags & track_flags & (FL_NOENT|FL_SYMLINK);\n\n\t\tif (!(track_flags & FL_FULLPATH) && match_len == len)\n\t\t\tmatch_len = last_slash = previous_slash;\n\n\t\tif (*ret_flags && match_len == cache->path.len)\n\t\t\treturn match_len;\n\t\t/*\n\t\t * If we now have match_len > 0, we would know that\n\t\t * the matched part will always be a directory.\n\t\t *\n\t\t * Also, if we are tracking directories and 'name' is\n\t\t * a substring of the cache on a path component basis,\n\t\t * we can return immediately.\n\t\t */\n\t\t*ret_flags = track_flags & FL_DIR;\n\t\tif (*ret_flags && len == match_len)\n\t\t\treturn match_len;\n\t}\n\n\t/*\n\t * Okay, no match from the cache so far, so now we have to\n\t * check the rest of the path components.\n\t */\n\t*ret_flags = FL_DIR;\n\tlast_slash_dir = last_slash;\n\tif (len > cache->path.len)\n\t\tstrbuf_grow(&cache->path, len - cache->path.len);\n\twhile (match_len < len) {\n\t\tdo {\n\t\t\tcache->path.buf[match_len] = name[match_len];\n\t\t\tmatch_len++;\n\t\t} while (match_len < len && name[match_len] != '/');\n\t\tif (match_len >= len && !(track_flags & FL_FULLPATH))\n\t\t\tbreak;\n\t\tlast_slash = match_len;\n\t\tcache->path.buf[last_slash] = '\\0';\n\n\t\tif (last_slash <= prefix_len_stat_func)\n\t\t\tret = stat(cache->path.buf, &st);\n\t\telse\n\t\t\tret = lstat(cache->path.buf, &st);\n\n\t\tif (ret) {\n\t\t\t*ret_flags = FL_LSTATERR;\n\t\t\tif (errno == ENOENT)\n\t\t\t\t*ret_flags |= FL_NOENT;\n\t\t} else if (S_ISDIR(st.st_mode)) {\n\t\t\tlast_slash_dir = last_slash;\n\t\t\tcontinue;\n\t\t} else if (S_ISLNK(st.st_mode)) {\n\t\t\t*ret_flags = FL_SYMLINK;\n\t\t} else {\n\t\t\t*ret_flags = FL_ERR;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * At the end update the cache.  Note that max 3 different\n\t * path types, FL_NOENT, FL_SYMLINK and FL_DIR, can be cached\n\t * for the moment!\n\t */\n\tsave_flags = *ret_flags & track_flags & (FL_NOENT|FL_SYMLINK);\n\tif (save_flags && last_slash > 0) {\n\t\tcache->path.buf[last_slash] = '\\0';\n\t\tcache->path.len = last_slash;\n\t\tcache->flags = save_flags;\n\t} else if ((track_flags & FL_DIR) && last_slash_dir > 0) {\n\t\t/*\n\t\t * We have a separate test for the directory case,\n\t\t * since it could be that we have found a symlink or a\n\t\t * non-existing directory and the track_flags says\n\t\t * that we cannot cache this fact, so the cache would\n\t\t * then have been left empty in this case.\n\t\t *\n\t\t * But if we are allowed to track real directories, we\n\t\t * can still cache the path components before the last\n\t\t * one (the found symlink or non-existing component).\n\t\t */\n\t\tcache->path.buf[last_slash_dir] = '\\0';\n\t\tcache->path.len = last_slash_dir;\n\t\tcache->flags = FL_DIR;\n\t} else {\n\t\treset_lstat_cache(cache);\n\t}\n\treturn match_len;\n}\n\nstatic int lstat_cache(struct cache_def *cache, const char *name, int len,\n\t\t       int track_flags, int prefix_len_stat_func)\n{\n\tint flags;\n\t(void)lstat_cache_matchlen(cache, name, len, &flags, track_flags,\n\t\t\tprefix_len_stat_func);\n\treturn flags;\n}\n\n#define USE_ONLY_LSTAT  0\n\n/*\n * Return non-zero if path 'name' has a leading symlink component\n */\nint threaded_has_symlink_leading_path(struct cache_def *cache, const char *name, int len)\n{\n\treturn lstat_cache(cache, name, len, FL_SYMLINK|FL_DIR, USE_ONLY_LSTAT) & FL_SYMLINK;\n}\n\n/*\n * Return non-zero if path 'name' has a leading symlink component\n */\nint has_symlink_leading_path(const char *name, int len)\n{\n\treturn threaded_has_symlink_leading_path(&default_cache, name, len);\n}\n\n/*\n * Return zero if path 'name' has a leading symlink component or\n * if some leading path component does not exists.\n *\n * Return -1 if leading path exists and is a directory.\n *\n * Return path length if leading path exists and is neither a\n * directory nor a symlink.\n */\nint check_leading_path(const char *name, int len)\n{\n    return threaded_check_leading_path(&default_cache, name, len);\n}\n\n/*\n * Return zero if path 'name' has a leading symlink component or\n * if some leading path component does not exists.\n *\n * Return -1 if leading path exists and is a directory.\n *\n * Return path length if leading path exists and is neither a\n * directory nor a symlink.\n */\nstatic int threaded_check_leading_path(struct cache_def *cache, const char *name, int len)\n{\n\tint flags;\n\tint match_len = lstat_cache_matchlen(cache, name, len, &flags,\n\t\t\t   FL_SYMLINK|FL_NOENT|FL_DIR, USE_ONLY_LSTAT);\n\tif (flags & FL_NOENT)\n\t\treturn 0;\n\telse if (flags & FL_DIR)\n\t\treturn -1;\n\telse\n\t\treturn match_len;\n}\n\n/*\n * Return non-zero if all path components of 'name' exists as a\n * directory.  If prefix_len > 0, we will test with the stat()\n * function instead of the lstat() function for a prefix length of\n * 'prefix_len', thus we then allow for symlinks in the prefix part as\n * long as those points to real existing directories.\n */\nint has_dirs_only_path(const char *name, int len, int prefix_len)\n{\n\treturn threaded_has_dirs_only_path(&default_cache, name, len, prefix_len);\n}\n\n/*\n * Return non-zero if all path components of 'name' exists as a\n * directory.  If prefix_len > 0, we will test with the stat()\n * function instead of the lstat() function for a prefix length of\n * 'prefix_len', thus we then allow for symlinks in the prefix part as\n * long as those points to real existing directories.\n */\nstatic int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n{\n\t/*\n\t * Note: this function is used by the checkout machinery, which also\n\t * takes care to properly reset the cache when it performs an operation\n\t * that would leave the cache outdated. If this function starts caching\n\t * anything else besides FL_DIR, remember to also invalidate the cache\n\t * when creating or deleting paths that might be in the cache.\n\t */\n\treturn lstat_cache(cache, name, len,\n\t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n\t\tFL_DIR;\n}\n\nstatic struct strbuf removal = STRBUF_INIT;\n\nstatic void do_remove_scheduled_dirs(int new_len)\n{\n\twhile (removal.len > new_len) {\n\t\tremoval.buf[removal.len] = '\\0';\n\t\tif (rmdir(removal.buf))\n\t\t\tbreak;\n\t\tdo {\n\t\t\tremoval.len--;\n\t\t} while (removal.len > new_len &&\n\t\t\t removal.buf[removal.len] != '/');\n\t}\n\tremoval.len = new_len;\n}\n\nvoid schedule_dir_for_removal(const char *name, int len)\n{\n\tint match_len, last_slash, i, previous_slash;\n\n\tmatch_len = last_slash = i =\n\t\tlongest_path_match(name, len, removal.buf, removal.len,\n\t\t\t\t   &previous_slash);\n\t/* Find last slash inside 'name' */\n\twhile (i < len) {\n\t\tif (name[i] == '/')\n\t\t\tlast_slash = i;\n\t\ti++;\n\t}\n\n\t/*\n\t * If we are about to go down the directory tree, we check if\n\t * we must first go upwards the tree, such that we then can\n\t * remove possible empty directories as we go upwards.\n\t */\n\tif (match_len < last_slash && match_len < removal.len)\n\t\tdo_remove_scheduled_dirs(match_len);\n\t/*\n\t * If we go deeper down the directory tree, we only need to\n\t * save the new path components as we go down.\n\t */\n\tif (match_len < last_slash)\n\t\tstrbuf_add(&removal, &name[match_len], last_slash - match_len);\n}\n\nvoid remove_scheduled_dirs(void)\n{\n\tdo_remove_scheduled_dirs(0);\n}\n\nvoid invalidate_lstat_cache(void)\n{\n\treset_lstat_cache(&default_cache);\n}\n\n#undef rmdir\nint lstat_cache_aware_rmdir(const char *path)\n{\n\t/* Any change in this function must be made also in `mingw_rmdir()` */\n\tint ret = rmdir(path);\n\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\n\treturn ret;\n}\n", "#!/bin/sh\n\ntest_description='blob conversion via gitattributes'\n\n. ./test-lib.sh\n\nTEST_ROOT=\"$PWD\"\nPATH=$TEST_ROOT:$PATH\n\nwrite_script <<\\EOF \"$TEST_ROOT/rot13.sh\"\ntr \\\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' \\\n  'nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'\nEOF\n\nwrite_script rot13-filter.pl \"$PERL_PATH\" \\\n\t<\"$TEST_DIRECTORY\"/t0021/rot13-filter.pl\n\ngenerate_random_characters () {\n\tLEN=$1\n\tNAME=$2\n\ttest-genrandom some-seed $LEN |\n\t\tperl -pe \"s/./chr((ord($&) % 26) + ord('a'))/sge\" >\"$TEST_ROOT/$NAME\"\n}\n\nfile_size () {\n\tperl -e 'print -s $ARGV[0]' \"$1\"\n}\n\nfilter_git () {\n\trm -f *.log &&\n\tgit \"$@\"\n}\n\n# Compare two files and ensure that `clean` and `smudge` respectively are\n# called at least once if specified in the `expect` file. The actual\n# invocation count is not relevant because their number can vary.\n# c.f. http://public-inbox.org/git/xmqqshv18i8i.fsf@gitster.mtv.corp.google.com/\ntest_cmp_count () {\n\texpect=$1\n\tactual=$2\n\tfor FILE in \"$expect\" \"$actual\"\n\tdo\n\t\tsort \"$FILE\" | uniq -c |\n\t\tsed -e \"s/^ *[0-9][0-9]*[ \t]*IN: /x IN: /\" >\"$FILE.tmp\"\n\tdone &&\n\ttest_cmp \"$expect.tmp\" \"$actual.tmp\" &&\n\trm \"$expect.tmp\" \"$actual.tmp\"\n}\n\n# Compare two files but exclude all `clean` invocations because Git can\n# call `clean` zero or more times.\n# c.f. http://public-inbox.org/git/xmqqshv18i8i.fsf@gitster.mtv.corp.google.com/\ntest_cmp_exclude_clean () {\n\texpect=$1\n\tactual=$2\n\tfor FILE in \"$expect\" \"$actual\"\n\tdo\n\t\tgrep -v \"IN: clean\" \"$FILE\" >\"$FILE.tmp\"\n\tdone &&\n\ttest_cmp \"$expect.tmp\" \"$actual.tmp\" &&\n\trm \"$expect.tmp\" \"$actual.tmp\"\n}\n\n# Check that the contents of two files are equal and that their rot13 version\n# is equal to the committed content.\ntest_cmp_committed_rot13 () {\n\ttest_cmp \"$1\" \"$2\" &&\n\trot13.sh <\"$1\" >expected &&\n\tgit cat-file blob :\"$2\" >actual &&\n\ttest_cmp expected actual\n}\n\ntest_expect_success setup '\n\tgit config filter.rot13.smudge ./rot13.sh &&\n\tgit config filter.rot13.clean ./rot13.sh &&\n\n\t{\n\t    echo \"*.t filter=rot13\"\n\t    echo \"*.i ident\"\n\t} >.gitattributes &&\n\n\t{\n\t    echo a b c d e f g h i j k l m\n\t    echo n o p q r s t u v w x y z\n\t    echo '\\''$Id$'\\''\n\t} >test &&\n\tcat test >test.t &&\n\tcat test >test.o &&\n\tcat test >test.i &&\n\tgit add test test.t test.i &&\n\trm -f test test.t test.i &&\n\tgit checkout -- test test.t test.i &&\n\n\techo \"content-test2\" >test2.o &&\n\techo \"content-test3 - filename with special characters\" >\"test3 '\\''sq'\\'',\\$x=.o\"\n'\n\nscript='s/^\\$Id: \\([0-9a-f]*\\) \\$/\\1/p'\n\ntest_expect_success check '\n\n\ttest_cmp test.o test &&\n\ttest_cmp test.o test.t &&\n\n\t# ident should be stripped in the repository\n\tgit diff --raw --exit-code :test :test.i &&\n\tid=$(git rev-parse --verify :test) &&\n\tembedded=$(sed -ne \"$script\" test.i) &&\n\ttest \"z$id\" = \"z$embedded\" &&\n\n\tgit cat-file blob :test.t >test.r &&\n\n\t./rot13.sh <test.o >test.t &&\n\ttest_cmp test.r test.t\n'\n\n# If an expanded ident ever gets into the repository, we want to make sure that\n# it is collapsed before being expanded again on checkout\ntest_expect_success expanded_in_repo '\n\t{\n\t\techo \"File with expanded keywords\"\n\t\techo \"\\$Id\\$\"\n\t\techo \"\\$Id:\\$\"\n\t\techo \"\\$Id: 0000000000000000000000000000000000000000 \\$\"\n\t\techo \"\\$Id: NoSpaceAtEnd\\$\"\n\t\techo \"\\$Id:NoSpaceAtFront \\$\"\n\t\techo \"\\$Id:NoSpaceAtEitherEnd\\$\"\n\t\techo \"\\$Id: NoTerminatingSymbol\"\n\t\techo \"\\$Id: Foreign Commit With Spaces \\$\"\n\t} >expanded-keywords.0 &&\n\n\t{\n\t\tcat expanded-keywords.0 &&\n\t\tprintf \"\\$Id: NoTerminatingSymbolAtEOF\"\n\t} >expanded-keywords &&\n\tcat expanded-keywords >expanded-keywords-crlf &&\n\tgit add expanded-keywords expanded-keywords-crlf &&\n\tgit commit -m \"File with keywords expanded\" &&\n\tid=$(git rev-parse --verify :expanded-keywords) &&\n\n\t{\n\t\techo \"File with expanded keywords\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: $id \\$\"\n\t\techo \"\\$Id: NoTerminatingSymbol\"\n\t\techo \"\\$Id: Foreign Commit With Spaces \\$\"\n\t} >expected-output.0 &&\n\t{\n\t\tcat expected-output.0 &&\n\t\tprintf \"\\$Id: NoTerminatingSymbolAtEOF\"\n\t} >expected-output &&\n\t{\n\t\tappend_cr <expected-output.0 &&\n\t\tprintf \"\\$Id: NoTerminatingSymbolAtEOF\"\n\t} >expected-output-crlf &&\n\t{\n\t\techo \"expanded-keywords ident\"\n\t\techo \"expanded-keywords-crlf ident text eol=crlf\"\n\t} >>.gitattributes &&\n\n\trm -f expanded-keywords expanded-keywords-crlf &&\n\n\tgit checkout -- expanded-keywords &&\n\ttest_cmp expanded-keywords expected-output &&\n\n\tgit checkout -- expanded-keywords-crlf &&\n\ttest_cmp expanded-keywords-crlf expected-output-crlf\n'\n\n# The use of %f in a filter definition is expanded to the path to\n# the filename being smudged or cleaned.  It must be shell escaped.\n# First, set up some interesting file names and pet them in\n# .gitattributes.\ntest_expect_success 'filter shell-escaped filenames' '\n\tcat >argc.sh <<-EOF &&\n\t#!$SHELL_PATH\n\tcat >/dev/null\n\techo argc: \\$# \"\\$@\"\n\tEOF\n\tnormal=name-no-magic &&\n\tspecial=\"name  with '\\''sq'\\'' and \\$x\" &&\n\techo some test text >\"$normal\" &&\n\techo some test text >\"$special\" &&\n\tgit add \"$normal\" \"$special\" &&\n\tgit commit -q -m \"add files\" &&\n\techo \"name* filter=argc\" >.gitattributes &&\n\n\t# delete the files and check them out again, using a smudge filter\n\t# that will count the args and echo the command-line back to us\n\ttest_config filter.argc.smudge \"sh ./argc.sh %f\" &&\n\trm \"$normal\" \"$special\" &&\n\tgit checkout -- \"$normal\" \"$special\" &&\n\n\t# make sure argc.sh counted the right number of args\n\techo \"argc: 1 $normal\" >expect &&\n\ttest_cmp expect \"$normal\" &&\n\techo \"argc: 1 $special\" >expect &&\n\ttest_cmp expect \"$special\" &&\n\n\t# do the same thing, but with more args in the filter expression\n\ttest_config filter.argc.smudge \"sh ./argc.sh %f --my-extra-arg\" &&\n\trm \"$normal\" \"$special\" &&\n\tgit checkout -- \"$normal\" \"$special\" &&\n\n\t# make sure argc.sh counted the right number of args\n\techo \"argc: 2 $normal --my-extra-arg\" >expect &&\n\ttest_cmp expect \"$normal\" &&\n\techo \"argc: 2 $special --my-extra-arg\" >expect &&\n\ttest_cmp expect \"$special\" &&\n\t:\n'\n\ntest_expect_success 'required filter should filter data' '\n\ttest_config filter.required.smudge ./rot13.sh &&\n\ttest_config filter.required.clean ./rot13.sh &&\n\ttest_config filter.required.required true &&\n\n\techo \"*.r filter=required\" >.gitattributes &&\n\n\tcat test.o >test.r &&\n\tgit add test.r &&\n\n\trm -f test.r &&\n\tgit checkout -- test.r &&\n\ttest_cmp test.o test.r &&\n\n\t./rot13.sh <test.o >expected &&\n\tgit cat-file blob :test.r >actual &&\n\ttest_cmp expected actual\n'\n\ntest_expect_success 'required filter smudge failure' '\n\ttest_config filter.failsmudge.smudge false &&\n\ttest_config filter.failsmudge.clean cat &&\n\ttest_config filter.failsmudge.required true &&\n\n\techo \"*.fs filter=failsmudge\" >.gitattributes &&\n\n\techo test >test.fs &&\n\tgit add test.fs &&\n\trm -f test.fs &&\n\ttest_must_fail git checkout -- test.fs\n'\n\ntest_expect_success 'required filter clean failure' '\n\ttest_config filter.failclean.smudge cat &&\n\ttest_config filter.failclean.clean false &&\n\ttest_config filter.failclean.required true &&\n\n\techo \"*.fc filter=failclean\" >.gitattributes &&\n\n\techo test >test.fc &&\n\ttest_must_fail git add test.fc\n'\n\ntest_expect_success 'filtering large input to small output should use little memory' '\n\ttest_config filter.devnull.clean \"cat >/dev/null\" &&\n\ttest_config filter.devnull.required true &&\n\tfor i in $(test_seq 1 30); do printf \"%1048576d\" 1; done >30MB &&\n\techo \"30MB filter=devnull\" >.gitattributes &&\n\tGIT_MMAP_LIMIT=1m GIT_ALLOC_LIMIT=1m git add 30MB\n'\n\ntest_expect_success 'filter that does not read is fine' '\n\ttest-genrandom foo $((128 * 1024 + 1)) >big &&\n\techo \"big filter=epipe\" >.gitattributes &&\n\ttest_config filter.epipe.clean \"echo xyzzy\" &&\n\tgit add big &&\n\tgit cat-file blob :big >actual &&\n\techo xyzzy >expect &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success EXPENSIVE 'filter large file' '\n\ttest_config filter.largefile.smudge cat &&\n\ttest_config filter.largefile.clean cat &&\n\tfor i in $(test_seq 1 2048); do printf \"%1048576d\" 1; done >2GB &&\n\techo \"2GB filter=largefile\" >.gitattributes &&\n\tgit add 2GB 2>err &&\n\ttest_must_be_empty err &&\n\trm -f 2GB &&\n\tgit checkout -- 2GB 2>err &&\n\ttest_must_be_empty err\n'\n\ntest_expect_success \"filter: clean empty file\" '\n\ttest_config filter.in-repo-header.clean  \"echo cleaned && cat\" &&\n\ttest_config filter.in-repo-header.smudge \"sed 1d\" &&\n\n\techo \"empty-in-worktree    filter=in-repo-header\" >>.gitattributes &&\n\t>empty-in-worktree &&\n\n\techo cleaned >expected &&\n\tgit add empty-in-worktree &&\n\tgit show :empty-in-worktree >actual &&\n\ttest_cmp expected actual\n'\n\ntest_expect_success \"filter: smudge empty file\" '\n\ttest_config filter.empty-in-repo.clean \"cat >/dev/null\" &&\n\ttest_config filter.empty-in-repo.smudge \"echo smudged && cat\" &&\n\n\techo \"empty-in-repo filter=empty-in-repo\" >>.gitattributes &&\n\techo dead data walking >empty-in-repo &&\n\tgit add empty-in-repo &&\n\n\techo smudged >expected &&\n\tgit checkout-index --prefix=filtered- empty-in-repo &&\n\ttest_cmp expected filtered-empty-in-repo\n'\n\ntest_expect_success 'disable filter with empty override' '\n\ttest_config_global filter.disable.smudge false &&\n\ttest_config_global filter.disable.clean false &&\n\ttest_config filter.disable.smudge false &&\n\ttest_config filter.disable.clean false &&\n\n\techo \"*.disable filter=disable\" >.gitattributes &&\n\n\techo test >test.disable &&\n\tgit -c filter.disable.clean= add test.disable 2>err &&\n\ttest_must_be_empty err &&\n\trm -f test.disable &&\n\tgit -c filter.disable.smudge= checkout -- test.disable 2>err &&\n\ttest_must_be_empty err\n'\n\ntest_expect_success 'diff does not reuse worktree files that need cleaning' '\n\ttest_config filter.counter.clean \"echo . >>count; sed s/^/clean:/\" &&\n\techo \"file filter=counter\" >.gitattributes &&\n\ttest_commit one file &&\n\ttest_commit two file &&\n\n\t>count &&\n\tgit diff-tree -p HEAD &&\n\ttest_line_count = 0 count\n'\n\ntest_expect_success PERL 'required process filter should filter data' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\ttest_config_global filter.protocol.required true &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\t\tgit add . &&\n\t\tgit commit -m \"test commit 1\" &&\n\t\tgit branch empty-branch &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tcp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\tmkdir testsubdir &&\n\t\tcp \"$TEST_ROOT/test3 '\\''sq'\\'',\\$x=.o\" \"testsubdir/test3 '\\''sq'\\'',\\$x=.r\" &&\n\t\t>test4-empty.r &&\n\n\t\tS=$(file_size test.r) &&\n\t\tS2=$(file_size test2.r) &&\n\t\tS3=$(file_size \"testsubdir/test3 '\\''sq'\\'',\\$x=.r\") &&\n\n\t\tfilter_git add . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tIN: clean test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tIN: clean test4-empty.r 0 [OK] -- OUT: 0  [OK]\n\t\t\tIN: clean testsubdir/test3 '\\''sq'\\'',\\$x=.r $S3 [OK] -- OUT: $S3 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_count expected.log debug.log &&\n\n\t\tgit commit -m \"test commit 2\" &&\n\t\trm -f test2.r \"testsubdir/test3 '\\''sq'\\'',\\$x=.r\" &&\n\n\t\tfilter_git checkout --quiet --no-progress . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tIN: smudge testsubdir/test3 '\\''sq'\\'',\\$x=.r $S3 [OK] -- OUT: $S3 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\tfilter_git checkout --quiet --no-progress empty-branch &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\tfilter_git checkout --quiet --no-progress master &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tIN: smudge test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tIN: smudge test4-empty.r 0 [OK] -- OUT: 0  [OK]\n\t\t\tIN: smudge testsubdir/test3 '\\''sq'\\'',\\$x=.r $S3 [OK] -- OUT: $S3 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test2.o\" test2.r &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test3 '\\''sq'\\'',\\$x=.o\" \"testsubdir/test3 '\\''sq'\\'',\\$x=.r\"\n\t)\n'\n\ntest_expect_success PERL 'required process filter takes precedence' '\n\ttest_config_global filter.protocol.clean false &&\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean\" &&\n\ttest_config_global filter.protocol.required true &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tS=$(file_size test.r) &&\n\n\t\t# Check that the process filter is invoked here\n\t\tfilter_git add . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_count expected.log debug.log\n\t)\n'\n\ntest_expect_success PERL 'required process filter should be used only for \"clean\" operation only' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean\" &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tS=$(file_size test.r) &&\n\n\t\tfilter_git add . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_count expected.log debug.log &&\n\n\t\trm test.r &&\n\n\t\tfilter_git checkout --quiet --no-progress . &&\n\t\t# If the filter would be used for \"smudge\", too, we would see\n\t\t# \"IN: smudge test.r 57 [OK] -- OUT: 57 . [OK]\" here\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log\n\t)\n'\n\ntest_expect_success PERL 'required process filter should process multiple packets' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\ttest_config_global filter.protocol.required true &&\n\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\t# Generate data requiring 1, 2, 3 packets\n\t\tS=65516 && # PKTLINE_DATA_MAXLEN -> Maximal size of a packet\n\t\tgenerate_random_characters $(($S    )) 1pkt_1__.file &&\n\t\tgenerate_random_characters $(($S  +1)) 2pkt_1+1.file &&\n\t\tgenerate_random_characters $(($S*2-1)) 2pkt_2-1.file &&\n\t\tgenerate_random_characters $(($S*2  )) 2pkt_2__.file &&\n\t\tgenerate_random_characters $(($S*2+1)) 3pkt_2+1.file &&\n\n\t\tfor FILE in \"$TEST_ROOT\"/*.file\n\t\tdo\n\t\t\tcp \"$FILE\" . &&\n\t\t\trot13.sh <\"$FILE\" >\"$FILE.rot13\"\n\t\tdone &&\n\n\t\techo \"*.file filter=protocol\" >.gitattributes &&\n\t\tfilter_git add *.file .gitattributes &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: clean 1pkt_1__.file $(($S    )) [OK] -- OUT: $(($S    )) . [OK]\n\t\t\tIN: clean 2pkt_1+1.file $(($S  +1)) [OK] -- OUT: $(($S  +1)) .. [OK]\n\t\t\tIN: clean 2pkt_2-1.file $(($S*2-1)) [OK] -- OUT: $(($S*2-1)) .. [OK]\n\t\t\tIN: clean 2pkt_2__.file $(($S*2  )) [OK] -- OUT: $(($S*2  )) .. [OK]\n\t\t\tIN: clean 3pkt_2+1.file $(($S*2+1)) [OK] -- OUT: $(($S*2+1)) ... [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_count expected.log debug.log &&\n\n\t\trm -f *.file &&\n\n\t\tfilter_git checkout --quiet --no-progress -- *.file &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge 1pkt_1__.file $(($S    )) [OK] -- OUT: $(($S    )) . [OK]\n\t\t\tIN: smudge 2pkt_1+1.file $(($S  +1)) [OK] -- OUT: $(($S  +1)) .. [OK]\n\t\t\tIN: smudge 2pkt_2-1.file $(($S*2-1)) [OK] -- OUT: $(($S*2-1)) .. [OK]\n\t\t\tIN: smudge 2pkt_2__.file $(($S*2  )) [OK] -- OUT: $(($S*2  )) .. [OK]\n\t\t\tIN: smudge 3pkt_2+1.file $(($S*2+1)) [OK] -- OUT: $(($S*2+1)) ... [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\tfor FILE in *.file\n\t\tdo\n\t\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/$FILE\" $FILE\n\t\tdone\n\t)\n'\n\ntest_expect_success PERL 'required process filter with clean error should fail' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\ttest_config_global filter.protocol.required true &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\techo \"this is going to fail\" >clean-write-fail.r &&\n\t\techo \"content-test3-subdir\" >test3.r &&\n\n\t\ttest_must_fail git add .\n\t)\n'\n\ntest_expect_success PERL 'process filter should restart after unexpected write failure' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tcp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\techo \"this is going to fail\" >smudge-write-fail.o &&\n\t\tcp smudge-write-fail.o smudge-write-fail.r &&\n\n\t\tS=$(file_size test.r) &&\n\t\tS2=$(file_size test2.r) &&\n\t\tSF=$(file_size smudge-write-fail.r) &&\n\n\t\tgit add . &&\n\t\trm -f *.r &&\n\n\t\trm -f debug.log &&\n\t\tgit checkout --quiet --no-progress . 2>git-stderr.log &&\n\n\t\tgrep \"smudge write error at\" git-stderr.log &&\n\t\tgrep \"error: external filter\" git-stderr.log &&\n\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge smudge-write-fail.r $SF [OK] -- [WRITE FAIL]\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tIN: smudge test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test2.o\" test2.r &&\n\n\t\t# Smudge failed\n\t\t! test_cmp smudge-write-fail.o smudge-write-fail.r &&\n\t\trot13.sh <smudge-write-fail.o >expected &&\n\t\tgit cat-file blob :smudge-write-fail.r >actual &&\n\t\ttest_cmp expected actual\n\t)\n'\n\ntest_expect_success PERL 'process filter should not be restarted if it signals an error' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tcp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\techo \"this will cause an error\" >error.o &&\n\t\tcp error.o error.r &&\n\n\t\tS=$(file_size test.r) &&\n\t\tS2=$(file_size test2.r) &&\n\t\tSE=$(file_size error.r) &&\n\n\t\tgit add . &&\n\t\trm -f *.r &&\n\n\t\tfilter_git checkout --quiet --no-progress . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge error.r $SE [OK] -- [ERROR]\n\t\t\tIN: smudge test.r $S [OK] -- OUT: $S . [OK]\n\t\t\tIN: smudge test2.r $S2 [OK] -- OUT: $S2 . [OK]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test2.o\" test2.r &&\n\t\ttest_cmp error.o error.r\n\t)\n'\n\ntest_expect_success PERL 'process filter abort stops processing of all further files' '\n\ttest_config_global filter.protocol.process \"rot13-filter.pl debug.log clean smudge\" &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\tcp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\techo \"error this blob and all future blobs\" >abort.o &&\n\t\tcp abort.o abort.r &&\n\n\t\tSA=$(file_size abort.r) &&\n\n\t\tgit add . &&\n\t\trm -f *.r &&\n\n\t\t# Note: This test assumes that Git filters files in alphabetical\n\t\t# order (\"abort.r\" before \"test.r\").\n\t\tfilter_git checkout --quiet --no-progress . &&\n\t\tcat >expected.log <<-EOF &&\n\t\t\tSTART\n\t\t\tinit handshake complete\n\t\t\tIN: smudge abort.r $SA [OK] -- [ABORT]\n\t\t\tSTOP\n\t\tEOF\n\t\ttest_cmp_exclude_clean expected.log debug.log &&\n\n\t\ttest_cmp \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_cmp \"$TEST_ROOT/test2.o\" test2.r &&\n\t\ttest_cmp abort.o abort.r\n\t)\n'\n\ntest_expect_success PERL 'invalid process filter must fail (and not hang!)' '\n\ttest_config_global filter.protocol.process cat &&\n\ttest_config_global filter.protocol.required true &&\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\n\t\techo \"*.r filter=protocol\" >.gitattributes &&\n\n\t\tcp \"$TEST_ROOT/test.o\" test.r &&\n\t\ttest_must_fail git add . 2>git-stderr.log &&\n\t\tgrep \"expected git-filter-server\" git-stderr.log\n\t)\n'\n\ntest_expect_success PERL 'delayed checkout in process filter' '\n\ttest_config_global filter.a.process \"rot13-filter.pl a.log clean smudge delay\" &&\n\ttest_config_global filter.a.required true &&\n\ttest_config_global filter.b.process \"rot13-filter.pl b.log clean smudge delay\" &&\n\ttest_config_global filter.b.required true &&\n\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\t\techo \"*.a filter=a\" >.gitattributes &&\n\t\techo \"*.b filter=b\" >>.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" test.a &&\n\t\tcp \"$TEST_ROOT/test.o\" test-delay10.a &&\n\t\tcp \"$TEST_ROOT/test.o\" test-delay11.a &&\n\t\tcp \"$TEST_ROOT/test.o\" test-delay20.a &&\n\t\tcp \"$TEST_ROOT/test.o\" test-delay10.b &&\n\t\tgit add . &&\n\t\tgit commit -m \"test commit\"\n\t) &&\n\n\tS=$(file_size \"$TEST_ROOT/test.o\") &&\n\tcat >a.exp <<-EOF &&\n\t\tSTART\n\t\tinit handshake complete\n\t\tIN: smudge test.a $S [OK] -- OUT: $S . [OK]\n\t\tIN: smudge test-delay10.a $S [OK] -- [DELAYED]\n\t\tIN: smudge test-delay11.a $S [OK] -- [DELAYED]\n\t\tIN: smudge test-delay20.a $S [OK] -- [DELAYED]\n\t\tIN: list_available_blobs test-delay10.a test-delay11.a [OK]\n\t\tIN: smudge test-delay10.a 0 [OK] -- OUT: $S . [OK]\n\t\tIN: smudge test-delay11.a 0 [OK] -- OUT: $S . [OK]\n\t\tIN: list_available_blobs test-delay20.a [OK]\n\t\tIN: smudge test-delay20.a 0 [OK] -- OUT: $S . [OK]\n\t\tIN: list_available_blobs [OK]\n\t\tSTOP\n\tEOF\n\tcat >b.exp <<-EOF &&\n\t\tSTART\n\t\tinit handshake complete\n\t\tIN: smudge test-delay10.b $S [OK] -- [DELAYED]\n\t\tIN: list_available_blobs test-delay10.b [OK]\n\t\tIN: smudge test-delay10.b 0 [OK] -- OUT: $S . [OK]\n\t\tIN: list_available_blobs [OK]\n\t\tSTOP\n\tEOF\n\n\trm -rf repo-cloned &&\n\tfilter_git clone repo repo-cloned &&\n\ttest_cmp_count a.exp repo-cloned/a.log &&\n\ttest_cmp_count b.exp repo-cloned/b.log &&\n\n\t(\n\t\tcd repo-cloned &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay10.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay11.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay20.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay10.b &&\n\n\t\trm *.a *.b &&\n\t\tfilter_git checkout . &&\n\t\ttest_cmp_count ../a.exp a.log &&\n\t\ttest_cmp_count ../b.exp b.log &&\n\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay10.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay11.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay20.a &&\n\t\ttest_cmp_committed_rot13 \"$TEST_ROOT/test.o\" test-delay10.b\n\t)\n'\n\ntest_expect_success PERL 'missing file in delayed checkout' '\n\ttest_config_global filter.bug.process \"rot13-filter.pl bug.log clean smudge delay\" &&\n\ttest_config_global filter.bug.required true &&\n\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\t\techo \"*.a filter=bug\" >.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" missing-delay.a\n\t\tgit add . &&\n\t\tgit commit -m \"test commit\"\n\t) &&\n\n\trm -rf repo-cloned &&\n\ttest_must_fail git clone repo repo-cloned 2>git-stderr.log &&\n\tcat git-stderr.log &&\n\tgrep \"error: .missing-delay\\.a. was not filtered properly\" git-stderr.log\n'\n\ntest_expect_success PERL 'invalid file in delayed checkout' '\n\ttest_config_global filter.bug.process \"rot13-filter.pl bug.log clean smudge delay\" &&\n\ttest_config_global filter.bug.required true &&\n\n\trm -rf repo &&\n\tmkdir repo &&\n\t(\n\t\tcd repo &&\n\t\tgit init &&\n\t\techo \"*.a filter=bug\" >.gitattributes &&\n\t\tcp \"$TEST_ROOT/test.o\" invalid-delay.a &&\n\t\tcp \"$TEST_ROOT/test.o\" unfiltered\n\t\tgit add . &&\n\t\tgit commit -m \"test commit\"\n\t) &&\n\n\trm -rf repo-cloned &&\n\ttest_must_fail git clone repo repo-cloned 2>git-stderr.log &&\n\tgrep \"error: external filter .* signaled that .unfiltered. is now available although it has not been delayed earlier\" git-stderr.log\n'\n\nfor mode in 'case' 'utf-8'\ndo\n\tcase \"$mode\" in\n\tcase)\tdir='A' symlink='a' mode_prereq='CASE_INSENSITIVE_FS' ;;\n\tutf-8)\n\t\tdir=$(printf \"\\141\\314\\210\") symlink=$(printf \"\\303\\244\")\n\t\tmode_prereq='UTF8_NFD_TO_NFC' ;;\n\tesac\n\n\ttest_expect_success PERL,SYMLINKS,$mode_prereq \\\n\t\"delayed checkout with $mode-collision don't write to the wrong place\" '\n\t\ttest_config_global filter.delay.process \\\n\t\t\t\"\\\"$TEST_ROOT/rot13-filter.pl\\\" --always-delay delayed.log clean smudge delay\" &&\n\t\ttest_config_global filter.delay.required true &&\n\n\t\tgit init $mode-collision &&\n\t\t(\n\t\t\tcd $mode-collision &&\n\t\t\tmkdir target-dir &&\n\n\t\t\tempty_oid=$(printf \"\" | git hash-object -w --stdin) &&\n\t\t\tsymlink_oid=$(printf \"%s\" \"$PWD/target-dir\" | git hash-object -w --stdin) &&\n\t\t\tattr_oid=$(echo \"$dir/z filter=delay\" | git hash-object -w --stdin) &&\n\n\t\t\tcat >objs <<-EOF &&\n\t\t\t100644 blob $empty_oid\t$dir/x\n\t\t\t100644 blob $empty_oid\t$dir/y\n\t\t\t100644 blob $empty_oid\t$dir/z\n\t\t\t120000 blob $symlink_oid\t$symlink\n\t\t\t100644 blob $attr_oid\t.gitattributes\n\t\t\tEOF\n\n\t\t\tgit update-index --index-info <objs &&\n\t\t\tgit commit -m \"test commit\"\n\t\t) &&\n\n\t\tgit clone $mode-collision $mode-collision-cloned &&\n\t\t# Make sure z was really delayed\n\t\tgrep \"IN: smudge $dir/z .* \\\\[DELAYED\\\\]\" $mode-collision-cloned/delayed.log &&\n\n\t\t# Should not create $dir/z at $symlink/z\n\t\ttest_path_is_missing $mode-collision/target-dir/z\n\t'\ndone\n\ntest_done\n", "#\n# Example implementation for the Git filter protocol version 2\n# See Documentation/gitattributes.txt, section \"Filter Protocol\"\n#\n# Usage: rot13-filter.pl [--always-delay] <log path> <capabilities>\n#\n# Log path defines a debug log file that the script writes to. The\n# subsequent arguments define a list of supported protocol capabilities\n# (\"clean\", \"smudge\", etc).\n#\n# When --always-delay is given all pathnames with the \"can-delay\" flag\n# that don't appear on the list bellow are delayed with a count of 1\n# (see more below).\n#\n# This implementation supports special test cases:\n# (1) If data with the pathname \"clean-write-fail.r\" is processed with\n#     a \"clean\" operation then the write operation will die.\n# (2) If data with the pathname \"smudge-write-fail.r\" is processed with\n#     a \"smudge\" operation then the write operation will die.\n# (3) If data with the pathname \"error.r\" is processed with any\n#     operation then the filter signals that it cannot or does not want\n#     to process the file.\n# (4) If data with the pathname \"abort.r\" is processed with any\n#     operation then the filter signals that it cannot or does not want\n#     to process the file and any file after that is processed with the\n#     same command.\n# (5) If data with a pathname that is a key in the DELAY hash is\n#     requested (e.g. \"test-delay10.a\") then the filter responds with\n#     a \"delay\" status and sets the \"requested\" field in the DELAY hash.\n#     The filter will signal the availability of this object after\n#     \"count\" (field in DELAY hash) \"list_available_blobs\" commands.\n# (6) If data with the pathname \"missing-delay.a\" is processed that the\n#     filter will drop the path from the \"list_available_blobs\" response.\n# (7) If data with the pathname \"invalid-delay.a\" is processed that the\n#     filter will add the path \"unfiltered\" which was not delayed before\n#     to the \"list_available_blobs\" response.\n#\n\nuse 5.008;\nsub gitperllib {\n\t# Git assumes that all path lists are Unix-y colon-separated ones. But\n\t# when the Git for Windows executes the test suite, its MSYS2 Bash\n\t# calls git.exe, and colon-separated path lists are converted into\n\t# Windows-y semicolon-separated lists of *Windows* paths (which\n\t# naturally contain a colon after the drive letter, so splitting by\n\t# colons simply does not cut it).\n\t#\n\t# Detect semicolon-separated path list and handle them appropriately.\n\n\tif ($ENV{GITPERLLIB} =~ /;/) {\n\t\treturn split(/;/, $ENV{GITPERLLIB});\n\t}\n\treturn split(/:/, $ENV{GITPERLLIB});\n}\nuse lib (gitperllib());\nuse strict;\nuse warnings;\nuse IO::File;\nuse Git::Packet;\n\nmy $MAX_PACKET_CONTENT_SIZE = 65516;\n\nmy $always_delay = 0;\nif ( $ARGV[0] eq '--always-delay' ) {\n\t$always_delay = 1;\n\tshift @ARGV;\n}\n\nmy $log_file                = shift @ARGV;\nmy @capabilities            = @ARGV;\n\nopen my $debug, \">>\", $log_file or die \"cannot open log file: $!\";\n\nmy %DELAY = (\n\t'test-delay10.a' => { \"requested\" => 0, \"count\" => 1 },\n\t'test-delay11.a' => { \"requested\" => 0, \"count\" => 1 },\n\t'test-delay20.a' => { \"requested\" => 0, \"count\" => 2 },\n\t'test-delay10.b' => { \"requested\" => 0, \"count\" => 1 },\n\t'missing-delay.a' => { \"requested\" => 0, \"count\" => 1 },\n\t'invalid-delay.a' => { \"requested\" => 0, \"count\" => 1 },\n);\n\nsub rot13 {\n\tmy $str = shift;\n\t$str =~ y/A-Za-z/N-ZA-Mn-za-m/;\n\treturn $str;\n}\n\nprint $debug \"START\\n\";\n$debug->flush();\n\npacket_initialize(\"git-filter\", 2);\n\nmy %remote_caps = packet_read_and_check_capabilities(\"clean\", \"smudge\", \"delay\");\npacket_check_and_write_capabilities(\\%remote_caps, @capabilities);\n\nprint $debug \"init handshake complete\\n\";\n$debug->flush();\n\nwhile (1) {\n\tmy ( $res, $command ) = packet_key_val_read(\"command\");\n\tif ( $res == -1 ) {\n\t\tprint $debug \"STOP\\n\";\n\t\texit();\n\t}\n\tprint $debug \"IN: $command\";\n\t$debug->flush();\n\n\tif ( $command eq \"list_available_blobs\" ) {\n\t\t# Flush\n\t\tpacket_compare_lists([1, \"\"], packet_bin_read()) ||\n\t\t\tdie \"bad list_available_blobs end\";\n\n\t\tforeach my $pathname ( sort keys %DELAY ) {\n\t\t\tif ( $DELAY{$pathname}{\"requested\"} >= 1 ) {\n\t\t\t\t$DELAY{$pathname}{\"count\"} = $DELAY{$pathname}{\"count\"} - 1;\n\t\t\t\tif ( $pathname eq \"invalid-delay.a\" ) {\n\t\t\t\t\t# Send Git a pathname that was not delayed earlier\n\t\t\t\t\tpacket_txt_write(\"pathname=unfiltered\");\n\t\t\t\t}\n\t\t\t\tif ( $pathname eq \"missing-delay.a\" ) {\n\t\t\t\t\t# Do not signal Git that this file is available\n\t\t\t\t} elsif ( $DELAY{$pathname}{\"count\"} == 0 ) {\n\t\t\t\t\tprint $debug \" $pathname\";\n\t\t\t\t\tpacket_txt_write(\"pathname=$pathname\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpacket_flush();\n\n\t\tprint $debug \" [OK]\\n\";\n\t\t$debug->flush();\n\t\tpacket_txt_write(\"status=success\");\n\t\tpacket_flush();\n\t} else {\n\t\tmy ( $res, $pathname ) = packet_key_val_read(\"pathname\");\n\t\tif ( $res == -1 ) {\n\t\t\tdie \"unexpected EOF while expecting pathname\";\n\t\t}\n\t\tprint $debug \" $pathname\";\n\t\t$debug->flush();\n\n\t\t# Read until flush\n\t\tmy ( $done, $buffer ) = packet_txt_read();\n\t\twhile ( $buffer ne '' ) {\n\t\t\tif ( $buffer eq \"can-delay=1\" ) {\n\t\t\t\tif ( exists $DELAY{$pathname} and $DELAY{$pathname}{\"requested\"} == 0 ) {\n\t\t\t\t\t$DELAY{$pathname}{\"requested\"} = 1;\n\t\t\t\t} elsif ( !exists $DELAY{$pathname} and $always_delay ) {\n\t\t\t\t\t$DELAY{$pathname} = { \"requested\" => 1, \"count\" => 1 };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdie \"Unknown message '$buffer'\";\n\t\t\t}\n\n\t\t\t( $done, $buffer ) = packet_txt_read();\n\t\t}\n\t\tif ( $done == -1 ) {\n\t\t\tdie \"unexpected EOF after pathname '$pathname'\";\n\t\t}\n\n\t\tmy $input = \"\";\n\t\t{\n\t\t\tbinmode(STDIN);\n\t\t\tmy $buffer;\n\t\t\tmy $done = 0;\n\t\t\twhile ( !$done ) {\n\t\t\t\t( $done, $buffer ) = packet_bin_read();\n\t\t\t\t$input .= $buffer;\n\t\t\t}\n\t\t\tif ( $done == -1 ) {\n\t\t\t\tdie \"unexpected EOF while reading input for '$pathname'\";\n\t\t\t}\t\t\t\n\t\t\tprint $debug \" \" . length($input) . \" [OK] -- \";\n\t\t\t$debug->flush();\n\t\t}\n\n\t\tmy $output;\n\t\tif ( exists $DELAY{$pathname} and exists $DELAY{$pathname}{\"output\"} ) {\n\t\t\t$output = $DELAY{$pathname}{\"output\"}\n\t\t} elsif ( $pathname eq \"error.r\" or $pathname eq \"abort.r\" ) {\n\t\t\t$output = \"\";\n\t\t} elsif ( $command eq \"clean\" and grep( /^clean$/, @capabilities ) ) {\n\t\t\t$output = rot13($input);\n\t\t} elsif ( $command eq \"smudge\" and grep( /^smudge$/, @capabilities ) ) {\n\t\t\t$output = rot13($input);\n\t\t} else {\n\t\t\tdie \"bad command '$command'\";\n\t\t}\n\n\t\tif ( $pathname eq \"error.r\" ) {\n\t\t\tprint $debug \"[ERROR]\\n\";\n\t\t\t$debug->flush();\n\t\t\tpacket_txt_write(\"status=error\");\n\t\t\tpacket_flush();\n\t\t} elsif ( $pathname eq \"abort.r\" ) {\n\t\t\tprint $debug \"[ABORT]\\n\";\n\t\t\t$debug->flush();\n\t\t\tpacket_txt_write(\"status=abort\");\n\t\t\tpacket_flush();\n\t\t} elsif ( $command eq \"smudge\" and\n\t\t\texists $DELAY{$pathname} and\n\t\t\t$DELAY{$pathname}{\"requested\"} == 1 ) {\n\t\t\tprint $debug \"[DELAYED]\\n\";\n\t\t\t$debug->flush();\n\t\t\tpacket_txt_write(\"status=delayed\");\n\t\t\tpacket_flush();\n\t\t\t$DELAY{$pathname}{\"requested\"} = 2;\n\t\t\t$DELAY{$pathname}{\"output\"} = $output;\n\t\t} else {\n\t\t\tpacket_txt_write(\"status=success\");\n\t\t\tpacket_flush();\n\n\t\t\tif ( $pathname eq \"${command}-write-fail.r\" ) {\n\t\t\t\tprint $debug \"[WRITE FAIL]\\n\";\n\t\t\t\t$debug->flush();\n\t\t\t\tdie \"${command} write error\";\n\t\t\t}\n\n\t\t\tprint $debug \"OUT: \" . length($output) . \" \";\n\t\t\t$debug->flush();\n\n\t\t\twhile ( length($output) > 0 ) {\n\t\t\t\tmy $packet = substr( $output, 0, $MAX_PACKET_CONTENT_SIZE );\n\t\t\t\tpacket_bin_write($packet);\n\t\t\t\t# dots represent the number of packets\n\t\t\t\tprint $debug \".\";\n\t\t\t\tif ( length($output) > $MAX_PACKET_CONTENT_SIZE ) {\n\t\t\t\t\t$output = substr( $output, $MAX_PACKET_CONTENT_SIZE );\n\t\t\t\t} else {\n\t\t\t\t\t$output = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tpacket_flush();\n\t\t\tprint $debug \" [OK]\\n\";\n\t\t\t$debug->flush();\n\t\t\tpacket_flush();\n\t\t}\n\t}\n}\n", "#!/bin/sh\n\ntest_description='basic checkout-index tests\n'\n\n. ./test-lib.sh\n\ntest_expect_success 'checkout-index --gobbledegook' '\n\ttest_expect_code 129 git checkout-index --gobbledegook 2>err &&\n\ttest_i18ngrep \"[Uu]sage\" err\n'\n\ntest_expect_success 'checkout-index -h in broken repository' '\n\tmkdir broken &&\n\t(\n\t\tcd broken &&\n\t\tgit init &&\n\t\t>.git/index &&\n\t\ttest_expect_code 129 git checkout-index -h >usage 2>&1\n\t) &&\n\ttest_i18ngrep \"[Uu]sage\" broken/usage\n'\n\nfor mode in 'case' 'utf-8'\ndo\n\tcase \"$mode\" in\n\tcase)\tdir='A' symlink='a' mode_prereq='CASE_INSENSITIVE_FS' ;;\n\tutf-8)\n\t\tdir=$(printf \"\\141\\314\\210\") symlink=$(printf \"\\303\\244\")\n\t\tmode_prereq='UTF8_NFD_TO_NFC' ;;\n\tesac\n\n\ttest_expect_success SYMLINKS,$mode_prereq \\\n\t\"checkout-index with $mode-collision don't write to the wrong place\" '\n\t\tgit init $mode-collision &&\n\t\t(\n\t\t\tcd $mode-collision &&\n\t\t\tmkdir target-dir &&\n\n\t\t\tempty_obj_hex=$(git hash-object -w --stdin </dev/null) &&\n\t\t\tsymlink_hex=$(printf \"%s\" \"$PWD/target-dir\" | git hash-object -w --stdin) &&\n\n\t\t\tcat >objs <<-EOF &&\n\t\t\t100644 blob ${empty_obj_hex}\t${dir}/x\n\t\t\t100644 blob ${empty_obj_hex}\t${dir}/y\n\t\t\t100644 blob ${empty_obj_hex}\t${dir}/z\n\t\t\t120000 blob ${symlink_hex}\t${symlink}\n\t\t\tEOF\n\n\t\t\tgit update-index --index-info <objs &&\n\n\t\t\t# Note: the order is important here to exercise the\n\t\t\t# case where the file at ${dir} has its type changed by\n\t\t\t# the time Git tries to check out ${dir}/z.\n\t\t\t#\n\t\t\t# Also, we use core.precomposeUnicode=false because we\n\t\t\t# want Git to treat the UTF-8 paths transparently on\n\t\t\t# Mac OS, matching what is in the index.\n\t\t\t#\n\t\t\tgit -c core.precomposeUnicode=false checkout-index -f \\\n\t\t\t\t${dir}/x ${dir}/y ${symlink} ${dir}/z &&\n\n\t\t\t# Should not create ${dir}/z at ${symlink}/z\n\t\t\ttest_path_is_missing target-dir/z\n\n\t\t)\n\t'\ndone\n\ntest_done\n"], "filenames": ["cache.h", "compat/mingw.c", "git-compat-util.h", "symlinks.c", "t/t0021-conversion.sh", "t/t0021/rot13-filter.pl", "t/t2006-checkout-index-basic.sh"], "buggy_code_start_loc": [1571, 285, 338, 269, 819, 5, 23], "buggy_code_end_loc": [1571, 285, 338, 323, 819, 136, 23], "fixing_code_start_loc": [1572, 286, 339, 270, 820, 5, 24], "fixing_code_end_loc": [1573, 288, 344, 348, 865, 152, 70], "type": "CWE-59", "message": "Git is an open-source distributed revision control system. In affected versions of Git a specially crafted repository that contains symbolic links as well as files using a clean/smudge filter such as Git LFS, may cause just-checked out script to be executed while cloning onto a case-insensitive file system such as NTFS, HFS+ or APFS (i.e. the default file systems on Windows and macOS). Note that clean/smudge filters have to be configured for that. Git for Windows configures Git LFS by default, and is therefore vulnerable. The problem has been patched in the versions published on Tuesday, March 9th, 2021. As a workaound, if symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. Likewise, if no clean/smudge filters such as Git LFS are configured globally (i.e. _before_ cloning), the attack is foiled. As always, it is best to avoid cloning repositories from untrusted sources. The earliest impacted version is 2.14.2. The fix versions are: 2.30.1, 2.29.3, 2.28.1, 2.27.1, 2.26.3, 2.25.5, 2.24.4, 2.23.4, 2.22.5, 2.21.4, 2.20.5, 2.19.6, 2.18.5, 2.17.62.17.6.", "other": {"cve": {"id": "CVE-2021-21300", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-09T20:15:13.260", "lastModified": "2022-12-06T21:38:14.987", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Git is an open-source distributed revision control system. In affected versions of Git a specially crafted repository that contains symbolic links as well as files using a clean/smudge filter such as Git LFS, may cause just-checked out script to be executed while cloning onto a case-insensitive file system such as NTFS, HFS+ or APFS (i.e. the default file systems on Windows and macOS). Note that clean/smudge filters have to be configured for that. Git for Windows configures Git LFS by default, and is therefore vulnerable. The problem has been patched in the versions published on Tuesday, March 9th, 2021. As a workaound, if symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. Likewise, if no clean/smudge filters such as Git LFS are configured globally (i.e. _before_ cloning), the attack is foiled. As always, it is best to avoid cloning repositories from untrusted sources. The earliest impacted version is 2.14.2. The fix versions are: 2.30.1, 2.29.3, 2.28.1, 2.27.1, 2.26.3, 2.25.5, 2.24.4, 2.23.4, 2.22.5, 2.21.4, 2.20.5, 2.19.6, 2.18.5, 2.17.62.17.6."}, {"lang": "es", "value": "Git es un sistema de control de revisiones distribuido de c\u00f3digo abierto.&#xa0;En las versiones afectadas de Git, un repositorio especialmente dise\u00f1ado que contiene enlaces simb\u00f3licos, as\u00ed como archivos que usan un filtro clean/smudge como Git LFS, puede hacer que se ejecute un script reci\u00e9n extra\u00eddo mientras se clona en un sistema de archivos que no distingue entre may\u00fasculas y min\u00fasculas como NTFS , HFS+ o APFS (es decir, los sistemas de archivos predeterminados en Windows y macOS).&#xa0;Tome en cuenta que los filtros de clean/smudge deben ser configurados para eso.&#xa0;Git para Windows configura Git LFS por defecto y, por lo tanto, es vulnerable.&#xa0;El problema se ha corregido en las versiones publicadas el martes 9 de marzo de 2021. Como soluci\u00f3n temporal, si el soporte de enlace simb\u00f3lico est\u00e1 deshabilitado en Git (por ejemplo, por medio de \"git config --global core.symlinks false\"), el ataque descrito no funcionar\u00e1.&#xa0;Del mismo modo, si no se configuran globalmente filtros clean/smudge como Git LFS (es decir,_before_ cloning), el ataque se frustra.&#xa0;Como siempre, es mejor evitar la clonaci\u00f3n de repositorios de fuentes no confiables.&#xa0;La primera versi\u00f3n afectada es 2.14.2.&#xa0;Las versiones correctas son: 2.30.1, 2.29.3, 2.28.1, 2.27.1, 2.26.3, 2.25.5, 2.24.4, 2.23.4, 2.22.5, 2.21.4, 2.20.5, 2.19 .6, 2.18.5, 2.17.62.17.6"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.14.2", "matchCriteriaId": "B122112C-041C-4E35-A95B-09A6FEB34E66"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.17.0", "versionEndExcluding": "2.17.6", "matchCriteriaId": "F22EC766-C4F5-478C-812C-DC0ECE2B5017"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.18.0", "versionEndExcluding": "2.18.5", "matchCriteriaId": "852AD237-C1C7-4C6D-8CD0-46FC6CF3CA2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.19.0", "versionEndExcluding": "2.19.6", "matchCriteriaId": "3964581A-A764-44AC-96AA-0FBAC723876C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.20.0", "versionEndExcluding": "2.20.5", "matchCriteriaId": "6B873D83-F63E-4183-8DF5-FB2CA9F7442A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.21.0", "versionEndExcluding": "2.21.4", "matchCriteriaId": "28F16A48-7467-428E-A797-F17C1B33D845"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.22.0", "versionEndExcluding": "2.22.5", "matchCriteriaId": "344A8A7D-A440-46D2-A424-FE9576211B66"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.23.0", "versionEndExcluding": "2.23.4", "matchCriteriaId": "E08D59A6-5026-4E64-A685-3F3C61384AA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.24.0", "versionEndExcluding": "2.24.4", "matchCriteriaId": "800D0A90-9ABA-49AE-AC15-FAB0EAD8E6B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.25.0", "versionEndExcluding": "2.25.5", "matchCriteriaId": "F73CA1C3-0970-4A25-86DF-D6BCF6A245D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.26.0", "versionEndExcluding": "2.26.3", "matchCriteriaId": "C55EAADC-86F7-48AD-ADE6-EAC35900ACCE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.29.0", "versionEndExcluding": "2.29.3", "matchCriteriaId": "60B8D72E-7390-4748-85C3-2143B473B8A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.30.0", "versionEndExcluding": "2.30.2", "matchCriteriaId": "3B4C27E1-AB72-4ABB-8BEF-BA317C229CF8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:2.27.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A303CF1-7129-4C24-B6EB-03E7F5A51FB7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:2.28.0:*:*:*:*:*:*:*", "matchCriteriaId": "8920211C-E92D-41FD-BBFA-4702FB07B4D4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apple:xcode:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.5", "matchCriteriaId": "BD2A6382-E564-4CF6-AE51-62A021766671"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "matchCriteriaId": "FD77D019-6FF7-4D3B-BE07-65C7A6879F12"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/163978/Git-LFS-Clone-Command-Execution.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2021/Apr/60", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/03/09/3", "source": "security-advisories@github.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://git-scm.com/docs/git-config#Documentation/git-config.txt-coresymlinks", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://git-scm.com/docs/gitattributes#_filter", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/git/git/commit/684dd4c2b414bcf648505e74498a608f28de4592", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/git/git/security/advisories/GHSA-8prw-h3cq-mghm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00014.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BBPNGLQSYJHLZZ37BO42YY6S5OTIF4L4/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LCLJJLKKMS5WRFO6C475AOUZTWQLIARX/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LMXX2POK5X576BSDWSXGU7EIK6I72ERU/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/git/xmqqim6019yd.fsf@gitster.c.googlers.com/", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202104-01", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT212320", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/git/git/commit/684dd4c2b414bcf648505e74498a608f28de4592"}}