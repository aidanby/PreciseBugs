{"buggy_code": ["/* Copyright (c) 2013-2018 the Civetweb developers\n * Copyright (c) 2004-2013 Sergey Lyubka\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Disable unused macros warnings - not all defines are required\n * for all systems and all compilers. */\n#pragma GCC diagnostic ignored \"-Wunused-macros\"\n/* A padding warning is just plain useless */\n#pragma GCC diagnostic ignored \"-Wpadded\"\n#endif\n\n#if defined(__clang__) /* GCC does not (yet) support this pragma */\n/* We must set some flags for the headers we include. These flags\n * are reserved ids according to C99, so we need to disable a\n * warning for that. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wreserved-id-macro\"\n#endif\n\n#if defined(_WIN32)\n#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS /* Disable deprecation warning in VS2005 */\n#endif\n#if !defined(_WIN32_WINNT) /* defined for tdm-gcc so we can use getnameinfo */\n#define _WIN32_WINNT 0x0501\n#endif\n#else\n#if !defined(_GNU_SOURCE)\n#define _GNU_SOURCE /* for setgroups(), pthread_setname_np() */\n#endif\n#if defined(__linux__) && !defined(_XOPEN_SOURCE)\n#define _XOPEN_SOURCE 600 /* For flockfile() on Linux */\n#endif\n#if !defined(_LARGEFILE_SOURCE)\n#define _LARGEFILE_SOURCE /* For fseeko(), ftello() */\n#endif\n#if !defined(_FILE_OFFSET_BITS)\n#define _FILE_OFFSET_BITS 64 /* Use 64-bit file offsets by default */\n#endif\n#if !defined(__STDC_FORMAT_MACROS)\n#define __STDC_FORMAT_MACROS /* <inttypes.h> wants this for C++ */\n#endif\n#if !defined(__STDC_LIMIT_MACROS)\n#define __STDC_LIMIT_MACROS /* C++ wants that for INT64_MAX */\n#endif\n#if !defined(_DARWIN_UNLIMITED_SELECT)\n#define _DARWIN_UNLIMITED_SELECT\n#endif\n#if defined(__sun)\n#define __EXTENSIONS__  /* to expose flockfile and friends in stdio.h */\n#define __inline inline /* not recognized on older compiler versions */\n#endif\n#endif\n\n#if defined(__clang__)\n/* Enable reserved-id-macro warning again. */\n#pragma GCC diagnostic pop\n#endif\n\n\n#if defined(USE_LUA)\n#define USE_TIMERS\n#endif\n\n#if defined(_MSC_VER)\n/* 'type cast' : conversion from 'int' to 'HANDLE' of greater size */\n#pragma warning(disable : 4306)\n/* conditional expression is constant: introduced by FD_SET(..) */\n#pragma warning(disable : 4127)\n/* non-constant aggregate initializer: issued due to missing C99 support */\n#pragma warning(disable : 4204)\n/* padding added after data member */\n#pragma warning(disable : 4820)\n/* not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */\n#pragma warning(disable : 4668)\n/* no function prototype given: converting '()' to '(void)' */\n#pragma warning(disable : 4255)\n/* function has been selected for automatic inline expansion */\n#pragma warning(disable : 4711)\n#endif\n\n\n/* This code uses static_assert to check some conditions.\n * Unfortunately some compilers still do not support it, so we have a\n * replacement function here. */\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L\n#define mg_static_assert _Static_assert\n#elif defined(__cplusplus) && __cplusplus >= 201103L\n#define mg_static_assert static_assert\n#else\nchar static_assert_replacement[1];\n#define mg_static_assert(cond, txt)                                            \\\n\textern char static_assert_replacement[(cond) ? 1 : -1]\n#endif\n\nmg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,\n                 \"int data type size check\");\nmg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,\n                 \"pointer data type size check\");\nmg_static_assert(sizeof(void *) >= sizeof(int), \"data type size check\");\n\n\n/* Alternative queue is well tested and should be the new default */\n#if defined(NO_ALTERNATIVE_QUEUE)\n#if defined(ALTERNATIVE_QUEUE)\n#error \"Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE or none, but not both\"\n#endif\n#else\n#define ALTERNATIVE_QUEUE\n#endif\n\n\n/* DTL -- including winsock2.h works better if lean and mean */\n#if !defined(WIN32_LEAN_AND_MEAN)\n#define WIN32_LEAN_AND_MEAN\n#endif\n\n#if defined(__SYMBIAN32__)\n/* According to https://en.wikipedia.org/wiki/Symbian#History,\n * Symbian is no longer maintained since 2014-01-01.\n * Recent versions of CivetWeb are no longer tested for Symbian.\n * It makes no sense, to support an abandoned operating system.\n */\n#error \"Symbian is no longer maintained. CivetWeb no longer supports Symbian.\"\n#define NO_SSL /* SSL is not supported */\n#define NO_CGI /* CGI is not supported */\n#define PATH_MAX FILENAME_MAX\n#endif /* __SYMBIAN32__ */\n\n\n#if !defined(CIVETWEB_HEADER_INCLUDED)\n/* Include the header file here, so the CivetWeb interface is defined for the\n * entire implementation, including the following forward definitions. */\n#include \"civetweb.h\"\n#endif\n\n#if !defined(DEBUG_TRACE)\n#if defined(DEBUG)\nstatic void DEBUG_TRACE_FUNC(const char *func,\n                             unsigned line,\n                             PRINTF_FORMAT_STRING(const char *fmt),\n                             ...) PRINTF_ARGS(3, 4);\n\n#define DEBUG_TRACE(fmt, ...)                                                  \\\n\tDEBUG_TRACE_FUNC(__func__, __LINE__, fmt, __VA_ARGS__)\n\n#define NEED_DEBUG_TRACE_FUNC\n\n#else\n#define DEBUG_TRACE(fmt, ...)                                                  \\\n\tdo {                                                                       \\\n\t} while (0)\n#endif /* DEBUG */\n#endif /* DEBUG_TRACE */\n\n\n#if !defined(DEBUG_ASSERT)\n#if defined(DEBUG)\n#define DEBUG_ASSERT(cond)                                                     \\\n\tdo {                                                                       \\\n\t\tif (!(cond)) {                                                         \\\n\t\t\tDEBUG_TRACE(\"ASSERTION FAILED: %s\", #cond);                        \\\n\t\t\texit(2); /* Exit with error */                                     \\\n\t\t}                                                                      \\\n\t} while (0)\n#else\n#define DEBUG_ASSERT(cond)\n#endif /* DEBUG */\n#endif\n\n\n#if !defined(IGNORE_UNUSED_RESULT)\n#define IGNORE_UNUSED_RESULT(a) ((void)((a) && 1))\n#endif\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n\n/* GCC unused function attribute seems fundamentally broken.\n * Several attempts to tell the compiler \"THIS FUNCTION MAY BE USED\n * OR UNUSED\" for individual functions failed.\n * Either the compiler creates an \"unused-function\" warning if a\n * function is not marked with __attribute__((unused)).\n * On the other hand, if the function is marked with this attribute,\n * but is used, the compiler raises a completely idiotic\n * \"used-but-marked-unused\" warning - and\n *   #pragma GCC diagnostic ignored \"-Wused-but-marked-unused\"\n * raises error: unknown option after \"#pragma GCC diagnostic\".\n * Disable this warning completely, until the GCC guys sober up\n * again.\n */\n\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n\n#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */\n\n#else\n#define FUNCTION_MAY_BE_UNUSED\n#endif\n\n\n/* Some ANSI #includes are not available on Windows CE */\n#if !defined(_WIN32_WCE)\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n#endif /* !_WIN32_WCE */\n\n\n#if defined(__clang__)\n/* When using -Weverything, clang does not accept it's own headers\n * in a release build configuration. Disable what is too much in\n * -Weverything. */\n#pragma clang diagnostic ignored \"-Wdisabled-macro-expansion\"\n#endif\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Who on earth came to the conclusion, using __DATE__ should rise\n * an \"expansion of date or time macro is not reproducible\"\n * warning. That's exactly what was intended by using this macro.\n * Just disable this nonsense warning. */\n\n/* And disabling them does not work either:\n * #pragma clang diagnostic ignored \"-Wno-error=date-time\"\n * #pragma clang diagnostic ignored \"-Wdate-time\"\n * So we just have to disable ALL warnings for some lines\n * of code.\n * This seems to be a known GCC bug, not resolved since 2012:\n * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431\n */\n#endif\n\n\n#if defined(__MACH__) /* Apple OSX section */\n\n#if defined(__clang__)\n#if (__clang_major__ == 3) && ((__clang_minor__ == 7) || (__clang_minor__ == 8))\n/* Avoid warnings for Xcode 7. It seems it does no longer exist in Xcode 8 */\n#pragma clang diagnostic ignored \"-Wno-reserved-id-macro\"\n#pragma clang diagnostic ignored \"-Wno-keyword-macro\"\n#endif\n#endif\n\n#define CLOCK_MONOTONIC (1)\n#define CLOCK_REALTIME (2)\n\n#include <sys/errno.h>\n#include <sys/time.h>\n#include <mach/clock.h>\n#include <mach/mach.h>\n#include <mach/mach_time.h>\n\n/* clock_gettime is not implemented on OSX prior to 10.12 */\nstatic int\n_civet_clock_gettime(int clk_id, struct timespec *t)\n{\n\tmemset(t, 0, sizeof(*t));\n\tif (clk_id == CLOCK_REALTIME) {\n\t\tstruct timeval now;\n\t\tint rv = gettimeofday(&now, NULL);\n\t\tif (rv) {\n\t\t\treturn rv;\n\t\t}\n\t\tt->tv_sec = now.tv_sec;\n\t\tt->tv_nsec = now.tv_usec * 1000;\n\t\treturn 0;\n\n\t} else if (clk_id == CLOCK_MONOTONIC) {\n\t\tstatic uint64_t clock_start_time = 0;\n\t\tstatic mach_timebase_info_data_t timebase_ifo = {0, 0};\n\n\t\tuint64_t now = mach_absolute_time();\n\n\t\tif (clock_start_time == 0) {\n\t\t\tkern_return_t mach_status = mach_timebase_info(&timebase_ifo);\n\t\t\tDEBUG_ASSERT(mach_status == KERN_SUCCESS);\n\n\t\t\t/* appease \"unused variable\" warning for release builds */\n\t\t\t(void)mach_status;\n\n\t\t\tclock_start_time = now;\n\t\t}\n\n\t\tnow = (uint64_t)((double)(now - clock_start_time)\n\t\t                 * (double)timebase_ifo.numer\n\t\t                 / (double)timebase_ifo.denom);\n\n\t\tt->tv_sec = now / 1000000000;\n\t\tt->tv_nsec = now % 1000000000;\n\t\treturn 0;\n\t}\n\treturn -1; /* EINVAL - Clock ID is unknown */\n}\n\n/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */\n#if defined(__CLOCK_AVAILABILITY)\n/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be\n * declared but it may be NULL at runtime. So we need to check before using\n * it. */\nstatic int\n_civet_safe_clock_gettime(int clk_id, struct timespec *t)\n{\n\tif (clock_gettime) {\n\t\treturn clock_gettime(clk_id, t);\n\t}\n\treturn _civet_clock_gettime(clk_id, t);\n}\n#define clock_gettime _civet_safe_clock_gettime\n#else\n#define clock_gettime _civet_clock_gettime\n#endif\n\n#endif\n\n\n#include <time.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdint.h>\n\n/********************************************************************/\n/* CivetWeb configuration defines */\n/********************************************************************/\n\n/* Maximum number of threads that can be configured.\n * The number of threads actually created depends on the \"num_threads\"\n * configuration parameter, but this is the upper limit. */\n#if !defined(MAX_WORKER_THREADS)\n#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */\n#endif\n\n/* Timeout interval for select/poll calls.\n * The timeouts depend on \"*_timeout_ms\" configuration values, but long\n * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.\n * This reduces the time required to stop the server. */\n#if !defined(SOCKET_TIMEOUT_QUANTUM)\n#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */\n#endif\n\n/* Do not try to compress files smaller than this limit. */\n#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT)\n#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */\n#endif\n\n#if !defined(PASSWORDS_FILE_NAME)\n#define PASSWORDS_FILE_NAME \".htpasswd\"\n#endif\n\n/* Initial buffer size for all CGI environment variables. In case there is\n * not enough space, another block is allocated. */\n#if !defined(CGI_ENVIRONMENT_SIZE)\n#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */\n#endif\n\n/* Maximum number of environment variables. */\n#if !defined(MAX_CGI_ENVIR_VARS)\n#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */\n#endif\n\n/* General purpose buffer size. */\n#if !defined(MG_BUF_LEN) /* in bytes */\n#define MG_BUF_LEN (1024 * 8)\n#endif\n\n/* Size of the accepted socket queue (in case the old queue implementation\n * is used). */\n#if !defined(MGSQLEN)\n#define MGSQLEN (20) /* count */\n#endif\n\n\n/********************************************************************/\n\n/* Helper makros */\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\n/* Standard defines */\n#if !defined(INT64_MAX)\n#define INT64_MAX (9223372036854775807)\n#endif\n\n#define SHUTDOWN_RD (0)\n#define SHUTDOWN_WR (1)\n#define SHUTDOWN_BOTH (2)\n\nmg_static_assert(MAX_WORKER_THREADS >= 1,\n                 \"worker threads must be a positive number\");\n\nmg_static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8,\n                 \"size_t data type size check\");\n\n#if defined(_WIN32)   /* WINDOWS include block */\n#include <winsock2.h> /* DTL add for SO_EXCLUSIVE */\n#include <ws2tcpip.h>\n#include <windows.h>\n\ntypedef const char *SOCK_OPT_TYPE;\n\n#if !defined(PATH_MAX)\n#define W_PATH_MAX (MAX_PATH)\n/* at most three UTF-8 chars per wchar_t */\n#define PATH_MAX (W_PATH_MAX * 3)\n#else\n#define W_PATH_MAX ((PATH_MAX + 2) / 3)\n#endif\n\nmg_static_assert(PATH_MAX >= 1, \"path length must be a positive number\");\n\n#if !defined(_IN_PORT_T)\n#if !defined(in_port_t)\n#define in_port_t u_short\n#endif\n#endif\n\n#if !defined(_WIN32_WCE)\n#include <process.h>\n#include <direct.h>\n#include <io.h>\n#else            /* _WIN32_WCE */\n#define NO_CGI   /* WinCE has no pipes */\n#define NO_POPEN /* WinCE has no popen */\n\ntypedef long off_t;\n\n#define errno ((int)(GetLastError()))\n#define strerror(x) (_ultoa(x, (char *)_alloca(sizeof(x) * 3), 10))\n#endif /* _WIN32_WCE */\n\n#define MAKEUQUAD(lo, hi)                                                      \\\n\t((uint64_t)(((uint32_t)(lo)) | ((uint64_t)((uint32_t)(hi))) << 32))\n#define RATE_DIFF (10000000) /* 100 nsecs */\n#define EPOCH_DIFF (MAKEUQUAD(0xd53e8000, 0x019db1de))\n#define SYS2UNIX_TIME(lo, hi)                                                  \\\n\t((time_t)((MAKEUQUAD((lo), (hi)) - EPOCH_DIFF) / RATE_DIFF))\n\n/* Visual Studio 6 does not know __func__ or __FUNCTION__\n * The rest of MS compilers use __FUNCTION__, not C99 __func__\n * Also use _strtoui64 on modern M$ compilers */\n#if defined(_MSC_VER)\n#if (_MSC_VER < 1300)\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n#define strtoull(x, y, z) ((unsigned __int64)_atoi64(x))\n#define strtoll(x, y, z) (_atoi64(x))\n#else\n#define __func__ __FUNCTION__\n#define strtoull(x, y, z) (_strtoui64(x, y, z))\n#define strtoll(x, y, z) (_strtoi64(x, y, z))\n#endif\n#endif /* _MSC_VER */\n\n#define ERRNO ((int)(GetLastError()))\n#define NO_SOCKLEN_T\n\n#if defined(_WIN64) || defined(__MINGW64__)\n#if !defined(SSL_LIB)\n#define SSL_LIB \"ssleay64.dll\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libeay64.dll\"\n#endif\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB \"ssleay32.dll\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libeay32.dll\"\n#endif\n#endif\n\n#define O_NONBLOCK (0)\n#if !defined(W_OK)\n#define W_OK (2) /* http://msdn.microsoft.com/en-us/library/1w06ktdy.aspx */\n#endif\n#if !defined(EWOULDBLOCK)\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#endif /* !EWOULDBLOCK */\n#define _POSIX_\n#define INT64_FMT \"I64d\"\n#define UINT64_FMT \"I64u\"\n\n#define WINCDECL __cdecl\n#define vsnprintf_impl _vsnprintf\n#define access _access\n#define mg_sleep(x) (Sleep(x))\n\n#define pipe(x) _pipe(x, MG_BUF_LEN, _O_BINARY)\n#if !defined(popen)\n#define popen(x, y) (_popen(x, y))\n#endif\n#if !defined(pclose)\n#define pclose(x) (_pclose(x))\n#endif\n#define close(x) (_close(x))\n#define dlsym(x, y) (GetProcAddress((HINSTANCE)(x), (y)))\n#define RTLD_LAZY (0)\n#define fseeko(x, y, z) ((_lseeki64(_fileno(x), (y), (z)) == -1) ? -1 : 0)\n#define fdopen(x, y) (_fdopen((x), (y)))\n#define write(x, y, z) (_write((x), (y), (unsigned)z))\n#define read(x, y, z) (_read((x), (y), (unsigned)z))\n#define flockfile(x) (EnterCriticalSection(&global_log_file_lock))\n#define funlockfile(x) (LeaveCriticalSection(&global_log_file_lock))\n#define sleep(x) (Sleep((x)*1000))\n#define rmdir(x) (_rmdir(x))\n#if defined(_WIN64) || !defined(__MINGW32__)\n/* Only MinGW 32 bit is missing this function */\n#define timegm(x) (_mkgmtime(x))\n#else\ntime_t timegm(struct tm *tm);\n#define NEED_TIMEGM\n#endif\n\n\n#if !defined(fileno)\n#define fileno(x) (_fileno(x))\n#endif /* !fileno MINGW #defines fileno */\n\ntypedef HANDLE pthread_mutex_t;\ntypedef DWORD pthread_key_t;\ntypedef HANDLE pthread_t;\ntypedef struct {\n\tCRITICAL_SECTION threadIdSec;\n\tstruct mg_workerTLS *waiting_thread; /* The chain of threads */\n} pthread_cond_t;\n\n#if !defined(__clockid_t_defined)\ntypedef DWORD clockid_t;\n#endif\n#if !defined(CLOCK_MONOTONIC)\n#define CLOCK_MONOTONIC (1)\n#endif\n#if !defined(CLOCK_REALTIME)\n#define CLOCK_REALTIME (2)\n#endif\n#if !defined(CLOCK_THREAD)\n#define CLOCK_THREAD (3)\n#endif\n#if !defined(CLOCK_PROCESS)\n#define CLOCK_PROCESS (4)\n#endif\n\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1900)\n#define _TIMESPEC_DEFINED\n#endif\n#if !defined(_TIMESPEC_DEFINED)\nstruct timespec {\n\ttime_t tv_sec; /* seconds */\n\tlong tv_nsec;  /* nanoseconds */\n};\n#endif\n\n#if !defined(WIN_PTHREADS_TIME_H)\n#define MUST_IMPLEMENT_CLOCK_GETTIME\n#endif\n\n#if defined(MUST_IMPLEMENT_CLOCK_GETTIME)\n#define clock_gettime mg_clock_gettime\nstatic int\nclock_gettime(clockid_t clk_id, struct timespec *tp)\n{\n\tFILETIME ft;\n\tULARGE_INTEGER li, li2;\n\tBOOL ok = FALSE;\n\tdouble d;\n\tstatic double perfcnt_per_sec = 0.0;\n\tstatic BOOL initialized = FALSE;\n\n\tif (!initialized) {\n\t\tQueryPerformanceFrequency((LARGE_INTEGER *)&li);\n\t\tperfcnt_per_sec = 1.0 / li.QuadPart;\n\t\tinitialized = TRUE;\n\t}\n\n\tif (tp) {\n\t\tmemset(tp, 0, sizeof(*tp));\n\n\t\tif (clk_id == CLOCK_REALTIME) {\n\n\t\t\t/* BEGIN: CLOCK_REALTIME = wall clock (date and time) */\n\t\t\tGetSystemTimeAsFileTime(&ft);\n\t\t\tli.LowPart = ft.dwLowDateTime;\n\t\t\tli.HighPart = ft.dwHighDateTime;\n\t\t\tli.QuadPart -= 116444736000000000; /* 1.1.1970 in filedate */\n\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_REALTIME */\n\n\t\t} else if (clk_id == CLOCK_MONOTONIC) {\n\n\t\t\t/* BEGIN: CLOCK_MONOTONIC = stopwatch (time differences) */\n\t\t\tQueryPerformanceCounter((LARGE_INTEGER *)&li);\n\t\t\td = li.QuadPart * perfcnt_per_sec;\n\t\t\ttp->tv_sec = (time_t)d;\n\t\t\td -= (double)tp->tv_sec;\n\t\t\ttp->tv_nsec = (long)(d * 1.0E9);\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_MONOTONIC */\n\n\t\t} else if (clk_id == CLOCK_THREAD) {\n\n\t\t\t/* BEGIN: CLOCK_THREAD = CPU usage of thread */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetThreadTimes(GetCurrentThread(),\n\t\t\t                   &t_create,\n\t\t\t                   &t_exit,\n\t\t\t                   &t_kernel,\n\t\t\t                   &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_THREAD */\n\n\t\t} else if (clk_id == CLOCK_PROCESS) {\n\n\t\t\t/* BEGIN: CLOCK_PROCESS = CPU usage of process */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetProcessTimes(GetCurrentProcess(),\n\t\t\t                    &t_create,\n\t\t\t                    &t_exit,\n\t\t\t                    &t_kernel,\n\t\t\t                    &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_PROCESS */\n\n\t\t} else {\n\n\t\t\t/* BEGIN: unknown clock */\n\t\t\t/* ok = FALSE; already set by init */\n\t\t\t/* END: unknown clock */\n\t\t}\n\t}\n\n\treturn ok ? 0 : -1;\n}\n#endif\n\n\n#define pid_t HANDLE /* MINGW typedefs pid_t to int. Using #define here. */\n\nstatic int pthread_mutex_lock(pthread_mutex_t *);\nstatic int pthread_mutex_unlock(pthread_mutex_t *);\nstatic void path_to_unicode(const struct mg_connection *conn,\n                            const char *path,\n                            wchar_t *wbuf,\n                            size_t wbuf_len);\n\n/* All file operations need to be rewritten to solve #246. */\n\nstruct mg_file;\n\nstatic const char *\nmg_fgets(char *buf, size_t size, struct mg_file *filep, char **p);\n\n\n/* POSIX dirent interface */\nstruct dirent {\n\tchar d_name[PATH_MAX];\n};\n\ntypedef struct DIR {\n\tHANDLE handle;\n\tWIN32_FIND_DATAW info;\n\tstruct dirent result;\n} DIR;\n\n#if defined(_WIN32)\n#if !defined(HAVE_POLL)\nstruct pollfd {\n\tSOCKET fd;\n\tshort events;\n\tshort revents;\n};\n#endif\n#endif\n\n/* Mark required libraries */\n#if defined(_MSC_VER)\n#pragma comment(lib, \"Ws2_32.lib\")\n#endif\n\n#else /* defined(_WIN32) - WINDOWS vs UNIX include block */\n\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/poll.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/utsname.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <netdb.h>\n#include <netinet/tcp.h>\ntypedef const void *SOCK_OPT_TYPE;\n\n#if defined(ANDROID)\ntypedef unsigned short int in_port_t;\n#endif\n\n#include <pwd.h>\n#include <unistd.h>\n#include <grp.h>\n#include <dirent.h>\n#define vsnprintf_impl vsnprintf\n\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n#include <dlfcn.h>\n#endif\n#include <pthread.h>\n#if defined(__MACH__)\n#define SSL_LIB \"libssl.dylib\"\n#define CRYPTO_LIB \"libcrypto.dylib\"\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB \"libssl.so\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libcrypto.so\"\n#endif\n#endif\n#if !defined(O_BINARY)\n#define O_BINARY (0)\n#endif /* O_BINARY */\n#define closesocket(a) (close(a))\n#define mg_mkdir(conn, path, mode) (mkdir(path, mode))\n#define mg_remove(conn, x) (remove(x))\n#define mg_sleep(x) (usleep((x)*1000))\n#define mg_opendir(conn, x) (opendir(x))\n#define mg_closedir(x) (closedir(x))\n#define mg_readdir(x) (readdir(x))\n#define ERRNO (errno)\n#define INVALID_SOCKET (-1)\n#define INT64_FMT PRId64\n#define UINT64_FMT PRIu64\ntypedef int SOCKET;\n#define WINCDECL\n\n#if defined(__hpux)\n/* HPUX 11 does not have monotonic, fall back to realtime */\n#if !defined(CLOCK_MONOTONIC)\n#define CLOCK_MONOTONIC CLOCK_REALTIME\n#endif\n\n/* HPUX defines socklen_t incorrectly as size_t which is 64bit on\n * Itanium.  Without defining _XOPEN_SOURCE or _XOPEN_SOURCE_EXTENDED\n * the prototypes use int* rather than socklen_t* which matches the\n * actual library expectation.  When called with the wrong size arg\n * accept() returns a zero client inet addr and check_acl() always\n * fails.  Since socklen_t is widely used below, just force replace\n * their typedef with int. - DTL\n */\n#define socklen_t int\n#endif /* hpux */\n\n#endif /* defined(_WIN32) - WINDOWS vs UNIX include block */\n\n/* Maximum queue length for pending connections. This value is passed as\n * parameter to the \"listen\" socket call. */\n#if !defined(SOMAXCONN)\n/* This symbol may be defined in winsock2.h so this must after that include */\n#define SOMAXCONN (100) /* in pending connections (count) */\n#endif\n\n/* In case our C library is missing \"timegm\", provide an implementation */\n#if defined(NEED_TIMEGM)\nstatic inline int\nis_leap(int y)\n{\n\treturn (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;\n}\n\nstatic inline int\ncount_leap(int y)\n{\n\treturn (y - 1969) / 4 - (y - 1901) / 100 + (y - 1601) / 400;\n}\n\ntime_t\ntimegm(struct tm *tm)\n{\n\tstatic const unsigned short ydays[] = {\n\t    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\n\tint year = tm->tm_year + 1900;\n\tint mon = tm->tm_mon;\n\tint mday = tm->tm_mday - 1;\n\tint hour = tm->tm_hour;\n\tint min = tm->tm_min;\n\tint sec = tm->tm_sec;\n\n\tif (year < 1970 || mon < 0 || mon > 11 || mday < 0\n\t    || (mday >= ydays[mon + 1] - ydays[mon]\n\t                    + (mon == 1 && is_leap(year) ? 1 : 0)) || hour < 0\n\t    || hour > 23\n\t    || min < 0\n\t    || min > 59\n\t    || sec < 0\n\t    || sec > 60)\n\t\treturn -1;\n\n\ttime_t res = year - 1970;\n\tres *= 365;\n\tres += mday;\n\tres += ydays[mon] + (mon > 1 && is_leap(year) ? 1 : 0);\n\tres += count_leap(year);\n\n\tres *= 24;\n\tres += hour;\n\tres *= 60;\n\tres += min;\n\tres *= 60;\n\tres += sec;\n\treturn res;\n}\n#endif /* NEED_TIMEGM */\n\n\n/* va_copy should always be a macro, C99 and C++11 - DTL */\n#if !defined(va_copy)\n#define va_copy(x, y) ((x) = (y))\n#endif\n\n\n#if defined(_WIN32)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nstatic CRITICAL_SECTION global_log_file_lock;\n\nFUNCTION_MAY_BE_UNUSED\nstatic DWORD\npthread_self(void)\n{\n\treturn GetCurrentThreadId();\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_key_create(\n    pthread_key_t *key,\n    void (*_ignored)(void *) /* destructor not supported for Windows */\n    )\n{\n\t(void)_ignored;\n\n\tif ((key != 0)) {\n\t\t*key = TlsAlloc();\n\t\treturn (*key != TLS_OUT_OF_INDEXES) ? 0 : -1;\n\t}\n\treturn -2;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_key_delete(pthread_key_t key)\n{\n\treturn TlsFree(key) ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_setspecific(pthread_key_t key, void *value)\n{\n\treturn TlsSetValue(key, value) ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void *\npthread_getspecific(pthread_key_t key)\n{\n\treturn TlsGetValue(key);\n}\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\nstatic struct pthread_mutex_undefined_struct *pthread_mutex_attr = NULL;\n#else\nstatic pthread_mutexattr_t pthread_mutex_attr;\n#endif /* _WIN32 */\n\n\n#if defined(_WIN32_WCE)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic time_t\ntime(time_t *ptime)\n{\n\ttime_t t;\n\tSYSTEMTIME st;\n\tFILETIME ft;\n\n\tGetSystemTime(&st);\n\tSystemTimeToFileTime(&st, &ft);\n\tt = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);\n\n\tif (ptime != NULL) {\n\t\t*ptime = t;\n\t}\n\n\treturn t;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\nlocaltime_s(const time_t *ptime, struct tm *ptm)\n{\n\tint64_t t = ((int64_t)*ptime) * RATE_DIFF + EPOCH_DIFF;\n\tFILETIME ft, lft;\n\tSYSTEMTIME st;\n\tTIME_ZONE_INFORMATION tzinfo;\n\n\tif (ptm == NULL) {\n\t\treturn NULL;\n\t}\n\n\t*(int64_t *)&ft = t;\n\tFileTimeToLocalFileTime(&ft, &lft);\n\tFileTimeToSystemTime(&lft, &st);\n\tptm->tm_year = st.wYear - 1900;\n\tptm->tm_mon = st.wMonth - 1;\n\tptm->tm_wday = st.wDayOfWeek;\n\tptm->tm_mday = st.wDay;\n\tptm->tm_hour = st.wHour;\n\tptm->tm_min = st.wMinute;\n\tptm->tm_sec = st.wSecond;\n\tptm->tm_yday = 0; /* hope nobody uses this */\n\tptm->tm_isdst =\n\t    (GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT) ? 1 : 0;\n\n\treturn ptm;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\ngmtime_s(const time_t *ptime, struct tm *ptm)\n{\n\t/* FIXME(lsm): fix this. */\n\treturn localtime_s(ptime, ptm);\n}\n\n\nstatic int mg_atomic_inc(volatile int *addr);\nstatic struct tm tm_array[MAX_WORKER_THREADS];\nstatic int tm_index = 0;\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\nlocaltime(const time_t *ptime)\n{\n\tint i = mg_atomic_inc(&tm_index) % (sizeof(tm_array) / sizeof(tm_array[0]));\n\treturn localtime_s(ptime, tm_array + i);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\ngmtime(const time_t *ptime)\n{\n\tint i = mg_atomic_inc(&tm_index) % ARRAY_SIZE(tm_array);\n\treturn gmtime_s(ptime, tm_array + i);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic size_t\nstrftime(char *dst, size_t dst_size, const char *fmt, const struct tm *tm)\n{\n\t/* TODO: (void)mg_snprintf(NULL, dst, dst_size, \"implement strftime()\n\t * for WinCE\"); */\n\treturn 0;\n}\n\n#define _beginthreadex(psec, stack, func, prm, flags, ptid)                    \\\n\t(uintptr_t) CreateThread(psec, stack, func, prm, flags, ptid)\n\n#define remove(f) mg_remove(NULL, f)\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nrename(const char *a, const char *b)\n{\n\twchar_t wa[W_PATH_MAX];\n\twchar_t wb[W_PATH_MAX];\n\tpath_to_unicode(NULL, a, wa, ARRAY_SIZE(wa));\n\tpath_to_unicode(NULL, b, wb, ARRAY_SIZE(wb));\n\n\treturn MoveFileW(wa, wb) ? 0 : -1;\n}\n\n\nstruct stat {\n\tint64_t st_size;\n\ttime_t st_mtime;\n};\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nstat(const char *name, struct stat *st)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tWIN32_FILE_ATTRIBUTE_DATA attr;\n\ttime_t creation_time, write_time;\n\n\tpath_to_unicode(NULL, name, wbuf, ARRAY_SIZE(wbuf));\n\tmemset(&attr, 0, sizeof(attr));\n\n\tGetFileAttributesExW(wbuf, GetFileExInfoStandard, &attr);\n\tst->st_size =\n\t    (((int64_t)attr.nFileSizeHigh) << 32) + (int64_t)attr.nFileSizeLow;\n\n\twrite_time = SYS2UNIX_TIME(attr.ftLastWriteTime.dwLowDateTime,\n\t                           attr.ftLastWriteTime.dwHighDateTime);\n\tcreation_time = SYS2UNIX_TIME(attr.ftCreationTime.dwLowDateTime,\n\t                              attr.ftCreationTime.dwHighDateTime);\n\n\tif (creation_time > write_time) {\n\t\tst->st_mtime = creation_time;\n\t} else {\n\t\tst->st_mtime = write_time;\n\t}\n\treturn 0;\n}\n\n#define access(x, a) 1 /* not required anyway */\n\n/* WinCE-TODO: define stat, remove, rename, _rmdir, _lseeki64 */\n/* Values from errno.h in Windows SDK (Visual Studio). */\n#define EEXIST 17\n#define EACCES 13\n#define ENOENT 2\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n#endif /* defined(_WIN32_WCE) */\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#define GCC_VERSION                                                            \\\n\t(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\nstatic pthread_mutex_t global_lock_mutex;\n\n\n#if defined(_WIN32)\n/* Forward declaration for Windows */\nFUNCTION_MAY_BE_UNUSED\nstatic int pthread_mutex_lock(pthread_mutex_t *mutex);\n\nFUNCTION_MAY_BE_UNUSED\nstatic int pthread_mutex_unlock(pthread_mutex_t *mutex);\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nmg_global_lock(void)\n{\n\t(void)pthread_mutex_lock(&global_lock_mutex);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nmg_global_unlock(void)\n{\n\t(void)pthread_mutex_unlock(&global_lock_mutex);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_atomic_inc(volatile int *addr)\n{\n\tint ret;\n#if defined(_WIN32) && !defined(NO_ATOMICS)\n\t/* Depending on the SDK, this function uses either\n\t * (volatile unsigned int *) or (volatile LONG *),\n\t * so whatever you use, the other SDK is likely to raise a warning. */\n\tret = InterlockedIncrement((volatile long *)addr);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_add_and_fetch(addr, 1);\n#else\n\tmg_global_lock();\n\tret = (++(*addr));\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_atomic_dec(volatile int *addr)\n{\n\tint ret;\n#if defined(_WIN32) && !defined(NO_ATOMICS)\n\t/* Depending on the SDK, this function uses either\n\t * (volatile unsigned int *) or (volatile LONG *),\n\t * so whatever you use, the other SDK is likely to raise a warning. */\n\tret = InterlockedDecrement((volatile long *)addr);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_sub_and_fetch(addr, 1);\n#else\n\tmg_global_lock();\n\tret = (--(*addr));\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n\n\n#if defined(USE_SERVER_STATS)\nstatic int64_t\nmg_atomic_add(volatile int64_t *addr, int64_t value)\n{\n\tint64_t ret;\n#if defined(_WIN64) && !defined(NO_ATOMICS)\n\tret = InterlockedAdd64(addr, value);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_add_and_fetch(addr, value);\n#else\n\tmg_global_lock();\n\t*addr += value;\n\tret = (*addr);\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n#endif\n\n\n#if defined(__GNUC__)\n/* Show no warning in case system functions are not used. */\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic pop\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic pop\n#endif\n\n\n#if defined(USE_SERVER_STATS)\n\nstruct mg_memory_stat {\n\tvolatile int64_t totalMemUsed;\n\tvolatile int64_t maxMemUsed;\n\tvolatile int blockCount;\n};\n\n\nstatic struct mg_memory_stat *get_memory_stat(struct mg_context *ctx);\n\n\nstatic void *\nmg_malloc_ex(size_t size,\n             struct mg_context *ctx,\n             const char *file,\n             unsigned line)\n{\n\tvoid *data = malloc(size + 2 * sizeof(uintptr_t));\n\tvoid *memory = 0;\n\tstruct mg_memory_stat *mstat = get_memory_stat(ctx);\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (data) {\n\t\tint64_t mmem = mg_atomic_add(&mstat->totalMemUsed, (int64_t)size);\n\t\tif (mmem > mstat->maxMemUsed) {\n\t\t\t/* could use atomic compare exchange, but this\n\t\t\t * seems overkill for statistics data */\n\t\t\tmstat->maxMemUsed = mmem;\n\t\t}\n\n\t\tmg_atomic_inc(&mstat->blockCount);\n\t\t((uintptr_t *)data)[0] = size;\n\t\t((uintptr_t *)data)[1] = (uintptr_t)mstat;\n\t\tmemory = (void *)(((char *)data) + 2 * sizeof(uintptr_t));\n\t}\n\n#if defined(MEMORY_DEBUGGING)\n\tsprintf(mallocStr,\n\t        \"MEM: %p %5lu alloc   %7lu %4lu --- %s:%u\\n\",\n\t        memory,\n\t        (unsigned long)size,\n\t        (unsigned long)mstat->totalMemUsed,\n\t        (unsigned long)mstat->blockCount,\n\t        file,\n\t        line);\n#if defined(_WIN32)\n\tOutputDebugStringA(mallocStr);\n#else\n\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\n\treturn memory;\n}\n\n\nstatic void *\nmg_calloc_ex(size_t count,\n             size_t size,\n             struct mg_context *ctx,\n             const char *file,\n             unsigned line)\n{\n\tvoid *data = mg_malloc_ex(size * count, ctx, file, line);\n\n\tif (data) {\n\t\tmemset(data, 0, size * count);\n\t}\n\treturn data;\n}\n\n\nstatic void\nmg_free_ex(void *memory, const char *file, unsigned line)\n{\n\tvoid *data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));\n\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (memory) {\n\t\tuintptr_t size = ((uintptr_t *)data)[0];\n\t\tstruct mg_memory_stat *mstat =\n\t\t    (struct mg_memory_stat *)(((uintptr_t *)data)[1]);\n\t\tmg_atomic_add(&mstat->totalMemUsed, -(int64_t)size);\n\t\tmg_atomic_dec(&mstat->blockCount);\n#if defined(MEMORY_DEBUGGING)\n\t\tsprintf(mallocStr,\n\t\t        \"MEM: %p %5lu free    %7lu %4lu --- %s:%u\\n\",\n\t\t        memory,\n\t\t        (unsigned long)size,\n\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t        (unsigned long)mstat->blockCount,\n\t\t        file,\n\t\t        line);\n#if defined(_WIN32)\n\t\tOutputDebugStringA(mallocStr);\n#else\n\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\tfree(data);\n\t}\n}\n\n\nstatic void *\nmg_realloc_ex(void *memory,\n              size_t newsize,\n              struct mg_context *ctx,\n              const char *file,\n              unsigned line)\n{\n\tvoid *data;\n\tvoid *_realloc;\n\tuintptr_t oldsize;\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (newsize) {\n\t\tif (memory) {\n\t\t\t/* Reallocate existing block */\n\t\t\tstruct mg_memory_stat *mstat;\n\t\t\tdata = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));\n\t\t\toldsize = ((uintptr_t *)data)[0];\n\t\t\tmstat = (struct mg_memory_stat *)((uintptr_t *)data)[1];\n\t\t\t_realloc = realloc(data, newsize + 2 * sizeof(uintptr_t));\n\t\t\tif (_realloc) {\n\t\t\t\tdata = _realloc;\n\t\t\t\tmg_atomic_add(&mstat->totalMemUsed, -(int64_t)oldsize);\n#if defined(MEMORY_DEBUGGING)\n\t\t\t\tsprintf(mallocStr,\n\t\t\t\t        \"MEM: %p %5lu r-free  %7lu %4lu --- %s:%u\\n\",\n\t\t\t\t        memory,\n\t\t\t\t        (unsigned long)oldsize,\n\t\t\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t\t\t        (unsigned long)mstat->blockCount,\n\t\t\t\t        file,\n\t\t\t\t        line);\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(mallocStr);\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\t\t\tmg_atomic_add(&mstat->totalMemUsed, (int64_t)newsize);\n#if defined(MEMORY_DEBUGGING)\n\t\t\t\tsprintf(mallocStr,\n\t\t\t\t        \"MEM: %p %5lu r-alloc %7lu %4lu --- %s:%u\\n\",\n\t\t\t\t        memory,\n\t\t\t\t        (unsigned long)newsize,\n\t\t\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t\t\t        (unsigned long)mstat->blockCount,\n\t\t\t\t        file,\n\t\t\t\t        line);\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(mallocStr);\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\t\t\t*(uintptr_t *)data = newsize;\n\t\t\t\tdata = (void *)(((char *)data) + 2 * sizeof(uintptr_t));\n\t\t\t} else {\n#if defined(MEMORY_DEBUGGING)\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(\"MEM: realloc failed\\n\");\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", \"MEM: realloc failed\\n\");\n#endif\n#endif\n\t\t\t\treturn _realloc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Allocate new block */\n\t\t\tdata = mg_malloc_ex(newsize, ctx, file, line);\n\t\t}\n\t} else {\n\t\t/* Free existing block */\n\t\tdata = 0;\n\t\tmg_free_ex(memory, file, line);\n\t}\n\n\treturn data;\n}\n\n#define mg_malloc(a) mg_malloc_ex(a, NULL, __FILE__, __LINE__)\n#define mg_calloc(a, b) mg_calloc_ex(a, b, NULL, __FILE__, __LINE__)\n#define mg_realloc(a, b) mg_realloc_ex(a, b, NULL, __FILE__, __LINE__)\n#define mg_free(a) mg_free_ex(a, __FILE__, __LINE__)\n\n#define mg_malloc_ctx(a, c) mg_malloc_ex(a, c, __FILE__, __LINE__)\n#define mg_calloc_ctx(a, b, c) mg_calloc_ex(a, b, c, __FILE__, __LINE__)\n#define mg_realloc_ctx(a, b, c) mg_realloc_ex(a, b, c, __FILE__, __LINE__)\n\n#else /* USE_SERVER_STATS */\n\nstatic __inline void *\nmg_malloc(size_t a)\n{\n\treturn malloc(a);\n}\n\nstatic __inline void *\nmg_calloc(size_t a, size_t b)\n{\n\treturn calloc(a, b);\n}\n\nstatic __inline void *\nmg_realloc(void *a, size_t b)\n{\n\treturn realloc(a, b);\n}\n\nstatic __inline void\nmg_free(void *a)\n{\n\tfree(a);\n}\n\n#define mg_malloc_ctx(a, c) mg_malloc(a)\n#define mg_calloc_ctx(a, b, c) mg_calloc(a, b)\n#define mg_realloc_ctx(a, b, c) mg_realloc(a, b)\n#define mg_free_ctx(a, c) mg_free(a)\n\n#endif /* USE_SERVER_STATS */\n\n\nstatic void mg_vsnprintf(const struct mg_connection *conn,\n                         int *truncated,\n                         char *buf,\n                         size_t buflen,\n                         const char *fmt,\n                         va_list ap);\n\nstatic void mg_snprintf(const struct mg_connection *conn,\n                        int *truncated,\n                        char *buf,\n                        size_t buflen,\n                        PRINTF_FORMAT_STRING(const char *fmt),\n                        ...) PRINTF_ARGS(5, 6);\n\n/* This following lines are just meant as a reminder to use the mg-functions\n * for memory management */\n#if defined(malloc)\n#undef malloc\n#endif\n#if defined(calloc)\n#undef calloc\n#endif\n#if defined(realloc)\n#undef realloc\n#endif\n#if defined(free)\n#undef free\n#endif\n#if defined(snprintf)\n#undef snprintf\n#endif\n#if defined(vsnprintf)\n#undef vsnprintf\n#endif\n#define malloc DO_NOT_USE_THIS_FUNCTION__USE_mg_malloc\n#define calloc DO_NOT_USE_THIS_FUNCTION__USE_mg_calloc\n#define realloc DO_NOT_USE_THIS_FUNCTION__USE_mg_realloc\n#define free DO_NOT_USE_THIS_FUNCTION__USE_mg_free\n#define snprintf DO_NOT_USE_THIS_FUNCTION__USE_mg_snprintf\n#if defined(_WIN32)\n/* vsnprintf must not be used in any system,\n * but this define only works well for Windows. */\n#define vsnprintf DO_NOT_USE_THIS_FUNCTION__USE_mg_vsnprintf\n#endif\n\n\n/* mg_init_library counter */\nstatic int mg_init_library_called = 0;\n\n#if !defined(NO_SSL)\nstatic int mg_ssl_initialized = 0;\n#endif\n\nstatic pthread_key_t sTlsKey; /* Thread local storage index */\nstatic int thread_idx_max = 0;\n\n#if defined(MG_LEGACY_INTERFACE)\n#define MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE\n#endif\n\nstruct mg_workerTLS {\n\tint is_master;\n\tunsigned long thread_idx;\n#if defined(_WIN32)\n\tHANDLE pthread_cond_helper_mutex;\n\tstruct mg_workerTLS *next_waiting_thread;\n#endif\n#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE)\n\tchar txtbuf[4];\n#endif\n};\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\n\n/* Get a unique thread ID as unsigned long, independent from the data type\n * of thread IDs defined by the operating system API.\n * If two calls to mg_current_thread_id  return the same value, they calls\n * are done from the same thread. If they return different values, they are\n * done from different threads. (Provided this function is used in the same\n * process context and threads are not repeatedly created and deleted, but\n * CivetWeb does not do that).\n * This function must match the signature required for SSL id callbacks:\n * CRYPTO_set_id_callback\n */\nFUNCTION_MAY_BE_UNUSED\nstatic unsigned long\nmg_current_thread_id(void)\n{\n#if defined(_WIN32)\n\treturn GetCurrentThreadId();\n#else\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n/* For every compiler, either \"sizeof(pthread_t) > sizeof(unsigned long)\"\n * or not, so one of the two conditions will be unreachable by construction.\n * Unfortunately the C standard does not define a way to check this at\n * compile time, since the #if preprocessor conditions can not use the sizeof\n * operator as an argument. */\n#endif\n\n\tif (sizeof(pthread_t) > sizeof(unsigned long)) {\n\t\t/* This is the problematic case for CRYPTO_set_id_callback:\n\t\t * The OS pthread_t can not be cast to unsigned long. */\n\t\tstruct mg_workerTLS *tls =\n\t\t    (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\t\tif (tls == NULL) {\n\t\t\t/* SSL called from an unknown thread: Create some thread index.\n\t\t\t */\n\t\t\ttls = (struct mg_workerTLS *)mg_malloc(sizeof(struct mg_workerTLS));\n\t\t\ttls->is_master = -2; /* -2 means \"3rd party thread\" */\n\t\t\ttls->thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n\t\t\tpthread_setspecific(sTlsKey, tls);\n\t\t}\n\t\treturn tls->thread_idx;\n\t} else {\n\t\t/* pthread_t may be any data type, so a simple cast to unsigned long\n\t\t * can rise a warning/error, depending on the platform.\n\t\t * Here memcpy is used as an anything-to-anything cast. */\n\t\tunsigned long ret = 0;\n\t\tpthread_t t = pthread_self();\n\t\tmemcpy(&ret, &t, sizeof(pthread_t));\n\t\treturn ret;\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n#endif\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic uint64_t\nmg_get_current_time_ns(void)\n{\n\tstruct timespec tsnow;\n\tclock_gettime(CLOCK_REALTIME, &tsnow);\n\treturn (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;\n}\n\n\n#if defined(__GNUC__)\n/* Show no warning in case system functions are not used. */\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic pop\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic pop\n#endif\n\n\n#if defined(NEED_DEBUG_TRACE_FUNC)\nstatic void\nDEBUG_TRACE_FUNC(const char *func, unsigned line, const char *fmt, ...)\n{\n\tva_list args;\n\tuint64_t nsnow;\n\tstatic uint64_t nslast;\n\tstruct timespec tsnow;\n\n\t/* Get some operating system independent thread id */\n\tunsigned long thread_id = mg_current_thread_id();\n\n\tclock_gettime(CLOCK_REALTIME, &tsnow);\n\tnsnow = ((uint64_t)tsnow.tv_sec) * ((uint64_t)1000000000)\n\t        + ((uint64_t)tsnow.tv_nsec);\n\n\tif (!nslast) {\n\t\tnslast = nsnow;\n\t}\n\n\tflockfile(stdout);\n\tprintf(\"*** %lu.%09lu %12\" INT64_FMT \" %lu %s:%u: \",\n\t       (unsigned long)tsnow.tv_sec,\n\t       (unsigned long)tsnow.tv_nsec,\n\t       nsnow - nslast,\n\t       thread_id,\n\t       func,\n\t       line);\n\tva_start(args, fmt);\n\tvprintf(fmt, args);\n\tva_end(args);\n\tputchar('\\n');\n\tfflush(stdout);\n\tfunlockfile(stdout);\n\tnslast = nsnow;\n}\n#endif /* NEED_DEBUG_TRACE_FUNC */\n\n\n#define MD5_STATIC static\n#include \"md5.inl\"\n\n/* Darwin prior to 7.0 and Win32 do not have socklen_t */\n#if defined(NO_SOCKLEN_T)\ntypedef int socklen_t;\n#endif /* NO_SOCKLEN_T */\n\n#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */\n\n#if !defined(MSG_NOSIGNAL)\n#define MSG_NOSIGNAL (0)\n#endif\n\n\n#if defined(NO_SSL)\ntypedef struct SSL SSL; /* dummy for SSL argument to push/pull */\ntypedef struct SSL_CTX SSL_CTX;\n#else\n#if defined(NO_SSL_DL)\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <openssl/engine.h>\n#include <openssl/conf.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <openssl/opensslv.h>\n\n#if defined(WOLFSSL_VERSION)\n/* Additional defines for WolfSSL, see\n * https://github.com/civetweb/civetweb/issues/583 */\n#include \"wolfssl_extras.inl\"\n#endif\n\n#else\n\n/* SSL loaded dynamically from DLL.\n * I put the prototypes here to be independent from OpenSSL source\n * installation. */\n\ntypedef struct ssl_st SSL;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef struct ssl_ctx_st SSL_CTX;\ntypedef struct x509_store_ctx_st X509_STORE_CTX;\ntypedef struct x509_name X509_NAME;\ntypedef struct asn1_integer ASN1_INTEGER;\ntypedef struct bignum BIGNUM;\ntypedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;\ntypedef struct evp_md EVP_MD;\ntypedef struct x509 X509;\n\n\n#define SSL_CTRL_OPTIONS (32)\n#define SSL_CTRL_CLEAR_OPTIONS (77)\n#define SSL_CTRL_SET_ECDH_AUTO (94)\n\n#define OPENSSL_INIT_NO_LOAD_SSL_STRINGS 0x00100000L\n#define OPENSSL_INIT_LOAD_SSL_STRINGS 0x00200000L\n#define OPENSSL_INIT_LOAD_CRYPTO_STRINGS 0x00000002L\n\n#define SSL_VERIFY_NONE (0)\n#define SSL_VERIFY_PEER (1)\n#define SSL_VERIFY_FAIL_IF_NO_PEER_CERT (2)\n#define SSL_VERIFY_CLIENT_ONCE (4)\n#define SSL_OP_ALL ((long)(0x80000BFFUL))\n#define SSL_OP_NO_SSLv2 (0x01000000L)\n#define SSL_OP_NO_SSLv3 (0x02000000L)\n#define SSL_OP_NO_TLSv1 (0x04000000L)\n#define SSL_OP_NO_TLSv1_2 (0x08000000L)\n#define SSL_OP_NO_TLSv1_1 (0x10000000L)\n#define SSL_OP_SINGLE_DH_USE (0x00100000L)\n#define SSL_OP_CIPHER_SERVER_PREFERENCE (0x00400000L)\n#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (0x00010000L)\n#define SSL_OP_NO_COMPRESSION (0x00020000L)\n\n#define SSL_CB_HANDSHAKE_START (0x10)\n#define SSL_CB_HANDSHAKE_DONE (0x20)\n\n#define SSL_ERROR_NONE (0)\n#define SSL_ERROR_SSL (1)\n#define SSL_ERROR_WANT_READ (2)\n#define SSL_ERROR_WANT_WRITE (3)\n#define SSL_ERROR_WANT_X509_LOOKUP (4)\n#define SSL_ERROR_SYSCALL (5) /* see errno */\n#define SSL_ERROR_ZERO_RETURN (6)\n#define SSL_ERROR_WANT_CONNECT (7)\n#define SSL_ERROR_WANT_ACCEPT (8)\n\n#define TLSEXT_TYPE_server_name (0)\n#define TLSEXT_NAMETYPE_host_name (0)\n#define SSL_TLSEXT_ERR_OK (0)\n#define SSL_TLSEXT_ERR_ALERT_WARNING (1)\n#define SSL_TLSEXT_ERR_ALERT_FATAL (2)\n#define SSL_TLSEXT_ERR_NOACK (3)\n\nstruct ssl_func {\n\tconst char *name;  /* SSL function name */\n\tvoid (*ptr)(void); /* Function pointer */\n};\n\n\n#if defined(OPENSSL_API_1_1)\n\n#define SSL_free (*(void (*)(SSL *))ssl_sw[0].ptr)\n#define SSL_accept (*(int (*)(SSL *))ssl_sw[1].ptr)\n#define SSL_connect (*(int (*)(SSL *))ssl_sw[2].ptr)\n#define SSL_read (*(int (*)(SSL *, void *, int))ssl_sw[3].ptr)\n#define SSL_write (*(int (*)(SSL *, const void *, int))ssl_sw[4].ptr)\n#define SSL_get_error (*(int (*)(SSL *, int))ssl_sw[5].ptr)\n#define SSL_set_fd (*(int (*)(SSL *, SOCKET))ssl_sw[6].ptr)\n#define SSL_new (*(SSL * (*)(SSL_CTX *))ssl_sw[7].ptr)\n#define SSL_CTX_new (*(SSL_CTX * (*)(SSL_METHOD *))ssl_sw[8].ptr)\n#define TLS_server_method (*(SSL_METHOD * (*)(void))ssl_sw[9].ptr)\n#define OPENSSL_init_ssl                                                       \\\n\t(*(int (*)(uint64_t opts,                                                  \\\n\t           const OPENSSL_INIT_SETTINGS *settings))ssl_sw[10].ptr)\n#define SSL_CTX_use_PrivateKey_file                                            \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file                                           \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb                                          \\\n\t(*(void (*)(SSL_CTX *, mg_callback_t))ssl_sw[13].ptr)\n#define SSL_CTX_free (*(void (*)(SSL_CTX *))ssl_sw[14].ptr)\n#define SSL_CTX_use_certificate_chain_file                                     \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[15].ptr)\n#define TLS_client_method (*(SSL_METHOD * (*)(void))ssl_sw[16].ptr)\n#define SSL_pending (*(int (*)(SSL *))ssl_sw[17].ptr)\n#define SSL_CTX_set_verify                                                     \\\n\t(*(void (*)(SSL_CTX *,                                                     \\\n\t            int,                                                           \\\n\t            int (*verify_callback)(int, X509_STORE_CTX *)))ssl_sw[18].ptr)\n#define SSL_shutdown (*(int (*)(SSL *))ssl_sw[19].ptr)\n#define SSL_CTX_load_verify_locations                                          \\\n\t(*(int (*)(SSL_CTX *, const char *, const char *))ssl_sw[20].ptr)\n#define SSL_CTX_set_default_verify_paths (*(int (*)(SSL_CTX *))ssl_sw[21].ptr)\n#define SSL_CTX_set_verify_depth (*(void (*)(SSL_CTX *, int))ssl_sw[22].ptr)\n#define SSL_get_peer_certificate (*(X509 * (*)(SSL *))ssl_sw[23].ptr)\n#define SSL_get_version (*(const char *(*)(SSL *))ssl_sw[24].ptr)\n#define SSL_get_current_cipher (*(SSL_CIPHER * (*)(SSL *))ssl_sw[25].ptr)\n#define SSL_CIPHER_get_name                                                    \\\n\t(*(const char *(*)(const SSL_CIPHER *))ssl_sw[26].ptr)\n#define SSL_CTX_check_private_key (*(int (*)(SSL_CTX *))ssl_sw[27].ptr)\n#define SSL_CTX_set_session_id_context                                         \\\n\t(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[28].ptr)\n#define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[29].ptr)\n#define SSL_CTX_set_cipher_list                                                \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[30].ptr)\n#define SSL_CTX_set_options                                                    \\\n\t(*(unsigned long (*)(SSL_CTX *, unsigned long))ssl_sw[31].ptr)\n#define SSL_CTX_set_info_callback                                              \\\n\t(*(void (*)(SSL_CTX * ctx,                                                 \\\n\t            void (*callback)(SSL * s, int, int)))ssl_sw[32].ptr)\n#define SSL_get_ex_data (*(char *(*)(SSL *, int))ssl_sw[33].ptr)\n#define SSL_set_ex_data (*(void (*)(SSL *, int, char *))ssl_sw[34].ptr)\n#define SSL_CTX_callback_ctrl                                                  \\\n\t(*(long (*)(SSL_CTX *, int, void (*)(void)))ssl_sw[35].ptr)\n#define SSL_get_servername                                                     \\\n\t(*(const char *(*)(const SSL *, int type))ssl_sw[36].ptr)\n#define SSL_set_SSL_CTX (*(SSL_CTX * (*)(SSL *, SSL_CTX *))ssl_sw[37].ptr)\n\n#define SSL_CTX_clear_options(ctx, op)                                         \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_CLEAR_OPTIONS, (op), NULL)\n#define SSL_CTX_set_ecdh_auto(ctx, onoff)                                      \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, onoff, NULL)\n\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 53\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 54\n#define SSL_CTX_set_tlsext_servername_callback(ctx, cb)                        \\\n\tSSL_CTX_callback_ctrl(ctx,                                                 \\\n\t                      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,                   \\\n\t                      (void (*)(void))cb)\n#define SSL_CTX_set_tlsext_servername_arg(ctx, arg)                            \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, (void *)arg)\n\n#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)\n#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)\n\n#define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)arg))\n#define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))\n\n#define ERR_get_error (*(unsigned long (*)(void))crypto_sw[0].ptr)\n#define ERR_error_string (*(char *(*)(unsigned long, char *))crypto_sw[1].ptr)\n#define ERR_remove_state (*(void (*)(unsigned long))crypto_sw[2].ptr)\n#define CONF_modules_unload (*(void (*)(int))crypto_sw[3].ptr)\n#define X509_free (*(void (*)(X509 *))crypto_sw[4].ptr)\n#define X509_get_subject_name (*(X509_NAME * (*)(X509 *))crypto_sw[5].ptr)\n#define X509_get_issuer_name (*(X509_NAME * (*)(X509 *))crypto_sw[6].ptr)\n#define X509_NAME_oneline                                                      \\\n\t(*(char *(*)(X509_NAME *, char *, int))crypto_sw[7].ptr)\n#define X509_get_serialNumber (*(ASN1_INTEGER * (*)(X509 *))crypto_sw[8].ptr)\n#define EVP_get_digestbyname                                                   \\\n\t(*(const EVP_MD *(*)(const char *))crypto_sw[9].ptr)\n#define EVP_Digest                                                             \\\n\t(*(int (*)(                                                                \\\n\t    const void *, size_t, void *, unsigned int *, const EVP_MD *, void *)) \\\n\t      crypto_sw[10].ptr)\n#define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[11].ptr)\n#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[12].ptr)\n#define ASN1_INTEGER_to_BN                                                     \\\n\t(*(BIGNUM * (*)(const ASN1_INTEGER *ai, BIGNUM *bn))crypto_sw[13].ptr)\n#define BN_free (*(void (*)(const BIGNUM *a))crypto_sw[14].ptr)\n#define CRYPTO_free (*(void (*)(void *addr))crypto_sw[15].ptr)\n\n#define OPENSSL_free(a) CRYPTO_free(a)\n\n\n/* init_ssl_ctx() function updates this array.\n * It loads SSL library dynamically and changes NULLs to the actual addresses\n * of respective functions. The macros above (like SSL_connect()) are really\n * just calling these functions indirectly via the pointer. */\nstatic struct ssl_func ssl_sw[] = {{\"SSL_free\", NULL},\n                                   {\"SSL_accept\", NULL},\n                                   {\"SSL_connect\", NULL},\n                                   {\"SSL_read\", NULL},\n                                   {\"SSL_write\", NULL},\n                                   {\"SSL_get_error\", NULL},\n                                   {\"SSL_set_fd\", NULL},\n                                   {\"SSL_new\", NULL},\n                                   {\"SSL_CTX_new\", NULL},\n                                   {\"TLS_server_method\", NULL},\n                                   {\"OPENSSL_init_ssl\", NULL},\n                                   {\"SSL_CTX_use_PrivateKey_file\", NULL},\n                                   {\"SSL_CTX_use_certificate_file\", NULL},\n                                   {\"SSL_CTX_set_default_passwd_cb\", NULL},\n                                   {\"SSL_CTX_free\", NULL},\n                                   {\"SSL_CTX_use_certificate_chain_file\", NULL},\n                                   {\"TLS_client_method\", NULL},\n                                   {\"SSL_pending\", NULL},\n                                   {\"SSL_CTX_set_verify\", NULL},\n                                   {\"SSL_shutdown\", NULL},\n                                   {\"SSL_CTX_load_verify_locations\", NULL},\n                                   {\"SSL_CTX_set_default_verify_paths\", NULL},\n                                   {\"SSL_CTX_set_verify_depth\", NULL},\n                                   {\"SSL_get_peer_certificate\", NULL},\n                                   {\"SSL_get_version\", NULL},\n                                   {\"SSL_get_current_cipher\", NULL},\n                                   {\"SSL_CIPHER_get_name\", NULL},\n                                   {\"SSL_CTX_check_private_key\", NULL},\n                                   {\"SSL_CTX_set_session_id_context\", NULL},\n                                   {\"SSL_CTX_ctrl\", NULL},\n                                   {\"SSL_CTX_set_cipher_list\", NULL},\n                                   {\"SSL_CTX_set_options\", NULL},\n                                   {\"SSL_CTX_set_info_callback\", NULL},\n                                   {\"SSL_get_ex_data\", NULL},\n                                   {\"SSL_set_ex_data\", NULL},\n                                   {\"SSL_CTX_callback_ctrl\", NULL},\n                                   {\"SSL_get_servername\", NULL},\n                                   {\"SSL_set_SSL_CTX\", NULL},\n                                   {NULL, NULL}};\n\n\n/* Similar array as ssl_sw. These functions could be located in different\n * lib. */\nstatic struct ssl_func crypto_sw[] = {{\"ERR_get_error\", NULL},\n                                      {\"ERR_error_string\", NULL},\n                                      {\"ERR_remove_state\", NULL},\n                                      {\"CONF_modules_unload\", NULL},\n                                      {\"X509_free\", NULL},\n                                      {\"X509_get_subject_name\", NULL},\n                                      {\"X509_get_issuer_name\", NULL},\n                                      {\"X509_NAME_oneline\", NULL},\n                                      {\"X509_get_serialNumber\", NULL},\n                                      {\"EVP_get_digestbyname\", NULL},\n                                      {\"EVP_Digest\", NULL},\n                                      {\"i2d_X509\", NULL},\n                                      {\"BN_bn2hex\", NULL},\n                                      {\"ASN1_INTEGER_to_BN\", NULL},\n                                      {\"BN_free\", NULL},\n                                      {\"CRYPTO_free\", NULL},\n                                      {NULL, NULL}};\n#else\n\n#define SSL_free (*(void (*)(SSL *))ssl_sw[0].ptr)\n#define SSL_accept (*(int (*)(SSL *))ssl_sw[1].ptr)\n#define SSL_connect (*(int (*)(SSL *))ssl_sw[2].ptr)\n#define SSL_read (*(int (*)(SSL *, void *, int))ssl_sw[3].ptr)\n#define SSL_write (*(int (*)(SSL *, const void *, int))ssl_sw[4].ptr)\n#define SSL_get_error (*(int (*)(SSL *, int))ssl_sw[5].ptr)\n#define SSL_set_fd (*(int (*)(SSL *, SOCKET))ssl_sw[6].ptr)\n#define SSL_new (*(SSL * (*)(SSL_CTX *))ssl_sw[7].ptr)\n#define SSL_CTX_new (*(SSL_CTX * (*)(SSL_METHOD *))ssl_sw[8].ptr)\n#define SSLv23_server_method (*(SSL_METHOD * (*)(void))ssl_sw[9].ptr)\n#define SSL_library_init (*(int (*)(void))ssl_sw[10].ptr)\n#define SSL_CTX_use_PrivateKey_file                                            \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file                                           \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb                                          \\\n\t(*(void (*)(SSL_CTX *, mg_callback_t))ssl_sw[13].ptr)\n#define SSL_CTX_free (*(void (*)(SSL_CTX *))ssl_sw[14].ptr)\n#define SSL_load_error_strings (*(void (*)(void))ssl_sw[15].ptr)\n#define SSL_CTX_use_certificate_chain_file                                     \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[16].ptr)\n#define SSLv23_client_method (*(SSL_METHOD * (*)(void))ssl_sw[17].ptr)\n#define SSL_pending (*(int (*)(SSL *))ssl_sw[18].ptr)\n#define SSL_CTX_set_verify                                                     \\\n\t(*(void (*)(SSL_CTX *,                                                     \\\n\t            int,                                                           \\\n\t            int (*verify_callback)(int, X509_STORE_CTX *)))ssl_sw[19].ptr)\n#define SSL_shutdown (*(int (*)(SSL *))ssl_sw[20].ptr)\n#define SSL_CTX_load_verify_locations                                          \\\n\t(*(int (*)(SSL_CTX *, const char *, const char *))ssl_sw[21].ptr)\n#define SSL_CTX_set_default_verify_paths (*(int (*)(SSL_CTX *))ssl_sw[22].ptr)\n#define SSL_CTX_set_verify_depth (*(void (*)(SSL_CTX *, int))ssl_sw[23].ptr)\n#define SSL_get_peer_certificate (*(X509 * (*)(SSL *))ssl_sw[24].ptr)\n#define SSL_get_version (*(const char *(*)(SSL *))ssl_sw[25].ptr)\n#define SSL_get_current_cipher (*(SSL_CIPHER * (*)(SSL *))ssl_sw[26].ptr)\n#define SSL_CIPHER_get_name                                                    \\\n\t(*(const char *(*)(const SSL_CIPHER *))ssl_sw[27].ptr)\n#define SSL_CTX_check_private_key (*(int (*)(SSL_CTX *))ssl_sw[28].ptr)\n#define SSL_CTX_set_session_id_context                                         \\\n\t(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[29].ptr)\n#define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[30].ptr)\n#define SSL_CTX_set_cipher_list                                                \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[31].ptr)\n#define SSL_CTX_set_info_callback                                              \\\n\t(*(void (*)(SSL_CTX *, void (*callback)(SSL * s, int, int)))ssl_sw[32].ptr)\n#define SSL_get_ex_data (*(char *(*)(SSL *, int))ssl_sw[33].ptr)\n#define SSL_set_ex_data (*(void (*)(SSL *, int, char *))ssl_sw[34].ptr)\n#define SSL_CTX_callback_ctrl                                                  \\\n\t(*(long (*)(SSL_CTX *, int, void (*)(void)))ssl_sw[35].ptr)\n#define SSL_get_servername                                                     \\\n\t(*(const char *(*)(const SSL *, int type))ssl_sw[36].ptr)\n#define SSL_set_SSL_CTX (*(SSL_CTX * (*)(SSL *, SSL_CTX *))ssl_sw[37].ptr)\n\n#define SSL_CTX_set_options(ctx, op)                                           \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_OPTIONS, (op), NULL)\n#define SSL_CTX_clear_options(ctx, op)                                         \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_CLEAR_OPTIONS, (op), NULL)\n#define SSL_CTX_set_ecdh_auto(ctx, onoff)                                      \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, onoff, NULL)\n\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 53\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 54\n#define SSL_CTX_set_tlsext_servername_callback(ctx, cb)                        \\\n\tSSL_CTX_callback_ctrl(ctx,                                                 \\\n\t                      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,                   \\\n\t                      (void (*)(void))cb)\n#define SSL_CTX_set_tlsext_servername_arg(ctx, arg)                            \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, (void *)arg)\n\n#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)\n#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)\n\n#define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)arg))\n#define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))\n\n#define CRYPTO_num_locks (*(int (*)(void))crypto_sw[0].ptr)\n#define CRYPTO_set_locking_callback                                            \\\n\t(*(void (*)(void (*)(int, int, const char *, int)))crypto_sw[1].ptr)\n#define CRYPTO_set_id_callback                                                 \\\n\t(*(void (*)(unsigned long (*)(void)))crypto_sw[2].ptr)\n#define ERR_get_error (*(unsigned long (*)(void))crypto_sw[3].ptr)\n#define ERR_error_string (*(char *(*)(unsigned long, char *))crypto_sw[4].ptr)\n#define ERR_remove_state (*(void (*)(unsigned long))crypto_sw[5].ptr)\n#define ERR_free_strings (*(void (*)(void))crypto_sw[6].ptr)\n#define ENGINE_cleanup (*(void (*)(void))crypto_sw[7].ptr)\n#define CONF_modules_unload (*(void (*)(int))crypto_sw[8].ptr)\n#define CRYPTO_cleanup_all_ex_data (*(void (*)(void))crypto_sw[9].ptr)\n#define EVP_cleanup (*(void (*)(void))crypto_sw[10].ptr)\n#define X509_free (*(void (*)(X509 *))crypto_sw[11].ptr)\n#define X509_get_subject_name (*(X509_NAME * (*)(X509 *))crypto_sw[12].ptr)\n#define X509_get_issuer_name (*(X509_NAME * (*)(X509 *))crypto_sw[13].ptr)\n#define X509_NAME_oneline                                                      \\\n\t(*(char *(*)(X509_NAME *, char *, int))crypto_sw[14].ptr)\n#define X509_get_serialNumber (*(ASN1_INTEGER * (*)(X509 *))crypto_sw[15].ptr)\n#define i2c_ASN1_INTEGER                                                       \\\n\t(*(int (*)(ASN1_INTEGER *, unsigned char **))crypto_sw[16].ptr)\n#define EVP_get_digestbyname                                                   \\\n\t(*(const EVP_MD *(*)(const char *))crypto_sw[17].ptr)\n#define EVP_Digest                                                             \\\n\t(*(int (*)(                                                                \\\n\t    const void *, size_t, void *, unsigned int *, const EVP_MD *, void *)) \\\n\t      crypto_sw[18].ptr)\n#define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[19].ptr)\n#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[20].ptr)\n#define ASN1_INTEGER_to_BN                                                     \\\n\t(*(BIGNUM * (*)(const ASN1_INTEGER *ai, BIGNUM *bn))crypto_sw[21].ptr)\n#define BN_free (*(void (*)(const BIGNUM *a))crypto_sw[22].ptr)\n#define CRYPTO_free (*(void (*)(void *addr))crypto_sw[23].ptr)\n\n#define OPENSSL_free(a) CRYPTO_free(a)\n\n/* init_ssl_ctx() function updates this array.\n * It loads SSL library dynamically and changes NULLs to the actual addresses\n * of respective functions. The macros above (like SSL_connect()) are really\n * just calling these functions indirectly via the pointer. */\nstatic struct ssl_func ssl_sw[] = {{\"SSL_free\", NULL},\n                                   {\"SSL_accept\", NULL},\n                                   {\"SSL_connect\", NULL},\n                                   {\"SSL_read\", NULL},\n                                   {\"SSL_write\", NULL},\n                                   {\"SSL_get_error\", NULL},\n                                   {\"SSL_set_fd\", NULL},\n                                   {\"SSL_new\", NULL},\n                                   {\"SSL_CTX_new\", NULL},\n                                   {\"SSLv23_server_method\", NULL},\n                                   {\"SSL_library_init\", NULL},\n                                   {\"SSL_CTX_use_PrivateKey_file\", NULL},\n                                   {\"SSL_CTX_use_certificate_file\", NULL},\n                                   {\"SSL_CTX_set_default_passwd_cb\", NULL},\n                                   {\"SSL_CTX_free\", NULL},\n                                   {\"SSL_load_error_strings\", NULL},\n                                   {\"SSL_CTX_use_certificate_chain_file\", NULL},\n                                   {\"SSLv23_client_method\", NULL},\n                                   {\"SSL_pending\", NULL},\n                                   {\"SSL_CTX_set_verify\", NULL},\n                                   {\"SSL_shutdown\", NULL},\n                                   {\"SSL_CTX_load_verify_locations\", NULL},\n                                   {\"SSL_CTX_set_default_verify_paths\", NULL},\n                                   {\"SSL_CTX_set_verify_depth\", NULL},\n                                   {\"SSL_get_peer_certificate\", NULL},\n                                   {\"SSL_get_version\", NULL},\n                                   {\"SSL_get_current_cipher\", NULL},\n                                   {\"SSL_CIPHER_get_name\", NULL},\n                                   {\"SSL_CTX_check_private_key\", NULL},\n                                   {\"SSL_CTX_set_session_id_context\", NULL},\n                                   {\"SSL_CTX_ctrl\", NULL},\n                                   {\"SSL_CTX_set_cipher_list\", NULL},\n                                   {\"SSL_CTX_set_info_callback\", NULL},\n                                   {\"SSL_get_ex_data\", NULL},\n                                   {\"SSL_set_ex_data\", NULL},\n                                   {\"SSL_CTX_callback_ctrl\", NULL},\n                                   {\"SSL_get_servername\", NULL},\n                                   {\"SSL_set_SSL_CTX\", NULL},\n                                   {NULL, NULL}};\n\n\n/* Similar array as ssl_sw. These functions could be located in different\n * lib. */\nstatic struct ssl_func crypto_sw[] = {{\"CRYPTO_num_locks\", NULL},\n                                      {\"CRYPTO_set_locking_callback\", NULL},\n                                      {\"CRYPTO_set_id_callback\", NULL},\n                                      {\"ERR_get_error\", NULL},\n                                      {\"ERR_error_string\", NULL},\n                                      {\"ERR_remove_state\", NULL},\n                                      {\"ERR_free_strings\", NULL},\n                                      {\"ENGINE_cleanup\", NULL},\n                                      {\"CONF_modules_unload\", NULL},\n                                      {\"CRYPTO_cleanup_all_ex_data\", NULL},\n                                      {\"EVP_cleanup\", NULL},\n                                      {\"X509_free\", NULL},\n                                      {\"X509_get_subject_name\", NULL},\n                                      {\"X509_get_issuer_name\", NULL},\n                                      {\"X509_NAME_oneline\", NULL},\n                                      {\"X509_get_serialNumber\", NULL},\n                                      {\"i2c_ASN1_INTEGER\", NULL},\n                                      {\"EVP_get_digestbyname\", NULL},\n                                      {\"EVP_Digest\", NULL},\n                                      {\"i2d_X509\", NULL},\n                                      {\"BN_bn2hex\", NULL},\n                                      {\"ASN1_INTEGER_to_BN\", NULL},\n                                      {\"BN_free\", NULL},\n                                      {\"CRYPTO_free\", NULL},\n                                      {NULL, NULL}};\n#endif /* OPENSSL_API_1_1 */\n#endif /* NO_SSL_DL */\n#endif /* NO_SSL */\n\n\n#if !defined(NO_CACHING)\nstatic const char *month_names[] = {\"Jan\",\n                                    \"Feb\",\n                                    \"Mar\",\n                                    \"Apr\",\n                                    \"May\",\n                                    \"Jun\",\n                                    \"Jul\",\n                                    \"Aug\",\n                                    \"Sep\",\n                                    \"Oct\",\n                                    \"Nov\",\n                                    \"Dec\"};\n#endif /* !NO_CACHING */\n\n/* Unified socket address. For IPv6 support, add IPv6 address structure in\n * the\n * union u. */\nunion usa {\n\tstruct sockaddr sa;\n\tstruct sockaddr_in sin;\n#if defined(USE_IPV6)\n\tstruct sockaddr_in6 sin6;\n#endif\n};\n\n/* Describes a string (chunk of memory). */\nstruct vec {\n\tconst char *ptr;\n\tsize_t len;\n};\n\nstruct mg_file_stat {\n\t/* File properties filled by mg_stat: */\n\tuint64_t size;\n\ttime_t last_modified;\n\tint is_directory; /* Set to 1 if mg_stat is called for a directory */\n\tint is_gzipped;   /* Set to 1 if the content is gzipped, in which\n\t                   * case we need a \"Content-Eencoding: gzip\" header */\n\tint location;     /* 0 = nowhere, 1 = on disk, 2 = in memory */\n};\n\nstruct mg_file_in_memory {\n\tchar *p;\n\tuint32_t pos;\n\tchar mode;\n};\n\nstruct mg_file_access {\n\t/* File properties filled by mg_fopen: */\n\tFILE *fp;\n#if defined(MG_USE_OPEN_FILE)\n\t/* TODO (low): Remove obsolete \"file in memory\" implementation.\n\t * In an \"early 2017\" discussion at Google groups\n\t * https://groups.google.com/forum/#!topic/civetweb/h9HT4CmeYqI\n\t * we decided to get rid of this feature (after some fade-out\n\t * phase). */\n\tconst char *membuf;\n#endif\n};\n\nstruct mg_file {\n\tstruct mg_file_stat stat;\n\tstruct mg_file_access access;\n};\n\n#if defined(MG_USE_OPEN_FILE)\n\n#define STRUCT_FILE_INITIALIZER                                                \\\n\t{                                                                          \\\n\t\t{                                                                      \\\n\t\t\t(uint64_t)0, (time_t)0, 0, 0, 0                                    \\\n\t\t}                                                                      \\\n\t\t,                                                                      \\\n\t\t{                                                                      \\\n\t\t\t(FILE *) NULL, (const char *)NULL                                  \\\n\t\t}                                                                      \\\n\t}\n\n#else\n\n#define STRUCT_FILE_INITIALIZER                                                \\\n\t{                                                                          \\\n\t\t{                                                                      \\\n\t\t\t(uint64_t)0, (time_t)0, 0, 0, 0                                    \\\n\t\t}                                                                      \\\n\t\t,                                                                      \\\n\t\t{                                                                      \\\n\t\t\t(FILE *) NULL                                                      \\\n\t\t}                                                                      \\\n\t}\n\n#endif\n\n\n/* Describes listening socket, or socket which was accept()-ed by the master\n * thread and queued for future handling by the worker thread. */\nstruct socket {\n\tSOCKET sock;             /* Listening socket */\n\tunion usa lsa;           /* Local socket address */\n\tunion usa rsa;           /* Remote socket address */\n\tunsigned char is_ssl;    /* Is port SSL-ed */\n\tunsigned char ssl_redir; /* Is port supposed to redirect everything to SSL\n\t                          * port */\n\tunsigned char in_use;    /* Is valid */\n};\n\n\n/* Enum const for all options must be in sync with\n * static struct mg_option config_options[]\n * This is tested in the unit test (test/private.c)\n * \"Private Config Options\"\n */\nenum {\n\tLISTENING_PORTS,\n\tNUM_THREADS,\n\tRUN_AS_USER,\n\tCONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the\n                         * socket option typedef TCP_NODELAY. */\n\tMAX_REQUEST_SIZE,\n\tLINGER_TIMEOUT,\n#if defined(__linux__)\n\tALLOW_SENDFILE_CALL,\n#endif\n#if defined(_WIN32)\n\tCASE_SENSITIVE_FILES,\n#endif\n\tTHROTTLE,\n\tACCESS_LOG_FILE,\n\tERROR_LOG_FILE,\n\tENABLE_KEEP_ALIVE,\n\tREQUEST_TIMEOUT,\n\tKEEP_ALIVE_TIMEOUT,\n#if defined(USE_WEBSOCKET)\n\tWEBSOCKET_TIMEOUT,\n\tENABLE_WEBSOCKET_PING_PONG,\n#endif\n\tDECODE_URL,\n#if defined(USE_LUA)\n\tLUA_BACKGROUND_SCRIPT,\n\tLUA_BACKGROUND_SCRIPT_PARAMS,\n#endif\n\n\n\tDOCUMENT_ROOT,\n\tCGI_EXTENSIONS,\n\tCGI_ENVIRONMENT,\n\tPUT_DELETE_PASSWORDS_FILE,\n\tCGI_INTERPRETER,\n\tPROTECT_URI,\n\tAUTHENTICATION_DOMAIN,\n\tENABLE_AUTH_DOMAIN_CHECK,\n\tSSI_EXTENSIONS,\n\tENABLE_DIRECTORY_LISTING,\n\tGLOBAL_PASSWORDS_FILE,\n\tINDEX_FILES,\n\tACCESS_CONTROL_LIST,\n\tEXTRA_MIME_TYPES,\n\tSSL_CERTIFICATE,\n\tSSL_CERTIFICATE_CHAIN,\n\tURL_REWRITE_PATTERN,\n\tHIDE_FILES,\n\tSSL_DO_VERIFY_PEER,\n\tSSL_CA_PATH,\n\tSSL_CA_FILE,\n\tSSL_VERIFY_DEPTH,\n\tSSL_DEFAULT_VERIFY_PATHS,\n\tSSL_CIPHER_LIST,\n\tSSL_PROTOCOL_VERSION,\n\tSSL_SHORT_TRUST,\n\n#if defined(USE_LUA)\n\tLUA_PRELOAD_FILE,\n\tLUA_SCRIPT_EXTENSIONS,\n\tLUA_SERVER_PAGE_EXTENSIONS,\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n\tLUA_DEBUG_PARAMS,\n#endif\n#endif\n#if defined(USE_DUKTAPE)\n\tDUKTAPE_SCRIPT_EXTENSIONS,\n#endif\n\n#if defined(USE_WEBSOCKET)\n\tWEBSOCKET_ROOT,\n#endif\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tLUA_WEBSOCKET_EXTENSIONS,\n#endif\n\n\tACCESS_CONTROL_ALLOW_ORIGIN,\n\tACCESS_CONTROL_ALLOW_METHODS,\n\tACCESS_CONTROL_ALLOW_HEADERS,\n\tERROR_PAGES,\n#if !defined(NO_CACHING)\n\tSTATIC_FILE_MAX_AGE,\n#endif\n#if !defined(NO_SSL)\n\tSTRICT_HTTPS_MAX_AGE,\n#endif\n\tADDITIONAL_HEADER,\n\tALLOW_INDEX_SCRIPT_SUB_RES,\n\n\tNUM_OPTIONS\n};\n\n\n/* Config option name, config types, default value.\n * Must be in the same order as the enum const above.\n */\nstatic const struct mg_option config_options[] = {\n\n    /* Once for each server */\n    {\"listening_ports\", MG_CONFIG_TYPE_STRING_LIST, \"8080\"},\n    {\"num_threads\", MG_CONFIG_TYPE_NUMBER, \"50\"},\n    {\"run_as_user\", MG_CONFIG_TYPE_STRING, NULL},\n    {\"tcp_nodelay\", MG_CONFIG_TYPE_NUMBER, \"0\"},\n    {\"max_request_size\", MG_CONFIG_TYPE_NUMBER, \"16384\"},\n    {\"linger_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n#if defined(__linux__)\n    {\"allow_sendfile_call\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n#endif\n#if defined(_WIN32)\n    {\"case_sensitive\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n#endif\n    {\"throttle\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"access_log_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"error_log_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"enable_keep_alive\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n    {\"request_timeout_ms\", MG_CONFIG_TYPE_NUMBER, \"30000\"},\n    {\"keep_alive_timeout_ms\", MG_CONFIG_TYPE_NUMBER, \"500\"},\n#if defined(USE_WEBSOCKET)\n    {\"websocket_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n    {\"enable_websocket_ping_pong\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n#endif\n    {\"decode_url\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n#if defined(USE_LUA)\n    {\"lua_background_script\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"lua_background_script_params\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n#endif\n\n\n    /* Once for each domain */\n    {\"document_root\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n    {\"cgi_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.cgi$|**.pl$|**.php$\"},\n    {\"cgi_environment\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"put_delete_auth_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"cgi_interpreter\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"protect_uri\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"authentication_domain\", MG_CONFIG_TYPE_STRING, \"mydomain.com\"},\n    {\"enable_auth_domain_check\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"ssi_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.shtml$|**.shtm$\"},\n    {\"enable_directory_listing\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"global_auth_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"index_files\",\n     MG_CONFIG_TYPE_STRING_LIST,\n#if defined(USE_LUA)\n     \"index.xhtml,index.html,index.htm,\"\n     \"index.lp,index.lsp,index.lua,index.cgi,\"\n     \"index.shtml,index.php\"},\n#else\n     \"index.xhtml,index.html,index.htm,index.cgi,index.shtml,index.php\"},\n#endif\n    {\"access_control_list\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"extra_mime_types\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"ssl_certificate\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"ssl_certificate_chain\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"url_rewrite_patterns\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"hide_files_patterns\", MG_CONFIG_TYPE_EXT_PATTERN, NULL},\n\n    {\"ssl_verify_peer\", MG_CONFIG_TYPE_YES_NO_OPTIONAL, \"no\"},\n\n    {\"ssl_ca_path\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n    {\"ssl_ca_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"ssl_verify_depth\", MG_CONFIG_TYPE_NUMBER, \"9\"},\n    {\"ssl_default_verify_paths\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"ssl_cipher_list\", MG_CONFIG_TYPE_STRING, NULL},\n    {\"ssl_protocol_version\", MG_CONFIG_TYPE_NUMBER, \"0\"},\n    {\"ssl_short_trust\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n\n#if defined(USE_LUA)\n    {\"lua_preload_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"lua_script_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},\n    {\"lua_server_page_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lp$|**.lsp$\"},\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n    {\"lua_debug\", MG_CONFIG_TYPE_STRING, NULL},\n#endif\n#endif\n#if defined(USE_DUKTAPE)\n    /* The support for duktape is still in alpha version state.\n     * The name of this config option might change. */\n    {\"duktape_script_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.ssjs$\"},\n#endif\n\n#if defined(USE_WEBSOCKET)\n    {\"websocket_root\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n#endif\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n    {\"lua_websocket_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},\n#endif\n    {\"access_control_allow_origin\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"access_control_allow_methods\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"access_control_allow_headers\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"error_pages\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n#if !defined(NO_CACHING)\n    {\"static_file_max_age\", MG_CONFIG_TYPE_NUMBER, \"3600\"},\n#endif\n#if !defined(NO_SSL)\n    {\"strict_transport_security_max_age\", MG_CONFIG_TYPE_NUMBER, NULL},\n#endif\n    {\"additional_header\", MG_CONFIG_TYPE_STRING_MULTILINE, NULL},\n    {\"allow_index_script_resource\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n\n    {NULL, MG_CONFIG_TYPE_UNKNOWN, NULL}};\n\n\n/* Check if the config_options and the corresponding enum have compatible\n * sizes. */\nmg_static_assert((sizeof(config_options) / sizeof(config_options[0]))\n                     == (NUM_OPTIONS + 1),\n                 \"config_options and enum not sync\");\n\n\nenum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };\n\n\nstruct mg_handler_info {\n\t/* Name/Pattern of the URI. */\n\tchar *uri;\n\tsize_t uri_len;\n\n\t/* handler type */\n\tint handler_type;\n\n\t/* Handler for http/https or authorization requests. */\n\tmg_request_handler handler;\n\tunsigned int refcount;\n\tpthread_mutex_t refcount_mutex; /* Protects refcount */\n\tpthread_cond_t\n\t    refcount_cond; /* Signaled when handler refcount is decremented */\n\n\t/* Handler for ws/wss (websocket) requests. */\n\tmg_websocket_connect_handler connect_handler;\n\tmg_websocket_ready_handler ready_handler;\n\tmg_websocket_data_handler data_handler;\n\tmg_websocket_close_handler close_handler;\n\n\t/* accepted subprotocols for ws/wss requests. */\n\tstruct mg_websocket_subprotocols *subprotocols;\n\n\t/* Handler for authorization requests */\n\tmg_authorization_handler auth_handler;\n\n\t/* User supplied argument for the handler function. */\n\tvoid *cbdata;\n\n\t/* next handler in a linked list */\n\tstruct mg_handler_info *next;\n};\n\n\nenum {\n\tCONTEXT_INVALID,\n\tCONTEXT_SERVER,\n\tCONTEXT_HTTP_CLIENT,\n\tCONTEXT_WS_CLIENT\n};\n\n\nstruct mg_domain_context {\n\tSSL_CTX *ssl_ctx;                 /* SSL context */\n\tchar *config[NUM_OPTIONS];        /* Civetweb configuration parameters */\n\tstruct mg_handler_info *handlers; /* linked list of uri handlers */\n\n\t/* Server nonce */\n\tuint64_t auth_nonce_mask;  /* Mask for all nonce values */\n\tunsigned long nonce_count; /* Used nonces, used for authentication */\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\t/* linked list of shared lua websockets */\n\tstruct mg_shared_lua_websocket_list *shared_lua_websockets;\n#endif\n\n\t/* Linked list of domains */\n\tstruct mg_domain_context *next;\n};\n\n\nstruct mg_context {\n\n\t/* Part 1 - Physical context:\n\t * This holds threads, ports, timeouts, ...\n\t * set for the entire server, independent from the\n\t * addressed hostname.\n\t */\n\n\t/* Connection related */\n\tint context_type; /* See CONTEXT_* above */\n\n\tstruct socket *listening_sockets;\n\tstruct pollfd *listening_socket_fds;\n\tunsigned int num_listening_sockets;\n\n\tstruct mg_connection *worker_connections; /* The connection struct, pre-\n\t                                           * allocated for each worker */\n\n#if defined(USE_SERVER_STATS)\n\tint active_connections;\n\tint max_connections;\n\tint64_t total_connections;\n\tint64_t total_requests;\n\tint64_t total_data_read;\n\tint64_t total_data_written;\n#endif\n\n\t/* Thread related */\n\tvolatile int stop_flag;       /* Should we stop event loop */\n\tpthread_mutex_t thread_mutex; /* Protects (max|num)_threads */\n\n\tpthread_t masterthreadid; /* The master thread ID */\n\tunsigned int\n\t    cfg_worker_threads;      /* The number of configured worker threads. */\n\tpthread_t *worker_threadids; /* The worker thread IDs */\n\n/* Connection to thread dispatching */\n#if defined(ALTERNATIVE_QUEUE)\n\tstruct socket *client_socks;\n\tvoid **client_wait_events;\n#else\n\tstruct socket queue[MGSQLEN]; /* Accepted sockets */\n\tvolatile int sq_head;         /* Head of the socket queue */\n\tvolatile int sq_tail;         /* Tail of the socket queue */\n\tpthread_cond_t sq_full;       /* Signaled when socket is produced */\n\tpthread_cond_t sq_empty;      /* Signaled when socket is consumed */\n#endif\n\n\t/* Memory related */\n\tunsigned int max_request_size; /* The max request size */\n\n#if defined(USE_SERVER_STATS)\n\tstruct mg_memory_stat ctx_memory;\n#endif\n\n\t/* Operating system related */\n\tchar *systemName;  /* What operating system is running */\n\ttime_t start_time; /* Server start time, used for authentication\n\t                    * and for diagnstics. */\n\n#if defined(USE_TIMERS)\n\tstruct ttimers *timers;\n#endif\n\n/* Lua specific: Background operations and shared websockets */\n#if defined(USE_LUA)\n\tvoid *lua_background_state;\n#endif\n\n\t/* Server nonce */\n\tpthread_mutex_t nonce_mutex; /* Protects nonce_count */\n\n\t/* Server callbacks */\n\tstruct mg_callbacks callbacks; /* User-defined callback function */\n\tvoid *user_data;               /* User-defined data */\n\n\t/* Part 2 - Logical domain:\n\t * This holds hostname, TLS certificate, document root, ...\n\t * set for a domain hosted at the server.\n\t * There may be multiple domains hosted at one physical server.\n\t * The default domain \"dd\" is the first element of a list of\n\t * domains.\n\t */\n\tstruct mg_domain_context dd; /* default domain */\n};\n\n\n#if defined(USE_SERVER_STATS)\nstatic struct mg_memory_stat mg_common_memory = {0, 0, 0};\n\nstatic struct mg_memory_stat *\nget_memory_stat(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\treturn &(ctx->ctx_memory);\n\t}\n\treturn &mg_common_memory;\n}\n#endif\n\nenum {\n\tCONNECTION_TYPE_INVALID,\n\tCONNECTION_TYPE_REQUEST,\n\tCONNECTION_TYPE_RESPONSE\n};\n\nstruct mg_connection {\n\tint connection_type; /* see CONNECTION_TYPE_* above */\n\n\tstruct mg_request_info request_info;\n\tstruct mg_response_info response_info;\n\n\tstruct mg_context *phys_ctx;\n\tstruct mg_domain_context *dom_ctx;\n\n#if defined(USE_SERVER_STATS)\n\tint conn_state; /* 0 = undef, numerical value may change in different\n\t                 * versions. For the current definition, see\n\t                 * mg_get_connection_info_impl */\n#endif\n\n\tconst char *host;         /* Host (HTTP/1.1 header or SNI) */\n\tSSL *ssl;                 /* SSL descriptor */\n\tSSL_CTX *client_ssl_ctx;  /* SSL context for client connections */\n\tstruct socket client;     /* Connected client */\n\ttime_t conn_birth_time;   /* Time (wall clock) when connection was\n\t                           * established */\n\tstruct timespec req_time; /* Time (since system start) when the request\n\t                           * was received */\n\tint64_t num_bytes_sent;   /* Total bytes sent to client */\n\tint64_t content_len;      /* Content-Length header value */\n\tint64_t consumed_content; /* How many bytes of content have been read */\n\tint is_chunked;           /* Transfer-Encoding is chunked:\n\t                           * 0 = not chunked,\n\t                           * 1 = chunked, do data read yet,\n\t                           * 2 = chunked, some data read,\n\t                           * 3 = chunked, all data read\n\t                           */\n\tsize_t chunk_remainder;   /* Unread data from the last chunk */\n\tchar *buf;                /* Buffer for received data */\n\tchar *path_info;          /* PATH_INFO part of the URL */\n\n\tint must_close;       /* 1 if connection must be closed */\n\tint accept_gzip;      /* 1 if gzip encoding is accepted */\n\tint in_error_handler; /* 1 if in handler for user defined error\n\t                       * pages */\n#if defined(USE_WEBSOCKET)\n\tint in_websocket_handling; /* 1 if in read_websocket */\n#endif\n\tint handled_requests; /* Number of requests handled by this connection\n\t                         */\n\tint buf_size;         /* Buffer size */\n\tint request_len;      /* Size of the request + headers in a buffer */\n\tint data_len;         /* Total size of data in a buffer */\n\tint status_code;      /* HTTP reply status code, e.g. 200 */\n\tint throttle;         /* Throttling, bytes/sec. <= 0 means no\n\t                       * throttle */\n\n\ttime_t last_throttle_time;   /* Last time throttled data was sent */\n\tint64_t last_throttle_bytes; /* Bytes sent this second */\n\tpthread_mutex_t mutex;       /* Used by mg_(un)lock_connection to ensure\n\t                              * atomic transmissions for websockets */\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tvoid *lua_websocket_state; /* Lua_State for a websocket connection */\n#endif\n\n\tint thread_index; /* Thread index within ctx */\n};\n\n\n/* Directory entry */\nstruct de {\n\tstruct mg_connection *conn;\n\tchar *file_name;\n\tstruct mg_file_stat file;\n};\n\n\n#if defined(USE_WEBSOCKET)\nstatic int is_websocket_protocol(const struct mg_connection *conn);\n#else\n#define is_websocket_protocol(conn) (0)\n#endif\n\n\n#define mg_cry_internal(conn, fmt, ...)                                        \\\n\tmg_cry_internal_wrap(conn, __func__, __LINE__, fmt, __VA_ARGS__)\n\nstatic void mg_cry_internal_wrap(const struct mg_connection *conn,\n                                 const char *func,\n                                 unsigned line,\n                                 const char *fmt,\n                                 ...) PRINTF_ARGS(4, 5);\n\n\n#if !defined(NO_THREAD_NAME)\n#if defined(_WIN32) && defined(_MSC_VER)\n/* Set the thread name for debugging purposes in Visual Studio\n * http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\n */\n#pragma pack(push, 8)\ntypedef struct tagTHREADNAME_INFO {\n\tDWORD dwType;     /* Must be 0x1000. */\n\tLPCSTR szName;    /* Pointer to name (in user addr space). */\n\tDWORD dwThreadID; /* Thread ID (-1=caller thread). */\n\tDWORD dwFlags;    /* Reserved for future use, must be zero. */\n} THREADNAME_INFO;\n#pragma pack(pop)\n\n#elif defined(__linux__)\n\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#if defined(ALTERNATIVE_QUEUE)\n#include <sys/eventfd.h>\n#endif /* ALTERNATIVE_QUEUE */\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\nstatic void *\nevent_create(void)\n{\n\tint evhdl = eventfd(0, EFD_CLOEXEC);\n\tint *ret;\n\n\tif (evhdl == -1) {\n\t\t/* Linux uses -1 on error, Windows NULL. */\n\t\t/* However, Linux does not return 0 on success either. */\n\t\treturn 0;\n\t}\n\n\tret = (int *)mg_malloc(sizeof(int));\n\tif (ret) {\n\t\t*ret = evhdl;\n\t} else {\n\t\t(void)close(evhdl);\n\t}\n\n\treturn (void *)ret;\n}\n\n\nstatic int\nevent_wait(void *eventhdl)\n{\n\tuint64_t u;\n\tint evhdl, s;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\ts = (int)read(evhdl, &u, sizeof(u));\n\tif (s != sizeof(u)) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\t(void)u; /* the value is not required */\n\treturn 1;\n}\n\n\nstatic int\nevent_signal(void *eventhdl)\n{\n\tuint64_t u = 1;\n\tint evhdl, s;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\ts = (int)write(evhdl, &u, sizeof(u));\n\tif (s != sizeof(u)) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tint evhdl;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\tclose(evhdl);\n\tmg_free(eventhdl);\n}\n\n\n#endif\n\n#endif\n\n\n#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE)\n\nstruct posix_event {\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cond;\n};\n\n\nstatic void *\nevent_create(void)\n{\n\tstruct posix_event *ret = mg_malloc(sizeof(struct posix_event));\n\tif (ret == 0) {\n\t\t/* out of memory */\n\t\treturn 0;\n\t}\n\tif (0 != pthread_mutex_init(&(ret->mutex), NULL)) {\n\t\t/* pthread mutex not available */\n\t\tmg_free(ret);\n\t\treturn 0;\n\t}\n\tif (0 != pthread_cond_init(&(ret->cond), NULL)) {\n\t\t/* pthread cond not available */\n\t\tpthread_mutex_destroy(&(ret->mutex));\n\t\tmg_free(ret);\n\t\treturn 0;\n\t}\n\treturn (void *)ret;\n}\n\n\nstatic int\nevent_wait(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_mutex_lock(&(ev->mutex));\n\tpthread_cond_wait(&(ev->cond), &(ev->mutex));\n\tpthread_mutex_unlock(&(ev->mutex));\n\treturn 1;\n}\n\n\nstatic int\nevent_signal(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_mutex_lock(&(ev->mutex));\n\tpthread_cond_signal(&(ev->cond));\n\tpthread_mutex_unlock(&(ev->mutex));\n\treturn 1;\n}\n\n\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_cond_destroy(&(ev->cond));\n\tpthread_mutex_destroy(&(ev->mutex));\n\tmg_free(ev);\n}\n#endif\n\n\nstatic void\nmg_set_thread_name(const char *name)\n{\n\tchar threadName[16 + 1]; /* 16 = Max. thread length in Linux/OSX/.. */\n\n\tmg_snprintf(\n\t    NULL, NULL, threadName, sizeof(threadName), \"civetweb-%s\", name);\n\n#if defined(_WIN32)\n#if defined(_MSC_VER)\n\t/* Windows and Visual Studio Compiler */\n\t__try\n\t{\n\t\tTHREADNAME_INFO info;\n\t\tinfo.dwType = 0x1000;\n\t\tinfo.szName = threadName;\n\t\tinfo.dwThreadID = ~0U;\n\t\tinfo.dwFlags = 0;\n\n\t\tRaiseException(0x406D1388,\n\t\t               0,\n\t\t               sizeof(info) / sizeof(ULONG_PTR),\n\t\t               (ULONG_PTR *)&info);\n\t}\n\t__except(EXCEPTION_EXECUTE_HANDLER)\n\t{\n\t}\n#elif defined(__MINGW32__)\n/* No option known to set thread name for MinGW */\n#endif\n#elif defined(_GNU_SOURCE) && defined(__GLIBC__)                               \\\n    && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 12)))\n\t/* pthread_setname_np first appeared in glibc in version 2.12*/\n\t(void)pthread_setname_np(pthread_self(), threadName);\n#elif defined(__linux__)\n\t/* on linux we can use the old prctl function */\n\t(void)prctl(PR_SET_NAME, threadName, 0, 0, 0);\n#endif\n}\n#else /* !defined(NO_THREAD_NAME) */\nvoid\nmg_set_thread_name(const char *threadName)\n{\n}\n#endif\n\n\n#if defined(MG_LEGACY_INTERFACE)\nconst char **\nmg_get_valid_option_names(void)\n{\n\t/* This function is deprecated. Use mg_get_valid_options instead. */\n\tstatic const char *\n\t    data[2 * sizeof(config_options) / sizeof(config_options[0])] = {0};\n\tint i;\n\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdata[i * 2] = config_options[i].name;\n\t\tdata[i * 2 + 1] = config_options[i].default_value;\n\t}\n\n\treturn data;\n}\n#endif\n\n\nconst struct mg_option *\nmg_get_valid_options(void)\n{\n\treturn config_options;\n}\n\n\n/* Do not open file (used in is_file_in_memory) */\n#define MG_FOPEN_MODE_NONE (0)\n\n/* Open file for read only access */\n#define MG_FOPEN_MODE_READ (1)\n\n/* Open file for writing, create and overwrite */\n#define MG_FOPEN_MODE_WRITE (2)\n\n/* Open file for writing, create and append */\n#define MG_FOPEN_MODE_APPEND (4)\n\n\n/* If a file is in memory, set all \"stat\" members and the membuf pointer of\n * output filep and return 1, otherwise return 0 and don't modify anything.\n */\nstatic int\nopen_file_in_memory(const struct mg_connection *conn,\n                    const char *path,\n                    struct mg_file *filep,\n                    int mode)\n{\n#if defined(MG_USE_OPEN_FILE)\n\n\tsize_t size = 0;\n\tconst char *buf = NULL;\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tif ((mode != MG_FOPEN_MODE_NONE) && (mode != MG_FOPEN_MODE_READ)) {\n\t\treturn 0;\n\t}\n\n\tif (conn->phys_ctx->callbacks.open_file) {\n\t\tbuf = conn->phys_ctx->callbacks.open_file(conn, path, &size);\n\t\tif (buf != NULL) {\n\t\t\tif (filep == NULL) {\n\t\t\t\t/* This is a file in memory, but we cannot store the\n\t\t\t\t * properties\n\t\t\t\t * now.\n\t\t\t\t * Called from \"is_file_in_memory\" function. */\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* NOTE: override filep->size only on success. Otherwise, it\n\t\t\t * might\n\t\t\t * break constructs like if (!mg_stat() || !mg_fopen()) ... */\n\t\t\tfilep->access.membuf = buf;\n\t\t\tfilep->access.fp = NULL;\n\n\t\t\t/* Size was set by the callback */\n\t\t\tfilep->stat.size = size;\n\n\t\t\t/* Assume the data may change during runtime by setting\n\t\t\t * last_modified = now */\n\t\t\tfilep->stat.last_modified = time(NULL);\n\n\t\t\tfilep->stat.is_directory = 0;\n\t\t\tfilep->stat.is_gzipped = 0;\n\t\t}\n\t}\n\n\treturn (buf != NULL);\n\n#else\n\t(void)conn;\n\t(void)path;\n\t(void)filep;\n\t(void)mode;\n\n\treturn 0;\n\n#endif\n}\n\n\nstatic int\nis_file_in_memory(const struct mg_connection *conn, const char *path)\n{\n\treturn open_file_in_memory(conn, path, NULL, MG_FOPEN_MODE_NONE);\n}\n\n\nstatic int\nis_file_opened(const struct mg_file_access *fileacc)\n{\n\tif (!fileacc) {\n\t\treturn 0;\n\t}\n\n#if defined(MG_USE_OPEN_FILE)\n\treturn (fileacc->membuf != NULL) || (fileacc->fp != NULL);\n#else\n\treturn (fileacc->fp != NULL);\n#endif\n}\n\n\nstatic int mg_stat(const struct mg_connection *conn,\n                   const char *path,\n                   struct mg_file_stat *filep);\n\n\n/* mg_fopen will open a file either in memory or on the disk.\n * The input parameter path is a string in UTF-8 encoding.\n * The input parameter mode is MG_FOPEN_MODE_*\n * On success, either fp or membuf will be set in the output\n * struct file. All status members will also be set.\n * The function returns 1 on success, 0 on error. */\nstatic int\nmg_fopen(const struct mg_connection *conn,\n         const char *path,\n         int mode,\n         struct mg_file *filep)\n{\n\tint found;\n\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tfilep->access.fp = NULL;\n#if defined(MG_USE_OPEN_FILE)\n\tfilep->access.membuf = NULL;\n#endif\n\n\tif (!is_file_in_memory(conn, path)) {\n\n\t\t/* filep is initialized in mg_stat: all fields with memset to,\n\t\t * some fields like size and modification date with values */\n\t\tfound = mg_stat(conn, path, &(filep->stat));\n\n\t\tif ((mode == MG_FOPEN_MODE_READ) && (!found)) {\n\t\t\t/* file does not exist and will not be created */\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\t{\n\t\t\twchar_t wbuf[W_PATH_MAX];\n\t\t\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\t\t\tswitch (mode) {\n\t\t\tcase MG_FOPEN_MODE_READ:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"rb\");\n\t\t\t\tbreak;\n\t\t\tcase MG_FOPEN_MODE_WRITE:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"wb\");\n\t\t\t\tbreak;\n\t\t\tcase MG_FOPEN_MODE_APPEND:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"ab\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\t/* Linux et al already use unicode. No need to convert. */\n\t\tswitch (mode) {\n\t\tcase MG_FOPEN_MODE_READ:\n\t\t\tfilep->access.fp = fopen(path, \"r\");\n\t\t\tbreak;\n\t\tcase MG_FOPEN_MODE_WRITE:\n\t\t\tfilep->access.fp = fopen(path, \"w\");\n\t\t\tbreak;\n\t\tcase MG_FOPEN_MODE_APPEND:\n\t\t\tfilep->access.fp = fopen(path, \"a\");\n\t\t\tbreak;\n\t\t}\n\n#endif\n\t\tif (!found) {\n\t\t\t/* File did not exist before fopen was called.\n\t\t\t * Maybe it has been created now. Get stat info\n\t\t\t * like creation time now. */\n\t\t\tfound = mg_stat(conn, path, &(filep->stat));\n\t\t\t(void)found;\n\t\t}\n\n\t\t/* file is on disk */\n\t\treturn (filep->access.fp != NULL);\n\n\t} else {\n#if defined(MG_USE_OPEN_FILE)\n\t\t/* is_file_in_memory returned true */\n\t\tif (open_file_in_memory(conn, path, filep, mode)) {\n\t\t\t/* file is in memory */\n\t\t\treturn (filep->access.membuf != NULL);\n\t\t}\n#endif\n\t}\n\n\t/* Open failed */\n\treturn 0;\n}\n\n\n/* return 0 on success, just like fclose */\nstatic int\nmg_fclose(struct mg_file_access *fileacc)\n{\n\tint ret = -1;\n\tif (fileacc != NULL) {\n\t\tif (fileacc->fp != NULL) {\n\t\t\tret = fclose(fileacc->fp);\n#if defined(MG_USE_OPEN_FILE)\n\t\t} else if (fileacc->membuf != NULL) {\n\t\t\tret = 0;\n#endif\n\t\t}\n\t\t/* reset all members of fileacc */\n\t\tmemset(fileacc, 0, sizeof(*fileacc));\n\t}\n\treturn ret;\n}\n\n\nstatic void\nmg_strlcpy(register char *dst, register const char *src, size_t n)\n{\n\tfor (; *src != '\\0' && n > 1; n--) {\n\t\t*dst++ = *src++;\n\t}\n\t*dst = '\\0';\n}\n\n\nstatic int\nlowercase(const char *s)\n{\n\treturn tolower(*(const unsigned char *)s);\n}\n\n\nint\nmg_strncasecmp(const char *s1, const char *s2, size_t len)\n{\n\tint diff = 0;\n\n\tif (len > 0) {\n\t\tdo {\n\t\t\tdiff = lowercase(s1++) - lowercase(s2++);\n\t\t} while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\t}\n\n\treturn diff;\n}\n\n\nint\nmg_strcasecmp(const char *s1, const char *s2)\n{\n\tint diff;\n\n\tdo {\n\t\tdiff = lowercase(s1++) - lowercase(s2++);\n\t} while (diff == 0 && s1[-1] != '\\0');\n\n\treturn diff;\n}\n\n\nstatic char *\nmg_strndup_ctx(const char *ptr, size_t len, struct mg_context *ctx)\n{\n\tchar *p;\n\t(void)ctx; /* Avoid Visual Studio warning if USE_SERVER_STATS is not\n\t            * defined */\n\n\tif ((p = (char *)mg_malloc_ctx(len + 1, ctx)) != NULL) {\n\t\tmg_strlcpy(p, ptr, len + 1);\n\t}\n\n\treturn p;\n}\n\n\nstatic char *\nmg_strdup_ctx(const char *str, struct mg_context *ctx)\n{\n\treturn mg_strndup_ctx(str, strlen(str), ctx);\n}\n\nstatic char *\nmg_strdup(const char *str)\n{\n\treturn mg_strndup_ctx(str, strlen(str), NULL);\n}\n\n\nstatic const char *\nmg_strcasestr(const char *big_str, const char *small_str)\n{\n\tsize_t i, big_len = strlen(big_str), small_len = strlen(small_str);\n\n\tif (big_len >= small_len) {\n\t\tfor (i = 0; i <= (big_len - small_len); i++) {\n\t\t\tif (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {\n\t\t\t\treturn big_str + i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/* Return null terminated string of given maximum length.\n * Report errors if length is exceeded. */\nstatic void\nmg_vsnprintf(const struct mg_connection *conn,\n             int *truncated,\n             char *buf,\n             size_t buflen,\n             const char *fmt,\n             va_list ap)\n{\n\tint n, ok;\n\n\tif (buflen == 0) {\n\t\tif (truncated) {\n\t\t\t*truncated = 1;\n\t\t}\n\t\treturn;\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n/* Using fmt as a non-literal is intended here, since it is mostly called\n * indirectly by mg_snprintf */\n#endif\n\n\tn = (int)vsnprintf_impl(buf, buflen, fmt, ap);\n\tok = (n >= 0) && ((size_t)n < buflen);\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\tif (ok) {\n\t\tif (truncated) {\n\t\t\t*truncated = 0;\n\t\t}\n\t} else {\n\t\tif (truncated) {\n\t\t\t*truncated = 1;\n\t\t}\n\t\tmg_cry_internal(conn,\n\t\t                \"truncating vsnprintf buffer: [%.*s]\",\n\t\t                (int)((buflen > 200) ? 200 : (buflen - 1)),\n\t\t                buf);\n\t\tn = (int)buflen - 1;\n\t}\n\tbuf[n] = '\\0';\n}\n\n\nstatic void\nmg_snprintf(const struct mg_connection *conn,\n            int *truncated,\n            char *buf,\n            size_t buflen,\n            const char *fmt,\n            ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tmg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);\n\tva_end(ap);\n}\n\n\nstatic int\nget_option_index(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tif (strcmp(config_options[i].name, name) == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nconst char *\nmg_get_option(const struct mg_context *ctx, const char *name)\n{\n\tint i;\n\tif ((i = get_option_index(name)) == -1) {\n\t\treturn NULL;\n\t} else if (!ctx || ctx->dd.config[i] == NULL) {\n\t\treturn \"\";\n\t} else {\n\t\treturn ctx->dd.config[i];\n\t}\n}\n\n#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly\n\nstruct mg_context *\nmg_get_context(const struct mg_connection *conn)\n{\n\treturn (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);\n}\n\n\nvoid *\nmg_get_user_data(const struct mg_context *ctx)\n{\n\treturn (ctx == NULL) ? NULL : ctx->user_data;\n}\n\n\nvoid\nmg_set_user_connection_data(struct mg_connection *conn, void *data)\n{\n\tif (conn != NULL) {\n\t\tconn->request_info.conn_data = data;\n\t}\n}\n\n\nvoid *\nmg_get_user_connection_data(const struct mg_connection *conn)\n{\n\tif (conn != NULL) {\n\t\treturn conn->request_info.conn_data;\n\t}\n\treturn NULL;\n}\n\n\n#if defined(MG_LEGACY_INTERFACE)\n/* Deprecated: Use mg_get_server_ports instead. */\nsize_t\nmg_get_ports(const struct mg_context *ctx, size_t size, int *ports, int *ssl)\n{\n\tsize_t i;\n\tif (!ctx) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < size && i < ctx->num_listening_sockets; i++) {\n\t\tssl[i] = ctx->listening_sockets[i].is_ssl;\n\t\tports[i] =\n#if defined(USE_IPV6)\n\t\t    (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)\n\t\t        ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);\n\t}\n\treturn i;\n}\n#endif\n\n\nint\nmg_get_server_ports(const struct mg_context *ctx,\n                    int size,\n                    struct mg_server_ports *ports)\n{\n\tint i, cnt = 0;\n\n\tif (size <= 0) {\n\t\treturn -1;\n\t}\n\tmemset(ports, 0, sizeof(*ports) * (size_t)size);\n\tif (!ctx) {\n\t\treturn -1;\n\t}\n\tif (!ctx->listening_sockets) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {\n\n\t\tports[cnt].port =\n#if defined(USE_IPV6)\n\t\t    (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)\n\t\t        ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);\n\t\tports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;\n\t\tports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;\n\n\t\tif (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {\n\t\t\t/* IPv4 */\n\t\t\tports[cnt].protocol = 1;\n\t\t\tcnt++;\n\t\t} else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {\n\t\t\t/* IPv6 */\n\t\t\tports[cnt].protocol = 3;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\n\nstatic void\nsockaddr_to_string(char *buf, size_t len, const union usa *usa)\n{\n\tbuf[0] = '\\0';\n\n\tif (!usa) {\n\t\treturn;\n\t}\n\n\tif (usa->sa.sa_family == AF_INET) {\n\t\tgetnameinfo(&usa->sa,\n\t\t            sizeof(usa->sin),\n\t\t            buf,\n\t\t            (unsigned)len,\n\t\t            NULL,\n\t\t            0,\n\t\t            NI_NUMERICHOST);\n\t}\n#if defined(USE_IPV6)\n\telse if (usa->sa.sa_family == AF_INET6) {\n\t\tgetnameinfo(&usa->sa,\n\t\t            sizeof(usa->sin6),\n\t\t            buf,\n\t\t            (unsigned)len,\n\t\t            NULL,\n\t\t            0,\n\t\t            NI_NUMERICHOST);\n\t}\n#endif\n}\n\n\n/* Convert time_t to a string. According to RFC2616, Sec 14.18, this must be\n * included in all responses other than 100, 101, 5xx. */\nstatic void\ngmt_time_string(char *buf, size_t buf_len, time_t *t)\n{\n#if !defined(REENTRANT_TIME)\n\tstruct tm *tm;\n\n\ttm = ((t != NULL) ? gmtime(t) : NULL);\n\tif (tm != NULL) {\n#else\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n\n\tif (t != NULL) {\n\t\tgmtime_r(t, tm);\n#endif\n\t\tstrftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", tm);\n\t} else {\n\t\tmg_strlcpy(buf, \"Thu, 01 Jan 1970 00:00:00 GMT\", buf_len);\n\t\tbuf[buf_len - 1] = '\\0';\n\t}\n}\n\n\n/* difftime for struct timespec. Return value is in seconds. */\nstatic double\nmg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before)\n{\n\treturn (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9\n\t       + (double)(ts_now->tv_sec - ts_before->tv_sec);\n}\n\n\n#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl)\nstatic void mg_cry_internal_impl(const struct mg_connection *conn,\n                                 const char *func,\n                                 unsigned line,\n                                 const char *fmt,\n                                 va_list ap);\n#include \"external_mg_cry_internal_impl.inl\"\n#else\n\n/* Print error message to the opened error log stream. */\nstatic void\nmg_cry_internal_impl(const struct mg_connection *conn,\n                     const char *func,\n                     unsigned line,\n                     const char *fmt,\n                     va_list ap)\n{\n\tchar buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];\n\tstruct mg_file fi;\n\ttime_t timestamp;\n\n\t/* Unused, in the RELEASE build */\n\t(void)func;\n\t(void)line;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\tIGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif\n\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tDEBUG_TRACE(\"mg_cry called from %s:%u: %s\", func, line, buf);\n\n\tif (!conn) {\n\t\tputs(buf);\n\t\treturn;\n\t}\n\n\t/* Do not lock when getting the callback value, here and below.\n\t * I suppose this is fine, since function cannot disappear in the\n\t * same way string option can. */\n\tif ((conn->phys_ctx->callbacks.log_message == NULL)\n\t    || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {\n\n\t\tif (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {\n\t\t\tif (mg_fopen(conn,\n\t\t\t             conn->dom_ctx->config[ERROR_LOG_FILE],\n\t\t\t             MG_FOPEN_MODE_APPEND,\n\t\t\t             &fi) == 0) {\n\t\t\t\tfi.access.fp = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tfi.access.fp = NULL;\n\t\t}\n\n\t\tif (fi.access.fp != NULL) {\n\t\t\tflockfile(fi.access.fp);\n\t\t\ttimestamp = time(NULL);\n\n\t\t\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\t\t\tfprintf(fi.access.fp,\n\t\t\t        \"[%010lu] [error] [client %s] \",\n\t\t\t        (unsigned long)timestamp,\n\t\t\t        src_addr);\n\n\t\t\tif (conn->request_info.request_method != NULL) {\n\t\t\t\tfprintf(fi.access.fp,\n\t\t\t\t        \"%s %s: \",\n\t\t\t\t        conn->request_info.request_method,\n\t\t\t\t        conn->request_info.request_uri\n\t\t\t\t            ? conn->request_info.request_uri\n\t\t\t\t            : \"\");\n\t\t\t}\n\n\t\t\tfprintf(fi.access.fp, \"%s\", buf);\n\t\t\tfputc('\\n', fi.access.fp);\n\t\t\tfflush(fi.access.fp);\n\t\t\tfunlockfile(fi.access.fp);\n\t\t\t(void)mg_fclose(&fi.access); /* Ignore errors. We can't call\n\t\t\t                              * mg_cry here anyway ;-) */\n\t\t}\n\t}\n}\n\n#endif /* Externally provided function */\n\n\nstatic void\nmg_cry_internal_wrap(const struct mg_connection *conn,\n                     const char *func,\n                     unsigned line,\n                     const char *fmt,\n                     ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tmg_cry_internal_impl(conn, func, line, fmt, ap);\n\tva_end(ap);\n}\n\n\nvoid\nmg_cry(const struct mg_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tmg_cry_internal_impl(conn, \"user\", 0, fmt, ap);\n\tva_end(ap);\n}\n\n\n#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal\n\n\n/* Return fake connection structure. Used for logging, if connection\n * is not applicable at the moment of logging. */\nstatic struct mg_connection *\nfc(struct mg_context *ctx)\n{\n\tstatic struct mg_connection fake_connection;\n\tfake_connection.phys_ctx = ctx;\n\tfake_connection.dom_ctx = &(ctx->dd);\n\treturn &fake_connection;\n}\n\n\nconst char *\nmg_version(void)\n{\n\treturn CIVETWEB_VERSION;\n}\n\n\nconst struct mg_request_info *\nmg_get_request_info(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE)\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\tchar txt[16];\n\t\tstruct mg_workerTLS *tls =\n\t\t    (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\n\t\tsprintf(txt, \"%03i\", conn->response_info.status_code);\n\t\tif (strlen(txt) == 3) {\n\t\t\tmemcpy(tls->txtbuf, txt, 4);\n\t\t} else {\n\t\t\tstrcpy(tls->txtbuf, \"ERR\");\n\t\t}\n\n\t\t((struct mg_connection *)conn)->request_info.local_uri =\n\t\t    ((struct mg_connection *)conn)->request_info.request_uri =\n\t\t        tls->txtbuf; /* use thread safe buffer */\n\n\t\t((struct mg_connection *)conn)->request_info.num_headers =\n\t\t    conn->response_info.num_headers;\n\t\tmemcpy(((struct mg_connection *)conn)->request_info.http_headers,\n\t\t       conn->response_info.http_headers,\n\t\t       sizeof(conn->response_info.http_headers));\n\t} else\n#endif\n\t    if (conn->connection_type != CONNECTION_TYPE_REQUEST) {\n\t\treturn NULL;\n\t}\n\treturn &conn->request_info;\n}\n\n\nconst struct mg_response_info *\nmg_get_response_info(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\tif (conn->connection_type != CONNECTION_TYPE_RESPONSE) {\n\t\treturn NULL;\n\t}\n\treturn &conn->response_info;\n}\n\n\nstatic const char *\nget_proto_name(const struct mg_connection *conn)\n{\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n/* Depending on USE_WEBSOCKET and NO_SSL, some oft the protocols might be\n * not supported. Clang raises an \"unreachable code\" warning for parts of ?:\n * unreachable, but splitting into four different #ifdef clauses here is more\n * complicated.\n */\n#endif\n\n\tconst struct mg_request_info *ri = &conn->request_info;\n\n\tconst char *proto =\n\t    (is_websocket_protocol(conn) ? (ri->is_ssl ? \"wss\" : \"ws\")\n\t                                 : (ri->is_ssl ? \"https\" : \"http\"));\n\n\treturn proto;\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n}\n\n\nint\nmg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen)\n{\n\tif ((buflen < 1) || (buf == 0) || (conn == 0)) {\n\t\treturn -1;\n\t} else {\n\n\t\tint truncated = 0;\n\t\tconst struct mg_request_info *ri = &conn->request_info;\n\n\t\tconst char *proto = get_proto_name(conn);\n\n\t\tif (ri->local_uri == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((ri->request_uri != NULL)\n\t\t    && (0 != strcmp(ri->local_uri, ri->request_uri))) {\n\t\t\t/* The request uri is different from the local uri.\n\t\t\t * This is usually if an absolute URI, including server\n\t\t\t * name has been provided. */\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            buf,\n\t\t\t            buflen,\n\t\t\t            \"%s://%s\",\n\t\t\t            proto,\n\t\t\t            ri->request_uri);\n\t\t\tif (truncated) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\t} else {\n\n/* The common case is a relative URI, so we have to\n * construct an absolute URI from server name and port */\n\n#if defined(USE_IPV6)\n\t\t\tint is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);\n\t\t\tint port = is_ipv6 ? htons(conn->client.lsa.sin6.sin6_port)\n\t\t\t                   : htons(conn->client.lsa.sin.sin_port);\n#else\n\t\t\tint port = htons(conn->client.lsa.sin.sin_port);\n#endif\n\t\t\tint def_port = ri->is_ssl ? 443 : 80;\n\t\t\tint auth_domain_check_enabled =\n\t\t\t    conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]\n\t\t\t    && (!mg_strcasecmp(\n\t\t\t            conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK],\n\t\t\t            \"yes\"));\n\t\t\tconst char *server_domain =\n\t\t\t    conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\n\t\t\tchar portstr[16];\n\t\t\tchar server_ip[48];\n\n\t\t\tif (port != def_port) {\n\t\t\t\tsprintf(portstr, \":%u\", (unsigned)port);\n\t\t\t} else {\n\t\t\t\tportstr[0] = 0;\n\t\t\t}\n\n\t\t\tif (!auth_domain_check_enabled || !server_domain) {\n\n\t\t\t\tsockaddr_to_string(server_ip,\n\t\t\t\t                   sizeof(server_ip),\n\t\t\t\t                   &conn->client.lsa);\n\n\t\t\t\tserver_domain = server_ip;\n\t\t\t}\n\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            buf,\n\t\t\t            buflen,\n\t\t\t            \"%s://%s%s%s\",\n\t\t\t            proto,\n\t\t\t            server_domain,\n\t\t\t            portstr,\n\t\t\t            ri->local_uri);\n\t\t\tif (truncated) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n/* Skip the characters until one of the delimiters characters found.\n * 0-terminate resulting word. Skip the delimiter and following whitespaces.\n * Advance pointer to buffer to the next word. Return found 0-terminated\n * word.\n * Delimiters can be quoted with quotechar. */\nstatic char *\nskip_quoted(char **buf,\n            const char *delimiters,\n            const char *whitespace,\n            char quotechar)\n{\n\tchar *p, *begin_word, *end_word, *end_whitespace;\n\n\tbegin_word = *buf;\n\tend_word = begin_word + strcspn(begin_word, delimiters);\n\n\t/* Check for quotechar */\n\tif (end_word > begin_word) {\n\t\tp = end_word - 1;\n\t\twhile (*p == quotechar) {\n\t\t\t/* While the delimiter is quoted, look for the next delimiter.\n\t\t\t */\n\t\t\t/* This happens, e.g., in calls from parse_auth_header,\n\t\t\t * if the user name contains a \" character. */\n\n\t\t\t/* If there is anything beyond end_word, copy it. */\n\t\t\tif (*end_word != '\\0') {\n\t\t\t\tsize_t end_off = strcspn(end_word + 1, delimiters);\n\t\t\t\tmemmove(p, end_word, end_off + 1);\n\t\t\t\tp += end_off; /* p must correspond to end_word - 1 */\n\t\t\t\tend_word += end_off + 1;\n\t\t\t} else {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (p++; p < end_word; p++) {\n\t\t\t*p = '\\0';\n\t\t}\n\t}\n\n\tif (*end_word == '\\0') {\n\t\t*buf = end_word;\n\t} else {\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Disable spurious conversion warning for GCC */\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\t\tend_whitespace = end_word + strspn(&end_word[1], whitespace) + 1;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic pop\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\t\tfor (p = end_word; p < end_whitespace; p++) {\n\t\t\t*p = '\\0';\n\t\t}\n\n\t\t*buf = end_whitespace;\n\t}\n\n\treturn begin_word;\n}\n\n\n/* Return HTTP header value, or NULL if not found. */\nstatic const char *\nget_header(const struct mg_header *hdr, int num_hdr, const char *name)\n{\n\tint i;\n\tfor (i = 0; i < num_hdr; i++) {\n\t\tif (!mg_strcasecmp(name, hdr[i].name)) {\n\t\t\treturn hdr[i].value;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n#if defined(USE_WEBSOCKET)\n/* Retrieve requested HTTP header multiple values, and return the number of\n * found occurrences */\nstatic int\nget_req_headers(const struct mg_request_info *ri,\n                const char *name,\n                const char **output,\n                int output_max_size)\n{\n\tint i;\n\tint cnt = 0;\n\tif (ri) {\n\t\tfor (i = 0; i < ri->num_headers && cnt < output_max_size; i++) {\n\t\t\tif (!mg_strcasecmp(name, ri->http_headers[i].name)) {\n\t\t\t\toutput[cnt++] = ri->http_headers[i].value;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n#endif\n\n\nconst char *\nmg_get_header(const struct mg_connection *conn, const char *name)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\n\tif (conn->connection_type == CONNECTION_TYPE_REQUEST) {\n\t\treturn get_header(conn->request_info.http_headers,\n\t\t                  conn->request_info.num_headers,\n\t\t                  name);\n\t}\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\treturn get_header(conn->response_info.http_headers,\n\t\t                  conn->response_info.num_headers,\n\t\t                  name);\n\t}\n\treturn NULL;\n}\n\n\nstatic const char *\nget_http_version(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\n\tif (conn->connection_type == CONNECTION_TYPE_REQUEST) {\n\t\treturn conn->request_info.http_version;\n\t}\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\treturn conn->response_info.http_version;\n\t}\n\treturn NULL;\n}\n\n\n/* A helper function for traversing a comma separated list of values.\n * It returns a list pointer shifted to the next value, or NULL if the end\n * of the list found.\n * Value is stored in val vector. If value has form \"x=y\", then eq_val\n * vector is initialized to point to the \"y\" part, and val vector length\n * is adjusted to point only to \"x\". */\nstatic const char *\nnext_option(const char *list, struct vec *val, struct vec *eq_val)\n{\n\tint end;\n\nreparse:\n\tif (val == NULL || list == NULL || *list == '\\0') {\n\t\t/* End of the list */\n\t\treturn NULL;\n\t}\n\n\t/* Skip over leading LWS */\n\twhile (*list == ' ' || *list == '\\t')\n\t\tlist++;\n\n\tval->ptr = list;\n\tif ((list = strchr(val->ptr, ',')) != NULL) {\n\t\t/* Comma found. Store length and shift the list ptr */\n\t\tval->len = ((size_t)(list - val->ptr));\n\t\tlist++;\n\t} else {\n\t\t/* This value is the last one */\n\t\tlist = val->ptr + strlen(val->ptr);\n\t\tval->len = ((size_t)(list - val->ptr));\n\t}\n\n\t/* Adjust length for trailing LWS */\n\tend = (int)val->len - 1;\n\twhile (end >= 0 && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))\n\t\tend--;\n\tval->len = (size_t)(end + 1);\n\n\tif (val->len == 0) {\n\t\t/* Ignore any empty entries. */\n\t\tgoto reparse;\n\t}\n\n\tif (eq_val != NULL) {\n\t\t/* Value has form \"x=y\", adjust pointers and lengths\n\t\t * so that val points to \"x\", and eq_val points to \"y\". */\n\t\teq_val->len = 0;\n\t\teq_val->ptr = (const char *)memchr(val->ptr, '=', val->len);\n\t\tif (eq_val->ptr != NULL) {\n\t\t\teq_val->ptr++; /* Skip over '=' character */\n\t\t\teq_val->len = ((size_t)(val->ptr - eq_val->ptr)) + val->len;\n\t\t\tval->len = ((size_t)(eq_val->ptr - val->ptr)) - 1;\n\t\t}\n\t}\n\n\treturn list;\n}\n\n\n/* A helper function for checking if a comma separated list of values\n * contains\n * the given option (case insensitvely).\n * 'header' can be NULL, in which case false is returned. */\nstatic int\nheader_has_option(const char *header, const char *option)\n{\n\tstruct vec opt_vec;\n\tstruct vec eq_vec;\n\n\tDEBUG_ASSERT(option != NULL);\n\tDEBUG_ASSERT(option[0] != '\\0');\n\n\twhile ((header = next_option(header, &opt_vec, &eq_vec)) != NULL) {\n\t\tif (mg_strncasecmp(option, opt_vec.ptr, opt_vec.len) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n/* Perform case-insensitive match of string against pattern */\nstatic ptrdiff_t\nmatch_prefix(const char *pattern, size_t pattern_len, const char *str)\n{\n\tconst char *or_str;\n\tptrdiff_t i, j, len, res;\n\n\tif ((or_str = (const char *)memchr(pattern, '|', pattern_len)) != NULL) {\n\t\tres = match_prefix(pattern, (size_t)(or_str - pattern), str);\n\t\treturn (res > 0) ? res : match_prefix(or_str + 1,\n\t\t                                      (size_t)((pattern + pattern_len)\n\t\t                                               - (or_str + 1)),\n\t\t                                      str);\n\t}\n\n\tfor (i = 0, j = 0; (i < (ptrdiff_t)pattern_len); i++, j++) {\n\t\tif ((pattern[i] == '?') && (str[j] != '\\0')) {\n\t\t\tcontinue;\n\t\t} else if (pattern[i] == '$') {\n\t\t\treturn (str[j] == '\\0') ? j : -1;\n\t\t} else if (pattern[i] == '*') {\n\t\t\ti++;\n\t\t\tif (pattern[i] == '*') {\n\t\t\t\ti++;\n\t\t\t\tlen = strlen(str + j);\n\t\t\t} else {\n\t\t\t\tlen = strcspn(str + j, \"/\");\n\t\t\t}\n\t\t\tif (i == (ptrdiff_t)pattern_len) {\n\t\t\t\treturn j + len;\n\t\t\t}\n\t\t\tdo {\n\t\t\t\tres = match_prefix(pattern + i, pattern_len - i, str + j + len);\n\t\t\t} while (res == -1 && len-- > 0);\n\t\t\treturn (res == -1) ? -1 : j + res + len;\n\t\t} else if (lowercase(&pattern[i]) != lowercase(&str[j])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn (ptrdiff_t)j;\n}\n\n\n/* HTTP 1.1 assumes keep alive if \"Connection:\" header is not set\n * This function must tolerate situations when connection info is not\n * set up, for example if request parsing failed. */\nstatic int\nshould_keep_alive(const struct mg_connection *conn)\n{\n\tconst char *http_version;\n\tconst char *header;\n\n\t/* First satisfy needs of the server */\n\tif ((conn == NULL) || conn->must_close) {\n\t\t/* Close, if civetweb framework needs to close */\n\t\treturn 0;\n\t}\n\n\tif (mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0) {\n\t\t/* Close, if keep alive is not enabled */\n\t\treturn 0;\n\t}\n\n\t/* Check explicit wish of the client */\n\theader = mg_get_header(conn, \"Connection\");\n\tif (header) {\n\t\t/* If there is a connection header from the client, obey */\n\t\tif (header_has_option(header, \"keep-alive\")) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Use default of the standard */\n\thttp_version = get_http_version(conn);\n\tif (http_version && (0 == strcmp(http_version, \"1.1\"))) {\n\t\t/* HTTP 1.1 default is keep alive */\n\t\treturn 1;\n\t}\n\n\t/* HTTP 1.0 (and earlier) default is to close the connection */\n\treturn 0;\n}\n\n\nstatic int\nshould_decode_url(const struct mg_connection *conn)\n{\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\treturn (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], \"yes\") == 0);\n}\n\n\nstatic const char *\nsuggest_connection_header(const struct mg_connection *conn)\n{\n\treturn should_keep_alive(conn) ? \"keep-alive\" : \"close\";\n}\n\n\nstatic int\nsend_no_cache_header(struct mg_connection *conn)\n{\n\t/* Send all current and obsolete cache opt-out directives. */\n\treturn mg_printf(conn,\n\t                 \"Cache-Control: no-cache, no-store, \"\n\t                 \"must-revalidate, private, max-age=0\\r\\n\"\n\t                 \"Pragma: no-cache\\r\\n\"\n\t                 \"Expires: 0\\r\\n\");\n}\n\n\nstatic int\nsend_static_cache_header(struct mg_connection *conn)\n{\n#if !defined(NO_CACHING)\n\t/* Read the server config to check how long a file may be cached.\n\t * The configuration is in seconds. */\n\tint max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);\n\tif (max_age <= 0) {\n\t\t/* 0 means \"do not cache\". All values <0 are reserved\n\t\t * and may be used differently in the future. */\n\t\t/* If a file should not be cached, do not only send\n\t\t * max-age=0, but also pragmas and Expires headers. */\n\t\treturn send_no_cache_header(conn);\n\t}\n\n\t/* Use \"Cache-Control: max-age\" instead of \"Expires\" header.\n\t * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */\n\t/* See also https://www.mnot.net/cache_docs/ */\n\t/* According to RFC 2616, Section 14.21, caching times should not exceed\n\t * one year. A year with 365 days corresponds to 31536000 seconds, a\n\t * leap\n\t * year to 31622400 seconds. For the moment, we just send whatever has\n\t * been configured, still the behavior for >1 year should be considered\n\t * as undefined. */\n\treturn mg_printf(conn, \"Cache-Control: max-age=%u\\r\\n\", (unsigned)max_age);\n#else  /* NO_CACHING */\n\treturn send_no_cache_header(conn);\n#endif /* !NO_CACHING */\n}\n\n\nstatic int\nsend_additional_header(struct mg_connection *conn)\n{\n\tint i = 0;\n\tconst char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];\n\n#if !defined(NO_SSL)\n\tif (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {\n\t\tint max_age = atoi(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);\n\t\tif (max_age >= 0) {\n\t\t\ti += mg_printf(conn,\n\t\t\t               \"Strict-Transport-Security: max-age=%u\\r\\n\",\n\t\t\t               (unsigned)max_age);\n\t\t}\n\t}\n#endif\n\n\tif (header && header[0]) {\n\t\ti += mg_printf(conn, \"%s\\r\\n\", header);\n\t}\n\n\treturn i;\n}\n\n\nstatic void handle_file_based_request(struct mg_connection *conn,\n                                      const char *path,\n                                      struct mg_file *filep);\n\n\nconst char *\nmg_get_response_code_text(const struct mg_connection *conn, int response_code)\n{\n\t/* See IANA HTTP status code assignment:\n\t * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n\t */\n\n\tswitch (response_code) {\n\t/* RFC2616 Section 10.1 - Informational 1xx */\n\tcase 100:\n\t\treturn \"Continue\"; /* RFC2616 Section 10.1.1 */\n\tcase 101:\n\t\treturn \"Switching Protocols\"; /* RFC2616 Section 10.1.2 */\n\tcase 102:\n\t\treturn \"Processing\"; /* RFC2518 Section 10.1 */\n\n\t/* RFC2616 Section 10.2 - Successful 2xx */\n\tcase 200:\n\t\treturn \"OK\"; /* RFC2616 Section 10.2.1 */\n\tcase 201:\n\t\treturn \"Created\"; /* RFC2616 Section 10.2.2 */\n\tcase 202:\n\t\treturn \"Accepted\"; /* RFC2616 Section 10.2.3 */\n\tcase 203:\n\t\treturn \"Non-Authoritative Information\"; /* RFC2616 Section 10.2.4 */\n\tcase 204:\n\t\treturn \"No Content\"; /* RFC2616 Section 10.2.5 */\n\tcase 205:\n\t\treturn \"Reset Content\"; /* RFC2616 Section 10.2.6 */\n\tcase 206:\n\t\treturn \"Partial Content\"; /* RFC2616 Section 10.2.7 */\n\tcase 207:\n\t\treturn \"Multi-Status\"; /* RFC2518 Section 10.2, RFC4918 Section 11.1\n\t\t                          */\n\tcase 208:\n\t\treturn \"Already Reported\"; /* RFC5842 Section 7.1 */\n\n\tcase 226:\n\t\treturn \"IM used\"; /* RFC3229 Section 10.4.1 */\n\n\t/* RFC2616 Section 10.3 - Redirection 3xx */\n\tcase 300:\n\t\treturn \"Multiple Choices\"; /* RFC2616 Section 10.3.1 */\n\tcase 301:\n\t\treturn \"Moved Permanently\"; /* RFC2616 Section 10.3.2 */\n\tcase 302:\n\t\treturn \"Found\"; /* RFC2616 Section 10.3.3 */\n\tcase 303:\n\t\treturn \"See Other\"; /* RFC2616 Section 10.3.4 */\n\tcase 304:\n\t\treturn \"Not Modified\"; /* RFC2616 Section 10.3.5 */\n\tcase 305:\n\t\treturn \"Use Proxy\"; /* RFC2616 Section 10.3.6 */\n\tcase 307:\n\t\treturn \"Temporary Redirect\"; /* RFC2616 Section 10.3.8 */\n\tcase 308:\n\t\treturn \"Permanent Redirect\"; /* RFC7238 Section 3 */\n\n\t/* RFC2616 Section 10.4 - Client Error 4xx */\n\tcase 400:\n\t\treturn \"Bad Request\"; /* RFC2616 Section 10.4.1 */\n\tcase 401:\n\t\treturn \"Unauthorized\"; /* RFC2616 Section 10.4.2 */\n\tcase 402:\n\t\treturn \"Payment Required\"; /* RFC2616 Section 10.4.3 */\n\tcase 403:\n\t\treturn \"Forbidden\"; /* RFC2616 Section 10.4.4 */\n\tcase 404:\n\t\treturn \"Not Found\"; /* RFC2616 Section 10.4.5 */\n\tcase 405:\n\t\treturn \"Method Not Allowed\"; /* RFC2616 Section 10.4.6 */\n\tcase 406:\n\t\treturn \"Not Acceptable\"; /* RFC2616 Section 10.4.7 */\n\tcase 407:\n\t\treturn \"Proxy Authentication Required\"; /* RFC2616 Section 10.4.8 */\n\tcase 408:\n\t\treturn \"Request Time-out\"; /* RFC2616 Section 10.4.9 */\n\tcase 409:\n\t\treturn \"Conflict\"; /* RFC2616 Section 10.4.10 */\n\tcase 410:\n\t\treturn \"Gone\"; /* RFC2616 Section 10.4.11 */\n\tcase 411:\n\t\treturn \"Length Required\"; /* RFC2616 Section 10.4.12 */\n\tcase 412:\n\t\treturn \"Precondition Failed\"; /* RFC2616 Section 10.4.13 */\n\tcase 413:\n\t\treturn \"Request Entity Too Large\"; /* RFC2616 Section 10.4.14 */\n\tcase 414:\n\t\treturn \"Request-URI Too Large\"; /* RFC2616 Section 10.4.15 */\n\tcase 415:\n\t\treturn \"Unsupported Media Type\"; /* RFC2616 Section 10.4.16 */\n\tcase 416:\n\t\treturn \"Requested range not satisfiable\"; /* RFC2616 Section 10.4.17\n\t\t                                             */\n\tcase 417:\n\t\treturn \"Expectation Failed\"; /* RFC2616 Section 10.4.18 */\n\n\tcase 421:\n\t\treturn \"Misdirected Request\"; /* RFC7540 Section 9.1.2 */\n\tcase 422:\n\t\treturn \"Unproccessable entity\"; /* RFC2518 Section 10.3, RFC4918\n\t\t                                 * Section 11.2 */\n\tcase 423:\n\t\treturn \"Locked\"; /* RFC2518 Section 10.4, RFC4918 Section 11.3 */\n\tcase 424:\n\t\treturn \"Failed Dependency\"; /* RFC2518 Section 10.5, RFC4918\n\t\t                             * Section 11.4 */\n\n\tcase 426:\n\t\treturn \"Upgrade Required\"; /* RFC 2817 Section 4 */\n\n\tcase 428:\n\t\treturn \"Precondition Required\"; /* RFC 6585, Section 3 */\n\tcase 429:\n\t\treturn \"Too Many Requests\"; /* RFC 6585, Section 4 */\n\n\tcase 431:\n\t\treturn \"Request Header Fields Too Large\"; /* RFC 6585, Section 5 */\n\n\tcase 451:\n\t\treturn \"Unavailable For Legal Reasons\"; /* draft-tbray-http-legally-restricted-status-05,\n\t\t                                         * Section 3 */\n\n\t/* RFC2616 Section 10.5 - Server Error 5xx */\n\tcase 500:\n\t\treturn \"Internal Server Error\"; /* RFC2616 Section 10.5.1 */\n\tcase 501:\n\t\treturn \"Not Implemented\"; /* RFC2616 Section 10.5.2 */\n\tcase 502:\n\t\treturn \"Bad Gateway\"; /* RFC2616 Section 10.5.3 */\n\tcase 503:\n\t\treturn \"Service Unavailable\"; /* RFC2616 Section 10.5.4 */\n\tcase 504:\n\t\treturn \"Gateway Time-out\"; /* RFC2616 Section 10.5.5 */\n\tcase 505:\n\t\treturn \"HTTP Version not supported\"; /* RFC2616 Section 10.5.6 */\n\tcase 506:\n\t\treturn \"Variant Also Negotiates\"; /* RFC 2295, Section 8.1 */\n\tcase 507:\n\t\treturn \"Insufficient Storage\"; /* RFC2518 Section 10.6, RFC4918\n\t\t                                * Section 11.5 */\n\tcase 508:\n\t\treturn \"Loop Detected\"; /* RFC5842 Section 7.1 */\n\n\tcase 510:\n\t\treturn \"Not Extended\"; /* RFC 2774, Section 7 */\n\tcase 511:\n\t\treturn \"Network Authentication Required\"; /* RFC 6585, Section 6 */\n\n\t/* Other status codes, not shown in the IANA HTTP status code\n\t * assignment.\n\t * E.g., \"de facto\" standards due to common use, ... */\n\tcase 418:\n\t\treturn \"I am a teapot\"; /* RFC2324 Section 2.3.2 */\n\tcase 419:\n\t\treturn \"Authentication Timeout\"; /* common use */\n\tcase 420:\n\t\treturn \"Enhance Your Calm\"; /* common use */\n\tcase 440:\n\t\treturn \"Login Timeout\"; /* common use */\n\tcase 509:\n\t\treturn \"Bandwidth Limit Exceeded\"; /* common use */\n\n\tdefault:\n\t\t/* This error code is unknown. This should not happen. */\n\t\tif (conn) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Unknown HTTP response code: %u\",\n\t\t\t                response_code);\n\t\t}\n\n\t\t/* Return at least a category according to RFC 2616 Section 10. */\n\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t/* Unknown informational status code */\n\t\t\treturn \"Information\";\n\t\t}\n\t\tif (response_code >= 200 && response_code < 300) {\n\t\t\t/* Unknown success code */\n\t\t\treturn \"Success\";\n\t\t}\n\t\tif (response_code >= 300 && response_code < 400) {\n\t\t\t/* Unknown redirection code */\n\t\t\treturn \"Redirection\";\n\t\t}\n\t\tif (response_code >= 400 && response_code < 500) {\n\t\t\t/* Unknown request error code */\n\t\t\treturn \"Client Error\";\n\t\t}\n\t\tif (response_code >= 500 && response_code < 600) {\n\t\t\t/* Unknown server error code */\n\t\t\treturn \"Server Error\";\n\t\t}\n\n\t\t/* Response code not even within reasonable range */\n\t\treturn \"\";\n\t}\n}\n\n\nstatic int\nmg_send_http_error_impl(struct mg_connection *conn,\n                        int status,\n                        const char *fmt,\n                        va_list args)\n{\n\tchar errmsg_buf[MG_BUF_LEN];\n\tchar path_buf[PATH_MAX];\n\tva_list ap;\n\tint len, i, page_handler_found, scope, truncated, has_body;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tconst char *error_handler = NULL;\n\tstruct mg_file error_page_file = STRUCT_FILE_INITIALIZER;\n\tconst char *error_page_file_ext, *tstr;\n\tint handled_by_callback = 0;\n\n\tconst char *status_text = mg_get_response_code_text(conn, status);\n\n\tif ((conn == NULL) || (fmt == NULL)) {\n\t\treturn -2;\n\t}\n\n\t/* Set status (for log) */\n\tconn->status_code = status;\n\n\t/* Errors 1xx, 204 and 304 MUST NOT send a body */\n\thas_body = ((status > 199) && (status != 204) && (status != 304));\n\n\t/* Prepare message in buf, if required */\n\tif (has_body || (!conn->in_error_handler\n\t                 && (conn->phys_ctx->callbacks.http_error != NULL))) {\n\t\t/* Store error message in errmsg_buf */\n\t\tva_copy(ap, args);\n\t\tmg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);\n\t\tva_end(ap);\n\t\t/* In a debug build, print all html errors */\n\t\tDEBUG_TRACE(\"Error %i - [%s]\", status, errmsg_buf);\n\t}\n\n\t/* If there is a http_error callback, call it.\n\t * But don't do it recursively, if callback calls mg_send_http_error again.\n\t */\n\tif (!conn->in_error_handler\n\t    && (conn->phys_ctx->callbacks.http_error != NULL)) {\n\t\t/* Mark in_error_handler to avoid recursion and call user callback. */\n\t\tconn->in_error_handler = 1;\n\t\thandled_by_callback =\n\t\t    (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf)\n\t\t     == 0);\n\t\tconn->in_error_handler = 0;\n\t}\n\n\tif (!handled_by_callback) {\n\t\t/* Check for recursion */\n\t\tif (conn->in_error_handler) {\n\t\t\tDEBUG_TRACE(\n\t\t\t    \"Recursion when handling error %u - fall back to default\",\n\t\t\t    status);\n\t\t} else {\n\t\t\t/* Send user defined error pages, if defined */\n\t\t\terror_handler = conn->dom_ctx->config[ERROR_PAGES];\n\t\t\terror_page_file_ext = conn->dom_ctx->config[INDEX_FILES];\n\t\t\tpage_handler_found = 0;\n\n\t\t\tif (error_handler != NULL) {\n\t\t\t\tfor (scope = 1; (scope <= 3) && !page_handler_found; scope++) {\n\t\t\t\t\tswitch (scope) {\n\t\t\t\t\tcase 1: /* Handler for specific error, e.g. 404 error */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror%03u.\",\n\t\t\t\t\t\t            error_handler,\n\t\t\t\t\t\t            status);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: /* Handler for error group, e.g., 5xx error\n\t\t\t\t\t         * handler\n\t\t\t\t\t         * for all server errors (500-599) */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror%01uxx.\",\n\t\t\t\t\t\t            error_handler,\n\t\t\t\t\t\t            status / 100);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: /* Handler for all errors */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror.\",\n\t\t\t\t\t\t            error_handler);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* String truncation in buf may only occur if\n\t\t\t\t\t * error_handler is too long. This string is\n\t\t\t\t\t * from the config, not from a client. */\n\t\t\t\t\t(void)truncated;\n\n\t\t\t\t\tlen = (int)strlen(path_buf);\n\n\t\t\t\t\ttstr = strchr(error_page_file_ext, '.');\n\n\t\t\t\t\twhile (tstr) {\n\t\t\t\t\t\tfor (i = 1;\n\t\t\t\t\t\t     (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');\n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\t/* buffer overrun is not possible here, since\n\t\t\t\t\t\t\t * (i < 32) && (len < sizeof(path_buf) - 32)\n\t\t\t\t\t\t\t * ==> (i + len) < sizeof(path_buf) */\n\t\t\t\t\t\t\tpath_buf[len + i - 1] = tstr[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* buffer overrun is not possible here, since\n\t\t\t\t\t\t * (i <= 32) && (len < sizeof(path_buf) - 32)\n\t\t\t\t\t\t * ==> (i + len) <= sizeof(path_buf) */\n\t\t\t\t\t\tpath_buf[len + i - 1] = 0;\n\n\t\t\t\t\t\tif (mg_stat(conn, path_buf, &error_page_file.stat)) {\n\t\t\t\t\t\t\tDEBUG_TRACE(\"Check error page %s - found\",\n\t\t\t\t\t\t\t            path_buf);\n\t\t\t\t\t\t\tpage_handler_found = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDEBUG_TRACE(\"Check error page %s - not found\",\n\t\t\t\t\t\t            path_buf);\n\n\t\t\t\t\t\ttstr = strchr(tstr + i, '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (page_handler_found) {\n\t\t\t\tconn->in_error_handler = 1;\n\t\t\t\thandle_file_based_request(conn, path_buf, &error_page_file);\n\t\t\t\tconn->in_error_handler = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/* No custom error page. Send default error page. */\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\n\t\tconn->must_close = 1;\n\t\tmg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tif (has_body) {\n\t\t\tmg_printf(conn,\n\t\t\t          \"%s\",\n\t\t\t          \"Content-Type: text/plain; charset=utf-8\\r\\n\");\n\t\t}\n\t\tmg_printf(conn,\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Connection: close\\r\\n\\r\\n\",\n\t\t          date);\n\n\t\t/* HTTP responses 1xx, 204 and 304 MUST NOT send a body */\n\t\tif (has_body) {\n\t\t\t/* For other errors, send a generic error message. */\n\t\t\tmg_printf(conn, \"Error %d: %s\\n\", status, status_text);\n\t\t\tmg_write(conn, errmsg_buf, strlen(errmsg_buf));\n\n\t\t} else {\n\t\t\t/* No body allowed. Close the connection. */\n\t\t\tDEBUG_TRACE(\"Error %i\", status);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint\nmg_send_http_error(struct mg_connection *conn, int status, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = mg_send_http_error_impl(conn, status, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\n\nint\nmg_send_http_ok(struct mg_connection *conn,\n                const char *mime_type,\n                long long content_length)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif ((mime_type == NULL) || (*mime_type == 0)) {\n\t\t/* Parameter error */\n\t\treturn -2;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tmg_printf(conn,\n\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t          \"Content-Type: %s\\r\\n\"\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\",\n\t          mime_type,\n\t          date,\n\t          suggest_connection_header(conn));\n\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tif (content_length < 0) {\n\t\tmg_printf(conn, \"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n\t} else {\n\t\tmg_printf(conn,\n\t\t          \"Content-Length: %\" UINT64_FMT \"\\r\\n\\r\\n\",\n\t\t          (uint64_t)content_length);\n\t}\n\n\treturn 0;\n}\n\n\nint\nmg_send_http_redirect(struct mg_connection *conn,\n                      const char *target_url,\n                      int redirect_code)\n{\n\t/* Send a 30x redirect response.\n\t *\n\t * Redirect types (status codes):\n\t *\n\t * Status | Perm/Temp | Method              | Version\n\t *   301  | permanent | POST->GET undefined | HTTP/1.0\n\t *   302  | temporary | POST->GET undefined | HTTP/1.0\n\t *   303  | temporary | always use GET      | HTTP/1.1\n\t *   307  | temporary | always keep method  | HTTP/1.1\n\t *   308  | permanent | always keep method  | HTTP/1.1\n\t */\n\tconst char *redirect_text;\n\tint ret;\n\tsize_t content_len = 0;\n\tchar reply[MG_BUF_LEN];\n\n\t/* In case redirect_code=0, use 307. */\n\tif (redirect_code == 0) {\n\t\tredirect_code = 307;\n\t}\n\n\t/* In case redirect_code is none of the above, return error. */\n\tif ((redirect_code != 301) && (redirect_code != 302)\n\t    && (redirect_code != 303) && (redirect_code != 307)\n\t    && (redirect_code != 308)) {\n\t\t/* Parameter error */\n\t\treturn -2;\n\t}\n\n\t/* Get proper text for response code */\n\tredirect_text = mg_get_response_code_text(conn, redirect_code);\n\n\t/* If target_url is not defined, redirect to \"/\". */\n\tif ((target_url == NULL) || (*target_url == 0)) {\n\t\ttarget_url = \"/\";\n\t}\n\n#if defined(MG_SEND_REDIRECT_BODY)\n\t/* TODO: condition name? */\n\n\t/* Prepare a response body with a hyperlink.\n\t *\n\t * According to RFC2616 (and RFC1945 before):\n\t * Unless the request method was HEAD, the entity of the\n\t * response SHOULD contain a short hypertext note with a hyperlink to\n\t * the new URI(s).\n\t *\n\t * However, this response body is not useful in M2M communication.\n\t * Probably the original reason in the RFC was, clients not supporting\n\t * a 30x HTTP redirect could still show the HTML page and let the user\n\t * press the link. Since current browsers support 30x HTTP, the additional\n\t * HTML body does not seem to make sense anymore.\n\t *\n\t * The new RFC7231 (Section 6.4) does no longer recommend it (\"SHOULD\"),\n\t * but it only notes:\n\t * The server's response payload usually contains a short\n\t * hypertext note with a hyperlink to the new URI(s).\n\t *\n\t * Deactivated by default. If you need the 30x body, set the define.\n\t */\n\tmg_snprintf(\n\t    conn,\n\t    NULL /* ignore truncation */,\n\t    reply,\n\t    sizeof(reply),\n\t    \"<html><head>%s</head><body><a href=\\\"%s\\\">%s</a></body></html>\",\n\t    redirect_text,\n\t    target_url,\n\t    target_url);\n\tcontent_len = strlen(reply);\n#else\n\treply[0] = 0;\n#endif\n\n\t/* Do not send any additional header. For all other options,\n\t * including caching, there are suitable defaults. */\n\tret = mg_printf(conn,\n\t                \"HTTP/1.1 %i %s\\r\\n\"\n\t                \"Location: %s\\r\\n\"\n\t                \"Content-Length: %u\\r\\n\"\n\t                \"Connection: %s\\r\\n\\r\\n\",\n\t                redirect_code,\n\t                redirect_text,\n\t                target_url,\n\t                (unsigned int)content_len,\n\t                suggest_connection_header(conn));\n\n\t/* Send response body */\n\tif (ret > 0) {\n\t\t/* ... unless it is a HEAD request */\n\t\tif (0 != strcmp(conn->request_info.request_method, \"HEAD\")) {\n\t\t\tret = mg_write(conn, reply, content_len);\n\t\t}\n\t}\n\n\treturn (ret > 0) ? ret : -1;\n}\n\n\n#if defined(_WIN32)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_init(pthread_mutex_t *mutex, void *unused)\n{\n\t(void)unused;\n\t*mutex = CreateMutex(NULL, FALSE, NULL);\n\treturn (*mutex == NULL) ? -1 : 0;\n}\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_destroy(pthread_mutex_t *mutex)\n{\n\treturn (CloseHandle(*mutex) == 0) ? -1 : 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\treturn (WaitForSingleObject(*mutex, (DWORD)INFINITE) == WAIT_OBJECT_0) ? 0\n\t                                                                       : -1;\n}\n\n\n#if defined(ENABLE_UNUSED_PTHREAD_FUNCTIONS)\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_trylock(pthread_mutex_t *mutex)\n{\n\tswitch (WaitForSingleObject(*mutex, 0)) {\n\tcase WAIT_OBJECT_0:\n\t\treturn 0;\n\tcase WAIT_TIMEOUT:\n\t\treturn -2; /* EBUSY */\n\t}\n\treturn -1;\n}\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\treturn (ReleaseMutex(*mutex) == 0) ? -1 : 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_init(pthread_cond_t *cv, const void *unused)\n{\n\t(void)unused;\n\tInitializeCriticalSection(&cv->threadIdSec);\n\tcv->waiting_thread = NULL;\n\treturn 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_timedwait(pthread_cond_t *cv,\n                       pthread_mutex_t *mutex,\n                       FUNCTION_MAY_BE_UNUSED const struct timespec *abstime)\n{\n\tstruct mg_workerTLS **ptls,\n\t    *tls = (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\tint ok;\n\tint64_t nsnow, nswaitabs, nswaitrel;\n\tDWORD mswaitrel;\n\n\tEnterCriticalSection(&cv->threadIdSec);\n\t/* Add this thread to cv's waiting list */\n\tptls = &cv->waiting_thread;\n\tfor (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread)\n\t\t;\n\ttls->next_waiting_thread = NULL;\n\t*ptls = tls;\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\tif (abstime) {\n\t\tnsnow = mg_get_current_time_ns();\n\t\tnswaitabs =\n\t\t    (((int64_t)abstime->tv_sec) * 1000000000) + abstime->tv_nsec;\n\t\tnswaitrel = nswaitabs - nsnow;\n\t\tif (nswaitrel < 0) {\n\t\t\tnswaitrel = 0;\n\t\t}\n\t\tmswaitrel = (DWORD)(nswaitrel / 1000000);\n\t} else {\n\t\tmswaitrel = (DWORD)INFINITE;\n\t}\n\n\tpthread_mutex_unlock(mutex);\n\tok = (WAIT_OBJECT_0\n\t      == WaitForSingleObject(tls->pthread_cond_helper_mutex, mswaitrel));\n\tif (!ok) {\n\t\tok = 1;\n\t\tEnterCriticalSection(&cv->threadIdSec);\n\t\tptls = &cv->waiting_thread;\n\t\tfor (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread) {\n\t\t\tif (*ptls == tls) {\n\t\t\t\t*ptls = tls->next_waiting_thread;\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tLeaveCriticalSection(&cv->threadIdSec);\n\t\tif (ok) {\n\t\t\tWaitForSingleObject(tls->pthread_cond_helper_mutex,\n\t\t\t                    (DWORD)INFINITE);\n\t\t}\n\t}\n\t/* This thread has been removed from cv's waiting list */\n\tpthread_mutex_lock(mutex);\n\n\treturn ok ? 0 : -1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex)\n{\n\treturn pthread_cond_timedwait(cv, mutex, NULL);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_signal(pthread_cond_t *cv)\n{\n\tHANDLE wkup = NULL;\n\tBOOL ok = FALSE;\n\n\tEnterCriticalSection(&cv->threadIdSec);\n\tif (cv->waiting_thread) {\n\t\twkup = cv->waiting_thread->pthread_cond_helper_mutex;\n\t\tcv->waiting_thread = cv->waiting_thread->next_waiting_thread;\n\n\t\tok = SetEvent(wkup);\n\t\tDEBUG_ASSERT(ok);\n\t}\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\treturn ok ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_broadcast(pthread_cond_t *cv)\n{\n\tEnterCriticalSection(&cv->threadIdSec);\n\twhile (cv->waiting_thread) {\n\t\tpthread_cond_signal(cv);\n\t}\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\treturn 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_destroy(pthread_cond_t *cv)\n{\n\tEnterCriticalSection(&cv->threadIdSec);\n\tDEBUG_ASSERT(cv->waiting_thread == NULL);\n\tLeaveCriticalSection(&cv->threadIdSec);\n\tDeleteCriticalSection(&cv->threadIdSec);\n\n\treturn 0;\n}\n\n\n#if defined(ALTERNATIVE_QUEUE)\nFUNCTION_MAY_BE_UNUSED\nstatic void *\nevent_create(void)\n{\n\treturn (void *)CreateEvent(NULL, FALSE, FALSE, NULL);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nevent_wait(void *eventhdl)\n{\n\tint res = WaitForSingleObject((HANDLE)eventhdl, (DWORD)INFINITE);\n\treturn (res == WAIT_OBJECT_0);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nevent_signal(void *eventhdl)\n{\n\treturn (int)SetEvent((HANDLE)eventhdl);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tCloseHandle((HANDLE)eventhdl);\n}\n#endif\n\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n\n/* For Windows, change all slashes to backslashes in path names. */\nstatic void\nchange_slashes_to_backslashes(char *path)\n{\n\tint i;\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == '/') {\n\t\t\tpath[i] = '\\\\';\n\t\t}\n\n\t\t/* remove double backslash (check i > 0 to preserve UNC paths,\n\t\t * like \\\\server\\file.txt) */\n\t\tif ((path[i] == '\\\\') && (i > 0)) {\n\t\t\twhile ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {\n\t\t\t\t(void)memmove(path + i + 1, path + i + 2, strlen(path + i + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nmg_wcscasecmp(const wchar_t *s1, const wchar_t *s2)\n{\n\tint diff;\n\n\tdo {\n\t\tdiff = tolower(*s1) - tolower(*s2);\n\t\ts1++;\n\t\ts2++;\n\t} while ((diff == 0) && (s1[-1] != '\\0'));\n\n\treturn diff;\n}\n\n\n/* Encode 'path' which is assumed UTF-8 string, into UNICODE string.\n * wbuf and wbuf_len is a target buffer and its length. */\nstatic void\npath_to_unicode(const struct mg_connection *conn,\n                const char *path,\n                wchar_t *wbuf,\n                size_t wbuf_len)\n{\n\tchar buf[PATH_MAX], buf2[PATH_MAX];\n\twchar_t wbuf2[W_PATH_MAX + 1];\n\tDWORD long_len, err;\n\tint (*fcompare)(const wchar_t *, const wchar_t *) = mg_wcscasecmp;\n\n\tmg_strlcpy(buf, path, sizeof(buf));\n\tchange_slashes_to_backslashes(buf);\n\n\t/* Convert to Unicode and back. If doubly-converted string does not\n\t * match the original, something is fishy, reject. */\n\tmemset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n\tMultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);\n\tWideCharToMultiByte(\n\t    CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);\n\tif (strcmp(buf, buf2) != 0) {\n\t\twbuf[0] = L'\\0';\n\t}\n\n\t/* Windows file systems are not case sensitive, but you can still use\n\t * uppercase and lowercase letters (on all modern file systems).\n\t * The server can check if the URI uses the same upper/lowercase\n\t * letters an the file system, effectively making Windows servers\n\t * case sensitive (like Linux servers are). It is still not possible\n\t * to use two files with the same name in different cases on Windows\n\t * (like /a and /A) - this would be possible in Linux.\n\t * As a default, Windows is not case sensitive, but the case sensitive\n\t * file name check can be activated by an additional configuration. */\n\tif (conn) {\n\t\tif (conn->dom_ctx->config[CASE_SENSITIVE_FILES]\n\t\t    && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],\n\t\t                      \"yes\")) {\n\t\t\t/* Use case sensitive compare function */\n\t\t\tfcompare = wcscmp;\n\t\t}\n\t}\n\t(void)conn; /* conn is currently unused */\n\n#if !defined(_WIN32_WCE)\n\t/* Only accept a full file path, not a Windows short (8.3) path. */\n\tmemset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));\n\tlong_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);\n\tif (long_len == 0) {\n\t\terr = GetLastError();\n\t\tif (err == ERROR_FILE_NOT_FOUND) {\n\t\t\t/* File does not exist. This is not always a problem here. */\n\t\t\treturn;\n\t\t}\n\t}\n\tif ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {\n\t\t/* Short name is used. */\n\t\twbuf[0] = L'\\0';\n\t}\n#else\n\t(void)long_len;\n\t(void)wbuf2;\n\t(void)err;\n\n\tif (strchr(path, '~')) {\n\t\twbuf[0] = L'\\0';\n\t}\n#endif\n}\n\n\n/* Windows happily opens files with some garbage at the end of file name.\n * For example, fopen(\"a.cgi    \", \"r\") on Windows successfully opens\n * \"a.cgi\", despite one would expect an error back.\n * This function returns non-0 if path ends with some garbage. */\nstatic int\npath_cannot_disclose_cgi(const char *path)\n{\n\tstatic const char *allowed_last_characters = \"_-\";\n\tint last = path[strlen(path) - 1];\n\treturn isalnum(last) || strchr(allowed_last_characters, last) != NULL;\n}\n\n\nstatic int\nmg_stat(const struct mg_connection *conn,\n        const char *path,\n        struct mg_file_stat *filep)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tWIN32_FILE_ATTRIBUTE_DATA info;\n\ttime_t creation_time;\n\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tmemset(filep, 0, sizeof(*filep));\n\n\tif (conn && is_file_in_memory(conn, path)) {\n\t\t/* filep->is_directory = 0; filep->gzipped = 0; .. already done by\n\t\t * memset */\n\n\t\t/* Quick fix (for 1.9.x): */\n\t\t/* mg_stat must fill all fields, also for files in memory */\n\t\tstruct mg_file tmp_file = STRUCT_FILE_INITIALIZER;\n\t\topen_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);\n\t\tfilep->size = tmp_file.stat.size;\n\t\tfilep->location = 2;\n\t\t/* TODO: for 1.10: restructure how files in memory are handled */\n\n\t\t/* The \"file in memory\" feature is a candidate for deletion.\n\t\t * Please join the discussion at\n\t\t * https://groups.google.com/forum/#!topic/civetweb/h9HT4CmeYqI\n\t\t */\n\n\t\tfilep->last_modified = time(NULL); /* TODO */\n\t\t/* last_modified = now ... assumes the file may change during\n\t\t * runtime,\n\t\t * so every mg_fopen call may return different data */\n\t\t/* last_modified = conn->phys_ctx.start_time;\n\t\t * May be used it the data does not change during runtime. This\n\t\t * allows\n\t\t * browser caching. Since we do not know, we have to assume the file\n\t\t * in memory may change. */\n\t\treturn 1;\n\t}\n\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\tif (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {\n\t\tfilep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);\n\t\tfilep->last_modified =\n\t\t    SYS2UNIX_TIME(info.ftLastWriteTime.dwLowDateTime,\n\t\t                  info.ftLastWriteTime.dwHighDateTime);\n\n\t\t/* On Windows, the file creation time can be higher than the\n\t\t * modification time, e.g. when a file is copied.\n\t\t * Since the Last-Modified timestamp is used for caching\n\t\t * it should be based on the most recent timestamp. */\n\t\tcreation_time = SYS2UNIX_TIME(info.ftCreationTime.dwLowDateTime,\n\t\t                              info.ftCreationTime.dwHighDateTime);\n\t\tif (creation_time > filep->last_modified) {\n\t\t\tfilep->last_modified = creation_time;\n\t\t}\n\n\t\tfilep->is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;\n\t\t/* If file name is fishy, reset the file structure and return\n\t\t * error.\n\t\t * Note it is important to reset, not just return the error, cause\n\t\t * functions like is_file_opened() check the struct. */\n\t\tif (!filep->is_directory && !path_cannot_disclose_cgi(path)) {\n\t\t\tmemset(filep, 0, sizeof(*filep));\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int\nmg_remove(const struct mg_connection *conn, const char *path)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\treturn DeleteFileW(wbuf) ? 0 : -1;\n}\n\n\nstatic int\nmg_mkdir(const struct mg_connection *conn, const char *path, int mode)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\t(void)mode;\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\treturn CreateDirectoryW(wbuf, NULL) ? 0 : -1;\n}\n\n\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\n/* Implementation of POSIX opendir/closedir/readdir for Windows. */\nFUNCTION_MAY_BE_UNUSED\nstatic DIR *\nmg_opendir(const struct mg_connection *conn, const char *name)\n{\n\tDIR *dir = NULL;\n\twchar_t wpath[W_PATH_MAX];\n\tDWORD attrs;\n\n\tif (name == NULL) {\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t} else if ((dir = (DIR *)mg_malloc(sizeof(*dir))) == NULL) {\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\n\t} else {\n\t\tpath_to_unicode(conn, name, wpath, ARRAY_SIZE(wpath));\n\t\tattrs = GetFileAttributesW(wpath);\n\t\tif ((wcslen(wpath) + 2 < ARRAY_SIZE(wpath)) && (attrs != 0xFFFFFFFF)\n\t\t    && ((attrs & FILE_ATTRIBUTE_DIRECTORY) != 0)) {\n\t\t\t(void)wcscat(wpath, L\"\\\\*\");\n\t\t\tdir->handle = FindFirstFileW(wpath, &dir->info);\n\t\t\tdir->result.d_name[0] = '\\0';\n\t\t} else {\n\t\t\tmg_free(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\treturn dir;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_closedir(DIR *dir)\n{\n\tint result = 0;\n\n\tif (dir != NULL) {\n\t\tif (dir->handle != INVALID_HANDLE_VALUE)\n\t\t\tresult = FindClose(dir->handle) ? 0 : -1;\n\n\t\tmg_free(dir);\n\t} else {\n\t\tresult = -1;\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t}\n\n\treturn result;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct dirent *\nmg_readdir(DIR *dir)\n{\n\tstruct dirent *result = 0;\n\n\tif (dir) {\n\t\tif (dir->handle != INVALID_HANDLE_VALUE) {\n\t\t\tresult = &dir->result;\n\t\t\t(void)WideCharToMultiByte(CP_UTF8,\n\t\t\t                          0,\n\t\t\t                          dir->info.cFileName,\n\t\t\t                          -1,\n\t\t\t                          result->d_name,\n\t\t\t                          sizeof(result->d_name),\n\t\t\t                          NULL,\n\t\t\t                          NULL);\n\n\t\t\tif (!FindNextFileW(dir->handle, &dir->info)) {\n\t\t\t\t(void)FindClose(dir->handle);\n\t\t\t\tdir->handle = INVALID_HANDLE_VALUE;\n\t\t\t}\n\n\t\t} else {\n\t\t\tSetLastError(ERROR_FILE_NOT_FOUND);\n\t\t}\n\t} else {\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t}\n\n\treturn result;\n}\n\n\n#if !defined(HAVE_POLL)\n#define POLLIN (1)  /* Data ready - read will not block. */\n#define POLLPRI (2) /* Priority data ready. */\n#define POLLOUT (4) /* Send queue not full - write will not block. */\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npoll(struct pollfd *pfd, unsigned int n, int milliseconds)\n{\n\tstruct timeval tv;\n\tfd_set rset;\n\tfd_set wset;\n\tunsigned int i;\n\tint result;\n\tSOCKET maxfd = 0;\n\n\tmemset(&tv, 0, sizeof(tv));\n\ttv.tv_sec = milliseconds / 1000;\n\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\tFD_ZERO(&rset);\n\tFD_ZERO(&wset);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (pfd[i].events & POLLIN) {\n\t\t\tFD_SET((SOCKET)pfd[i].fd, &rset);\n\t\t} else if (pfd[i].events & POLLOUT) {\n\t\t\tFD_SET((SOCKET)pfd[i].fd, &wset);\n\t\t}\n\t\tpfd[i].revents = 0;\n\n\t\tif (pfd[i].fd > maxfd) {\n\t\t\tmaxfd = pfd[i].fd;\n\t\t}\n\t}\n\n\tif ((result = select((int)maxfd + 1, &rset, &wset, NULL, &tv)) > 0) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (FD_ISSET(pfd[i].fd, &rset)) {\n\t\t\t\tpfd[i].revents |= POLLIN;\n\t\t\t}\n\t\t\tif (FD_ISSET(pfd[i].fd, &wset)) {\n\t\t\t\tpfd[i].revents |= POLLOUT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* We should subtract the time used in select from remaining\n\t * \"milliseconds\", in particular if called from mg_poll with a\n\t * timeout quantum.\n\t * Unfortunately, the remaining time is not stored in \"tv\" in all\n\t * implementations, so the result in \"tv\" must be considered undefined.\n\t * See http://man7.org/linux/man-pages/man2/select.2.html */\n\n\treturn result;\n}\n#endif /* HAVE_POLL */\n\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n\nstatic void\nset_close_on_exec(SOCKET sock, struct mg_connection *conn /* may be null */)\n{\n\t(void)conn; /* Unused. */\n#if defined(_WIN32_WCE)\n\t(void)sock;\n#else\n\t(void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);\n#endif\n}\n\n\nint\nmg_start_thread(mg_thread_func_t f, void *p)\n{\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size, e.g.\n\t * -DUSE_STACK_SIZE=16384\n\t */\n\treturn ((_beginthread((void(__cdecl *)(void *))f, USE_STACK_SIZE, p)\n\t         == ((uintptr_t)(-1L)))\n\t            ? -1\n\t            : 0);\n#else\n\treturn (\n\t    (_beginthread((void(__cdecl *)(void *))f, 0, p) == ((uintptr_t)(-1L)))\n\t        ? -1\n\t        : 0);\n#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */\n}\n\n\n/* Start a thread storing the thread context. */\nstatic int\nmg_start_thread_with_id(unsigned(__stdcall *f)(void *),\n                        void *p,\n                        pthread_t *threadidptr)\n{\n\tuintptr_t uip;\n\tHANDLE threadhandle;\n\tint result = -1;\n\n\tuip = _beginthreadex(NULL, 0, (unsigned(__stdcall *)(void *))f, p, 0, NULL);\n\tthreadhandle = (HANDLE)uip;\n\tif ((uip != (uintptr_t)(-1L)) && (threadidptr != NULL)) {\n\t\t*threadidptr = threadhandle;\n\t\tresult = 0;\n\t}\n\n\treturn result;\n}\n\n\n/* Wait for a thread to finish. */\nstatic int\nmg_join_thread(pthread_t threadid)\n{\n\tint result;\n\tDWORD dwevent;\n\n\tresult = -1;\n\tdwevent = WaitForSingleObject(threadid, (DWORD)INFINITE);\n\tif (dwevent == WAIT_FAILED) {\n\t\tDEBUG_TRACE(\"WaitForSingleObject() failed, error %d\", ERRNO);\n\t} else {\n\t\tif (dwevent == WAIT_OBJECT_0) {\n\t\t\tCloseHandle(threadid);\n\t\t\tresult = 0;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n/* If SSL is loaded dynamically, dlopen/dlclose is required. */\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic HANDLE\ndlopen(const char *dll_name, int flags)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\t(void)flags;\n\tpath_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));\n\treturn LoadLibraryW(wbuf);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\ndlclose(void *handle)\n{\n\tint result;\n\n\tif (FreeLibrary((HMODULE)handle) != 0) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = -1;\n\t}\n\n\treturn result;\n}\n\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n#endif\n\n\n#if !defined(NO_CGI)\n#define SIGKILL (0)\n\n\nstatic int\nkill(pid_t pid, int sig_num)\n{\n\t(void)TerminateProcess((HANDLE)pid, (UINT)sig_num);\n\t(void)CloseHandle((HANDLE)pid);\n\treturn 0;\n}\n\n\n#ifndef WNOHANG\n#define WNOHANG (1)\n#endif\n\n\nstatic pid_t\nwaitpid(pid_t pid, int *status, int flags)\n{\n\tDWORD timeout = INFINITE;\n\tDWORD waitres;\n\n\t(void)status; /* Currently not used by any client here */\n\n\tif ((flags | WNOHANG) == WNOHANG) {\n\t\ttimeout = 0;\n\t}\n\n\twaitres = WaitForSingleObject((HANDLE)pid, timeout);\n\tif (waitres == WAIT_OBJECT_0) {\n\t\treturn pid;\n\t}\n\tif (waitres == WAIT_TIMEOUT) {\n\t\treturn 0;\n\t}\n\treturn (pid_t)-1;\n}\n\n\nstatic void\ntrim_trailing_whitespaces(char *s)\n{\n\tchar *e = s + strlen(s) - 1;\n\twhile ((e > s) && isspace(*(unsigned char *)e)) {\n\t\t*e-- = '\\0';\n\t}\n}\n\n\nstatic pid_t\nspawn_process(struct mg_connection *conn,\n              const char *prog,\n              char *envblk,\n              char *envp[],\n              int fdin[2],\n              int fdout[2],\n              int fderr[2],\n              const char *dir)\n{\n\tHANDLE me;\n\tchar *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],\n\t    cmdline[PATH_MAX], buf[PATH_MAX];\n\tint truncated;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tSTARTUPINFOA si;\n\tPROCESS_INFORMATION pi = {0};\n\n\t(void)envp;\n\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\tsi.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n\tsi.wShowWindow = SW_HIDE;\n\n\tme = GetCurrentProcess();\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fdin[0]),\n\t                me,\n\t                &si.hStdInput,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fdout[1]),\n\t                me,\n\t                &si.hStdOutput,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fderr[1]),\n\t                me,\n\t                &si.hStdError,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\n\t/* Mark handles that should not be inherited. See\n\t * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx\n\t */\n\tSetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\tSetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\tSetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\n\t/* If CGI file is a script, try to read the interpreter line */\n\tinterp = conn->dom_ctx->config[CGI_INTERPRETER];\n\tif (interp == NULL) {\n\t\tbuf[0] = buf[1] = '\\0';\n\n\t\t/* Read the first line of the script into the buffer */\n\t\tmg_snprintf(\n\t\t    conn, &truncated, cmdline, sizeof(cmdline), \"%s/%s\", dir, prog);\n\n\t\tif (truncated) {\n\t\t\tpi.hProcess = (pid_t)-1;\n\t\t\tgoto spawn_cleanup;\n\t\t}\n\n\t\tif (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {\n#if defined(MG_USE_OPEN_FILE)\n\t\t\tp = (char *)file.access.membuf;\n#else\n\t\t\tp = (char *)NULL;\n#endif\n\t\t\tmg_fgets(buf, sizeof(buf), &file, &p);\n\t\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t}\n\n\t\tif ((buf[0] == '#') && (buf[1] == '!')) {\n\t\t\ttrim_trailing_whitespaces(buf + 2);\n\t\t} else {\n\t\t\tbuf[2] = '\\0';\n\t\t}\n\t\tinterp = buf + 2;\n\t}\n\n\tif (interp[0] != '\\0') {\n\t\tGetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);\n\t\tinterp = full_interp;\n\t}\n\tGetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);\n\n\tif (interp[0] != '\\0') {\n\t\tmg_snprintf(conn,\n\t\t            &truncated,\n\t\t            cmdline,\n\t\t            sizeof(cmdline),\n\t\t            \"\\\"%s\\\" \\\"%s\\\\%s\\\"\",\n\t\t            interp,\n\t\t            full_dir,\n\t\t            prog);\n\t} else {\n\t\tmg_snprintf(conn,\n\t\t            &truncated,\n\t\t            cmdline,\n\t\t            sizeof(cmdline),\n\t\t            \"\\\"%s\\\\%s\\\"\",\n\t\t            full_dir,\n\t\t            prog);\n\t}\n\n\tif (truncated) {\n\t\tpi.hProcess = (pid_t)-1;\n\t\tgoto spawn_cleanup;\n\t}\n\n\tDEBUG_TRACE(\"Running [%s]\", cmdline);\n\tif (CreateProcessA(NULL,\n\t                   cmdline,\n\t                   NULL,\n\t                   NULL,\n\t                   TRUE,\n\t                   CREATE_NEW_PROCESS_GROUP,\n\t                   envblk,\n\t                   NULL,\n\t                   &si,\n\t                   &pi) == 0) {\n\t\tmg_cry_internal(\n\t\t    conn, \"%s: CreateProcess(%s): %ld\", __func__, cmdline, (long)ERRNO);\n\t\tpi.hProcess = (pid_t)-1;\n\t\t/* goto spawn_cleanup; */\n\t}\n\nspawn_cleanup:\n\t(void)CloseHandle(si.hStdOutput);\n\t(void)CloseHandle(si.hStdError);\n\t(void)CloseHandle(si.hStdInput);\n\tif (pi.hThread != NULL) {\n\t\t(void)CloseHandle(pi.hThread);\n\t}\n\n\treturn (pid_t)pi.hProcess;\n}\n#endif /* !NO_CGI */\n\n\nstatic int\nset_blocking_mode(SOCKET sock)\n{\n\tunsigned long non_blocking = 0;\n\treturn ioctlsocket(sock, (long)FIONBIO, &non_blocking);\n}\n\nstatic int\nset_non_blocking_mode(SOCKET sock)\n{\n\tunsigned long non_blocking = 1;\n\treturn ioctlsocket(sock, (long)FIONBIO, &non_blocking);\n}\n\n#else\n\nstatic int\nmg_stat(const struct mg_connection *conn,\n        const char *path,\n        struct mg_file_stat *filep)\n{\n\tstruct stat st;\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tmemset(filep, 0, sizeof(*filep));\n\n\tif (conn && is_file_in_memory(conn, path)) {\n\n\t\t/* Quick fix (for 1.9.x): */\n\t\t/* mg_stat must fill all fields, also for files in memory */\n\t\tstruct mg_file tmp_file = STRUCT_FILE_INITIALIZER;\n\t\topen_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);\n\t\tfilep->size = tmp_file.stat.size;\n\t\tfilep->last_modified = time(NULL);\n\t\tfilep->location = 2;\n\t\t/* TODO: remove legacy \"files in memory\" feature */\n\n\t\treturn 1;\n\t}\n\n\tif (0 == stat(path, &st)) {\n\t\tfilep->size = (uint64_t)(st.st_size);\n\t\tfilep->last_modified = st.st_mtime;\n\t\tfilep->is_directory = S_ISDIR(st.st_mode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nset_close_on_exec(SOCKET fd, struct mg_connection *conn /* may be null */)\n{\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {\n\t\tif (conn) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n\t}\n}\n\n\nint\nmg_start_thread(mg_thread_func_t func, void *param)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\tint result;\n\n\t(void)pthread_attr_init(&attr);\n\t(void)pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size,\n\t * e.g. -DUSE_STACK_SIZE=16384 */\n\t(void)pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */\n\n\tresult = pthread_create(&thread_id, &attr, func, param);\n\tpthread_attr_destroy(&attr);\n\n\treturn result;\n}\n\n\n/* Start a thread storing the thread context. */\nstatic int\nmg_start_thread_with_id(mg_thread_func_t func,\n                        void *param,\n                        pthread_t *threadidptr)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\tint result;\n\n\t(void)pthread_attr_init(&attr);\n\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size,\n\t * e.g. -DUSE_STACK_SIZE=16384 */\n\t(void)pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif /* defined(USE_STACK_SIZE) && USE_STACK_SIZE > 1 */\n\n\tresult = pthread_create(&thread_id, &attr, func, param);\n\tpthread_attr_destroy(&attr);\n\tif ((result == 0) && (threadidptr != NULL)) {\n\t\t*threadidptr = thread_id;\n\t}\n\treturn result;\n}\n\n\n/* Wait for a thread to finish. */\nstatic int\nmg_join_thread(pthread_t threadid)\n{\n\tint result;\n\n\tresult = pthread_join(threadid, NULL);\n\treturn result;\n}\n\n\n#if !defined(NO_CGI)\nstatic pid_t\nspawn_process(struct mg_connection *conn,\n              const char *prog,\n              char *envblk,\n              char *envp[],\n              int fdin[2],\n              int fdout[2],\n              int fderr[2],\n              const char *dir)\n{\n\tpid_t pid;\n\tconst char *interp;\n\n\t(void)envblk;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif ((pid = fork()) == -1) {\n\t\t/* Parent */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Creating CGI process\\nfork(): %s\",\n\t\t                   strerror(ERRNO));\n\t} else if (pid == 0) {\n\t\t/* Child */\n\t\tif (chdir(dir) != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    conn, \"%s: chdir(%s): %s\", __func__, dir, strerror(ERRNO));\n\t\t} else if (dup2(fdin[0], 0) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 0): %s\",\n\t\t\t                __func__,\n\t\t\t                fdin[0],\n\t\t\t                strerror(ERRNO));\n\t\t} else if (dup2(fdout[1], 1) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 1): %s\",\n\t\t\t                __func__,\n\t\t\t                fdout[1],\n\t\t\t                strerror(ERRNO));\n\t\t} else if (dup2(fderr[1], 2) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 2): %s\",\n\t\t\t                __func__,\n\t\t\t                fderr[1],\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\t/* Keep stderr and stdout in two different pipes.\n\t\t\t * Stdout will be sent back to the client,\n\t\t\t * stderr should go into a server error log. */\n\t\t\t(void)close(fdin[0]);\n\t\t\t(void)close(fdout[1]);\n\t\t\t(void)close(fderr[1]);\n\n\t\t\t/* Close write end fdin and read end fdout and fderr */\n\t\t\t(void)close(fdin[1]);\n\t\t\t(void)close(fdout[0]);\n\t\t\t(void)close(fderr[0]);\n\n\t\t\t/* After exec, all signal handlers are restored to their default\n\t\t\t * values, with one exception of SIGCHLD. According to\n\t\t\t * POSIX.1-2001 and Linux's implementation, SIGCHLD's handler\n\t\t\t * will leave unchanged after exec if it was set to be ignored.\n\t\t\t * Restore it to default action. */\n\t\t\tsignal(SIGCHLD, SIG_DFL);\n\n\t\t\tinterp = conn->dom_ctx->config[CGI_INTERPRETER];\n\t\t\tif (interp == NULL) {\n\t\t\t\t(void)execle(prog, prog, NULL, envp);\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: execle(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                prog,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t} else {\n\t\t\t\t(void)execle(interp, interp, prog, NULL, envp);\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: execle(%s %s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                interp,\n\t\t\t\t                prog,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t}\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn pid;\n}\n#endif /* !NO_CGI */\n\n\nstatic int\nset_non_blocking_mode(SOCKET sock)\n{\n\tint flags = fcntl(sock, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nset_blocking_mode(SOCKET sock)\n{\n\tint flags = fcntl(sock, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif /* _WIN32 / else */\n\n/* End of initial operating system specific define block. */\n\n\n/* Get a random number (independent of C rand function) */\nstatic uint64_t\nget_random(void)\n{\n\tstatic uint64_t lfsr = 0; /* Linear feedback shift register */\n\tstatic uint64_t lcg = 0;  /* Linear congruential generator */\n\tuint64_t now = mg_get_current_time_ns();\n\n\tif (lfsr == 0) {\n\t\t/* lfsr will be only 0 if has not been initialized,\n\t\t * so this code is called only once. */\n\t\tlfsr = mg_get_current_time_ns();\n\t\tlcg = mg_get_current_time_ns();\n\t} else {\n\t\t/* Get the next step of both random number generators. */\n\t\tlfsr = (lfsr >> 1)\n\t\t       | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1)\n\t\t          << 63);\n\t\tlcg = lcg * 6364136223846793005LL + 1442695040888963407LL;\n\t}\n\n\t/* Combining two pseudo-random number generators and a high resolution\n\t * part\n\t * of the current server time will make it hard (impossible?) to guess\n\t * the\n\t * next number. */\n\treturn (lfsr ^ lcg ^ now);\n}\n\n\nstatic int\nmg_poll(struct pollfd *pfd,\n        unsigned int n,\n        int milliseconds,\n        volatile int *stop_server)\n{\n\t/* Call poll, but only for a maximum time of a few seconds.\n\t * This will allow to stop the server after some seconds, instead\n\t * of having to wait for a long socket timeout. */\n\tint ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */\n\n\tdo {\n\t\tint result;\n\n\t\tif (*stop_server) {\n\t\t\t/* Shut down signal */\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((milliseconds >= 0) && (milliseconds < ms_now)) {\n\t\t\tms_now = milliseconds;\n\t\t}\n\n\t\tresult = poll(pfd, n, ms_now);\n\t\tif (result != 0) {\n\t\t\t/* Poll returned either success (1) or error (-1).\n\t\t\t * Forward both to the caller. */\n\t\t\treturn result;\n\t\t}\n\n\t\t/* Poll returned timeout (0). */\n\t\tif (milliseconds > 0) {\n\t\t\tmilliseconds -= ms_now;\n\t\t}\n\n\t} while (milliseconds != 0);\n\n\t/* timeout: return 0 */\n\treturn 0;\n}\n\n\n/* Write data to the IO channel - opened file descriptor, socket or SSL\n * descriptor.\n * Return value:\n *  >=0 .. number of bytes successfully written\n *   -1 .. timeout\n *   -2 .. error\n */\nstatic int\npush_inner(struct mg_context *ctx,\n           FILE *fp,\n           SOCKET sock,\n           SSL *ssl,\n           const char *buf,\n           int len,\n           double timeout)\n{\n\tuint64_t start = 0, now = 0, timeout_ns = 0;\n\tint n, err;\n\tunsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */\n\n#if defined(_WIN32)\n\ttypedef int len_t;\n#else\n\ttypedef size_t len_t;\n#endif\n\n\tif (timeout > 0) {\n\t\tnow = mg_get_current_time_ns();\n\t\tstart = now;\n\t\ttimeout_ns = (uint64_t)(timeout * 1.0E9);\n\t}\n\n\tif (ctx == NULL) {\n\t\treturn -2;\n\t}\n\n#if defined(NO_SSL)\n\tif (ssl) {\n\t\treturn -2;\n\t}\n#endif\n\n\t/* Try to read until it succeeds, fails, times out, or the server\n\t * shuts down. */\n\tfor (;;) {\n\n#if !defined(NO_SSL)\n\t\tif (ssl != NULL) {\n\t\t\tn = SSL_write(ssl, buf, len);\n\t\t\tif (n <= 0) {\n\t\t\t\terr = SSL_get_error(ssl, n);\n\t\t\t\tif ((err == SSL_ERROR_SYSCALL) && (n == -1)) {\n\t\t\t\t\terr = ERRNO;\n\t\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\t\tn = 0;\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_TRACE(\"SSL_write() failed, error %d\", err);\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else\n#endif\n\t\t    if (fp != NULL) {\n\t\t\tn = (int)fwrite(buf, 1, (size_t)len, fp);\n\t\t\tif (ferror(fp)) {\n\t\t\t\tn = -1;\n\t\t\t\terr = ERRNO;\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);\n\t\t\terr = (n < 0) ? ERRNO : 0;\n#if defined(_WIN32)\n\t\t\tif (err == WSAEWOULDBLOCK) {\n\t\t\t\terr = 0;\n\t\t\t\tn = 0;\n\t\t\t}\n#else\n\t\t\tif (err == EWOULDBLOCK) {\n\t\t\t\terr = 0;\n\t\t\t\tn = 0;\n\t\t\t}\n#endif\n\t\t\tif (n < 0) {\n\t\t\t\t/* shutdown of the socket at client side */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((n > 0) || ((n == 0) && (len == 0))) {\n\t\t\t/* some data has been read, or no data was requested */\n\t\t\treturn n;\n\t\t}\n\t\tif (n < 0) {\n\t\t\t/* socket error - check errno */\n\t\t\tDEBUG_TRACE(\"send() failed, error %d\", err);\n\n\t\t\t/* TODO (mid): error handling depending on the error code.\n\t\t\t * These codes are different between Windows and Linux.\n\t\t\t * Currently there is no problem with failing send calls,\n\t\t\t * if there is a reproducible situation, it should be\n\t\t\t * investigated in detail.\n\t\t\t */\n\t\t\treturn -2;\n\t\t}\n\n\t\t/* Only in case n=0 (timeout), repeat calling the write function */\n\n\t\t/* If send failed, wait before retry */\n\t\tif (fp != NULL) {\n\t\t\t/* For files, just wait a fixed time.\n\t\t\t * Maybe it helps, maybe not. */\n\t\t\tmg_sleep(5);\n\t\t} else {\n\t\t\t/* For sockets, wait for the socket using poll */\n\t\t\tstruct pollfd pfd[1];\n\t\t\tint pollres;\n\n\t\t\tpfd[0].fd = sock;\n\t\t\tpfd[0].events = POLLOUT;\n\t\t\tpollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));\n\t\t\tif (ctx->stop_flag) {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tif (pollres > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (timeout > 0) {\n\t\t\tnow = mg_get_current_time_ns();\n\t\t\tif ((now - start) > timeout_ns) {\n\t\t\t\t/* Timeout */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t(void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not\n\t              used */\n\n\treturn -1;\n}\n\n\nstatic int64_t\npush_all(struct mg_context *ctx,\n         FILE *fp,\n         SOCKET sock,\n         SSL *ssl,\n         const char *buf,\n         int64_t len)\n{\n\tdouble timeout = -1.0;\n\tint64_t n, nwritten = 0;\n\n\tif (ctx == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (ctx->dd.config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\twhile ((len > 0) && (ctx->stop_flag == 0)) {\n\t\tn = push_inner(ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);\n\t\tif (n < 0) {\n\t\t\tif (nwritten == 0) {\n\t\t\t\tnwritten = n; /* Propagate the error */\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == 0) {\n\t\t\tbreak; /* No more data to write */\n\t\t} else {\n\t\t\tnwritten += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n\n\treturn nwritten;\n}\n\n\n/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.\n * Return value:\n *  >=0 .. number of bytes successfully read\n *   -1 .. timeout\n *   -2 .. error\n */\nstatic int\npull_inner(FILE *fp,\n           struct mg_connection *conn,\n           char *buf,\n           int len,\n           double timeout)\n{\n\tint nread, err = 0;\n\n#if defined(_WIN32)\n\ttypedef int len_t;\n#else\n\ttypedef size_t len_t;\n#endif\n#if !defined(NO_SSL)\n\tint ssl_pending;\n#endif\n\n\t/* We need an additional wait loop around this, because in some cases\n\t * with TLSwe may get data from the socket but not from SSL_read.\n\t * In this case we need to repeat at least once.\n\t */\n\n\tif (fp != NULL) {\n#if !defined(_WIN32_WCE)\n\t\t/* Use read() instead of fread(), because if we're reading from the\n\t\t * CGI pipe, fread() may block until IO buffer is filled up. We\n\t\t * cannot afford to block and must pass all read bytes immediately\n\t\t * to the client. */\n\t\tnread = (int)read(fileno(fp), buf, (size_t)len);\n#else\n\t\t/* WinCE does not support CGI pipes */\n\t\tnread = (int)fread(buf, 1, (size_t)len, fp);\n#endif\n\t\terr = (nread < 0) ? ERRNO : 0;\n\t\tif ((nread == 0) && (len > 0)) {\n\t\t\t/* Should get data, but got EOL */\n\t\t\treturn -2;\n\t\t}\n\n#if !defined(NO_SSL)\n\t} else if ((conn->ssl != NULL)\n\t           && ((ssl_pending = SSL_pending(conn->ssl)) > 0)) {\n\t\t/* We already know there is no more data buffered in conn->buf\n\t\t * but there is more available in the SSL layer. So don't poll\n\t\t * conn->client.sock yet. */\n\t\tif (ssl_pending > len) {\n\t\t\tssl_pending = len;\n\t\t}\n\t\tnread = SSL_read(conn->ssl, buf, ssl_pending);\n\t\tif (nread <= 0) {\n\t\t\terr = SSL_get_error(conn->ssl, nread);\n\t\t\tif ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {\n\t\t\t\terr = ERRNO;\n\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\tnread = 0;\n\t\t\t} else {\n\t\t\t\tDEBUG_TRACE(\"SSL_read() failed, error %d\", err);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\terr = 0;\n\t\t}\n\n\t} else if (conn->ssl != NULL) {\n\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\n\t\tpfd[0].fd = conn->client.sock;\n\t\tpfd[0].events = POLLIN;\n\t\tpollres = mg_poll(pfd,\n\t\t                  1,\n\t\t                  (int)(timeout * 1000.0),\n\t\t                  &(conn->phys_ctx->stop_flag));\n\t\tif (conn->phys_ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (pollres > 0) {\n\t\t\tnread = SSL_read(conn->ssl, buf, len);\n\t\t\tif (nread <= 0) {\n\t\t\t\terr = SSL_get_error(conn->ssl, nread);\n\t\t\t\tif ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {\n\t\t\t\t\terr = ERRNO;\n\t\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\t\tnread = 0;\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_TRACE(\"SSL_read() failed, error %d\", err);\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\n\t\t} else if (pollres < 0) {\n\t\t\t/* Error */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/* pollres = 0 means timeout */\n\t\t\tnread = 0;\n\t\t}\n#endif\n\n\t} else {\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\n\t\tpfd[0].fd = conn->client.sock;\n\t\tpfd[0].events = POLLIN;\n\t\tpollres = mg_poll(pfd,\n\t\t                  1,\n\t\t                  (int)(timeout * 1000.0),\n\t\t                  &(conn->phys_ctx->stop_flag));\n\t\tif (conn->phys_ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (pollres > 0) {\n\t\t\tnread = (int)recv(conn->client.sock, buf, (len_t)len, 0);\n\t\t\terr = (nread < 0) ? ERRNO : 0;\n\t\t\tif (nread <= 0) {\n\t\t\t\t/* shutdown of the socket at client side */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t} else if (pollres < 0) {\n\t\t\t/* error callint poll */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/* pollres = 0 means timeout */\n\t\t\tnread = 0;\n\t\t}\n\t}\n\n\tif (conn->phys_ctx->stop_flag) {\n\t\treturn -2;\n\t}\n\n\tif ((nread > 0) || ((nread == 0) && (len == 0))) {\n\t\t/* some data has been read, or no data was requested */\n\t\treturn nread;\n\t}\n\n\tif (nread < 0) {\n/* socket error - check errno */\n#if defined(_WIN32)\n\t\tif (err == WSAEWOULDBLOCK) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* standard case if called from close_socket_gracefully */\n\t\t\treturn -2;\n\t\t} else if (err == WSAETIMEDOUT) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* timeout is handled by the while loop  */\n\t\t\treturn 0;\n\t\t} else if (err == WSAECONNABORTED) {\n\t\t\t/* See https://www.chilkatsoft.com/p/p_299.asp */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\tDEBUG_TRACE(\"recv() failed, error %d\", err);\n\t\t\treturn -2;\n\t\t}\n#else\n\t\t/* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,\n\t\t * if the timeout is reached and if the socket was set to non-\n\t\t * blocking in close_socket_gracefully, so we can not distinguish\n\t\t * here. We have to wait for the timeout in both cases for now.\n\t\t */\n\t\tif ((err == EAGAIN) || (err == EWOULDBLOCK) || (err == EINTR)) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* EAGAIN/EWOULDBLOCK:\n\t\t\t * standard case if called from close_socket_gracefully\n\t\t\t * => should return -1 */\n\t\t\t/* or timeout occurred\n\t\t\t * => the code must stay in the while loop */\n\n\t\t\t/* EINTR can be generated on a socket with a timeout set even\n\t\t\t * when SA_RESTART is effective for all relevant signals\n\t\t\t * (see signal(7)).\n\t\t\t * => stay in the while loop */\n\t\t} else {\n\t\t\tDEBUG_TRACE(\"recv() failed, error %d\", err);\n\t\t\treturn -2;\n\t\t}\n#endif\n\t}\n\n\t/* Timeout occurred, but no data available. */\n\treturn -1;\n}\n\n\nstatic int\npull_all(FILE *fp, struct mg_connection *conn, char *buf, int len)\n{\n\tint n, nread = 0;\n\tdouble timeout = -1.0;\n\tuint64_t start_time = 0, now = 0, timeout_ns = 0;\n\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\tif (timeout >= 0.0) {\n\t\tstart_time = mg_get_current_time_ns();\n\t\ttimeout_ns = (uint64_t)(timeout * 1.0E9);\n\t}\n\n\twhile ((len > 0) && (conn->phys_ctx->stop_flag == 0)) {\n\t\tn = pull_inner(fp, conn, buf + nread, len, timeout);\n\t\tif (n == -2) {\n\t\t\tif (nread == 0) {\n\t\t\t\tnread = -1; /* Propagate the error */\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == -1) {\n\t\t\t/* timeout */\n\t\t\tif (timeout >= 0.0) {\n\t\t\t\tnow = mg_get_current_time_ns();\n\t\t\t\tif ((now - start_time) <= timeout_ns) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == 0) {\n\t\t\tbreak; /* No more data to read */\n\t\t} else {\n\t\t\tconn->consumed_content += n;\n\t\t\tnread += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n\n\treturn nread;\n}\n\n\nstatic void\ndiscard_unread_request_data(struct mg_connection *conn)\n{\n\tchar buf[MG_BUF_LEN];\n\tsize_t to_read;\n\tint nread;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tto_read = sizeof(buf);\n\n\tif (conn->is_chunked) {\n\t\t/* Chunked encoding: 3=chunk read completely\n\t\t * completely */\n\t\twhile (conn->is_chunked != 3) {\n\t\t\tnread = mg_read(conn, buf, to_read);\n\t\t\tif (nread <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* Not chunked: content length is known */\n\t\twhile (conn->consumed_content < conn->content_len) {\n\t\t\tif (to_read\n\t\t\t    > (size_t)(conn->content_len - conn->consumed_content)) {\n\t\t\t\tto_read = (size_t)(conn->content_len - conn->consumed_content);\n\t\t\t}\n\n\t\t\tnread = mg_read(conn, buf, to_read);\n\t\t\tif (nread <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nmg_read_inner(struct mg_connection *conn, void *buf, size_t len)\n{\n\tint64_t n, buffered_len, nread;\n\tint64_t len64 =\n\t    (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is\n\t                                                 * int, we may not read more\n\t                                                 * bytes */\n\tconst char *body;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* If Content-Length is not set for a request with body data\n\t * (e.g., a PUT or POST request), we do not know in advance\n\t * how much data should be read. */\n\tif (conn->consumed_content == 0) {\n\t\tif (conn->is_chunked == 1) {\n\t\t\tconn->content_len = len64;\n\t\t\tconn->is_chunked = 2;\n\t\t} else if (conn->content_len == -1) {\n\t\t\t/* The body data is completed when the connection\n\t\t\t * is closed. */\n\t\t\tconn->content_len = INT64_MAX;\n\t\t\tconn->must_close = 1;\n\t\t}\n\t}\n\n\tnread = 0;\n\tif (conn->consumed_content < conn->content_len) {\n\t\t/* Adjust number of bytes to read. */\n\t\tint64_t left_to_read = conn->content_len - conn->consumed_content;\n\t\tif (left_to_read < len64) {\n\t\t\t/* Do not read more than the total content length of the\n\t\t\t * request.\n\t\t\t */\n\t\t\tlen64 = left_to_read;\n\t\t}\n\n\t\t/* Return buffered data */\n\t\tbuffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len\n\t\t               - conn->consumed_content;\n\t\tif (buffered_len > 0) {\n\t\t\tif (len64 < buffered_len) {\n\t\t\t\tbuffered_len = len64;\n\t\t\t}\n\t\t\tbody = conn->buf + conn->request_len + conn->consumed_content;\n\t\t\tmemcpy(buf, body, (size_t)buffered_len);\n\t\t\tlen64 -= buffered_len;\n\t\t\tconn->consumed_content += buffered_len;\n\t\t\tnread += buffered_len;\n\t\t\tbuf = (char *)buf + buffered_len;\n\t\t}\n\n\t\t/* We have returned all buffered data. Read new data from the remote\n\t\t * socket.\n\t\t */\n\t\tif ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {\n\t\t\tnread += n;\n\t\t} else {\n\t\t\tnread = ((nread > 0) ? nread : n);\n\t\t}\n\t}\n\treturn (int)nread;\n}\n\n\nstatic char\nmg_getc(struct mg_connection *conn)\n{\n\tchar c;\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\tif (mg_read_inner(conn, &c, 1) <= 0) {\n\t\treturn (char)0;\n\t}\n\treturn c;\n}\n\n\nint\nmg_read(struct mg_connection *conn, void *buf, size_t len)\n{\n\tif (len > INT_MAX) {\n\t\tlen = INT_MAX;\n\t}\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (conn->is_chunked) {\n\t\tsize_t all_read = 0;\n\n\t\twhile (len > 0) {\n\t\t\tif (conn->is_chunked == 3) {\n\t\t\t\t/* No more data left to read */\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (conn->chunk_remainder) {\n\t\t\t\t/* copy from the remainder of the last received chunk */\n\t\t\t\tlong read_ret;\n\t\t\t\tsize_t read_now =\n\t\t\t\t    ((conn->chunk_remainder > len) ? (len)\n\t\t\t\t                                   : (conn->chunk_remainder));\n\n\t\t\t\tconn->content_len += (int)read_now;\n\t\t\t\tread_ret =\n\t\t\t\t    mg_read_inner(conn, (char *)buf + all_read, read_now);\n\n\t\t\t\tif (read_ret < 1) {\n\t\t\t\t\t/* read error */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tall_read += (size_t)read_ret;\n\t\t\t\tconn->chunk_remainder -= (size_t)read_ret;\n\t\t\t\tlen -= (size_t)read_ret;\n\n\t\t\t\tif (conn->chunk_remainder == 0) {\n\t\t\t\t\t/* Add data bytes in the current chunk have been read,\n\t\t\t\t\t * so we are expecting \\r\\n now. */\n\t\t\t\t\tchar x1, x2;\n\t\t\t\t\tconn->content_len += 2;\n\t\t\t\t\tx1 = mg_getc(conn);\n\t\t\t\t\tx2 = mg_getc(conn);\n\t\t\t\t\tif ((x1 != '\\r') || (x2 != '\\n')) {\n\t\t\t\t\t\t/* Protocol violation */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* fetch a new chunk */\n\t\t\t\tint i = 0;\n\t\t\t\tchar lenbuf[64];\n\t\t\t\tchar *end = 0;\n\t\t\t\tunsigned long chunkSize = 0;\n\n\t\t\t\tfor (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {\n\t\t\t\t\tconn->content_len++;\n\t\t\t\t\tlenbuf[i] = mg_getc(conn);\n\t\t\t\t\tif ((i > 0) && (lenbuf[i] == '\\r')\n\t\t\t\t\t    && (lenbuf[i - 1] != '\\r')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((i > 1) && (lenbuf[i] == '\\n')\n\t\t\t\t\t    && (lenbuf[i - 1] == '\\r')) {\n\t\t\t\t\t\tlenbuf[i + 1] = 0;\n\t\t\t\t\t\tchunkSize = strtoul(lenbuf, &end, 16);\n\t\t\t\t\t\tif (chunkSize == 0) {\n\t\t\t\t\t\t\t/* regular end of content */\n\t\t\t\t\t\t\tconn->is_chunked = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isxdigit(lenbuf[i])) {\n\t\t\t\t\t\t/* illegal character for chunk length */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((end == NULL) || (*end != '\\r')) {\n\t\t\t\t\t/* chunksize not set correctly */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (chunkSize == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconn->chunk_remainder = chunkSize;\n\t\t\t}\n\t\t}\n\n\t\treturn (int)all_read;\n\t}\n\treturn mg_read_inner(conn, buf, len);\n}\n\n\nint\nmg_write(struct mg_connection *conn, const void *buf, size_t len)\n{\n\ttime_t now;\n\tint64_t n, total, allowed;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (conn->throttle > 0) {\n\t\tif ((now = time(NULL)) != conn->last_throttle_time) {\n\t\t\tconn->last_throttle_time = now;\n\t\t\tconn->last_throttle_bytes = 0;\n\t\t}\n\t\tallowed = conn->throttle - conn->last_throttle_bytes;\n\t\tif (allowed > (int64_t)len) {\n\t\t\tallowed = (int64_t)len;\n\t\t}\n\t\tif ((total = push_all(conn->phys_ctx,\n\t\t                      NULL,\n\t\t                      conn->client.sock,\n\t\t                      conn->ssl,\n\t\t                      (const char *)buf,\n\t\t                      (int64_t)allowed)) == allowed) {\n\t\t\tbuf = (const char *)buf + total;\n\t\t\tconn->last_throttle_bytes += total;\n\t\t\twhile ((total < (int64_t)len) && (conn->phys_ctx->stop_flag == 0)) {\n\t\t\t\tallowed = (conn->throttle > ((int64_t)len - total))\n\t\t\t\t              ? (int64_t)len - total\n\t\t\t\t              : conn->throttle;\n\t\t\t\tif ((n = push_all(conn->phys_ctx,\n\t\t\t\t                  NULL,\n\t\t\t\t                  conn->client.sock,\n\t\t\t\t                  conn->ssl,\n\t\t\t\t                  (const char *)buf,\n\t\t\t\t                  (int64_t)allowed)) != allowed) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t\tconn->last_throttle_bytes = allowed;\n\t\t\t\tconn->last_throttle_time = time(NULL);\n\t\t\t\tbuf = (const char *)buf + n;\n\t\t\t\ttotal += n;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttotal = push_all(conn->phys_ctx,\n\t\t                 NULL,\n\t\t                 conn->client.sock,\n\t\t                 conn->ssl,\n\t\t                 (const char *)buf,\n\t\t                 (int64_t)len);\n\t}\n\tif (total > 0) {\n\t\tconn->num_bytes_sent += total;\n\t}\n\treturn (int)total;\n}\n\n\n/* Send a chunk, if \"Transfer-Encoding: chunked\" is used */\nint\nmg_send_chunk(struct mg_connection *conn,\n              const char *chunk,\n              unsigned int chunk_len)\n{\n\tchar lenbuf[16];\n\tsize_t lenbuf_len;\n\tint ret;\n\tint t;\n\n\t/* First store the length information in a text buffer. */\n\tsprintf(lenbuf, \"%x\\r\\n\", chunk_len);\n\tlenbuf_len = strlen(lenbuf);\n\n\t/* Then send length information, chunk and terminating \\r\\n. */\n\tret = mg_write(conn, lenbuf, lenbuf_len);\n\tif (ret != (int)lenbuf_len) {\n\t\treturn -1;\n\t}\n\tt = ret;\n\n\tret = mg_write(conn, chunk, chunk_len);\n\tif (ret != (int)chunk_len) {\n\t\treturn -1;\n\t}\n\tt += ret;\n\n\tret = mg_write(conn, \"\\r\\n\", 2);\n\tif (ret != 2) {\n\t\treturn -1;\n\t}\n\tt += ret;\n\n\treturn t;\n}\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* This block forwards format strings to printf implementations,\n * so we need to disable the format-nonliteral warning. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\n/* Alternative alloc_vprintf() for non-compliant C runtimes */\nstatic int\nalloc_vprintf2(char **buf, const char *fmt, va_list ap)\n{\n\tva_list ap_copy;\n\tsize_t size = MG_BUF_LEN / 4;\n\tint len = -1;\n\n\t*buf = NULL;\n\twhile (len < 0) {\n\t\tif (*buf) {\n\t\t\tmg_free(*buf);\n\t\t}\n\n\t\tsize *= 4;\n\t\t*buf = (char *)mg_malloc(size);\n\t\tif (!*buf) {\n\t\t\tbreak;\n\t\t}\n\n\t\tva_copy(ap_copy, ap);\n\t\tlen = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);\n\t\tva_end(ap_copy);\n\t\t(*buf)[size - 1] = 0;\n\t}\n\n\treturn len;\n}\n\n\n/* Print message to buffer. If buffer is large enough to hold the message,\n * return buffer. If buffer is to small, allocate large enough buffer on\n * heap,\n * and return allocated buffer. */\nstatic int\nalloc_vprintf(char **out_buf,\n              char *prealloc_buf,\n              size_t prealloc_size,\n              const char *fmt,\n              va_list ap)\n{\n\tva_list ap_copy;\n\tint len;\n\n\t/* Windows is not standard-compliant, and vsnprintf() returns -1 if\n\t * buffer is too small. Also, older versions of msvcrt.dll do not have\n\t * _vscprintf().  However, if size is 0, vsnprintf() behaves correctly.\n\t * Therefore, we make two passes: on first pass, get required message\n\t * length.\n\t * On second pass, actually print the message. */\n\tva_copy(ap_copy, ap);\n\tlen = vsnprintf_impl(NULL, 0, fmt, ap_copy);\n\tva_end(ap_copy);\n\n\tif (len < 0) {\n\t\t/* C runtime is not standard compliant, vsnprintf() returned -1.\n\t\t * Switch to alternative code path that uses incremental\n\t\t * allocations.\n\t\t*/\n\t\tva_copy(ap_copy, ap);\n\t\tlen = alloc_vprintf2(out_buf, fmt, ap_copy);\n\t\tva_end(ap_copy);\n\n\t} else if ((size_t)(len) >= prealloc_size) {\n\t\t/* The pre-allocated buffer not large enough. */\n\t\t/* Allocate a new buffer. */\n\t\t*out_buf = (char *)mg_malloc((size_t)(len) + 1);\n\t\tif (!*out_buf) {\n\t\t\t/* Allocation failed. Return -1 as \"out of memory\" error. */\n\t\t\treturn -1;\n\t\t}\n\t\t/* Buffer allocation successful. Store the string there. */\n\t\tva_copy(ap_copy, ap);\n\t\tIGNORE_UNUSED_RESULT(\n\t\t    vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));\n\t\tva_end(ap_copy);\n\n\t} else {\n\t\t/* The pre-allocated buffer is large enough.\n\t\t * Use it to store the string and return the address. */\n\t\tva_copy(ap_copy, ap);\n\t\tIGNORE_UNUSED_RESULT(\n\t\t    vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));\n\t\tva_end(ap_copy);\n\t\t*out_buf = prealloc_buf;\n\t}\n\n\treturn len;\n}\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Enable format-nonliteral warning again. */\n#pragma GCC diagnostic pop\n#endif\n\n\nstatic int\nmg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap)\n{\n\tchar mem[MG_BUF_LEN];\n\tchar *buf = NULL;\n\tint len;\n\n\tif ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {\n\t\tlen = mg_write(conn, buf, (size_t)len);\n\t}\n\tif ((buf != mem) && (buf != NULL)) {\n\t\tmg_free(buf);\n\t}\n\n\treturn len;\n}\n\n\nint\nmg_printf(struct mg_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\tint result;\n\n\tva_start(ap, fmt);\n\tresult = mg_vprintf(conn, fmt, ap);\n\tva_end(ap);\n\n\treturn result;\n}\n\n\nint\nmg_url_decode(const char *src,\n              int src_len,\n              char *dst,\n              int dst_len,\n              int is_form_url_encoded)\n{\n\tint i, j, a, b;\n#define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))\n\n\tfor (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {\n\t\tif ((i < src_len - 2) && (src[i] == '%')\n\t\t    && isxdigit(*(const unsigned char *)(src + i + 1))\n\t\t    && isxdigit(*(const unsigned char *)(src + i + 2))) {\n\t\t\ta = tolower(*(const unsigned char *)(src + i + 1));\n\t\t\tb = tolower(*(const unsigned char *)(src + i + 2));\n\t\t\tdst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));\n\t\t\ti += 2;\n\t\t} else if (is_form_url_encoded && (src[i] == '+')) {\n\t\t\tdst[j] = ' ';\n\t\t} else {\n\t\t\tdst[j] = src[i];\n\t\t}\n\t}\n\n\tdst[j] = '\\0'; /* Null-terminate the destination */\n\n\treturn (i >= src_len) ? j : -1;\n}\n\n\nint\nmg_get_var(const char *data,\n           size_t data_len,\n           const char *name,\n           char *dst,\n           size_t dst_len)\n{\n\treturn mg_get_var2(data, data_len, name, dst, dst_len, 0);\n}\n\n\nint\nmg_get_var2(const char *data,\n            size_t data_len,\n            const char *name,\n            char *dst,\n            size_t dst_len,\n            size_t occurrence)\n{\n\tconst char *p, *e, *s;\n\tsize_t name_len;\n\tint len;\n\n\tif ((dst == NULL) || (dst_len == 0)) {\n\t\tlen = -2;\n\t} else if ((data == NULL) || (name == NULL) || (data_len == 0)) {\n\t\tlen = -1;\n\t\tdst[0] = '\\0';\n\t} else {\n\t\tname_len = strlen(name);\n\t\te = data + data_len;\n\t\tlen = -1;\n\t\tdst[0] = '\\0';\n\n\t\t/* data is \"var1=val1&var2=val2...\". Find variable first */\n\t\tfor (p = data; p + name_len < e; p++) {\n\t\t\tif (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')\n\t\t\t    && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {\n\t\t\t\t/* Point p to variable value */\n\t\t\t\tp += name_len + 1;\n\n\t\t\t\t/* Point s to the end of the value */\n\t\t\t\ts = (const char *)memchr(p, '&', (size_t)(e - p));\n\t\t\t\tif (s == NULL) {\n\t\t\t\t\ts = e;\n\t\t\t\t}\n\t\t\t\tDEBUG_ASSERT(s >= p);\n\t\t\t\tif (s < p) {\n\t\t\t\t\treturn -3;\n\t\t\t\t}\n\n\t\t\t\t/* Decode variable into destination buffer */\n\t\t\t\tlen = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);\n\n\t\t\t\t/* Redirect error code from -1 to -2 (destination buffer too\n\t\t\t\t * small). */\n\t\t\t\tif (len == -1) {\n\t\t\t\t\tlen = -2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn len;\n}\n\n\n/* HCP24: some changes to compare hole var_name */\nint\nmg_get_cookie(const char *cookie_header,\n              const char *var_name,\n              char *dst,\n              size_t dst_size)\n{\n\tconst char *s, *p, *end;\n\tint name_len, len = -1;\n\n\tif ((dst == NULL) || (dst_size == 0)) {\n\t\treturn -2;\n\t}\n\n\tdst[0] = '\\0';\n\tif ((var_name == NULL) || ((s = cookie_header) == NULL)) {\n\t\treturn -1;\n\t}\n\n\tname_len = (int)strlen(var_name);\n\tend = s + strlen(s);\n\tfor (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {\n\t\tif (s[name_len] == '=') {\n\t\t\t/* HCP24: now check is it a substring or a full cookie name */\n\t\t\tif ((s == cookie_header) || (s[-1] == ' ')) {\n\t\t\t\ts += name_len + 1;\n\t\t\t\tif ((p = strchr(s, ' ')) == NULL) {\n\t\t\t\t\tp = end;\n\t\t\t\t}\n\t\t\t\tif (p[-1] == ';') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tif ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {\n\t\t\t\t\ts++;\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tif ((size_t)(p - s) < dst_size) {\n\t\t\t\t\tlen = (int)(p - s);\n\t\t\t\t\tmg_strlcpy(dst, s, (size_t)len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlen = -3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn len;\n}\n\n\n#if defined(USE_WEBSOCKET) || defined(USE_LUA)\nstatic void\nbase64_encode(const unsigned char *src, int src_len, char *dst)\n{\n\tstatic const char *b64 =\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tint i, j, a, b, c;\n\n\tfor (i = j = 0; i < src_len; i += 3) {\n\t\ta = src[i];\n\t\tb = ((i + 1) >= src_len) ? 0 : src[i + 1];\n\t\tc = ((i + 2) >= src_len) ? 0 : src[i + 2];\n\n\t\tdst[j++] = b64[a >> 2];\n\t\tdst[j++] = b64[((a & 3) << 4) | (b >> 4)];\n\t\tif (i + 1 < src_len) {\n\t\t\tdst[j++] = b64[(b & 15) << 2 | (c >> 6)];\n\t\t}\n\t\tif (i + 2 < src_len) {\n\t\t\tdst[j++] = b64[c & 63];\n\t\t}\n\t}\n\twhile (j % 4 != 0) {\n\t\tdst[j++] = '=';\n\t}\n\tdst[j++] = '\\0';\n}\n#endif\n\n\n#if defined(USE_LUA)\nstatic unsigned char\nb64reverse(char letter)\n{\n\tif ((letter >= 'A') && (letter <= 'Z')) {\n\t\treturn letter - 'A';\n\t}\n\tif ((letter >= 'a') && (letter <= 'z')) {\n\t\treturn letter - 'a' + 26;\n\t}\n\tif ((letter >= '0') && (letter <= '9')) {\n\t\treturn letter - '0' + 52;\n\t}\n\tif (letter == '+') {\n\t\treturn 62;\n\t}\n\tif (letter == '/') {\n\t\treturn 63;\n\t}\n\tif (letter == '=') {\n\t\treturn 255; /* normal end */\n\t}\n\treturn 254; /* error */\n}\n\n\nstatic int\nbase64_decode(const unsigned char *src, int src_len, char *dst, size_t *dst_len)\n{\n\tint i;\n\tunsigned char a, b, c, d;\n\n\t*dst_len = 0;\n\n\tfor (i = 0; i < src_len; i += 4) {\n\t\ta = b64reverse(src[i]);\n\t\tif (a >= 254) {\n\t\t\treturn i;\n\t\t}\n\n\t\tb = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);\n\t\tif (b >= 254) {\n\t\t\treturn i + 1;\n\t\t}\n\n\t\tc = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);\n\t\tif (c == 254) {\n\t\t\treturn i + 2;\n\t\t}\n\n\t\td = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);\n\t\tif (d == 254) {\n\t\t\treturn i + 3;\n\t\t}\n\n\t\tdst[(*dst_len)++] = (a << 2) + (b >> 4);\n\t\tif (c != 255) {\n\t\t\tdst[(*dst_len)++] = (b << 4) + (c >> 2);\n\t\t\tif (d != 255) {\n\t\t\t\tdst[(*dst_len)++] = (c << 6) + d;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n#endif\n\n\nstatic int\nis_put_or_delete_method(const struct mg_connection *conn)\n{\n\tif (conn) {\n\t\tconst char *s = conn->request_info.request_method;\n\t\treturn (s != NULL) && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")\n\t\t                       || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));\n\t}\n\treturn 0;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nextention_matches_script(\n    struct mg_connection *conn, /* in: request (must be valid) */\n    const char *filename        /* in: filename  (must be valid) */\n    )\n{\n#if !defined(NO_CGI)\n\tif (match_prefix(conn->dom_ctx->config[CGI_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[CGI_EXTENSIONS]),\n\t                 filename) > 0) {\n\t\treturn 1;\n\t}\n#endif\n#if defined(USE_LUA)\n\tif (match_prefix(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS]),\n\t                 filename) > 0) {\n\t\treturn 1;\n\t}\n#endif\n#if defined(USE_DUKTAPE)\n\tif (match_prefix(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),\n\t                 filename) > 0) {\n\t\treturn 1;\n\t}\n#endif\n\t/* filename and conn could be unused, if all preocessor conditions\n\t * are false (no script language supported). */\n\t(void)filename;\n\t(void)conn;\n\n\treturn 0;\n}\n\n\n/* For given directory path, substitute it to valid index file.\n * Return 1 if index file has been found, 0 if not found.\n * If the file is found, it's stats is returned in stp. */\nstatic int\nsubstitute_index_file(struct mg_connection *conn,\n                      char *path,\n                      size_t path_len,\n                      struct mg_file_stat *filestat)\n{\n\tconst char *list = conn->dom_ctx->config[INDEX_FILES];\n\tstruct vec filename_vec;\n\tsize_t n = strlen(path);\n\tint found = 0;\n\n\t/* The 'path' given to us points to the directory. Remove all trailing\n\t * directory separator characters from the end of the path, and\n\t * then append single directory separator character. */\n\twhile ((n > 0) && (path[n - 1] == '/')) {\n\t\tn--;\n\t}\n\tpath[n] = '/';\n\n\t/* Traverse index files list. For each entry, append it to the given\n\t * path and see if the file exists. If it exists, break the loop */\n\twhile ((list = next_option(list, &filename_vec, NULL)) != NULL) {\n\t\t/* Ignore too long entries that may overflow path buffer */\n\t\tif ((filename_vec.len + 1) > (path_len - (n + 1))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Prepare full path to the index file */\n\t\tmg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);\n\n\t\t/* Does it exist? */\n\t\tif (mg_stat(conn, path, filestat)) {\n\t\t\t/* Yes it does, break the loop */\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If no index file exists, restore directory path */\n\tif (!found) {\n\t\tpath[n] = '\\0';\n\t}\n\n\treturn found;\n}\n#endif\n\n\nstatic void\ninterpret_uri(struct mg_connection *conn, /* in/out: request (must be valid) */\n              char *filename,             /* out: filename */\n              size_t filename_buf_len,    /* in: size of filename buffer */\n              struct mg_file_stat *filestat, /* out: file status structure */\n              int *is_found,                 /* out: file found (directly) */\n              int *is_script_resource,       /* out: handled by a script? */\n              int *is_websocket_request,     /* out: websocket connetion? */\n              int *is_put_or_delete_request  /* out: put/delete a file? */\n              )\n{\n\tchar const *accept_encoding;\n\n#if !defined(NO_FILES)\n\tconst char *uri = conn->request_info.local_uri;\n\tconst char *root = conn->dom_ctx->config[DOCUMENT_ROOT];\n\tconst char *rewrite;\n\tstruct vec a, b;\n\tptrdiff_t match_len;\n\tchar gz_path[PATH_MAX];\n\tint truncated;\n#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)\n\tchar *tmp_str;\n\tsize_t tmp_str_len, sep_pos;\n\tint allow_substitute_script_subresources;\n#endif\n#else\n\t(void)filename_buf_len; /* unused if NO_FILES is defined */\n#endif\n\n\t/* Step 1: Set all initially unknown outputs to zero */\n\tmemset(filestat, 0, sizeof(*filestat));\n\t*filename = 0;\n\t*is_found = 0;\n\t*is_script_resource = 0;\n\n\t/* Step 2: Check if the request attempts to modify the file system */\n\t*is_put_or_delete_request = is_put_or_delete_method(conn);\n\n/* Step 3: Check if it is a websocket request, and modify the document\n * root if required */\n#if defined(USE_WEBSOCKET)\n\t*is_websocket_request = is_websocket_protocol(conn);\n#if !defined(NO_FILES)\n\tif (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {\n\t\troot = conn->dom_ctx->config[WEBSOCKET_ROOT];\n\t}\n#endif /* !NO_FILES */\n#else  /* USE_WEBSOCKET */\n\t*is_websocket_request = 0;\n#endif /* USE_WEBSOCKET */\n\n\t/* Step 4: Check if gzip encoded response is allowed */\n\tconn->accept_gzip = 0;\n\tif ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\")) != NULL) {\n\t\tif (strstr(accept_encoding, \"gzip\") != NULL) {\n\t\t\tconn->accept_gzip = 1;\n\t\t}\n\t}\n\n#if !defined(NO_FILES)\n\t/* Step 5: If there is no root directory, don't look for files. */\n\t/* Note that root == NULL is a regular use case here. This occurs,\n\t * if all requests are handled by callbacks, so the WEBSOCKET_ROOT\n\t * config is not required. */\n\tif (root == NULL) {\n\t\t/* all file related outputs have already been set to 0, just return\n\t\t */\n\t\treturn;\n\t}\n\n\t/* Step 6: Determine the local file path from the root path and the\n\t * request uri. */\n\t/* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift\n\t * part of the path one byte on the right. */\n\tmg_snprintf(\n\t    conn, &truncated, filename, filename_buf_len - 1, \"%s%s\", root, uri);\n\n\tif (truncated) {\n\t\tgoto interpret_cleanup;\n\t}\n\n\t/* Step 7: URI rewriting */\n\trewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];\n\twhile ((rewrite = next_option(rewrite, &a, &b)) != NULL) {\n\t\tif ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            filename,\n\t\t\t            filename_buf_len - 1,\n\t\t\t            \"%.*s%s\",\n\t\t\t            (int)b.len,\n\t\t\t            b.ptr,\n\t\t\t            uri + match_len);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (truncated) {\n\t\tgoto interpret_cleanup;\n\t}\n\n\t/* Step 8: Check if the file exists at the server */\n\t/* Local file path and name, corresponding to requested URI\n\t * is now stored in \"filename\" variable. */\n\tif (mg_stat(conn, filename, filestat)) {\n\t\tint uri_len = (int)strlen(uri);\n\t\tint is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');\n\n\t\t/* 8.1: File exists. */\n\t\t*is_found = 1;\n\n\t\t/* 8.2: Check if it is a script type. */\n\t\tif (extention_matches_script(conn, filename)) {\n\t\t\t/* The request addresses a CGI resource, Lua script or\n\t\t\t * server-side javascript.\n\t\t\t * The URI corresponds to the script itself (like\n\t\t\t * /path/script.cgi), and there is no additional resource\n\t\t\t * path (like /path/script.cgi/something).\n\t\t\t * Requests that modify (replace or delete) a resource, like\n\t\t\t * PUT and DELETE requests, should replace/delete the script\n\t\t\t * file.\n\t\t\t * Requests that read or write from/to a resource, like GET and\n\t\t\t * POST requests, should call the script and return the\n\t\t\t * generated response. */\n\t\t\t*is_script_resource = (!*is_put_or_delete_request);\n\t\t}\n\n\t\t/* 8.3: If the request target is a directory, there could be\n\t\t * a substitute file (index.html, index.cgi, ...). */\n\t\tif (filestat->is_directory && is_uri_end_slash) {\n\t\t\t/* Use a local copy here, since substitute_index_file will\n\t\t\t * change the content of the file status */\n\t\t\tstruct mg_file_stat tmp_filestat;\n\t\t\tmemset(&tmp_filestat, 0, sizeof(tmp_filestat));\n\n\t\t\tif (substitute_index_file(\n\t\t\t        conn, filename, filename_buf_len, &tmp_filestat)) {\n\n\t\t\t\t/* Substitute file found. Copy stat to the output, then\n\t\t\t\t * check if the file is a script file */\n\t\t\t\t*filestat = tmp_filestat;\n\n\t\t\t\tif (extention_matches_script(conn, filename)) {\n\t\t\t\t\t/* Substitute file is a script file */\n\t\t\t\t\t*is_script_resource = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* Substitute file is a regular file */\n\t\t\t\t\t*is_script_resource = 0;\n\t\t\t\t\t*is_found = (mg_stat(conn, filename, filestat) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If there is no substitute file, the server could return\n\t\t\t * a directory listing in a later step */\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Step 9: Check for zipped files: */\n\t/* If we can't find the actual file, look for the file\n\t * with the same name but a .gz extension. If we find it,\n\t * use that and set the gzipped flag in the file struct\n\t * to indicate that the response need to have the content-\n\t * encoding: gzip header.\n\t * We can only do this if the browser declares support. */\n\tif (conn->accept_gzip) {\n\t\tmg_snprintf(\n\t\t    conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", filename);\n\n\t\tif (truncated) {\n\t\t\tgoto interpret_cleanup;\n\t\t}\n\n\t\tif (mg_stat(conn, gz_path, filestat)) {\n\t\t\tif (filestat) {\n\t\t\t\tfilestat->is_gzipped = 1;\n\t\t\t\t*is_found = 1;\n\t\t\t}\n\t\t\t/* Currently gz files can not be scripts. */\n\t\t\treturn;\n\t\t}\n\t}\n\n#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)\n\t/* Step 10: Script resources may handle sub-resources */\n\t/* Support PATH_INFO for CGI scripts. */\n\ttmp_str_len = strlen(filename);\n\ttmp_str = (char *)mg_malloc_ctx(tmp_str_len + PATH_MAX + 1, conn->phys_ctx);\n\tif (!tmp_str) {\n\t\t/* Out of memory */\n\t\tgoto interpret_cleanup;\n\t}\n\tmemcpy(tmp_str, filename, tmp_str_len + 1);\n\n\t/* Check config, if index scripts may have sub-resources */\n\tallow_substitute_script_subresources =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ALLOW_INDEX_SCRIPT_SUB_RES],\n\t                   \"yes\");\n\n\tsep_pos = tmp_str_len;\n\twhile (sep_pos > 0) {\n\t\tsep_pos--;\n\t\tif (tmp_str[sep_pos] == '/') {\n\t\t\tint is_script = 0, does_exist = 0;\n\n\t\t\ttmp_str[sep_pos] = 0;\n\t\t\tif (tmp_str[0]) {\n\t\t\t\tis_script = extention_matches_script(conn, tmp_str);\n\t\t\t\tdoes_exist = mg_stat(conn, tmp_str, filestat);\n\t\t\t}\n\n\t\t\tif (does_exist && is_script) {\n\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\tmemmove(filename + sep_pos + 2,\n\t\t\t\t        filename + sep_pos + 1,\n\t\t\t\t        strlen(filename + sep_pos + 1) + 1);\n\t\t\t\tconn->path_info = filename + sep_pos + 1;\n\t\t\t\tfilename[sep_pos + 1] = '/';\n\t\t\t\t*is_script_resource = 1;\n\t\t\t\t*is_found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (allow_substitute_script_subresources) {\n\t\t\t\tif (substitute_index_file(\n\t\t\t\t        conn, tmp_str, tmp_str_len + PATH_MAX, filestat)) {\n\n\t\t\t\t\t/* some intermediate directory has an index file */\n\t\t\t\t\tif (extention_matches_script(conn, tmp_str)) {\n\n\t\t\t\t\t\tchar *tmp_str2;\n\n\t\t\t\t\t\tDEBUG_TRACE(\"Substitute script %s serving path %s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            filename);\n\n\t\t\t\t\t\t/* this index file is a script */\n\t\t\t\t\t\ttmp_str2 = mg_strdup_ctx(filename + sep_pos + 1,\n\t\t\t\t\t\t                         conn->phys_ctx);\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            filename,\n\t\t\t\t\t\t            filename_buf_len,\n\t\t\t\t\t\t            \"%s//%s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            tmp_str2);\n\t\t\t\t\t\tmg_free(tmp_str2);\n\n\t\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\t\tmg_free(tmp_str);\n\t\t\t\t\t\t\tgoto interpret_cleanup;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsep_pos = strlen(tmp_str);\n\t\t\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\t\t\tconn->path_info = filename + sep_pos + 1;\n\t\t\t\t\t\t*is_script_resource = 1;\n\t\t\t\t\t\t*is_found = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tDEBUG_TRACE(\"Substitute file %s serving path %s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            filename);\n\n\t\t\t\t\t\t/* non-script files will not have sub-resources */\n\t\t\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\t\t\tconn->path_info = 0;\n\t\t\t\t\t\t*is_script_resource = 0;\n\t\t\t\t\t\t*is_found = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp_str[sep_pos] = '/';\n\t\t}\n\t}\n\n\tmg_free(tmp_str);\n\n#endif /* !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE) */\n#endif /* !defined(NO_FILES) */\n\treturn;\n\n#if !defined(NO_FILES)\n/* Reset all outputs */\ninterpret_cleanup:\n\tmemset(filestat, 0, sizeof(*filestat));\n\t*filename = 0;\n\t*is_found = 0;\n\t*is_script_resource = 0;\n\t*is_websocket_request = 0;\n\t*is_put_or_delete_request = 0;\n#endif /* !defined(NO_FILES) */\n}\n\n\n/* Check whether full request is buffered. Return:\n * -1  if request or response is malformed\n *  0  if request or response is not yet fully buffered\n * >0  actual request length, including last \\r\\n\\r\\n */\nstatic int\nget_http_header_len(const char *buf, int buflen)\n{\n\tint i;\n\tfor (i = 0; i < buflen; i++) {\n\t\t/* Do an unsigned comparison in some conditions below */\n\t\tconst unsigned char c = ((const unsigned char *)buf)[i];\n\n\t\tif ((c < 128) && ((char)c != '\\r') && ((char)c != '\\n')\n\t\t    && !isprint(c)) {\n\t\t\t/* abort scan as soon as one malformed character is found */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (i < buflen - 1) {\n\t\t\tif ((buf[i] == '\\n') && (buf[i + 1] == '\\n')) {\n\t\t\t\t/* Two newline, no carriage return - not standard compliant,\n\t\t\t\t * but\n\t\t\t\t * it\n\t\t\t\t * should be accepted */\n\t\t\t\treturn i + 2;\n\t\t\t}\n\t\t}\n\n\t\tif (i < buflen - 3) {\n\t\t\tif ((buf[i] == '\\r') && (buf[i + 1] == '\\n') && (buf[i + 2] == '\\r')\n\t\t\t    && (buf[i + 3] == '\\n')) {\n\t\t\t\t/* Two \\r\\n - standard compliant */\n\t\t\t\treturn i + 4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#if !defined(NO_CACHING)\n/* Convert month to the month number. Return -1 on error, or month number */\nstatic int\nget_month_index(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(month_names); i++) {\n\t\tif (!strcmp(s, month_names[i])) {\n\t\t\treturn (int)i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\n/* Parse UTC date-time string, and return the corresponding time_t value. */\nstatic time_t\nparse_date_string(const char *datetime)\n{\n\tchar month_str[32] = {0};\n\tint second, minute, hour, day, month, year;\n\ttime_t result = (time_t)0;\n\tstruct tm tm;\n\n\tif ((sscanf(datetime,\n\t            \"%d/%3s/%d %d:%d:%d\",\n\t            &day,\n\t            month_str,\n\t            &year,\n\t            &hour,\n\t            &minute,\n\t            &second) == 6) || (sscanf(datetime,\n\t                                      \"%d %3s %d %d:%d:%d\",\n\t                                      &day,\n\t                                      month_str,\n\t                                      &year,\n\t                                      &hour,\n\t                                      &minute,\n\t                                      &second) == 6)\n\t    || (sscanf(datetime,\n\t               \"%*3s, %d %3s %d %d:%d:%d\",\n\t               &day,\n\t               month_str,\n\t               &year,\n\t               &hour,\n\t               &minute,\n\t               &second) == 6) || (sscanf(datetime,\n\t                                         \"%d-%3s-%d %d:%d:%d\",\n\t                                         &day,\n\t                                         month_str,\n\t                                         &year,\n\t                                         &hour,\n\t                                         &minute,\n\t                                         &second) == 6)) {\n\t\tmonth = get_month_index(month_str);\n\t\tif ((month >= 0) && (year >= 1970)) {\n\t\t\tmemset(&tm, 0, sizeof(tm));\n\t\t\ttm.tm_year = year - 1900;\n\t\t\ttm.tm_mon = month;\n\t\t\ttm.tm_mday = day;\n\t\t\ttm.tm_hour = hour;\n\t\t\ttm.tm_min = minute;\n\t\t\ttm.tm_sec = second;\n\t\t\tresult = timegm(&tm);\n\t\t}\n\t}\n\n\treturn result;\n}\n#endif /* !NO_CACHING */\n\n\n/* Protect against directory disclosure attack by removing '..',\n * excessive '/' and '\\' characters */\nstatic void\nremove_double_dots_and_double_slashes(char *s)\n{\n\tchar *p = s;\n\n\twhile ((s[0] == '.') && (s[1] == '.')) {\n\t\ts++;\n\t}\n\n\twhile (*s != '\\0') {\n\t\t*p++ = *s++;\n\t\tif ((s[-1] == '/') || (s[-1] == '\\\\')) {\n\t\t\t/* Skip all following slashes, backslashes and double-dots */\n\t\t\twhile (s[0] != '\\0') {\n\t\t\t\tif ((s[0] == '/') || (s[0] == '\\\\')) {\n\t\t\t\t\ts++;\n\t\t\t\t} else if ((s[0] == '.') && (s[1] == '.')) {\n\t\t\t\t\ts += 2;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*p = '\\0';\n}\n\n\nstatic const struct {\n\tconst char *extension;\n\tsize_t ext_len;\n\tconst char *mime_type;\n} builtin_mime_types[] = {\n    /* IANA registered MIME types\n     * (http://www.iana.org/assignments/media-types)\n     * application types */\n    {\".doc\", 4, \"application/msword\"},\n    {\".eps\", 4, \"application/postscript\"},\n    {\".exe\", 4, \"application/octet-stream\"},\n    {\".js\", 3, \"application/javascript\"},\n    {\".json\", 5, \"application/json\"},\n    {\".pdf\", 4, \"application/pdf\"},\n    {\".ps\", 3, \"application/postscript\"},\n    {\".rtf\", 4, \"application/rtf\"},\n    {\".xhtml\", 6, \"application/xhtml+xml\"},\n    {\".xsl\", 4, \"application/xml\"},\n    {\".xslt\", 5, \"application/xml\"},\n\n    /* fonts */\n    {\".ttf\", 4, \"application/font-sfnt\"},\n    {\".cff\", 4, \"application/font-sfnt\"},\n    {\".otf\", 4, \"application/font-sfnt\"},\n    {\".aat\", 4, \"application/font-sfnt\"},\n    {\".sil\", 4, \"application/font-sfnt\"},\n    {\".pfr\", 4, \"application/font-tdpfr\"},\n    {\".woff\", 5, \"application/font-woff\"},\n\n    /* audio */\n    {\".mp3\", 4, \"audio/mpeg\"},\n    {\".oga\", 4, \"audio/ogg\"},\n    {\".ogg\", 4, \"audio/ogg\"},\n\n    /* image */\n    {\".gif\", 4, \"image/gif\"},\n    {\".ief\", 4, \"image/ief\"},\n    {\".jpeg\", 5, \"image/jpeg\"},\n    {\".jpg\", 4, \"image/jpeg\"},\n    {\".jpm\", 4, \"image/jpm\"},\n    {\".jpx\", 4, \"image/jpx\"},\n    {\".png\", 4, \"image/png\"},\n    {\".svg\", 4, \"image/svg+xml\"},\n    {\".tif\", 4, \"image/tiff\"},\n    {\".tiff\", 5, \"image/tiff\"},\n\n    /* model */\n    {\".wrl\", 4, \"model/vrml\"},\n\n    /* text */\n    {\".css\", 4, \"text/css\"},\n    {\".csv\", 4, \"text/csv\"},\n    {\".htm\", 4, \"text/html\"},\n    {\".html\", 5, \"text/html\"},\n    {\".sgm\", 4, \"text/sgml\"},\n    {\".shtm\", 5, \"text/html\"},\n    {\".shtml\", 6, \"text/html\"},\n    {\".txt\", 4, \"text/plain\"},\n    {\".xml\", 4, \"text/xml\"},\n\n    /* video */\n    {\".mov\", 4, \"video/quicktime\"},\n    {\".mp4\", 4, \"video/mp4\"},\n    {\".mpeg\", 5, \"video/mpeg\"},\n    {\".mpg\", 4, \"video/mpeg\"},\n    {\".ogv\", 4, \"video/ogg\"},\n    {\".qt\", 3, \"video/quicktime\"},\n\n    /* not registered types\n     * (http://reference.sitepoint.com/html/mime-types-full,\n     * http://www.hansenb.pdx.edu/DMKB/dict/tutorials/mime_typ.php, ..) */\n    {\".arj\", 4, \"application/x-arj-compressed\"},\n    {\".gz\", 3, \"application/x-gunzip\"},\n    {\".rar\", 4, \"application/x-arj-compressed\"},\n    {\".swf\", 4, \"application/x-shockwave-flash\"},\n    {\".tar\", 4, \"application/x-tar\"},\n    {\".tgz\", 4, \"application/x-tar-gz\"},\n    {\".torrent\", 8, \"application/x-bittorrent\"},\n    {\".ppt\", 4, \"application/x-mspowerpoint\"},\n    {\".xls\", 4, \"application/x-msexcel\"},\n    {\".zip\", 4, \"application/x-zip-compressed\"},\n    {\".aac\",\n     4,\n     \"audio/aac\"}, /* http://en.wikipedia.org/wiki/Advanced_Audio_Coding */\n    {\".aif\", 4, \"audio/x-aif\"},\n    {\".m3u\", 4, \"audio/x-mpegurl\"},\n    {\".mid\", 4, \"audio/x-midi\"},\n    {\".ra\", 3, \"audio/x-pn-realaudio\"},\n    {\".ram\", 4, \"audio/x-pn-realaudio\"},\n    {\".wav\", 4, \"audio/x-wav\"},\n    {\".bmp\", 4, \"image/bmp\"},\n    {\".ico\", 4, \"image/x-icon\"},\n    {\".pct\", 4, \"image/x-pct\"},\n    {\".pict\", 5, \"image/pict\"},\n    {\".rgb\", 4, \"image/x-rgb\"},\n    {\".webm\", 5, \"video/webm\"}, /* http://en.wikipedia.org/wiki/WebM */\n    {\".asf\", 4, \"video/x-ms-asf\"},\n    {\".avi\", 4, \"video/x-msvideo\"},\n    {\".m4v\", 4, \"video/x-m4v\"},\n    {NULL, 0, NULL}};\n\n\nconst char *\nmg_get_builtin_mime_type(const char *path)\n{\n\tconst char *ext;\n\tsize_t i, path_len;\n\n\tpath_len = strlen(path);\n\n\tfor (i = 0; builtin_mime_types[i].extension != NULL; i++) {\n\t\text = path + (path_len - builtin_mime_types[i].ext_len);\n\t\tif ((path_len > builtin_mime_types[i].ext_len)\n\t\t    && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {\n\t\t\treturn builtin_mime_types[i].mime_type;\n\t\t}\n\t}\n\n\treturn \"text/plain\";\n}\n\n\n/* Look at the \"path\" extension and figure what mime type it has.\n * Store mime type in the vector. */\nstatic void\nget_mime_type(struct mg_connection *conn, const char *path, struct vec *vec)\n{\n\tstruct vec ext_vec, mime_vec;\n\tconst char *list, *ext;\n\tsize_t path_len;\n\n\tpath_len = strlen(path);\n\n\tif ((conn == NULL) || (vec == NULL)) {\n\t\tif (vec != NULL) {\n\t\t\tmemset(vec, '\\0', sizeof(struct vec));\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Scan user-defined mime types first, in case user wants to\n\t * override default mime types. */\n\tlist = conn->dom_ctx->config[EXTRA_MIME_TYPES];\n\twhile ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {\n\t\t/* ext now points to the path suffix */\n\t\text = path + path_len - ext_vec.len;\n\t\tif (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {\n\t\t\t*vec = mime_vec;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvec->ptr = mg_get_builtin_mime_type(path);\n\tvec->len = strlen(vec->ptr);\n}\n\n\n/* Stringify binary data. Output buffer must be twice as big as input,\n * because each byte takes 2 bytes in string representation */\nstatic void\nbin2str(char *to, const unsigned char *p, size_t len)\n{\n\tstatic const char *hex = \"0123456789abcdef\";\n\n\tfor (; len--; p++) {\n\t\t*to++ = hex[p[0] >> 4];\n\t\t*to++ = hex[p[0] & 0x0f];\n\t}\n\t*to = '\\0';\n}\n\n\n/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.\n */\nchar *\nmg_md5(char buf[33], ...)\n{\n\tmd5_byte_t hash[16];\n\tconst char *p;\n\tva_list ap;\n\tmd5_state_t ctx;\n\n\tmd5_init(&ctx);\n\n\tva_start(ap, buf);\n\twhile ((p = va_arg(ap, const char *)) != NULL) {\n\t\tmd5_append(&ctx, (const md5_byte_t *)p, strlen(p));\n\t}\n\tva_end(ap);\n\n\tmd5_finish(&ctx, hash);\n\tbin2str(buf, hash, sizeof(hash));\n\treturn buf;\n}\n\n\n/* Check the user's password, return 1 if OK */\nstatic int\ncheck_password(const char *method,\n               const char *ha1,\n               const char *uri,\n               const char *nonce,\n               const char *nc,\n               const char *cnonce,\n               const char *qop,\n               const char *response)\n{\n\tchar ha2[32 + 1], expected_response[32 + 1];\n\n\t/* Some of the parameters may be NULL */\n\tif ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL)\n\t    || (qop == NULL) || (response == NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */\n\tif (strlen(response) != 32) {\n\t\treturn 0;\n\t}\n\n\tmg_md5(ha2, method, \":\", uri, NULL);\n\tmg_md5(expected_response,\n\t       ha1,\n\t       \":\",\n\t       nonce,\n\t       \":\",\n\t       nc,\n\t       \":\",\n\t       cnonce,\n\t       \":\",\n\t       qop,\n\t       \":\",\n\t       ha2,\n\t       NULL);\n\n\treturn mg_strcasecmp(response, expected_response) == 0;\n}\n\n\n/* Use the global passwords file, if specified by auth_gpass option,\n * or search for .htpasswd in the requested directory. */\nstatic void\nopen_auth_file(struct mg_connection *conn,\n               const char *path,\n               struct mg_file *filep)\n{\n\tif ((conn != NULL) && (conn->dom_ctx != NULL)) {\n\t\tchar name[PATH_MAX];\n\t\tconst char *p, *e,\n\t\t    *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];\n\t\tint truncated;\n\n\t\tif (gpass != NULL) {\n\t\t\t/* Use global passwords file */\n\t\t\tif (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Use mg_cry_internal here, since gpass has been configured. */\n\t\t\t\tmg_cry_internal(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t\t/* Important: using local struct mg_file to test path for\n\t\t\t * is_directory flag. If filep is used, mg_stat() makes it\n\t\t\t * appear as if auth file was opened.\n\t\t\t * TODO(mid): Check if this is still required after rewriting\n\t\t\t * mg_stat */\n\t\t} else if (mg_stat(conn, path, &filep->stat)\n\t\t           && filep->stat.is_directory) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            name,\n\t\t\t            sizeof(name),\n\t\t\t            \"%s/%s\",\n\t\t\t            path,\n\t\t\t            PASSWORDS_FILE_NAME);\n\n\t\t\tif (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Don't use mg_cry_internal here, but only a trace, since this\n\t\t\t\t * is\n\t\t\t\t * a typical case. It will occur for every directory\n\t\t\t\t * without a password file. */\n\t\t\t\tDEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t} else {\n\t\t\t/* Try to find .htpasswd in requested directory. */\n\t\t\tfor (p = path, e = p + strlen(p) - 1; e > p; e--) {\n\t\t\t\tif (e[0] == '/') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            name,\n\t\t\t            sizeof(name),\n\t\t\t            \"%.*s/%s\",\n\t\t\t            (int)(e - p),\n\t\t\t            p,\n\t\t\t            PASSWORDS_FILE_NAME);\n\n\t\t\tif (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Don't use mg_cry_internal here, but only a trace, since this\n\t\t\t\t * is\n\t\t\t\t * a typical case. It will occur for every directory\n\t\t\t\t * without a password file. */\n\t\t\t\tDEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/* Parsed Authorization header */\nstruct ah {\n\tchar *user, *uri, *cnonce, *response, *qop, *nc, *nonce;\n};\n\n\n/* Return 1 on success. Always initializes the ah structure. */\nstatic int\nparse_auth_header(struct mg_connection *conn,\n                  char *buf,\n                  size_t buf_size,\n                  struct ah *ah)\n{\n\tchar *name, *value, *s;\n\tconst char *auth_header;\n\tuint64_t nonce;\n\n\tif (!ah || !conn) {\n\t\treturn 0;\n\t}\n\n\t(void)memset(ah, 0, sizeof(*ah));\n\tif (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)\n\t    || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* Make modifiable copy of the auth header */\n\t(void)mg_strlcpy(buf, auth_header + 7, buf_size);\n\ts = buf;\n\n\t/* Parse authorization header */\n\tfor (;;) {\n\t\t/* Gobble initial spaces */\n\t\twhile (isspace(*(unsigned char *)s)) {\n\t\t\ts++;\n\t\t}\n\t\tname = skip_quoted(&s, \"=\", \" \", 0);\n\t\t/* Value is either quote-delimited, or ends at first comma or space.\n\t\t */\n\t\tif (s[0] == '\\\"') {\n\t\t\ts++;\n\t\t\tvalue = skip_quoted(&s, \"\\\"\", \" \", '\\\\');\n\t\t\tif (s[0] == ',') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = skip_quoted(&s, \", \", \" \", 0); /* IE uses commas, FF uses\n\t\t\t                                        * spaces */\n\t\t}\n\t\tif (*name == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!strcmp(name, \"username\")) {\n\t\t\tah->user = value;\n\t\t} else if (!strcmp(name, \"cnonce\")) {\n\t\t\tah->cnonce = value;\n\t\t} else if (!strcmp(name, \"response\")) {\n\t\t\tah->response = value;\n\t\t} else if (!strcmp(name, \"uri\")) {\n\t\t\tah->uri = value;\n\t\t} else if (!strcmp(name, \"qop\")) {\n\t\t\tah->qop = value;\n\t\t} else if (!strcmp(name, \"nc\")) {\n\t\t\tah->nc = value;\n\t\t} else if (!strcmp(name, \"nonce\")) {\n\t\t\tah->nonce = value;\n\t\t}\n\t}\n\n#if !defined(NO_NONCE_CHECK)\n\t/* Read the nonce from the response. */\n\tif (ah->nonce == NULL) {\n\t\treturn 0;\n\t}\n\ts = NULL;\n\tnonce = strtoull(ah->nonce, &s, 10);\n\tif ((s == NULL) || (*s != 0)) {\n\t\treturn 0;\n\t}\n\n\t/* Convert the nonce from the client to a number. */\n\tnonce ^= conn->dom_ctx->auth_nonce_mask;\n\n\t/* The converted number corresponds to the time the nounce has been\n\t * created. This should not be earlier than the server start. */\n\t/* Server side nonce check is valuable in all situations but one:\n\t * if the server restarts frequently, but the client should not see\n\t * that, so the server should accept nonces from previous starts. */\n\t/* However, the reasonable default is to not accept a nonce from a\n\t * previous start, so if anyone changed the access rights between\n\t * two restarts, a new login is required. */\n\tif (nonce < (uint64_t)conn->phys_ctx->start_time) {\n\t\t/* nonce is from a previous start of the server and no longer valid\n\t\t * (replay attack?) */\n\t\treturn 0;\n\t}\n\t/* Check if the nonce is too high, so it has not (yet) been used by the\n\t * server. */\n\tif (nonce >= ((uint64_t)conn->phys_ctx->start_time\n\t              + conn->dom_ctx->nonce_count)) {\n\t\treturn 0;\n\t}\n#else\n\t(void)nonce;\n#endif\n\n\t/* CGI needs it as REMOTE_USER */\n\tif (ah->user != NULL) {\n\t\tconn->request_info.remote_user =\n\t\t    mg_strdup_ctx(ah->user, conn->phys_ctx);\n\t} else {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic const char *\nmg_fgets(char *buf, size_t size, struct mg_file *filep, char **p)\n{\n#if defined(MG_USE_OPEN_FILE)\n\tconst char *eof;\n\tsize_t len;\n\tconst char *memend;\n#else\n\t(void)p; /* parameter is unused */\n#endif\n\n\tif (!filep) {\n\t\treturn NULL;\n\t}\n\n#if defined(MG_USE_OPEN_FILE)\n\tif ((filep->access.membuf != NULL) && (*p != NULL)) {\n\t\tmemend = (const char *)&filep->access.membuf[filep->stat.size];\n\t\t/* Search for \\n from p till the end of stream */\n\t\teof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));\n\t\tif (eof != NULL) {\n\t\t\teof += 1; /* Include \\n */\n\t\t} else {\n\t\t\teof = memend; /* Copy remaining data */\n\t\t}\n\t\tlen =\n\t\t    ((size_t)(eof - *p) > (size - 1)) ? (size - 1) : (size_t)(eof - *p);\n\t\tmemcpy(buf, *p, len);\n\t\tbuf[len] = '\\0';\n\t\t*p += len;\n\t\treturn len ? eof : NULL;\n\t} else /* filep->access.fp block below */\n#endif\n\t    if (filep->access.fp != NULL) {\n\t\treturn fgets(buf, (int)size, filep->access.fp);\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\n/* Define the initial recursion depth for procesesing htpasswd files that\n * include other htpasswd\n * (or even the same) files.  It is not difficult to provide a file or files\n * s.t. they force civetweb\n * to infinitely recurse and then crash.\n */\n#define INITIAL_DEPTH 9\n#if INITIAL_DEPTH <= 0\n#error Bad INITIAL_DEPTH for recursion, set to at least 1\n#endif\n\nstruct read_auth_file_struct {\n\tstruct mg_connection *conn;\n\tstruct ah ah;\n\tconst char *domain;\n\tchar buf[256 + 256 + 40];\n\tconst char *f_user;\n\tconst char *f_domain;\n\tconst char *f_ha1;\n};\n\n\nstatic int\nread_auth_file(struct mg_file *filep,\n               struct read_auth_file_struct *workdata,\n               int depth)\n{\n\tchar *p = NULL /* init if MG_USE_OPEN_FILE is not set */;\n\tint is_authorized = 0;\n\tstruct mg_file fp;\n\tsize_t l;\n\n\tif (!filep || !workdata || (0 == depth)) {\n\t\treturn 0;\n\t}\n\n/* Loop over passwords file */\n#if defined(MG_USE_OPEN_FILE)\n\tp = (char *)filep->access.membuf;\n#endif\n\twhile (mg_fgets(workdata->buf, sizeof(workdata->buf), filep, &p) != NULL) {\n\t\tl = strlen(workdata->buf);\n\t\twhile (l > 0) {\n\t\t\tif (isspace(workdata->buf[l - 1])\n\t\t\t    || iscntrl(workdata->buf[l - 1])) {\n\t\t\t\tl--;\n\t\t\t\tworkdata->buf[l] = 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (l < 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tworkdata->f_user = workdata->buf;\n\n\t\tif (workdata->f_user[0] == ':') {\n\t\t\t/* user names may not contain a ':' and may not be empty,\n\t\t\t * so lines starting with ':' may be used for a special purpose\n\t\t\t */\n\t\t\tif (workdata->f_user[1] == '#') {\n\t\t\t\t/* :# is a comment */\n\t\t\t\tcontinue;\n\t\t\t} else if (!strncmp(workdata->f_user + 1, \"include=\", 8)) {\n\t\t\t\tif (mg_fopen(workdata->conn,\n\t\t\t\t             workdata->f_user + 9,\n\t\t\t\t             MG_FOPEN_MODE_READ,\n\t\t\t\t             &fp)) {\n\t\t\t\t\tis_authorized = read_auth_file(&fp, workdata, depth - 1);\n\t\t\t\t\t(void)mg_fclose(\n\t\t\t\t\t    &fp.access); /* ignore error on read only file */\n\n\t\t\t\t\t/* No need to continue processing files once we have a\n\t\t\t\t\t * match, since nothing will reset it back\n\t\t\t\t\t * to 0.\n\t\t\t\t\t */\n\t\t\t\t\tif (is_authorized) {\n\t\t\t\t\t\treturn is_authorized;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t\t\t                \"%s: cannot open authorization file: %s\",\n\t\t\t\t\t                __func__,\n\t\t\t\t\t                workdata->buf);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* everything is invalid for the moment (might change in the\n\t\t\t * future) */\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tworkdata->f_domain = strchr(workdata->f_user, ':');\n\t\tif (workdata->f_domain == NULL) {\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\t\t*(char *)(workdata->f_domain) = 0;\n\t\t(workdata->f_domain)++;\n\n\t\tworkdata->f_ha1 = strchr(workdata->f_domain, ':');\n\t\tif (workdata->f_ha1 == NULL) {\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\t\t*(char *)(workdata->f_ha1) = 0;\n\t\t(workdata->f_ha1)++;\n\n\t\tif (!strcmp(workdata->ah.user, workdata->f_user)\n\t\t    && !strcmp(workdata->domain, workdata->f_domain)) {\n\t\t\treturn check_password(workdata->conn->request_info.request_method,\n\t\t\t                      workdata->f_ha1,\n\t\t\t                      workdata->ah.uri,\n\t\t\t                      workdata->ah.nonce,\n\t\t\t                      workdata->ah.nc,\n\t\t\t                      workdata->ah.cnonce,\n\t\t\t                      workdata->ah.qop,\n\t\t\t                      workdata->ah.response);\n\t\t}\n\t}\n\n\treturn is_authorized;\n}\n\n\n/* Authorize against the opened passwords file. Return 1 if authorized. */\nstatic int\nauthorize(struct mg_connection *conn, struct mg_file *filep, const char *realm)\n{\n\tstruct read_auth_file_struct workdata;\n\tchar buf[MG_BUF_LEN];\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&workdata, 0, sizeof(workdata));\n\tworkdata.conn = conn;\n\n\tif (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {\n\t\treturn 0;\n\t}\n\n\tif (realm) {\n\t\tworkdata.domain = realm;\n\t} else {\n\t\tworkdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t}\n\n\treturn read_auth_file(filep, &workdata, INITIAL_DEPTH);\n}\n\n\n/* Public function to check http digest authentication header */\nint\nmg_check_digest_access_authentication(struct mg_connection *conn,\n                                      const char *realm,\n                                      const char *filename)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tint auth;\n\n\tif (!conn || !filename) {\n\t\treturn -1;\n\t}\n\tif (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {\n\t\treturn -2;\n\t}\n\n\tauth = authorize(conn, &file, realm);\n\n\tmg_fclose(&file.access);\n\n\treturn auth;\n}\n\n\n/* Return 1 if request is authorised, 0 otherwise. */\nstatic int\ncheck_authorization(struct mg_connection *conn, const char *path)\n{\n\tchar fname[PATH_MAX];\n\tstruct vec uri_vec, filename_vec;\n\tconst char *list;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tint authorized = 1, truncated;\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\tlist = conn->dom_ctx->config[PROTECT_URI];\n\twhile ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {\n\t\tif (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            fname,\n\t\t\t            sizeof(fname),\n\t\t\t            \"%.*s\",\n\t\t\t            (int)filename_vec.len,\n\t\t\t            filename_vec.ptr);\n\n\t\t\tif (truncated\n\t\t\t    || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: cannot open %s: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                fname,\n\t\t\t\t                strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_file_opened(&file.access)) {\n\t\topen_auth_file(conn, path, &file);\n\t}\n\n\tif (is_file_opened(&file.access)) {\n\t\tauthorized = authorize(conn, &file, NULL);\n\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t}\n\n\treturn authorized;\n}\n\n\n/* Internal function. Assumes conn is valid */\nstatic void\nsend_authorization_request(struct mg_connection *conn, const char *realm)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tuint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);\n\n\tif (!realm) {\n\t\trealm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t}\n\n\t(void)pthread_mutex_lock(&conn->phys_ctx->nonce_mutex);\n\tnonce += conn->dom_ctx->nonce_count;\n\t++conn->dom_ctx->nonce_count;\n\t(void)pthread_mutex_unlock(&conn->phys_ctx->nonce_mutex);\n\n\tnonce ^= conn->dom_ctx->auth_nonce_mask;\n\tconn->status_code = 401;\n\tconn->must_close = 1;\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tmg_printf(conn, \"HTTP/1.1 401 Unauthorized\\r\\n\");\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\"\n\t          \"Content-Length: 0\\r\\n\"\n\t          \"WWW-Authenticate: Digest qop=\\\"auth\\\", realm=\\\"%s\\\", \"\n\t          \"nonce=\\\"%\" UINT64_FMT \"\\\"\\r\\n\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn),\n\t          realm,\n\t          nonce);\n}\n\n\n/* Interface function. Parameters are provided by the user, so do\n * at least some basic checks.\n */\nint\nmg_send_digest_access_authentication_request(struct mg_connection *conn,\n                                             const char *realm)\n{\n\tif (conn && conn->dom_ctx) {\n\t\tsend_authorization_request(conn, realm);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nis_authorized_for_put(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\t\tconst char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];\n\t\tint ret = 0;\n\n\t\tif (passfile != NULL\n\t\t    && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {\n\t\t\tret = authorize(conn, &file, NULL);\n\t\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t\t}\n\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n#endif\n\n\nint\nmg_modify_passwords_file(const char *fname,\n                         const char *domain,\n                         const char *user,\n                         const char *pass)\n{\n\tint found, i;\n\tchar line[512], u[512] = \"\", d[512] = \"\", ha1[33], tmp[PATH_MAX + 8];\n\tFILE *fp, *fp2;\n\n\tfound = 0;\n\tfp = fp2 = NULL;\n\n\t/* Regard empty password as no password - remove user record. */\n\tif ((pass != NULL) && (pass[0] == '\\0')) {\n\t\tpass = NULL;\n\t}\n\n\t/* Other arguments must not be empty */\n\tif ((fname == NULL) || (domain == NULL) || (user == NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* Using the given file format, user name and domain must not contain\n\t * ':'\n\t */\n\tif (strchr(user, ':') != NULL) {\n\t\treturn 0;\n\t}\n\tif (strchr(domain, ':') != NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Do not allow control characters like newline in user name and domain.\n\t * Do not allow excessively long names either. */\n\tfor (i = 0; ((i < 255) && (user[i] != 0)); i++) {\n\t\tif (iscntrl(user[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (user[i]) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; ((i < 255) && (domain[i] != 0)); i++) {\n\t\tif (iscntrl(domain[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (domain[i]) {\n\t\treturn 0;\n\t}\n\n\t/* The maximum length of the path to the password file is limited */\n\tif ((strlen(fname) + 4) >= PATH_MAX) {\n\t\treturn 0;\n\t}\n\n\t/* Create a temporary file name. Length has been checked before. */\n\tstrcpy(tmp, fname);\n\tstrcat(tmp, \".tmp\");\n\n\t/* Create the file if does not exist */\n\t/* Use of fopen here is OK, since fname is only ASCII */\n\tif ((fp = fopen(fname, \"a+\")) != NULL) {\n\t\t(void)fclose(fp);\n\t}\n\n\t/* Open the given file and temporary file */\n\tif ((fp = fopen(fname, \"r\")) == NULL) {\n\t\treturn 0;\n\t} else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\n\t/* Copy the stuff to temporary file */\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\tif (sscanf(line, \"%255[^:]:%255[^:]:%*s\", u, d) != 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tu[255] = 0;\n\t\td[255] = 0;\n\n\t\tif (!strcmp(u, user) && !strcmp(d, domain)) {\n\t\t\tfound++;\n\t\t\tif (pass != NULL) {\n\t\t\t\tmg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n\t\t\t\tfprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(fp2, \"%s\", line);\n\t\t}\n\t}\n\n\t/* If new user, just add it */\n\tif (!found && (pass != NULL)) {\n\t\tmg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n\t\tfprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n\t}\n\n\t/* Close files */\n\tfclose(fp);\n\tfclose(fp2);\n\n\t/* Put the temp file in place of real file */\n\tIGNORE_UNUSED_RESULT(remove(fname));\n\tIGNORE_UNUSED_RESULT(rename(tmp, fname));\n\n\treturn 1;\n}\n\n\nstatic int\nis_valid_port(unsigned long port)\n{\n\treturn (port <= 0xffff);\n}\n\n\nstatic int\nmg_inet_pton(int af, const char *src, void *dst, size_t dstlen)\n{\n\tstruct addrinfo hints, *res, *ressave;\n\tint func_ret = 0;\n\tint gai_ret;\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = af;\n\n\tgai_ret = getaddrinfo(src, NULL, &hints, &res);\n\tif (gai_ret != 0) {\n\t\t/* gai_strerror could be used to convert gai_ret to a string */\n\t\t/* POSIX return values: see\n\t\t * http://pubs.opengroup.org/onlinepubs/9699919799/functions/freeaddrinfo.html\n\t\t */\n\t\t/* Windows return values: see\n\t\t * https://msdn.microsoft.com/en-us/library/windows/desktop/ms738520%28v=vs.85%29.aspx\n\t\t */\n\t\treturn 0;\n\t}\n\n\tressave = res;\n\n\twhile (res) {\n\t\tif (dstlen >= (size_t)res->ai_addrlen) {\n\t\t\tmemcpy(dst, res->ai_addr, res->ai_addrlen);\n\t\t\tfunc_ret = 1;\n\t\t}\n\t\tres = res->ai_next;\n\t}\n\n\tfreeaddrinfo(ressave);\n\treturn func_ret;\n}\n\n\nstatic int\nconnect_socket(struct mg_context *ctx /* may be NULL */,\n               const char *host,\n               int port,\n               int use_ssl,\n               char *ebuf,\n               size_t ebuf_len,\n               SOCKET *sock /* output: socket, must not be NULL */,\n               union usa *sa /* output: socket address, must not be NULL  */\n               )\n{\n\tint ip_ver = 0;\n\tint conn_ret = -1;\n\t*sock = INVALID_SOCKET;\n\tmemset(sa, 0, sizeof(*sa));\n\n\tif (ebuf_len > 0) {\n\t\t*ebuf = 0;\n\t}\n\n\tif (host == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"NULL host\");\n\t\treturn 0;\n\t}\n\n\tif ((port <= 0) || !is_valid_port((unsigned)port)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"invalid port\");\n\t\treturn 0;\n\t}\n\n#if !defined(NO_SSL)\n#if !defined(NO_SSL_DL)\n#if defined(OPENSSL_API_1_1)\n\tif (use_ssl && (TLS_client_method == NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"SSL is not initialized\");\n\t\treturn 0;\n\t}\n#else\n\tif (use_ssl && (SSLv23_client_method == NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"SSL is not initialized\");\n\t\treturn 0;\n\t}\n\n#endif /* OPENSSL_API_1_1 */\n#else\n\t(void)use_ssl;\n#endif /* NO_SSL_DL */\n#else\n\t(void)use_ssl;\n#endif /* !defined(NO_SSL) */\n\n\tif (mg_inet_pton(AF_INET, host, &sa->sin, sizeof(sa->sin))) {\n\t\tsa->sin.sin_family = AF_INET;\n\t\tsa->sin.sin_port = htons((uint16_t)port);\n\t\tip_ver = 4;\n#if defined(USE_IPV6)\n\t} else if (mg_inet_pton(AF_INET6, host, &sa->sin6, sizeof(sa->sin6))) {\n\t\tsa->sin6.sin6_family = AF_INET6;\n\t\tsa->sin6.sin6_port = htons((uint16_t)port);\n\t\tip_ver = 6;\n\t} else if (host[0] == '[') {\n\t\t/* While getaddrinfo on Windows will work with [::1],\n\t\t * getaddrinfo on Linux only works with ::1 (without []). */\n\t\tsize_t l = strlen(host + 1);\n\t\tchar *h = (l > 1) ? mg_strdup_ctx(host + 1, ctx) : NULL;\n\t\tif (h) {\n\t\t\th[l - 1] = 0;\n\t\t\tif (mg_inet_pton(AF_INET6, h, &sa->sin6, sizeof(sa->sin6))) {\n\t\t\t\tsa->sin6.sin6_family = AF_INET6;\n\t\t\t\tsa->sin6.sin6_port = htons((uint16_t)port);\n\t\t\t\tip_ver = 6;\n\t\t\t}\n\t\t\tmg_free(h);\n\t\t}\n#endif\n\t}\n\n\tif (ip_ver == 0) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"host not found\");\n\t\treturn 0;\n\t}\n\n\tif (ip_ver == 4) {\n\t\t*sock = socket(PF_INET, SOCK_STREAM, 0);\n\t}\n#if defined(USE_IPV6)\n\telse if (ip_ver == 6) {\n\t\t*sock = socket(PF_INET6, SOCK_STREAM, 0);\n\t}\n#endif\n\n\tif (*sock == INVALID_SOCKET) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"socket(): %s\",\n\t\t            strerror(ERRNO));\n\t\treturn 0;\n\t}\n\n\tif (0 != set_non_blocking_mode(*sock)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"Cannot set socket to non-blocking: %s\",\n\t\t            strerror(ERRNO));\n\t\tclosesocket(*sock);\n\t\t*sock = INVALID_SOCKET;\n\t\treturn 0;\n\t}\n\n\tset_close_on_exec(*sock, fc(ctx));\n\n\tif (ip_ver == 4) {\n\t\t/* connected with IPv4 */\n\t\tconn_ret = connect(*sock,\n\t\t                   (struct sockaddr *)((void *)&sa->sin),\n\t\t                   sizeof(sa->sin));\n\t}\n#if defined(USE_IPV6)\n\telse if (ip_ver == 6) {\n\t\t/* connected with IPv6 */\n\t\tconn_ret = connect(*sock,\n\t\t                   (struct sockaddr *)((void *)&sa->sin6),\n\t\t                   sizeof(sa->sin6));\n\t}\n#endif\n\n#if defined(_WIN32)\n\tif (conn_ret != 0) {\n\t\tDWORD err = WSAGetLastError(); /* could return WSAEWOULDBLOCK */\n\t\tconn_ret = (int)err;\n#if !defined(EINPROGRESS)\n#define EINPROGRESS (WSAEWOULDBLOCK) /* Winsock equivalent */\n#endif                               /* if !defined(EINPROGRESS) */\n\t}\n#endif\n\n\tif ((conn_ret != 0) && (conn_ret != EINPROGRESS)) {\n\t\t/* Data for getsockopt */\n\t\tint sockerr = -1;\n\t\tvoid *psockerr = &sockerr;\n\n#if defined(_WIN32)\n\t\tint len = (int)sizeof(sockerr);\n#else\n\t\tsocklen_t len = (socklen_t)sizeof(sockerr);\n#endif\n\n\t\t/* Data for poll */\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\t\tint ms_wait = 10000; /* 10 second timeout */\n\n\t\t/* For a non-blocking socket, the connect sequence is:\n\t\t * 1) call connect (will not block)\n\t\t * 2) wait until the socket is ready for writing (select or poll)\n\t\t * 3) check connection state with getsockopt\n\t\t */\n\t\tpfd[0].fd = *sock;\n\t\tpfd[0].events = POLLOUT;\n\t\tpollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));\n\n\t\tif (pollres != 1) {\n\t\t\t/* Not connected */\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"connect(%s:%d): timeout\",\n\t\t\t            host,\n\t\t\t            port);\n\t\t\tclosesocket(*sock);\n\t\t\t*sock = INVALID_SOCKET;\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\tgetsockopt(*sock, SOL_SOCKET, SO_ERROR, (char *)psockerr, &len);\n#else\n\t\tgetsockopt(*sock, SOL_SOCKET, SO_ERROR, psockerr, &len);\n#endif\n\n\t\tif (sockerr != 0) {\n\t\t\t/* Not connected */\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"connect(%s:%d): error %s\",\n\t\t\t            host,\n\t\t\t            port,\n\t\t\t            strerror(sockerr));\n\t\t\tclosesocket(*sock);\n\t\t\t*sock = INVALID_SOCKET;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\nint\nmg_url_encode(const char *src, char *dst, size_t dst_len)\n{\n\tstatic const char *dont_escape = \"._-$,;~()\";\n\tstatic const char *hex = \"0123456789abcdef\";\n\tchar *pos = dst;\n\tconst char *end = dst + dst_len - 1;\n\n\tfor (; ((*src != '\\0') && (pos < end)); src++, pos++) {\n\t\tif (isalnum(*(const unsigned char *)src)\n\t\t    || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {\n\t\t\t*pos = *src;\n\t\t} else if (pos + 2 < end) {\n\t\t\tpos[0] = '%';\n\t\t\tpos[1] = hex[(*(const unsigned char *)src) >> 4];\n\t\t\tpos[2] = hex[(*(const unsigned char *)src) & 0xf];\n\t\t\tpos += 2;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*pos = '\\0';\n\treturn (*src == '\\0') ? (int)(pos - dst) : -1;\n}\n\n/* Return 0 on success, non-zero if an error occurs. */\n\nstatic int\nprint_dir_entry(struct de *de)\n{\n\tsize_t hrefsize;\n\tchar *href;\n\tchar size[64], mod[64];\n#if defined(REENTRANT_TIME)\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n#else\n\tstruct tm *tm;\n#endif\n\n\threfsize = PATH_MAX * 3; /* worst case */\n\thref = (char *)mg_malloc(hrefsize);\n\tif (href == NULL) {\n\t\treturn -1;\n\t}\n\tif (de->file.is_directory) {\n\t\tmg_snprintf(de->conn,\n\t\t            NULL, /* Buffer is big enough */\n\t\t            size,\n\t\t            sizeof(size),\n\t\t            \"%s\",\n\t\t            \"[DIRECTORY]\");\n\t} else {\n\t\t/* We use (signed) cast below because MSVC 6 compiler cannot\n\t\t * convert unsigned __int64 to double. Sigh. */\n\t\tif (de->file.size < 1024) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%d\",\n\t\t\t            (int)de->file.size);\n\t\t} else if (de->file.size < 0x100000) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fk\",\n\t\t\t            (double)de->file.size / 1024.0);\n\t\t} else if (de->file.size < 0x40000000) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fM\",\n\t\t\t            (double)de->file.size / 1048576);\n\t\t} else {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fG\",\n\t\t\t            (double)de->file.size / 1073741824);\n\t\t}\n\t}\n\n/* Note: mg_snprintf will not cause a buffer overflow above.\n * So, string truncation checks are not required here. */\n\n#if defined(REENTRANT_TIME)\n\tlocaltime_r(&de->file.last_modified, tm);\n#else\n\ttm = localtime(&de->file.last_modified);\n#endif\n\tif (tm != NULL) {\n\t\tstrftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", tm);\n\t} else {\n\t\tmg_strlcpy(mod, \"01-Jan-1970 00:00\", sizeof(mod));\n\t\tmod[sizeof(mod) - 1] = '\\0';\n\t}\n\tmg_url_encode(de->file_name, href, hrefsize);\n\tmg_printf(de->conn,\n\t          \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"\n\t          \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n\t          de->conn->request_info.local_uri,\n\t          href,\n\t          de->file.is_directory ? \"/\" : \"\",\n\t          de->file_name,\n\t          de->file.is_directory ? \"/\" : \"\",\n\t          mod,\n\t          size);\n\tmg_free(href);\n\treturn 0;\n}\n\n\n/* This function is called from send_directory() and used for\n * sorting directory entries by size, or name, or modification time.\n * On windows, __cdecl specification is needed in case if project is built\n * with __stdcall convention. qsort always requires __cdels callback. */\nstatic int WINCDECL\ncompare_dir_entries(const void *p1, const void *p2)\n{\n\tif (p1 && p2) {\n\t\tconst struct de *a = (const struct de *)p1, *b = (const struct de *)p2;\n\t\tconst char *query_string = a->conn->request_info.query_string;\n\t\tint cmp_result = 0;\n\n\t\tif (query_string == NULL) {\n\t\t\tquery_string = \"na\";\n\t\t}\n\n\t\tif (a->file.is_directory && !b->file.is_directory) {\n\t\t\treturn -1; /* Always put directories on top */\n\t\t} else if (!a->file.is_directory && b->file.is_directory) {\n\t\t\treturn 1; /* Always put directories on top */\n\t\t} else if (*query_string == 'n') {\n\t\t\tcmp_result = strcmp(a->file_name, b->file_name);\n\t\t} else if (*query_string == 's') {\n\t\t\tcmp_result = (a->file.size == b->file.size)\n\t\t\t                 ? 0\n\t\t\t                 : ((a->file.size > b->file.size) ? 1 : -1);\n\t\t} else if (*query_string == 'd') {\n\t\t\tcmp_result =\n\t\t\t    (a->file.last_modified == b->file.last_modified)\n\t\t\t        ? 0\n\t\t\t        : ((a->file.last_modified > b->file.last_modified) ? 1\n\t\t\t                                                           : -1);\n\t\t}\n\n\t\treturn (query_string[1] == 'd') ? -cmp_result : cmp_result;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nmust_hide_file(struct mg_connection *conn, const char *path)\n{\n\tif (conn && conn->dom_ctx) {\n\t\tconst char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";\n\t\tconst char *pattern = conn->dom_ctx->config[HIDE_FILES];\n\t\treturn (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)\n\t\t       || ((pattern != NULL)\n\t\t           && (match_prefix(pattern, strlen(pattern), path) > 0));\n\t}\n\treturn 0;\n}\n\n\nstatic int\nscan_directory(struct mg_connection *conn,\n               const char *dir,\n               void *data,\n               int (*cb)(struct de *, void *))\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tstruct de de;\n\tint truncated;\n\n\tif ((dirp = mg_opendir(conn, dir)) == NULL) {\n\t\treturn 0;\n\t} else {\n\t\tde.conn = conn;\n\n\t\twhile ((dp = mg_readdir(dirp)) != NULL) {\n\t\t\t/* Do not show current dir and hidden files */\n\t\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")\n\t\t\t    || must_hide_file(conn, dp->d_name)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmg_snprintf(\n\t\t\t    conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n\n\t\t\t/* If we don't memset stat structure to zero, mtime will have\n\t\t\t * garbage and strftime() will segfault later on in\n\t\t\t * print_dir_entry(). memset is required only if mg_stat()\n\t\t\t * fails. For more details, see\n\t\t\t * http://code.google.com/p/mongoose/issues/detail?id=79 */\n\t\t\tmemset(&de.file, 0, sizeof(de.file));\n\n\t\t\tif (truncated) {\n\t\t\t\t/* If the path is not complete, skip processing. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!mg_stat(conn, path, &de.file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                path,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t}\n\t\t\tde.file_name = dp->d_name;\n\t\t\tcb(&de, data);\n\t\t}\n\t\t(void)mg_closedir(dirp);\n\t}\n\treturn 1;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nremove_directory(struct mg_connection *conn, const char *dir)\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tstruct de de;\n\tint truncated;\n\tint ok = 1;\n\n\tif ((dirp = mg_opendir(conn, dir)) == NULL) {\n\t\treturn 0;\n\t} else {\n\t\tde.conn = conn;\n\n\t\twhile ((dp = mg_readdir(dirp)) != NULL) {\n\t\t\t/* Do not show current dir (but show hidden files as they will\n\t\t\t * also be removed) */\n\t\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmg_snprintf(\n\t\t\t    conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n\n\t\t\t/* If we don't memset stat structure to zero, mtime will have\n\t\t\t * garbage and strftime() will segfault later on in\n\t\t\t * print_dir_entry(). memset is required only if mg_stat()\n\t\t\t * fails. For more details, see\n\t\t\t * http://code.google.com/p/mongoose/issues/detail?id=79 */\n\t\t\tmemset(&de.file, 0, sizeof(de.file));\n\n\t\t\tif (truncated) {\n\t\t\t\t/* Do not delete anything shorter */\n\t\t\t\tok = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!mg_stat(conn, path, &de.file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                path,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t\tok = 0;\n\t\t\t}\n\n\t\t\tif (de.file.is_directory) {\n\t\t\t\tif (remove_directory(conn, path) == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* This will fail file is the file is in memory */\n\t\t\t\tif (mg_remove(conn, path) == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(void)mg_closedir(dirp);\n\n\t\tIGNORE_UNUSED_RESULT(rmdir(dir));\n\t}\n\n\treturn ok;\n}\n#endif\n\n\nstruct dir_scan_data {\n\tstruct de *entries;\n\tunsigned int num_entries;\n\tunsigned int arr_size;\n};\n\n\n/* Behaves like realloc(), but frees original pointer on failure */\nstatic void *\nrealloc2(void *ptr, size_t size)\n{\n\tvoid *new_ptr = mg_realloc(ptr, size);\n\tif (new_ptr == NULL) {\n\t\tmg_free(ptr);\n\t}\n\treturn new_ptr;\n}\n\n\nstatic int\ndir_scan_callback(struct de *de, void *data)\n{\n\tstruct dir_scan_data *dsd = (struct dir_scan_data *)data;\n\n\tif ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {\n\t\tdsd->arr_size *= 2;\n\t\tdsd->entries =\n\t\t    (struct de *)realloc2(dsd->entries,\n\t\t                          dsd->arr_size * sizeof(dsd->entries[0]));\n\t}\n\tif (dsd->entries == NULL) {\n\t\t/* TODO(lsm, low): propagate an error to the caller */\n\t\tdsd->num_entries = 0;\n\t} else {\n\t\tdsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);\n\t\tdsd->entries[dsd->num_entries].file = de->file;\n\t\tdsd->entries[dsd->num_entries].conn = de->conn;\n\t\tdsd->num_entries++;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_directory_request(struct mg_connection *conn, const char *dir)\n{\n\tunsigned int i;\n\tint sort_direction;\n\tstruct dir_scan_data data = {NULL, 0, 128};\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (!scan_directory(conn, dir, &data, dir_scan_callback)) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot open directory\\nopendir(%s): %s\",\n\t\t                   dir,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\tsort_direction = ((conn->request_info.query_string != NULL)\n\t                  && (conn->request_info.query_string[1] == 'd'))\n\t                     ? 'a'\n\t                     : 'd';\n\n\tconn->must_close = 1;\n\tmg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: close\\r\\n\"\n\t          \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\",\n\t          date);\n\tmg_printf(conn,\n\t          \"<html><head><title>Index of %s</title>\"\n\t          \"<style>th {text-align: left;}</style></head>\"\n\t          \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"\n\t          \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"\n\t          \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"\n\t          \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"\n\t          \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",\n\t          conn->request_info.local_uri,\n\t          conn->request_info.local_uri,\n\t          sort_direction,\n\t          sort_direction,\n\t          sort_direction);\n\n\t/* Print first entry - link to a parent directory */\n\tmg_printf(conn,\n\t          \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"\n\t          \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n\t          conn->request_info.local_uri,\n\t          \"..\",\n\t          \"Parent directory\",\n\t          \"-\",\n\t          \"-\");\n\n\t/* Sort and print directory entries */\n\tif (data.entries != NULL) {\n\t\tqsort(data.entries,\n\t\t      (size_t)data.num_entries,\n\t\t      sizeof(data.entries[0]),\n\t\t      compare_dir_entries);\n\t\tfor (i = 0; i < data.num_entries; i++) {\n\t\t\tprint_dir_entry(&data.entries[i]);\n\t\t\tmg_free(data.entries[i].file_name);\n\t\t}\n\t\tmg_free(data.entries);\n\t}\n\n\tmg_printf(conn, \"%s\", \"</table></body></html>\");\n\tconn->status_code = 200;\n}\n\n\n/* Send len bytes from the opened file to the client. */\nstatic void\nsend_file_data(struct mg_connection *conn,\n               struct mg_file *filep,\n               int64_t offset,\n               int64_t len)\n{\n\tchar buf[MG_BUF_LEN];\n\tint to_read, num_read, num_written;\n\tint64_t size;\n\n\tif (!filep || !conn) {\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tsize = (filep->stat.size > INT64_MAX) ? INT64_MAX\n\t                                      : (int64_t)(filep->stat.size);\n\toffset = (offset < 0) ? 0 : ((offset > size) ? size : offset);\n\n#if defined(MG_USE_OPEN_FILE)\n\tif ((len > 0) && (filep->access.membuf != NULL) && (size > 0)) {\n\t\t/* file stored in memory */\n\t\tif (len > size - offset) {\n\t\t\tlen = size - offset;\n\t\t}\n\t\tmg_write(conn, filep->access.membuf + offset, (size_t)len);\n\t} else /* else block below */\n#endif\n\t    if (len > 0 && filep->access.fp != NULL) {\n/* file stored on disk */\n#if defined(__linux__)\n\t\t/* sendfile is only available for Linux */\n\t\tif ((conn->ssl == 0) && (conn->throttle == 0)\n\t\t    && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],\n\t\t                       \"yes\"))) {\n\t\t\toff_t sf_offs = (off_t)offset;\n\t\t\tssize_t sf_sent;\n\t\t\tint sf_file = fileno(filep->access.fp);\n\t\t\tint loop_cnt = 0;\n\n\t\t\tdo {\n\t\t\t\t/* 2147479552 (0x7FFFF000) is a limit found by experiment on\n\t\t\t\t * 64 bit Linux (2^31 minus one memory page of 4k?). */\n\t\t\t\tsize_t sf_tosend =\n\t\t\t\t    (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);\n\t\t\t\tsf_sent =\n\t\t\t\t    sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);\n\t\t\t\tif (sf_sent > 0) {\n\t\t\t\t\tlen -= sf_sent;\n\t\t\t\t\toffset += sf_sent;\n\t\t\t\t} else if (loop_cnt == 0) {\n\t\t\t\t\t/* This file can not be sent using sendfile.\n\t\t\t\t\t * This might be the case for pseudo-files in the\n\t\t\t\t\t * /sys/ and /proc/ file system.\n\t\t\t\t\t * Use the regular user mode copy code instead. */\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (sf_sent == 0) {\n\t\t\t\t\t/* No error, but 0 bytes sent. May be EOF? */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tloop_cnt++;\n\n\t\t\t} while ((len > 0) && (sf_sent >= 0));\n\n\t\t\tif (sf_sent > 0) {\n\t\t\t\treturn; /* OK */\n\t\t\t}\n\n\t\t\t/* sf_sent<0 means error, thus fall back to the classic way */\n\t\t\t/* This is always the case, if sf_file is not a \"normal\" file,\n\t\t\t * e.g., for sending data from the output of a CGI process. */\n\t\t\toffset = (int64_t)sf_offs;\n\t\t}\n#endif\n\t\tif ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fseeko() failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t\tmg_send_http_error(\n\t\t\t    conn,\n\t\t\t    500,\n\t\t\t    \"%s\",\n\t\t\t    \"Error: Unable to access file at requested position.\");\n\t\t} else {\n\t\t\twhile (len > 0) {\n\t\t\t\t/* Calculate how much to read from the file in the buffer */\n\t\t\t\tto_read = sizeof(buf);\n\t\t\t\tif ((int64_t)to_read > len) {\n\t\t\t\t\tto_read = (int)len;\n\t\t\t\t}\n\n\t\t\t\t/* Read from file, exit the loop on error */\n\t\t\t\tif ((num_read =\n\t\t\t\t         (int)fread(buf, 1, (size_t)to_read, filep->access.fp))\n\t\t\t\t    <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Send read bytes to the client, exit the loop on error */\n\t\t\t\tif ((num_written = mg_write(conn, buf, (size_t)num_read))\n\t\t\t\t    != num_read) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Both read and were successful, adjust counters */\n\t\t\t\tlen -= num_written;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nparse_range_header(const char *header, int64_t *a, int64_t *b)\n{\n\treturn sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);\n}\n\n\nstatic void\nconstruct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat)\n{\n\tif ((filestat != NULL) && (buf != NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* All calls to construct_etag use 64 byte buffer */\n\t\t            buf,\n\t\t            buf_len,\n\t\t            \"\\\"%lx.%\" INT64_FMT \"\\\"\",\n\t\t            (unsigned long)filestat->last_modified,\n\t\t            filestat->size);\n\t}\n}\n\n\nstatic void\nfclose_on_exec(struct mg_file_access *filep, struct mg_connection *conn)\n{\n\tif (filep != NULL && filep->fp != NULL) {\n#if defined(_WIN32)\n\t\t(void)conn; /* Unused. */\n#else\n\t\tif (fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC) != 0) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n#endif\n\t}\n}\n\n\n#if defined(USE_ZLIB)\n#include \"mod_zlib.inl\"\n#endif\n\n\nstatic void\nhandle_static_file_request(struct mg_connection *conn,\n                           const char *path,\n                           struct mg_file *filep,\n                           const char *mime_type,\n                           const char *additional_headers)\n{\n\tchar date[64], lm[64], etag[64];\n\tchar range[128]; /* large enough, so there will be no overflow */\n\tconst char *msg = \"OK\", *hdr;\n\ttime_t curtime = time(NULL);\n\tint64_t cl, r1, r2;\n\tstruct vec mime_vec;\n\tint n, truncated;\n\tchar gz_path[PATH_MAX];\n\tconst char *encoding = \"\";\n\tconst char *cors1, *cors2, *cors3;\n\tint is_head_request;\n\n#if defined(USE_ZLIB)\n\t/* Compression is allowed, unless there is a reason not to use compression.\n\t * If the file is already compressed, too small or a \"range\" request was\n\t * made, on the fly compression is not possible. */\n\tint allow_on_the_fly_compression = 1;\n#endif\n\n\tif ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tis_head_request = !strcmp(conn->request_info.request_method, \"HEAD\");\n\n\tif (mime_type == NULL) {\n\t\tget_mime_type(conn, path, &mime_vec);\n\t} else {\n\t\tmime_vec.ptr = mime_type;\n\t\tmime_vec.len = strlen(mime_type);\n\t}\n\tif (filep->stat.size > INT64_MAX) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: File size is too large to send\\n%\" INT64_FMT,\n\t\t                   filep->stat.size);\n\t\treturn;\n\t}\n\tcl = (int64_t)filep->stat.size;\n\tconn->status_code = 200;\n\trange[0] = '\\0';\n\n#if defined(USE_ZLIB)\n\t/* if this file is in fact a pre-gzipped file, rewrite its filename\n\t * it's important to rewrite the filename after resolving\n\t * the mime type from it, to preserve the actual file's type */\n\tif (!conn->accept_gzip) {\n\t\tallow_on_the_fly_compression = 0;\n\t}\n#endif\n\n\tif (filep->stat.is_gzipped) {\n\t\tmg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", path);\n\n\t\tif (truncated) {\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: Path of zipped file too long (%s)\",\n\t\t\t                   path);\n\t\t\treturn;\n\t\t}\n\n\t\tpath = gz_path;\n\t\tencoding = \"Content-Encoding: gzip\\r\\n\";\n\n#if defined(USE_ZLIB)\n\t\t/* File is already compressed. No \"on the fly\" compression. */\n\t\tallow_on_the_fly_compression = 0;\n#endif\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot open file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tfclose_on_exec(&filep->access, conn);\n\n\t/* If \"Range\" request was made: parse header, send only selected part\n\t * of the file. */\n\tr1 = r2 = 0;\n\thdr = mg_get_header(conn, \"Range\");\n\tif ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)\n\t    && (r1 >= 0) && (r2 >= 0)) {\n\t\t/* actually, range requests don't play well with a pre-gzipped\n\t\t * file (since the range is specified in the uncompressed space) */\n\t\tif (filep->stat.is_gzipped) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn,\n\t\t\t    416, /* 416 = Range Not Satisfiable */\n\t\t\t    \"%s\",\n\t\t\t    \"Error: Range requests in gzipped files are not supported\");\n\t\t\t(void)mg_fclose(\n\t\t\t    &filep->access); /* ignore error on read only file */\n\t\t\treturn;\n\t\t}\n\t\tconn->status_code = 206;\n\t\tcl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* range buffer is big enough */\n\t\t            range,\n\t\t            sizeof(range),\n\t\t            \"Content-Range: bytes \"\n\t\t            \"%\" INT64_FMT \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",\n\t\t            r1,\n\t\t            r1 + cl - 1,\n\t\t            filep->stat.size);\n\t\tmsg = \"Partial Content\";\n\n#if defined(USE_ZLIB)\n\t\t/* Do not compress ranges. */\n\t\tallow_on_the_fly_compression = 0;\n#endif\n\t}\n\n/* Do not compress small files. Small files do not benefit from file\n * compression, but there is still some overhead. */\n#if defined(USE_ZLIB)\n\tif (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {\n\t\t/* File is below the size limit. */\n\t\tallow_on_the_fly_compression = 0;\n\t}\n#endif\n\n\t/* Standard CORS header */\n\thdr = mg_get_header(conn, \"Origin\");\n\tif (hdr) {\n\t\t/* Cross-origin resource sharing (CORS), see\n\t\t * http://www.html5rocks.com/en/tutorials/cors/,\n\t\t * http://www.html5rocks.com/static/images/cors_server_flowchart.png\n\t\t * -\n\t\t * preflight is not supported for files. */\n\t\tcors1 = \"Access-Control-Allow-Origin: \";\n\t\tcors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tcors3 = \"\\r\\n\";\n\t} else {\n\t\tcors1 = cors2 = cors3 = \"\";\n\t}\n\n\t/* Prepare Etag, Date, Last-Modified headers. Must be in UTC,\n\t * according to\n\t * http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3 */\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tgmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);\n\tconstruct_etag(etag, sizeof(etag), &filep->stat);\n\n\t/* Send header */\n\t(void)mg_printf(conn,\n\t                \"HTTP/1.1 %d %s\\r\\n\"\n\t                \"%s%s%s\" /* CORS */\n\t                \"Date: %s\\r\\n\"\n\t                \"Last-Modified: %s\\r\\n\"\n\t                \"Etag: %s\\r\\n\"\n\t                \"Content-Type: %.*s\\r\\n\"\n\t                \"Connection: %s\\r\\n\",\n\t                conn->status_code,\n\t                msg,\n\t                cors1,\n\t                cors2,\n\t                cors3,\n\t                date,\n\t                lm,\n\t                etag,\n\t                (int)mime_vec.len,\n\t                mime_vec.ptr,\n\t                suggest_connection_header(conn));\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\n#if defined(USE_ZLIB)\n\t/* On the fly compression allowed */\n\tif (allow_on_the_fly_compression) {\n\t\t/* For on the fly compression, we don't know the content size in\n\t\t * advance, so we have to use chunked encoding */\n\t\t(void)mg_printf(conn,\n\t\t                \"Content-Encoding: gzip\\r\\n\"\n\t\t                \"Transfer-Encoding: chunked\\r\\n\");\n\t} else\n#endif\n\t{\n\t\t/* Without on-the-fly compression, we know the content-length\n\t\t * and we can use ranges (with on-the-fly compression we cannot).\n\t\t * So we send these response headers only in this case. */\n\t\t(void)mg_printf(conn,\n\t\t                \"Content-Length: %\" INT64_FMT \"\\r\\n\"\n\t\t                \"Accept-Ranges: bytes\\r\\n\"\n\t\t                \"%s\" /* range */\n\t\t                \"%s\" /* encoding */,\n\t\t                cl,\n\t\t                range,\n\t\t                encoding);\n\t}\n\n\t/* The previous code must not add any header starting with X- to make\n\t * sure no one of the additional_headers is included twice */\n\tif (additional_headers != NULL) {\n\t\t(void)mg_printf(conn,\n\t\t                \"%.*s\\r\\n\\r\\n\",\n\t\t                (int)strlen(additional_headers),\n\t\t                additional_headers);\n\t} else {\n\t\t(void)mg_printf(conn, \"\\r\\n\");\n\t}\n\n\tif (!is_head_request) {\n#if defined(USE_ZLIB)\n\t\tif (allow_on_the_fly_compression) {\n\t\t\t/* Compress and send */\n\t\t\tsend_compressed_data(conn, filep);\n\t\t} else\n#endif\n\t\t{\n\t\t\t/* Send file directly */\n\t\t\tsend_file_data(conn, filep, r1, cl);\n\t\t}\n\t}\n\t(void)mg_fclose(&filep->access); /* ignore error on read only file */\n}\n\n\n#if !defined(NO_CACHING)\n/* Return True if we should reply 304 Not Modified. */\nstatic int\nis_not_modified(const struct mg_connection *conn,\n                const struct mg_file_stat *filestat)\n{\n\tchar etag[64];\n\tconst char *ims = mg_get_header(conn, \"If-Modified-Since\");\n\tconst char *inm = mg_get_header(conn, \"If-None-Match\");\n\tconstruct_etag(etag, sizeof(etag), filestat);\n\n\treturn ((inm != NULL) && !mg_strcasecmp(etag, inm))\n\t       || ((ims != NULL)\n\t           && (filestat->last_modified <= parse_date_string(ims)));\n}\n\nstatic void\nhandle_not_modified_static_file_request(struct mg_connection *conn,\n                                        struct mg_file *filep)\n{\n\tchar date[64], lm[64], etag[64];\n\ttime_t curtime = time(NULL);\n\n\tif ((conn == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\tconn->status_code = 304;\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tgmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);\n\tconstruct_etag(etag, sizeof(etag), &filep->stat);\n\n\t(void)mg_printf(conn,\n\t                \"HTTP/1.1 %d %s\\r\\n\"\n\t                \"Date: %s\\r\\n\",\n\t                conn->status_code,\n\t                mg_get_response_code_text(conn, conn->status_code),\n\t                date);\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\t(void)mg_printf(conn,\n\t                \"Last-Modified: %s\\r\\n\"\n\t                \"Etag: %s\\r\\n\"\n\t                \"Connection: %s\\r\\n\"\n\t                \"\\r\\n\",\n\t                lm,\n\t                etag,\n\t                suggest_connection_header(conn));\n}\n#endif\n\n\nvoid\nmg_send_file(struct mg_connection *conn, const char *path)\n{\n\tmg_send_mime_file(conn, path, NULL);\n}\n\n\nvoid\nmg_send_mime_file(struct mg_connection *conn,\n                  const char *path,\n                  const char *mime_type)\n{\n\tmg_send_mime_file2(conn, path, mime_type, NULL);\n}\n\n\nvoid\nmg_send_mime_file2(struct mg_connection *conn,\n                   const char *path,\n                   const char *mime_type,\n                   const char *additional_headers)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (!conn) {\n\t\t/* No conn */\n\t\treturn;\n\t}\n\n\tif (mg_stat(conn, path, &file.stat)) {\n#if !defined(NO_CACHING)\n\t\tif (is_not_modified(conn, &file.stat)) {\n\t\t\t/* Send 304 \"Not Modified\" - this must not send any body data */\n\t\t\thandle_not_modified_static_file_request(conn, &file);\n\t\t} else\n#endif /* NO_CACHING */\n\t\t    if (file.stat.is_directory) {\n\t\t\tif (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t\t\t                   \"yes\")) {\n\t\t\t\thandle_directory_request(conn, path);\n\t\t\t} else {\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   403,\n\t\t\t\t                   \"%s\",\n\t\t\t\t                   \"Error: Directory listing denied\");\n\t\t\t}\n\t\t} else {\n\t\t\thandle_static_file_request(\n\t\t\t    conn, path, &file, mime_type, additional_headers);\n\t\t}\n\t} else {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Error: File not found\");\n\t}\n}\n\n\n/* For a given PUT path, create all intermediate subdirectories.\n * Return  0  if the path itself is a directory.\n * Return  1  if the path leads to a file.\n * Return -1  for if the path is too long.\n * Return -2  if path can not be created.\n*/\nstatic int\nput_dir(struct mg_connection *conn, const char *path)\n{\n\tchar buf[PATH_MAX];\n\tconst char *s, *p;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tsize_t len;\n\tint res = 1;\n\n\tfor (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {\n\t\tlen = (size_t)(p - path);\n\t\tif (len >= sizeof(buf)) {\n\t\t\t/* path too long */\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf, path, len);\n\t\tbuf[len] = '\\0';\n\n\t\t/* Try to create intermediate directory */\n\t\tDEBUG_TRACE(\"mkdir(%s)\", buf);\n\t\tif (!mg_stat(conn, buf, &file.stat) && mg_mkdir(conn, buf, 0755) != 0) {\n\t\t\t/* path does not exixt and can not be created */\n\t\t\tres = -2;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Is path itself a directory? */\n\t\tif (p[1] == '\\0') {\n\t\t\tres = 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\nstatic void\nremove_bad_file(const struct mg_connection *conn, const char *path)\n{\n\tint r = mg_remove(conn, path);\n\tif (r != 0) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Cannot remove invalid file %s\",\n\t\t                __func__,\n\t\t                path);\n\t}\n}\n\n\nlong long\nmg_store_body(struct mg_connection *conn, const char *path)\n{\n\tchar buf[MG_BUF_LEN];\n\tlong long len = 0;\n\tint ret, n;\n\tstruct mg_file fi;\n\n\tif (conn->consumed_content != 0) {\n\t\tmg_cry_internal(conn, \"%s: Contents already consumed\", __func__);\n\t\treturn -11;\n\t}\n\n\tret = put_dir(conn, path);\n\tif (ret < 0) {\n\t\t/* -1 for path too long,\n\t\t * -2 for path can not be created. */\n\t\treturn ret;\n\t}\n\tif (ret != 1) {\n\t\t/* Return 0 means, path itself is a directory. */\n\t\treturn 0;\n\t}\n\n\tif (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {\n\t\treturn -12;\n\t}\n\n\tret = mg_read(conn, buf, sizeof(buf));\n\twhile (ret > 0) {\n\t\tn = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);\n\t\tif (n != ret) {\n\t\t\t(void)mg_fclose(\n\t\t\t    &fi.access); /* File is bad and will be removed anyway. */\n\t\t\tremove_bad_file(conn, path);\n\t\t\treturn -13;\n\t\t}\n\t\tlen += ret;\n\t\tret = mg_read(conn, buf, sizeof(buf));\n\t}\n\n\t/* File is open for writing. If fclose fails, there was probably an\n\t * error flushing the buffer to disk, so the file on disk might be\n\t * broken. Delete it and return an error to the caller. */\n\tif (mg_fclose(&fi.access) != 0) {\n\t\tremove_bad_file(conn, path);\n\t\treturn -14;\n\t}\n\n\treturn len;\n}\n\n\n/* Parse a buffer:\n * Forward the string pointer till the end of a word, then\n * terminate it and forward till the begin of the next word.\n */\nstatic int\nskip_to_end_of_word_and_terminate(char **ppw, int eol)\n{\n\t/* Forward until a space is found - use isgraph here */\n\t/* See http://www.cplusplus.com/reference/cctype/ */\n\twhile (isgraph(**ppw)) {\n\t\t(*ppw)++;\n\t}\n\n\t/* Check end of word */\n\tif (eol) {\n\t\t/* must be a end of line */\n\t\tif ((**ppw != '\\r') && (**ppw != '\\n')) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* must be a end of a word, but not a line */\n\t\tif (**ppw != ' ') {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Terminate and forward to the next word */\n\tdo {\n\t\t**ppw = 0;\n\t\t(*ppw)++;\n\t} while ((**ppw) && isspace(**ppw));\n\n\t/* Check after term */\n\tif (!eol) {\n\t\t/* if it's not the end of line, there must be a next word */\n\t\tif (!isgraph(**ppw)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* ok */\n\treturn 1;\n}\n\n\n/* Parse HTTP headers from the given buffer, advance buf pointer\n * to the point where parsing stopped.\n * All parameters must be valid pointers (not NULL).\n * Return <0 on error. */\nstatic int\nparse_http_headers(char **buf, struct mg_header hdr[MG_MAX_HEADERS])\n{\n\tint i;\n\tint num_headers = 0;\n\n\tfor (i = 0; i < (int)MG_MAX_HEADERS; i++) {\n\t\tchar *dp = *buf;\n\t\twhile ((*dp != ':') && (*dp >= 33) && (*dp <= 126)) {\n\t\t\tdp++;\n\t\t}\n\t\tif (dp == *buf) {\n\t\t\t/* End of headers reached. */\n\t\t\tbreak;\n\t\t}\n\t\tif (*dp != ':') {\n\t\t\t/* This is not a valid field. */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* End of header key (*dp == ':') */\n\t\t/* Truncate here and set the key name */\n\t\t*dp = 0;\n\t\thdr[i].name = *buf;\n\t\tdo {\n\t\t\tdp++;\n\t\t} while (*dp == ' ');\n\n\t\t/* The rest of the line is the value */\n\t\thdr[i].value = dp;\n\t\t*buf = dp + strcspn(dp, \"\\r\\n\");\n\t\tif (((*buf)[0] != '\\r') || ((*buf)[1] != '\\n')) {\n\t\t\t*buf = NULL;\n\t\t}\n\n\t\tnum_headers = i + 1;\n\t\tif (*buf) {\n\t\t\t(*buf)[0] = 0;\n\t\t\t(*buf)[1] = 0;\n\t\t\t*buf += 2;\n\t\t} else {\n\t\t\t*buf = dp;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((*buf)[0] == '\\r') {\n\t\t\t/* This is the end of the header */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn num_headers;\n}\n\n\nstruct mg_http_method_info {\n\tconst char *name;\n\tint request_has_body;\n\tint response_has_body;\n\tint is_safe;\n\tint is_idempotent;\n\tint is_cacheable;\n};\n\n\n/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */\nstatic struct mg_http_method_info http_methods[] = {\n    /* HTTP (RFC 2616) */\n    {\"GET\", 0, 1, 1, 1, 1},\n    {\"POST\", 1, 1, 0, 0, 0},\n    {\"PUT\", 1, 0, 0, 1, 0},\n    {\"DELETE\", 0, 0, 0, 1, 0},\n    {\"HEAD\", 0, 0, 1, 1, 1},\n    {\"OPTIONS\", 0, 0, 1, 1, 0},\n    {\"CONNECT\", 1, 1, 0, 0, 0},\n    /* TRACE method (RFC 2616) is not supported for security reasons */\n\n    /* PATCH method (RFC 5789) */\n    {\"PATCH\", 1, 0, 0, 0, 0},\n    /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */\n\n    /* WEBDAV (RFC 2518) */\n    {\"PROPFIND\", 0, 1, 1, 1, 0},\n    /* http://www.webdav.org/specs/rfc4918.html, 9.1:\n     * Some PROPFIND results MAY be cached, with care,\n     * as there is no cache validation mechanism for\n     * most properties. This method is both safe and\n     * idempotent (see Section 9.1 of [RFC2616]). */\n    {\"MKCOL\", 0, 0, 0, 1, 0},\n    /* http://www.webdav.org/specs/rfc4918.html, 9.1:\n     * When MKCOL is invoked without a request body,\n     * the newly created collection SHOULD have no\n     * members. A MKCOL request message may contain\n     * a message body. The precise behavior of a MKCOL\n     * request when the body is present is undefined,\n     * ... ==> We do not support MKCOL with body data.\n     * This method is idempotent, but not safe (see\n     * Section 9.1 of [RFC2616]). Responses to this\n     * method MUST NOT be cached. */\n\n    /* Unsupported WEBDAV Methods: */\n    /* PROPPATCH, COPY, MOVE, LOCK, UNLOCK (RFC 2518) */\n    /* + 11 methods from RFC 3253 */\n    /* ORDERPATCH (RFC 3648) */\n    /* ACL (RFC 3744) */\n    /* SEARCH (RFC 5323) */\n    /* + MicroSoft extensions\n     * https://msdn.microsoft.com/en-us/library/aa142917.aspx */\n\n    /* REPORT method (RFC 3253) */\n    {\"REPORT\", 1, 1, 1, 1, 1},\n    /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */\n    /* It was defined for WEBDAV in RFC 3253, Sec. 3.6\n     * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems\n     * to be useful for REST in case a \"GET request with body\" is\n     * required. */\n\n    {NULL, 0, 0, 0, 0, 0}\n    /* end of list */\n};\n\n\nstatic const struct mg_http_method_info *\nget_http_method_info(const char *method)\n{\n\t/* Check if the method is known to the server. The list of all known\n\t * HTTP methods can be found here at\n\t * http://www.iana.org/assignments/http-methods/http-methods.xhtml\n\t */\n\tconst struct mg_http_method_info *m = http_methods;\n\n\twhile (m->name) {\n\t\tif (!strcmp(m->name, method)) {\n\t\t\treturn m;\n\t\t}\n\t\tm++;\n\t}\n\treturn NULL;\n}\n\n\nstatic int\nis_valid_http_method(const char *method)\n{\n\treturn (get_http_method_info(method) != NULL);\n}\n\n\n/* Parse HTTP request, fill in mg_request_info structure.\n * This function modifies the buffer by NUL-terminating\n * HTTP request components, header names and header values.\n * Parameters:\n *   buf (in/out): pointer to the HTTP header to parse and split\n *   len (in): length of HTTP header buffer\n *   re (out): parsed header as mg_request_info\n * buf and ri must be valid pointers (not NULL), len>0.\n * Returns <0 on error. */\nstatic int\nparse_http_request(char *buf, int len, struct mg_request_info *ri)\n{\n\tint request_length;\n\tint init_skip = 0;\n\n\t/* Reset attributes. DO NOT TOUCH is_ssl, remote_addr,\n\t * remote_port */\n\tri->remote_user = ri->request_method = ri->request_uri = ri->http_version =\n\t    NULL;\n\tri->num_headers = 0;\n\n\t/* RFC says that all initial whitespaces should be ingored */\n\t/* This included all leading \\r and \\n (isspace) */\n\t/* See table: http://www.cplusplus.com/reference/cctype/ */\n\twhile ((len > 0) && isspace(*(unsigned char *)buf)) {\n\t\tbuf++;\n\t\tlen--;\n\t\tinit_skip++;\n\t}\n\n\tif (len == 0) {\n\t\t/* Incomplete request */\n\t\treturn 0;\n\t}\n\n\t/* Control characters are not allowed, including zero */\n\tif (iscntrl(*(unsigned char *)buf)) {\n\t\treturn -1;\n\t}\n\n\t/* Find end of HTTP header */\n\trequest_length = get_http_header_len(buf, len);\n\tif (request_length <= 0) {\n\t\treturn request_length;\n\t}\n\tbuf[request_length - 1] = '\\0';\n\n\tif ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {\n\t\treturn -1;\n\t}\n\n\t/* The first word has to be the HTTP method */\n\tri->request_method = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Check for a valid http method */\n\tif (!is_valid_http_method(ri->request_method)) {\n\t\treturn -1;\n\t}\n\n\t/* The second word is the URI */\n\tri->request_uri = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Next would be the HTTP version */\n\tri->http_version = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 1) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Check for a valid HTTP version key */\n\tif (strncmp(ri->http_version, \"HTTP/\", 5) != 0) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tri->http_version += 5;\n\n\n\t/* Parse all HTTP headers */\n\tri->num_headers = parse_http_headers(&buf, ri->http_headers);\n\tif (ri->num_headers < 0) {\n\t\t/* Error while parsing headers */\n\t\treturn -1;\n\t}\n\n\treturn request_length + init_skip;\n}\n\n\nstatic int\nparse_http_response(char *buf, int len, struct mg_response_info *ri)\n{\n\tint response_length;\n\tint init_skip = 0;\n\tchar *tmp, *tmp2;\n\tlong l;\n\n\t/* Initialize elements. */\n\tri->http_version = ri->status_text = NULL;\n\tri->num_headers = ri->status_code = 0;\n\n\t/* RFC says that all initial whitespaces should be ingored */\n\t/* This included all leading \\r and \\n (isspace) */\n\t/* See table: http://www.cplusplus.com/reference/cctype/ */\n\twhile ((len > 0) && isspace(*(unsigned char *)buf)) {\n\t\tbuf++;\n\t\tlen--;\n\t\tinit_skip++;\n\t}\n\n\tif (len == 0) {\n\t\t/* Incomplete request */\n\t\treturn 0;\n\t}\n\n\t/* Control characters are not allowed, including zero */\n\tif (iscntrl(*(unsigned char *)buf)) {\n\t\treturn -1;\n\t}\n\n\t/* Find end of HTTP header */\n\tresponse_length = get_http_header_len(buf, len);\n\tif (response_length <= 0) {\n\t\treturn response_length;\n\t}\n\tbuf[response_length - 1] = '\\0';\n\n\tif ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {\n\t\treturn -1;\n\t}\n\n\t/* The first word is the HTTP version */\n\t/* Check for a valid HTTP version key */\n\tif (strncmp(buf, \"HTTP/\", 5) != 0) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tbuf += 5;\n\tif (!isgraph(buf[0])) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tri->http_version = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* The second word is the status as a number */\n\ttmp = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\tl = strtol(tmp, &tmp2, 10);\n\tif ((l < 100) || (l >= 1000) || ((tmp2 - tmp) != 3) || (*tmp2 != 0)) {\n\t\t/* Everything else but a 3 digit code is invalid */\n\t\treturn -1;\n\t}\n\tri->status_code = (int)l;\n\n\t/* The rest of the line is the status text */\n\tri->status_text = buf;\n\n\t/* Find end of status text */\n\t/* isgraph or isspace = isprint */\n\twhile (isprint(*buf)) {\n\t\tbuf++;\n\t}\n\tif ((*buf != '\\r') && (*buf != '\\n')) {\n\t\treturn -1;\n\t}\n\t/* Terminate string and forward buf to next line */\n\tdo {\n\t\t*buf = 0;\n\t\tbuf++;\n\t} while ((*buf) && isspace(*buf));\n\n\n\t/* Parse all HTTP headers */\n\tri->num_headers = parse_http_headers(&buf, ri->http_headers);\n\tif (ri->num_headers < 0) {\n\t\t/* Error while parsing headers */\n\t\treturn -1;\n\t}\n\n\treturn response_length + init_skip;\n}\n\n\n/* Keep reading the input (either opened file descriptor fd, or socket sock,\n * or SSL descriptor ssl) into buffer buf, until \\r\\n\\r\\n appears in the\n * buffer (which marks the end of HTTP request). Buffer buf may already\n * have some data. The length of the data is stored in nread.\n * Upon every read operation, increase nread by the number of bytes read. */\nstatic int\nread_message(FILE *fp,\n             struct mg_connection *conn,\n             char *buf,\n             int bufsiz,\n             int *nread)\n{\n\tint request_len, n = 0;\n\tstruct timespec last_action_time;\n\tdouble request_timeout;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tmemset(&last_action_time, 0, sizeof(last_action_time));\n\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\t/* value of request_timeout is in seconds, config in milliseconds */\n\t\trequest_timeout = atof(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t} else {\n\t\trequest_timeout = -1.0;\n\t}\n\tif (conn->handled_requests > 0) {\n\t\tif (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {\n\t\t\trequest_timeout =\n\t\t\t    atof(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) / 1000.0;\n\t\t}\n\t}\n\n\trequest_len = get_http_header_len(buf, *nread);\n\n\t/* first time reading from this connection */\n\tclock_gettime(CLOCK_MONOTONIC, &last_action_time);\n\n\twhile (request_len == 0) {\n\t\t/* Full request not yet received */\n\t\tif (conn->phys_ctx->stop_flag != 0) {\n\t\t\t/* Server is to be stopped. */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (*nread >= bufsiz) {\n\t\t\t/* Request too long */\n\t\t\treturn -2;\n\t\t}\n\n\t\tn = pull_inner(\n\t\t    fp, conn, buf + *nread, bufsiz - *nread, request_timeout);\n\t\tif (n == -2) {\n\t\t\t/* Receive error */\n\t\t\treturn -1;\n\t\t}\n\t\tif (n > 0) {\n\t\t\t*nread += n;\n\t\t\trequest_len = get_http_header_len(buf, *nread);\n\t\t} else {\n\t\t\trequest_len = 0;\n\t\t}\n\n\t\tif ((request_len == 0) && (request_timeout >= 0)) {\n\t\t\tif (mg_difftimespec(&last_action_time, &(conn->req_time))\n\t\t\t    > request_timeout) {\n\t\t\t\t/* Timeout */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &last_action_time);\n\t\t}\n\t}\n\n\treturn request_len;\n}\n\n\n#if !defined(NO_CGI) || !defined(NO_FILES)\nstatic int\nforward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl)\n{\n\tconst char *expect, *body;\n\tchar buf[MG_BUF_LEN];\n\tint to_read, nread, success = 0;\n\tint64_t buffered_len;\n\tdouble timeout = -1.0;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\texpect = mg_get_header(conn, \"Expect\");\n\tDEBUG_ASSERT(fp != NULL);\n\tif (!fp) {\n\t\tmg_send_http_error(conn, 500, \"%s\", \"Error: NULL File\");\n\t\treturn 0;\n\t}\n\n\tif ((conn->content_len == -1) && (!conn->is_chunked)) {\n\t\t/* Content length is not specified by the client. */\n\t\tmg_send_http_error(conn,\n\t\t                   411,\n\t\t                   \"%s\",\n\t\t                   \"Error: Client did not specify content length\");\n\t} else if ((expect != NULL)\n\t           && (mg_strcasecmp(expect, \"100-continue\") != 0)) {\n\t\t/* Client sent an \"Expect: xyz\" header and xyz is not 100-continue.\n\t\t */\n\t\tmg_send_http_error(conn,\n\t\t                   417,\n\t\t                   \"Error: Can not fulfill expectation %s\",\n\t\t                   expect);\n\t} else {\n\t\tif (expect != NULL) {\n\t\t\t(void)mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");\n\t\t\tconn->status_code = 100;\n\t\t} else {\n\t\t\tconn->status_code = 200;\n\t\t}\n\n\t\tbuffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len\n\t\t               - conn->consumed_content;\n\n\t\tDEBUG_ASSERT(buffered_len >= 0);\n\t\tDEBUG_ASSERT(conn->consumed_content == 0);\n\n\t\tif ((buffered_len < 0) || (conn->consumed_content != 0)) {\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"Error: Size mismatch\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (buffered_len > 0) {\n\t\t\tif ((int64_t)buffered_len > conn->content_len) {\n\t\t\t\tbuffered_len = (int)conn->content_len;\n\t\t\t}\n\t\t\tbody = conn->buf + conn->request_len + conn->consumed_content;\n\t\t\tpush_all(\n\t\t\t    conn->phys_ctx, fp, sock, ssl, body, (int64_t)buffered_len);\n\t\t\tconn->consumed_content += buffered_len;\n\t\t}\n\n\t\tnread = 0;\n\t\twhile (conn->consumed_content < conn->content_len) {\n\t\t\tto_read = sizeof(buf);\n\t\t\tif ((int64_t)to_read > conn->content_len - conn->consumed_content) {\n\t\t\t\tto_read = (int)(conn->content_len - conn->consumed_content);\n\t\t\t}\n\t\t\tnread = pull_inner(NULL, conn, buf, to_read, timeout);\n\t\t\tif (nread == -2) {\n\t\t\t\t/* error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nread > 0) {\n\t\t\t\tif (push_all(conn->phys_ctx, fp, sock, ssl, buf, nread)\n\t\t\t\t    != nread) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconn->consumed_content += nread;\n\t\t}\n\n\t\tif (conn->consumed_content == conn->content_len) {\n\t\t\tsuccess = (nread >= 0);\n\t\t}\n\n\t\t/* Each error code path in this function must send an error */\n\t\tif (!success) {\n\t\t\t/* NOTE: Maybe some data has already been sent. */\n\t\t\t/* TODO (low): If some data has been sent, a correct error\n\t\t\t * reply can no longer be sent, so just close the connection */\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"\");\n\t\t}\n\t}\n\n\treturn success;\n}\n#endif\n\n\n#if defined(USE_TIMERS)\n\n#define TIMER_API static\n#include \"timer.inl\"\n\n#endif /* USE_TIMERS */\n\n\n#if !defined(NO_CGI)\n/* This structure helps to create an environment for the spawned CGI\n * program.\n * Environment is an array of \"VARIABLE=VALUE\\0\" ASCIIZ strings,\n * last element must be NULL.\n * However, on Windows there is a requirement that all these\n * VARIABLE=VALUE\\0\n * strings must reside in a contiguous buffer. The end of the buffer is\n * marked by two '\\0' characters.\n * We satisfy both worlds: we create an envp array (which is vars), all\n * entries are actually pointers inside buf. */\nstruct cgi_environment {\n\tstruct mg_connection *conn;\n\t/* Data block */\n\tchar *buf;      /* Environment buffer */\n\tsize_t buflen;  /* Space available in buf */\n\tsize_t bufused; /* Space taken in buf */\n\t                /* Index block */\n\tchar **var;     /* char **envp */\n\tsize_t varlen;  /* Number of variables available in var */\n\tsize_t varused; /* Number of variables stored in var */\n};\n\n\nstatic void addenv(struct cgi_environment *env,\n                   PRINTF_FORMAT_STRING(const char *fmt),\n                   ...) PRINTF_ARGS(2, 3);\n\n/* Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n * pointer into the vars array. Assumes env != NULL and fmt != NULL. */\nstatic void\naddenv(struct cgi_environment *env, const char *fmt, ...)\n{\n\tsize_t n, space;\n\tint truncated = 0;\n\tchar *added;\n\tva_list ap;\n\n\t/* Calculate how much space is left in the buffer */\n\tspace = (env->buflen - env->bufused);\n\n\t/* Calculate an estimate for the required space */\n\tn = strlen(fmt) + 2 + 128;\n\n\tdo {\n\t\tif (space <= n) {\n\t\t\t/* Allocate new buffer */\n\t\t\tn = env->buflen + CGI_ENVIRONMENT_SIZE;\n\t\t\tadded = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);\n\t\t\tif (!added) {\n\t\t\t\t/* Out of memory */\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    env->conn,\n\t\t\t\t    \"%s: Cannot allocate memory for CGI variable [%s]\",\n\t\t\t\t    __func__,\n\t\t\t\t    fmt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tenv->buf = added;\n\t\t\tenv->buflen = n;\n\t\t\tspace = (env->buflen - env->bufused);\n\t\t}\n\n\t\t/* Make a pointer to the free space int the buffer */\n\t\tadded = env->buf + env->bufused;\n\n\t\t/* Copy VARIABLE=VALUE\\0 string into the free space */\n\t\tva_start(ap, fmt);\n\t\tmg_vsnprintf(env->conn, &truncated, added, (size_t)space, fmt, ap);\n\t\tva_end(ap);\n\n\t\t/* Do not add truncated strings to the environment */\n\t\tif (truncated) {\n\t\t\t/* Reallocate the buffer */\n\t\t\tspace = 0;\n\t\t\tn = 1;\n\t\t}\n\t} while (truncated);\n\n\t/* Calculate number of bytes added to the environment */\n\tn = strlen(added) + 1;\n\tenv->bufused += n;\n\n\t/* Now update the variable index */\n\tspace = (env->varlen - env->varused);\n\tif (space < 2) {\n\t\tmg_cry_internal(env->conn,\n\t\t                \"%s: Cannot register CGI variable [%s]\",\n\t\t                __func__,\n\t\t                fmt);\n\t\treturn;\n\t}\n\n\t/* Append a pointer to the added string into the envp array */\n\tenv->var[env->varused] = added;\n\tenv->varused++;\n}\n\n/* Return 0 on success, non-zero if an error occurs. */\n\nstatic int\nprepare_cgi_environment(struct mg_connection *conn,\n                        const char *prog,\n                        struct cgi_environment *env)\n{\n\tconst char *s;\n\tstruct vec var_vec;\n\tchar *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];\n\tint i, truncated, uri_len;\n\n\tif ((conn == NULL) || (prog == NULL) || (env == NULL)) {\n\t\treturn -1;\n\t}\n\n\tenv->conn = conn;\n\tenv->buflen = CGI_ENVIRONMENT_SIZE;\n\tenv->bufused = 0;\n\tenv->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);\n\tif (env->buf == NULL) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Not enough memory for environmental buffer\",\n\t\t                __func__);\n\t\treturn -1;\n\t}\n\tenv->varlen = MAX_CGI_ENVIR_VARS;\n\tenv->varused = 0;\n\tenv->var =\n\t    (char **)mg_malloc_ctx(env->buflen * sizeof(char *), conn->phys_ctx);\n\tif (env->var == NULL) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Not enough memory for environmental variables\",\n\t\t                __func__);\n\t\tmg_free(env->buf);\n\t\treturn -1;\n\t}\n\n\taddenv(env, \"SERVER_NAME=%s\", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);\n\taddenv(env, \"SERVER_ROOT=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\taddenv(env, \"DOCUMENT_ROOT=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\taddenv(env, \"SERVER_SOFTWARE=CivetWeb/%s\", mg_version());\n\n\t/* Prepare the environment block */\n\taddenv(env, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n\taddenv(env, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n\taddenv(env, \"%s\", \"REDIRECT_STATUS=200\"); /* For PHP */\n\n#if defined(USE_IPV6)\n\tif (conn->client.lsa.sa.sa_family == AF_INET6) {\n\t\taddenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin6.sin6_port));\n\t} else\n#endif\n\t{\n\t\taddenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));\n\t}\n\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\taddenv(env, \"REMOTE_ADDR=%s\", src_addr);\n\n\taddenv(env, \"REQUEST_METHOD=%s\", conn->request_info.request_method);\n\taddenv(env, \"REMOTE_PORT=%d\", conn->request_info.remote_port);\n\n\taddenv(env, \"REQUEST_URI=%s\", conn->request_info.request_uri);\n\taddenv(env, \"LOCAL_URI=%s\", conn->request_info.local_uri);\n\n\t/* SCRIPT_NAME */\n\turi_len = (int)strlen(conn->request_info.local_uri);\n\tif (conn->path_info == NULL) {\n\t\tif (conn->request_info.local_uri[uri_len - 1] != '/') {\n\t\t\t/* URI: /path_to_script/script.cgi */\n\t\t\taddenv(env, \"SCRIPT_NAME=%s\", conn->request_info.local_uri);\n\t\t} else {\n\t\t\t/* URI: /path_to_script/ ... using index.cgi */\n\t\t\tconst char *index_file = strrchr(prog, '/');\n\t\t\tif (index_file) {\n\t\t\t\taddenv(env,\n\t\t\t\t       \"SCRIPT_NAME=%s%s\",\n\t\t\t\t       conn->request_info.local_uri,\n\t\t\t\t       index_file + 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* URI: /path_to_script/script.cgi/path_info */\n\t\taddenv(env,\n\t\t       \"SCRIPT_NAME=%.*s\",\n\t\t       uri_len - (int)strlen(conn->path_info),\n\t\t       conn->request_info.local_uri);\n\t}\n\n\taddenv(env, \"SCRIPT_FILENAME=%s\", prog);\n\tif (conn->path_info == NULL) {\n\t\taddenv(env, \"PATH_TRANSLATED=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\t} else {\n\t\taddenv(env,\n\t\t       \"PATH_TRANSLATED=%s%s\",\n\t\t       conn->dom_ctx->config[DOCUMENT_ROOT],\n\t\t       conn->path_info);\n\t}\n\n\taddenv(env, \"HTTPS=%s\", (conn->ssl == NULL) ? \"off\" : \"on\");\n\n\tif ((s = mg_get_header(conn, \"Content-Type\")) != NULL) {\n\t\taddenv(env, \"CONTENT_TYPE=%s\", s);\n\t}\n\tif (conn->request_info.query_string != NULL) {\n\t\taddenv(env, \"QUERY_STRING=%s\", conn->request_info.query_string);\n\t}\n\tif ((s = mg_get_header(conn, \"Content-Length\")) != NULL) {\n\t\taddenv(env, \"CONTENT_LENGTH=%s\", s);\n\t}\n\tif ((s = getenv(\"PATH\")) != NULL) {\n\t\taddenv(env, \"PATH=%s\", s);\n\t}\n\tif (conn->path_info != NULL) {\n\t\taddenv(env, \"PATH_INFO=%s\", conn->path_info);\n\t}\n\n\tif (conn->status_code > 0) {\n\t\t/* CGI error handler should show the status code */\n\t\taddenv(env, \"STATUS=%d\", conn->status_code);\n\t}\n\n#if defined(_WIN32)\n\tif ((s = getenv(\"COMSPEC\")) != NULL) {\n\t\taddenv(env, \"COMSPEC=%s\", s);\n\t}\n\tif ((s = getenv(\"SYSTEMROOT\")) != NULL) {\n\t\taddenv(env, \"SYSTEMROOT=%s\", s);\n\t}\n\tif ((s = getenv(\"SystemDrive\")) != NULL) {\n\t\taddenv(env, \"SystemDrive=%s\", s);\n\t}\n\tif ((s = getenv(\"ProgramFiles\")) != NULL) {\n\t\taddenv(env, \"ProgramFiles=%s\", s);\n\t}\n\tif ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {\n\t\taddenv(env, \"ProgramFiles(x86)=%s\", s);\n\t}\n#else\n\tif ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL) {\n\t\taddenv(env, \"LD_LIBRARY_PATH=%s\", s);\n\t}\n#endif /* _WIN32 */\n\n\tif ((s = getenv(\"PERLLIB\")) != NULL) {\n\t\taddenv(env, \"PERLLIB=%s\", s);\n\t}\n\n\tif (conn->request_info.remote_user != NULL) {\n\t\taddenv(env, \"REMOTE_USER=%s\", conn->request_info.remote_user);\n\t\taddenv(env, \"%s\", \"AUTH_TYPE=Digest\");\n\t}\n\n\t/* Add all headers as HTTP_* variables */\n\tfor (i = 0; i < conn->request_info.num_headers; i++) {\n\n\t\t(void)mg_snprintf(conn,\n\t\t                  &truncated,\n\t\t                  http_var_name,\n\t\t                  sizeof(http_var_name),\n\t\t                  \"HTTP_%s\",\n\t\t                  conn->request_info.http_headers[i].name);\n\n\t\tif (truncated) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: HTTP header variable too long [%s]\",\n\t\t\t                __func__,\n\t\t\t                conn->request_info.http_headers[i].name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Convert variable name into uppercase, and change - to _ */\n\t\tfor (p = http_var_name; *p != '\\0'; p++) {\n\t\t\tif (*p == '-') {\n\t\t\t\t*p = '_';\n\t\t\t}\n\t\t\t*p = (char)toupper(*(unsigned char *)p);\n\t\t}\n\n\t\taddenv(env,\n\t\t       \"%s=%s\",\n\t\t       http_var_name,\n\t\t       conn->request_info.http_headers[i].value);\n\t}\n\n\t/* Add user-specified variables */\n\ts = conn->dom_ctx->config[CGI_ENVIRONMENT];\n\twhile ((s = next_option(s, &var_vec, NULL)) != NULL) {\n\t\taddenv(env, \"%.*s\", (int)var_vec.len, var_vec.ptr);\n\t}\n\n\tenv->var[env->varused] = NULL;\n\tenv->buf[env->bufused] = '\\0';\n\n\treturn 0;\n}\n\n\nstatic int\nabort_process(void *data)\n{\n\t/* Waitpid checks for child status and won't work for a pid that does not\n\t * identify a child of the current process. Thus, if the pid is reused,\n\t * we will not affect a different process. */\n\tpid_t pid = (pid_t)data;\n\tint status = 0;\n\tpid_t rpid = waitpid(pid, &status, WNOHANG);\n\tif ((rpid != (pid_t)-1) && (status == 0)) {\n\t\t/* Stop child process */\n\t\tDEBUG_TRACE(\"CGI timer: Stop child process %p\\n\", pid);\n\t\tkill(pid, SIGABRT);\n\n\t\t/* Wait until process is terminated (don't leave zombies) */\n\t\twhile (waitpid(pid, &status, 0) != (pid_t)-1) /* nop */\n\t\t\t;\n\t} else {\n\t\tDEBUG_TRACE(\"CGI timer: Child process %p already stopped in time\\n\",\n\t\t            pid);\n\t}\n\treturn 0;\n}\n\n\nstatic void\nhandle_cgi_request(struct mg_connection *conn, const char *prog)\n{\n\tchar *buf;\n\tsize_t buflen;\n\tint headers_len, data_len, i, truncated;\n\tint fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};\n\tconst char *status, *status_text, *connection_state;\n\tchar *pbuf, dir[PATH_MAX], *p;\n\tstruct mg_request_info ri;\n\tstruct cgi_environment blk;\n\tFILE *in = NULL, *out = NULL, *err = NULL;\n\tstruct mg_file fout = STRUCT_FILE_INITIALIZER;\n\tpid_t pid = (pid_t)-1;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tbuf = NULL;\n\tbuflen = conn->phys_ctx->max_request_size;\n\ti = prepare_cgi_environment(conn, prog, &blk);\n\tif (i != 0) {\n\t\tblk.buf = NULL;\n\t\tblk.var = NULL;\n\t\tgoto done;\n\t}\n\n\t/* CGI must be executed in its own directory. 'dir' must point to the\n\t * directory containing executable program, 'p' must point to the\n\t * executable program name relative to 'dir'. */\n\t(void)mg_snprintf(conn, &truncated, dir, sizeof(dir), \"%s\", prog);\n\n\tif (truncated) {\n\t\tmg_cry_internal(conn, \"Error: CGI program \\\"%s\\\": Path too long\", prog);\n\t\tmg_send_http_error(conn, 500, \"Error: %s\", \"CGI path too long\");\n\t\tgoto done;\n\t}\n\n\tif ((p = strrchr(dir, '/')) != NULL) {\n\t\t*p++ = '\\0';\n\t} else {\n\t\tdir[0] = '.';\n\t\tdir[1] = '\\0';\n\t\tp = (char *)prog;\n\t}\n\n\tif ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",\n\t\t    prog,\n\t\t    status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot create CGI pipe: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tDEBUG_TRACE(\"CGI: spawn %s %s\\n\", dir, p);\n\tpid = spawn_process(conn, p, blk.buf, blk.var, fdin, fdout, fderr, dir);\n\n\tif (pid == (pid_t)-1) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Can not spawn CGI process: %s\",\n\t\t    prog,\n\t\t    status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot spawn CGI process [%s]: %s\",\n\t\t                   prog,\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n#if defined(USE_TIMERS)\n\t// TODO (#618): set a timeout\n\ttimer_add(conn->phys_ctx,\n\t          /* one minute */ 60.0,\n\t          0.0,\n\t          1,\n\t          abort_process,\n\t          (void *)pid);\n#endif\n\n\t/* Make sure child closes all pipe descriptors. It must dup them to 0,1\n\t */\n\tset_close_on_exec((SOCKET)fdin[0], conn);  /* stdin read */\n\tset_close_on_exec((SOCKET)fdin[1], conn);  /* stdin write */\n\tset_close_on_exec((SOCKET)fdout[0], conn); /* stdout read */\n\tset_close_on_exec((SOCKET)fdout[1], conn); /* stdout write */\n\tset_close_on_exec((SOCKET)fderr[0], conn); /* stderr read */\n\tset_close_on_exec((SOCKET)fderr[1], conn); /* stderr write */\n\n\t/* Parent closes only one side of the pipes.\n\t * If we don't mark them as closed, close() attempt before\n\t * return from this function throws an exception on Windows.\n\t * Windows does not like when closed descriptor is closed again. */\n\t(void)close(fdin[0]);\n\t(void)close(fdout[1]);\n\t(void)close(fderr[1]);\n\tfdin[0] = fdout[1] = fderr[1] = -1;\n\n\tif ((in = fdopen(fdin[1], \"wb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stdin: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fdin\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tif ((out = fdopen(fdout[0], \"rb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stdout: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fdout\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tif ((err = fdopen(fderr[0], \"rb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stderr: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fderr\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tsetbuf(in, NULL);\n\tsetbuf(out, NULL);\n\tsetbuf(err, NULL);\n\tfout.access.fp = out;\n\n\tif ((conn->request_info.content_length != 0) || (conn->is_chunked)) {\n\t\tDEBUG_TRACE(\"CGI: send body data (%lli)\\n\",\n\t\t            (signed long long)conn->request_info.content_length);\n\n\t\t/* This is a POST/PUT request, or another request with body data. */\n\t\tif (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {\n\t\t\t/* Error sending the body data */\n\t\t\tmg_cry_internal(\n\t\t\t    conn,\n\t\t\t    \"Error: CGI program \\\"%s\\\": Forward body data failed\",\n\t\t\t    prog);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Close so child gets an EOF. */\n\tfclose(in);\n\tin = NULL;\n\tfdin[1] = -1;\n\n\t/* Now read CGI reply into a buffer. We need to set correct\n\t * status code, thus we need to see all HTTP headers first.\n\t * Do not send anything back to client, until we buffer in all\n\t * HTTP headers. */\n\tdata_len = 0;\n\tbuf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);\n\tif (buf == NULL) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Not enough memory for CGI buffer (%u bytes)\",\n\t\t                   (unsigned int)buflen);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Not enough memory for buffer (%u \"\n\t\t    \"bytes)\",\n\t\t    prog,\n\t\t    (unsigned int)buflen);\n\t\tgoto done;\n\t}\n\n\tDEBUG_TRACE(\"CGI: %s\", \"wait for response\");\n\theaders_len = read_message(out, conn, buf, (int)buflen, &data_len);\n\tDEBUG_TRACE(\"CGI: response: %li\", (signed long)headers_len);\n\n\tif (headers_len <= 0) {\n\n\t\t/* Could not parse the CGI response. Check if some error message on\n\t\t * stderr. */\n\t\ti = pull_all(err, conn, buf, (int)buflen);\n\t\tif (i > 0) {\n\t\t\t/* CGI program explicitly sent an error */\n\t\t\t/* Write the error message to the internal log */\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error: CGI program \\\"%s\\\" sent error \"\n\t\t\t                \"message: [%.*s]\",\n\t\t\t                prog,\n\t\t\t                i,\n\t\t\t                buf);\n\t\t\t/* Don't send the error message back to the client */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: CGI program \\\"%s\\\" failed.\",\n\t\t\t                   prog);\n\t\t} else {\n\t\t\t/* CGI program did not explicitly send an error, but a broken\n\t\t\t * respon header */\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error: CGI program sent malformed or too big \"\n\t\t\t                \"(>%u bytes) HTTP headers: [%.*s]\",\n\t\t\t                (unsigned)buflen,\n\t\t\t                data_len,\n\t\t\t                buf);\n\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: CGI program sent malformed or too big \"\n\t\t\t                   \"(>%u bytes) HTTP headers: [%.*s]\",\n\t\t\t                   (unsigned)buflen,\n\t\t\t                   data_len,\n\t\t\t                   buf);\n\t\t}\n\n\t\t/* in both cases, abort processing CGI */\n\t\tgoto done;\n\t}\n\n\tpbuf = buf;\n\tbuf[headers_len - 1] = '\\0';\n\tri.num_headers = parse_http_headers(&pbuf, ri.http_headers);\n\n\t/* Make up and send the status line */\n\tstatus_text = \"OK\";\n\tif ((status = get_header(ri.http_headers, ri.num_headers, \"Status\"))\n\t    != NULL) {\n\t\tconn->status_code = atoi(status);\n\t\tstatus_text = status;\n\t\twhile (isdigit(*(const unsigned char *)status_text)\n\t\t       || *status_text == ' ') {\n\t\t\tstatus_text++;\n\t\t}\n\t} else if (get_header(ri.http_headers, ri.num_headers, \"Location\")\n\t           != NULL) {\n\t\tconn->status_code = 307;\n\t} else {\n\t\tconn->status_code = 200;\n\t}\n\tconnection_state =\n\t    get_header(ri.http_headers, ri.num_headers, \"Connection\");\n\tif (!header_has_option(connection_state, \"keep-alive\")) {\n\t\tconn->must_close = 1;\n\t}\n\n\tDEBUG_TRACE(\"CGI: response %u %s\", conn->status_code, status_text);\n\n\t(void)mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", conn->status_code, status_text);\n\n\t/* Send headers */\n\tfor (i = 0; i < ri.num_headers; i++) {\n\t\tmg_printf(conn,\n\t\t          \"%s: %s\\r\\n\",\n\t\t          ri.http_headers[i].name,\n\t\t          ri.http_headers[i].value);\n\t}\n\tmg_write(conn, \"\\r\\n\", 2);\n\n\t/* Send chunk of data that may have been read after the headers */\n\tmg_write(conn, buf + headers_len, (size_t)(data_len - headers_len));\n\n\t/* Read the rest of CGI output and send to the client */\n\tDEBUG_TRACE(\"CGI: %s\", \"forward all data\");\n\tsend_file_data(conn, &fout, 0, INT64_MAX);\n\tDEBUG_TRACE(\"CGI: %s\", \"all data sent\");\n\ndone:\n\tmg_free(blk.var);\n\tmg_free(blk.buf);\n\n\tif (pid != (pid_t)-1) {\n\t\tabort_process((void *)pid);\n\t}\n\n\tif (fdin[0] != -1) {\n\t\tclose(fdin[0]);\n\t}\n\tif (fdout[1] != -1) {\n\t\tclose(fdout[1]);\n\t}\n\n\tif (in != NULL) {\n\t\tfclose(in);\n\t} else if (fdin[1] != -1) {\n\t\tclose(fdin[1]);\n\t}\n\n\tif (out != NULL) {\n\t\tfclose(out);\n\t} else if (fdout[0] != -1) {\n\t\tclose(fdout[0]);\n\t}\n\n\tif (err != NULL) {\n\t\tfclose(err);\n\t} else if (fderr[0] != -1) {\n\t\tclose(fderr[0]);\n\t}\n\n\tif (buf != NULL) {\n\t\tmg_free(buf);\n\t}\n}\n#endif /* !NO_CGI */\n\n\n#if !defined(NO_FILES)\nstatic void\nmkcol(struct mg_connection *conn, const char *path)\n{\n\tint rc, body_len;\n\tstruct de de;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\t/* TODO (mid): Check the mg_send_http_error situations in this function\n\t */\n\n\tmemset(&de.file, 0, sizeof(de.file));\n\tif (!mg_stat(conn, path, &de.file)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t                __func__,\n\t\t                path,\n\t\t                strerror(ERRNO));\n\t}\n\n\tif (de.file.last_modified) {\n\t\t/* TODO (mid): This check does not seem to make any sense ! */\n\t\t/* TODO (mid): Add a webdav unit test first, before changing\n\t\t * anything here. */\n\t\tmg_send_http_error(\n\t\t    conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tbody_len = conn->data_len - conn->request_len;\n\tif (body_len > 0) {\n\t\tmg_send_http_error(\n\t\t    conn, 415, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\treturn;\n\t}\n\n\trc = mg_mkdir(conn, path, 0755);\n\n\tif (rc == 0) {\n\t\tconn->status_code = 201;\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 %d Created\\r\\n\"\n\t\t          \"Date: %s\\r\\n\",\n\t\t          conn->status_code,\n\t\t          date);\n\t\tsend_static_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          suggest_connection_header(conn));\n\t} else {\n\t\tif (errno == EEXIST) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else if (errno == EACCES) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 403, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else if (errno == ENOENT) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 409, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 500, \"fopen(%s): %s\", path, strerror(ERRNO));\n\t\t}\n\t}\n}\n\n\nstatic void\nput_file(struct mg_connection *conn, const char *path)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tconst char *range;\n\tint64_t r1, r2;\n\tint rc;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tif (mg_stat(conn, path, &file.stat)) {\n\t\t/* File already exists */\n\t\tconn->status_code = 200;\n\n\t\tif (file.stat.is_directory) {\n\t\t\t/* This is an already existing directory,\n\t\t\t * so there is nothing to do for the server. */\n\t\t\trc = 0;\n\n\t\t} else {\n/* File exists and is not a directory. */\n/* Can it be replaced? */\n\n#if defined(MG_USE_OPEN_FILE)\n\t\t\tif (file.access.membuf != NULL) {\n\t\t\t\t/* This is an \"in-memory\" file, that can not be replaced */\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   405,\n\t\t\t\t                   \"Error: Put not possible\\nReplacing %s \"\n\t\t\t\t                   \"is not supported\",\n\t\t\t\t                   path);\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\n\t\t\t/* Check if the server may write this file */\n\t\t\tif (access(path, W_OK) == 0) {\n\t\t\t\t/* Access granted */\n\t\t\t\tconn->status_code = 200;\n\t\t\t\trc = 1;\n\t\t\t} else {\n\t\t\t\tmg_send_http_error(\n\t\t\t\t    conn,\n\t\t\t\t    403,\n\t\t\t\t    \"Error: Put not possible\\nReplacing %s is not allowed\",\n\t\t\t\t    path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* File should be created */\n\t\tconn->status_code = 201;\n\t\trc = put_dir(conn, path);\n\t}\n\n\tif (rc == 0) {\n\t\t/* put_dir returns 0 if path is a directory */\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 %d %s\\r\\n\",\n\t\t          conn->status_code,\n\t\t          mg_get_response_code_text(NULL, conn->status_code));\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\n\t\t/* Request to create a directory has been fulfilled successfully.\n\t\t * No need to put a file. */\n\t\treturn;\n\t}\n\n\tif (rc == -1) {\n\t\t/* put_dir returns -1 if the path is too long */\n\t\tmg_send_http_error(conn,\n\t\t                   414,\n\t\t                   \"Error: Path too long\\nput_dir(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tif (rc == -2) {\n\t\t/* put_dir returns -2 if the directory can not be created */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Can not create directory\\nput_dir(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\t/* A file should be created or overwritten. */\n\t/* Currently CivetWeb does not nead read+write access. */\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file)\n\t    || file.access.fp == NULL) {\n\t\t(void)mg_fclose(&file.access);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Can not create file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tfclose_on_exec(&file.access, conn);\n\trange = mg_get_header(conn, \"Content-Range\");\n\tr1 = r2 = 0;\n\tif ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {\n\t\tconn->status_code = 206; /* Partial content */\n\t\tfseeko(file.access.fp, r1, SEEK_SET);\n\t}\n\n\tif (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {\n\t\t/* forward_body_data failed.\n\t\t * The error code has already been sent to the client,\n\t\t * and conn->status_code is already set. */\n\t\t(void)mg_fclose(&file.access);\n\t\treturn;\n\t}\n\n\tif (mg_fclose(&file.access) != 0) {\n\t\t/* fclose failed. This might have different reasons, but a likely\n\t\t * one is \"no space on disk\", http 507. */\n\t\tconn->status_code = 507;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tmg_printf(conn,\n\t          \"HTTP/1.1 %d %s\\r\\n\",\n\t          conn->status_code,\n\t          mg_get_response_code_text(NULL, conn->status_code));\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Content-Length: 0\\r\\n\"\n\t          \"Connection: %s\\r\\n\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn));\n}\n\n\nstatic void\ndelete_file(struct mg_connection *conn, const char *path)\n{\n\tstruct de de;\n\tmemset(&de.file, 0, sizeof(de.file));\n\tif (!mg_stat(conn, path, &de.file)) {\n\t\t/* mg_stat returns 0 if the file does not exist */\n\t\tmg_send_http_error(conn,\n\t\t                   404,\n\t\t                   \"Error: Cannot delete file\\nFile %s not found\",\n\t\t                   path);\n\t\treturn;\n\t}\n\n#if 0 /* Ignore if a file in memory is inside a folder */\n        if (de.access.membuf != NULL) {\n                /* the file is cached in memory */\n                mg_send_http_error(\n                    conn,\n                    405,\n                    \"Error: Delete not possible\\nDeleting %s is not supported\",\n                    path);\n                return;\n        }\n#endif\n\n\tif (de.file.is_directory) {\n\t\tif (remove_directory(conn, path)) {\n\t\t\t/* Delete is successful: Return 204 without content. */\n\t\t\tmg_send_http_error(conn, 204, \"%s\", \"\");\n\t\t} else {\n\t\t\t/* Delete is not successful: Return 500 (Server error). */\n\t\t\tmg_send_http_error(conn, 500, \"Error: Could not delete %s\", path);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* This is an existing file (not a directory).\n\t * Check if write permission is granted. */\n\tif (access(path, W_OK) != 0) {\n\t\t/* File is read only */\n\t\tmg_send_http_error(\n\t\t    conn,\n\t\t    403,\n\t\t    \"Error: Delete not possible\\nDeleting %s is not allowed\",\n\t\t    path);\n\t\treturn;\n\t}\n\n\t/* Try to delete it. */\n\tif (mg_remove(conn, path) == 0) {\n\t\t/* Delete was successful: Return 204 without content. */\n\t\tmg_send_http_error(conn, 204, \"%s\", \"\");\n\t} else {\n\t\t/* Delete not successful (file locked). */\n\t\tmg_send_http_error(conn,\n\t\t                   423,\n\t\t                   \"Error: Cannot delete file\\nremove(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t}\n}\n#endif /* !NO_FILES */\n\n\nstatic void\nsend_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);\n\n\nstatic void\ndo_ssi_include(struct mg_connection *conn,\n               const char *ssi,\n               char *tag,\n               int include_level)\n{\n\tchar file_name[MG_BUF_LEN], path[512], *p;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tsize_t len;\n\tint truncated = 0;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\t/* sscanf() is safe here, since send_ssi_file() also uses buffer\n\t * of size MG_BUF_LEN to get the tag. So strlen(tag) is\n\t * always < MG_BUF_LEN. */\n\tif (sscanf(tag, \" virtual=\\\"%511[^\\\"]\\\"\", file_name) == 1) {\n\t\t/* File name is relative to the webserver root */\n\t\tfile_name[511] = 0;\n\t\t(void)mg_snprintf(conn,\n\t\t                  &truncated,\n\t\t                  path,\n\t\t                  sizeof(path),\n\t\t                  \"%s/%s\",\n\t\t                  conn->dom_ctx->config[DOCUMENT_ROOT],\n\t\t                  file_name);\n\n\t} else if (sscanf(tag, \" abspath=\\\"%511[^\\\"]\\\"\", file_name) == 1) {\n\t\t/* File name is relative to the webserver working directory\n\t\t * or it is absolute system path */\n\t\tfile_name[511] = 0;\n\t\t(void)\n\t\t    mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", file_name);\n\n\t} else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)\n\t           || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {\n\t\t/* File name is relative to the currect document */\n\t\tfile_name[511] = 0;\n\t\t(void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);\n\n\t\tif (!truncated) {\n\t\t\tif ((p = strrchr(path, '/')) != NULL) {\n\t\t\t\tp[1] = '\\0';\n\t\t\t}\n\t\t\tlen = strlen(path);\n\t\t\t(void)mg_snprintf(conn,\n\t\t\t                  &truncated,\n\t\t\t                  path + len,\n\t\t\t                  sizeof(path) - len,\n\t\t\t                  \"%s\",\n\t\t\t                  file_name);\n\t\t}\n\n\t} else {\n\t\tmg_cry_internal(conn, \"Bad SSI #include: [%s]\", tag);\n\t\treturn;\n\t}\n\n\tif (truncated) {\n\t\tmg_cry_internal(conn, \"SSI #include path length overflow: [%s]\", tag);\n\t\treturn;\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"Cannot open SSI #include: [%s]: fopen(%s): %s\",\n\t\t                tag,\n\t\t                path,\n\t\t                strerror(ERRNO));\n\t} else {\n\t\tfclose_on_exec(&file.access, conn);\n\t\tif (match_prefix(conn->dom_ctx->config[SSI_EXTENSIONS],\n\t\t                 strlen(conn->dom_ctx->config[SSI_EXTENSIONS]),\n\t\t                 path) > 0) {\n\t\t\tsend_ssi_file(conn, path, &file, include_level + 1);\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t}\n\t\t(void)mg_fclose(&file.access); /* Ignore errors for readonly files */\n\t}\n}\n\n\n#if !defined(NO_POPEN)\nstatic void\ndo_ssi_exec(struct mg_connection *conn, char *tag)\n{\n\tchar cmd[1024] = \"\";\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {\n\t\tmg_cry_internal(conn, \"Bad SSI #exec: [%s]\", tag);\n\t} else {\n\t\tcmd[1023] = 0;\n\t\tif ((file.access.fp = popen(cmd, \"r\")) == NULL) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Cannot SSI #exec: [%s]: %s\",\n\t\t\t                cmd,\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t\tpclose(file.access.fp);\n\t\t}\n\t}\n}\n#endif /* !NO_POPEN */\n\n\nstatic int\nmg_fgetc(struct mg_file *filep, int offset)\n{\n\t(void)offset; /* unused in case MG_USE_OPEN_FILE is set */\n\n\tif (filep == NULL) {\n\t\treturn EOF;\n\t}\n#if defined(MG_USE_OPEN_FILE)\n\tif ((filep->access.membuf != NULL) && (offset >= 0)\n\t    && (((unsigned int)(offset)) < filep->stat.size)) {\n\t\treturn ((const unsigned char *)filep->access.membuf)[offset];\n\t} else /* else block below */\n#endif\n\t    if (filep->access.fp != NULL) {\n\t\treturn fgetc(filep->access.fp);\n\t} else {\n\t\treturn EOF;\n\t}\n}\n\n\nstatic void\nsend_ssi_file(struct mg_connection *conn,\n              const char *path,\n              struct mg_file *filep,\n              int include_level)\n{\n\tchar buf[MG_BUF_LEN];\n\tint ch, offset, len, in_tag, in_ssi_tag;\n\n\tif (include_level > 10) {\n\t\tmg_cry_internal(conn, \"SSI #include level is too deep (%s)\", path);\n\t\treturn;\n\t}\n\n\tin_tag = in_ssi_tag = len = offset = 0;\n\n\t/* Read file, byte by byte, and look for SSI include tags */\n\twhile ((ch = mg_fgetc(filep, offset++)) != EOF) {\n\n\t\tif (in_tag) {\n\t\t\t/* We are in a tag, either SSI tag or html tag */\n\n\t\t\tif (ch == '>') {\n\t\t\t\t/* Tag is closing */\n\t\t\t\tbuf[len++] = '>';\n\n\t\t\t\tif (in_ssi_tag) {\n\t\t\t\t\t/* Handle SSI tag */\n\t\t\t\t\tbuf[len] = 0;\n\n\t\t\t\t\tif (!memcmp(buf + 5, \"include\", 7)) {\n\t\t\t\t\t\tdo_ssi_include(conn, path, buf + 12, include_level + 1);\n#if !defined(NO_POPEN)\n\t\t\t\t\t} else if (!memcmp(buf + 5, \"exec\", 4)) {\n\t\t\t\t\t\tdo_ssi_exec(conn, buf + 9);\n#endif /* !NO_POPEN */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t\t\t                \"%s: unknown SSI \"\n\t\t\t\t\t\t                \"command: \\\"%s\\\"\",\n\t\t\t\t\t\t                path,\n\t\t\t\t\t\t                buf);\n\t\t\t\t\t}\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tin_ssi_tag = in_tag = 0;\n\n\t\t\t\t} else {\n\t\t\t\t\t/* Not an SSI tag */\n\t\t\t\t\t/* Flush buffer */\n\t\t\t\t\t(void)mg_write(conn, buf, (size_t)len);\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tin_tag = 0;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* Tag is still open */\n\t\t\t\tbuf[len++] = (char)(ch & 0xff);\n\n\t\t\t\tif ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {\n\t\t\t\t\t/* All SSI tags start with <!--# */\n\t\t\t\t\tin_ssi_tag = 1;\n\t\t\t\t}\n\n\t\t\t\tif ((len + 2) > (int)sizeof(buf)) {\n\t\t\t\t\t/* Tag to long for buffer */\n\t\t\t\t\tmg_cry_internal(conn, \"%s: tag is too large\", path);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t/* We are not in a tag yet. */\n\t\t\tif (ch == '<') {\n\t\t\t\t/* Tag is opening */\n\t\t\t\tin_tag = 1;\n\n\t\t\t\tif (len > 0) {\n\t\t\t\t\t/* Flush current buffer.\n\t\t\t\t\t * Buffer is filled with \"len\" bytes. */\n\t\t\t\t\t(void)mg_write(conn, buf, (size_t)len);\n\t\t\t\t}\n\t\t\t\t/* Store the < */\n\t\t\t\tlen = 1;\n\t\t\t\tbuf[0] = '<';\n\n\t\t\t} else {\n\t\t\t\t/* No Tag */\n\t\t\t\t/* Add data to buffer */\n\t\t\t\tbuf[len++] = (char)(ch & 0xff);\n\t\t\t\t/* Flush if buffer is full */\n\t\t\t\tif (len == (int)sizeof(buf)) {\n\t\t\t\t\tmg_write(conn, buf, (size_t)len);\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send the rest of buffered data */\n\tif (len > 0) {\n\t\tmg_write(conn, buf, (size_t)len);\n\t}\n}\n\n\nstatic void\nhandle_ssi_file_request(struct mg_connection *conn,\n                        const char *path,\n                        struct mg_file *filep)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tconst char *cors1, *cors2, *cors3;\n\n\tif ((conn == NULL) || (path == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tif (mg_get_header(conn, \"Origin\")) {\n\t\t/* Cross-origin resource sharing (CORS). */\n\t\tcors1 = \"Access-Control-Allow-Origin: \";\n\t\tcors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tcors3 = \"\\r\\n\";\n\t} else {\n\t\tcors1 = cors2 = cors3 = \"\";\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {\n\t\t/* File exists (precondition for calling this function),\n\t\t * but can not be opened by the server. */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot read file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t} else {\n\t\tconn->must_close = 1;\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tfclose_on_exec(&filep->access, conn);\n\t\tmg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"%s%s%s\"\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Content-Type: text/html\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          cors1,\n\t\t          cors2,\n\t\t          cors3,\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\t\tsend_ssi_file(conn, path, filep, 0);\n\t\t(void)mg_fclose(&filep->access); /* Ignore errors for readonly files */\n\t}\n}\n\n\n#if !defined(NO_FILES)\nstatic void\nsend_options(struct mg_connection *conn)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\tconn->status_code = 200;\n\tconn->must_close = 1;\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\t/* We do not set a \"Cache-Control\" header here, but leave the default.\n\t * Since browsers do not send an OPTIONS request, we can not test the\n\t * effect anyway. */\n\tmg_printf(conn,\n\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\"\n\t          \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, \"\n\t          \"PROPFIND, MKCOL\\r\\n\"\n\t          \"DAV: 1\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn));\n\tsend_additional_header(conn);\n\tmg_printf(conn, \"\\r\\n\");\n}\n\n\n/* Writes PROPFIND properties for a collection element */\nstatic void\nprint_props(struct mg_connection *conn,\n            const char *uri,\n            struct mg_file_stat *filep)\n{\n\tchar mtime[64];\n\n\tif ((conn == NULL) || (uri == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tgmt_time_string(mtime, sizeof(mtime), &filep->last_modified);\n\tmg_printf(conn,\n\t          \"<d:response>\"\n\t          \"<d:href>%s</d:href>\"\n\t          \"<d:propstat>\"\n\t          \"<d:prop>\"\n\t          \"<d:resourcetype>%s</d:resourcetype>\"\n\t          \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"\n\t          \"<d:getlastmodified>%s</d:getlastmodified>\"\n\t          \"</d:prop>\"\n\t          \"<d:status>HTTP/1.1 200 OK</d:status>\"\n\t          \"</d:propstat>\"\n\t          \"</d:response>\\n\",\n\t          uri,\n\t          filep->is_directory ? \"<d:collection/>\" : \"\",\n\t          filep->size,\n\t          mtime);\n}\n\n\nstatic int\nprint_dav_dir_entry(struct de *de, void *data)\n{\n\tchar href[PATH_MAX];\n\tint truncated;\n\n\tstruct mg_connection *conn = (struct mg_connection *)data;\n\tif (!de || !conn) {\n\t\treturn -1;\n\t}\n\tmg_snprintf(conn,\n\t            &truncated,\n\t            href,\n\t            sizeof(href),\n\t            \"%s%s\",\n\t            conn->request_info.local_uri,\n\t            de->file_name);\n\n\tif (!truncated) {\n\t\tsize_t href_encoded_size;\n\t\tchar *href_encoded;\n\n\t\thref_encoded_size = PATH_MAX * 3; /* worst case */\n\t\thref_encoded = (char *)mg_malloc(href_encoded_size);\n\t\tif (href_encoded == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tmg_url_encode(href, href_encoded, href_encoded_size);\n\t\tprint_props(conn, href_encoded, &de->file);\n\t\tmg_free(href_encoded);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_propfind(struct mg_connection *conn,\n                const char *path,\n                struct mg_file_stat *filep)\n{\n\tconst char *depth = mg_get_header(conn, \"Depth\");\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tif (!conn || !path || !filep || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tconn->must_close = 1;\n\tconn->status_code = 207;\n\tmg_printf(conn,\n\t          \"HTTP/1.1 207 Multi-Status\\r\\n\"\n\t          \"Date: %s\\r\\n\",\n\t          date);\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Connection: %s\\r\\n\"\n\t          \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\",\n\t          suggest_connection_header(conn));\n\n\tmg_printf(conn,\n\t          \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t          \"<d:multistatus xmlns:d='DAV:'>\\n\");\n\n\t/* Print properties for the requested resource itself */\n\tprint_props(conn, conn->request_info.local_uri, filep);\n\n\t/* If it is a directory, print directory entries too if Depth is not 0\n\t */\n\tif (filep->is_directory\n\t    && !mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t                      \"yes\")\n\t    && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {\n\t\tscan_directory(conn, path, conn, &print_dav_dir_entry);\n\t}\n\n\tmg_printf(conn, \"%s\\n\", \"</d:multistatus>\");\n}\n#endif\n\nvoid\nmg_lock_connection(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\t(void)pthread_mutex_lock(&conn->mutex);\n\t}\n}\n\nvoid\nmg_unlock_connection(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\t(void)pthread_mutex_unlock(&conn->mutex);\n\t}\n}\n\nvoid\nmg_lock_context(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\t(void)pthread_mutex_lock(&ctx->nonce_mutex);\n\t}\n}\n\nvoid\nmg_unlock_context(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\t(void)pthread_mutex_unlock(&ctx->nonce_mutex);\n\t}\n}\n\n\n#if defined(USE_LUA)\n#include \"mod_lua.inl\"\n#endif /* USE_LUA */\n\n#if defined(USE_DUKTAPE)\n#include \"mod_duktape.inl\"\n#endif /* USE_DUKTAPE */\n\n#if defined(USE_WEBSOCKET)\n\n#if !defined(NO_SSL_DL)\n#define SHA_API static\n#include \"sha1.inl\"\n#endif\n\nstatic int\nsend_websocket_handshake(struct mg_connection *conn, const char *websock_key)\n{\n\tstatic const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\tchar buf[100], sha[20], b64_sha[sizeof(sha) * 2];\n\tSHA_CTX sha_ctx;\n\tint truncated;\n\n\t/* Calculate Sec-WebSocket-Accept reply from Sec-WebSocket-Key. */\n\tmg_snprintf(conn, &truncated, buf, sizeof(buf), \"%s%s\", websock_key, magic);\n\tif (truncated) {\n\t\tconn->must_close = 1;\n\t\treturn 0;\n\t}\n\n\tDEBUG_TRACE(\"%s\", \"Send websocket handshake\");\n\n\tSHA1_Init(&sha_ctx);\n\tSHA1_Update(&sha_ctx, (unsigned char *)buf, (uint32_t)strlen(buf));\n\tSHA1_Final((unsigned char *)sha, &sha_ctx);\n\tbase64_encode((unsigned char *)sha, sizeof(sha), b64_sha);\n\tmg_printf(conn,\n\t          \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n\t          \"Upgrade: websocket\\r\\n\"\n\t          \"Connection: Upgrade\\r\\n\"\n\t          \"Sec-WebSocket-Accept: %s\\r\\n\",\n\t          b64_sha);\n\tif (conn->request_info.acceptedWebSocketSubprotocol) {\n\t\tmg_printf(conn,\n\t\t          \"Sec-WebSocket-Protocol: %s\\r\\n\\r\\n\",\n\t\t          conn->request_info.acceptedWebSocketSubprotocol);\n\t} else {\n\t\tmg_printf(conn, \"%s\", \"\\r\\n\");\n\t}\n\n\treturn 1;\n}\n\n\n#if !defined(MG_MAX_UNANSWERED_PING)\n/* Configuration of the maximum number of websocket PINGs that might\n * stay unanswered before the connection is considered broken.\n * Note: The name of this define may still change (until it is\n * defined as a compile parameter in a documentation).\n */\n#define MG_MAX_UNANSWERED_PING (5)\n#endif\n\n\nstatic void\nread_websocket(struct mg_connection *conn,\n               mg_websocket_data_handler ws_data_handler,\n               void *callback_data)\n{\n\t/* Pointer to the beginning of the portion of the incoming websocket\n\t * message queue.\n\t * The original websocket upgrade request is never removed, so the queue\n\t * begins after it. */\n\tunsigned char *buf = (unsigned char *)conn->buf + conn->request_len;\n\tint n, error, exit_by_callback;\n\tint ret;\n\n\t/* body_len is the length of the entire queue in bytes\n\t * len is the length of the current message\n\t * data_len is the length of the current message's data payload\n\t * header_len is the length of the current message's header */\n\tsize_t i, len, mask_len = 0, header_len, body_len;\n\tuint64_t data_len = 0;\n\n\t/* \"The masking key is a 32-bit value chosen at random by the client.\"\n\t * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5\n\t*/\n\tunsigned char mask[4];\n\n\t/* data points to the place where the message is stored when passed to\n\t * the websocket_data callback.  This is either mem on the stack, or a\n\t * dynamically allocated buffer if it is too large. */\n\tunsigned char mem[4096];\n\tunsigned char mop; /* mask flag and opcode */\n\n\n\t/* Variables used for connection monitoring */\n\tdouble timeout = -1.0;\n\tint enable_ping_pong = 0;\n\tint ping_count = 0;\n\n\tif (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {\n\t\tenable_ping_pong =\n\t\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],\n\t\t                   \"yes\");\n\t}\n\n\tif (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;\n\t}\n\tif ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\t/* Enter data processing loop */\n\tDEBUG_TRACE(\"Websocket connection %s:%u start data processing loop\",\n\t            conn->request_info.remote_addr,\n\t            conn->request_info.remote_port);\n\tconn->in_websocket_handling = 1;\n\tmg_set_thread_name(\"wsock\");\n\n\t/* Loop continuously, reading messages from the socket, invoking the\n\t * callback, and waiting repeatedly until an error occurs. */\n\twhile (!conn->phys_ctx->stop_flag && !conn->must_close) {\n\t\theader_len = 0;\n\t\tDEBUG_ASSERT(conn->data_len >= conn->request_len);\n\t\tif ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {\n\t\t\tlen = buf[1] & 127;\n\t\t\tmask_len = (buf[1] & 128) ? 4 : 0;\n\t\t\tif ((len < 126) && (body_len >= mask_len)) {\n\t\t\t\t/* inline 7-bit length field */\n\t\t\t\tdata_len = len;\n\t\t\t\theader_len = 2 + mask_len;\n\t\t\t} else if ((len == 126) && (body_len >= (4 + mask_len))) {\n\t\t\t\t/* 16-bit length field */\n\t\t\t\theader_len = 4 + mask_len;\n\t\t\t\tdata_len = ((((size_t)buf[2]) << 8) + buf[3]);\n\t\t\t} else if (body_len >= (10 + mask_len)) {\n\t\t\t\t/* 64-bit length field */\n\t\t\t\tuint32_t l1, l2;\n\t\t\t\tmemcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */\n\t\t\t\tmemcpy(&l2, &buf[6], 4);\n\t\t\t\theader_len = 10 + mask_len;\n\t\t\t\tdata_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);\n\n\t\t\t\tif (data_len > (uint64_t)0x7FFF0000ul) {\n\t\t\t\t\t/* no can do */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"websocket out of memory; closing connection\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((header_len > 0) && (body_len >= header_len)) {\n\t\t\t/* Allocate space to hold websocket payload */\n\t\t\tunsigned char *data = mem;\n\n\t\t\tif ((size_t)data_len > (size_t)sizeof(mem)) {\n\t\t\t\tdata = (unsigned char *)mg_malloc_ctx((size_t)data_len,\n\t\t\t\t                                      conn->phys_ctx);\n\t\t\t\tif (data == NULL) {\n\t\t\t\t\t/* Allocation failed, exit the loop and then close the\n\t\t\t\t\t * connection */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"websocket out of memory; closing connection\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Copy the mask before we shift the queue and destroy it */\n\t\t\tif (mask_len > 0) {\n\t\t\t\tmemcpy(mask, buf + header_len - mask_len, sizeof(mask));\n\t\t\t} else {\n\t\t\t\tmemset(mask, 0, sizeof(mask));\n\t\t\t}\n\n\t\t\t/* Read frame payload from the first message in the queue into\n\t\t\t * data and advance the queue by moving the memory in place. */\n\t\t\tDEBUG_ASSERT(body_len >= header_len);\n\t\t\tif (data_len + (uint64_t)header_len > (uint64_t)body_len) {\n\t\t\t\tmop = buf[0]; /* current mask and opcode */\n\t\t\t\t/* Overflow case */\n\t\t\t\tlen = body_len - header_len;\n\t\t\t\tmemcpy(data, buf + header_len, len);\n\t\t\t\terror = 0;\n\t\t\t\twhile ((uint64_t)len < data_len) {\n\t\t\t\t\tn = pull_inner(NULL,\n\t\t\t\t\t               conn,\n\t\t\t\t\t               (char *)(data + len),\n\t\t\t\t\t               (int)(data_len - len),\n\t\t\t\t\t               timeout);\n\t\t\t\t\tif (n <= -2) {\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (n > 0) {\n\t\t\t\t\t\tlen += (size_t)n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Timeout: should retry */\n\t\t\t\t\t\t/* TODO: retry condition */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"Websocket pull failed; closing connection\");\n\t\t\t\t\tif (data != mem) {\n\t\t\t\t\t\tmg_free(data);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconn->data_len = conn->request_len;\n\n\t\t\t} else {\n\n\t\t\t\tmop = buf[0]; /* current mask and opcode, overwritten by\n\t\t\t\t               * memmove() */\n\n\t\t\t\t/* Length of the message being read at the front of the\n\t\t\t\t * queue. Cast to 31 bit is OK, since we limited\n\t\t\t\t * data_len before. */\n\t\t\t\tlen = (size_t)data_len + header_len;\n\n\t\t\t\t/* Copy the data payload into the data pointer for the\n\t\t\t\t * callback. Cast to 31 bit is OK, since we\n\t\t\t\t * limited data_len */\n\t\t\t\tmemcpy(data, buf + header_len, (size_t)data_len);\n\n\t\t\t\t/* Move the queue forward len bytes */\n\t\t\t\tmemmove(buf, buf + len, body_len - len);\n\n\t\t\t\t/* Mark the queue as advanced */\n\t\t\t\tconn->data_len -= (int)len;\n\t\t\t}\n\n\t\t\t/* Apply mask if necessary */\n\t\t\tif (mask_len > 0) {\n\t\t\t\tfor (i = 0; i < (size_t)data_len; i++) {\n\t\t\t\t\tdata[i] ^= mask[i & 3];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texit_by_callback = 0;\n\t\t\tif (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {\n\t\t\t\t/* filter PONG messages */\n\t\t\t\tDEBUG_TRACE(\"PONG from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t/* No unanwered PINGs left */\n\t\t\t\tping_count = 0;\n\t\t\t} else if (enable_ping_pong\n\t\t\t           && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {\n\t\t\t\t/* reply PING messages */\n\t\t\t\tDEBUG_TRACE(\"Reply PING from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tret = mg_websocket_write(conn,\n\t\t\t\t                         MG_WEBSOCKET_OPCODE_PONG,\n\t\t\t\t                         (char *)data,\n\t\t\t\t                         (size_t)data_len);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\t/* Error: send failed */\n\t\t\t\t\tDEBUG_TRACE(\"Reply PONG failed (%i)\", ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t} else {\n\t\t\t\t/* Exit the loop if callback signals to exit (server side),\n\t\t\t\t * or \"connection close\" opcode received (client side). */\n\t\t\t\tif ((ws_data_handler != NULL)\n\t\t\t\t    && !ws_data_handler(conn,\n\t\t\t\t                        mop,\n\t\t\t\t                        (char *)data,\n\t\t\t\t                        (size_t)data_len,\n\t\t\t\t                        callback_data)) {\n\t\t\t\t\texit_by_callback = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* It a buffer has been allocated, free it again */\n\t\t\tif (data != mem) {\n\t\t\t\tmg_free(data);\n\t\t\t}\n\n\t\t\tif (exit_by_callback) {\n\t\t\t\tDEBUG_TRACE(\"Callback requests to close connection from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {\n\t\t\t\t/* Opcode == 8, connection close */\n\t\t\t\tDEBUG_TRACE(\"Message requests to close connection from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Not breaking the loop, process next websocket frame. */\n\t\t} else {\n\t\t\t/* Read from the socket into the next available location in the\n\t\t\t * message queue. */\n\t\t\tn = pull_inner(NULL,\n\t\t\t               conn,\n\t\t\t               conn->buf + conn->data_len,\n\t\t\t               conn->buf_size - conn->data_len,\n\t\t\t               timeout);\n\t\t\tif (n <= -2) {\n\t\t\t\t/* Error, no bytes read */\n\t\t\t\tDEBUG_TRACE(\"PULL from %s:%u failed\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n > 0) {\n\t\t\t\tconn->data_len += n;\n\t\t\t\t/* Reset open PING count */\n\t\t\t\tping_count = 0;\n\t\t\t} else {\n\t\t\t\tif (!conn->phys_ctx->stop_flag && !conn->must_close) {\n\t\t\t\t\tif (ping_count > MG_MAX_UNANSWERED_PING) {\n\t\t\t\t\t\t/* Stop sending PING */\n\t\t\t\t\t\tDEBUG_TRACE(\"Too many (%i) unanswered ping from %s:%u \"\n\t\t\t\t\t\t            \"- closing connection\",\n\t\t\t\t\t\t            ping_count,\n\t\t\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (enable_ping_pong) {\n\t\t\t\t\t\t/* Send Websocket PING message */\n\t\t\t\t\t\tDEBUG_TRACE(\"PING to %s:%u\",\n\t\t\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t\t\tret = mg_websocket_write(conn,\n\t\t\t\t\t\t                         MG_WEBSOCKET_OPCODE_PING,\n\t\t\t\t\t\t                         NULL,\n\t\t\t\t\t\t                         0);\n\n\t\t\t\t\t\tif (ret <= 0) {\n\t\t\t\t\t\t\t/* Error: send failed */\n\t\t\t\t\t\t\tDEBUG_TRACE(\"Send PING failed (%i)\", ret);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tping_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Timeout: should retry */\n\t\t\t\t/* TODO: get timeout def */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Leave data processing loop */\n\tmg_set_thread_name(\"worker\");\n\tconn->in_websocket_handling = 0;\n\tDEBUG_TRACE(\"Websocket connection %s:%u left data processing loop\",\n\t            conn->request_info.remote_addr,\n\t            conn->request_info.remote_port);\n}\n\n\nstatic int\nmg_websocket_write_exec(struct mg_connection *conn,\n                        int opcode,\n                        const char *data,\n                        size_t dataLen,\n                        uint32_t masking_key)\n{\n\tunsigned char header[14];\n\tsize_t headerLen;\n\tint retval;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Disable spurious conversion warning for GCC */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n\n\theader[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif\n\n\t/* Frame format: http://tools.ietf.org/html/rfc6455#section-5.2 */\n\tif (dataLen < 126) {\n\t\t/* inline 7-bit length field */\n\t\theader[1] = (unsigned char)dataLen;\n\t\theaderLen = 2;\n\t} else if (dataLen <= 0xFFFF) {\n\t\t/* 16-bit length field */\n\t\tuint16_t len = htons((uint16_t)dataLen);\n\t\theader[1] = 126;\n\t\tmemcpy(header + 2, &len, 2);\n\t\theaderLen = 4;\n\t} else {\n\t\t/* 64-bit length field */\n\t\tuint32_t len1 = htonl((uint32_t)((uint64_t)dataLen >> 32));\n\t\tuint32_t len2 = htonl((uint32_t)(dataLen & 0xFFFFFFFFu));\n\t\theader[1] = 127;\n\t\tmemcpy(header + 2, &len1, 4);\n\t\tmemcpy(header + 6, &len2, 4);\n\t\theaderLen = 10;\n\t}\n\n\tif (masking_key) {\n\t\t/* add mask */\n\t\theader[1] |= 0x80;\n\t\tmemcpy(header + headerLen, &masking_key, 4);\n\t\theaderLen += 4;\n\t}\n\n\t/* Note that POSIX/Winsock's send() is threadsafe\n\t * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid\n\t * but mongoose's mg_printf/mg_write is not (because of the loop in\n\t * push(), although that is only a problem if the packet is large or\n\t * outgoing buffer is full). */\n\n\t/* TODO: Check if this lock should be moved to user land.\n\t * Currently the server sets this lock for websockets, but\n\t * not for any other connection. It must be set for every\n\t * conn read/written by more than one thread, no matter if\n\t * it is a websocket or regular connection. */\n\t(void)mg_lock_connection(conn);\n\n\tretval = mg_write(conn, header, headerLen);\n\tif (retval != (int)headerLen) {\n\t\t/* Did not send complete header */\n\t\tretval = -1;\n\t} else {\n\t\tif (dataLen > 0) {\n\t\t\tretval = mg_write(conn, data, dataLen);\n\t\t}\n\t\t/* if dataLen == 0, the header length (2) is returned */\n\t}\n\n\t/* TODO: Remove this unlock as well, when lock is removed. */\n\tmg_unlock_connection(conn);\n\n\treturn retval;\n}\n\nint\nmg_websocket_write(struct mg_connection *conn,\n                   int opcode,\n                   const char *data,\n                   size_t dataLen)\n{\n\treturn mg_websocket_write_exec(conn, opcode, data, dataLen, 0);\n}\n\n\nstatic void\nmask_data(const char *in, size_t in_len, uint32_t masking_key, char *out)\n{\n\tsize_t i = 0;\n\n\ti = 0;\n\tif ((in_len > 3) && ((ptrdiff_t)in % 4) == 0) {\n\t\t/* Convert in 32 bit words, if data is 4 byte aligned */\n\t\twhile (i < (in_len - 3)) {\n\t\t\t*(uint32_t *)(void *)(out + i) =\n\t\t\t    *(uint32_t *)(void *)(in + i) ^ masking_key;\n\t\t\ti += 4;\n\t\t}\n\t}\n\tif (i != in_len) {\n\t\t/* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/\n\t\twhile (i < in_len) {\n\t\t\t*(uint8_t *)(void *)(out + i) =\n\t\t\t    *(uint8_t *)(void *)(in + i)\n\t\t\t    ^ *(((uint8_t *)&masking_key) + (i % 4));\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n\nint\nmg_websocket_client_write(struct mg_connection *conn,\n                          int opcode,\n                          const char *data,\n                          size_t dataLen)\n{\n\tint retval = -1;\n\tchar *masked_data =\n\t    (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);\n\tuint32_t masking_key = 0;\n\n\tif (masked_data == NULL) {\n\t\t/* Return -1 in an error case */\n\t\tmg_cry_internal(conn,\n\t\t                \"%s\",\n\t\t                \"Cannot allocate buffer for masked websocket response: \"\n\t\t                \"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\t/* Get a masking key - but not 0 */\n\t\tmasking_key = (uint32_t)get_random();\n\t} while (masking_key == 0);\n\n\tmask_data(data, dataLen, masking_key, masked_data);\n\n\tretval = mg_websocket_write_exec(\n\t    conn, opcode, masked_data, dataLen, masking_key);\n\tmg_free(masked_data);\n\n\treturn retval;\n}\n\n\nstatic void\nhandle_websocket_request(struct mg_connection *conn,\n                         const char *path,\n                         int is_callback_resource,\n                         struct mg_websocket_subprotocols *subprotocols,\n                         mg_websocket_connect_handler ws_connect_handler,\n                         mg_websocket_ready_handler ws_ready_handler,\n                         mg_websocket_data_handler ws_data_handler,\n                         mg_websocket_close_handler ws_close_handler,\n                         void *cbData)\n{\n\tconst char *websock_key = mg_get_header(conn, \"Sec-WebSocket-Key\");\n\tconst char *version = mg_get_header(conn, \"Sec-WebSocket-Version\");\n\tptrdiff_t lua_websock = 0;\n\n#if !defined(USE_LUA)\n\t(void)path;\n#endif\n\n\t/* Step 1: Check websocket protocol version. */\n\t/* Step 1.1: Check Sec-WebSocket-Key. */\n\tif (!websock_key) {\n\t\t/* The RFC standard version (https://tools.ietf.org/html/rfc6455)\n\t\t * requires a Sec-WebSocket-Key header.\n\t\t */\n\t\t/* It could be the hixie draft version\n\t\t * (http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76).\n\t\t */\n\t\tconst char *key1 = mg_get_header(conn, \"Sec-WebSocket-Key1\");\n\t\tconst char *key2 = mg_get_header(conn, \"Sec-WebSocket-Key2\");\n\t\tchar key3[8];\n\n\t\tif ((key1 != NULL) && (key2 != NULL)) {\n\t\t\t/* This version uses 8 byte body data in a GET request */\n\t\t\tconn->content_len = 8;\n\t\t\tif (8 == mg_read(conn, key3, 8)) {\n\t\t\t\t/* This is the hixie version */\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   426,\n\t\t\t\t                   \"%s\",\n\t\t\t\t                   \"Protocol upgrade to RFC 6455 required\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* This is an unknown version */\n\t\tmg_send_http_error(conn, 400, \"%s\", \"Malformed websocket request\");\n\t\treturn;\n\t}\n\n\t/* Step 1.2: Check websocket protocol version. */\n\t/* The RFC version (https://tools.ietf.org/html/rfc6455) is 13. */\n\tif ((version == NULL) || (strcmp(version, \"13\") != 0)) {\n\t\t/* Reject wrong versions */\n\t\tmg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");\n\t\treturn;\n\t}\n\n\t/* Step 1.3: Could check for \"Host\", but we do not really nead this\n\t * value for anything, so just ignore it. */\n\n\t/* Step 2: If a callback is responsible, call it. */\n\tif (is_callback_resource) {\n\t\t/* Step 2.1 check and select subprotocol */\n\t\tconst char *protocols[64]; // max 64 headers\n\t\tint nbSubprotocolHeader = get_req_headers(&conn->request_info,\n\t\t                                          \"Sec-WebSocket-Protocol\",\n\t\t                                          protocols,\n\t\t                                          64);\n\t\tif ((nbSubprotocolHeader > 0) && subprotocols) {\n\t\t\tint cnt = 0;\n\t\t\tint idx;\n\t\t\tunsigned long len;\n\t\t\tconst char *sep, *curSubProtocol,\n\t\t\t    *acceptedWebSocketSubprotocol = NULL;\n\n\n\t\t\t/* look for matching subprotocol */\n\t\t\tdo {\n\t\t\t\tconst char *protocol = protocols[cnt];\n\n\t\t\t\tdo {\n\t\t\t\t\tsep = strchr(protocol, ',');\n\t\t\t\t\tcurSubProtocol = protocol;\n\t\t\t\t\tlen = sep ? (unsigned long)(sep - protocol)\n\t\t\t\t\t          : (unsigned long)strlen(protocol);\n\t\t\t\t\twhile (sep && isspace(*++sep))\n\t\t\t\t\t\t; // ignore leading whitespaces\n\t\t\t\t\tprotocol = sep;\n\n\n\t\t\t\t\tfor (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {\n\t\t\t\t\t\tif ((strlen(subprotocols->subprotocols[idx]) == len)\n\t\t\t\t\t\t    && (strncmp(curSubProtocol,\n\t\t\t\t\t\t                subprotocols->subprotocols[idx],\n\t\t\t\t\t\t                len) == 0)) {\n\t\t\t\t\t\t\tacceptedWebSocketSubprotocol =\n\t\t\t\t\t\t\t    subprotocols->subprotocols[idx];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (sep && !acceptedWebSocketSubprotocol);\n\t\t\t} while (++cnt < nbSubprotocolHeader\n\t\t\t         && !acceptedWebSocketSubprotocol);\n\n\t\t\tconn->request_info.acceptedWebSocketSubprotocol =\n\t\t\t    acceptedWebSocketSubprotocol;\n\n\t\t} else if (nbSubprotocolHeader > 0) {\n\t\t\t/* keep legacy behavior */\n\t\t\tconst char *protocol = protocols[0];\n\n\t\t\t/* The protocol is a comma separated list of names. */\n\t\t\t/* The server must only return one value from this list. */\n\t\t\t/* First check if it is a list or just a single value. */\n\t\t\tconst char *sep = strrchr(protocol, ',');\n\t\t\tif (sep == NULL) {\n\t\t\t\t/* Just a single protocol -> accept it. */\n\t\t\t\tconn->request_info.acceptedWebSocketSubprotocol = protocol;\n\t\t\t} else {\n\t\t\t\t/* Multiple protocols -> accept the last one. */\n\t\t\t\t/* This is just a quick fix if the client offers multiple\n\t\t\t\t * protocols. The handler should have a list of accepted\n\t\t\t\t * protocols on his own\n\t\t\t\t * and use it to select one protocol among those the client\n\t\t\t\t * has\n\t\t\t\t * offered.\n\t\t\t\t */\n\t\t\t\twhile (isspace(*++sep)) {\n\t\t\t\t\t; /* ignore leading whitespaces */\n\t\t\t\t}\n\t\t\t\tconn->request_info.acceptedWebSocketSubprotocol = sep;\n\t\t\t}\n\t\t}\n\n\t\tif ((ws_connect_handler != NULL)\n\t\t    && (ws_connect_handler(conn, cbData) != 0)) {\n\t\t\t/* C callback has returned non-zero, do not proceed with\n\t\t\t * handshake.\n\t\t\t */\n\t\t\t/* Note that C callbacks are no longer called when Lua is\n\t\t\t * responsible, so C can no longer filter callbacks for Lua. */\n\t\t\treturn;\n\t\t}\n\t}\n\n#if defined(USE_LUA)\n\t/* Step 3: No callback. Check if Lua is responsible. */\n\telse {\n\t\t/* Step 3.1: Check if Lua is responsible. */\n\t\tif (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {\n\t\t\tlua_websock = match_prefix(\n\t\t\t    conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS],\n\t\t\t    strlen(conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]),\n\t\t\t    path);\n\t\t}\n\n\t\tif (lua_websock) {\n\t\t\t/* Step 3.2: Lua is responsible: call it. */\n\t\t\tconn->lua_websocket_state = lua_websocket_new(path, conn);\n\t\t\tif (!conn->lua_websocket_state) {\n\t\t\t\t/* Lua rejected the new client */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t/* Step 4: Check if there is a responsible websocket handler. */\n\tif (!is_callback_resource && !lua_websock) {\n\t\t/* There is no callback, and Lua is not responsible either. */\n\t\t/* Reply with a 404 Not Found. We are still at a standard\n\t\t * HTTP request here, before the websocket handshake, so\n\t\t * we can still send standard HTTP error replies. */\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n\t\treturn;\n\t}\n\n\t/* Step 5: The websocket connection has been accepted */\n\tif (!send_websocket_handshake(conn, websock_key)) {\n\t\tmg_send_http_error(conn, 500, \"%s\", \"Websocket handshake failed\");\n\t\treturn;\n\t}\n\n\t/* Step 6: Call the ready handler */\n\tif (is_callback_resource) {\n\t\tif (ws_ready_handler != NULL) {\n\t\t\tws_ready_handler(conn, cbData);\n\t\t}\n#if defined(USE_LUA)\n\t} else if (lua_websock) {\n\t\tif (!lua_websocket_ready(conn, conn->lua_websocket_state)) {\n\t\t\t/* the ready handler returned false */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\n\t/* Step 7: Enter the read loop */\n\tif (is_callback_resource) {\n\t\tread_websocket(conn, ws_data_handler, cbData);\n#if defined(USE_LUA)\n\t} else if (lua_websock) {\n\t\tread_websocket(conn, lua_websocket_data, conn->lua_websocket_state);\n#endif\n\t}\n\n\t/* Step 8: Call the close handler */\n\tif (ws_close_handler) {\n\t\tws_close_handler(conn, cbData);\n\t}\n}\n\n\nstatic int\nis_websocket_protocol(const struct mg_connection *conn)\n{\n\tconst char *upgrade, *connection;\n\n\t/* A websocket protocoll has the following HTTP headers:\n\t *\n\t * Connection: Upgrade\n\t * Upgrade: Websocket\n\t */\n\n\tupgrade = mg_get_header(conn, \"Upgrade\");\n\tif (upgrade == NULL) {\n\t\treturn 0; /* fail early, don't waste time checking other header\n\t\t           * fields\n\t\t             */\n\t}\n\tif (!mg_strcasestr(upgrade, \"websocket\")) {\n\t\treturn 0;\n\t}\n\n\tconnection = mg_get_header(conn, \"Connection\");\n\tif (connection == NULL) {\n\t\treturn 0;\n\t}\n\tif (!mg_strcasestr(connection, \"upgrade\")) {\n\t\treturn 0;\n\t}\n\n\t/* The headers \"Host\", \"Sec-WebSocket-Key\", \"Sec-WebSocket-Protocol\" and\n\t * \"Sec-WebSocket-Version\" are also required.\n\t * Don't check them here, since even an unsupported websocket protocol\n\t * request still IS a websocket request (in contrast to a standard HTTP\n\t * request). It will fail later in handle_websocket_request.\n\t */\n\n\treturn 1;\n}\n#endif /* !USE_WEBSOCKET */\n\n\nstatic int\nisbyte(int n)\n{\n\treturn (n >= 0) && (n <= 255);\n}\n\n\nstatic int\nparse_net(const char *spec, uint32_t *net, uint32_t *mask)\n{\n\tint n, a, b, c, d, slash = 32, len = 0;\n\n\tif (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)\n\t     || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))\n\t    && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)\n\t    && (slash < 33)) {\n\t\tlen = n;\n\t\t*net = ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8)\n\t\t       | (uint32_t)d;\n\t\t*mask = slash ? (0xffffffffU << (32 - slash)) : 0;\n\t}\n\n\treturn len;\n}\n\n\nstatic int\nset_throttle(const char *spec, uint32_t remote_ip, const char *uri)\n{\n\tint throttle = 0;\n\tstruct vec vec, val;\n\tuint32_t net, mask;\n\tchar mult;\n\tdouble v;\n\n\twhile ((spec = next_option(spec, &vec, &val)) != NULL) {\n\t\tmult = ',';\n\t\tif ((val.ptr == NULL) || (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1)\n\t\t    || (v < 0) || ((lowercase(&mult) != 'k')\n\t\t                   && (lowercase(&mult) != 'm') && (mult != ','))) {\n\t\t\tcontinue;\n\t\t}\n\t\tv *= (lowercase(&mult) == 'k')\n\t\t         ? 1024\n\t\t         : ((lowercase(&mult) == 'm') ? 1048576 : 1);\n\t\tif (vec.len == 1 && vec.ptr[0] == '*') {\n\t\t\tthrottle = (int)v;\n\t\t} else if (parse_net(vec.ptr, &net, &mask) > 0) {\n\t\t\tif ((remote_ip & mask) == net) {\n\t\t\t\tthrottle = (int)v;\n\t\t\t}\n\t\t} else if (match_prefix(vec.ptr, vec.len, uri) > 0) {\n\t\t\tthrottle = (int)v;\n\t\t}\n\t}\n\n\treturn throttle;\n}\n\n\nstatic uint32_t\nget_remote_ip(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\treturn ntohl(*(const uint32_t *)&conn->client.rsa.sin.sin_addr);\n}\n\n\n/* The mg_upload function is superseeded by mg_handle_form_request. */\n#include \"handle_form.inl\"\n\n\n#if defined(MG_LEGACY_INTERFACE)\n/* Implement the deprecated mg_upload function by calling the new\n * mg_handle_form_request function. While mg_upload could only handle\n * HTML forms sent as POST request in multipart/form-data format\n * containing only file input elements, mg_handle_form_request can\n * handle all form input elements and all standard request methods. */\nstruct mg_upload_user_data {\n\tstruct mg_connection *conn;\n\tconst char *destination_dir;\n\tint num_uploaded_files;\n};\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_found(const char *key,\n                      const char *filename,\n                      char *path,\n                      size_t pathlen,\n                      void *user_data)\n{\n\tint truncated = 0;\n\tstruct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;\n\t(void)key;\n\n\tif (!filename) {\n\t\tmg_cry_internal(fud->conn, \"%s: No filename set\", __func__);\n\t\treturn FORM_FIELD_STORAGE_ABORT;\n\t}\n\tmg_snprintf(fud->conn,\n\t            &truncated,\n\t            path,\n\t            pathlen - 1,\n\t            \"%s/%s\",\n\t            fud->destination_dir,\n\t            filename);\n\tif (truncated) {\n\t\tmg_cry_internal(fud->conn, \"%s: File path too long\", __func__);\n\t\treturn FORM_FIELD_STORAGE_ABORT;\n\t}\n\treturn FORM_FIELD_STORAGE_STORE;\n}\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_get(const char *key,\n                    const char *value,\n                    size_t value_size,\n                    void *user_data)\n{\n\t/* Function should never be called */\n\t(void)key;\n\t(void)value;\n\t(void)value_size;\n\t(void)user_data;\n\n\treturn 0;\n}\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_stored(const char *path, long long file_size, void *user_data)\n{\n\tstruct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;\n\t(void)file_size;\n\n\tfud->num_uploaded_files++;\n\tfud->conn->phys_ctx->callbacks.upload(fud->conn, path);\n\n\treturn 0;\n}\n\n\n/* Deprecated function mg_upload - use mg_handle_form_request instead. */\nint\nmg_upload(struct mg_connection *conn, const char *destination_dir)\n{\n\tstruct mg_upload_user_data fud = {conn, destination_dir, 0};\n\tstruct mg_form_data_handler fdh = {mg_upload_field_found,\n\t                                   mg_upload_field_get,\n\t                                   mg_upload_field_stored,\n\t                                   0};\n\tint ret;\n\n\tfdh.user_data = (void *)&fud;\n\tret = mg_handle_form_request(conn, &fdh);\n\n\tif (ret < 0) {\n\t\tmg_cry_internal(conn, \"%s: Error while parsing the request\", __func__);\n\t}\n\n\treturn fud.num_uploaded_files;\n}\n#endif\n\n\nstatic int\nget_first_ssl_listener_index(const struct mg_context *ctx)\n{\n\tunsigned int i;\n\tint idx = -1;\n\tif (ctx) {\n\t\tfor (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {\n\t\t\tidx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;\n\t\t}\n\t}\n\treturn idx;\n}\n\n\n/* Return host (without port) */\n/* Use mg_free to free the result */\nstatic const char *\nalloc_get_host(struct mg_connection *conn)\n{\n\tchar buf[1025];\n\tsize_t buflen = sizeof(buf);\n\tconst char *host_header = get_header(conn->request_info.http_headers,\n\t                                     conn->request_info.num_headers,\n\t                                     \"Host\");\n\tchar *host;\n\n\tif (host_header != NULL) {\n\t\tchar *pos;\n\n\t\t/* Create a local copy of the \"Host\" header, since it might be\n\t\t * modified here. */\n\t\tmg_strlcpy(buf, host_header, buflen);\n\t\tbuf[buflen - 1] = '\\0';\n\t\thost = buf;\n\t\twhile (isspace(*host)) {\n\t\t\thost++;\n\t\t}\n\n\t\t/* If the \"Host\" is an IPv6 address, like [::1], parse until ]\n\t\t * is found. */\n\t\tif (*host == '[') {\n\t\t\tpos = strchr(host, ']');\n\t\t\tif (!pos) {\n\t\t\t\t/* Malformed hostname starts with '[', but no ']' found */\n\t\t\t\tDEBUG_TRACE(\"%s\", \"Host name format error '[' without ']'\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* terminate after ']' */\n\t\t\tpos[1] = 0;\n\t\t} else {\n\t\t\t/* Otherwise, a ':' separates hostname and port number */\n\t\t\tpos = strchr(host, ':');\n\t\t\tif (pos != NULL) {\n\t\t\t\t*pos = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tif (conn->ssl) {\n\t\t\t/* This is a HTTPS connection, maybe we have a hostname\n\t\t\t * from SNI (set in ssl_servername_callback). */\n\t\t\tconst char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t\t\tif (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {\n\t\t\t\t/* We are not using the default domain */\n\t\t\t\tif (mg_strcasecmp(host, sslhost)) {\n\t\t\t\t\t/* Mismatch between SNI domain and HTTP domain */\n\t\t\t\t\tDEBUG_TRACE(\"Host mismatch: SNI: %s, HTTPS: %s\",\n\t\t\t\t\t            sslhost,\n\t\t\t\t\t            host);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDEBUG_TRACE(\"HTTPS Host: %s\", host);\n\n\t\t} else {\n\t\t\tstruct mg_domain_context *dom = &(conn->phys_ctx->dd);\n\t\t\twhile (dom) {\n\t\t\t\tif (!mg_strcasecmp(host, dom->config[AUTHENTICATION_DOMAIN])) {\n\n\t\t\t\t\t/* Found matching domain */\n\t\t\t\t\tDEBUG_TRACE(\"HTTP domain %s found\",\n\t\t\t\t\t            dom->config[AUTHENTICATION_DOMAIN]);\n\n\t\t\t\t\t/* TODO: Check if this is a HTTP or HTTPS domain */\n\t\t\t\t\tconn->dom_ctx = dom;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdom = dom->next;\n\t\t\t}\n\n\t\t\tDEBUG_TRACE(\"HTTP Host: %s\", host);\n\t\t}\n\n\t} else {\n\t\tsockaddr_to_string(buf, buflen, &conn->client.lsa);\n\t\thost = buf;\n\n\t\tDEBUG_TRACE(\"IP: %s\", host);\n\t}\n\n\treturn mg_strdup_ctx(host, conn->phys_ctx);\n}\n\n\nstatic void\nredirect_to_https_port(struct mg_connection *conn, int ssl_index)\n{\n\tchar target_url[MG_BUF_LEN];\n\tint truncated = 0;\n\n\tconn->must_close = 1;\n\n\t/* Send host, port, uri and (if it exists) ?query_string */\n\tif (conn->host) {\n\n\t\t/* Use \"308 Permanent Redirect\" */\n\t\tint redirect_code = 308;\n\n\t\t/* Create target URL */\n\t\tmg_snprintf(\n\t\t    conn,\n\t\t    &truncated,\n\t\t    target_url,\n\t\t    sizeof(target_url),\n\t\t    \"Location: https://%s:%d%s%s%s\",\n\n\t\t    conn->host,\n#if defined(USE_IPV6)\n\t\t    (conn->phys_ctx->listening_sockets[ssl_index].lsa.sa.sa_family\n\t\t     == AF_INET6)\n\t\t        ? (int)ntohs(conn->phys_ctx->listening_sockets[ssl_index]\n\t\t                         .lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        (int)ntohs(conn->phys_ctx->listening_sockets[ssl_index]\n\t\t                       .lsa.sin.sin_port),\n\t\t    conn->request_info.local_uri,\n\t\t    (conn->request_info.query_string == NULL) ? \"\" : \"?\",\n\t\t    (conn->request_info.query_string == NULL)\n\t\t        ? \"\"\n\t\t        : conn->request_info.query_string);\n\n\t\t/* Check overflow in location buffer (will not occur if MG_BUF_LEN\n\t\t * is used as buffer size) */\n\t\tif (truncated) {\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"Redirect URL too long\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Use redirect helper function */\n\t\tmg_send_http_redirect(conn, target_url, redirect_code);\n\t}\n}\n\n\nstatic void\nhandler_info_acquire(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\thandler_info->refcount++;\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nhandler_info_release(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\thandler_info->refcount--;\n\tpthread_cond_signal(&handler_info->refcount_cond);\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nhandler_info_wait_unused(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\twhile (handler_info->refcount) {\n\t\tpthread_cond_wait(&handler_info->refcount_cond,\n\t\t                  &handler_info->refcount_mutex);\n\t}\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nmg_set_handler_type(struct mg_context *phys_ctx,\n                    struct mg_domain_context *dom_ctx,\n                    const char *uri,\n                    int handler_type,\n                    int is_delete_request,\n                    mg_request_handler handler,\n                    struct mg_websocket_subprotocols *subprotocols,\n                    mg_websocket_connect_handler connect_handler,\n                    mg_websocket_ready_handler ready_handler,\n                    mg_websocket_data_handler data_handler,\n                    mg_websocket_close_handler close_handler,\n                    mg_authorization_handler auth_handler,\n                    void *cbdata)\n{\n\tstruct mg_handler_info *tmp_rh, **lastref;\n\tsize_t urilen = strlen(uri);\n\n\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\tDEBUG_ASSERT(handler == NULL);\n\t\tDEBUG_ASSERT(is_delete_request || connect_handler != NULL\n\t\t             || ready_handler != NULL\n\t\t             || data_handler != NULL\n\t\t             || close_handler != NULL);\n\n\t\tDEBUG_ASSERT(auth_handler == NULL);\n\t\tif (handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (connect_handler == NULL)\n\t\t    && (ready_handler == NULL) && (data_handler == NULL)\n\t\t    && (close_handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (auth_handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t} else if (handler_type == REQUEST_HANDLER) {\n\t\tDEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL\n\t\t             && data_handler == NULL\n\t\t             && close_handler == NULL);\n\t\tDEBUG_ASSERT(is_delete_request || (handler != NULL));\n\t\tDEBUG_ASSERT(auth_handler == NULL);\n\n\t\tif ((connect_handler != NULL) || (ready_handler != NULL)\n\t\t    || (data_handler != NULL) || (close_handler != NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (auth_handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t} else { /* AUTH_HANDLER */\n\t\tDEBUG_ASSERT(handler == NULL);\n\t\tDEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL\n\t\t             && data_handler == NULL\n\t\t             && close_handler == NULL);\n\t\tDEBUG_ASSERT(auth_handler != NULL);\n\t\tif (handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t\tif ((connect_handler != NULL) || (ready_handler != NULL)\n\t\t    || (data_handler != NULL) || (close_handler != NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (auth_handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!phys_ctx || !dom_ctx) {\n\t\treturn;\n\t}\n\n\tmg_lock_context(phys_ctx);\n\n\t/* first try to find an existing handler */\n\tlastref = &(dom_ctx->handlers);\n\tfor (tmp_rh = dom_ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {\n\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\tif ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {\n\t\t\t\tif (!is_delete_request) {\n\t\t\t\t\t/* update existing handler */\n\t\t\t\t\tif (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t/* Wait for end of use before updating */\n\t\t\t\t\t\thandler_info_wait_unused(tmp_rh);\n\n\t\t\t\t\t\t/* Ok, the handler is no more use -> Update it */\n\t\t\t\t\t\ttmp_rh->handler = handler;\n\t\t\t\t\t} else if (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\ttmp_rh->subprotocols = subprotocols;\n\t\t\t\t\t\ttmp_rh->connect_handler = connect_handler;\n\t\t\t\t\t\ttmp_rh->ready_handler = ready_handler;\n\t\t\t\t\t\ttmp_rh->data_handler = data_handler;\n\t\t\t\t\t\ttmp_rh->close_handler = close_handler;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\ttmp_rh->auth_handler = auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\ttmp_rh->cbdata = cbdata;\n\t\t\t\t} else {\n\t\t\t\t\t/* remove existing handler */\n\t\t\t\t\tif (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t/* Wait for end of use before removing */\n\t\t\t\t\t\thandler_info_wait_unused(tmp_rh);\n\n\t\t\t\t\t\t/* Ok, the handler is no more used -> Destroy resources\n\t\t\t\t\t\t */\n\t\t\t\t\t\tpthread_cond_destroy(&tmp_rh->refcount_cond);\n\t\t\t\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t\t\t\t}\n\t\t\t\t\t*lastref = tmp_rh->next;\n\t\t\t\t\tmg_free(tmp_rh->uri);\n\t\t\t\t\tmg_free(tmp_rh);\n\t\t\t\t}\n\t\t\t\tmg_unlock_context(phys_ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlastref = &(tmp_rh->next);\n\t}\n\n\tif (is_delete_request) {\n\t\t/* no handler to set, this was a remove request to a non-existing\n\t\t * handler */\n\t\tmg_unlock_context(phys_ctx);\n\t\treturn;\n\t}\n\n\ttmp_rh =\n\t    (struct mg_handler_info *)mg_calloc_ctx(sizeof(struct mg_handler_info),\n\t                                            1,\n\t                                            phys_ctx);\n\tif (tmp_rh == NULL) {\n\t\tmg_unlock_context(phys_ctx);\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot create new request handler struct, OOM\");\n\t\treturn;\n\t}\n\ttmp_rh->uri = mg_strdup_ctx(uri, phys_ctx);\n\tif (!tmp_rh->uri) {\n\t\tmg_unlock_context(phys_ctx);\n\t\tmg_free(tmp_rh);\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot create new request handler struct, OOM\");\n\t\treturn;\n\t}\n\ttmp_rh->uri_len = urilen;\n\tif (handler_type == REQUEST_HANDLER) {\n\t\t/* Init refcount mutex and condition */\n\t\tif (0 != pthread_mutex_init(&tmp_rh->refcount_mutex, NULL)) {\n\t\t\tmg_unlock_context(phys_ctx);\n\t\t\tmg_free(tmp_rh);\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Cannot init refcount mutex\");\n\t\t\treturn;\n\t\t}\n\t\tif (0 != pthread_cond_init(&tmp_rh->refcount_cond, NULL)) {\n\t\t\tmg_unlock_context(phys_ctx);\n\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t\tmg_free(tmp_rh);\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Cannot init refcount cond\");\n\t\t\treturn;\n\t\t}\n\t\ttmp_rh->refcount = 0;\n\t\ttmp_rh->handler = handler;\n\t} else if (handler_type == WEBSOCKET_HANDLER) {\n\t\ttmp_rh->subprotocols = subprotocols;\n\t\ttmp_rh->connect_handler = connect_handler;\n\t\ttmp_rh->ready_handler = ready_handler;\n\t\ttmp_rh->data_handler = data_handler;\n\t\ttmp_rh->close_handler = close_handler;\n\t} else { /* AUTH_HANDLER */\n\t\ttmp_rh->auth_handler = auth_handler;\n\t}\n\ttmp_rh->cbdata = cbdata;\n\ttmp_rh->handler_type = handler_type;\n\ttmp_rh->next = NULL;\n\n\t*lastref = tmp_rh;\n\tmg_unlock_context(phys_ctx);\n}\n\n\nvoid\nmg_set_request_handler(struct mg_context *ctx,\n                       const char *uri,\n                       mg_request_handler handler,\n                       void *cbdata)\n{\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    REQUEST_HANDLER,\n\t                    handler == NULL,\n\t                    handler,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    cbdata);\n}\n\n\nvoid\nmg_set_websocket_handler(struct mg_context *ctx,\n                         const char *uri,\n                         mg_websocket_connect_handler connect_handler,\n                         mg_websocket_ready_handler ready_handler,\n                         mg_websocket_data_handler data_handler,\n                         mg_websocket_close_handler close_handler,\n                         void *cbdata)\n{\n\tmg_set_websocket_handler_with_subprotocols(ctx,\n\t                                           uri,\n\t                                           NULL,\n\t                                           connect_handler,\n\t                                           ready_handler,\n\t                                           data_handler,\n\t                                           close_handler,\n\t                                           cbdata);\n}\n\n\nvoid\nmg_set_websocket_handler_with_subprotocols(\n    struct mg_context *ctx,\n    const char *uri,\n    struct mg_websocket_subprotocols *subprotocols,\n    mg_websocket_connect_handler connect_handler,\n    mg_websocket_ready_handler ready_handler,\n    mg_websocket_data_handler data_handler,\n    mg_websocket_close_handler close_handler,\n    void *cbdata)\n{\n\tint is_delete_request = (connect_handler == NULL) && (ready_handler == NULL)\n\t                        && (data_handler == NULL)\n\t                        && (close_handler == NULL);\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    WEBSOCKET_HANDLER,\n\t                    is_delete_request,\n\t                    NULL,\n\t                    subprotocols,\n\t                    connect_handler,\n\t                    ready_handler,\n\t                    data_handler,\n\t                    close_handler,\n\t                    NULL,\n\t                    cbdata);\n}\n\n\nvoid\nmg_set_auth_handler(struct mg_context *ctx,\n                    const char *uri,\n                    mg_request_handler handler,\n                    void *cbdata)\n{\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    AUTH_HANDLER,\n\t                    handler == NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    handler,\n\t                    cbdata);\n}\n\n\nstatic int\nget_request_handler(struct mg_connection *conn,\n                    int handler_type,\n                    mg_request_handler *handler,\n                    struct mg_websocket_subprotocols **subprotocols,\n                    mg_websocket_connect_handler *connect_handler,\n                    mg_websocket_ready_handler *ready_handler,\n                    mg_websocket_data_handler *data_handler,\n                    mg_websocket_close_handler *close_handler,\n                    mg_authorization_handler *auth_handler,\n                    void **cbdata,\n                    struct mg_handler_info **handler_info)\n{\n\tconst struct mg_request_info *request_info = mg_get_request_info(conn);\n\tif (request_info) {\n\t\tconst char *uri = request_info->local_uri;\n\t\tsize_t urilen = strlen(uri);\n\t\tstruct mg_handler_info *tmp_rh;\n\n\t\tif (!conn || !conn->phys_ctx || !conn->dom_ctx) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tmg_lock_context(conn->phys_ctx);\n\n\t\t/* first try for an exact match */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* next try for a partial match, we will accept uri/something */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif ((tmp_rh->uri_len < urilen) && (uri[tmp_rh->uri_len] == '/')\n\t\t\t\t    && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* finally try for pattern match */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif (match_prefix(tmp_rh->uri, tmp_rh->uri_len, uri) > 0) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmg_unlock_context(conn->phys_ctx);\n\t}\n\treturn 0; /* none found */\n}\n\n\n/* Check if the script file is in a path, allowed for script files.\n * This can be used if uploading files is possible not only for the server\n * admin, and the upload mechanism does not check the file extension.\n */\nstatic int\nis_in_script_path(const struct mg_connection *conn, const char *path)\n{\n\t/* TODO (Feature): Add config value for allowed script path.\n\t * Default: All allowed. */\n\t(void)conn;\n\t(void)path;\n\treturn 1;\n}\n\n\n#if defined(USE_WEBSOCKET) && defined(MG_LEGACY_INTERFACE)\nstatic int\ndeprecated_websocket_connect_wrapper(const struct mg_connection *conn,\n                                     void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_connect) {\n\t\treturn pcallbacks->websocket_connect(conn);\n\t}\n\t/* No handler set - assume \"OK\" */\n\treturn 0;\n}\n\n\nstatic void\ndeprecated_websocket_ready_wrapper(struct mg_connection *conn, void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_ready) {\n\t\tpcallbacks->websocket_ready(conn);\n\t}\n}\n\n\nstatic int\ndeprecated_websocket_data_wrapper(struct mg_connection *conn,\n                                  int bits,\n                                  char *data,\n                                  size_t len,\n                                  void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_data) {\n\t\treturn pcallbacks->websocket_data(conn, bits, data, len);\n\t}\n\t/* No handler set - assume \"OK\" */\n\treturn 1;\n}\n#endif\n\n\n/* This is the heart of the Civetweb's logic.\n * This function is called when the request is read, parsed and validated,\n * and Civetweb must decide what action to take: serve a file, or\n * a directory, or call embedded function, etcetera. */\nstatic void\nhandle_request(struct mg_connection *conn)\n{\n\tstruct mg_request_info *ri = &conn->request_info;\n\tchar path[PATH_MAX];\n\tint uri_len, ssl_index;\n\tint is_found = 0, is_script_resource = 0, is_websocket_request = 0,\n\t    is_put_or_delete_request = 0, is_callback_resource = 0;\n\tint i;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tmg_request_handler callback_handler = NULL;\n\tstruct mg_handler_info *handler_info = NULL;\n\tstruct mg_websocket_subprotocols *subprotocols;\n\tmg_websocket_connect_handler ws_connect_handler = NULL;\n\tmg_websocket_ready_handler ws_ready_handler = NULL;\n\tmg_websocket_data_handler ws_data_handler = NULL;\n\tmg_websocket_close_handler ws_close_handler = NULL;\n\tvoid *callback_data = NULL;\n\tmg_authorization_handler auth_handler = NULL;\n\tvoid *auth_callback_data = NULL;\n\tint handler_type;\n\ttime_t curtime = time(NULL);\n\tchar date[64];\n\n\tpath[0] = 0;\n\n\t/* 1. get the request url */\n\t/* 1.1. split into url and query string */\n\tif ((conn->request_info.query_string = strchr(ri->request_uri, '?'))\n\t    != NULL) {\n\t\t*((char *)conn->request_info.query_string++) = '\\0';\n\t}\n\n\t/* 1.2. do a https redirect, if required. Do not decode URIs yet. */\n\tif (!conn->client.is_ssl && conn->client.ssl_redir) {\n\t\tssl_index = get_first_ssl_listener_index(conn->phys_ctx);\n\t\tif (ssl_index >= 0) {\n\t\t\tredirect_to_https_port(conn, ssl_index);\n\t\t} else {\n\t\t\t/* A http to https forward port has been specified,\n\t\t\t * but no https port to forward to. */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   503,\n\t\t\t                   \"%s\",\n\t\t\t                   \"Error: SSL forward not configured properly\");\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s\",\n\t\t\t                \"Can not redirect to SSL, no SSL port available\");\n\t\t}\n\t\treturn;\n\t}\n\turi_len = (int)strlen(ri->local_uri);\n\n\t/* 1.3. decode url (if config says so) */\n\tif (should_decode_url(conn)) {\n\t\tmg_url_decode(\n\t\t    ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);\n\t}\n\n\t/* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is\n\t * not possible */\n\tremove_double_dots_and_double_slashes((char *)ri->local_uri);\n\n\t/* step 1. completed, the url is known now */\n\turi_len = (int)strlen(ri->local_uri);\n\tDEBUG_TRACE(\"URL: %s\", ri->local_uri);\n\n\t/* 2. if this ip has limited speed, set it for this connection */\n\tconn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],\n\t                              get_remote_ip(conn),\n\t                              ri->local_uri);\n\n\t/* 3. call a \"handle everything\" callback, if registered */\n\tif (conn->phys_ctx->callbacks.begin_request != NULL) {\n\t\t/* Note that since V1.7 the \"begin_request\" function is called\n\t\t * before an authorization check. If an authorization check is\n\t\t * required, use a request_handler instead. */\n\t\ti = conn->phys_ctx->callbacks.begin_request(conn);\n\t\tif (i > 0) {\n\t\t\t/* callback already processed the request. Store the\n\t\t\t   return value as a status code for the access log. */\n\t\t\tconn->status_code = i;\n\t\t\tdiscard_unread_request_data(conn);\n\t\t\treturn;\n\t\t} else if (i == 0) {\n\t\t\t/* civetweb should process the request */\n\t\t} else {\n\t\t\t/* unspecified - may change with the next version */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* request not yet handled by a handler or redirect, so the request\n\t * is processed here */\n\n\t/* 4. Check for CORS preflight requests and handle them (if configured).\n\t * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\n\t */\n\tif (!strcmp(ri->request_method, \"OPTIONS\")) {\n\t\t/* Send a response to CORS preflights only if\n\t\t * access_control_allow_methods is not NULL and not an empty string.\n\t\t * In this case, scripts can still handle CORS. */\n\t\tconst char *cors_meth_cfg =\n\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];\n\t\tconst char *cors_orig_cfg =\n\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tconst char *cors_origin =\n\t\t    get_header(ri->http_headers, ri->num_headers, \"Origin\");\n\t\tconst char *cors_acrm = get_header(ri->http_headers,\n\t\t                                   ri->num_headers,\n\t\t                                   \"Access-Control-Request-Method\");\n\n\t\t/* Todo: check if cors_origin is in cors_orig_cfg.\n\t\t * Or, let the client check this. */\n\n\t\tif ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0)\n\t\t    && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0)\n\t\t    && (cors_origin != NULL) && (cors_acrm != NULL)) {\n\t\t\t/* This is a valid CORS preflight, and the server is configured\n\t\t\t * to\n\t\t\t * handle it automatically. */\n\t\t\tconst char *cors_acrh =\n\t\t\t    get_header(ri->http_headers,\n\t\t\t               ri->num_headers,\n\t\t\t               \"Access-Control-Request-Headers\");\n\n\t\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\t\tmg_printf(conn,\n\t\t\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t          \"Date: %s\\r\\n\"\n\t\t\t          \"Access-Control-Allow-Origin: %s\\r\\n\"\n\t\t\t          \"Access-Control-Allow-Methods: %s\\r\\n\"\n\t\t\t          \"Content-Length: 0\\r\\n\"\n\t\t\t          \"Connection: %s\\r\\n\",\n\t\t\t          date,\n\t\t\t          cors_orig_cfg,\n\t\t\t          ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),\n\t\t\t          suggest_connection_header(conn));\n\n\t\t\tif (cors_acrh != NULL) {\n\t\t\t\t/* CORS request is asking for additional headers */\n\t\t\t\tconst char *cors_hdr_cfg =\n\t\t\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];\n\n\t\t\t\tif ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {\n\t\t\t\t\t/* Allow only if access_control_allow_headers is\n\t\t\t\t\t * not NULL and not an empty string. If this\n\t\t\t\t\t * configuration is set to *, allow everything.\n\t\t\t\t\t * Otherwise this configuration must be a list\n\t\t\t\t\t * of allowed HTTP header names. */\n\t\t\t\t\tmg_printf(conn,\n\t\t\t\t\t          \"Access-Control-Allow-Headers: %s\\r\\n\",\n\t\t\t\t\t          ((cors_hdr_cfg[0] == '*') ? cors_acrh\n\t\t\t\t\t                                    : cors_hdr_cfg));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg_printf(conn, \"Access-Control-Max-Age: 60\\r\\n\");\n\n\t\t\tmg_printf(conn, \"\\r\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* 5. interpret the url to find out how the request must be handled\n\t */\n\t/* 5.1. first test, if the request targets the regular http(s)://\n\t * protocol namespace or the websocket ws(s):// protocol namespace.\n\t */\n\tis_websocket_request = is_websocket_protocol(conn);\n#if defined(USE_WEBSOCKET)\n\thandler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;\n#else\n\thandler_type = REQUEST_HANDLER;\n#endif /* defined(USE_WEBSOCKET) */\n\t/* 5.2. check if the request will be handled by a callback */\n\tif (get_request_handler(conn,\n\t                        handler_type,\n\t                        &callback_handler,\n\t                        &subprotocols,\n\t                        &ws_connect_handler,\n\t                        &ws_ready_handler,\n\t                        &ws_data_handler,\n\t                        &ws_close_handler,\n\t                        NULL,\n\t                        &callback_data,\n\t                        &handler_info)) {\n\t\t/* 5.2.1. A callback will handle this request. All requests\n\t\t * handled\n\t\t * by a callback have to be considered as requests to a script\n\t\t * resource. */\n\t\tis_callback_resource = 1;\n\t\tis_script_resource = 1;\n\t\tis_put_or_delete_request = is_put_or_delete_method(conn);\n\t} else {\n\tno_callback_resource:\n\n\t\t/* 5.2.2. No callback is responsible for this request. The URI\n\t\t * addresses a file based resource (static content or Lua/cgi\n\t\t * scripts in the file system). */\n\t\tis_callback_resource = 0;\n\t\tinterpret_uri(conn,\n\t\t              path,\n\t\t              sizeof(path),\n\t\t              &file.stat,\n\t\t              &is_found,\n\t\t              &is_script_resource,\n\t\t              &is_websocket_request,\n\t\t              &is_put_or_delete_request);\n\t}\n\n\t/* 6. authorization check */\n\t/* 6.1. a custom authorization handler is installed */\n\tif (get_request_handler(conn,\n\t                        AUTH_HANDLER,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        &auth_handler,\n\t                        &auth_callback_data,\n\t                        NULL)) {\n\t\tif (!auth_handler(conn, auth_callback_data)) {\n\t\t\treturn;\n\t\t}\n\t} else if (is_put_or_delete_request && !is_script_resource\n\t           && !is_callback_resource) {\n/* 6.2. this request is a PUT/DELETE to a real file */\n/* 6.2.1. thus, the server must have real files */\n#if defined(NO_FILES)\n\t\tif (1) {\n#else\n\t\tif (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {\n#endif\n\t\t\t/* This server does not have any real files, thus the\n\t\t\t * PUT/DELETE methods are not valid. */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   405,\n\t\t\t                   \"%s method not allowed\",\n\t\t\t                   conn->request_info.request_method);\n\t\t\treturn;\n\t\t}\n\n#if !defined(NO_FILES)\n\t\t/* 6.2.2. Check if put authorization for static files is\n\t\t * available.\n\t\t */\n\t\tif (!is_authorized_for_put(conn)) {\n\t\t\tsend_authorization_request(conn, NULL);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t} else {\n\t\t/* 6.3. This is either a OPTIONS, GET, HEAD or POST request,\n\t\t * or it is a PUT or DELETE request to a resource that does not\n\t\t * correspond to a file. Check authorization. */\n\t\tif (!check_authorization(conn, path)) {\n\t\t\tsend_authorization_request(conn, NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* request is authorized or does not need authorization */\n\n\t/* 7. check if there are request handlers for this uri */\n\tif (is_callback_resource) {\n\t\tif (!is_websocket_request) {\n\t\t\ti = callback_handler(conn, callback_data);\n\n\t\t\t/* Callback handler will not be used anymore. Release it */\n\t\t\thandler_info_release(handler_info);\n\n\t\t\tif (i > 0) {\n\t\t\t\t/* Do nothing, callback has served the request. Store\n\t\t\t\t * then return value as status code for the log and discard\n\t\t\t\t * all data from the client not used by the callback. */\n\t\t\t\tconn->status_code = i;\n\t\t\t\tdiscard_unread_request_data(conn);\n\t\t\t} else {\n\t\t\t\t/* The handler did NOT handle the request. */\n\t\t\t\t/* Some proper reactions would be:\n\t\t\t\t * a) close the connections without sending anything\n\t\t\t\t * b) send a 404 not found\n\t\t\t\t * c) try if there is a file matching the URI\n\t\t\t\t * It would be possible to do a, b or c in the callback\n\t\t\t\t * implementation, and return 1 - we cannot do anything\n\t\t\t\t * here, that is not possible in the callback.\n\t\t\t\t *\n\t\t\t\t * TODO: What would be the best reaction here?\n\t\t\t\t * (Note: The reaction may change, if there is a better\n\t\t\t\t *idea.)\n\t\t\t\t */\n\n\t\t\t\t/* For the moment, use option c: We look for a proper file,\n\t\t\t\t * but since a file request is not always a script resource,\n\t\t\t\t * the authorization check might be different. */\n\t\t\t\tinterpret_uri(conn,\n\t\t\t\t              path,\n\t\t\t\t              sizeof(path),\n\t\t\t\t              &file.stat,\n\t\t\t\t              &is_found,\n\t\t\t\t              &is_script_resource,\n\t\t\t\t              &is_websocket_request,\n\t\t\t\t              &is_put_or_delete_request);\n\t\t\t\tcallback_handler = NULL;\n\n\t\t\t\t/* Here we are at a dead end:\n\t\t\t\t * According to URI matching, a callback should be\n\t\t\t\t * responsible for handling the request,\n\t\t\t\t * we called it, but the callback declared itself\n\t\t\t\t * not responsible.\n\t\t\t\t * We use a goto here, to get out of this dead end,\n\t\t\t\t * and continue with the default handling.\n\t\t\t\t * A goto here is simpler and better to understand\n\t\t\t\t * than some curious loop. */\n\t\t\t\tgoto no_callback_resource;\n\t\t\t}\n\t\t} else {\n#if defined(USE_WEBSOCKET)\n\t\t\thandle_websocket_request(conn,\n\t\t\t                         path,\n\t\t\t                         is_callback_resource,\n\t\t\t                         subprotocols,\n\t\t\t                         ws_connect_handler,\n\t\t\t                         ws_ready_handler,\n\t\t\t                         ws_data_handler,\n\t\t\t                         ws_close_handler,\n\t\t\t                         callback_data);\n#endif\n\t\t}\n\t\treturn;\n\t}\n\n/* 8. handle websocket requests */\n#if defined(USE_WEBSOCKET)\n\tif (is_websocket_request) {\n\t\tif (is_script_resource) {\n\n\t\t\tif (is_in_script_path(conn, path)) {\n\t\t\t\t/* Websocket Lua script */\n\t\t\t\thandle_websocket_request(conn,\n\t\t\t\t                         path,\n\t\t\t\t                         0 /* Lua Script */,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         conn->phys_ctx->user_data);\n\t\t\t} else {\n\t\t\t\t/* Script was in an illegal path */\n\t\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t\t}\n\t\t} else {\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\thandle_websocket_request(\n\t\t\t    conn,\n\t\t\t    path,\n\t\t\t    !is_script_resource /* could be deprecated global callback */,\n\t\t\t    NULL,\n\t\t\t    deprecated_websocket_connect_wrapper,\n\t\t\t    deprecated_websocket_ready_wrapper,\n\t\t\t    deprecated_websocket_data_wrapper,\n\t\t\t    NULL,\n\t\t\t    conn->phys_ctx->user_data);\n#else\n\t\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n#endif\n\t\t}\n\t\treturn;\n\t} else\n#endif\n\n#if defined(NO_FILES)\n\t\t/* 9a. In case the server uses only callbacks, this uri is\n\t\t * unknown.\n\t\t * Then, all request handling ends here. */\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not Found\");\n\n#else\n\t/* 9b. This request is either for a static file or resource handled\n\t * by a script file. Thus, a DOCUMENT_ROOT must exist. */\n\tif (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not Found\");\n\t\treturn;\n\t}\n\n\t/* 10. Request is handled by a script */\n\tif (is_script_resource) {\n\t\thandle_file_based_request(conn, path, &file);\n\t\treturn;\n\t}\n\n\t/* 11. Handle put/delete/mkcol requests */\n\tif (is_put_or_delete_request) {\n\t\t/* 11.1. PUT method */\n\t\tif (!strcmp(ri->request_method, \"PUT\")) {\n\t\t\tput_file(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.2. DELETE method */\n\t\tif (!strcmp(ri->request_method, \"DELETE\")) {\n\t\t\tdelete_file(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.3. MKCOL method */\n\t\tif (!strcmp(ri->request_method, \"MKCOL\")) {\n\t\t\tmkcol(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.4. PATCH method\n\t\t * This method is not supported for static resources,\n\t\t * only for scripts (Lua, CGI) and callbacks. */\n\t\tmg_send_http_error(conn,\n\t\t                   405,\n\t\t                   \"%s method not allowed\",\n\t\t                   conn->request_info.request_method);\n\t\treturn;\n\t}\n\n\t/* 11. File does not exist, or it was configured that it should be\n\t * hidden */\n\tif (!is_found || (must_hide_file(conn, path))) {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n\t\treturn;\n\t}\n\n\t/* 12. Directory uris should end with a slash */\n\tif (file.stat.is_directory && (uri_len > 0)\n\t    && (ri->local_uri[uri_len - 1] != '/')) {\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n\t\t          \"Location: %s/\\r\\n\"\n\t\t          \"Date: %s\\r\\n\"\n\t\t          /* \"Cache-Control: private\\r\\n\" (= default) */\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\",\n\t\t          ri->request_uri,\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn, \"\\r\\n\");\n\t\treturn;\n\t}\n\n\t/* 13. Handle other methods than GET/HEAD */\n\t/* 13.1. Handle PROPFIND */\n\tif (!strcmp(ri->request_method, \"PROPFIND\")) {\n\t\thandle_propfind(conn, path, &file.stat);\n\t\treturn;\n\t}\n\t/* 13.2. Handle OPTIONS for files */\n\tif (!strcmp(ri->request_method, \"OPTIONS\")) {\n\t\t/* This standard handler is only used for real files.\n\t\t * Scripts should support the OPTIONS method themselves, to allow a\n\t\t * maximum flexibility.\n\t\t * Lua and CGI scripts may fully support CORS this way (including\n\t\t * preflights). */\n\t\tsend_options(conn);\n\t\treturn;\n\t}\n\t/* 13.3. everything but GET and HEAD (e.g. POST) */\n\tif ((0 != strcmp(ri->request_method, \"GET\"))\n\t    && (0 != strcmp(ri->request_method, \"HEAD\"))) {\n\t\tmg_send_http_error(conn,\n\t\t                   405,\n\t\t                   \"%s method not allowed\",\n\t\t                   conn->request_info.request_method);\n\t\treturn;\n\t}\n\n\t/* 14. directories */\n\tif (file.stat.is_directory) {\n\t\t/* Substitute files have already been handled above. */\n\t\t/* Here we can either generate and send a directory listing,\n\t\t * or send an \"access denied\" error. */\n\t\tif (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t\t                   \"yes\")) {\n\t\t\thandle_directory_request(conn, path);\n\t\t} else {\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   403,\n\t\t\t                   \"%s\",\n\t\t\t                   \"Error: Directory listing denied\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/* 15. read a normal file with GET or HEAD */\n\thandle_file_based_request(conn, path, &file);\n#endif /* !defined(NO_FILES) */\n}\n\n\nstatic void\nhandle_file_based_request(struct mg_connection *conn,\n                          const char *path,\n                          struct mg_file *file)\n{\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tif (0) {\n#if defined(USE_LUA)\n\t} else if (match_prefix(\n\t               conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],\n\t               strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS]),\n\t               path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Lua server page: an SSI like page containing mostly plain\n\t\t\t * html\n\t\t\t * code\n\t\t\t * plus some tags with server generated contents. */\n\t\t\thandle_lsp_request(conn, path, file, NULL);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n\n\t} else if (match_prefix(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],\n\t                        strlen(\n\t                            conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS]),\n\t                        path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Lua in-server module script: a CGI like script used to\n\t\t\t * generate\n\t\t\t * the\n\t\t\t * entire reply. */\n\t\t\tmg_exec_lua_script(conn, path, NULL);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif\n#if defined(USE_DUKTAPE)\n\t} else if (match_prefix(\n\t               conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],\n\t               strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),\n\t               path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Call duktape to generate the page */\n\t\t\tmg_exec_duktape_script(conn, path);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif\n#if !defined(NO_CGI)\n\t} else if (match_prefix(conn->dom_ctx->config[CGI_EXTENSIONS],\n\t                        strlen(conn->dom_ctx->config[CGI_EXTENSIONS]),\n\t                        path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* CGI scripts may support all HTTP methods */\n\t\t\thandle_cgi_request(conn, path);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif /* !NO_CGI */\n\t} else if (match_prefix(conn->dom_ctx->config[SSI_EXTENSIONS],\n\t                        strlen(conn->dom_ctx->config[SSI_EXTENSIONS]),\n\t                        path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\thandle_ssi_file_request(conn, path, file);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#if !defined(NO_CACHING)\n\t} else if ((!conn->in_error_handler)\n\t           && is_not_modified(conn, &file->stat)) {\n\t\t/* Send 304 \"Not Modified\" - this must not send any body data */\n\t\thandle_not_modified_static_file_request(conn, file);\n#endif /* !NO_CACHING */\n\t} else {\n\t\thandle_static_file_request(conn, path, file, NULL, NULL);\n\t}\n}\n\n\nstatic void\nclose_all_listening_sockets(struct mg_context *ctx)\n{\n\tunsigned int i;\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\tclosesocket(ctx->listening_sockets[i].sock);\n\t\tctx->listening_sockets[i].sock = INVALID_SOCKET;\n\t}\n\tmg_free(ctx->listening_sockets);\n\tctx->listening_sockets = NULL;\n\tmg_free(ctx->listening_socket_fds);\n\tctx->listening_socket_fds = NULL;\n}\n\n\n/* Valid listening port specification is: [ip_address:]port[s]\n * Examples for IPv4: 80, 443s, 127.0.0.1:3128, 192.0.2.3:8080s\n * Examples for IPv6: [::]:80, [::1]:80,\n *   [2001:0db8:7654:3210:FEDC:BA98:7654:3210]:443s\n *   see https://tools.ietf.org/html/rfc3513#section-2.2\n * In order to bind to both, IPv4 and IPv6, you can either add\n * both ports using 8080,[::]:8080, or the short form +8080.\n * Both forms differ in detail: 8080,[::]:8080 create two sockets,\n * one only accepting IPv4 the other only IPv6. +8080 creates\n * one socket accepting IPv4 and IPv6. Depending on the IPv6\n * environment, they might work differently, or might not work\n * at all - it must be tested what options work best in the\n * relevant network environment.\n */\nstatic int\nparse_port_string(const struct vec *vec, struct socket *so, int *ip_version)\n{\n\tunsigned int a, b, c, d, port;\n\tint ch, len;\n\tconst char *cb;\n#if defined(USE_IPV6)\n\tchar buf[100] = {0};\n#endif\n\n\t/* MacOS needs that. If we do not zero it, subsequent bind() will fail.\n\t * Also, all-zeroes in the socket address means binding to all addresses\n\t * for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT). */\n\tmemset(so, 0, sizeof(*so));\n\tso->lsa.sin.sin_family = AF_INET;\n\t*ip_version = 0;\n\n\t/* Initialize port and len as invalid. */\n\tport = 0;\n\tlen = 0;\n\n\t/* Test for different ways to format this string */\n\tif (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len)\n\t    == 5) {\n\t\t/* Bind to a specific IPv4 address, e.g. 192.168.1.5:8080 */\n\t\tso->lsa.sin.sin_addr.s_addr =\n\t\t    htonl((a << 24) | (b << 16) | (c << 8) | d);\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n#if defined(USE_IPV6)\n\t} else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2\n\t           && mg_inet_pton(\n\t                  AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6))) {\n\t\t/* IPv6 address, examples: see above */\n\t\t/* so->lsa.sin6.sin6_family = AF_INET6; already set by mg_inet_pton\n\t\t */\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 6;\n#endif\n\n\t} else if ((vec->ptr[0] == '+')\n\t           && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len) == 1)) {\n\n\t\t/* Port is specified with a +, bind to IPv6 and IPv4, INADDR_ANY */\n\t\t/* Add 1 to len for the + character we skipped before */\n\t\tlen++;\n\n#if defined(USE_IPV6)\n\t\t/* Set socket family to IPv6, do not use IPV6_V6ONLY */\n\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 4 + 6;\n#else\n\t\t/* Bind to IPv4 only, since IPv6 is not built in. */\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n#endif\n\n\t} else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {\n\t\t/* If only port is specified, bind to IPv4, INADDR_ANY */\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n\t} else if ((cb = strchr(vec->ptr, ':')) != NULL) {\n\t\t/* String could be a hostname. This check algotithm\n\t\t * will only work for RFC 952 compliant hostnames,\n\t\t * starting with a letter, containing only letters,\n\t\t * digits and hyphen ('-'). Newer specs may allow\n\t\t * more, but this is not guaranteed here, since it\n\t\t * may interfere with rules for port option lists. */\n\n\t\t/* According to RFC 1035, hostnames are restricted to 255 characters\n\t\t * in total (63 between two dots). */\n\t\tchar hostname[256];\n\t\tsize_t hostnlen = (size_t)(cb - vec->ptr);\n\n\t\tif (hostnlen >= sizeof(hostname)) {\n\t\t\t/* This would be invalid in any case */\n\t\t\t*ip_version = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemcpy(hostname, vec->ptr, hostnlen);\n\t\thostname[hostnlen] = 0;\n\n\t\tif (mg_inet_pton(\n\t\t        AF_INET, vec->ptr, &so->lsa.sin, sizeof(so->lsa.sin))) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 4;\n\t\t\t\tso->lsa.sin.sin_family = AF_INET;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tport = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#if defined(USE_IPV6)\n\t\t} else if (mg_inet_pton(AF_INET6,\n\t\t                        vec->ptr,\n\t\t                        &so->lsa.sin6,\n\t\t                        sizeof(so->lsa.sin6))) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 6;\n\t\t\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tport = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t} else {\n\t\t/* Parsing failure. */\n\t}\n\n\t/* sscanf and the option splitting code ensure the following condition\n\t */\n\tif ((len < 0) && ((unsigned)len > (unsigned)vec->len)) {\n\t\t*ip_version = 0;\n\t\treturn 0;\n\t}\n\tch = vec->ptr[len]; /* Next character after the port number */\n\tso->is_ssl = (ch == 's');\n\tso->ssl_redir = (ch == 'r');\n\n\t/* Make sure the port is valid and vector ends with 's', 'r' or ',' */\n\tif (is_valid_port(port)\n\t    && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {\n\t\treturn 1;\n\t}\n\n\t/* Reset ip_version to 0 if there is an error */\n\t*ip_version = 0;\n\treturn 0;\n}\n\n\n/* Is there any SSL port in use? */\nstatic int\nis_ssl_port_used(const char *ports)\n{\n\tif (ports) {\n\t\t/* There are several different allowed syntax variants:\n\t\t * - \"80\" for a single port using every network interface\n\t\t * - \"localhost:80\" for a single port using only localhost\n\t\t * - \"80,localhost:8080\" for two ports, one bound to localhost\n\t\t * - \"80,127.0.0.1:8084,[::1]:8086\" for three ports, one bound\n\t\t *   to IPv4 localhost, one to IPv6 localhost\n\t\t * - \"+80\" use port 80 for IPv4 and IPv6\n\t\t * - \"+80r,+443s\" port 80 (HTTP) is a redirect to port 443 (HTTPS),\n\t\t *   for both: IPv4 and IPv4\n\t\t * - \"+443s,localhost:8080\" port 443 (HTTPS) for every interface,\n\t\t *   additionally port 8080 bound to localhost connections\n\t\t *\n\t\t * If we just look for 's' anywhere in the string, \"localhost:80\"\n\t\t * will be detected as SSL (false positive).\n\t\t * Looking for 's' after a digit may cause false positives in\n\t\t * \"my24service:8080\".\n\t\t * Looking from 's' backward if there are only ':' and numbers\n\t\t * before will not work for \"24service:8080\" (non SSL, port 8080)\n\t\t * or \"24s\" (SSL, port 24).\n\t\t *\n\t\t * Remark: Initially hostnames were not allowed to start with a\n\t\t * digit (according to RFC 952), this was allowed later (RFC 1123,\n\t\t * Section 2.1).\n\t\t *\n\t\t * To get this correct, the entire string must be parsed as a whole,\n\t\t * reading it as a list element for element and parsing with an\n\t\t * algorithm equivalent to parse_port_string.\n\t\t *\n\t\t * In fact, we use local interface names here, not arbitrary hostnames,\n\t\t * so in most cases the only name will be \"localhost\".\n\t\t *\n\t\t * So, for now, we use this simple algorithm, that may still return\n\t\t * a false positive in bizarre cases.\n\t\t */\n\t\tint i;\n\t\tint portslen = (int)strlen(ports);\n\t\tchar prevIsNumber = 0;\n\n\t\tfor (i = 0; i < portslen; i++) {\n\t\t\tif (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (ports[i] >= '0' && ports[i] <= '9') {\n\t\t\t\tprevIsNumber = 1;\n\t\t\t} else {\n\t\t\t\tprevIsNumber = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_ports_option(struct mg_context *phys_ctx)\n{\n\tconst char *list;\n\tint on = 1;\n#if defined(USE_IPV6)\n\tint off = 0;\n#endif\n\tstruct vec vec;\n\tstruct socket so, *ptr;\n\n\tstruct pollfd *pfd;\n\tunion usa usa;\n\tsocklen_t len;\n\tint ip_version;\n\n\tint portsTotal = 0;\n\tint portsOk = 0;\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&so, 0, sizeof(so));\n\tmemset(&usa, 0, sizeof(usa));\n\tlen = sizeof(usa);\n\tlist = phys_ctx->dd.config[LISTENING_PORTS];\n\n\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\n\t\tportsTotal++;\n\n\t\tif (!parse_port_string(&vec, &so, &ip_version)) {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"%.*s: invalid port spec (entry %i). Expecting list of: %s\",\n\t\t\t    (int)vec.len,\n\t\t\t    vec.ptr,\n\t\t\t    portsTotal,\n\t\t\t    \"[IP_ADDRESS:]PORT[s|r]\");\n\t\t\tcontinue;\n\t\t}\n\n#if !defined(NO_SSL)\n\t\tif (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"Cannot add SSL socket (entry %i)\",\n\t\t\t                portsTotal);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6))\n\t\t    == INVALID_SOCKET) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot create socket (entry %i)\",\n\t\t\t                portsTotal);\n\t\t\tcontinue;\n\t\t}\n\n#if defined(_WIN32)\n\t\t/* Windows SO_REUSEADDR lets many procs binds to a\n\t\t * socket, SO_EXCLUSIVEADDRUSE makes the bind fail\n\t\t * if someone already has the socket -- DTL */\n\t\t/* NOTE: If SO_EXCLUSIVEADDRUSE is used,\n\t\t * Windows might need a few seconds before\n\t\t * the same port can be used again in the\n\t\t * same process, so a short Sleep may be\n\t\t * required between mg_stop and mg_start.\n\t\t */\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_EXCLUSIVEADDRUSE,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on)) != 0) {\n\n\t\t\t/* Set reuse option, but don't abort on errors. */\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)\",\n\t\t\t    portsTotal);\n\t\t}\n#else\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_REUSEADDR,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on)) != 0) {\n\n\t\t\t/* Set reuse option, but don't abort on errors. */\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot set socket option SO_REUSEADDR (entry %i)\",\n\t\t\t                portsTotal);\n\t\t}\n#endif\n\n\t\tif (ip_version > 4) {\n/* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */\n#if defined(USE_IPV6)\n\t\t\tif (ip_version > 6) {\n\t\t\t\tif (so.lsa.sa.sa_family == AF_INET6\n\t\t\t\t    && setsockopt(so.sock,\n\t\t\t\t                  IPPROTO_IPV6,\n\t\t\t\t                  IPV6_V6ONLY,\n\t\t\t\t                  (void *)&off,\n\t\t\t\t                  sizeof(off)) != 0) {\n\n\t\t\t\t\t/* Set IPv6 only option, but don't abort on errors. */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    fc(phys_ctx),\n\t\t\t\t\t    \"cannot set socket option IPV6_V6ONLY=off (entry %i)\",\n\t\t\t\t\t    portsTotal);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (so.lsa.sa.sa_family == AF_INET6\n\t\t\t\t    && setsockopt(so.sock,\n\t\t\t\t                  IPPROTO_IPV6,\n\t\t\t\t                  IPV6_V6ONLY,\n\t\t\t\t                  (void *)&on,\n\t\t\t\t                  sizeof(on)) != 0) {\n\n\t\t\t\t\t/* Set IPv6 only option, but don't abort on errors. */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    fc(phys_ctx),\n\t\t\t\t\t    \"cannot set socket option IPV6_V6ONLY=on (entry %i)\",\n\t\t\t\t\t    portsTotal);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"IPv6 not available\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tif (so.lsa.sa.sa_family == AF_INET) {\n\n\t\t\tlen = sizeof(so.lsa.sin);\n\t\t\tif (bind(so.sock, &so.lsa.sa, len) != 0) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"cannot bind to %.*s: %d (%s)\",\n\t\t\t\t                (int)vec.len,\n\t\t\t\t                vec.ptr,\n\t\t\t\t                (int)ERRNO,\n\t\t\t\t                strerror(errno));\n\t\t\t\tclosesocket(so.sock);\n\t\t\t\tso.sock = INVALID_SOCKET;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#if defined(USE_IPV6)\n\t\telse if (so.lsa.sa.sa_family == AF_INET6) {\n\n\t\t\tlen = sizeof(so.lsa.sin6);\n\t\t\tif (bind(so.sock, &so.lsa.sa, len) != 0) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"cannot bind to IPv6 %.*s: %d (%s)\",\n\t\t\t\t                (int)vec.len,\n\t\t\t\t                vec.ptr,\n\t\t\t\t                (int)ERRNO,\n\t\t\t\t                strerror(errno));\n\t\t\t\tclosesocket(so.sock);\n\t\t\t\tso.sock = INVALID_SOCKET;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\telse {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"cannot bind: address family not supported (entry %i)\",\n\t\t\t    portsTotal);\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (listen(so.sock, SOMAXCONN) != 0) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot listen to %.*s: %d (%s)\",\n\t\t\t                (int)vec.len,\n\t\t\t                vec.ptr,\n\t\t\t                (int)ERRNO,\n\t\t\t                strerror(errno));\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((getsockname(so.sock, &(usa.sa), &len) != 0)\n\t\t    || (usa.sa.sa_family != so.lsa.sa.sa_family)) {\n\n\t\t\tint err = (int)ERRNO;\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"call to getsockname failed %.*s: %d (%s)\",\n\t\t\t                (int)vec.len,\n\t\t\t                vec.ptr,\n\t\t\t                err,\n\t\t\t                strerror(errno));\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n/* Update lsa port in case of random free ports */\n#if defined(USE_IPV6)\n\t\tif (so.lsa.sa.sa_family == AF_INET6) {\n\t\t\tso.lsa.sin6.sin6_port = usa.sin6.sin6_port;\n\t\t} else\n#endif\n\t\t{\n\t\t\tso.lsa.sin.sin_port = usa.sin.sin_port;\n\t\t}\n\n\t\tif ((ptr = (struct socket *)\n\t\t         mg_realloc_ctx(phys_ctx->listening_sockets,\n\t\t                        (phys_ctx->num_listening_sockets + 1)\n\t\t                            * sizeof(phys_ctx->listening_sockets[0]),\n\t\t                        phys_ctx)) == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Out of memory\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pfd = (struct pollfd *)\n\t\t         mg_realloc_ctx(phys_ctx->listening_socket_fds,\n\t\t                        (phys_ctx->num_listening_sockets + 1)\n\t\t                            * sizeof(phys_ctx->listening_socket_fds[0]),\n\t\t                        phys_ctx)) == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Out of memory\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tmg_free(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_close_on_exec(so.sock, fc(phys_ctx));\n\t\tphys_ctx->listening_sockets = ptr;\n\t\tphys_ctx->listening_sockets[phys_ctx->num_listening_sockets] = so;\n\t\tphys_ctx->listening_socket_fds = pfd;\n\t\tphys_ctx->num_listening_sockets++;\n\t\tportsOk++;\n\t}\n\n\tif (portsOk != portsTotal) {\n\t\tclose_all_listening_sockets(phys_ctx);\n\t\tportsOk = 0;\n\t}\n\n\treturn portsOk;\n}\n\n\nstatic const char *\nheader_val(const struct mg_connection *conn, const char *header)\n{\n\tconst char *header_value;\n\n\tif ((header_value = mg_get_header(conn, header)) == NULL) {\n\t\treturn \"-\";\n\t} else {\n\t\treturn header_value;\n\t}\n}\n\n\n#if defined(MG_EXTERNAL_FUNCTION_log_access)\nstatic void log_access(const struct mg_connection *conn);\n#include \"external_log_access.inl\"\n#else\n\nstatic void\nlog_access(const struct mg_connection *conn)\n{\n\tconst struct mg_request_info *ri;\n\tstruct mg_file fi;\n\tchar date[64], src_addr[IP_ADDR_STR_LEN];\n\tstruct tm *tm;\n\n\tconst char *referer;\n\tconst char *user_agent;\n\n\tchar buf[4096];\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tif (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {\n\t\tif (mg_fopen(conn,\n\t\t             conn->dom_ctx->config[ACCESS_LOG_FILE],\n\t\t             MG_FOPEN_MODE_APPEND,\n\t\t             &fi) == 0) {\n\t\t\tfi.access.fp = NULL;\n\t\t}\n\t} else {\n\t\tfi.access.fp = NULL;\n\t}\n\n\t/* Log is written to a file and/or a callback. If both are not set,\n\t * executing the rest of the function is pointless. */\n\tif ((fi.access.fp == NULL)\n\t    && (conn->phys_ctx->callbacks.log_access == NULL)) {\n\t\treturn;\n\t}\n\n\ttm = localtime(&conn->conn_birth_time);\n\tif (tm != NULL) {\n\t\tstrftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\", tm);\n\t} else {\n\t\tmg_strlcpy(date, \"01/Jan/1970:00:00:00 +0000\", sizeof(date));\n\t\tdate[sizeof(date) - 1] = '\\0';\n\t}\n\n\tri = &conn->request_info;\n\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\treferer = header_val(conn, \"Referer\");\n\tuser_agent = header_val(conn, \"User-Agent\");\n\n\tmg_snprintf(conn,\n\t            NULL, /* Ignore truncation in access log */\n\t            buf,\n\t            sizeof(buf),\n\t            \"%s - %s [%s] \\\"%s %s%s%s HTTP/%s\\\" %d %\" INT64_FMT \" %s %s\",\n\t            src_addr,\n\t            (ri->remote_user == NULL) ? \"-\" : ri->remote_user,\n\t            date,\n\t            ri->request_method ? ri->request_method : \"-\",\n\t            ri->request_uri ? ri->request_uri : \"-\",\n\t            ri->query_string ? \"?\" : \"\",\n\t            ri->query_string ? ri->query_string : \"\",\n\t            ri->http_version,\n\t            conn->status_code,\n\t            conn->num_bytes_sent,\n\t            referer,\n\t            user_agent);\n\n\tif (conn->phys_ctx->callbacks.log_access) {\n\t\tconn->phys_ctx->callbacks.log_access(conn, buf);\n\t}\n\n\tif (fi.access.fp) {\n\t\tint ok = 1;\n\t\tflockfile(fi.access.fp);\n\t\tif (fprintf(fi.access.fp, \"%s\\n\", buf) < 1) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (fflush(fi.access.fp) != 0) {\n\t\t\tok = 0;\n\t\t}\n\t\tfunlockfile(fi.access.fp);\n\t\tif (mg_fclose(&fi.access) != 0) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (!ok) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error writing log file %s\",\n\t\t\t                conn->dom_ctx->config[ACCESS_LOG_FILE]);\n\t\t}\n\t}\n}\n\n#endif /* Externally provided function */\n\n\n/* Verify given socket address against the ACL.\n * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.\n */\nstatic int\ncheck_acl(struct mg_context *phys_ctx, uint32_t remote_ip)\n{\n\tint allowed, flag;\n\tuint32_t net, mask;\n\tstruct vec vec;\n\n\tif (phys_ctx) {\n\t\tconst char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];\n\n\t\t/* If any ACL is set, deny by default */\n\t\tallowed = (list == NULL) ? '+' : '-';\n\n\t\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\t\t\tflag = vec.ptr[0];\n\t\t\tif ((flag != '+' && flag != '-')\n\t\t\t    || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: subnet must be [+|-]x.x.x.x[/x]\",\n\t\t\t\t                __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (net == (remote_ip & mask)) {\n\t\t\t\tallowed = flag;\n\t\t\t}\n\t\t}\n\n\t\treturn allowed == '+';\n\t}\n\treturn -1;\n}\n\n\n#if !defined(_WIN32)\nstatic int\nset_uid_option(struct mg_context *phys_ctx)\n{\n\tint success = 0;\n\n\tif (phys_ctx) {\n\t\t/* We are currently running as curr_uid. */\n\t\tconst uid_t curr_uid = getuid();\n\t\t/* If set, we want to run as run_as_user. */\n\t\tconst char *run_as_user = phys_ctx->dd.config[RUN_AS_USER];\n\t\tconst struct passwd *to_pw = NULL;\n\n\t\tif (run_as_user != NULL && (to_pw = getpwnam(run_as_user)) == NULL) {\n\t\t\t/* run_as_user does not exist on the system. We can't proceed\n\t\t\t * further. */\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"%s: unknown user [%s]\",\n\t\t\t                __func__,\n\t\t\t                run_as_user);\n\t\t} else if (run_as_user == NULL || curr_uid == to_pw->pw_uid) {\n\t\t\t/* There was either no request to change user, or we're already\n\t\t\t * running as run_as_user. Nothing else to do.\n\t\t\t */\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* Valid change request.  */\n\t\t\tif (setgid(to_pw->pw_gid) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setgid(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                run_as_user,\n\t\t\t\t                strerror(errno));\n\t\t\t} else if (setgroups(0, NULL) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setgroups(): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                strerror(errno));\n\t\t\t} else if (setuid(to_pw->pw_uid) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setuid(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                run_as_user,\n\t\t\t\t                strerror(errno));\n\t\t\t} else {\n\t\t\t\tsuccess = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn success;\n}\n#endif /* !_WIN32 */\n\n\nstatic void\ntls_dtor(void *key)\n{\n\tstruct mg_workerTLS *tls = (struct mg_workerTLS *)key;\n\t/* key == pthread_getspecific(sTlsKey); */\n\n\tif (tls) {\n\t\tif (tls->is_master == 2) {\n\t\t\ttls->is_master = -3; /* Mark memory as dead */\n\t\t\tmg_free(tls);\n\t\t}\n\t}\n\tpthread_setspecific(sTlsKey, NULL);\n}\n\n\n#if !defined(NO_SSL)\n\nstatic int ssl_use_pem_file(struct mg_context *phys_ctx,\n                            struct mg_domain_context *dom_ctx,\n                            const char *pem,\n                            const char *chain);\nstatic const char *ssl_error(void);\n\n\nstatic int\nrefresh_trust(struct mg_connection *conn)\n{\n\tstatic int reload_lock = 0;\n\tstatic long int data_check = 0;\n\tvolatile int *p_reload_lock = (volatile int *)&reload_lock;\n\n\tstruct stat cert_buf;\n\tlong int t;\n\tconst char *pem;\n\tconst char *chain;\n\tint should_verify_peer;\n\n\tif ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {\n\t\t/* If peem is NULL and conn->phys_ctx->callbacks.init_ssl is not,\n\t\t * refresh_trust still can not work. */\n\t\treturn 0;\n\t}\n\tchain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];\n\tif (chain == NULL) {\n\t\t/* pem is not NULL here */\n\t\tchain = pem;\n\t}\n\tif (*chain == 0) {\n\t\tchain = NULL;\n\t}\n\n\tt = data_check;\n\tif (stat(pem, &cert_buf) != -1) {\n\t\tt = (long int)cert_buf.st_mtime;\n\t}\n\n\tif (data_check != t) {\n\t\tdata_check = t;\n\n\t\tshould_verify_peer = 0;\n\t\tif (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {\n\t\t\tif (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], \"yes\")\n\t\t\t    == 0) {\n\t\t\t\tshould_verify_peer = 1;\n\t\t\t} else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],\n\t\t\t                         \"optional\") == 0) {\n\t\t\t\tshould_verify_peer = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (should_verify_peer) {\n\t\t\tchar *ca_path = conn->dom_ctx->config[SSL_CA_PATH];\n\t\t\tchar *ca_file = conn->dom_ctx->config[SSL_CA_FILE];\n\t\t\tif (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,\n\t\t\t                                  ca_file,\n\t\t\t                                  ca_path) != 1) {\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    fc(conn->phys_ctx),\n\t\t\t\t    \"SSL_CTX_load_verify_locations error: %s \"\n\t\t\t\t    \"ssl_verify_peer requires setting \"\n\t\t\t\t    \"either ssl_ca_path or ssl_ca_file. Is any of them \"\n\t\t\t\t    \"present in \"\n\t\t\t\t    \"the .conf file?\",\n\t\t\t\t    ssl_error());\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (1 == mg_atomic_inc(p_reload_lock)) {\n\t\t\tif (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain)\n\t\t\t    == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*p_reload_lock = 0;\n\t\t}\n\t}\n\t/* lock while cert is reloading */\n\twhile (*p_reload_lock) {\n\t\tsleep(1);\n\t}\n\n\treturn 1;\n}\n\n#if defined(OPENSSL_API_1_1)\n#else\nstatic pthread_mutex_t *ssl_mutexes;\n#endif /* OPENSSL_API_1_1 */\n\nstatic int\nsslize(struct mg_connection *conn,\n       SSL_CTX *s,\n       int (*func)(SSL *),\n       volatile int *stop_server)\n{\n\tint ret, err;\n\tint short_trust;\n\tunsigned i;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tshort_trust =\n\t    (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL)\n\t    && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], \"yes\") == 0);\n\n\tif (short_trust) {\n\t\tint trust_ret = refresh_trust(conn);\n\t\tif (!trust_ret) {\n\t\t\treturn trust_ret;\n\t\t}\n\t}\n\n\tconn->ssl = SSL_new(s);\n\tif (conn->ssl == NULL) {\n\t\treturn 0;\n\t}\n\tSSL_set_app_data(conn->ssl, (char *)conn);\n\n\tret = SSL_set_fd(conn->ssl, conn->client.sock);\n\tif (ret != 1) {\n\t\terr = SSL_get_error(conn->ssl, ret);\n\t\tmg_cry_internal(conn, \"SSL error %i, destroying SSL context\", err);\n\t\tSSL_free(conn->ssl);\n\t\tconn->ssl = NULL;\n/* Avoid CRYPTO_cleanup_all_ex_data(); See discussion:\n * https://wiki.openssl.org/index.php/Talk:Library_Initialization */\n#if !defined(OPENSSL_API_1_1)\n\t\tERR_remove_state(0);\n#endif\n\t\treturn 0;\n\t}\n\n\t/* SSL functions may fail and require to be called again:\n\t * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html\n\t * Here \"func\" could be SSL_connect or SSL_accept. */\n\tfor (i = 16; i <= 1024; i *= 2) {\n\t\tret = func(conn->ssl);\n\t\tif (ret != 1) {\n\t\t\terr = SSL_get_error(conn->ssl, ret);\n\t\t\tif ((err == SSL_ERROR_WANT_CONNECT)\n\t\t\t    || (err == SSL_ERROR_WANT_ACCEPT)\n\t\t\t    || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE)\n\t\t\t    || (err == SSL_ERROR_WANT_X509_LOOKUP)) {\n\t\t\t\t/* Need to retry the function call \"later\".\n\t\t\t\t * See https://linux.die.net/man/3/ssl_get_error\n\t\t\t\t * This is typical for non-blocking sockets. */\n\t\t\t\tif (*stop_server) {\n\t\t\t\t\t/* Don't wait if the server is going to be stopped. */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmg_sleep(i);\n\n\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t/* This is an IO error. Look at errno. */\n\t\t\t\terr = errno;\n\t\t\t\tmg_cry_internal(conn, \"SSL syscall error %i\", err);\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t/* This is an SSL specific error, e.g. SSL_ERROR_SSL */\n\t\t\t\tmg_cry_internal(conn, \"sslize error: %s\", ssl_error());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* success */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != 1) {\n\t\tSSL_free(conn->ssl);\n\t\tconn->ssl = NULL;\n/* Avoid CRYPTO_cleanup_all_ex_data(); See discussion:\n * https://wiki.openssl.org/index.php/Talk:Library_Initialization */\n#if !defined(OPENSSL_API_1_1)\n\t\tERR_remove_state(0);\n#endif\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\n/* Return OpenSSL error message (from CRYPTO lib) */\nstatic const char *\nssl_error(void)\n{\n\tunsigned long err;\n\terr = ERR_get_error();\n\treturn ((err == 0) ? \"\" : ERR_error_string(err, NULL));\n}\n\n\nstatic int\nhexdump2string(void *mem, int memlen, char *buf, int buflen)\n{\n\tint i;\n\tconst char hexdigit[] = \"0123456789abcdef\";\n\n\tif ((memlen <= 0) || (buflen <= 0)) {\n\t\treturn 0;\n\t}\n\tif (buflen < (3 * memlen)) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < memlen; i++) {\n\t\tif (i > 0) {\n\t\t\tbuf[3 * i - 1] = ' ';\n\t\t}\n\t\tbuf[3 * i] = hexdigit[(((uint8_t *)mem)[i] >> 4) & 0xF];\n\t\tbuf[3 * i + 1] = hexdigit[((uint8_t *)mem)[i] & 0xF];\n\t}\n\tbuf[3 * memlen - 1] = 0;\n\n\treturn 1;\n}\n\n\nstatic void\nssl_get_client_cert_info(struct mg_connection *conn)\n{\n\tX509 *cert = SSL_get_peer_certificate(conn->ssl);\n\tif (cert) {\n\t\tchar str_subject[1024];\n\t\tchar str_issuer[1024];\n\t\tchar str_finger[1024];\n\t\tunsigned char buf[256];\n\t\tchar *str_serial = NULL;\n\t\tunsigned int ulen;\n\t\tint ilen;\n\t\tunsigned char *tmp_buf;\n\t\tunsigned char *tmp_p;\n\n\t\t/* Handle to algorithm used for fingerprint */\n\t\tconst EVP_MD *digest = EVP_get_digestbyname(\"sha1\");\n\n\t\t/* Get Subject and issuer */\n\t\tX509_NAME *subj = X509_get_subject_name(cert);\n\t\tX509_NAME *iss = X509_get_issuer_name(cert);\n\n\t\t/* Get serial number */\n\t\tASN1_INTEGER *serial = X509_get_serialNumber(cert);\n\n\t\t/* Translate serial number to a hex string */\n\t\tBIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);\n\t\tstr_serial = BN_bn2hex(serial_bn);\n\t\tBN_free(serial_bn);\n\n\t\t/* Translate subject and issuer to a string */\n\t\t(void)X509_NAME_oneline(subj, str_subject, (int)sizeof(str_subject));\n\t\t(void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));\n\n\t\t/* Calculate SHA1 fingerprint and store as a hex string */\n\t\tulen = 0;\n\n\t\t/* ASN1_digest is deprecated. Do the calculation manually,\n\t\t * using EVP_Digest. */\n\t\tilen = i2d_X509(cert, NULL);\n\t\ttmp_buf = (ilen > 0)\n\t\t              ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1,\n\t\t                                               conn->phys_ctx)\n\t\t              : NULL;\n\t\tif (tmp_buf) {\n\t\t\ttmp_p = tmp_buf;\n\t\t\t(void)i2d_X509(cert, &tmp_p);\n\t\t\tif (!EVP_Digest(\n\t\t\t        tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {\n\t\t\t\tulen = 0;\n\t\t\t}\n\t\t\tmg_free(tmp_buf);\n\t\t}\n\n\t\tif (!hexdump2string(\n\t\t        buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {\n\t\t\t*str_finger = 0;\n\t\t}\n\n\t\tconn->request_info.client_cert = (struct mg_client_cert *)\n\t\t    mg_malloc_ctx(sizeof(struct mg_client_cert), conn->phys_ctx);\n\t\tif (conn->request_info.client_cert) {\n\t\t\tconn->request_info.client_cert->peer_cert = (void *)cert;\n\t\t\tconn->request_info.client_cert->subject =\n\t\t\t    mg_strdup_ctx(str_subject, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->issuer =\n\t\t\t    mg_strdup_ctx(str_issuer, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->serial =\n\t\t\t    mg_strdup_ctx(str_serial, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->finger =\n\t\t\t    mg_strdup_ctx(str_finger, conn->phys_ctx);\n\t\t} else {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s\",\n\t\t\t                \"Out of memory: Cannot allocate memory for client \"\n\t\t\t                \"certificate\");\n\t\t}\n\n\t\t/* Strings returned from bn_bn2hex must be freed using OPENSSL_free,\n\t\t * see https://linux.die.net/man/3/bn_bn2hex */\n\t\tOPENSSL_free(str_serial);\n\t}\n}\n\n\n#if defined(OPENSSL_API_1_1)\n#else\nstatic void\nssl_locking_callback(int mode, int mutex_num, const char *file, int line)\n{\n\t(void)line;\n\t(void)file;\n\n\tif (mode & 1) {\n\t\t/* 1 is CRYPTO_LOCK */\n\t\t(void)pthread_mutex_lock(&ssl_mutexes[mutex_num]);\n\t} else {\n\t\t(void)pthread_mutex_unlock(&ssl_mutexes[mutex_num]);\n\t}\n}\n#endif /* OPENSSL_API_1_1 */\n\n\n#if !defined(NO_SSL_DL)\nstatic void *\nload_dll(char *ebuf, size_t ebuf_len, const char *dll_name, struct ssl_func *sw)\n{\n\tunion {\n\t\tvoid *p;\n\t\tvoid (*fp)(void);\n\t} u;\n\tvoid *dll_handle;\n\tstruct ssl_func *fp;\n\tint ok;\n\tint truncated = 0;\n\n\tif ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s: cannot load %s\",\n\t\t            __func__,\n\t\t            dll_name);\n\t\treturn NULL;\n\t}\n\n\tok = 1;\n\tfor (fp = sw; fp->name != NULL; fp++) {\n#if defined(_WIN32)\n\t\t/* GetProcAddress() returns pointer to function */\n\t\tu.fp = (void (*)(void))dlsym(dll_handle, fp->name);\n#else\n\t\t/* dlsym() on UNIX returns void *. ISO C forbids casts of data\n\t\t * pointers to function pointers. We need to use a union to make a\n\t\t * cast. */\n\t\tu.p = dlsym(dll_handle, fp->name);\n#endif /* _WIN32 */\n\t\tif (u.fp == NULL) {\n\t\t\tif (ok) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            &truncated,\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"%s: %s: cannot find %s\",\n\t\t\t\t            __func__,\n\t\t\t\t            dll_name,\n\t\t\t\t            fp->name);\n\t\t\t\tok = 0;\n\t\t\t} else {\n\t\t\t\tsize_t cur_len = strlen(ebuf);\n\t\t\t\tif (!truncated) {\n\t\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t\t            &truncated,\n\t\t\t\t\t            ebuf + cur_len,\n\t\t\t\t\t            ebuf_len - cur_len - 3,\n\t\t\t\t\t            \", %s\",\n\t\t\t\t\t            fp->name);\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\t/* If truncated, add \"...\" */\n\t\t\t\t\t\tstrcat(ebuf, \"...\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Debug:\n\t\t\t * printf(\"Missing function: %s\\n\", fp->name); */\n\t\t} else {\n\t\t\tfp->ptr = u.fp;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\t(void)dlclose(dll_handle);\n\t\treturn NULL;\n\t}\n\n\treturn dll_handle;\n}\n\n\nstatic void *ssllib_dll_handle;    /* Store the ssl library handle. */\nstatic void *cryptolib_dll_handle; /* Store the crypto library handle. */\n\n#endif /* NO_SSL_DL */\n\n\n#if defined(SSL_ALREADY_INITIALIZED)\nstatic int cryptolib_users = 1; /* Reference counter for crypto library. */\n#else\nstatic int cryptolib_users = 0; /* Reference counter for crypto library. */\n#endif\n\n\nstatic int\ninitialize_ssl(char *ebuf, size_t ebuf_len)\n{\n#if defined(OPENSSL_API_1_1)\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = 0;\n\t}\n\n#if !defined(NO_SSL_DL)\n\tif (!cryptolib_dll_handle) {\n\t\tcryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);\n\t\tif (!cryptolib_dll_handle) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: error loading library %s\",\n\t\t\t            __func__,\n\t\t\t            CRYPTO_LIB);\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n\tif (mg_atomic_inc(&cryptolib_users) > 1) {\n\t\treturn 1;\n\t}\n\n#else /* not OPENSSL_API_1_1 */\n\tint i, num_locks;\n\tsize_t size;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = 0;\n\t}\n\n#if !defined(NO_SSL_DL)\n\tif (!cryptolib_dll_handle) {\n\t\tcryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);\n\t\tif (!cryptolib_dll_handle) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: error loading library %s\",\n\t\t\t            __func__,\n\t\t\t            CRYPTO_LIB);\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n\tif (mg_atomic_inc(&cryptolib_users) > 1) {\n\t\treturn 1;\n\t}\n\n\t/* Initialize locking callbacks, needed for thread safety.\n\t * http://www.openssl.org/support/faq.html#PROG1\n\t */\n\tnum_locks = CRYPTO_num_locks();\n\tif (num_locks < 0) {\n\t\tnum_locks = 0;\n\t}\n\tsize = sizeof(pthread_mutex_t) * ((size_t)(num_locks));\n\n\t/* allocate mutex array, if required */\n\tif (num_locks == 0) {\n\t\t/* No mutex array required */\n\t\tssl_mutexes = NULL;\n\t} else {\n\t\t/* Mutex array required - allocate it */\n\t\tssl_mutexes = (pthread_mutex_t *)mg_malloc(size);\n\n\t\t/* Check OOM */\n\t\tif (ssl_mutexes == NULL) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: cannot allocate mutexes: %s\",\n\t\t\t            __func__,\n\t\t\t            ssl_error());\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* initialize mutex array */\n\t\tfor (i = 0; i < num_locks; i++) {\n\t\t\tif (0 != pthread_mutex_init(&ssl_mutexes[i], &pthread_mutex_attr)) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"%s: error initializing mutex %i of %i\",\n\t\t\t\t            __func__,\n\t\t\t\t            i,\n\t\t\t\t            num_locks);\n\t\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\t\tmg_free(ssl_mutexes);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tCRYPTO_set_locking_callback(&ssl_locking_callback);\n\tCRYPTO_set_id_callback(&mg_current_thread_id);\n#endif /* OPENSSL_API_1_1 */\n\n#if !defined(NO_SSL_DL)\n\tif (!ssllib_dll_handle) {\n\t\tssllib_dll_handle = load_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw);\n\t\tif (!ssllib_dll_handle) {\n#if !defined(OPENSSL_API_1_1)\n\t\t\tmg_free(ssl_mutexes);\n#endif\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n#if defined(OPENSSL_API_1_1)\n\t/* Initialize SSL library */\n\tOPENSSL_init_ssl(0, NULL);\n\tOPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS\n\t                     | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,\n\t                 NULL);\n#else\n\t/* Initialize SSL library */\n\tSSL_library_init();\n\tSSL_load_error_strings();\n#endif\n\n\treturn 1;\n}\n\n\nstatic int\nssl_use_pem_file(struct mg_context *phys_ctx,\n                 struct mg_domain_context *dom_ctx,\n                 const char *pem,\n                 const char *chain)\n{\n\tif (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: cannot open certificate file %s: %s\",\n\t\t                __func__,\n\t\t                pem,\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n\n\t/* could use SSL_CTX_set_default_passwd_cb_userdata */\n\tif (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: cannot open private key file %s: %s\",\n\t\t                __func__,\n\t\t                pem,\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n\n\tif (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: certificate and private key do not match: %s\",\n\t\t                __func__,\n\t\t                pem);\n\t\treturn 0;\n\t}\n\n\t/* In contrast to OpenSSL, wolfSSL does not support certificate\n\t * chain files that contain private keys and certificates in\n\t * SSL_CTX_use_certificate_chain_file.\n\t * The CivetWeb-Server used pem-Files that contained both information.\n\t * In order to make wolfSSL work, it is split in two files.\n\t * One file that contains key and certificate used by the server and\n\t * an optional chain file for the ssl stack.\n\t */\n\tif (chain) {\n\t\tif (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"%s: cannot use certificate chain file %s: %s\",\n\t\t\t                __func__,\n\t\t\t                pem,\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n\n#if defined(OPENSSL_API_1_1)\nstatic unsigned long\nssl_get_protocol(int version_id)\n{\n\tlong unsigned ret = (long unsigned)SSL_OP_ALL;\n\tif (version_id > 0)\n\t\tret |= SSL_OP_NO_SSLv2;\n\tif (version_id > 1)\n\t\tret |= SSL_OP_NO_SSLv3;\n\tif (version_id > 2)\n\t\tret |= SSL_OP_NO_TLSv1;\n\tif (version_id > 3)\n\t\tret |= SSL_OP_NO_TLSv1_1;\n\treturn ret;\n}\n#else\nstatic long\nssl_get_protocol(int version_id)\n{\n\tlong ret = (long)SSL_OP_ALL;\n\tif (version_id > 0)\n\t\tret |= SSL_OP_NO_SSLv2;\n\tif (version_id > 1)\n\t\tret |= SSL_OP_NO_SSLv3;\n\tif (version_id > 2)\n\t\tret |= SSL_OP_NO_TLSv1;\n\tif (version_id > 3)\n\t\tret |= SSL_OP_NO_TLSv1_1;\n\treturn ret;\n}\n#endif /* OPENSSL_API_1_1 */\n\n\n/* SSL callback documentation:\n * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html\n * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3)\n * https://linux.die.net/man/3/ssl_set_info_callback */\n/* Note: There is no \"const\" for the first argument in the documentation,\n * however some (maybe most, but not all) headers of OpenSSL versions /\n * OpenSSL compatibility layers have it. Having a different definition\n * will cause a warning in C and an error in C++. With inconsitent\n * definitions of this function, having a warning in one version or\n * another is unavoidable. */\nstatic void\nssl_info_callback(SSL *ssl, int what, int ret)\n{\n\t(void)ret;\n\n\tif (what & SSL_CB_HANDSHAKE_START) {\n\t\tSSL_get_app_data(ssl);\n\t}\n\tif (what & SSL_CB_HANDSHAKE_DONE) {\n\t\t/* TODO: check for openSSL 1.1 */\n\t\t//#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001\n\t\t// ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;\n\t}\n}\n\n\nstatic int\nssl_servername_callback(SSL *ssl, int *ad, void *arg)\n{\n\tstruct mg_context *ctx = (struct mg_context *)arg;\n\tstruct mg_domain_context *dom =\n\t    (struct mg_domain_context *)ctx ? &(ctx->dd) : NULL;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\t/* We used an aligned pointer in SSL_set_app_data */\n\tstruct mg_connection *conn = (struct mg_connection *)SSL_get_app_data(ssl);\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\tconst char *servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n\n\t(void)ad;\n\n\tif ((ctx == NULL) || (conn->phys_ctx == ctx)) {\n\t\tDEBUG_TRACE(\"%s\", \"internal error - assertion failed\");\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t}\n\n\t/* Old clients (Win XP) will not support SNI. Then, there\n\t * is no server name available in the request - we can\n\t * only work with the default certificate.\n\t * Multiple HTTPS hosts on one IP+port are only possible\n\t * with a certificate containing all alternative names.\n\t */\n\tif ((servername == NULL) || (*servername == 0)) {\n\t\tDEBUG_TRACE(\"%s\", \"SSL connection not supporting SNI\");\n\t\tconn->dom_ctx = &(ctx->dd);\n\t\tSSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t}\n\n\tDEBUG_TRACE(\"TLS connection to host %s\", servername);\n\n\twhile (dom) {\n\t\tif (!mg_strcasecmp(servername, dom->config[AUTHENTICATION_DOMAIN])) {\n\n\t\t\t/* Found matching domain */\n\t\t\tDEBUG_TRACE(\"TLS domain %s found\",\n\t\t\t            dom->config[AUTHENTICATION_DOMAIN]);\n\t\t\tSSL_set_SSL_CTX(ssl, dom->ssl_ctx);\n\t\t\tconn->dom_ctx = dom;\n\t\t\treturn SSL_TLSEXT_ERR_OK;\n\t\t}\n\t\tdom = dom->next;\n\t}\n\n\t/* Default domain */\n\tDEBUG_TRACE(\"TLS default domain %s used\",\n\t            ctx->dd.config[AUTHENTICATION_DOMAIN]);\n\tconn->dom_ctx = &(ctx->dd);\n\tSSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);\n\treturn SSL_TLSEXT_ERR_OK;\n}\n\n\n/* Setup SSL CTX as required by CivetWeb */\nstatic int\ninit_ssl_ctx_impl(struct mg_context *phys_ctx,\n                  struct mg_domain_context *dom_ctx,\n                  const char *pem,\n                  const char *chain)\n{\n\tint callback_ret;\n\tint should_verify_peer;\n\tint peer_certificate_optional;\n\tconst char *ca_path;\n\tconst char *ca_file;\n\tint use_default_verify_paths;\n\tint verify_depth;\n\tstruct timespec now_mt;\n\tmd5_byte_t ssl_context_id[16];\n\tmd5_state_t md5state;\n\tint protocol_ver;\n\n#if defined(OPENSSL_API_1_1)\n\tif ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL_CTX_new (server) error: %s\",\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n#else\n\tif ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL_CTX_new (server) error: %s\",\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n#endif /* OPENSSL_API_1_1 */\n\n\tSSL_CTX_clear_options(dom_ctx->ssl_ctx,\n\t                      SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1\n\t                          | SSL_OP_NO_TLSv1_1);\n\tprotocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx,\n\t                    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);\n#if !defined(NO_SSL_DL)\n\tSSL_CTX_set_ecdh_auto(dom_ctx->ssl_ctx, 1);\n#endif /* NO_SSL_DL */\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wincompatible-pointer-types\"\n#endif\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#endif\n\t/* Depending on the OpenSSL version, the callback may be\n\t * 'void (*)(SSL *, int, int)' or 'void (*)(const SSL *, int, int)'\n\t * yielding in an \"incompatible-pointer-type\" warning for the other\n\t * version. It seems to be \"unclear\" what is correct:\n\t * https://bugs.launchpad.net/ubuntu/+source/openssl/+bug/1147526\n\t * https://www.openssl.org/docs/man1.0.2/ssl/ssl.html\n\t * https://www.openssl.org/docs/man1.1.0/ssl/ssl.html\n\t * https://github.com/openssl/openssl/blob/1d97c8435171a7af575f73c526d79e1ef0ee5960/ssl/ssl.h#L1173\n\t * Disable this warning here.\n\t * Alternative would be a version dependent ssl_info_callback and\n\t * a const-cast to call 'char *SSL_get_app_data(SSL *ssl)' there.\n\t */\n\tSSL_CTX_set_info_callback(dom_ctx->ssl_ctx, ssl_info_callback);\n\n\n\tSSL_CTX_set_tlsext_servername_callback(dom_ctx->ssl_ctx,\n\t                                       ssl_servername_callback);\n\tSSL_CTX_set_tlsext_servername_arg(dom_ctx->ssl_ctx, phys_ctx);\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\t/* If a callback has been specified, call it. */\n\tcallback_ret = (phys_ctx->callbacks.init_ssl == NULL)\n\t                   ? 0\n\t                   : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,\n\t                                                   phys_ctx->user_data));\n\n\t/* If callback returns 0, civetweb sets up the SSL certificate.\n\t * If it returns 1, civetweb assumes the calback already did this.\n\t * If it returns -1, initializing ssl fails. */\n\tif (callback_ret < 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL callback returned error: %i\",\n\t\t                callback_ret);\n\t\treturn 0;\n\t}\n\tif (callback_ret > 0) {\n\t\t/* Callback did everything. */\n\t\treturn 1;\n\t}\n\n\t/* Use some combination of start time, domain and port as a SSL\n\t * context ID. This should be unique on the current machine. */\n\tmd5_init(&md5state);\n\tclock_gettime(CLOCK_MONOTONIC, &now_mt);\n\tmd5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));\n\tmd5_append(&md5state,\n\t           (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],\n\t           strlen(phys_ctx->dd.config[LISTENING_PORTS]));\n\tmd5_append(&md5state,\n\t           (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],\n\t           strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));\n\tmd5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));\n\tmd5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));\n\tmd5_finish(&md5state, ssl_context_id);\n\n\tSSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,\n\t                               (unsigned char *)ssl_context_id,\n\t                               sizeof(ssl_context_id));\n\n\tif (pem != NULL) {\n\t\tif (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Should we support client certificates? */\n\t/* Default is \"no\". */\n\tshould_verify_peer = 0;\n\tpeer_certificate_optional = 0;\n\tif (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {\n\t\tif (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], \"yes\") == 0) {\n\t\t\t/* Yes, they are mandatory */\n\t\t\tshould_verify_peer = 1;\n\t\t\tpeer_certificate_optional = 0;\n\t\t} else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],\n\t\t                         \"optional\") == 0) {\n\t\t\t/* Yes, they are optional */\n\t\t\tshould_verify_peer = 1;\n\t\t\tpeer_certificate_optional = 1;\n\t\t}\n\t}\n\n\tuse_default_verify_paths =\n\t    (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL)\n\t    && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], \"yes\")\n\t        == 0);\n\n\tif (should_verify_peer) {\n\t\tca_path = dom_ctx->config[SSL_CA_PATH];\n\t\tca_file = dom_ctx->config[SSL_CA_FILE];\n\t\tif (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path)\n\t\t    != 1) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_load_verify_locations error: %s \"\n\t\t\t                \"ssl_verify_peer requires setting \"\n\t\t\t                \"either ssl_ca_path or ssl_ca_file. \"\n\t\t\t                \"Is any of them present in the \"\n\t\t\t                \".conf file?\",\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (peer_certificate_optional) {\n\t\t\tSSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(dom_ctx->ssl_ctx,\n\t\t\t                   SSL_VERIFY_PEER\n\t\t\t                       | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n\t\t\t                   NULL);\n\t\t}\n\n\t\tif (use_default_verify_paths\n\t\t    && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_set_default_verify_paths error: %s\",\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dom_ctx->config[SSL_VERIFY_DEPTH]) {\n\t\t\tverify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);\n\t\t\tSSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);\n\t\t}\n\t}\n\n\tif (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {\n\t\tif (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,\n\t\t                            dom_ctx->config[SSL_CIPHER_LIST]) != 1) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_set_cipher_list error: %s\",\n\t\t\t                ssl_error());\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\n/* Check if SSL is required.\n * If so, dynamically load SSL library\n * and set up ctx->ssl_ctx pointer. */\nstatic int\ninit_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx)\n{\n\tvoid *ssl_ctx = 0;\n\tint callback_ret;\n\tconst char *pem;\n\tconst char *chain;\n\tchar ebuf[128];\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tif (!dom_ctx) {\n\t\tdom_ctx = &(phys_ctx->dd);\n\t}\n\n\tif (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {\n\t\t/* No SSL port is set. No need to setup SSL. */\n\t\treturn 1;\n\t}\n\n\t/* Check for external SSL_CTX */\n\tcallback_ret =\n\t    (phys_ctx->callbacks.external_ssl_ctx == NULL)\n\t        ? 0\n\t        : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,\n\t                                                phys_ctx->user_data));\n\n\tif (callback_ret < 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"external_ssl_ctx callback returned error: %i\",\n\t\t                callback_ret);\n\t\treturn 0;\n\t} else if (callback_ret > 0) {\n\t\tdom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;\n\t\tif (!initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\t/* else: external_ssl_ctx does not exist or returns 0,\n\t * CivetWeb should continue initializing SSL */\n\n\t/* If PEM file is not specified and the init_ssl callback\n\t * is not specified, setup will fail. */\n\tif (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL)\n\t    && (phys_ctx->callbacks.init_ssl == NULL)) {\n\t\t/* No certificate and no callback:\n\t\t * Essential data to set up TLS is missing.\n\t\t */\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"Initializing SSL failed: -%s is not set\",\n\t\t                config_options[SSL_CERTIFICATE].name);\n\t\treturn 0;\n\t}\n\n\tchain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];\n\tif (chain == NULL) {\n\t\tchain = pem;\n\t}\n\tif ((chain != NULL) && (*chain == 0)) {\n\t\tchain = NULL;\n\t}\n\n\tif (!initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\tmg_cry_internal(fc(phys_ctx), \"%s\", ebuf);\n\t\treturn 0;\n\t}\n\n\treturn init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);\n}\n\n\nstatic void\nuninitialize_ssl(void)\n{\n#if defined(OPENSSL_API_1_1)\n\n\tif (mg_atomic_dec(&cryptolib_users) == 0) {\n\n\t\t/* Shutdown according to\n\t\t * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup\n\t\t * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl\n\t\t */\n\t\tCONF_modules_unload(1);\n#else\n\tint i;\n\n\tif (mg_atomic_dec(&cryptolib_users) == 0) {\n\n\t\t/* Shutdown according to\n\t\t * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup\n\t\t * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl\n\t\t */\n\t\tCRYPTO_set_locking_callback(NULL);\n\t\tCRYPTO_set_id_callback(NULL);\n\t\tENGINE_cleanup();\n\t\tCONF_modules_unload(1);\n\t\tERR_free_strings();\n\t\tEVP_cleanup();\n\t\tCRYPTO_cleanup_all_ex_data();\n\t\tERR_remove_state(0);\n\n\t\tfor (i = 0; i < CRYPTO_num_locks(); i++) {\n\t\t\tpthread_mutex_destroy(&ssl_mutexes[i]);\n\t\t}\n\t\tmg_free(ssl_mutexes);\n\t\tssl_mutexes = NULL;\n#endif /* OPENSSL_API_1_1 */\n\t}\n}\n#endif /* !NO_SSL */\n\n\nstatic int\nset_gpass_option(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx)\n{\n\tif (phys_ctx) {\n\t\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\t\tconst char *path;\n\t\tif (!dom_ctx) {\n\t\t\tdom_ctx = &(phys_ctx->dd);\n\t\t}\n\t\tpath = dom_ctx->config[GLOBAL_PASSWORDS_FILE];\n\t\tif ((path != NULL) && !mg_stat(fc(phys_ctx), path, &file.stat)) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"Cannot open %s: %s\",\n\t\t\t                path,\n\t\t\t                strerror(ERRNO));\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_acl_option(struct mg_context *phys_ctx)\n{\n\treturn check_acl(phys_ctx, (uint32_t)0x7f000001UL) != -1;\n}\n\n\nstatic void\nreset_per_request_attributes(struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn;\n\t}\n\tconn->connection_type =\n\t    CONNECTION_TYPE_INVALID; /* Not yet a valid request/response */\n\n\tconn->num_bytes_sent = conn->consumed_content = 0;\n\n\tconn->path_info = NULL;\n\tconn->status_code = -1;\n\tconn->content_len = -1;\n\tconn->is_chunked = 0;\n\tconn->must_close = 0;\n\tconn->request_len = 0;\n\tconn->throttle = 0;\n\tconn->data_len = 0;\n\tconn->chunk_remainder = 0;\n\tconn->accept_gzip = 0;\n\n\tconn->response_info.content_length = conn->request_info.content_length = -1;\n\tconn->response_info.http_version = conn->request_info.http_version = NULL;\n\tconn->response_info.num_headers = conn->request_info.num_headers = 0;\n\tconn->response_info.status_text = NULL;\n\tconn->response_info.status_code = 0;\n\n\tconn->request_info.remote_user = NULL;\n\tconn->request_info.request_method = NULL;\n\tconn->request_info.request_uri = NULL;\n\tconn->request_info.local_uri = NULL;\n\n#if defined(MG_LEGACY_INTERFACE)\n\t/* Legacy before split into local_uri and request_uri */\n\tconn->request_info.uri = NULL;\n#endif\n}\n\n\n#if 0\n/* Note: set_sock_timeout is not required for non-blocking sockets.\n * Leave this function here (commented out) for reference until\n * CivetWeb 1.9 is tested, and the tests confirme this function is\n * no longer required.\n*/\nstatic int\nset_sock_timeout(SOCKET sock, int milliseconds)\n{\n        int r0 = 0, r1, r2;\n\n#if defined(_WIN32)\n        /* Windows specific */\n\n        DWORD tv = (DWORD)milliseconds;\n\n#else\n        /* Linux, ... (not Windows) */\n\n        struct timeval tv;\n\n/* TCP_USER_TIMEOUT/RFC5482 (http://tools.ietf.org/html/rfc5482):\n * max. time waiting for the acknowledged of TCP data before the connection\n * will be forcefully closed and ETIMEDOUT is returned to the application.\n * If this option is not set, the default timeout of 20-30 minutes is used.\n*/\n/* #define TCP_USER_TIMEOUT (18) */\n\n#if defined(TCP_USER_TIMEOUT)\n        unsigned int uto = (unsigned int)milliseconds;\n        r0 = setsockopt(sock, 6, TCP_USER_TIMEOUT, (const void *)&uto, sizeof(uto));\n#endif\n\n        memset(&tv, 0, sizeof(tv));\n        tv.tv_sec = milliseconds / 1000;\n        tv.tv_usec = (milliseconds * 1000) % 1000000;\n\n#endif /* _WIN32 */\n\n        r1 = setsockopt(\n            sock, SOL_SOCKET, SO_RCVTIMEO, (SOCK_OPT_TYPE)&tv, sizeof(tv));\n        r2 = setsockopt(\n            sock, SOL_SOCKET, SO_SNDTIMEO, (SOCK_OPT_TYPE)&tv, sizeof(tv));\n\n        return r0 || r1 || r2;\n}\n#endif\n\n\nstatic int\nset_tcp_nodelay(SOCKET sock, int nodelay_on)\n{\n\tif (setsockopt(sock,\n\t               IPPROTO_TCP,\n\t               TCP_NODELAY,\n\t               (SOCK_OPT_TYPE)&nodelay_on,\n\t               sizeof(nodelay_on)) != 0) {\n\t\t/* Error */\n\t\treturn 1;\n\t}\n\t/* OK */\n\treturn 0;\n}\n\n\nstatic void\nclose_socket_gracefully(struct mg_connection *conn)\n{\n#if defined(_WIN32)\n\tchar buf[MG_BUF_LEN];\n\tint n;\n#endif\n\tstruct linger linger;\n\tint error_code = 0;\n\tint linger_timeout = -2;\n\tsocklen_t opt_len = sizeof(error_code);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\t/* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:\n\t * \"Note that enabling a nonzero timeout on a nonblocking socket\n\t * is not recommended.\", so set it to blocking now */\n\tset_blocking_mode(conn->client.sock);\n\n\t/* Send FIN to the client */\n\tshutdown(conn->client.sock, SHUTDOWN_WR);\n\n\n#if defined(_WIN32)\n\t/* Read and discard pending incoming data. If we do not do that and\n\t * close\n\t * the socket, the data in the send buffer may be discarded. This\n\t * behaviour is seen on Windows, when client keeps sending data\n\t * when server decides to close the connection; then when client\n\t * does recv() it gets no data back. */\n\tdo {\n\t\tn = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);\n\t} while (n > 0);\n#endif\n\n\tif (conn->dom_ctx->config[LINGER_TIMEOUT]) {\n\t\tlinger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);\n\t}\n\n\t/* Set linger option according to configuration */\n\tif (linger_timeout >= 0) {\n\t\t/* Set linger option to avoid socket hanging out after close. This\n\t\t * prevent ephemeral port exhaust problem under high QPS. */\n\t\tlinger.l_onoff = 1;\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4244)\n#endif\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n\t\t/* Data type of linger structure elements may differ,\n\t\t * so we don't know what cast we need here.\n\t\t * Disable type conversion warnings. */\n\n\t\tlinger.l_linger = (linger_timeout + 999) / 1000;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\t} else {\n\t\tlinger.l_onoff = 0;\n\t\tlinger.l_linger = 0;\n\t}\n\n\tif (linger_timeout < -1) {\n\t\t/* Default: don't configure any linger */\n\t} else if (getsockopt(conn->client.sock,\n\t                      SOL_SOCKET,\n\t                      SO_ERROR,\n#if defined(_WIN32) /* WinSock uses different data type here */\n\t                      (char *)&error_code,\n#else\n\t                      &error_code,\n#endif\n\t                      &opt_len) != 0) {\n\t\t/* Cannot determine if socket is already closed. This should\n\t\t * not occur and never did in a test. Log an error message\n\t\t * and continue. */\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s\",\n\t\t                __func__,\n\t\t                strerror(ERRNO));\n\t} else if (error_code == ECONNRESET) {\n\t\t/* Socket already closed by client/peer, close socket without linger\n\t\t */\n\t} else {\n\n\t\t/* Set linger timeout */\n\t\tif (setsockopt(conn->client.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_LINGER,\n\t\t               (char *)&linger,\n\t\t               sizeof(linger)) != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    conn,\n\t\t\t    \"%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s\",\n\t\t\t    __func__,\n\t\t\t    linger.l_onoff,\n\t\t\t    linger.l_linger,\n\t\t\t    strerror(ERRNO));\n\t\t}\n\t}\n\n\t/* Now we know that our FIN is ACK-ed, safe to close */\n\tclosesocket(conn->client.sock);\n\tconn->client.sock = INVALID_SOCKET;\n}\n\n\nstatic void\nclose_connection(struct mg_connection *conn)\n{\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 6; /* to close */\n#endif\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tif (conn->lua_websocket_state) {\n\t\tlua_websocket_close(conn, conn->lua_websocket_state);\n\t\tconn->lua_websocket_state = NULL;\n\t}\n#endif\n\n\tmg_lock_connection(conn);\n\n\t/* Set close flag, so keep-alive loops will stop */\n\tconn->must_close = 1;\n\n\t/* call the connection_close callback if assigned */\n\tif (conn->phys_ctx->callbacks.connection_close != NULL) {\n\t\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\t\tconn->phys_ctx->callbacks.connection_close(conn);\n\t\t}\n\t}\n\n\t/* Reset user data, after close callback is called.\n\t * Do not reuse it. If the user needs a destructor,\n\t * it must be done in the connection_close callback. */\n\tmg_set_user_connection_data(conn, NULL);\n\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 7; /* closing */\n#endif\n\n#if !defined(NO_SSL)\n\tif (conn->ssl != NULL) {\n\t\t/* Run SSL_shutdown twice to ensure completely close SSL connection\n\t\t */\n\t\tSSL_shutdown(conn->ssl);\n\t\tSSL_free(conn->ssl);\n/* Avoid CRYPTO_cleanup_all_ex_data(); See discussion:\n * https://wiki.openssl.org/index.php/Talk:Library_Initialization */\n#if !defined(OPENSSL_API_1_1)\n\t\tERR_remove_state(0);\n#endif\n\t\tconn->ssl = NULL;\n\t}\n#endif\n\tif (conn->client.sock != INVALID_SOCKET) {\n\t\tclose_socket_gracefully(conn);\n\t\tconn->client.sock = INVALID_SOCKET;\n\t}\n\n\tif (conn->host) {\n\t\tmg_free((void *)conn->host);\n\t\tconn->host = NULL;\n\t}\n\n\tmg_unlock_connection(conn);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 8; /* closed */\n#endif\n}\n\n\nvoid\nmg_close_connection(struct mg_connection *conn)\n{\n#if defined(USE_WEBSOCKET)\n\tstruct mg_context *client_ctx = NULL;\n#endif /* defined(USE_WEBSOCKET) */\n\n\tif ((conn == NULL) || (conn->phys_ctx == NULL)) {\n\t\treturn;\n\t}\n\n#if defined(USE_WEBSOCKET)\n\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\tif (conn->in_websocket_handling) {\n\t\t\t/* Set close flag, so the server thread can exit. */\n\t\t\tconn->must_close = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {\n\n\t\tunsigned int i;\n\n\t\t/* ws/wss client */\n\t\tclient_ctx = conn->phys_ctx;\n\n\t\t/* client context: loops must end */\n\t\tclient_ctx->stop_flag = 1;\n\t\tconn->must_close = 1;\n\n\t\t/* We need to get the client thread out of the select/recv call\n\t\t * here. */\n\t\t/* Since we use a sleep quantum of some seconds to check for recv\n\t\t * timeouts, we will just wait a few seconds in mg_join_thread. */\n\n\t\t/* join worker thread */\n\t\tfor (i = 0; i < client_ctx->cfg_worker_threads; i++) {\n\t\t\tif (client_ctx->worker_threadids[i] != 0) {\n\t\t\t\tmg_join_thread(client_ctx->worker_threadids[i]);\n\t\t\t}\n\t\t}\n\t}\n#endif /* defined(USE_WEBSOCKET) */\n\n\tclose_connection(conn);\n\n#if !defined(NO_SSL)\n\tif (conn->client_ssl_ctx != NULL) {\n\t\tSSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);\n\t}\n#endif\n\n#if defined(USE_WEBSOCKET)\n\tif (client_ctx != NULL) {\n\t\t/* free context */\n\t\tmg_free(client_ctx->worker_threadids);\n\t\tmg_free(client_ctx);\n\t\t(void)pthread_mutex_destroy(&conn->mutex);\n\t\tmg_free(conn);\n\t} else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {\n\t\tmg_free(conn);\n\t}\n#else\n\tif (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) { /* Client */\n\t\tmg_free(conn);\n\t}\n#endif /* defined(USE_WEBSOCKET) */\n}\n\n\n/* Only for memory statistics */\nstatic struct mg_context common_client_context;\n\n\nstatic struct mg_connection *\nmg_connect_client_impl(const struct mg_client_options *client_options,\n                       int use_ssl,\n                       char *ebuf,\n                       size_t ebuf_len)\n{\n\tstruct mg_connection *conn = NULL;\n\tSOCKET sock;\n\tunion usa sa;\n\tstruct sockaddr *psa;\n\tsocklen_t len;\n\n\tunsigned max_req_size =\n\t    (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);\n\n\t/* Size of structures, aligned to 8 bytes */\n\tsize_t conn_size = ((sizeof(struct mg_connection) + 7) >> 3) << 3;\n\tsize_t ctx_size = ((sizeof(struct mg_context) + 7) >> 3) << 3;\n\n\tconn = (struct mg_connection *)mg_calloc_ctx(1,\n\t                                             conn_size + ctx_size\n\t                                                 + max_req_size,\n\t                                             &common_client_context);\n\n\tif (conn == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"calloc(): %s\",\n\t\t            strerror(ERRNO));\n\t\treturn NULL;\n\t}\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\t/* conn_size is aligned to 8 bytes */\n\n\tconn->phys_ctx = (struct mg_context *)(((char *)conn) + conn_size);\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\tconn->buf = (((char *)conn) + conn_size + ctx_size);\n\tconn->buf_size = (int)max_req_size;\n\tconn->phys_ctx->context_type = CONTEXT_HTTP_CLIENT;\n\tconn->dom_ctx = &(conn->phys_ctx->dd);\n\n\tif (!connect_socket(&common_client_context,\n\t                    client_options->host,\n\t                    client_options->port,\n\t                    use_ssl,\n\t                    ebuf,\n\t                    ebuf_len,\n\t                    &sock,\n\t                    &sa)) {\n\t\t/* ebuf is set by connect_socket,\n\t\t * free all memory and return NULL; */\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n#if !defined(NO_SSL)\n#if defined(OPENSSL_API_1_1)\n\tif (use_ssl\n\t    && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method())) == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"SSL_CTX_new error\");\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n#else\n\tif (use_ssl\n\t    && (conn->client_ssl_ctx = SSL_CTX_new(SSLv23_client_method()))\n\t           == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"SSL_CTX_new error\");\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n#endif /* OPENSSL_API_1_1 */\n#endif /* NO_SSL */\n\n\n#if defined(USE_IPV6)\n\tlen = (sa.sa.sa_family == AF_INET) ? sizeof(conn->client.rsa.sin)\n\t                                   : sizeof(conn->client.rsa.sin6);\n\tpsa = (sa.sa.sa_family == AF_INET)\n\t          ? (struct sockaddr *)&(conn->client.rsa.sin)\n\t          : (struct sockaddr *)&(conn->client.rsa.sin6);\n#else\n\tlen = sizeof(conn->client.rsa.sin);\n\tpsa = (struct sockaddr *)&(conn->client.rsa.sin);\n#endif\n\n\tconn->client.sock = sock;\n\tconn->client.lsa = sa;\n\n\tif (getsockname(sock, psa, &len) != 0) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: getsockname() failed: %s\",\n\t\t                __func__,\n\t\t                strerror(ERRNO));\n\t}\n\n\tconn->client.is_ssl = use_ssl ? 1 : 0;\n\tif (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"Can not create mutex\");\n#if !defined(NO_SSL)\n\t\tSSL_CTX_free(conn->client_ssl_ctx);\n#endif\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\n#if !defined(NO_SSL)\n\tif (use_ssl) {\n\t\tcommon_client_context.dd.ssl_ctx = conn->client_ssl_ctx;\n\n\t\t/* TODO: Check ssl_verify_peer and ssl_ca_path here.\n\t\t * SSL_CTX_set_verify call is needed to switch off server\n\t\t * certificate checking, which is off by default in OpenSSL and\n\t\t * on in yaSSL. */\n\t\t/* TODO: SSL_CTX_set_verify(conn->client_ssl_ctx,\n\t\t * SSL_VERIFY_PEER, verify_ssl_server); */\n\n\t\tif (client_options->client_cert) {\n\t\t\tif (!ssl_use_pem_file(&common_client_context,\n\t\t\t                      &(common_client_context.dd),\n\t\t\t                      client_options->client_cert,\n\t\t\t                      NULL)) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"Can not use SSL client certificate\");\n\t\t\t\tSSL_CTX_free(conn->client_ssl_ctx);\n\t\t\t\tclosesocket(sock);\n\t\t\t\tmg_free(conn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (client_options->server_cert) {\n\t\t\tSSL_CTX_load_verify_locations(conn->client_ssl_ctx,\n\t\t\t                              client_options->server_cert,\n\t\t\t                              NULL);\n\t\t\tSSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);\n\t\t}\n\n\t\tif (!sslize(conn,\n\t\t            conn->client_ssl_ctx,\n\t\t            SSL_connect,\n\t\t            &(conn->phys_ctx->stop_flag))) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"SSL connection error\");\n\t\t\tSSL_CTX_free(conn->client_ssl_ctx);\n\t\t\tclosesocket(sock);\n\t\t\tmg_free(conn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\tif (0 != set_non_blocking_mode(sock)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"Cannot set non-blocking mode for client %s:%i\",\n\t\t                client_options->host,\n\t\t                client_options->port);\n\t}\n\n\treturn conn;\n}\n\n\nCIVETWEB_API struct mg_connection *\nmg_connect_client_secure(const struct mg_client_options *client_options,\n                         char *error_buffer,\n                         size_t error_buffer_size)\n{\n\treturn mg_connect_client_impl(client_options,\n\t                              1,\n\t                              error_buffer,\n\t                              error_buffer_size);\n}\n\n\nstruct mg_connection *\nmg_connect_client(const char *host,\n                  int port,\n                  int use_ssl,\n                  char *error_buffer,\n                  size_t error_buffer_size)\n{\n\tstruct mg_client_options opts;\n\tmemset(&opts, 0, sizeof(opts));\n\topts.host = host;\n\topts.port = port;\n\treturn mg_connect_client_impl(&opts,\n\t                              use_ssl,\n\t                              error_buffer,\n\t                              error_buffer_size);\n}\n\n\nstatic const struct {\n\tconst char *proto;\n\tsize_t proto_len;\n\tunsigned default_port;\n} abs_uri_protocols[] = {{\"http://\", 7, 80},\n                         {\"https://\", 8, 443},\n                         {\"ws://\", 5, 80},\n                         {\"wss://\", 6, 443},\n                         {NULL, 0, 0}};\n\n\n/* Check if the uri is valid.\n * return 0 for invalid uri,\n * return 1 for *,\n * return 2 for relative uri,\n * return 3 for absolute uri without port,\n * return 4 for absolute uri with port */\nstatic int\nget_uri_type(const char *uri)\n{\n\tint i;\n\tconst char *hostend, *portbegin;\n\tchar *portend;\n\tunsigned long port;\n\n\t/* According to the HTTP standard\n\t * http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2\n\t * URI can be an asterisk (*) or should start with slash (relative uri),\n\t * or it should start with the protocol (absolute uri). */\n\tif ((uri[0] == '*') && (uri[1] == '\\0')) {\n\t\t/* asterisk */\n\t\treturn 1;\n\t}\n\n\t/* Valid URIs according to RFC 3986\n\t * (https://www.ietf.org/rfc/rfc3986.txt)\n\t * must only contain reserved characters :/?#[]@!$&'()*+,;=\n\t * and unreserved characters A-Z a-z 0-9 and -._~\n\t * and % encoded symbols.\n\t */\n\tfor (i = 0; uri[i] != 0; i++) {\n\t\tif (uri[i] < 33) {\n\t\t\t/* control characters and spaces are invalid */\n\t\t\treturn 0;\n\t\t}\n\t\tif (uri[i] > 126) {\n\t\t\t/* non-ascii characters must be % encoded */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tswitch (uri[i]) {\n\t\t\tcase '\"':  /* 34 */\n\t\t\tcase '<':  /* 60 */\n\t\t\tcase '>':  /* 62 */\n\t\t\tcase '\\\\': /* 92 */\n\t\t\tcase '^':  /* 94 */\n\t\t\tcase '`':  /* 96 */\n\t\t\tcase '{':  /* 123 */\n\t\t\tcase '|':  /* 124 */\n\t\t\tcase '}':  /* 125 */\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\t/* character is ok */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* A relative uri starts with a / character */\n\tif (uri[0] == '/') {\n\t\t/* relative uri */\n\t\treturn 2;\n\t}\n\n\t/* It could be an absolute uri: */\n\t/* This function only checks if the uri is valid, not if it is\n\t * addressing the current server. So civetweb can also be used\n\t * as a proxy server. */\n\tfor (i = 0; abs_uri_protocols[i].proto != NULL; i++) {\n\t\tif (mg_strncasecmp(uri,\n\t\t                   abs_uri_protocols[i].proto,\n\t\t                   abs_uri_protocols[i].proto_len) == 0) {\n\n\t\t\thostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');\n\t\t\tif (!hostend) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tportbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');\n\t\t\tif (!portbegin) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tport = strtoul(portbegin + 1, &portend, 10);\n\t\t\tif ((portend != hostend) || (port <= 0) || !is_valid_port(port)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n/* Return NULL or the relative uri at the current server */\nstatic const char *\nget_rel_url_at_current_server(const char *uri, const struct mg_connection *conn)\n{\n\tconst char *server_domain;\n\tsize_t server_domain_len;\n\tsize_t request_domain_len = 0;\n\tunsigned long port = 0;\n\tint i, auth_domain_check_enabled;\n\tconst char *hostbegin = NULL;\n\tconst char *hostend = NULL;\n\tconst char *portbegin;\n\tchar *portend;\n\n\tauth_domain_check_enabled =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\");\n\n\t/* DNS is case insensitive, so use case insensitive string compare here\n\t */\n\tfor (i = 0; abs_uri_protocols[i].proto != NULL; i++) {\n\t\tif (mg_strncasecmp(uri,\n\t\t                   abs_uri_protocols[i].proto,\n\t\t                   abs_uri_protocols[i].proto_len) == 0) {\n\n\t\t\thostbegin = uri + abs_uri_protocols[i].proto_len;\n\t\t\thostend = strchr(hostbegin, '/');\n\t\t\tif (!hostend) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tportbegin = strchr(hostbegin, ':');\n\t\t\tif ((!portbegin) || (portbegin > hostend)) {\n\t\t\t\tport = abs_uri_protocols[i].default_port;\n\t\t\t\trequest_domain_len = (size_t)(hostend - hostbegin);\n\t\t\t} else {\n\t\t\t\tport = strtoul(portbegin + 1, &portend, 10);\n\t\t\t\tif ((portend != hostend) || (port <= 0)\n\t\t\t\t    || !is_valid_port(port)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\trequest_domain_len = (size_t)(portbegin - hostbegin);\n\t\t\t}\n\t\t\t/* protocol found, port set */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!port) {\n\t\t/* port remains 0 if the protocol is not found */\n\t\treturn 0;\n\t}\n\n/* Check if the request is directed to a different server. */\n/* First check if the port is the same (IPv4 and IPv6). */\n#if defined(USE_IPV6)\n\tif (conn->client.lsa.sa.sa_family == AF_INET6) {\n\t\tif (ntohs(conn->client.lsa.sin6.sin6_port) != port) {\n\t\t\t/* Request is directed to a different port */\n\t\t\treturn 0;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tif (ntohs(conn->client.lsa.sin.sin_port) != port) {\n\t\t\t/* Request is directed to a different port */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Finally check if the server corresponds to the authentication\n\t * domain of the server (the server domain).\n\t * Allow full matches (like http://mydomain.com/path/file.ext), and\n\t * allow subdomain matches (like http://www.mydomain.com/path/file.ext),\n\t * but do not allow substrings (like\n\t * http://notmydomain.com/path/file.ext\n\t * or http://mydomain.com.fake/path/file.ext).\n\t */\n\tif (auth_domain_check_enabled) {\n\t\tserver_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t\tserver_domain_len = strlen(server_domain);\n\t\tif ((server_domain_len == 0) || (hostbegin == NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((request_domain_len == server_domain_len)\n\t\t    && (!memcmp(server_domain, hostbegin, server_domain_len))) {\n\t\t\t/* Request is directed to this server - full name match. */\n\t\t} else {\n\t\t\tif (request_domain_len < (server_domain_len + 2)) {\n\t\t\t\t/* Request is directed to another server: The server name\n\t\t\t\t * is longer than the request name.\n\t\t\t\t * Drop this case here to avoid overflows in the\n\t\t\t\t * following checks. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (hostbegin[request_domain_len - server_domain_len - 1] != '.') {\n\t\t\t\t/* Request is directed to another server: It could be a\n\t\t\t\t * substring\n\t\t\t\t * like notmyserver.com */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (0 != memcmp(server_domain,\n\t\t\t                hostbegin + request_domain_len - server_domain_len,\n\t\t\t                server_domain_len)) {\n\t\t\t\t/* Request is directed to another server:\n\t\t\t\t * The server name is different. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hostend;\n}\n\n\nstatic int\nget_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\t*err = 0;\n\n\treset_per_request_attributes(conn);\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Internal error\");\n\t\t*err = 500;\n\t\treturn 0;\n\t}\n\t/* Set the time the request was received. This value should be used for\n\t * timeouts. */\n\tclock_gettime(CLOCK_MONOTONIC, &(conn->req_time));\n\n\tconn->request_len =\n\t    read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);\n\tDEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);\n\tif ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Invalid message size\");\n\t\t*err = 500;\n\t\treturn 0;\n\t}\n\n\tif ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Message too large\");\n\t\t*err = 413;\n\t\treturn 0;\n\t}\n\n\tif (conn->request_len <= 0) {\n\t\tif (conn->data_len > 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Malformed message\");\n\t\t\t*err = 400;\n\t\t} else {\n\t\t\t/* Server did not recv anything -> just close the connection */\n\t\t\tconn->must_close = 1;\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"No data received\");\n\t\t\t*err = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic int\nget_request(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tconst char *cl;\n\tif (!get_message(conn, ebuf, ebuf_len, err)) {\n\t\treturn 0;\n\t}\n\n\tif (parse_http_request(conn->buf, conn->buf_size, &conn->request_info)\n\t    <= 0) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad request\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Message is a valid request */\n\n\t/* Is there a \"host\" ? */\n\tconn->host = alloc_get_host(conn);\n\tif (!conn->host) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad request: Host mismatch\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Do we know the content length? */\n\tif ((cl = get_header(conn->request_info.http_headers,\n\t                     conn->request_info.num_headers,\n\t                     \"Content-Length\")) != NULL) {\n\t\t/* Request/response has content length set */\n\t\tchar *endptr = NULL;\n\t\tconn->content_len = strtoll(cl, &endptr, 10);\n\t\tif (endptr == cl) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Publish the content length back to the request info. */\n\t\tconn->request_info.content_length = conn->content_len;\n\t} else if ((cl = get_header(conn->request_info.http_headers,\n\t                            conn->request_info.num_headers,\n\t                            \"Transfer-Encoding\")) != NULL\n\t           && !mg_strcasecmp(cl, \"chunked\")) {\n\t\tconn->is_chunked = 1;\n\t\tconn->content_len = -1; /* unknown content length */\n\t} else {\n\t\tconst struct mg_http_method_info *meth =\n\t\t    get_http_method_info(conn->request_info.request_method);\n\t\tif (!meth) {\n\t\t\t/* No valid HTTP method */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\tif (meth->request_has_body) {\n\t\t\t/* POST or PUT request without content length set */\n\t\t\tconn->content_len = -1; /* unknown content length */\n\t\t} else {\n\t\t\t/* Other request */\n\t\t\tconn->content_len = 0; /* No content */\n\t\t}\n\t}\n\n\tconn->connection_type = CONNECTION_TYPE_REQUEST; /* Valid request */\n\treturn 1;\n}\n\n\n/* conn is assumed to be valid in this internal function */\nstatic int\nget_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tconst char *cl;\n\tif (!get_message(conn, ebuf, ebuf_len, err)) {\n\t\treturn 0;\n\t}\n\n\tif (parse_http_response(conn->buf, conn->buf_size, &conn->response_info)\n\t    <= 0) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad response\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Message is a valid response */\n\n\t/* Do we know the content length? */\n\tif ((cl = get_header(conn->response_info.http_headers,\n\t                     conn->response_info.num_headers,\n\t                     \"Content-Length\")) != NULL) {\n\t\t/* Request/response has content length set */\n\t\tchar *endptr = NULL;\n\t\tconn->content_len = strtoll(cl, &endptr, 10);\n\t\tif (endptr == cl) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Publish the content length back to the response info. */\n\t\tconn->response_info.content_length = conn->content_len;\n\n\t\t/* TODO: check if it is still used in response_info */\n\t\tconn->request_info.content_length = conn->content_len;\n\n\t} else if ((cl = get_header(conn->response_info.http_headers,\n\t                            conn->response_info.num_headers,\n\t                            \"Transfer-Encoding\")) != NULL\n\t           && !mg_strcasecmp(cl, \"chunked\")) {\n\t\tconn->is_chunked = 1;\n\t\tconn->content_len = -1; /* unknown content length */\n\t} else {\n\t\tconn->content_len = -1; /* unknown content length */\n\t}\n\n\tconn->connection_type = CONNECTION_TYPE_RESPONSE; /* Valid response */\n\treturn 1;\n}\n\n\nint\nmg_get_response(struct mg_connection *conn,\n                char *ebuf,\n                size_t ebuf_len,\n                int timeout)\n{\n\tint err, ret;\n\tchar txt[32]; /* will not overflow */\n\tchar *save_timeout;\n\tchar *new_timeout;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Parameter error\");\n\t\treturn -1;\n\t}\n\n\t/* Implementation of API function for HTTP clients */\n\tsave_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];\n\n\tif (timeout >= 0) {\n\t\tmg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);\n\t\tnew_timeout = txt;\n\t\t/* Not required for non-blocking sockets.\n\t\tset_sock_timeout(conn->client.sock, timeout);\n\t\t*/\n\t} else {\n\t\tnew_timeout = NULL;\n\t}\n\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;\n\tret = get_response(conn, ebuf, ebuf_len, &err);\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;\n\n#if defined(MG_LEGACY_INTERFACE)\n\t/* TODO: 1) uri is deprecated;\n\t *       2) here, ri.uri is the http response code */\n\tconn->request_info.uri = conn->request_info.request_uri;\n#endif\n\tconn->request_info.local_uri = conn->request_info.request_uri;\n\n\t/* TODO (mid): Define proper return values - maybe return length?\n\t * For the first test use <0 for error and >0 for OK */\n\treturn (ret == 0) ? -1 : +1;\n}\n\n\nstruct mg_connection *\nmg_download(const char *host,\n            int port,\n            int use_ssl,\n            char *ebuf,\n            size_t ebuf_len,\n            const char *fmt,\n            ...)\n{\n\tstruct mg_connection *conn;\n\tva_list ap;\n\tint i;\n\tint reqerr;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tva_start(ap, fmt);\n\n\t/* open a connection */\n\tconn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);\n\n\tif (conn != NULL) {\n\t\ti = mg_vprintf(conn, fmt, ap);\n\t\tif (i <= 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Error sending request\");\n\t\t} else {\n\t\t\tget_response(conn, ebuf, ebuf_len, &reqerr);\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\t/* TODO: 1) uri is deprecated;\n\t\t\t *       2) here, ri.uri is the http response code */\n\t\t\tconn->request_info.uri = conn->request_info.request_uri;\n#endif\n\t\t\tconn->request_info.local_uri = conn->request_info.request_uri;\n\t\t}\n\t}\n\n\t/* if an error occurred, close the connection */\n\tif ((ebuf[0] != '\\0') && (conn != NULL)) {\n\t\tmg_close_connection(conn);\n\t\tconn = NULL;\n\t}\n\n\tva_end(ap);\n\treturn conn;\n}\n\n\nstruct websocket_client_thread_data {\n\tstruct mg_connection *conn;\n\tmg_websocket_data_handler data_handler;\n\tmg_websocket_close_handler close_handler;\n\tvoid *callback_data;\n};\n\n\n#if defined(USE_WEBSOCKET)\n#if defined(_WIN32)\nstatic unsigned __stdcall websocket_client_thread(void *data)\n#else\nstatic void *\nwebsocket_client_thread(void *data)\n#endif\n{\n\tstruct websocket_client_thread_data *cdata =\n\t    (struct websocket_client_thread_data *)data;\n\n#if !defined(_WIN32)\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n#endif\n\n\tmg_set_thread_name(\"ws-clnt\");\n\n\tif (cdata->conn->phys_ctx) {\n\t\tif (cdata->conn->phys_ctx->callbacks.init_thread) {\n\t\t\t/* 3 indicates a websocket client thread */\n\t\t\t/* TODO: check if conn->phys_ctx can be set */\n\t\t\tcdata->conn->phys_ctx->callbacks.init_thread(cdata->conn->phys_ctx,\n\t\t\t                                             3);\n\t\t}\n\t}\n\n\tread_websocket(cdata->conn, cdata->data_handler, cdata->callback_data);\n\n\tDEBUG_TRACE(\"%s\", \"Websocket client thread exited\\n\");\n\n\tif (cdata->close_handler != NULL) {\n\t\tcdata->close_handler(cdata->conn, cdata->callback_data);\n\t}\n\n\t/* The websocket_client context has only this thread. If it runs out,\n\t   set the stop_flag to 2 (= \"stopped\"). */\n\tcdata->conn->phys_ctx->stop_flag = 2;\n\n\tmg_free((void *)cdata);\n\n#if defined(_WIN32)\n\treturn 0;\n#else\n\treturn NULL;\n#endif\n}\n#endif\n\n\nstruct mg_connection *\nmg_connect_websocket_client(const char *host,\n                            int port,\n                            int use_ssl,\n                            char *error_buffer,\n                            size_t error_buffer_size,\n                            const char *path,\n                            const char *origin,\n                            mg_websocket_data_handler data_func,\n                            mg_websocket_close_handler close_func,\n                            void *user_data)\n{\n\tstruct mg_connection *conn = NULL;\n\n#if defined(USE_WEBSOCKET)\n\tstruct mg_context *newctx = NULL;\n\tstruct websocket_client_thread_data *thread_data;\n\tstatic const char *magic = \"x3JJHMbDL1EzLkh9GBhXDw==\";\n\tstatic const char *handshake_req;\n\n\tif (origin != NULL) {\n\t\thandshake_req = \"GET %s HTTP/1.1\\r\\n\"\n\t\t                \"Host: %s\\r\\n\"\n\t\t                \"Upgrade: websocket\\r\\n\"\n\t\t                \"Connection: Upgrade\\r\\n\"\n\t\t                \"Sec-WebSocket-Key: %s\\r\\n\"\n\t\t                \"Sec-WebSocket-Version: 13\\r\\n\"\n\t\t                \"Origin: %s\\r\\n\"\n\t\t                \"\\r\\n\";\n\t} else {\n\t\thandshake_req = \"GET %s HTTP/1.1\\r\\n\"\n\t\t                \"Host: %s\\r\\n\"\n\t\t                \"Upgrade: websocket\\r\\n\"\n\t\t                \"Connection: Upgrade\\r\\n\"\n\t\t                \"Sec-WebSocket-Key: %s\\r\\n\"\n\t\t                \"Sec-WebSocket-Version: 13\\r\\n\"\n\t\t                \"\\r\\n\";\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\t/* Establish the client connection and request upgrade */\n\tconn = mg_download(host,\n\t                   port,\n\t                   use_ssl,\n\t                   error_buffer,\n\t                   error_buffer_size,\n\t                   handshake_req,\n\t                   path,\n\t                   host,\n\t                   magic,\n\t                   origin);\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\t/* Connection object will be null if something goes wrong */\n\tif (conn == NULL) {\n\t\tif (!*error_buffer) {\n\t\t\t/* There should be already an error message */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            error_buffer,\n\t\t\t            error_buffer_size,\n\t\t\t            \"Unexpected error\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (conn->response_info.status_code != 101) {\n\t\t/* We sent an \"upgrade\" request. For a correct websocket\n\t\t * protocol handshake, we expect a \"101 Continue\" response.\n\t\t * Otherwise it is a protocol violation. Maybe the HTTP\n\t\t * Server does not know websockets. */\n\t\tif (!*error_buffer) {\n\t\t\t/* set an error, if not yet set */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            error_buffer,\n\t\t\t            error_buffer_size,\n\t\t\t            \"Unexpected server reply\");\n\t\t}\n\n\t\tDEBUG_TRACE(\"Websocket client connect error: %s\\r\\n\", error_buffer);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\t/* For client connections, mg_context is fake. Since we need to set a\n\t * callback function, we need to create a copy and modify it. */\n\tnewctx = (struct mg_context *)mg_malloc(sizeof(struct mg_context));\n\tif (!newctx) {\n\t\tDEBUG_TRACE(\"%s\\r\\n\", \"Out of memory\");\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(newctx, conn->phys_ctx, sizeof(struct mg_context));\n\tnewctx->user_data = user_data;\n\tnewctx->context_type = CONTEXT_WS_CLIENT; /* ws/wss client context */\n\tnewctx->cfg_worker_threads = 1; /* one worker thread will be created */\n\tnewctx->worker_threadids =\n\t    (pthread_t *)mg_calloc_ctx(newctx->cfg_worker_threads,\n\t                               sizeof(pthread_t),\n\t                               newctx);\n\n\tconn->phys_ctx = newctx;\n\tconn->dom_ctx = &(newctx->dd);\n\n\tthread_data = (struct websocket_client_thread_data *)\n\t    mg_calloc_ctx(sizeof(struct websocket_client_thread_data), 1, newctx);\n\tif (!thread_data) {\n\t\tDEBUG_TRACE(\"%s\\r\\n\", \"Out of memory\");\n\t\tmg_free(newctx);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\tthread_data->conn = conn;\n\tthread_data->data_handler = data_func;\n\tthread_data->close_handler = close_func;\n\tthread_data->callback_data = user_data;\n\n\t/* Start a thread to read the websocket client connection\n\t * This thread will automatically stop when mg_disconnect is\n\t * called on the client connection */\n\tif (mg_start_thread_with_id(websocket_client_thread,\n\t                            (void *)thread_data,\n\t                            newctx->worker_threadids) != 0) {\n\t\tmg_free((void *)thread_data);\n\t\tmg_free((void *)newctx->worker_threadids);\n\t\tmg_free((void *)newctx);\n\t\tmg_free((void *)conn);\n\t\tconn = NULL;\n\t\tDEBUG_TRACE(\"%s\",\n\t\t            \"Websocket client connect thread could not be started\\r\\n\");\n\t}\n\n#else\n\t/* Appease \"unused parameter\" warnings */\n\t(void)host;\n\t(void)port;\n\t(void)use_ssl;\n\t(void)error_buffer;\n\t(void)error_buffer_size;\n\t(void)path;\n\t(void)origin;\n\t(void)user_data;\n\t(void)data_func;\n\t(void)close_func;\n#endif\n\n\treturn conn;\n}\n\n\n/* Prepare connection data structure */\nstatic void\ninit_connection(struct mg_connection *conn)\n{\n\t/* Is keep alive allowed by the server */\n\tint keep_alive_enabled =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], \"yes\");\n\n\tif (!keep_alive_enabled) {\n\t\tconn->must_close = 1;\n\t}\n\n\t/* Important: on new connection, reset the receiving buffer. Credit\n\t * goes to crule42. */\n\tconn->data_len = 0;\n\tconn->handled_requests = 0;\n\tmg_set_user_connection_data(conn, NULL);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 2; /* init */\n#endif\n\n\t/* call the init_connection callback if assigned */\n\tif (conn->phys_ctx->callbacks.init_connection != NULL) {\n\t\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\t\tvoid *conn_data = NULL;\n\t\t\tconn->phys_ctx->callbacks.init_connection(conn, &conn_data);\n\t\t\tmg_set_user_connection_data(conn, conn_data);\n\t\t}\n\t}\n}\n\n\n/* Process a connection - may handle multiple requests\n * using the same connection.\n * Must be called with a valid connection (conn  and\n * conn->phys_ctx must be valid).\n */\nstatic void\nprocess_new_connection(struct mg_connection *conn)\n{\n\tstruct mg_request_info *ri = &conn->request_info;\n\tint keep_alive, discard_len;\n\tchar ebuf[100];\n\tconst char *hostend;\n\tint reqerr, uri_type;\n\n#if defined(USE_SERVER_STATS)\n\tint mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));\n\tmg_atomic_add(&(conn->phys_ctx->total_connections), 1);\n\tif (mcon > (conn->phys_ctx->max_connections)) {\n\t\t/* could use atomic compare exchange, but this\n\t\t * seems overkill for statistics data */\n\t\tconn->phys_ctx->max_connections = mcon;\n\t}\n#endif\n\n\tinit_connection(conn);\n\n\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t            conn->request_info.remote_addr);\n\n\t/* Loop over multiple requests sent using the same connection\n\t * (while \"keep alive\"). */\n\tdo {\n\n\t\tDEBUG_TRACE(\"calling get_request (%i times for this connection)\",\n\t\t            conn->handled_requests + 1);\n\n#if defined(USE_SERVER_STATS)\n\t\tconn->conn_state = 3; /* ready */\n#endif\n\n\t\tif (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {\n\t\t\t/* The request sent by the client could not be understood by\n\t\t\t * the server, or it was incomplete or a timeout. Send an\n\t\t\t * error message and close the connection. */\n\t\t\tif (reqerr > 0) {\n\t\t\t\tDEBUG_ASSERT(ebuf[0] != '\\0');\n\t\t\t\tmg_send_http_error(conn, reqerr, \"%s\", ebuf);\n\t\t\t}\n\t\t} else if (strcmp(ri->http_version, \"1.0\")\n\t\t           && strcmp(ri->http_version, \"1.1\")) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            sizeof(ebuf),\n\t\t\t            \"Bad HTTP version: [%s]\",\n\t\t\t            ri->http_version);\n\t\t\tmg_send_http_error(conn, 505, \"%s\", ebuf);\n\t\t}\n\n\t\tif (ebuf[0] == '\\0') {\n\t\t\turi_type = get_uri_type(conn->request_info.request_uri);\n\t\t\tswitch (uri_type) {\n\t\t\tcase 1:\n\t\t\t\t/* Asterisk */\n\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t/* relative uri */\n\t\t\t\tconn->request_info.local_uri = conn->request_info.request_uri;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\t/* absolute uri (with/without port) */\n\t\t\t\thostend = get_rel_url_at_current_server(\n\t\t\t\t    conn->request_info.request_uri, conn);\n\t\t\t\tif (hostend) {\n\t\t\t\t\tconn->request_info.local_uri = hostend;\n\t\t\t\t} else {\n\t\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmg_snprintf(conn,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            sizeof(ebuf),\n\t\t\t\t            \"Invalid URI\");\n\t\t\t\tmg_send_http_error(conn, 400, \"%s\", ebuf);\n\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\t/* Legacy before split into local_uri and request_uri */\n\t\t\tconn->request_info.uri = conn->request_info.local_uri;\n#endif\n\t\t}\n\n\t\tDEBUG_TRACE(\"http: %s, error: %s\",\n\t\t            (ri->http_version ? ri->http_version : \"none\"),\n\t\t            (ebuf[0] ? ebuf : \"none\"));\n\n\t\tif (ebuf[0] == '\\0') {\n\t\t\tif (conn->request_info.local_uri) {\n\n/* handle request to local server */\n#if defined(USE_SERVER_STATS)\n\t\t\t\tconn->conn_state = 4; /* processing */\n#endif\n\t\t\t\thandle_request(conn);\n\n#if defined(USE_SERVER_STATS)\n\t\t\t\tconn->conn_state = 5; /* processed */\n\n\t\t\t\tmg_atomic_add(&(conn->phys_ctx->total_data_read),\n\t\t\t\t              conn->consumed_content);\n\t\t\t\tmg_atomic_add(&(conn->phys_ctx->total_data_written),\n\t\t\t\t              conn->num_bytes_sent);\n#endif\n\n\t\t\t\tDEBUG_TRACE(\"%s\", \"handle_request done\");\n\n\t\t\t\tif (conn->phys_ctx->callbacks.end_request != NULL) {\n\t\t\t\t\tconn->phys_ctx->callbacks.end_request(conn,\n\t\t\t\t\t                                      conn->status_code);\n\t\t\t\t\tDEBUG_TRACE(\"%s\", \"end_request callback done\");\n\t\t\t\t}\n\t\t\t\tlog_access(conn);\n\t\t\t} else {\n\t\t\t\t/* TODO: handle non-local request (PROXY) */\n\t\t\t\tconn->must_close = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tconn->must_close = 1;\n\t\t}\n\n\t\tif (ri->remote_user != NULL) {\n\t\t\tmg_free((void *)ri->remote_user);\n\t\t\t/* Important! When having connections with and without auth\n\t\t\t * would cause double free and then crash */\n\t\t\tri->remote_user = NULL;\n\t\t}\n\n\t\t/* NOTE(lsm): order is important here. should_keep_alive() call\n\t\t * is using parsed request, which will be invalid after\n\t\t * memmove's below.\n\t\t * Therefore, memorize should_keep_alive() result now for later\n\t\t * use in loop exit condition. */\n\t\tkeep_alive = (conn->phys_ctx->stop_flag == 0) && should_keep_alive(conn)\n\t\t             && (conn->content_len >= 0);\n\n\n\t\t/* Discard all buffered data for this request */\n\t\tdiscard_len = ((conn->content_len >= 0) && (conn->request_len > 0)\n\t\t               && ((conn->request_len + conn->content_len)\n\t\t                   < (int64_t)conn->data_len))\n\t\t                  ? (int)(conn->request_len + conn->content_len)\n\t\t                  : conn->data_len;\n\t\tDEBUG_ASSERT(discard_len >= 0);\n\t\tif (discard_len < 0) {\n\t\t\tDEBUG_TRACE(\"internal error: discard_len = %li\",\n\t\t\t            (long int)discard_len);\n\t\t\tbreak;\n\t\t}\n\t\tconn->data_len -= discard_len;\n\t\tif (conn->data_len > 0) {\n\t\t\tDEBUG_TRACE(\"discard_len = %lu\", (long unsigned)discard_len);\n\t\t\tmemmove(conn->buf, conn->buf + discard_len, (size_t)conn->data_len);\n\t\t}\n\n\t\tDEBUG_ASSERT(conn->data_len >= 0);\n\t\tDEBUG_ASSERT(conn->data_len <= conn->buf_size);\n\n\t\tif ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {\n\t\t\tDEBUG_TRACE(\"internal error: data_len = %li, buf_size = %li\",\n\t\t\t            (long int)conn->data_len,\n\t\t\t            (long int)conn->buf_size);\n\t\t\tbreak;\n\t\t}\n\n\t\tconn->handled_requests++;\n\n\t} while (keep_alive);\n\n\tDEBUG_TRACE(\"Done processing connection from %s (%f sec)\",\n\t            conn->request_info.remote_addr,\n\t            difftime(time(NULL), conn->conn_birth_time));\n\n\tclose_connection(conn);\n\n#if defined(USE_SERVER_STATS)\n\tmg_atomic_add(&(conn->phys_ctx->total_requests), conn->handled_requests);\n\tmg_atomic_dec(&(conn->phys_ctx->active_connections));\n#endif\n}\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\nstatic void\nproduce_socket(struct mg_context *ctx, const struct socket *sp)\n{\n\tunsigned int i;\n\n\twhile (!ctx->stop_flag) {\n\t\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\t\t/* find a free worker slot and signal it */\n\t\t\tif (ctx->client_socks[i].in_use == 0) {\n\t\t\t\tctx->client_socks[i] = *sp;\n\t\t\t\tctx->client_socks[i].in_use = 1;\n\t\t\t\tevent_signal(ctx->client_wait_events[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* queue is full */\n\t\tmg_sleep(1);\n\t}\n}\n\n\nstatic int\nconsume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)\n{\n\tDEBUG_TRACE(\"%s\", \"going idle\");\n\tctx->client_socks[thread_index].in_use = 0;\n\tevent_wait(ctx->client_wait_events[thread_index]);\n\t*sp = ctx->client_socks[thread_index];\n\tDEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);\n\n\treturn !ctx->stop_flag;\n}\n\n#else /* ALTERNATIVE_QUEUE */\n\n/* Worker threads take accepted socket from the queue */\nstatic int\nconsume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)\n{\n#define QUEUE_SIZE(ctx) ((int)(ARRAY_SIZE(ctx->queue)))\n\n\t(void)thread_index;\n\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n\tDEBUG_TRACE(\"%s\", \"going idle\");\n\n\t/* If the queue is empty, wait. We're idle at this point. */\n\twhile ((ctx->sq_head == ctx->sq_tail) && (ctx->stop_flag == 0)) {\n\t\tpthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);\n\t}\n\n\t/* If we're stopping, sq_head may be equal to sq_tail. */\n\tif (ctx->sq_head > ctx->sq_tail) {\n\t\t/* Copy socket from the queue and increment tail */\n\t\t*sp = ctx->queue[ctx->sq_tail % QUEUE_SIZE(ctx)];\n\t\tctx->sq_tail++;\n\n\t\tDEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);\n\n\t\t/* Wrap pointers if needed */\n\t\twhile (ctx->sq_tail > QUEUE_SIZE(ctx)) {\n\t\t\tctx->sq_tail -= QUEUE_SIZE(ctx);\n\t\t\tctx->sq_head -= QUEUE_SIZE(ctx);\n\t\t}\n\t}\n\n\t(void)pthread_cond_signal(&ctx->sq_empty);\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n\n\treturn !ctx->stop_flag;\n#undef QUEUE_SIZE\n}\n\n\n/* Master thread adds accepted socket to a queue */\nstatic void\nproduce_socket(struct mg_context *ctx, const struct socket *sp)\n{\n#define QUEUE_SIZE(ctx) ((int)(ARRAY_SIZE(ctx->queue)))\n\tif (!ctx) {\n\t\treturn;\n\t}\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n\n\t/* If the queue is full, wait */\n\twhile ((ctx->stop_flag == 0)\n\t       && (ctx->sq_head - ctx->sq_tail >= QUEUE_SIZE(ctx))) {\n\t\t(void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);\n\t}\n\n\tif (ctx->sq_head - ctx->sq_tail < QUEUE_SIZE(ctx)) {\n\t\t/* Copy socket to the queue and increment head */\n\t\tctx->queue[ctx->sq_head % QUEUE_SIZE(ctx)] = *sp;\n\t\tctx->sq_head++;\n\t\tDEBUG_TRACE(\"queued socket %d\", sp ? sp->sock : -1);\n\t}\n\n\t(void)pthread_cond_signal(&ctx->sq_full);\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n#undef QUEUE_SIZE\n}\n#endif /* ALTERNATIVE_QUEUE */\n\n\nstruct worker_thread_args {\n\tstruct mg_context *ctx;\n\tint index;\n};\n\n\nstatic void *\nworker_thread_run(struct worker_thread_args *thread_args)\n{\n\tstruct mg_context *ctx = thread_args->ctx;\n\tstruct mg_connection *conn;\n\tstruct mg_workerTLS tls;\n#if defined(MG_LEGACY_INTERFACE)\n\tuint32_t addr;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\ttls.is_master = 0;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* Initialize thread local storage before calling any callback */\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* call init_thread for a worker thread (type 1) */\n\t\tctx->callbacks.init_thread(ctx, 1);\n\t}\n\n\t/* Connection structure has been pre-allocated */\n\tif (((int)thread_args->index < 0)\n\t    || ((unsigned)thread_args->index\n\t        >= (unsigned)ctx->cfg_worker_threads)) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"Internal error: Invalid worker index %i\",\n\t\t                (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn = ctx->worker_connections + thread_args->index;\n\n\t/* Request buffers are not pre-allocated. They are private to the\n\t * request and do not contain any state information that might be\n\t * of interest to anyone observing a server status.  */\n\tconn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);\n\tif (conn->buf == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t                (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn->buf_size = (int)ctx->max_request_size;\n\n\tconn->phys_ctx = ctx;\n\tconn->dom_ctx = &(ctx->dd); /* Use default domain and default host */\n\tconn->host = NULL;          /* until we have more information. */\n\n\tconn->thread_index = thread_args->index;\n\tconn->request_info.user_data = ctx->user_data;\n\t/* Allocate a mutex for this connection to allow communication both\n\t * within the request handler and from elsewhere in the application\n\t */\n\tif (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {\n\t\tmg_free(conn->buf);\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Cannot create mutex\");\n\t\treturn NULL;\n\t}\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 1; /* not consumed */\n#endif\n\n#if defined(ALTERNATIVE_QUEUE)\n\twhile ((ctx->stop_flag == 0)\n\t       && consume_socket(ctx, &conn->client, conn->thread_index)) {\n#else\n\t/* Call consume_socket() even when ctx->stop_flag > 0, to let it\n\t * signal sq_empty condvar to wake up the master waiting in\n\t * produce_socket() */\n\twhile (consume_socket(ctx, &conn->client, conn->thread_index)) {\n#endif\n\n\t\tconn->conn_birth_time = time(NULL);\n\n/* Fill in IP, port info early so even if SSL setup below fails,\n * error handler would have the corresponding info.\n * Thanks to Johannes Winkelmann for the patch.\n */\n#if defined(USE_IPV6)\n\t\tif (conn->client.rsa.sa.sa_family == AF_INET6) {\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(conn->request_info.remote_addr,\n\t\t                   sizeof(conn->request_info.remote_addr),\n\t\t                   &conn->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            conn->request_info.remote_addr);\n\n\t\tconn->request_info.is_ssl = conn->client.is_ssl;\n\n\t\tif (conn->client.is_ssl) {\n#if !defined(NO_SSL)\n\t\t\t/* HTTPS connection */\n\t\t\tif (sslize(conn,\n\t\t\t           conn->dom_ctx->ssl_ctx,\n\t\t\t           SSL_accept,\n\t\t\t           &(conn->phys_ctx->stop_flag))) {\n\t\t\t\t/* conn->dom_ctx is set in get_request */\n\n\t\t\t\t/* Get SSL client certificate information (if set) */\n\t\t\t\tssl_get_client_cert_info(conn);\n\n\t\t\t\t/* process HTTPS connection */\n\t\t\t\tprocess_new_connection(conn);\n\n\t\t\t\t/* Free client certificate info */\n\t\t\t\tif (conn->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->finger));\n\t\t\t\t\t/* Free certificate memory */\n\t\t\t\t\tX509_free(\n\t\t\t\t\t    (X509 *)conn->request_info.client_cert->peer_cert);\n\t\t\t\t\tconn->request_info.client_cert->peer_cert = 0;\n\t\t\t\t\tconn->request_info.client_cert->subject = 0;\n\t\t\t\t\tconn->request_info.client_cert->issuer = 0;\n\t\t\t\t\tconn->request_info.client_cert->serial = 0;\n\t\t\t\t\tconn->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(conn->request_info.client_cert);\n\t\t\t\t\tconn->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* make sure the connection is cleaned up on SSL failure */\n\t\t\t\tclose_connection(conn);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* process HTTP connection */\n\t\t\tprocess_new_connection(conn);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(sTlsKey, NULL);\n#if defined(_WIN32)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&conn->mutex);\n\n\t/* Free the request buffer. */\n\tconn->buf_size = 0;\n\tmg_free(conn->buf);\n\tconn->buf = NULL;\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 9; /* done */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}\n\n\n/* Threads have different return types on Windows and Unix. */\n#if defined(_WIN32)\nstatic unsigned __stdcall worker_thread(void *thread_func_param)\n{\n\tstruct worker_thread_args *pwta =\n\t    (struct worker_thread_args *)thread_func_param;\n\tworker_thread_run(pwta);\n\tmg_free(thread_func_param);\n\treturn 0;\n}\n#else\nstatic void *\nworker_thread(void *thread_func_param)\n{\n\tstruct worker_thread_args *pwta =\n\t    (struct worker_thread_args *)thread_func_param;\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n\n\tworker_thread_run(pwta);\n\tmg_free(thread_func_param);\n\treturn NULL;\n}\n#endif /* _WIN32 */\n\n\n/* This is an internal function, thus all arguments are expected to be\n * valid - a NULL check is not required. */\nstatic void\naccept_new_connection(const struct socket *listener, struct mg_context *ctx)\n{\n\tstruct socket so;\n\tchar src_addr[IP_ADDR_STR_LEN];\n\tsocklen_t len = sizeof(so.rsa);\n\tint on = 1;\n\n\tif ((so.sock = accept(listener->sock, &so.rsa.sa, &len))\n\t    == INVALID_SOCKET) {\n\t} else if (!check_acl(ctx, ntohl(*(uint32_t *)&so.rsa.sin.sin_addr))) {\n\t\tsockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s: %s is not allowed to connect\",\n\t\t                __func__,\n\t\t                src_addr);\n\t\tclosesocket(so.sock);\n\t} else {\n\t\t/* Put so socket structure into the queue */\n\t\tDEBUG_TRACE(\"Accepted socket %d\", (int)so.sock);\n\t\tset_close_on_exec(so.sock, fc(ctx));\n\t\tso.is_ssl = listener->is_ssl;\n\t\tso.ssl_redir = listener->ssl_redir;\n\t\tif (getsockname(so.sock, &so.lsa.sa, &len) != 0) {\n\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t                \"%s: getsockname() failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n\n\t\t/* Set TCP keep-alive. This is needed because if HTTP-level\n\t\t * keep-alive\n\t\t * is enabled, and client resets the connection, server won't get\n\t\t * TCP FIN or RST and will keep the connection open forever. With\n\t\t * TCP keep-alive, next keep-alive handshake will figure out that\n\t\t * the client is down and will close the server end.\n\t\t * Thanks to Igor Klopov who suggested the patch. */\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_KEEPALIVE,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on)) != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(ctx),\n\t\t\t    \"%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s\",\n\t\t\t    __func__,\n\t\t\t    strerror(ERRNO));\n\t\t}\n\n\t\t/* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced\n\t\t * to effectively fill up the underlying IP packet payload and\n\t\t * reduce the overhead of sending lots of small buffers. However\n\t\t * this hurts the server's throughput (ie. operations per second)\n\t\t * when HTTP 1.1 persistent connections are used and the responses\n\t\t * are relatively small (eg. less than 1400 bytes).\n\t\t */\n\t\tif ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL)\n\t\t    && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], \"1\"))) {\n\t\t\tif (set_tcp_nodelay(so.sock, 1) != 0) {\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    fc(ctx),\n\t\t\t\t    \"%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s\",\n\t\t\t\t    __func__,\n\t\t\t\t    strerror(ERRNO));\n\t\t\t}\n\t\t}\n\n\t\t/* We are using non-blocking sockets. Thus, the\n\t\t * set_sock_timeout(so.sock, timeout);\n\t\t * call is no longer required. */\n\n\t\t/* The \"non blocking\" property should already be\n\t\t * inherited from the parent socket. Set it for\n\t\t * non-compliant socket implementations. */\n\t\tset_non_blocking_mode(so.sock);\n\n\t\tso.in_use = 0;\n\t\tproduce_socket(ctx, &so);\n\t}\n}\n\n\nstatic void\nmaster_thread_run(void *thread_func_param)\n{\n\tstruct mg_context *ctx = (struct mg_context *)thread_func_param;\n\tstruct mg_workerTLS tls;\n\tstruct pollfd *pfd;\n\tunsigned int i;\n\tunsigned int workerthreadcount;\n\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\tmg_set_thread_name(\"master\");\n\n/* Increase priority of the master thread */\n#if defined(_WIN32)\n\tSetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);\n#elif defined(USE_MASTER_THREAD_PRIORITY)\n\tint min_prio = sched_get_priority_min(SCHED_RR);\n\tint max_prio = sched_get_priority_max(SCHED_RR);\n\tif ((min_prio >= 0) && (max_prio >= 0)\n\t    && ((USE_MASTER_THREAD_PRIORITY) <= max_prio)\n\t    && ((USE_MASTER_THREAD_PRIORITY) >= min_prio)) {\n\t\tstruct sched_param sched_param = {0};\n\t\tsched_param.sched_priority = (USE_MASTER_THREAD_PRIORITY);\n\t\tpthread_setschedparam(pthread_self(), SCHED_RR, &sched_param);\n\t}\n#endif\n\n/* Initialize thread local storage */\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\ttls.is_master = 1;\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* Callback for the master thread (type 0) */\n\t\tctx->callbacks.init_thread(ctx, 0);\n\t}\n\n\t/* Server starts *now* */\n\tctx->start_time = time(NULL);\n\n\t/* Start the server */\n\tpfd = ctx->listening_socket_fds;\n\twhile (ctx->stop_flag == 0) {\n\t\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\t\tpfd[i].fd = ctx->listening_sockets[i].sock;\n\t\t\tpfd[i].events = POLLIN;\n\t\t}\n\n\t\tif (poll(pfd, ctx->num_listening_sockets, 200) > 0) {\n\t\t\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\t\t\t/* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the\n\t\t\t\t * successful poll, and POLLIN is defined as\n\t\t\t\t * (POLLRDNORM | POLLRDBAND)\n\t\t\t\t * Therefore, we're checking pfd[i].revents & POLLIN, not\n\t\t\t\t * pfd[i].revents == POLLIN. */\n\t\t\t\tif ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {\n\t\t\t\t\taccept_new_connection(&ctx->listening_sockets[i], ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Here stop_flag is 1 - Initiate shutdown. */\n\tDEBUG_TRACE(\"%s\", \"stopping workers\");\n\n\t/* Stop signal received: somebody called mg_stop. Quit. */\n\tclose_all_listening_sockets(ctx);\n\n\t/* Wakeup workers that are waiting for connections to handle. */\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n#if defined(ALTERNATIVE_QUEUE)\n\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\tevent_signal(ctx->client_wait_events[i]);\n\n\t\t/* Since we know all sockets, we can shutdown the connections. */\n\t\tif (ctx->client_socks[i].in_use) {\n\t\t\tshutdown(ctx->client_socks[i].sock, SHUTDOWN_BOTH);\n\t\t}\n\t}\n#else\n\tpthread_cond_broadcast(&ctx->sq_full);\n#endif\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n\n\t/* Join all worker threads to avoid leaking threads. */\n\tworkerthreadcount = ctx->cfg_worker_threads;\n\tfor (i = 0; i < workerthreadcount; i++) {\n\t\tif (ctx->worker_threadids[i] != 0) {\n\t\t\tmg_join_thread(ctx->worker_threadids[i]);\n\t\t}\n\t}\n\n#if defined(USE_LUA)\n\t/* Free Lua state of lua background task */\n\tif (ctx->lua_background_state) {\n\t\tlua_State *lstate = (lua_State *)ctx->lua_background_state;\n\t\tlua_getglobal(lstate, LUABACKGROUNDPARAMS);\n\t\tif (lua_istable(lstate, -1)) {\n\t\t\treg_boolean(lstate, \"shutdown\", 1);\n\t\t\tlua_pop(lstate, 1);\n\t\t\tmg_sleep(2);\n\t\t}\n\t\tlua_close(lstate);\n\t\tctx->lua_background_state = 0;\n\t}\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\n#if defined(_WIN32)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_setspecific(sTlsKey, NULL);\n\n\t/* Signal mg_stop() that we're done.\n\t * WARNING: This must be the very last thing this\n\t * thread does, as ctx becomes invalid after this line. */\n\tctx->stop_flag = 2;\n}\n\n\n/* Threads have different return types on Windows and Unix. */\n#if defined(_WIN32)\nstatic unsigned __stdcall master_thread(void *thread_func_param)\n{\n\tmaster_thread_run(thread_func_param);\n\treturn 0;\n}\n#else\nstatic void *\nmaster_thread(void *thread_func_param)\n{\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n\n\tmaster_thread_run(thread_func_param);\n\treturn NULL;\n}\n#endif /* _WIN32 */\n\n\nstatic void\nfree_context(struct mg_context *ctx)\n{\n\tint i;\n\tstruct mg_handler_info *tmp_rh;\n\n\tif (ctx == NULL) {\n\t\treturn;\n\t}\n\n\tif (ctx->callbacks.exit_context) {\n\t\tctx->callbacks.exit_context(ctx);\n\t}\n\n\t/* All threads exited, no sync is needed. Destroy thread mutex and\n\t * condvars\n\t */\n\t(void)pthread_mutex_destroy(&ctx->thread_mutex);\n#if defined(ALTERNATIVE_QUEUE)\n\tmg_free(ctx->client_socks);\n\tfor (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {\n\t\tevent_destroy(ctx->client_wait_events[i]);\n\t}\n\tmg_free(ctx->client_wait_events);\n#else\n\t(void)pthread_cond_destroy(&ctx->sq_empty);\n\t(void)pthread_cond_destroy(&ctx->sq_full);\n#endif\n\n\t/* Destroy other context global data structures mutex */\n\t(void)pthread_mutex_destroy(&ctx->nonce_mutex);\n\n#if defined(USE_TIMERS)\n\ttimers_exit(ctx);\n#endif\n\n\t/* Deallocate config parameters */\n\tfor (i = 0; i < NUM_OPTIONS; i++) {\n\t\tif (ctx->dd.config[i] != NULL) {\n#if defined(_MSC_VER)\n#pragma warning(suppress : 6001)\n#endif\n\t\t\tmg_free(ctx->dd.config[i]);\n\t\t}\n\t}\n\n\t/* Deallocate request handlers */\n\twhile (ctx->dd.handlers) {\n\t\ttmp_rh = ctx->dd.handlers;\n\t\tctx->dd.handlers = tmp_rh->next;\n\t\tif (tmp_rh->handler_type == REQUEST_HANDLER) {\n\t\t\tpthread_cond_destroy(&tmp_rh->refcount_cond);\n\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t}\n\t\tmg_free(tmp_rh->uri);\n\t\tmg_free(tmp_rh);\n\t}\n\n#if !defined(NO_SSL)\n\t/* Deallocate SSL context */\n\tif (ctx->dd.ssl_ctx != NULL) {\n\t\tvoid *ssl_ctx = (void *)ctx->dd.ssl_ctx;\n\t\tint callback_ret =\n\t\t    (ctx->callbacks.external_ssl_ctx == NULL)\n\t\t        ? 0\n\t\t        : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));\n\n\t\tif (callback_ret == 0) {\n\t\t\tSSL_CTX_free(ctx->dd.ssl_ctx);\n\t\t}\n\t\t/* else: ignore error and ommit SSL_CTX_free in case\n\t\t * callback_ret is 1 */\n\t}\n#endif /* !NO_SSL */\n\n\t/* Deallocate worker thread ID array */\n\tif (ctx->worker_threadids != NULL) {\n\t\tmg_free(ctx->worker_threadids);\n\t}\n\n\t/* Deallocate worker thread ID array */\n\tif (ctx->worker_connections != NULL) {\n\t\tmg_free(ctx->worker_connections);\n\t}\n\n\t/* deallocate system name string */\n\tmg_free(ctx->systemName);\n\n\t/* Deallocate context itself */\n\tmg_free(ctx);\n}\n\n\nvoid\nmg_stop(struct mg_context *ctx)\n{\n\tpthread_t mt;\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\t/* We don't use a lock here. Calling mg_stop with the same ctx from\n\t * two threads is not allowed. */\n\tmt = ctx->masterthreadid;\n\tif (mt == 0) {\n\t\treturn;\n\t}\n\n\tctx->masterthreadid = 0;\n\n\t/* Set stop flag, so all threads know they have to exit. */\n\tctx->stop_flag = 1;\n\n\t/* Wait until everything has stopped. */\n\twhile (ctx->stop_flag != 2) {\n\t\t(void)mg_sleep(10);\n\t}\n\n\tmg_join_thread(mt);\n\tfree_context(ctx);\n\n#if defined(_WIN32)\n\t(void)WSACleanup();\n#endif /* _WIN32 */\n}\n\n\nstatic void\nget_system_name(char **sysName)\n{\n#if defined(_WIN32)\n#if !defined(__SYMBIAN32__)\n#if defined(_WIN32_WCE)\n\t*sysName = mg_strdup(\"WinCE\");\n#else\n\tchar name[128];\n\tDWORD dwVersion = 0;\n\tDWORD dwMajorVersion = 0;\n\tDWORD dwMinorVersion = 0;\n\tDWORD dwBuild = 0;\n\tBOOL wowRet, isWoW = FALSE;\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n/* GetVersion was declared deprecated */\n#pragma warning(disable : 4996)\n#endif\n\tdwVersion = GetVersion();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\tdwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\tdwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\tdwBuild = ((dwVersion < 0x80000000) ? (DWORD)(HIWORD(dwVersion)) : 0);\n\t(void)dwBuild;\n\n\twowRet = IsWow64Process(GetCurrentProcess(), &isWoW);\n\n\tsprintf(name,\n\t        \"Windows %u.%u%s\",\n\t        (unsigned)dwMajorVersion,\n\t        (unsigned)dwMinorVersion,\n\t        (wowRet ? (isWoW ? \" (WoW64)\" : \"\") : \" (?)\"));\n\n\t*sysName = mg_strdup(name);\n#endif\n#else\n\t*sysName = mg_strdup(\"Symbian\");\n#endif\n#else\n\tstruct utsname name;\n\tmemset(&name, 0, sizeof(name));\n\tuname(&name);\n\t*sysName = mg_strdup(name.sysname);\n#endif\n}\n\n\nstruct mg_context *\nmg_start(const struct mg_callbacks *callbacks,\n         void *user_data,\n         const char **options)\n{\n\tstruct mg_context *ctx;\n\tconst char *name, *value, *default_value;\n\tint idx, ok, workerthreadcount;\n\tunsigned int i;\n\tint itmp;\n\tvoid (*exit_callback)(const struct mg_context *ctx) = 0;\n\n\tstruct mg_workerTLS tls;\n\n#if defined(_WIN32)\n\tWSADATA data;\n\tWSAStartup(MAKEWORD(2, 2), &data);\n#endif /* _WIN32  */\n\n\t/* Allocate context and initialize reasonable general case defaults. */\n\tif ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* Random number generator will initialize at the first call */\n\tctx->dd.auth_nonce_mask =\n\t    (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);\n\n\tif (mg_init_library_called == 0) {\n\t\t/* Legacy INIT, if mg_start is called without mg_init_library.\n\t\t * Note: This may cause a memory leak */\n\t\tconst char *ports_option =\n\t\t    config_options[LISTENING_PORTS].default_value;\n\n\t\tif (options) {\n\t\t\tconst char **run_options = options;\n\t\t\tconst char *optname = config_options[LISTENING_PORTS].name;\n\n\t\t\t/* Try to find the \"listening_ports\" option */\n\t\t\twhile (*run_options) {\n\t\t\t\tif (!strcmp(*run_options, optname)) {\n\t\t\t\t\tports_option = run_options[1];\n\t\t\t\t}\n\t\t\t\trun_options += 2;\n\t\t\t}\n\t\t}\n\n\t\tif (is_ssl_port_used(ports_option)) {\n\t\t\t/* Initialize with SSL support */\n\t\t\tmg_init_library(MG_FEATURES_TLS);\n\t\t} else {\n\t\t\t/* Initialize without SSL support */\n\t\t\tmg_init_library(MG_FEATURES_DEFAULT);\n\t\t}\n\t}\n\n\ttls.is_master = -1;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = NULL;\n#endif\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));\n#if !defined(ALTERNATIVE_QUEUE)\n\tok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));\n\tok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));\n#endif\n\tok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));\n\tif (!ok) {\n\t\t/* Fatal error - abort start. However, this situation should never\n\t\t * occur in practice. */\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot initialize thread synchronization objects\");\n\t\tmg_free(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tif (callbacks) {\n\t\tctx->callbacks = *callbacks;\n\t\texit_callback = callbacks->exit_context;\n\t\tctx->callbacks.exit_context = 0;\n\t}\n\tctx->user_data = user_data;\n\tctx->dd.handlers = NULL;\n\tctx->dd.next = NULL;\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tctx->dd.shared_lua_websockets = NULL;\n#endif\n\n\t/* Store options */\n\twhile (options && (name = *options++) != NULL) {\n\t\tif ((idx = get_option_index(name)) == -1) {\n\t\t\tmg_cry_internal(fc(ctx), \"Invalid option: %s\", name);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t} else if ((value = *options++) == NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"%s: option value cannot be NULL\", name);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (ctx->dd.config[idx] != NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"warning: %s: duplicate option\", name);\n\t\t\tmg_free(ctx->dd.config[idx]);\n\t\t}\n\t\tctx->dd.config[idx] = mg_strdup_ctx(value, ctx);\n\t\tDEBUG_TRACE(\"[%s] -> [%s]\", name, value);\n\t}\n\n\t/* Set default value if needed */\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdefault_value = config_options[i].default_value;\n\t\tif ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {\n\t\t\tctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);\n\t\t}\n\t}\n\n\t/* Request size option */\n\titmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);\n\tif (itmp < 1024) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"max_request_size too small\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\tctx->max_request_size = (unsigned)itmp;\n\n\t/* Worker thread count option */\n\tworkerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);\n\n\tif (workerthreadcount > MAX_WORKER_THREADS) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Too many worker threads\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tif (workerthreadcount <= 0) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Invalid number of worker threads\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n/* Document root */\n#if defined(NO_FILES)\n\tif (ctx->dd.config[DOCUMENT_ROOT] != NULL) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Document root must not be set\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n#endif\n\n\tget_system_name(&ctx->systemName);\n\n#if defined(USE_LUA)\n\t/* If a Lua background script has been configured, start it. */\n\tif (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {\n\t\tchar ebuf[256];\n\t\tstruct vec opt_vec;\n\t\tstruct vec eq_vec;\n\t\tconst char *sparams;\n\t\tlua_State *state = mg_prepare_lua_context_script(\n\t\t    ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));\n\t\tif (!state) {\n\t\t\tmg_cry_internal(fc(ctx), \"lua_background_script error: %s\", ebuf);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tctx->lua_background_state = (void *)state;\n\n\t\tlua_newtable(state);\n\t\treg_boolean(state, \"shutdown\", 0);\n\n\t\tsparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];\n\n\t\twhile ((sparams = next_option(sparams, &opt_vec, &eq_vec)) != NULL) {\n\t\t\treg_llstring(\n\t\t\t    state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);\n\t\t\tif (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tlua_setglobal(state, LUABACKGROUNDPARAMS);\n\n\t} else {\n\t\tctx->lua_background_state = 0;\n\t}\n#endif\n\n\t/* NOTE(lsm): order is important here. SSL certificates must\n\t * be initialized before listening ports. UID must be set last. */\n\tif (!set_gpass_option(ctx, NULL) ||\n#if !defined(NO_SSL)\n\t    !init_ssl_ctx(ctx, NULL) ||\n#endif\n\t    !set_ports_option(ctx) ||\n#if !defined(_WIN32)\n\t    !set_uid_option(ctx) ||\n#endif\n\t    !set_acl_option(ctx)) {\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));\n\tctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,\n\t                                                   sizeof(pthread_t),\n\t                                                   ctx);\n\n\tif (ctx->worker_threadids == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker thread ID array\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\tctx->worker_connections =\n\t    (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,\n\t                                          sizeof(struct mg_connection),\n\t                                          ctx);\n\tif (ctx->worker_connections == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker thread connection array\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\tctx->client_wait_events =\n\t    (void **)mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),\n\t                           ctx->cfg_worker_threads,\n\t                           ctx);\n\tif (ctx->client_wait_events == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker event array\");\n\t\tmg_free(ctx->worker_threadids);\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tctx->client_socks =\n\t    (struct socket *)mg_calloc_ctx(sizeof(ctx->client_socks[0]),\n\t                                   ctx->cfg_worker_threads,\n\t                                   ctx);\n\tif (ctx->client_socks == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker socket array\");\n\t\tmg_free(ctx->client_wait_events);\n\t\tmg_free(ctx->worker_threadids);\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {\n\t\tctx->client_wait_events[i] = event_create();\n\t\tif (ctx->client_wait_events[i] == 0) {\n\t\t\tmg_cry_internal(fc(ctx), \"Error creating worker event %i\", i);\n\t\t\twhile (i > 0) {\n\t\t\t\ti--;\n\t\t\t\tevent_destroy(ctx->client_wait_events[i]);\n\t\t\t}\n\t\t\tmg_free(ctx->client_socks);\n\t\t\tmg_free(ctx->client_wait_events);\n\t\t\tmg_free(ctx->worker_threadids);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\n#if defined(USE_TIMERS)\n\tif (timers_init(ctx) != 0) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Error creating timers\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Context has been created - init user libraries */\n\tif (ctx->callbacks.init_context) {\n\t\tctx->callbacks.init_context(ctx);\n\t}\n\tctx->callbacks.exit_context = exit_callback;\n\tctx->context_type = CONTEXT_SERVER; /* server context */\n\n\t/* Start master (listening) thread */\n\tmg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);\n\n\t/* Start worker threads */\n\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\tstruct worker_thread_args *wta = (struct worker_thread_args *)\n\t\t    mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);\n\t\tif (wta) {\n\t\t\twta->ctx = ctx;\n\t\t\twta->index = (int)i;\n\t\t}\n\n\t\tif ((wta == NULL)\n\t\t    || (mg_start_thread_with_id(worker_thread,\n\t\t                                wta,\n\t\t                                &ctx->worker_threadids[i]) != 0)) {\n\n\t\t\t/* thread was not created */\n\t\t\tif (wta != NULL) {\n\t\t\t\tmg_free(wta);\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t\t                \"Cannot start worker thread %i: error %ld\",\n\t\t\t\t                i + 1,\n\t\t\t\t                (long)ERRNO);\n\t\t\t} else {\n\t\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t\t                \"Cannot create threads: error %ld\",\n\t\t\t\t                (long)ERRNO);\n\t\t\t\tfree_context(ctx);\n\t\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpthread_setspecific(sTlsKey, NULL);\n\treturn ctx;\n}\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n/* Add an additional domain to an already running web server. */\nint\nmg_start_domain(struct mg_context *ctx, const char **options)\n{\n\tconst char *name;\n\tconst char *value;\n\tconst char *default_value;\n\tstruct mg_domain_context *new_dom;\n\tstruct mg_domain_context *dom;\n\tint idx, i;\n\n\tif ((ctx == NULL) || (ctx->stop_flag != 0) || (options == NULL)) {\n\t\treturn -1;\n\t}\n\n\tnew_dom = (struct mg_domain_context *)\n\t    mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);\n\n\tif (!new_dom) {\n\t\t/* Out of memory */\n\t\treturn -6;\n\t}\n\n\t/* Store options - TODO: unite duplicate code */\n\twhile (options && (name = *options++) != NULL) {\n\t\tif ((idx = get_option_index(name)) == -1) {\n\t\t\tmg_cry_internal(fc(ctx), \"Invalid option: %s\", name);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -2;\n\t\t} else if ((value = *options++) == NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"%s: option value cannot be NULL\", name);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -2;\n\t\t}\n\t\tif (new_dom->config[idx] != NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"warning: %s: duplicate option\", name);\n\t\t\tmg_free(new_dom->config[idx]);\n\t\t}\n\t\tnew_dom->config[idx] = mg_strdup_ctx(value, ctx);\n\t\tDEBUG_TRACE(\"[%s] -> [%s]\", name, value);\n\t}\n\n\t/* Authentication domain is mandatory */\n\t/* TODO: Maybe use a new option hostname? */\n\tif (!new_dom->config[AUTHENTICATION_DOMAIN]) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"authentication domain required\");\n\t\tmg_free(new_dom);\n\t\treturn -4;\n\t}\n\n\t/* Set default value if needed. Take the config value from\n\t * ctx as a default value. */\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdefault_value = ctx->dd.config[i];\n\t\tif ((new_dom->config[i] == NULL) && (default_value != NULL)) {\n\t\t\tnew_dom->config[i] = mg_strdup_ctx(default_value, ctx);\n\t\t}\n\t}\n\n\tnew_dom->handlers = NULL;\n\tnew_dom->next = NULL;\n\tnew_dom->nonce_count = 0;\n\tnew_dom->auth_nonce_mask =\n\t    (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tnew_dom->shared_lua_websockets = NULL;\n#endif\n\n\tif (!init_ssl_ctx(ctx, new_dom)) {\n\t\t/* Init SSL failed */\n\t\tmg_free(new_dom);\n\t\treturn -3;\n\t}\n\n\t/* Add element to linked list. */\n\tmg_lock_context(ctx);\n\n\tidx = 0;\n\tdom = &(ctx->dd);\n\tfor (;;) {\n\t\tif (!strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],\n\t\t                dom->config[AUTHENTICATION_DOMAIN])) {\n\t\t\t/* Domain collision */\n\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t                \"domain %s already in use\",\n\t\t\t                new_dom->config[AUTHENTICATION_DOMAIN]);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -5;\n\t\t}\n\n\t\t/* Count number of domains */\n\t\tidx++;\n\n\t\tif (dom->next == NULL) {\n\t\t\tdom->next = new_dom;\n\t\t\tbreak;\n\t\t}\n\t\tdom = dom->next;\n\t}\n\n\tmg_unlock_context(ctx);\n\n\t/* Return domain number */\n\treturn idx;\n}\n#endif\n\n\n/* Feature check API function */\nunsigned\nmg_check_feature(unsigned feature)\n{\n\tstatic const unsigned feature_set = 0\n/* Set bits for available features according to API documentation.\n * This bit mask is created at compile time, according to the active\n * preprocessor defines. It is a single const value at runtime. */\n#if !defined(NO_FILES)\n\t                                    | MG_FEATURES_FILES\n#endif\n#if !defined(NO_SSL)\n\t                                    | MG_FEATURES_SSL\n#endif\n#if !defined(NO_CGI)\n\t                                    | MG_FEATURES_CGI\n#endif\n#if defined(USE_IPV6)\n\t                                    | MG_FEATURES_IPV6\n#endif\n#if defined(USE_WEBSOCKET)\n\t                                    | MG_FEATURES_WEBSOCKET\n#endif\n#if defined(USE_LUA)\n\t                                    | MG_FEATURES_LUA\n#endif\n#if defined(USE_DUKTAPE)\n\t                                    | MG_FEATURES_SSJS\n#endif\n#if !defined(NO_CACHING)\n\t                                    | MG_FEATURES_CACHE\n#endif\n#if defined(USE_SERVER_STATS)\n\t                                    | MG_FEATURES_STATS\n#endif\n#if defined(USE_ZLIB)\n\t                                    | MG_FEATURES_COMPRESSION\n#endif\n\n/* Set some extra bits not defined in the API documentation.\n * These bits may change without further notice. */\n#if defined(MG_LEGACY_INTERFACE)\n\t                                    | 0x00008000u\n#endif\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n\t                                    | 0x00004000u\n#endif\n#if defined(MEMORY_DEBUGGING)\n\t                                    | 0x00001000u\n#endif\n#if defined(USE_TIMERS)\n\t                                    | 0x00020000u\n#endif\n#if !defined(NO_NONCE_CHECK)\n\t                                    | 0x00040000u\n#endif\n#if !defined(NO_POPEN)\n\t                                    | 0x00080000u\n#endif\n\t    ;\n\treturn (feature & feature_set);\n}\n\n\n/* strcat with additional NULL check to avoid clang scan-build warning. */\n#define strcat0(a, b)                                                          \\\n\t{                                                                          \\\n\t\tif ((a != NULL) && (b != NULL)) {                                      \\\n\t\t\tstrcat(a, b);                                                      \\\n\t\t}                                                                      \\\n\t}\n\n\n/* Get system information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_system_info_impl(char *buffer, int buflen)\n{\n\tchar block[256];\n\tint system_info_length = 0;\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tsystem_info_length += (int)strlen(block);\n\tif (system_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Server version */\n\t{\n\t\tconst char *version = mg_version();\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"version\\\" : \\\"%s\\\",%s\",\n\t\t            version,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* System info */\n\t{\n#if defined(_WIN32)\n\t\tDWORD dwVersion = 0;\n\t\tDWORD dwMajorVersion = 0;\n\t\tDWORD dwMinorVersion = 0;\n\t\tSYSTEM_INFO si;\n\n\t\tGetSystemInfo(&si);\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n/* GetVersion was declared deprecated */\n#pragma warning(disable : 4996)\n#endif\n\t\tdwVersion = GetVersion();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\t\tdwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\t\tdwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"os\\\" : \\\"Windows %u.%u\\\",%s\",\n\t\t            (unsigned)dwMajorVersion,\n\t\t            (unsigned)dwMinorVersion,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"cpu\\\" : \\\"type %u, cores %u, mask %x\\\",%s\",\n\t\t            (unsigned)si.wProcessorArchitecture,\n\t\t            (unsigned)si.dwNumberOfProcessors,\n\t\t            (unsigned)si.dwActiveProcessorMask,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#else\n\t\tstruct utsname name;\n\t\tmemset(&name, 0, sizeof(name));\n\t\tuname(&name);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"os\\\" : \\\"%s %s (%s) - %s\\\",%s\",\n\t\t            name.sysname,\n\t\t            name.version,\n\t\t            name.release,\n\t\t            name.machine,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Features */\n\t{\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"features\\\" : %lu,%s\"\n\t\t            \"\\\"feature_list\\\" : \\\"Server:%s%s%s%s%s%s%s%s%s\\\",%s\",\n\t\t            (unsigned long)mg_check_feature(0xFFFFFFFFu),\n\t\t            eol,\n\t\t            mg_check_feature(MG_FEATURES_FILES) ? \" Files\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_SSL) ? \" HTTPS\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_CGI) ? \" CGI\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_IPV6) ? \" IPv6\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_WEBSOCKET) ? \" WebSockets\"\n\t\t                                                    : \"\",\n\t\t            mg_check_feature(MG_FEATURES_LUA) ? \" Lua\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_SSJS) ? \" JavaScript\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_CACHE) ? \" Cache\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_STATS) ? \" Stats\" : \"\",\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n#if defined(USE_LUA)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"lua_version\\\" : \\\"%u (%s)\\\",%s\",\n\t\t            (unsigned)LUA_VERSION_NUM,\n\t\t            LUA_RELEASE,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n#if defined(USE_DUKTAPE)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"javascript\\\" : \\\"Duktape %u.%u.%u\\\",%s\",\n\t\t            (unsigned)DUK_VERSION / 10000,\n\t\t            ((unsigned)DUK_VERSION / 100) % 100,\n\t\t            (unsigned)DUK_VERSION % 100,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Build date */\n\t{\n#if defined(__GNUC__)\n#pragma GCC diagnostic push\n/* Disable bogus compiler warning -Wdate-time */\n#pragma GCC diagnostic ignored \"-Wdate-time\"\n#endif\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"build\\\" : \\\"%s\\\",%s\",\n\t\t            __DATE__,\n\t\t            eol);\n\n#if defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\n\t/* Compiler information */\n\t/* http://sourceforge.net/p/predef/wiki/Compilers/ */\n\t{\n#if defined(_MSC_VER)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MSC: %u (%u)\\\",%s\",\n\t\t            (unsigned)_MSC_VER,\n\t\t            (unsigned)_MSC_FULL_VER,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__MINGW64__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW64: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW64_VERSION_MAJOR,\n\t\t            (unsigned)__MINGW64_VERSION_MINOR,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW32: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW32_MAJOR_VERSION,\n\t\t            (unsigned)__MINGW32_MINOR_VERSION,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__MINGW32__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW32: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW32_MAJOR_VERSION,\n\t\t            (unsigned)__MINGW32_MINOR_VERSION,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__clang__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"clang: %u.%u.%u (%s)\\\",%s\",\n\t\t            __clang_major__,\n\t\t            __clang_minor__,\n\t\t            __clang_patchlevel__,\n\t\t            __clang_version__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__GNUC__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"gcc: %u.%u.%u\\\",%s\",\n\t\t            (unsigned)__GNUC__,\n\t\t            (unsigned)__GNUC_MINOR__,\n\t\t            (unsigned)__GNUC_PATCHLEVEL__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__INTEL_COMPILER)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Intel C/C++: %u\\\",%s\",\n\t\t            (unsigned)__INTEL_COMPILER,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__BORLANDC__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Borland C: 0x%x\\\",%s\",\n\t\t            (unsigned)__BORLANDC__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__SUNPRO_C)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Solaris: 0x%x\\\",%s\",\n\t\t            (unsigned)__SUNPRO_C,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#else\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"other\\\",%s\",\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Determine 32/64 bit data mode.\n\t * see https://en.wikipedia.org/wiki/64-bit_computing */\n\t{\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data_model\\\" : \\\"int:%u/%u/%u/%u, float:%u/%u/%u, \"\n\t\t            \"char:%u/%u, \"\n\t\t            \"ptr:%u, size:%u, time:%u\\\"%s\",\n\t\t            (unsigned)sizeof(short),\n\t\t            (unsigned)sizeof(int),\n\t\t            (unsigned)sizeof(long),\n\t\t            (unsigned)sizeof(long long),\n\t\t            (unsigned)sizeof(float),\n\t\t            (unsigned)sizeof(double),\n\t\t            (unsigned)sizeof(long double),\n\t\t            (unsigned)sizeof(char),\n\t\t            (unsigned)sizeof(wchar_t),\n\t\t            (unsigned)sizeof(void *),\n\t\t            (unsigned)sizeof(size_t),\n\t\t            (unsigned)sizeof(time_t),\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tsystem_info_length += reserved_len;\n\n\treturn system_info_length;\n}\n\n\n#if defined(USE_SERVER_STATS)\n/* Get context information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_context_info_impl(const struct mg_context *ctx, char *buffer, int buflen)\n\n{\n\tchar block[256];\n\tint context_info_length = 0;\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\tstruct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tcontext_info_length += (int)strlen(block);\n\tif (context_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\tif (ms) { /* <-- should be always true */\n\t\t/* Memory information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"memory\\\" : {%s\"\n\t\t            \"\\\"blocks\\\" : %i,%s\"\n\t\t            \"\\\"used\\\" : %\" INT64_FMT \",%s\"\n\t\t            \"\\\"maxUsed\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"}%s%s\",\n\t\t            eol,\n\t\t            ms->blockCount,\n\t\t            eol,\n\t\t            ms->totalMemUsed,\n\t\t            eol,\n\t\t            ms->maxMemUsed,\n\t\t            eol,\n\t\t            (ctx ? \",\" : \"\"),\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\tif (ctx) {\n\t\t/* Declare all variables at begin of the block, to comply\n\t\t * with old C standards. */\n\t\tchar start_time_str[64] = {0};\n\t\tchar now_str[64] = {0};\n\t\ttime_t start_time = ctx->start_time;\n\t\ttime_t now = time(NULL);\n\n\t\t/* Connections information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"connections\\\" : {%s\"\n\t\t            \"\\\"active\\\" : %i,%s\"\n\t\t            \"\\\"maxActive\\\" : %i,%s\"\n\t\t            \"\\\"total\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->active_connections,\n\t\t            eol,\n\t\t            ctx->max_connections,\n\t\t            eol,\n\t\t            ctx->total_connections,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Requests information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"requests\\\" : {%s\"\n\t\t            \"\\\"total\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->total_requests,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Data information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data\\\" : {%s\"\n\t\t            \"\\\"read\\\" : %\" INT64_FMT \"%s,\"\n\t\t            \"\\\"written\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->total_data_read,\n\t\t            eol,\n\t\t            ctx->total_data_written,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Execution time information */\n\t\tgmt_time_string(start_time_str,\n\t\t                sizeof(start_time_str) - 1,\n\t\t                &start_time);\n\t\tgmt_time_string(now_str, sizeof(now_str) - 1, &now);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"time\\\" : {%s\"\n\t\t            \"\\\"uptime\\\" : %.0f,%s\"\n\t\t            \"\\\"start\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"now\\\" : \\\"%s\\\"%s\"\n\t\t            \"}%s\",\n\t\t            eol,\n\t\t            difftime(now, start_time),\n\t\t            eol,\n\t\t            start_time_str,\n\t\t            eol,\n\t\t            now_str,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (context_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tcontext_info_length += reserved_len;\n\n\treturn context_info_length;\n}\n#endif\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n/* Get connection information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_connection_info_impl(const struct mg_context *ctx,\n                            int idx,\n                            char *buffer,\n                            int buflen)\n{\n\tconst struct mg_connection *conn;\n\tconst struct mg_request_info *ri;\n\tchar block[256];\n\tint connection_info_length = 0;\n\tint state = 0;\n\tconst char *state_str = \"unknown\";\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tif ((ctx == NULL) || (idx < 0)) {\n\t\t/* Parameter error */\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)idx >= ctx->cfg_worker_threads) {\n\t\t/* Out of range */\n\t\treturn 0;\n\t}\n\n\t/* Take connection [idx]. This connection is not locked in\n\t * any way, so some other thread might use it. */\n\tconn = (ctx->worker_connections) + idx;\n\n\t/* Initialize output string */\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tconnection_info_length += (int)strlen(block);\n\tif (connection_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Init variables */\n\tri = &(conn->request_info);\n\n#if defined(USE_SERVER_STATS)\n\tstate = conn->conn_state;\n\n\t/* State as string */\n\tswitch (state) {\n\tcase 0:\n\t\tstate_str = \"undefined\";\n\t\tbreak;\n\tcase 1:\n\t\tstate_str = \"not used\";\n\t\tbreak;\n\tcase 2:\n\t\tstate_str = \"init\";\n\t\tbreak;\n\tcase 3:\n\t\tstate_str = \"ready\";\n\t\tbreak;\n\tcase 4:\n\t\tstate_str = \"processing\";\n\t\tbreak;\n\tcase 5:\n\t\tstate_str = \"processed\";\n\t\tbreak;\n\tcase 6:\n\t\tstate_str = \"to close\";\n\t\tbreak;\n\tcase 7:\n\t\tstate_str = \"closing\";\n\t\tbreak;\n\tcase 8:\n\t\tstate_str = \"closed\";\n\t\tbreak;\n\tcase 9:\n\t\tstate_str = \"done\";\n\t\tbreak;\n\t}\n#endif\n\n\t/* Connection info */\n\tif ((state >= 3) && (state < 9)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"connection\\\" : {%s\"\n\t\t            \"\\\"remote\\\" : {%s\"\n\t\t            \"\\\"protocol\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"addr\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"port\\\" : %u%s\"\n\t\t            \"},%s\"\n\t\t            \"\\\"handled_requests\\\" : %u%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            eol,\n\t\t            get_proto_name(conn),\n\t\t            eol,\n\t\t            ri->remote_addr,\n\t\t            eol,\n\t\t            ri->remote_port,\n\t\t            eol,\n\t\t            eol,\n\t\t            conn->handled_requests,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Request info */\n\tif ((state >= 4) && (state < 6)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"request_info\\\" : {%s\"\n\t\t            \"\\\"method\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"uri\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"query\\\" : %s%s%s%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ri->request_method,\n\t\t            eol,\n\t\t            ri->request_uri,\n\t\t            eol,\n\t\t            ri->query_string ? \"\\\"\" : \"\",\n\t\t            ri->query_string ? ri->query_string : \"null\",\n\t\t            ri->query_string ? \"\\\"\" : \"\",\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Execution time information */\n\tif ((state >= 2) && (state < 9)) {\n\t\tchar start_time_str[64] = {0};\n\t\tchar now_str[64] = {0};\n\t\ttime_t start_time = conn->conn_birth_time;\n\t\ttime_t now = time(NULL);\n\n\t\tgmt_time_string(start_time_str,\n\t\t                sizeof(start_time_str) - 1,\n\t\t                &start_time);\n\t\tgmt_time_string(now_str, sizeof(now_str) - 1, &now);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"time\\\" : {%s\"\n\t\t            \"\\\"uptime\\\" : %.0f,%s\"\n\t\t            \"\\\"start\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"now\\\" : \\\"%s\\\"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            difftime(now, start_time),\n\t\t            eol,\n\t\t            start_time_str,\n\t\t            eol,\n\t\t            now_str,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Remote user name */\n\tif ((ri->remote_user) && (state < 9)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"user\\\" : {%s\"\n\t\t            \"\\\"name\\\" : \\\"%s\\\",%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ri->remote_user,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Data block */\n\tif (state >= 3) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data\\\" : {%s\"\n\t\t            \"\\\"read\\\" : %\" INT64_FMT \",%s\"\n\t\t            \"\\\"written\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            conn->consumed_content,\n\t\t            eol,\n\t\t            conn->num_bytes_sent,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* State */\n\tmg_snprintf(NULL,\n\t            NULL,\n\t            block,\n\t            sizeof(block),\n\t            \"\\\"state\\\" : \\\"%s\\\"%s\",\n\t            state_str,\n\t            eol);\n\n\tconnection_info_length += (int)strlen(block);\n\tif (connection_info_length + reserved_len < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (connection_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tconnection_info_length += reserved_len;\n\n\treturn connection_info_length;\n}\n#endif\n\n\n/* Get system information. It can be printed or stored by the caller.\n * Return the size of available information. */\nint\nmg_get_system_info(char *buffer, int buflen)\n{\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_system_info_impl(NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_system_info_impl(buffer, buflen);\n\t}\n}\n\n\n/* Get context information. It can be printed or stored by the caller.\n * Return the size of available information. */\nint\nmg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen)\n{\n#if defined(USE_SERVER_STATS)\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_context_info_impl(ctx, NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_context_info_impl(ctx, buffer, buflen);\n\t}\n#else\n\t(void)ctx;\n\tif ((buffer != NULL) && (buflen > 0)) {\n\t\tbuffer[0] = 0;\n\t}\n\treturn 0;\n#endif\n}\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\nint\nmg_get_connection_info(const struct mg_context *ctx,\n                       int idx,\n                       char *buffer,\n                       int buflen)\n{\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_connection_info_impl(ctx, idx, NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_connection_info_impl(ctx, idx, buffer, buflen);\n\t}\n}\n#endif\n\n\n/* Initialize this library. This function does not need to be thread safe.\n */\nunsigned\nmg_init_library(unsigned features)\n{\n#if !defined(NO_SSL)\n\tchar ebuf[128];\n#endif\n\n\tunsigned features_to_init = mg_check_feature(features & 0xFFu);\n\tunsigned features_inited = features_to_init;\n\n\tif (mg_init_library_called <= 0) {\n\t\t/* Not initialized yet */\n\t\tif (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmg_global_lock();\n\n\tif (mg_init_library_called <= 0) {\n\t\tif (0 != pthread_key_create(&sTlsKey, tls_dtor)) {\n\t\t\t/* Fatal error - abort start. However, this situation should\n\t\t\t * never occur in practice. */\n\t\t\tmg_global_unlock();\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\tInitializeCriticalSection(&global_log_file_lock);\n#endif\n#if !defined(_WIN32)\n\t\tpthread_mutexattr_init(&pthread_mutex_attr);\n\t\tpthread_mutexattr_settype(&pthread_mutex_attr, PTHREAD_MUTEX_RECURSIVE);\n#endif\n\n#if defined(USE_LUA)\n\t\tlua_init_optional_libraries();\n#endif\n\t}\n\n\tmg_global_unlock();\n\n#if !defined(NO_SSL)\n\tif (features_to_init & MG_FEATURES_SSL) {\n\t\tif (!mg_ssl_initialized) {\n\t\t\tif (initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\t\t\tmg_ssl_initialized = 1;\n\t\t\t} else {\n\t\t\t\t(void)ebuf;\n\t\t\t\tDEBUG_TRACE(\"Initializing SSL failed: %s\", ebuf);\n\t\t\t\tfeatures_inited &= ~((unsigned)(MG_FEATURES_SSL));\n\t\t\t}\n\t\t} else {\n\t\t\t/* ssl already initialized */\n\t\t}\n\t}\n#endif\n\n\t/* Start WinSock for Windows */\n\tmg_global_lock();\n\tif (mg_init_library_called <= 0) {\n#if defined(_WIN32)\n\t\tWSADATA data;\n\t\tWSAStartup(MAKEWORD(2, 2), &data);\n#endif /* _WIN32 */\n\t\tmg_init_library_called = 1;\n\t} else {\n\t\tmg_init_library_called++;\n\t}\n\tmg_global_unlock();\n\n\treturn features_inited;\n}\n\n\n/* Un-initialize this library. */\nunsigned\nmg_exit_library(void)\n{\n\tif (mg_init_library_called <= 0) {\n\t\treturn 0;\n\t}\n\n\tmg_global_lock();\n\n\tmg_init_library_called--;\n\tif (mg_init_library_called == 0) {\n#if defined(_WIN32)\n\t\t(void)WSACleanup();\n#endif /* _WIN32  */\n#if !defined(NO_SSL)\n\t\tif (mg_ssl_initialized) {\n\t\t\tuninitialize_ssl();\n\t\t\tmg_ssl_initialized = 0;\n\t\t}\n#endif\n\n#if defined(_WIN32)\n\t\t(void)DeleteCriticalSection(&global_log_file_lock);\n#endif /* _WIN32 */\n#if !defined(_WIN32)\n\t\t(void)pthread_mutexattr_destroy(&pthread_mutex_attr);\n#endif\n\n\t\t(void)pthread_key_delete(sTlsKey);\n\n#if defined(USE_LUA)\n\t\tlua_exit_optional_libraries();\n#endif\n\n\t\tmg_global_unlock();\n\t\t(void)pthread_mutex_destroy(&global_lock_mutex);\n\t\treturn 1;\n\t}\n\n\tmg_global_unlock();\n\treturn 1;\n}\n\n\n/* End of civetweb.c */\n"], "fixing_code": ["/* Copyright (c) 2013-2018 the Civetweb developers\n * Copyright (c) 2004-2013 Sergey Lyubka\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Disable unused macros warnings - not all defines are required\n * for all systems and all compilers. */\n#pragma GCC diagnostic ignored \"-Wunused-macros\"\n/* A padding warning is just plain useless */\n#pragma GCC diagnostic ignored \"-Wpadded\"\n#endif\n\n#if defined(__clang__) /* GCC does not (yet) support this pragma */\n/* We must set some flags for the headers we include. These flags\n * are reserved ids according to C99, so we need to disable a\n * warning for that. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wreserved-id-macro\"\n#endif\n\n#if defined(_WIN32)\n#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS /* Disable deprecation warning in VS2005 */\n#endif\n#if !defined(_WIN32_WINNT) /* defined for tdm-gcc so we can use getnameinfo */\n#define _WIN32_WINNT 0x0501\n#endif\n#else\n#if !defined(_GNU_SOURCE)\n#define _GNU_SOURCE /* for setgroups(), pthread_setname_np() */\n#endif\n#if defined(__linux__) && !defined(_XOPEN_SOURCE)\n#define _XOPEN_SOURCE 600 /* For flockfile() on Linux */\n#endif\n#if !defined(_LARGEFILE_SOURCE)\n#define _LARGEFILE_SOURCE /* For fseeko(), ftello() */\n#endif\n#if !defined(_FILE_OFFSET_BITS)\n#define _FILE_OFFSET_BITS 64 /* Use 64-bit file offsets by default */\n#endif\n#if !defined(__STDC_FORMAT_MACROS)\n#define __STDC_FORMAT_MACROS /* <inttypes.h> wants this for C++ */\n#endif\n#if !defined(__STDC_LIMIT_MACROS)\n#define __STDC_LIMIT_MACROS /* C++ wants that for INT64_MAX */\n#endif\n#if !defined(_DARWIN_UNLIMITED_SELECT)\n#define _DARWIN_UNLIMITED_SELECT\n#endif\n#if defined(__sun)\n#define __EXTENSIONS__  /* to expose flockfile and friends in stdio.h */\n#define __inline inline /* not recognized on older compiler versions */\n#endif\n#endif\n\n#if defined(__clang__)\n/* Enable reserved-id-macro warning again. */\n#pragma GCC diagnostic pop\n#endif\n\n\n#if defined(USE_LUA)\n#define USE_TIMERS\n#endif\n\n#if defined(_MSC_VER)\n/* 'type cast' : conversion from 'int' to 'HANDLE' of greater size */\n#pragma warning(disable : 4306)\n/* conditional expression is constant: introduced by FD_SET(..) */\n#pragma warning(disable : 4127)\n/* non-constant aggregate initializer: issued due to missing C99 support */\n#pragma warning(disable : 4204)\n/* padding added after data member */\n#pragma warning(disable : 4820)\n/* not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */\n#pragma warning(disable : 4668)\n/* no function prototype given: converting '()' to '(void)' */\n#pragma warning(disable : 4255)\n/* function has been selected for automatic inline expansion */\n#pragma warning(disable : 4711)\n#endif\n\n\n/* This code uses static_assert to check some conditions.\n * Unfortunately some compilers still do not support it, so we have a\n * replacement function here. */\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L\n#define mg_static_assert _Static_assert\n#elif defined(__cplusplus) && __cplusplus >= 201103L\n#define mg_static_assert static_assert\n#else\nchar static_assert_replacement[1];\n#define mg_static_assert(cond, txt)                                            \\\n\textern char static_assert_replacement[(cond) ? 1 : -1]\n#endif\n\nmg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,\n                 \"int data type size check\");\nmg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,\n                 \"pointer data type size check\");\nmg_static_assert(sizeof(void *) >= sizeof(int), \"data type size check\");\n\n\n/* Alternative queue is well tested and should be the new default */\n#if defined(NO_ALTERNATIVE_QUEUE)\n#if defined(ALTERNATIVE_QUEUE)\n#error \"Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE or none, but not both\"\n#endif\n#else\n#define ALTERNATIVE_QUEUE\n#endif\n\n\n/* DTL -- including winsock2.h works better if lean and mean */\n#if !defined(WIN32_LEAN_AND_MEAN)\n#define WIN32_LEAN_AND_MEAN\n#endif\n\n#if defined(__SYMBIAN32__)\n/* According to https://en.wikipedia.org/wiki/Symbian#History,\n * Symbian is no longer maintained since 2014-01-01.\n * Recent versions of CivetWeb are no longer tested for Symbian.\n * It makes no sense, to support an abandoned operating system.\n */\n#error \"Symbian is no longer maintained. CivetWeb no longer supports Symbian.\"\n#define NO_SSL /* SSL is not supported */\n#define NO_CGI /* CGI is not supported */\n#define PATH_MAX FILENAME_MAX\n#endif /* __SYMBIAN32__ */\n\n\n#if !defined(CIVETWEB_HEADER_INCLUDED)\n/* Include the header file here, so the CivetWeb interface is defined for the\n * entire implementation, including the following forward definitions. */\n#include \"civetweb.h\"\n#endif\n\n#if !defined(DEBUG_TRACE)\n#if defined(DEBUG)\nstatic void DEBUG_TRACE_FUNC(const char *func,\n                             unsigned line,\n                             PRINTF_FORMAT_STRING(const char *fmt),\n                             ...) PRINTF_ARGS(3, 4);\n\n#define DEBUG_TRACE(fmt, ...)                                                  \\\n\tDEBUG_TRACE_FUNC(__func__, __LINE__, fmt, __VA_ARGS__)\n\n#define NEED_DEBUG_TRACE_FUNC\n\n#else\n#define DEBUG_TRACE(fmt, ...)                                                  \\\n\tdo {                                                                       \\\n\t} while (0)\n#endif /* DEBUG */\n#endif /* DEBUG_TRACE */\n\n\n#if !defined(DEBUG_ASSERT)\n#if defined(DEBUG)\n#define DEBUG_ASSERT(cond)                                                     \\\n\tdo {                                                                       \\\n\t\tif (!(cond)) {                                                         \\\n\t\t\tDEBUG_TRACE(\"ASSERTION FAILED: %s\", #cond);                        \\\n\t\t\texit(2); /* Exit with error */                                     \\\n\t\t}                                                                      \\\n\t} while (0)\n#else\n#define DEBUG_ASSERT(cond)\n#endif /* DEBUG */\n#endif\n\n\n#if !defined(IGNORE_UNUSED_RESULT)\n#define IGNORE_UNUSED_RESULT(a) ((void)((a) && 1))\n#endif\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n\n/* GCC unused function attribute seems fundamentally broken.\n * Several attempts to tell the compiler \"THIS FUNCTION MAY BE USED\n * OR UNUSED\" for individual functions failed.\n * Either the compiler creates an \"unused-function\" warning if a\n * function is not marked with __attribute__((unused)).\n * On the other hand, if the function is marked with this attribute,\n * but is used, the compiler raises a completely idiotic\n * \"used-but-marked-unused\" warning - and\n *   #pragma GCC diagnostic ignored \"-Wused-but-marked-unused\"\n * raises error: unknown option after \"#pragma GCC diagnostic\".\n * Disable this warning completely, until the GCC guys sober up\n * again.\n */\n\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n\n#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */\n\n#else\n#define FUNCTION_MAY_BE_UNUSED\n#endif\n\n\n/* Some ANSI #includes are not available on Windows CE */\n#if !defined(_WIN32_WCE)\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n#endif /* !_WIN32_WCE */\n\n\n#if defined(__clang__)\n/* When using -Weverything, clang does not accept it's own headers\n * in a release build configuration. Disable what is too much in\n * -Weverything. */\n#pragma clang diagnostic ignored \"-Wdisabled-macro-expansion\"\n#endif\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Who on earth came to the conclusion, using __DATE__ should rise\n * an \"expansion of date or time macro is not reproducible\"\n * warning. That's exactly what was intended by using this macro.\n * Just disable this nonsense warning. */\n\n/* And disabling them does not work either:\n * #pragma clang diagnostic ignored \"-Wno-error=date-time\"\n * #pragma clang diagnostic ignored \"-Wdate-time\"\n * So we just have to disable ALL warnings for some lines\n * of code.\n * This seems to be a known GCC bug, not resolved since 2012:\n * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431\n */\n#endif\n\n\n#if defined(__MACH__) /* Apple OSX section */\n\n#if defined(__clang__)\n#if (__clang_major__ == 3) && ((__clang_minor__ == 7) || (__clang_minor__ == 8))\n/* Avoid warnings for Xcode 7. It seems it does no longer exist in Xcode 8 */\n#pragma clang diagnostic ignored \"-Wno-reserved-id-macro\"\n#pragma clang diagnostic ignored \"-Wno-keyword-macro\"\n#endif\n#endif\n\n#define CLOCK_MONOTONIC (1)\n#define CLOCK_REALTIME (2)\n\n#include <sys/errno.h>\n#include <sys/time.h>\n#include <mach/clock.h>\n#include <mach/mach.h>\n#include <mach/mach_time.h>\n\n/* clock_gettime is not implemented on OSX prior to 10.12 */\nstatic int\n_civet_clock_gettime(int clk_id, struct timespec *t)\n{\n\tmemset(t, 0, sizeof(*t));\n\tif (clk_id == CLOCK_REALTIME) {\n\t\tstruct timeval now;\n\t\tint rv = gettimeofday(&now, NULL);\n\t\tif (rv) {\n\t\t\treturn rv;\n\t\t}\n\t\tt->tv_sec = now.tv_sec;\n\t\tt->tv_nsec = now.tv_usec * 1000;\n\t\treturn 0;\n\n\t} else if (clk_id == CLOCK_MONOTONIC) {\n\t\tstatic uint64_t clock_start_time = 0;\n\t\tstatic mach_timebase_info_data_t timebase_ifo = {0, 0};\n\n\t\tuint64_t now = mach_absolute_time();\n\n\t\tif (clock_start_time == 0) {\n\t\t\tkern_return_t mach_status = mach_timebase_info(&timebase_ifo);\n\t\t\tDEBUG_ASSERT(mach_status == KERN_SUCCESS);\n\n\t\t\t/* appease \"unused variable\" warning for release builds */\n\t\t\t(void)mach_status;\n\n\t\t\tclock_start_time = now;\n\t\t}\n\n\t\tnow = (uint64_t)((double)(now - clock_start_time)\n\t\t                 * (double)timebase_ifo.numer\n\t\t                 / (double)timebase_ifo.denom);\n\n\t\tt->tv_sec = now / 1000000000;\n\t\tt->tv_nsec = now % 1000000000;\n\t\treturn 0;\n\t}\n\treturn -1; /* EINVAL - Clock ID is unknown */\n}\n\n/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */\n#if defined(__CLOCK_AVAILABILITY)\n/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be\n * declared but it may be NULL at runtime. So we need to check before using\n * it. */\nstatic int\n_civet_safe_clock_gettime(int clk_id, struct timespec *t)\n{\n\tif (clock_gettime) {\n\t\treturn clock_gettime(clk_id, t);\n\t}\n\treturn _civet_clock_gettime(clk_id, t);\n}\n#define clock_gettime _civet_safe_clock_gettime\n#else\n#define clock_gettime _civet_clock_gettime\n#endif\n\n#endif\n\n\n#include <time.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdint.h>\n\n/********************************************************************/\n/* CivetWeb configuration defines */\n/********************************************************************/\n\n/* Maximum number of threads that can be configured.\n * The number of threads actually created depends on the \"num_threads\"\n * configuration parameter, but this is the upper limit. */\n#if !defined(MAX_WORKER_THREADS)\n#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */\n#endif\n\n/* Timeout interval for select/poll calls.\n * The timeouts depend on \"*_timeout_ms\" configuration values, but long\n * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.\n * This reduces the time required to stop the server. */\n#if !defined(SOCKET_TIMEOUT_QUANTUM)\n#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */\n#endif\n\n/* Do not try to compress files smaller than this limit. */\n#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT)\n#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */\n#endif\n\n#if !defined(PASSWORDS_FILE_NAME)\n#define PASSWORDS_FILE_NAME \".htpasswd\"\n#endif\n\n/* Initial buffer size for all CGI environment variables. In case there is\n * not enough space, another block is allocated. */\n#if !defined(CGI_ENVIRONMENT_SIZE)\n#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */\n#endif\n\n/* Maximum number of environment variables. */\n#if !defined(MAX_CGI_ENVIR_VARS)\n#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */\n#endif\n\n/* General purpose buffer size. */\n#if !defined(MG_BUF_LEN) /* in bytes */\n#define MG_BUF_LEN (1024 * 8)\n#endif\n\n/* Size of the accepted socket queue (in case the old queue implementation\n * is used). */\n#if !defined(MGSQLEN)\n#define MGSQLEN (20) /* count */\n#endif\n\n\n/********************************************************************/\n\n/* Helper makros */\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\n/* Standard defines */\n#if !defined(INT64_MAX)\n#define INT64_MAX (9223372036854775807)\n#endif\n\n#define SHUTDOWN_RD (0)\n#define SHUTDOWN_WR (1)\n#define SHUTDOWN_BOTH (2)\n\nmg_static_assert(MAX_WORKER_THREADS >= 1,\n                 \"worker threads must be a positive number\");\n\nmg_static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8,\n                 \"size_t data type size check\");\n\n#if defined(_WIN32)   /* WINDOWS include block */\n#include <winsock2.h> /* DTL add for SO_EXCLUSIVE */\n#include <ws2tcpip.h>\n#include <windows.h>\n\ntypedef const char *SOCK_OPT_TYPE;\n\n#if !defined(PATH_MAX)\n#define W_PATH_MAX (MAX_PATH)\n/* at most three UTF-8 chars per wchar_t */\n#define PATH_MAX (W_PATH_MAX * 3)\n#else\n#define W_PATH_MAX ((PATH_MAX + 2) / 3)\n#endif\n\nmg_static_assert(PATH_MAX >= 1, \"path length must be a positive number\");\n\n#if !defined(_IN_PORT_T)\n#if !defined(in_port_t)\n#define in_port_t u_short\n#endif\n#endif\n\n#if !defined(_WIN32_WCE)\n#include <process.h>\n#include <direct.h>\n#include <io.h>\n#else            /* _WIN32_WCE */\n#define NO_CGI   /* WinCE has no pipes */\n#define NO_POPEN /* WinCE has no popen */\n\ntypedef long off_t;\n\n#define errno ((int)(GetLastError()))\n#define strerror(x) (_ultoa(x, (char *)_alloca(sizeof(x) * 3), 10))\n#endif /* _WIN32_WCE */\n\n#define MAKEUQUAD(lo, hi)                                                      \\\n\t((uint64_t)(((uint32_t)(lo)) | ((uint64_t)((uint32_t)(hi))) << 32))\n#define RATE_DIFF (10000000) /* 100 nsecs */\n#define EPOCH_DIFF (MAKEUQUAD(0xd53e8000, 0x019db1de))\n#define SYS2UNIX_TIME(lo, hi)                                                  \\\n\t((time_t)((MAKEUQUAD((lo), (hi)) - EPOCH_DIFF) / RATE_DIFF))\n\n/* Visual Studio 6 does not know __func__ or __FUNCTION__\n * The rest of MS compilers use __FUNCTION__, not C99 __func__\n * Also use _strtoui64 on modern M$ compilers */\n#if defined(_MSC_VER)\n#if (_MSC_VER < 1300)\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n#define strtoull(x, y, z) ((unsigned __int64)_atoi64(x))\n#define strtoll(x, y, z) (_atoi64(x))\n#else\n#define __func__ __FUNCTION__\n#define strtoull(x, y, z) (_strtoui64(x, y, z))\n#define strtoll(x, y, z) (_strtoi64(x, y, z))\n#endif\n#endif /* _MSC_VER */\n\n#define ERRNO ((int)(GetLastError()))\n#define NO_SOCKLEN_T\n\n#if defined(_WIN64) || defined(__MINGW64__)\n#if !defined(SSL_LIB)\n#define SSL_LIB \"ssleay64.dll\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libeay64.dll\"\n#endif\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB \"ssleay32.dll\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libeay32.dll\"\n#endif\n#endif\n\n#define O_NONBLOCK (0)\n#if !defined(W_OK)\n#define W_OK (2) /* http://msdn.microsoft.com/en-us/library/1w06ktdy.aspx */\n#endif\n#if !defined(EWOULDBLOCK)\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#endif /* !EWOULDBLOCK */\n#define _POSIX_\n#define INT64_FMT \"I64d\"\n#define UINT64_FMT \"I64u\"\n\n#define WINCDECL __cdecl\n#define vsnprintf_impl _vsnprintf\n#define access _access\n#define mg_sleep(x) (Sleep(x))\n\n#define pipe(x) _pipe(x, MG_BUF_LEN, _O_BINARY)\n#if !defined(popen)\n#define popen(x, y) (_popen(x, y))\n#endif\n#if !defined(pclose)\n#define pclose(x) (_pclose(x))\n#endif\n#define close(x) (_close(x))\n#define dlsym(x, y) (GetProcAddress((HINSTANCE)(x), (y)))\n#define RTLD_LAZY (0)\n#define fseeko(x, y, z) ((_lseeki64(_fileno(x), (y), (z)) == -1) ? -1 : 0)\n#define fdopen(x, y) (_fdopen((x), (y)))\n#define write(x, y, z) (_write((x), (y), (unsigned)z))\n#define read(x, y, z) (_read((x), (y), (unsigned)z))\n#define flockfile(x) (EnterCriticalSection(&global_log_file_lock))\n#define funlockfile(x) (LeaveCriticalSection(&global_log_file_lock))\n#define sleep(x) (Sleep((x)*1000))\n#define rmdir(x) (_rmdir(x))\n#if defined(_WIN64) || !defined(__MINGW32__)\n/* Only MinGW 32 bit is missing this function */\n#define timegm(x) (_mkgmtime(x))\n#else\ntime_t timegm(struct tm *tm);\n#define NEED_TIMEGM\n#endif\n\n\n#if !defined(fileno)\n#define fileno(x) (_fileno(x))\n#endif /* !fileno MINGW #defines fileno */\n\ntypedef HANDLE pthread_mutex_t;\ntypedef DWORD pthread_key_t;\ntypedef HANDLE pthread_t;\ntypedef struct {\n\tCRITICAL_SECTION threadIdSec;\n\tstruct mg_workerTLS *waiting_thread; /* The chain of threads */\n} pthread_cond_t;\n\n#if !defined(__clockid_t_defined)\ntypedef DWORD clockid_t;\n#endif\n#if !defined(CLOCK_MONOTONIC)\n#define CLOCK_MONOTONIC (1)\n#endif\n#if !defined(CLOCK_REALTIME)\n#define CLOCK_REALTIME (2)\n#endif\n#if !defined(CLOCK_THREAD)\n#define CLOCK_THREAD (3)\n#endif\n#if !defined(CLOCK_PROCESS)\n#define CLOCK_PROCESS (4)\n#endif\n\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1900)\n#define _TIMESPEC_DEFINED\n#endif\n#if !defined(_TIMESPEC_DEFINED)\nstruct timespec {\n\ttime_t tv_sec; /* seconds */\n\tlong tv_nsec;  /* nanoseconds */\n};\n#endif\n\n#if !defined(WIN_PTHREADS_TIME_H)\n#define MUST_IMPLEMENT_CLOCK_GETTIME\n#endif\n\n#if defined(MUST_IMPLEMENT_CLOCK_GETTIME)\n#define clock_gettime mg_clock_gettime\nstatic int\nclock_gettime(clockid_t clk_id, struct timespec *tp)\n{\n\tFILETIME ft;\n\tULARGE_INTEGER li, li2;\n\tBOOL ok = FALSE;\n\tdouble d;\n\tstatic double perfcnt_per_sec = 0.0;\n\tstatic BOOL initialized = FALSE;\n\n\tif (!initialized) {\n\t\tQueryPerformanceFrequency((LARGE_INTEGER *)&li);\n\t\tperfcnt_per_sec = 1.0 / li.QuadPart;\n\t\tinitialized = TRUE;\n\t}\n\n\tif (tp) {\n\t\tmemset(tp, 0, sizeof(*tp));\n\n\t\tif (clk_id == CLOCK_REALTIME) {\n\n\t\t\t/* BEGIN: CLOCK_REALTIME = wall clock (date and time) */\n\t\t\tGetSystemTimeAsFileTime(&ft);\n\t\t\tli.LowPart = ft.dwLowDateTime;\n\t\t\tli.HighPart = ft.dwHighDateTime;\n\t\t\tli.QuadPart -= 116444736000000000; /* 1.1.1970 in filedate */\n\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_REALTIME */\n\n\t\t} else if (clk_id == CLOCK_MONOTONIC) {\n\n\t\t\t/* BEGIN: CLOCK_MONOTONIC = stopwatch (time differences) */\n\t\t\tQueryPerformanceCounter((LARGE_INTEGER *)&li);\n\t\t\td = li.QuadPart * perfcnt_per_sec;\n\t\t\ttp->tv_sec = (time_t)d;\n\t\t\td -= (double)tp->tv_sec;\n\t\t\ttp->tv_nsec = (long)(d * 1.0E9);\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_MONOTONIC */\n\n\t\t} else if (clk_id == CLOCK_THREAD) {\n\n\t\t\t/* BEGIN: CLOCK_THREAD = CPU usage of thread */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetThreadTimes(GetCurrentThread(),\n\t\t\t                   &t_create,\n\t\t\t                   &t_exit,\n\t\t\t                   &t_kernel,\n\t\t\t                   &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_THREAD */\n\n\t\t} else if (clk_id == CLOCK_PROCESS) {\n\n\t\t\t/* BEGIN: CLOCK_PROCESS = CPU usage of process */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetProcessTimes(GetCurrentProcess(),\n\t\t\t                    &t_create,\n\t\t\t                    &t_exit,\n\t\t\t                    &t_kernel,\n\t\t\t                    &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_PROCESS */\n\n\t\t} else {\n\n\t\t\t/* BEGIN: unknown clock */\n\t\t\t/* ok = FALSE; already set by init */\n\t\t\t/* END: unknown clock */\n\t\t}\n\t}\n\n\treturn ok ? 0 : -1;\n}\n#endif\n\n\n#define pid_t HANDLE /* MINGW typedefs pid_t to int. Using #define here. */\n\nstatic int pthread_mutex_lock(pthread_mutex_t *);\nstatic int pthread_mutex_unlock(pthread_mutex_t *);\nstatic void path_to_unicode(const struct mg_connection *conn,\n                            const char *path,\n                            wchar_t *wbuf,\n                            size_t wbuf_len);\n\n/* All file operations need to be rewritten to solve #246. */\n\nstruct mg_file;\n\nstatic const char *\nmg_fgets(char *buf, size_t size, struct mg_file *filep, char **p);\n\n\n/* POSIX dirent interface */\nstruct dirent {\n\tchar d_name[PATH_MAX];\n};\n\ntypedef struct DIR {\n\tHANDLE handle;\n\tWIN32_FIND_DATAW info;\n\tstruct dirent result;\n} DIR;\n\n#if defined(_WIN32)\n#if !defined(HAVE_POLL)\nstruct pollfd {\n\tSOCKET fd;\n\tshort events;\n\tshort revents;\n};\n#endif\n#endif\n\n/* Mark required libraries */\n#if defined(_MSC_VER)\n#pragma comment(lib, \"Ws2_32.lib\")\n#endif\n\n#else /* defined(_WIN32) - WINDOWS vs UNIX include block */\n\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/poll.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/utsname.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <netdb.h>\n#include <netinet/tcp.h>\ntypedef const void *SOCK_OPT_TYPE;\n\n#if defined(ANDROID)\ntypedef unsigned short int in_port_t;\n#endif\n\n#include <pwd.h>\n#include <unistd.h>\n#include <grp.h>\n#include <dirent.h>\n#define vsnprintf_impl vsnprintf\n\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n#include <dlfcn.h>\n#endif\n#include <pthread.h>\n#if defined(__MACH__)\n#define SSL_LIB \"libssl.dylib\"\n#define CRYPTO_LIB \"libcrypto.dylib\"\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB \"libssl.so\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libcrypto.so\"\n#endif\n#endif\n#if !defined(O_BINARY)\n#define O_BINARY (0)\n#endif /* O_BINARY */\n#define closesocket(a) (close(a))\n#define mg_mkdir(conn, path, mode) (mkdir(path, mode))\n#define mg_remove(conn, x) (remove(x))\n#define mg_sleep(x) (usleep((x)*1000))\n#define mg_opendir(conn, x) (opendir(x))\n#define mg_closedir(x) (closedir(x))\n#define mg_readdir(x) (readdir(x))\n#define ERRNO (errno)\n#define INVALID_SOCKET (-1)\n#define INT64_FMT PRId64\n#define UINT64_FMT PRIu64\ntypedef int SOCKET;\n#define WINCDECL\n\n#if defined(__hpux)\n/* HPUX 11 does not have monotonic, fall back to realtime */\n#if !defined(CLOCK_MONOTONIC)\n#define CLOCK_MONOTONIC CLOCK_REALTIME\n#endif\n\n/* HPUX defines socklen_t incorrectly as size_t which is 64bit on\n * Itanium.  Without defining _XOPEN_SOURCE or _XOPEN_SOURCE_EXTENDED\n * the prototypes use int* rather than socklen_t* which matches the\n * actual library expectation.  When called with the wrong size arg\n * accept() returns a zero client inet addr and check_acl() always\n * fails.  Since socklen_t is widely used below, just force replace\n * their typedef with int. - DTL\n */\n#define socklen_t int\n#endif /* hpux */\n\n#endif /* defined(_WIN32) - WINDOWS vs UNIX include block */\n\n/* Maximum queue length for pending connections. This value is passed as\n * parameter to the \"listen\" socket call. */\n#if !defined(SOMAXCONN)\n/* This symbol may be defined in winsock2.h so this must after that include */\n#define SOMAXCONN (100) /* in pending connections (count) */\n#endif\n\n/* In case our C library is missing \"timegm\", provide an implementation */\n#if defined(NEED_TIMEGM)\nstatic inline int\nis_leap(int y)\n{\n\treturn (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;\n}\n\nstatic inline int\ncount_leap(int y)\n{\n\treturn (y - 1969) / 4 - (y - 1901) / 100 + (y - 1601) / 400;\n}\n\ntime_t\ntimegm(struct tm *tm)\n{\n\tstatic const unsigned short ydays[] = {\n\t    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\n\tint year = tm->tm_year + 1900;\n\tint mon = tm->tm_mon;\n\tint mday = tm->tm_mday - 1;\n\tint hour = tm->tm_hour;\n\tint min = tm->tm_min;\n\tint sec = tm->tm_sec;\n\n\tif (year < 1970 || mon < 0 || mon > 11 || mday < 0\n\t    || (mday >= ydays[mon + 1] - ydays[mon]\n\t                    + (mon == 1 && is_leap(year) ? 1 : 0)) || hour < 0\n\t    || hour > 23\n\t    || min < 0\n\t    || min > 59\n\t    || sec < 0\n\t    || sec > 60)\n\t\treturn -1;\n\n\ttime_t res = year - 1970;\n\tres *= 365;\n\tres += mday;\n\tres += ydays[mon] + (mon > 1 && is_leap(year) ? 1 : 0);\n\tres += count_leap(year);\n\n\tres *= 24;\n\tres += hour;\n\tres *= 60;\n\tres += min;\n\tres *= 60;\n\tres += sec;\n\treturn res;\n}\n#endif /* NEED_TIMEGM */\n\n\n/* va_copy should always be a macro, C99 and C++11 - DTL */\n#if !defined(va_copy)\n#define va_copy(x, y) ((x) = (y))\n#endif\n\n\n#if defined(_WIN32)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nstatic CRITICAL_SECTION global_log_file_lock;\n\nFUNCTION_MAY_BE_UNUSED\nstatic DWORD\npthread_self(void)\n{\n\treturn GetCurrentThreadId();\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_key_create(\n    pthread_key_t *key,\n    void (*_ignored)(void *) /* destructor not supported for Windows */\n    )\n{\n\t(void)_ignored;\n\n\tif ((key != 0)) {\n\t\t*key = TlsAlloc();\n\t\treturn (*key != TLS_OUT_OF_INDEXES) ? 0 : -1;\n\t}\n\treturn -2;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_key_delete(pthread_key_t key)\n{\n\treturn TlsFree(key) ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_setspecific(pthread_key_t key, void *value)\n{\n\treturn TlsSetValue(key, value) ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void *\npthread_getspecific(pthread_key_t key)\n{\n\treturn TlsGetValue(key);\n}\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\nstatic struct pthread_mutex_undefined_struct *pthread_mutex_attr = NULL;\n#else\nstatic pthread_mutexattr_t pthread_mutex_attr;\n#endif /* _WIN32 */\n\n\n#if defined(_WIN32_WCE)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic time_t\ntime(time_t *ptime)\n{\n\ttime_t t;\n\tSYSTEMTIME st;\n\tFILETIME ft;\n\n\tGetSystemTime(&st);\n\tSystemTimeToFileTime(&st, &ft);\n\tt = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);\n\n\tif (ptime != NULL) {\n\t\t*ptime = t;\n\t}\n\n\treturn t;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\nlocaltime_s(const time_t *ptime, struct tm *ptm)\n{\n\tint64_t t = ((int64_t)*ptime) * RATE_DIFF + EPOCH_DIFF;\n\tFILETIME ft, lft;\n\tSYSTEMTIME st;\n\tTIME_ZONE_INFORMATION tzinfo;\n\n\tif (ptm == NULL) {\n\t\treturn NULL;\n\t}\n\n\t*(int64_t *)&ft = t;\n\tFileTimeToLocalFileTime(&ft, &lft);\n\tFileTimeToSystemTime(&lft, &st);\n\tptm->tm_year = st.wYear - 1900;\n\tptm->tm_mon = st.wMonth - 1;\n\tptm->tm_wday = st.wDayOfWeek;\n\tptm->tm_mday = st.wDay;\n\tptm->tm_hour = st.wHour;\n\tptm->tm_min = st.wMinute;\n\tptm->tm_sec = st.wSecond;\n\tptm->tm_yday = 0; /* hope nobody uses this */\n\tptm->tm_isdst =\n\t    (GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT) ? 1 : 0;\n\n\treturn ptm;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\ngmtime_s(const time_t *ptime, struct tm *ptm)\n{\n\t/* FIXME(lsm): fix this. */\n\treturn localtime_s(ptime, ptm);\n}\n\n\nstatic int mg_atomic_inc(volatile int *addr);\nstatic struct tm tm_array[MAX_WORKER_THREADS];\nstatic int tm_index = 0;\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\nlocaltime(const time_t *ptime)\n{\n\tint i = mg_atomic_inc(&tm_index) % (sizeof(tm_array) / sizeof(tm_array[0]));\n\treturn localtime_s(ptime, tm_array + i);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\ngmtime(const time_t *ptime)\n{\n\tint i = mg_atomic_inc(&tm_index) % ARRAY_SIZE(tm_array);\n\treturn gmtime_s(ptime, tm_array + i);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic size_t\nstrftime(char *dst, size_t dst_size, const char *fmt, const struct tm *tm)\n{\n\t/* TODO: (void)mg_snprintf(NULL, dst, dst_size, \"implement strftime()\n\t * for WinCE\"); */\n\treturn 0;\n}\n\n#define _beginthreadex(psec, stack, func, prm, flags, ptid)                    \\\n\t(uintptr_t) CreateThread(psec, stack, func, prm, flags, ptid)\n\n#define remove(f) mg_remove(NULL, f)\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nrename(const char *a, const char *b)\n{\n\twchar_t wa[W_PATH_MAX];\n\twchar_t wb[W_PATH_MAX];\n\tpath_to_unicode(NULL, a, wa, ARRAY_SIZE(wa));\n\tpath_to_unicode(NULL, b, wb, ARRAY_SIZE(wb));\n\n\treturn MoveFileW(wa, wb) ? 0 : -1;\n}\n\n\nstruct stat {\n\tint64_t st_size;\n\ttime_t st_mtime;\n};\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nstat(const char *name, struct stat *st)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tWIN32_FILE_ATTRIBUTE_DATA attr;\n\ttime_t creation_time, write_time;\n\n\tpath_to_unicode(NULL, name, wbuf, ARRAY_SIZE(wbuf));\n\tmemset(&attr, 0, sizeof(attr));\n\n\tGetFileAttributesExW(wbuf, GetFileExInfoStandard, &attr);\n\tst->st_size =\n\t    (((int64_t)attr.nFileSizeHigh) << 32) + (int64_t)attr.nFileSizeLow;\n\n\twrite_time = SYS2UNIX_TIME(attr.ftLastWriteTime.dwLowDateTime,\n\t                           attr.ftLastWriteTime.dwHighDateTime);\n\tcreation_time = SYS2UNIX_TIME(attr.ftCreationTime.dwLowDateTime,\n\t                              attr.ftCreationTime.dwHighDateTime);\n\n\tif (creation_time > write_time) {\n\t\tst->st_mtime = creation_time;\n\t} else {\n\t\tst->st_mtime = write_time;\n\t}\n\treturn 0;\n}\n\n#define access(x, a) 1 /* not required anyway */\n\n/* WinCE-TODO: define stat, remove, rename, _rmdir, _lseeki64 */\n/* Values from errno.h in Windows SDK (Visual Studio). */\n#define EEXIST 17\n#define EACCES 13\n#define ENOENT 2\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n#endif /* defined(_WIN32_WCE) */\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#define GCC_VERSION                                                            \\\n\t(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\nstatic pthread_mutex_t global_lock_mutex;\n\n\n#if defined(_WIN32)\n/* Forward declaration for Windows */\nFUNCTION_MAY_BE_UNUSED\nstatic int pthread_mutex_lock(pthread_mutex_t *mutex);\n\nFUNCTION_MAY_BE_UNUSED\nstatic int pthread_mutex_unlock(pthread_mutex_t *mutex);\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nmg_global_lock(void)\n{\n\t(void)pthread_mutex_lock(&global_lock_mutex);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nmg_global_unlock(void)\n{\n\t(void)pthread_mutex_unlock(&global_lock_mutex);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_atomic_inc(volatile int *addr)\n{\n\tint ret;\n#if defined(_WIN32) && !defined(NO_ATOMICS)\n\t/* Depending on the SDK, this function uses either\n\t * (volatile unsigned int *) or (volatile LONG *),\n\t * so whatever you use, the other SDK is likely to raise a warning. */\n\tret = InterlockedIncrement((volatile long *)addr);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_add_and_fetch(addr, 1);\n#else\n\tmg_global_lock();\n\tret = (++(*addr));\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_atomic_dec(volatile int *addr)\n{\n\tint ret;\n#if defined(_WIN32) && !defined(NO_ATOMICS)\n\t/* Depending on the SDK, this function uses either\n\t * (volatile unsigned int *) or (volatile LONG *),\n\t * so whatever you use, the other SDK is likely to raise a warning. */\n\tret = InterlockedDecrement((volatile long *)addr);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_sub_and_fetch(addr, 1);\n#else\n\tmg_global_lock();\n\tret = (--(*addr));\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n\n\n#if defined(USE_SERVER_STATS)\nstatic int64_t\nmg_atomic_add(volatile int64_t *addr, int64_t value)\n{\n\tint64_t ret;\n#if defined(_WIN64) && !defined(NO_ATOMICS)\n\tret = InterlockedAdd64(addr, value);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_add_and_fetch(addr, value);\n#else\n\tmg_global_lock();\n\t*addr += value;\n\tret = (*addr);\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n#endif\n\n\n#if defined(__GNUC__)\n/* Show no warning in case system functions are not used. */\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic pop\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic pop\n#endif\n\n\n#if defined(USE_SERVER_STATS)\n\nstruct mg_memory_stat {\n\tvolatile int64_t totalMemUsed;\n\tvolatile int64_t maxMemUsed;\n\tvolatile int blockCount;\n};\n\n\nstatic struct mg_memory_stat *get_memory_stat(struct mg_context *ctx);\n\n\nstatic void *\nmg_malloc_ex(size_t size,\n             struct mg_context *ctx,\n             const char *file,\n             unsigned line)\n{\n\tvoid *data = malloc(size + 2 * sizeof(uintptr_t));\n\tvoid *memory = 0;\n\tstruct mg_memory_stat *mstat = get_memory_stat(ctx);\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (data) {\n\t\tint64_t mmem = mg_atomic_add(&mstat->totalMemUsed, (int64_t)size);\n\t\tif (mmem > mstat->maxMemUsed) {\n\t\t\t/* could use atomic compare exchange, but this\n\t\t\t * seems overkill for statistics data */\n\t\t\tmstat->maxMemUsed = mmem;\n\t\t}\n\n\t\tmg_atomic_inc(&mstat->blockCount);\n\t\t((uintptr_t *)data)[0] = size;\n\t\t((uintptr_t *)data)[1] = (uintptr_t)mstat;\n\t\tmemory = (void *)(((char *)data) + 2 * sizeof(uintptr_t));\n\t}\n\n#if defined(MEMORY_DEBUGGING)\n\tsprintf(mallocStr,\n\t        \"MEM: %p %5lu alloc   %7lu %4lu --- %s:%u\\n\",\n\t        memory,\n\t        (unsigned long)size,\n\t        (unsigned long)mstat->totalMemUsed,\n\t        (unsigned long)mstat->blockCount,\n\t        file,\n\t        line);\n#if defined(_WIN32)\n\tOutputDebugStringA(mallocStr);\n#else\n\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\n\treturn memory;\n}\n\n\nstatic void *\nmg_calloc_ex(size_t count,\n             size_t size,\n             struct mg_context *ctx,\n             const char *file,\n             unsigned line)\n{\n\tvoid *data = mg_malloc_ex(size * count, ctx, file, line);\n\n\tif (data) {\n\t\tmemset(data, 0, size * count);\n\t}\n\treturn data;\n}\n\n\nstatic void\nmg_free_ex(void *memory, const char *file, unsigned line)\n{\n\tvoid *data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));\n\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (memory) {\n\t\tuintptr_t size = ((uintptr_t *)data)[0];\n\t\tstruct mg_memory_stat *mstat =\n\t\t    (struct mg_memory_stat *)(((uintptr_t *)data)[1]);\n\t\tmg_atomic_add(&mstat->totalMemUsed, -(int64_t)size);\n\t\tmg_atomic_dec(&mstat->blockCount);\n#if defined(MEMORY_DEBUGGING)\n\t\tsprintf(mallocStr,\n\t\t        \"MEM: %p %5lu free    %7lu %4lu --- %s:%u\\n\",\n\t\t        memory,\n\t\t        (unsigned long)size,\n\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t        (unsigned long)mstat->blockCount,\n\t\t        file,\n\t\t        line);\n#if defined(_WIN32)\n\t\tOutputDebugStringA(mallocStr);\n#else\n\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\tfree(data);\n\t}\n}\n\n\nstatic void *\nmg_realloc_ex(void *memory,\n              size_t newsize,\n              struct mg_context *ctx,\n              const char *file,\n              unsigned line)\n{\n\tvoid *data;\n\tvoid *_realloc;\n\tuintptr_t oldsize;\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (newsize) {\n\t\tif (memory) {\n\t\t\t/* Reallocate existing block */\n\t\t\tstruct mg_memory_stat *mstat;\n\t\t\tdata = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));\n\t\t\toldsize = ((uintptr_t *)data)[0];\n\t\t\tmstat = (struct mg_memory_stat *)((uintptr_t *)data)[1];\n\t\t\t_realloc = realloc(data, newsize + 2 * sizeof(uintptr_t));\n\t\t\tif (_realloc) {\n\t\t\t\tdata = _realloc;\n\t\t\t\tmg_atomic_add(&mstat->totalMemUsed, -(int64_t)oldsize);\n#if defined(MEMORY_DEBUGGING)\n\t\t\t\tsprintf(mallocStr,\n\t\t\t\t        \"MEM: %p %5lu r-free  %7lu %4lu --- %s:%u\\n\",\n\t\t\t\t        memory,\n\t\t\t\t        (unsigned long)oldsize,\n\t\t\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t\t\t        (unsigned long)mstat->blockCount,\n\t\t\t\t        file,\n\t\t\t\t        line);\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(mallocStr);\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\t\t\tmg_atomic_add(&mstat->totalMemUsed, (int64_t)newsize);\n#if defined(MEMORY_DEBUGGING)\n\t\t\t\tsprintf(mallocStr,\n\t\t\t\t        \"MEM: %p %5lu r-alloc %7lu %4lu --- %s:%u\\n\",\n\t\t\t\t        memory,\n\t\t\t\t        (unsigned long)newsize,\n\t\t\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t\t\t        (unsigned long)mstat->blockCount,\n\t\t\t\t        file,\n\t\t\t\t        line);\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(mallocStr);\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\t\t\t*(uintptr_t *)data = newsize;\n\t\t\t\tdata = (void *)(((char *)data) + 2 * sizeof(uintptr_t));\n\t\t\t} else {\n#if defined(MEMORY_DEBUGGING)\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(\"MEM: realloc failed\\n\");\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", \"MEM: realloc failed\\n\");\n#endif\n#endif\n\t\t\t\treturn _realloc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Allocate new block */\n\t\t\tdata = mg_malloc_ex(newsize, ctx, file, line);\n\t\t}\n\t} else {\n\t\t/* Free existing block */\n\t\tdata = 0;\n\t\tmg_free_ex(memory, file, line);\n\t}\n\n\treturn data;\n}\n\n#define mg_malloc(a) mg_malloc_ex(a, NULL, __FILE__, __LINE__)\n#define mg_calloc(a, b) mg_calloc_ex(a, b, NULL, __FILE__, __LINE__)\n#define mg_realloc(a, b) mg_realloc_ex(a, b, NULL, __FILE__, __LINE__)\n#define mg_free(a) mg_free_ex(a, __FILE__, __LINE__)\n\n#define mg_malloc_ctx(a, c) mg_malloc_ex(a, c, __FILE__, __LINE__)\n#define mg_calloc_ctx(a, b, c) mg_calloc_ex(a, b, c, __FILE__, __LINE__)\n#define mg_realloc_ctx(a, b, c) mg_realloc_ex(a, b, c, __FILE__, __LINE__)\n\n#else /* USE_SERVER_STATS */\n\nstatic __inline void *\nmg_malloc(size_t a)\n{\n\treturn malloc(a);\n}\n\nstatic __inline void *\nmg_calloc(size_t a, size_t b)\n{\n\treturn calloc(a, b);\n}\n\nstatic __inline void *\nmg_realloc(void *a, size_t b)\n{\n\treturn realloc(a, b);\n}\n\nstatic __inline void\nmg_free(void *a)\n{\n\tfree(a);\n}\n\n#define mg_malloc_ctx(a, c) mg_malloc(a)\n#define mg_calloc_ctx(a, b, c) mg_calloc(a, b)\n#define mg_realloc_ctx(a, b, c) mg_realloc(a, b)\n#define mg_free_ctx(a, c) mg_free(a)\n\n#endif /* USE_SERVER_STATS */\n\n\nstatic void mg_vsnprintf(const struct mg_connection *conn,\n                         int *truncated,\n                         char *buf,\n                         size_t buflen,\n                         const char *fmt,\n                         va_list ap);\n\nstatic void mg_snprintf(const struct mg_connection *conn,\n                        int *truncated,\n                        char *buf,\n                        size_t buflen,\n                        PRINTF_FORMAT_STRING(const char *fmt),\n                        ...) PRINTF_ARGS(5, 6);\n\n/* This following lines are just meant as a reminder to use the mg-functions\n * for memory management */\n#if defined(malloc)\n#undef malloc\n#endif\n#if defined(calloc)\n#undef calloc\n#endif\n#if defined(realloc)\n#undef realloc\n#endif\n#if defined(free)\n#undef free\n#endif\n#if defined(snprintf)\n#undef snprintf\n#endif\n#if defined(vsnprintf)\n#undef vsnprintf\n#endif\n#define malloc DO_NOT_USE_THIS_FUNCTION__USE_mg_malloc\n#define calloc DO_NOT_USE_THIS_FUNCTION__USE_mg_calloc\n#define realloc DO_NOT_USE_THIS_FUNCTION__USE_mg_realloc\n#define free DO_NOT_USE_THIS_FUNCTION__USE_mg_free\n#define snprintf DO_NOT_USE_THIS_FUNCTION__USE_mg_snprintf\n#if defined(_WIN32)\n/* vsnprintf must not be used in any system,\n * but this define only works well for Windows. */\n#define vsnprintf DO_NOT_USE_THIS_FUNCTION__USE_mg_vsnprintf\n#endif\n\n\n/* mg_init_library counter */\nstatic int mg_init_library_called = 0;\n\n#if !defined(NO_SSL)\nstatic int mg_ssl_initialized = 0;\n#endif\n\nstatic pthread_key_t sTlsKey; /* Thread local storage index */\nstatic int thread_idx_max = 0;\n\n#if defined(MG_LEGACY_INTERFACE)\n#define MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE\n#endif\n\nstruct mg_workerTLS {\n\tint is_master;\n\tunsigned long thread_idx;\n#if defined(_WIN32)\n\tHANDLE pthread_cond_helper_mutex;\n\tstruct mg_workerTLS *next_waiting_thread;\n#endif\n#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE)\n\tchar txtbuf[4];\n#endif\n};\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\n\n/* Get a unique thread ID as unsigned long, independent from the data type\n * of thread IDs defined by the operating system API.\n * If two calls to mg_current_thread_id  return the same value, they calls\n * are done from the same thread. If they return different values, they are\n * done from different threads. (Provided this function is used in the same\n * process context and threads are not repeatedly created and deleted, but\n * CivetWeb does not do that).\n * This function must match the signature required for SSL id callbacks:\n * CRYPTO_set_id_callback\n */\nFUNCTION_MAY_BE_UNUSED\nstatic unsigned long\nmg_current_thread_id(void)\n{\n#if defined(_WIN32)\n\treturn GetCurrentThreadId();\n#else\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n/* For every compiler, either \"sizeof(pthread_t) > sizeof(unsigned long)\"\n * or not, so one of the two conditions will be unreachable by construction.\n * Unfortunately the C standard does not define a way to check this at\n * compile time, since the #if preprocessor conditions can not use the sizeof\n * operator as an argument. */\n#endif\n\n\tif (sizeof(pthread_t) > sizeof(unsigned long)) {\n\t\t/* This is the problematic case for CRYPTO_set_id_callback:\n\t\t * The OS pthread_t can not be cast to unsigned long. */\n\t\tstruct mg_workerTLS *tls =\n\t\t    (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\t\tif (tls == NULL) {\n\t\t\t/* SSL called from an unknown thread: Create some thread index.\n\t\t\t */\n\t\t\ttls = (struct mg_workerTLS *)mg_malloc(sizeof(struct mg_workerTLS));\n\t\t\ttls->is_master = -2; /* -2 means \"3rd party thread\" */\n\t\t\ttls->thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n\t\t\tpthread_setspecific(sTlsKey, tls);\n\t\t}\n\t\treturn tls->thread_idx;\n\t} else {\n\t\t/* pthread_t may be any data type, so a simple cast to unsigned long\n\t\t * can rise a warning/error, depending on the platform.\n\t\t * Here memcpy is used as an anything-to-anything cast. */\n\t\tunsigned long ret = 0;\n\t\tpthread_t t = pthread_self();\n\t\tmemcpy(&ret, &t, sizeof(pthread_t));\n\t\treturn ret;\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n#endif\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic uint64_t\nmg_get_current_time_ns(void)\n{\n\tstruct timespec tsnow;\n\tclock_gettime(CLOCK_REALTIME, &tsnow);\n\treturn (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;\n}\n\n\n#if defined(__GNUC__)\n/* Show no warning in case system functions are not used. */\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic pop\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic pop\n#endif\n\n\n#if defined(NEED_DEBUG_TRACE_FUNC)\nstatic void\nDEBUG_TRACE_FUNC(const char *func, unsigned line, const char *fmt, ...)\n{\n\tva_list args;\n\tuint64_t nsnow;\n\tstatic uint64_t nslast;\n\tstruct timespec tsnow;\n\n\t/* Get some operating system independent thread id */\n\tunsigned long thread_id = mg_current_thread_id();\n\n\tclock_gettime(CLOCK_REALTIME, &tsnow);\n\tnsnow = ((uint64_t)tsnow.tv_sec) * ((uint64_t)1000000000)\n\t        + ((uint64_t)tsnow.tv_nsec);\n\n\tif (!nslast) {\n\t\tnslast = nsnow;\n\t}\n\n\tflockfile(stdout);\n\tprintf(\"*** %lu.%09lu %12\" INT64_FMT \" %lu %s:%u: \",\n\t       (unsigned long)tsnow.tv_sec,\n\t       (unsigned long)tsnow.tv_nsec,\n\t       nsnow - nslast,\n\t       thread_id,\n\t       func,\n\t       line);\n\tva_start(args, fmt);\n\tvprintf(fmt, args);\n\tva_end(args);\n\tputchar('\\n');\n\tfflush(stdout);\n\tfunlockfile(stdout);\n\tnslast = nsnow;\n}\n#endif /* NEED_DEBUG_TRACE_FUNC */\n\n\n#define MD5_STATIC static\n#include \"md5.inl\"\n\n/* Darwin prior to 7.0 and Win32 do not have socklen_t */\n#if defined(NO_SOCKLEN_T)\ntypedef int socklen_t;\n#endif /* NO_SOCKLEN_T */\n\n#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */\n\n#if !defined(MSG_NOSIGNAL)\n#define MSG_NOSIGNAL (0)\n#endif\n\n\n#if defined(NO_SSL)\ntypedef struct SSL SSL; /* dummy for SSL argument to push/pull */\ntypedef struct SSL_CTX SSL_CTX;\n#else\n#if defined(NO_SSL_DL)\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <openssl/engine.h>\n#include <openssl/conf.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <openssl/opensslv.h>\n\n#if defined(WOLFSSL_VERSION)\n/* Additional defines for WolfSSL, see\n * https://github.com/civetweb/civetweb/issues/583 */\n#include \"wolfssl_extras.inl\"\n#endif\n\n#else\n\n/* SSL loaded dynamically from DLL.\n * I put the prototypes here to be independent from OpenSSL source\n * installation. */\n\ntypedef struct ssl_st SSL;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef struct ssl_ctx_st SSL_CTX;\ntypedef struct x509_store_ctx_st X509_STORE_CTX;\ntypedef struct x509_name X509_NAME;\ntypedef struct asn1_integer ASN1_INTEGER;\ntypedef struct bignum BIGNUM;\ntypedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;\ntypedef struct evp_md EVP_MD;\ntypedef struct x509 X509;\n\n\n#define SSL_CTRL_OPTIONS (32)\n#define SSL_CTRL_CLEAR_OPTIONS (77)\n#define SSL_CTRL_SET_ECDH_AUTO (94)\n\n#define OPENSSL_INIT_NO_LOAD_SSL_STRINGS 0x00100000L\n#define OPENSSL_INIT_LOAD_SSL_STRINGS 0x00200000L\n#define OPENSSL_INIT_LOAD_CRYPTO_STRINGS 0x00000002L\n\n#define SSL_VERIFY_NONE (0)\n#define SSL_VERIFY_PEER (1)\n#define SSL_VERIFY_FAIL_IF_NO_PEER_CERT (2)\n#define SSL_VERIFY_CLIENT_ONCE (4)\n#define SSL_OP_ALL ((long)(0x80000BFFUL))\n#define SSL_OP_NO_SSLv2 (0x01000000L)\n#define SSL_OP_NO_SSLv3 (0x02000000L)\n#define SSL_OP_NO_TLSv1 (0x04000000L)\n#define SSL_OP_NO_TLSv1_2 (0x08000000L)\n#define SSL_OP_NO_TLSv1_1 (0x10000000L)\n#define SSL_OP_SINGLE_DH_USE (0x00100000L)\n#define SSL_OP_CIPHER_SERVER_PREFERENCE (0x00400000L)\n#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (0x00010000L)\n#define SSL_OP_NO_COMPRESSION (0x00020000L)\n\n#define SSL_CB_HANDSHAKE_START (0x10)\n#define SSL_CB_HANDSHAKE_DONE (0x20)\n\n#define SSL_ERROR_NONE (0)\n#define SSL_ERROR_SSL (1)\n#define SSL_ERROR_WANT_READ (2)\n#define SSL_ERROR_WANT_WRITE (3)\n#define SSL_ERROR_WANT_X509_LOOKUP (4)\n#define SSL_ERROR_SYSCALL (5) /* see errno */\n#define SSL_ERROR_ZERO_RETURN (6)\n#define SSL_ERROR_WANT_CONNECT (7)\n#define SSL_ERROR_WANT_ACCEPT (8)\n\n#define TLSEXT_TYPE_server_name (0)\n#define TLSEXT_NAMETYPE_host_name (0)\n#define SSL_TLSEXT_ERR_OK (0)\n#define SSL_TLSEXT_ERR_ALERT_WARNING (1)\n#define SSL_TLSEXT_ERR_ALERT_FATAL (2)\n#define SSL_TLSEXT_ERR_NOACK (3)\n\nstruct ssl_func {\n\tconst char *name;  /* SSL function name */\n\tvoid (*ptr)(void); /* Function pointer */\n};\n\n\n#if defined(OPENSSL_API_1_1)\n\n#define SSL_free (*(void (*)(SSL *))ssl_sw[0].ptr)\n#define SSL_accept (*(int (*)(SSL *))ssl_sw[1].ptr)\n#define SSL_connect (*(int (*)(SSL *))ssl_sw[2].ptr)\n#define SSL_read (*(int (*)(SSL *, void *, int))ssl_sw[3].ptr)\n#define SSL_write (*(int (*)(SSL *, const void *, int))ssl_sw[4].ptr)\n#define SSL_get_error (*(int (*)(SSL *, int))ssl_sw[5].ptr)\n#define SSL_set_fd (*(int (*)(SSL *, SOCKET))ssl_sw[6].ptr)\n#define SSL_new (*(SSL * (*)(SSL_CTX *))ssl_sw[7].ptr)\n#define SSL_CTX_new (*(SSL_CTX * (*)(SSL_METHOD *))ssl_sw[8].ptr)\n#define TLS_server_method (*(SSL_METHOD * (*)(void))ssl_sw[9].ptr)\n#define OPENSSL_init_ssl                                                       \\\n\t(*(int (*)(uint64_t opts,                                                  \\\n\t           const OPENSSL_INIT_SETTINGS *settings))ssl_sw[10].ptr)\n#define SSL_CTX_use_PrivateKey_file                                            \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file                                           \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb                                          \\\n\t(*(void (*)(SSL_CTX *, mg_callback_t))ssl_sw[13].ptr)\n#define SSL_CTX_free (*(void (*)(SSL_CTX *))ssl_sw[14].ptr)\n#define SSL_CTX_use_certificate_chain_file                                     \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[15].ptr)\n#define TLS_client_method (*(SSL_METHOD * (*)(void))ssl_sw[16].ptr)\n#define SSL_pending (*(int (*)(SSL *))ssl_sw[17].ptr)\n#define SSL_CTX_set_verify                                                     \\\n\t(*(void (*)(SSL_CTX *,                                                     \\\n\t            int,                                                           \\\n\t            int (*verify_callback)(int, X509_STORE_CTX *)))ssl_sw[18].ptr)\n#define SSL_shutdown (*(int (*)(SSL *))ssl_sw[19].ptr)\n#define SSL_CTX_load_verify_locations                                          \\\n\t(*(int (*)(SSL_CTX *, const char *, const char *))ssl_sw[20].ptr)\n#define SSL_CTX_set_default_verify_paths (*(int (*)(SSL_CTX *))ssl_sw[21].ptr)\n#define SSL_CTX_set_verify_depth (*(void (*)(SSL_CTX *, int))ssl_sw[22].ptr)\n#define SSL_get_peer_certificate (*(X509 * (*)(SSL *))ssl_sw[23].ptr)\n#define SSL_get_version (*(const char *(*)(SSL *))ssl_sw[24].ptr)\n#define SSL_get_current_cipher (*(SSL_CIPHER * (*)(SSL *))ssl_sw[25].ptr)\n#define SSL_CIPHER_get_name                                                    \\\n\t(*(const char *(*)(const SSL_CIPHER *))ssl_sw[26].ptr)\n#define SSL_CTX_check_private_key (*(int (*)(SSL_CTX *))ssl_sw[27].ptr)\n#define SSL_CTX_set_session_id_context                                         \\\n\t(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[28].ptr)\n#define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[29].ptr)\n#define SSL_CTX_set_cipher_list                                                \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[30].ptr)\n#define SSL_CTX_set_options                                                    \\\n\t(*(unsigned long (*)(SSL_CTX *, unsigned long))ssl_sw[31].ptr)\n#define SSL_CTX_set_info_callback                                              \\\n\t(*(void (*)(SSL_CTX * ctx,                                                 \\\n\t            void (*callback)(SSL * s, int, int)))ssl_sw[32].ptr)\n#define SSL_get_ex_data (*(char *(*)(SSL *, int))ssl_sw[33].ptr)\n#define SSL_set_ex_data (*(void (*)(SSL *, int, char *))ssl_sw[34].ptr)\n#define SSL_CTX_callback_ctrl                                                  \\\n\t(*(long (*)(SSL_CTX *, int, void (*)(void)))ssl_sw[35].ptr)\n#define SSL_get_servername                                                     \\\n\t(*(const char *(*)(const SSL *, int type))ssl_sw[36].ptr)\n#define SSL_set_SSL_CTX (*(SSL_CTX * (*)(SSL *, SSL_CTX *))ssl_sw[37].ptr)\n\n#define SSL_CTX_clear_options(ctx, op)                                         \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_CLEAR_OPTIONS, (op), NULL)\n#define SSL_CTX_set_ecdh_auto(ctx, onoff)                                      \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, onoff, NULL)\n\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 53\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 54\n#define SSL_CTX_set_tlsext_servername_callback(ctx, cb)                        \\\n\tSSL_CTX_callback_ctrl(ctx,                                                 \\\n\t                      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,                   \\\n\t                      (void (*)(void))cb)\n#define SSL_CTX_set_tlsext_servername_arg(ctx, arg)                            \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, (void *)arg)\n\n#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)\n#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)\n\n#define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)arg))\n#define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))\n\n#define ERR_get_error (*(unsigned long (*)(void))crypto_sw[0].ptr)\n#define ERR_error_string (*(char *(*)(unsigned long, char *))crypto_sw[1].ptr)\n#define ERR_remove_state (*(void (*)(unsigned long))crypto_sw[2].ptr)\n#define CONF_modules_unload (*(void (*)(int))crypto_sw[3].ptr)\n#define X509_free (*(void (*)(X509 *))crypto_sw[4].ptr)\n#define X509_get_subject_name (*(X509_NAME * (*)(X509 *))crypto_sw[5].ptr)\n#define X509_get_issuer_name (*(X509_NAME * (*)(X509 *))crypto_sw[6].ptr)\n#define X509_NAME_oneline                                                      \\\n\t(*(char *(*)(X509_NAME *, char *, int))crypto_sw[7].ptr)\n#define X509_get_serialNumber (*(ASN1_INTEGER * (*)(X509 *))crypto_sw[8].ptr)\n#define EVP_get_digestbyname                                                   \\\n\t(*(const EVP_MD *(*)(const char *))crypto_sw[9].ptr)\n#define EVP_Digest                                                             \\\n\t(*(int (*)(                                                                \\\n\t    const void *, size_t, void *, unsigned int *, const EVP_MD *, void *)) \\\n\t      crypto_sw[10].ptr)\n#define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[11].ptr)\n#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[12].ptr)\n#define ASN1_INTEGER_to_BN                                                     \\\n\t(*(BIGNUM * (*)(const ASN1_INTEGER *ai, BIGNUM *bn))crypto_sw[13].ptr)\n#define BN_free (*(void (*)(const BIGNUM *a))crypto_sw[14].ptr)\n#define CRYPTO_free (*(void (*)(void *addr))crypto_sw[15].ptr)\n\n#define OPENSSL_free(a) CRYPTO_free(a)\n\n\n/* init_ssl_ctx() function updates this array.\n * It loads SSL library dynamically and changes NULLs to the actual addresses\n * of respective functions. The macros above (like SSL_connect()) are really\n * just calling these functions indirectly via the pointer. */\nstatic struct ssl_func ssl_sw[] = {{\"SSL_free\", NULL},\n                                   {\"SSL_accept\", NULL},\n                                   {\"SSL_connect\", NULL},\n                                   {\"SSL_read\", NULL},\n                                   {\"SSL_write\", NULL},\n                                   {\"SSL_get_error\", NULL},\n                                   {\"SSL_set_fd\", NULL},\n                                   {\"SSL_new\", NULL},\n                                   {\"SSL_CTX_new\", NULL},\n                                   {\"TLS_server_method\", NULL},\n                                   {\"OPENSSL_init_ssl\", NULL},\n                                   {\"SSL_CTX_use_PrivateKey_file\", NULL},\n                                   {\"SSL_CTX_use_certificate_file\", NULL},\n                                   {\"SSL_CTX_set_default_passwd_cb\", NULL},\n                                   {\"SSL_CTX_free\", NULL},\n                                   {\"SSL_CTX_use_certificate_chain_file\", NULL},\n                                   {\"TLS_client_method\", NULL},\n                                   {\"SSL_pending\", NULL},\n                                   {\"SSL_CTX_set_verify\", NULL},\n                                   {\"SSL_shutdown\", NULL},\n                                   {\"SSL_CTX_load_verify_locations\", NULL},\n                                   {\"SSL_CTX_set_default_verify_paths\", NULL},\n                                   {\"SSL_CTX_set_verify_depth\", NULL},\n                                   {\"SSL_get_peer_certificate\", NULL},\n                                   {\"SSL_get_version\", NULL},\n                                   {\"SSL_get_current_cipher\", NULL},\n                                   {\"SSL_CIPHER_get_name\", NULL},\n                                   {\"SSL_CTX_check_private_key\", NULL},\n                                   {\"SSL_CTX_set_session_id_context\", NULL},\n                                   {\"SSL_CTX_ctrl\", NULL},\n                                   {\"SSL_CTX_set_cipher_list\", NULL},\n                                   {\"SSL_CTX_set_options\", NULL},\n                                   {\"SSL_CTX_set_info_callback\", NULL},\n                                   {\"SSL_get_ex_data\", NULL},\n                                   {\"SSL_set_ex_data\", NULL},\n                                   {\"SSL_CTX_callback_ctrl\", NULL},\n                                   {\"SSL_get_servername\", NULL},\n                                   {\"SSL_set_SSL_CTX\", NULL},\n                                   {NULL, NULL}};\n\n\n/* Similar array as ssl_sw. These functions could be located in different\n * lib. */\nstatic struct ssl_func crypto_sw[] = {{\"ERR_get_error\", NULL},\n                                      {\"ERR_error_string\", NULL},\n                                      {\"ERR_remove_state\", NULL},\n                                      {\"CONF_modules_unload\", NULL},\n                                      {\"X509_free\", NULL},\n                                      {\"X509_get_subject_name\", NULL},\n                                      {\"X509_get_issuer_name\", NULL},\n                                      {\"X509_NAME_oneline\", NULL},\n                                      {\"X509_get_serialNumber\", NULL},\n                                      {\"EVP_get_digestbyname\", NULL},\n                                      {\"EVP_Digest\", NULL},\n                                      {\"i2d_X509\", NULL},\n                                      {\"BN_bn2hex\", NULL},\n                                      {\"ASN1_INTEGER_to_BN\", NULL},\n                                      {\"BN_free\", NULL},\n                                      {\"CRYPTO_free\", NULL},\n                                      {NULL, NULL}};\n#else\n\n#define SSL_free (*(void (*)(SSL *))ssl_sw[0].ptr)\n#define SSL_accept (*(int (*)(SSL *))ssl_sw[1].ptr)\n#define SSL_connect (*(int (*)(SSL *))ssl_sw[2].ptr)\n#define SSL_read (*(int (*)(SSL *, void *, int))ssl_sw[3].ptr)\n#define SSL_write (*(int (*)(SSL *, const void *, int))ssl_sw[4].ptr)\n#define SSL_get_error (*(int (*)(SSL *, int))ssl_sw[5].ptr)\n#define SSL_set_fd (*(int (*)(SSL *, SOCKET))ssl_sw[6].ptr)\n#define SSL_new (*(SSL * (*)(SSL_CTX *))ssl_sw[7].ptr)\n#define SSL_CTX_new (*(SSL_CTX * (*)(SSL_METHOD *))ssl_sw[8].ptr)\n#define SSLv23_server_method (*(SSL_METHOD * (*)(void))ssl_sw[9].ptr)\n#define SSL_library_init (*(int (*)(void))ssl_sw[10].ptr)\n#define SSL_CTX_use_PrivateKey_file                                            \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file                                           \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb                                          \\\n\t(*(void (*)(SSL_CTX *, mg_callback_t))ssl_sw[13].ptr)\n#define SSL_CTX_free (*(void (*)(SSL_CTX *))ssl_sw[14].ptr)\n#define SSL_load_error_strings (*(void (*)(void))ssl_sw[15].ptr)\n#define SSL_CTX_use_certificate_chain_file                                     \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[16].ptr)\n#define SSLv23_client_method (*(SSL_METHOD * (*)(void))ssl_sw[17].ptr)\n#define SSL_pending (*(int (*)(SSL *))ssl_sw[18].ptr)\n#define SSL_CTX_set_verify                                                     \\\n\t(*(void (*)(SSL_CTX *,                                                     \\\n\t            int,                                                           \\\n\t            int (*verify_callback)(int, X509_STORE_CTX *)))ssl_sw[19].ptr)\n#define SSL_shutdown (*(int (*)(SSL *))ssl_sw[20].ptr)\n#define SSL_CTX_load_verify_locations                                          \\\n\t(*(int (*)(SSL_CTX *, const char *, const char *))ssl_sw[21].ptr)\n#define SSL_CTX_set_default_verify_paths (*(int (*)(SSL_CTX *))ssl_sw[22].ptr)\n#define SSL_CTX_set_verify_depth (*(void (*)(SSL_CTX *, int))ssl_sw[23].ptr)\n#define SSL_get_peer_certificate (*(X509 * (*)(SSL *))ssl_sw[24].ptr)\n#define SSL_get_version (*(const char *(*)(SSL *))ssl_sw[25].ptr)\n#define SSL_get_current_cipher (*(SSL_CIPHER * (*)(SSL *))ssl_sw[26].ptr)\n#define SSL_CIPHER_get_name                                                    \\\n\t(*(const char *(*)(const SSL_CIPHER *))ssl_sw[27].ptr)\n#define SSL_CTX_check_private_key (*(int (*)(SSL_CTX *))ssl_sw[28].ptr)\n#define SSL_CTX_set_session_id_context                                         \\\n\t(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[29].ptr)\n#define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[30].ptr)\n#define SSL_CTX_set_cipher_list                                                \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[31].ptr)\n#define SSL_CTX_set_info_callback                                              \\\n\t(*(void (*)(SSL_CTX *, void (*callback)(SSL * s, int, int)))ssl_sw[32].ptr)\n#define SSL_get_ex_data (*(char *(*)(SSL *, int))ssl_sw[33].ptr)\n#define SSL_set_ex_data (*(void (*)(SSL *, int, char *))ssl_sw[34].ptr)\n#define SSL_CTX_callback_ctrl                                                  \\\n\t(*(long (*)(SSL_CTX *, int, void (*)(void)))ssl_sw[35].ptr)\n#define SSL_get_servername                                                     \\\n\t(*(const char *(*)(const SSL *, int type))ssl_sw[36].ptr)\n#define SSL_set_SSL_CTX (*(SSL_CTX * (*)(SSL *, SSL_CTX *))ssl_sw[37].ptr)\n\n#define SSL_CTX_set_options(ctx, op)                                           \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_OPTIONS, (op), NULL)\n#define SSL_CTX_clear_options(ctx, op)                                         \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_CLEAR_OPTIONS, (op), NULL)\n#define SSL_CTX_set_ecdh_auto(ctx, onoff)                                      \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, onoff, NULL)\n\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 53\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 54\n#define SSL_CTX_set_tlsext_servername_callback(ctx, cb)                        \\\n\tSSL_CTX_callback_ctrl(ctx,                                                 \\\n\t                      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,                   \\\n\t                      (void (*)(void))cb)\n#define SSL_CTX_set_tlsext_servername_arg(ctx, arg)                            \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, (void *)arg)\n\n#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)\n#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)\n\n#define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)arg))\n#define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))\n\n#define CRYPTO_num_locks (*(int (*)(void))crypto_sw[0].ptr)\n#define CRYPTO_set_locking_callback                                            \\\n\t(*(void (*)(void (*)(int, int, const char *, int)))crypto_sw[1].ptr)\n#define CRYPTO_set_id_callback                                                 \\\n\t(*(void (*)(unsigned long (*)(void)))crypto_sw[2].ptr)\n#define ERR_get_error (*(unsigned long (*)(void))crypto_sw[3].ptr)\n#define ERR_error_string (*(char *(*)(unsigned long, char *))crypto_sw[4].ptr)\n#define ERR_remove_state (*(void (*)(unsigned long))crypto_sw[5].ptr)\n#define ERR_free_strings (*(void (*)(void))crypto_sw[6].ptr)\n#define ENGINE_cleanup (*(void (*)(void))crypto_sw[7].ptr)\n#define CONF_modules_unload (*(void (*)(int))crypto_sw[8].ptr)\n#define CRYPTO_cleanup_all_ex_data (*(void (*)(void))crypto_sw[9].ptr)\n#define EVP_cleanup (*(void (*)(void))crypto_sw[10].ptr)\n#define X509_free (*(void (*)(X509 *))crypto_sw[11].ptr)\n#define X509_get_subject_name (*(X509_NAME * (*)(X509 *))crypto_sw[12].ptr)\n#define X509_get_issuer_name (*(X509_NAME * (*)(X509 *))crypto_sw[13].ptr)\n#define X509_NAME_oneline                                                      \\\n\t(*(char *(*)(X509_NAME *, char *, int))crypto_sw[14].ptr)\n#define X509_get_serialNumber (*(ASN1_INTEGER * (*)(X509 *))crypto_sw[15].ptr)\n#define i2c_ASN1_INTEGER                                                       \\\n\t(*(int (*)(ASN1_INTEGER *, unsigned char **))crypto_sw[16].ptr)\n#define EVP_get_digestbyname                                                   \\\n\t(*(const EVP_MD *(*)(const char *))crypto_sw[17].ptr)\n#define EVP_Digest                                                             \\\n\t(*(int (*)(                                                                \\\n\t    const void *, size_t, void *, unsigned int *, const EVP_MD *, void *)) \\\n\t      crypto_sw[18].ptr)\n#define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[19].ptr)\n#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[20].ptr)\n#define ASN1_INTEGER_to_BN                                                     \\\n\t(*(BIGNUM * (*)(const ASN1_INTEGER *ai, BIGNUM *bn))crypto_sw[21].ptr)\n#define BN_free (*(void (*)(const BIGNUM *a))crypto_sw[22].ptr)\n#define CRYPTO_free (*(void (*)(void *addr))crypto_sw[23].ptr)\n\n#define OPENSSL_free(a) CRYPTO_free(a)\n\n/* init_ssl_ctx() function updates this array.\n * It loads SSL library dynamically and changes NULLs to the actual addresses\n * of respective functions. The macros above (like SSL_connect()) are really\n * just calling these functions indirectly via the pointer. */\nstatic struct ssl_func ssl_sw[] = {{\"SSL_free\", NULL},\n                                   {\"SSL_accept\", NULL},\n                                   {\"SSL_connect\", NULL},\n                                   {\"SSL_read\", NULL},\n                                   {\"SSL_write\", NULL},\n                                   {\"SSL_get_error\", NULL},\n                                   {\"SSL_set_fd\", NULL},\n                                   {\"SSL_new\", NULL},\n                                   {\"SSL_CTX_new\", NULL},\n                                   {\"SSLv23_server_method\", NULL},\n                                   {\"SSL_library_init\", NULL},\n                                   {\"SSL_CTX_use_PrivateKey_file\", NULL},\n                                   {\"SSL_CTX_use_certificate_file\", NULL},\n                                   {\"SSL_CTX_set_default_passwd_cb\", NULL},\n                                   {\"SSL_CTX_free\", NULL},\n                                   {\"SSL_load_error_strings\", NULL},\n                                   {\"SSL_CTX_use_certificate_chain_file\", NULL},\n                                   {\"SSLv23_client_method\", NULL},\n                                   {\"SSL_pending\", NULL},\n                                   {\"SSL_CTX_set_verify\", NULL},\n                                   {\"SSL_shutdown\", NULL},\n                                   {\"SSL_CTX_load_verify_locations\", NULL},\n                                   {\"SSL_CTX_set_default_verify_paths\", NULL},\n                                   {\"SSL_CTX_set_verify_depth\", NULL},\n                                   {\"SSL_get_peer_certificate\", NULL},\n                                   {\"SSL_get_version\", NULL},\n                                   {\"SSL_get_current_cipher\", NULL},\n                                   {\"SSL_CIPHER_get_name\", NULL},\n                                   {\"SSL_CTX_check_private_key\", NULL},\n                                   {\"SSL_CTX_set_session_id_context\", NULL},\n                                   {\"SSL_CTX_ctrl\", NULL},\n                                   {\"SSL_CTX_set_cipher_list\", NULL},\n                                   {\"SSL_CTX_set_info_callback\", NULL},\n                                   {\"SSL_get_ex_data\", NULL},\n                                   {\"SSL_set_ex_data\", NULL},\n                                   {\"SSL_CTX_callback_ctrl\", NULL},\n                                   {\"SSL_get_servername\", NULL},\n                                   {\"SSL_set_SSL_CTX\", NULL},\n                                   {NULL, NULL}};\n\n\n/* Similar array as ssl_sw. These functions could be located in different\n * lib. */\nstatic struct ssl_func crypto_sw[] = {{\"CRYPTO_num_locks\", NULL},\n                                      {\"CRYPTO_set_locking_callback\", NULL},\n                                      {\"CRYPTO_set_id_callback\", NULL},\n                                      {\"ERR_get_error\", NULL},\n                                      {\"ERR_error_string\", NULL},\n                                      {\"ERR_remove_state\", NULL},\n                                      {\"ERR_free_strings\", NULL},\n                                      {\"ENGINE_cleanup\", NULL},\n                                      {\"CONF_modules_unload\", NULL},\n                                      {\"CRYPTO_cleanup_all_ex_data\", NULL},\n                                      {\"EVP_cleanup\", NULL},\n                                      {\"X509_free\", NULL},\n                                      {\"X509_get_subject_name\", NULL},\n                                      {\"X509_get_issuer_name\", NULL},\n                                      {\"X509_NAME_oneline\", NULL},\n                                      {\"X509_get_serialNumber\", NULL},\n                                      {\"i2c_ASN1_INTEGER\", NULL},\n                                      {\"EVP_get_digestbyname\", NULL},\n                                      {\"EVP_Digest\", NULL},\n                                      {\"i2d_X509\", NULL},\n                                      {\"BN_bn2hex\", NULL},\n                                      {\"ASN1_INTEGER_to_BN\", NULL},\n                                      {\"BN_free\", NULL},\n                                      {\"CRYPTO_free\", NULL},\n                                      {NULL, NULL}};\n#endif /* OPENSSL_API_1_1 */\n#endif /* NO_SSL_DL */\n#endif /* NO_SSL */\n\n\n#if !defined(NO_CACHING)\nstatic const char *month_names[] = {\"Jan\",\n                                    \"Feb\",\n                                    \"Mar\",\n                                    \"Apr\",\n                                    \"May\",\n                                    \"Jun\",\n                                    \"Jul\",\n                                    \"Aug\",\n                                    \"Sep\",\n                                    \"Oct\",\n                                    \"Nov\",\n                                    \"Dec\"};\n#endif /* !NO_CACHING */\n\n/* Unified socket address. For IPv6 support, add IPv6 address structure in\n * the\n * union u. */\nunion usa {\n\tstruct sockaddr sa;\n\tstruct sockaddr_in sin;\n#if defined(USE_IPV6)\n\tstruct sockaddr_in6 sin6;\n#endif\n};\n\n/* Describes a string (chunk of memory). */\nstruct vec {\n\tconst char *ptr;\n\tsize_t len;\n};\n\nstruct mg_file_stat {\n\t/* File properties filled by mg_stat: */\n\tuint64_t size;\n\ttime_t last_modified;\n\tint is_directory; /* Set to 1 if mg_stat is called for a directory */\n\tint is_gzipped;   /* Set to 1 if the content is gzipped, in which\n\t                   * case we need a \"Content-Eencoding: gzip\" header */\n\tint location;     /* 0 = nowhere, 1 = on disk, 2 = in memory */\n};\n\nstruct mg_file_in_memory {\n\tchar *p;\n\tuint32_t pos;\n\tchar mode;\n};\n\nstruct mg_file_access {\n\t/* File properties filled by mg_fopen: */\n\tFILE *fp;\n#if defined(MG_USE_OPEN_FILE)\n\t/* TODO (low): Remove obsolete \"file in memory\" implementation.\n\t * In an \"early 2017\" discussion at Google groups\n\t * https://groups.google.com/forum/#!topic/civetweb/h9HT4CmeYqI\n\t * we decided to get rid of this feature (after some fade-out\n\t * phase). */\n\tconst char *membuf;\n#endif\n};\n\nstruct mg_file {\n\tstruct mg_file_stat stat;\n\tstruct mg_file_access access;\n};\n\n#if defined(MG_USE_OPEN_FILE)\n\n#define STRUCT_FILE_INITIALIZER                                                \\\n\t{                                                                          \\\n\t\t{                                                                      \\\n\t\t\t(uint64_t)0, (time_t)0, 0, 0, 0                                    \\\n\t\t}                                                                      \\\n\t\t,                                                                      \\\n\t\t{                                                                      \\\n\t\t\t(FILE *) NULL, (const char *)NULL                                  \\\n\t\t}                                                                      \\\n\t}\n\n#else\n\n#define STRUCT_FILE_INITIALIZER                                                \\\n\t{                                                                          \\\n\t\t{                                                                      \\\n\t\t\t(uint64_t)0, (time_t)0, 0, 0, 0                                    \\\n\t\t}                                                                      \\\n\t\t,                                                                      \\\n\t\t{                                                                      \\\n\t\t\t(FILE *) NULL                                                      \\\n\t\t}                                                                      \\\n\t}\n\n#endif\n\n\n/* Describes listening socket, or socket which was accept()-ed by the master\n * thread and queued for future handling by the worker thread. */\nstruct socket {\n\tSOCKET sock;             /* Listening socket */\n\tunion usa lsa;           /* Local socket address */\n\tunion usa rsa;           /* Remote socket address */\n\tunsigned char is_ssl;    /* Is port SSL-ed */\n\tunsigned char ssl_redir; /* Is port supposed to redirect everything to SSL\n\t                          * port */\n\tunsigned char in_use;    /* Is valid */\n};\n\n\n/* Enum const for all options must be in sync with\n * static struct mg_option config_options[]\n * This is tested in the unit test (test/private.c)\n * \"Private Config Options\"\n */\nenum {\n\tLISTENING_PORTS,\n\tNUM_THREADS,\n\tRUN_AS_USER,\n\tCONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the\n                         * socket option typedef TCP_NODELAY. */\n\tMAX_REQUEST_SIZE,\n\tLINGER_TIMEOUT,\n#if defined(__linux__)\n\tALLOW_SENDFILE_CALL,\n#endif\n#if defined(_WIN32)\n\tCASE_SENSITIVE_FILES,\n#endif\n\tTHROTTLE,\n\tACCESS_LOG_FILE,\n\tERROR_LOG_FILE,\n\tENABLE_KEEP_ALIVE,\n\tREQUEST_TIMEOUT,\n\tKEEP_ALIVE_TIMEOUT,\n#if defined(USE_WEBSOCKET)\n\tWEBSOCKET_TIMEOUT,\n\tENABLE_WEBSOCKET_PING_PONG,\n#endif\n\tDECODE_URL,\n#if defined(USE_LUA)\n\tLUA_BACKGROUND_SCRIPT,\n\tLUA_BACKGROUND_SCRIPT_PARAMS,\n#endif\n\n\n\tDOCUMENT_ROOT,\n\tCGI_EXTENSIONS,\n\tCGI_ENVIRONMENT,\n\tPUT_DELETE_PASSWORDS_FILE,\n\tCGI_INTERPRETER,\n\tPROTECT_URI,\n\tAUTHENTICATION_DOMAIN,\n\tENABLE_AUTH_DOMAIN_CHECK,\n\tSSI_EXTENSIONS,\n\tENABLE_DIRECTORY_LISTING,\n\tGLOBAL_PASSWORDS_FILE,\n\tINDEX_FILES,\n\tACCESS_CONTROL_LIST,\n\tEXTRA_MIME_TYPES,\n\tSSL_CERTIFICATE,\n\tSSL_CERTIFICATE_CHAIN,\n\tURL_REWRITE_PATTERN,\n\tHIDE_FILES,\n\tSSL_DO_VERIFY_PEER,\n\tSSL_CA_PATH,\n\tSSL_CA_FILE,\n\tSSL_VERIFY_DEPTH,\n\tSSL_DEFAULT_VERIFY_PATHS,\n\tSSL_CIPHER_LIST,\n\tSSL_PROTOCOL_VERSION,\n\tSSL_SHORT_TRUST,\n\n#if defined(USE_LUA)\n\tLUA_PRELOAD_FILE,\n\tLUA_SCRIPT_EXTENSIONS,\n\tLUA_SERVER_PAGE_EXTENSIONS,\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n\tLUA_DEBUG_PARAMS,\n#endif\n#endif\n#if defined(USE_DUKTAPE)\n\tDUKTAPE_SCRIPT_EXTENSIONS,\n#endif\n\n#if defined(USE_WEBSOCKET)\n\tWEBSOCKET_ROOT,\n#endif\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tLUA_WEBSOCKET_EXTENSIONS,\n#endif\n\n\tACCESS_CONTROL_ALLOW_ORIGIN,\n\tACCESS_CONTROL_ALLOW_METHODS,\n\tACCESS_CONTROL_ALLOW_HEADERS,\n\tERROR_PAGES,\n#if !defined(NO_CACHING)\n\tSTATIC_FILE_MAX_AGE,\n#endif\n#if !defined(NO_SSL)\n\tSTRICT_HTTPS_MAX_AGE,\n#endif\n\tADDITIONAL_HEADER,\n\tALLOW_INDEX_SCRIPT_SUB_RES,\n\n\tNUM_OPTIONS\n};\n\n\n/* Config option name, config types, default value.\n * Must be in the same order as the enum const above.\n */\nstatic const struct mg_option config_options[] = {\n\n    /* Once for each server */\n    {\"listening_ports\", MG_CONFIG_TYPE_STRING_LIST, \"8080\"},\n    {\"num_threads\", MG_CONFIG_TYPE_NUMBER, \"50\"},\n    {\"run_as_user\", MG_CONFIG_TYPE_STRING, NULL},\n    {\"tcp_nodelay\", MG_CONFIG_TYPE_NUMBER, \"0\"},\n    {\"max_request_size\", MG_CONFIG_TYPE_NUMBER, \"16384\"},\n    {\"linger_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n#if defined(__linux__)\n    {\"allow_sendfile_call\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n#endif\n#if defined(_WIN32)\n    {\"case_sensitive\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n#endif\n    {\"throttle\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"access_log_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"error_log_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"enable_keep_alive\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n    {\"request_timeout_ms\", MG_CONFIG_TYPE_NUMBER, \"30000\"},\n    {\"keep_alive_timeout_ms\", MG_CONFIG_TYPE_NUMBER, \"500\"},\n#if defined(USE_WEBSOCKET)\n    {\"websocket_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n    {\"enable_websocket_ping_pong\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n#endif\n    {\"decode_url\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n#if defined(USE_LUA)\n    {\"lua_background_script\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"lua_background_script_params\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n#endif\n\n\n    /* Once for each domain */\n    {\"document_root\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n    {\"cgi_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.cgi$|**.pl$|**.php$\"},\n    {\"cgi_environment\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"put_delete_auth_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"cgi_interpreter\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"protect_uri\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"authentication_domain\", MG_CONFIG_TYPE_STRING, \"mydomain.com\"},\n    {\"enable_auth_domain_check\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"ssi_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.shtml$|**.shtm$\"},\n    {\"enable_directory_listing\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"global_auth_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"index_files\",\n     MG_CONFIG_TYPE_STRING_LIST,\n#if defined(USE_LUA)\n     \"index.xhtml,index.html,index.htm,\"\n     \"index.lp,index.lsp,index.lua,index.cgi,\"\n     \"index.shtml,index.php\"},\n#else\n     \"index.xhtml,index.html,index.htm,index.cgi,index.shtml,index.php\"},\n#endif\n    {\"access_control_list\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"extra_mime_types\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"ssl_certificate\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"ssl_certificate_chain\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"url_rewrite_patterns\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"hide_files_patterns\", MG_CONFIG_TYPE_EXT_PATTERN, NULL},\n\n    {\"ssl_verify_peer\", MG_CONFIG_TYPE_YES_NO_OPTIONAL, \"no\"},\n\n    {\"ssl_ca_path\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n    {\"ssl_ca_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"ssl_verify_depth\", MG_CONFIG_TYPE_NUMBER, \"9\"},\n    {\"ssl_default_verify_paths\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"ssl_cipher_list\", MG_CONFIG_TYPE_STRING, NULL},\n    {\"ssl_protocol_version\", MG_CONFIG_TYPE_NUMBER, \"0\"},\n    {\"ssl_short_trust\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n\n#if defined(USE_LUA)\n    {\"lua_preload_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"lua_script_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},\n    {\"lua_server_page_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lp$|**.lsp$\"},\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n    {\"lua_debug\", MG_CONFIG_TYPE_STRING, NULL},\n#endif\n#endif\n#if defined(USE_DUKTAPE)\n    /* The support for duktape is still in alpha version state.\n     * The name of this config option might change. */\n    {\"duktape_script_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.ssjs$\"},\n#endif\n\n#if defined(USE_WEBSOCKET)\n    {\"websocket_root\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n#endif\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n    {\"lua_websocket_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},\n#endif\n    {\"access_control_allow_origin\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"access_control_allow_methods\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"access_control_allow_headers\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"error_pages\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n#if !defined(NO_CACHING)\n    {\"static_file_max_age\", MG_CONFIG_TYPE_NUMBER, \"3600\"},\n#endif\n#if !defined(NO_SSL)\n    {\"strict_transport_security_max_age\", MG_CONFIG_TYPE_NUMBER, NULL},\n#endif\n    {\"additional_header\", MG_CONFIG_TYPE_STRING_MULTILINE, NULL},\n    {\"allow_index_script_resource\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n\n    {NULL, MG_CONFIG_TYPE_UNKNOWN, NULL}};\n\n\n/* Check if the config_options and the corresponding enum have compatible\n * sizes. */\nmg_static_assert((sizeof(config_options) / sizeof(config_options[0]))\n                     == (NUM_OPTIONS + 1),\n                 \"config_options and enum not sync\");\n\n\nenum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };\n\n\nstruct mg_handler_info {\n\t/* Name/Pattern of the URI. */\n\tchar *uri;\n\tsize_t uri_len;\n\n\t/* handler type */\n\tint handler_type;\n\n\t/* Handler for http/https or authorization requests. */\n\tmg_request_handler handler;\n\tunsigned int refcount;\n\tpthread_mutex_t refcount_mutex; /* Protects refcount */\n\tpthread_cond_t\n\t    refcount_cond; /* Signaled when handler refcount is decremented */\n\n\t/* Handler for ws/wss (websocket) requests. */\n\tmg_websocket_connect_handler connect_handler;\n\tmg_websocket_ready_handler ready_handler;\n\tmg_websocket_data_handler data_handler;\n\tmg_websocket_close_handler close_handler;\n\n\t/* accepted subprotocols for ws/wss requests. */\n\tstruct mg_websocket_subprotocols *subprotocols;\n\n\t/* Handler for authorization requests */\n\tmg_authorization_handler auth_handler;\n\n\t/* User supplied argument for the handler function. */\n\tvoid *cbdata;\n\n\t/* next handler in a linked list */\n\tstruct mg_handler_info *next;\n};\n\n\nenum {\n\tCONTEXT_INVALID,\n\tCONTEXT_SERVER,\n\tCONTEXT_HTTP_CLIENT,\n\tCONTEXT_WS_CLIENT\n};\n\n\nstruct mg_domain_context {\n\tSSL_CTX *ssl_ctx;                 /* SSL context */\n\tchar *config[NUM_OPTIONS];        /* Civetweb configuration parameters */\n\tstruct mg_handler_info *handlers; /* linked list of uri handlers */\n\n\t/* Server nonce */\n\tuint64_t auth_nonce_mask;  /* Mask for all nonce values */\n\tunsigned long nonce_count; /* Used nonces, used for authentication */\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\t/* linked list of shared lua websockets */\n\tstruct mg_shared_lua_websocket_list *shared_lua_websockets;\n#endif\n\n\t/* Linked list of domains */\n\tstruct mg_domain_context *next;\n};\n\n\nstruct mg_context {\n\n\t/* Part 1 - Physical context:\n\t * This holds threads, ports, timeouts, ...\n\t * set for the entire server, independent from the\n\t * addressed hostname.\n\t */\n\n\t/* Connection related */\n\tint context_type; /* See CONTEXT_* above */\n\n\tstruct socket *listening_sockets;\n\tstruct pollfd *listening_socket_fds;\n\tunsigned int num_listening_sockets;\n\n\tstruct mg_connection *worker_connections; /* The connection struct, pre-\n\t                                           * allocated for each worker */\n\n#if defined(USE_SERVER_STATS)\n\tint active_connections;\n\tint max_connections;\n\tint64_t total_connections;\n\tint64_t total_requests;\n\tint64_t total_data_read;\n\tint64_t total_data_written;\n#endif\n\n\t/* Thread related */\n\tvolatile int stop_flag;       /* Should we stop event loop */\n\tpthread_mutex_t thread_mutex; /* Protects (max|num)_threads */\n\n\tpthread_t masterthreadid; /* The master thread ID */\n\tunsigned int\n\t    cfg_worker_threads;      /* The number of configured worker threads. */\n\tpthread_t *worker_threadids; /* The worker thread IDs */\n\n/* Connection to thread dispatching */\n#if defined(ALTERNATIVE_QUEUE)\n\tstruct socket *client_socks;\n\tvoid **client_wait_events;\n#else\n\tstruct socket queue[MGSQLEN]; /* Accepted sockets */\n\tvolatile int sq_head;         /* Head of the socket queue */\n\tvolatile int sq_tail;         /* Tail of the socket queue */\n\tpthread_cond_t sq_full;       /* Signaled when socket is produced */\n\tpthread_cond_t sq_empty;      /* Signaled when socket is consumed */\n#endif\n\n\t/* Memory related */\n\tunsigned int max_request_size; /* The max request size */\n\n#if defined(USE_SERVER_STATS)\n\tstruct mg_memory_stat ctx_memory;\n#endif\n\n\t/* Operating system related */\n\tchar *systemName;  /* What operating system is running */\n\ttime_t start_time; /* Server start time, used for authentication\n\t                    * and for diagnstics. */\n\n#if defined(USE_TIMERS)\n\tstruct ttimers *timers;\n#endif\n\n/* Lua specific: Background operations and shared websockets */\n#if defined(USE_LUA)\n\tvoid *lua_background_state;\n#endif\n\n\t/* Server nonce */\n\tpthread_mutex_t nonce_mutex; /* Protects nonce_count */\n\n\t/* Server callbacks */\n\tstruct mg_callbacks callbacks; /* User-defined callback function */\n\tvoid *user_data;               /* User-defined data */\n\n\t/* Part 2 - Logical domain:\n\t * This holds hostname, TLS certificate, document root, ...\n\t * set for a domain hosted at the server.\n\t * There may be multiple domains hosted at one physical server.\n\t * The default domain \"dd\" is the first element of a list of\n\t * domains.\n\t */\n\tstruct mg_domain_context dd; /* default domain */\n};\n\n\n#if defined(USE_SERVER_STATS)\nstatic struct mg_memory_stat mg_common_memory = {0, 0, 0};\n\nstatic struct mg_memory_stat *\nget_memory_stat(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\treturn &(ctx->ctx_memory);\n\t}\n\treturn &mg_common_memory;\n}\n#endif\n\nenum {\n\tCONNECTION_TYPE_INVALID,\n\tCONNECTION_TYPE_REQUEST,\n\tCONNECTION_TYPE_RESPONSE\n};\n\nstruct mg_connection {\n\tint connection_type; /* see CONNECTION_TYPE_* above */\n\n\tstruct mg_request_info request_info;\n\tstruct mg_response_info response_info;\n\n\tstruct mg_context *phys_ctx;\n\tstruct mg_domain_context *dom_ctx;\n\n#if defined(USE_SERVER_STATS)\n\tint conn_state; /* 0 = undef, numerical value may change in different\n\t                 * versions. For the current definition, see\n\t                 * mg_get_connection_info_impl */\n#endif\n\n\tconst char *host;         /* Host (HTTP/1.1 header or SNI) */\n\tSSL *ssl;                 /* SSL descriptor */\n\tSSL_CTX *client_ssl_ctx;  /* SSL context for client connections */\n\tstruct socket client;     /* Connected client */\n\ttime_t conn_birth_time;   /* Time (wall clock) when connection was\n\t                           * established */\n\tstruct timespec req_time; /* Time (since system start) when the request\n\t                           * was received */\n\tint64_t num_bytes_sent;   /* Total bytes sent to client */\n\tint64_t content_len;      /* Content-Length header value */\n\tint64_t consumed_content; /* How many bytes of content have been read */\n\tint is_chunked;           /* Transfer-Encoding is chunked:\n\t                           * 0 = not chunked,\n\t                           * 1 = chunked, do data read yet,\n\t                           * 2 = chunked, some data read,\n\t                           * 3 = chunked, all data read\n\t                           */\n\tsize_t chunk_remainder;   /* Unread data from the last chunk */\n\tchar *buf;                /* Buffer for received data */\n\tchar *path_info;          /* PATH_INFO part of the URL */\n\n\tint must_close;       /* 1 if connection must be closed */\n\tint accept_gzip;      /* 1 if gzip encoding is accepted */\n\tint in_error_handler; /* 1 if in handler for user defined error\n\t                       * pages */\n#if defined(USE_WEBSOCKET)\n\tint in_websocket_handling; /* 1 if in read_websocket */\n#endif\n\tint handled_requests; /* Number of requests handled by this connection\n\t                         */\n\tint buf_size;         /* Buffer size */\n\tint request_len;      /* Size of the request + headers in a buffer */\n\tint data_len;         /* Total size of data in a buffer */\n\tint status_code;      /* HTTP reply status code, e.g. 200 */\n\tint throttle;         /* Throttling, bytes/sec. <= 0 means no\n\t                       * throttle */\n\n\ttime_t last_throttle_time;   /* Last time throttled data was sent */\n\tint64_t last_throttle_bytes; /* Bytes sent this second */\n\tpthread_mutex_t mutex;       /* Used by mg_(un)lock_connection to ensure\n\t                              * atomic transmissions for websockets */\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tvoid *lua_websocket_state; /* Lua_State for a websocket connection */\n#endif\n\n\tint thread_index; /* Thread index within ctx */\n};\n\n\n/* Directory entry */\nstruct de {\n\tstruct mg_connection *conn;\n\tchar *file_name;\n\tstruct mg_file_stat file;\n};\n\n\n#if defined(USE_WEBSOCKET)\nstatic int is_websocket_protocol(const struct mg_connection *conn);\n#else\n#define is_websocket_protocol(conn) (0)\n#endif\n\n\n#define mg_cry_internal(conn, fmt, ...)                                        \\\n\tmg_cry_internal_wrap(conn, __func__, __LINE__, fmt, __VA_ARGS__)\n\nstatic void mg_cry_internal_wrap(const struct mg_connection *conn,\n                                 const char *func,\n                                 unsigned line,\n                                 const char *fmt,\n                                 ...) PRINTF_ARGS(4, 5);\n\n\n#if !defined(NO_THREAD_NAME)\n#if defined(_WIN32) && defined(_MSC_VER)\n/* Set the thread name for debugging purposes in Visual Studio\n * http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\n */\n#pragma pack(push, 8)\ntypedef struct tagTHREADNAME_INFO {\n\tDWORD dwType;     /* Must be 0x1000. */\n\tLPCSTR szName;    /* Pointer to name (in user addr space). */\n\tDWORD dwThreadID; /* Thread ID (-1=caller thread). */\n\tDWORD dwFlags;    /* Reserved for future use, must be zero. */\n} THREADNAME_INFO;\n#pragma pack(pop)\n\n#elif defined(__linux__)\n\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#if defined(ALTERNATIVE_QUEUE)\n#include <sys/eventfd.h>\n#endif /* ALTERNATIVE_QUEUE */\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\nstatic void *\nevent_create(void)\n{\n\tint evhdl = eventfd(0, EFD_CLOEXEC);\n\tint *ret;\n\n\tif (evhdl == -1) {\n\t\t/* Linux uses -1 on error, Windows NULL. */\n\t\t/* However, Linux does not return 0 on success either. */\n\t\treturn 0;\n\t}\n\n\tret = (int *)mg_malloc(sizeof(int));\n\tif (ret) {\n\t\t*ret = evhdl;\n\t} else {\n\t\t(void)close(evhdl);\n\t}\n\n\treturn (void *)ret;\n}\n\n\nstatic int\nevent_wait(void *eventhdl)\n{\n\tuint64_t u;\n\tint evhdl, s;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\ts = (int)read(evhdl, &u, sizeof(u));\n\tif (s != sizeof(u)) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\t(void)u; /* the value is not required */\n\treturn 1;\n}\n\n\nstatic int\nevent_signal(void *eventhdl)\n{\n\tuint64_t u = 1;\n\tint evhdl, s;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\ts = (int)write(evhdl, &u, sizeof(u));\n\tif (s != sizeof(u)) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tint evhdl;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\tclose(evhdl);\n\tmg_free(eventhdl);\n}\n\n\n#endif\n\n#endif\n\n\n#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE)\n\nstruct posix_event {\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cond;\n};\n\n\nstatic void *\nevent_create(void)\n{\n\tstruct posix_event *ret = mg_malloc(sizeof(struct posix_event));\n\tif (ret == 0) {\n\t\t/* out of memory */\n\t\treturn 0;\n\t}\n\tif (0 != pthread_mutex_init(&(ret->mutex), NULL)) {\n\t\t/* pthread mutex not available */\n\t\tmg_free(ret);\n\t\treturn 0;\n\t}\n\tif (0 != pthread_cond_init(&(ret->cond), NULL)) {\n\t\t/* pthread cond not available */\n\t\tpthread_mutex_destroy(&(ret->mutex));\n\t\tmg_free(ret);\n\t\treturn 0;\n\t}\n\treturn (void *)ret;\n}\n\n\nstatic int\nevent_wait(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_mutex_lock(&(ev->mutex));\n\tpthread_cond_wait(&(ev->cond), &(ev->mutex));\n\tpthread_mutex_unlock(&(ev->mutex));\n\treturn 1;\n}\n\n\nstatic int\nevent_signal(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_mutex_lock(&(ev->mutex));\n\tpthread_cond_signal(&(ev->cond));\n\tpthread_mutex_unlock(&(ev->mutex));\n\treturn 1;\n}\n\n\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_cond_destroy(&(ev->cond));\n\tpthread_mutex_destroy(&(ev->mutex));\n\tmg_free(ev);\n}\n#endif\n\n\nstatic void\nmg_set_thread_name(const char *name)\n{\n\tchar threadName[16 + 1]; /* 16 = Max. thread length in Linux/OSX/.. */\n\n\tmg_snprintf(\n\t    NULL, NULL, threadName, sizeof(threadName), \"civetweb-%s\", name);\n\n#if defined(_WIN32)\n#if defined(_MSC_VER)\n\t/* Windows and Visual Studio Compiler */\n\t__try\n\t{\n\t\tTHREADNAME_INFO info;\n\t\tinfo.dwType = 0x1000;\n\t\tinfo.szName = threadName;\n\t\tinfo.dwThreadID = ~0U;\n\t\tinfo.dwFlags = 0;\n\n\t\tRaiseException(0x406D1388,\n\t\t               0,\n\t\t               sizeof(info) / sizeof(ULONG_PTR),\n\t\t               (ULONG_PTR *)&info);\n\t}\n\t__except(EXCEPTION_EXECUTE_HANDLER)\n\t{\n\t}\n#elif defined(__MINGW32__)\n/* No option known to set thread name for MinGW */\n#endif\n#elif defined(_GNU_SOURCE) && defined(__GLIBC__)                               \\\n    && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 12)))\n\t/* pthread_setname_np first appeared in glibc in version 2.12*/\n\t(void)pthread_setname_np(pthread_self(), threadName);\n#elif defined(__linux__)\n\t/* on linux we can use the old prctl function */\n\t(void)prctl(PR_SET_NAME, threadName, 0, 0, 0);\n#endif\n}\n#else /* !defined(NO_THREAD_NAME) */\nvoid\nmg_set_thread_name(const char *threadName)\n{\n}\n#endif\n\n\n#if defined(MG_LEGACY_INTERFACE)\nconst char **\nmg_get_valid_option_names(void)\n{\n\t/* This function is deprecated. Use mg_get_valid_options instead. */\n\tstatic const char *\n\t    data[2 * sizeof(config_options) / sizeof(config_options[0])] = {0};\n\tint i;\n\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdata[i * 2] = config_options[i].name;\n\t\tdata[i * 2 + 1] = config_options[i].default_value;\n\t}\n\n\treturn data;\n}\n#endif\n\n\nconst struct mg_option *\nmg_get_valid_options(void)\n{\n\treturn config_options;\n}\n\n\n/* Do not open file (used in is_file_in_memory) */\n#define MG_FOPEN_MODE_NONE (0)\n\n/* Open file for read only access */\n#define MG_FOPEN_MODE_READ (1)\n\n/* Open file for writing, create and overwrite */\n#define MG_FOPEN_MODE_WRITE (2)\n\n/* Open file for writing, create and append */\n#define MG_FOPEN_MODE_APPEND (4)\n\n\n/* If a file is in memory, set all \"stat\" members and the membuf pointer of\n * output filep and return 1, otherwise return 0 and don't modify anything.\n */\nstatic int\nopen_file_in_memory(const struct mg_connection *conn,\n                    const char *path,\n                    struct mg_file *filep,\n                    int mode)\n{\n#if defined(MG_USE_OPEN_FILE)\n\n\tsize_t size = 0;\n\tconst char *buf = NULL;\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tif ((mode != MG_FOPEN_MODE_NONE) && (mode != MG_FOPEN_MODE_READ)) {\n\t\treturn 0;\n\t}\n\n\tif (conn->phys_ctx->callbacks.open_file) {\n\t\tbuf = conn->phys_ctx->callbacks.open_file(conn, path, &size);\n\t\tif (buf != NULL) {\n\t\t\tif (filep == NULL) {\n\t\t\t\t/* This is a file in memory, but we cannot store the\n\t\t\t\t * properties\n\t\t\t\t * now.\n\t\t\t\t * Called from \"is_file_in_memory\" function. */\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* NOTE: override filep->size only on success. Otherwise, it\n\t\t\t * might\n\t\t\t * break constructs like if (!mg_stat() || !mg_fopen()) ... */\n\t\t\tfilep->access.membuf = buf;\n\t\t\tfilep->access.fp = NULL;\n\n\t\t\t/* Size was set by the callback */\n\t\t\tfilep->stat.size = size;\n\n\t\t\t/* Assume the data may change during runtime by setting\n\t\t\t * last_modified = now */\n\t\t\tfilep->stat.last_modified = time(NULL);\n\n\t\t\tfilep->stat.is_directory = 0;\n\t\t\tfilep->stat.is_gzipped = 0;\n\t\t}\n\t}\n\n\treturn (buf != NULL);\n\n#else\n\t(void)conn;\n\t(void)path;\n\t(void)filep;\n\t(void)mode;\n\n\treturn 0;\n\n#endif\n}\n\n\nstatic int\nis_file_in_memory(const struct mg_connection *conn, const char *path)\n{\n\treturn open_file_in_memory(conn, path, NULL, MG_FOPEN_MODE_NONE);\n}\n\n\nstatic int\nis_file_opened(const struct mg_file_access *fileacc)\n{\n\tif (!fileacc) {\n\t\treturn 0;\n\t}\n\n#if defined(MG_USE_OPEN_FILE)\n\treturn (fileacc->membuf != NULL) || (fileacc->fp != NULL);\n#else\n\treturn (fileacc->fp != NULL);\n#endif\n}\n\n\nstatic int mg_stat(const struct mg_connection *conn,\n                   const char *path,\n                   struct mg_file_stat *filep);\n\n\n/* mg_fopen will open a file either in memory or on the disk.\n * The input parameter path is a string in UTF-8 encoding.\n * The input parameter mode is MG_FOPEN_MODE_*\n * On success, either fp or membuf will be set in the output\n * struct file. All status members will also be set.\n * The function returns 1 on success, 0 on error. */\nstatic int\nmg_fopen(const struct mg_connection *conn,\n         const char *path,\n         int mode,\n         struct mg_file *filep)\n{\n\tint found;\n\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tfilep->access.fp = NULL;\n#if defined(MG_USE_OPEN_FILE)\n\tfilep->access.membuf = NULL;\n#endif\n\n\tif (!is_file_in_memory(conn, path)) {\n\n\t\t/* filep is initialized in mg_stat: all fields with memset to,\n\t\t * some fields like size and modification date with values */\n\t\tfound = mg_stat(conn, path, &(filep->stat));\n\n\t\tif ((mode == MG_FOPEN_MODE_READ) && (!found)) {\n\t\t\t/* file does not exist and will not be created */\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\t{\n\t\t\twchar_t wbuf[W_PATH_MAX];\n\t\t\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\t\t\tswitch (mode) {\n\t\t\tcase MG_FOPEN_MODE_READ:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"rb\");\n\t\t\t\tbreak;\n\t\t\tcase MG_FOPEN_MODE_WRITE:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"wb\");\n\t\t\t\tbreak;\n\t\t\tcase MG_FOPEN_MODE_APPEND:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"ab\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\t/* Linux et al already use unicode. No need to convert. */\n\t\tswitch (mode) {\n\t\tcase MG_FOPEN_MODE_READ:\n\t\t\tfilep->access.fp = fopen(path, \"r\");\n\t\t\tbreak;\n\t\tcase MG_FOPEN_MODE_WRITE:\n\t\t\tfilep->access.fp = fopen(path, \"w\");\n\t\t\tbreak;\n\t\tcase MG_FOPEN_MODE_APPEND:\n\t\t\tfilep->access.fp = fopen(path, \"a\");\n\t\t\tbreak;\n\t\t}\n\n#endif\n\t\tif (!found) {\n\t\t\t/* File did not exist before fopen was called.\n\t\t\t * Maybe it has been created now. Get stat info\n\t\t\t * like creation time now. */\n\t\t\tfound = mg_stat(conn, path, &(filep->stat));\n\t\t\t(void)found;\n\t\t}\n\n\t\t/* file is on disk */\n\t\treturn (filep->access.fp != NULL);\n\n\t} else {\n#if defined(MG_USE_OPEN_FILE)\n\t\t/* is_file_in_memory returned true */\n\t\tif (open_file_in_memory(conn, path, filep, mode)) {\n\t\t\t/* file is in memory */\n\t\t\treturn (filep->access.membuf != NULL);\n\t\t}\n#endif\n\t}\n\n\t/* Open failed */\n\treturn 0;\n}\n\n\n/* return 0 on success, just like fclose */\nstatic int\nmg_fclose(struct mg_file_access *fileacc)\n{\n\tint ret = -1;\n\tif (fileacc != NULL) {\n\t\tif (fileacc->fp != NULL) {\n\t\t\tret = fclose(fileacc->fp);\n#if defined(MG_USE_OPEN_FILE)\n\t\t} else if (fileacc->membuf != NULL) {\n\t\t\tret = 0;\n#endif\n\t\t}\n\t\t/* reset all members of fileacc */\n\t\tmemset(fileacc, 0, sizeof(*fileacc));\n\t}\n\treturn ret;\n}\n\n\nstatic void\nmg_strlcpy(register char *dst, register const char *src, size_t n)\n{\n\tfor (; *src != '\\0' && n > 1; n--) {\n\t\t*dst++ = *src++;\n\t}\n\t*dst = '\\0';\n}\n\n\nstatic int\nlowercase(const char *s)\n{\n\treturn tolower(*(const unsigned char *)s);\n}\n\n\nint\nmg_strncasecmp(const char *s1, const char *s2, size_t len)\n{\n\tint diff = 0;\n\n\tif (len > 0) {\n\t\tdo {\n\t\t\tdiff = lowercase(s1++) - lowercase(s2++);\n\t\t} while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\t}\n\n\treturn diff;\n}\n\n\nint\nmg_strcasecmp(const char *s1, const char *s2)\n{\n\tint diff;\n\n\tdo {\n\t\tdiff = lowercase(s1++) - lowercase(s2++);\n\t} while (diff == 0 && s1[-1] != '\\0');\n\n\treturn diff;\n}\n\n\nstatic char *\nmg_strndup_ctx(const char *ptr, size_t len, struct mg_context *ctx)\n{\n\tchar *p;\n\t(void)ctx; /* Avoid Visual Studio warning if USE_SERVER_STATS is not\n\t            * defined */\n\n\tif ((p = (char *)mg_malloc_ctx(len + 1, ctx)) != NULL) {\n\t\tmg_strlcpy(p, ptr, len + 1);\n\t}\n\n\treturn p;\n}\n\n\nstatic char *\nmg_strdup_ctx(const char *str, struct mg_context *ctx)\n{\n\treturn mg_strndup_ctx(str, strlen(str), ctx);\n}\n\nstatic char *\nmg_strdup(const char *str)\n{\n\treturn mg_strndup_ctx(str, strlen(str), NULL);\n}\n\n\nstatic const char *\nmg_strcasestr(const char *big_str, const char *small_str)\n{\n\tsize_t i, big_len = strlen(big_str), small_len = strlen(small_str);\n\n\tif (big_len >= small_len) {\n\t\tfor (i = 0; i <= (big_len - small_len); i++) {\n\t\t\tif (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {\n\t\t\t\treturn big_str + i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/* Return null terminated string of given maximum length.\n * Report errors if length is exceeded. */\nstatic void\nmg_vsnprintf(const struct mg_connection *conn,\n             int *truncated,\n             char *buf,\n             size_t buflen,\n             const char *fmt,\n             va_list ap)\n{\n\tint n, ok;\n\n\tif (buflen == 0) {\n\t\tif (truncated) {\n\t\t\t*truncated = 1;\n\t\t}\n\t\treturn;\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n/* Using fmt as a non-literal is intended here, since it is mostly called\n * indirectly by mg_snprintf */\n#endif\n\n\tn = (int)vsnprintf_impl(buf, buflen, fmt, ap);\n\tok = (n >= 0) && ((size_t)n < buflen);\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\tif (ok) {\n\t\tif (truncated) {\n\t\t\t*truncated = 0;\n\t\t}\n\t} else {\n\t\tif (truncated) {\n\t\t\t*truncated = 1;\n\t\t}\n\t\tmg_cry_internal(conn,\n\t\t                \"truncating vsnprintf buffer: [%.*s]\",\n\t\t                (int)((buflen > 200) ? 200 : (buflen - 1)),\n\t\t                buf);\n\t\tn = (int)buflen - 1;\n\t}\n\tbuf[n] = '\\0';\n}\n\n\nstatic void\nmg_snprintf(const struct mg_connection *conn,\n            int *truncated,\n            char *buf,\n            size_t buflen,\n            const char *fmt,\n            ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tmg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);\n\tva_end(ap);\n}\n\n\nstatic int\nget_option_index(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tif (strcmp(config_options[i].name, name) == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nconst char *\nmg_get_option(const struct mg_context *ctx, const char *name)\n{\n\tint i;\n\tif ((i = get_option_index(name)) == -1) {\n\t\treturn NULL;\n\t} else if (!ctx || ctx->dd.config[i] == NULL) {\n\t\treturn \"\";\n\t} else {\n\t\treturn ctx->dd.config[i];\n\t}\n}\n\n#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly\n\nstruct mg_context *\nmg_get_context(const struct mg_connection *conn)\n{\n\treturn (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);\n}\n\n\nvoid *\nmg_get_user_data(const struct mg_context *ctx)\n{\n\treturn (ctx == NULL) ? NULL : ctx->user_data;\n}\n\n\nvoid\nmg_set_user_connection_data(struct mg_connection *conn, void *data)\n{\n\tif (conn != NULL) {\n\t\tconn->request_info.conn_data = data;\n\t}\n}\n\n\nvoid *\nmg_get_user_connection_data(const struct mg_connection *conn)\n{\n\tif (conn != NULL) {\n\t\treturn conn->request_info.conn_data;\n\t}\n\treturn NULL;\n}\n\n\n#if defined(MG_LEGACY_INTERFACE)\n/* Deprecated: Use mg_get_server_ports instead. */\nsize_t\nmg_get_ports(const struct mg_context *ctx, size_t size, int *ports, int *ssl)\n{\n\tsize_t i;\n\tif (!ctx) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < size && i < ctx->num_listening_sockets; i++) {\n\t\tssl[i] = ctx->listening_sockets[i].is_ssl;\n\t\tports[i] =\n#if defined(USE_IPV6)\n\t\t    (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)\n\t\t        ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);\n\t}\n\treturn i;\n}\n#endif\n\n\nint\nmg_get_server_ports(const struct mg_context *ctx,\n                    int size,\n                    struct mg_server_ports *ports)\n{\n\tint i, cnt = 0;\n\n\tif (size <= 0) {\n\t\treturn -1;\n\t}\n\tmemset(ports, 0, sizeof(*ports) * (size_t)size);\n\tif (!ctx) {\n\t\treturn -1;\n\t}\n\tif (!ctx->listening_sockets) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {\n\n\t\tports[cnt].port =\n#if defined(USE_IPV6)\n\t\t    (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)\n\t\t        ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);\n\t\tports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;\n\t\tports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;\n\n\t\tif (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {\n\t\t\t/* IPv4 */\n\t\t\tports[cnt].protocol = 1;\n\t\t\tcnt++;\n\t\t} else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {\n\t\t\t/* IPv6 */\n\t\t\tports[cnt].protocol = 3;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\n\nstatic void\nsockaddr_to_string(char *buf, size_t len, const union usa *usa)\n{\n\tbuf[0] = '\\0';\n\n\tif (!usa) {\n\t\treturn;\n\t}\n\n\tif (usa->sa.sa_family == AF_INET) {\n\t\tgetnameinfo(&usa->sa,\n\t\t            sizeof(usa->sin),\n\t\t            buf,\n\t\t            (unsigned)len,\n\t\t            NULL,\n\t\t            0,\n\t\t            NI_NUMERICHOST);\n\t}\n#if defined(USE_IPV6)\n\telse if (usa->sa.sa_family == AF_INET6) {\n\t\tgetnameinfo(&usa->sa,\n\t\t            sizeof(usa->sin6),\n\t\t            buf,\n\t\t            (unsigned)len,\n\t\t            NULL,\n\t\t            0,\n\t\t            NI_NUMERICHOST);\n\t}\n#endif\n}\n\n\n/* Convert time_t to a string. According to RFC2616, Sec 14.18, this must be\n * included in all responses other than 100, 101, 5xx. */\nstatic void\ngmt_time_string(char *buf, size_t buf_len, time_t *t)\n{\n#if !defined(REENTRANT_TIME)\n\tstruct tm *tm;\n\n\ttm = ((t != NULL) ? gmtime(t) : NULL);\n\tif (tm != NULL) {\n#else\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n\n\tif (t != NULL) {\n\t\tgmtime_r(t, tm);\n#endif\n\t\tstrftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", tm);\n\t} else {\n\t\tmg_strlcpy(buf, \"Thu, 01 Jan 1970 00:00:00 GMT\", buf_len);\n\t\tbuf[buf_len - 1] = '\\0';\n\t}\n}\n\n\n/* difftime for struct timespec. Return value is in seconds. */\nstatic double\nmg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before)\n{\n\treturn (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9\n\t       + (double)(ts_now->tv_sec - ts_before->tv_sec);\n}\n\n\n#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl)\nstatic void mg_cry_internal_impl(const struct mg_connection *conn,\n                                 const char *func,\n                                 unsigned line,\n                                 const char *fmt,\n                                 va_list ap);\n#include \"external_mg_cry_internal_impl.inl\"\n#else\n\n/* Print error message to the opened error log stream. */\nstatic void\nmg_cry_internal_impl(const struct mg_connection *conn,\n                     const char *func,\n                     unsigned line,\n                     const char *fmt,\n                     va_list ap)\n{\n\tchar buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];\n\tstruct mg_file fi;\n\ttime_t timestamp;\n\n\t/* Unused, in the RELEASE build */\n\t(void)func;\n\t(void)line;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\tIGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif\n\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tDEBUG_TRACE(\"mg_cry called from %s:%u: %s\", func, line, buf);\n\n\tif (!conn) {\n\t\tputs(buf);\n\t\treturn;\n\t}\n\n\t/* Do not lock when getting the callback value, here and below.\n\t * I suppose this is fine, since function cannot disappear in the\n\t * same way string option can. */\n\tif ((conn->phys_ctx->callbacks.log_message == NULL)\n\t    || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {\n\n\t\tif (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {\n\t\t\tif (mg_fopen(conn,\n\t\t\t             conn->dom_ctx->config[ERROR_LOG_FILE],\n\t\t\t             MG_FOPEN_MODE_APPEND,\n\t\t\t             &fi) == 0) {\n\t\t\t\tfi.access.fp = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tfi.access.fp = NULL;\n\t\t}\n\n\t\tif (fi.access.fp != NULL) {\n\t\t\tflockfile(fi.access.fp);\n\t\t\ttimestamp = time(NULL);\n\n\t\t\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\t\t\tfprintf(fi.access.fp,\n\t\t\t        \"[%010lu] [error] [client %s] \",\n\t\t\t        (unsigned long)timestamp,\n\t\t\t        src_addr);\n\n\t\t\tif (conn->request_info.request_method != NULL) {\n\t\t\t\tfprintf(fi.access.fp,\n\t\t\t\t        \"%s %s: \",\n\t\t\t\t        conn->request_info.request_method,\n\t\t\t\t        conn->request_info.request_uri\n\t\t\t\t            ? conn->request_info.request_uri\n\t\t\t\t            : \"\");\n\t\t\t}\n\n\t\t\tfprintf(fi.access.fp, \"%s\", buf);\n\t\t\tfputc('\\n', fi.access.fp);\n\t\t\tfflush(fi.access.fp);\n\t\t\tfunlockfile(fi.access.fp);\n\t\t\t(void)mg_fclose(&fi.access); /* Ignore errors. We can't call\n\t\t\t                              * mg_cry here anyway ;-) */\n\t\t}\n\t}\n}\n\n#endif /* Externally provided function */\n\n\nstatic void\nmg_cry_internal_wrap(const struct mg_connection *conn,\n                     const char *func,\n                     unsigned line,\n                     const char *fmt,\n                     ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tmg_cry_internal_impl(conn, func, line, fmt, ap);\n\tva_end(ap);\n}\n\n\nvoid\nmg_cry(const struct mg_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tmg_cry_internal_impl(conn, \"user\", 0, fmt, ap);\n\tva_end(ap);\n}\n\n\n#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal\n\n\n/* Return fake connection structure. Used for logging, if connection\n * is not applicable at the moment of logging. */\nstatic struct mg_connection *\nfc(struct mg_context *ctx)\n{\n\tstatic struct mg_connection fake_connection;\n\tfake_connection.phys_ctx = ctx;\n\tfake_connection.dom_ctx = &(ctx->dd);\n\treturn &fake_connection;\n}\n\n\nconst char *\nmg_version(void)\n{\n\treturn CIVETWEB_VERSION;\n}\n\n\nconst struct mg_request_info *\nmg_get_request_info(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE)\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\tchar txt[16];\n\t\tstruct mg_workerTLS *tls =\n\t\t    (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\n\t\tsprintf(txt, \"%03i\", conn->response_info.status_code);\n\t\tif (strlen(txt) == 3) {\n\t\t\tmemcpy(tls->txtbuf, txt, 4);\n\t\t} else {\n\t\t\tstrcpy(tls->txtbuf, \"ERR\");\n\t\t}\n\n\t\t((struct mg_connection *)conn)->request_info.local_uri =\n\t\t    ((struct mg_connection *)conn)->request_info.request_uri =\n\t\t        tls->txtbuf; /* use thread safe buffer */\n\n\t\t((struct mg_connection *)conn)->request_info.num_headers =\n\t\t    conn->response_info.num_headers;\n\t\tmemcpy(((struct mg_connection *)conn)->request_info.http_headers,\n\t\t       conn->response_info.http_headers,\n\t\t       sizeof(conn->response_info.http_headers));\n\t} else\n#endif\n\t    if (conn->connection_type != CONNECTION_TYPE_REQUEST) {\n\t\treturn NULL;\n\t}\n\treturn &conn->request_info;\n}\n\n\nconst struct mg_response_info *\nmg_get_response_info(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\tif (conn->connection_type != CONNECTION_TYPE_RESPONSE) {\n\t\treturn NULL;\n\t}\n\treturn &conn->response_info;\n}\n\n\nstatic const char *\nget_proto_name(const struct mg_connection *conn)\n{\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n/* Depending on USE_WEBSOCKET and NO_SSL, some oft the protocols might be\n * not supported. Clang raises an \"unreachable code\" warning for parts of ?:\n * unreachable, but splitting into four different #ifdef clauses here is more\n * complicated.\n */\n#endif\n\n\tconst struct mg_request_info *ri = &conn->request_info;\n\n\tconst char *proto =\n\t    (is_websocket_protocol(conn) ? (ri->is_ssl ? \"wss\" : \"ws\")\n\t                                 : (ri->is_ssl ? \"https\" : \"http\"));\n\n\treturn proto;\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n}\n\n\nint\nmg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen)\n{\n\tif ((buflen < 1) || (buf == 0) || (conn == 0)) {\n\t\treturn -1;\n\t} else {\n\n\t\tint truncated = 0;\n\t\tconst struct mg_request_info *ri = &conn->request_info;\n\n\t\tconst char *proto = get_proto_name(conn);\n\n\t\tif (ri->local_uri == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((ri->request_uri != NULL)\n\t\t    && (0 != strcmp(ri->local_uri, ri->request_uri))) {\n\t\t\t/* The request uri is different from the local uri.\n\t\t\t * This is usually if an absolute URI, including server\n\t\t\t * name has been provided. */\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            buf,\n\t\t\t            buflen,\n\t\t\t            \"%s://%s\",\n\t\t\t            proto,\n\t\t\t            ri->request_uri);\n\t\t\tif (truncated) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\t} else {\n\n/* The common case is a relative URI, so we have to\n * construct an absolute URI from server name and port */\n\n#if defined(USE_IPV6)\n\t\t\tint is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);\n\t\t\tint port = is_ipv6 ? htons(conn->client.lsa.sin6.sin6_port)\n\t\t\t                   : htons(conn->client.lsa.sin.sin_port);\n#else\n\t\t\tint port = htons(conn->client.lsa.sin.sin_port);\n#endif\n\t\t\tint def_port = ri->is_ssl ? 443 : 80;\n\t\t\tint auth_domain_check_enabled =\n\t\t\t    conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]\n\t\t\t    && (!mg_strcasecmp(\n\t\t\t            conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK],\n\t\t\t            \"yes\"));\n\t\t\tconst char *server_domain =\n\t\t\t    conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\n\t\t\tchar portstr[16];\n\t\t\tchar server_ip[48];\n\n\t\t\tif (port != def_port) {\n\t\t\t\tsprintf(portstr, \":%u\", (unsigned)port);\n\t\t\t} else {\n\t\t\t\tportstr[0] = 0;\n\t\t\t}\n\n\t\t\tif (!auth_domain_check_enabled || !server_domain) {\n\n\t\t\t\tsockaddr_to_string(server_ip,\n\t\t\t\t                   sizeof(server_ip),\n\t\t\t\t                   &conn->client.lsa);\n\n\t\t\t\tserver_domain = server_ip;\n\t\t\t}\n\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            buf,\n\t\t\t            buflen,\n\t\t\t            \"%s://%s%s%s\",\n\t\t\t            proto,\n\t\t\t            server_domain,\n\t\t\t            portstr,\n\t\t\t            ri->local_uri);\n\t\t\tif (truncated) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n/* Skip the characters until one of the delimiters characters found.\n * 0-terminate resulting word. Skip the delimiter and following whitespaces.\n * Advance pointer to buffer to the next word. Return found 0-terminated\n * word.\n * Delimiters can be quoted with quotechar. */\nstatic char *\nskip_quoted(char **buf,\n            const char *delimiters,\n            const char *whitespace,\n            char quotechar)\n{\n\tchar *p, *begin_word, *end_word, *end_whitespace;\n\n\tbegin_word = *buf;\n\tend_word = begin_word + strcspn(begin_word, delimiters);\n\n\t/* Check for quotechar */\n\tif (end_word > begin_word) {\n\t\tp = end_word - 1;\n\t\twhile (*p == quotechar) {\n\t\t\t/* While the delimiter is quoted, look for the next delimiter.\n\t\t\t */\n\t\t\t/* This happens, e.g., in calls from parse_auth_header,\n\t\t\t * if the user name contains a \" character. */\n\n\t\t\t/* If there is anything beyond end_word, copy it. */\n\t\t\tif (*end_word != '\\0') {\n\t\t\t\tsize_t end_off = strcspn(end_word + 1, delimiters);\n\t\t\t\tmemmove(p, end_word, end_off + 1);\n\t\t\t\tp += end_off; /* p must correspond to end_word - 1 */\n\t\t\t\tend_word += end_off + 1;\n\t\t\t} else {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (p++; p < end_word; p++) {\n\t\t\t*p = '\\0';\n\t\t}\n\t}\n\n\tif (*end_word == '\\0') {\n\t\t*buf = end_word;\n\t} else {\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Disable spurious conversion warning for GCC */\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\t\tend_whitespace = end_word + strspn(&end_word[1], whitespace) + 1;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#if GCC_VERSION >= 40500\n#pragma GCC diagnostic pop\n#endif /* GCC_VERSION >= 40500 */\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\t\tfor (p = end_word; p < end_whitespace; p++) {\n\t\t\t*p = '\\0';\n\t\t}\n\n\t\t*buf = end_whitespace;\n\t}\n\n\treturn begin_word;\n}\n\n\n/* Return HTTP header value, or NULL if not found. */\nstatic const char *\nget_header(const struct mg_header *hdr, int num_hdr, const char *name)\n{\n\tint i;\n\tfor (i = 0; i < num_hdr; i++) {\n\t\tif (!mg_strcasecmp(name, hdr[i].name)) {\n\t\t\treturn hdr[i].value;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n#if defined(USE_WEBSOCKET)\n/* Retrieve requested HTTP header multiple values, and return the number of\n * found occurrences */\nstatic int\nget_req_headers(const struct mg_request_info *ri,\n                const char *name,\n                const char **output,\n                int output_max_size)\n{\n\tint i;\n\tint cnt = 0;\n\tif (ri) {\n\t\tfor (i = 0; i < ri->num_headers && cnt < output_max_size; i++) {\n\t\t\tif (!mg_strcasecmp(name, ri->http_headers[i].name)) {\n\t\t\t\toutput[cnt++] = ri->http_headers[i].value;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n#endif\n\n\nconst char *\nmg_get_header(const struct mg_connection *conn, const char *name)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\n\tif (conn->connection_type == CONNECTION_TYPE_REQUEST) {\n\t\treturn get_header(conn->request_info.http_headers,\n\t\t                  conn->request_info.num_headers,\n\t\t                  name);\n\t}\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\treturn get_header(conn->response_info.http_headers,\n\t\t                  conn->response_info.num_headers,\n\t\t                  name);\n\t}\n\treturn NULL;\n}\n\n\nstatic const char *\nget_http_version(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\n\tif (conn->connection_type == CONNECTION_TYPE_REQUEST) {\n\t\treturn conn->request_info.http_version;\n\t}\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\treturn conn->response_info.http_version;\n\t}\n\treturn NULL;\n}\n\n\n/* A helper function for traversing a comma separated list of values.\n * It returns a list pointer shifted to the next value, or NULL if the end\n * of the list found.\n * Value is stored in val vector. If value has form \"x=y\", then eq_val\n * vector is initialized to point to the \"y\" part, and val vector length\n * is adjusted to point only to \"x\". */\nstatic const char *\nnext_option(const char *list, struct vec *val, struct vec *eq_val)\n{\n\tint end;\n\nreparse:\n\tif (val == NULL || list == NULL || *list == '\\0') {\n\t\t/* End of the list */\n\t\treturn NULL;\n\t}\n\n\t/* Skip over leading LWS */\n\twhile (*list == ' ' || *list == '\\t')\n\t\tlist++;\n\n\tval->ptr = list;\n\tif ((list = strchr(val->ptr, ',')) != NULL) {\n\t\t/* Comma found. Store length and shift the list ptr */\n\t\tval->len = ((size_t)(list - val->ptr));\n\t\tlist++;\n\t} else {\n\t\t/* This value is the last one */\n\t\tlist = val->ptr + strlen(val->ptr);\n\t\tval->len = ((size_t)(list - val->ptr));\n\t}\n\n\t/* Adjust length for trailing LWS */\n\tend = (int)val->len - 1;\n\twhile (end >= 0 && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))\n\t\tend--;\n\tval->len = (size_t)(end + 1);\n\n\tif (val->len == 0) {\n\t\t/* Ignore any empty entries. */\n\t\tgoto reparse;\n\t}\n\n\tif (eq_val != NULL) {\n\t\t/* Value has form \"x=y\", adjust pointers and lengths\n\t\t * so that val points to \"x\", and eq_val points to \"y\". */\n\t\teq_val->len = 0;\n\t\teq_val->ptr = (const char *)memchr(val->ptr, '=', val->len);\n\t\tif (eq_val->ptr != NULL) {\n\t\t\teq_val->ptr++; /* Skip over '=' character */\n\t\t\teq_val->len = ((size_t)(val->ptr - eq_val->ptr)) + val->len;\n\t\t\tval->len = ((size_t)(eq_val->ptr - val->ptr)) - 1;\n\t\t}\n\t}\n\n\treturn list;\n}\n\n\n/* A helper function for checking if a comma separated list of values\n * contains\n * the given option (case insensitvely).\n * 'header' can be NULL, in which case false is returned. */\nstatic int\nheader_has_option(const char *header, const char *option)\n{\n\tstruct vec opt_vec;\n\tstruct vec eq_vec;\n\n\tDEBUG_ASSERT(option != NULL);\n\tDEBUG_ASSERT(option[0] != '\\0');\n\n\twhile ((header = next_option(header, &opt_vec, &eq_vec)) != NULL) {\n\t\tif (mg_strncasecmp(option, opt_vec.ptr, opt_vec.len) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n/* Perform case-insensitive match of string against pattern */\nstatic ptrdiff_t\nmatch_prefix(const char *pattern, size_t pattern_len, const char *str)\n{\n\tconst char *or_str;\n\tptrdiff_t i, j, len, res;\n\n\tif ((or_str = (const char *)memchr(pattern, '|', pattern_len)) != NULL) {\n\t\tres = match_prefix(pattern, (size_t)(or_str - pattern), str);\n\t\treturn (res > 0) ? res : match_prefix(or_str + 1,\n\t\t                                      (size_t)((pattern + pattern_len)\n\t\t                                               - (or_str + 1)),\n\t\t                                      str);\n\t}\n\n\tfor (i = 0, j = 0; (i < (ptrdiff_t)pattern_len); i++, j++) {\n\t\tif ((pattern[i] == '?') && (str[j] != '\\0')) {\n\t\t\tcontinue;\n\t\t} else if (pattern[i] == '$') {\n\t\t\treturn (str[j] == '\\0') ? j : -1;\n\t\t} else if (pattern[i] == '*') {\n\t\t\ti++;\n\t\t\tif (pattern[i] == '*') {\n\t\t\t\ti++;\n\t\t\t\tlen = strlen(str + j);\n\t\t\t} else {\n\t\t\t\tlen = strcspn(str + j, \"/\");\n\t\t\t}\n\t\t\tif (i == (ptrdiff_t)pattern_len) {\n\t\t\t\treturn j + len;\n\t\t\t}\n\t\t\tdo {\n\t\t\t\tres = match_prefix(pattern + i, pattern_len - i, str + j + len);\n\t\t\t} while (res == -1 && len-- > 0);\n\t\t\treturn (res == -1) ? -1 : j + res + len;\n\t\t} else if (lowercase(&pattern[i]) != lowercase(&str[j])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn (ptrdiff_t)j;\n}\n\n\n/* HTTP 1.1 assumes keep alive if \"Connection:\" header is not set\n * This function must tolerate situations when connection info is not\n * set up, for example if request parsing failed. */\nstatic int\nshould_keep_alive(const struct mg_connection *conn)\n{\n\tconst char *http_version;\n\tconst char *header;\n\n\t/* First satisfy needs of the server */\n\tif ((conn == NULL) || conn->must_close) {\n\t\t/* Close, if civetweb framework needs to close */\n\t\treturn 0;\n\t}\n\n\tif (mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0) {\n\t\t/* Close, if keep alive is not enabled */\n\t\treturn 0;\n\t}\n\n\t/* Check explicit wish of the client */\n\theader = mg_get_header(conn, \"Connection\");\n\tif (header) {\n\t\t/* If there is a connection header from the client, obey */\n\t\tif (header_has_option(header, \"keep-alive\")) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Use default of the standard */\n\thttp_version = get_http_version(conn);\n\tif (http_version && (0 == strcmp(http_version, \"1.1\"))) {\n\t\t/* HTTP 1.1 default is keep alive */\n\t\treturn 1;\n\t}\n\n\t/* HTTP 1.0 (and earlier) default is to close the connection */\n\treturn 0;\n}\n\n\nstatic int\nshould_decode_url(const struct mg_connection *conn)\n{\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\treturn (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], \"yes\") == 0);\n}\n\n\nstatic const char *\nsuggest_connection_header(const struct mg_connection *conn)\n{\n\treturn should_keep_alive(conn) ? \"keep-alive\" : \"close\";\n}\n\n\nstatic int\nsend_no_cache_header(struct mg_connection *conn)\n{\n\t/* Send all current and obsolete cache opt-out directives. */\n\treturn mg_printf(conn,\n\t                 \"Cache-Control: no-cache, no-store, \"\n\t                 \"must-revalidate, private, max-age=0\\r\\n\"\n\t                 \"Pragma: no-cache\\r\\n\"\n\t                 \"Expires: 0\\r\\n\");\n}\n\n\nstatic int\nsend_static_cache_header(struct mg_connection *conn)\n{\n#if !defined(NO_CACHING)\n\t/* Read the server config to check how long a file may be cached.\n\t * The configuration is in seconds. */\n\tint max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);\n\tif (max_age <= 0) {\n\t\t/* 0 means \"do not cache\". All values <0 are reserved\n\t\t * and may be used differently in the future. */\n\t\t/* If a file should not be cached, do not only send\n\t\t * max-age=0, but also pragmas and Expires headers. */\n\t\treturn send_no_cache_header(conn);\n\t}\n\n\t/* Use \"Cache-Control: max-age\" instead of \"Expires\" header.\n\t * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */\n\t/* See also https://www.mnot.net/cache_docs/ */\n\t/* According to RFC 2616, Section 14.21, caching times should not exceed\n\t * one year. A year with 365 days corresponds to 31536000 seconds, a\n\t * leap\n\t * year to 31622400 seconds. For the moment, we just send whatever has\n\t * been configured, still the behavior for >1 year should be considered\n\t * as undefined. */\n\treturn mg_printf(conn, \"Cache-Control: max-age=%u\\r\\n\", (unsigned)max_age);\n#else  /* NO_CACHING */\n\treturn send_no_cache_header(conn);\n#endif /* !NO_CACHING */\n}\n\n\nstatic int\nsend_additional_header(struct mg_connection *conn)\n{\n\tint i = 0;\n\tconst char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];\n\n#if !defined(NO_SSL)\n\tif (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {\n\t\tint max_age = atoi(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);\n\t\tif (max_age >= 0) {\n\t\t\ti += mg_printf(conn,\n\t\t\t               \"Strict-Transport-Security: max-age=%u\\r\\n\",\n\t\t\t               (unsigned)max_age);\n\t\t}\n\t}\n#endif\n\n\tif (header && header[0]) {\n\t\ti += mg_printf(conn, \"%s\\r\\n\", header);\n\t}\n\n\treturn i;\n}\n\n\nstatic void handle_file_based_request(struct mg_connection *conn,\n                                      const char *path,\n                                      struct mg_file *filep);\n\n\nconst char *\nmg_get_response_code_text(const struct mg_connection *conn, int response_code)\n{\n\t/* See IANA HTTP status code assignment:\n\t * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n\t */\n\n\tswitch (response_code) {\n\t/* RFC2616 Section 10.1 - Informational 1xx */\n\tcase 100:\n\t\treturn \"Continue\"; /* RFC2616 Section 10.1.1 */\n\tcase 101:\n\t\treturn \"Switching Protocols\"; /* RFC2616 Section 10.1.2 */\n\tcase 102:\n\t\treturn \"Processing\"; /* RFC2518 Section 10.1 */\n\n\t/* RFC2616 Section 10.2 - Successful 2xx */\n\tcase 200:\n\t\treturn \"OK\"; /* RFC2616 Section 10.2.1 */\n\tcase 201:\n\t\treturn \"Created\"; /* RFC2616 Section 10.2.2 */\n\tcase 202:\n\t\treturn \"Accepted\"; /* RFC2616 Section 10.2.3 */\n\tcase 203:\n\t\treturn \"Non-Authoritative Information\"; /* RFC2616 Section 10.2.4 */\n\tcase 204:\n\t\treturn \"No Content\"; /* RFC2616 Section 10.2.5 */\n\tcase 205:\n\t\treturn \"Reset Content\"; /* RFC2616 Section 10.2.6 */\n\tcase 206:\n\t\treturn \"Partial Content\"; /* RFC2616 Section 10.2.7 */\n\tcase 207:\n\t\treturn \"Multi-Status\"; /* RFC2518 Section 10.2, RFC4918 Section 11.1\n\t\t                          */\n\tcase 208:\n\t\treturn \"Already Reported\"; /* RFC5842 Section 7.1 */\n\n\tcase 226:\n\t\treturn \"IM used\"; /* RFC3229 Section 10.4.1 */\n\n\t/* RFC2616 Section 10.3 - Redirection 3xx */\n\tcase 300:\n\t\treturn \"Multiple Choices\"; /* RFC2616 Section 10.3.1 */\n\tcase 301:\n\t\treturn \"Moved Permanently\"; /* RFC2616 Section 10.3.2 */\n\tcase 302:\n\t\treturn \"Found\"; /* RFC2616 Section 10.3.3 */\n\tcase 303:\n\t\treturn \"See Other\"; /* RFC2616 Section 10.3.4 */\n\tcase 304:\n\t\treturn \"Not Modified\"; /* RFC2616 Section 10.3.5 */\n\tcase 305:\n\t\treturn \"Use Proxy\"; /* RFC2616 Section 10.3.6 */\n\tcase 307:\n\t\treturn \"Temporary Redirect\"; /* RFC2616 Section 10.3.8 */\n\tcase 308:\n\t\treturn \"Permanent Redirect\"; /* RFC7238 Section 3 */\n\n\t/* RFC2616 Section 10.4 - Client Error 4xx */\n\tcase 400:\n\t\treturn \"Bad Request\"; /* RFC2616 Section 10.4.1 */\n\tcase 401:\n\t\treturn \"Unauthorized\"; /* RFC2616 Section 10.4.2 */\n\tcase 402:\n\t\treturn \"Payment Required\"; /* RFC2616 Section 10.4.3 */\n\tcase 403:\n\t\treturn \"Forbidden\"; /* RFC2616 Section 10.4.4 */\n\tcase 404:\n\t\treturn \"Not Found\"; /* RFC2616 Section 10.4.5 */\n\tcase 405:\n\t\treturn \"Method Not Allowed\"; /* RFC2616 Section 10.4.6 */\n\tcase 406:\n\t\treturn \"Not Acceptable\"; /* RFC2616 Section 10.4.7 */\n\tcase 407:\n\t\treturn \"Proxy Authentication Required\"; /* RFC2616 Section 10.4.8 */\n\tcase 408:\n\t\treturn \"Request Time-out\"; /* RFC2616 Section 10.4.9 */\n\tcase 409:\n\t\treturn \"Conflict\"; /* RFC2616 Section 10.4.10 */\n\tcase 410:\n\t\treturn \"Gone\"; /* RFC2616 Section 10.4.11 */\n\tcase 411:\n\t\treturn \"Length Required\"; /* RFC2616 Section 10.4.12 */\n\tcase 412:\n\t\treturn \"Precondition Failed\"; /* RFC2616 Section 10.4.13 */\n\tcase 413:\n\t\treturn \"Request Entity Too Large\"; /* RFC2616 Section 10.4.14 */\n\tcase 414:\n\t\treturn \"Request-URI Too Large\"; /* RFC2616 Section 10.4.15 */\n\tcase 415:\n\t\treturn \"Unsupported Media Type\"; /* RFC2616 Section 10.4.16 */\n\tcase 416:\n\t\treturn \"Requested range not satisfiable\"; /* RFC2616 Section 10.4.17\n\t\t                                             */\n\tcase 417:\n\t\treturn \"Expectation Failed\"; /* RFC2616 Section 10.4.18 */\n\n\tcase 421:\n\t\treturn \"Misdirected Request\"; /* RFC7540 Section 9.1.2 */\n\tcase 422:\n\t\treturn \"Unproccessable entity\"; /* RFC2518 Section 10.3, RFC4918\n\t\t                                 * Section 11.2 */\n\tcase 423:\n\t\treturn \"Locked\"; /* RFC2518 Section 10.4, RFC4918 Section 11.3 */\n\tcase 424:\n\t\treturn \"Failed Dependency\"; /* RFC2518 Section 10.5, RFC4918\n\t\t                             * Section 11.4 */\n\n\tcase 426:\n\t\treturn \"Upgrade Required\"; /* RFC 2817 Section 4 */\n\n\tcase 428:\n\t\treturn \"Precondition Required\"; /* RFC 6585, Section 3 */\n\tcase 429:\n\t\treturn \"Too Many Requests\"; /* RFC 6585, Section 4 */\n\n\tcase 431:\n\t\treturn \"Request Header Fields Too Large\"; /* RFC 6585, Section 5 */\n\n\tcase 451:\n\t\treturn \"Unavailable For Legal Reasons\"; /* draft-tbray-http-legally-restricted-status-05,\n\t\t                                         * Section 3 */\n\n\t/* RFC2616 Section 10.5 - Server Error 5xx */\n\tcase 500:\n\t\treturn \"Internal Server Error\"; /* RFC2616 Section 10.5.1 */\n\tcase 501:\n\t\treturn \"Not Implemented\"; /* RFC2616 Section 10.5.2 */\n\tcase 502:\n\t\treturn \"Bad Gateway\"; /* RFC2616 Section 10.5.3 */\n\tcase 503:\n\t\treturn \"Service Unavailable\"; /* RFC2616 Section 10.5.4 */\n\tcase 504:\n\t\treturn \"Gateway Time-out\"; /* RFC2616 Section 10.5.5 */\n\tcase 505:\n\t\treturn \"HTTP Version not supported\"; /* RFC2616 Section 10.5.6 */\n\tcase 506:\n\t\treturn \"Variant Also Negotiates\"; /* RFC 2295, Section 8.1 */\n\tcase 507:\n\t\treturn \"Insufficient Storage\"; /* RFC2518 Section 10.6, RFC4918\n\t\t                                * Section 11.5 */\n\tcase 508:\n\t\treturn \"Loop Detected\"; /* RFC5842 Section 7.1 */\n\n\tcase 510:\n\t\treturn \"Not Extended\"; /* RFC 2774, Section 7 */\n\tcase 511:\n\t\treturn \"Network Authentication Required\"; /* RFC 6585, Section 6 */\n\n\t/* Other status codes, not shown in the IANA HTTP status code\n\t * assignment.\n\t * E.g., \"de facto\" standards due to common use, ... */\n\tcase 418:\n\t\treturn \"I am a teapot\"; /* RFC2324 Section 2.3.2 */\n\tcase 419:\n\t\treturn \"Authentication Timeout\"; /* common use */\n\tcase 420:\n\t\treturn \"Enhance Your Calm\"; /* common use */\n\tcase 440:\n\t\treturn \"Login Timeout\"; /* common use */\n\tcase 509:\n\t\treturn \"Bandwidth Limit Exceeded\"; /* common use */\n\n\tdefault:\n\t\t/* This error code is unknown. This should not happen. */\n\t\tif (conn) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Unknown HTTP response code: %u\",\n\t\t\t                response_code);\n\t\t}\n\n\t\t/* Return at least a category according to RFC 2616 Section 10. */\n\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t/* Unknown informational status code */\n\t\t\treturn \"Information\";\n\t\t}\n\t\tif (response_code >= 200 && response_code < 300) {\n\t\t\t/* Unknown success code */\n\t\t\treturn \"Success\";\n\t\t}\n\t\tif (response_code >= 300 && response_code < 400) {\n\t\t\t/* Unknown redirection code */\n\t\t\treturn \"Redirection\";\n\t\t}\n\t\tif (response_code >= 400 && response_code < 500) {\n\t\t\t/* Unknown request error code */\n\t\t\treturn \"Client Error\";\n\t\t}\n\t\tif (response_code >= 500 && response_code < 600) {\n\t\t\t/* Unknown server error code */\n\t\t\treturn \"Server Error\";\n\t\t}\n\n\t\t/* Response code not even within reasonable range */\n\t\treturn \"\";\n\t}\n}\n\n\nstatic int\nmg_send_http_error_impl(struct mg_connection *conn,\n                        int status,\n                        const char *fmt,\n                        va_list args)\n{\n\tchar errmsg_buf[MG_BUF_LEN];\n\tchar path_buf[PATH_MAX];\n\tva_list ap;\n\tint len, i, page_handler_found, scope, truncated, has_body;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tconst char *error_handler = NULL;\n\tstruct mg_file error_page_file = STRUCT_FILE_INITIALIZER;\n\tconst char *error_page_file_ext, *tstr;\n\tint handled_by_callback = 0;\n\n\tconst char *status_text = mg_get_response_code_text(conn, status);\n\n\tif ((conn == NULL) || (fmt == NULL)) {\n\t\treturn -2;\n\t}\n\n\t/* Set status (for log) */\n\tconn->status_code = status;\n\n\t/* Errors 1xx, 204 and 304 MUST NOT send a body */\n\thas_body = ((status > 199) && (status != 204) && (status != 304));\n\n\t/* Prepare message in buf, if required */\n\tif (has_body || (!conn->in_error_handler\n\t                 && (conn->phys_ctx->callbacks.http_error != NULL))) {\n\t\t/* Store error message in errmsg_buf */\n\t\tva_copy(ap, args);\n\t\tmg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);\n\t\tva_end(ap);\n\t\t/* In a debug build, print all html errors */\n\t\tDEBUG_TRACE(\"Error %i - [%s]\", status, errmsg_buf);\n\t}\n\n\t/* If there is a http_error callback, call it.\n\t * But don't do it recursively, if callback calls mg_send_http_error again.\n\t */\n\tif (!conn->in_error_handler\n\t    && (conn->phys_ctx->callbacks.http_error != NULL)) {\n\t\t/* Mark in_error_handler to avoid recursion and call user callback. */\n\t\tconn->in_error_handler = 1;\n\t\thandled_by_callback =\n\t\t    (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf)\n\t\t     == 0);\n\t\tconn->in_error_handler = 0;\n\t}\n\n\tif (!handled_by_callback) {\n\t\t/* Check for recursion */\n\t\tif (conn->in_error_handler) {\n\t\t\tDEBUG_TRACE(\n\t\t\t    \"Recursion when handling error %u - fall back to default\",\n\t\t\t    status);\n\t\t} else {\n\t\t\t/* Send user defined error pages, if defined */\n\t\t\terror_handler = conn->dom_ctx->config[ERROR_PAGES];\n\t\t\terror_page_file_ext = conn->dom_ctx->config[INDEX_FILES];\n\t\t\tpage_handler_found = 0;\n\n\t\t\tif (error_handler != NULL) {\n\t\t\t\tfor (scope = 1; (scope <= 3) && !page_handler_found; scope++) {\n\t\t\t\t\tswitch (scope) {\n\t\t\t\t\tcase 1: /* Handler for specific error, e.g. 404 error */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror%03u.\",\n\t\t\t\t\t\t            error_handler,\n\t\t\t\t\t\t            status);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: /* Handler for error group, e.g., 5xx error\n\t\t\t\t\t         * handler\n\t\t\t\t\t         * for all server errors (500-599) */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror%01uxx.\",\n\t\t\t\t\t\t            error_handler,\n\t\t\t\t\t\t            status / 100);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: /* Handler for all errors */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror.\",\n\t\t\t\t\t\t            error_handler);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* String truncation in buf may only occur if\n\t\t\t\t\t * error_handler is too long. This string is\n\t\t\t\t\t * from the config, not from a client. */\n\t\t\t\t\t(void)truncated;\n\n\t\t\t\t\tlen = (int)strlen(path_buf);\n\n\t\t\t\t\ttstr = strchr(error_page_file_ext, '.');\n\n\t\t\t\t\twhile (tstr) {\n\t\t\t\t\t\tfor (i = 1;\n\t\t\t\t\t\t     (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');\n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\t/* buffer overrun is not possible here, since\n\t\t\t\t\t\t\t * (i < 32) && (len < sizeof(path_buf) - 32)\n\t\t\t\t\t\t\t * ==> (i + len) < sizeof(path_buf) */\n\t\t\t\t\t\t\tpath_buf[len + i - 1] = tstr[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* buffer overrun is not possible here, since\n\t\t\t\t\t\t * (i <= 32) && (len < sizeof(path_buf) - 32)\n\t\t\t\t\t\t * ==> (i + len) <= sizeof(path_buf) */\n\t\t\t\t\t\tpath_buf[len + i - 1] = 0;\n\n\t\t\t\t\t\tif (mg_stat(conn, path_buf, &error_page_file.stat)) {\n\t\t\t\t\t\t\tDEBUG_TRACE(\"Check error page %s - found\",\n\t\t\t\t\t\t\t            path_buf);\n\t\t\t\t\t\t\tpage_handler_found = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDEBUG_TRACE(\"Check error page %s - not found\",\n\t\t\t\t\t\t            path_buf);\n\n\t\t\t\t\t\ttstr = strchr(tstr + i, '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (page_handler_found) {\n\t\t\t\tconn->in_error_handler = 1;\n\t\t\t\thandle_file_based_request(conn, path_buf, &error_page_file);\n\t\t\t\tconn->in_error_handler = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/* No custom error page. Send default error page. */\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\n\t\tconn->must_close = 1;\n\t\tmg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tif (has_body) {\n\t\t\tmg_printf(conn,\n\t\t\t          \"%s\",\n\t\t\t          \"Content-Type: text/plain; charset=utf-8\\r\\n\");\n\t\t}\n\t\tmg_printf(conn,\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Connection: close\\r\\n\\r\\n\",\n\t\t          date);\n\n\t\t/* HTTP responses 1xx, 204 and 304 MUST NOT send a body */\n\t\tif (has_body) {\n\t\t\t/* For other errors, send a generic error message. */\n\t\t\tmg_printf(conn, \"Error %d: %s\\n\", status, status_text);\n\t\t\tmg_write(conn, errmsg_buf, strlen(errmsg_buf));\n\n\t\t} else {\n\t\t\t/* No body allowed. Close the connection. */\n\t\t\tDEBUG_TRACE(\"Error %i\", status);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint\nmg_send_http_error(struct mg_connection *conn, int status, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = mg_send_http_error_impl(conn, status, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\n\nint\nmg_send_http_ok(struct mg_connection *conn,\n                const char *mime_type,\n                long long content_length)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif ((mime_type == NULL) || (*mime_type == 0)) {\n\t\t/* Parameter error */\n\t\treturn -2;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tmg_printf(conn,\n\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t          \"Content-Type: %s\\r\\n\"\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\",\n\t          mime_type,\n\t          date,\n\t          suggest_connection_header(conn));\n\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tif (content_length < 0) {\n\t\tmg_printf(conn, \"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n\t} else {\n\t\tmg_printf(conn,\n\t\t          \"Content-Length: %\" UINT64_FMT \"\\r\\n\\r\\n\",\n\t\t          (uint64_t)content_length);\n\t}\n\n\treturn 0;\n}\n\n\nint\nmg_send_http_redirect(struct mg_connection *conn,\n                      const char *target_url,\n                      int redirect_code)\n{\n\t/* Send a 30x redirect response.\n\t *\n\t * Redirect types (status codes):\n\t *\n\t * Status | Perm/Temp | Method              | Version\n\t *   301  | permanent | POST->GET undefined | HTTP/1.0\n\t *   302  | temporary | POST->GET undefined | HTTP/1.0\n\t *   303  | temporary | always use GET      | HTTP/1.1\n\t *   307  | temporary | always keep method  | HTTP/1.1\n\t *   308  | permanent | always keep method  | HTTP/1.1\n\t */\n\tconst char *redirect_text;\n\tint ret;\n\tsize_t content_len = 0;\n\tchar reply[MG_BUF_LEN];\n\n\t/* In case redirect_code=0, use 307. */\n\tif (redirect_code == 0) {\n\t\tredirect_code = 307;\n\t}\n\n\t/* In case redirect_code is none of the above, return error. */\n\tif ((redirect_code != 301) && (redirect_code != 302)\n\t    && (redirect_code != 303) && (redirect_code != 307)\n\t    && (redirect_code != 308)) {\n\t\t/* Parameter error */\n\t\treturn -2;\n\t}\n\n\t/* Get proper text for response code */\n\tredirect_text = mg_get_response_code_text(conn, redirect_code);\n\n\t/* If target_url is not defined, redirect to \"/\". */\n\tif ((target_url == NULL) || (*target_url == 0)) {\n\t\ttarget_url = \"/\";\n\t}\n\n#if defined(MG_SEND_REDIRECT_BODY)\n\t/* TODO: condition name? */\n\n\t/* Prepare a response body with a hyperlink.\n\t *\n\t * According to RFC2616 (and RFC1945 before):\n\t * Unless the request method was HEAD, the entity of the\n\t * response SHOULD contain a short hypertext note with a hyperlink to\n\t * the new URI(s).\n\t *\n\t * However, this response body is not useful in M2M communication.\n\t * Probably the original reason in the RFC was, clients not supporting\n\t * a 30x HTTP redirect could still show the HTML page and let the user\n\t * press the link. Since current browsers support 30x HTTP, the additional\n\t * HTML body does not seem to make sense anymore.\n\t *\n\t * The new RFC7231 (Section 6.4) does no longer recommend it (\"SHOULD\"),\n\t * but it only notes:\n\t * The server's response payload usually contains a short\n\t * hypertext note with a hyperlink to the new URI(s).\n\t *\n\t * Deactivated by default. If you need the 30x body, set the define.\n\t */\n\tmg_snprintf(\n\t    conn,\n\t    NULL /* ignore truncation */,\n\t    reply,\n\t    sizeof(reply),\n\t    \"<html><head>%s</head><body><a href=\\\"%s\\\">%s</a></body></html>\",\n\t    redirect_text,\n\t    target_url,\n\t    target_url);\n\tcontent_len = strlen(reply);\n#else\n\treply[0] = 0;\n#endif\n\n\t/* Do not send any additional header. For all other options,\n\t * including caching, there are suitable defaults. */\n\tret = mg_printf(conn,\n\t                \"HTTP/1.1 %i %s\\r\\n\"\n\t                \"Location: %s\\r\\n\"\n\t                \"Content-Length: %u\\r\\n\"\n\t                \"Connection: %s\\r\\n\\r\\n\",\n\t                redirect_code,\n\t                redirect_text,\n\t                target_url,\n\t                (unsigned int)content_len,\n\t                suggest_connection_header(conn));\n\n\t/* Send response body */\n\tif (ret > 0) {\n\t\t/* ... unless it is a HEAD request */\n\t\tif (0 != strcmp(conn->request_info.request_method, \"HEAD\")) {\n\t\t\tret = mg_write(conn, reply, content_len);\n\t\t}\n\t}\n\n\treturn (ret > 0) ? ret : -1;\n}\n\n\n#if defined(_WIN32)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_init(pthread_mutex_t *mutex, void *unused)\n{\n\t(void)unused;\n\t*mutex = CreateMutex(NULL, FALSE, NULL);\n\treturn (*mutex == NULL) ? -1 : 0;\n}\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_destroy(pthread_mutex_t *mutex)\n{\n\treturn (CloseHandle(*mutex) == 0) ? -1 : 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\treturn (WaitForSingleObject(*mutex, (DWORD)INFINITE) == WAIT_OBJECT_0) ? 0\n\t                                                                       : -1;\n}\n\n\n#if defined(ENABLE_UNUSED_PTHREAD_FUNCTIONS)\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_trylock(pthread_mutex_t *mutex)\n{\n\tswitch (WaitForSingleObject(*mutex, 0)) {\n\tcase WAIT_OBJECT_0:\n\t\treturn 0;\n\tcase WAIT_TIMEOUT:\n\t\treturn -2; /* EBUSY */\n\t}\n\treturn -1;\n}\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\treturn (ReleaseMutex(*mutex) == 0) ? -1 : 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_init(pthread_cond_t *cv, const void *unused)\n{\n\t(void)unused;\n\tInitializeCriticalSection(&cv->threadIdSec);\n\tcv->waiting_thread = NULL;\n\treturn 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_timedwait(pthread_cond_t *cv,\n                       pthread_mutex_t *mutex,\n                       FUNCTION_MAY_BE_UNUSED const struct timespec *abstime)\n{\n\tstruct mg_workerTLS **ptls,\n\t    *tls = (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\tint ok;\n\tint64_t nsnow, nswaitabs, nswaitrel;\n\tDWORD mswaitrel;\n\n\tEnterCriticalSection(&cv->threadIdSec);\n\t/* Add this thread to cv's waiting list */\n\tptls = &cv->waiting_thread;\n\tfor (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread)\n\t\t;\n\ttls->next_waiting_thread = NULL;\n\t*ptls = tls;\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\tif (abstime) {\n\t\tnsnow = mg_get_current_time_ns();\n\t\tnswaitabs =\n\t\t    (((int64_t)abstime->tv_sec) * 1000000000) + abstime->tv_nsec;\n\t\tnswaitrel = nswaitabs - nsnow;\n\t\tif (nswaitrel < 0) {\n\t\t\tnswaitrel = 0;\n\t\t}\n\t\tmswaitrel = (DWORD)(nswaitrel / 1000000);\n\t} else {\n\t\tmswaitrel = (DWORD)INFINITE;\n\t}\n\n\tpthread_mutex_unlock(mutex);\n\tok = (WAIT_OBJECT_0\n\t      == WaitForSingleObject(tls->pthread_cond_helper_mutex, mswaitrel));\n\tif (!ok) {\n\t\tok = 1;\n\t\tEnterCriticalSection(&cv->threadIdSec);\n\t\tptls = &cv->waiting_thread;\n\t\tfor (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread) {\n\t\t\tif (*ptls == tls) {\n\t\t\t\t*ptls = tls->next_waiting_thread;\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tLeaveCriticalSection(&cv->threadIdSec);\n\t\tif (ok) {\n\t\t\tWaitForSingleObject(tls->pthread_cond_helper_mutex,\n\t\t\t                    (DWORD)INFINITE);\n\t\t}\n\t}\n\t/* This thread has been removed from cv's waiting list */\n\tpthread_mutex_lock(mutex);\n\n\treturn ok ? 0 : -1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex)\n{\n\treturn pthread_cond_timedwait(cv, mutex, NULL);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_signal(pthread_cond_t *cv)\n{\n\tHANDLE wkup = NULL;\n\tBOOL ok = FALSE;\n\n\tEnterCriticalSection(&cv->threadIdSec);\n\tif (cv->waiting_thread) {\n\t\twkup = cv->waiting_thread->pthread_cond_helper_mutex;\n\t\tcv->waiting_thread = cv->waiting_thread->next_waiting_thread;\n\n\t\tok = SetEvent(wkup);\n\t\tDEBUG_ASSERT(ok);\n\t}\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\treturn ok ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_broadcast(pthread_cond_t *cv)\n{\n\tEnterCriticalSection(&cv->threadIdSec);\n\twhile (cv->waiting_thread) {\n\t\tpthread_cond_signal(cv);\n\t}\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\treturn 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_destroy(pthread_cond_t *cv)\n{\n\tEnterCriticalSection(&cv->threadIdSec);\n\tDEBUG_ASSERT(cv->waiting_thread == NULL);\n\tLeaveCriticalSection(&cv->threadIdSec);\n\tDeleteCriticalSection(&cv->threadIdSec);\n\n\treturn 0;\n}\n\n\n#if defined(ALTERNATIVE_QUEUE)\nFUNCTION_MAY_BE_UNUSED\nstatic void *\nevent_create(void)\n{\n\treturn (void *)CreateEvent(NULL, FALSE, FALSE, NULL);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nevent_wait(void *eventhdl)\n{\n\tint res = WaitForSingleObject((HANDLE)eventhdl, (DWORD)INFINITE);\n\treturn (res == WAIT_OBJECT_0);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nevent_signal(void *eventhdl)\n{\n\treturn (int)SetEvent((HANDLE)eventhdl);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tCloseHandle((HANDLE)eventhdl);\n}\n#endif\n\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n\n/* For Windows, change all slashes to backslashes in path names. */\nstatic void\nchange_slashes_to_backslashes(char *path)\n{\n\tint i;\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == '/') {\n\t\t\tpath[i] = '\\\\';\n\t\t}\n\n\t\t/* remove double backslash (check i > 0 to preserve UNC paths,\n\t\t * like \\\\server\\file.txt) */\n\t\tif ((path[i] == '\\\\') && (i > 0)) {\n\t\t\twhile ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {\n\t\t\t\t(void)memmove(path + i + 1, path + i + 2, strlen(path + i + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nmg_wcscasecmp(const wchar_t *s1, const wchar_t *s2)\n{\n\tint diff;\n\n\tdo {\n\t\tdiff = tolower(*s1) - tolower(*s2);\n\t\ts1++;\n\t\ts2++;\n\t} while ((diff == 0) && (s1[-1] != '\\0'));\n\n\treturn diff;\n}\n\n\n/* Encode 'path' which is assumed UTF-8 string, into UNICODE string.\n * wbuf and wbuf_len is a target buffer and its length. */\nstatic void\npath_to_unicode(const struct mg_connection *conn,\n                const char *path,\n                wchar_t *wbuf,\n                size_t wbuf_len)\n{\n\tchar buf[PATH_MAX], buf2[PATH_MAX];\n\twchar_t wbuf2[W_PATH_MAX + 1];\n\tDWORD long_len, err;\n\tint (*fcompare)(const wchar_t *, const wchar_t *) = mg_wcscasecmp;\n\n\tmg_strlcpy(buf, path, sizeof(buf));\n\tchange_slashes_to_backslashes(buf);\n\n\t/* Convert to Unicode and back. If doubly-converted string does not\n\t * match the original, something is fishy, reject. */\n\tmemset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n\tMultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);\n\tWideCharToMultiByte(\n\t    CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);\n\tif (strcmp(buf, buf2) != 0) {\n\t\twbuf[0] = L'\\0';\n\t}\n\n\t/* Windows file systems are not case sensitive, but you can still use\n\t * uppercase and lowercase letters (on all modern file systems).\n\t * The server can check if the URI uses the same upper/lowercase\n\t * letters an the file system, effectively making Windows servers\n\t * case sensitive (like Linux servers are). It is still not possible\n\t * to use two files with the same name in different cases on Windows\n\t * (like /a and /A) - this would be possible in Linux.\n\t * As a default, Windows is not case sensitive, but the case sensitive\n\t * file name check can be activated by an additional configuration. */\n\tif (conn) {\n\t\tif (conn->dom_ctx->config[CASE_SENSITIVE_FILES]\n\t\t    && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],\n\t\t                      \"yes\")) {\n\t\t\t/* Use case sensitive compare function */\n\t\t\tfcompare = wcscmp;\n\t\t}\n\t}\n\t(void)conn; /* conn is currently unused */\n\n#if !defined(_WIN32_WCE)\n\t/* Only accept a full file path, not a Windows short (8.3) path. */\n\tmemset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));\n\tlong_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);\n\tif (long_len == 0) {\n\t\terr = GetLastError();\n\t\tif (err == ERROR_FILE_NOT_FOUND) {\n\t\t\t/* File does not exist. This is not always a problem here. */\n\t\t\treturn;\n\t\t}\n\t}\n\tif ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {\n\t\t/* Short name is used. */\n\t\twbuf[0] = L'\\0';\n\t}\n#else\n\t(void)long_len;\n\t(void)wbuf2;\n\t(void)err;\n\n\tif (strchr(path, '~')) {\n\t\twbuf[0] = L'\\0';\n\t}\n#endif\n}\n\n\n/* Windows happily opens files with some garbage at the end of file name.\n * For example, fopen(\"a.cgi    \", \"r\") on Windows successfully opens\n * \"a.cgi\", despite one would expect an error back.\n * This function returns non-0 if path ends with some garbage. */\nstatic int\npath_cannot_disclose_cgi(const char *path)\n{\n\tstatic const char *allowed_last_characters = \"_-\";\n\tint last = path[strlen(path) - 1];\n\treturn isalnum(last) || strchr(allowed_last_characters, last) != NULL;\n}\n\n\nstatic int\nmg_stat(const struct mg_connection *conn,\n        const char *path,\n        struct mg_file_stat *filep)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tWIN32_FILE_ATTRIBUTE_DATA info;\n\ttime_t creation_time;\n\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tmemset(filep, 0, sizeof(*filep));\n\n\tif (conn && is_file_in_memory(conn, path)) {\n\t\t/* filep->is_directory = 0; filep->gzipped = 0; .. already done by\n\t\t * memset */\n\n\t\t/* Quick fix (for 1.9.x): */\n\t\t/* mg_stat must fill all fields, also for files in memory */\n\t\tstruct mg_file tmp_file = STRUCT_FILE_INITIALIZER;\n\t\topen_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);\n\t\tfilep->size = tmp_file.stat.size;\n\t\tfilep->location = 2;\n\t\t/* TODO: for 1.10: restructure how files in memory are handled */\n\n\t\t/* The \"file in memory\" feature is a candidate for deletion.\n\t\t * Please join the discussion at\n\t\t * https://groups.google.com/forum/#!topic/civetweb/h9HT4CmeYqI\n\t\t */\n\n\t\tfilep->last_modified = time(NULL); /* TODO */\n\t\t/* last_modified = now ... assumes the file may change during\n\t\t * runtime,\n\t\t * so every mg_fopen call may return different data */\n\t\t/* last_modified = conn->phys_ctx.start_time;\n\t\t * May be used it the data does not change during runtime. This\n\t\t * allows\n\t\t * browser caching. Since we do not know, we have to assume the file\n\t\t * in memory may change. */\n\t\treturn 1;\n\t}\n\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\tif (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {\n\t\tfilep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);\n\t\tfilep->last_modified =\n\t\t    SYS2UNIX_TIME(info.ftLastWriteTime.dwLowDateTime,\n\t\t                  info.ftLastWriteTime.dwHighDateTime);\n\n\t\t/* On Windows, the file creation time can be higher than the\n\t\t * modification time, e.g. when a file is copied.\n\t\t * Since the Last-Modified timestamp is used for caching\n\t\t * it should be based on the most recent timestamp. */\n\t\tcreation_time = SYS2UNIX_TIME(info.ftCreationTime.dwLowDateTime,\n\t\t                              info.ftCreationTime.dwHighDateTime);\n\t\tif (creation_time > filep->last_modified) {\n\t\t\tfilep->last_modified = creation_time;\n\t\t}\n\n\t\tfilep->is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;\n\t\t/* If file name is fishy, reset the file structure and return\n\t\t * error.\n\t\t * Note it is important to reset, not just return the error, cause\n\t\t * functions like is_file_opened() check the struct. */\n\t\tif (!filep->is_directory && !path_cannot_disclose_cgi(path)) {\n\t\t\tmemset(filep, 0, sizeof(*filep));\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int\nmg_remove(const struct mg_connection *conn, const char *path)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\treturn DeleteFileW(wbuf) ? 0 : -1;\n}\n\n\nstatic int\nmg_mkdir(const struct mg_connection *conn, const char *path, int mode)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\t(void)mode;\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\treturn CreateDirectoryW(wbuf, NULL) ? 0 : -1;\n}\n\n\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\n/* Implementation of POSIX opendir/closedir/readdir for Windows. */\nFUNCTION_MAY_BE_UNUSED\nstatic DIR *\nmg_opendir(const struct mg_connection *conn, const char *name)\n{\n\tDIR *dir = NULL;\n\twchar_t wpath[W_PATH_MAX];\n\tDWORD attrs;\n\n\tif (name == NULL) {\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t} else if ((dir = (DIR *)mg_malloc(sizeof(*dir))) == NULL) {\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\n\t} else {\n\t\tpath_to_unicode(conn, name, wpath, ARRAY_SIZE(wpath));\n\t\tattrs = GetFileAttributesW(wpath);\n\t\tif ((wcslen(wpath) + 2 < ARRAY_SIZE(wpath)) && (attrs != 0xFFFFFFFF)\n\t\t    && ((attrs & FILE_ATTRIBUTE_DIRECTORY) != 0)) {\n\t\t\t(void)wcscat(wpath, L\"\\\\*\");\n\t\t\tdir->handle = FindFirstFileW(wpath, &dir->info);\n\t\t\tdir->result.d_name[0] = '\\0';\n\t\t} else {\n\t\t\tmg_free(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\treturn dir;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_closedir(DIR *dir)\n{\n\tint result = 0;\n\n\tif (dir != NULL) {\n\t\tif (dir->handle != INVALID_HANDLE_VALUE)\n\t\t\tresult = FindClose(dir->handle) ? 0 : -1;\n\n\t\tmg_free(dir);\n\t} else {\n\t\tresult = -1;\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t}\n\n\treturn result;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct dirent *\nmg_readdir(DIR *dir)\n{\n\tstruct dirent *result = 0;\n\n\tif (dir) {\n\t\tif (dir->handle != INVALID_HANDLE_VALUE) {\n\t\t\tresult = &dir->result;\n\t\t\t(void)WideCharToMultiByte(CP_UTF8,\n\t\t\t                          0,\n\t\t\t                          dir->info.cFileName,\n\t\t\t                          -1,\n\t\t\t                          result->d_name,\n\t\t\t                          sizeof(result->d_name),\n\t\t\t                          NULL,\n\t\t\t                          NULL);\n\n\t\t\tif (!FindNextFileW(dir->handle, &dir->info)) {\n\t\t\t\t(void)FindClose(dir->handle);\n\t\t\t\tdir->handle = INVALID_HANDLE_VALUE;\n\t\t\t}\n\n\t\t} else {\n\t\t\tSetLastError(ERROR_FILE_NOT_FOUND);\n\t\t}\n\t} else {\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t}\n\n\treturn result;\n}\n\n\n#if !defined(HAVE_POLL)\n#define POLLIN (1)  /* Data ready - read will not block. */\n#define POLLPRI (2) /* Priority data ready. */\n#define POLLOUT (4) /* Send queue not full - write will not block. */\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npoll(struct pollfd *pfd, unsigned int n, int milliseconds)\n{\n\tstruct timeval tv;\n\tfd_set rset;\n\tfd_set wset;\n\tunsigned int i;\n\tint result;\n\tSOCKET maxfd = 0;\n\n\tmemset(&tv, 0, sizeof(tv));\n\ttv.tv_sec = milliseconds / 1000;\n\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\tFD_ZERO(&rset);\n\tFD_ZERO(&wset);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (pfd[i].events & POLLIN) {\n\t\t\tFD_SET((SOCKET)pfd[i].fd, &rset);\n\t\t} else if (pfd[i].events & POLLOUT) {\n\t\t\tFD_SET((SOCKET)pfd[i].fd, &wset);\n\t\t}\n\t\tpfd[i].revents = 0;\n\n\t\tif (pfd[i].fd > maxfd) {\n\t\t\tmaxfd = pfd[i].fd;\n\t\t}\n\t}\n\n\tif ((result = select((int)maxfd + 1, &rset, &wset, NULL, &tv)) > 0) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (FD_ISSET(pfd[i].fd, &rset)) {\n\t\t\t\tpfd[i].revents |= POLLIN;\n\t\t\t}\n\t\t\tif (FD_ISSET(pfd[i].fd, &wset)) {\n\t\t\t\tpfd[i].revents |= POLLOUT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* We should subtract the time used in select from remaining\n\t * \"milliseconds\", in particular if called from mg_poll with a\n\t * timeout quantum.\n\t * Unfortunately, the remaining time is not stored in \"tv\" in all\n\t * implementations, so the result in \"tv\" must be considered undefined.\n\t * See http://man7.org/linux/man-pages/man2/select.2.html */\n\n\treturn result;\n}\n#endif /* HAVE_POLL */\n\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n\nstatic void\nset_close_on_exec(SOCKET sock, struct mg_connection *conn /* may be null */)\n{\n\t(void)conn; /* Unused. */\n#if defined(_WIN32_WCE)\n\t(void)sock;\n#else\n\t(void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);\n#endif\n}\n\n\nint\nmg_start_thread(mg_thread_func_t f, void *p)\n{\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size, e.g.\n\t * -DUSE_STACK_SIZE=16384\n\t */\n\treturn ((_beginthread((void(__cdecl *)(void *))f, USE_STACK_SIZE, p)\n\t         == ((uintptr_t)(-1L)))\n\t            ? -1\n\t            : 0);\n#else\n\treturn (\n\t    (_beginthread((void(__cdecl *)(void *))f, 0, p) == ((uintptr_t)(-1L)))\n\t        ? -1\n\t        : 0);\n#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */\n}\n\n\n/* Start a thread storing the thread context. */\nstatic int\nmg_start_thread_with_id(unsigned(__stdcall *f)(void *),\n                        void *p,\n                        pthread_t *threadidptr)\n{\n\tuintptr_t uip;\n\tHANDLE threadhandle;\n\tint result = -1;\n\n\tuip = _beginthreadex(NULL, 0, (unsigned(__stdcall *)(void *))f, p, 0, NULL);\n\tthreadhandle = (HANDLE)uip;\n\tif ((uip != (uintptr_t)(-1L)) && (threadidptr != NULL)) {\n\t\t*threadidptr = threadhandle;\n\t\tresult = 0;\n\t}\n\n\treturn result;\n}\n\n\n/* Wait for a thread to finish. */\nstatic int\nmg_join_thread(pthread_t threadid)\n{\n\tint result;\n\tDWORD dwevent;\n\n\tresult = -1;\n\tdwevent = WaitForSingleObject(threadid, (DWORD)INFINITE);\n\tif (dwevent == WAIT_FAILED) {\n\t\tDEBUG_TRACE(\"WaitForSingleObject() failed, error %d\", ERRNO);\n\t} else {\n\t\tif (dwevent == WAIT_OBJECT_0) {\n\t\t\tCloseHandle(threadid);\n\t\t\tresult = 0;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n/* If SSL is loaded dynamically, dlopen/dlclose is required. */\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(__MINGW32__)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic HANDLE\ndlopen(const char *dll_name, int flags)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\t(void)flags;\n\tpath_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));\n\treturn LoadLibraryW(wbuf);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\ndlclose(void *handle)\n{\n\tint result;\n\n\tif (FreeLibrary((HMODULE)handle) != 0) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = -1;\n\t}\n\n\treturn result;\n}\n\n\n#if defined(__MINGW32__)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n#endif\n\n\n#if !defined(NO_CGI)\n#define SIGKILL (0)\n\n\nstatic int\nkill(pid_t pid, int sig_num)\n{\n\t(void)TerminateProcess((HANDLE)pid, (UINT)sig_num);\n\t(void)CloseHandle((HANDLE)pid);\n\treturn 0;\n}\n\n\n#ifndef WNOHANG\n#define WNOHANG (1)\n#endif\n\n\nstatic pid_t\nwaitpid(pid_t pid, int *status, int flags)\n{\n\tDWORD timeout = INFINITE;\n\tDWORD waitres;\n\n\t(void)status; /* Currently not used by any client here */\n\n\tif ((flags | WNOHANG) == WNOHANG) {\n\t\ttimeout = 0;\n\t}\n\n\twaitres = WaitForSingleObject((HANDLE)pid, timeout);\n\tif (waitres == WAIT_OBJECT_0) {\n\t\treturn pid;\n\t}\n\tif (waitres == WAIT_TIMEOUT) {\n\t\treturn 0;\n\t}\n\treturn (pid_t)-1;\n}\n\n\nstatic void\ntrim_trailing_whitespaces(char *s)\n{\n\tchar *e = s + strlen(s) - 1;\n\twhile ((e > s) && isspace(*(unsigned char *)e)) {\n\t\t*e-- = '\\0';\n\t}\n}\n\n\nstatic pid_t\nspawn_process(struct mg_connection *conn,\n              const char *prog,\n              char *envblk,\n              char *envp[],\n              int fdin[2],\n              int fdout[2],\n              int fderr[2],\n              const char *dir)\n{\n\tHANDLE me;\n\tchar *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],\n\t    cmdline[PATH_MAX], buf[PATH_MAX];\n\tint truncated;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tSTARTUPINFOA si;\n\tPROCESS_INFORMATION pi = {0};\n\n\t(void)envp;\n\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\tsi.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n\tsi.wShowWindow = SW_HIDE;\n\n\tme = GetCurrentProcess();\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fdin[0]),\n\t                me,\n\t                &si.hStdInput,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fdout[1]),\n\t                me,\n\t                &si.hStdOutput,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fderr[1]),\n\t                me,\n\t                &si.hStdError,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\n\t/* Mark handles that should not be inherited. See\n\t * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx\n\t */\n\tSetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\tSetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\tSetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\n\t/* If CGI file is a script, try to read the interpreter line */\n\tinterp = conn->dom_ctx->config[CGI_INTERPRETER];\n\tif (interp == NULL) {\n\t\tbuf[0] = buf[1] = '\\0';\n\n\t\t/* Read the first line of the script into the buffer */\n\t\tmg_snprintf(\n\t\t    conn, &truncated, cmdline, sizeof(cmdline), \"%s/%s\", dir, prog);\n\n\t\tif (truncated) {\n\t\t\tpi.hProcess = (pid_t)-1;\n\t\t\tgoto spawn_cleanup;\n\t\t}\n\n\t\tif (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {\n#if defined(MG_USE_OPEN_FILE)\n\t\t\tp = (char *)file.access.membuf;\n#else\n\t\t\tp = (char *)NULL;\n#endif\n\t\t\tmg_fgets(buf, sizeof(buf), &file, &p);\n\t\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t}\n\n\t\tif ((buf[0] == '#') && (buf[1] == '!')) {\n\t\t\ttrim_trailing_whitespaces(buf + 2);\n\t\t} else {\n\t\t\tbuf[2] = '\\0';\n\t\t}\n\t\tinterp = buf + 2;\n\t}\n\n\tif (interp[0] != '\\0') {\n\t\tGetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);\n\t\tinterp = full_interp;\n\t}\n\tGetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);\n\n\tif (interp[0] != '\\0') {\n\t\tmg_snprintf(conn,\n\t\t            &truncated,\n\t\t            cmdline,\n\t\t            sizeof(cmdline),\n\t\t            \"\\\"%s\\\" \\\"%s\\\\%s\\\"\",\n\t\t            interp,\n\t\t            full_dir,\n\t\t            prog);\n\t} else {\n\t\tmg_snprintf(conn,\n\t\t            &truncated,\n\t\t            cmdline,\n\t\t            sizeof(cmdline),\n\t\t            \"\\\"%s\\\\%s\\\"\",\n\t\t            full_dir,\n\t\t            prog);\n\t}\n\n\tif (truncated) {\n\t\tpi.hProcess = (pid_t)-1;\n\t\tgoto spawn_cleanup;\n\t}\n\n\tDEBUG_TRACE(\"Running [%s]\", cmdline);\n\tif (CreateProcessA(NULL,\n\t                   cmdline,\n\t                   NULL,\n\t                   NULL,\n\t                   TRUE,\n\t                   CREATE_NEW_PROCESS_GROUP,\n\t                   envblk,\n\t                   NULL,\n\t                   &si,\n\t                   &pi) == 0) {\n\t\tmg_cry_internal(\n\t\t    conn, \"%s: CreateProcess(%s): %ld\", __func__, cmdline, (long)ERRNO);\n\t\tpi.hProcess = (pid_t)-1;\n\t\t/* goto spawn_cleanup; */\n\t}\n\nspawn_cleanup:\n\t(void)CloseHandle(si.hStdOutput);\n\t(void)CloseHandle(si.hStdError);\n\t(void)CloseHandle(si.hStdInput);\n\tif (pi.hThread != NULL) {\n\t\t(void)CloseHandle(pi.hThread);\n\t}\n\n\treturn (pid_t)pi.hProcess;\n}\n#endif /* !NO_CGI */\n\n\nstatic int\nset_blocking_mode(SOCKET sock)\n{\n\tunsigned long non_blocking = 0;\n\treturn ioctlsocket(sock, (long)FIONBIO, &non_blocking);\n}\n\nstatic int\nset_non_blocking_mode(SOCKET sock)\n{\n\tunsigned long non_blocking = 1;\n\treturn ioctlsocket(sock, (long)FIONBIO, &non_blocking);\n}\n\n#else\n\nstatic int\nmg_stat(const struct mg_connection *conn,\n        const char *path,\n        struct mg_file_stat *filep)\n{\n\tstruct stat st;\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tmemset(filep, 0, sizeof(*filep));\n\n\tif (conn && is_file_in_memory(conn, path)) {\n\n\t\t/* Quick fix (for 1.9.x): */\n\t\t/* mg_stat must fill all fields, also for files in memory */\n\t\tstruct mg_file tmp_file = STRUCT_FILE_INITIALIZER;\n\t\topen_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);\n\t\tfilep->size = tmp_file.stat.size;\n\t\tfilep->last_modified = time(NULL);\n\t\tfilep->location = 2;\n\t\t/* TODO: remove legacy \"files in memory\" feature */\n\n\t\treturn 1;\n\t}\n\n\tif (0 == stat(path, &st)) {\n\t\tfilep->size = (uint64_t)(st.st_size);\n\t\tfilep->last_modified = st.st_mtime;\n\t\tfilep->is_directory = S_ISDIR(st.st_mode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nset_close_on_exec(SOCKET fd, struct mg_connection *conn /* may be null */)\n{\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {\n\t\tif (conn) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n\t}\n}\n\n\nint\nmg_start_thread(mg_thread_func_t func, void *param)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\tint result;\n\n\t(void)pthread_attr_init(&attr);\n\t(void)pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size,\n\t * e.g. -DUSE_STACK_SIZE=16384 */\n\t(void)pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */\n\n\tresult = pthread_create(&thread_id, &attr, func, param);\n\tpthread_attr_destroy(&attr);\n\n\treturn result;\n}\n\n\n/* Start a thread storing the thread context. */\nstatic int\nmg_start_thread_with_id(mg_thread_func_t func,\n                        void *param,\n                        pthread_t *threadidptr)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\tint result;\n\n\t(void)pthread_attr_init(&attr);\n\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size,\n\t * e.g. -DUSE_STACK_SIZE=16384 */\n\t(void)pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif /* defined(USE_STACK_SIZE) && USE_STACK_SIZE > 1 */\n\n\tresult = pthread_create(&thread_id, &attr, func, param);\n\tpthread_attr_destroy(&attr);\n\tif ((result == 0) && (threadidptr != NULL)) {\n\t\t*threadidptr = thread_id;\n\t}\n\treturn result;\n}\n\n\n/* Wait for a thread to finish. */\nstatic int\nmg_join_thread(pthread_t threadid)\n{\n\tint result;\n\n\tresult = pthread_join(threadid, NULL);\n\treturn result;\n}\n\n\n#if !defined(NO_CGI)\nstatic pid_t\nspawn_process(struct mg_connection *conn,\n              const char *prog,\n              char *envblk,\n              char *envp[],\n              int fdin[2],\n              int fdout[2],\n              int fderr[2],\n              const char *dir)\n{\n\tpid_t pid;\n\tconst char *interp;\n\n\t(void)envblk;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif ((pid = fork()) == -1) {\n\t\t/* Parent */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Creating CGI process\\nfork(): %s\",\n\t\t                   strerror(ERRNO));\n\t} else if (pid == 0) {\n\t\t/* Child */\n\t\tif (chdir(dir) != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    conn, \"%s: chdir(%s): %s\", __func__, dir, strerror(ERRNO));\n\t\t} else if (dup2(fdin[0], 0) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 0): %s\",\n\t\t\t                __func__,\n\t\t\t                fdin[0],\n\t\t\t                strerror(ERRNO));\n\t\t} else if (dup2(fdout[1], 1) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 1): %s\",\n\t\t\t                __func__,\n\t\t\t                fdout[1],\n\t\t\t                strerror(ERRNO));\n\t\t} else if (dup2(fderr[1], 2) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 2): %s\",\n\t\t\t                __func__,\n\t\t\t                fderr[1],\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\t/* Keep stderr and stdout in two different pipes.\n\t\t\t * Stdout will be sent back to the client,\n\t\t\t * stderr should go into a server error log. */\n\t\t\t(void)close(fdin[0]);\n\t\t\t(void)close(fdout[1]);\n\t\t\t(void)close(fderr[1]);\n\n\t\t\t/* Close write end fdin and read end fdout and fderr */\n\t\t\t(void)close(fdin[1]);\n\t\t\t(void)close(fdout[0]);\n\t\t\t(void)close(fderr[0]);\n\n\t\t\t/* After exec, all signal handlers are restored to their default\n\t\t\t * values, with one exception of SIGCHLD. According to\n\t\t\t * POSIX.1-2001 and Linux's implementation, SIGCHLD's handler\n\t\t\t * will leave unchanged after exec if it was set to be ignored.\n\t\t\t * Restore it to default action. */\n\t\t\tsignal(SIGCHLD, SIG_DFL);\n\n\t\t\tinterp = conn->dom_ctx->config[CGI_INTERPRETER];\n\t\t\tif (interp == NULL) {\n\t\t\t\t(void)execle(prog, prog, NULL, envp);\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: execle(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                prog,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t} else {\n\t\t\t\t(void)execle(interp, interp, prog, NULL, envp);\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: execle(%s %s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                interp,\n\t\t\t\t                prog,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t}\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn pid;\n}\n#endif /* !NO_CGI */\n\n\nstatic int\nset_non_blocking_mode(SOCKET sock)\n{\n\tint flags = fcntl(sock, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nset_blocking_mode(SOCKET sock)\n{\n\tint flags = fcntl(sock, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif /* _WIN32 / else */\n\n/* End of initial operating system specific define block. */\n\n\n/* Get a random number (independent of C rand function) */\nstatic uint64_t\nget_random(void)\n{\n\tstatic uint64_t lfsr = 0; /* Linear feedback shift register */\n\tstatic uint64_t lcg = 0;  /* Linear congruential generator */\n\tuint64_t now = mg_get_current_time_ns();\n\n\tif (lfsr == 0) {\n\t\t/* lfsr will be only 0 if has not been initialized,\n\t\t * so this code is called only once. */\n\t\tlfsr = mg_get_current_time_ns();\n\t\tlcg = mg_get_current_time_ns();\n\t} else {\n\t\t/* Get the next step of both random number generators. */\n\t\tlfsr = (lfsr >> 1)\n\t\t       | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1)\n\t\t          << 63);\n\t\tlcg = lcg * 6364136223846793005LL + 1442695040888963407LL;\n\t}\n\n\t/* Combining two pseudo-random number generators and a high resolution\n\t * part\n\t * of the current server time will make it hard (impossible?) to guess\n\t * the\n\t * next number. */\n\treturn (lfsr ^ lcg ^ now);\n}\n\n\nstatic int\nmg_poll(struct pollfd *pfd,\n        unsigned int n,\n        int milliseconds,\n        volatile int *stop_server)\n{\n\t/* Call poll, but only for a maximum time of a few seconds.\n\t * This will allow to stop the server after some seconds, instead\n\t * of having to wait for a long socket timeout. */\n\tint ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */\n\n\tdo {\n\t\tint result;\n\n\t\tif (*stop_server) {\n\t\t\t/* Shut down signal */\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((milliseconds >= 0) && (milliseconds < ms_now)) {\n\t\t\tms_now = milliseconds;\n\t\t}\n\n\t\tresult = poll(pfd, n, ms_now);\n\t\tif (result != 0) {\n\t\t\t/* Poll returned either success (1) or error (-1).\n\t\t\t * Forward both to the caller. */\n\t\t\treturn result;\n\t\t}\n\n\t\t/* Poll returned timeout (0). */\n\t\tif (milliseconds > 0) {\n\t\t\tmilliseconds -= ms_now;\n\t\t}\n\n\t} while (milliseconds != 0);\n\n\t/* timeout: return 0 */\n\treturn 0;\n}\n\n\n/* Write data to the IO channel - opened file descriptor, socket or SSL\n * descriptor.\n * Return value:\n *  >=0 .. number of bytes successfully written\n *   -1 .. timeout\n *   -2 .. error\n */\nstatic int\npush_inner(struct mg_context *ctx,\n           FILE *fp,\n           SOCKET sock,\n           SSL *ssl,\n           const char *buf,\n           int len,\n           double timeout)\n{\n\tuint64_t start = 0, now = 0, timeout_ns = 0;\n\tint n, err;\n\tunsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */\n\n#if defined(_WIN32)\n\ttypedef int len_t;\n#else\n\ttypedef size_t len_t;\n#endif\n\n\tif (timeout > 0) {\n\t\tnow = mg_get_current_time_ns();\n\t\tstart = now;\n\t\ttimeout_ns = (uint64_t)(timeout * 1.0E9);\n\t}\n\n\tif (ctx == NULL) {\n\t\treturn -2;\n\t}\n\n#if defined(NO_SSL)\n\tif (ssl) {\n\t\treturn -2;\n\t}\n#endif\n\n\t/* Try to read until it succeeds, fails, times out, or the server\n\t * shuts down. */\n\tfor (;;) {\n\n#if !defined(NO_SSL)\n\t\tif (ssl != NULL) {\n\t\t\tn = SSL_write(ssl, buf, len);\n\t\t\tif (n <= 0) {\n\t\t\t\terr = SSL_get_error(ssl, n);\n\t\t\t\tif ((err == SSL_ERROR_SYSCALL) && (n == -1)) {\n\t\t\t\t\terr = ERRNO;\n\t\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\t\tn = 0;\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_TRACE(\"SSL_write() failed, error %d\", err);\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else\n#endif\n\t\t    if (fp != NULL) {\n\t\t\tn = (int)fwrite(buf, 1, (size_t)len, fp);\n\t\t\tif (ferror(fp)) {\n\t\t\t\tn = -1;\n\t\t\t\terr = ERRNO;\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);\n\t\t\terr = (n < 0) ? ERRNO : 0;\n#if defined(_WIN32)\n\t\t\tif (err == WSAEWOULDBLOCK) {\n\t\t\t\terr = 0;\n\t\t\t\tn = 0;\n\t\t\t}\n#else\n\t\t\tif (err == EWOULDBLOCK) {\n\t\t\t\terr = 0;\n\t\t\t\tn = 0;\n\t\t\t}\n#endif\n\t\t\tif (n < 0) {\n\t\t\t\t/* shutdown of the socket at client side */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((n > 0) || ((n == 0) && (len == 0))) {\n\t\t\t/* some data has been read, or no data was requested */\n\t\t\treturn n;\n\t\t}\n\t\tif (n < 0) {\n\t\t\t/* socket error - check errno */\n\t\t\tDEBUG_TRACE(\"send() failed, error %d\", err);\n\n\t\t\t/* TODO (mid): error handling depending on the error code.\n\t\t\t * These codes are different between Windows and Linux.\n\t\t\t * Currently there is no problem with failing send calls,\n\t\t\t * if there is a reproducible situation, it should be\n\t\t\t * investigated in detail.\n\t\t\t */\n\t\t\treturn -2;\n\t\t}\n\n\t\t/* Only in case n=0 (timeout), repeat calling the write function */\n\n\t\t/* If send failed, wait before retry */\n\t\tif (fp != NULL) {\n\t\t\t/* For files, just wait a fixed time.\n\t\t\t * Maybe it helps, maybe not. */\n\t\t\tmg_sleep(5);\n\t\t} else {\n\t\t\t/* For sockets, wait for the socket using poll */\n\t\t\tstruct pollfd pfd[1];\n\t\t\tint pollres;\n\n\t\t\tpfd[0].fd = sock;\n\t\t\tpfd[0].events = POLLOUT;\n\t\t\tpollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));\n\t\t\tif (ctx->stop_flag) {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tif (pollres > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (timeout > 0) {\n\t\t\tnow = mg_get_current_time_ns();\n\t\t\tif ((now - start) > timeout_ns) {\n\t\t\t\t/* Timeout */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t(void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not\n\t              used */\n\n\treturn -1;\n}\n\n\nstatic int64_t\npush_all(struct mg_context *ctx,\n         FILE *fp,\n         SOCKET sock,\n         SSL *ssl,\n         const char *buf,\n         int64_t len)\n{\n\tdouble timeout = -1.0;\n\tint64_t n, nwritten = 0;\n\n\tif (ctx == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (ctx->dd.config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\twhile ((len > 0) && (ctx->stop_flag == 0)) {\n\t\tn = push_inner(ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);\n\t\tif (n < 0) {\n\t\t\tif (nwritten == 0) {\n\t\t\t\tnwritten = n; /* Propagate the error */\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == 0) {\n\t\t\tbreak; /* No more data to write */\n\t\t} else {\n\t\t\tnwritten += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n\n\treturn nwritten;\n}\n\n\n/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.\n * Return value:\n *  >=0 .. number of bytes successfully read\n *   -1 .. timeout\n *   -2 .. error\n */\nstatic int\npull_inner(FILE *fp,\n           struct mg_connection *conn,\n           char *buf,\n           int len,\n           double timeout)\n{\n\tint nread, err = 0;\n\n#if defined(_WIN32)\n\ttypedef int len_t;\n#else\n\ttypedef size_t len_t;\n#endif\n#if !defined(NO_SSL)\n\tint ssl_pending;\n#endif\n\n\t/* We need an additional wait loop around this, because in some cases\n\t * with TLSwe may get data from the socket but not from SSL_read.\n\t * In this case we need to repeat at least once.\n\t */\n\n\tif (fp != NULL) {\n#if !defined(_WIN32_WCE)\n\t\t/* Use read() instead of fread(), because if we're reading from the\n\t\t * CGI pipe, fread() may block until IO buffer is filled up. We\n\t\t * cannot afford to block and must pass all read bytes immediately\n\t\t * to the client. */\n\t\tnread = (int)read(fileno(fp), buf, (size_t)len);\n#else\n\t\t/* WinCE does not support CGI pipes */\n\t\tnread = (int)fread(buf, 1, (size_t)len, fp);\n#endif\n\t\terr = (nread < 0) ? ERRNO : 0;\n\t\tif ((nread == 0) && (len > 0)) {\n\t\t\t/* Should get data, but got EOL */\n\t\t\treturn -2;\n\t\t}\n\n#if !defined(NO_SSL)\n\t} else if ((conn->ssl != NULL)\n\t           && ((ssl_pending = SSL_pending(conn->ssl)) > 0)) {\n\t\t/* We already know there is no more data buffered in conn->buf\n\t\t * but there is more available in the SSL layer. So don't poll\n\t\t * conn->client.sock yet. */\n\t\tif (ssl_pending > len) {\n\t\t\tssl_pending = len;\n\t\t}\n\t\tnread = SSL_read(conn->ssl, buf, ssl_pending);\n\t\tif (nread <= 0) {\n\t\t\terr = SSL_get_error(conn->ssl, nread);\n\t\t\tif ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {\n\t\t\t\terr = ERRNO;\n\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\tnread = 0;\n\t\t\t} else {\n\t\t\t\tDEBUG_TRACE(\"SSL_read() failed, error %d\", err);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\terr = 0;\n\t\t}\n\n\t} else if (conn->ssl != NULL) {\n\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\n\t\tpfd[0].fd = conn->client.sock;\n\t\tpfd[0].events = POLLIN;\n\t\tpollres = mg_poll(pfd,\n\t\t                  1,\n\t\t                  (int)(timeout * 1000.0),\n\t\t                  &(conn->phys_ctx->stop_flag));\n\t\tif (conn->phys_ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (pollres > 0) {\n\t\t\tnread = SSL_read(conn->ssl, buf, len);\n\t\t\tif (nread <= 0) {\n\t\t\t\terr = SSL_get_error(conn->ssl, nread);\n\t\t\t\tif ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {\n\t\t\t\t\terr = ERRNO;\n\t\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\t\tnread = 0;\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_TRACE(\"SSL_read() failed, error %d\", err);\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\n\t\t} else if (pollres < 0) {\n\t\t\t/* Error */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/* pollres = 0 means timeout */\n\t\t\tnread = 0;\n\t\t}\n#endif\n\n\t} else {\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\n\t\tpfd[0].fd = conn->client.sock;\n\t\tpfd[0].events = POLLIN;\n\t\tpollres = mg_poll(pfd,\n\t\t                  1,\n\t\t                  (int)(timeout * 1000.0),\n\t\t                  &(conn->phys_ctx->stop_flag));\n\t\tif (conn->phys_ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (pollres > 0) {\n\t\t\tnread = (int)recv(conn->client.sock, buf, (len_t)len, 0);\n\t\t\terr = (nread < 0) ? ERRNO : 0;\n\t\t\tif (nread <= 0) {\n\t\t\t\t/* shutdown of the socket at client side */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t} else if (pollres < 0) {\n\t\t\t/* error callint poll */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/* pollres = 0 means timeout */\n\t\t\tnread = 0;\n\t\t}\n\t}\n\n\tif (conn->phys_ctx->stop_flag) {\n\t\treturn -2;\n\t}\n\n\tif ((nread > 0) || ((nread == 0) && (len == 0))) {\n\t\t/* some data has been read, or no data was requested */\n\t\treturn nread;\n\t}\n\n\tif (nread < 0) {\n/* socket error - check errno */\n#if defined(_WIN32)\n\t\tif (err == WSAEWOULDBLOCK) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* standard case if called from close_socket_gracefully */\n\t\t\treturn -2;\n\t\t} else if (err == WSAETIMEDOUT) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* timeout is handled by the while loop  */\n\t\t\treturn 0;\n\t\t} else if (err == WSAECONNABORTED) {\n\t\t\t/* See https://www.chilkatsoft.com/p/p_299.asp */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\tDEBUG_TRACE(\"recv() failed, error %d\", err);\n\t\t\treturn -2;\n\t\t}\n#else\n\t\t/* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,\n\t\t * if the timeout is reached and if the socket was set to non-\n\t\t * blocking in close_socket_gracefully, so we can not distinguish\n\t\t * here. We have to wait for the timeout in both cases for now.\n\t\t */\n\t\tif ((err == EAGAIN) || (err == EWOULDBLOCK) || (err == EINTR)) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* EAGAIN/EWOULDBLOCK:\n\t\t\t * standard case if called from close_socket_gracefully\n\t\t\t * => should return -1 */\n\t\t\t/* or timeout occurred\n\t\t\t * => the code must stay in the while loop */\n\n\t\t\t/* EINTR can be generated on a socket with a timeout set even\n\t\t\t * when SA_RESTART is effective for all relevant signals\n\t\t\t * (see signal(7)).\n\t\t\t * => stay in the while loop */\n\t\t} else {\n\t\t\tDEBUG_TRACE(\"recv() failed, error %d\", err);\n\t\t\treturn -2;\n\t\t}\n#endif\n\t}\n\n\t/* Timeout occurred, but no data available. */\n\treturn -1;\n}\n\n\nstatic int\npull_all(FILE *fp, struct mg_connection *conn, char *buf, int len)\n{\n\tint n, nread = 0;\n\tdouble timeout = -1.0;\n\tuint64_t start_time = 0, now = 0, timeout_ns = 0;\n\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\tif (timeout >= 0.0) {\n\t\tstart_time = mg_get_current_time_ns();\n\t\ttimeout_ns = (uint64_t)(timeout * 1.0E9);\n\t}\n\n\twhile ((len > 0) && (conn->phys_ctx->stop_flag == 0)) {\n\t\tn = pull_inner(fp, conn, buf + nread, len, timeout);\n\t\tif (n == -2) {\n\t\t\tif (nread == 0) {\n\t\t\t\tnread = -1; /* Propagate the error */\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == -1) {\n\t\t\t/* timeout */\n\t\t\tif (timeout >= 0.0) {\n\t\t\t\tnow = mg_get_current_time_ns();\n\t\t\t\tif ((now - start_time) <= timeout_ns) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == 0) {\n\t\t\tbreak; /* No more data to read */\n\t\t} else {\n\t\t\tconn->consumed_content += n;\n\t\t\tnread += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n\n\treturn nread;\n}\n\n\nstatic void\ndiscard_unread_request_data(struct mg_connection *conn)\n{\n\tchar buf[MG_BUF_LEN];\n\tsize_t to_read;\n\tint nread;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tto_read = sizeof(buf);\n\n\tif (conn->is_chunked) {\n\t\t/* Chunked encoding: 3=chunk read completely\n\t\t * completely */\n\t\twhile (conn->is_chunked != 3) {\n\t\t\tnread = mg_read(conn, buf, to_read);\n\t\t\tif (nread <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* Not chunked: content length is known */\n\t\twhile (conn->consumed_content < conn->content_len) {\n\t\t\tif (to_read\n\t\t\t    > (size_t)(conn->content_len - conn->consumed_content)) {\n\t\t\t\tto_read = (size_t)(conn->content_len - conn->consumed_content);\n\t\t\t}\n\n\t\t\tnread = mg_read(conn, buf, to_read);\n\t\t\tif (nread <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nmg_read_inner(struct mg_connection *conn, void *buf, size_t len)\n{\n\tint64_t n, buffered_len, nread;\n\tint64_t len64 =\n\t    (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is\n\t                                                 * int, we may not read more\n\t                                                 * bytes */\n\tconst char *body;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* If Content-Length is not set for a request with body data\n\t * (e.g., a PUT or POST request), we do not know in advance\n\t * how much data should be read. */\n\tif (conn->consumed_content == 0) {\n\t\tif (conn->is_chunked == 1) {\n\t\t\tconn->content_len = len64;\n\t\t\tconn->is_chunked = 2;\n\t\t} else if (conn->content_len == -1) {\n\t\t\t/* The body data is completed when the connection\n\t\t\t * is closed. */\n\t\t\tconn->content_len = INT64_MAX;\n\t\t\tconn->must_close = 1;\n\t\t}\n\t}\n\n\tnread = 0;\n\tif (conn->consumed_content < conn->content_len) {\n\t\t/* Adjust number of bytes to read. */\n\t\tint64_t left_to_read = conn->content_len - conn->consumed_content;\n\t\tif (left_to_read < len64) {\n\t\t\t/* Do not read more than the total content length of the\n\t\t\t * request.\n\t\t\t */\n\t\t\tlen64 = left_to_read;\n\t\t}\n\n\t\t/* Return buffered data */\n\t\tbuffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len\n\t\t               - conn->consumed_content;\n\t\tif (buffered_len > 0) {\n\t\t\tif (len64 < buffered_len) {\n\t\t\t\tbuffered_len = len64;\n\t\t\t}\n\t\t\tbody = conn->buf + conn->request_len + conn->consumed_content;\n\t\t\tmemcpy(buf, body, (size_t)buffered_len);\n\t\t\tlen64 -= buffered_len;\n\t\t\tconn->consumed_content += buffered_len;\n\t\t\tnread += buffered_len;\n\t\t\tbuf = (char *)buf + buffered_len;\n\t\t}\n\n\t\t/* We have returned all buffered data. Read new data from the remote\n\t\t * socket.\n\t\t */\n\t\tif ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {\n\t\t\tnread += n;\n\t\t} else {\n\t\t\tnread = ((nread > 0) ? nread : n);\n\t\t}\n\t}\n\treturn (int)nread;\n}\n\n\nstatic char\nmg_getc(struct mg_connection *conn)\n{\n\tchar c;\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\tif (mg_read_inner(conn, &c, 1) <= 0) {\n\t\treturn (char)0;\n\t}\n\treturn c;\n}\n\n\nint\nmg_read(struct mg_connection *conn, void *buf, size_t len)\n{\n\tif (len > INT_MAX) {\n\t\tlen = INT_MAX;\n\t}\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (conn->is_chunked) {\n\t\tsize_t all_read = 0;\n\n\t\twhile (len > 0) {\n\t\t\tif (conn->is_chunked == 3) {\n\t\t\t\t/* No more data left to read */\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (conn->chunk_remainder) {\n\t\t\t\t/* copy from the remainder of the last received chunk */\n\t\t\t\tlong read_ret;\n\t\t\t\tsize_t read_now =\n\t\t\t\t    ((conn->chunk_remainder > len) ? (len)\n\t\t\t\t                                   : (conn->chunk_remainder));\n\n\t\t\t\tconn->content_len += (int)read_now;\n\t\t\t\tread_ret =\n\t\t\t\t    mg_read_inner(conn, (char *)buf + all_read, read_now);\n\n\t\t\t\tif (read_ret < 1) {\n\t\t\t\t\t/* read error */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tall_read += (size_t)read_ret;\n\t\t\t\tconn->chunk_remainder -= (size_t)read_ret;\n\t\t\t\tlen -= (size_t)read_ret;\n\n\t\t\t\tif (conn->chunk_remainder == 0) {\n\t\t\t\t\t/* Add data bytes in the current chunk have been read,\n\t\t\t\t\t * so we are expecting \\r\\n now. */\n\t\t\t\t\tchar x1, x2;\n\t\t\t\t\tconn->content_len += 2;\n\t\t\t\t\tx1 = mg_getc(conn);\n\t\t\t\t\tx2 = mg_getc(conn);\n\t\t\t\t\tif ((x1 != '\\r') || (x2 != '\\n')) {\n\t\t\t\t\t\t/* Protocol violation */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* fetch a new chunk */\n\t\t\t\tint i = 0;\n\t\t\t\tchar lenbuf[64];\n\t\t\t\tchar *end = 0;\n\t\t\t\tunsigned long chunkSize = 0;\n\n\t\t\t\tfor (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {\n\t\t\t\t\tconn->content_len++;\n\t\t\t\t\tlenbuf[i] = mg_getc(conn);\n\t\t\t\t\tif ((i > 0) && (lenbuf[i] == '\\r')\n\t\t\t\t\t    && (lenbuf[i - 1] != '\\r')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((i > 1) && (lenbuf[i] == '\\n')\n\t\t\t\t\t    && (lenbuf[i - 1] == '\\r')) {\n\t\t\t\t\t\tlenbuf[i + 1] = 0;\n\t\t\t\t\t\tchunkSize = strtoul(lenbuf, &end, 16);\n\t\t\t\t\t\tif (chunkSize == 0) {\n\t\t\t\t\t\t\t/* regular end of content */\n\t\t\t\t\t\t\tconn->is_chunked = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isxdigit(lenbuf[i])) {\n\t\t\t\t\t\t/* illegal character for chunk length */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((end == NULL) || (*end != '\\r')) {\n\t\t\t\t\t/* chunksize not set correctly */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (chunkSize == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconn->chunk_remainder = chunkSize;\n\t\t\t}\n\t\t}\n\n\t\treturn (int)all_read;\n\t}\n\treturn mg_read_inner(conn, buf, len);\n}\n\n\nint\nmg_write(struct mg_connection *conn, const void *buf, size_t len)\n{\n\ttime_t now;\n\tint64_t n, total, allowed;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (conn->throttle > 0) {\n\t\tif ((now = time(NULL)) != conn->last_throttle_time) {\n\t\t\tconn->last_throttle_time = now;\n\t\t\tconn->last_throttle_bytes = 0;\n\t\t}\n\t\tallowed = conn->throttle - conn->last_throttle_bytes;\n\t\tif (allowed > (int64_t)len) {\n\t\t\tallowed = (int64_t)len;\n\t\t}\n\t\tif ((total = push_all(conn->phys_ctx,\n\t\t                      NULL,\n\t\t                      conn->client.sock,\n\t\t                      conn->ssl,\n\t\t                      (const char *)buf,\n\t\t                      (int64_t)allowed)) == allowed) {\n\t\t\tbuf = (const char *)buf + total;\n\t\t\tconn->last_throttle_bytes += total;\n\t\t\twhile ((total < (int64_t)len) && (conn->phys_ctx->stop_flag == 0)) {\n\t\t\t\tallowed = (conn->throttle > ((int64_t)len - total))\n\t\t\t\t              ? (int64_t)len - total\n\t\t\t\t              : conn->throttle;\n\t\t\t\tif ((n = push_all(conn->phys_ctx,\n\t\t\t\t                  NULL,\n\t\t\t\t                  conn->client.sock,\n\t\t\t\t                  conn->ssl,\n\t\t\t\t                  (const char *)buf,\n\t\t\t\t                  (int64_t)allowed)) != allowed) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t\tconn->last_throttle_bytes = allowed;\n\t\t\t\tconn->last_throttle_time = time(NULL);\n\t\t\t\tbuf = (const char *)buf + n;\n\t\t\t\ttotal += n;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttotal = push_all(conn->phys_ctx,\n\t\t                 NULL,\n\t\t                 conn->client.sock,\n\t\t                 conn->ssl,\n\t\t                 (const char *)buf,\n\t\t                 (int64_t)len);\n\t}\n\tif (total > 0) {\n\t\tconn->num_bytes_sent += total;\n\t}\n\treturn (int)total;\n}\n\n\n/* Send a chunk, if \"Transfer-Encoding: chunked\" is used */\nint\nmg_send_chunk(struct mg_connection *conn,\n              const char *chunk,\n              unsigned int chunk_len)\n{\n\tchar lenbuf[16];\n\tsize_t lenbuf_len;\n\tint ret;\n\tint t;\n\n\t/* First store the length information in a text buffer. */\n\tsprintf(lenbuf, \"%x\\r\\n\", chunk_len);\n\tlenbuf_len = strlen(lenbuf);\n\n\t/* Then send length information, chunk and terminating \\r\\n. */\n\tret = mg_write(conn, lenbuf, lenbuf_len);\n\tif (ret != (int)lenbuf_len) {\n\t\treturn -1;\n\t}\n\tt = ret;\n\n\tret = mg_write(conn, chunk, chunk_len);\n\tif (ret != (int)chunk_len) {\n\t\treturn -1;\n\t}\n\tt += ret;\n\n\tret = mg_write(conn, \"\\r\\n\", 2);\n\tif (ret != 2) {\n\t\treturn -1;\n\t}\n\tt += ret;\n\n\treturn t;\n}\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* This block forwards format strings to printf implementations,\n * so we need to disable the format-nonliteral warning. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\n/* Alternative alloc_vprintf() for non-compliant C runtimes */\nstatic int\nalloc_vprintf2(char **buf, const char *fmt, va_list ap)\n{\n\tva_list ap_copy;\n\tsize_t size = MG_BUF_LEN / 4;\n\tint len = -1;\n\n\t*buf = NULL;\n\twhile (len < 0) {\n\t\tif (*buf) {\n\t\t\tmg_free(*buf);\n\t\t}\n\n\t\tsize *= 4;\n\t\t*buf = (char *)mg_malloc(size);\n\t\tif (!*buf) {\n\t\t\tbreak;\n\t\t}\n\n\t\tva_copy(ap_copy, ap);\n\t\tlen = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);\n\t\tva_end(ap_copy);\n\t\t(*buf)[size - 1] = 0;\n\t}\n\n\treturn len;\n}\n\n\n/* Print message to buffer. If buffer is large enough to hold the message,\n * return buffer. If buffer is to small, allocate large enough buffer on\n * heap,\n * and return allocated buffer. */\nstatic int\nalloc_vprintf(char **out_buf,\n              char *prealloc_buf,\n              size_t prealloc_size,\n              const char *fmt,\n              va_list ap)\n{\n\tva_list ap_copy;\n\tint len;\n\n\t/* Windows is not standard-compliant, and vsnprintf() returns -1 if\n\t * buffer is too small. Also, older versions of msvcrt.dll do not have\n\t * _vscprintf().  However, if size is 0, vsnprintf() behaves correctly.\n\t * Therefore, we make two passes: on first pass, get required message\n\t * length.\n\t * On second pass, actually print the message. */\n\tva_copy(ap_copy, ap);\n\tlen = vsnprintf_impl(NULL, 0, fmt, ap_copy);\n\tva_end(ap_copy);\n\n\tif (len < 0) {\n\t\t/* C runtime is not standard compliant, vsnprintf() returned -1.\n\t\t * Switch to alternative code path that uses incremental\n\t\t * allocations.\n\t\t*/\n\t\tva_copy(ap_copy, ap);\n\t\tlen = alloc_vprintf2(out_buf, fmt, ap_copy);\n\t\tva_end(ap_copy);\n\n\t} else if ((size_t)(len) >= prealloc_size) {\n\t\t/* The pre-allocated buffer not large enough. */\n\t\t/* Allocate a new buffer. */\n\t\t*out_buf = (char *)mg_malloc((size_t)(len) + 1);\n\t\tif (!*out_buf) {\n\t\t\t/* Allocation failed. Return -1 as \"out of memory\" error. */\n\t\t\treturn -1;\n\t\t}\n\t\t/* Buffer allocation successful. Store the string there. */\n\t\tva_copy(ap_copy, ap);\n\t\tIGNORE_UNUSED_RESULT(\n\t\t    vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));\n\t\tva_end(ap_copy);\n\n\t} else {\n\t\t/* The pre-allocated buffer is large enough.\n\t\t * Use it to store the string and return the address. */\n\t\tva_copy(ap_copy, ap);\n\t\tIGNORE_UNUSED_RESULT(\n\t\t    vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));\n\t\tva_end(ap_copy);\n\t\t*out_buf = prealloc_buf;\n\t}\n\n\treturn len;\n}\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Enable format-nonliteral warning again. */\n#pragma GCC diagnostic pop\n#endif\n\n\nstatic int\nmg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap)\n{\n\tchar mem[MG_BUF_LEN];\n\tchar *buf = NULL;\n\tint len;\n\n\tif ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {\n\t\tlen = mg_write(conn, buf, (size_t)len);\n\t}\n\tif ((buf != mem) && (buf != NULL)) {\n\t\tmg_free(buf);\n\t}\n\n\treturn len;\n}\n\n\nint\nmg_printf(struct mg_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\tint result;\n\n\tva_start(ap, fmt);\n\tresult = mg_vprintf(conn, fmt, ap);\n\tva_end(ap);\n\n\treturn result;\n}\n\n\nint\nmg_url_decode(const char *src,\n              int src_len,\n              char *dst,\n              int dst_len,\n              int is_form_url_encoded)\n{\n\tint i, j, a, b;\n#define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))\n\n\tfor (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {\n\t\tif ((i < src_len - 2) && (src[i] == '%')\n\t\t    && isxdigit(*(const unsigned char *)(src + i + 1))\n\t\t    && isxdigit(*(const unsigned char *)(src + i + 2))) {\n\t\t\ta = tolower(*(const unsigned char *)(src + i + 1));\n\t\t\tb = tolower(*(const unsigned char *)(src + i + 2));\n\t\t\tdst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));\n\t\t\ti += 2;\n\t\t} else if (is_form_url_encoded && (src[i] == '+')) {\n\t\t\tdst[j] = ' ';\n\t\t} else {\n\t\t\tdst[j] = src[i];\n\t\t}\n\t}\n\n\tdst[j] = '\\0'; /* Null-terminate the destination */\n\n\treturn (i >= src_len) ? j : -1;\n}\n\n\nint\nmg_get_var(const char *data,\n           size_t data_len,\n           const char *name,\n           char *dst,\n           size_t dst_len)\n{\n\treturn mg_get_var2(data, data_len, name, dst, dst_len, 0);\n}\n\n\nint\nmg_get_var2(const char *data,\n            size_t data_len,\n            const char *name,\n            char *dst,\n            size_t dst_len,\n            size_t occurrence)\n{\n\tconst char *p, *e, *s;\n\tsize_t name_len;\n\tint len;\n\n\tif ((dst == NULL) || (dst_len == 0)) {\n\t\tlen = -2;\n\t} else if ((data == NULL) || (name == NULL) || (data_len == 0)) {\n\t\tlen = -1;\n\t\tdst[0] = '\\0';\n\t} else {\n\t\tname_len = strlen(name);\n\t\te = data + data_len;\n\t\tlen = -1;\n\t\tdst[0] = '\\0';\n\n\t\t/* data is \"var1=val1&var2=val2...\". Find variable first */\n\t\tfor (p = data; p + name_len < e; p++) {\n\t\t\tif (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')\n\t\t\t    && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {\n\t\t\t\t/* Point p to variable value */\n\t\t\t\tp += name_len + 1;\n\n\t\t\t\t/* Point s to the end of the value */\n\t\t\t\ts = (const char *)memchr(p, '&', (size_t)(e - p));\n\t\t\t\tif (s == NULL) {\n\t\t\t\t\ts = e;\n\t\t\t\t}\n\t\t\t\tDEBUG_ASSERT(s >= p);\n\t\t\t\tif (s < p) {\n\t\t\t\t\treturn -3;\n\t\t\t\t}\n\n\t\t\t\t/* Decode variable into destination buffer */\n\t\t\t\tlen = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);\n\n\t\t\t\t/* Redirect error code from -1 to -2 (destination buffer too\n\t\t\t\t * small). */\n\t\t\t\tif (len == -1) {\n\t\t\t\t\tlen = -2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn len;\n}\n\n\n/* HCP24: some changes to compare hole var_name */\nint\nmg_get_cookie(const char *cookie_header,\n              const char *var_name,\n              char *dst,\n              size_t dst_size)\n{\n\tconst char *s, *p, *end;\n\tint name_len, len = -1;\n\n\tif ((dst == NULL) || (dst_size == 0)) {\n\t\treturn -2;\n\t}\n\n\tdst[0] = '\\0';\n\tif ((var_name == NULL) || ((s = cookie_header) == NULL)) {\n\t\treturn -1;\n\t}\n\n\tname_len = (int)strlen(var_name);\n\tend = s + strlen(s);\n\tfor (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {\n\t\tif (s[name_len] == '=') {\n\t\t\t/* HCP24: now check is it a substring or a full cookie name */\n\t\t\tif ((s == cookie_header) || (s[-1] == ' ')) {\n\t\t\t\ts += name_len + 1;\n\t\t\t\tif ((p = strchr(s, ' ')) == NULL) {\n\t\t\t\t\tp = end;\n\t\t\t\t}\n\t\t\t\tif (p[-1] == ';') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tif ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {\n\t\t\t\t\ts++;\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tif ((size_t)(p - s) < dst_size) {\n\t\t\t\t\tlen = (int)(p - s);\n\t\t\t\t\tmg_strlcpy(dst, s, (size_t)len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlen = -3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn len;\n}\n\n\n#if defined(USE_WEBSOCKET) || defined(USE_LUA)\nstatic void\nbase64_encode(const unsigned char *src, int src_len, char *dst)\n{\n\tstatic const char *b64 =\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tint i, j, a, b, c;\n\n\tfor (i = j = 0; i < src_len; i += 3) {\n\t\ta = src[i];\n\t\tb = ((i + 1) >= src_len) ? 0 : src[i + 1];\n\t\tc = ((i + 2) >= src_len) ? 0 : src[i + 2];\n\n\t\tdst[j++] = b64[a >> 2];\n\t\tdst[j++] = b64[((a & 3) << 4) | (b >> 4)];\n\t\tif (i + 1 < src_len) {\n\t\t\tdst[j++] = b64[(b & 15) << 2 | (c >> 6)];\n\t\t}\n\t\tif (i + 2 < src_len) {\n\t\t\tdst[j++] = b64[c & 63];\n\t\t}\n\t}\n\twhile (j % 4 != 0) {\n\t\tdst[j++] = '=';\n\t}\n\tdst[j++] = '\\0';\n}\n#endif\n\n\n#if defined(USE_LUA)\nstatic unsigned char\nb64reverse(char letter)\n{\n\tif ((letter >= 'A') && (letter <= 'Z')) {\n\t\treturn letter - 'A';\n\t}\n\tif ((letter >= 'a') && (letter <= 'z')) {\n\t\treturn letter - 'a' + 26;\n\t}\n\tif ((letter >= '0') && (letter <= '9')) {\n\t\treturn letter - '0' + 52;\n\t}\n\tif (letter == '+') {\n\t\treturn 62;\n\t}\n\tif (letter == '/') {\n\t\treturn 63;\n\t}\n\tif (letter == '=') {\n\t\treturn 255; /* normal end */\n\t}\n\treturn 254; /* error */\n}\n\n\nstatic int\nbase64_decode(const unsigned char *src, int src_len, char *dst, size_t *dst_len)\n{\n\tint i;\n\tunsigned char a, b, c, d;\n\n\t*dst_len = 0;\n\n\tfor (i = 0; i < src_len; i += 4) {\n\t\ta = b64reverse(src[i]);\n\t\tif (a >= 254) {\n\t\t\treturn i;\n\t\t}\n\n\t\tb = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);\n\t\tif (b >= 254) {\n\t\t\treturn i + 1;\n\t\t}\n\n\t\tc = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);\n\t\tif (c == 254) {\n\t\t\treturn i + 2;\n\t\t}\n\n\t\td = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);\n\t\tif (d == 254) {\n\t\t\treturn i + 3;\n\t\t}\n\n\t\tdst[(*dst_len)++] = (a << 2) + (b >> 4);\n\t\tif (c != 255) {\n\t\t\tdst[(*dst_len)++] = (b << 4) + (c >> 2);\n\t\t\tif (d != 255) {\n\t\t\t\tdst[(*dst_len)++] = (c << 6) + d;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n#endif\n\n\nstatic int\nis_put_or_delete_method(const struct mg_connection *conn)\n{\n\tif (conn) {\n\t\tconst char *s = conn->request_info.request_method;\n\t\treturn (s != NULL) && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")\n\t\t                       || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));\n\t}\n\treturn 0;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nextention_matches_script(\n    struct mg_connection *conn, /* in: request (must be valid) */\n    const char *filename        /* in: filename  (must be valid) */\n    )\n{\n#if !defined(NO_CGI)\n\tif (match_prefix(conn->dom_ctx->config[CGI_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[CGI_EXTENSIONS]),\n\t                 filename) > 0) {\n\t\treturn 1;\n\t}\n#endif\n#if defined(USE_LUA)\n\tif (match_prefix(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS]),\n\t                 filename) > 0) {\n\t\treturn 1;\n\t}\n#endif\n#if defined(USE_DUKTAPE)\n\tif (match_prefix(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),\n\t                 filename) > 0) {\n\t\treturn 1;\n\t}\n#endif\n\t/* filename and conn could be unused, if all preocessor conditions\n\t * are false (no script language supported). */\n\t(void)filename;\n\t(void)conn;\n\n\treturn 0;\n}\n\n\n/* For given directory path, substitute it to valid index file.\n * Return 1 if index file has been found, 0 if not found.\n * If the file is found, it's stats is returned in stp. */\nstatic int\nsubstitute_index_file(struct mg_connection *conn,\n                      char *path,\n                      size_t path_len,\n                      struct mg_file_stat *filestat)\n{\n\tconst char *list = conn->dom_ctx->config[INDEX_FILES];\n\tstruct vec filename_vec;\n\tsize_t n = strlen(path);\n\tint found = 0;\n\n\t/* The 'path' given to us points to the directory. Remove all trailing\n\t * directory separator characters from the end of the path, and\n\t * then append single directory separator character. */\n\twhile ((n > 0) && (path[n - 1] == '/')) {\n\t\tn--;\n\t}\n\tpath[n] = '/';\n\n\t/* Traverse index files list. For each entry, append it to the given\n\t * path and see if the file exists. If it exists, break the loop */\n\twhile ((list = next_option(list, &filename_vec, NULL)) != NULL) {\n\t\t/* Ignore too long entries that may overflow path buffer */\n\t\tif ((filename_vec.len + 1) > (path_len - (n + 1))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Prepare full path to the index file */\n\t\tmg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);\n\n\t\t/* Does it exist? */\n\t\tif (mg_stat(conn, path, filestat)) {\n\t\t\t/* Yes it does, break the loop */\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If no index file exists, restore directory path */\n\tif (!found) {\n\t\tpath[n] = '\\0';\n\t}\n\n\treturn found;\n}\n#endif\n\n\nstatic void\ninterpret_uri(struct mg_connection *conn, /* in/out: request (must be valid) */\n              char *filename,             /* out: filename */\n              size_t filename_buf_len,    /* in: size of filename buffer */\n              struct mg_file_stat *filestat, /* out: file status structure */\n              int *is_found,                 /* out: file found (directly) */\n              int *is_script_resource,       /* out: handled by a script? */\n              int *is_websocket_request,     /* out: websocket connetion? */\n              int *is_put_or_delete_request  /* out: put/delete a file? */\n              )\n{\n\tchar const *accept_encoding;\n\n#if !defined(NO_FILES)\n\tconst char *uri = conn->request_info.local_uri;\n\tconst char *root = conn->dom_ctx->config[DOCUMENT_ROOT];\n\tconst char *rewrite;\n\tstruct vec a, b;\n\tptrdiff_t match_len;\n\tchar gz_path[PATH_MAX];\n\tint truncated;\n#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)\n\tchar *tmp_str;\n\tsize_t tmp_str_len, sep_pos;\n\tint allow_substitute_script_subresources;\n#endif\n#else\n\t(void)filename_buf_len; /* unused if NO_FILES is defined */\n#endif\n\n\t/* Step 1: Set all initially unknown outputs to zero */\n\tmemset(filestat, 0, sizeof(*filestat));\n\t*filename = 0;\n\t*is_found = 0;\n\t*is_script_resource = 0;\n\n\t/* Step 2: Check if the request attempts to modify the file system */\n\t*is_put_or_delete_request = is_put_or_delete_method(conn);\n\n/* Step 3: Check if it is a websocket request, and modify the document\n * root if required */\n#if defined(USE_WEBSOCKET)\n\t*is_websocket_request = is_websocket_protocol(conn);\n#if !defined(NO_FILES)\n\tif (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {\n\t\troot = conn->dom_ctx->config[WEBSOCKET_ROOT];\n\t}\n#endif /* !NO_FILES */\n#else  /* USE_WEBSOCKET */\n\t*is_websocket_request = 0;\n#endif /* USE_WEBSOCKET */\n\n\t/* Step 4: Check if gzip encoded response is allowed */\n\tconn->accept_gzip = 0;\n\tif ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\")) != NULL) {\n\t\tif (strstr(accept_encoding, \"gzip\") != NULL) {\n\t\t\tconn->accept_gzip = 1;\n\t\t}\n\t}\n\n#if !defined(NO_FILES)\n\t/* Step 5: If there is no root directory, don't look for files. */\n\t/* Note that root == NULL is a regular use case here. This occurs,\n\t * if all requests are handled by callbacks, so the WEBSOCKET_ROOT\n\t * config is not required. */\n\tif (root == NULL) {\n\t\t/* all file related outputs have already been set to 0, just return\n\t\t */\n\t\treturn;\n\t}\n\n\t/* Step 6: Determine the local file path from the root path and the\n\t * request uri. */\n\t/* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift\n\t * part of the path one byte on the right. */\n\tmg_snprintf(\n\t    conn, &truncated, filename, filename_buf_len - 1, \"%s%s\", root, uri);\n\n\tif (truncated) {\n\t\tgoto interpret_cleanup;\n\t}\n\n\t/* Step 7: URI rewriting */\n\trewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];\n\twhile ((rewrite = next_option(rewrite, &a, &b)) != NULL) {\n\t\tif ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            filename,\n\t\t\t            filename_buf_len - 1,\n\t\t\t            \"%.*s%s\",\n\t\t\t            (int)b.len,\n\t\t\t            b.ptr,\n\t\t\t            uri + match_len);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (truncated) {\n\t\tgoto interpret_cleanup;\n\t}\n\n\t/* Step 8: Check if the file exists at the server */\n\t/* Local file path and name, corresponding to requested URI\n\t * is now stored in \"filename\" variable. */\n\tif (mg_stat(conn, filename, filestat)) {\n\t\tint uri_len = (int)strlen(uri);\n\t\tint is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');\n\n\t\t/* 8.1: File exists. */\n\t\t*is_found = 1;\n\n\t\t/* 8.2: Check if it is a script type. */\n\t\tif (extention_matches_script(conn, filename)) {\n\t\t\t/* The request addresses a CGI resource, Lua script or\n\t\t\t * server-side javascript.\n\t\t\t * The URI corresponds to the script itself (like\n\t\t\t * /path/script.cgi), and there is no additional resource\n\t\t\t * path (like /path/script.cgi/something).\n\t\t\t * Requests that modify (replace or delete) a resource, like\n\t\t\t * PUT and DELETE requests, should replace/delete the script\n\t\t\t * file.\n\t\t\t * Requests that read or write from/to a resource, like GET and\n\t\t\t * POST requests, should call the script and return the\n\t\t\t * generated response. */\n\t\t\t*is_script_resource = (!*is_put_or_delete_request);\n\t\t}\n\n\t\t/* 8.3: If the request target is a directory, there could be\n\t\t * a substitute file (index.html, index.cgi, ...). */\n\t\tif (filestat->is_directory && is_uri_end_slash) {\n\t\t\t/* Use a local copy here, since substitute_index_file will\n\t\t\t * change the content of the file status */\n\t\t\tstruct mg_file_stat tmp_filestat;\n\t\t\tmemset(&tmp_filestat, 0, sizeof(tmp_filestat));\n\n\t\t\tif (substitute_index_file(\n\t\t\t        conn, filename, filename_buf_len, &tmp_filestat)) {\n\n\t\t\t\t/* Substitute file found. Copy stat to the output, then\n\t\t\t\t * check if the file is a script file */\n\t\t\t\t*filestat = tmp_filestat;\n\n\t\t\t\tif (extention_matches_script(conn, filename)) {\n\t\t\t\t\t/* Substitute file is a script file */\n\t\t\t\t\t*is_script_resource = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* Substitute file is a regular file */\n\t\t\t\t\t*is_script_resource = 0;\n\t\t\t\t\t*is_found = (mg_stat(conn, filename, filestat) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If there is no substitute file, the server could return\n\t\t\t * a directory listing in a later step */\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Step 9: Check for zipped files: */\n\t/* If we can't find the actual file, look for the file\n\t * with the same name but a .gz extension. If we find it,\n\t * use that and set the gzipped flag in the file struct\n\t * to indicate that the response need to have the content-\n\t * encoding: gzip header.\n\t * We can only do this if the browser declares support. */\n\tif (conn->accept_gzip) {\n\t\tmg_snprintf(\n\t\t    conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", filename);\n\n\t\tif (truncated) {\n\t\t\tgoto interpret_cleanup;\n\t\t}\n\n\t\tif (mg_stat(conn, gz_path, filestat)) {\n\t\t\tif (filestat) {\n\t\t\t\tfilestat->is_gzipped = 1;\n\t\t\t\t*is_found = 1;\n\t\t\t}\n\t\t\t/* Currently gz files can not be scripts. */\n\t\t\treturn;\n\t\t}\n\t}\n\n#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)\n\t/* Step 10: Script resources may handle sub-resources */\n\t/* Support PATH_INFO for CGI scripts. */\n\ttmp_str_len = strlen(filename);\n\ttmp_str = (char *)mg_malloc_ctx(tmp_str_len + PATH_MAX + 1, conn->phys_ctx);\n\tif (!tmp_str) {\n\t\t/* Out of memory */\n\t\tgoto interpret_cleanup;\n\t}\n\tmemcpy(tmp_str, filename, tmp_str_len + 1);\n\n\t/* Check config, if index scripts may have sub-resources */\n\tallow_substitute_script_subresources =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ALLOW_INDEX_SCRIPT_SUB_RES],\n\t                   \"yes\");\n\n\tsep_pos = tmp_str_len;\n\twhile (sep_pos > 0) {\n\t\tsep_pos--;\n\t\tif (tmp_str[sep_pos] == '/') {\n\t\t\tint is_script = 0, does_exist = 0;\n\n\t\t\ttmp_str[sep_pos] = 0;\n\t\t\tif (tmp_str[0]) {\n\t\t\t\tis_script = extention_matches_script(conn, tmp_str);\n\t\t\t\tdoes_exist = mg_stat(conn, tmp_str, filestat);\n\t\t\t}\n\n\t\t\tif (does_exist && is_script) {\n\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\tmemmove(filename + sep_pos + 2,\n\t\t\t\t        filename + sep_pos + 1,\n\t\t\t\t        strlen(filename + sep_pos + 1) + 1);\n\t\t\t\tconn->path_info = filename + sep_pos + 1;\n\t\t\t\tfilename[sep_pos + 1] = '/';\n\t\t\t\t*is_script_resource = 1;\n\t\t\t\t*is_found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (allow_substitute_script_subresources) {\n\t\t\t\tif (substitute_index_file(\n\t\t\t\t        conn, tmp_str, tmp_str_len + PATH_MAX, filestat)) {\n\n\t\t\t\t\t/* some intermediate directory has an index file */\n\t\t\t\t\tif (extention_matches_script(conn, tmp_str)) {\n\n\t\t\t\t\t\tchar *tmp_str2;\n\n\t\t\t\t\t\tDEBUG_TRACE(\"Substitute script %s serving path %s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            filename);\n\n\t\t\t\t\t\t/* this index file is a script */\n\t\t\t\t\t\ttmp_str2 = mg_strdup_ctx(filename + sep_pos + 1,\n\t\t\t\t\t\t                         conn->phys_ctx);\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            filename,\n\t\t\t\t\t\t            filename_buf_len,\n\t\t\t\t\t\t            \"%s//%s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            tmp_str2);\n\t\t\t\t\t\tmg_free(tmp_str2);\n\n\t\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\t\tmg_free(tmp_str);\n\t\t\t\t\t\t\tgoto interpret_cleanup;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsep_pos = strlen(tmp_str);\n\t\t\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\t\t\tconn->path_info = filename + sep_pos + 1;\n\t\t\t\t\t\t*is_script_resource = 1;\n\t\t\t\t\t\t*is_found = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tDEBUG_TRACE(\"Substitute file %s serving path %s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            filename);\n\n\t\t\t\t\t\t/* non-script files will not have sub-resources */\n\t\t\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\t\t\tconn->path_info = 0;\n\t\t\t\t\t\t*is_script_resource = 0;\n\t\t\t\t\t\t*is_found = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp_str[sep_pos] = '/';\n\t\t}\n\t}\n\n\tmg_free(tmp_str);\n\n#endif /* !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE) */\n#endif /* !defined(NO_FILES) */\n\treturn;\n\n#if !defined(NO_FILES)\n/* Reset all outputs */\ninterpret_cleanup:\n\tmemset(filestat, 0, sizeof(*filestat));\n\t*filename = 0;\n\t*is_found = 0;\n\t*is_script_resource = 0;\n\t*is_websocket_request = 0;\n\t*is_put_or_delete_request = 0;\n#endif /* !defined(NO_FILES) */\n}\n\n\n/* Check whether full request is buffered. Return:\n * -1  if request or response is malformed\n *  0  if request or response is not yet fully buffered\n * >0  actual request length, including last \\r\\n\\r\\n */\nstatic int\nget_http_header_len(const char *buf, int buflen)\n{\n\tint i;\n\tfor (i = 0; i < buflen; i++) {\n\t\t/* Do an unsigned comparison in some conditions below */\n\t\tconst unsigned char c = ((const unsigned char *)buf)[i];\n\n\t\tif ((c < 128) && ((char)c != '\\r') && ((char)c != '\\n')\n\t\t    && !isprint(c)) {\n\t\t\t/* abort scan as soon as one malformed character is found */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (i < buflen - 1) {\n\t\t\tif ((buf[i] == '\\n') && (buf[i + 1] == '\\n')) {\n\t\t\t\t/* Two newline, no carriage return - not standard compliant,\n\t\t\t\t * but\n\t\t\t\t * it\n\t\t\t\t * should be accepted */\n\t\t\t\treturn i + 2;\n\t\t\t}\n\t\t}\n\n\t\tif (i < buflen - 3) {\n\t\t\tif ((buf[i] == '\\r') && (buf[i + 1] == '\\n') && (buf[i + 2] == '\\r')\n\t\t\t    && (buf[i + 3] == '\\n')) {\n\t\t\t\t/* Two \\r\\n - standard compliant */\n\t\t\t\treturn i + 4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#if !defined(NO_CACHING)\n/* Convert month to the month number. Return -1 on error, or month number */\nstatic int\nget_month_index(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(month_names); i++) {\n\t\tif (!strcmp(s, month_names[i])) {\n\t\t\treturn (int)i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\n/* Parse UTC date-time string, and return the corresponding time_t value. */\nstatic time_t\nparse_date_string(const char *datetime)\n{\n\tchar month_str[32] = {0};\n\tint second, minute, hour, day, month, year;\n\ttime_t result = (time_t)0;\n\tstruct tm tm;\n\n\tif ((sscanf(datetime,\n\t            \"%d/%3s/%d %d:%d:%d\",\n\t            &day,\n\t            month_str,\n\t            &year,\n\t            &hour,\n\t            &minute,\n\t            &second) == 6) || (sscanf(datetime,\n\t                                      \"%d %3s %d %d:%d:%d\",\n\t                                      &day,\n\t                                      month_str,\n\t                                      &year,\n\t                                      &hour,\n\t                                      &minute,\n\t                                      &second) == 6)\n\t    || (sscanf(datetime,\n\t               \"%*3s, %d %3s %d %d:%d:%d\",\n\t               &day,\n\t               month_str,\n\t               &year,\n\t               &hour,\n\t               &minute,\n\t               &second) == 6) || (sscanf(datetime,\n\t                                         \"%d-%3s-%d %d:%d:%d\",\n\t                                         &day,\n\t                                         month_str,\n\t                                         &year,\n\t                                         &hour,\n\t                                         &minute,\n\t                                         &second) == 6)) {\n\t\tmonth = get_month_index(month_str);\n\t\tif ((month >= 0) && (year >= 1970)) {\n\t\t\tmemset(&tm, 0, sizeof(tm));\n\t\t\ttm.tm_year = year - 1900;\n\t\t\ttm.tm_mon = month;\n\t\t\ttm.tm_mday = day;\n\t\t\ttm.tm_hour = hour;\n\t\t\ttm.tm_min = minute;\n\t\t\ttm.tm_sec = second;\n\t\t\tresult = timegm(&tm);\n\t\t}\n\t}\n\n\treturn result;\n}\n#endif /* !NO_CACHING */\n\n\n/* Protect against directory disclosure attack by removing '..',\n * excessive '/' and '\\' characters */\nstatic void\nremove_double_dots_and_double_slashes(char *s)\n{\n\tchar *p = s;\n\n\twhile ((s[0] == '.') && (s[1] == '.')) {\n\t\ts++;\n\t}\n\n\twhile (*s != '\\0') {\n\t\t*p++ = *s++;\n\t\tif ((s[-1] == '/') || (s[-1] == '\\\\')) {\n\t\t\t/* Skip all following slashes, backslashes and double-dots */\n\t\t\twhile (s[0] != '\\0') {\n\t\t\t\tif ((s[0] == '/') || (s[0] == '\\\\')) {\n\t\t\t\t\ts++;\n\t\t\t\t} else if ((s[0] == '.') && (s[1] == '.')) {\n\t\t\t\t\ts += 2;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*p = '\\0';\n}\n\n\nstatic const struct {\n\tconst char *extension;\n\tsize_t ext_len;\n\tconst char *mime_type;\n} builtin_mime_types[] = {\n    /* IANA registered MIME types\n     * (http://www.iana.org/assignments/media-types)\n     * application types */\n    {\".doc\", 4, \"application/msword\"},\n    {\".eps\", 4, \"application/postscript\"},\n    {\".exe\", 4, \"application/octet-stream\"},\n    {\".js\", 3, \"application/javascript\"},\n    {\".json\", 5, \"application/json\"},\n    {\".pdf\", 4, \"application/pdf\"},\n    {\".ps\", 3, \"application/postscript\"},\n    {\".rtf\", 4, \"application/rtf\"},\n    {\".xhtml\", 6, \"application/xhtml+xml\"},\n    {\".xsl\", 4, \"application/xml\"},\n    {\".xslt\", 5, \"application/xml\"},\n\n    /* fonts */\n    {\".ttf\", 4, \"application/font-sfnt\"},\n    {\".cff\", 4, \"application/font-sfnt\"},\n    {\".otf\", 4, \"application/font-sfnt\"},\n    {\".aat\", 4, \"application/font-sfnt\"},\n    {\".sil\", 4, \"application/font-sfnt\"},\n    {\".pfr\", 4, \"application/font-tdpfr\"},\n    {\".woff\", 5, \"application/font-woff\"},\n\n    /* audio */\n    {\".mp3\", 4, \"audio/mpeg\"},\n    {\".oga\", 4, \"audio/ogg\"},\n    {\".ogg\", 4, \"audio/ogg\"},\n\n    /* image */\n    {\".gif\", 4, \"image/gif\"},\n    {\".ief\", 4, \"image/ief\"},\n    {\".jpeg\", 5, \"image/jpeg\"},\n    {\".jpg\", 4, \"image/jpeg\"},\n    {\".jpm\", 4, \"image/jpm\"},\n    {\".jpx\", 4, \"image/jpx\"},\n    {\".png\", 4, \"image/png\"},\n    {\".svg\", 4, \"image/svg+xml\"},\n    {\".tif\", 4, \"image/tiff\"},\n    {\".tiff\", 5, \"image/tiff\"},\n\n    /* model */\n    {\".wrl\", 4, \"model/vrml\"},\n\n    /* text */\n    {\".css\", 4, \"text/css\"},\n    {\".csv\", 4, \"text/csv\"},\n    {\".htm\", 4, \"text/html\"},\n    {\".html\", 5, \"text/html\"},\n    {\".sgm\", 4, \"text/sgml\"},\n    {\".shtm\", 5, \"text/html\"},\n    {\".shtml\", 6, \"text/html\"},\n    {\".txt\", 4, \"text/plain\"},\n    {\".xml\", 4, \"text/xml\"},\n\n    /* video */\n    {\".mov\", 4, \"video/quicktime\"},\n    {\".mp4\", 4, \"video/mp4\"},\n    {\".mpeg\", 5, \"video/mpeg\"},\n    {\".mpg\", 4, \"video/mpeg\"},\n    {\".ogv\", 4, \"video/ogg\"},\n    {\".qt\", 3, \"video/quicktime\"},\n\n    /* not registered types\n     * (http://reference.sitepoint.com/html/mime-types-full,\n     * http://www.hansenb.pdx.edu/DMKB/dict/tutorials/mime_typ.php, ..) */\n    {\".arj\", 4, \"application/x-arj-compressed\"},\n    {\".gz\", 3, \"application/x-gunzip\"},\n    {\".rar\", 4, \"application/x-arj-compressed\"},\n    {\".swf\", 4, \"application/x-shockwave-flash\"},\n    {\".tar\", 4, \"application/x-tar\"},\n    {\".tgz\", 4, \"application/x-tar-gz\"},\n    {\".torrent\", 8, \"application/x-bittorrent\"},\n    {\".ppt\", 4, \"application/x-mspowerpoint\"},\n    {\".xls\", 4, \"application/x-msexcel\"},\n    {\".zip\", 4, \"application/x-zip-compressed\"},\n    {\".aac\",\n     4,\n     \"audio/aac\"}, /* http://en.wikipedia.org/wiki/Advanced_Audio_Coding */\n    {\".aif\", 4, \"audio/x-aif\"},\n    {\".m3u\", 4, \"audio/x-mpegurl\"},\n    {\".mid\", 4, \"audio/x-midi\"},\n    {\".ra\", 3, \"audio/x-pn-realaudio\"},\n    {\".ram\", 4, \"audio/x-pn-realaudio\"},\n    {\".wav\", 4, \"audio/x-wav\"},\n    {\".bmp\", 4, \"image/bmp\"},\n    {\".ico\", 4, \"image/x-icon\"},\n    {\".pct\", 4, \"image/x-pct\"},\n    {\".pict\", 5, \"image/pict\"},\n    {\".rgb\", 4, \"image/x-rgb\"},\n    {\".webm\", 5, \"video/webm\"}, /* http://en.wikipedia.org/wiki/WebM */\n    {\".asf\", 4, \"video/x-ms-asf\"},\n    {\".avi\", 4, \"video/x-msvideo\"},\n    {\".m4v\", 4, \"video/x-m4v\"},\n    {NULL, 0, NULL}};\n\n\nconst char *\nmg_get_builtin_mime_type(const char *path)\n{\n\tconst char *ext;\n\tsize_t i, path_len;\n\n\tpath_len = strlen(path);\n\n\tfor (i = 0; builtin_mime_types[i].extension != NULL; i++) {\n\t\text = path + (path_len - builtin_mime_types[i].ext_len);\n\t\tif ((path_len > builtin_mime_types[i].ext_len)\n\t\t    && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {\n\t\t\treturn builtin_mime_types[i].mime_type;\n\t\t}\n\t}\n\n\treturn \"text/plain\";\n}\n\n\n/* Look at the \"path\" extension and figure what mime type it has.\n * Store mime type in the vector. */\nstatic void\nget_mime_type(struct mg_connection *conn, const char *path, struct vec *vec)\n{\n\tstruct vec ext_vec, mime_vec;\n\tconst char *list, *ext;\n\tsize_t path_len;\n\n\tpath_len = strlen(path);\n\n\tif ((conn == NULL) || (vec == NULL)) {\n\t\tif (vec != NULL) {\n\t\t\tmemset(vec, '\\0', sizeof(struct vec));\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Scan user-defined mime types first, in case user wants to\n\t * override default mime types. */\n\tlist = conn->dom_ctx->config[EXTRA_MIME_TYPES];\n\twhile ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {\n\t\t/* ext now points to the path suffix */\n\t\text = path + path_len - ext_vec.len;\n\t\tif (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {\n\t\t\t*vec = mime_vec;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvec->ptr = mg_get_builtin_mime_type(path);\n\tvec->len = strlen(vec->ptr);\n}\n\n\n/* Stringify binary data. Output buffer must be twice as big as input,\n * because each byte takes 2 bytes in string representation */\nstatic void\nbin2str(char *to, const unsigned char *p, size_t len)\n{\n\tstatic const char *hex = \"0123456789abcdef\";\n\n\tfor (; len--; p++) {\n\t\t*to++ = hex[p[0] >> 4];\n\t\t*to++ = hex[p[0] & 0x0f];\n\t}\n\t*to = '\\0';\n}\n\n\n/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.\n */\nchar *\nmg_md5(char buf[33], ...)\n{\n\tmd5_byte_t hash[16];\n\tconst char *p;\n\tva_list ap;\n\tmd5_state_t ctx;\n\n\tmd5_init(&ctx);\n\n\tva_start(ap, buf);\n\twhile ((p = va_arg(ap, const char *)) != NULL) {\n\t\tmd5_append(&ctx, (const md5_byte_t *)p, strlen(p));\n\t}\n\tva_end(ap);\n\n\tmd5_finish(&ctx, hash);\n\tbin2str(buf, hash, sizeof(hash));\n\treturn buf;\n}\n\n\n/* Check the user's password, return 1 if OK */\nstatic int\ncheck_password(const char *method,\n               const char *ha1,\n               const char *uri,\n               const char *nonce,\n               const char *nc,\n               const char *cnonce,\n               const char *qop,\n               const char *response)\n{\n\tchar ha2[32 + 1], expected_response[32 + 1];\n\n\t/* Some of the parameters may be NULL */\n\tif ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL)\n\t    || (qop == NULL) || (response == NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */\n\tif (strlen(response) != 32) {\n\t\treturn 0;\n\t}\n\n\tmg_md5(ha2, method, \":\", uri, NULL);\n\tmg_md5(expected_response,\n\t       ha1,\n\t       \":\",\n\t       nonce,\n\t       \":\",\n\t       nc,\n\t       \":\",\n\t       cnonce,\n\t       \":\",\n\t       qop,\n\t       \":\",\n\t       ha2,\n\t       NULL);\n\n\treturn mg_strcasecmp(response, expected_response) == 0;\n}\n\n\n/* Use the global passwords file, if specified by auth_gpass option,\n * or search for .htpasswd in the requested directory. */\nstatic void\nopen_auth_file(struct mg_connection *conn,\n               const char *path,\n               struct mg_file *filep)\n{\n\tif ((conn != NULL) && (conn->dom_ctx != NULL)) {\n\t\tchar name[PATH_MAX];\n\t\tconst char *p, *e,\n\t\t    *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];\n\t\tint truncated;\n\n\t\tif (gpass != NULL) {\n\t\t\t/* Use global passwords file */\n\t\t\tif (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Use mg_cry_internal here, since gpass has been configured. */\n\t\t\t\tmg_cry_internal(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t\t/* Important: using local struct mg_file to test path for\n\t\t\t * is_directory flag. If filep is used, mg_stat() makes it\n\t\t\t * appear as if auth file was opened.\n\t\t\t * TODO(mid): Check if this is still required after rewriting\n\t\t\t * mg_stat */\n\t\t} else if (mg_stat(conn, path, &filep->stat)\n\t\t           && filep->stat.is_directory) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            name,\n\t\t\t            sizeof(name),\n\t\t\t            \"%s/%s\",\n\t\t\t            path,\n\t\t\t            PASSWORDS_FILE_NAME);\n\n\t\t\tif (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Don't use mg_cry_internal here, but only a trace, since this\n\t\t\t\t * is\n\t\t\t\t * a typical case. It will occur for every directory\n\t\t\t\t * without a password file. */\n\t\t\t\tDEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t} else {\n\t\t\t/* Try to find .htpasswd in requested directory. */\n\t\t\tfor (p = path, e = p + strlen(p) - 1; e > p; e--) {\n\t\t\t\tif (e[0] == '/') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            name,\n\t\t\t            sizeof(name),\n\t\t\t            \"%.*s/%s\",\n\t\t\t            (int)(e - p),\n\t\t\t            p,\n\t\t\t            PASSWORDS_FILE_NAME);\n\n\t\t\tif (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Don't use mg_cry_internal here, but only a trace, since this\n\t\t\t\t * is\n\t\t\t\t * a typical case. It will occur for every directory\n\t\t\t\t * without a password file. */\n\t\t\t\tDEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/* Parsed Authorization header */\nstruct ah {\n\tchar *user, *uri, *cnonce, *response, *qop, *nc, *nonce;\n};\n\n\n/* Return 1 on success. Always initializes the ah structure. */\nstatic int\nparse_auth_header(struct mg_connection *conn,\n                  char *buf,\n                  size_t buf_size,\n                  struct ah *ah)\n{\n\tchar *name, *value, *s;\n\tconst char *auth_header;\n\tuint64_t nonce;\n\n\tif (!ah || !conn) {\n\t\treturn 0;\n\t}\n\n\t(void)memset(ah, 0, sizeof(*ah));\n\tif (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)\n\t    || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* Make modifiable copy of the auth header */\n\t(void)mg_strlcpy(buf, auth_header + 7, buf_size);\n\ts = buf;\n\n\t/* Parse authorization header */\n\tfor (;;) {\n\t\t/* Gobble initial spaces */\n\t\twhile (isspace(*(unsigned char *)s)) {\n\t\t\ts++;\n\t\t}\n\t\tname = skip_quoted(&s, \"=\", \" \", 0);\n\t\t/* Value is either quote-delimited, or ends at first comma or space.\n\t\t */\n\t\tif (s[0] == '\\\"') {\n\t\t\ts++;\n\t\t\tvalue = skip_quoted(&s, \"\\\"\", \" \", '\\\\');\n\t\t\tif (s[0] == ',') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = skip_quoted(&s, \", \", \" \", 0); /* IE uses commas, FF uses\n\t\t\t                                        * spaces */\n\t\t}\n\t\tif (*name == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!strcmp(name, \"username\")) {\n\t\t\tah->user = value;\n\t\t} else if (!strcmp(name, \"cnonce\")) {\n\t\t\tah->cnonce = value;\n\t\t} else if (!strcmp(name, \"response\")) {\n\t\t\tah->response = value;\n\t\t} else if (!strcmp(name, \"uri\")) {\n\t\t\tah->uri = value;\n\t\t} else if (!strcmp(name, \"qop\")) {\n\t\t\tah->qop = value;\n\t\t} else if (!strcmp(name, \"nc\")) {\n\t\t\tah->nc = value;\n\t\t} else if (!strcmp(name, \"nonce\")) {\n\t\t\tah->nonce = value;\n\t\t}\n\t}\n\n#if !defined(NO_NONCE_CHECK)\n\t/* Read the nonce from the response. */\n\tif (ah->nonce == NULL) {\n\t\treturn 0;\n\t}\n\ts = NULL;\n\tnonce = strtoull(ah->nonce, &s, 10);\n\tif ((s == NULL) || (*s != 0)) {\n\t\treturn 0;\n\t}\n\n\t/* Convert the nonce from the client to a number. */\n\tnonce ^= conn->dom_ctx->auth_nonce_mask;\n\n\t/* The converted number corresponds to the time the nounce has been\n\t * created. This should not be earlier than the server start. */\n\t/* Server side nonce check is valuable in all situations but one:\n\t * if the server restarts frequently, but the client should not see\n\t * that, so the server should accept nonces from previous starts. */\n\t/* However, the reasonable default is to not accept a nonce from a\n\t * previous start, so if anyone changed the access rights between\n\t * two restarts, a new login is required. */\n\tif (nonce < (uint64_t)conn->phys_ctx->start_time) {\n\t\t/* nonce is from a previous start of the server and no longer valid\n\t\t * (replay attack?) */\n\t\treturn 0;\n\t}\n\t/* Check if the nonce is too high, so it has not (yet) been used by the\n\t * server. */\n\tif (nonce >= ((uint64_t)conn->phys_ctx->start_time\n\t              + conn->dom_ctx->nonce_count)) {\n\t\treturn 0;\n\t}\n#else\n\t(void)nonce;\n#endif\n\n\t/* CGI needs it as REMOTE_USER */\n\tif (ah->user != NULL) {\n\t\tconn->request_info.remote_user =\n\t\t    mg_strdup_ctx(ah->user, conn->phys_ctx);\n\t} else {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic const char *\nmg_fgets(char *buf, size_t size, struct mg_file *filep, char **p)\n{\n#if defined(MG_USE_OPEN_FILE)\n\tconst char *eof;\n\tsize_t len;\n\tconst char *memend;\n#else\n\t(void)p; /* parameter is unused */\n#endif\n\n\tif (!filep) {\n\t\treturn NULL;\n\t}\n\n#if defined(MG_USE_OPEN_FILE)\n\tif ((filep->access.membuf != NULL) && (*p != NULL)) {\n\t\tmemend = (const char *)&filep->access.membuf[filep->stat.size];\n\t\t/* Search for \\n from p till the end of stream */\n\t\teof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));\n\t\tif (eof != NULL) {\n\t\t\teof += 1; /* Include \\n */\n\t\t} else {\n\t\t\teof = memend; /* Copy remaining data */\n\t\t}\n\t\tlen =\n\t\t    ((size_t)(eof - *p) > (size - 1)) ? (size - 1) : (size_t)(eof - *p);\n\t\tmemcpy(buf, *p, len);\n\t\tbuf[len] = '\\0';\n\t\t*p += len;\n\t\treturn len ? eof : NULL;\n\t} else /* filep->access.fp block below */\n#endif\n\t    if (filep->access.fp != NULL) {\n\t\treturn fgets(buf, (int)size, filep->access.fp);\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\n/* Define the initial recursion depth for procesesing htpasswd files that\n * include other htpasswd\n * (or even the same) files.  It is not difficult to provide a file or files\n * s.t. they force civetweb\n * to infinitely recurse and then crash.\n */\n#define INITIAL_DEPTH 9\n#if INITIAL_DEPTH <= 0\n#error Bad INITIAL_DEPTH for recursion, set to at least 1\n#endif\n\nstruct read_auth_file_struct {\n\tstruct mg_connection *conn;\n\tstruct ah ah;\n\tconst char *domain;\n\tchar buf[256 + 256 + 40];\n\tconst char *f_user;\n\tconst char *f_domain;\n\tconst char *f_ha1;\n};\n\n\nstatic int\nread_auth_file(struct mg_file *filep,\n               struct read_auth_file_struct *workdata,\n               int depth)\n{\n\tchar *p = NULL /* init if MG_USE_OPEN_FILE is not set */;\n\tint is_authorized = 0;\n\tstruct mg_file fp;\n\tsize_t l;\n\n\tif (!filep || !workdata || (0 == depth)) {\n\t\treturn 0;\n\t}\n\n/* Loop over passwords file */\n#if defined(MG_USE_OPEN_FILE)\n\tp = (char *)filep->access.membuf;\n#endif\n\twhile (mg_fgets(workdata->buf, sizeof(workdata->buf), filep, &p) != NULL) {\n\t\tl = strlen(workdata->buf);\n\t\twhile (l > 0) {\n\t\t\tif (isspace(workdata->buf[l - 1])\n\t\t\t    || iscntrl(workdata->buf[l - 1])) {\n\t\t\t\tl--;\n\t\t\t\tworkdata->buf[l] = 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (l < 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tworkdata->f_user = workdata->buf;\n\n\t\tif (workdata->f_user[0] == ':') {\n\t\t\t/* user names may not contain a ':' and may not be empty,\n\t\t\t * so lines starting with ':' may be used for a special purpose\n\t\t\t */\n\t\t\tif (workdata->f_user[1] == '#') {\n\t\t\t\t/* :# is a comment */\n\t\t\t\tcontinue;\n\t\t\t} else if (!strncmp(workdata->f_user + 1, \"include=\", 8)) {\n\t\t\t\tif (mg_fopen(workdata->conn,\n\t\t\t\t             workdata->f_user + 9,\n\t\t\t\t             MG_FOPEN_MODE_READ,\n\t\t\t\t             &fp)) {\n\t\t\t\t\tis_authorized = read_auth_file(&fp, workdata, depth - 1);\n\t\t\t\t\t(void)mg_fclose(\n\t\t\t\t\t    &fp.access); /* ignore error on read only file */\n\n\t\t\t\t\t/* No need to continue processing files once we have a\n\t\t\t\t\t * match, since nothing will reset it back\n\t\t\t\t\t * to 0.\n\t\t\t\t\t */\n\t\t\t\t\tif (is_authorized) {\n\t\t\t\t\t\treturn is_authorized;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t\t\t                \"%s: cannot open authorization file: %s\",\n\t\t\t\t\t                __func__,\n\t\t\t\t\t                workdata->buf);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* everything is invalid for the moment (might change in the\n\t\t\t * future) */\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tworkdata->f_domain = strchr(workdata->f_user, ':');\n\t\tif (workdata->f_domain == NULL) {\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\t\t*(char *)(workdata->f_domain) = 0;\n\t\t(workdata->f_domain)++;\n\n\t\tworkdata->f_ha1 = strchr(workdata->f_domain, ':');\n\t\tif (workdata->f_ha1 == NULL) {\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\t\t*(char *)(workdata->f_ha1) = 0;\n\t\t(workdata->f_ha1)++;\n\n\t\tif (!strcmp(workdata->ah.user, workdata->f_user)\n\t\t    && !strcmp(workdata->domain, workdata->f_domain)) {\n\t\t\treturn check_password(workdata->conn->request_info.request_method,\n\t\t\t                      workdata->f_ha1,\n\t\t\t                      workdata->ah.uri,\n\t\t\t                      workdata->ah.nonce,\n\t\t\t                      workdata->ah.nc,\n\t\t\t                      workdata->ah.cnonce,\n\t\t\t                      workdata->ah.qop,\n\t\t\t                      workdata->ah.response);\n\t\t}\n\t}\n\n\treturn is_authorized;\n}\n\n\n/* Authorize against the opened passwords file. Return 1 if authorized. */\nstatic int\nauthorize(struct mg_connection *conn, struct mg_file *filep, const char *realm)\n{\n\tstruct read_auth_file_struct workdata;\n\tchar buf[MG_BUF_LEN];\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&workdata, 0, sizeof(workdata));\n\tworkdata.conn = conn;\n\n\tif (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {\n\t\treturn 0;\n\t}\n\n\tif (realm) {\n\t\tworkdata.domain = realm;\n\t} else {\n\t\tworkdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t}\n\n\treturn read_auth_file(filep, &workdata, INITIAL_DEPTH);\n}\n\n\n/* Public function to check http digest authentication header */\nint\nmg_check_digest_access_authentication(struct mg_connection *conn,\n                                      const char *realm,\n                                      const char *filename)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tint auth;\n\n\tif (!conn || !filename) {\n\t\treturn -1;\n\t}\n\tif (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {\n\t\treturn -2;\n\t}\n\n\tauth = authorize(conn, &file, realm);\n\n\tmg_fclose(&file.access);\n\n\treturn auth;\n}\n\n\n/* Return 1 if request is authorised, 0 otherwise. */\nstatic int\ncheck_authorization(struct mg_connection *conn, const char *path)\n{\n\tchar fname[PATH_MAX];\n\tstruct vec uri_vec, filename_vec;\n\tconst char *list;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tint authorized = 1, truncated;\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\tlist = conn->dom_ctx->config[PROTECT_URI];\n\twhile ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {\n\t\tif (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            fname,\n\t\t\t            sizeof(fname),\n\t\t\t            \"%.*s\",\n\t\t\t            (int)filename_vec.len,\n\t\t\t            filename_vec.ptr);\n\n\t\t\tif (truncated\n\t\t\t    || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: cannot open %s: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                fname,\n\t\t\t\t                strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_file_opened(&file.access)) {\n\t\topen_auth_file(conn, path, &file);\n\t}\n\n\tif (is_file_opened(&file.access)) {\n\t\tauthorized = authorize(conn, &file, NULL);\n\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t}\n\n\treturn authorized;\n}\n\n\n/* Internal function. Assumes conn is valid */\nstatic void\nsend_authorization_request(struct mg_connection *conn, const char *realm)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tuint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);\n\n\tif (!realm) {\n\t\trealm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t}\n\n\t(void)pthread_mutex_lock(&conn->phys_ctx->nonce_mutex);\n\tnonce += conn->dom_ctx->nonce_count;\n\t++conn->dom_ctx->nonce_count;\n\t(void)pthread_mutex_unlock(&conn->phys_ctx->nonce_mutex);\n\n\tnonce ^= conn->dom_ctx->auth_nonce_mask;\n\tconn->status_code = 401;\n\tconn->must_close = 1;\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tmg_printf(conn, \"HTTP/1.1 401 Unauthorized\\r\\n\");\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\"\n\t          \"Content-Length: 0\\r\\n\"\n\t          \"WWW-Authenticate: Digest qop=\\\"auth\\\", realm=\\\"%s\\\", \"\n\t          \"nonce=\\\"%\" UINT64_FMT \"\\\"\\r\\n\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn),\n\t          realm,\n\t          nonce);\n}\n\n\n/* Interface function. Parameters are provided by the user, so do\n * at least some basic checks.\n */\nint\nmg_send_digest_access_authentication_request(struct mg_connection *conn,\n                                             const char *realm)\n{\n\tif (conn && conn->dom_ctx) {\n\t\tsend_authorization_request(conn, realm);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nis_authorized_for_put(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\t\tconst char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];\n\t\tint ret = 0;\n\n\t\tif (passfile != NULL\n\t\t    && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {\n\t\t\tret = authorize(conn, &file, NULL);\n\t\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t\t}\n\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n#endif\n\n\nint\nmg_modify_passwords_file(const char *fname,\n                         const char *domain,\n                         const char *user,\n                         const char *pass)\n{\n\tint found, i;\n\tchar line[512], u[512] = \"\", d[512] = \"\", ha1[33], tmp[PATH_MAX + 8];\n\tFILE *fp, *fp2;\n\n\tfound = 0;\n\tfp = fp2 = NULL;\n\n\t/* Regard empty password as no password - remove user record. */\n\tif ((pass != NULL) && (pass[0] == '\\0')) {\n\t\tpass = NULL;\n\t}\n\n\t/* Other arguments must not be empty */\n\tif ((fname == NULL) || (domain == NULL) || (user == NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* Using the given file format, user name and domain must not contain\n\t * ':'\n\t */\n\tif (strchr(user, ':') != NULL) {\n\t\treturn 0;\n\t}\n\tif (strchr(domain, ':') != NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Do not allow control characters like newline in user name and domain.\n\t * Do not allow excessively long names either. */\n\tfor (i = 0; ((i < 255) && (user[i] != 0)); i++) {\n\t\tif (iscntrl(user[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (user[i]) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; ((i < 255) && (domain[i] != 0)); i++) {\n\t\tif (iscntrl(domain[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (domain[i]) {\n\t\treturn 0;\n\t}\n\n\t/* The maximum length of the path to the password file is limited */\n\tif ((strlen(fname) + 4) >= PATH_MAX) {\n\t\treturn 0;\n\t}\n\n\t/* Create a temporary file name. Length has been checked before. */\n\tstrcpy(tmp, fname);\n\tstrcat(tmp, \".tmp\");\n\n\t/* Create the file if does not exist */\n\t/* Use of fopen here is OK, since fname is only ASCII */\n\tif ((fp = fopen(fname, \"a+\")) != NULL) {\n\t\t(void)fclose(fp);\n\t}\n\n\t/* Open the given file and temporary file */\n\tif ((fp = fopen(fname, \"r\")) == NULL) {\n\t\treturn 0;\n\t} else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\n\t/* Copy the stuff to temporary file */\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\tif (sscanf(line, \"%255[^:]:%255[^:]:%*s\", u, d) != 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tu[255] = 0;\n\t\td[255] = 0;\n\n\t\tif (!strcmp(u, user) && !strcmp(d, domain)) {\n\t\t\tfound++;\n\t\t\tif (pass != NULL) {\n\t\t\t\tmg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n\t\t\t\tfprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(fp2, \"%s\", line);\n\t\t}\n\t}\n\n\t/* If new user, just add it */\n\tif (!found && (pass != NULL)) {\n\t\tmg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n\t\tfprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n\t}\n\n\t/* Close files */\n\tfclose(fp);\n\tfclose(fp2);\n\n\t/* Put the temp file in place of real file */\n\tIGNORE_UNUSED_RESULT(remove(fname));\n\tIGNORE_UNUSED_RESULT(rename(tmp, fname));\n\n\treturn 1;\n}\n\n\nstatic int\nis_valid_port(unsigned long port)\n{\n\treturn (port <= 0xffff);\n}\n\n\nstatic int\nmg_inet_pton(int af, const char *src, void *dst, size_t dstlen)\n{\n\tstruct addrinfo hints, *res, *ressave;\n\tint func_ret = 0;\n\tint gai_ret;\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = af;\n\n\tgai_ret = getaddrinfo(src, NULL, &hints, &res);\n\tif (gai_ret != 0) {\n\t\t/* gai_strerror could be used to convert gai_ret to a string */\n\t\t/* POSIX return values: see\n\t\t * http://pubs.opengroup.org/onlinepubs/9699919799/functions/freeaddrinfo.html\n\t\t */\n\t\t/* Windows return values: see\n\t\t * https://msdn.microsoft.com/en-us/library/windows/desktop/ms738520%28v=vs.85%29.aspx\n\t\t */\n\t\treturn 0;\n\t}\n\n\tressave = res;\n\n\twhile (res) {\n\t\tif (dstlen >= (size_t)res->ai_addrlen) {\n\t\t\tmemcpy(dst, res->ai_addr, res->ai_addrlen);\n\t\t\tfunc_ret = 1;\n\t\t}\n\t\tres = res->ai_next;\n\t}\n\n\tfreeaddrinfo(ressave);\n\treturn func_ret;\n}\n\n\nstatic int\nconnect_socket(struct mg_context *ctx /* may be NULL */,\n               const char *host,\n               int port,\n               int use_ssl,\n               char *ebuf,\n               size_t ebuf_len,\n               SOCKET *sock /* output: socket, must not be NULL */,\n               union usa *sa /* output: socket address, must not be NULL  */\n               )\n{\n\tint ip_ver = 0;\n\tint conn_ret = -1;\n\t*sock = INVALID_SOCKET;\n\tmemset(sa, 0, sizeof(*sa));\n\n\tif (ebuf_len > 0) {\n\t\t*ebuf = 0;\n\t}\n\n\tif (host == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"NULL host\");\n\t\treturn 0;\n\t}\n\n\tif ((port <= 0) || !is_valid_port((unsigned)port)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"invalid port\");\n\t\treturn 0;\n\t}\n\n#if !defined(NO_SSL)\n#if !defined(NO_SSL_DL)\n#if defined(OPENSSL_API_1_1)\n\tif (use_ssl && (TLS_client_method == NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"SSL is not initialized\");\n\t\treturn 0;\n\t}\n#else\n\tif (use_ssl && (SSLv23_client_method == NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"SSL is not initialized\");\n\t\treturn 0;\n\t}\n\n#endif /* OPENSSL_API_1_1 */\n#else\n\t(void)use_ssl;\n#endif /* NO_SSL_DL */\n#else\n\t(void)use_ssl;\n#endif /* !defined(NO_SSL) */\n\n\tif (mg_inet_pton(AF_INET, host, &sa->sin, sizeof(sa->sin))) {\n\t\tsa->sin.sin_family = AF_INET;\n\t\tsa->sin.sin_port = htons((uint16_t)port);\n\t\tip_ver = 4;\n#if defined(USE_IPV6)\n\t} else if (mg_inet_pton(AF_INET6, host, &sa->sin6, sizeof(sa->sin6))) {\n\t\tsa->sin6.sin6_family = AF_INET6;\n\t\tsa->sin6.sin6_port = htons((uint16_t)port);\n\t\tip_ver = 6;\n\t} else if (host[0] == '[') {\n\t\t/* While getaddrinfo on Windows will work with [::1],\n\t\t * getaddrinfo on Linux only works with ::1 (without []). */\n\t\tsize_t l = strlen(host + 1);\n\t\tchar *h = (l > 1) ? mg_strdup_ctx(host + 1, ctx) : NULL;\n\t\tif (h) {\n\t\t\th[l - 1] = 0;\n\t\t\tif (mg_inet_pton(AF_INET6, h, &sa->sin6, sizeof(sa->sin6))) {\n\t\t\t\tsa->sin6.sin6_family = AF_INET6;\n\t\t\t\tsa->sin6.sin6_port = htons((uint16_t)port);\n\t\t\t\tip_ver = 6;\n\t\t\t}\n\t\t\tmg_free(h);\n\t\t}\n#endif\n\t}\n\n\tif (ip_ver == 0) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"host not found\");\n\t\treturn 0;\n\t}\n\n\tif (ip_ver == 4) {\n\t\t*sock = socket(PF_INET, SOCK_STREAM, 0);\n\t}\n#if defined(USE_IPV6)\n\telse if (ip_ver == 6) {\n\t\t*sock = socket(PF_INET6, SOCK_STREAM, 0);\n\t}\n#endif\n\n\tif (*sock == INVALID_SOCKET) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"socket(): %s\",\n\t\t            strerror(ERRNO));\n\t\treturn 0;\n\t}\n\n\tif (0 != set_non_blocking_mode(*sock)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"Cannot set socket to non-blocking: %s\",\n\t\t            strerror(ERRNO));\n\t\tclosesocket(*sock);\n\t\t*sock = INVALID_SOCKET;\n\t\treturn 0;\n\t}\n\n\tset_close_on_exec(*sock, fc(ctx));\n\n\tif (ip_ver == 4) {\n\t\t/* connected with IPv4 */\n\t\tconn_ret = connect(*sock,\n\t\t                   (struct sockaddr *)((void *)&sa->sin),\n\t\t                   sizeof(sa->sin));\n\t}\n#if defined(USE_IPV6)\n\telse if (ip_ver == 6) {\n\t\t/* connected with IPv6 */\n\t\tconn_ret = connect(*sock,\n\t\t                   (struct sockaddr *)((void *)&sa->sin6),\n\t\t                   sizeof(sa->sin6));\n\t}\n#endif\n\n#if defined(_WIN32)\n\tif (conn_ret != 0) {\n\t\tDWORD err = WSAGetLastError(); /* could return WSAEWOULDBLOCK */\n\t\tconn_ret = (int)err;\n#if !defined(EINPROGRESS)\n#define EINPROGRESS (WSAEWOULDBLOCK) /* Winsock equivalent */\n#endif                               /* if !defined(EINPROGRESS) */\n\t}\n#endif\n\n\tif ((conn_ret != 0) && (conn_ret != EINPROGRESS)) {\n\t\t/* Data for getsockopt */\n\t\tint sockerr = -1;\n\t\tvoid *psockerr = &sockerr;\n\n#if defined(_WIN32)\n\t\tint len = (int)sizeof(sockerr);\n#else\n\t\tsocklen_t len = (socklen_t)sizeof(sockerr);\n#endif\n\n\t\t/* Data for poll */\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\t\tint ms_wait = 10000; /* 10 second timeout */\n\n\t\t/* For a non-blocking socket, the connect sequence is:\n\t\t * 1) call connect (will not block)\n\t\t * 2) wait until the socket is ready for writing (select or poll)\n\t\t * 3) check connection state with getsockopt\n\t\t */\n\t\tpfd[0].fd = *sock;\n\t\tpfd[0].events = POLLOUT;\n\t\tpollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));\n\n\t\tif (pollres != 1) {\n\t\t\t/* Not connected */\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"connect(%s:%d): timeout\",\n\t\t\t            host,\n\t\t\t            port);\n\t\t\tclosesocket(*sock);\n\t\t\t*sock = INVALID_SOCKET;\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\tgetsockopt(*sock, SOL_SOCKET, SO_ERROR, (char *)psockerr, &len);\n#else\n\t\tgetsockopt(*sock, SOL_SOCKET, SO_ERROR, psockerr, &len);\n#endif\n\n\t\tif (sockerr != 0) {\n\t\t\t/* Not connected */\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"connect(%s:%d): error %s\",\n\t\t\t            host,\n\t\t\t            port,\n\t\t\t            strerror(sockerr));\n\t\t\tclosesocket(*sock);\n\t\t\t*sock = INVALID_SOCKET;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\nint\nmg_url_encode(const char *src, char *dst, size_t dst_len)\n{\n\tstatic const char *dont_escape = \"._-$,;~()\";\n\tstatic const char *hex = \"0123456789abcdef\";\n\tchar *pos = dst;\n\tconst char *end = dst + dst_len - 1;\n\n\tfor (; ((*src != '\\0') && (pos < end)); src++, pos++) {\n\t\tif (isalnum(*(const unsigned char *)src)\n\t\t    || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {\n\t\t\t*pos = *src;\n\t\t} else if (pos + 2 < end) {\n\t\t\tpos[0] = '%';\n\t\t\tpos[1] = hex[(*(const unsigned char *)src) >> 4];\n\t\t\tpos[2] = hex[(*(const unsigned char *)src) & 0xf];\n\t\t\tpos += 2;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*pos = '\\0';\n\treturn (*src == '\\0') ? (int)(pos - dst) : -1;\n}\n\n/* Return 0 on success, non-zero if an error occurs. */\n\nstatic int\nprint_dir_entry(struct de *de)\n{\n\tsize_t hrefsize;\n\tchar *href;\n\tchar size[64], mod[64];\n#if defined(REENTRANT_TIME)\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n#else\n\tstruct tm *tm;\n#endif\n\n\threfsize = PATH_MAX * 3; /* worst case */\n\thref = (char *)mg_malloc(hrefsize);\n\tif (href == NULL) {\n\t\treturn -1;\n\t}\n\tif (de->file.is_directory) {\n\t\tmg_snprintf(de->conn,\n\t\t            NULL, /* Buffer is big enough */\n\t\t            size,\n\t\t            sizeof(size),\n\t\t            \"%s\",\n\t\t            \"[DIRECTORY]\");\n\t} else {\n\t\t/* We use (signed) cast below because MSVC 6 compiler cannot\n\t\t * convert unsigned __int64 to double. Sigh. */\n\t\tif (de->file.size < 1024) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%d\",\n\t\t\t            (int)de->file.size);\n\t\t} else if (de->file.size < 0x100000) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fk\",\n\t\t\t            (double)de->file.size / 1024.0);\n\t\t} else if (de->file.size < 0x40000000) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fM\",\n\t\t\t            (double)de->file.size / 1048576);\n\t\t} else {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fG\",\n\t\t\t            (double)de->file.size / 1073741824);\n\t\t}\n\t}\n\n/* Note: mg_snprintf will not cause a buffer overflow above.\n * So, string truncation checks are not required here. */\n\n#if defined(REENTRANT_TIME)\n\tlocaltime_r(&de->file.last_modified, tm);\n#else\n\ttm = localtime(&de->file.last_modified);\n#endif\n\tif (tm != NULL) {\n\t\tstrftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", tm);\n\t} else {\n\t\tmg_strlcpy(mod, \"01-Jan-1970 00:00\", sizeof(mod));\n\t\tmod[sizeof(mod) - 1] = '\\0';\n\t}\n\tmg_url_encode(de->file_name, href, hrefsize);\n\tmg_printf(de->conn,\n\t          \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"\n\t          \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n\t          de->conn->request_info.local_uri,\n\t          href,\n\t          de->file.is_directory ? \"/\" : \"\",\n\t          de->file_name,\n\t          de->file.is_directory ? \"/\" : \"\",\n\t          mod,\n\t          size);\n\tmg_free(href);\n\treturn 0;\n}\n\n\n/* This function is called from send_directory() and used for\n * sorting directory entries by size, or name, or modification time.\n * On windows, __cdecl specification is needed in case if project is built\n * with __stdcall convention. qsort always requires __cdels callback. */\nstatic int WINCDECL\ncompare_dir_entries(const void *p1, const void *p2)\n{\n\tif (p1 && p2) {\n\t\tconst struct de *a = (const struct de *)p1, *b = (const struct de *)p2;\n\t\tconst char *query_string = a->conn->request_info.query_string;\n\t\tint cmp_result = 0;\n\n\t\tif (query_string == NULL) {\n\t\t\tquery_string = \"na\";\n\t\t}\n\n\t\tif (a->file.is_directory && !b->file.is_directory) {\n\t\t\treturn -1; /* Always put directories on top */\n\t\t} else if (!a->file.is_directory && b->file.is_directory) {\n\t\t\treturn 1; /* Always put directories on top */\n\t\t} else if (*query_string == 'n') {\n\t\t\tcmp_result = strcmp(a->file_name, b->file_name);\n\t\t} else if (*query_string == 's') {\n\t\t\tcmp_result = (a->file.size == b->file.size)\n\t\t\t                 ? 0\n\t\t\t                 : ((a->file.size > b->file.size) ? 1 : -1);\n\t\t} else if (*query_string == 'd') {\n\t\t\tcmp_result =\n\t\t\t    (a->file.last_modified == b->file.last_modified)\n\t\t\t        ? 0\n\t\t\t        : ((a->file.last_modified > b->file.last_modified) ? 1\n\t\t\t                                                           : -1);\n\t\t}\n\n\t\treturn (query_string[1] == 'd') ? -cmp_result : cmp_result;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nmust_hide_file(struct mg_connection *conn, const char *path)\n{\n\tif (conn && conn->dom_ctx) {\n\t\tconst char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";\n\t\tconst char *pattern = conn->dom_ctx->config[HIDE_FILES];\n\t\treturn (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)\n\t\t       || ((pattern != NULL)\n\t\t           && (match_prefix(pattern, strlen(pattern), path) > 0));\n\t}\n\treturn 0;\n}\n\n\nstatic int\nscan_directory(struct mg_connection *conn,\n               const char *dir,\n               void *data,\n               int (*cb)(struct de *, void *))\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tstruct de de;\n\tint truncated;\n\n\tif ((dirp = mg_opendir(conn, dir)) == NULL) {\n\t\treturn 0;\n\t} else {\n\t\tde.conn = conn;\n\n\t\twhile ((dp = mg_readdir(dirp)) != NULL) {\n\t\t\t/* Do not show current dir and hidden files */\n\t\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")\n\t\t\t    || must_hide_file(conn, dp->d_name)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmg_snprintf(\n\t\t\t    conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n\n\t\t\t/* If we don't memset stat structure to zero, mtime will have\n\t\t\t * garbage and strftime() will segfault later on in\n\t\t\t * print_dir_entry(). memset is required only if mg_stat()\n\t\t\t * fails. For more details, see\n\t\t\t * http://code.google.com/p/mongoose/issues/detail?id=79 */\n\t\t\tmemset(&de.file, 0, sizeof(de.file));\n\n\t\t\tif (truncated) {\n\t\t\t\t/* If the path is not complete, skip processing. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!mg_stat(conn, path, &de.file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                path,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t}\n\t\t\tde.file_name = dp->d_name;\n\t\t\tcb(&de, data);\n\t\t}\n\t\t(void)mg_closedir(dirp);\n\t}\n\treturn 1;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nremove_directory(struct mg_connection *conn, const char *dir)\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tstruct de de;\n\tint truncated;\n\tint ok = 1;\n\n\tif ((dirp = mg_opendir(conn, dir)) == NULL) {\n\t\treturn 0;\n\t} else {\n\t\tde.conn = conn;\n\n\t\twhile ((dp = mg_readdir(dirp)) != NULL) {\n\t\t\t/* Do not show current dir (but show hidden files as they will\n\t\t\t * also be removed) */\n\t\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmg_snprintf(\n\t\t\t    conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n\n\t\t\t/* If we don't memset stat structure to zero, mtime will have\n\t\t\t * garbage and strftime() will segfault later on in\n\t\t\t * print_dir_entry(). memset is required only if mg_stat()\n\t\t\t * fails. For more details, see\n\t\t\t * http://code.google.com/p/mongoose/issues/detail?id=79 */\n\t\t\tmemset(&de.file, 0, sizeof(de.file));\n\n\t\t\tif (truncated) {\n\t\t\t\t/* Do not delete anything shorter */\n\t\t\t\tok = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!mg_stat(conn, path, &de.file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                path,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t\tok = 0;\n\t\t\t}\n\n\t\t\tif (de.file.is_directory) {\n\t\t\t\tif (remove_directory(conn, path) == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* This will fail file is the file is in memory */\n\t\t\t\tif (mg_remove(conn, path) == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(void)mg_closedir(dirp);\n\n\t\tIGNORE_UNUSED_RESULT(rmdir(dir));\n\t}\n\n\treturn ok;\n}\n#endif\n\n\nstruct dir_scan_data {\n\tstruct de *entries;\n\tunsigned int num_entries;\n\tunsigned int arr_size;\n};\n\n\n/* Behaves like realloc(), but frees original pointer on failure */\nstatic void *\nrealloc2(void *ptr, size_t size)\n{\n\tvoid *new_ptr = mg_realloc(ptr, size);\n\tif (new_ptr == NULL) {\n\t\tmg_free(ptr);\n\t}\n\treturn new_ptr;\n}\n\n\nstatic int\ndir_scan_callback(struct de *de, void *data)\n{\n\tstruct dir_scan_data *dsd = (struct dir_scan_data *)data;\n\n\tif ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {\n\t\tdsd->arr_size *= 2;\n\t\tdsd->entries =\n\t\t    (struct de *)realloc2(dsd->entries,\n\t\t                          dsd->arr_size * sizeof(dsd->entries[0]));\n\t}\n\tif (dsd->entries == NULL) {\n\t\t/* TODO(lsm, low): propagate an error to the caller */\n\t\tdsd->num_entries = 0;\n\t} else {\n\t\tdsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);\n\t\tdsd->entries[dsd->num_entries].file = de->file;\n\t\tdsd->entries[dsd->num_entries].conn = de->conn;\n\t\tdsd->num_entries++;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_directory_request(struct mg_connection *conn, const char *dir)\n{\n\tunsigned int i;\n\tint sort_direction;\n\tstruct dir_scan_data data = {NULL, 0, 128};\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (!scan_directory(conn, dir, &data, dir_scan_callback)) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot open directory\\nopendir(%s): %s\",\n\t\t                   dir,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\tsort_direction = ((conn->request_info.query_string != NULL)\n\t                  && (conn->request_info.query_string[1] == 'd'))\n\t                     ? 'a'\n\t                     : 'd';\n\n\tconn->must_close = 1;\n\tmg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: close\\r\\n\"\n\t          \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\",\n\t          date);\n\tmg_printf(conn,\n\t          \"<html><head><title>Index of %s</title>\"\n\t          \"<style>th {text-align: left;}</style></head>\"\n\t          \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"\n\t          \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"\n\t          \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"\n\t          \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"\n\t          \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",\n\t          conn->request_info.local_uri,\n\t          conn->request_info.local_uri,\n\t          sort_direction,\n\t          sort_direction,\n\t          sort_direction);\n\n\t/* Print first entry - link to a parent directory */\n\tmg_printf(conn,\n\t          \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"\n\t          \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n\t          conn->request_info.local_uri,\n\t          \"..\",\n\t          \"Parent directory\",\n\t          \"-\",\n\t          \"-\");\n\n\t/* Sort and print directory entries */\n\tif (data.entries != NULL) {\n\t\tqsort(data.entries,\n\t\t      (size_t)data.num_entries,\n\t\t      sizeof(data.entries[0]),\n\t\t      compare_dir_entries);\n\t\tfor (i = 0; i < data.num_entries; i++) {\n\t\t\tprint_dir_entry(&data.entries[i]);\n\t\t\tmg_free(data.entries[i].file_name);\n\t\t}\n\t\tmg_free(data.entries);\n\t}\n\n\tmg_printf(conn, \"%s\", \"</table></body></html>\");\n\tconn->status_code = 200;\n}\n\n\n/* Send len bytes from the opened file to the client. */\nstatic void\nsend_file_data(struct mg_connection *conn,\n               struct mg_file *filep,\n               int64_t offset,\n               int64_t len)\n{\n\tchar buf[MG_BUF_LEN];\n\tint to_read, num_read, num_written;\n\tint64_t size;\n\n\tif (!filep || !conn) {\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tsize = (filep->stat.size > INT64_MAX) ? INT64_MAX\n\t                                      : (int64_t)(filep->stat.size);\n\toffset = (offset < 0) ? 0 : ((offset > size) ? size : offset);\n\n#if defined(MG_USE_OPEN_FILE)\n\tif ((len > 0) && (filep->access.membuf != NULL) && (size > 0)) {\n\t\t/* file stored in memory */\n\t\tif (len > size - offset) {\n\t\t\tlen = size - offset;\n\t\t}\n\t\tmg_write(conn, filep->access.membuf + offset, (size_t)len);\n\t} else /* else block below */\n#endif\n\t    if (len > 0 && filep->access.fp != NULL) {\n/* file stored on disk */\n#if defined(__linux__)\n\t\t/* sendfile is only available for Linux */\n\t\tif ((conn->ssl == 0) && (conn->throttle == 0)\n\t\t    && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],\n\t\t                       \"yes\"))) {\n\t\t\toff_t sf_offs = (off_t)offset;\n\t\t\tssize_t sf_sent;\n\t\t\tint sf_file = fileno(filep->access.fp);\n\t\t\tint loop_cnt = 0;\n\n\t\t\tdo {\n\t\t\t\t/* 2147479552 (0x7FFFF000) is a limit found by experiment on\n\t\t\t\t * 64 bit Linux (2^31 minus one memory page of 4k?). */\n\t\t\t\tsize_t sf_tosend =\n\t\t\t\t    (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);\n\t\t\t\tsf_sent =\n\t\t\t\t    sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);\n\t\t\t\tif (sf_sent > 0) {\n\t\t\t\t\tlen -= sf_sent;\n\t\t\t\t\toffset += sf_sent;\n\t\t\t\t} else if (loop_cnt == 0) {\n\t\t\t\t\t/* This file can not be sent using sendfile.\n\t\t\t\t\t * This might be the case for pseudo-files in the\n\t\t\t\t\t * /sys/ and /proc/ file system.\n\t\t\t\t\t * Use the regular user mode copy code instead. */\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (sf_sent == 0) {\n\t\t\t\t\t/* No error, but 0 bytes sent. May be EOF? */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tloop_cnt++;\n\n\t\t\t} while ((len > 0) && (sf_sent >= 0));\n\n\t\t\tif (sf_sent > 0) {\n\t\t\t\treturn; /* OK */\n\t\t\t}\n\n\t\t\t/* sf_sent<0 means error, thus fall back to the classic way */\n\t\t\t/* This is always the case, if sf_file is not a \"normal\" file,\n\t\t\t * e.g., for sending data from the output of a CGI process. */\n\t\t\toffset = (int64_t)sf_offs;\n\t\t}\n#endif\n\t\tif ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fseeko() failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t\tmg_send_http_error(\n\t\t\t    conn,\n\t\t\t    500,\n\t\t\t    \"%s\",\n\t\t\t    \"Error: Unable to access file at requested position.\");\n\t\t} else {\n\t\t\twhile (len > 0) {\n\t\t\t\t/* Calculate how much to read from the file in the buffer */\n\t\t\t\tto_read = sizeof(buf);\n\t\t\t\tif ((int64_t)to_read > len) {\n\t\t\t\t\tto_read = (int)len;\n\t\t\t\t}\n\n\t\t\t\t/* Read from file, exit the loop on error */\n\t\t\t\tif ((num_read =\n\t\t\t\t         (int)fread(buf, 1, (size_t)to_read, filep->access.fp))\n\t\t\t\t    <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Send read bytes to the client, exit the loop on error */\n\t\t\t\tif ((num_written = mg_write(conn, buf, (size_t)num_read))\n\t\t\t\t    != num_read) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Both read and were successful, adjust counters */\n\t\t\t\tlen -= num_written;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nparse_range_header(const char *header, int64_t *a, int64_t *b)\n{\n\treturn sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);\n}\n\n\nstatic void\nconstruct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat)\n{\n\tif ((filestat != NULL) && (buf != NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* All calls to construct_etag use 64 byte buffer */\n\t\t            buf,\n\t\t            buf_len,\n\t\t            \"\\\"%lx.%\" INT64_FMT \"\\\"\",\n\t\t            (unsigned long)filestat->last_modified,\n\t\t            filestat->size);\n\t}\n}\n\n\nstatic void\nfclose_on_exec(struct mg_file_access *filep, struct mg_connection *conn)\n{\n\tif (filep != NULL && filep->fp != NULL) {\n#if defined(_WIN32)\n\t\t(void)conn; /* Unused. */\n#else\n\t\tif (fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC) != 0) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n#endif\n\t}\n}\n\n\n#if defined(USE_ZLIB)\n#include \"mod_zlib.inl\"\n#endif\n\n\nstatic void\nhandle_static_file_request(struct mg_connection *conn,\n                           const char *path,\n                           struct mg_file *filep,\n                           const char *mime_type,\n                           const char *additional_headers)\n{\n\tchar date[64], lm[64], etag[64];\n\tchar range[128]; /* large enough, so there will be no overflow */\n\tconst char *msg = \"OK\", *hdr;\n\ttime_t curtime = time(NULL);\n\tint64_t cl, r1, r2;\n\tstruct vec mime_vec;\n\tint n, truncated;\n\tchar gz_path[PATH_MAX];\n\tconst char *encoding = \"\";\n\tconst char *cors1, *cors2, *cors3;\n\tint is_head_request;\n\n#if defined(USE_ZLIB)\n\t/* Compression is allowed, unless there is a reason not to use compression.\n\t * If the file is already compressed, too small or a \"range\" request was\n\t * made, on the fly compression is not possible. */\n\tint allow_on_the_fly_compression = 1;\n#endif\n\n\tif ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tis_head_request = !strcmp(conn->request_info.request_method, \"HEAD\");\n\n\tif (mime_type == NULL) {\n\t\tget_mime_type(conn, path, &mime_vec);\n\t} else {\n\t\tmime_vec.ptr = mime_type;\n\t\tmime_vec.len = strlen(mime_type);\n\t}\n\tif (filep->stat.size > INT64_MAX) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: File size is too large to send\\n%\" INT64_FMT,\n\t\t                   filep->stat.size);\n\t\treturn;\n\t}\n\tcl = (int64_t)filep->stat.size;\n\tconn->status_code = 200;\n\trange[0] = '\\0';\n\n#if defined(USE_ZLIB)\n\t/* if this file is in fact a pre-gzipped file, rewrite its filename\n\t * it's important to rewrite the filename after resolving\n\t * the mime type from it, to preserve the actual file's type */\n\tif (!conn->accept_gzip) {\n\t\tallow_on_the_fly_compression = 0;\n\t}\n#endif\n\n\tif (filep->stat.is_gzipped) {\n\t\tmg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", path);\n\n\t\tif (truncated) {\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: Path of zipped file too long (%s)\",\n\t\t\t                   path);\n\t\t\treturn;\n\t\t}\n\n\t\tpath = gz_path;\n\t\tencoding = \"Content-Encoding: gzip\\r\\n\";\n\n#if defined(USE_ZLIB)\n\t\t/* File is already compressed. No \"on the fly\" compression. */\n\t\tallow_on_the_fly_compression = 0;\n#endif\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot open file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tfclose_on_exec(&filep->access, conn);\n\n\t/* If \"Range\" request was made: parse header, send only selected part\n\t * of the file. */\n\tr1 = r2 = 0;\n\thdr = mg_get_header(conn, \"Range\");\n\tif ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)\n\t    && (r1 >= 0) && (r2 >= 0)) {\n\t\t/* actually, range requests don't play well with a pre-gzipped\n\t\t * file (since the range is specified in the uncompressed space) */\n\t\tif (filep->stat.is_gzipped) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn,\n\t\t\t    416, /* 416 = Range Not Satisfiable */\n\t\t\t    \"%s\",\n\t\t\t    \"Error: Range requests in gzipped files are not supported\");\n\t\t\t(void)mg_fclose(\n\t\t\t    &filep->access); /* ignore error on read only file */\n\t\t\treturn;\n\t\t}\n\t\tconn->status_code = 206;\n\t\tcl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* range buffer is big enough */\n\t\t            range,\n\t\t            sizeof(range),\n\t\t            \"Content-Range: bytes \"\n\t\t            \"%\" INT64_FMT \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",\n\t\t            r1,\n\t\t            r1 + cl - 1,\n\t\t            filep->stat.size);\n\t\tmsg = \"Partial Content\";\n\n#if defined(USE_ZLIB)\n\t\t/* Do not compress ranges. */\n\t\tallow_on_the_fly_compression = 0;\n#endif\n\t}\n\n/* Do not compress small files. Small files do not benefit from file\n * compression, but there is still some overhead. */\n#if defined(USE_ZLIB)\n\tif (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {\n\t\t/* File is below the size limit. */\n\t\tallow_on_the_fly_compression = 0;\n\t}\n#endif\n\n\t/* Standard CORS header */\n\thdr = mg_get_header(conn, \"Origin\");\n\tif (hdr) {\n\t\t/* Cross-origin resource sharing (CORS), see\n\t\t * http://www.html5rocks.com/en/tutorials/cors/,\n\t\t * http://www.html5rocks.com/static/images/cors_server_flowchart.png\n\t\t * -\n\t\t * preflight is not supported for files. */\n\t\tcors1 = \"Access-Control-Allow-Origin: \";\n\t\tcors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tcors3 = \"\\r\\n\";\n\t} else {\n\t\tcors1 = cors2 = cors3 = \"\";\n\t}\n\n\t/* Prepare Etag, Date, Last-Modified headers. Must be in UTC,\n\t * according to\n\t * http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3 */\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tgmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);\n\tconstruct_etag(etag, sizeof(etag), &filep->stat);\n\n\t/* Send header */\n\t(void)mg_printf(conn,\n\t                \"HTTP/1.1 %d %s\\r\\n\"\n\t                \"%s%s%s\" /* CORS */\n\t                \"Date: %s\\r\\n\"\n\t                \"Last-Modified: %s\\r\\n\"\n\t                \"Etag: %s\\r\\n\"\n\t                \"Content-Type: %.*s\\r\\n\"\n\t                \"Connection: %s\\r\\n\",\n\t                conn->status_code,\n\t                msg,\n\t                cors1,\n\t                cors2,\n\t                cors3,\n\t                date,\n\t                lm,\n\t                etag,\n\t                (int)mime_vec.len,\n\t                mime_vec.ptr,\n\t                suggest_connection_header(conn));\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\n#if defined(USE_ZLIB)\n\t/* On the fly compression allowed */\n\tif (allow_on_the_fly_compression) {\n\t\t/* For on the fly compression, we don't know the content size in\n\t\t * advance, so we have to use chunked encoding */\n\t\t(void)mg_printf(conn,\n\t\t                \"Content-Encoding: gzip\\r\\n\"\n\t\t                \"Transfer-Encoding: chunked\\r\\n\");\n\t} else\n#endif\n\t{\n\t\t/* Without on-the-fly compression, we know the content-length\n\t\t * and we can use ranges (with on-the-fly compression we cannot).\n\t\t * So we send these response headers only in this case. */\n\t\t(void)mg_printf(conn,\n\t\t                \"Content-Length: %\" INT64_FMT \"\\r\\n\"\n\t\t                \"Accept-Ranges: bytes\\r\\n\"\n\t\t                \"%s\" /* range */\n\t\t                \"%s\" /* encoding */,\n\t\t                cl,\n\t\t                range,\n\t\t                encoding);\n\t}\n\n\t/* The previous code must not add any header starting with X- to make\n\t * sure no one of the additional_headers is included twice */\n\tif (additional_headers != NULL) {\n\t\t(void)mg_printf(conn,\n\t\t                \"%.*s\\r\\n\\r\\n\",\n\t\t                (int)strlen(additional_headers),\n\t\t                additional_headers);\n\t} else {\n\t\t(void)mg_printf(conn, \"\\r\\n\");\n\t}\n\n\tif (!is_head_request) {\n#if defined(USE_ZLIB)\n\t\tif (allow_on_the_fly_compression) {\n\t\t\t/* Compress and send */\n\t\t\tsend_compressed_data(conn, filep);\n\t\t} else\n#endif\n\t\t{\n\t\t\t/* Send file directly */\n\t\t\tsend_file_data(conn, filep, r1, cl);\n\t\t}\n\t}\n\t(void)mg_fclose(&filep->access); /* ignore error on read only file */\n}\n\n\n#if !defined(NO_CACHING)\n/* Return True if we should reply 304 Not Modified. */\nstatic int\nis_not_modified(const struct mg_connection *conn,\n                const struct mg_file_stat *filestat)\n{\n\tchar etag[64];\n\tconst char *ims = mg_get_header(conn, \"If-Modified-Since\");\n\tconst char *inm = mg_get_header(conn, \"If-None-Match\");\n\tconstruct_etag(etag, sizeof(etag), filestat);\n\n\treturn ((inm != NULL) && !mg_strcasecmp(etag, inm))\n\t       || ((ims != NULL)\n\t           && (filestat->last_modified <= parse_date_string(ims)));\n}\n\nstatic void\nhandle_not_modified_static_file_request(struct mg_connection *conn,\n                                        struct mg_file *filep)\n{\n\tchar date[64], lm[64], etag[64];\n\ttime_t curtime = time(NULL);\n\n\tif ((conn == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\tconn->status_code = 304;\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tgmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);\n\tconstruct_etag(etag, sizeof(etag), &filep->stat);\n\n\t(void)mg_printf(conn,\n\t                \"HTTP/1.1 %d %s\\r\\n\"\n\t                \"Date: %s\\r\\n\",\n\t                conn->status_code,\n\t                mg_get_response_code_text(conn, conn->status_code),\n\t                date);\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\t(void)mg_printf(conn,\n\t                \"Last-Modified: %s\\r\\n\"\n\t                \"Etag: %s\\r\\n\"\n\t                \"Connection: %s\\r\\n\"\n\t                \"\\r\\n\",\n\t                lm,\n\t                etag,\n\t                suggest_connection_header(conn));\n}\n#endif\n\n\nvoid\nmg_send_file(struct mg_connection *conn, const char *path)\n{\n\tmg_send_mime_file(conn, path, NULL);\n}\n\n\nvoid\nmg_send_mime_file(struct mg_connection *conn,\n                  const char *path,\n                  const char *mime_type)\n{\n\tmg_send_mime_file2(conn, path, mime_type, NULL);\n}\n\n\nvoid\nmg_send_mime_file2(struct mg_connection *conn,\n                   const char *path,\n                   const char *mime_type,\n                   const char *additional_headers)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (!conn) {\n\t\t/* No conn */\n\t\treturn;\n\t}\n\n\tif (mg_stat(conn, path, &file.stat)) {\n#if !defined(NO_CACHING)\n\t\tif (is_not_modified(conn, &file.stat)) {\n\t\t\t/* Send 304 \"Not Modified\" - this must not send any body data */\n\t\t\thandle_not_modified_static_file_request(conn, &file);\n\t\t} else\n#endif /* NO_CACHING */\n\t\t    if (file.stat.is_directory) {\n\t\t\tif (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t\t\t                   \"yes\")) {\n\t\t\t\thandle_directory_request(conn, path);\n\t\t\t} else {\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   403,\n\t\t\t\t                   \"%s\",\n\t\t\t\t                   \"Error: Directory listing denied\");\n\t\t\t}\n\t\t} else {\n\t\t\thandle_static_file_request(\n\t\t\t    conn, path, &file, mime_type, additional_headers);\n\t\t}\n\t} else {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Error: File not found\");\n\t}\n}\n\n\n/* For a given PUT path, create all intermediate subdirectories.\n * Return  0  if the path itself is a directory.\n * Return  1  if the path leads to a file.\n * Return -1  for if the path is too long.\n * Return -2  if path can not be created.\n*/\nstatic int\nput_dir(struct mg_connection *conn, const char *path)\n{\n\tchar buf[PATH_MAX];\n\tconst char *s, *p;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tsize_t len;\n\tint res = 1;\n\n\tfor (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {\n\t\tlen = (size_t)(p - path);\n\t\tif (len >= sizeof(buf)) {\n\t\t\t/* path too long */\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf, path, len);\n\t\tbuf[len] = '\\0';\n\n\t\t/* Try to create intermediate directory */\n\t\tDEBUG_TRACE(\"mkdir(%s)\", buf);\n\t\tif (!mg_stat(conn, buf, &file.stat) && mg_mkdir(conn, buf, 0755) != 0) {\n\t\t\t/* path does not exixt and can not be created */\n\t\t\tres = -2;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Is path itself a directory? */\n\t\tif (p[1] == '\\0') {\n\t\t\tres = 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\nstatic void\nremove_bad_file(const struct mg_connection *conn, const char *path)\n{\n\tint r = mg_remove(conn, path);\n\tif (r != 0) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Cannot remove invalid file %s\",\n\t\t                __func__,\n\t\t                path);\n\t}\n}\n\n\nlong long\nmg_store_body(struct mg_connection *conn, const char *path)\n{\n\tchar buf[MG_BUF_LEN];\n\tlong long len = 0;\n\tint ret, n;\n\tstruct mg_file fi;\n\n\tif (conn->consumed_content != 0) {\n\t\tmg_cry_internal(conn, \"%s: Contents already consumed\", __func__);\n\t\treturn -11;\n\t}\n\n\tret = put_dir(conn, path);\n\tif (ret < 0) {\n\t\t/* -1 for path too long,\n\t\t * -2 for path can not be created. */\n\t\treturn ret;\n\t}\n\tif (ret != 1) {\n\t\t/* Return 0 means, path itself is a directory. */\n\t\treturn 0;\n\t}\n\n\tif (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {\n\t\treturn -12;\n\t}\n\n\tret = mg_read(conn, buf, sizeof(buf));\n\twhile (ret > 0) {\n\t\tn = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);\n\t\tif (n != ret) {\n\t\t\t(void)mg_fclose(\n\t\t\t    &fi.access); /* File is bad and will be removed anyway. */\n\t\t\tremove_bad_file(conn, path);\n\t\t\treturn -13;\n\t\t}\n\t\tlen += ret;\n\t\tret = mg_read(conn, buf, sizeof(buf));\n\t}\n\n\t/* File is open for writing. If fclose fails, there was probably an\n\t * error flushing the buffer to disk, so the file on disk might be\n\t * broken. Delete it and return an error to the caller. */\n\tif (mg_fclose(&fi.access) != 0) {\n\t\tremove_bad_file(conn, path);\n\t\treturn -14;\n\t}\n\n\treturn len;\n}\n\n\n/* Parse a buffer:\n * Forward the string pointer till the end of a word, then\n * terminate it and forward till the begin of the next word.\n */\nstatic int\nskip_to_end_of_word_and_terminate(char **ppw, int eol)\n{\n\t/* Forward until a space is found - use isgraph here */\n\t/* See http://www.cplusplus.com/reference/cctype/ */\n\twhile (isgraph(**ppw)) {\n\t\t(*ppw)++;\n\t}\n\n\t/* Check end of word */\n\tif (eol) {\n\t\t/* must be a end of line */\n\t\tif ((**ppw != '\\r') && (**ppw != '\\n')) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* must be a end of a word, but not a line */\n\t\tif (**ppw != ' ') {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Terminate and forward to the next word */\n\tdo {\n\t\t**ppw = 0;\n\t\t(*ppw)++;\n\t} while ((**ppw) && isspace(**ppw));\n\n\t/* Check after term */\n\tif (!eol) {\n\t\t/* if it's not the end of line, there must be a next word */\n\t\tif (!isgraph(**ppw)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* ok */\n\treturn 1;\n}\n\n\n/* Parse HTTP headers from the given buffer, advance buf pointer\n * to the point where parsing stopped.\n * All parameters must be valid pointers (not NULL).\n * Return <0 on error. */\nstatic int\nparse_http_headers(char **buf, struct mg_header hdr[MG_MAX_HEADERS])\n{\n\tint i;\n\tint num_headers = 0;\n\n\tfor (i = 0; i < (int)MG_MAX_HEADERS; i++) {\n\t\tchar *dp = *buf;\n\t\twhile ((*dp != ':') && (*dp >= 33) && (*dp <= 126)) {\n\t\t\tdp++;\n\t\t}\n\t\tif (dp == *buf) {\n\t\t\t/* End of headers reached. */\n\t\t\tbreak;\n\t\t}\n\t\tif (*dp != ':') {\n\t\t\t/* This is not a valid field. */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* End of header key (*dp == ':') */\n\t\t/* Truncate here and set the key name */\n\t\t*dp = 0;\n\t\thdr[i].name = *buf;\n\t\tdo {\n\t\t\tdp++;\n\t\t} while (*dp == ' ');\n\n\t\t/* The rest of the line is the value */\n\t\thdr[i].value = dp;\n\t\t*buf = dp + strcspn(dp, \"\\r\\n\");\n\t\tif (((*buf)[0] != '\\r') || ((*buf)[1] != '\\n')) {\n\t\t\t*buf = NULL;\n\t\t}\n\n\t\tnum_headers = i + 1;\n\t\tif (*buf) {\n\t\t\t(*buf)[0] = 0;\n\t\t\t(*buf)[1] = 0;\n\t\t\t*buf += 2;\n\t\t} else {\n\t\t\t*buf = dp;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((*buf)[0] == '\\r') {\n\t\t\t/* This is the end of the header */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn num_headers;\n}\n\n\nstruct mg_http_method_info {\n\tconst char *name;\n\tint request_has_body;\n\tint response_has_body;\n\tint is_safe;\n\tint is_idempotent;\n\tint is_cacheable;\n};\n\n\n/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */\nstatic struct mg_http_method_info http_methods[] = {\n    /* HTTP (RFC 2616) */\n    {\"GET\", 0, 1, 1, 1, 1},\n    {\"POST\", 1, 1, 0, 0, 0},\n    {\"PUT\", 1, 0, 0, 1, 0},\n    {\"DELETE\", 0, 0, 0, 1, 0},\n    {\"HEAD\", 0, 0, 1, 1, 1},\n    {\"OPTIONS\", 0, 0, 1, 1, 0},\n    {\"CONNECT\", 1, 1, 0, 0, 0},\n    /* TRACE method (RFC 2616) is not supported for security reasons */\n\n    /* PATCH method (RFC 5789) */\n    {\"PATCH\", 1, 0, 0, 0, 0},\n    /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */\n\n    /* WEBDAV (RFC 2518) */\n    {\"PROPFIND\", 0, 1, 1, 1, 0},\n    /* http://www.webdav.org/specs/rfc4918.html, 9.1:\n     * Some PROPFIND results MAY be cached, with care,\n     * as there is no cache validation mechanism for\n     * most properties. This method is both safe and\n     * idempotent (see Section 9.1 of [RFC2616]). */\n    {\"MKCOL\", 0, 0, 0, 1, 0},\n    /* http://www.webdav.org/specs/rfc4918.html, 9.1:\n     * When MKCOL is invoked without a request body,\n     * the newly created collection SHOULD have no\n     * members. A MKCOL request message may contain\n     * a message body. The precise behavior of a MKCOL\n     * request when the body is present is undefined,\n     * ... ==> We do not support MKCOL with body data.\n     * This method is idempotent, but not safe (see\n     * Section 9.1 of [RFC2616]). Responses to this\n     * method MUST NOT be cached. */\n\n    /* Unsupported WEBDAV Methods: */\n    /* PROPPATCH, COPY, MOVE, LOCK, UNLOCK (RFC 2518) */\n    /* + 11 methods from RFC 3253 */\n    /* ORDERPATCH (RFC 3648) */\n    /* ACL (RFC 3744) */\n    /* SEARCH (RFC 5323) */\n    /* + MicroSoft extensions\n     * https://msdn.microsoft.com/en-us/library/aa142917.aspx */\n\n    /* REPORT method (RFC 3253) */\n    {\"REPORT\", 1, 1, 1, 1, 1},\n    /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */\n    /* It was defined for WEBDAV in RFC 3253, Sec. 3.6\n     * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems\n     * to be useful for REST in case a \"GET request with body\" is\n     * required. */\n\n    {NULL, 0, 0, 0, 0, 0}\n    /* end of list */\n};\n\n\nstatic const struct mg_http_method_info *\nget_http_method_info(const char *method)\n{\n\t/* Check if the method is known to the server. The list of all known\n\t * HTTP methods can be found here at\n\t * http://www.iana.org/assignments/http-methods/http-methods.xhtml\n\t */\n\tconst struct mg_http_method_info *m = http_methods;\n\n\twhile (m->name) {\n\t\tif (!strcmp(m->name, method)) {\n\t\t\treturn m;\n\t\t}\n\t\tm++;\n\t}\n\treturn NULL;\n}\n\n\nstatic int\nis_valid_http_method(const char *method)\n{\n\treturn (get_http_method_info(method) != NULL);\n}\n\n\n/* Parse HTTP request, fill in mg_request_info structure.\n * This function modifies the buffer by NUL-terminating\n * HTTP request components, header names and header values.\n * Parameters:\n *   buf (in/out): pointer to the HTTP header to parse and split\n *   len (in): length of HTTP header buffer\n *   re (out): parsed header as mg_request_info\n * buf and ri must be valid pointers (not NULL), len>0.\n * Returns <0 on error. */\nstatic int\nparse_http_request(char *buf, int len, struct mg_request_info *ri)\n{\n\tint request_length;\n\tint init_skip = 0;\n\n\t/* Reset attributes. DO NOT TOUCH is_ssl, remote_addr,\n\t * remote_port */\n\tri->remote_user = ri->request_method = ri->request_uri = ri->http_version =\n\t    NULL;\n\tri->num_headers = 0;\n\n\t/* RFC says that all initial whitespaces should be ingored */\n\t/* This included all leading \\r and \\n (isspace) */\n\t/* See table: http://www.cplusplus.com/reference/cctype/ */\n\twhile ((len > 0) && isspace(*(unsigned char *)buf)) {\n\t\tbuf++;\n\t\tlen--;\n\t\tinit_skip++;\n\t}\n\n\tif (len == 0) {\n\t\t/* Incomplete request */\n\t\treturn 0;\n\t}\n\n\t/* Control characters are not allowed, including zero */\n\tif (iscntrl(*(unsigned char *)buf)) {\n\t\treturn -1;\n\t}\n\n\t/* Find end of HTTP header */\n\trequest_length = get_http_header_len(buf, len);\n\tif (request_length <= 0) {\n\t\treturn request_length;\n\t}\n\tbuf[request_length - 1] = '\\0';\n\n\tif ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {\n\t\treturn -1;\n\t}\n\n\t/* The first word has to be the HTTP method */\n\tri->request_method = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Check for a valid http method */\n\tif (!is_valid_http_method(ri->request_method)) {\n\t\treturn -1;\n\t}\n\n\t/* The second word is the URI */\n\tri->request_uri = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Next would be the HTTP version */\n\tri->http_version = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 1) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Check for a valid HTTP version key */\n\tif (strncmp(ri->http_version, \"HTTP/\", 5) != 0) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tri->http_version += 5;\n\n\n\t/* Parse all HTTP headers */\n\tri->num_headers = parse_http_headers(&buf, ri->http_headers);\n\tif (ri->num_headers < 0) {\n\t\t/* Error while parsing headers */\n\t\treturn -1;\n\t}\n\n\treturn request_length + init_skip;\n}\n\n\nstatic int\nparse_http_response(char *buf, int len, struct mg_response_info *ri)\n{\n\tint response_length;\n\tint init_skip = 0;\n\tchar *tmp, *tmp2;\n\tlong l;\n\n\t/* Initialize elements. */\n\tri->http_version = ri->status_text = NULL;\n\tri->num_headers = ri->status_code = 0;\n\n\t/* RFC says that all initial whitespaces should be ingored */\n\t/* This included all leading \\r and \\n (isspace) */\n\t/* See table: http://www.cplusplus.com/reference/cctype/ */\n\twhile ((len > 0) && isspace(*(unsigned char *)buf)) {\n\t\tbuf++;\n\t\tlen--;\n\t\tinit_skip++;\n\t}\n\n\tif (len == 0) {\n\t\t/* Incomplete request */\n\t\treturn 0;\n\t}\n\n\t/* Control characters are not allowed, including zero */\n\tif (iscntrl(*(unsigned char *)buf)) {\n\t\treturn -1;\n\t}\n\n\t/* Find end of HTTP header */\n\tresponse_length = get_http_header_len(buf, len);\n\tif (response_length <= 0) {\n\t\treturn response_length;\n\t}\n\tbuf[response_length - 1] = '\\0';\n\n\tif ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {\n\t\treturn -1;\n\t}\n\n\t/* The first word is the HTTP version */\n\t/* Check for a valid HTTP version key */\n\tif (strncmp(buf, \"HTTP/\", 5) != 0) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tbuf += 5;\n\tif (!isgraph(buf[0])) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tri->http_version = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* The second word is the status as a number */\n\ttmp = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\tl = strtol(tmp, &tmp2, 10);\n\tif ((l < 100) || (l >= 1000) || ((tmp2 - tmp) != 3) || (*tmp2 != 0)) {\n\t\t/* Everything else but a 3 digit code is invalid */\n\t\treturn -1;\n\t}\n\tri->status_code = (int)l;\n\n\t/* The rest of the line is the status text */\n\tri->status_text = buf;\n\n\t/* Find end of status text */\n\t/* isgraph or isspace = isprint */\n\twhile (isprint(*buf)) {\n\t\tbuf++;\n\t}\n\tif ((*buf != '\\r') && (*buf != '\\n')) {\n\t\treturn -1;\n\t}\n\t/* Terminate string and forward buf to next line */\n\tdo {\n\t\t*buf = 0;\n\t\tbuf++;\n\t} while ((*buf) && isspace(*buf));\n\n\n\t/* Parse all HTTP headers */\n\tri->num_headers = parse_http_headers(&buf, ri->http_headers);\n\tif (ri->num_headers < 0) {\n\t\t/* Error while parsing headers */\n\t\treturn -1;\n\t}\n\n\treturn response_length + init_skip;\n}\n\n\n/* Keep reading the input (either opened file descriptor fd, or socket sock,\n * or SSL descriptor ssl) into buffer buf, until \\r\\n\\r\\n appears in the\n * buffer (which marks the end of HTTP request). Buffer buf may already\n * have some data. The length of the data is stored in nread.\n * Upon every read operation, increase nread by the number of bytes read. */\nstatic int\nread_message(FILE *fp,\n             struct mg_connection *conn,\n             char *buf,\n             int bufsiz,\n             int *nread)\n{\n\tint request_len, n = 0;\n\tstruct timespec last_action_time;\n\tdouble request_timeout;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tmemset(&last_action_time, 0, sizeof(last_action_time));\n\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\t/* value of request_timeout is in seconds, config in milliseconds */\n\t\trequest_timeout = atof(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t} else {\n\t\trequest_timeout = -1.0;\n\t}\n\tif (conn->handled_requests > 0) {\n\t\tif (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {\n\t\t\trequest_timeout =\n\t\t\t    atof(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) / 1000.0;\n\t\t}\n\t}\n\n\trequest_len = get_http_header_len(buf, *nread);\n\n\t/* first time reading from this connection */\n\tclock_gettime(CLOCK_MONOTONIC, &last_action_time);\n\n\twhile (request_len == 0) {\n\t\t/* Full request not yet received */\n\t\tif (conn->phys_ctx->stop_flag != 0) {\n\t\t\t/* Server is to be stopped. */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (*nread >= bufsiz) {\n\t\t\t/* Request too long */\n\t\t\treturn -2;\n\t\t}\n\n\t\tn = pull_inner(\n\t\t    fp, conn, buf + *nread, bufsiz - *nread, request_timeout);\n\t\tif (n == -2) {\n\t\t\t/* Receive error */\n\t\t\treturn -1;\n\t\t}\n\t\tif (n > 0) {\n\t\t\t*nread += n;\n\t\t\trequest_len = get_http_header_len(buf, *nread);\n\t\t} else {\n\t\t\trequest_len = 0;\n\t\t}\n\n\t\tif ((request_len == 0) && (request_timeout >= 0)) {\n\t\t\tif (mg_difftimespec(&last_action_time, &(conn->req_time))\n\t\t\t    > request_timeout) {\n\t\t\t\t/* Timeout */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &last_action_time);\n\t\t}\n\t}\n\n\treturn request_len;\n}\n\n\n#if !defined(NO_CGI) || !defined(NO_FILES)\nstatic int\nforward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl)\n{\n\tconst char *expect, *body;\n\tchar buf[MG_BUF_LEN];\n\tint to_read, nread, success = 0;\n\tint64_t buffered_len;\n\tdouble timeout = -1.0;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\texpect = mg_get_header(conn, \"Expect\");\n\tDEBUG_ASSERT(fp != NULL);\n\tif (!fp) {\n\t\tmg_send_http_error(conn, 500, \"%s\", \"Error: NULL File\");\n\t\treturn 0;\n\t}\n\n\tif ((conn->content_len == -1) && (!conn->is_chunked)) {\n\t\t/* Content length is not specified by the client. */\n\t\tmg_send_http_error(conn,\n\t\t                   411,\n\t\t                   \"%s\",\n\t\t                   \"Error: Client did not specify content length\");\n\t} else if ((expect != NULL)\n\t           && (mg_strcasecmp(expect, \"100-continue\") != 0)) {\n\t\t/* Client sent an \"Expect: xyz\" header and xyz is not 100-continue.\n\t\t */\n\t\tmg_send_http_error(conn,\n\t\t                   417,\n\t\t                   \"Error: Can not fulfill expectation %s\",\n\t\t                   expect);\n\t} else {\n\t\tif (expect != NULL) {\n\t\t\t(void)mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");\n\t\t\tconn->status_code = 100;\n\t\t} else {\n\t\t\tconn->status_code = 200;\n\t\t}\n\n\t\tbuffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len\n\t\t               - conn->consumed_content;\n\n\t\tDEBUG_ASSERT(buffered_len >= 0);\n\t\tDEBUG_ASSERT(conn->consumed_content == 0);\n\n\t\tif ((buffered_len < 0) || (conn->consumed_content != 0)) {\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"Error: Size mismatch\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (buffered_len > 0) {\n\t\t\tif ((int64_t)buffered_len > conn->content_len) {\n\t\t\t\tbuffered_len = (int)conn->content_len;\n\t\t\t}\n\t\t\tbody = conn->buf + conn->request_len + conn->consumed_content;\n\t\t\tpush_all(\n\t\t\t    conn->phys_ctx, fp, sock, ssl, body, (int64_t)buffered_len);\n\t\t\tconn->consumed_content += buffered_len;\n\t\t}\n\n\t\tnread = 0;\n\t\twhile (conn->consumed_content < conn->content_len) {\n\t\t\tto_read = sizeof(buf);\n\t\t\tif ((int64_t)to_read > conn->content_len - conn->consumed_content) {\n\t\t\t\tto_read = (int)(conn->content_len - conn->consumed_content);\n\t\t\t}\n\t\t\tnread = pull_inner(NULL, conn, buf, to_read, timeout);\n\t\t\tif (nread == -2) {\n\t\t\t\t/* error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nread > 0) {\n\t\t\t\tif (push_all(conn->phys_ctx, fp, sock, ssl, buf, nread)\n\t\t\t\t    != nread) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconn->consumed_content += nread;\n\t\t}\n\n\t\tif (conn->consumed_content == conn->content_len) {\n\t\t\tsuccess = (nread >= 0);\n\t\t}\n\n\t\t/* Each error code path in this function must send an error */\n\t\tif (!success) {\n\t\t\t/* NOTE: Maybe some data has already been sent. */\n\t\t\t/* TODO (low): If some data has been sent, a correct error\n\t\t\t * reply can no longer be sent, so just close the connection */\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"\");\n\t\t}\n\t}\n\n\treturn success;\n}\n#endif\n\n\n#if defined(USE_TIMERS)\n\n#define TIMER_API static\n#include \"timer.inl\"\n\n#endif /* USE_TIMERS */\n\n\n#if !defined(NO_CGI)\n/* This structure helps to create an environment for the spawned CGI\n * program.\n * Environment is an array of \"VARIABLE=VALUE\\0\" ASCIIZ strings,\n * last element must be NULL.\n * However, on Windows there is a requirement that all these\n * VARIABLE=VALUE\\0\n * strings must reside in a contiguous buffer. The end of the buffer is\n * marked by two '\\0' characters.\n * We satisfy both worlds: we create an envp array (which is vars), all\n * entries are actually pointers inside buf. */\nstruct cgi_environment {\n\tstruct mg_connection *conn;\n\t/* Data block */\n\tchar *buf;      /* Environment buffer */\n\tsize_t buflen;  /* Space available in buf */\n\tsize_t bufused; /* Space taken in buf */\n\t                /* Index block */\n\tchar **var;     /* char **envp */\n\tsize_t varlen;  /* Number of variables available in var */\n\tsize_t varused; /* Number of variables stored in var */\n};\n\n\nstatic void addenv(struct cgi_environment *env,\n                   PRINTF_FORMAT_STRING(const char *fmt),\n                   ...) PRINTF_ARGS(2, 3);\n\n/* Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n * pointer into the vars array. Assumes env != NULL and fmt != NULL. */\nstatic void\naddenv(struct cgi_environment *env, const char *fmt, ...)\n{\n\tsize_t n, space;\n\tint truncated = 0;\n\tchar *added;\n\tva_list ap;\n\n\t/* Calculate how much space is left in the buffer */\n\tspace = (env->buflen - env->bufused);\n\n\t/* Calculate an estimate for the required space */\n\tn = strlen(fmt) + 2 + 128;\n\n\tdo {\n\t\tif (space <= n) {\n\t\t\t/* Allocate new buffer */\n\t\t\tn = env->buflen + CGI_ENVIRONMENT_SIZE;\n\t\t\tadded = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);\n\t\t\tif (!added) {\n\t\t\t\t/* Out of memory */\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    env->conn,\n\t\t\t\t    \"%s: Cannot allocate memory for CGI variable [%s]\",\n\t\t\t\t    __func__,\n\t\t\t\t    fmt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tenv->buf = added;\n\t\t\tenv->buflen = n;\n\t\t\tspace = (env->buflen - env->bufused);\n\t\t}\n\n\t\t/* Make a pointer to the free space int the buffer */\n\t\tadded = env->buf + env->bufused;\n\n\t\t/* Copy VARIABLE=VALUE\\0 string into the free space */\n\t\tva_start(ap, fmt);\n\t\tmg_vsnprintf(env->conn, &truncated, added, (size_t)space, fmt, ap);\n\t\tva_end(ap);\n\n\t\t/* Do not add truncated strings to the environment */\n\t\tif (truncated) {\n\t\t\t/* Reallocate the buffer */\n\t\t\tspace = 0;\n\t\t\tn = 1;\n\t\t}\n\t} while (truncated);\n\n\t/* Calculate number of bytes added to the environment */\n\tn = strlen(added) + 1;\n\tenv->bufused += n;\n\n\t/* Now update the variable index */\n\tspace = (env->varlen - env->varused);\n\tif (space < 2) {\n\t\tmg_cry_internal(env->conn,\n\t\t                \"%s: Cannot register CGI variable [%s]\",\n\t\t                __func__,\n\t\t                fmt);\n\t\treturn;\n\t}\n\n\t/* Append a pointer to the added string into the envp array */\n\tenv->var[env->varused] = added;\n\tenv->varused++;\n}\n\n/* Return 0 on success, non-zero if an error occurs. */\n\nstatic int\nprepare_cgi_environment(struct mg_connection *conn,\n                        const char *prog,\n                        struct cgi_environment *env)\n{\n\tconst char *s;\n\tstruct vec var_vec;\n\tchar *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];\n\tint i, truncated, uri_len;\n\n\tif ((conn == NULL) || (prog == NULL) || (env == NULL)) {\n\t\treturn -1;\n\t}\n\n\tenv->conn = conn;\n\tenv->buflen = CGI_ENVIRONMENT_SIZE;\n\tenv->bufused = 0;\n\tenv->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);\n\tif (env->buf == NULL) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Not enough memory for environmental buffer\",\n\t\t                __func__);\n\t\treturn -1;\n\t}\n\tenv->varlen = MAX_CGI_ENVIR_VARS;\n\tenv->varused = 0;\n\tenv->var =\n\t    (char **)mg_malloc_ctx(env->buflen * sizeof(char *), conn->phys_ctx);\n\tif (env->var == NULL) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Not enough memory for environmental variables\",\n\t\t                __func__);\n\t\tmg_free(env->buf);\n\t\treturn -1;\n\t}\n\n\taddenv(env, \"SERVER_NAME=%s\", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);\n\taddenv(env, \"SERVER_ROOT=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\taddenv(env, \"DOCUMENT_ROOT=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\taddenv(env, \"SERVER_SOFTWARE=CivetWeb/%s\", mg_version());\n\n\t/* Prepare the environment block */\n\taddenv(env, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n\taddenv(env, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n\taddenv(env, \"%s\", \"REDIRECT_STATUS=200\"); /* For PHP */\n\n#if defined(USE_IPV6)\n\tif (conn->client.lsa.sa.sa_family == AF_INET6) {\n\t\taddenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin6.sin6_port));\n\t} else\n#endif\n\t{\n\t\taddenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));\n\t}\n\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\taddenv(env, \"REMOTE_ADDR=%s\", src_addr);\n\n\taddenv(env, \"REQUEST_METHOD=%s\", conn->request_info.request_method);\n\taddenv(env, \"REMOTE_PORT=%d\", conn->request_info.remote_port);\n\n\taddenv(env, \"REQUEST_URI=%s\", conn->request_info.request_uri);\n\taddenv(env, \"LOCAL_URI=%s\", conn->request_info.local_uri);\n\n\t/* SCRIPT_NAME */\n\turi_len = (int)strlen(conn->request_info.local_uri);\n\tif (conn->path_info == NULL) {\n\t\tif (conn->request_info.local_uri[uri_len - 1] != '/') {\n\t\t\t/* URI: /path_to_script/script.cgi */\n\t\t\taddenv(env, \"SCRIPT_NAME=%s\", conn->request_info.local_uri);\n\t\t} else {\n\t\t\t/* URI: /path_to_script/ ... using index.cgi */\n\t\t\tconst char *index_file = strrchr(prog, '/');\n\t\t\tif (index_file) {\n\t\t\t\taddenv(env,\n\t\t\t\t       \"SCRIPT_NAME=%s%s\",\n\t\t\t\t       conn->request_info.local_uri,\n\t\t\t\t       index_file + 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* URI: /path_to_script/script.cgi/path_info */\n\t\taddenv(env,\n\t\t       \"SCRIPT_NAME=%.*s\",\n\t\t       uri_len - (int)strlen(conn->path_info),\n\t\t       conn->request_info.local_uri);\n\t}\n\n\taddenv(env, \"SCRIPT_FILENAME=%s\", prog);\n\tif (conn->path_info == NULL) {\n\t\taddenv(env, \"PATH_TRANSLATED=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\t} else {\n\t\taddenv(env,\n\t\t       \"PATH_TRANSLATED=%s%s\",\n\t\t       conn->dom_ctx->config[DOCUMENT_ROOT],\n\t\t       conn->path_info);\n\t}\n\n\taddenv(env, \"HTTPS=%s\", (conn->ssl == NULL) ? \"off\" : \"on\");\n\n\tif ((s = mg_get_header(conn, \"Content-Type\")) != NULL) {\n\t\taddenv(env, \"CONTENT_TYPE=%s\", s);\n\t}\n\tif (conn->request_info.query_string != NULL) {\n\t\taddenv(env, \"QUERY_STRING=%s\", conn->request_info.query_string);\n\t}\n\tif ((s = mg_get_header(conn, \"Content-Length\")) != NULL) {\n\t\taddenv(env, \"CONTENT_LENGTH=%s\", s);\n\t}\n\tif ((s = getenv(\"PATH\")) != NULL) {\n\t\taddenv(env, \"PATH=%s\", s);\n\t}\n\tif (conn->path_info != NULL) {\n\t\taddenv(env, \"PATH_INFO=%s\", conn->path_info);\n\t}\n\n\tif (conn->status_code > 0) {\n\t\t/* CGI error handler should show the status code */\n\t\taddenv(env, \"STATUS=%d\", conn->status_code);\n\t}\n\n#if defined(_WIN32)\n\tif ((s = getenv(\"COMSPEC\")) != NULL) {\n\t\taddenv(env, \"COMSPEC=%s\", s);\n\t}\n\tif ((s = getenv(\"SYSTEMROOT\")) != NULL) {\n\t\taddenv(env, \"SYSTEMROOT=%s\", s);\n\t}\n\tif ((s = getenv(\"SystemDrive\")) != NULL) {\n\t\taddenv(env, \"SystemDrive=%s\", s);\n\t}\n\tif ((s = getenv(\"ProgramFiles\")) != NULL) {\n\t\taddenv(env, \"ProgramFiles=%s\", s);\n\t}\n\tif ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {\n\t\taddenv(env, \"ProgramFiles(x86)=%s\", s);\n\t}\n#else\n\tif ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL) {\n\t\taddenv(env, \"LD_LIBRARY_PATH=%s\", s);\n\t}\n#endif /* _WIN32 */\n\n\tif ((s = getenv(\"PERLLIB\")) != NULL) {\n\t\taddenv(env, \"PERLLIB=%s\", s);\n\t}\n\n\tif (conn->request_info.remote_user != NULL) {\n\t\taddenv(env, \"REMOTE_USER=%s\", conn->request_info.remote_user);\n\t\taddenv(env, \"%s\", \"AUTH_TYPE=Digest\");\n\t}\n\n\t/* Add all headers as HTTP_* variables */\n\tfor (i = 0; i < conn->request_info.num_headers; i++) {\n\n\t\t(void)mg_snprintf(conn,\n\t\t                  &truncated,\n\t\t                  http_var_name,\n\t\t                  sizeof(http_var_name),\n\t\t                  \"HTTP_%s\",\n\t\t                  conn->request_info.http_headers[i].name);\n\n\t\tif (truncated) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: HTTP header variable too long [%s]\",\n\t\t\t                __func__,\n\t\t\t                conn->request_info.http_headers[i].name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Convert variable name into uppercase, and change - to _ */\n\t\tfor (p = http_var_name; *p != '\\0'; p++) {\n\t\t\tif (*p == '-') {\n\t\t\t\t*p = '_';\n\t\t\t}\n\t\t\t*p = (char)toupper(*(unsigned char *)p);\n\t\t}\n\n\t\taddenv(env,\n\t\t       \"%s=%s\",\n\t\t       http_var_name,\n\t\t       conn->request_info.http_headers[i].value);\n\t}\n\n\t/* Add user-specified variables */\n\ts = conn->dom_ctx->config[CGI_ENVIRONMENT];\n\twhile ((s = next_option(s, &var_vec, NULL)) != NULL) {\n\t\taddenv(env, \"%.*s\", (int)var_vec.len, var_vec.ptr);\n\t}\n\n\tenv->var[env->varused] = NULL;\n\tenv->buf[env->bufused] = '\\0';\n\n\treturn 0;\n}\n\n\nstatic int\nabort_process(void *data)\n{\n\t/* Waitpid checks for child status and won't work for a pid that does not\n\t * identify a child of the current process. Thus, if the pid is reused,\n\t * we will not affect a different process. */\n\tpid_t pid = (pid_t)data;\n\tint status = 0;\n\tpid_t rpid = waitpid(pid, &status, WNOHANG);\n\tif ((rpid != (pid_t)-1) && (status == 0)) {\n\t\t/* Stop child process */\n\t\tDEBUG_TRACE(\"CGI timer: Stop child process %p\\n\", pid);\n\t\tkill(pid, SIGABRT);\n\n\t\t/* Wait until process is terminated (don't leave zombies) */\n\t\twhile (waitpid(pid, &status, 0) != (pid_t)-1) /* nop */\n\t\t\t;\n\t} else {\n\t\tDEBUG_TRACE(\"CGI timer: Child process %p already stopped in time\\n\",\n\t\t            pid);\n\t}\n\treturn 0;\n}\n\n\nstatic void\nhandle_cgi_request(struct mg_connection *conn, const char *prog)\n{\n\tchar *buf;\n\tsize_t buflen;\n\tint headers_len, data_len, i, truncated;\n\tint fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};\n\tconst char *status, *status_text, *connection_state;\n\tchar *pbuf, dir[PATH_MAX], *p;\n\tstruct mg_request_info ri;\n\tstruct cgi_environment blk;\n\tFILE *in = NULL, *out = NULL, *err = NULL;\n\tstruct mg_file fout = STRUCT_FILE_INITIALIZER;\n\tpid_t pid = (pid_t)-1;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tbuf = NULL;\n\tbuflen = conn->phys_ctx->max_request_size;\n\ti = prepare_cgi_environment(conn, prog, &blk);\n\tif (i != 0) {\n\t\tblk.buf = NULL;\n\t\tblk.var = NULL;\n\t\tgoto done;\n\t}\n\n\t/* CGI must be executed in its own directory. 'dir' must point to the\n\t * directory containing executable program, 'p' must point to the\n\t * executable program name relative to 'dir'. */\n\t(void)mg_snprintf(conn, &truncated, dir, sizeof(dir), \"%s\", prog);\n\n\tif (truncated) {\n\t\tmg_cry_internal(conn, \"Error: CGI program \\\"%s\\\": Path too long\", prog);\n\t\tmg_send_http_error(conn, 500, \"Error: %s\", \"CGI path too long\");\n\t\tgoto done;\n\t}\n\n\tif ((p = strrchr(dir, '/')) != NULL) {\n\t\t*p++ = '\\0';\n\t} else {\n\t\tdir[0] = '.';\n\t\tdir[1] = '\\0';\n\t\tp = (char *)prog;\n\t}\n\n\tif ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",\n\t\t    prog,\n\t\t    status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot create CGI pipe: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tDEBUG_TRACE(\"CGI: spawn %s %s\\n\", dir, p);\n\tpid = spawn_process(conn, p, blk.buf, blk.var, fdin, fdout, fderr, dir);\n\n\tif (pid == (pid_t)-1) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Can not spawn CGI process: %s\",\n\t\t    prog,\n\t\t    status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot spawn CGI process [%s]: %s\",\n\t\t                   prog,\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n#if defined(USE_TIMERS)\n\t// TODO (#618): set a timeout\n\ttimer_add(conn->phys_ctx,\n\t          /* one minute */ 60.0,\n\t          0.0,\n\t          1,\n\t          abort_process,\n\t          (void *)pid);\n#endif\n\n\t/* Make sure child closes all pipe descriptors. It must dup them to 0,1\n\t */\n\tset_close_on_exec((SOCKET)fdin[0], conn);  /* stdin read */\n\tset_close_on_exec((SOCKET)fdin[1], conn);  /* stdin write */\n\tset_close_on_exec((SOCKET)fdout[0], conn); /* stdout read */\n\tset_close_on_exec((SOCKET)fdout[1], conn); /* stdout write */\n\tset_close_on_exec((SOCKET)fderr[0], conn); /* stderr read */\n\tset_close_on_exec((SOCKET)fderr[1], conn); /* stderr write */\n\n\t/* Parent closes only one side of the pipes.\n\t * If we don't mark them as closed, close() attempt before\n\t * return from this function throws an exception on Windows.\n\t * Windows does not like when closed descriptor is closed again. */\n\t(void)close(fdin[0]);\n\t(void)close(fdout[1]);\n\t(void)close(fderr[1]);\n\tfdin[0] = fdout[1] = fderr[1] = -1;\n\n\tif ((in = fdopen(fdin[1], \"wb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stdin: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fdin\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tif ((out = fdopen(fdout[0], \"rb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stdout: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fdout\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tif ((err = fdopen(fderr[0], \"rb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stderr: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fderr\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tsetbuf(in, NULL);\n\tsetbuf(out, NULL);\n\tsetbuf(err, NULL);\n\tfout.access.fp = out;\n\n\tif ((conn->request_info.content_length != 0) || (conn->is_chunked)) {\n\t\tDEBUG_TRACE(\"CGI: send body data (%lli)\\n\",\n\t\t            (signed long long)conn->request_info.content_length);\n\n\t\t/* This is a POST/PUT request, or another request with body data. */\n\t\tif (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {\n\t\t\t/* Error sending the body data */\n\t\t\tmg_cry_internal(\n\t\t\t    conn,\n\t\t\t    \"Error: CGI program \\\"%s\\\": Forward body data failed\",\n\t\t\t    prog);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Close so child gets an EOF. */\n\tfclose(in);\n\tin = NULL;\n\tfdin[1] = -1;\n\n\t/* Now read CGI reply into a buffer. We need to set correct\n\t * status code, thus we need to see all HTTP headers first.\n\t * Do not send anything back to client, until we buffer in all\n\t * HTTP headers. */\n\tdata_len = 0;\n\tbuf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);\n\tif (buf == NULL) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Not enough memory for CGI buffer (%u bytes)\",\n\t\t                   (unsigned int)buflen);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Not enough memory for buffer (%u \"\n\t\t    \"bytes)\",\n\t\t    prog,\n\t\t    (unsigned int)buflen);\n\t\tgoto done;\n\t}\n\n\tDEBUG_TRACE(\"CGI: %s\", \"wait for response\");\n\theaders_len = read_message(out, conn, buf, (int)buflen, &data_len);\n\tDEBUG_TRACE(\"CGI: response: %li\", (signed long)headers_len);\n\n\tif (headers_len <= 0) {\n\n\t\t/* Could not parse the CGI response. Check if some error message on\n\t\t * stderr. */\n\t\ti = pull_all(err, conn, buf, (int)buflen);\n\t\tif (i > 0) {\n\t\t\t/* CGI program explicitly sent an error */\n\t\t\t/* Write the error message to the internal log */\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error: CGI program \\\"%s\\\" sent error \"\n\t\t\t                \"message: [%.*s]\",\n\t\t\t                prog,\n\t\t\t                i,\n\t\t\t                buf);\n\t\t\t/* Don't send the error message back to the client */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: CGI program \\\"%s\\\" failed.\",\n\t\t\t                   prog);\n\t\t} else {\n\t\t\t/* CGI program did not explicitly send an error, but a broken\n\t\t\t * respon header */\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error: CGI program sent malformed or too big \"\n\t\t\t                \"(>%u bytes) HTTP headers: [%.*s]\",\n\t\t\t                (unsigned)buflen,\n\t\t\t                data_len,\n\t\t\t                buf);\n\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: CGI program sent malformed or too big \"\n\t\t\t                   \"(>%u bytes) HTTP headers: [%.*s]\",\n\t\t\t                   (unsigned)buflen,\n\t\t\t                   data_len,\n\t\t\t                   buf);\n\t\t}\n\n\t\t/* in both cases, abort processing CGI */\n\t\tgoto done;\n\t}\n\n\tpbuf = buf;\n\tbuf[headers_len - 1] = '\\0';\n\tri.num_headers = parse_http_headers(&pbuf, ri.http_headers);\n\n\t/* Make up and send the status line */\n\tstatus_text = \"OK\";\n\tif ((status = get_header(ri.http_headers, ri.num_headers, \"Status\"))\n\t    != NULL) {\n\t\tconn->status_code = atoi(status);\n\t\tstatus_text = status;\n\t\twhile (isdigit(*(const unsigned char *)status_text)\n\t\t       || *status_text == ' ') {\n\t\t\tstatus_text++;\n\t\t}\n\t} else if (get_header(ri.http_headers, ri.num_headers, \"Location\")\n\t           != NULL) {\n\t\tconn->status_code = 307;\n\t} else {\n\t\tconn->status_code = 200;\n\t}\n\tconnection_state =\n\t    get_header(ri.http_headers, ri.num_headers, \"Connection\");\n\tif (!header_has_option(connection_state, \"keep-alive\")) {\n\t\tconn->must_close = 1;\n\t}\n\n\tDEBUG_TRACE(\"CGI: response %u %s\", conn->status_code, status_text);\n\n\t(void)mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", conn->status_code, status_text);\n\n\t/* Send headers */\n\tfor (i = 0; i < ri.num_headers; i++) {\n\t\tmg_printf(conn,\n\t\t          \"%s: %s\\r\\n\",\n\t\t          ri.http_headers[i].name,\n\t\t          ri.http_headers[i].value);\n\t}\n\tmg_write(conn, \"\\r\\n\", 2);\n\n\t/* Send chunk of data that may have been read after the headers */\n\tmg_write(conn, buf + headers_len, (size_t)(data_len - headers_len));\n\n\t/* Read the rest of CGI output and send to the client */\n\tDEBUG_TRACE(\"CGI: %s\", \"forward all data\");\n\tsend_file_data(conn, &fout, 0, INT64_MAX);\n\tDEBUG_TRACE(\"CGI: %s\", \"all data sent\");\n\ndone:\n\tmg_free(blk.var);\n\tmg_free(blk.buf);\n\n\tif (pid != (pid_t)-1) {\n\t\tabort_process((void *)pid);\n\t}\n\n\tif (fdin[0] != -1) {\n\t\tclose(fdin[0]);\n\t}\n\tif (fdout[1] != -1) {\n\t\tclose(fdout[1]);\n\t}\n\n\tif (in != NULL) {\n\t\tfclose(in);\n\t} else if (fdin[1] != -1) {\n\t\tclose(fdin[1]);\n\t}\n\n\tif (out != NULL) {\n\t\tfclose(out);\n\t} else if (fdout[0] != -1) {\n\t\tclose(fdout[0]);\n\t}\n\n\tif (err != NULL) {\n\t\tfclose(err);\n\t} else if (fderr[0] != -1) {\n\t\tclose(fderr[0]);\n\t}\n\n\tif (buf != NULL) {\n\t\tmg_free(buf);\n\t}\n}\n#endif /* !NO_CGI */\n\n\n#if !defined(NO_FILES)\nstatic void\nmkcol(struct mg_connection *conn, const char *path)\n{\n\tint rc, body_len;\n\tstruct de de;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\t/* TODO (mid): Check the mg_send_http_error situations in this function\n\t */\n\n\tmemset(&de.file, 0, sizeof(de.file));\n\tif (!mg_stat(conn, path, &de.file)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t                __func__,\n\t\t                path,\n\t\t                strerror(ERRNO));\n\t}\n\n\tif (de.file.last_modified) {\n\t\t/* TODO (mid): This check does not seem to make any sense ! */\n\t\t/* TODO (mid): Add a webdav unit test first, before changing\n\t\t * anything here. */\n\t\tmg_send_http_error(\n\t\t    conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tbody_len = conn->data_len - conn->request_len;\n\tif (body_len > 0) {\n\t\tmg_send_http_error(\n\t\t    conn, 415, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\treturn;\n\t}\n\n\trc = mg_mkdir(conn, path, 0755);\n\n\tif (rc == 0) {\n\t\tconn->status_code = 201;\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 %d Created\\r\\n\"\n\t\t          \"Date: %s\\r\\n\",\n\t\t          conn->status_code,\n\t\t          date);\n\t\tsend_static_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          suggest_connection_header(conn));\n\t} else {\n\t\tif (errno == EEXIST) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else if (errno == EACCES) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 403, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else if (errno == ENOENT) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 409, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 500, \"fopen(%s): %s\", path, strerror(ERRNO));\n\t\t}\n\t}\n}\n\n\nstatic void\nput_file(struct mg_connection *conn, const char *path)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tconst char *range;\n\tint64_t r1, r2;\n\tint rc;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tif (mg_stat(conn, path, &file.stat)) {\n\t\t/* File already exists */\n\t\tconn->status_code = 200;\n\n\t\tif (file.stat.is_directory) {\n\t\t\t/* This is an already existing directory,\n\t\t\t * so there is nothing to do for the server. */\n\t\t\trc = 0;\n\n\t\t} else {\n/* File exists and is not a directory. */\n/* Can it be replaced? */\n\n#if defined(MG_USE_OPEN_FILE)\n\t\t\tif (file.access.membuf != NULL) {\n\t\t\t\t/* This is an \"in-memory\" file, that can not be replaced */\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   405,\n\t\t\t\t                   \"Error: Put not possible\\nReplacing %s \"\n\t\t\t\t                   \"is not supported\",\n\t\t\t\t                   path);\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\n\t\t\t/* Check if the server may write this file */\n\t\t\tif (access(path, W_OK) == 0) {\n\t\t\t\t/* Access granted */\n\t\t\t\tconn->status_code = 200;\n\t\t\t\trc = 1;\n\t\t\t} else {\n\t\t\t\tmg_send_http_error(\n\t\t\t\t    conn,\n\t\t\t\t    403,\n\t\t\t\t    \"Error: Put not possible\\nReplacing %s is not allowed\",\n\t\t\t\t    path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* File should be created */\n\t\tconn->status_code = 201;\n\t\trc = put_dir(conn, path);\n\t}\n\n\tif (rc == 0) {\n\t\t/* put_dir returns 0 if path is a directory */\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 %d %s\\r\\n\",\n\t\t          conn->status_code,\n\t\t          mg_get_response_code_text(NULL, conn->status_code));\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\n\t\t/* Request to create a directory has been fulfilled successfully.\n\t\t * No need to put a file. */\n\t\treturn;\n\t}\n\n\tif (rc == -1) {\n\t\t/* put_dir returns -1 if the path is too long */\n\t\tmg_send_http_error(conn,\n\t\t                   414,\n\t\t                   \"Error: Path too long\\nput_dir(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tif (rc == -2) {\n\t\t/* put_dir returns -2 if the directory can not be created */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Can not create directory\\nput_dir(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\t/* A file should be created or overwritten. */\n\t/* Currently CivetWeb does not nead read+write access. */\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file)\n\t    || file.access.fp == NULL) {\n\t\t(void)mg_fclose(&file.access);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Can not create file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tfclose_on_exec(&file.access, conn);\n\trange = mg_get_header(conn, \"Content-Range\");\n\tr1 = r2 = 0;\n\tif ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {\n\t\tconn->status_code = 206; /* Partial content */\n\t\tfseeko(file.access.fp, r1, SEEK_SET);\n\t}\n\n\tif (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {\n\t\t/* forward_body_data failed.\n\t\t * The error code has already been sent to the client,\n\t\t * and conn->status_code is already set. */\n\t\t(void)mg_fclose(&file.access);\n\t\treturn;\n\t}\n\n\tif (mg_fclose(&file.access) != 0) {\n\t\t/* fclose failed. This might have different reasons, but a likely\n\t\t * one is \"no space on disk\", http 507. */\n\t\tconn->status_code = 507;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tmg_printf(conn,\n\t          \"HTTP/1.1 %d %s\\r\\n\",\n\t          conn->status_code,\n\t          mg_get_response_code_text(NULL, conn->status_code));\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Content-Length: 0\\r\\n\"\n\t          \"Connection: %s\\r\\n\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn));\n}\n\n\nstatic void\ndelete_file(struct mg_connection *conn, const char *path)\n{\n\tstruct de de;\n\tmemset(&de.file, 0, sizeof(de.file));\n\tif (!mg_stat(conn, path, &de.file)) {\n\t\t/* mg_stat returns 0 if the file does not exist */\n\t\tmg_send_http_error(conn,\n\t\t                   404,\n\t\t                   \"Error: Cannot delete file\\nFile %s not found\",\n\t\t                   path);\n\t\treturn;\n\t}\n\n#if 0 /* Ignore if a file in memory is inside a folder */\n        if (de.access.membuf != NULL) {\n                /* the file is cached in memory */\n                mg_send_http_error(\n                    conn,\n                    405,\n                    \"Error: Delete not possible\\nDeleting %s is not supported\",\n                    path);\n                return;\n        }\n#endif\n\n\tif (de.file.is_directory) {\n\t\tif (remove_directory(conn, path)) {\n\t\t\t/* Delete is successful: Return 204 without content. */\n\t\t\tmg_send_http_error(conn, 204, \"%s\", \"\");\n\t\t} else {\n\t\t\t/* Delete is not successful: Return 500 (Server error). */\n\t\t\tmg_send_http_error(conn, 500, \"Error: Could not delete %s\", path);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* This is an existing file (not a directory).\n\t * Check if write permission is granted. */\n\tif (access(path, W_OK) != 0) {\n\t\t/* File is read only */\n\t\tmg_send_http_error(\n\t\t    conn,\n\t\t    403,\n\t\t    \"Error: Delete not possible\\nDeleting %s is not allowed\",\n\t\t    path);\n\t\treturn;\n\t}\n\n\t/* Try to delete it. */\n\tif (mg_remove(conn, path) == 0) {\n\t\t/* Delete was successful: Return 204 without content. */\n\t\tmg_send_http_error(conn, 204, \"%s\", \"\");\n\t} else {\n\t\t/* Delete not successful (file locked). */\n\t\tmg_send_http_error(conn,\n\t\t                   423,\n\t\t                   \"Error: Cannot delete file\\nremove(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t}\n}\n#endif /* !NO_FILES */\n\n\nstatic void\nsend_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);\n\n\nstatic void\ndo_ssi_include(struct mg_connection *conn,\n               const char *ssi,\n               char *tag,\n               int include_level)\n{\n\tchar file_name[MG_BUF_LEN], path[512], *p;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tsize_t len;\n\tint truncated = 0;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\t/* sscanf() is safe here, since send_ssi_file() also uses buffer\n\t * of size MG_BUF_LEN to get the tag. So strlen(tag) is\n\t * always < MG_BUF_LEN. */\n\tif (sscanf(tag, \" virtual=\\\"%511[^\\\"]\\\"\", file_name) == 1) {\n\t\t/* File name is relative to the webserver root */\n\t\tfile_name[511] = 0;\n\t\t(void)mg_snprintf(conn,\n\t\t                  &truncated,\n\t\t                  path,\n\t\t                  sizeof(path),\n\t\t                  \"%s/%s\",\n\t\t                  conn->dom_ctx->config[DOCUMENT_ROOT],\n\t\t                  file_name);\n\n\t} else if (sscanf(tag, \" abspath=\\\"%511[^\\\"]\\\"\", file_name) == 1) {\n\t\t/* File name is relative to the webserver working directory\n\t\t * or it is absolute system path */\n\t\tfile_name[511] = 0;\n\t\t(void)\n\t\t    mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", file_name);\n\n\t} else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)\n\t           || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {\n\t\t/* File name is relative to the currect document */\n\t\tfile_name[511] = 0;\n\t\t(void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);\n\n\t\tif (!truncated) {\n\t\t\tif ((p = strrchr(path, '/')) != NULL) {\n\t\t\t\tp[1] = '\\0';\n\t\t\t}\n\t\t\tlen = strlen(path);\n\t\t\t(void)mg_snprintf(conn,\n\t\t\t                  &truncated,\n\t\t\t                  path + len,\n\t\t\t                  sizeof(path) - len,\n\t\t\t                  \"%s\",\n\t\t\t                  file_name);\n\t\t}\n\n\t} else {\n\t\tmg_cry_internal(conn, \"Bad SSI #include: [%s]\", tag);\n\t\treturn;\n\t}\n\n\tif (truncated) {\n\t\tmg_cry_internal(conn, \"SSI #include path length overflow: [%s]\", tag);\n\t\treturn;\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"Cannot open SSI #include: [%s]: fopen(%s): %s\",\n\t\t                tag,\n\t\t                path,\n\t\t                strerror(ERRNO));\n\t} else {\n\t\tfclose_on_exec(&file.access, conn);\n\t\tif (match_prefix(conn->dom_ctx->config[SSI_EXTENSIONS],\n\t\t                 strlen(conn->dom_ctx->config[SSI_EXTENSIONS]),\n\t\t                 path) > 0) {\n\t\t\tsend_ssi_file(conn, path, &file, include_level + 1);\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t}\n\t\t(void)mg_fclose(&file.access); /* Ignore errors for readonly files */\n\t}\n}\n\n\n#if !defined(NO_POPEN)\nstatic void\ndo_ssi_exec(struct mg_connection *conn, char *tag)\n{\n\tchar cmd[1024] = \"\";\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {\n\t\tmg_cry_internal(conn, \"Bad SSI #exec: [%s]\", tag);\n\t} else {\n\t\tcmd[1023] = 0;\n\t\tif ((file.access.fp = popen(cmd, \"r\")) == NULL) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Cannot SSI #exec: [%s]: %s\",\n\t\t\t                cmd,\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t\tpclose(file.access.fp);\n\t\t}\n\t}\n}\n#endif /* !NO_POPEN */\n\n\nstatic int\nmg_fgetc(struct mg_file *filep, int offset)\n{\n\t(void)offset; /* unused in case MG_USE_OPEN_FILE is set */\n\n\tif (filep == NULL) {\n\t\treturn EOF;\n\t}\n#if defined(MG_USE_OPEN_FILE)\n\tif ((filep->access.membuf != NULL) && (offset >= 0)\n\t    && (((unsigned int)(offset)) < filep->stat.size)) {\n\t\treturn ((const unsigned char *)filep->access.membuf)[offset];\n\t} else /* else block below */\n#endif\n\t    if (filep->access.fp != NULL) {\n\t\treturn fgetc(filep->access.fp);\n\t} else {\n\t\treturn EOF;\n\t}\n}\n\n\nstatic void\nsend_ssi_file(struct mg_connection *conn,\n              const char *path,\n              struct mg_file *filep,\n              int include_level)\n{\n\tchar buf[MG_BUF_LEN];\n\tint ch, offset, len, in_tag, in_ssi_tag;\n\n\tif (include_level > 10) {\n\t\tmg_cry_internal(conn, \"SSI #include level is too deep (%s)\", path);\n\t\treturn;\n\t}\n\n\tin_tag = in_ssi_tag = len = offset = 0;\n\n\t/* Read file, byte by byte, and look for SSI include tags */\n\twhile ((ch = mg_fgetc(filep, offset++)) != EOF) {\n\n\t\tif (in_tag) {\n\t\t\t/* We are in a tag, either SSI tag or html tag */\n\n\t\t\tif (ch == '>') {\n\t\t\t\t/* Tag is closing */\n\t\t\t\tbuf[len++] = '>';\n\n\t\t\t\tif (in_ssi_tag) {\n\t\t\t\t\t/* Handle SSI tag */\n\t\t\t\t\tbuf[len] = 0;\n\n\t\t\t\t\tif ((len > 12) && !memcmp(buf + 5, \"include\", 7)) {\n\t\t\t\t\t\tdo_ssi_include(conn, path, buf + 12, include_level + 1);\n#if !defined(NO_POPEN)\n\t\t\t\t\t} else if ((len > 9) && !memcmp(buf + 5, \"exec\", 4)) {\n\t\t\t\t\t\tdo_ssi_exec(conn, buf + 9);\n#endif /* !NO_POPEN */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t\t\t                \"%s: unknown SSI \"\n\t\t\t\t\t\t                \"command: \\\"%s\\\"\",\n\t\t\t\t\t\t                path,\n\t\t\t\t\t\t                buf);\n\t\t\t\t\t}\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tin_ssi_tag = in_tag = 0;\n\n\t\t\t\t} else {\n\t\t\t\t\t/* Not an SSI tag */\n\t\t\t\t\t/* Flush buffer */\n\t\t\t\t\t(void)mg_write(conn, buf, (size_t)len);\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tin_tag = 0;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* Tag is still open */\n\t\t\t\tbuf[len++] = (char)(ch & 0xff);\n\n\t\t\t\tif ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {\n\t\t\t\t\t/* All SSI tags start with <!--# */\n\t\t\t\t\tin_ssi_tag = 1;\n\t\t\t\t}\n\n\t\t\t\tif ((len + 2) > (int)sizeof(buf)) {\n\t\t\t\t\t/* Tag to long for buffer */\n\t\t\t\t\tmg_cry_internal(conn, \"%s: tag is too large\", path);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t/* We are not in a tag yet. */\n\t\t\tif (ch == '<') {\n\t\t\t\t/* Tag is opening */\n\t\t\t\tin_tag = 1;\n\n\t\t\t\tif (len > 0) {\n\t\t\t\t\t/* Flush current buffer.\n\t\t\t\t\t * Buffer is filled with \"len\" bytes. */\n\t\t\t\t\t(void)mg_write(conn, buf, (size_t)len);\n\t\t\t\t}\n\t\t\t\t/* Store the < */\n\t\t\t\tlen = 1;\n\t\t\t\tbuf[0] = '<';\n\n\t\t\t} else {\n\t\t\t\t/* No Tag */\n\t\t\t\t/* Add data to buffer */\n\t\t\t\tbuf[len++] = (char)(ch & 0xff);\n\t\t\t\t/* Flush if buffer is full */\n\t\t\t\tif (len == (int)sizeof(buf)) {\n\t\t\t\t\tmg_write(conn, buf, (size_t)len);\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send the rest of buffered data */\n\tif (len > 0) {\n\t\tmg_write(conn, buf, (size_t)len);\n\t}\n}\n\n\nstatic void\nhandle_ssi_file_request(struct mg_connection *conn,\n                        const char *path,\n                        struct mg_file *filep)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tconst char *cors1, *cors2, *cors3;\n\n\tif ((conn == NULL) || (path == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tif (mg_get_header(conn, \"Origin\")) {\n\t\t/* Cross-origin resource sharing (CORS). */\n\t\tcors1 = \"Access-Control-Allow-Origin: \";\n\t\tcors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tcors3 = \"\\r\\n\";\n\t} else {\n\t\tcors1 = cors2 = cors3 = \"\";\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {\n\t\t/* File exists (precondition for calling this function),\n\t\t * but can not be opened by the server. */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot read file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t} else {\n\t\tconn->must_close = 1;\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tfclose_on_exec(&filep->access, conn);\n\t\tmg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"%s%s%s\"\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Content-Type: text/html\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          cors1,\n\t\t          cors2,\n\t\t          cors3,\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\t\tsend_ssi_file(conn, path, filep, 0);\n\t\t(void)mg_fclose(&filep->access); /* Ignore errors for readonly files */\n\t}\n}\n\n\n#if !defined(NO_FILES)\nstatic void\nsend_options(struct mg_connection *conn)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\tconn->status_code = 200;\n\tconn->must_close = 1;\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\t/* We do not set a \"Cache-Control\" header here, but leave the default.\n\t * Since browsers do not send an OPTIONS request, we can not test the\n\t * effect anyway. */\n\tmg_printf(conn,\n\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\"\n\t          \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, \"\n\t          \"PROPFIND, MKCOL\\r\\n\"\n\t          \"DAV: 1\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn));\n\tsend_additional_header(conn);\n\tmg_printf(conn, \"\\r\\n\");\n}\n\n\n/* Writes PROPFIND properties for a collection element */\nstatic void\nprint_props(struct mg_connection *conn,\n            const char *uri,\n            struct mg_file_stat *filep)\n{\n\tchar mtime[64];\n\n\tif ((conn == NULL) || (uri == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tgmt_time_string(mtime, sizeof(mtime), &filep->last_modified);\n\tmg_printf(conn,\n\t          \"<d:response>\"\n\t          \"<d:href>%s</d:href>\"\n\t          \"<d:propstat>\"\n\t          \"<d:prop>\"\n\t          \"<d:resourcetype>%s</d:resourcetype>\"\n\t          \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"\n\t          \"<d:getlastmodified>%s</d:getlastmodified>\"\n\t          \"</d:prop>\"\n\t          \"<d:status>HTTP/1.1 200 OK</d:status>\"\n\t          \"</d:propstat>\"\n\t          \"</d:response>\\n\",\n\t          uri,\n\t          filep->is_directory ? \"<d:collection/>\" : \"\",\n\t          filep->size,\n\t          mtime);\n}\n\n\nstatic int\nprint_dav_dir_entry(struct de *de, void *data)\n{\n\tchar href[PATH_MAX];\n\tint truncated;\n\n\tstruct mg_connection *conn = (struct mg_connection *)data;\n\tif (!de || !conn) {\n\t\treturn -1;\n\t}\n\tmg_snprintf(conn,\n\t            &truncated,\n\t            href,\n\t            sizeof(href),\n\t            \"%s%s\",\n\t            conn->request_info.local_uri,\n\t            de->file_name);\n\n\tif (!truncated) {\n\t\tsize_t href_encoded_size;\n\t\tchar *href_encoded;\n\n\t\thref_encoded_size = PATH_MAX * 3; /* worst case */\n\t\thref_encoded = (char *)mg_malloc(href_encoded_size);\n\t\tif (href_encoded == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tmg_url_encode(href, href_encoded, href_encoded_size);\n\t\tprint_props(conn, href_encoded, &de->file);\n\t\tmg_free(href_encoded);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_propfind(struct mg_connection *conn,\n                const char *path,\n                struct mg_file_stat *filep)\n{\n\tconst char *depth = mg_get_header(conn, \"Depth\");\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tif (!conn || !path || !filep || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tconn->must_close = 1;\n\tconn->status_code = 207;\n\tmg_printf(conn,\n\t          \"HTTP/1.1 207 Multi-Status\\r\\n\"\n\t          \"Date: %s\\r\\n\",\n\t          date);\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Connection: %s\\r\\n\"\n\t          \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\",\n\t          suggest_connection_header(conn));\n\n\tmg_printf(conn,\n\t          \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t          \"<d:multistatus xmlns:d='DAV:'>\\n\");\n\n\t/* Print properties for the requested resource itself */\n\tprint_props(conn, conn->request_info.local_uri, filep);\n\n\t/* If it is a directory, print directory entries too if Depth is not 0\n\t */\n\tif (filep->is_directory\n\t    && !mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t                      \"yes\")\n\t    && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {\n\t\tscan_directory(conn, path, conn, &print_dav_dir_entry);\n\t}\n\n\tmg_printf(conn, \"%s\\n\", \"</d:multistatus>\");\n}\n#endif\n\nvoid\nmg_lock_connection(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\t(void)pthread_mutex_lock(&conn->mutex);\n\t}\n}\n\nvoid\nmg_unlock_connection(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\t(void)pthread_mutex_unlock(&conn->mutex);\n\t}\n}\n\nvoid\nmg_lock_context(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\t(void)pthread_mutex_lock(&ctx->nonce_mutex);\n\t}\n}\n\nvoid\nmg_unlock_context(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\t(void)pthread_mutex_unlock(&ctx->nonce_mutex);\n\t}\n}\n\n\n#if defined(USE_LUA)\n#include \"mod_lua.inl\"\n#endif /* USE_LUA */\n\n#if defined(USE_DUKTAPE)\n#include \"mod_duktape.inl\"\n#endif /* USE_DUKTAPE */\n\n#if defined(USE_WEBSOCKET)\n\n#if !defined(NO_SSL_DL)\n#define SHA_API static\n#include \"sha1.inl\"\n#endif\n\nstatic int\nsend_websocket_handshake(struct mg_connection *conn, const char *websock_key)\n{\n\tstatic const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\tchar buf[100], sha[20], b64_sha[sizeof(sha) * 2];\n\tSHA_CTX sha_ctx;\n\tint truncated;\n\n\t/* Calculate Sec-WebSocket-Accept reply from Sec-WebSocket-Key. */\n\tmg_snprintf(conn, &truncated, buf, sizeof(buf), \"%s%s\", websock_key, magic);\n\tif (truncated) {\n\t\tconn->must_close = 1;\n\t\treturn 0;\n\t}\n\n\tDEBUG_TRACE(\"%s\", \"Send websocket handshake\");\n\n\tSHA1_Init(&sha_ctx);\n\tSHA1_Update(&sha_ctx, (unsigned char *)buf, (uint32_t)strlen(buf));\n\tSHA1_Final((unsigned char *)sha, &sha_ctx);\n\tbase64_encode((unsigned char *)sha, sizeof(sha), b64_sha);\n\tmg_printf(conn,\n\t          \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n\t          \"Upgrade: websocket\\r\\n\"\n\t          \"Connection: Upgrade\\r\\n\"\n\t          \"Sec-WebSocket-Accept: %s\\r\\n\",\n\t          b64_sha);\n\tif (conn->request_info.acceptedWebSocketSubprotocol) {\n\t\tmg_printf(conn,\n\t\t          \"Sec-WebSocket-Protocol: %s\\r\\n\\r\\n\",\n\t\t          conn->request_info.acceptedWebSocketSubprotocol);\n\t} else {\n\t\tmg_printf(conn, \"%s\", \"\\r\\n\");\n\t}\n\n\treturn 1;\n}\n\n\n#if !defined(MG_MAX_UNANSWERED_PING)\n/* Configuration of the maximum number of websocket PINGs that might\n * stay unanswered before the connection is considered broken.\n * Note: The name of this define may still change (until it is\n * defined as a compile parameter in a documentation).\n */\n#define MG_MAX_UNANSWERED_PING (5)\n#endif\n\n\nstatic void\nread_websocket(struct mg_connection *conn,\n               mg_websocket_data_handler ws_data_handler,\n               void *callback_data)\n{\n\t/* Pointer to the beginning of the portion of the incoming websocket\n\t * message queue.\n\t * The original websocket upgrade request is never removed, so the queue\n\t * begins after it. */\n\tunsigned char *buf = (unsigned char *)conn->buf + conn->request_len;\n\tint n, error, exit_by_callback;\n\tint ret;\n\n\t/* body_len is the length of the entire queue in bytes\n\t * len is the length of the current message\n\t * data_len is the length of the current message's data payload\n\t * header_len is the length of the current message's header */\n\tsize_t i, len, mask_len = 0, header_len, body_len;\n\tuint64_t data_len = 0;\n\n\t/* \"The masking key is a 32-bit value chosen at random by the client.\"\n\t * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5\n\t*/\n\tunsigned char mask[4];\n\n\t/* data points to the place where the message is stored when passed to\n\t * the websocket_data callback.  This is either mem on the stack, or a\n\t * dynamically allocated buffer if it is too large. */\n\tunsigned char mem[4096];\n\tunsigned char mop; /* mask flag and opcode */\n\n\n\t/* Variables used for connection monitoring */\n\tdouble timeout = -1.0;\n\tint enable_ping_pong = 0;\n\tint ping_count = 0;\n\n\tif (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {\n\t\tenable_ping_pong =\n\t\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],\n\t\t                   \"yes\");\n\t}\n\n\tif (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;\n\t}\n\tif ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\t/* Enter data processing loop */\n\tDEBUG_TRACE(\"Websocket connection %s:%u start data processing loop\",\n\t            conn->request_info.remote_addr,\n\t            conn->request_info.remote_port);\n\tconn->in_websocket_handling = 1;\n\tmg_set_thread_name(\"wsock\");\n\n\t/* Loop continuously, reading messages from the socket, invoking the\n\t * callback, and waiting repeatedly until an error occurs. */\n\twhile (!conn->phys_ctx->stop_flag && !conn->must_close) {\n\t\theader_len = 0;\n\t\tDEBUG_ASSERT(conn->data_len >= conn->request_len);\n\t\tif ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {\n\t\t\tlen = buf[1] & 127;\n\t\t\tmask_len = (buf[1] & 128) ? 4 : 0;\n\t\t\tif ((len < 126) && (body_len >= mask_len)) {\n\t\t\t\t/* inline 7-bit length field */\n\t\t\t\tdata_len = len;\n\t\t\t\theader_len = 2 + mask_len;\n\t\t\t} else if ((len == 126) && (body_len >= (4 + mask_len))) {\n\t\t\t\t/* 16-bit length field */\n\t\t\t\theader_len = 4 + mask_len;\n\t\t\t\tdata_len = ((((size_t)buf[2]) << 8) + buf[3]);\n\t\t\t} else if (body_len >= (10 + mask_len)) {\n\t\t\t\t/* 64-bit length field */\n\t\t\t\tuint32_t l1, l2;\n\t\t\t\tmemcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */\n\t\t\t\tmemcpy(&l2, &buf[6], 4);\n\t\t\t\theader_len = 10 + mask_len;\n\t\t\t\tdata_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);\n\n\t\t\t\tif (data_len > (uint64_t)0x7FFF0000ul) {\n\t\t\t\t\t/* no can do */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"websocket out of memory; closing connection\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((header_len > 0) && (body_len >= header_len)) {\n\t\t\t/* Allocate space to hold websocket payload */\n\t\t\tunsigned char *data = mem;\n\n\t\t\tif ((size_t)data_len > (size_t)sizeof(mem)) {\n\t\t\t\tdata = (unsigned char *)mg_malloc_ctx((size_t)data_len,\n\t\t\t\t                                      conn->phys_ctx);\n\t\t\t\tif (data == NULL) {\n\t\t\t\t\t/* Allocation failed, exit the loop and then close the\n\t\t\t\t\t * connection */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"websocket out of memory; closing connection\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Copy the mask before we shift the queue and destroy it */\n\t\t\tif (mask_len > 0) {\n\t\t\t\tmemcpy(mask, buf + header_len - mask_len, sizeof(mask));\n\t\t\t} else {\n\t\t\t\tmemset(mask, 0, sizeof(mask));\n\t\t\t}\n\n\t\t\t/* Read frame payload from the first message in the queue into\n\t\t\t * data and advance the queue by moving the memory in place. */\n\t\t\tDEBUG_ASSERT(body_len >= header_len);\n\t\t\tif (data_len + (uint64_t)header_len > (uint64_t)body_len) {\n\t\t\t\tmop = buf[0]; /* current mask and opcode */\n\t\t\t\t/* Overflow case */\n\t\t\t\tlen = body_len - header_len;\n\t\t\t\tmemcpy(data, buf + header_len, len);\n\t\t\t\terror = 0;\n\t\t\t\twhile ((uint64_t)len < data_len) {\n\t\t\t\t\tn = pull_inner(NULL,\n\t\t\t\t\t               conn,\n\t\t\t\t\t               (char *)(data + len),\n\t\t\t\t\t               (int)(data_len - len),\n\t\t\t\t\t               timeout);\n\t\t\t\t\tif (n <= -2) {\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (n > 0) {\n\t\t\t\t\t\tlen += (size_t)n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Timeout: should retry */\n\t\t\t\t\t\t/* TODO: retry condition */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"Websocket pull failed; closing connection\");\n\t\t\t\t\tif (data != mem) {\n\t\t\t\t\t\tmg_free(data);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconn->data_len = conn->request_len;\n\n\t\t\t} else {\n\n\t\t\t\tmop = buf[0]; /* current mask and opcode, overwritten by\n\t\t\t\t               * memmove() */\n\n\t\t\t\t/* Length of the message being read at the front of the\n\t\t\t\t * queue. Cast to 31 bit is OK, since we limited\n\t\t\t\t * data_len before. */\n\t\t\t\tlen = (size_t)data_len + header_len;\n\n\t\t\t\t/* Copy the data payload into the data pointer for the\n\t\t\t\t * callback. Cast to 31 bit is OK, since we\n\t\t\t\t * limited data_len */\n\t\t\t\tmemcpy(data, buf + header_len, (size_t)data_len);\n\n\t\t\t\t/* Move the queue forward len bytes */\n\t\t\t\tmemmove(buf, buf + len, body_len - len);\n\n\t\t\t\t/* Mark the queue as advanced */\n\t\t\t\tconn->data_len -= (int)len;\n\t\t\t}\n\n\t\t\t/* Apply mask if necessary */\n\t\t\tif (mask_len > 0) {\n\t\t\t\tfor (i = 0; i < (size_t)data_len; i++) {\n\t\t\t\t\tdata[i] ^= mask[i & 3];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texit_by_callback = 0;\n\t\t\tif (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {\n\t\t\t\t/* filter PONG messages */\n\t\t\t\tDEBUG_TRACE(\"PONG from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t/* No unanwered PINGs left */\n\t\t\t\tping_count = 0;\n\t\t\t} else if (enable_ping_pong\n\t\t\t           && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {\n\t\t\t\t/* reply PING messages */\n\t\t\t\tDEBUG_TRACE(\"Reply PING from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tret = mg_websocket_write(conn,\n\t\t\t\t                         MG_WEBSOCKET_OPCODE_PONG,\n\t\t\t\t                         (char *)data,\n\t\t\t\t                         (size_t)data_len);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\t/* Error: send failed */\n\t\t\t\t\tDEBUG_TRACE(\"Reply PONG failed (%i)\", ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t} else {\n\t\t\t\t/* Exit the loop if callback signals to exit (server side),\n\t\t\t\t * or \"connection close\" opcode received (client side). */\n\t\t\t\tif ((ws_data_handler != NULL)\n\t\t\t\t    && !ws_data_handler(conn,\n\t\t\t\t                        mop,\n\t\t\t\t                        (char *)data,\n\t\t\t\t                        (size_t)data_len,\n\t\t\t\t                        callback_data)) {\n\t\t\t\t\texit_by_callback = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* It a buffer has been allocated, free it again */\n\t\t\tif (data != mem) {\n\t\t\t\tmg_free(data);\n\t\t\t}\n\n\t\t\tif (exit_by_callback) {\n\t\t\t\tDEBUG_TRACE(\"Callback requests to close connection from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {\n\t\t\t\t/* Opcode == 8, connection close */\n\t\t\t\tDEBUG_TRACE(\"Message requests to close connection from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Not breaking the loop, process next websocket frame. */\n\t\t} else {\n\t\t\t/* Read from the socket into the next available location in the\n\t\t\t * message queue. */\n\t\t\tn = pull_inner(NULL,\n\t\t\t               conn,\n\t\t\t               conn->buf + conn->data_len,\n\t\t\t               conn->buf_size - conn->data_len,\n\t\t\t               timeout);\n\t\t\tif (n <= -2) {\n\t\t\t\t/* Error, no bytes read */\n\t\t\t\tDEBUG_TRACE(\"PULL from %s:%u failed\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n > 0) {\n\t\t\t\tconn->data_len += n;\n\t\t\t\t/* Reset open PING count */\n\t\t\t\tping_count = 0;\n\t\t\t} else {\n\t\t\t\tif (!conn->phys_ctx->stop_flag && !conn->must_close) {\n\t\t\t\t\tif (ping_count > MG_MAX_UNANSWERED_PING) {\n\t\t\t\t\t\t/* Stop sending PING */\n\t\t\t\t\t\tDEBUG_TRACE(\"Too many (%i) unanswered ping from %s:%u \"\n\t\t\t\t\t\t            \"- closing connection\",\n\t\t\t\t\t\t            ping_count,\n\t\t\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (enable_ping_pong) {\n\t\t\t\t\t\t/* Send Websocket PING message */\n\t\t\t\t\t\tDEBUG_TRACE(\"PING to %s:%u\",\n\t\t\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t\t\tret = mg_websocket_write(conn,\n\t\t\t\t\t\t                         MG_WEBSOCKET_OPCODE_PING,\n\t\t\t\t\t\t                         NULL,\n\t\t\t\t\t\t                         0);\n\n\t\t\t\t\t\tif (ret <= 0) {\n\t\t\t\t\t\t\t/* Error: send failed */\n\t\t\t\t\t\t\tDEBUG_TRACE(\"Send PING failed (%i)\", ret);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tping_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Timeout: should retry */\n\t\t\t\t/* TODO: get timeout def */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Leave data processing loop */\n\tmg_set_thread_name(\"worker\");\n\tconn->in_websocket_handling = 0;\n\tDEBUG_TRACE(\"Websocket connection %s:%u left data processing loop\",\n\t            conn->request_info.remote_addr,\n\t            conn->request_info.remote_port);\n}\n\n\nstatic int\nmg_websocket_write_exec(struct mg_connection *conn,\n                        int opcode,\n                        const char *data,\n                        size_t dataLen,\n                        uint32_t masking_key)\n{\n\tunsigned char header[14];\n\tsize_t headerLen;\n\tint retval;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Disable spurious conversion warning for GCC */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n\n\theader[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif\n\n\t/* Frame format: http://tools.ietf.org/html/rfc6455#section-5.2 */\n\tif (dataLen < 126) {\n\t\t/* inline 7-bit length field */\n\t\theader[1] = (unsigned char)dataLen;\n\t\theaderLen = 2;\n\t} else if (dataLen <= 0xFFFF) {\n\t\t/* 16-bit length field */\n\t\tuint16_t len = htons((uint16_t)dataLen);\n\t\theader[1] = 126;\n\t\tmemcpy(header + 2, &len, 2);\n\t\theaderLen = 4;\n\t} else {\n\t\t/* 64-bit length field */\n\t\tuint32_t len1 = htonl((uint32_t)((uint64_t)dataLen >> 32));\n\t\tuint32_t len2 = htonl((uint32_t)(dataLen & 0xFFFFFFFFu));\n\t\theader[1] = 127;\n\t\tmemcpy(header + 2, &len1, 4);\n\t\tmemcpy(header + 6, &len2, 4);\n\t\theaderLen = 10;\n\t}\n\n\tif (masking_key) {\n\t\t/* add mask */\n\t\theader[1] |= 0x80;\n\t\tmemcpy(header + headerLen, &masking_key, 4);\n\t\theaderLen += 4;\n\t}\n\n\t/* Note that POSIX/Winsock's send() is threadsafe\n\t * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid\n\t * but mongoose's mg_printf/mg_write is not (because of the loop in\n\t * push(), although that is only a problem if the packet is large or\n\t * outgoing buffer is full). */\n\n\t/* TODO: Check if this lock should be moved to user land.\n\t * Currently the server sets this lock for websockets, but\n\t * not for any other connection. It must be set for every\n\t * conn read/written by more than one thread, no matter if\n\t * it is a websocket or regular connection. */\n\t(void)mg_lock_connection(conn);\n\n\tretval = mg_write(conn, header, headerLen);\n\tif (retval != (int)headerLen) {\n\t\t/* Did not send complete header */\n\t\tretval = -1;\n\t} else {\n\t\tif (dataLen > 0) {\n\t\t\tretval = mg_write(conn, data, dataLen);\n\t\t}\n\t\t/* if dataLen == 0, the header length (2) is returned */\n\t}\n\n\t/* TODO: Remove this unlock as well, when lock is removed. */\n\tmg_unlock_connection(conn);\n\n\treturn retval;\n}\n\nint\nmg_websocket_write(struct mg_connection *conn,\n                   int opcode,\n                   const char *data,\n                   size_t dataLen)\n{\n\treturn mg_websocket_write_exec(conn, opcode, data, dataLen, 0);\n}\n\n\nstatic void\nmask_data(const char *in, size_t in_len, uint32_t masking_key, char *out)\n{\n\tsize_t i = 0;\n\n\ti = 0;\n\tif ((in_len > 3) && ((ptrdiff_t)in % 4) == 0) {\n\t\t/* Convert in 32 bit words, if data is 4 byte aligned */\n\t\twhile (i < (in_len - 3)) {\n\t\t\t*(uint32_t *)(void *)(out + i) =\n\t\t\t    *(uint32_t *)(void *)(in + i) ^ masking_key;\n\t\t\ti += 4;\n\t\t}\n\t}\n\tif (i != in_len) {\n\t\t/* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/\n\t\twhile (i < in_len) {\n\t\t\t*(uint8_t *)(void *)(out + i) =\n\t\t\t    *(uint8_t *)(void *)(in + i)\n\t\t\t    ^ *(((uint8_t *)&masking_key) + (i % 4));\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n\nint\nmg_websocket_client_write(struct mg_connection *conn,\n                          int opcode,\n                          const char *data,\n                          size_t dataLen)\n{\n\tint retval = -1;\n\tchar *masked_data =\n\t    (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);\n\tuint32_t masking_key = 0;\n\n\tif (masked_data == NULL) {\n\t\t/* Return -1 in an error case */\n\t\tmg_cry_internal(conn,\n\t\t                \"%s\",\n\t\t                \"Cannot allocate buffer for masked websocket response: \"\n\t\t                \"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\t/* Get a masking key - but not 0 */\n\t\tmasking_key = (uint32_t)get_random();\n\t} while (masking_key == 0);\n\n\tmask_data(data, dataLen, masking_key, masked_data);\n\n\tretval = mg_websocket_write_exec(\n\t    conn, opcode, masked_data, dataLen, masking_key);\n\tmg_free(masked_data);\n\n\treturn retval;\n}\n\n\nstatic void\nhandle_websocket_request(struct mg_connection *conn,\n                         const char *path,\n                         int is_callback_resource,\n                         struct mg_websocket_subprotocols *subprotocols,\n                         mg_websocket_connect_handler ws_connect_handler,\n                         mg_websocket_ready_handler ws_ready_handler,\n                         mg_websocket_data_handler ws_data_handler,\n                         mg_websocket_close_handler ws_close_handler,\n                         void *cbData)\n{\n\tconst char *websock_key = mg_get_header(conn, \"Sec-WebSocket-Key\");\n\tconst char *version = mg_get_header(conn, \"Sec-WebSocket-Version\");\n\tptrdiff_t lua_websock = 0;\n\n#if !defined(USE_LUA)\n\t(void)path;\n#endif\n\n\t/* Step 1: Check websocket protocol version. */\n\t/* Step 1.1: Check Sec-WebSocket-Key. */\n\tif (!websock_key) {\n\t\t/* The RFC standard version (https://tools.ietf.org/html/rfc6455)\n\t\t * requires a Sec-WebSocket-Key header.\n\t\t */\n\t\t/* It could be the hixie draft version\n\t\t * (http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76).\n\t\t */\n\t\tconst char *key1 = mg_get_header(conn, \"Sec-WebSocket-Key1\");\n\t\tconst char *key2 = mg_get_header(conn, \"Sec-WebSocket-Key2\");\n\t\tchar key3[8];\n\n\t\tif ((key1 != NULL) && (key2 != NULL)) {\n\t\t\t/* This version uses 8 byte body data in a GET request */\n\t\t\tconn->content_len = 8;\n\t\t\tif (8 == mg_read(conn, key3, 8)) {\n\t\t\t\t/* This is the hixie version */\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   426,\n\t\t\t\t                   \"%s\",\n\t\t\t\t                   \"Protocol upgrade to RFC 6455 required\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* This is an unknown version */\n\t\tmg_send_http_error(conn, 400, \"%s\", \"Malformed websocket request\");\n\t\treturn;\n\t}\n\n\t/* Step 1.2: Check websocket protocol version. */\n\t/* The RFC version (https://tools.ietf.org/html/rfc6455) is 13. */\n\tif ((version == NULL) || (strcmp(version, \"13\") != 0)) {\n\t\t/* Reject wrong versions */\n\t\tmg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");\n\t\treturn;\n\t}\n\n\t/* Step 1.3: Could check for \"Host\", but we do not really nead this\n\t * value for anything, so just ignore it. */\n\n\t/* Step 2: If a callback is responsible, call it. */\n\tif (is_callback_resource) {\n\t\t/* Step 2.1 check and select subprotocol */\n\t\tconst char *protocols[64]; // max 64 headers\n\t\tint nbSubprotocolHeader = get_req_headers(&conn->request_info,\n\t\t                                          \"Sec-WebSocket-Protocol\",\n\t\t                                          protocols,\n\t\t                                          64);\n\t\tif ((nbSubprotocolHeader > 0) && subprotocols) {\n\t\t\tint cnt = 0;\n\t\t\tint idx;\n\t\t\tunsigned long len;\n\t\t\tconst char *sep, *curSubProtocol,\n\t\t\t    *acceptedWebSocketSubprotocol = NULL;\n\n\n\t\t\t/* look for matching subprotocol */\n\t\t\tdo {\n\t\t\t\tconst char *protocol = protocols[cnt];\n\n\t\t\t\tdo {\n\t\t\t\t\tsep = strchr(protocol, ',');\n\t\t\t\t\tcurSubProtocol = protocol;\n\t\t\t\t\tlen = sep ? (unsigned long)(sep - protocol)\n\t\t\t\t\t          : (unsigned long)strlen(protocol);\n\t\t\t\t\twhile (sep && isspace(*++sep))\n\t\t\t\t\t\t; // ignore leading whitespaces\n\t\t\t\t\tprotocol = sep;\n\n\n\t\t\t\t\tfor (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {\n\t\t\t\t\t\tif ((strlen(subprotocols->subprotocols[idx]) == len)\n\t\t\t\t\t\t    && (strncmp(curSubProtocol,\n\t\t\t\t\t\t                subprotocols->subprotocols[idx],\n\t\t\t\t\t\t                len) == 0)) {\n\t\t\t\t\t\t\tacceptedWebSocketSubprotocol =\n\t\t\t\t\t\t\t    subprotocols->subprotocols[idx];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (sep && !acceptedWebSocketSubprotocol);\n\t\t\t} while (++cnt < nbSubprotocolHeader\n\t\t\t         && !acceptedWebSocketSubprotocol);\n\n\t\t\tconn->request_info.acceptedWebSocketSubprotocol =\n\t\t\t    acceptedWebSocketSubprotocol;\n\n\t\t} else if (nbSubprotocolHeader > 0) {\n\t\t\t/* keep legacy behavior */\n\t\t\tconst char *protocol = protocols[0];\n\n\t\t\t/* The protocol is a comma separated list of names. */\n\t\t\t/* The server must only return one value from this list. */\n\t\t\t/* First check if it is a list or just a single value. */\n\t\t\tconst char *sep = strrchr(protocol, ',');\n\t\t\tif (sep == NULL) {\n\t\t\t\t/* Just a single protocol -> accept it. */\n\t\t\t\tconn->request_info.acceptedWebSocketSubprotocol = protocol;\n\t\t\t} else {\n\t\t\t\t/* Multiple protocols -> accept the last one. */\n\t\t\t\t/* This is just a quick fix if the client offers multiple\n\t\t\t\t * protocols. The handler should have a list of accepted\n\t\t\t\t * protocols on his own\n\t\t\t\t * and use it to select one protocol among those the client\n\t\t\t\t * has\n\t\t\t\t * offered.\n\t\t\t\t */\n\t\t\t\twhile (isspace(*++sep)) {\n\t\t\t\t\t; /* ignore leading whitespaces */\n\t\t\t\t}\n\t\t\t\tconn->request_info.acceptedWebSocketSubprotocol = sep;\n\t\t\t}\n\t\t}\n\n\t\tif ((ws_connect_handler != NULL)\n\t\t    && (ws_connect_handler(conn, cbData) != 0)) {\n\t\t\t/* C callback has returned non-zero, do not proceed with\n\t\t\t * handshake.\n\t\t\t */\n\t\t\t/* Note that C callbacks are no longer called when Lua is\n\t\t\t * responsible, so C can no longer filter callbacks for Lua. */\n\t\t\treturn;\n\t\t}\n\t}\n\n#if defined(USE_LUA)\n\t/* Step 3: No callback. Check if Lua is responsible. */\n\telse {\n\t\t/* Step 3.1: Check if Lua is responsible. */\n\t\tif (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {\n\t\t\tlua_websock = match_prefix(\n\t\t\t    conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS],\n\t\t\t    strlen(conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]),\n\t\t\t    path);\n\t\t}\n\n\t\tif (lua_websock) {\n\t\t\t/* Step 3.2: Lua is responsible: call it. */\n\t\t\tconn->lua_websocket_state = lua_websocket_new(path, conn);\n\t\t\tif (!conn->lua_websocket_state) {\n\t\t\t\t/* Lua rejected the new client */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t/* Step 4: Check if there is a responsible websocket handler. */\n\tif (!is_callback_resource && !lua_websock) {\n\t\t/* There is no callback, and Lua is not responsible either. */\n\t\t/* Reply with a 404 Not Found. We are still at a standard\n\t\t * HTTP request here, before the websocket handshake, so\n\t\t * we can still send standard HTTP error replies. */\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n\t\treturn;\n\t}\n\n\t/* Step 5: The websocket connection has been accepted */\n\tif (!send_websocket_handshake(conn, websock_key)) {\n\t\tmg_send_http_error(conn, 500, \"%s\", \"Websocket handshake failed\");\n\t\treturn;\n\t}\n\n\t/* Step 6: Call the ready handler */\n\tif (is_callback_resource) {\n\t\tif (ws_ready_handler != NULL) {\n\t\t\tws_ready_handler(conn, cbData);\n\t\t}\n#if defined(USE_LUA)\n\t} else if (lua_websock) {\n\t\tif (!lua_websocket_ready(conn, conn->lua_websocket_state)) {\n\t\t\t/* the ready handler returned false */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\n\t/* Step 7: Enter the read loop */\n\tif (is_callback_resource) {\n\t\tread_websocket(conn, ws_data_handler, cbData);\n#if defined(USE_LUA)\n\t} else if (lua_websock) {\n\t\tread_websocket(conn, lua_websocket_data, conn->lua_websocket_state);\n#endif\n\t}\n\n\t/* Step 8: Call the close handler */\n\tif (ws_close_handler) {\n\t\tws_close_handler(conn, cbData);\n\t}\n}\n\n\nstatic int\nis_websocket_protocol(const struct mg_connection *conn)\n{\n\tconst char *upgrade, *connection;\n\n\t/* A websocket protocoll has the following HTTP headers:\n\t *\n\t * Connection: Upgrade\n\t * Upgrade: Websocket\n\t */\n\n\tupgrade = mg_get_header(conn, \"Upgrade\");\n\tif (upgrade == NULL) {\n\t\treturn 0; /* fail early, don't waste time checking other header\n\t\t           * fields\n\t\t             */\n\t}\n\tif (!mg_strcasestr(upgrade, \"websocket\")) {\n\t\treturn 0;\n\t}\n\n\tconnection = mg_get_header(conn, \"Connection\");\n\tif (connection == NULL) {\n\t\treturn 0;\n\t}\n\tif (!mg_strcasestr(connection, \"upgrade\")) {\n\t\treturn 0;\n\t}\n\n\t/* The headers \"Host\", \"Sec-WebSocket-Key\", \"Sec-WebSocket-Protocol\" and\n\t * \"Sec-WebSocket-Version\" are also required.\n\t * Don't check them here, since even an unsupported websocket protocol\n\t * request still IS a websocket request (in contrast to a standard HTTP\n\t * request). It will fail later in handle_websocket_request.\n\t */\n\n\treturn 1;\n}\n#endif /* !USE_WEBSOCKET */\n\n\nstatic int\nisbyte(int n)\n{\n\treturn (n >= 0) && (n <= 255);\n}\n\n\nstatic int\nparse_net(const char *spec, uint32_t *net, uint32_t *mask)\n{\n\tint n, a, b, c, d, slash = 32, len = 0;\n\n\tif (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)\n\t     || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))\n\t    && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)\n\t    && (slash < 33)) {\n\t\tlen = n;\n\t\t*net = ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8)\n\t\t       | (uint32_t)d;\n\t\t*mask = slash ? (0xffffffffU << (32 - slash)) : 0;\n\t}\n\n\treturn len;\n}\n\n\nstatic int\nset_throttle(const char *spec, uint32_t remote_ip, const char *uri)\n{\n\tint throttle = 0;\n\tstruct vec vec, val;\n\tuint32_t net, mask;\n\tchar mult;\n\tdouble v;\n\n\twhile ((spec = next_option(spec, &vec, &val)) != NULL) {\n\t\tmult = ',';\n\t\tif ((val.ptr == NULL) || (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1)\n\t\t    || (v < 0) || ((lowercase(&mult) != 'k')\n\t\t                   && (lowercase(&mult) != 'm') && (mult != ','))) {\n\t\t\tcontinue;\n\t\t}\n\t\tv *= (lowercase(&mult) == 'k')\n\t\t         ? 1024\n\t\t         : ((lowercase(&mult) == 'm') ? 1048576 : 1);\n\t\tif (vec.len == 1 && vec.ptr[0] == '*') {\n\t\t\tthrottle = (int)v;\n\t\t} else if (parse_net(vec.ptr, &net, &mask) > 0) {\n\t\t\tif ((remote_ip & mask) == net) {\n\t\t\t\tthrottle = (int)v;\n\t\t\t}\n\t\t} else if (match_prefix(vec.ptr, vec.len, uri) > 0) {\n\t\t\tthrottle = (int)v;\n\t\t}\n\t}\n\n\treturn throttle;\n}\n\n\nstatic uint32_t\nget_remote_ip(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\treturn ntohl(*(const uint32_t *)&conn->client.rsa.sin.sin_addr);\n}\n\n\n/* The mg_upload function is superseeded by mg_handle_form_request. */\n#include \"handle_form.inl\"\n\n\n#if defined(MG_LEGACY_INTERFACE)\n/* Implement the deprecated mg_upload function by calling the new\n * mg_handle_form_request function. While mg_upload could only handle\n * HTML forms sent as POST request in multipart/form-data format\n * containing only file input elements, mg_handle_form_request can\n * handle all form input elements and all standard request methods. */\nstruct mg_upload_user_data {\n\tstruct mg_connection *conn;\n\tconst char *destination_dir;\n\tint num_uploaded_files;\n};\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_found(const char *key,\n                      const char *filename,\n                      char *path,\n                      size_t pathlen,\n                      void *user_data)\n{\n\tint truncated = 0;\n\tstruct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;\n\t(void)key;\n\n\tif (!filename) {\n\t\tmg_cry_internal(fud->conn, \"%s: No filename set\", __func__);\n\t\treturn FORM_FIELD_STORAGE_ABORT;\n\t}\n\tmg_snprintf(fud->conn,\n\t            &truncated,\n\t            path,\n\t            pathlen - 1,\n\t            \"%s/%s\",\n\t            fud->destination_dir,\n\t            filename);\n\tif (truncated) {\n\t\tmg_cry_internal(fud->conn, \"%s: File path too long\", __func__);\n\t\treturn FORM_FIELD_STORAGE_ABORT;\n\t}\n\treturn FORM_FIELD_STORAGE_STORE;\n}\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_get(const char *key,\n                    const char *value,\n                    size_t value_size,\n                    void *user_data)\n{\n\t/* Function should never be called */\n\t(void)key;\n\t(void)value;\n\t(void)value_size;\n\t(void)user_data;\n\n\treturn 0;\n}\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_stored(const char *path, long long file_size, void *user_data)\n{\n\tstruct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;\n\t(void)file_size;\n\n\tfud->num_uploaded_files++;\n\tfud->conn->phys_ctx->callbacks.upload(fud->conn, path);\n\n\treturn 0;\n}\n\n\n/* Deprecated function mg_upload - use mg_handle_form_request instead. */\nint\nmg_upload(struct mg_connection *conn, const char *destination_dir)\n{\n\tstruct mg_upload_user_data fud = {conn, destination_dir, 0};\n\tstruct mg_form_data_handler fdh = {mg_upload_field_found,\n\t                                   mg_upload_field_get,\n\t                                   mg_upload_field_stored,\n\t                                   0};\n\tint ret;\n\n\tfdh.user_data = (void *)&fud;\n\tret = mg_handle_form_request(conn, &fdh);\n\n\tif (ret < 0) {\n\t\tmg_cry_internal(conn, \"%s: Error while parsing the request\", __func__);\n\t}\n\n\treturn fud.num_uploaded_files;\n}\n#endif\n\n\nstatic int\nget_first_ssl_listener_index(const struct mg_context *ctx)\n{\n\tunsigned int i;\n\tint idx = -1;\n\tif (ctx) {\n\t\tfor (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {\n\t\t\tidx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;\n\t\t}\n\t}\n\treturn idx;\n}\n\n\n/* Return host (without port) */\n/* Use mg_free to free the result */\nstatic const char *\nalloc_get_host(struct mg_connection *conn)\n{\n\tchar buf[1025];\n\tsize_t buflen = sizeof(buf);\n\tconst char *host_header = get_header(conn->request_info.http_headers,\n\t                                     conn->request_info.num_headers,\n\t                                     \"Host\");\n\tchar *host;\n\n\tif (host_header != NULL) {\n\t\tchar *pos;\n\n\t\t/* Create a local copy of the \"Host\" header, since it might be\n\t\t * modified here. */\n\t\tmg_strlcpy(buf, host_header, buflen);\n\t\tbuf[buflen - 1] = '\\0';\n\t\thost = buf;\n\t\twhile (isspace(*host)) {\n\t\t\thost++;\n\t\t}\n\n\t\t/* If the \"Host\" is an IPv6 address, like [::1], parse until ]\n\t\t * is found. */\n\t\tif (*host == '[') {\n\t\t\tpos = strchr(host, ']');\n\t\t\tif (!pos) {\n\t\t\t\t/* Malformed hostname starts with '[', but no ']' found */\n\t\t\t\tDEBUG_TRACE(\"%s\", \"Host name format error '[' without ']'\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* terminate after ']' */\n\t\t\tpos[1] = 0;\n\t\t} else {\n\t\t\t/* Otherwise, a ':' separates hostname and port number */\n\t\t\tpos = strchr(host, ':');\n\t\t\tif (pos != NULL) {\n\t\t\t\t*pos = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tif (conn->ssl) {\n\t\t\t/* This is a HTTPS connection, maybe we have a hostname\n\t\t\t * from SNI (set in ssl_servername_callback). */\n\t\t\tconst char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t\t\tif (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {\n\t\t\t\t/* We are not using the default domain */\n\t\t\t\tif (mg_strcasecmp(host, sslhost)) {\n\t\t\t\t\t/* Mismatch between SNI domain and HTTP domain */\n\t\t\t\t\tDEBUG_TRACE(\"Host mismatch: SNI: %s, HTTPS: %s\",\n\t\t\t\t\t            sslhost,\n\t\t\t\t\t            host);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDEBUG_TRACE(\"HTTPS Host: %s\", host);\n\n\t\t} else {\n\t\t\tstruct mg_domain_context *dom = &(conn->phys_ctx->dd);\n\t\t\twhile (dom) {\n\t\t\t\tif (!mg_strcasecmp(host, dom->config[AUTHENTICATION_DOMAIN])) {\n\n\t\t\t\t\t/* Found matching domain */\n\t\t\t\t\tDEBUG_TRACE(\"HTTP domain %s found\",\n\t\t\t\t\t            dom->config[AUTHENTICATION_DOMAIN]);\n\n\t\t\t\t\t/* TODO: Check if this is a HTTP or HTTPS domain */\n\t\t\t\t\tconn->dom_ctx = dom;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdom = dom->next;\n\t\t\t}\n\n\t\t\tDEBUG_TRACE(\"HTTP Host: %s\", host);\n\t\t}\n\n\t} else {\n\t\tsockaddr_to_string(buf, buflen, &conn->client.lsa);\n\t\thost = buf;\n\n\t\tDEBUG_TRACE(\"IP: %s\", host);\n\t}\n\n\treturn mg_strdup_ctx(host, conn->phys_ctx);\n}\n\n\nstatic void\nredirect_to_https_port(struct mg_connection *conn, int ssl_index)\n{\n\tchar target_url[MG_BUF_LEN];\n\tint truncated = 0;\n\n\tconn->must_close = 1;\n\n\t/* Send host, port, uri and (if it exists) ?query_string */\n\tif (conn->host) {\n\n\t\t/* Use \"308 Permanent Redirect\" */\n\t\tint redirect_code = 308;\n\n\t\t/* Create target URL */\n\t\tmg_snprintf(\n\t\t    conn,\n\t\t    &truncated,\n\t\t    target_url,\n\t\t    sizeof(target_url),\n\t\t    \"Location: https://%s:%d%s%s%s\",\n\n\t\t    conn->host,\n#if defined(USE_IPV6)\n\t\t    (conn->phys_ctx->listening_sockets[ssl_index].lsa.sa.sa_family\n\t\t     == AF_INET6)\n\t\t        ? (int)ntohs(conn->phys_ctx->listening_sockets[ssl_index]\n\t\t                         .lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        (int)ntohs(conn->phys_ctx->listening_sockets[ssl_index]\n\t\t                       .lsa.sin.sin_port),\n\t\t    conn->request_info.local_uri,\n\t\t    (conn->request_info.query_string == NULL) ? \"\" : \"?\",\n\t\t    (conn->request_info.query_string == NULL)\n\t\t        ? \"\"\n\t\t        : conn->request_info.query_string);\n\n\t\t/* Check overflow in location buffer (will not occur if MG_BUF_LEN\n\t\t * is used as buffer size) */\n\t\tif (truncated) {\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"Redirect URL too long\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Use redirect helper function */\n\t\tmg_send_http_redirect(conn, target_url, redirect_code);\n\t}\n}\n\n\nstatic void\nhandler_info_acquire(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\thandler_info->refcount++;\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nhandler_info_release(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\thandler_info->refcount--;\n\tpthread_cond_signal(&handler_info->refcount_cond);\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nhandler_info_wait_unused(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\twhile (handler_info->refcount) {\n\t\tpthread_cond_wait(&handler_info->refcount_cond,\n\t\t                  &handler_info->refcount_mutex);\n\t}\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nmg_set_handler_type(struct mg_context *phys_ctx,\n                    struct mg_domain_context *dom_ctx,\n                    const char *uri,\n                    int handler_type,\n                    int is_delete_request,\n                    mg_request_handler handler,\n                    struct mg_websocket_subprotocols *subprotocols,\n                    mg_websocket_connect_handler connect_handler,\n                    mg_websocket_ready_handler ready_handler,\n                    mg_websocket_data_handler data_handler,\n                    mg_websocket_close_handler close_handler,\n                    mg_authorization_handler auth_handler,\n                    void *cbdata)\n{\n\tstruct mg_handler_info *tmp_rh, **lastref;\n\tsize_t urilen = strlen(uri);\n\n\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\tDEBUG_ASSERT(handler == NULL);\n\t\tDEBUG_ASSERT(is_delete_request || connect_handler != NULL\n\t\t             || ready_handler != NULL\n\t\t             || data_handler != NULL\n\t\t             || close_handler != NULL);\n\n\t\tDEBUG_ASSERT(auth_handler == NULL);\n\t\tif (handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (connect_handler == NULL)\n\t\t    && (ready_handler == NULL) && (data_handler == NULL)\n\t\t    && (close_handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (auth_handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t} else if (handler_type == REQUEST_HANDLER) {\n\t\tDEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL\n\t\t             && data_handler == NULL\n\t\t             && close_handler == NULL);\n\t\tDEBUG_ASSERT(is_delete_request || (handler != NULL));\n\t\tDEBUG_ASSERT(auth_handler == NULL);\n\n\t\tif ((connect_handler != NULL) || (ready_handler != NULL)\n\t\t    || (data_handler != NULL) || (close_handler != NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (auth_handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t} else { /* AUTH_HANDLER */\n\t\tDEBUG_ASSERT(handler == NULL);\n\t\tDEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL\n\t\t             && data_handler == NULL\n\t\t             && close_handler == NULL);\n\t\tDEBUG_ASSERT(auth_handler != NULL);\n\t\tif (handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t\tif ((connect_handler != NULL) || (ready_handler != NULL)\n\t\t    || (data_handler != NULL) || (close_handler != NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (auth_handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!phys_ctx || !dom_ctx) {\n\t\treturn;\n\t}\n\n\tmg_lock_context(phys_ctx);\n\n\t/* first try to find an existing handler */\n\tlastref = &(dom_ctx->handlers);\n\tfor (tmp_rh = dom_ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {\n\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\tif ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {\n\t\t\t\tif (!is_delete_request) {\n\t\t\t\t\t/* update existing handler */\n\t\t\t\t\tif (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t/* Wait for end of use before updating */\n\t\t\t\t\t\thandler_info_wait_unused(tmp_rh);\n\n\t\t\t\t\t\t/* Ok, the handler is no more use -> Update it */\n\t\t\t\t\t\ttmp_rh->handler = handler;\n\t\t\t\t\t} else if (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\ttmp_rh->subprotocols = subprotocols;\n\t\t\t\t\t\ttmp_rh->connect_handler = connect_handler;\n\t\t\t\t\t\ttmp_rh->ready_handler = ready_handler;\n\t\t\t\t\t\ttmp_rh->data_handler = data_handler;\n\t\t\t\t\t\ttmp_rh->close_handler = close_handler;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\ttmp_rh->auth_handler = auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\ttmp_rh->cbdata = cbdata;\n\t\t\t\t} else {\n\t\t\t\t\t/* remove existing handler */\n\t\t\t\t\tif (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t/* Wait for end of use before removing */\n\t\t\t\t\t\thandler_info_wait_unused(tmp_rh);\n\n\t\t\t\t\t\t/* Ok, the handler is no more used -> Destroy resources\n\t\t\t\t\t\t */\n\t\t\t\t\t\tpthread_cond_destroy(&tmp_rh->refcount_cond);\n\t\t\t\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t\t\t\t}\n\t\t\t\t\t*lastref = tmp_rh->next;\n\t\t\t\t\tmg_free(tmp_rh->uri);\n\t\t\t\t\tmg_free(tmp_rh);\n\t\t\t\t}\n\t\t\t\tmg_unlock_context(phys_ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlastref = &(tmp_rh->next);\n\t}\n\n\tif (is_delete_request) {\n\t\t/* no handler to set, this was a remove request to a non-existing\n\t\t * handler */\n\t\tmg_unlock_context(phys_ctx);\n\t\treturn;\n\t}\n\n\ttmp_rh =\n\t    (struct mg_handler_info *)mg_calloc_ctx(sizeof(struct mg_handler_info),\n\t                                            1,\n\t                                            phys_ctx);\n\tif (tmp_rh == NULL) {\n\t\tmg_unlock_context(phys_ctx);\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot create new request handler struct, OOM\");\n\t\treturn;\n\t}\n\ttmp_rh->uri = mg_strdup_ctx(uri, phys_ctx);\n\tif (!tmp_rh->uri) {\n\t\tmg_unlock_context(phys_ctx);\n\t\tmg_free(tmp_rh);\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot create new request handler struct, OOM\");\n\t\treturn;\n\t}\n\ttmp_rh->uri_len = urilen;\n\tif (handler_type == REQUEST_HANDLER) {\n\t\t/* Init refcount mutex and condition */\n\t\tif (0 != pthread_mutex_init(&tmp_rh->refcount_mutex, NULL)) {\n\t\t\tmg_unlock_context(phys_ctx);\n\t\t\tmg_free(tmp_rh);\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Cannot init refcount mutex\");\n\t\t\treturn;\n\t\t}\n\t\tif (0 != pthread_cond_init(&tmp_rh->refcount_cond, NULL)) {\n\t\t\tmg_unlock_context(phys_ctx);\n\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t\tmg_free(tmp_rh);\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Cannot init refcount cond\");\n\t\t\treturn;\n\t\t}\n\t\ttmp_rh->refcount = 0;\n\t\ttmp_rh->handler = handler;\n\t} else if (handler_type == WEBSOCKET_HANDLER) {\n\t\ttmp_rh->subprotocols = subprotocols;\n\t\ttmp_rh->connect_handler = connect_handler;\n\t\ttmp_rh->ready_handler = ready_handler;\n\t\ttmp_rh->data_handler = data_handler;\n\t\ttmp_rh->close_handler = close_handler;\n\t} else { /* AUTH_HANDLER */\n\t\ttmp_rh->auth_handler = auth_handler;\n\t}\n\ttmp_rh->cbdata = cbdata;\n\ttmp_rh->handler_type = handler_type;\n\ttmp_rh->next = NULL;\n\n\t*lastref = tmp_rh;\n\tmg_unlock_context(phys_ctx);\n}\n\n\nvoid\nmg_set_request_handler(struct mg_context *ctx,\n                       const char *uri,\n                       mg_request_handler handler,\n                       void *cbdata)\n{\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    REQUEST_HANDLER,\n\t                    handler == NULL,\n\t                    handler,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    cbdata);\n}\n\n\nvoid\nmg_set_websocket_handler(struct mg_context *ctx,\n                         const char *uri,\n                         mg_websocket_connect_handler connect_handler,\n                         mg_websocket_ready_handler ready_handler,\n                         mg_websocket_data_handler data_handler,\n                         mg_websocket_close_handler close_handler,\n                         void *cbdata)\n{\n\tmg_set_websocket_handler_with_subprotocols(ctx,\n\t                                           uri,\n\t                                           NULL,\n\t                                           connect_handler,\n\t                                           ready_handler,\n\t                                           data_handler,\n\t                                           close_handler,\n\t                                           cbdata);\n}\n\n\nvoid\nmg_set_websocket_handler_with_subprotocols(\n    struct mg_context *ctx,\n    const char *uri,\n    struct mg_websocket_subprotocols *subprotocols,\n    mg_websocket_connect_handler connect_handler,\n    mg_websocket_ready_handler ready_handler,\n    mg_websocket_data_handler data_handler,\n    mg_websocket_close_handler close_handler,\n    void *cbdata)\n{\n\tint is_delete_request = (connect_handler == NULL) && (ready_handler == NULL)\n\t                        && (data_handler == NULL)\n\t                        && (close_handler == NULL);\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    WEBSOCKET_HANDLER,\n\t                    is_delete_request,\n\t                    NULL,\n\t                    subprotocols,\n\t                    connect_handler,\n\t                    ready_handler,\n\t                    data_handler,\n\t                    close_handler,\n\t                    NULL,\n\t                    cbdata);\n}\n\n\nvoid\nmg_set_auth_handler(struct mg_context *ctx,\n                    const char *uri,\n                    mg_request_handler handler,\n                    void *cbdata)\n{\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    AUTH_HANDLER,\n\t                    handler == NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    handler,\n\t                    cbdata);\n}\n\n\nstatic int\nget_request_handler(struct mg_connection *conn,\n                    int handler_type,\n                    mg_request_handler *handler,\n                    struct mg_websocket_subprotocols **subprotocols,\n                    mg_websocket_connect_handler *connect_handler,\n                    mg_websocket_ready_handler *ready_handler,\n                    mg_websocket_data_handler *data_handler,\n                    mg_websocket_close_handler *close_handler,\n                    mg_authorization_handler *auth_handler,\n                    void **cbdata,\n                    struct mg_handler_info **handler_info)\n{\n\tconst struct mg_request_info *request_info = mg_get_request_info(conn);\n\tif (request_info) {\n\t\tconst char *uri = request_info->local_uri;\n\t\tsize_t urilen = strlen(uri);\n\t\tstruct mg_handler_info *tmp_rh;\n\n\t\tif (!conn || !conn->phys_ctx || !conn->dom_ctx) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tmg_lock_context(conn->phys_ctx);\n\n\t\t/* first try for an exact match */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* next try for a partial match, we will accept uri/something */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif ((tmp_rh->uri_len < urilen) && (uri[tmp_rh->uri_len] == '/')\n\t\t\t\t    && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* finally try for pattern match */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif (match_prefix(tmp_rh->uri, tmp_rh->uri_len, uri) > 0) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmg_unlock_context(conn->phys_ctx);\n\t}\n\treturn 0; /* none found */\n}\n\n\n/* Check if the script file is in a path, allowed for script files.\n * This can be used if uploading files is possible not only for the server\n * admin, and the upload mechanism does not check the file extension.\n */\nstatic int\nis_in_script_path(const struct mg_connection *conn, const char *path)\n{\n\t/* TODO (Feature): Add config value for allowed script path.\n\t * Default: All allowed. */\n\t(void)conn;\n\t(void)path;\n\treturn 1;\n}\n\n\n#if defined(USE_WEBSOCKET) && defined(MG_LEGACY_INTERFACE)\nstatic int\ndeprecated_websocket_connect_wrapper(const struct mg_connection *conn,\n                                     void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_connect) {\n\t\treturn pcallbacks->websocket_connect(conn);\n\t}\n\t/* No handler set - assume \"OK\" */\n\treturn 0;\n}\n\n\nstatic void\ndeprecated_websocket_ready_wrapper(struct mg_connection *conn, void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_ready) {\n\t\tpcallbacks->websocket_ready(conn);\n\t}\n}\n\n\nstatic int\ndeprecated_websocket_data_wrapper(struct mg_connection *conn,\n                                  int bits,\n                                  char *data,\n                                  size_t len,\n                                  void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_data) {\n\t\treturn pcallbacks->websocket_data(conn, bits, data, len);\n\t}\n\t/* No handler set - assume \"OK\" */\n\treturn 1;\n}\n#endif\n\n\n/* This is the heart of the Civetweb's logic.\n * This function is called when the request is read, parsed and validated,\n * and Civetweb must decide what action to take: serve a file, or\n * a directory, or call embedded function, etcetera. */\nstatic void\nhandle_request(struct mg_connection *conn)\n{\n\tstruct mg_request_info *ri = &conn->request_info;\n\tchar path[PATH_MAX];\n\tint uri_len, ssl_index;\n\tint is_found = 0, is_script_resource = 0, is_websocket_request = 0,\n\t    is_put_or_delete_request = 0, is_callback_resource = 0;\n\tint i;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tmg_request_handler callback_handler = NULL;\n\tstruct mg_handler_info *handler_info = NULL;\n\tstruct mg_websocket_subprotocols *subprotocols;\n\tmg_websocket_connect_handler ws_connect_handler = NULL;\n\tmg_websocket_ready_handler ws_ready_handler = NULL;\n\tmg_websocket_data_handler ws_data_handler = NULL;\n\tmg_websocket_close_handler ws_close_handler = NULL;\n\tvoid *callback_data = NULL;\n\tmg_authorization_handler auth_handler = NULL;\n\tvoid *auth_callback_data = NULL;\n\tint handler_type;\n\ttime_t curtime = time(NULL);\n\tchar date[64];\n\n\tpath[0] = 0;\n\n\t/* 1. get the request url */\n\t/* 1.1. split into url and query string */\n\tif ((conn->request_info.query_string = strchr(ri->request_uri, '?'))\n\t    != NULL) {\n\t\t*((char *)conn->request_info.query_string++) = '\\0';\n\t}\n\n\t/* 1.2. do a https redirect, if required. Do not decode URIs yet. */\n\tif (!conn->client.is_ssl && conn->client.ssl_redir) {\n\t\tssl_index = get_first_ssl_listener_index(conn->phys_ctx);\n\t\tif (ssl_index >= 0) {\n\t\t\tredirect_to_https_port(conn, ssl_index);\n\t\t} else {\n\t\t\t/* A http to https forward port has been specified,\n\t\t\t * but no https port to forward to. */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   503,\n\t\t\t                   \"%s\",\n\t\t\t                   \"Error: SSL forward not configured properly\");\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s\",\n\t\t\t                \"Can not redirect to SSL, no SSL port available\");\n\t\t}\n\t\treturn;\n\t}\n\turi_len = (int)strlen(ri->local_uri);\n\n\t/* 1.3. decode url (if config says so) */\n\tif (should_decode_url(conn)) {\n\t\tmg_url_decode(\n\t\t    ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);\n\t}\n\n\t/* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is\n\t * not possible */\n\tremove_double_dots_and_double_slashes((char *)ri->local_uri);\n\n\t/* step 1. completed, the url is known now */\n\turi_len = (int)strlen(ri->local_uri);\n\tDEBUG_TRACE(\"URL: %s\", ri->local_uri);\n\n\t/* 2. if this ip has limited speed, set it for this connection */\n\tconn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],\n\t                              get_remote_ip(conn),\n\t                              ri->local_uri);\n\n\t/* 3. call a \"handle everything\" callback, if registered */\n\tif (conn->phys_ctx->callbacks.begin_request != NULL) {\n\t\t/* Note that since V1.7 the \"begin_request\" function is called\n\t\t * before an authorization check. If an authorization check is\n\t\t * required, use a request_handler instead. */\n\t\ti = conn->phys_ctx->callbacks.begin_request(conn);\n\t\tif (i > 0) {\n\t\t\t/* callback already processed the request. Store the\n\t\t\t   return value as a status code for the access log. */\n\t\t\tconn->status_code = i;\n\t\t\tdiscard_unread_request_data(conn);\n\t\t\treturn;\n\t\t} else if (i == 0) {\n\t\t\t/* civetweb should process the request */\n\t\t} else {\n\t\t\t/* unspecified - may change with the next version */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* request not yet handled by a handler or redirect, so the request\n\t * is processed here */\n\n\t/* 4. Check for CORS preflight requests and handle them (if configured).\n\t * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\n\t */\n\tif (!strcmp(ri->request_method, \"OPTIONS\")) {\n\t\t/* Send a response to CORS preflights only if\n\t\t * access_control_allow_methods is not NULL and not an empty string.\n\t\t * In this case, scripts can still handle CORS. */\n\t\tconst char *cors_meth_cfg =\n\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];\n\t\tconst char *cors_orig_cfg =\n\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tconst char *cors_origin =\n\t\t    get_header(ri->http_headers, ri->num_headers, \"Origin\");\n\t\tconst char *cors_acrm = get_header(ri->http_headers,\n\t\t                                   ri->num_headers,\n\t\t                                   \"Access-Control-Request-Method\");\n\n\t\t/* Todo: check if cors_origin is in cors_orig_cfg.\n\t\t * Or, let the client check this. */\n\n\t\tif ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0)\n\t\t    && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0)\n\t\t    && (cors_origin != NULL) && (cors_acrm != NULL)) {\n\t\t\t/* This is a valid CORS preflight, and the server is configured\n\t\t\t * to\n\t\t\t * handle it automatically. */\n\t\t\tconst char *cors_acrh =\n\t\t\t    get_header(ri->http_headers,\n\t\t\t               ri->num_headers,\n\t\t\t               \"Access-Control-Request-Headers\");\n\n\t\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\t\tmg_printf(conn,\n\t\t\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t          \"Date: %s\\r\\n\"\n\t\t\t          \"Access-Control-Allow-Origin: %s\\r\\n\"\n\t\t\t          \"Access-Control-Allow-Methods: %s\\r\\n\"\n\t\t\t          \"Content-Length: 0\\r\\n\"\n\t\t\t          \"Connection: %s\\r\\n\",\n\t\t\t          date,\n\t\t\t          cors_orig_cfg,\n\t\t\t          ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),\n\t\t\t          suggest_connection_header(conn));\n\n\t\t\tif (cors_acrh != NULL) {\n\t\t\t\t/* CORS request is asking for additional headers */\n\t\t\t\tconst char *cors_hdr_cfg =\n\t\t\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];\n\n\t\t\t\tif ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {\n\t\t\t\t\t/* Allow only if access_control_allow_headers is\n\t\t\t\t\t * not NULL and not an empty string. If this\n\t\t\t\t\t * configuration is set to *, allow everything.\n\t\t\t\t\t * Otherwise this configuration must be a list\n\t\t\t\t\t * of allowed HTTP header names. */\n\t\t\t\t\tmg_printf(conn,\n\t\t\t\t\t          \"Access-Control-Allow-Headers: %s\\r\\n\",\n\t\t\t\t\t          ((cors_hdr_cfg[0] == '*') ? cors_acrh\n\t\t\t\t\t                                    : cors_hdr_cfg));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg_printf(conn, \"Access-Control-Max-Age: 60\\r\\n\");\n\n\t\t\tmg_printf(conn, \"\\r\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* 5. interpret the url to find out how the request must be handled\n\t */\n\t/* 5.1. first test, if the request targets the regular http(s)://\n\t * protocol namespace or the websocket ws(s):// protocol namespace.\n\t */\n\tis_websocket_request = is_websocket_protocol(conn);\n#if defined(USE_WEBSOCKET)\n\thandler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;\n#else\n\thandler_type = REQUEST_HANDLER;\n#endif /* defined(USE_WEBSOCKET) */\n\t/* 5.2. check if the request will be handled by a callback */\n\tif (get_request_handler(conn,\n\t                        handler_type,\n\t                        &callback_handler,\n\t                        &subprotocols,\n\t                        &ws_connect_handler,\n\t                        &ws_ready_handler,\n\t                        &ws_data_handler,\n\t                        &ws_close_handler,\n\t                        NULL,\n\t                        &callback_data,\n\t                        &handler_info)) {\n\t\t/* 5.2.1. A callback will handle this request. All requests\n\t\t * handled\n\t\t * by a callback have to be considered as requests to a script\n\t\t * resource. */\n\t\tis_callback_resource = 1;\n\t\tis_script_resource = 1;\n\t\tis_put_or_delete_request = is_put_or_delete_method(conn);\n\t} else {\n\tno_callback_resource:\n\n\t\t/* 5.2.2. No callback is responsible for this request. The URI\n\t\t * addresses a file based resource (static content or Lua/cgi\n\t\t * scripts in the file system). */\n\t\tis_callback_resource = 0;\n\t\tinterpret_uri(conn,\n\t\t              path,\n\t\t              sizeof(path),\n\t\t              &file.stat,\n\t\t              &is_found,\n\t\t              &is_script_resource,\n\t\t              &is_websocket_request,\n\t\t              &is_put_or_delete_request);\n\t}\n\n\t/* 6. authorization check */\n\t/* 6.1. a custom authorization handler is installed */\n\tif (get_request_handler(conn,\n\t                        AUTH_HANDLER,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        &auth_handler,\n\t                        &auth_callback_data,\n\t                        NULL)) {\n\t\tif (!auth_handler(conn, auth_callback_data)) {\n\t\t\treturn;\n\t\t}\n\t} else if (is_put_or_delete_request && !is_script_resource\n\t           && !is_callback_resource) {\n/* 6.2. this request is a PUT/DELETE to a real file */\n/* 6.2.1. thus, the server must have real files */\n#if defined(NO_FILES)\n\t\tif (1) {\n#else\n\t\tif (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {\n#endif\n\t\t\t/* This server does not have any real files, thus the\n\t\t\t * PUT/DELETE methods are not valid. */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   405,\n\t\t\t                   \"%s method not allowed\",\n\t\t\t                   conn->request_info.request_method);\n\t\t\treturn;\n\t\t}\n\n#if !defined(NO_FILES)\n\t\t/* 6.2.2. Check if put authorization for static files is\n\t\t * available.\n\t\t */\n\t\tif (!is_authorized_for_put(conn)) {\n\t\t\tsend_authorization_request(conn, NULL);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t} else {\n\t\t/* 6.3. This is either a OPTIONS, GET, HEAD or POST request,\n\t\t * or it is a PUT or DELETE request to a resource that does not\n\t\t * correspond to a file. Check authorization. */\n\t\tif (!check_authorization(conn, path)) {\n\t\t\tsend_authorization_request(conn, NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* request is authorized or does not need authorization */\n\n\t/* 7. check if there are request handlers for this uri */\n\tif (is_callback_resource) {\n\t\tif (!is_websocket_request) {\n\t\t\ti = callback_handler(conn, callback_data);\n\n\t\t\t/* Callback handler will not be used anymore. Release it */\n\t\t\thandler_info_release(handler_info);\n\n\t\t\tif (i > 0) {\n\t\t\t\t/* Do nothing, callback has served the request. Store\n\t\t\t\t * then return value as status code for the log and discard\n\t\t\t\t * all data from the client not used by the callback. */\n\t\t\t\tconn->status_code = i;\n\t\t\t\tdiscard_unread_request_data(conn);\n\t\t\t} else {\n\t\t\t\t/* The handler did NOT handle the request. */\n\t\t\t\t/* Some proper reactions would be:\n\t\t\t\t * a) close the connections without sending anything\n\t\t\t\t * b) send a 404 not found\n\t\t\t\t * c) try if there is a file matching the URI\n\t\t\t\t * It would be possible to do a, b or c in the callback\n\t\t\t\t * implementation, and return 1 - we cannot do anything\n\t\t\t\t * here, that is not possible in the callback.\n\t\t\t\t *\n\t\t\t\t * TODO: What would be the best reaction here?\n\t\t\t\t * (Note: The reaction may change, if there is a better\n\t\t\t\t *idea.)\n\t\t\t\t */\n\n\t\t\t\t/* For the moment, use option c: We look for a proper file,\n\t\t\t\t * but since a file request is not always a script resource,\n\t\t\t\t * the authorization check might be different. */\n\t\t\t\tinterpret_uri(conn,\n\t\t\t\t              path,\n\t\t\t\t              sizeof(path),\n\t\t\t\t              &file.stat,\n\t\t\t\t              &is_found,\n\t\t\t\t              &is_script_resource,\n\t\t\t\t              &is_websocket_request,\n\t\t\t\t              &is_put_or_delete_request);\n\t\t\t\tcallback_handler = NULL;\n\n\t\t\t\t/* Here we are at a dead end:\n\t\t\t\t * According to URI matching, a callback should be\n\t\t\t\t * responsible for handling the request,\n\t\t\t\t * we called it, but the callback declared itself\n\t\t\t\t * not responsible.\n\t\t\t\t * We use a goto here, to get out of this dead end,\n\t\t\t\t * and continue with the default handling.\n\t\t\t\t * A goto here is simpler and better to understand\n\t\t\t\t * than some curious loop. */\n\t\t\t\tgoto no_callback_resource;\n\t\t\t}\n\t\t} else {\n#if defined(USE_WEBSOCKET)\n\t\t\thandle_websocket_request(conn,\n\t\t\t                         path,\n\t\t\t                         is_callback_resource,\n\t\t\t                         subprotocols,\n\t\t\t                         ws_connect_handler,\n\t\t\t                         ws_ready_handler,\n\t\t\t                         ws_data_handler,\n\t\t\t                         ws_close_handler,\n\t\t\t                         callback_data);\n#endif\n\t\t}\n\t\treturn;\n\t}\n\n/* 8. handle websocket requests */\n#if defined(USE_WEBSOCKET)\n\tif (is_websocket_request) {\n\t\tif (is_script_resource) {\n\n\t\t\tif (is_in_script_path(conn, path)) {\n\t\t\t\t/* Websocket Lua script */\n\t\t\t\thandle_websocket_request(conn,\n\t\t\t\t                         path,\n\t\t\t\t                         0 /* Lua Script */,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         conn->phys_ctx->user_data);\n\t\t\t} else {\n\t\t\t\t/* Script was in an illegal path */\n\t\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t\t}\n\t\t} else {\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\thandle_websocket_request(\n\t\t\t    conn,\n\t\t\t    path,\n\t\t\t    !is_script_resource /* could be deprecated global callback */,\n\t\t\t    NULL,\n\t\t\t    deprecated_websocket_connect_wrapper,\n\t\t\t    deprecated_websocket_ready_wrapper,\n\t\t\t    deprecated_websocket_data_wrapper,\n\t\t\t    NULL,\n\t\t\t    conn->phys_ctx->user_data);\n#else\n\t\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n#endif\n\t\t}\n\t\treturn;\n\t} else\n#endif\n\n#if defined(NO_FILES)\n\t\t/* 9a. In case the server uses only callbacks, this uri is\n\t\t * unknown.\n\t\t * Then, all request handling ends here. */\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not Found\");\n\n#else\n\t/* 9b. This request is either for a static file or resource handled\n\t * by a script file. Thus, a DOCUMENT_ROOT must exist. */\n\tif (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not Found\");\n\t\treturn;\n\t}\n\n\t/* 10. Request is handled by a script */\n\tif (is_script_resource) {\n\t\thandle_file_based_request(conn, path, &file);\n\t\treturn;\n\t}\n\n\t/* 11. Handle put/delete/mkcol requests */\n\tif (is_put_or_delete_request) {\n\t\t/* 11.1. PUT method */\n\t\tif (!strcmp(ri->request_method, \"PUT\")) {\n\t\t\tput_file(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.2. DELETE method */\n\t\tif (!strcmp(ri->request_method, \"DELETE\")) {\n\t\t\tdelete_file(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.3. MKCOL method */\n\t\tif (!strcmp(ri->request_method, \"MKCOL\")) {\n\t\t\tmkcol(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.4. PATCH method\n\t\t * This method is not supported for static resources,\n\t\t * only for scripts (Lua, CGI) and callbacks. */\n\t\tmg_send_http_error(conn,\n\t\t                   405,\n\t\t                   \"%s method not allowed\",\n\t\t                   conn->request_info.request_method);\n\t\treturn;\n\t}\n\n\t/* 11. File does not exist, or it was configured that it should be\n\t * hidden */\n\tif (!is_found || (must_hide_file(conn, path))) {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n\t\treturn;\n\t}\n\n\t/* 12. Directory uris should end with a slash */\n\tif (file.stat.is_directory && (uri_len > 0)\n\t    && (ri->local_uri[uri_len - 1] != '/')) {\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n\t\t          \"Location: %s/\\r\\n\"\n\t\t          \"Date: %s\\r\\n\"\n\t\t          /* \"Cache-Control: private\\r\\n\" (= default) */\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\",\n\t\t          ri->request_uri,\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn, \"\\r\\n\");\n\t\treturn;\n\t}\n\n\t/* 13. Handle other methods than GET/HEAD */\n\t/* 13.1. Handle PROPFIND */\n\tif (!strcmp(ri->request_method, \"PROPFIND\")) {\n\t\thandle_propfind(conn, path, &file.stat);\n\t\treturn;\n\t}\n\t/* 13.2. Handle OPTIONS for files */\n\tif (!strcmp(ri->request_method, \"OPTIONS\")) {\n\t\t/* This standard handler is only used for real files.\n\t\t * Scripts should support the OPTIONS method themselves, to allow a\n\t\t * maximum flexibility.\n\t\t * Lua and CGI scripts may fully support CORS this way (including\n\t\t * preflights). */\n\t\tsend_options(conn);\n\t\treturn;\n\t}\n\t/* 13.3. everything but GET and HEAD (e.g. POST) */\n\tif ((0 != strcmp(ri->request_method, \"GET\"))\n\t    && (0 != strcmp(ri->request_method, \"HEAD\"))) {\n\t\tmg_send_http_error(conn,\n\t\t                   405,\n\t\t                   \"%s method not allowed\",\n\t\t                   conn->request_info.request_method);\n\t\treturn;\n\t}\n\n\t/* 14. directories */\n\tif (file.stat.is_directory) {\n\t\t/* Substitute files have already been handled above. */\n\t\t/* Here we can either generate and send a directory listing,\n\t\t * or send an \"access denied\" error. */\n\t\tif (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t\t                   \"yes\")) {\n\t\t\thandle_directory_request(conn, path);\n\t\t} else {\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   403,\n\t\t\t                   \"%s\",\n\t\t\t                   \"Error: Directory listing denied\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/* 15. read a normal file with GET or HEAD */\n\thandle_file_based_request(conn, path, &file);\n#endif /* !defined(NO_FILES) */\n}\n\n\nstatic void\nhandle_file_based_request(struct mg_connection *conn,\n                          const char *path,\n                          struct mg_file *file)\n{\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tif (0) {\n#if defined(USE_LUA)\n\t} else if (match_prefix(\n\t               conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],\n\t               strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS]),\n\t               path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Lua server page: an SSI like page containing mostly plain\n\t\t\t * html\n\t\t\t * code\n\t\t\t * plus some tags with server generated contents. */\n\t\t\thandle_lsp_request(conn, path, file, NULL);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n\n\t} else if (match_prefix(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],\n\t                        strlen(\n\t                            conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS]),\n\t                        path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Lua in-server module script: a CGI like script used to\n\t\t\t * generate\n\t\t\t * the\n\t\t\t * entire reply. */\n\t\t\tmg_exec_lua_script(conn, path, NULL);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif\n#if defined(USE_DUKTAPE)\n\t} else if (match_prefix(\n\t               conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],\n\t               strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),\n\t               path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Call duktape to generate the page */\n\t\t\tmg_exec_duktape_script(conn, path);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif\n#if !defined(NO_CGI)\n\t} else if (match_prefix(conn->dom_ctx->config[CGI_EXTENSIONS],\n\t                        strlen(conn->dom_ctx->config[CGI_EXTENSIONS]),\n\t                        path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* CGI scripts may support all HTTP methods */\n\t\t\thandle_cgi_request(conn, path);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif /* !NO_CGI */\n\t} else if (match_prefix(conn->dom_ctx->config[SSI_EXTENSIONS],\n\t                        strlen(conn->dom_ctx->config[SSI_EXTENSIONS]),\n\t                        path) > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\thandle_ssi_file_request(conn, path, file);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#if !defined(NO_CACHING)\n\t} else if ((!conn->in_error_handler)\n\t           && is_not_modified(conn, &file->stat)) {\n\t\t/* Send 304 \"Not Modified\" - this must not send any body data */\n\t\thandle_not_modified_static_file_request(conn, file);\n#endif /* !NO_CACHING */\n\t} else {\n\t\thandle_static_file_request(conn, path, file, NULL, NULL);\n\t}\n}\n\n\nstatic void\nclose_all_listening_sockets(struct mg_context *ctx)\n{\n\tunsigned int i;\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\tclosesocket(ctx->listening_sockets[i].sock);\n\t\tctx->listening_sockets[i].sock = INVALID_SOCKET;\n\t}\n\tmg_free(ctx->listening_sockets);\n\tctx->listening_sockets = NULL;\n\tmg_free(ctx->listening_socket_fds);\n\tctx->listening_socket_fds = NULL;\n}\n\n\n/* Valid listening port specification is: [ip_address:]port[s]\n * Examples for IPv4: 80, 443s, 127.0.0.1:3128, 192.0.2.3:8080s\n * Examples for IPv6: [::]:80, [::1]:80,\n *   [2001:0db8:7654:3210:FEDC:BA98:7654:3210]:443s\n *   see https://tools.ietf.org/html/rfc3513#section-2.2\n * In order to bind to both, IPv4 and IPv6, you can either add\n * both ports using 8080,[::]:8080, or the short form +8080.\n * Both forms differ in detail: 8080,[::]:8080 create two sockets,\n * one only accepting IPv4 the other only IPv6. +8080 creates\n * one socket accepting IPv4 and IPv6. Depending on the IPv6\n * environment, they might work differently, or might not work\n * at all - it must be tested what options work best in the\n * relevant network environment.\n */\nstatic int\nparse_port_string(const struct vec *vec, struct socket *so, int *ip_version)\n{\n\tunsigned int a, b, c, d, port;\n\tint ch, len;\n\tconst char *cb;\n#if defined(USE_IPV6)\n\tchar buf[100] = {0};\n#endif\n\n\t/* MacOS needs that. If we do not zero it, subsequent bind() will fail.\n\t * Also, all-zeroes in the socket address means binding to all addresses\n\t * for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT). */\n\tmemset(so, 0, sizeof(*so));\n\tso->lsa.sin.sin_family = AF_INET;\n\t*ip_version = 0;\n\n\t/* Initialize port and len as invalid. */\n\tport = 0;\n\tlen = 0;\n\n\t/* Test for different ways to format this string */\n\tif (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len)\n\t    == 5) {\n\t\t/* Bind to a specific IPv4 address, e.g. 192.168.1.5:8080 */\n\t\tso->lsa.sin.sin_addr.s_addr =\n\t\t    htonl((a << 24) | (b << 16) | (c << 8) | d);\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n#if defined(USE_IPV6)\n\t} else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2\n\t           && mg_inet_pton(\n\t                  AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6))) {\n\t\t/* IPv6 address, examples: see above */\n\t\t/* so->lsa.sin6.sin6_family = AF_INET6; already set by mg_inet_pton\n\t\t */\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 6;\n#endif\n\n\t} else if ((vec->ptr[0] == '+')\n\t           && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len) == 1)) {\n\n\t\t/* Port is specified with a +, bind to IPv6 and IPv4, INADDR_ANY */\n\t\t/* Add 1 to len for the + character we skipped before */\n\t\tlen++;\n\n#if defined(USE_IPV6)\n\t\t/* Set socket family to IPv6, do not use IPV6_V6ONLY */\n\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 4 + 6;\n#else\n\t\t/* Bind to IPv4 only, since IPv6 is not built in. */\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n#endif\n\n\t} else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {\n\t\t/* If only port is specified, bind to IPv4, INADDR_ANY */\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n\t} else if ((cb = strchr(vec->ptr, ':')) != NULL) {\n\t\t/* String could be a hostname. This check algotithm\n\t\t * will only work for RFC 952 compliant hostnames,\n\t\t * starting with a letter, containing only letters,\n\t\t * digits and hyphen ('-'). Newer specs may allow\n\t\t * more, but this is not guaranteed here, since it\n\t\t * may interfere with rules for port option lists. */\n\n\t\t/* According to RFC 1035, hostnames are restricted to 255 characters\n\t\t * in total (63 between two dots). */\n\t\tchar hostname[256];\n\t\tsize_t hostnlen = (size_t)(cb - vec->ptr);\n\n\t\tif (hostnlen >= sizeof(hostname)) {\n\t\t\t/* This would be invalid in any case */\n\t\t\t*ip_version = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemcpy(hostname, vec->ptr, hostnlen);\n\t\thostname[hostnlen] = 0;\n\n\t\tif (mg_inet_pton(\n\t\t        AF_INET, vec->ptr, &so->lsa.sin, sizeof(so->lsa.sin))) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 4;\n\t\t\t\tso->lsa.sin.sin_family = AF_INET;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tport = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#if defined(USE_IPV6)\n\t\t} else if (mg_inet_pton(AF_INET6,\n\t\t                        vec->ptr,\n\t\t                        &so->lsa.sin6,\n\t\t                        sizeof(so->lsa.sin6))) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 6;\n\t\t\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tport = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t} else {\n\t\t/* Parsing failure. */\n\t}\n\n\t/* sscanf and the option splitting code ensure the following condition\n\t */\n\tif ((len < 0) && ((unsigned)len > (unsigned)vec->len)) {\n\t\t*ip_version = 0;\n\t\treturn 0;\n\t}\n\tch = vec->ptr[len]; /* Next character after the port number */\n\tso->is_ssl = (ch == 's');\n\tso->ssl_redir = (ch == 'r');\n\n\t/* Make sure the port is valid and vector ends with 's', 'r' or ',' */\n\tif (is_valid_port(port)\n\t    && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {\n\t\treturn 1;\n\t}\n\n\t/* Reset ip_version to 0 if there is an error */\n\t*ip_version = 0;\n\treturn 0;\n}\n\n\n/* Is there any SSL port in use? */\nstatic int\nis_ssl_port_used(const char *ports)\n{\n\tif (ports) {\n\t\t/* There are several different allowed syntax variants:\n\t\t * - \"80\" for a single port using every network interface\n\t\t * - \"localhost:80\" for a single port using only localhost\n\t\t * - \"80,localhost:8080\" for two ports, one bound to localhost\n\t\t * - \"80,127.0.0.1:8084,[::1]:8086\" for three ports, one bound\n\t\t *   to IPv4 localhost, one to IPv6 localhost\n\t\t * - \"+80\" use port 80 for IPv4 and IPv6\n\t\t * - \"+80r,+443s\" port 80 (HTTP) is a redirect to port 443 (HTTPS),\n\t\t *   for both: IPv4 and IPv4\n\t\t * - \"+443s,localhost:8080\" port 443 (HTTPS) for every interface,\n\t\t *   additionally port 8080 bound to localhost connections\n\t\t *\n\t\t * If we just look for 's' anywhere in the string, \"localhost:80\"\n\t\t * will be detected as SSL (false positive).\n\t\t * Looking for 's' after a digit may cause false positives in\n\t\t * \"my24service:8080\".\n\t\t * Looking from 's' backward if there are only ':' and numbers\n\t\t * before will not work for \"24service:8080\" (non SSL, port 8080)\n\t\t * or \"24s\" (SSL, port 24).\n\t\t *\n\t\t * Remark: Initially hostnames were not allowed to start with a\n\t\t * digit (according to RFC 952), this was allowed later (RFC 1123,\n\t\t * Section 2.1).\n\t\t *\n\t\t * To get this correct, the entire string must be parsed as a whole,\n\t\t * reading it as a list element for element and parsing with an\n\t\t * algorithm equivalent to parse_port_string.\n\t\t *\n\t\t * In fact, we use local interface names here, not arbitrary hostnames,\n\t\t * so in most cases the only name will be \"localhost\".\n\t\t *\n\t\t * So, for now, we use this simple algorithm, that may still return\n\t\t * a false positive in bizarre cases.\n\t\t */\n\t\tint i;\n\t\tint portslen = (int)strlen(ports);\n\t\tchar prevIsNumber = 0;\n\n\t\tfor (i = 0; i < portslen; i++) {\n\t\t\tif (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (ports[i] >= '0' && ports[i] <= '9') {\n\t\t\t\tprevIsNumber = 1;\n\t\t\t} else {\n\t\t\t\tprevIsNumber = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_ports_option(struct mg_context *phys_ctx)\n{\n\tconst char *list;\n\tint on = 1;\n#if defined(USE_IPV6)\n\tint off = 0;\n#endif\n\tstruct vec vec;\n\tstruct socket so, *ptr;\n\n\tstruct pollfd *pfd;\n\tunion usa usa;\n\tsocklen_t len;\n\tint ip_version;\n\n\tint portsTotal = 0;\n\tint portsOk = 0;\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&so, 0, sizeof(so));\n\tmemset(&usa, 0, sizeof(usa));\n\tlen = sizeof(usa);\n\tlist = phys_ctx->dd.config[LISTENING_PORTS];\n\n\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\n\t\tportsTotal++;\n\n\t\tif (!parse_port_string(&vec, &so, &ip_version)) {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"%.*s: invalid port spec (entry %i). Expecting list of: %s\",\n\t\t\t    (int)vec.len,\n\t\t\t    vec.ptr,\n\t\t\t    portsTotal,\n\t\t\t    \"[IP_ADDRESS:]PORT[s|r]\");\n\t\t\tcontinue;\n\t\t}\n\n#if !defined(NO_SSL)\n\t\tif (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"Cannot add SSL socket (entry %i)\",\n\t\t\t                portsTotal);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6))\n\t\t    == INVALID_SOCKET) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot create socket (entry %i)\",\n\t\t\t                portsTotal);\n\t\t\tcontinue;\n\t\t}\n\n#if defined(_WIN32)\n\t\t/* Windows SO_REUSEADDR lets many procs binds to a\n\t\t * socket, SO_EXCLUSIVEADDRUSE makes the bind fail\n\t\t * if someone already has the socket -- DTL */\n\t\t/* NOTE: If SO_EXCLUSIVEADDRUSE is used,\n\t\t * Windows might need a few seconds before\n\t\t * the same port can be used again in the\n\t\t * same process, so a short Sleep may be\n\t\t * required between mg_stop and mg_start.\n\t\t */\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_EXCLUSIVEADDRUSE,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on)) != 0) {\n\n\t\t\t/* Set reuse option, but don't abort on errors. */\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)\",\n\t\t\t    portsTotal);\n\t\t}\n#else\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_REUSEADDR,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on)) != 0) {\n\n\t\t\t/* Set reuse option, but don't abort on errors. */\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot set socket option SO_REUSEADDR (entry %i)\",\n\t\t\t                portsTotal);\n\t\t}\n#endif\n\n\t\tif (ip_version > 4) {\n/* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */\n#if defined(USE_IPV6)\n\t\t\tif (ip_version > 6) {\n\t\t\t\tif (so.lsa.sa.sa_family == AF_INET6\n\t\t\t\t    && setsockopt(so.sock,\n\t\t\t\t                  IPPROTO_IPV6,\n\t\t\t\t                  IPV6_V6ONLY,\n\t\t\t\t                  (void *)&off,\n\t\t\t\t                  sizeof(off)) != 0) {\n\n\t\t\t\t\t/* Set IPv6 only option, but don't abort on errors. */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    fc(phys_ctx),\n\t\t\t\t\t    \"cannot set socket option IPV6_V6ONLY=off (entry %i)\",\n\t\t\t\t\t    portsTotal);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (so.lsa.sa.sa_family == AF_INET6\n\t\t\t\t    && setsockopt(so.sock,\n\t\t\t\t                  IPPROTO_IPV6,\n\t\t\t\t                  IPV6_V6ONLY,\n\t\t\t\t                  (void *)&on,\n\t\t\t\t                  sizeof(on)) != 0) {\n\n\t\t\t\t\t/* Set IPv6 only option, but don't abort on errors. */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    fc(phys_ctx),\n\t\t\t\t\t    \"cannot set socket option IPV6_V6ONLY=on (entry %i)\",\n\t\t\t\t\t    portsTotal);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"IPv6 not available\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tif (so.lsa.sa.sa_family == AF_INET) {\n\n\t\t\tlen = sizeof(so.lsa.sin);\n\t\t\tif (bind(so.sock, &so.lsa.sa, len) != 0) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"cannot bind to %.*s: %d (%s)\",\n\t\t\t\t                (int)vec.len,\n\t\t\t\t                vec.ptr,\n\t\t\t\t                (int)ERRNO,\n\t\t\t\t                strerror(errno));\n\t\t\t\tclosesocket(so.sock);\n\t\t\t\tso.sock = INVALID_SOCKET;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#if defined(USE_IPV6)\n\t\telse if (so.lsa.sa.sa_family == AF_INET6) {\n\n\t\t\tlen = sizeof(so.lsa.sin6);\n\t\t\tif (bind(so.sock, &so.lsa.sa, len) != 0) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"cannot bind to IPv6 %.*s: %d (%s)\",\n\t\t\t\t                (int)vec.len,\n\t\t\t\t                vec.ptr,\n\t\t\t\t                (int)ERRNO,\n\t\t\t\t                strerror(errno));\n\t\t\t\tclosesocket(so.sock);\n\t\t\t\tso.sock = INVALID_SOCKET;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\telse {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"cannot bind: address family not supported (entry %i)\",\n\t\t\t    portsTotal);\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (listen(so.sock, SOMAXCONN) != 0) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot listen to %.*s: %d (%s)\",\n\t\t\t                (int)vec.len,\n\t\t\t                vec.ptr,\n\t\t\t                (int)ERRNO,\n\t\t\t                strerror(errno));\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((getsockname(so.sock, &(usa.sa), &len) != 0)\n\t\t    || (usa.sa.sa_family != so.lsa.sa.sa_family)) {\n\n\t\t\tint err = (int)ERRNO;\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"call to getsockname failed %.*s: %d (%s)\",\n\t\t\t                (int)vec.len,\n\t\t\t                vec.ptr,\n\t\t\t                err,\n\t\t\t                strerror(errno));\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n/* Update lsa port in case of random free ports */\n#if defined(USE_IPV6)\n\t\tif (so.lsa.sa.sa_family == AF_INET6) {\n\t\t\tso.lsa.sin6.sin6_port = usa.sin6.sin6_port;\n\t\t} else\n#endif\n\t\t{\n\t\t\tso.lsa.sin.sin_port = usa.sin.sin_port;\n\t\t}\n\n\t\tif ((ptr = (struct socket *)\n\t\t         mg_realloc_ctx(phys_ctx->listening_sockets,\n\t\t                        (phys_ctx->num_listening_sockets + 1)\n\t\t                            * sizeof(phys_ctx->listening_sockets[0]),\n\t\t                        phys_ctx)) == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Out of memory\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pfd = (struct pollfd *)\n\t\t         mg_realloc_ctx(phys_ctx->listening_socket_fds,\n\t\t                        (phys_ctx->num_listening_sockets + 1)\n\t\t                            * sizeof(phys_ctx->listening_socket_fds[0]),\n\t\t                        phys_ctx)) == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Out of memory\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tmg_free(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_close_on_exec(so.sock, fc(phys_ctx));\n\t\tphys_ctx->listening_sockets = ptr;\n\t\tphys_ctx->listening_sockets[phys_ctx->num_listening_sockets] = so;\n\t\tphys_ctx->listening_socket_fds = pfd;\n\t\tphys_ctx->num_listening_sockets++;\n\t\tportsOk++;\n\t}\n\n\tif (portsOk != portsTotal) {\n\t\tclose_all_listening_sockets(phys_ctx);\n\t\tportsOk = 0;\n\t}\n\n\treturn portsOk;\n}\n\n\nstatic const char *\nheader_val(const struct mg_connection *conn, const char *header)\n{\n\tconst char *header_value;\n\n\tif ((header_value = mg_get_header(conn, header)) == NULL) {\n\t\treturn \"-\";\n\t} else {\n\t\treturn header_value;\n\t}\n}\n\n\n#if defined(MG_EXTERNAL_FUNCTION_log_access)\nstatic void log_access(const struct mg_connection *conn);\n#include \"external_log_access.inl\"\n#else\n\nstatic void\nlog_access(const struct mg_connection *conn)\n{\n\tconst struct mg_request_info *ri;\n\tstruct mg_file fi;\n\tchar date[64], src_addr[IP_ADDR_STR_LEN];\n\tstruct tm *tm;\n\n\tconst char *referer;\n\tconst char *user_agent;\n\n\tchar buf[4096];\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tif (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {\n\t\tif (mg_fopen(conn,\n\t\t             conn->dom_ctx->config[ACCESS_LOG_FILE],\n\t\t             MG_FOPEN_MODE_APPEND,\n\t\t             &fi) == 0) {\n\t\t\tfi.access.fp = NULL;\n\t\t}\n\t} else {\n\t\tfi.access.fp = NULL;\n\t}\n\n\t/* Log is written to a file and/or a callback. If both are not set,\n\t * executing the rest of the function is pointless. */\n\tif ((fi.access.fp == NULL)\n\t    && (conn->phys_ctx->callbacks.log_access == NULL)) {\n\t\treturn;\n\t}\n\n\ttm = localtime(&conn->conn_birth_time);\n\tif (tm != NULL) {\n\t\tstrftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\", tm);\n\t} else {\n\t\tmg_strlcpy(date, \"01/Jan/1970:00:00:00 +0000\", sizeof(date));\n\t\tdate[sizeof(date) - 1] = '\\0';\n\t}\n\n\tri = &conn->request_info;\n\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\treferer = header_val(conn, \"Referer\");\n\tuser_agent = header_val(conn, \"User-Agent\");\n\n\tmg_snprintf(conn,\n\t            NULL, /* Ignore truncation in access log */\n\t            buf,\n\t            sizeof(buf),\n\t            \"%s - %s [%s] \\\"%s %s%s%s HTTP/%s\\\" %d %\" INT64_FMT \" %s %s\",\n\t            src_addr,\n\t            (ri->remote_user == NULL) ? \"-\" : ri->remote_user,\n\t            date,\n\t            ri->request_method ? ri->request_method : \"-\",\n\t            ri->request_uri ? ri->request_uri : \"-\",\n\t            ri->query_string ? \"?\" : \"\",\n\t            ri->query_string ? ri->query_string : \"\",\n\t            ri->http_version,\n\t            conn->status_code,\n\t            conn->num_bytes_sent,\n\t            referer,\n\t            user_agent);\n\n\tif (conn->phys_ctx->callbacks.log_access) {\n\t\tconn->phys_ctx->callbacks.log_access(conn, buf);\n\t}\n\n\tif (fi.access.fp) {\n\t\tint ok = 1;\n\t\tflockfile(fi.access.fp);\n\t\tif (fprintf(fi.access.fp, \"%s\\n\", buf) < 1) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (fflush(fi.access.fp) != 0) {\n\t\t\tok = 0;\n\t\t}\n\t\tfunlockfile(fi.access.fp);\n\t\tif (mg_fclose(&fi.access) != 0) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (!ok) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error writing log file %s\",\n\t\t\t                conn->dom_ctx->config[ACCESS_LOG_FILE]);\n\t\t}\n\t}\n}\n\n#endif /* Externally provided function */\n\n\n/* Verify given socket address against the ACL.\n * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.\n */\nstatic int\ncheck_acl(struct mg_context *phys_ctx, uint32_t remote_ip)\n{\n\tint allowed, flag;\n\tuint32_t net, mask;\n\tstruct vec vec;\n\n\tif (phys_ctx) {\n\t\tconst char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];\n\n\t\t/* If any ACL is set, deny by default */\n\t\tallowed = (list == NULL) ? '+' : '-';\n\n\t\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\t\t\tflag = vec.ptr[0];\n\t\t\tif ((flag != '+' && flag != '-')\n\t\t\t    || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: subnet must be [+|-]x.x.x.x[/x]\",\n\t\t\t\t                __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (net == (remote_ip & mask)) {\n\t\t\t\tallowed = flag;\n\t\t\t}\n\t\t}\n\n\t\treturn allowed == '+';\n\t}\n\treturn -1;\n}\n\n\n#if !defined(_WIN32)\nstatic int\nset_uid_option(struct mg_context *phys_ctx)\n{\n\tint success = 0;\n\n\tif (phys_ctx) {\n\t\t/* We are currently running as curr_uid. */\n\t\tconst uid_t curr_uid = getuid();\n\t\t/* If set, we want to run as run_as_user. */\n\t\tconst char *run_as_user = phys_ctx->dd.config[RUN_AS_USER];\n\t\tconst struct passwd *to_pw = NULL;\n\n\t\tif (run_as_user != NULL && (to_pw = getpwnam(run_as_user)) == NULL) {\n\t\t\t/* run_as_user does not exist on the system. We can't proceed\n\t\t\t * further. */\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"%s: unknown user [%s]\",\n\t\t\t                __func__,\n\t\t\t                run_as_user);\n\t\t} else if (run_as_user == NULL || curr_uid == to_pw->pw_uid) {\n\t\t\t/* There was either no request to change user, or we're already\n\t\t\t * running as run_as_user. Nothing else to do.\n\t\t\t */\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* Valid change request.  */\n\t\t\tif (setgid(to_pw->pw_gid) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setgid(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                run_as_user,\n\t\t\t\t                strerror(errno));\n\t\t\t} else if (setgroups(0, NULL) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setgroups(): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                strerror(errno));\n\t\t\t} else if (setuid(to_pw->pw_uid) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setuid(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                run_as_user,\n\t\t\t\t                strerror(errno));\n\t\t\t} else {\n\t\t\t\tsuccess = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn success;\n}\n#endif /* !_WIN32 */\n\n\nstatic void\ntls_dtor(void *key)\n{\n\tstruct mg_workerTLS *tls = (struct mg_workerTLS *)key;\n\t/* key == pthread_getspecific(sTlsKey); */\n\n\tif (tls) {\n\t\tif (tls->is_master == 2) {\n\t\t\ttls->is_master = -3; /* Mark memory as dead */\n\t\t\tmg_free(tls);\n\t\t}\n\t}\n\tpthread_setspecific(sTlsKey, NULL);\n}\n\n\n#if !defined(NO_SSL)\n\nstatic int ssl_use_pem_file(struct mg_context *phys_ctx,\n                            struct mg_domain_context *dom_ctx,\n                            const char *pem,\n                            const char *chain);\nstatic const char *ssl_error(void);\n\n\nstatic int\nrefresh_trust(struct mg_connection *conn)\n{\n\tstatic int reload_lock = 0;\n\tstatic long int data_check = 0;\n\tvolatile int *p_reload_lock = (volatile int *)&reload_lock;\n\n\tstruct stat cert_buf;\n\tlong int t;\n\tconst char *pem;\n\tconst char *chain;\n\tint should_verify_peer;\n\n\tif ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {\n\t\t/* If peem is NULL and conn->phys_ctx->callbacks.init_ssl is not,\n\t\t * refresh_trust still can not work. */\n\t\treturn 0;\n\t}\n\tchain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];\n\tif (chain == NULL) {\n\t\t/* pem is not NULL here */\n\t\tchain = pem;\n\t}\n\tif (*chain == 0) {\n\t\tchain = NULL;\n\t}\n\n\tt = data_check;\n\tif (stat(pem, &cert_buf) != -1) {\n\t\tt = (long int)cert_buf.st_mtime;\n\t}\n\n\tif (data_check != t) {\n\t\tdata_check = t;\n\n\t\tshould_verify_peer = 0;\n\t\tif (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {\n\t\t\tif (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], \"yes\")\n\t\t\t    == 0) {\n\t\t\t\tshould_verify_peer = 1;\n\t\t\t} else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],\n\t\t\t                         \"optional\") == 0) {\n\t\t\t\tshould_verify_peer = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (should_verify_peer) {\n\t\t\tchar *ca_path = conn->dom_ctx->config[SSL_CA_PATH];\n\t\t\tchar *ca_file = conn->dom_ctx->config[SSL_CA_FILE];\n\t\t\tif (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,\n\t\t\t                                  ca_file,\n\t\t\t                                  ca_path) != 1) {\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    fc(conn->phys_ctx),\n\t\t\t\t    \"SSL_CTX_load_verify_locations error: %s \"\n\t\t\t\t    \"ssl_verify_peer requires setting \"\n\t\t\t\t    \"either ssl_ca_path or ssl_ca_file. Is any of them \"\n\t\t\t\t    \"present in \"\n\t\t\t\t    \"the .conf file?\",\n\t\t\t\t    ssl_error());\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (1 == mg_atomic_inc(p_reload_lock)) {\n\t\t\tif (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain)\n\t\t\t    == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*p_reload_lock = 0;\n\t\t}\n\t}\n\t/* lock while cert is reloading */\n\twhile (*p_reload_lock) {\n\t\tsleep(1);\n\t}\n\n\treturn 1;\n}\n\n#if defined(OPENSSL_API_1_1)\n#else\nstatic pthread_mutex_t *ssl_mutexes;\n#endif /* OPENSSL_API_1_1 */\n\nstatic int\nsslize(struct mg_connection *conn,\n       SSL_CTX *s,\n       int (*func)(SSL *),\n       volatile int *stop_server)\n{\n\tint ret, err;\n\tint short_trust;\n\tunsigned i;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tshort_trust =\n\t    (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL)\n\t    && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], \"yes\") == 0);\n\n\tif (short_trust) {\n\t\tint trust_ret = refresh_trust(conn);\n\t\tif (!trust_ret) {\n\t\t\treturn trust_ret;\n\t\t}\n\t}\n\n\tconn->ssl = SSL_new(s);\n\tif (conn->ssl == NULL) {\n\t\treturn 0;\n\t}\n\tSSL_set_app_data(conn->ssl, (char *)conn);\n\n\tret = SSL_set_fd(conn->ssl, conn->client.sock);\n\tif (ret != 1) {\n\t\terr = SSL_get_error(conn->ssl, ret);\n\t\tmg_cry_internal(conn, \"SSL error %i, destroying SSL context\", err);\n\t\tSSL_free(conn->ssl);\n\t\tconn->ssl = NULL;\n/* Avoid CRYPTO_cleanup_all_ex_data(); See discussion:\n * https://wiki.openssl.org/index.php/Talk:Library_Initialization */\n#if !defined(OPENSSL_API_1_1)\n\t\tERR_remove_state(0);\n#endif\n\t\treturn 0;\n\t}\n\n\t/* SSL functions may fail and require to be called again:\n\t * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html\n\t * Here \"func\" could be SSL_connect or SSL_accept. */\n\tfor (i = 16; i <= 1024; i *= 2) {\n\t\tret = func(conn->ssl);\n\t\tif (ret != 1) {\n\t\t\terr = SSL_get_error(conn->ssl, ret);\n\t\t\tif ((err == SSL_ERROR_WANT_CONNECT)\n\t\t\t    || (err == SSL_ERROR_WANT_ACCEPT)\n\t\t\t    || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE)\n\t\t\t    || (err == SSL_ERROR_WANT_X509_LOOKUP)) {\n\t\t\t\t/* Need to retry the function call \"later\".\n\t\t\t\t * See https://linux.die.net/man/3/ssl_get_error\n\t\t\t\t * This is typical for non-blocking sockets. */\n\t\t\t\tif (*stop_server) {\n\t\t\t\t\t/* Don't wait if the server is going to be stopped. */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmg_sleep(i);\n\n\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t/* This is an IO error. Look at errno. */\n\t\t\t\terr = errno;\n\t\t\t\tmg_cry_internal(conn, \"SSL syscall error %i\", err);\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t/* This is an SSL specific error, e.g. SSL_ERROR_SSL */\n\t\t\t\tmg_cry_internal(conn, \"sslize error: %s\", ssl_error());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* success */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != 1) {\n\t\tSSL_free(conn->ssl);\n\t\tconn->ssl = NULL;\n/* Avoid CRYPTO_cleanup_all_ex_data(); See discussion:\n * https://wiki.openssl.org/index.php/Talk:Library_Initialization */\n#if !defined(OPENSSL_API_1_1)\n\t\tERR_remove_state(0);\n#endif\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\n/* Return OpenSSL error message (from CRYPTO lib) */\nstatic const char *\nssl_error(void)\n{\n\tunsigned long err;\n\terr = ERR_get_error();\n\treturn ((err == 0) ? \"\" : ERR_error_string(err, NULL));\n}\n\n\nstatic int\nhexdump2string(void *mem, int memlen, char *buf, int buflen)\n{\n\tint i;\n\tconst char hexdigit[] = \"0123456789abcdef\";\n\n\tif ((memlen <= 0) || (buflen <= 0)) {\n\t\treturn 0;\n\t}\n\tif (buflen < (3 * memlen)) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < memlen; i++) {\n\t\tif (i > 0) {\n\t\t\tbuf[3 * i - 1] = ' ';\n\t\t}\n\t\tbuf[3 * i] = hexdigit[(((uint8_t *)mem)[i] >> 4) & 0xF];\n\t\tbuf[3 * i + 1] = hexdigit[((uint8_t *)mem)[i] & 0xF];\n\t}\n\tbuf[3 * memlen - 1] = 0;\n\n\treturn 1;\n}\n\n\nstatic void\nssl_get_client_cert_info(struct mg_connection *conn)\n{\n\tX509 *cert = SSL_get_peer_certificate(conn->ssl);\n\tif (cert) {\n\t\tchar str_subject[1024];\n\t\tchar str_issuer[1024];\n\t\tchar str_finger[1024];\n\t\tunsigned char buf[256];\n\t\tchar *str_serial = NULL;\n\t\tunsigned int ulen;\n\t\tint ilen;\n\t\tunsigned char *tmp_buf;\n\t\tunsigned char *tmp_p;\n\n\t\t/* Handle to algorithm used for fingerprint */\n\t\tconst EVP_MD *digest = EVP_get_digestbyname(\"sha1\");\n\n\t\t/* Get Subject and issuer */\n\t\tX509_NAME *subj = X509_get_subject_name(cert);\n\t\tX509_NAME *iss = X509_get_issuer_name(cert);\n\n\t\t/* Get serial number */\n\t\tASN1_INTEGER *serial = X509_get_serialNumber(cert);\n\n\t\t/* Translate serial number to a hex string */\n\t\tBIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);\n\t\tstr_serial = BN_bn2hex(serial_bn);\n\t\tBN_free(serial_bn);\n\n\t\t/* Translate subject and issuer to a string */\n\t\t(void)X509_NAME_oneline(subj, str_subject, (int)sizeof(str_subject));\n\t\t(void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));\n\n\t\t/* Calculate SHA1 fingerprint and store as a hex string */\n\t\tulen = 0;\n\n\t\t/* ASN1_digest is deprecated. Do the calculation manually,\n\t\t * using EVP_Digest. */\n\t\tilen = i2d_X509(cert, NULL);\n\t\ttmp_buf = (ilen > 0)\n\t\t              ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1,\n\t\t                                               conn->phys_ctx)\n\t\t              : NULL;\n\t\tif (tmp_buf) {\n\t\t\ttmp_p = tmp_buf;\n\t\t\t(void)i2d_X509(cert, &tmp_p);\n\t\t\tif (!EVP_Digest(\n\t\t\t        tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {\n\t\t\t\tulen = 0;\n\t\t\t}\n\t\t\tmg_free(tmp_buf);\n\t\t}\n\n\t\tif (!hexdump2string(\n\t\t        buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {\n\t\t\t*str_finger = 0;\n\t\t}\n\n\t\tconn->request_info.client_cert = (struct mg_client_cert *)\n\t\t    mg_malloc_ctx(sizeof(struct mg_client_cert), conn->phys_ctx);\n\t\tif (conn->request_info.client_cert) {\n\t\t\tconn->request_info.client_cert->peer_cert = (void *)cert;\n\t\t\tconn->request_info.client_cert->subject =\n\t\t\t    mg_strdup_ctx(str_subject, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->issuer =\n\t\t\t    mg_strdup_ctx(str_issuer, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->serial =\n\t\t\t    mg_strdup_ctx(str_serial, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->finger =\n\t\t\t    mg_strdup_ctx(str_finger, conn->phys_ctx);\n\t\t} else {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s\",\n\t\t\t                \"Out of memory: Cannot allocate memory for client \"\n\t\t\t                \"certificate\");\n\t\t}\n\n\t\t/* Strings returned from bn_bn2hex must be freed using OPENSSL_free,\n\t\t * see https://linux.die.net/man/3/bn_bn2hex */\n\t\tOPENSSL_free(str_serial);\n\t}\n}\n\n\n#if defined(OPENSSL_API_1_1)\n#else\nstatic void\nssl_locking_callback(int mode, int mutex_num, const char *file, int line)\n{\n\t(void)line;\n\t(void)file;\n\n\tif (mode & 1) {\n\t\t/* 1 is CRYPTO_LOCK */\n\t\t(void)pthread_mutex_lock(&ssl_mutexes[mutex_num]);\n\t} else {\n\t\t(void)pthread_mutex_unlock(&ssl_mutexes[mutex_num]);\n\t}\n}\n#endif /* OPENSSL_API_1_1 */\n\n\n#if !defined(NO_SSL_DL)\nstatic void *\nload_dll(char *ebuf, size_t ebuf_len, const char *dll_name, struct ssl_func *sw)\n{\n\tunion {\n\t\tvoid *p;\n\t\tvoid (*fp)(void);\n\t} u;\n\tvoid *dll_handle;\n\tstruct ssl_func *fp;\n\tint ok;\n\tint truncated = 0;\n\n\tif ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s: cannot load %s\",\n\t\t            __func__,\n\t\t            dll_name);\n\t\treturn NULL;\n\t}\n\n\tok = 1;\n\tfor (fp = sw; fp->name != NULL; fp++) {\n#if defined(_WIN32)\n\t\t/* GetProcAddress() returns pointer to function */\n\t\tu.fp = (void (*)(void))dlsym(dll_handle, fp->name);\n#else\n\t\t/* dlsym() on UNIX returns void *. ISO C forbids casts of data\n\t\t * pointers to function pointers. We need to use a union to make a\n\t\t * cast. */\n\t\tu.p = dlsym(dll_handle, fp->name);\n#endif /* _WIN32 */\n\t\tif (u.fp == NULL) {\n\t\t\tif (ok) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            &truncated,\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"%s: %s: cannot find %s\",\n\t\t\t\t            __func__,\n\t\t\t\t            dll_name,\n\t\t\t\t            fp->name);\n\t\t\t\tok = 0;\n\t\t\t} else {\n\t\t\t\tsize_t cur_len = strlen(ebuf);\n\t\t\t\tif (!truncated) {\n\t\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t\t            &truncated,\n\t\t\t\t\t            ebuf + cur_len,\n\t\t\t\t\t            ebuf_len - cur_len - 3,\n\t\t\t\t\t            \", %s\",\n\t\t\t\t\t            fp->name);\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\t/* If truncated, add \"...\" */\n\t\t\t\t\t\tstrcat(ebuf, \"...\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Debug:\n\t\t\t * printf(\"Missing function: %s\\n\", fp->name); */\n\t\t} else {\n\t\t\tfp->ptr = u.fp;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\t(void)dlclose(dll_handle);\n\t\treturn NULL;\n\t}\n\n\treturn dll_handle;\n}\n\n\nstatic void *ssllib_dll_handle;    /* Store the ssl library handle. */\nstatic void *cryptolib_dll_handle; /* Store the crypto library handle. */\n\n#endif /* NO_SSL_DL */\n\n\n#if defined(SSL_ALREADY_INITIALIZED)\nstatic int cryptolib_users = 1; /* Reference counter for crypto library. */\n#else\nstatic int cryptolib_users = 0; /* Reference counter for crypto library. */\n#endif\n\n\nstatic int\ninitialize_ssl(char *ebuf, size_t ebuf_len)\n{\n#if defined(OPENSSL_API_1_1)\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = 0;\n\t}\n\n#if !defined(NO_SSL_DL)\n\tif (!cryptolib_dll_handle) {\n\t\tcryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);\n\t\tif (!cryptolib_dll_handle) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: error loading library %s\",\n\t\t\t            __func__,\n\t\t\t            CRYPTO_LIB);\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n\tif (mg_atomic_inc(&cryptolib_users) > 1) {\n\t\treturn 1;\n\t}\n\n#else /* not OPENSSL_API_1_1 */\n\tint i, num_locks;\n\tsize_t size;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = 0;\n\t}\n\n#if !defined(NO_SSL_DL)\n\tif (!cryptolib_dll_handle) {\n\t\tcryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);\n\t\tif (!cryptolib_dll_handle) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: error loading library %s\",\n\t\t\t            __func__,\n\t\t\t            CRYPTO_LIB);\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n\tif (mg_atomic_inc(&cryptolib_users) > 1) {\n\t\treturn 1;\n\t}\n\n\t/* Initialize locking callbacks, needed for thread safety.\n\t * http://www.openssl.org/support/faq.html#PROG1\n\t */\n\tnum_locks = CRYPTO_num_locks();\n\tif (num_locks < 0) {\n\t\tnum_locks = 0;\n\t}\n\tsize = sizeof(pthread_mutex_t) * ((size_t)(num_locks));\n\n\t/* allocate mutex array, if required */\n\tif (num_locks == 0) {\n\t\t/* No mutex array required */\n\t\tssl_mutexes = NULL;\n\t} else {\n\t\t/* Mutex array required - allocate it */\n\t\tssl_mutexes = (pthread_mutex_t *)mg_malloc(size);\n\n\t\t/* Check OOM */\n\t\tif (ssl_mutexes == NULL) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: cannot allocate mutexes: %s\",\n\t\t\t            __func__,\n\t\t\t            ssl_error());\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* initialize mutex array */\n\t\tfor (i = 0; i < num_locks; i++) {\n\t\t\tif (0 != pthread_mutex_init(&ssl_mutexes[i], &pthread_mutex_attr)) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"%s: error initializing mutex %i of %i\",\n\t\t\t\t            __func__,\n\t\t\t\t            i,\n\t\t\t\t            num_locks);\n\t\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\t\tmg_free(ssl_mutexes);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tCRYPTO_set_locking_callback(&ssl_locking_callback);\n\tCRYPTO_set_id_callback(&mg_current_thread_id);\n#endif /* OPENSSL_API_1_1 */\n\n#if !defined(NO_SSL_DL)\n\tif (!ssllib_dll_handle) {\n\t\tssllib_dll_handle = load_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw);\n\t\tif (!ssllib_dll_handle) {\n#if !defined(OPENSSL_API_1_1)\n\t\t\tmg_free(ssl_mutexes);\n#endif\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n#if defined(OPENSSL_API_1_1)\n\t/* Initialize SSL library */\n\tOPENSSL_init_ssl(0, NULL);\n\tOPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS\n\t                     | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,\n\t                 NULL);\n#else\n\t/* Initialize SSL library */\n\tSSL_library_init();\n\tSSL_load_error_strings();\n#endif\n\n\treturn 1;\n}\n\n\nstatic int\nssl_use_pem_file(struct mg_context *phys_ctx,\n                 struct mg_domain_context *dom_ctx,\n                 const char *pem,\n                 const char *chain)\n{\n\tif (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: cannot open certificate file %s: %s\",\n\t\t                __func__,\n\t\t                pem,\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n\n\t/* could use SSL_CTX_set_default_passwd_cb_userdata */\n\tif (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: cannot open private key file %s: %s\",\n\t\t                __func__,\n\t\t                pem,\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n\n\tif (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: certificate and private key do not match: %s\",\n\t\t                __func__,\n\t\t                pem);\n\t\treturn 0;\n\t}\n\n\t/* In contrast to OpenSSL, wolfSSL does not support certificate\n\t * chain files that contain private keys and certificates in\n\t * SSL_CTX_use_certificate_chain_file.\n\t * The CivetWeb-Server used pem-Files that contained both information.\n\t * In order to make wolfSSL work, it is split in two files.\n\t * One file that contains key and certificate used by the server and\n\t * an optional chain file for the ssl stack.\n\t */\n\tif (chain) {\n\t\tif (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"%s: cannot use certificate chain file %s: %s\",\n\t\t\t                __func__,\n\t\t\t                pem,\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n\n#if defined(OPENSSL_API_1_1)\nstatic unsigned long\nssl_get_protocol(int version_id)\n{\n\tlong unsigned ret = (long unsigned)SSL_OP_ALL;\n\tif (version_id > 0)\n\t\tret |= SSL_OP_NO_SSLv2;\n\tif (version_id > 1)\n\t\tret |= SSL_OP_NO_SSLv3;\n\tif (version_id > 2)\n\t\tret |= SSL_OP_NO_TLSv1;\n\tif (version_id > 3)\n\t\tret |= SSL_OP_NO_TLSv1_1;\n\treturn ret;\n}\n#else\nstatic long\nssl_get_protocol(int version_id)\n{\n\tlong ret = (long)SSL_OP_ALL;\n\tif (version_id > 0)\n\t\tret |= SSL_OP_NO_SSLv2;\n\tif (version_id > 1)\n\t\tret |= SSL_OP_NO_SSLv3;\n\tif (version_id > 2)\n\t\tret |= SSL_OP_NO_TLSv1;\n\tif (version_id > 3)\n\t\tret |= SSL_OP_NO_TLSv1_1;\n\treturn ret;\n}\n#endif /* OPENSSL_API_1_1 */\n\n\n/* SSL callback documentation:\n * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html\n * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3)\n * https://linux.die.net/man/3/ssl_set_info_callback */\n/* Note: There is no \"const\" for the first argument in the documentation,\n * however some (maybe most, but not all) headers of OpenSSL versions /\n * OpenSSL compatibility layers have it. Having a different definition\n * will cause a warning in C and an error in C++. With inconsitent\n * definitions of this function, having a warning in one version or\n * another is unavoidable. */\nstatic void\nssl_info_callback(SSL *ssl, int what, int ret)\n{\n\t(void)ret;\n\n\tif (what & SSL_CB_HANDSHAKE_START) {\n\t\tSSL_get_app_data(ssl);\n\t}\n\tif (what & SSL_CB_HANDSHAKE_DONE) {\n\t\t/* TODO: check for openSSL 1.1 */\n\t\t//#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001\n\t\t// ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;\n\t}\n}\n\n\nstatic int\nssl_servername_callback(SSL *ssl, int *ad, void *arg)\n{\n\tstruct mg_context *ctx = (struct mg_context *)arg;\n\tstruct mg_domain_context *dom =\n\t    (struct mg_domain_context *)ctx ? &(ctx->dd) : NULL;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\t/* We used an aligned pointer in SSL_set_app_data */\n\tstruct mg_connection *conn = (struct mg_connection *)SSL_get_app_data(ssl);\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\tconst char *servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n\n\t(void)ad;\n\n\tif ((ctx == NULL) || (conn->phys_ctx == ctx)) {\n\t\tDEBUG_TRACE(\"%s\", \"internal error - assertion failed\");\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t}\n\n\t/* Old clients (Win XP) will not support SNI. Then, there\n\t * is no server name available in the request - we can\n\t * only work with the default certificate.\n\t * Multiple HTTPS hosts on one IP+port are only possible\n\t * with a certificate containing all alternative names.\n\t */\n\tif ((servername == NULL) || (*servername == 0)) {\n\t\tDEBUG_TRACE(\"%s\", \"SSL connection not supporting SNI\");\n\t\tconn->dom_ctx = &(ctx->dd);\n\t\tSSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t}\n\n\tDEBUG_TRACE(\"TLS connection to host %s\", servername);\n\n\twhile (dom) {\n\t\tif (!mg_strcasecmp(servername, dom->config[AUTHENTICATION_DOMAIN])) {\n\n\t\t\t/* Found matching domain */\n\t\t\tDEBUG_TRACE(\"TLS domain %s found\",\n\t\t\t            dom->config[AUTHENTICATION_DOMAIN]);\n\t\t\tSSL_set_SSL_CTX(ssl, dom->ssl_ctx);\n\t\t\tconn->dom_ctx = dom;\n\t\t\treturn SSL_TLSEXT_ERR_OK;\n\t\t}\n\t\tdom = dom->next;\n\t}\n\n\t/* Default domain */\n\tDEBUG_TRACE(\"TLS default domain %s used\",\n\t            ctx->dd.config[AUTHENTICATION_DOMAIN]);\n\tconn->dom_ctx = &(ctx->dd);\n\tSSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);\n\treturn SSL_TLSEXT_ERR_OK;\n}\n\n\n/* Setup SSL CTX as required by CivetWeb */\nstatic int\ninit_ssl_ctx_impl(struct mg_context *phys_ctx,\n                  struct mg_domain_context *dom_ctx,\n                  const char *pem,\n                  const char *chain)\n{\n\tint callback_ret;\n\tint should_verify_peer;\n\tint peer_certificate_optional;\n\tconst char *ca_path;\n\tconst char *ca_file;\n\tint use_default_verify_paths;\n\tint verify_depth;\n\tstruct timespec now_mt;\n\tmd5_byte_t ssl_context_id[16];\n\tmd5_state_t md5state;\n\tint protocol_ver;\n\n#if defined(OPENSSL_API_1_1)\n\tif ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL_CTX_new (server) error: %s\",\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n#else\n\tif ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL_CTX_new (server) error: %s\",\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n#endif /* OPENSSL_API_1_1 */\n\n\tSSL_CTX_clear_options(dom_ctx->ssl_ctx,\n\t                      SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1\n\t                          | SSL_OP_NO_TLSv1_1);\n\tprotocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx,\n\t                    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);\n#if !defined(NO_SSL_DL)\n\tSSL_CTX_set_ecdh_auto(dom_ctx->ssl_ctx, 1);\n#endif /* NO_SSL_DL */\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wincompatible-pointer-types\"\n#endif\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#endif\n\t/* Depending on the OpenSSL version, the callback may be\n\t * 'void (*)(SSL *, int, int)' or 'void (*)(const SSL *, int, int)'\n\t * yielding in an \"incompatible-pointer-type\" warning for the other\n\t * version. It seems to be \"unclear\" what is correct:\n\t * https://bugs.launchpad.net/ubuntu/+source/openssl/+bug/1147526\n\t * https://www.openssl.org/docs/man1.0.2/ssl/ssl.html\n\t * https://www.openssl.org/docs/man1.1.0/ssl/ssl.html\n\t * https://github.com/openssl/openssl/blob/1d97c8435171a7af575f73c526d79e1ef0ee5960/ssl/ssl.h#L1173\n\t * Disable this warning here.\n\t * Alternative would be a version dependent ssl_info_callback and\n\t * a const-cast to call 'char *SSL_get_app_data(SSL *ssl)' there.\n\t */\n\tSSL_CTX_set_info_callback(dom_ctx->ssl_ctx, ssl_info_callback);\n\n\n\tSSL_CTX_set_tlsext_servername_callback(dom_ctx->ssl_ctx,\n\t                                       ssl_servername_callback);\n\tSSL_CTX_set_tlsext_servername_arg(dom_ctx->ssl_ctx, phys_ctx);\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\t/* If a callback has been specified, call it. */\n\tcallback_ret = (phys_ctx->callbacks.init_ssl == NULL)\n\t                   ? 0\n\t                   : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,\n\t                                                   phys_ctx->user_data));\n\n\t/* If callback returns 0, civetweb sets up the SSL certificate.\n\t * If it returns 1, civetweb assumes the calback already did this.\n\t * If it returns -1, initializing ssl fails. */\n\tif (callback_ret < 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL callback returned error: %i\",\n\t\t                callback_ret);\n\t\treturn 0;\n\t}\n\tif (callback_ret > 0) {\n\t\t/* Callback did everything. */\n\t\treturn 1;\n\t}\n\n\t/* Use some combination of start time, domain and port as a SSL\n\t * context ID. This should be unique on the current machine. */\n\tmd5_init(&md5state);\n\tclock_gettime(CLOCK_MONOTONIC, &now_mt);\n\tmd5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));\n\tmd5_append(&md5state,\n\t           (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],\n\t           strlen(phys_ctx->dd.config[LISTENING_PORTS]));\n\tmd5_append(&md5state,\n\t           (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],\n\t           strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));\n\tmd5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));\n\tmd5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));\n\tmd5_finish(&md5state, ssl_context_id);\n\n\tSSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,\n\t                               (unsigned char *)ssl_context_id,\n\t                               sizeof(ssl_context_id));\n\n\tif (pem != NULL) {\n\t\tif (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Should we support client certificates? */\n\t/* Default is \"no\". */\n\tshould_verify_peer = 0;\n\tpeer_certificate_optional = 0;\n\tif (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {\n\t\tif (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], \"yes\") == 0) {\n\t\t\t/* Yes, they are mandatory */\n\t\t\tshould_verify_peer = 1;\n\t\t\tpeer_certificate_optional = 0;\n\t\t} else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],\n\t\t                         \"optional\") == 0) {\n\t\t\t/* Yes, they are optional */\n\t\t\tshould_verify_peer = 1;\n\t\t\tpeer_certificate_optional = 1;\n\t\t}\n\t}\n\n\tuse_default_verify_paths =\n\t    (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL)\n\t    && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], \"yes\")\n\t        == 0);\n\n\tif (should_verify_peer) {\n\t\tca_path = dom_ctx->config[SSL_CA_PATH];\n\t\tca_file = dom_ctx->config[SSL_CA_FILE];\n\t\tif (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path)\n\t\t    != 1) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_load_verify_locations error: %s \"\n\t\t\t                \"ssl_verify_peer requires setting \"\n\t\t\t                \"either ssl_ca_path or ssl_ca_file. \"\n\t\t\t                \"Is any of them present in the \"\n\t\t\t                \".conf file?\",\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (peer_certificate_optional) {\n\t\t\tSSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(dom_ctx->ssl_ctx,\n\t\t\t                   SSL_VERIFY_PEER\n\t\t\t                       | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n\t\t\t                   NULL);\n\t\t}\n\n\t\tif (use_default_verify_paths\n\t\t    && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_set_default_verify_paths error: %s\",\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dom_ctx->config[SSL_VERIFY_DEPTH]) {\n\t\t\tverify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);\n\t\t\tSSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);\n\t\t}\n\t}\n\n\tif (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {\n\t\tif (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,\n\t\t                            dom_ctx->config[SSL_CIPHER_LIST]) != 1) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_set_cipher_list error: %s\",\n\t\t\t                ssl_error());\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\n/* Check if SSL is required.\n * If so, dynamically load SSL library\n * and set up ctx->ssl_ctx pointer. */\nstatic int\ninit_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx)\n{\n\tvoid *ssl_ctx = 0;\n\tint callback_ret;\n\tconst char *pem;\n\tconst char *chain;\n\tchar ebuf[128];\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tif (!dom_ctx) {\n\t\tdom_ctx = &(phys_ctx->dd);\n\t}\n\n\tif (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {\n\t\t/* No SSL port is set. No need to setup SSL. */\n\t\treturn 1;\n\t}\n\n\t/* Check for external SSL_CTX */\n\tcallback_ret =\n\t    (phys_ctx->callbacks.external_ssl_ctx == NULL)\n\t        ? 0\n\t        : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,\n\t                                                phys_ctx->user_data));\n\n\tif (callback_ret < 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"external_ssl_ctx callback returned error: %i\",\n\t\t                callback_ret);\n\t\treturn 0;\n\t} else if (callback_ret > 0) {\n\t\tdom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;\n\t\tif (!initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\t/* else: external_ssl_ctx does not exist or returns 0,\n\t * CivetWeb should continue initializing SSL */\n\n\t/* If PEM file is not specified and the init_ssl callback\n\t * is not specified, setup will fail. */\n\tif (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL)\n\t    && (phys_ctx->callbacks.init_ssl == NULL)) {\n\t\t/* No certificate and no callback:\n\t\t * Essential data to set up TLS is missing.\n\t\t */\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"Initializing SSL failed: -%s is not set\",\n\t\t                config_options[SSL_CERTIFICATE].name);\n\t\treturn 0;\n\t}\n\n\tchain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];\n\tif (chain == NULL) {\n\t\tchain = pem;\n\t}\n\tif ((chain != NULL) && (*chain == 0)) {\n\t\tchain = NULL;\n\t}\n\n\tif (!initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\tmg_cry_internal(fc(phys_ctx), \"%s\", ebuf);\n\t\treturn 0;\n\t}\n\n\treturn init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);\n}\n\n\nstatic void\nuninitialize_ssl(void)\n{\n#if defined(OPENSSL_API_1_1)\n\n\tif (mg_atomic_dec(&cryptolib_users) == 0) {\n\n\t\t/* Shutdown according to\n\t\t * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup\n\t\t * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl\n\t\t */\n\t\tCONF_modules_unload(1);\n#else\n\tint i;\n\n\tif (mg_atomic_dec(&cryptolib_users) == 0) {\n\n\t\t/* Shutdown according to\n\t\t * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup\n\t\t * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl\n\t\t */\n\t\tCRYPTO_set_locking_callback(NULL);\n\t\tCRYPTO_set_id_callback(NULL);\n\t\tENGINE_cleanup();\n\t\tCONF_modules_unload(1);\n\t\tERR_free_strings();\n\t\tEVP_cleanup();\n\t\tCRYPTO_cleanup_all_ex_data();\n\t\tERR_remove_state(0);\n\n\t\tfor (i = 0; i < CRYPTO_num_locks(); i++) {\n\t\t\tpthread_mutex_destroy(&ssl_mutexes[i]);\n\t\t}\n\t\tmg_free(ssl_mutexes);\n\t\tssl_mutexes = NULL;\n#endif /* OPENSSL_API_1_1 */\n\t}\n}\n#endif /* !NO_SSL */\n\n\nstatic int\nset_gpass_option(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx)\n{\n\tif (phys_ctx) {\n\t\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\t\tconst char *path;\n\t\tif (!dom_ctx) {\n\t\t\tdom_ctx = &(phys_ctx->dd);\n\t\t}\n\t\tpath = dom_ctx->config[GLOBAL_PASSWORDS_FILE];\n\t\tif ((path != NULL) && !mg_stat(fc(phys_ctx), path, &file.stat)) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"Cannot open %s: %s\",\n\t\t\t                path,\n\t\t\t                strerror(ERRNO));\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_acl_option(struct mg_context *phys_ctx)\n{\n\treturn check_acl(phys_ctx, (uint32_t)0x7f000001UL) != -1;\n}\n\n\nstatic void\nreset_per_request_attributes(struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn;\n\t}\n\tconn->connection_type =\n\t    CONNECTION_TYPE_INVALID; /* Not yet a valid request/response */\n\n\tconn->num_bytes_sent = conn->consumed_content = 0;\n\n\tconn->path_info = NULL;\n\tconn->status_code = -1;\n\tconn->content_len = -1;\n\tconn->is_chunked = 0;\n\tconn->must_close = 0;\n\tconn->request_len = 0;\n\tconn->throttle = 0;\n\tconn->data_len = 0;\n\tconn->chunk_remainder = 0;\n\tconn->accept_gzip = 0;\n\n\tconn->response_info.content_length = conn->request_info.content_length = -1;\n\tconn->response_info.http_version = conn->request_info.http_version = NULL;\n\tconn->response_info.num_headers = conn->request_info.num_headers = 0;\n\tconn->response_info.status_text = NULL;\n\tconn->response_info.status_code = 0;\n\n\tconn->request_info.remote_user = NULL;\n\tconn->request_info.request_method = NULL;\n\tconn->request_info.request_uri = NULL;\n\tconn->request_info.local_uri = NULL;\n\n#if defined(MG_LEGACY_INTERFACE)\n\t/* Legacy before split into local_uri and request_uri */\n\tconn->request_info.uri = NULL;\n#endif\n}\n\n\n#if 0\n/* Note: set_sock_timeout is not required for non-blocking sockets.\n * Leave this function here (commented out) for reference until\n * CivetWeb 1.9 is tested, and the tests confirme this function is\n * no longer required.\n*/\nstatic int\nset_sock_timeout(SOCKET sock, int milliseconds)\n{\n        int r0 = 0, r1, r2;\n\n#if defined(_WIN32)\n        /* Windows specific */\n\n        DWORD tv = (DWORD)milliseconds;\n\n#else\n        /* Linux, ... (not Windows) */\n\n        struct timeval tv;\n\n/* TCP_USER_TIMEOUT/RFC5482 (http://tools.ietf.org/html/rfc5482):\n * max. time waiting for the acknowledged of TCP data before the connection\n * will be forcefully closed and ETIMEDOUT is returned to the application.\n * If this option is not set, the default timeout of 20-30 minutes is used.\n*/\n/* #define TCP_USER_TIMEOUT (18) */\n\n#if defined(TCP_USER_TIMEOUT)\n        unsigned int uto = (unsigned int)milliseconds;\n        r0 = setsockopt(sock, 6, TCP_USER_TIMEOUT, (const void *)&uto, sizeof(uto));\n#endif\n\n        memset(&tv, 0, sizeof(tv));\n        tv.tv_sec = milliseconds / 1000;\n        tv.tv_usec = (milliseconds * 1000) % 1000000;\n\n#endif /* _WIN32 */\n\n        r1 = setsockopt(\n            sock, SOL_SOCKET, SO_RCVTIMEO, (SOCK_OPT_TYPE)&tv, sizeof(tv));\n        r2 = setsockopt(\n            sock, SOL_SOCKET, SO_SNDTIMEO, (SOCK_OPT_TYPE)&tv, sizeof(tv));\n\n        return r0 || r1 || r2;\n}\n#endif\n\n\nstatic int\nset_tcp_nodelay(SOCKET sock, int nodelay_on)\n{\n\tif (setsockopt(sock,\n\t               IPPROTO_TCP,\n\t               TCP_NODELAY,\n\t               (SOCK_OPT_TYPE)&nodelay_on,\n\t               sizeof(nodelay_on)) != 0) {\n\t\t/* Error */\n\t\treturn 1;\n\t}\n\t/* OK */\n\treturn 0;\n}\n\n\nstatic void\nclose_socket_gracefully(struct mg_connection *conn)\n{\n#if defined(_WIN32)\n\tchar buf[MG_BUF_LEN];\n\tint n;\n#endif\n\tstruct linger linger;\n\tint error_code = 0;\n\tint linger_timeout = -2;\n\tsocklen_t opt_len = sizeof(error_code);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\t/* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:\n\t * \"Note that enabling a nonzero timeout on a nonblocking socket\n\t * is not recommended.\", so set it to blocking now */\n\tset_blocking_mode(conn->client.sock);\n\n\t/* Send FIN to the client */\n\tshutdown(conn->client.sock, SHUTDOWN_WR);\n\n\n#if defined(_WIN32)\n\t/* Read and discard pending incoming data. If we do not do that and\n\t * close\n\t * the socket, the data in the send buffer may be discarded. This\n\t * behaviour is seen on Windows, when client keeps sending data\n\t * when server decides to close the connection; then when client\n\t * does recv() it gets no data back. */\n\tdo {\n\t\tn = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);\n\t} while (n > 0);\n#endif\n\n\tif (conn->dom_ctx->config[LINGER_TIMEOUT]) {\n\t\tlinger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);\n\t}\n\n\t/* Set linger option according to configuration */\n\tif (linger_timeout >= 0) {\n\t\t/* Set linger option to avoid socket hanging out after close. This\n\t\t * prevent ephemeral port exhaust problem under high QPS. */\n\t\tlinger.l_onoff = 1;\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4244)\n#endif\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n\t\t/* Data type of linger structure elements may differ,\n\t\t * so we don't know what cast we need here.\n\t\t * Disable type conversion warnings. */\n\n\t\tlinger.l_linger = (linger_timeout + 999) / 1000;\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\t} else {\n\t\tlinger.l_onoff = 0;\n\t\tlinger.l_linger = 0;\n\t}\n\n\tif (linger_timeout < -1) {\n\t\t/* Default: don't configure any linger */\n\t} else if (getsockopt(conn->client.sock,\n\t                      SOL_SOCKET,\n\t                      SO_ERROR,\n#if defined(_WIN32) /* WinSock uses different data type here */\n\t                      (char *)&error_code,\n#else\n\t                      &error_code,\n#endif\n\t                      &opt_len) != 0) {\n\t\t/* Cannot determine if socket is already closed. This should\n\t\t * not occur and never did in a test. Log an error message\n\t\t * and continue. */\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s\",\n\t\t                __func__,\n\t\t                strerror(ERRNO));\n\t} else if (error_code == ECONNRESET) {\n\t\t/* Socket already closed by client/peer, close socket without linger\n\t\t */\n\t} else {\n\n\t\t/* Set linger timeout */\n\t\tif (setsockopt(conn->client.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_LINGER,\n\t\t               (char *)&linger,\n\t\t               sizeof(linger)) != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    conn,\n\t\t\t    \"%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s\",\n\t\t\t    __func__,\n\t\t\t    linger.l_onoff,\n\t\t\t    linger.l_linger,\n\t\t\t    strerror(ERRNO));\n\t\t}\n\t}\n\n\t/* Now we know that our FIN is ACK-ed, safe to close */\n\tclosesocket(conn->client.sock);\n\tconn->client.sock = INVALID_SOCKET;\n}\n\n\nstatic void\nclose_connection(struct mg_connection *conn)\n{\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 6; /* to close */\n#endif\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tif (conn->lua_websocket_state) {\n\t\tlua_websocket_close(conn, conn->lua_websocket_state);\n\t\tconn->lua_websocket_state = NULL;\n\t}\n#endif\n\n\tmg_lock_connection(conn);\n\n\t/* Set close flag, so keep-alive loops will stop */\n\tconn->must_close = 1;\n\n\t/* call the connection_close callback if assigned */\n\tif (conn->phys_ctx->callbacks.connection_close != NULL) {\n\t\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\t\tconn->phys_ctx->callbacks.connection_close(conn);\n\t\t}\n\t}\n\n\t/* Reset user data, after close callback is called.\n\t * Do not reuse it. If the user needs a destructor,\n\t * it must be done in the connection_close callback. */\n\tmg_set_user_connection_data(conn, NULL);\n\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 7; /* closing */\n#endif\n\n#if !defined(NO_SSL)\n\tif (conn->ssl != NULL) {\n\t\t/* Run SSL_shutdown twice to ensure completely close SSL connection\n\t\t */\n\t\tSSL_shutdown(conn->ssl);\n\t\tSSL_free(conn->ssl);\n/* Avoid CRYPTO_cleanup_all_ex_data(); See discussion:\n * https://wiki.openssl.org/index.php/Talk:Library_Initialization */\n#if !defined(OPENSSL_API_1_1)\n\t\tERR_remove_state(0);\n#endif\n\t\tconn->ssl = NULL;\n\t}\n#endif\n\tif (conn->client.sock != INVALID_SOCKET) {\n\t\tclose_socket_gracefully(conn);\n\t\tconn->client.sock = INVALID_SOCKET;\n\t}\n\n\tif (conn->host) {\n\t\tmg_free((void *)conn->host);\n\t\tconn->host = NULL;\n\t}\n\n\tmg_unlock_connection(conn);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 8; /* closed */\n#endif\n}\n\n\nvoid\nmg_close_connection(struct mg_connection *conn)\n{\n#if defined(USE_WEBSOCKET)\n\tstruct mg_context *client_ctx = NULL;\n#endif /* defined(USE_WEBSOCKET) */\n\n\tif ((conn == NULL) || (conn->phys_ctx == NULL)) {\n\t\treturn;\n\t}\n\n#if defined(USE_WEBSOCKET)\n\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\tif (conn->in_websocket_handling) {\n\t\t\t/* Set close flag, so the server thread can exit. */\n\t\t\tconn->must_close = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {\n\n\t\tunsigned int i;\n\n\t\t/* ws/wss client */\n\t\tclient_ctx = conn->phys_ctx;\n\n\t\t/* client context: loops must end */\n\t\tclient_ctx->stop_flag = 1;\n\t\tconn->must_close = 1;\n\n\t\t/* We need to get the client thread out of the select/recv call\n\t\t * here. */\n\t\t/* Since we use a sleep quantum of some seconds to check for recv\n\t\t * timeouts, we will just wait a few seconds in mg_join_thread. */\n\n\t\t/* join worker thread */\n\t\tfor (i = 0; i < client_ctx->cfg_worker_threads; i++) {\n\t\t\tif (client_ctx->worker_threadids[i] != 0) {\n\t\t\t\tmg_join_thread(client_ctx->worker_threadids[i]);\n\t\t\t}\n\t\t}\n\t}\n#endif /* defined(USE_WEBSOCKET) */\n\n\tclose_connection(conn);\n\n#if !defined(NO_SSL)\n\tif (conn->client_ssl_ctx != NULL) {\n\t\tSSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);\n\t}\n#endif\n\n#if defined(USE_WEBSOCKET)\n\tif (client_ctx != NULL) {\n\t\t/* free context */\n\t\tmg_free(client_ctx->worker_threadids);\n\t\tmg_free(client_ctx);\n\t\t(void)pthread_mutex_destroy(&conn->mutex);\n\t\tmg_free(conn);\n\t} else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {\n\t\tmg_free(conn);\n\t}\n#else\n\tif (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) { /* Client */\n\t\tmg_free(conn);\n\t}\n#endif /* defined(USE_WEBSOCKET) */\n}\n\n\n/* Only for memory statistics */\nstatic struct mg_context common_client_context;\n\n\nstatic struct mg_connection *\nmg_connect_client_impl(const struct mg_client_options *client_options,\n                       int use_ssl,\n                       char *ebuf,\n                       size_t ebuf_len)\n{\n\tstruct mg_connection *conn = NULL;\n\tSOCKET sock;\n\tunion usa sa;\n\tstruct sockaddr *psa;\n\tsocklen_t len;\n\n\tunsigned max_req_size =\n\t    (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);\n\n\t/* Size of structures, aligned to 8 bytes */\n\tsize_t conn_size = ((sizeof(struct mg_connection) + 7) >> 3) << 3;\n\tsize_t ctx_size = ((sizeof(struct mg_context) + 7) >> 3) << 3;\n\n\tconn = (struct mg_connection *)mg_calloc_ctx(1,\n\t                                             conn_size + ctx_size\n\t                                                 + max_req_size,\n\t                                             &common_client_context);\n\n\tif (conn == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"calloc(): %s\",\n\t\t            strerror(ERRNO));\n\t\treturn NULL;\n\t}\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\t/* conn_size is aligned to 8 bytes */\n\n\tconn->phys_ctx = (struct mg_context *)(((char *)conn) + conn_size);\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#pragma GCC diagnostic pop\n#endif /* defined(__GNUC__) || defined(__MINGW32__) */\n\n\tconn->buf = (((char *)conn) + conn_size + ctx_size);\n\tconn->buf_size = (int)max_req_size;\n\tconn->phys_ctx->context_type = CONTEXT_HTTP_CLIENT;\n\tconn->dom_ctx = &(conn->phys_ctx->dd);\n\n\tif (!connect_socket(&common_client_context,\n\t                    client_options->host,\n\t                    client_options->port,\n\t                    use_ssl,\n\t                    ebuf,\n\t                    ebuf_len,\n\t                    &sock,\n\t                    &sa)) {\n\t\t/* ebuf is set by connect_socket,\n\t\t * free all memory and return NULL; */\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n#if !defined(NO_SSL)\n#if defined(OPENSSL_API_1_1)\n\tif (use_ssl\n\t    && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method())) == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"SSL_CTX_new error\");\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n#else\n\tif (use_ssl\n\t    && (conn->client_ssl_ctx = SSL_CTX_new(SSLv23_client_method()))\n\t           == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"SSL_CTX_new error\");\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n#endif /* OPENSSL_API_1_1 */\n#endif /* NO_SSL */\n\n\n#if defined(USE_IPV6)\n\tlen = (sa.sa.sa_family == AF_INET) ? sizeof(conn->client.rsa.sin)\n\t                                   : sizeof(conn->client.rsa.sin6);\n\tpsa = (sa.sa.sa_family == AF_INET)\n\t          ? (struct sockaddr *)&(conn->client.rsa.sin)\n\t          : (struct sockaddr *)&(conn->client.rsa.sin6);\n#else\n\tlen = sizeof(conn->client.rsa.sin);\n\tpsa = (struct sockaddr *)&(conn->client.rsa.sin);\n#endif\n\n\tconn->client.sock = sock;\n\tconn->client.lsa = sa;\n\n\tif (getsockname(sock, psa, &len) != 0) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: getsockname() failed: %s\",\n\t\t                __func__,\n\t\t                strerror(ERRNO));\n\t}\n\n\tconn->client.is_ssl = use_ssl ? 1 : 0;\n\tif (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"Can not create mutex\");\n#if !defined(NO_SSL)\n\t\tSSL_CTX_free(conn->client_ssl_ctx);\n#endif\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\n#if !defined(NO_SSL)\n\tif (use_ssl) {\n\t\tcommon_client_context.dd.ssl_ctx = conn->client_ssl_ctx;\n\n\t\t/* TODO: Check ssl_verify_peer and ssl_ca_path here.\n\t\t * SSL_CTX_set_verify call is needed to switch off server\n\t\t * certificate checking, which is off by default in OpenSSL and\n\t\t * on in yaSSL. */\n\t\t/* TODO: SSL_CTX_set_verify(conn->client_ssl_ctx,\n\t\t * SSL_VERIFY_PEER, verify_ssl_server); */\n\n\t\tif (client_options->client_cert) {\n\t\t\tif (!ssl_use_pem_file(&common_client_context,\n\t\t\t                      &(common_client_context.dd),\n\t\t\t                      client_options->client_cert,\n\t\t\t                      NULL)) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"Can not use SSL client certificate\");\n\t\t\t\tSSL_CTX_free(conn->client_ssl_ctx);\n\t\t\t\tclosesocket(sock);\n\t\t\t\tmg_free(conn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (client_options->server_cert) {\n\t\t\tSSL_CTX_load_verify_locations(conn->client_ssl_ctx,\n\t\t\t                              client_options->server_cert,\n\t\t\t                              NULL);\n\t\t\tSSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);\n\t\t}\n\n\t\tif (!sslize(conn,\n\t\t            conn->client_ssl_ctx,\n\t\t            SSL_connect,\n\t\t            &(conn->phys_ctx->stop_flag))) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"SSL connection error\");\n\t\t\tSSL_CTX_free(conn->client_ssl_ctx);\n\t\t\tclosesocket(sock);\n\t\t\tmg_free(conn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\tif (0 != set_non_blocking_mode(sock)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"Cannot set non-blocking mode for client %s:%i\",\n\t\t                client_options->host,\n\t\t                client_options->port);\n\t}\n\n\treturn conn;\n}\n\n\nCIVETWEB_API struct mg_connection *\nmg_connect_client_secure(const struct mg_client_options *client_options,\n                         char *error_buffer,\n                         size_t error_buffer_size)\n{\n\treturn mg_connect_client_impl(client_options,\n\t                              1,\n\t                              error_buffer,\n\t                              error_buffer_size);\n}\n\n\nstruct mg_connection *\nmg_connect_client(const char *host,\n                  int port,\n                  int use_ssl,\n                  char *error_buffer,\n                  size_t error_buffer_size)\n{\n\tstruct mg_client_options opts;\n\tmemset(&opts, 0, sizeof(opts));\n\topts.host = host;\n\topts.port = port;\n\treturn mg_connect_client_impl(&opts,\n\t                              use_ssl,\n\t                              error_buffer,\n\t                              error_buffer_size);\n}\n\n\nstatic const struct {\n\tconst char *proto;\n\tsize_t proto_len;\n\tunsigned default_port;\n} abs_uri_protocols[] = {{\"http://\", 7, 80},\n                         {\"https://\", 8, 443},\n                         {\"ws://\", 5, 80},\n                         {\"wss://\", 6, 443},\n                         {NULL, 0, 0}};\n\n\n/* Check if the uri is valid.\n * return 0 for invalid uri,\n * return 1 for *,\n * return 2 for relative uri,\n * return 3 for absolute uri without port,\n * return 4 for absolute uri with port */\nstatic int\nget_uri_type(const char *uri)\n{\n\tint i;\n\tconst char *hostend, *portbegin;\n\tchar *portend;\n\tunsigned long port;\n\n\t/* According to the HTTP standard\n\t * http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2\n\t * URI can be an asterisk (*) or should start with slash (relative uri),\n\t * or it should start with the protocol (absolute uri). */\n\tif ((uri[0] == '*') && (uri[1] == '\\0')) {\n\t\t/* asterisk */\n\t\treturn 1;\n\t}\n\n\t/* Valid URIs according to RFC 3986\n\t * (https://www.ietf.org/rfc/rfc3986.txt)\n\t * must only contain reserved characters :/?#[]@!$&'()*+,;=\n\t * and unreserved characters A-Z a-z 0-9 and -._~\n\t * and % encoded symbols.\n\t */\n\tfor (i = 0; uri[i] != 0; i++) {\n\t\tif (uri[i] < 33) {\n\t\t\t/* control characters and spaces are invalid */\n\t\t\treturn 0;\n\t\t}\n\t\tif (uri[i] > 126) {\n\t\t\t/* non-ascii characters must be % encoded */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tswitch (uri[i]) {\n\t\t\tcase '\"':  /* 34 */\n\t\t\tcase '<':  /* 60 */\n\t\t\tcase '>':  /* 62 */\n\t\t\tcase '\\\\': /* 92 */\n\t\t\tcase '^':  /* 94 */\n\t\t\tcase '`':  /* 96 */\n\t\t\tcase '{':  /* 123 */\n\t\t\tcase '|':  /* 124 */\n\t\t\tcase '}':  /* 125 */\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\t/* character is ok */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* A relative uri starts with a / character */\n\tif (uri[0] == '/') {\n\t\t/* relative uri */\n\t\treturn 2;\n\t}\n\n\t/* It could be an absolute uri: */\n\t/* This function only checks if the uri is valid, not if it is\n\t * addressing the current server. So civetweb can also be used\n\t * as a proxy server. */\n\tfor (i = 0; abs_uri_protocols[i].proto != NULL; i++) {\n\t\tif (mg_strncasecmp(uri,\n\t\t                   abs_uri_protocols[i].proto,\n\t\t                   abs_uri_protocols[i].proto_len) == 0) {\n\n\t\t\thostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');\n\t\t\tif (!hostend) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tportbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');\n\t\t\tif (!portbegin) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tport = strtoul(portbegin + 1, &portend, 10);\n\t\t\tif ((portend != hostend) || (port <= 0) || !is_valid_port(port)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n/* Return NULL or the relative uri at the current server */\nstatic const char *\nget_rel_url_at_current_server(const char *uri, const struct mg_connection *conn)\n{\n\tconst char *server_domain;\n\tsize_t server_domain_len;\n\tsize_t request_domain_len = 0;\n\tunsigned long port = 0;\n\tint i, auth_domain_check_enabled;\n\tconst char *hostbegin = NULL;\n\tconst char *hostend = NULL;\n\tconst char *portbegin;\n\tchar *portend;\n\n\tauth_domain_check_enabled =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\");\n\n\t/* DNS is case insensitive, so use case insensitive string compare here\n\t */\n\tfor (i = 0; abs_uri_protocols[i].proto != NULL; i++) {\n\t\tif (mg_strncasecmp(uri,\n\t\t                   abs_uri_protocols[i].proto,\n\t\t                   abs_uri_protocols[i].proto_len) == 0) {\n\n\t\t\thostbegin = uri + abs_uri_protocols[i].proto_len;\n\t\t\thostend = strchr(hostbegin, '/');\n\t\t\tif (!hostend) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tportbegin = strchr(hostbegin, ':');\n\t\t\tif ((!portbegin) || (portbegin > hostend)) {\n\t\t\t\tport = abs_uri_protocols[i].default_port;\n\t\t\t\trequest_domain_len = (size_t)(hostend - hostbegin);\n\t\t\t} else {\n\t\t\t\tport = strtoul(portbegin + 1, &portend, 10);\n\t\t\t\tif ((portend != hostend) || (port <= 0)\n\t\t\t\t    || !is_valid_port(port)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\trequest_domain_len = (size_t)(portbegin - hostbegin);\n\t\t\t}\n\t\t\t/* protocol found, port set */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!port) {\n\t\t/* port remains 0 if the protocol is not found */\n\t\treturn 0;\n\t}\n\n/* Check if the request is directed to a different server. */\n/* First check if the port is the same (IPv4 and IPv6). */\n#if defined(USE_IPV6)\n\tif (conn->client.lsa.sa.sa_family == AF_INET6) {\n\t\tif (ntohs(conn->client.lsa.sin6.sin6_port) != port) {\n\t\t\t/* Request is directed to a different port */\n\t\t\treturn 0;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tif (ntohs(conn->client.lsa.sin.sin_port) != port) {\n\t\t\t/* Request is directed to a different port */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Finally check if the server corresponds to the authentication\n\t * domain of the server (the server domain).\n\t * Allow full matches (like http://mydomain.com/path/file.ext), and\n\t * allow subdomain matches (like http://www.mydomain.com/path/file.ext),\n\t * but do not allow substrings (like\n\t * http://notmydomain.com/path/file.ext\n\t * or http://mydomain.com.fake/path/file.ext).\n\t */\n\tif (auth_domain_check_enabled) {\n\t\tserver_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t\tserver_domain_len = strlen(server_domain);\n\t\tif ((server_domain_len == 0) || (hostbegin == NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((request_domain_len == server_domain_len)\n\t\t    && (!memcmp(server_domain, hostbegin, server_domain_len))) {\n\t\t\t/* Request is directed to this server - full name match. */\n\t\t} else {\n\t\t\tif (request_domain_len < (server_domain_len + 2)) {\n\t\t\t\t/* Request is directed to another server: The server name\n\t\t\t\t * is longer than the request name.\n\t\t\t\t * Drop this case here to avoid overflows in the\n\t\t\t\t * following checks. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (hostbegin[request_domain_len - server_domain_len - 1] != '.') {\n\t\t\t\t/* Request is directed to another server: It could be a\n\t\t\t\t * substring\n\t\t\t\t * like notmyserver.com */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (0 != memcmp(server_domain,\n\t\t\t                hostbegin + request_domain_len - server_domain_len,\n\t\t\t                server_domain_len)) {\n\t\t\t\t/* Request is directed to another server:\n\t\t\t\t * The server name is different. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hostend;\n}\n\n\nstatic int\nget_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\t*err = 0;\n\n\treset_per_request_attributes(conn);\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Internal error\");\n\t\t*err = 500;\n\t\treturn 0;\n\t}\n\t/* Set the time the request was received. This value should be used for\n\t * timeouts. */\n\tclock_gettime(CLOCK_MONOTONIC, &(conn->req_time));\n\n\tconn->request_len =\n\t    read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);\n\tDEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);\n\tif ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Invalid message size\");\n\t\t*err = 500;\n\t\treturn 0;\n\t}\n\n\tif ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Message too large\");\n\t\t*err = 413;\n\t\treturn 0;\n\t}\n\n\tif (conn->request_len <= 0) {\n\t\tif (conn->data_len > 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Malformed message\");\n\t\t\t*err = 400;\n\t\t} else {\n\t\t\t/* Server did not recv anything -> just close the connection */\n\t\t\tconn->must_close = 1;\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"No data received\");\n\t\t\t*err = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic int\nget_request(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tconst char *cl;\n\tif (!get_message(conn, ebuf, ebuf_len, err)) {\n\t\treturn 0;\n\t}\n\n\tif (parse_http_request(conn->buf, conn->buf_size, &conn->request_info)\n\t    <= 0) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad request\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Message is a valid request */\n\n\t/* Is there a \"host\" ? */\n\tconn->host = alloc_get_host(conn);\n\tif (!conn->host) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad request: Host mismatch\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Do we know the content length? */\n\tif ((cl = get_header(conn->request_info.http_headers,\n\t                     conn->request_info.num_headers,\n\t                     \"Content-Length\")) != NULL) {\n\t\t/* Request/response has content length set */\n\t\tchar *endptr = NULL;\n\t\tconn->content_len = strtoll(cl, &endptr, 10);\n\t\tif (endptr == cl) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Publish the content length back to the request info. */\n\t\tconn->request_info.content_length = conn->content_len;\n\t} else if ((cl = get_header(conn->request_info.http_headers,\n\t                            conn->request_info.num_headers,\n\t                            \"Transfer-Encoding\")) != NULL\n\t           && !mg_strcasecmp(cl, \"chunked\")) {\n\t\tconn->is_chunked = 1;\n\t\tconn->content_len = -1; /* unknown content length */\n\t} else {\n\t\tconst struct mg_http_method_info *meth =\n\t\t    get_http_method_info(conn->request_info.request_method);\n\t\tif (!meth) {\n\t\t\t/* No valid HTTP method */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\tif (meth->request_has_body) {\n\t\t\t/* POST or PUT request without content length set */\n\t\t\tconn->content_len = -1; /* unknown content length */\n\t\t} else {\n\t\t\t/* Other request */\n\t\t\tconn->content_len = 0; /* No content */\n\t\t}\n\t}\n\n\tconn->connection_type = CONNECTION_TYPE_REQUEST; /* Valid request */\n\treturn 1;\n}\n\n\n/* conn is assumed to be valid in this internal function */\nstatic int\nget_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tconst char *cl;\n\tif (!get_message(conn, ebuf, ebuf_len, err)) {\n\t\treturn 0;\n\t}\n\n\tif (parse_http_response(conn->buf, conn->buf_size, &conn->response_info)\n\t    <= 0) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad response\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Message is a valid response */\n\n\t/* Do we know the content length? */\n\tif ((cl = get_header(conn->response_info.http_headers,\n\t                     conn->response_info.num_headers,\n\t                     \"Content-Length\")) != NULL) {\n\t\t/* Request/response has content length set */\n\t\tchar *endptr = NULL;\n\t\tconn->content_len = strtoll(cl, &endptr, 10);\n\t\tif (endptr == cl) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Publish the content length back to the response info. */\n\t\tconn->response_info.content_length = conn->content_len;\n\n\t\t/* TODO: check if it is still used in response_info */\n\t\tconn->request_info.content_length = conn->content_len;\n\n\t} else if ((cl = get_header(conn->response_info.http_headers,\n\t                            conn->response_info.num_headers,\n\t                            \"Transfer-Encoding\")) != NULL\n\t           && !mg_strcasecmp(cl, \"chunked\")) {\n\t\tconn->is_chunked = 1;\n\t\tconn->content_len = -1; /* unknown content length */\n\t} else {\n\t\tconn->content_len = -1; /* unknown content length */\n\t}\n\n\tconn->connection_type = CONNECTION_TYPE_RESPONSE; /* Valid response */\n\treturn 1;\n}\n\n\nint\nmg_get_response(struct mg_connection *conn,\n                char *ebuf,\n                size_t ebuf_len,\n                int timeout)\n{\n\tint err, ret;\n\tchar txt[32]; /* will not overflow */\n\tchar *save_timeout;\n\tchar *new_timeout;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Parameter error\");\n\t\treturn -1;\n\t}\n\n\t/* Implementation of API function for HTTP clients */\n\tsave_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];\n\n\tif (timeout >= 0) {\n\t\tmg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);\n\t\tnew_timeout = txt;\n\t\t/* Not required for non-blocking sockets.\n\t\tset_sock_timeout(conn->client.sock, timeout);\n\t\t*/\n\t} else {\n\t\tnew_timeout = NULL;\n\t}\n\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;\n\tret = get_response(conn, ebuf, ebuf_len, &err);\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;\n\n#if defined(MG_LEGACY_INTERFACE)\n\t/* TODO: 1) uri is deprecated;\n\t *       2) here, ri.uri is the http response code */\n\tconn->request_info.uri = conn->request_info.request_uri;\n#endif\n\tconn->request_info.local_uri = conn->request_info.request_uri;\n\n\t/* TODO (mid): Define proper return values - maybe return length?\n\t * For the first test use <0 for error and >0 for OK */\n\treturn (ret == 0) ? -1 : +1;\n}\n\n\nstruct mg_connection *\nmg_download(const char *host,\n            int port,\n            int use_ssl,\n            char *ebuf,\n            size_t ebuf_len,\n            const char *fmt,\n            ...)\n{\n\tstruct mg_connection *conn;\n\tva_list ap;\n\tint i;\n\tint reqerr;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tva_start(ap, fmt);\n\n\t/* open a connection */\n\tconn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);\n\n\tif (conn != NULL) {\n\t\ti = mg_vprintf(conn, fmt, ap);\n\t\tif (i <= 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Error sending request\");\n\t\t} else {\n\t\t\tget_response(conn, ebuf, ebuf_len, &reqerr);\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\t/* TODO: 1) uri is deprecated;\n\t\t\t *       2) here, ri.uri is the http response code */\n\t\t\tconn->request_info.uri = conn->request_info.request_uri;\n#endif\n\t\t\tconn->request_info.local_uri = conn->request_info.request_uri;\n\t\t}\n\t}\n\n\t/* if an error occurred, close the connection */\n\tif ((ebuf[0] != '\\0') && (conn != NULL)) {\n\t\tmg_close_connection(conn);\n\t\tconn = NULL;\n\t}\n\n\tva_end(ap);\n\treturn conn;\n}\n\n\nstruct websocket_client_thread_data {\n\tstruct mg_connection *conn;\n\tmg_websocket_data_handler data_handler;\n\tmg_websocket_close_handler close_handler;\n\tvoid *callback_data;\n};\n\n\n#if defined(USE_WEBSOCKET)\n#if defined(_WIN32)\nstatic unsigned __stdcall websocket_client_thread(void *data)\n#else\nstatic void *\nwebsocket_client_thread(void *data)\n#endif\n{\n\tstruct websocket_client_thread_data *cdata =\n\t    (struct websocket_client_thread_data *)data;\n\n#if !defined(_WIN32)\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n#endif\n\n\tmg_set_thread_name(\"ws-clnt\");\n\n\tif (cdata->conn->phys_ctx) {\n\t\tif (cdata->conn->phys_ctx->callbacks.init_thread) {\n\t\t\t/* 3 indicates a websocket client thread */\n\t\t\t/* TODO: check if conn->phys_ctx can be set */\n\t\t\tcdata->conn->phys_ctx->callbacks.init_thread(cdata->conn->phys_ctx,\n\t\t\t                                             3);\n\t\t}\n\t}\n\n\tread_websocket(cdata->conn, cdata->data_handler, cdata->callback_data);\n\n\tDEBUG_TRACE(\"%s\", \"Websocket client thread exited\\n\");\n\n\tif (cdata->close_handler != NULL) {\n\t\tcdata->close_handler(cdata->conn, cdata->callback_data);\n\t}\n\n\t/* The websocket_client context has only this thread. If it runs out,\n\t   set the stop_flag to 2 (= \"stopped\"). */\n\tcdata->conn->phys_ctx->stop_flag = 2;\n\n\tmg_free((void *)cdata);\n\n#if defined(_WIN32)\n\treturn 0;\n#else\n\treturn NULL;\n#endif\n}\n#endif\n\n\nstruct mg_connection *\nmg_connect_websocket_client(const char *host,\n                            int port,\n                            int use_ssl,\n                            char *error_buffer,\n                            size_t error_buffer_size,\n                            const char *path,\n                            const char *origin,\n                            mg_websocket_data_handler data_func,\n                            mg_websocket_close_handler close_func,\n                            void *user_data)\n{\n\tstruct mg_connection *conn = NULL;\n\n#if defined(USE_WEBSOCKET)\n\tstruct mg_context *newctx = NULL;\n\tstruct websocket_client_thread_data *thread_data;\n\tstatic const char *magic = \"x3JJHMbDL1EzLkh9GBhXDw==\";\n\tstatic const char *handshake_req;\n\n\tif (origin != NULL) {\n\t\thandshake_req = \"GET %s HTTP/1.1\\r\\n\"\n\t\t                \"Host: %s\\r\\n\"\n\t\t                \"Upgrade: websocket\\r\\n\"\n\t\t                \"Connection: Upgrade\\r\\n\"\n\t\t                \"Sec-WebSocket-Key: %s\\r\\n\"\n\t\t                \"Sec-WebSocket-Version: 13\\r\\n\"\n\t\t                \"Origin: %s\\r\\n\"\n\t\t                \"\\r\\n\";\n\t} else {\n\t\thandshake_req = \"GET %s HTTP/1.1\\r\\n\"\n\t\t                \"Host: %s\\r\\n\"\n\t\t                \"Upgrade: websocket\\r\\n\"\n\t\t                \"Connection: Upgrade\\r\\n\"\n\t\t                \"Sec-WebSocket-Key: %s\\r\\n\"\n\t\t                \"Sec-WebSocket-Version: 13\\r\\n\"\n\t\t                \"\\r\\n\";\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\t/* Establish the client connection and request upgrade */\n\tconn = mg_download(host,\n\t                   port,\n\t                   use_ssl,\n\t                   error_buffer,\n\t                   error_buffer_size,\n\t                   handshake_req,\n\t                   path,\n\t                   host,\n\t                   magic,\n\t                   origin);\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\t/* Connection object will be null if something goes wrong */\n\tif (conn == NULL) {\n\t\tif (!*error_buffer) {\n\t\t\t/* There should be already an error message */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            error_buffer,\n\t\t\t            error_buffer_size,\n\t\t\t            \"Unexpected error\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (conn->response_info.status_code != 101) {\n\t\t/* We sent an \"upgrade\" request. For a correct websocket\n\t\t * protocol handshake, we expect a \"101 Continue\" response.\n\t\t * Otherwise it is a protocol violation. Maybe the HTTP\n\t\t * Server does not know websockets. */\n\t\tif (!*error_buffer) {\n\t\t\t/* set an error, if not yet set */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            error_buffer,\n\t\t\t            error_buffer_size,\n\t\t\t            \"Unexpected server reply\");\n\t\t}\n\n\t\tDEBUG_TRACE(\"Websocket client connect error: %s\\r\\n\", error_buffer);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\t/* For client connections, mg_context is fake. Since we need to set a\n\t * callback function, we need to create a copy and modify it. */\n\tnewctx = (struct mg_context *)mg_malloc(sizeof(struct mg_context));\n\tif (!newctx) {\n\t\tDEBUG_TRACE(\"%s\\r\\n\", \"Out of memory\");\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(newctx, conn->phys_ctx, sizeof(struct mg_context));\n\tnewctx->user_data = user_data;\n\tnewctx->context_type = CONTEXT_WS_CLIENT; /* ws/wss client context */\n\tnewctx->cfg_worker_threads = 1; /* one worker thread will be created */\n\tnewctx->worker_threadids =\n\t    (pthread_t *)mg_calloc_ctx(newctx->cfg_worker_threads,\n\t                               sizeof(pthread_t),\n\t                               newctx);\n\n\tconn->phys_ctx = newctx;\n\tconn->dom_ctx = &(newctx->dd);\n\n\tthread_data = (struct websocket_client_thread_data *)\n\t    mg_calloc_ctx(sizeof(struct websocket_client_thread_data), 1, newctx);\n\tif (!thread_data) {\n\t\tDEBUG_TRACE(\"%s\\r\\n\", \"Out of memory\");\n\t\tmg_free(newctx);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\tthread_data->conn = conn;\n\tthread_data->data_handler = data_func;\n\tthread_data->close_handler = close_func;\n\tthread_data->callback_data = user_data;\n\n\t/* Start a thread to read the websocket client connection\n\t * This thread will automatically stop when mg_disconnect is\n\t * called on the client connection */\n\tif (mg_start_thread_with_id(websocket_client_thread,\n\t                            (void *)thread_data,\n\t                            newctx->worker_threadids) != 0) {\n\t\tmg_free((void *)thread_data);\n\t\tmg_free((void *)newctx->worker_threadids);\n\t\tmg_free((void *)newctx);\n\t\tmg_free((void *)conn);\n\t\tconn = NULL;\n\t\tDEBUG_TRACE(\"%s\",\n\t\t            \"Websocket client connect thread could not be started\\r\\n\");\n\t}\n\n#else\n\t/* Appease \"unused parameter\" warnings */\n\t(void)host;\n\t(void)port;\n\t(void)use_ssl;\n\t(void)error_buffer;\n\t(void)error_buffer_size;\n\t(void)path;\n\t(void)origin;\n\t(void)user_data;\n\t(void)data_func;\n\t(void)close_func;\n#endif\n\n\treturn conn;\n}\n\n\n/* Prepare connection data structure */\nstatic void\ninit_connection(struct mg_connection *conn)\n{\n\t/* Is keep alive allowed by the server */\n\tint keep_alive_enabled =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], \"yes\");\n\n\tif (!keep_alive_enabled) {\n\t\tconn->must_close = 1;\n\t}\n\n\t/* Important: on new connection, reset the receiving buffer. Credit\n\t * goes to crule42. */\n\tconn->data_len = 0;\n\tconn->handled_requests = 0;\n\tmg_set_user_connection_data(conn, NULL);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 2; /* init */\n#endif\n\n\t/* call the init_connection callback if assigned */\n\tif (conn->phys_ctx->callbacks.init_connection != NULL) {\n\t\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\t\tvoid *conn_data = NULL;\n\t\t\tconn->phys_ctx->callbacks.init_connection(conn, &conn_data);\n\t\t\tmg_set_user_connection_data(conn, conn_data);\n\t\t}\n\t}\n}\n\n\n/* Process a connection - may handle multiple requests\n * using the same connection.\n * Must be called with a valid connection (conn  and\n * conn->phys_ctx must be valid).\n */\nstatic void\nprocess_new_connection(struct mg_connection *conn)\n{\n\tstruct mg_request_info *ri = &conn->request_info;\n\tint keep_alive, discard_len;\n\tchar ebuf[100];\n\tconst char *hostend;\n\tint reqerr, uri_type;\n\n#if defined(USE_SERVER_STATS)\n\tint mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));\n\tmg_atomic_add(&(conn->phys_ctx->total_connections), 1);\n\tif (mcon > (conn->phys_ctx->max_connections)) {\n\t\t/* could use atomic compare exchange, but this\n\t\t * seems overkill for statistics data */\n\t\tconn->phys_ctx->max_connections = mcon;\n\t}\n#endif\n\n\tinit_connection(conn);\n\n\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t            conn->request_info.remote_addr);\n\n\t/* Loop over multiple requests sent using the same connection\n\t * (while \"keep alive\"). */\n\tdo {\n\n\t\tDEBUG_TRACE(\"calling get_request (%i times for this connection)\",\n\t\t            conn->handled_requests + 1);\n\n#if defined(USE_SERVER_STATS)\n\t\tconn->conn_state = 3; /* ready */\n#endif\n\n\t\tif (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {\n\t\t\t/* The request sent by the client could not be understood by\n\t\t\t * the server, or it was incomplete or a timeout. Send an\n\t\t\t * error message and close the connection. */\n\t\t\tif (reqerr > 0) {\n\t\t\t\tDEBUG_ASSERT(ebuf[0] != '\\0');\n\t\t\t\tmg_send_http_error(conn, reqerr, \"%s\", ebuf);\n\t\t\t}\n\t\t} else if (strcmp(ri->http_version, \"1.0\")\n\t\t           && strcmp(ri->http_version, \"1.1\")) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            sizeof(ebuf),\n\t\t\t            \"Bad HTTP version: [%s]\",\n\t\t\t            ri->http_version);\n\t\t\tmg_send_http_error(conn, 505, \"%s\", ebuf);\n\t\t}\n\n\t\tif (ebuf[0] == '\\0') {\n\t\t\turi_type = get_uri_type(conn->request_info.request_uri);\n\t\t\tswitch (uri_type) {\n\t\t\tcase 1:\n\t\t\t\t/* Asterisk */\n\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t/* relative uri */\n\t\t\t\tconn->request_info.local_uri = conn->request_info.request_uri;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\t/* absolute uri (with/without port) */\n\t\t\t\thostend = get_rel_url_at_current_server(\n\t\t\t\t    conn->request_info.request_uri, conn);\n\t\t\t\tif (hostend) {\n\t\t\t\t\tconn->request_info.local_uri = hostend;\n\t\t\t\t} else {\n\t\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmg_snprintf(conn,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            sizeof(ebuf),\n\t\t\t\t            \"Invalid URI\");\n\t\t\t\tmg_send_http_error(conn, 400, \"%s\", ebuf);\n\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\t/* Legacy before split into local_uri and request_uri */\n\t\t\tconn->request_info.uri = conn->request_info.local_uri;\n#endif\n\t\t}\n\n\t\tDEBUG_TRACE(\"http: %s, error: %s\",\n\t\t            (ri->http_version ? ri->http_version : \"none\"),\n\t\t            (ebuf[0] ? ebuf : \"none\"));\n\n\t\tif (ebuf[0] == '\\0') {\n\t\t\tif (conn->request_info.local_uri) {\n\n/* handle request to local server */\n#if defined(USE_SERVER_STATS)\n\t\t\t\tconn->conn_state = 4; /* processing */\n#endif\n\t\t\t\thandle_request(conn);\n\n#if defined(USE_SERVER_STATS)\n\t\t\t\tconn->conn_state = 5; /* processed */\n\n\t\t\t\tmg_atomic_add(&(conn->phys_ctx->total_data_read),\n\t\t\t\t              conn->consumed_content);\n\t\t\t\tmg_atomic_add(&(conn->phys_ctx->total_data_written),\n\t\t\t\t              conn->num_bytes_sent);\n#endif\n\n\t\t\t\tDEBUG_TRACE(\"%s\", \"handle_request done\");\n\n\t\t\t\tif (conn->phys_ctx->callbacks.end_request != NULL) {\n\t\t\t\t\tconn->phys_ctx->callbacks.end_request(conn,\n\t\t\t\t\t                                      conn->status_code);\n\t\t\t\t\tDEBUG_TRACE(\"%s\", \"end_request callback done\");\n\t\t\t\t}\n\t\t\t\tlog_access(conn);\n\t\t\t} else {\n\t\t\t\t/* TODO: handle non-local request (PROXY) */\n\t\t\t\tconn->must_close = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tconn->must_close = 1;\n\t\t}\n\n\t\tif (ri->remote_user != NULL) {\n\t\t\tmg_free((void *)ri->remote_user);\n\t\t\t/* Important! When having connections with and without auth\n\t\t\t * would cause double free and then crash */\n\t\t\tri->remote_user = NULL;\n\t\t}\n\n\t\t/* NOTE(lsm): order is important here. should_keep_alive() call\n\t\t * is using parsed request, which will be invalid after\n\t\t * memmove's below.\n\t\t * Therefore, memorize should_keep_alive() result now for later\n\t\t * use in loop exit condition. */\n\t\tkeep_alive = (conn->phys_ctx->stop_flag == 0) && should_keep_alive(conn)\n\t\t             && (conn->content_len >= 0);\n\n\n\t\t/* Discard all buffered data for this request */\n\t\tdiscard_len = ((conn->content_len >= 0) && (conn->request_len > 0)\n\t\t               && ((conn->request_len + conn->content_len)\n\t\t                   < (int64_t)conn->data_len))\n\t\t                  ? (int)(conn->request_len + conn->content_len)\n\t\t                  : conn->data_len;\n\t\tDEBUG_ASSERT(discard_len >= 0);\n\t\tif (discard_len < 0) {\n\t\t\tDEBUG_TRACE(\"internal error: discard_len = %li\",\n\t\t\t            (long int)discard_len);\n\t\t\tbreak;\n\t\t}\n\t\tconn->data_len -= discard_len;\n\t\tif (conn->data_len > 0) {\n\t\t\tDEBUG_TRACE(\"discard_len = %lu\", (long unsigned)discard_len);\n\t\t\tmemmove(conn->buf, conn->buf + discard_len, (size_t)conn->data_len);\n\t\t}\n\n\t\tDEBUG_ASSERT(conn->data_len >= 0);\n\t\tDEBUG_ASSERT(conn->data_len <= conn->buf_size);\n\n\t\tif ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {\n\t\t\tDEBUG_TRACE(\"internal error: data_len = %li, buf_size = %li\",\n\t\t\t            (long int)conn->data_len,\n\t\t\t            (long int)conn->buf_size);\n\t\t\tbreak;\n\t\t}\n\n\t\tconn->handled_requests++;\n\n\t} while (keep_alive);\n\n\tDEBUG_TRACE(\"Done processing connection from %s (%f sec)\",\n\t            conn->request_info.remote_addr,\n\t            difftime(time(NULL), conn->conn_birth_time));\n\n\tclose_connection(conn);\n\n#if defined(USE_SERVER_STATS)\n\tmg_atomic_add(&(conn->phys_ctx->total_requests), conn->handled_requests);\n\tmg_atomic_dec(&(conn->phys_ctx->active_connections));\n#endif\n}\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\nstatic void\nproduce_socket(struct mg_context *ctx, const struct socket *sp)\n{\n\tunsigned int i;\n\n\twhile (!ctx->stop_flag) {\n\t\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\t\t/* find a free worker slot and signal it */\n\t\t\tif (ctx->client_socks[i].in_use == 0) {\n\t\t\t\tctx->client_socks[i] = *sp;\n\t\t\t\tctx->client_socks[i].in_use = 1;\n\t\t\t\tevent_signal(ctx->client_wait_events[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* queue is full */\n\t\tmg_sleep(1);\n\t}\n}\n\n\nstatic int\nconsume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)\n{\n\tDEBUG_TRACE(\"%s\", \"going idle\");\n\tctx->client_socks[thread_index].in_use = 0;\n\tevent_wait(ctx->client_wait_events[thread_index]);\n\t*sp = ctx->client_socks[thread_index];\n\tDEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);\n\n\treturn !ctx->stop_flag;\n}\n\n#else /* ALTERNATIVE_QUEUE */\n\n/* Worker threads take accepted socket from the queue */\nstatic int\nconsume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)\n{\n#define QUEUE_SIZE(ctx) ((int)(ARRAY_SIZE(ctx->queue)))\n\n\t(void)thread_index;\n\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n\tDEBUG_TRACE(\"%s\", \"going idle\");\n\n\t/* If the queue is empty, wait. We're idle at this point. */\n\twhile ((ctx->sq_head == ctx->sq_tail) && (ctx->stop_flag == 0)) {\n\t\tpthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);\n\t}\n\n\t/* If we're stopping, sq_head may be equal to sq_tail. */\n\tif (ctx->sq_head > ctx->sq_tail) {\n\t\t/* Copy socket from the queue and increment tail */\n\t\t*sp = ctx->queue[ctx->sq_tail % QUEUE_SIZE(ctx)];\n\t\tctx->sq_tail++;\n\n\t\tDEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);\n\n\t\t/* Wrap pointers if needed */\n\t\twhile (ctx->sq_tail > QUEUE_SIZE(ctx)) {\n\t\t\tctx->sq_tail -= QUEUE_SIZE(ctx);\n\t\t\tctx->sq_head -= QUEUE_SIZE(ctx);\n\t\t}\n\t}\n\n\t(void)pthread_cond_signal(&ctx->sq_empty);\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n\n\treturn !ctx->stop_flag;\n#undef QUEUE_SIZE\n}\n\n\n/* Master thread adds accepted socket to a queue */\nstatic void\nproduce_socket(struct mg_context *ctx, const struct socket *sp)\n{\n#define QUEUE_SIZE(ctx) ((int)(ARRAY_SIZE(ctx->queue)))\n\tif (!ctx) {\n\t\treturn;\n\t}\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n\n\t/* If the queue is full, wait */\n\twhile ((ctx->stop_flag == 0)\n\t       && (ctx->sq_head - ctx->sq_tail >= QUEUE_SIZE(ctx))) {\n\t\t(void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);\n\t}\n\n\tif (ctx->sq_head - ctx->sq_tail < QUEUE_SIZE(ctx)) {\n\t\t/* Copy socket to the queue and increment head */\n\t\tctx->queue[ctx->sq_head % QUEUE_SIZE(ctx)] = *sp;\n\t\tctx->sq_head++;\n\t\tDEBUG_TRACE(\"queued socket %d\", sp ? sp->sock : -1);\n\t}\n\n\t(void)pthread_cond_signal(&ctx->sq_full);\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n#undef QUEUE_SIZE\n}\n#endif /* ALTERNATIVE_QUEUE */\n\n\nstruct worker_thread_args {\n\tstruct mg_context *ctx;\n\tint index;\n};\n\n\nstatic void *\nworker_thread_run(struct worker_thread_args *thread_args)\n{\n\tstruct mg_context *ctx = thread_args->ctx;\n\tstruct mg_connection *conn;\n\tstruct mg_workerTLS tls;\n#if defined(MG_LEGACY_INTERFACE)\n\tuint32_t addr;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\ttls.is_master = 0;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* Initialize thread local storage before calling any callback */\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* call init_thread for a worker thread (type 1) */\n\t\tctx->callbacks.init_thread(ctx, 1);\n\t}\n\n\t/* Connection structure has been pre-allocated */\n\tif (((int)thread_args->index < 0)\n\t    || ((unsigned)thread_args->index\n\t        >= (unsigned)ctx->cfg_worker_threads)) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"Internal error: Invalid worker index %i\",\n\t\t                (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn = ctx->worker_connections + thread_args->index;\n\n\t/* Request buffers are not pre-allocated. They are private to the\n\t * request and do not contain any state information that might be\n\t * of interest to anyone observing a server status.  */\n\tconn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);\n\tif (conn->buf == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t                (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn->buf_size = (int)ctx->max_request_size;\n\n\tconn->phys_ctx = ctx;\n\tconn->dom_ctx = &(ctx->dd); /* Use default domain and default host */\n\tconn->host = NULL;          /* until we have more information. */\n\n\tconn->thread_index = thread_args->index;\n\tconn->request_info.user_data = ctx->user_data;\n\t/* Allocate a mutex for this connection to allow communication both\n\t * within the request handler and from elsewhere in the application\n\t */\n\tif (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {\n\t\tmg_free(conn->buf);\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Cannot create mutex\");\n\t\treturn NULL;\n\t}\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 1; /* not consumed */\n#endif\n\n#if defined(ALTERNATIVE_QUEUE)\n\twhile ((ctx->stop_flag == 0)\n\t       && consume_socket(ctx, &conn->client, conn->thread_index)) {\n#else\n\t/* Call consume_socket() even when ctx->stop_flag > 0, to let it\n\t * signal sq_empty condvar to wake up the master waiting in\n\t * produce_socket() */\n\twhile (consume_socket(ctx, &conn->client, conn->thread_index)) {\n#endif\n\n\t\tconn->conn_birth_time = time(NULL);\n\n/* Fill in IP, port info early so even if SSL setup below fails,\n * error handler would have the corresponding info.\n * Thanks to Johannes Winkelmann for the patch.\n */\n#if defined(USE_IPV6)\n\t\tif (conn->client.rsa.sa.sa_family == AF_INET6) {\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(conn->request_info.remote_addr,\n\t\t                   sizeof(conn->request_info.remote_addr),\n\t\t                   &conn->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            conn->request_info.remote_addr);\n\n\t\tconn->request_info.is_ssl = conn->client.is_ssl;\n\n\t\tif (conn->client.is_ssl) {\n#if !defined(NO_SSL)\n\t\t\t/* HTTPS connection */\n\t\t\tif (sslize(conn,\n\t\t\t           conn->dom_ctx->ssl_ctx,\n\t\t\t           SSL_accept,\n\t\t\t           &(conn->phys_ctx->stop_flag))) {\n\t\t\t\t/* conn->dom_ctx is set in get_request */\n\n\t\t\t\t/* Get SSL client certificate information (if set) */\n\t\t\t\tssl_get_client_cert_info(conn);\n\n\t\t\t\t/* process HTTPS connection */\n\t\t\t\tprocess_new_connection(conn);\n\n\t\t\t\t/* Free client certificate info */\n\t\t\t\tif (conn->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->finger));\n\t\t\t\t\t/* Free certificate memory */\n\t\t\t\t\tX509_free(\n\t\t\t\t\t    (X509 *)conn->request_info.client_cert->peer_cert);\n\t\t\t\t\tconn->request_info.client_cert->peer_cert = 0;\n\t\t\t\t\tconn->request_info.client_cert->subject = 0;\n\t\t\t\t\tconn->request_info.client_cert->issuer = 0;\n\t\t\t\t\tconn->request_info.client_cert->serial = 0;\n\t\t\t\t\tconn->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(conn->request_info.client_cert);\n\t\t\t\t\tconn->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* make sure the connection is cleaned up on SSL failure */\n\t\t\t\tclose_connection(conn);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* process HTTP connection */\n\t\t\tprocess_new_connection(conn);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(sTlsKey, NULL);\n#if defined(_WIN32)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&conn->mutex);\n\n\t/* Free the request buffer. */\n\tconn->buf_size = 0;\n\tmg_free(conn->buf);\n\tconn->buf = NULL;\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 9; /* done */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}\n\n\n/* Threads have different return types on Windows and Unix. */\n#if defined(_WIN32)\nstatic unsigned __stdcall worker_thread(void *thread_func_param)\n{\n\tstruct worker_thread_args *pwta =\n\t    (struct worker_thread_args *)thread_func_param;\n\tworker_thread_run(pwta);\n\tmg_free(thread_func_param);\n\treturn 0;\n}\n#else\nstatic void *\nworker_thread(void *thread_func_param)\n{\n\tstruct worker_thread_args *pwta =\n\t    (struct worker_thread_args *)thread_func_param;\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n\n\tworker_thread_run(pwta);\n\tmg_free(thread_func_param);\n\treturn NULL;\n}\n#endif /* _WIN32 */\n\n\n/* This is an internal function, thus all arguments are expected to be\n * valid - a NULL check is not required. */\nstatic void\naccept_new_connection(const struct socket *listener, struct mg_context *ctx)\n{\n\tstruct socket so;\n\tchar src_addr[IP_ADDR_STR_LEN];\n\tsocklen_t len = sizeof(so.rsa);\n\tint on = 1;\n\n\tif ((so.sock = accept(listener->sock, &so.rsa.sa, &len))\n\t    == INVALID_SOCKET) {\n\t} else if (!check_acl(ctx, ntohl(*(uint32_t *)&so.rsa.sin.sin_addr))) {\n\t\tsockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s: %s is not allowed to connect\",\n\t\t                __func__,\n\t\t                src_addr);\n\t\tclosesocket(so.sock);\n\t} else {\n\t\t/* Put so socket structure into the queue */\n\t\tDEBUG_TRACE(\"Accepted socket %d\", (int)so.sock);\n\t\tset_close_on_exec(so.sock, fc(ctx));\n\t\tso.is_ssl = listener->is_ssl;\n\t\tso.ssl_redir = listener->ssl_redir;\n\t\tif (getsockname(so.sock, &so.lsa.sa, &len) != 0) {\n\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t                \"%s: getsockname() failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n\n\t\t/* Set TCP keep-alive. This is needed because if HTTP-level\n\t\t * keep-alive\n\t\t * is enabled, and client resets the connection, server won't get\n\t\t * TCP FIN or RST and will keep the connection open forever. With\n\t\t * TCP keep-alive, next keep-alive handshake will figure out that\n\t\t * the client is down and will close the server end.\n\t\t * Thanks to Igor Klopov who suggested the patch. */\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_KEEPALIVE,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on)) != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(ctx),\n\t\t\t    \"%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s\",\n\t\t\t    __func__,\n\t\t\t    strerror(ERRNO));\n\t\t}\n\n\t\t/* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced\n\t\t * to effectively fill up the underlying IP packet payload and\n\t\t * reduce the overhead of sending lots of small buffers. However\n\t\t * this hurts the server's throughput (ie. operations per second)\n\t\t * when HTTP 1.1 persistent connections are used and the responses\n\t\t * are relatively small (eg. less than 1400 bytes).\n\t\t */\n\t\tif ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL)\n\t\t    && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], \"1\"))) {\n\t\t\tif (set_tcp_nodelay(so.sock, 1) != 0) {\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    fc(ctx),\n\t\t\t\t    \"%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s\",\n\t\t\t\t    __func__,\n\t\t\t\t    strerror(ERRNO));\n\t\t\t}\n\t\t}\n\n\t\t/* We are using non-blocking sockets. Thus, the\n\t\t * set_sock_timeout(so.sock, timeout);\n\t\t * call is no longer required. */\n\n\t\t/* The \"non blocking\" property should already be\n\t\t * inherited from the parent socket. Set it for\n\t\t * non-compliant socket implementations. */\n\t\tset_non_blocking_mode(so.sock);\n\n\t\tso.in_use = 0;\n\t\tproduce_socket(ctx, &so);\n\t}\n}\n\n\nstatic void\nmaster_thread_run(void *thread_func_param)\n{\n\tstruct mg_context *ctx = (struct mg_context *)thread_func_param;\n\tstruct mg_workerTLS tls;\n\tstruct pollfd *pfd;\n\tunsigned int i;\n\tunsigned int workerthreadcount;\n\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\tmg_set_thread_name(\"master\");\n\n/* Increase priority of the master thread */\n#if defined(_WIN32)\n\tSetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);\n#elif defined(USE_MASTER_THREAD_PRIORITY)\n\tint min_prio = sched_get_priority_min(SCHED_RR);\n\tint max_prio = sched_get_priority_max(SCHED_RR);\n\tif ((min_prio >= 0) && (max_prio >= 0)\n\t    && ((USE_MASTER_THREAD_PRIORITY) <= max_prio)\n\t    && ((USE_MASTER_THREAD_PRIORITY) >= min_prio)) {\n\t\tstruct sched_param sched_param = {0};\n\t\tsched_param.sched_priority = (USE_MASTER_THREAD_PRIORITY);\n\t\tpthread_setschedparam(pthread_self(), SCHED_RR, &sched_param);\n\t}\n#endif\n\n/* Initialize thread local storage */\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\ttls.is_master = 1;\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* Callback for the master thread (type 0) */\n\t\tctx->callbacks.init_thread(ctx, 0);\n\t}\n\n\t/* Server starts *now* */\n\tctx->start_time = time(NULL);\n\n\t/* Start the server */\n\tpfd = ctx->listening_socket_fds;\n\twhile (ctx->stop_flag == 0) {\n\t\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\t\tpfd[i].fd = ctx->listening_sockets[i].sock;\n\t\t\tpfd[i].events = POLLIN;\n\t\t}\n\n\t\tif (poll(pfd, ctx->num_listening_sockets, 200) > 0) {\n\t\t\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\t\t\t/* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the\n\t\t\t\t * successful poll, and POLLIN is defined as\n\t\t\t\t * (POLLRDNORM | POLLRDBAND)\n\t\t\t\t * Therefore, we're checking pfd[i].revents & POLLIN, not\n\t\t\t\t * pfd[i].revents == POLLIN. */\n\t\t\t\tif ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {\n\t\t\t\t\taccept_new_connection(&ctx->listening_sockets[i], ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Here stop_flag is 1 - Initiate shutdown. */\n\tDEBUG_TRACE(\"%s\", \"stopping workers\");\n\n\t/* Stop signal received: somebody called mg_stop. Quit. */\n\tclose_all_listening_sockets(ctx);\n\n\t/* Wakeup workers that are waiting for connections to handle. */\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n#if defined(ALTERNATIVE_QUEUE)\n\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\tevent_signal(ctx->client_wait_events[i]);\n\n\t\t/* Since we know all sockets, we can shutdown the connections. */\n\t\tif (ctx->client_socks[i].in_use) {\n\t\t\tshutdown(ctx->client_socks[i].sock, SHUTDOWN_BOTH);\n\t\t}\n\t}\n#else\n\tpthread_cond_broadcast(&ctx->sq_full);\n#endif\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n\n\t/* Join all worker threads to avoid leaking threads. */\n\tworkerthreadcount = ctx->cfg_worker_threads;\n\tfor (i = 0; i < workerthreadcount; i++) {\n\t\tif (ctx->worker_threadids[i] != 0) {\n\t\t\tmg_join_thread(ctx->worker_threadids[i]);\n\t\t}\n\t}\n\n#if defined(USE_LUA)\n\t/* Free Lua state of lua background task */\n\tif (ctx->lua_background_state) {\n\t\tlua_State *lstate = (lua_State *)ctx->lua_background_state;\n\t\tlua_getglobal(lstate, LUABACKGROUNDPARAMS);\n\t\tif (lua_istable(lstate, -1)) {\n\t\t\treg_boolean(lstate, \"shutdown\", 1);\n\t\t\tlua_pop(lstate, 1);\n\t\t\tmg_sleep(2);\n\t\t}\n\t\tlua_close(lstate);\n\t\tctx->lua_background_state = 0;\n\t}\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\n#if defined(_WIN32)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_setspecific(sTlsKey, NULL);\n\n\t/* Signal mg_stop() that we're done.\n\t * WARNING: This must be the very last thing this\n\t * thread does, as ctx becomes invalid after this line. */\n\tctx->stop_flag = 2;\n}\n\n\n/* Threads have different return types on Windows and Unix. */\n#if defined(_WIN32)\nstatic unsigned __stdcall master_thread(void *thread_func_param)\n{\n\tmaster_thread_run(thread_func_param);\n\treturn 0;\n}\n#else\nstatic void *\nmaster_thread(void *thread_func_param)\n{\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n\n\tmaster_thread_run(thread_func_param);\n\treturn NULL;\n}\n#endif /* _WIN32 */\n\n\nstatic void\nfree_context(struct mg_context *ctx)\n{\n\tint i;\n\tstruct mg_handler_info *tmp_rh;\n\n\tif (ctx == NULL) {\n\t\treturn;\n\t}\n\n\tif (ctx->callbacks.exit_context) {\n\t\tctx->callbacks.exit_context(ctx);\n\t}\n\n\t/* All threads exited, no sync is needed. Destroy thread mutex and\n\t * condvars\n\t */\n\t(void)pthread_mutex_destroy(&ctx->thread_mutex);\n#if defined(ALTERNATIVE_QUEUE)\n\tmg_free(ctx->client_socks);\n\tfor (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {\n\t\tevent_destroy(ctx->client_wait_events[i]);\n\t}\n\tmg_free(ctx->client_wait_events);\n#else\n\t(void)pthread_cond_destroy(&ctx->sq_empty);\n\t(void)pthread_cond_destroy(&ctx->sq_full);\n#endif\n\n\t/* Destroy other context global data structures mutex */\n\t(void)pthread_mutex_destroy(&ctx->nonce_mutex);\n\n#if defined(USE_TIMERS)\n\ttimers_exit(ctx);\n#endif\n\n\t/* Deallocate config parameters */\n\tfor (i = 0; i < NUM_OPTIONS; i++) {\n\t\tif (ctx->dd.config[i] != NULL) {\n#if defined(_MSC_VER)\n#pragma warning(suppress : 6001)\n#endif\n\t\t\tmg_free(ctx->dd.config[i]);\n\t\t}\n\t}\n\n\t/* Deallocate request handlers */\n\twhile (ctx->dd.handlers) {\n\t\ttmp_rh = ctx->dd.handlers;\n\t\tctx->dd.handlers = tmp_rh->next;\n\t\tif (tmp_rh->handler_type == REQUEST_HANDLER) {\n\t\t\tpthread_cond_destroy(&tmp_rh->refcount_cond);\n\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t}\n\t\tmg_free(tmp_rh->uri);\n\t\tmg_free(tmp_rh);\n\t}\n\n#if !defined(NO_SSL)\n\t/* Deallocate SSL context */\n\tif (ctx->dd.ssl_ctx != NULL) {\n\t\tvoid *ssl_ctx = (void *)ctx->dd.ssl_ctx;\n\t\tint callback_ret =\n\t\t    (ctx->callbacks.external_ssl_ctx == NULL)\n\t\t        ? 0\n\t\t        : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));\n\n\t\tif (callback_ret == 0) {\n\t\t\tSSL_CTX_free(ctx->dd.ssl_ctx);\n\t\t}\n\t\t/* else: ignore error and ommit SSL_CTX_free in case\n\t\t * callback_ret is 1 */\n\t}\n#endif /* !NO_SSL */\n\n\t/* Deallocate worker thread ID array */\n\tif (ctx->worker_threadids != NULL) {\n\t\tmg_free(ctx->worker_threadids);\n\t}\n\n\t/* Deallocate worker thread ID array */\n\tif (ctx->worker_connections != NULL) {\n\t\tmg_free(ctx->worker_connections);\n\t}\n\n\t/* deallocate system name string */\n\tmg_free(ctx->systemName);\n\n\t/* Deallocate context itself */\n\tmg_free(ctx);\n}\n\n\nvoid\nmg_stop(struct mg_context *ctx)\n{\n\tpthread_t mt;\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\t/* We don't use a lock here. Calling mg_stop with the same ctx from\n\t * two threads is not allowed. */\n\tmt = ctx->masterthreadid;\n\tif (mt == 0) {\n\t\treturn;\n\t}\n\n\tctx->masterthreadid = 0;\n\n\t/* Set stop flag, so all threads know they have to exit. */\n\tctx->stop_flag = 1;\n\n\t/* Wait until everything has stopped. */\n\twhile (ctx->stop_flag != 2) {\n\t\t(void)mg_sleep(10);\n\t}\n\n\tmg_join_thread(mt);\n\tfree_context(ctx);\n\n#if defined(_WIN32)\n\t(void)WSACleanup();\n#endif /* _WIN32 */\n}\n\n\nstatic void\nget_system_name(char **sysName)\n{\n#if defined(_WIN32)\n#if !defined(__SYMBIAN32__)\n#if defined(_WIN32_WCE)\n\t*sysName = mg_strdup(\"WinCE\");\n#else\n\tchar name[128];\n\tDWORD dwVersion = 0;\n\tDWORD dwMajorVersion = 0;\n\tDWORD dwMinorVersion = 0;\n\tDWORD dwBuild = 0;\n\tBOOL wowRet, isWoW = FALSE;\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n/* GetVersion was declared deprecated */\n#pragma warning(disable : 4996)\n#endif\n\tdwVersion = GetVersion();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\tdwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\tdwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\tdwBuild = ((dwVersion < 0x80000000) ? (DWORD)(HIWORD(dwVersion)) : 0);\n\t(void)dwBuild;\n\n\twowRet = IsWow64Process(GetCurrentProcess(), &isWoW);\n\n\tsprintf(name,\n\t        \"Windows %u.%u%s\",\n\t        (unsigned)dwMajorVersion,\n\t        (unsigned)dwMinorVersion,\n\t        (wowRet ? (isWoW ? \" (WoW64)\" : \"\") : \" (?)\"));\n\n\t*sysName = mg_strdup(name);\n#endif\n#else\n\t*sysName = mg_strdup(\"Symbian\");\n#endif\n#else\n\tstruct utsname name;\n\tmemset(&name, 0, sizeof(name));\n\tuname(&name);\n\t*sysName = mg_strdup(name.sysname);\n#endif\n}\n\n\nstruct mg_context *\nmg_start(const struct mg_callbacks *callbacks,\n         void *user_data,\n         const char **options)\n{\n\tstruct mg_context *ctx;\n\tconst char *name, *value, *default_value;\n\tint idx, ok, workerthreadcount;\n\tunsigned int i;\n\tint itmp;\n\tvoid (*exit_callback)(const struct mg_context *ctx) = 0;\n\n\tstruct mg_workerTLS tls;\n\n#if defined(_WIN32)\n\tWSADATA data;\n\tWSAStartup(MAKEWORD(2, 2), &data);\n#endif /* _WIN32  */\n\n\t/* Allocate context and initialize reasonable general case defaults. */\n\tif ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* Random number generator will initialize at the first call */\n\tctx->dd.auth_nonce_mask =\n\t    (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);\n\n\tif (mg_init_library_called == 0) {\n\t\t/* Legacy INIT, if mg_start is called without mg_init_library.\n\t\t * Note: This may cause a memory leak */\n\t\tconst char *ports_option =\n\t\t    config_options[LISTENING_PORTS].default_value;\n\n\t\tif (options) {\n\t\t\tconst char **run_options = options;\n\t\t\tconst char *optname = config_options[LISTENING_PORTS].name;\n\n\t\t\t/* Try to find the \"listening_ports\" option */\n\t\t\twhile (*run_options) {\n\t\t\t\tif (!strcmp(*run_options, optname)) {\n\t\t\t\t\tports_option = run_options[1];\n\t\t\t\t}\n\t\t\t\trun_options += 2;\n\t\t\t}\n\t\t}\n\n\t\tif (is_ssl_port_used(ports_option)) {\n\t\t\t/* Initialize with SSL support */\n\t\t\tmg_init_library(MG_FEATURES_TLS);\n\t\t} else {\n\t\t\t/* Initialize without SSL support */\n\t\t\tmg_init_library(MG_FEATURES_DEFAULT);\n\t\t}\n\t}\n\n\ttls.is_master = -1;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = NULL;\n#endif\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));\n#if !defined(ALTERNATIVE_QUEUE)\n\tok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));\n\tok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));\n#endif\n\tok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));\n\tif (!ok) {\n\t\t/* Fatal error - abort start. However, this situation should never\n\t\t * occur in practice. */\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot initialize thread synchronization objects\");\n\t\tmg_free(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tif (callbacks) {\n\t\tctx->callbacks = *callbacks;\n\t\texit_callback = callbacks->exit_context;\n\t\tctx->callbacks.exit_context = 0;\n\t}\n\tctx->user_data = user_data;\n\tctx->dd.handlers = NULL;\n\tctx->dd.next = NULL;\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tctx->dd.shared_lua_websockets = NULL;\n#endif\n\n\t/* Store options */\n\twhile (options && (name = *options++) != NULL) {\n\t\tif ((idx = get_option_index(name)) == -1) {\n\t\t\tmg_cry_internal(fc(ctx), \"Invalid option: %s\", name);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t} else if ((value = *options++) == NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"%s: option value cannot be NULL\", name);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (ctx->dd.config[idx] != NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"warning: %s: duplicate option\", name);\n\t\t\tmg_free(ctx->dd.config[idx]);\n\t\t}\n\t\tctx->dd.config[idx] = mg_strdup_ctx(value, ctx);\n\t\tDEBUG_TRACE(\"[%s] -> [%s]\", name, value);\n\t}\n\n\t/* Set default value if needed */\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdefault_value = config_options[i].default_value;\n\t\tif ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {\n\t\t\tctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);\n\t\t}\n\t}\n\n\t/* Request size option */\n\titmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);\n\tif (itmp < 1024) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"max_request_size too small\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\tctx->max_request_size = (unsigned)itmp;\n\n\t/* Worker thread count option */\n\tworkerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);\n\n\tif (workerthreadcount > MAX_WORKER_THREADS) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Too many worker threads\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tif (workerthreadcount <= 0) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Invalid number of worker threads\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n/* Document root */\n#if defined(NO_FILES)\n\tif (ctx->dd.config[DOCUMENT_ROOT] != NULL) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Document root must not be set\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n#endif\n\n\tget_system_name(&ctx->systemName);\n\n#if defined(USE_LUA)\n\t/* If a Lua background script has been configured, start it. */\n\tif (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {\n\t\tchar ebuf[256];\n\t\tstruct vec opt_vec;\n\t\tstruct vec eq_vec;\n\t\tconst char *sparams;\n\t\tlua_State *state = mg_prepare_lua_context_script(\n\t\t    ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));\n\t\tif (!state) {\n\t\t\tmg_cry_internal(fc(ctx), \"lua_background_script error: %s\", ebuf);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tctx->lua_background_state = (void *)state;\n\n\t\tlua_newtable(state);\n\t\treg_boolean(state, \"shutdown\", 0);\n\n\t\tsparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];\n\n\t\twhile ((sparams = next_option(sparams, &opt_vec, &eq_vec)) != NULL) {\n\t\t\treg_llstring(\n\t\t\t    state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);\n\t\t\tif (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tlua_setglobal(state, LUABACKGROUNDPARAMS);\n\n\t} else {\n\t\tctx->lua_background_state = 0;\n\t}\n#endif\n\n\t/* NOTE(lsm): order is important here. SSL certificates must\n\t * be initialized before listening ports. UID must be set last. */\n\tif (!set_gpass_option(ctx, NULL) ||\n#if !defined(NO_SSL)\n\t    !init_ssl_ctx(ctx, NULL) ||\n#endif\n\t    !set_ports_option(ctx) ||\n#if !defined(_WIN32)\n\t    !set_uid_option(ctx) ||\n#endif\n\t    !set_acl_option(ctx)) {\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));\n\tctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,\n\t                                                   sizeof(pthread_t),\n\t                                                   ctx);\n\n\tif (ctx->worker_threadids == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker thread ID array\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\tctx->worker_connections =\n\t    (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,\n\t                                          sizeof(struct mg_connection),\n\t                                          ctx);\n\tif (ctx->worker_connections == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker thread connection array\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\tctx->client_wait_events =\n\t    (void **)mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),\n\t                           ctx->cfg_worker_threads,\n\t                           ctx);\n\tif (ctx->client_wait_events == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker event array\");\n\t\tmg_free(ctx->worker_threadids);\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tctx->client_socks =\n\t    (struct socket *)mg_calloc_ctx(sizeof(ctx->client_socks[0]),\n\t                                   ctx->cfg_worker_threads,\n\t                                   ctx);\n\tif (ctx->client_socks == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker socket array\");\n\t\tmg_free(ctx->client_wait_events);\n\t\tmg_free(ctx->worker_threadids);\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {\n\t\tctx->client_wait_events[i] = event_create();\n\t\tif (ctx->client_wait_events[i] == 0) {\n\t\t\tmg_cry_internal(fc(ctx), \"Error creating worker event %i\", i);\n\t\t\twhile (i > 0) {\n\t\t\t\ti--;\n\t\t\t\tevent_destroy(ctx->client_wait_events[i]);\n\t\t\t}\n\t\t\tmg_free(ctx->client_socks);\n\t\t\tmg_free(ctx->client_wait_events);\n\t\t\tmg_free(ctx->worker_threadids);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\n#if defined(USE_TIMERS)\n\tif (timers_init(ctx) != 0) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Error creating timers\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Context has been created - init user libraries */\n\tif (ctx->callbacks.init_context) {\n\t\tctx->callbacks.init_context(ctx);\n\t}\n\tctx->callbacks.exit_context = exit_callback;\n\tctx->context_type = CONTEXT_SERVER; /* server context */\n\n\t/* Start master (listening) thread */\n\tmg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);\n\n\t/* Start worker threads */\n\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\tstruct worker_thread_args *wta = (struct worker_thread_args *)\n\t\t    mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);\n\t\tif (wta) {\n\t\t\twta->ctx = ctx;\n\t\t\twta->index = (int)i;\n\t\t}\n\n\t\tif ((wta == NULL)\n\t\t    || (mg_start_thread_with_id(worker_thread,\n\t\t                                wta,\n\t\t                                &ctx->worker_threadids[i]) != 0)) {\n\n\t\t\t/* thread was not created */\n\t\t\tif (wta != NULL) {\n\t\t\t\tmg_free(wta);\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t\t                \"Cannot start worker thread %i: error %ld\",\n\t\t\t\t                i + 1,\n\t\t\t\t                (long)ERRNO);\n\t\t\t} else {\n\t\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t\t                \"Cannot create threads: error %ld\",\n\t\t\t\t                (long)ERRNO);\n\t\t\t\tfree_context(ctx);\n\t\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpthread_setspecific(sTlsKey, NULL);\n\treturn ctx;\n}\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n/* Add an additional domain to an already running web server. */\nint\nmg_start_domain(struct mg_context *ctx, const char **options)\n{\n\tconst char *name;\n\tconst char *value;\n\tconst char *default_value;\n\tstruct mg_domain_context *new_dom;\n\tstruct mg_domain_context *dom;\n\tint idx, i;\n\n\tif ((ctx == NULL) || (ctx->stop_flag != 0) || (options == NULL)) {\n\t\treturn -1;\n\t}\n\n\tnew_dom = (struct mg_domain_context *)\n\t    mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);\n\n\tif (!new_dom) {\n\t\t/* Out of memory */\n\t\treturn -6;\n\t}\n\n\t/* Store options - TODO: unite duplicate code */\n\twhile (options && (name = *options++) != NULL) {\n\t\tif ((idx = get_option_index(name)) == -1) {\n\t\t\tmg_cry_internal(fc(ctx), \"Invalid option: %s\", name);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -2;\n\t\t} else if ((value = *options++) == NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"%s: option value cannot be NULL\", name);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -2;\n\t\t}\n\t\tif (new_dom->config[idx] != NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"warning: %s: duplicate option\", name);\n\t\t\tmg_free(new_dom->config[idx]);\n\t\t}\n\t\tnew_dom->config[idx] = mg_strdup_ctx(value, ctx);\n\t\tDEBUG_TRACE(\"[%s] -> [%s]\", name, value);\n\t}\n\n\t/* Authentication domain is mandatory */\n\t/* TODO: Maybe use a new option hostname? */\n\tif (!new_dom->config[AUTHENTICATION_DOMAIN]) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"authentication domain required\");\n\t\tmg_free(new_dom);\n\t\treturn -4;\n\t}\n\n\t/* Set default value if needed. Take the config value from\n\t * ctx as a default value. */\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdefault_value = ctx->dd.config[i];\n\t\tif ((new_dom->config[i] == NULL) && (default_value != NULL)) {\n\t\t\tnew_dom->config[i] = mg_strdup_ctx(default_value, ctx);\n\t\t}\n\t}\n\n\tnew_dom->handlers = NULL;\n\tnew_dom->next = NULL;\n\tnew_dom->nonce_count = 0;\n\tnew_dom->auth_nonce_mask =\n\t    (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tnew_dom->shared_lua_websockets = NULL;\n#endif\n\n\tif (!init_ssl_ctx(ctx, new_dom)) {\n\t\t/* Init SSL failed */\n\t\tmg_free(new_dom);\n\t\treturn -3;\n\t}\n\n\t/* Add element to linked list. */\n\tmg_lock_context(ctx);\n\n\tidx = 0;\n\tdom = &(ctx->dd);\n\tfor (;;) {\n\t\tif (!strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],\n\t\t                dom->config[AUTHENTICATION_DOMAIN])) {\n\t\t\t/* Domain collision */\n\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t                \"domain %s already in use\",\n\t\t\t                new_dom->config[AUTHENTICATION_DOMAIN]);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -5;\n\t\t}\n\n\t\t/* Count number of domains */\n\t\tidx++;\n\n\t\tif (dom->next == NULL) {\n\t\t\tdom->next = new_dom;\n\t\t\tbreak;\n\t\t}\n\t\tdom = dom->next;\n\t}\n\n\tmg_unlock_context(ctx);\n\n\t/* Return domain number */\n\treturn idx;\n}\n#endif\n\n\n/* Feature check API function */\nunsigned\nmg_check_feature(unsigned feature)\n{\n\tstatic const unsigned feature_set = 0\n/* Set bits for available features according to API documentation.\n * This bit mask is created at compile time, according to the active\n * preprocessor defines. It is a single const value at runtime. */\n#if !defined(NO_FILES)\n\t                                    | MG_FEATURES_FILES\n#endif\n#if !defined(NO_SSL)\n\t                                    | MG_FEATURES_SSL\n#endif\n#if !defined(NO_CGI)\n\t                                    | MG_FEATURES_CGI\n#endif\n#if defined(USE_IPV6)\n\t                                    | MG_FEATURES_IPV6\n#endif\n#if defined(USE_WEBSOCKET)\n\t                                    | MG_FEATURES_WEBSOCKET\n#endif\n#if defined(USE_LUA)\n\t                                    | MG_FEATURES_LUA\n#endif\n#if defined(USE_DUKTAPE)\n\t                                    | MG_FEATURES_SSJS\n#endif\n#if !defined(NO_CACHING)\n\t                                    | MG_FEATURES_CACHE\n#endif\n#if defined(USE_SERVER_STATS)\n\t                                    | MG_FEATURES_STATS\n#endif\n#if defined(USE_ZLIB)\n\t                                    | MG_FEATURES_COMPRESSION\n#endif\n\n/* Set some extra bits not defined in the API documentation.\n * These bits may change without further notice. */\n#if defined(MG_LEGACY_INTERFACE)\n\t                                    | 0x00008000u\n#endif\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n\t                                    | 0x00004000u\n#endif\n#if defined(MEMORY_DEBUGGING)\n\t                                    | 0x00001000u\n#endif\n#if defined(USE_TIMERS)\n\t                                    | 0x00020000u\n#endif\n#if !defined(NO_NONCE_CHECK)\n\t                                    | 0x00040000u\n#endif\n#if !defined(NO_POPEN)\n\t                                    | 0x00080000u\n#endif\n\t    ;\n\treturn (feature & feature_set);\n}\n\n\n/* strcat with additional NULL check to avoid clang scan-build warning. */\n#define strcat0(a, b)                                                          \\\n\t{                                                                          \\\n\t\tif ((a != NULL) && (b != NULL)) {                                      \\\n\t\t\tstrcat(a, b);                                                      \\\n\t\t}                                                                      \\\n\t}\n\n\n/* Get system information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_system_info_impl(char *buffer, int buflen)\n{\n\tchar block[256];\n\tint system_info_length = 0;\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tsystem_info_length += (int)strlen(block);\n\tif (system_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Server version */\n\t{\n\t\tconst char *version = mg_version();\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"version\\\" : \\\"%s\\\",%s\",\n\t\t            version,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* System info */\n\t{\n#if defined(_WIN32)\n\t\tDWORD dwVersion = 0;\n\t\tDWORD dwMajorVersion = 0;\n\t\tDWORD dwMinorVersion = 0;\n\t\tSYSTEM_INFO si;\n\n\t\tGetSystemInfo(&si);\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n/* GetVersion was declared deprecated */\n#pragma warning(disable : 4996)\n#endif\n\t\tdwVersion = GetVersion();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\t\tdwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\t\tdwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"os\\\" : \\\"Windows %u.%u\\\",%s\",\n\t\t            (unsigned)dwMajorVersion,\n\t\t            (unsigned)dwMinorVersion,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"cpu\\\" : \\\"type %u, cores %u, mask %x\\\",%s\",\n\t\t            (unsigned)si.wProcessorArchitecture,\n\t\t            (unsigned)si.dwNumberOfProcessors,\n\t\t            (unsigned)si.dwActiveProcessorMask,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#else\n\t\tstruct utsname name;\n\t\tmemset(&name, 0, sizeof(name));\n\t\tuname(&name);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"os\\\" : \\\"%s %s (%s) - %s\\\",%s\",\n\t\t            name.sysname,\n\t\t            name.version,\n\t\t            name.release,\n\t\t            name.machine,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Features */\n\t{\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"features\\\" : %lu,%s\"\n\t\t            \"\\\"feature_list\\\" : \\\"Server:%s%s%s%s%s%s%s%s%s\\\",%s\",\n\t\t            (unsigned long)mg_check_feature(0xFFFFFFFFu),\n\t\t            eol,\n\t\t            mg_check_feature(MG_FEATURES_FILES) ? \" Files\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_SSL) ? \" HTTPS\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_CGI) ? \" CGI\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_IPV6) ? \" IPv6\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_WEBSOCKET) ? \" WebSockets\"\n\t\t                                                    : \"\",\n\t\t            mg_check_feature(MG_FEATURES_LUA) ? \" Lua\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_SSJS) ? \" JavaScript\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_CACHE) ? \" Cache\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_STATS) ? \" Stats\" : \"\",\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n#if defined(USE_LUA)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"lua_version\\\" : \\\"%u (%s)\\\",%s\",\n\t\t            (unsigned)LUA_VERSION_NUM,\n\t\t            LUA_RELEASE,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n#if defined(USE_DUKTAPE)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"javascript\\\" : \\\"Duktape %u.%u.%u\\\",%s\",\n\t\t            (unsigned)DUK_VERSION / 10000,\n\t\t            ((unsigned)DUK_VERSION / 100) % 100,\n\t\t            (unsigned)DUK_VERSION % 100,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Build date */\n\t{\n#if defined(__GNUC__)\n#pragma GCC diagnostic push\n/* Disable bogus compiler warning -Wdate-time */\n#pragma GCC diagnostic ignored \"-Wdate-time\"\n#endif\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"build\\\" : \\\"%s\\\",%s\",\n\t\t            __DATE__,\n\t\t            eol);\n\n#if defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\n\t/* Compiler information */\n\t/* http://sourceforge.net/p/predef/wiki/Compilers/ */\n\t{\n#if defined(_MSC_VER)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MSC: %u (%u)\\\",%s\",\n\t\t            (unsigned)_MSC_VER,\n\t\t            (unsigned)_MSC_FULL_VER,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__MINGW64__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW64: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW64_VERSION_MAJOR,\n\t\t            (unsigned)__MINGW64_VERSION_MINOR,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW32: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW32_MAJOR_VERSION,\n\t\t            (unsigned)__MINGW32_MINOR_VERSION,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__MINGW32__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW32: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW32_MAJOR_VERSION,\n\t\t            (unsigned)__MINGW32_MINOR_VERSION,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__clang__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"clang: %u.%u.%u (%s)\\\",%s\",\n\t\t            __clang_major__,\n\t\t            __clang_minor__,\n\t\t            __clang_patchlevel__,\n\t\t            __clang_version__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__GNUC__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"gcc: %u.%u.%u\\\",%s\",\n\t\t            (unsigned)__GNUC__,\n\t\t            (unsigned)__GNUC_MINOR__,\n\t\t            (unsigned)__GNUC_PATCHLEVEL__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__INTEL_COMPILER)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Intel C/C++: %u\\\",%s\",\n\t\t            (unsigned)__INTEL_COMPILER,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__BORLANDC__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Borland C: 0x%x\\\",%s\",\n\t\t            (unsigned)__BORLANDC__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__SUNPRO_C)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Solaris: 0x%x\\\",%s\",\n\t\t            (unsigned)__SUNPRO_C,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#else\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"other\\\",%s\",\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Determine 32/64 bit data mode.\n\t * see https://en.wikipedia.org/wiki/64-bit_computing */\n\t{\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data_model\\\" : \\\"int:%u/%u/%u/%u, float:%u/%u/%u, \"\n\t\t            \"char:%u/%u, \"\n\t\t            \"ptr:%u, size:%u, time:%u\\\"%s\",\n\t\t            (unsigned)sizeof(short),\n\t\t            (unsigned)sizeof(int),\n\t\t            (unsigned)sizeof(long),\n\t\t            (unsigned)sizeof(long long),\n\t\t            (unsigned)sizeof(float),\n\t\t            (unsigned)sizeof(double),\n\t\t            (unsigned)sizeof(long double),\n\t\t            (unsigned)sizeof(char),\n\t\t            (unsigned)sizeof(wchar_t),\n\t\t            (unsigned)sizeof(void *),\n\t\t            (unsigned)sizeof(size_t),\n\t\t            (unsigned)sizeof(time_t),\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tsystem_info_length += reserved_len;\n\n\treturn system_info_length;\n}\n\n\n#if defined(USE_SERVER_STATS)\n/* Get context information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_context_info_impl(const struct mg_context *ctx, char *buffer, int buflen)\n\n{\n\tchar block[256];\n\tint context_info_length = 0;\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\tstruct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tcontext_info_length += (int)strlen(block);\n\tif (context_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\tif (ms) { /* <-- should be always true */\n\t\t/* Memory information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"memory\\\" : {%s\"\n\t\t            \"\\\"blocks\\\" : %i,%s\"\n\t\t            \"\\\"used\\\" : %\" INT64_FMT \",%s\"\n\t\t            \"\\\"maxUsed\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"}%s%s\",\n\t\t            eol,\n\t\t            ms->blockCount,\n\t\t            eol,\n\t\t            ms->totalMemUsed,\n\t\t            eol,\n\t\t            ms->maxMemUsed,\n\t\t            eol,\n\t\t            (ctx ? \",\" : \"\"),\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\tif (ctx) {\n\t\t/* Declare all variables at begin of the block, to comply\n\t\t * with old C standards. */\n\t\tchar start_time_str[64] = {0};\n\t\tchar now_str[64] = {0};\n\t\ttime_t start_time = ctx->start_time;\n\t\ttime_t now = time(NULL);\n\n\t\t/* Connections information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"connections\\\" : {%s\"\n\t\t            \"\\\"active\\\" : %i,%s\"\n\t\t            \"\\\"maxActive\\\" : %i,%s\"\n\t\t            \"\\\"total\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->active_connections,\n\t\t            eol,\n\t\t            ctx->max_connections,\n\t\t            eol,\n\t\t            ctx->total_connections,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Requests information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"requests\\\" : {%s\"\n\t\t            \"\\\"total\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->total_requests,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Data information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data\\\" : {%s\"\n\t\t            \"\\\"read\\\" : %\" INT64_FMT \"%s,\"\n\t\t            \"\\\"written\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->total_data_read,\n\t\t            eol,\n\t\t            ctx->total_data_written,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Execution time information */\n\t\tgmt_time_string(start_time_str,\n\t\t                sizeof(start_time_str) - 1,\n\t\t                &start_time);\n\t\tgmt_time_string(now_str, sizeof(now_str) - 1, &now);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"time\\\" : {%s\"\n\t\t            \"\\\"uptime\\\" : %.0f,%s\"\n\t\t            \"\\\"start\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"now\\\" : \\\"%s\\\"%s\"\n\t\t            \"}%s\",\n\t\t            eol,\n\t\t            difftime(now, start_time),\n\t\t            eol,\n\t\t            start_time_str,\n\t\t            eol,\n\t\t            now_str,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (context_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tcontext_info_length += reserved_len;\n\n\treturn context_info_length;\n}\n#endif\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n/* Get connection information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_connection_info_impl(const struct mg_context *ctx,\n                            int idx,\n                            char *buffer,\n                            int buflen)\n{\n\tconst struct mg_connection *conn;\n\tconst struct mg_request_info *ri;\n\tchar block[256];\n\tint connection_info_length = 0;\n\tint state = 0;\n\tconst char *state_str = \"unknown\";\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tif ((ctx == NULL) || (idx < 0)) {\n\t\t/* Parameter error */\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)idx >= ctx->cfg_worker_threads) {\n\t\t/* Out of range */\n\t\treturn 0;\n\t}\n\n\t/* Take connection [idx]. This connection is not locked in\n\t * any way, so some other thread might use it. */\n\tconn = (ctx->worker_connections) + idx;\n\n\t/* Initialize output string */\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tconnection_info_length += (int)strlen(block);\n\tif (connection_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Init variables */\n\tri = &(conn->request_info);\n\n#if defined(USE_SERVER_STATS)\n\tstate = conn->conn_state;\n\n\t/* State as string */\n\tswitch (state) {\n\tcase 0:\n\t\tstate_str = \"undefined\";\n\t\tbreak;\n\tcase 1:\n\t\tstate_str = \"not used\";\n\t\tbreak;\n\tcase 2:\n\t\tstate_str = \"init\";\n\t\tbreak;\n\tcase 3:\n\t\tstate_str = \"ready\";\n\t\tbreak;\n\tcase 4:\n\t\tstate_str = \"processing\";\n\t\tbreak;\n\tcase 5:\n\t\tstate_str = \"processed\";\n\t\tbreak;\n\tcase 6:\n\t\tstate_str = \"to close\";\n\t\tbreak;\n\tcase 7:\n\t\tstate_str = \"closing\";\n\t\tbreak;\n\tcase 8:\n\t\tstate_str = \"closed\";\n\t\tbreak;\n\tcase 9:\n\t\tstate_str = \"done\";\n\t\tbreak;\n\t}\n#endif\n\n\t/* Connection info */\n\tif ((state >= 3) && (state < 9)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"connection\\\" : {%s\"\n\t\t            \"\\\"remote\\\" : {%s\"\n\t\t            \"\\\"protocol\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"addr\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"port\\\" : %u%s\"\n\t\t            \"},%s\"\n\t\t            \"\\\"handled_requests\\\" : %u%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            eol,\n\t\t            get_proto_name(conn),\n\t\t            eol,\n\t\t            ri->remote_addr,\n\t\t            eol,\n\t\t            ri->remote_port,\n\t\t            eol,\n\t\t            eol,\n\t\t            conn->handled_requests,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Request info */\n\tif ((state >= 4) && (state < 6)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"request_info\\\" : {%s\"\n\t\t            \"\\\"method\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"uri\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"query\\\" : %s%s%s%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ri->request_method,\n\t\t            eol,\n\t\t            ri->request_uri,\n\t\t            eol,\n\t\t            ri->query_string ? \"\\\"\" : \"\",\n\t\t            ri->query_string ? ri->query_string : \"null\",\n\t\t            ri->query_string ? \"\\\"\" : \"\",\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Execution time information */\n\tif ((state >= 2) && (state < 9)) {\n\t\tchar start_time_str[64] = {0};\n\t\tchar now_str[64] = {0};\n\t\ttime_t start_time = conn->conn_birth_time;\n\t\ttime_t now = time(NULL);\n\n\t\tgmt_time_string(start_time_str,\n\t\t                sizeof(start_time_str) - 1,\n\t\t                &start_time);\n\t\tgmt_time_string(now_str, sizeof(now_str) - 1, &now);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"time\\\" : {%s\"\n\t\t            \"\\\"uptime\\\" : %.0f,%s\"\n\t\t            \"\\\"start\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"now\\\" : \\\"%s\\\"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            difftime(now, start_time),\n\t\t            eol,\n\t\t            start_time_str,\n\t\t            eol,\n\t\t            now_str,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Remote user name */\n\tif ((ri->remote_user) && (state < 9)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"user\\\" : {%s\"\n\t\t            \"\\\"name\\\" : \\\"%s\\\",%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ri->remote_user,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Data block */\n\tif (state >= 3) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data\\\" : {%s\"\n\t\t            \"\\\"read\\\" : %\" INT64_FMT \",%s\"\n\t\t            \"\\\"written\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            conn->consumed_content,\n\t\t            eol,\n\t\t            conn->num_bytes_sent,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* State */\n\tmg_snprintf(NULL,\n\t            NULL,\n\t            block,\n\t            sizeof(block),\n\t            \"\\\"state\\\" : \\\"%s\\\"%s\",\n\t            state_str,\n\t            eol);\n\n\tconnection_info_length += (int)strlen(block);\n\tif (connection_info_length + reserved_len < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (connection_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tconnection_info_length += reserved_len;\n\n\treturn connection_info_length;\n}\n#endif\n\n\n/* Get system information. It can be printed or stored by the caller.\n * Return the size of available information. */\nint\nmg_get_system_info(char *buffer, int buflen)\n{\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_system_info_impl(NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_system_info_impl(buffer, buflen);\n\t}\n}\n\n\n/* Get context information. It can be printed or stored by the caller.\n * Return the size of available information. */\nint\nmg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen)\n{\n#if defined(USE_SERVER_STATS)\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_context_info_impl(ctx, NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_context_info_impl(ctx, buffer, buflen);\n\t}\n#else\n\t(void)ctx;\n\tif ((buffer != NULL) && (buflen > 0)) {\n\t\tbuffer[0] = 0;\n\t}\n\treturn 0;\n#endif\n}\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\nint\nmg_get_connection_info(const struct mg_context *ctx,\n                       int idx,\n                       char *buffer,\n                       int buflen)\n{\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_connection_info_impl(ctx, idx, NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_connection_info_impl(ctx, idx, buffer, buflen);\n\t}\n}\n#endif\n\n\n/* Initialize this library. This function does not need to be thread safe.\n */\nunsigned\nmg_init_library(unsigned features)\n{\n#if !defined(NO_SSL)\n\tchar ebuf[128];\n#endif\n\n\tunsigned features_to_init = mg_check_feature(features & 0xFFu);\n\tunsigned features_inited = features_to_init;\n\n\tif (mg_init_library_called <= 0) {\n\t\t/* Not initialized yet */\n\t\tif (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmg_global_lock();\n\n\tif (mg_init_library_called <= 0) {\n\t\tif (0 != pthread_key_create(&sTlsKey, tls_dtor)) {\n\t\t\t/* Fatal error - abort start. However, this situation should\n\t\t\t * never occur in practice. */\n\t\t\tmg_global_unlock();\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\tInitializeCriticalSection(&global_log_file_lock);\n#endif\n#if !defined(_WIN32)\n\t\tpthread_mutexattr_init(&pthread_mutex_attr);\n\t\tpthread_mutexattr_settype(&pthread_mutex_attr, PTHREAD_MUTEX_RECURSIVE);\n#endif\n\n#if defined(USE_LUA)\n\t\tlua_init_optional_libraries();\n#endif\n\t}\n\n\tmg_global_unlock();\n\n#if !defined(NO_SSL)\n\tif (features_to_init & MG_FEATURES_SSL) {\n\t\tif (!mg_ssl_initialized) {\n\t\t\tif (initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\t\t\tmg_ssl_initialized = 1;\n\t\t\t} else {\n\t\t\t\t(void)ebuf;\n\t\t\t\tDEBUG_TRACE(\"Initializing SSL failed: %s\", ebuf);\n\t\t\t\tfeatures_inited &= ~((unsigned)(MG_FEATURES_SSL));\n\t\t\t}\n\t\t} else {\n\t\t\t/* ssl already initialized */\n\t\t}\n\t}\n#endif\n\n\t/* Start WinSock for Windows */\n\tmg_global_lock();\n\tif (mg_init_library_called <= 0) {\n#if defined(_WIN32)\n\t\tWSADATA data;\n\t\tWSAStartup(MAKEWORD(2, 2), &data);\n#endif /* _WIN32 */\n\t\tmg_init_library_called = 1;\n\t} else {\n\t\tmg_init_library_called++;\n\t}\n\tmg_global_unlock();\n\n\treturn features_inited;\n}\n\n\n/* Un-initialize this library. */\nunsigned\nmg_exit_library(void)\n{\n\tif (mg_init_library_called <= 0) {\n\t\treturn 0;\n\t}\n\n\tmg_global_lock();\n\n\tmg_init_library_called--;\n\tif (mg_init_library_called == 0) {\n#if defined(_WIN32)\n\t\t(void)WSACleanup();\n#endif /* _WIN32  */\n#if !defined(NO_SSL)\n\t\tif (mg_ssl_initialized) {\n\t\t\tuninitialize_ssl();\n\t\t\tmg_ssl_initialized = 0;\n\t\t}\n#endif\n\n#if defined(_WIN32)\n\t\t(void)DeleteCriticalSection(&global_log_file_lock);\n#endif /* _WIN32 */\n#if !defined(_WIN32)\n\t\t(void)pthread_mutexattr_destroy(&pthread_mutex_attr);\n#endif\n\n\t\t(void)pthread_key_delete(sTlsKey);\n\n#if defined(USE_LUA)\n\t\tlua_exit_optional_libraries();\n#endif\n\n\t\tmg_global_unlock();\n\t\t(void)pthread_mutex_destroy(&global_lock_mutex);\n\t\treturn 1;\n\t}\n\n\tmg_global_unlock();\n\treturn 1;\n}\n\n\n/* End of civetweb.c */\n"], "filenames": ["src/civetweb.c"], "buggy_code_start_loc": [11614], "buggy_code_end_loc": [11618], "fixing_code_start_loc": [11614], "fixing_code_end_loc": [11618], "type": "CWE-125", "message": "Out-of-bounds Read in the send_ssi_file function in civetweb.c in CivetWeb through 1.10 allows attackers to cause a Denial of Service or Information Disclosure via a crafted SSI file.", "other": {"cve": {"id": "CVE-2018-12684", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-22T19:29:00.267", "lastModified": "2018-08-10T13:26:35.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in the send_ssi_file function in civetweb.c in CivetWeb through 1.10 allows attackers to cause a Denial of Service or Information Disclosure via a crafted SSI file."}, {"lang": "es", "value": "Lectura fuera de l\u00edmites en la funci\u00f3n send_ssi_file en civetweb.c en CivetWeb hasta la versi\u00f3n 1.10 permite que los atacantes provoquen una divulgaci\u00f3n de informaci\u00f3n por denegaci\u00f3n de servicio (DoS) mediante un archivo SSI manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:civetweb_project:civetweb:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.10", "matchCriteriaId": "D8A77DAD-2799-4DB4-8572-4DE74FCF8AC8"}]}]}], "references": [{"url": "https://github.com/civetweb/civetweb/commit/8fd069f6dedb064339f1091069ac96f3f8bdb552", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/civetweb/civetweb/issues/633", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/civetweb/civetweb/commit/8fd069f6dedb064339f1091069ac96f3f8bdb552"}}