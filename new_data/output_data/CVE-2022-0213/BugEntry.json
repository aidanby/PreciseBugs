{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * drawscreen.c: Code for updating all the windows on the screen.\n * This is the top level, drawline.c is the middle and screen.c the lower\n * level.\n *\n * update_screen() is the function that updates all windows and status lines.\n * It is called form the main loop when must_redraw is non-zero.  It may be\n * called from other places when an immediate screen update is needed.\n *\n * The part of the buffer that is displayed in a window is set with:\n * - w_topline (first buffer line in window)\n * - w_topfill (filler lines above the first line)\n * - w_leftcol (leftmost window cell in window),\n * - w_skipcol (skipped window cells of first line)\n *\n * Commands that only move the cursor around in a window, do not need to take\n * action to update the display.  The main loop will check if w_topline is\n * valid and update it (scroll the window) when needed.\n *\n * Commands that scroll a window change w_topline and must call\n * check_cursor() to move the cursor into the visible part of the window, and\n * call redraw_later(VALID) to have the window displayed by update_screen()\n * later.\n *\n * Commands that change text in the buffer must call changed_bytes() or\n * changed_lines() to mark the area that changed and will require updating\n * later.  The main loop will call update_screen(), which will update each\n * window that shows the changed buffer.  This assumes text above the change\n * can remain displayed as it is.  Text after the change may need updating for\n * scrolling, folding and syntax highlighting.\n *\n * Commands that change how a window is displayed (e.g., setting 'list') or\n * invalidate the contents of a window in another way (e.g., change fold\n * settings), must call redraw_later(NOT_VALID) to have the whole window\n * redisplayed by update_screen() later.\n *\n * Commands that change how a buffer is displayed (e.g., setting 'tabstop')\n * must call redraw_curbuf_later(NOT_VALID) to have all the windows for the\n * buffer redisplayed by update_screen() later.\n *\n * Commands that change highlighting and possibly cause a scroll too must call\n * redraw_later(SOME_VALID) to update the whole window but still use scrolling\n * to avoid redrawing everything.  But the length of displayed lines must not\n * change, use NOT_VALID then.\n *\n * Commands that move the window position must call redraw_later(NOT_VALID).\n * TODO: should minimize redrawing by scrolling when possible.\n *\n * Commands that change everything (e.g., resizing the screen) must call\n * redraw_all_later(NOT_VALID) or redraw_all_later(CLEAR).\n *\n * Things that are handled indirectly:\n * - When messages scroll the screen up, msg_scrolled will be set and\n *   update_screen() called to redraw.\n */\n\n#include \"vim.h\"\n\nstatic void win_update(win_T *wp);\n#ifdef FEAT_STL_OPT\nstatic void redraw_custom_statusline(win_T *wp);\n#endif\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)\nstatic int  did_update_one_window;\n#endif\n\nstatic void win_redr_status(win_T *wp, int ignore_pum);\n\n/*\n * Based on the current value of curwin->w_topline, transfer a screenfull\n * of stuff from Filemem to ScreenLines[], and update curwin->w_botline.\n * Return OK when the screen was updated, FAIL if it was not done.\n */\n    int\nupdate_screen(int type_arg)\n{\n    int\t\ttype = type_arg;\n    win_T\t*wp;\n    static int\tdid_intro = FALSE;\n#ifdef FEAT_GUI\n    int\t\tdid_one = FALSE;\n    int\t\tdid_undraw = FALSE;\n    int\t\tgui_cursor_col = 0;\n    int\t\tgui_cursor_row = 0;\n#endif\n    int\t\tno_update = FALSE;\n    int\t\tsave_pum_will_redraw = pum_will_redraw;\n\n    // Don't do anything if the screen structures are (not yet) valid.\n    if (!screen_valid(TRUE))\n\treturn FAIL;\n\n    if (type == VALID_NO_UPDATE)\n    {\n\tno_update = TRUE;\n\ttype = 0;\n    }\n\n#ifdef FEAT_EVAL\n    {\n\tbuf_T *buf;\n\n\t// Before updating the screen, notify any listeners of changed text.\n\tFOR_ALL_BUFFERS(buf)\n\t    invoke_listeners(buf);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // May have postponed updating diffs.\n    if (need_diff_redraw)\n\tdiff_redraw(TRUE);\n#endif\n\n    if (must_redraw)\n    {\n\tif (type < must_redraw)\t    // use maximal type\n\t    type = must_redraw;\n\n\t// must_redraw is reset here, so that when we run into some weird\n\t// reason to redraw while busy redrawing (e.g., asynchronous\n\t// scrolling), or update_topline() in win_update() will cause a\n\t// scroll, the screen will be redrawn later or in win_update().\n\tmust_redraw = 0;\n    }\n\n    // May need to update w_lines[].\n    if (curwin->w_lines_valid == 0 && type < NOT_VALID\n#ifdef FEAT_TERMINAL\n\t    && !term_do_update_window(curwin)\n#endif\n\t\t)\n\ttype = NOT_VALID;\n\n    // Postpone the redrawing when it's not needed and when being called\n    // recursively.\n    if (!redrawing() || updating_screen)\n    {\n\tredraw_later(type);\t\t// remember type for next time\n\tmust_redraw = type;\n\tif (type > INVERTED_ALL)\n\t    curwin->w_lines_valid = 0;\t// don't use w_lines[].wl_size now\n\treturn FAIL;\n    }\n    updating_screen = TRUE;\n\n#ifdef FEAT_PROP_POPUP\n    // Update popup_mask if needed.  This may set w_redraw_top and w_redraw_bot\n    // in some windows.\n    may_update_popup_mask(type);\n#endif\n\n#ifdef FEAT_SYN_HL\n    ++display_tick;\t    // let syntax code know we're in a next round of\n\t\t\t    // display updating\n#endif\n    if (no_update)\n\t++no_win_do_lines_ins;\n\n    // if the screen was scrolled up when displaying a message, scroll it down\n    if (msg_scrolled)\n    {\n\tclear_cmdline = TRUE;\n\tif (msg_scrolled > Rows - 5)\t    // clearing is faster\n\t    type = CLEAR;\n\telse if (type != CLEAR)\n\t{\n\t    check_for_delay(FALSE);\n\t    if (screen_ins_lines(0, 0, msg_scrolled, (int)Rows, 0, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\ttype = CLEAR;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp->w_winrow < msg_scrolled)\n\t\t{\n\t\t    if (W_WINROW(wp) + wp->w_height > msg_scrolled\n\t\t\t    && wp->w_redr_type < REDRAW_TOP\n\t\t\t    && wp->w_lines_valid > 0\n\t\t\t    && wp->w_topline == wp->w_lines[0].wl_lnum)\n\t\t    {\n\t\t\twp->w_upd_rows = msg_scrolled - W_WINROW(wp);\n\t\t\twp->w_redr_type = REDRAW_TOP;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\twp->w_redr_type = NOT_VALID;\n\t\t\tif (W_WINROW(wp) + wp->w_height + wp->w_status_height\n\t\t\t\t\t\t\t       <= msg_scrolled)\n\t\t\t    wp->w_redr_status = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!no_update)\n\t\tredraw_cmdline = TRUE;\n\t    redraw_tabline = TRUE;\n\t}\n\tmsg_scrolled = 0;\n\tneed_wait_return = FALSE;\n    }\n\n    // reset cmdline_row now (may have been changed temporarily)\n    compute_cmdrow();\n\n    // Check for changed highlighting\n    if (need_highlight_changed)\n\thighlight_changed();\n\n    if (type == CLEAR)\t\t// first clear screen\n    {\n\tscreenclear();\t\t// will reset clear_cmdline\n\ttype = NOT_VALID;\n\t// must_redraw may be set indirectly, avoid another redraw later\n\tmust_redraw = 0;\n    }\n\n    if (clear_cmdline)\t\t// going to clear cmdline (done below)\n\tcheck_for_delay(FALSE);\n\n#ifdef FEAT_LINEBREAK\n    // Force redraw when width of 'number' or 'relativenumber' column\n    // changes.\n    if (curwin->w_redr_type < NOT_VALID\n\t   && curwin->w_nrwidth != ((curwin->w_p_nu || curwin->w_p_rnu)\n\t\t\t\t    ? number_width(curwin) : 0))\n\tcurwin->w_redr_type = NOT_VALID;\n#endif\n\n    // Only start redrawing if there is really something to do.\n    if (type == INVERTED)\n\tupdate_curswant();\n    if (curwin->w_redr_type < type\n\t    && !((type == VALID\n\t\t    && curwin->w_lines[0].wl_valid\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill == curwin->w_old_topfill\n\t\t    && curwin->w_botfill == curwin->w_old_botfill\n#endif\n\t\t    && curwin->w_topline == curwin->w_lines[0].wl_lnum)\n\t\t|| (type == INVERTED\n\t\t    && VIsual_active\n\t\t    && curwin->w_old_cursor_lnum == curwin->w_cursor.lnum\n\t\t    && curwin->w_old_visual_mode == VIsual_mode\n\t\t    && (curwin->w_valid & VALID_VIRTCOL)\n\t\t    && curwin->w_old_curswant == curwin->w_curswant)\n\t\t))\n\tcurwin->w_redr_type = type;\n\n    // Redraw the tab pages line if needed.\n    if (redraw_tabline || type >= NOT_VALID)\n\tdraw_tabline();\n\n#ifdef FEAT_SYN_HL\n    // Correct stored syntax highlighting info for changes in each displayed\n    // buffer.  Each buffer must only be done once.\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer->b_mod_set)\n\t{\n\t    win_T\t*wwp;\n\n\t    // Check if we already did this buffer.\n\t    for (wwp = firstwin; wwp != wp; wwp = wwp->w_next)\n\t\tif (wwp->w_buffer == wp->w_buffer)\n\t\t    break;\n\t    if (wwp == wp && syntax_present(wp))\n\t\tsyn_stack_apply_changes(wp->w_buffer);\n\t}\n    }\n#endif\n\n    if (pum_redraw_in_same_position())\n\t// Avoid flicker if the popup menu is going to be redrawn in the same\n\t// position.\n\tpum_will_redraw = TRUE;\n\n    // Go from top to bottom through the windows, redrawing the ones that need\n    // it.\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)\n    did_update_one_window = FALSE;\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n    screen_search_hl.rm.regprog = NULL;\n#endif\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_redr_type != 0)\n\t{\n\t    cursor_off();\n#ifdef FEAT_GUI\n\t    if (!did_one)\n\t    {\n\t\tdid_one = TRUE;\n\n\t\t// Remove the cursor before starting to do anything, because\n\t\t// scrolling may make it difficult to redraw the text under\n\t\t// it.\n\t\t// Also remove the cursor if it needs to be hidden due to an\n\t\t// ongoing cursor-less sleep.\n\t\tif (gui.in_use && (wp == curwin || cursor_is_sleeping()))\n\t\t{\n\t\t    gui_cursor_col = gui.cursor_col;\n\t\t    gui_cursor_row = gui.cursor_row;\n\t\t    gui_undraw_cursor();\n\t\t    did_undraw = TRUE;\n\t\t}\n\t    }\n#endif\n\t    win_update(wp);\n\t}\n\n\t// redraw status line after the window to minimize cursor movement\n\tif (wp->w_redr_status)\n\t{\n\t    cursor_off();\n\t    win_redr_status(wp, TRUE); // any popup menu will be redrawn below\n\t}\n    }\n#if defined(FEAT_SEARCH_EXTRA)\n    end_search_hl();\n#endif\n\n    // May need to redraw the popup menu.\n    pum_will_redraw = save_pum_will_redraw;\n    pum_may_redraw();\n\n    // Reset b_mod_set flags.  Going through all windows is probably faster\n    // than going through all buffers (there could be many buffers).\n    FOR_ALL_WINDOWS(wp)\n\twp->w_buffer->b_mod_set = FALSE;\n\n#ifdef FEAT_PROP_POPUP\n    // Display popup windows on top of the windows and command line.\n    update_popups(win_update);\n#endif\n\n#ifdef FEAT_TERMINAL\n    FOR_ALL_WINDOWS(wp)\n\t// If this window contains a terminal, after redrawing all windows, the\n\t// dirty row range can be reset.\n\tterm_did_update_window(wp);\n#endif\n\n    after_updating_screen(TRUE);\n\n    // Clear or redraw the command line.  Done last, because scrolling may\n    // mess up the command line.\n    if (clear_cmdline || redraw_cmdline || redraw_mode)\n\tshowmode();\n\n    if (no_update)\n\t--no_win_do_lines_ins;\n\n    // May put up an introductory message when not editing a file\n    if (!did_intro)\n\tmaybe_intro_message();\n    did_intro = TRUE;\n\n#ifdef FEAT_GUI\n    // Redraw the cursor and update the scrollbars when all screen updating is\n    // done.\n    if (gui.in_use)\n    {\n\tif (did_undraw && !gui_mch_is_blink_off())\n\t{\n\t    mch_disable_flush();\n\t    out_flush();\t// required before updating the cursor\n\t    mch_enable_flush();\n\n\t    // Put the GUI position where the cursor was, gui_update_cursor()\n\t    // uses that.\n\t    gui.col = gui_cursor_col;\n\t    gui.row = gui_cursor_row;\n\t    gui.col = mb_fix_col(gui.col, gui.row);\n\t    gui_update_cursor(FALSE, FALSE);\n\t    gui_may_flush();\n\t    screen_cur_col = gui.col;\n\t    screen_cur_row = gui.row;\n\t}\n\telse\n\t    out_flush();\n\tgui_update_scrollbars(FALSE);\n    }\n#endif\n    return OK;\n}\n\n/*\n * Return the row for drawing the statusline and the ruler of window \"wp\".\n */\n    int\nstatusline_row(win_T *wp)\n{\n#if defined(FEAT_PROP_POPUP)\n    // If the window is really zero height the winbar isn't displayed.\n    if (wp->w_frame->fr_height == wp->w_status_height && !popup_is_popup(wp))\n\treturn wp->w_winrow;\n#endif\n    return W_WINROW(wp) + wp->w_height;\n}\n\n/*\n * Redraw the status line of window wp.\n *\n * If inversion is possible we use it. Else '=' characters are used.\n * If \"ignore_pum\" is TRUE, also redraw statusline when the popup menu is\n * displayed.\n */\n    static void\nwin_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif (bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t|| wp->w_p_pvw\n#endif\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}\n\n#ifdef FEAT_STL_OPT\n/*\n * Redraw the status line according to 'statusline' and take care of any\n * errors encountered.\n */\n    static void\nredraw_custom_statusline(win_T *wp)\n{\n    static int\t    entered = FALSE;\n    int\t\t    saved_did_emsg = did_emsg;\n\n    // When called recursively return.  This can happen when the statusline\n    // contains an expression that triggers a redraw.\n    if (entered)\n\treturn;\n    entered = TRUE;\n\n    did_emsg = FALSE;\n    win_redr_custom(wp, FALSE);\n    if (did_emsg)\n    {\n\t// When there is an error disable the statusline, otherwise the\n\t// display is messed up with errors and a redraw triggers the problem\n\t// again and again.\n\tset_string_option_direct((char_u *)\"statusline\", -1,\n\t\t(char_u *)\"\", OPT_FREE | (*wp->w_p_stl != NUL\n\t\t\t\t\t? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);\n    }\n    did_emsg |= saved_did_emsg;\n    entered = FALSE;\n}\n#endif\n\n/*\n * Show current status info in ruler and various other places\n * If always is FALSE, only show ruler if position has changed.\n */\n    void\nshowruler(int always)\n{\n    if (!always && !redrawing())\n\treturn;\n    if (pum_visible())\n    {\n\t// Don't redraw right now, do it later.\n\tcurwin->w_redr_status = TRUE;\n\treturn;\n    }\n#if defined(FEAT_STL_OPT)\n    if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)\n\tredraw_custom_statusline(curwin);\n    else\n#endif\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(curwin, always, FALSE);\n#endif\n\n    if (need_maketitle\n#ifdef FEAT_STL_OPT\n\t    || (p_icon && (stl_syntax & STL_IN_ICON))\n\t    || (p_title && (stl_syntax & STL_IN_TITLE))\n#endif\n       )\n\tmaketitle();\n\n    // Redraw the tab pages line if needed.\n    if (redraw_tabline)\n\tdraw_tabline();\n}\n\n#if defined(FEAT_CMDL_INFO) || defined(PROTO)\n    void\nwin_redr_ruler(win_T *wp, int always, int ignore_pum)\n{\n#define RULER_BUF_LEN 70\n    char_u\tbuffer[RULER_BUF_LEN];\n    int\t\trow;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tempty_line = FALSE;\n    colnr_T\tvirtcol;\n    int\t\ti;\n    size_t\tlen;\n    int\t\to;\n    int\t\tthis_ru_col;\n    int\t\toff = 0;\n    int\t\twidth;\n\n    // If 'ruler' off or redrawing disabled, don't do anything\n    if (!p_ru)\n\treturn;\n\n    /*\n     * Check if cursor.lnum is valid, since win_redr_ruler() may be called\n     * after deleting lines, before cursor.lnum is corrected.\n     */\n    if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)\n\treturn;\n\n    // Don't draw the ruler while doing insert-completion, it might overwrite\n    // the (long) mode message.\n    if (wp == lastwin && lastwin->w_status_height == 0)\n\tif (edit_submode != NULL)\n\t    return;\n    // Don't draw the ruler when the popup menu is visible, it may overlap.\n    // Except when the popup menu will be redrawn anyway.\n    if (!ignore_pum && pum_visible())\n\treturn;\n\n#ifdef FEAT_STL_OPT\n    if (*p_ruf)\n    {\n\tint\tcalled_emsg_before = called_emsg;\n\n\twin_redr_custom(wp, TRUE);\n\tif (called_emsg > called_emsg_before)\n\t    set_string_option_direct((char_u *)\"rulerformat\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\treturn;\n    }\n#endif\n\n    /*\n     * Check if not in Insert mode and the line is empty (will show \"0-1\").\n     */\n    if (!(State & INSERT)\n\t\t&& *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)\n\tempty_line = TRUE;\n\n    /*\n     * Only draw the ruler when something changed.\n     */\n    validate_virtcol_win(wp);\n    if (       redraw_cmdline\n\t    || always\n\t    || wp->w_cursor.lnum != wp->w_ru_cursor.lnum\n\t    || wp->w_cursor.col != wp->w_ru_cursor.col\n\t    || wp->w_virtcol != wp->w_ru_virtcol\n\t    || wp->w_cursor.coladd != wp->w_ru_cursor.coladd\n\t    || wp->w_topline != wp->w_ru_topline\n\t    || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count\n#ifdef FEAT_DIFF\n\t    || wp->w_topfill != wp->w_ru_topfill\n#endif\n\t    || empty_line != wp->w_ru_empty)\n    {\n\tcursor_off();\n\tif (wp->w_status_height)\n\t{\n\t    row = statusline_row(wp);\n\t    fillchar = fillchar_status(&attr, wp);\n\t    off = wp->w_wincol;\n\t    width = wp->w_width;\n\t}\n\telse\n\t{\n\t    row = Rows - 1;\n\t    fillchar = ' ';\n\t    attr = 0;\n\t    width = Columns;\n\t    off = 0;\n\t}\n\n\t// In list mode virtcol needs to be recomputed\n\tvirtcol = wp->w_virtcol;\n\tif (wp->w_p_list && wp->w_lcs_chars.tab1 == NUL)\n\t{\n\t    wp->w_p_list = FALSE;\n\t    getvvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);\n\t    wp->w_p_list = TRUE;\n\t}\n\n\t/*\n\t * Some sprintfs return the length, some return a pointer.\n\t * To avoid portability problems we use strlen() here.\n\t */\n\tvim_snprintf((char *)buffer, RULER_BUF_LEN, \"%ld,\",\n\t\t(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t    ? 0L\n\t\t    : (long)(wp->w_cursor.lnum));\n\tlen = STRLEN(buffer);\n\tcol_print(buffer + len, RULER_BUF_LEN - len,\n\t\t\tempty_line ? 0 : (int)wp->w_cursor.col + 1,\n\t\t\t(int)virtcol + 1);\n\n\t/*\n\t * Add a \"50%\" if there is room for it.\n\t * On the last line, don't print in the last column (scrolls the\n\t * screen up on some terminals).\n\t */\n\ti = (int)STRLEN(buffer);\n\tget_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);\n\to = i + vim_strsize(buffer + i + 1);\n\tif (wp->w_status_height == 0)\t// can't use last char of screen\n\t    ++o;\n\tthis_ru_col = ru_col - (Columns - width);\n\tif (this_ru_col < 0)\n\t    this_ru_col = 0;\n\t// Never use more than half the window/screen width, leave the other\n\t// half for the filename.\n\tif (this_ru_col < (width + 1) / 2)\n\t    this_ru_col = (width + 1) / 2;\n\tif (this_ru_col + o < width)\n\t{\n\t    // need at least 3 chars left for get_rel_pos() + NUL\n\t    while (this_ru_col + o < width && RULER_BUF_LEN > i + 4)\n\t    {\n\t\tif (has_mbyte)\n\t\t    i += (*mb_char2bytes)(fillchar, buffer + i);\n\t\telse\n\t\t    buffer[i++] = fillchar;\n\t\t++o;\n\t    }\n\t    get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);\n\t}\n\t// Truncate at window boundary.\n\tif (has_mbyte)\n\t{\n\t    o = 0;\n\t    for (i = 0; buffer[i] != NUL; i += (*mb_ptr2len)(buffer + i))\n\t    {\n\t\to += (*mb_ptr2cells)(buffer + i);\n\t\tif (this_ru_col + o > width)\n\t\t{\n\t\t    buffer[i] = NUL;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (this_ru_col + (int)STRLEN(buffer) > width)\n\t    buffer[width - this_ru_col] = NUL;\n\n\tscreen_puts(buffer, row, this_ru_col + off, attr);\n\ti = redraw_cmdline;\n\tscreen_fill(row, row + 1,\n\t\tthis_ru_col + off + (int)STRLEN(buffer),\n\t\t(int)(off + width),\n\t\tfillchar, fillchar, attr);\n\t// don't redraw the cmdline because of showing the ruler\n\tredraw_cmdline = i;\n\twp->w_ru_cursor = wp->w_cursor;\n\twp->w_ru_virtcol = wp->w_virtcol;\n\twp->w_ru_empty = empty_line;\n\twp->w_ru_topline = wp->w_topline;\n\twp->w_ru_line_count = wp->w_buffer->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\twp->w_ru_topfill = wp->w_topfill;\n#endif\n    }\n}\n#endif\n\n/*\n * To be called when \"updating_screen\" was set before and now the postponed\n * side effects may take place.\n */\n    void\nafter_updating_screen(int may_resize_shell UNUSED)\n{\n    updating_screen = FALSE;\n#ifdef FEAT_GUI\n    if (may_resize_shell)\n\tgui_may_resize_shell();\n#endif\n#ifdef FEAT_TERMINAL\n    term_check_channel_closed_recently();\n#endif\n\n#ifdef HAVE_DROP_FILE\n    // If handle_drop() was called while updating_screen was TRUE need to\n    // handle the drop now.\n    handle_any_postponed_drop();\n#endif\n}\n\n/*\n * Update all windows that are editing the current buffer.\n */\n    void\nupdate_curbuf(int type)\n{\n    redraw_curbuf_later(type);\n    update_screen(type);\n}\n\n#if defined(FEAT_MENU) || defined(FEAT_FOLDING)\n/*\n * Copy \"text\" to ScreenLines using \"attr\".\n * Returns the next screen column.\n */\n    static int\ntext_to_screenline(win_T *wp, char_u *text, int col)\n{\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n\n    if (has_mbyte)\n    {\n\tint\tcells;\n\tint\tu8c, u8cc[MAX_MCO];\n\tint\ti;\n\tint\tidx;\n\tint\tc_len;\n\tchar_u\t*p;\n# ifdef FEAT_ARABIC\n\tint\tprev_c = 0;\t\t// previous Arabic character\n\tint\tprev_c1 = 0;\t\t// first composing char for prev_c\n# endif\n\n# ifdef FEAT_RIGHTLEFT\n\tif (wp->w_p_rl)\n\t    idx = off;\n\telse\n# endif\n\t    idx = off + col;\n\n\t// Store multibyte characters in ScreenLines[] et al. correctly.\n\tfor (p = text; *p != NUL; )\n\t{\n\t    cells = (*mb_ptr2cells)(p);\n\t    c_len = (*mb_ptr2len)(p);\n\t    if (col + cells > wp->w_width\n# ifdef FEAT_RIGHTLEFT\n\t\t    - (wp->w_p_rl ? col : 0)\n# endif\n\t\t    )\n\t\tbreak;\n\t    ScreenLines[idx] = *p;\n\t    if (enc_utf8)\n\t    {\n\t\tu8c = utfc_ptr2char(p, u8cc);\n\t\tif (*p < 0x80 && u8cc[0] == 0)\n\t\t{\n\t\t    ScreenLinesUC[idx] = 0;\n#ifdef FEAT_ARABIC\n\t\t    prev_c = u8c;\n#endif\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_ARABIC\n\t\t    if (p_arshape && !p_tbidi && ARABIC_CHAR(u8c))\n\t\t    {\n\t\t\t// Do Arabic shaping.\n\t\t\tint\tpc, pc1, nc;\n\t\t\tint\tpcc[MAX_MCO];\n\t\t\tint\tfirstbyte = *p;\n\n\t\t\t// The idea of what is the previous and next\n\t\t\t// character depends on 'rightleft'.\n\t\t\tif (wp->w_p_rl)\n\t\t\t{\n\t\t\t    pc = prev_c;\n\t\t\t    pc1 = prev_c1;\n\t\t\t    nc = utf_ptr2char(p + c_len);\n\t\t\t    prev_c1 = u8cc[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    pc = utfc_ptr2char(p + c_len, pcc);\n\t\t\t    nc = prev_c;\n\t\t\t    pc1 = pcc[0];\n\t\t\t}\n\t\t\tprev_c = u8c;\n\n\t\t\tu8c = arabic_shape(u8c, &firstbyte, &u8cc[0],\n\t\t\t\t\t\t\t\t pc, pc1, nc);\n\t\t\tScreenLines[idx] = firstbyte;\n\t\t    }\n\t\t    else\n\t\t\tprev_c = u8c;\n#endif\n\t\t    // Non-BMP character: display as ? or fullwidth ?.\n\t\t    ScreenLinesUC[idx] = u8c;\n\t\t    for (i = 0; i < Screen_mco; ++i)\n\t\t    {\n\t\t\tScreenLinesC[i][idx] = u8cc[i];\n\t\t\tif (u8cc[i] == 0)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\tif (cells > 1)\n\t\t    ScreenLines[idx + 1] = 0;\n\t    }\n\t    else if (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\t\t// double-byte single width character\n\t\tScreenLines2[idx] = p[1];\n\t    else if (cells > 1)\n\t\t// double-width character\n\t\tScreenLines[idx + 1] = p[1];\n\t    col += cells;\n\t    idx += cells;\n\t    p += c_len;\n\t}\n    }\n    else\n    {\n\tint len = (int)STRLEN(text);\n\n\tif (len > wp->w_width - col)\n\t    len = wp->w_width - col;\n\tif (len > 0)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (wp->w_p_rl)\n\t\tmch_memmove(current_ScreenLine, text, len);\n\t    else\n#endif\n\t\tmch_memmove(current_ScreenLine + col, text, len);\n\t    col += len;\n\t}\n    }\n    return col;\n}\n#endif\n\n#ifdef FEAT_MENU\n/*\n * Draw the window toolbar.\n */\n    static void\nredraw_win_toolbar(win_T *wp)\n{\n    vimmenu_T\t*menu;\n    int\t\titem_idx = 0;\n    int\t\titem_count = 0;\n    int\t\tcol = 0;\n    int\t\tnext_col;\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n    int\t\tfill_attr = syn_name2attr((char_u *)\"ToolbarLine\");\n    int\t\tbutton_attr = syn_name2attr((char_u *)\"ToolbarButton\");\n\n    vim_free(wp->w_winbar_items);\n    FOR_ALL_CHILD_MENUS(wp->w_winbar, menu)\n\t++item_count;\n    wp->w_winbar_items = ALLOC_CLEAR_MULT(winbar_item_T, item_count + 1);\n\n    // TODO: use fewer spaces if there is not enough room\n    for (menu = wp->w_winbar->children;\n\t\t\t  menu != NULL && col < wp->w_width; menu = menu->next)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\tif (col > 1)\n\t{\n\t    space_to_screenline(off + col, fill_attr);\n\t    if (++col >= wp->w_width)\n\t\tbreak;\n\t}\n\n\twp->w_winbar_items[item_idx].wb_startcol = col;\n\tspace_to_screenline(off + col, button_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\n\tnext_col = text_to_screenline(wp, menu->name, col);\n\twhile (col < next_col)\n\t{\n\t    ScreenAttrs[off + col] = button_attr;\n\t    ++col;\n\t}\n\twp->w_winbar_items[item_idx].wb_endcol = col;\n\twp->w_winbar_items[item_idx].wb_menu = menu;\n\t++item_idx;\n\n\tif (col >= wp->w_width)\n\t    break;\n\tspace_to_screenline(off + col, button_attr);\n\t++col;\n    }\n    while (col < wp->w_width)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\t++col;\n    }\n    wp->w_winbar_items[item_idx].wb_menu = NULL; // end marker\n\n    screen_line(wp->w_winrow, wp->w_wincol, (int)wp->w_width,\n\t\t\t\t\t\t\t  (int)wp->w_width, 0);\n}\n#endif\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Copy \"buf[len]\" to ScreenLines[\"off\"] and set attributes to \"attr\".\n */\n    static void\ncopy_text_attr(\n    int\t\toff,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tattr)\n{\n    int\t\ti;\n\n    mch_memmove(ScreenLines + off, buf, (size_t)len);\n    if (enc_utf8)\n\tvim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);\n    for (i = 0; i < len; ++i)\n\tScreenAttrs[off + i] = attr;\n}\n\n/*\n * Display one folded line.\n */\n    static void\nfold_line(\n    win_T\t*wp,\n    long\tfold_count,\n    foldinfo_T\t*foldinfo,\n    linenr_T\tlnum,\n    int\t\trow)\n{\n    // Max value of 'foldcolumn' is 12 and maximum number of bytes in a\n    // multi-byte character is MAX_MCO.\n    char_u\tbuf[MAX_MCO * 12 + 1];\n    pos_T\t*top, *bot;\n    linenr_T\tlnume = lnum + fold_count - 1;\n    int\t\tlen;\n    char_u\t*text;\n    int\t\tfdc;\n    int\t\tcol;\n    int\t\ttxtcol;\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n    int\t\tri;\n\n    // Build the fold line:\n    // 1. Add the cmdwin_type for the command-line window\n    // 2. Add the 'foldcolumn'\n    // 3. Add the 'number' or 'relativenumber' column\n    // 4. Compose the text\n    // 5. Add the text\n    // 6. set highlighting for the Visual area an other text\n    col = 0;\n\n    // 1. Add the cmdwin_type for the command-line window\n    // Ignores 'rightleft', this window is never right-left.\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0 && wp == curwin)\n    {\n\tScreenLines[off] = cmdwin_type;\n\tScreenAttrs[off] = HL_ATTR(HLF_AT);\n\tif (enc_utf8)\n\t    ScreenLinesUC[off] = 0;\n\t++col;\n    }\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n# define RL_MEMSET(p, v, l) \\\n    do { \\\n\tif (wp->w_p_rl) \\\n\t    for (ri = 0; ri < l; ++ri) \\\n\t       ScreenAttrs[off + (wp->w_width - (p) - (l)) + ri] = v; \\\n\t else \\\n\t    for (ri = 0; ri < l; ++ri) \\\n\t       ScreenAttrs[off + (p) + ri] = v; \\\n    } while (0)\n#else\n# define RL_MEMSET(p, v, l) \\\n    do { \\\n\tfor (ri = 0; ri < l; ++ri) \\\n\t    ScreenAttrs[off + (p) + ri] = v; \\\n    } while (0)\n#endif\n\n    // 2. Add the 'foldcolumn'\n    //    Reduce the width when there is not enough space.\n    fdc = compute_foldcolumn(wp, col);\n    if (fdc > 0)\n    {\n\tchar_u\t*p;\n\tint\ti;\n\tint\tidx;\n\n\tfill_foldcolumn(buf, wp, TRUE, lnum);\n\tp = buf;\n\tfor (i = 0; i < fdc; i++)\n\t{\n\t    int\t\tch;\n\n\t    if (has_mbyte)\n\t\tch = mb_ptr2char_adv(&p);\n\t    else\n\t\tch = *p++;\n#ifdef FEAT_RIGHTLEFT\n\t    if (wp->w_p_rl)\n\t\tidx = off + wp->w_width - i - 1 - col;\n\t    else\n#endif\n\t\tidx = off + col + i;\n\t    if (enc_utf8)\n\t    {\n\t\tif (ch >= 0x80)\n\t\t{\n\t\t    ScreenLinesUC[idx] = ch;\n\t\t    ScreenLinesC[0][idx] = 0;\n\t\t    ScreenLines[idx] = 0x80;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ScreenLines[idx] = ch;\n\t\t    ScreenLinesUC[idx] = 0;\n\t\t}\n\t    }\n\t    else\n\t\tScreenLines[idx] = ch;\n\t}\n\n\tRL_MEMSET(col, HL_ATTR(HLF_FC), fdc);\n\tcol += fdc;\n    }\n\n    // Set all attributes of the 'number' or 'relativenumber' column and the\n    // text\n    RL_MEMSET(col, HL_ATTR(HLF_FL), wp->w_width - col);\n\n#ifdef FEAT_SIGNS\n    // If signs are being displayed, add two spaces.\n    if (signcolumn_on(wp))\n    {\n\tlen = wp->w_width - col;\n\tif (len > 0)\n\t{\n\t    if (len > 2)\n\t\tlen = 2;\n# ifdef FEAT_RIGHTLEFT\n\t    if (wp->w_p_rl)\n\t\t// the line number isn't reversed\n\t\tcopy_text_attr(off + wp->w_width - len - col,\n\t\t\t\t\t(char_u *)\"  \", len, HL_ATTR(HLF_FL));\n\t    else\n# endif\n\t\tcopy_text_attr(off + col, (char_u *)\"  \", len, HL_ATTR(HLF_FL));\n\t    col += len;\n\t}\n    }\n#endif\n\n    // 3. Add the 'number' or 'relativenumber' column\n    if (wp->w_p_nu || wp->w_p_rnu)\n    {\n\tlen = wp->w_width - col;\n\tif (len > 0)\n\t{\n\t    int\t    w = number_width(wp);\n\t    long    num;\n\t    char    *fmt = \"%*ld \";\n\n\t    if (len > w + 1)\n\t\tlen = w + 1;\n\n\t    if (wp->w_p_nu && !wp->w_p_rnu)\n\t\t// 'number' + 'norelativenumber'\n\t\tnum = (long)lnum;\n\t    else\n\t    {\n\t\t// 'relativenumber', don't use negative numbers\n\t\tnum = labs((long)get_cursor_rel_lnum(wp, lnum));\n\t\tif (num == 0 && wp->w_p_nu && wp->w_p_rnu)\n\t\t{\n\t\t    // 'number' + 'relativenumber': cursor line shows absolute\n\t\t    // line number\n\t\t    num = lnum;\n\t\t    fmt = \"%-*ld \";\n\t\t}\n\t    }\n\n\t    sprintf((char *)buf, fmt, w, num);\n#ifdef FEAT_RIGHTLEFT\n\t    if (wp->w_p_rl)\n\t\t// the line number isn't reversed\n\t\tcopy_text_attr(off + wp->w_width - len - col, buf, len,\n\t\t\t\t\t\t\t     HL_ATTR(HLF_FL));\n\t    else\n#endif\n\t\tcopy_text_attr(off + col, buf, len, HL_ATTR(HLF_FL));\n\t    col += len;\n\t}\n    }\n\n    // 4. Compose the folded-line string with 'foldtext', if set.\n    text = get_foldtext(wp, lnum, lnume, foldinfo, buf);\n\n    txtcol = col;\t// remember where text starts\n\n    // 5. move the text to current_ScreenLine.  Fill up with \"fill_fold\".\n    //    Right-left text is put in columns 0 - number-col, normal text is put\n    //    in columns number-col - window-width.\n    col = text_to_screenline(wp, text, col);\n\n    // Fill the rest of the line with the fold filler\n#ifdef FEAT_RIGHTLEFT\n    if (wp->w_p_rl)\n\tcol -= txtcol;\n#endif\n    while (col < wp->w_width\n#ifdef FEAT_RIGHTLEFT\n\t\t    - (wp->w_p_rl ? txtcol : 0)\n#endif\n\t    )\n    {\n\tif (enc_utf8)\n\t{\n\t    if (fill_fold >= 0x80)\n\t    {\n\t\tScreenLinesUC[off + col] = fill_fold;\n\t\tScreenLinesC[0][off + col] = 0;\n\t\tScreenLines[off + col] = 0x80; // avoid storing zero\n\t    }\n\t    else\n\t    {\n\t\tScreenLinesUC[off + col] = 0;\n\t\tScreenLines[off + col] = fill_fold;\n\t    }\n\t    col++;\n\t}\n\telse\n\t    ScreenLines[off + col++] = fill_fold;\n    }\n\n    if (text != buf)\n\tvim_free(text);\n\n    // 6. set highlighting for the Visual area an other text.\n    // If all folded lines are in the Visual area, highlight the line.\n    if (VIsual_active && wp->w_buffer == curwin->w_buffer)\n    {\n\tif (LTOREQ_POS(curwin->w_cursor, VIsual))\n\t{\n\t    // Visual is after curwin->w_cursor\n\t    top = &curwin->w_cursor;\n\t    bot = &VIsual;\n\t}\n\telse\n\t{\n\t    // Visual is before curwin->w_cursor\n\t    top = &VIsual;\n\t    bot = &curwin->w_cursor;\n\t}\n\tif (lnum >= top->lnum\n\t\t&& lnume <= bot->lnum\n\t\t&& (VIsual_mode != 'v'\n\t\t    || ((lnum > top->lnum\n\t\t\t    || (lnum == top->lnum\n\t\t\t\t&& top->col == 0))\n\t\t\t&& (lnume < bot->lnum\n\t\t\t    || (lnume == bot->lnum\n\t\t\t\t&& (bot->col - (*p_sel == 'e'))\n\t\t>= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))\n\t{\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n\t\t// Visual block mode: highlight the chars part of the block\n\t\tif (wp->w_old_cursor_fcol + txtcol < (colnr_T)wp->w_width)\n\t\t{\n\t\t    if (wp->w_old_cursor_lcol != MAXCOL\n\t\t\t     && wp->w_old_cursor_lcol + txtcol\n\t\t\t\t\t\t       < (colnr_T)wp->w_width)\n\t\t\tlen = wp->w_old_cursor_lcol;\n\t\t    else\n\t\t\tlen = wp->w_width - txtcol;\n\t\t    RL_MEMSET(wp->w_old_cursor_fcol + txtcol, HL_ATTR(HLF_V),\n\t\t\t\t\t    len - (int)wp->w_old_cursor_fcol);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Set all attributes of the text\n\t\tRL_MEMSET(txtcol, HL_ATTR(HLF_V), wp->w_width - txtcol);\n\t    }\n\t}\n    }\n\n#ifdef FEAT_SYN_HL\n    // Show colorcolumn in the fold line, but let cursorcolumn override it.\n    if (wp->w_p_cc_cols)\n    {\n\tint i = 0;\n\tint j = wp->w_p_cc_cols[i];\n\tint old_txtcol = txtcol;\n\n\twhile (j > -1)\n\t{\n\t    txtcol += j;\n\t    if (wp->w_p_wrap)\n\t\ttxtcol -= wp->w_skipcol;\n\t    else\n\t\ttxtcol -= wp->w_leftcol;\n\t    if (txtcol >= 0 && txtcol < wp->w_width)\n\t\tScreenAttrs[off + txtcol] = hl_combine_attr(\n\t\t\t\t    ScreenAttrs[off + txtcol], HL_ATTR(HLF_MC));\n\t    txtcol = old_txtcol;\n\t    j = wp->w_p_cc_cols[++i];\n\t}\n    }\n\n    // Show 'cursorcolumn' in the fold line.\n    if (wp->w_p_cuc)\n    {\n\ttxtcol += wp->w_virtcol;\n\tif (wp->w_p_wrap)\n\t    txtcol -= wp->w_skipcol;\n\telse\n\t    txtcol -= wp->w_leftcol;\n\tif (txtcol >= 0 && txtcol < wp->w_width)\n\t    ScreenAttrs[off + txtcol] = hl_combine_attr(\n\t\t\t\t ScreenAttrs[off + txtcol], HL_ATTR(HLF_CUC));\n    }\n#endif\n\n    screen_line(row + W_WINROW(wp), wp->w_wincol, (int)wp->w_width,\n\t\t\t\t\t\t     (int)wp->w_width, 0);\n\n    // Update w_cline_height and w_cline_folded if the cursor line was\n    // updated (saves a call to plines() later).\n    if (wp == curwin\n\t    && lnum <= curwin->w_cursor.lnum\n\t    && lnume >= curwin->w_cursor.lnum)\n    {\n\tcurwin->w_cline_row = row;\n\tcurwin->w_cline_height = 1;\n\tcurwin->w_cline_folded = TRUE;\n\tcurwin->w_valid |= (VALID_CHEIGHT|VALID_CROW);\n    }\n\n# ifdef FEAT_CONCEAL\n    // When the line was not folded w_wrow may have been set, recompute it.\n    if (wp == curwin\n\t    && wp->w_cursor.lnum >= lnum\n\t    && wp->w_cursor.lnum <= lnume\n\t    && conceal_cursor_line(wp))\n\tcurs_columns(TRUE);\n# endif\n}\n#endif\n\n/*\n * Update a single window.\n *\n * This may cause the windows below it also to be redrawn (when clearing the\n * screen or scrolling lines).\n *\n * How the window is redrawn depends on wp->w_redr_type.  Each type also\n * implies the one below it.\n * NOT_VALID\tredraw the whole window\n * SOME_VALID\tredraw the whole window but do scroll when possible\n * REDRAW_TOP\tredraw the top w_upd_rows window lines, otherwise like VALID\n * INVERTED\tredraw the changed part of the Visual area\n * INVERTED_ALL\tredraw the whole Visual area\n * VALID\t1. scroll up/down to adjust for a changed w_topline\n *\t\t2. update lines at the top when scrolled down\n *\t\t3. redraw changed text:\n *\t\t   - if wp->w_buffer->b_mod_set set, update lines between\n *\t\t     b_mod_top and b_mod_bot.\n *\t\t   - if wp->w_redraw_top non-zero, redraw lines between\n *\t\t     wp->w_redraw_top and wp->w_redr_bot.\n *\t\t   - continue redrawing when syntax status is invalid.\n *\t\t4. if scrolled up, update lines at the bottom.\n * This results in three areas that may need updating:\n * top:\tfrom first row to top_end (when scrolled down)\n * mid: from mid_start to mid_end (update inversion or changed text)\n * bot: from bot_start to last row (when scrolled up)\n */\n    static void\nwin_update(win_T *wp)\n{\n    buf_T\t*buf = wp->w_buffer;\n    int\t\ttype;\n    int\t\ttop_end = 0;\t// Below last row of the top area that needs\n\t\t\t\t// updating.  0 when no top area updating.\n    int\t\tmid_start = 999;// first row of the mid area that needs\n\t\t\t\t// updating.  999 when no mid area updating.\n    int\t\tmid_end = 0;\t// Below last row of the mid area that needs\n\t\t\t\t// updating.  0 when no mid area updating.\n    int\t\tbot_start = 999;// first row of the bot area that needs\n\t\t\t\t// updating.  999 when no bot area updating\n    int\t\tscrolled_down = FALSE;\t// TRUE when scrolled down when\n\t\t\t\t\t// w_topline got smaller a bit\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\ttop_to_mod = FALSE;    // redraw above mod_top\n#endif\n\n    int\t\trow;\t\t// current window row to display\n    linenr_T\tlnum;\t\t// current buffer lnum to display\n    int\t\tidx;\t\t// current index in w_lines[]\n    int\t\tsrow;\t\t// starting row of the current line\n\n    int\t\teof = FALSE;\t// if TRUE, we hit the end of the file\n    int\t\tdidline = FALSE; // if TRUE, we finished the last line\n    int\t\ti;\n    long\tj;\n    static int\trecursive = FALSE;\t// being called recursively\n    linenr_T\told_botline = wp->w_botline;\n#ifdef FEAT_CONCEAL\n    int\t\told_wrow = wp->w_wrow;\n    int\t\told_wcol = wp->w_wcol;\n#endif\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n#ifdef FEAT_SYN_HL\n    // remember what happened to the previous line, to know if\n    // check_visual_highlight() can be used\n#define DID_NONE 1\t// didn't update a line\n#define DID_LINE 2\t// updated a normal line\n#define DID_FOLD 3\t// updated a folded line\n    int\t\tdid_update = DID_NONE;\n    linenr_T\tsyntax_last_parsed = 0;\t\t// last parsed text line\n#endif\n    linenr_T\tmod_top = 0;\n    linenr_T\tmod_bot = 0;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)\n    int\t\tsave_got_int;\n#endif\n#ifdef SYN_TIME_LIMIT\n    proftime_T\tsyntax_tm;\n#endif\n\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)\n    // This needs to be done only for the first window when update_screen() is\n    // called.\n    if (!did_update_one_window)\n    {\n\tdid_update_one_window = TRUE;\n# ifdef FEAT_SEARCH_EXTRA\n\tstart_search_hl();\n# endif\n# ifdef FEAT_CLIPBOARD\n\t// When Visual area changed, may have to update selection.\n\tif (clip_star.available && clip_isautosel_star())\n\t    clip_update_selection(&clip_star);\n\tif (clip_plus.available && clip_isautosel_plus())\n\t    clip_update_selection(&clip_plus);\n# endif\n    }\n#endif\n\n    type = wp->w_redr_type;\n\n    if (type == NOT_VALID)\n    {\n\twp->w_redr_status = TRUE;\n\twp->w_lines_valid = 0;\n    }\n\n    // Window frame is zero-height: nothing to draw.\n    if (wp->w_height + WINBAR_HEIGHT(wp) == 0\n\t    || (wp->w_frame->fr_height == wp->w_status_height\n#if defined(FEAT_PROP_POPUP)\n\t\t&& !popup_is_popup(wp)\n#endif\n\t       ))\n    {\n\twp->w_redr_type = 0;\n\treturn;\n    }\n\n    // Window is zero-width: Only need to draw the separator.\n    if (wp->w_width == 0)\n    {\n\t// draw the vertical separator right of this window\n\tdraw_vsep_win(wp, 0);\n\twp->w_redr_type = 0;\n\treturn;\n    }\n\n#ifdef FEAT_TERMINAL\n    // If this window contains a terminal, redraw works completely differently.\n    if (term_do_update_window(wp))\n    {\n\tterm_update_window(wp);\n# ifdef FEAT_MENU\n\t// Draw the window toolbar, if there is one.\n\tif (winbar_height(wp) > 0)\n\t    redraw_win_toolbar(wp);\n# endif\n\twp->w_redr_type = 0;\n\treturn;\n    }\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_search_hl(wp, &screen_search_hl);\n#endif\n\n#ifdef FEAT_LINEBREAK\n    // Force redraw when width of 'number' or 'relativenumber' column\n    // changes.\n    i = (wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) : 0;\n    if (wp->w_nrwidth != i)\n    {\n\ttype = NOT_VALID;\n\twp->w_nrwidth = i;\n    }\n    else\n#endif\n\n    if (buf->b_mod_set && buf->b_mod_xlines != 0 && wp->w_redraw_top != 0)\n    {\n\t// When there are both inserted/deleted lines and specific lines to be\n\t// redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw\n\t// everything (only happens when redrawing is off for while).\n\ttype = NOT_VALID;\n    }\n    else\n    {\n\t// Set mod_top to the first line that needs displaying because of\n\t// changes.  Set mod_bot to the first line after the changes.\n\tmod_top = wp->w_redraw_top;\n\tif (wp->w_redraw_bot != 0)\n\t    mod_bot = wp->w_redraw_bot + 1;\n\telse\n\t    mod_bot = 0;\n\tif (buf->b_mod_set)\n\t{\n\t    if (mod_top == 0 || mod_top > buf->b_mod_top)\n\t    {\n\t\tmod_top = buf->b_mod_top;\n#ifdef FEAT_SYN_HL\n\t\t// Need to redraw lines above the change that may be included\n\t\t// in a pattern match.\n\t\tif (syntax_present(wp))\n\t\t{\n\t\t    mod_top -= buf->b_s.b_syn_sync_linebreaks;\n\t\t    if (mod_top < 1)\n\t\t\tmod_top = 1;\n\t\t}\n#endif\n\t    }\n\t    if (mod_bot == 0 || mod_bot < buf->b_mod_bot)\n\t\tmod_bot = buf->b_mod_bot;\n\n#ifdef FEAT_SEARCH_EXTRA\n\t    // When 'hlsearch' is on and using a multi-line search pattern, a\n\t    // change in one line may make the Search highlighting in a\n\t    // previous line invalid.  Simple solution: redraw all visible\n\t    // lines above the change.\n\t    // Same for a match pattern.\n\t    if (screen_search_hl.rm.regprog != NULL\n\t\t    && re_multiline(screen_search_hl.rm.regprog))\n\t\ttop_to_mod = TRUE;\n\t    else\n\t    {\n\t\tmatchitem_T *cur = wp->w_match_head;\n\n\t\twhile (cur != NULL)\n\t\t{\n\t\t    if (cur->match.regprog != NULL\n\t\t\t\t\t   && re_multiline(cur->match.regprog))\n\t\t    {\n\t\t\ttop_to_mod = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t    cur = cur->next;\n\t\t}\n\t    }\n#endif\n\t}\n#ifdef FEAT_FOLDING\n\tif (mod_top != 0 && hasAnyFolding(wp))\n\t{\n\t    linenr_T\tlnumt, lnumb;\n\n\t    // A change in a line can cause lines above it to become folded or\n\t    // unfolded.  Find the top most buffer line that may be affected.\n\t    // If the line was previously folded and displayed, get the first\n\t    // line of that fold.  If the line is folded now, get the first\n\t    // folded line.  Use the minimum of these two.\n\n\t    // Find last valid w_lines[] entry above mod_top.  Set lnumt to\n\t    // the line below it.  If there is no valid entry, use w_topline.\n\t    // Find the first valid w_lines[] entry below mod_bot.  Set lnumb\n\t    // to this line.  If there is no valid entry, use MAXLNUM.\n\t    lnumt = wp->w_topline;\n\t    lnumb = MAXLNUM;\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lastlnum < mod_top)\n\t\t\tlnumt = wp->w_lines[i].wl_lastlnum + 1;\n\t\t    if (lnumb == MAXLNUM && wp->w_lines[i].wl_lnum >= mod_bot)\n\t\t    {\n\t\t\tlnumb = wp->w_lines[i].wl_lnum;\n\t\t\t// When there is a fold column it might need updating\n\t\t\t// in the next line (\"J\" just above an open fold).\n\t\t\tif (compute_foldcolumn(wp, 0) > 0)\n\t\t\t    ++lnumb;\n\t\t    }\n\t\t}\n\n\t    (void)hasFoldingWin(wp, mod_top, &mod_top, NULL, TRUE, NULL);\n\t    if (mod_top > lnumt)\n\t\tmod_top = lnumt;\n\n\t    // Now do the same for the bottom line (one above mod_bot).\n\t    --mod_bot;\n\t    (void)hasFoldingWin(wp, mod_bot, NULL, &mod_bot, TRUE, NULL);\n\t    ++mod_bot;\n\t    if (mod_bot < lnumb)\n\t\tmod_bot = lnumb;\n\t}\n#endif\n\n\t// When a change starts above w_topline and the end is below\n\t// w_topline, start redrawing at w_topline.\n\t// If the end of the change is above w_topline: do like no change was\n\t// made, but redraw the first line to find changes in syntax.\n\tif (mod_top != 0 && mod_top < wp->w_topline)\n\t{\n\t    if (mod_bot > wp->w_topline)\n\t\tmod_top = wp->w_topline;\n#ifdef FEAT_SYN_HL\n\t    else if (syntax_present(wp))\n\t\ttop_end = 1;\n#endif\n\t}\n\n\t// When line numbers are displayed need to redraw all lines below\n\t// inserted/deleted lines.\n\tif (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_p_nu)\n\t    mod_bot = MAXLNUM;\n    }\n    wp->w_redraw_top = 0;\t// reset for next time\n    wp->w_redraw_bot = 0;\n\n    // When only displaying the lines at the top, set top_end.  Used when\n    // window has scrolled down for msg_scrolled.\n    if (type == REDRAW_TOP)\n    {\n\tj = 0;\n\tfor (i = 0; i < wp->w_lines_valid; ++i)\n\t{\n\t    j += wp->w_lines[i].wl_size;\n\t    if (j >= wp->w_upd_rows)\n\t    {\n\t\ttop_end = j;\n\t\tbreak;\n\t    }\n\t}\n\tif (top_end == 0)\n\t    // not found (cannot happen?): redraw everything\n\t    type = NOT_VALID;\n\telse\n\t    // top area defined, the rest is VALID\n\t    type = VALID;\n    }\n\n    // Trick: we want to avoid clearing the screen twice.  screenclear() will\n    // set \"screen_cleared\" to TRUE.  The special value MAYBE (which is still\n    // non-zero and thus not FALSE) will indicate that screenclear() was not\n    // called.\n    if (screen_cleared)\n\tscreen_cleared = MAYBE;\n\n    // If there are no changes on the screen that require a complete redraw,\n    // handle three cases:\n    // 1: we are off the top of the screen by a few lines: scroll down\n    // 2: wp->w_topline is below wp->w_lines[0].wl_lnum: may scroll up\n    // 3: wp->w_topline is wp->w_lines[0].wl_lnum: find first entry in\n    //    w_lines[] that needs updating.\n    if ((type == VALID || type == SOME_VALID\n\t\t\t\t  || type == INVERTED || type == INVERTED_ALL)\n#ifdef FEAT_DIFF\n\t    && !wp->w_botfill && !wp->w_old_botfill\n#endif\n\t    )\n    {\n\tif (mod_top != 0\n\t\t&& wp->w_topline == mod_top\n\t\t&& (!wp->w_lines[0].wl_valid\n\t\t    || wp->w_topline <= wp->w_lines[0].wl_lnum))\n\t{\n\t    // w_topline is the first changed line and window is not scrolled,\n\t    // the scrolling from changed lines will be done further down.\n\t}\n\telse if (wp->w_lines[0].wl_valid\n\t\t&& (wp->w_topline < wp->w_lines[0].wl_lnum\n#ifdef FEAT_DIFF\n\t\t    || (wp->w_topline == wp->w_lines[0].wl_lnum\n\t\t\t&& wp->w_topfill > wp->w_old_topfill)\n#endif\n\t\t   ))\n\t{\n\t    // New topline is above old topline: May scroll down.\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(wp))\n\t    {\n\t\tlinenr_T ln;\n\n\t\t// count the number of lines we are off, counting a sequence\n\t\t// of folded lines as one\n\t\tj = 0;\n\t\tfor (ln = wp->w_topline; ln < wp->w_lines[0].wl_lnum; ++ln)\n\t\t{\n\t\t    ++j;\n\t\t    if (j >= wp->w_height - 2)\n\t\t\tbreak;\n\t\t    (void)hasFoldingWin(wp, ln, NULL, &ln, TRUE, NULL);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tj = wp->w_lines[0].wl_lnum - wp->w_topline;\n\t    if (j < wp->w_height - 2)\t\t// not too far off\n\t    {\n\t\ti = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);\n#ifdef FEAT_DIFF\n\t\t// insert extra lines for previously invisible filler lines\n\t\tif (wp->w_lines[0].wl_lnum != wp->w_topline)\n\t\t    i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)\n\t\t\t\t\t\t\t  - wp->w_old_topfill;\n#endif\n\t\tif (i < wp->w_height - 2)\t// less than a screen off\n\t\t{\n\t\t    // Try to insert the correct number of lines.\n\t\t    // If not the last window, delete the lines at the bottom.\n\t\t    // win_ins_lines may fail when the terminal can't do it.\n\t\t    if (i > 0)\n\t\t\tcheck_for_delay(FALSE);\n\t\t    if (win_ins_lines(wp, 0, i, FALSE, wp == firstwin) == OK)\n\t\t    {\n\t\t\tif (wp->w_lines_valid != 0)\n\t\t\t{\n\t\t\t    // Need to update rows that are new, stop at the\n\t\t\t    // first one that scrolled down.\n\t\t\t    top_end = i;\n\t\t\t    scrolled_down = TRUE;\n\n\t\t\t    // Move the entries that were scrolled, disable\n\t\t\t    // the entries for the lines to be redrawn.\n\t\t\t    if ((wp->w_lines_valid += j) > wp->w_height)\n\t\t\t\twp->w_lines_valid = wp->w_height;\n\t\t\t    for (idx = wp->w_lines_valid; idx - j >= 0; idx--)\n\t\t\t\twp->w_lines[idx] = wp->w_lines[idx - j];\n\t\t\t    while (idx >= 0)\n\t\t\t\twp->w_lines[idx--].wl_valid = FALSE;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tmid_start = 0;\t\t// redraw all lines\n\t\t}\n\t\telse\n\t\t    mid_start = 0;\t\t// redraw all lines\n\t    }\n\t    else\n\t\tmid_start = 0;\t\t// redraw all lines\n\t}\n\telse\n\t{\n\t    // New topline is at or below old topline: May scroll up.\n\t    // When topline didn't change, find first entry in w_lines[] that\n\t    // needs updating.\n\n\t    // try to find wp->w_topline in wp->w_lines[].wl_lnum\n\t    j = -1;\n\t    row = 0;\n\t    for (i = 0; i < wp->w_lines_valid; i++)\n\t    {\n\t\tif (wp->w_lines[i].wl_valid\n\t\t\t&& wp->w_lines[i].wl_lnum == wp->w_topline)\n\t\t{\n\t\t    j = i;\n\t\t    break;\n\t\t}\n\t\trow += wp->w_lines[i].wl_size;\n\t    }\n\t    if (j == -1)\n\t    {\n\t\t// if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all\n\t\t// lines\n\t\tmid_start = 0;\n\t    }\n\t    else\n\t    {\n\t\t// Try to delete the correct number of lines.\n\t\t// wp->w_topline is at wp->w_lines[i].wl_lnum.\n#ifdef FEAT_DIFF\n\t\t// If the topline didn't change, delete old filler lines,\n\t\t// otherwise delete filler lines of the new topline...\n\t\tif (wp->w_lines[0].wl_lnum == wp->w_topline)\n\t\t    row += wp->w_old_topfill;\n\t\telse\n\t\t    row += diff_check_fill(wp, wp->w_topline);\n\t\t// ... but don't delete new filler lines.\n\t\trow -= wp->w_topfill;\n#endif\n\t\tif (row > 0)\n\t\t{\n\t\t    check_for_delay(FALSE);\n\t\t    if (win_del_lines(wp, 0, row, FALSE, wp == firstwin, 0)\n\t\t\t\t\t\t\t\t\t == OK)\n\t\t\tbot_start = wp->w_height - row;\n\t\t    else\n\t\t\tmid_start = 0;\t\t// redraw all lines\n\t\t}\n\t\tif ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0)\n\t\t{\n\t\t    // Skip the lines (below the deleted lines) that are still\n\t\t    // valid and don't need redrawing.\tCopy their info\n\t\t    // upwards, to compensate for the deleted lines.  Set\n\t\t    // bot_start to the first row that needs redrawing.\n\t\t    bot_start = 0;\n\t\t    idx = 0;\n\t\t    for (;;)\n\t\t    {\n\t\t\twp->w_lines[idx] = wp->w_lines[j];\n\t\t\t// stop at line that didn't fit, unless it is still\n\t\t\t// valid (no lines deleted)\n\t\t\tif (row > 0 && bot_start + row\n\t\t\t\t + (int)wp->w_lines[j].wl_size > wp->w_height)\n\t\t\t{\n\t\t\t    wp->w_lines_valid = idx + 1;\n\t\t\t    break;\n\t\t\t}\n\t\t\tbot_start += wp->w_lines[idx++].wl_size;\n\n\t\t\t// stop at the last valid entry in w_lines[].wl_size\n\t\t\tif (++j >= wp->w_lines_valid)\n\t\t\t{\n\t\t\t    wp->w_lines_valid = idx;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n#ifdef FEAT_DIFF\n\t\t    // Correct the first entry for filler lines at the top\n\t\t    // when it won't get updated below.\n\t\t    if (wp->w_p_diff && bot_start > 0)\n\t\t\twp->w_lines[0].wl_size =\n\t\t\t    plines_win_nofill(wp, wp->w_topline, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n#endif\n\t\t}\n\t    }\n\t}\n\n\t// When starting redraw in the first line, redraw all lines.  When\n\t// there is only one window it's probably faster to clear the screen\n\t// first.\n\tif (mid_start == 0)\n\t{\n\t    mid_end = wp->w_height;\n\t    if (ONE_WINDOW && !WIN_IS_POPUP(wp))\n\t    {\n\t\t// Clear the screen when it was not done by win_del_lines() or\n\t\t// win_ins_lines() above, \"screen_cleared\" is FALSE or MAYBE\n\t\t// then.\n\t\tif (screen_cleared != TRUE)\n\t\t    screenclear();\n\t\t// The screen was cleared, redraw the tab pages line.\n\t\tif (redraw_tabline)\n\t\t    draw_tabline();\n\t    }\n\t}\n\n\t// When win_del_lines() or win_ins_lines() caused the screen to be\n\t// cleared (only happens for the first window) or when screenclear()\n\t// was called directly above, \"must_redraw\" will have been set to\n\t// NOT_VALID, need to reset it here to avoid redrawing twice.\n\tif (screen_cleared == TRUE)\n\t    must_redraw = 0;\n    }\n    else\n    {\n\t// Not VALID or INVERTED: redraw all lines.\n\tmid_start = 0;\n\tmid_end = wp->w_height;\n    }\n\n    if (type == SOME_VALID)\n    {\n\t// SOME_VALID: redraw all lines.\n\tmid_start = 0;\n\tmid_end = wp->w_height;\n\ttype = NOT_VALID;\n    }\n\n    // check if we are updating or removing the inverted part\n    if ((VIsual_active && buf == curwin->w_buffer)\n\t    || (wp->w_old_cursor_lnum != 0 && type != NOT_VALID))\n    {\n\tlinenr_T    from, to;\n\n\tif (VIsual_active)\n\t{\n\t    if (VIsual_active\n\t\t    && (VIsual_mode != wp->w_old_visual_mode\n\t\t\t|| type == INVERTED_ALL))\n\t    {\n\t\t// If the type of Visual selection changed, redraw the whole\n\t\t// selection.  Also when the ownership of the X selection is\n\t\t// gained or lost.\n\t\tif (curwin->w_cursor.lnum < VIsual.lnum)\n\t\t{\n\t\t    from = curwin->w_cursor.lnum;\n\t\t    to = VIsual.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    from = VIsual.lnum;\n\t\t    to = curwin->w_cursor.lnum;\n\t\t}\n\t\t// redraw more when the cursor moved as well\n\t\tif (wp->w_old_cursor_lnum < from)\n\t\t    from = wp->w_old_cursor_lnum;\n\t\tif (wp->w_old_cursor_lnum > to)\n\t\t    to = wp->w_old_cursor_lnum;\n\t\tif (wp->w_old_visual_lnum < from)\n\t\t    from = wp->w_old_visual_lnum;\n\t\tif (wp->w_old_visual_lnum > to)\n\t\t    to = wp->w_old_visual_lnum;\n\t    }\n\t    else\n\t    {\n\t\t// Find the line numbers that need to be updated: The lines\n\t\t// between the old cursor position and the current cursor\n\t\t// position.  Also check if the Visual position changed.\n\t\tif (curwin->w_cursor.lnum < wp->w_old_cursor_lnum)\n\t\t{\n\t\t    from = curwin->w_cursor.lnum;\n\t\t    to = wp->w_old_cursor_lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    from = wp->w_old_cursor_lnum;\n\t\t    to = curwin->w_cursor.lnum;\n\t\t    if (from == 0)\t// Visual mode just started\n\t\t\tfrom = to;\n\t\t}\n\n\t\tif (VIsual.lnum != wp->w_old_visual_lnum\n\t\t\t\t\t|| VIsual.col != wp->w_old_visual_col)\n\t\t{\n\t\t    if (wp->w_old_visual_lnum < from\n\t\t\t\t\t\t&& wp->w_old_visual_lnum != 0)\n\t\t\tfrom = wp->w_old_visual_lnum;\n\t\t    if (wp->w_old_visual_lnum > to)\n\t\t\tto = wp->w_old_visual_lnum;\n\t\t    if (VIsual.lnum < from)\n\t\t\tfrom = VIsual.lnum;\n\t\t    if (VIsual.lnum > to)\n\t\t\tto = VIsual.lnum;\n\t\t}\n\t    }\n\n\t    // If in block mode and changed column or curwin->w_curswant:\n\t    // update all lines.\n\t    // First compute the actual start and end column.\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tcolnr_T\t    fromc, toc;\n#if defined(FEAT_LINEBREAK)\n\t\tint\t    save_ve_flags = curwin->w_ve_flags;\n\n\t\tif (curwin->w_p_lbr)\n\t\t    curwin->w_ve_flags = VE_ALL;\n#endif\n\t\tgetvcols(wp, &VIsual, &curwin->w_cursor, &fromc, &toc);\n\t\t++toc;\n#if defined(FEAT_LINEBREAK)\n\t\tcurwin->w_ve_flags = save_ve_flags;\n#endif\n\t\t// Highlight to the end of the line, unless 'virtualedit' has\n\t\t// \"block\".\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t{\n\t\t    if (get_ve_flags() & VE_BLOCK)\n\t\t    {\n\t\t\tpos_T\t    pos;\n\t\t\tint\t    cursor_above =\n\t\t\t\t\t   curwin->w_cursor.lnum < VIsual.lnum;\n\n\t\t\t// Need to find the longest line.\n\t\t\ttoc = 0;\n\t\t\tpos.coladd = 0;\n\t\t\tfor (pos.lnum = curwin->w_cursor.lnum; cursor_above\n\t\t\t\t\t? pos.lnum <= VIsual.lnum\n\t\t\t\t\t: pos.lnum >= VIsual.lnum;\n\t\t\t\t\t     pos.lnum += cursor_above ? 1 : -1)\n\t\t\t{\n\t\t\t    colnr_T t;\n\n\t\t\t    pos.col = (int)STRLEN(ml_get_buf(wp->w_buffer,\n\t\t\t\t\t\t\t     pos.lnum, FALSE));\n\t\t\t    getvvcol(wp, &pos, NULL, NULL, &t);\n\t\t\t    if (toc < t)\n\t\t\t\ttoc = t;\n\t\t\t}\n\t\t\t++toc;\n\t\t    }\n\t\t    else\n\t\t\ttoc = MAXCOL;\n\t\t}\n\n\t\tif (fromc != wp->w_old_cursor_fcol\n\t\t\t|| toc != wp->w_old_cursor_lcol)\n\t\t{\n\t\t    if (from > VIsual.lnum)\n\t\t\tfrom = VIsual.lnum;\n\t\t    if (to < VIsual.lnum)\n\t\t\tto = VIsual.lnum;\n\t\t}\n\t\twp->w_old_cursor_fcol = fromc;\n\t\twp->w_old_cursor_lcol = toc;\n\t    }\n\t}\n\telse\n\t{\n\t    // Use the line numbers of the old Visual area.\n\t    if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum)\n\t    {\n\t\tfrom = wp->w_old_cursor_lnum;\n\t\tto = wp->w_old_visual_lnum;\n\t    }\n\t    else\n\t    {\n\t\tfrom = wp->w_old_visual_lnum;\n\t\tto = wp->w_old_cursor_lnum;\n\t    }\n\t}\n\n\t// There is no need to update lines above the top of the window.\n\tif (from < wp->w_topline)\n\t    from = wp->w_topline;\n\n\t// If we know the value of w_botline, use it to restrict the update to\n\t// the lines that are visible in the window.\n\tif (wp->w_valid & VALID_BOTLINE)\n\t{\n\t    if (from >= wp->w_botline)\n\t\tfrom = wp->w_botline - 1;\n\t    if (to >= wp->w_botline)\n\t\tto = wp->w_botline - 1;\n\t}\n\n\t// Find the minimal part to be updated.\n\t// Watch out for scrolling that made entries in w_lines[] invalid.\n\t// E.g., CTRL-U makes the first half of w_lines[] invalid and sets\n\t// top_end; need to redraw from top_end to the \"to\" line.\n\t// A middle mouse click with a Visual selection may change the text\n\t// above the Visual area and reset wl_valid, do count these for\n\t// mid_end (in srow).\n\tif (mid_start > 0)\n\t{\n\t    lnum = wp->w_topline;\n\t    idx = 0;\n\t    srow = 0;\n\t    if (scrolled_down)\n\t\tmid_start = top_end;\n\t    else\n\t\tmid_start = 0;\n\t    while (lnum < from && idx < wp->w_lines_valid)\t// find start\n\t    {\n\t\tif (wp->w_lines[idx].wl_valid)\n\t\t    mid_start += wp->w_lines[idx].wl_size;\n\t\telse if (!scrolled_down)\n\t\t    srow += wp->w_lines[idx].wl_size;\n\t\t++idx;\n# ifdef FEAT_FOLDING\n\t\tif (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)\n\t\t    lnum = wp->w_lines[idx].wl_lnum;\n\t\telse\n# endif\n\t\t    ++lnum;\n\t    }\n\t    srow += mid_start;\n\t    mid_end = wp->w_height;\n\t    for ( ; idx < wp->w_lines_valid; ++idx)\t\t// find end\n\t    {\n\t\tif (wp->w_lines[idx].wl_valid\n\t\t\t&& wp->w_lines[idx].wl_lnum >= to + 1)\n\t\t{\n\t\t    // Only update until first row of this line\n\t\t    mid_end = srow;\n\t\t    break;\n\t\t}\n\t\tsrow += wp->w_lines[idx].wl_size;\n\t    }\n\t}\n    }\n\n    if (VIsual_active && buf == curwin->w_buffer)\n    {\n\twp->w_old_visual_mode = VIsual_mode;\n\twp->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\twp->w_old_visual_lnum = VIsual.lnum;\n\twp->w_old_visual_col = VIsual.col;\n\twp->w_old_curswant = curwin->w_curswant;\n    }\n    else\n    {\n\twp->w_old_visual_mode = 0;\n\twp->w_old_cursor_lnum = 0;\n\twp->w_old_visual_lnum = 0;\n\twp->w_old_visual_col = 0;\n    }\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)\n    // reset got_int, otherwise regexp won't work\n    save_got_int = got_int;\n    got_int = 0;\n#endif\n#ifdef SYN_TIME_LIMIT\n    // Set the time limit to 'redrawtime'.\n    profile_setlimit(p_rdt, &syntax_tm);\n    syn_set_timeout(&syntax_tm);\n#endif\n#ifdef FEAT_FOLDING\n    win_foldinfo.fi_level = 0;\n#endif\n\n#ifdef FEAT_MENU\n    // Draw the window toolbar, if there is one.\n    // TODO: only when needed.\n    if (winbar_height(wp) > 0)\n\tredraw_win_toolbar(wp);\n#endif\n\n    // Update all the window rows.\n    idx = 0;\t\t// first entry in w_lines[].wl_size\n    row = 0;\n    srow = 0;\n    lnum = wp->w_topline;\t// first line shown in window\n    for (;;)\n    {\n\t// stop updating when reached the end of the window (check for _past_\n\t// the end of the window is at the end of the loop)\n\tif (row == wp->w_height)\n\t{\n\t    didline = TRUE;\n\t    break;\n\t}\n\n\t// stop updating when hit the end of the file\n\tif (lnum > buf->b_ml.ml_line_count)\n\t{\n\t    eof = TRUE;\n\t    break;\n\t}\n\n\t// Remember the starting row of the line that is going to be dealt\n\t// with.  It is used further down when the line doesn't fit.\n\tsrow = row;\n\n\t// Update a line when it is in an area that needs updating, when it\n\t// has changes or w_lines[idx] is invalid.\n\t// \"bot_start\" may be halfway a wrapped line after using\n\t// win_del_lines(), check if the current line includes it.\n\t// When syntax folding is being used, the saved syntax states will\n\t// already have been updated, we can't see where the syntax state is\n\t// the same again, just update until the end of the window.\n\tif (row < top_end\n\t\t|| (row >= mid_start && row < mid_end)\n#ifdef FEAT_SEARCH_EXTRA\n\t\t|| top_to_mod\n#endif\n\t\t|| idx >= wp->w_lines_valid\n\t\t|| (row + wp->w_lines[idx].wl_size > bot_start)\n\t\t|| (mod_top != 0\n\t\t    && (lnum == mod_top\n\t\t\t|| (lnum >= mod_top\n\t\t\t    && (lnum < mod_bot\n#ifdef FEAT_SYN_HL\n\t\t\t\t|| did_update == DID_FOLD\n\t\t\t\t|| (did_update == DID_LINE\n\t\t\t\t    && syntax_present(wp)\n\t\t\t\t    && (\n# ifdef FEAT_FOLDING\n\t\t\t\t\t(foldmethodIsSyntax(wp)\n\t\t\t\t\t\t      && hasAnyFolding(wp)) ||\n# endif\n\t\t\t\t\tsyntax_check_changed(lnum)))\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n\t\t\t\t// match in fixed position might need redraw\n\t\t\t\t// if lines were inserted or deleted\n\t\t\t\t|| (wp->w_match_head != NULL\n\t\t\t\t\t\t    && buf->b_mod_xlines != 0)\n#endif\n\t\t\t\t))))\n#ifdef FEAT_SYN_HL\n\t\t|| (wp->w_p_cul && (lnum == wp->w_cursor.lnum\n\t\t\t\t\t     || lnum == wp->w_last_cursorline))\n#endif\n\t\t\t\t)\n\t{\n#ifdef FEAT_SEARCH_EXTRA\n\t    if (lnum == mod_top)\n\t\ttop_to_mod = FALSE;\n#endif\n\n\t    // When at start of changed lines: May scroll following lines\n\t    // up or down to minimize redrawing.\n\t    // Don't do this when the change continues until the end.\n\t    // Don't scroll when dollar_vcol >= 0, keep the \"$\".\n\t    // Don't scroll when redrawing the top, scrolled already above.\n\t    if (lnum == mod_top\n\t\t    && mod_bot != MAXLNUM\n\t\t    && !(dollar_vcol >= 0 && mod_bot == mod_top + 1)\n\t\t    && row >= top_end)\n\t    {\n\t\tint\t\told_rows = 0;\n\t\tint\t\tnew_rows = 0;\n\t\tint\t\txtra_rows;\n\t\tlinenr_T\tl;\n\n\t\t// Count the old number of window rows, using w_lines[], which\n\t\t// should still contain the sizes for the lines as they are\n\t\t// currently displayed.\n\t\tfor (i = idx; i < wp->w_lines_valid; ++i)\n\t\t{\n\t\t    // Only valid lines have a meaningful wl_lnum.  Invalid\n\t\t    // lines are part of the changed area.\n\t\t    if (wp->w_lines[i].wl_valid\n\t\t\t    && wp->w_lines[i].wl_lnum == mod_bot)\n\t\t\tbreak;\n\t\t    old_rows += wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t\t    if (wp->w_lines[i].wl_valid\n\t\t\t    && wp->w_lines[i].wl_lastlnum + 1 == mod_bot)\n\t\t    {\n\t\t\t// Must have found the last valid entry above mod_bot.\n\t\t\t// Add following invalid entries.\n\t\t\t++i;\n\t\t\twhile (i < wp->w_lines_valid\n\t\t\t\t\t\t  && !wp->w_lines[i].wl_valid)\n\t\t\t    old_rows += wp->w_lines[i++].wl_size;\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\t}\n\n\t\tif (i >= wp->w_lines_valid)\n\t\t{\n\t\t    // We can't find a valid line below the changed lines,\n\t\t    // need to redraw until the end of the window.\n\t\t    // Inserting/deleting lines has no use.\n\t\t    bot_start = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Able to count old number of rows: Count new window\n\t\t    // rows, and may insert/delete lines\n\t\t    j = idx;\n\t\t    for (l = lnum; l < mod_bot; ++l)\n\t\t    {\n#ifdef FEAT_FOLDING\n\t\t\tif (hasFoldingWin(wp, l, NULL, &l, TRUE, NULL))\n\t\t\t    ++new_rows;\n\t\t\telse\n#endif\n\t\t\t{\n#ifdef FEAT_DIFF\n\t\t\t    if (l == wp->w_topline)\n\t\t\t\tnew_rows += plines_win_nofill(wp, l, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\t\t    else\n#endif\n\t\t\t\tnew_rows += plines_win(wp, l, TRUE);\n\t\t\t}\n\t\t\t++j;\n\t\t\tif (new_rows > wp->w_height - row - 2)\n\t\t\t{\n\t\t\t    // it's getting too much, must redraw the rest\n\t\t\t    new_rows = 9999;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    xtra_rows = new_rows - old_rows;\n\t\t    if (xtra_rows < 0)\n\t\t    {\n\t\t\t// May scroll text up.  If there is not enough\n\t\t\t// remaining text or scrolling fails, must redraw the\n\t\t\t// rest.  If scrolling works, must redraw the text\n\t\t\t// below the scrolled text.\n\t\t\tif (row - xtra_rows >= wp->w_height - 2)\n\t\t\t    mod_bot = MAXLNUM;\n\t\t\telse\n\t\t\t{\n\t\t\t    check_for_delay(FALSE);\n\t\t\t    if (win_del_lines(wp, row,\n\t\t\t\t\t  -xtra_rows, FALSE, FALSE, 0) == FAIL)\n\t\t\t\tmod_bot = MAXLNUM;\n\t\t\t    else\n\t\t\t\tbot_start = wp->w_height + xtra_rows;\n\t\t\t}\n\t\t    }\n\t\t    else if (xtra_rows > 0)\n\t\t    {\n\t\t\t// May scroll text down.  If there is not enough\n\t\t\t// remaining text of scrolling fails, must redraw the\n\t\t\t// rest.\n\t\t\tif (row + xtra_rows >= wp->w_height - 2)\n\t\t\t    mod_bot = MAXLNUM;\n\t\t\telse\n\t\t\t{\n\t\t\t    check_for_delay(FALSE);\n\t\t\t    if (win_ins_lines(wp, row + old_rows,\n\t\t\t\t\t     xtra_rows, FALSE, FALSE) == FAIL)\n\t\t\t\tmod_bot = MAXLNUM;\n\t\t\t    else if (top_end > row + old_rows)\n\t\t\t\t// Scrolled the part at the top that requires\n\t\t\t\t// updating down.\n\t\t\t\ttop_end += xtra_rows;\n\t\t\t}\n\t\t    }\n\n\t\t    // When not updating the rest, may need to move w_lines[]\n\t\t    // entries.\n\t\t    if (mod_bot != MAXLNUM && i != j)\n\t\t    {\n\t\t\tif (j < i)\n\t\t\t{\n\t\t\t    int x = row + new_rows;\n\n\t\t\t    // move entries in w_lines[] upwards\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t// stop at last valid entry in w_lines[]\n\t\t\t\tif (i >= wp->w_lines_valid)\n\t\t\t\t{\n\t\t\t\t    wp->w_lines_valid = j;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\twp->w_lines[j] = wp->w_lines[i];\n\t\t\t\t// stop at a line that won't fit\n\t\t\t\tif (x + (int)wp->w_lines[j].wl_size\n\t\t\t\t\t\t\t   > wp->w_height)\n\t\t\t\t{\n\t\t\t\t    wp->w_lines_valid = j + 1;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tx += wp->w_lines[j++].wl_size;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (bot_start > x)\n\t\t\t\tbot_start = x;\n\t\t\t}\n\t\t\telse // j > i\n\t\t\t{\n\t\t\t    // move entries in w_lines[] downwards\n\t\t\t    j -= i;\n\t\t\t    wp->w_lines_valid += j;\n\t\t\t    if (wp->w_lines_valid > wp->w_height)\n\t\t\t\twp->w_lines_valid = wp->w_height;\n\t\t\t    for (i = wp->w_lines_valid; i - j >= idx; --i)\n\t\t\t\twp->w_lines[i] = wp->w_lines[i - j];\n\n\t\t\t    // The w_lines[] entries for inserted lines are\n\t\t\t    // now invalid, but wl_size may be used above.\n\t\t\t    // Reset to zero.\n\t\t\t    while (i >= idx)\n\t\t\t    {\n\t\t\t\twp->w_lines[i].wl_size = 0;\n\t\t\t\twp->w_lines[i--].wl_valid = FALSE;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n#ifdef FEAT_FOLDING\n\t    // When lines are folded, display one line for all of them.\n\t    // Otherwise, display normally (can be several display lines when\n\t    // 'wrap' is on).\n\t    fold_count = foldedCount(wp, lnum, &win_foldinfo);\n\t    if (fold_count != 0)\n\t    {\n\t\tfold_line(wp, fold_count, &win_foldinfo, lnum, row);\n\t\t++row;\n\t\t--fold_count;\n\t\twp->w_lines[idx].wl_folded = TRUE;\n\t\twp->w_lines[idx].wl_lastlnum = lnum + fold_count;\n# ifdef FEAT_SYN_HL\n\t\tdid_update = DID_FOLD;\n# endif\n\t    }\n\t    else\n#endif\n\t    if (idx < wp->w_lines_valid\n\t\t    && wp->w_lines[idx].wl_valid\n\t\t    && wp->w_lines[idx].wl_lnum == lnum\n\t\t    && lnum > wp->w_topline\n\t\t    && !(dy_flags & (DY_LASTLINE | DY_TRUNCATE))\n\t\t    && !WIN_IS_POPUP(wp)\n\t\t    && srow + wp->w_lines[idx].wl_size > wp->w_height\n#ifdef FEAT_DIFF\n\t\t    && diff_check_fill(wp, lnum) == 0\n#endif\n\t\t    )\n\t    {\n\t\t// This line is not going to fit.  Don't draw anything here,\n\t\t// will draw \"@  \" lines below.\n\t\trow = wp->w_height + 1;\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_SEARCH_EXTRA\n\t\tprepare_search_hl(wp, &screen_search_hl, lnum);\n#endif\n#ifdef FEAT_SYN_HL\n\t\t// Let the syntax stuff know we skipped a few lines.\n\t\tif (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum\n\t\t\t\t\t\t       && syntax_present(wp))\n\t\t    syntax_end_parsing(syntax_last_parsed + 1);\n#endif\n\n\t\t// Display one line.\n\t\trow = win_line(wp, lnum, srow, wp->w_height,\n\t\t\t\t\t\t\t  mod_top == 0, FALSE);\n\n#ifdef FEAT_FOLDING\n\t\twp->w_lines[idx].wl_folded = FALSE;\n\t\twp->w_lines[idx].wl_lastlnum = lnum;\n#endif\n#ifdef FEAT_SYN_HL\n\t\tdid_update = DID_LINE;\n\t\tsyntax_last_parsed = lnum;\n#endif\n\t    }\n\n\t    wp->w_lines[idx].wl_lnum = lnum;\n\t    wp->w_lines[idx].wl_valid = TRUE;\n\n\t    // Past end of the window or end of the screen. Note that after\n\t    // resizing wp->w_height may be end up too big. That's a problem\n\t    // elsewhere, but prevent a crash here.\n\t    if (row > wp->w_height || row + wp->w_winrow >= Rows)\n\t    {\n\t\t// we may need the size of that too long line later on\n\t\tif (dollar_vcol == -1)\n\t\t    wp->w_lines[idx].wl_size = plines_win(wp, lnum, TRUE);\n\t\t++idx;\n\t\tbreak;\n\t    }\n\t    if (dollar_vcol == -1)\n\t\twp->w_lines[idx].wl_size = row - srow;\n\t    ++idx;\n#ifdef FEAT_FOLDING\n\t    lnum += fold_count + 1;\n#else\n\t    ++lnum;\n#endif\n\t}\n\telse\n\t{\n\t    if (wp->w_p_rnu)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// 'relativenumber' set: The text doesn't need to be drawn, but\n\t\t// the number column nearly always does.\n\t\tfold_count = foldedCount(wp, lnum, &win_foldinfo);\n\t\tif (fold_count != 0)\n\t\t    fold_line(wp, fold_count, &win_foldinfo, lnum, row);\n\t\telse\n#endif\n\t\t    (void)win_line(wp, lnum, srow, wp->w_height, TRUE, TRUE);\n\t    }\n\n\t    // This line does not need to be drawn, advance to the next one.\n\t    row += wp->w_lines[idx++].wl_size;\n\t    if (row > wp->w_height)\t// past end of screen\n\t\tbreak;\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[idx - 1].wl_lastlnum + 1;\n#else\n\t    ++lnum;\n#endif\n#ifdef FEAT_SYN_HL\n\t    did_update = DID_NONE;\n#endif\n\t}\n\n\tif (lnum > buf->b_ml.ml_line_count)\n\t{\n\t    eof = TRUE;\n\t    break;\n\t}\n    }\n\n    // End of loop over all window lines.\n\n#ifdef FEAT_VTP\n    // Rewrite the character at the end of the screen line.\n    // See the version that was fixed.\n    if (use_vtp() && get_conpty_fix_type() < 1)\n    {\n\tint i;\n\n\tfor (i = 0; i < Rows; ++i)\n\t    if (enc_utf8)\n\t\tif ((*mb_off2cells)(LineOffset[i] + Columns - 2,\n\t\t\t\t\t   LineOffset[i] + screen_Columns) > 1)\n\t\t    screen_draw_rectangle(i, Columns - 2, 1, 2, FALSE);\n\t\telse\n\t\t    screen_draw_rectangle(i, Columns - 1, 1, 1, FALSE);\n\t    else\n\t\tscreen_char(LineOffset[i] + Columns - 1, i, Columns - 1);\n    }\n#endif\n\n    if (idx > wp->w_lines_valid)\n\twp->w_lines_valid = idx;\n\n#ifdef FEAT_SYN_HL\n    // Let the syntax stuff know we stop parsing here.\n    if (syntax_last_parsed != 0 && syntax_present(wp))\n\tsyntax_end_parsing(syntax_last_parsed + 1);\n#endif\n\n    // If we didn't hit the end of the file, and we didn't finish the last\n    // line we were working on, then the line didn't fit.\n    wp->w_empty_rows = 0;\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (!eof && !didline)\n    {\n\tif (lnum == wp->w_topline)\n\t{\n\t    // Single line that does not fit!\n\t    // Don't overwrite it, it can be edited.\n\t    wp->w_botline = lnum + 1;\n\t}\n#ifdef FEAT_DIFF\n\telse if (diff_check_fill(wp, lnum) >= wp->w_height - srow)\n\t{\n\t    // Window ends in filler lines.\n\t    wp->w_botline = lnum;\n\t    wp->w_filler_rows = wp->w_height - srow;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\telse if (WIN_IS_POPUP(wp))\n\t{\n\t    // popup line that doesn't fit is left as-is\n\t    wp->w_botline = lnum;\n\t}\n#endif\n\telse if (dy_flags & DY_TRUNCATE)\t// 'display' has \"truncate\"\n\t{\n\t    int scr_row = W_WINROW(wp) + wp->w_height - 1;\n\n\t    // Last line isn't finished: Display \"@@@\" in the last screen line.\n\t    screen_puts_len((char_u *)\"@@\", 2, scr_row, wp->w_wincol,\n\t\t\t\t\t\t\t      HL_ATTR(HLF_AT));\n\t    screen_fill(scr_row, scr_row + 1,\n\t\t    (int)wp->w_wincol + 2, (int)W_ENDCOL(wp),\n\t\t    '@', ' ', HL_ATTR(HLF_AT));\n\t    set_empty_rows(wp, srow);\n\t    wp->w_botline = lnum;\n\t}\n\telse if (dy_flags & DY_LASTLINE)\t// 'display' has \"lastline\"\n\t{\n\t    // Last line isn't finished: Display \"@@@\" at the end.\n\t    screen_fill(W_WINROW(wp) + wp->w_height - 1,\n\t\t    W_WINROW(wp) + wp->w_height,\n\t\t    (int)W_ENDCOL(wp) - 3, (int)W_ENDCOL(wp),\n\t\t    '@', '@', HL_ATTR(HLF_AT));\n\t    set_empty_rows(wp, srow);\n\t    wp->w_botline = lnum;\n\t}\n\telse\n\t{\n\t    win_draw_end(wp, '@', ' ', TRUE, srow, wp->w_height, HLF_AT);\n\t    wp->w_botline = lnum;\n\t}\n    }\n    else\n    {\n\tdraw_vsep_win(wp, row);\n\tif (eof)\t\t// we hit the end of the file\n\t{\n\t    wp->w_botline = buf->b_ml.ml_line_count + 1;\n#ifdef FEAT_DIFF\n\t    j = diff_check_fill(wp, wp->w_botline);\n\t    if (j > 0 && !wp->w_botfill)\n\t    {\n\t\t// Display filler lines at the end of the file.\n\t\tif (char2cells(fill_diff) > 1)\n\t\t    i = '-';\n\t\telse\n\t\t    i = fill_diff;\n\t\tif (row + j > wp->w_height)\n\t\t    j = wp->w_height - row;\n\t\twin_draw_end(wp, i, i, TRUE, row, row + (int)j, HLF_DED);\n\t\trow += j;\n\t    }\n#endif\n\t}\n\telse if (dollar_vcol == -1)\n\t    wp->w_botline = lnum;\n\n\t// Make sure the rest of the screen is blank\n\t// write the 'fill_eob' character to rows that aren't part of the file\n\tif (WIN_IS_POPUP(wp))\n\t    win_draw_end(wp, ' ', ' ', FALSE, row, wp->w_height, HLF_AT);\n\telse\n\t    win_draw_end(wp, fill_eob, ' ', FALSE, row, wp->w_height, HLF_EOB);\n    }\n\n#ifdef SYN_TIME_LIMIT\n    syn_set_timeout(NULL);\n#endif\n\n    // Reset the type of redrawing required, the window has been updated.\n    wp->w_redr_type = 0;\n#ifdef FEAT_DIFF\n    wp->w_old_topfill = wp->w_topfill;\n    wp->w_old_botfill = wp->w_botfill;\n#endif\n\n    if (dollar_vcol == -1)\n    {\n\t// There is a trick with w_botline.  If we invalidate it on each\n\t// change that might modify it, this will cause a lot of expensive\n\t// calls to plines() in update_topline() each time.  Therefore the\n\t// value of w_botline is often approximated, and this value is used to\n\t// compute the value of w_topline.  If the value of w_botline was\n\t// wrong, check that the value of w_topline is correct (cursor is on\n\t// the visible part of the text).  If it's not, we need to redraw\n\t// again.  Mostly this just means scrolling up a few lines, so it\n\t// doesn't look too bad.  Only do this for the current window (where\n\t// changes are relevant).\n\twp->w_valid |= VALID_BOTLINE;\n\tif (wp == curwin && wp->w_botline != old_botline && !recursive)\n\t{\n\t    win_T\t*wwp;\n#if defined(FEAT_CONCEAL)\n\t    linenr_T\told_topline = wp->w_topline;\n\t    int\t\tnew_wcol = wp->w_wcol;\n#endif\n\t    recursive = TRUE;\n\t    curwin->w_valid &= ~VALID_TOPLINE;\n\t    update_topline();\t// may invalidate w_botline again\n\n#if defined(FEAT_CONCEAL)\n\t    if (old_wcol != new_wcol && (wp->w_valid & (VALID_WCOL|VALID_WROW))\n\t\t\t\t\t\t    != (VALID_WCOL|VALID_WROW))\n\t    {\n\t\t// A win_line() call applied a fix to screen cursor column to\n\t\t// accommodate concealment of cursor line, but in this call to\n\t\t// update_topline() the cursor's row or column got invalidated.\n\t\t// If they are left invalid, setcursor() will recompute them\n\t\t// but there won't be any further win_line() call to re-fix the\n\t\t// column and the cursor will end up misplaced.  So we call\n\t\t// cursor validation now and reapply the fix again (or call\n\t\t// win_line() to do it for us).\n\t\tvalidate_cursor();\n\t\tif (wp->w_wcol == old_wcol && wp->w_wrow == old_wrow\n\t\t\t\t\t       && old_topline == wp->w_topline)\n\t\t    wp->w_wcol = new_wcol;\n\t\telse\n\t\t    redrawWinline(wp, wp->w_cursor.lnum);\n\t    }\n#endif\n\t    // New redraw either due to updated topline or due to wcol fix.\n\t    if (wp->w_redr_type != 0)\n\t    {\n\t\t// Don't update for changes in buffer again.\n\t\ti = curbuf->b_mod_set;\n\t\tcurbuf->b_mod_set = FALSE;\n\t\tj = curbuf->b_mod_xlines;\n\t\tcurbuf->b_mod_xlines = 0;\n\t\twin_update(curwin);\n\t\tcurbuf->b_mod_set = i;\n\t\tcurbuf->b_mod_xlines = j;\n\t    }\n\t    // Other windows might have w_redr_type raised in update_topline().\n\t    must_redraw = 0;\n\t    FOR_ALL_WINDOWS(wwp)\n\t\tif (wwp->w_redr_type > must_redraw)\n\t\t    must_redraw = wwp->w_redr_type;\n\t    recursive = FALSE;\n\t}\n    }\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)\n    // restore got_int, unless CTRL-C was hit while redrawing\n    if (!got_int)\n\tgot_int = save_got_int;\n#endif\n}\n\n#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GUI)\n/*\n * Prepare for updating one or more windows.\n * Caller must check for \"updating_screen\" already set to avoid recursiveness.\n */\n    static void\nupdate_prepare(void)\n{\n    cursor_off();\n    updating_screen = TRUE;\n#ifdef FEAT_GUI\n    // Remove the cursor before starting to do anything, because scrolling may\n    // make it difficult to redraw the text under it.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n    start_search_hl();\n#endif\n#ifdef FEAT_PROP_POPUP\n    // Update popup_mask if needed.\n    may_update_popup_mask(must_redraw);\n#endif\n}\n\n/*\n * Finish updating one or more windows.\n */\n    static void\nupdate_finish(void)\n{\n    if (redraw_cmdline || redraw_mode)\n\tshowmode();\n\n# ifdef FEAT_SEARCH_EXTRA\n    end_search_hl();\n# endif\n\n    after_updating_screen(TRUE);\n\n# ifdef FEAT_GUI\n    // Redraw the cursor and update the scrollbars when all screen updating is\n    // done.\n    if (gui.in_use)\n    {\n\tout_flush_cursor(FALSE, FALSE);\n\tgui_update_scrollbars(FALSE);\n    }\n# endif\n}\n#endif\n\n#if defined(FEAT_NETBEANS_INTG) || defined(PROTO)\n    void\nupdate_debug_sign(buf_T *buf, linenr_T lnum)\n{\n    win_T\t*wp;\n    int\t\tdoit = FALSE;\n\n# ifdef FEAT_FOLDING\n    win_foldinfo.fi_level = 0;\n# endif\n\n    // update/delete a specific sign\n    redraw_buf_line_later(buf, lnum);\n\n    // check if it resulted in the need to redraw a window\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_redr_type != 0)\n\t    doit = TRUE;\n\n    // Return when there is nothing to do, screen updating is already\n    // happening (recursive call), messages on the screen or still starting up.\n    if (!doit || updating_screen\n\t    || State == ASKMORE || State == HITRETURN\n\t    || msg_scrolled\n#ifdef FEAT_GUI\n\t    || gui.starting\n#endif\n\t    || starting)\n\treturn;\n\n    // update all windows that need updating\n    update_prepare();\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_redr_type != 0)\n\t    win_update(wp);\n\tif (wp->w_redr_status)\n\t    win_redr_status(wp, FALSE);\n    }\n\n    update_finish();\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Update a single window, its status line and maybe the command line msg.\n * Used for the GUI scrollbar.\n */\n    void\nupdateWindow(win_T *wp)\n{\n    // return if already busy updating\n    if (updating_screen)\n\treturn;\n\n    update_prepare();\n\n#ifdef FEAT_CLIPBOARD\n    // When Visual area changed, may have to update selection.\n    if (clip_star.available && clip_isautosel_star())\n\tclip_update_selection(&clip_star);\n    if (clip_plus.available && clip_isautosel_plus())\n\tclip_update_selection(&clip_plus);\n#endif\n\n    win_update(wp);\n\n    // When the screen was cleared redraw the tab pages line.\n    if (redraw_tabline)\n\tdraw_tabline();\n\n    if (wp->w_redr_status\n# ifdef FEAT_CMDL_INFO\n\t    || p_ru\n# endif\n# ifdef FEAT_STL_OPT\n\t    || *p_stl != NUL || *wp->w_p_stl != NUL\n# endif\n\t    )\n\twin_redr_status(wp, FALSE);\n\n#ifdef FEAT_PROP_POPUP\n    // Display popup windows on top of everything.\n    update_popups(win_update);\n#endif\n\n    update_finish();\n}\n#endif\n\n#if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * Redraw as soon as possible.  When the command line is not scrolled redraw\n * right away and restore what was on the command line.\n * Return a code indicating what happened.\n */\n    int\nredraw_asap(int type)\n{\n    int\t\trows;\n    int\t\tcols = screen_Columns;\n    int\t\tr;\n    int\t\tret = 0;\n    schar_T\t*screenline;\t// copy from ScreenLines[]\n    sattr_T\t*screenattr;\t// copy from ScreenAttrs[]\n    int\t\ti;\n    u8char_T\t*screenlineUC = NULL;\t// copy from ScreenLinesUC[]\n    u8char_T\t*screenlineC[MAX_MCO];\t// copy from ScreenLinesC[][]\n    schar_T\t*screenline2 = NULL;\t// copy from ScreenLines2[]\n\n    redraw_later(type);\n    if (msg_scrolled || (State != NORMAL && State != NORMAL_BUSY) || exiting)\n\treturn ret;\n\n    // Allocate space to save the text displayed in the command line area.\n    rows = screen_Rows - cmdline_row;\n    screenline = LALLOC_MULT(schar_T, rows * cols);\n    screenattr = LALLOC_MULT(sattr_T, rows * cols);\n    if (screenline == NULL || screenattr == NULL)\n\tret = 2;\n    if (enc_utf8)\n    {\n\tscreenlineUC = LALLOC_MULT(u8char_T, rows * cols);\n\tif (screenlineUC == NULL)\n\t    ret = 2;\n\tfor (i = 0; i < p_mco; ++i)\n\t{\n\t    screenlineC[i] = LALLOC_MULT(u8char_T, rows * cols);\n\t    if (screenlineC[i] == NULL)\n\t\tret = 2;\n\t}\n    }\n    if (enc_dbcs == DBCS_JPNU)\n    {\n\tscreenline2 = LALLOC_MULT(schar_T, rows * cols);\n\tif (screenline2 == NULL)\n\t    ret = 2;\n    }\n\n    if (ret != 2)\n    {\n\t// Save the text displayed in the command line area.\n\tfor (r = 0; r < rows; ++r)\n\t{\n\t    mch_memmove(screenline + r * cols,\n\t\t\tScreenLines + LineOffset[cmdline_row + r],\n\t\t\t(size_t)cols * sizeof(schar_T));\n\t    mch_memmove(screenattr + r * cols,\n\t\t\tScreenAttrs + LineOffset[cmdline_row + r],\n\t\t\t(size_t)cols * sizeof(sattr_T));\n\t    if (enc_utf8)\n\t    {\n\t\tmch_memmove(screenlineUC + r * cols,\n\t\t\t    ScreenLinesUC + LineOffset[cmdline_row + r],\n\t\t\t    (size_t)cols * sizeof(u8char_T));\n\t\tfor (i = 0; i < p_mco; ++i)\n\t\t    mch_memmove(screenlineC[i] + r * cols,\n\t\t\t\tScreenLinesC[i] + LineOffset[cmdline_row + r],\n\t\t\t\t(size_t)cols * sizeof(u8char_T));\n\t    }\n\t    if (enc_dbcs == DBCS_JPNU)\n\t\tmch_memmove(screenline2 + r * cols,\n\t\t\t    ScreenLines2 + LineOffset[cmdline_row + r],\n\t\t\t    (size_t)cols * sizeof(schar_T));\n\t}\n\n\tupdate_screen(0);\n\tret = 3;\n\n\tif (must_redraw == 0)\n\t{\n\t    int\toff = (int)(current_ScreenLine - ScreenLines);\n\n\t    // Restore the text displayed in the command line area.\n\t    for (r = 0; r < rows; ++r)\n\t    {\n\t\tmch_memmove(current_ScreenLine,\n\t\t\t    screenline + r * cols,\n\t\t\t    (size_t)cols * sizeof(schar_T));\n\t\tmch_memmove(ScreenAttrs + off,\n\t\t\t    screenattr + r * cols,\n\t\t\t    (size_t)cols * sizeof(sattr_T));\n\t\tif (enc_utf8)\n\t\t{\n\t\t    mch_memmove(ScreenLinesUC + off,\n\t\t\t\tscreenlineUC + r * cols,\n\t\t\t\t(size_t)cols * sizeof(u8char_T));\n\t\t    for (i = 0; i < p_mco; ++i)\n\t\t\tmch_memmove(ScreenLinesC[i] + off,\n\t\t\t\t    screenlineC[i] + r * cols,\n\t\t\t\t    (size_t)cols * sizeof(u8char_T));\n\t\t}\n\t\tif (enc_dbcs == DBCS_JPNU)\n\t\t    mch_memmove(ScreenLines2 + off,\n\t\t\t\tscreenline2 + r * cols,\n\t\t\t\t(size_t)cols * sizeof(schar_T));\n\t\tscreen_line(cmdline_row + r, 0, cols, cols, 0);\n\t    }\n\t    ret = 4;\n\t}\n    }\n\n    vim_free(screenline);\n    vim_free(screenattr);\n    if (enc_utf8)\n    {\n\tvim_free(screenlineUC);\n\tfor (i = 0; i < p_mco; ++i)\n\t    vim_free(screenlineC[i]);\n    }\n    if (enc_dbcs == DBCS_JPNU)\n\tvim_free(screenline2);\n\n    // Show the intro message when appropriate.\n    maybe_intro_message();\n\n    setcursor();\n\n    return ret;\n}\n#endif\n\n/*\n * Invoked after an asynchronous callback is called.\n * If an echo command was used the cursor needs to be put back where\n * it belongs. If highlighting was changed a redraw is needed.\n * If \"call_update_screen\" is FALSE don't call update_screen() when at the\n * command line.\n * If \"redraw_message\" is TRUE.\n */\n    void\nredraw_after_callback(int call_update_screen, int do_message)\n{\n    ++redrawing_for_callback;\n\n    if (State == HITRETURN || State == ASKMORE || State == SETWSIZE\n\t    || State == EXTERNCMD || State == CONFIRM || exmode_active)\n    {\n\tif (do_message)\n\t    repeat_message();\n    }\n    else if (State & CMDLINE)\n    {\n\t// Don't redraw when in prompt_for_number().\n\tif (cmdline_row > 0)\n\t{\n\t    // Redrawing only works when the screen didn't scroll. Don't clear\n\t    // wildmenu entries.\n\t    if (msg_scrolled == 0\n#ifdef FEAT_WILDMENU\n\t\t    && wild_menu_showing == 0\n#endif\n\t\t    && call_update_screen)\n\t\tupdate_screen(0);\n\n\t    // Redraw in the same position, so that the user can continue\n\t    // editing the command.\n\t    redrawcmdline_ex(FALSE);\n\t}\n    }\n    else if (State & (NORMAL | INSERT | TERMINAL))\n    {\n\t// keep the command line if possible\n\tupdate_screen(VALID_NO_UPDATE);\n\tsetcursor();\n\n\tif (msg_scrolled == 0)\n\t{\n\t    // don't want a hit-enter prompt when something else is displayed\n\t    msg_didany = FALSE;\n\t    need_wait_return = FALSE;\n\t}\n    }\n    cursor_on();\n#ifdef FEAT_GUI\n    if (gui.in_use && !gui_mch_is_blink_off())\n\t// Don't update the cursor when it is blinking and off to avoid\n\t// flicker.\n\tout_flush_cursor(FALSE, FALSE);\n    else\n#endif\n\tout_flush();\n\n    --redrawing_for_callback;\n}\n\n/*\n * Redraw the current window later, with update_screen(type).\n * Set must_redraw only if not already set to a higher value.\n * E.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.\n */\n    void\nredraw_later(int type)\n{\n    redraw_win_later(curwin, type);\n}\n\n    void\nredraw_win_later(\n    win_T\t*wp,\n    int\t\ttype)\n{\n    if (!exiting && wp->w_redr_type < type)\n    {\n\twp->w_redr_type = type;\n\tif (type >= NOT_VALID)\n\t    wp->w_lines_valid = 0;\n\tif (must_redraw < type)\t// must_redraw is the maximum of all windows\n\t    must_redraw = type;\n    }\n}\n\n/*\n * Force a complete redraw later.  Also resets the highlighting.  To be used\n * after executing a shell command that messes up the screen.\n */\n    void\nredraw_later_clear(void)\n{\n    redraw_all_later(CLEAR);\n    reset_screen_attr();\n}\n\n/*\n * Mark all windows to be redrawn later.\n */\n    void\nredraw_all_later(int type)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tredraw_win_later(wp, type);\n    // This may be needed when switching tabs.\n    if (must_redraw < type)\n\tmust_redraw = type;\n}\n\n/*\n * Mark all windows that are editing the current buffer to be updated later.\n */\n    void\nredraw_curbuf_later(int type)\n{\n    redraw_buf_later(curbuf, type);\n}\n\n    void\nredraw_buf_later(buf_T *buf, int type)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == buf)\n\t    redraw_win_later(wp, type);\n    }\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // terminal in popup window is not in list of windows\n    if (curwin->w_buffer == buf)\n\tredraw_win_later(curwin, type);\n#endif\n}\n\n#if defined(FEAT_SIGNS) || defined(PROTO)\n    void\nredraw_buf_line_later(buf_T *buf, linenr_T lnum)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf && lnum >= wp->w_topline\n\t\t\t\t\t\t  && lnum < wp->w_botline)\n\t    redrawWinline(wp, lnum);\n}\n#endif\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n    void\nredraw_buf_and_status_later(buf_T *buf, int type)\n{\n    win_T\t*wp;\n\n#ifdef FEAT_WILDMENU\n    if (wild_menu_showing != 0)\n\t// Don't redraw while the command line completion is displayed, it\n\t// would disappear.\n\treturn;\n#endif\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == buf)\n\t{\n\t    redraw_win_later(wp, type);\n\t    wp->w_redr_status = TRUE;\n\t}\n    }\n}\n#endif\n\n/*\n * mark all status lines for redraw; used after first :cd\n */\n    void\nstatus_redraw_all(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_status_height)\n\t{\n\t    wp->w_redr_status = TRUE;\n\t    redraw_later(VALID);\n\t}\n}\n\n/*\n * mark all status lines of the current buffer for redraw\n */\n    void\nstatus_redraw_curbuf(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_status_height != 0 && wp->w_buffer == curbuf)\n\t{\n\t    wp->w_redr_status = TRUE;\n\t    redraw_later(VALID);\n\t}\n}\n\n/*\n * Redraw all status lines that need to be redrawn.\n */\n    void\nredraw_statuslines(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_redr_status)\n\t    win_redr_status(wp, FALSE);\n    if (redraw_tabline)\n\tdraw_tabline();\n}\n\n#if defined(FEAT_WILDMENU) || defined(PROTO)\n/*\n * Redraw all status lines at the bottom of frame \"frp\".\n */\n    void\nwin_redraw_last_status(frame_T *frp)\n{\n    if (frp->fr_layout == FR_LEAF)\n\tfrp->fr_win->w_redr_status = TRUE;\n    else if (frp->fr_layout == FR_ROW)\n    {\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    win_redraw_last_status(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\twin_redraw_last_status(frp);\n    }\n}\n#endif\n\n/*\n * Changed something in the current window, at buffer line \"lnum\", that\n * requires that line and possibly other lines to be redrawn.\n * Used when entering/leaving Insert mode with the cursor on a folded line.\n * Used to remove the \"$\" from a change command.\n * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot\n * may become invalid and the whole window will have to be redrawn.\n */\n    void\nredrawWinline(\n    win_T\t*wp,\n    linenr_T\tlnum)\n{\n    if (wp->w_redraw_top == 0 || wp->w_redraw_top > lnum)\n\twp->w_redraw_top = lnum;\n    if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lnum)\n\twp->w_redraw_bot = lnum;\n    redraw_win_later(wp, VALID);\n}\n", "\" Test for edit functions\n\nif exists(\"+t_kD\")\n  let &t_kD=\"\u001b[3;*~\"\nendif\n\nsource check.vim\n\n\" Needed for testing basic rightleft: Test_edit_rightleft\nsource view_util.vim\n\n\" Needs to come first until the bug in getchar() is\n\" fixed: https://groups.google.com/d/msg/vim_dev/fXL9yme4H4c/bOR-U6_bAQAJ\nfunc Test_edit_00b()\n  new\n  call setline(1, ['abc '])\n  inoreabbr <buffer> h here some more\n  call cursor(1, 4)\n  \" <c-l> expands the abbreviation and ends insertmode\n  call feedkeys(\":set im\\<cr> h\\<c-l>:set noim\\<cr>\", 'tix')\n  call assert_equal(['abc here some more '], getline(1,'$'))\n  iunabbr <buffer> h\n  bw!\nendfunc\n\nfunc Test_edit_01()\n  \" set for Travis CI?\n  \"  set nocp noesckeys\n  new\n  \" 1) empty buffer\n  call assert_equal([''], getline(1,'$'))\n  \" 2) delete in an empty line\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 3) delete one character\n  call setline(1, 'a')\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 4) delete a multibyte character\n  call setline(1, \"\\u0401\")\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 5.1) delete linebreak with 'bs' option containing eol\n  let _bs=&bs\n  set bs=eol\n  call setline(1, [\"abc def\", \"ghi jkl\"])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<del>\\<esc>\", 'tnix')\n  call assert_equal(['abc defghi jkl'], getline(1, 2))\n  %d\n  \" 5.2) delete linebreak with backspace option w/out eol\n  set bs=\n  call setline(1, [\"abc def\", \"ghi jkl\"])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<del>\\<esc>\", 'tnix')\n  call assert_equal([\"abc def\", \"ghi jkl\"], getline(1, 2))\n  let &bs=_bs\n  bw!\nendfunc\n\nfunc Test_edit_02()\n  \" Change cursor position in InsertCharPre command\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  fu! DoIt(...)\n    call cursor(1, 4)\n    if len(a:000)\n      let v:char=a:1\n    endif\n  endfu\n  au InsertCharPre <buffer> :call DoIt('y')\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  \" Setting <Enter> in InsertCharPre\n  au! InsertCharPre <buffer> :call DoIt(\"\\n\")\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abc', ''], getline(1, '$'))\n  %d\n  au! InsertCharPre\n  \" Change cursor position in InsertEnter command\n  \" 1) when setting v:char, keeps changed cursor position\n  au! InsertEnter <buffer> :call DoIt('y')\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abxc'], getline(1, '$'))\n  \" 2) when not setting v:char, restores changed cursor position\n  au! InsertEnter <buffer> :call DoIt()\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['xabc'], getline(1, '$'))\n  au! InsertEnter\n  delfu DoIt\n  bw!\nendfunc\n\nfunc Test_edit_03()\n  \" Change cursor after <c-o> command to end of line\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>$y\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  %d\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>80|y\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  %d\n  call setline(1, 'abc')\n  call feedkeys(\"Ad\\<c-o>:s/$/efg/\\<cr>hij\", 'tnix')\n  call assert_equal(['hijabcdefg'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_04()\n  \" test for :stopinsert\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>:stopinsert\\<cr>$\", 'tnix')\n  call feedkeys(\"aX\\<esc>\", 'tnix')\n  call assert_equal(['abcX'], getline(1, '$'))\n  %d\n  bw!\nendfunc\n\nfunc Test_edit_05()\n  \" test for folds being opened\n  new\n  call setline(1, ['abcX', 'abcX', 'zzzZ'])\n  call cursor(1, 1)\n  set foldmethod=manual foldopen+=insert\n  \" create fold for those two lines\n  norm! Vjzf\n  call feedkeys(\"$ay\\<esc>\", 'tnix')\n  call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))\n  %d\n  call setline(1, ['abcX', 'abcX', 'zzzZ'])\n  call cursor(1, 1)\n  set foldmethod=manual foldopen-=insert\n  \" create fold for those two lines\n  norm! Vjzf\n  call feedkeys(\"$ay\\<esc>\", 'tnix')\n  call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))\n  %d\n  bw!\nendfunc\n\nfunc Test_edit_06()\n  \" Test in diff mode\n  CheckFeature diff\n  CheckExecutable diff\n  new\n  call setline(1, ['abc', 'xxx', 'yyy'])\n  vnew\n  call setline(1, ['abc', 'zzz', 'xxx', 'yyy'])\n  wincmd p\n  diffthis\n  wincmd p\n  diffthis\n  wincmd p\n  call cursor(2, 1)\n  norm! zt\n  call feedkeys(\"Ozzz\\<esc>\", 'tnix')\n  call assert_equal(['abc', 'zzz', 'xxx', 'yyy'], getline(1,'$'))\n  bw!\n  bw!\nendfunc\n\nfunc Test_edit_07()\n  \" 1) Test with completion <c-l> when popupmenu is visible\n  new\n  call setline(1, 'J')\n\n  func! ListMonths()\n    call complete(col('.')-1, ['January', 'February', 'March',\n    \\ 'April', 'May', 'June', 'July', 'August', 'September',\n    \\ 'October', 'November', 'December'])\n    return ''\n  endfunc\n  inoremap <buffer> <F5> <C-R>=ListMonths()<CR>\n\n  call feedkeys(\"A\\<f5>\\<c-p>\". repeat(\"\\<down>\", 6).\"\\<c-l>\\<down>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal(['July'], getline(1,'$'))\n  \" 1) Test completion when InsertCharPre kicks in\n  %d\n  call setline(1, 'J')\n  fu! DoIt()\n    if v:char=='u'\n      let v:char='an'\n    endif\n  endfu\n  au InsertCharPre <buffer> :call DoIt()\n  call feedkeys(\"A\\<f5>\\<c-p>u\\<cr>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal([\"Jan\\<c-l>\",''], 1->getline('$'))\n  %d\n  call setline(1, 'J')\n  call feedkeys(\"A\\<f5>\\<c-p>u\\<down>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal([\"January\"], 1->getline('$'))\n\n  delfu ListMonths\n  delfu DoIt\n  iunmap <buffer> <f5>\n  bw!\nendfunc\n\nfunc Test_edit_08()\n  \" reset insertmode from i_ctrl-r_=\n  let g:bufnr = bufnr('%')\n  new\n  call setline(1, ['abc'])\n  call cursor(1, 4)\n  call feedkeys(\":set im\\<cr>ZZZ\\<c-r>=setbufvar(g:bufnr,'&im', 0)\\<cr>\",'tnix')\n  call assert_equal(['abZZZc'], getline(1,'$'))\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call assert_false(0, '&im')\n  bw!\n  unlet g:bufnr\nendfunc\n\nfunc Test_edit_09()\n  \" test i_CTRL-\\ combinations\n  new\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 1)\n  \" 1) CTRL-\\ CTLR-N\n  call feedkeys(\":set im\\<cr>\\<c-\\>\\<c-n>ccABC\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'def', 'ghi'], getline(1,'$'))\n  call setline(1, ['ABC', 'def', 'ghi'])\n  \" 2) CTRL-\\ CTLR-G\n  call feedkeys(\"j0\\<c-\\>\\<c-g>ZZZ\\<cr>\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  call feedkeys(\"I\\<c-\\>\\<c-g>YYY\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'ZZZ', 'YYYdef', 'ghi'], getline(1,'$'))\n  set noinsertmode\n  \" 3) CTRL-\\ CTRL-O\n  call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-o>ix\", 'txin')\n  call assert_equal(['ABxC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  call feedkeys(\"A\\<c-\\>\\<c-o>ix\", 'txin')\n  call assert_equal(['ABxCx', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  \" 4) CTRL-\\ a (should be inserted literally, not special after <c-\\>\n  call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-\\>a\", 'txin')\n  call assert_equal([\"ABC\\<c-\\>a\", 'ZZZ', 'def', 'ghi'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_11()\n  \" Test that indenting kicks in\n  new\n  set cindent\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"\\<Insert>/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"/* comment */\"], getline(1, '$'))\n  \" added changed cindentkeys slightly\n  set cindent cinkeys+=*/\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"i/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"\\<tab>/* comment */\"], getline(1, '$'))\n  set cindent cinkeys+==end\n  call feedkeys(\"oend\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"\\<tab>/* comment */\", \"\\tend\", ''], getline(1, '$'))\n  set cinkeys-==end\n  %d\n  \" Use indentexpr instead of cindenting\n  func! Do_Indent()\n    if v:lnum == 3\n      return 3*shiftwidth()\n    else\n      return 2*shiftwidth()\n    endif\n  endfunc\n  setl indentexpr=Do_Indent() indentkeys+=*/\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"i/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>\\<tab>int c;\", \"\\<tab>\\<tab>\\<tab>/* comment */\"], getline(1, '$'))\n  set cinkeys&vim indentkeys&vim\n  set nocindent indentexpr=\n  delfu Do_Indent\n  bw!\nendfunc\n\nfunc Test_edit_11_indentexpr()\n  \" Test that indenting kicks in\n  new\n  \" Use indentexpr instead of cindenting\n  func! Do_Indent()\n    let pline=prevnonblank(v:lnum)\n    if empty(getline(v:lnum))\n      if getline(pline) =~ 'if\\|then'\n        return shiftwidth()\n      else\n        return 0\n      endif\n    else\n        return 0\n    endif\n  endfunc\n  setl indentexpr=Do_Indent() indentkeys+=0=then,0=fi\n  call setline(1, ['if [ $this ]'])\n  call cursor(1, 1)\n  call feedkeys(\"othen\\<cr>that\\<cr>fi\", 'tnix')\n  call assert_equal(['if [ $this ]', \"then\", \"\\<tab>that\", \"fi\"], getline(1, '$'))\n  set cinkeys&vim indentkeys&vim\n  set nocindent indentexpr=\n  delfu Do_Indent\n\n  \" Using a script-local function\n  func s:NewIndentExpr()\n  endfunc\n  set indentexpr=s:NewIndentExpr()\n  call assert_equal(expand('<SID>') .. 'NewIndentExpr()', &indentexpr)\n  set indentexpr=<SID>NewIndentExpr()\n  call assert_equal(expand('<SID>') .. 'NewIndentExpr()', &indentexpr)\n  set indentexpr&\n\n  bw!\nendfunc\n\n\" Test changing indent in replace mode\nfunc Test_edit_12()\n  new\n  call setline(1, [\"\\tabc\", \"\\tdef\"])\n  call cursor(2, 4)\n  call feedkeys(\"R^\\<c-d>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"def\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], '.'->getpos())\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R^\\<c-d>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"def\"], getline(1, '$'))\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  bw!\n  10vnew\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  %d\n  set sw=4\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  set sw&\n\n  \" In replace mode, after hitting enter in a line with tab characters,\n  \" pressing backspace should restore the tab characters.\n  %d\n  setlocal autoindent backspace=2\n  call setline(1, \"\\tone\\t\\ttwo\")\n  exe \"normal ggRred\\<CR>six\" .. repeat(\"\\<BS>\", 8)\n  call assert_equal([\"\\tone\\t\\ttwo\"], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_13()\n  \" Test smartindenting\n  if exists(\"+smartindent\")\n    new\n    set smartindent autoindent\n    call setline(1, [\"\\tabc\"])\n    call feedkeys(\"A {\\<cr>more\\<cr>}\\<esc>\", 'tnix')\n    call assert_equal([\"\\tabc {\", \"\\t\\tmore\", \"\\t}\"], getline(1, '$'))\n    set smartindent& autoindent&\n    bwipe!\n  endif\n\n  \" Test autoindent removing indent of blank line.\n  new\n  call setline(1, '    foo bar baz')\n  set autoindent\n  exe \"normal 0eea\\<CR>\\<CR>\\<Esc>\"\n  call assert_equal(\"    foo bar\", getline(1))\n  call assert_equal(\"\", getline(2))\n  call assert_equal(\"    baz\", getline(3))\n  set autoindent&\n\n  \" pressing <C-U> to erase line should keep the indent with 'autoindent'\n  set backspace=2 autoindent\n  %d\n  exe \"normal i\\tone\\<CR>three\\<C-U>two\"\n  call assert_equal([\"\\tone\", \"\\ttwo\"], getline(1, '$'))\n  set backspace& autoindent&\n\n  bwipe!\nendfunc\n\n\" Test for autoindent removing indent when insert mode is stopped.  Some parts\n\" of the code is exercised only when interactive mode is used. So use Vim in a\n\" terminal.\nfunc Test_autoindent_remove_indent()\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('-N Xfile', {'rows': 6, 'cols' : 20})\n  call TermWait(buf)\n  call term_sendkeys(buf, \":set autoindent\\n\")\n  \" leaving insert mode in a new line with indent added by autoindent, should\n  \" remove the indent.\n  call term_sendkeys(buf, \"i\\<Tab>foo\\<CR>\\<Esc>\")\n  \" Need to delay for some time, otherwise the code in getchar.c will not be\n  \" exercised.\n  call TermWait(buf, 50)\n  \" when a line is wrapped and the cursor is at the start of the second line,\n  \" leaving insert mode, should move the cursor back to the first line.\n  call term_sendkeys(buf, \"o\" .. repeat('x', 20) .. \"\\<Esc>\")\n  \" Need to delay for some time, otherwise the code in getchar.c will not be\n  \" exercised.\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":w\\n\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n  call assert_equal([\"\\tfoo\", '', repeat('x', 20)], readfile('Xfile'))\n  call delete('Xfile')\nendfunc\n\nfunc Test_edit_CR()\n  \" Test for <CR> in insert mode\n  \" basically only in quickfix mode it's tested, the rest\n  \" has been taken care of by other tests\n  CheckFeature quickfix\n  botright new\n  call writefile(range(1, 10), 'Xqflist.txt')\n  call setqflist([{'filename': 'Xqflist.txt', 'lnum': 2}])\n  copen\n  set modifiable\n  call feedkeys(\"A\\<cr>\", 'tnix')\n  call assert_equal('Xqflist.txt', bufname(''))\n  call assert_equal(2, line('.'))\n  cclose\n  botright new\n  call setloclist(0, [{'filename': 'Xqflist.txt', 'lnum': 10}])\n  lopen\n  set modifiable\n  call feedkeys(\"A\\<cr>\", 'tnix')\n  call assert_equal('Xqflist.txt', bufname(''))\n  call assert_equal(10, line('.'))\n  call feedkeys(\"A\\<Enter>\", 'tnix')\n  call feedkeys(\"A\\<kEnter>\", 'tnix')\n  call feedkeys(\"A\\n\", 'tnix')\n  call feedkeys(\"A\\r\", 'tnix')\n  call assert_equal(map(range(1, 10), 'string(v:val)') + ['', '', '', ''], getline(1, '$'))\n  bw!\n  lclose\n  call delete('Xqflist.txt')\nendfunc\n\nfunc Test_edit_CTRL_()\n  CheckFeature rightleft\n  \" disabled for Windows builds, why?\n  CheckNotMSWindows\n  let _encoding=&encoding\n  set encoding=utf-8\n  \" Test for CTRL-_\n  new\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"\\<C-_>xyzabc\"], getline(1, '$'))\n  call assert_false(&revins)\n  set ari\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"\u00e6\u00e8\u00f1abc\"], getline(1, '$'))\n  call assert_true(&revins)\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"xyzabc\"], getline(1, '$'))\n  call assert_false(&revins)\n  set noari\n  let &encoding=_encoding\n  bw!\nendfunc\n\n\" needs to come first, to have the @. register empty\nfunc Test_edit_00a_CTRL_A()\n  \" Test pressing CTRL-A\n  new\n  call setline(1, repeat([''], 5))\n  call cursor(1, 1)\n  try\n    call feedkeys(\"A\\<NUL>\", 'tnix')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E29/\n    call assert_true(1, 'E29 error caught')\n  endtry\n  call cursor(1, 1)\n  call feedkeys(\"Afoobar \\<esc>\", 'tnix')\n  call cursor(2, 1)\n  call feedkeys(\"A\\<c-a>more\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"A\\<NUL>and more\\<esc>\", 'tnix')\n  call assert_equal(['foobar ', 'foobar more', 'foobar morend more', '', ''], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_EY()\n  \" Ctrl-E/ Ctrl-Y in insert mode completion to scroll\n  10new\n  call setline(1, range(1, 100))\n  call cursor(30, 1)\n  norm! z.\n  call feedkeys(\"A\\<c-x>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\", 'tnix')\n  call assert_equal(30, winsaveview()['topline'])\n  call assert_equal([0, 30, 2, 0], getpos('.'))\n  call feedkeys(\"A\\<c-x>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\", 'tnix')\n  call feedkeys(\"A\\<c-x>\".repeat(\"\\<c-y>\", 10), 'tnix')\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 30, 2, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_G()\n  new\n  call setline(1, ['foobar', 'foobar', 'foobar'])\n  call cursor(2, 4)\n  call feedkeys(\"ioooooooo\\<c-g>k\\<c-r>.\\<esc>\", 'tnix')\n  call assert_equal(['foooooooooobar', 'foooooooooobar', 'foobar'], getline(1, '$'))\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call feedkeys(\"i\\<c-g>k\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 10, 0], getpos('.'))\n  call cursor(2, 4)\n  call feedkeys(\"i\\<c-g>jzzzz\\<esc>\", 'tnix')\n  call assert_equal(['foooooooooobar', 'foooooooooobar', 'foozzzzbar'], getline(1, '$'))\n  call assert_equal([0, 3, 7, 0], getpos('.'))\n  call feedkeys(\"i\\<c-g>j\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 6, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_I()\n  \" Tab in completion mode\n  let path=expand(\"%:p:h\")\n  new\n  call setline(1, [path. \"/\", ''])\n  call feedkeys(\"Arunt\\<c-x>\\<c-f>\\<tab>\\<cr>\\<esc>\", 'tnix')\n  call assert_match('runtest\\.vim', getline(1))\n  %d\n  call writefile(['one', 'two', 'three'], 'Xinclude.txt')\n  let include='#include Xinclude.txt'\n  call setline(1, [include, ''])\n  call cursor(2, 1)\n  call feedkeys(\"A\\<c-x>\\<tab>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'one', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'two', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'three', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, '', ''], getline(1, '$'))\n  call delete(\"Xinclude.txt\")\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_K()\n  \" Test pressing CTRL-K (basically only dictionary completion and digraphs\n  \" the rest is already covered\n  call writefile(['A', 'AA', 'AAA', 'AAAA'], 'Xdictionary.txt')\n  set dictionary=Xdictionary.txt\n  new\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA', ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AAA'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AAAA'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['A'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA'], getline(1, '$'))\n\n  \" press an unexpected key after dictionary completion\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-]>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA', ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"AA\\<c-s>\", ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-f>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"AA\\<c-f>\", ''], getline(1, '$'))\n\n  set dictionary=\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  let v:testing = 1\n  try\n    call feedkeys(\"A\\<c-x>\\<c-k>\\<esc>\", 'tnix')\n  catch\n    \" error sleeps 2 seconds, when v:testing is not set\n    let v:testing = 0\n  endtry\n  call delete('Xdictionary.txt')\n\n  call test_override(\"char_avail\", 1)\n  set showcmd\n  %d\n  call feedkeys(\"A\\<c-k>a:\\<esc>\", 'tnix')\n  call assert_equal(['\u00e4'], getline(1, '$'))\n  call test_override(\"char_avail\", 0)\n  set noshowcmd\n\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_L()\n  \" Test Ctrl-X Ctrl-L (line completion)\n  new\n  set complete=.\n  call setline(1, ['one', 'two', 'three', '', '', '', ''])\n  call cursor(4, 1)\n  call feedkeys(\"A\\<c-x>\\<c-l>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<c-p>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  set complete=\n  call cursor(5, 1)\n  call feedkeys(\"A\\<c-x>\\<c-l>\\<c-p>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', \"\\<c-l>\\<c-p>\\<c-n>\", '', ''], getline(1, '$'))\n  set complete&\n  %d\n  if has(\"conceal\") && has(\"syntax\")\n    call setline(1, ['foo', 'bar', 'foobar'])\n    call test_override(\"char_avail\", 1)\n    set conceallevel=2 concealcursor=n\n    syn on\n    syn match ErrorMsg \"^bar\"\n    call matchadd(\"Conceal\", 'oo', 10, -1, {'conceal': 'X'})\n    func! DoIt()\n      let g:change=1\n    endfunc\n    au! TextChangedI <buffer> :call DoIt()\n\n    call cursor(2, 1)\n    call assert_false(exists(\"g:change\"))\n    call feedkeys(\"A \\<esc>\", 'tnix')\n    call assert_equal(['foo', 'bar ', 'foobar'], getline(1, '$'))\n    call assert_equal(1, g:change)\n\n    call test_override(\"char_avail\", 0)\n    call clearmatches()\n    syn off\n    au! TextChangedI\n    delfu DoIt\n    unlet! g:change\n  endif\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_N()\n  \" Check keyword completion\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n    new\n    set complete=.\n    call setline(1, ['INFER', 'loWER', '', '', ])\n    call cursor(3, 1)\n    call feedkeys(\"Ai\\<c-n>\\<cr>\\<esc>\", \"tnix\")\n    call feedkeys(\"ILO\\<c-n>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['INFER', 'loWER', 'i', 'LO', '', ''], getline(1, '$'), e)\n    %d\n    call setline(1, ['INFER', 'loWER', '', '', ])\n    call cursor(3, 1)\n    set ignorecase infercase\n    call feedkeys(\"Ii\\<c-n>\\<cr>\\<esc>\", \"tnix\")\n    call feedkeys(\"ILO\\<c-n>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['INFER', 'loWER', 'infer', 'LOWER', '', ''], getline(1, '$'), e)\n    set noignorecase noinfercase\n    %d\n    call setline(1, ['one word', 'two word'])\n    exe \"normal! Goo\\<C-P>\\<C-X>\\<C-P>\"\n    call assert_equal('one word', getline(3))\n    %d\n    set complete&\n    bw!\n  endfor\nendfunc\n\nfunc Test_edit_CTRL_O()\n  \" Check for CTRL-O in insert mode\n  new\n  inoreabbr <buffer> h here some more\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  \" Ctrl-O after an abbreviation\n  exe \"norm A h\\<c-o>:set nu\\<cr> text\"\n  call assert_equal(['abc here some more text', 'def'], getline(1, '$'))\n  call assert_true(&nu)\n  set nonu\n  iunabbr <buffer> h\n  \" Ctrl-O at end of line with 've'=onemore\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-o>:let g:a=getpos('.')\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 23, 0], g:a)\n  call cursor(1, 1)\n  set ve=onemore\n  call feedkeys(\"A\\<c-o>:let g:a=getpos('.')\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 24, 0], g:a)\n  set ve=\n  unlet! g:a\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_R()\n  \" Insert Register\n  new\n  call test_override(\"ALL\", 1)\n  set showcmd\n  call feedkeys(\"AFOOBAR eins zwei\\<esc>\", 'tnix')\n  call feedkeys(\"O\\<c-r>.\", 'tnix')\n  call feedkeys(\"O\\<c-r>=10*500\\<cr>\\<esc>\", 'tnix')\n  call feedkeys(\"O\\<c-r>=getreg('=', 1)\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"getreg('=', 1)\", '5000', \"FOOBAR eins zwei\", \"FOOBAR eins zwei\"], getline(1, '$'))\n  call test_override(\"ALL\", 0)\n  set noshowcmd\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_S()\n  \" Test pressing CTRL-S (basically only spellfile completion)\n  \" the rest is already covered\n  new\n  if !has(\"spell\")\n    call setline(1, 'vim')\n    call feedkeys(\"A\\<c-x>ss\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['vims', ''], getline(1, '$'))\n    bw!\n    return\n  endif\n  call setline(1, 'vim')\n  \" spell option not yet set\n  try\n    call feedkeys(\"A\\<c-x>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E756/\n    call assert_true(1, 'error caught')\n  endtry\n  call assert_equal(['vim', ''], getline(1, '$'))\n  %d\n  setl spell spelllang=en\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Vim', ''], getline(1, '$'))\n  %d\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Aim'], getline(1, '$'))\n  %d\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['vim', ''], getline(1, '$'))\n  %d\n  \" empty buffer\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['', ''], getline(1, '$'))\n  setl nospell\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_T()\n  \" Check for CTRL-T and CTRL-X CTRL-T in insert mode\n  \" 1) increase indent\n  new\n  call setline(1, \"abc\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-t>xyz\", 'tnix')\n  call assert_equal([\"\\<tab>abcxyz\"], getline(1, '$'))\n  \" 2) also when paste option is set\n  set paste\n  call setline(1, \"abc\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-t>xyz\", 'tnix')\n  call assert_equal([\"\\<tab>abcxyz\"], getline(1, '$'))\n  set nopaste\n  \" CTRL-X CTRL-T (thesaurus complete)\n  call writefile(['angry furious mad enraged'], 'Xthesaurus')\n  set thesaurus=Xthesaurus\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['angry', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['furious', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['enraged', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  \" Using <c-p> <c-n> when 'complete' is empty\n  set complete=\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['angry', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  set complete&\n\n  set thesaurus=\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  let v:testing = 1\n  try\n    call feedkeys(\"A\\<c-x>\\<c-t>\\<esc>\", 'tnix')\n  catch\n    \" error sleeps 2 seconds, when v:testing is not set\n    let v:testing = 0\n  endtry\n  call assert_equal(['mad'], getline(1, '$'))\n  call delete('Xthesaurus')\n  bw!\nendfunc\n\n\" Test thesaurus completion with different encodings\nfunc Test_thesaurus_complete_with_encoding()\n  call writefile(['angry furious mad enraged'], 'Xthesaurus')\n  set thesaurus=Xthesaurus\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n    new\n    call setline(1, 'mad')\n    call cursor(1, 1)\n    call feedkeys(\"A\\<c-x>\\<c-t>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['mad', ''], getline(1, '$'))\n    bw!\n  endfor\n  set thesaurus=\n  call delete('Xthesaurus')\nendfunc\n\n\" Test 'thesaurusfunc'\nfunc MyThesaurus(findstart, base)\n  let mythesaurus = [\n        \\ #{word: \"happy\",\n        \\   synonyms: \"cheerful,blissful,flying high,looking good,peppy\"},\n        \\ #{word: \"kind\",\n        \\   synonyms: \"amiable,bleeding-heart,heart in right place\"}]\n  if a:findstart\n    \" locate the start of the word\n    let line = getline('.')\n    let start = col('.') - 1\n    while start > 0 && line[start - 1] =~ '\\a'\n      let start -= 1\n    endwhile\n    return start\n  else\n    \" find strings matching with \"a:base\"\n    let res = []\n    for w in mythesaurus\n      if w.word =~ '^' . a:base\n        call add(res, w.word)\n        call extend(res, split(w.synonyms, \",\"))\n      endif\n    endfor\n    return res\n  endif\nendfunc\n\nfunc Test_thesaurus_func()\n  new\n  set thesaurus=notused\n  set thesaurusfunc=NotUsed\n  setlocal thesaurusfunc=MyThesaurus\n  call setline(1, \"an ki\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['an amiable', ''], getline(1, '$'))\n\n  setlocal thesaurusfunc=NonExistingFunc\n  call assert_fails(\"normal $a\\<C-X>\\<C-T>\", 'E117:')\n\n  setlocal thesaurusfunc=\n  set thesaurusfunc=NonExistingFunc\n  call assert_fails(\"normal $a\\<C-X>\\<C-T>\", 'E117:')\n  %bw!\n\n  set thesaurusfunc=\n  set thesaurus=\nendfunc\n\nfunc Test_edit_CTRL_U()\n  \" Test 'completefunc'\n  new\n  \" -1, -2 and -3 are special return values\n  let g:special=0\n  fun! CompleteMonths(findstart, base)\n    if a:findstart\n      \" locate the start of the word\n      return g:special\n    else\n      \" find months matching with \"a:base\"\n      let res = []\n      for m in split(\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\")\n        if m =~ '^\\c'.a:base\n          call add(res, {'word': m, 'abbr': m.' Month', 'icase': 0})\n        endif\n      endfor\n      return {'words': res, 'refresh': 'always'}\n    endif\n  endfun\n  set completefunc=CompleteMonths\n  call setline(1, ['', ''])\n  call cursor(1, 1)\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', '', ''], getline(1, '$'))\n  %d\n  let g:special=-1\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['XJan', ''], getline(1, '$'))\n  %d\n  let g:special=-2\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', ''], getline(1, '$'))\n  %d\n  let g:special=-3\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', ''], getline(1, '$'))\n  %d\n  let g:special=0\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Mar', ''], getline(1, '$'))\n  %d\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['May', ''], getline(1, '$'))\n  %d\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['M', ''], getline(1, '$'))\n  delfu CompleteMonths\n  %d\n  try\n    call feedkeys(\"A\\<c-x>\\<c-u>\", 'tnix')\n    call assert_fails(1, 'unknown completion function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E117/\n    call assert_true(1, 'E117 error caught')\n  endtry\n  set completefunc=\n  bw!\nendfunc\n\nfunc Test_edit_completefunc_delete()\n  func CompleteFunc(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    normal dd\n    return ['a', 'b']\n  endfunc\n  new\n  set completefunc=CompleteFunc\n  call setline(1, ['', 'abcd', ''])\n  2d\n  call assert_fails(\"normal 2G$a\\<C-X>\\<C-U>\", 'E578:')\n  bwipe!\nendfunc\n\n\nfunc Test_edit_CTRL_Z()\n  \" Ctrl-Z when insertmode is not set inserts it literally\n  new\n  call setline(1, 'abc')\n  call feedkeys(\"A\\<c-z>\\<esc>\", 'tnix')\n  call assert_equal([\"abc\\<c-z>\"], getline(1,'$'))\n  bw!\n  \" TODO: How to Test Ctrl-Z in insert mode, e.g. suspend?\nendfunc\n\nfunc Test_edit_DROP()\n  CheckFeature dnd\n  new\n  call setline(1, ['abc def ghi'])\n  call cursor(1, 1)\n  try\n    call feedkeys(\"i\\<Drop>\\<Esc>\", 'tnix')\n    call assert_fails(1, 'Invalid register name')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E353/\n    call assert_true(1, 'error caught')\n  endtry\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_V()\n  CheckFeature ebcdic\n  new\n  call setline(1, ['abc'])\n  call cursor(2, 1)\n  \" force some redraws\n  set showmode showcmd\n  \"call test_override_char_avail(1)\n  call test_override('ALL', 1)\n  call feedkeys(\"A\\<c-v>\\<c-n>\\<c-v>\\<c-l>\\<c-v>\\<c-b>\\<esc>\", 'tnix')\n  call assert_equal([\"abc\\x0e\\x0c\\x02\"], getline(1, '$'))\n\n  if has(\"rightleft\") && exists(\"+rl\")\n    set rl\n    call setline(1, ['abc'])\n    call cursor(2, 1)\n    call feedkeys(\"A\\<c-v>\\<c-n>\\<c-v>\\<c-l>\\<c-v>\\<c-b>\\<esc>\", 'tnix')\n    call assert_equal([\"abc\\x0e\\x0c\\x02\"], getline(1, '$'))\n    set norl\n  endif\n\n  call test_override('ALL', 0)\n  set noshowmode showcmd\n  bw!\nendfunc\n\nfunc Test_edit_F1()\n  CheckFeature quickfix\n\n  \" Pressing <f1>\n  new\n  call feedkeys(\":set im\\<cr>\\<f1>\\<c-l>\", 'tnix')\n  set noinsertmode\n  call assert_equal('help', &buftype)\n  bw\n  bw\nendfunc\n\nfunc Test_edit_F21()\n  \" Pressing <f21>\n  \" sends a netbeans command\n  CheckFeature netbeans_intg\n  new\n  \" I have no idea what this is supposed to do :)\n  call feedkeys(\"A\\<F21>\\<F1>\\<esc>\", 'tnix')\n  bw\nendfunc\n\nfunc Test_edit_HOME_END()\n  \" Test Home/End Keys\n  new\n  set foldopen+=hor\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"AX\\<Home>Y\\<esc>\", 'tnix')\n  call cursor(2, 1)\n  call feedkeys(\"iZ\\<End>Y\\<esc>\", 'tnix')\n  call assert_equal(['YabcX', 'ZdefY'], getline(1, '$'))\n\n  set foldopen-=hor\n  bw!\nendfunc\n\nfunc Test_edit_INS()\n  \" Test for Pressing <Insert>\n  new\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<Insert>ZYX>\", 'tnix')\n  call assert_equal(['ZYX>', 'def'], getline(1, '$'))\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<Insert>Z\\<Insert>YX>\", 'tnix')\n  call assert_equal(['ZYX>bc', 'def'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_LEFT_RIGHT()\n  \" Left, Shift-Left, Right, Shift-Right\n  new\n  call setline(1, ['abc def ghi', 'ABC DEF GHI', 'ZZZ YYY XXX'])\n  let _ww=&ww\n  set ww=\n  call cursor(2, 1)\n  call feedkeys(\"i\\<left>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  \" Is this a bug, <s-left> does not respect whichwrap option\n  call feedkeys(\"i\\<s-left>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 8, 0], getpos('.'))\n  call feedkeys(\"i\". repeat(\"\\<s-left>\", 3). \"\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<right>\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 2, 0], getpos('.'))\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 4, 0], getpos('.'))\n  call cursor(3, 11)\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 11, 0], getpos('.'))\n  call cursor(2, 11)\n  \" <S-Right> does not respect 'whichwrap' option\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  \" Check motion when 'whichwrap' contains cursor keys for insert mode\n  set ww+=[,]\n  call cursor(2, 1)\n  call feedkeys(\"i\\<left>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call cursor(2, 11)\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  call cursor(2, 11)\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  let &ww = _ww\n  bw!\nendfunc\n\nfunc Test_edit_MOUSE()\n  \" This is a simple test, since we not really using the mouse here\n  CheckFeature mouse\n  10new\n  call setline(1, range(1, 100))\n  call cursor(1, 1)\n  set mouse=a\n  call feedkeys(\"A\\<ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 4, 1, 0], getpos('.'))\n  \" This should move by one pageDown, but only moves\n  \" by one line when the test is run...\n  call feedkeys(\"A\\<S-ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  set nostartofline\n  call feedkeys(\"A\\<C-ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<LeftMouse>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<RightMouse>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call cursor(1, 100)\n  norm! zt\n  \" this should move by a screen up, but when the test\n  \" is run, it moves up to the top of the buffer...\n  call feedkeys(\"A\\<ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call cursor(1, 30)\n  norm! zt\n  call feedkeys(\"A\\<S-ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call cursor(1, 30)\n  norm! zt\n  call feedkeys(\"A\\<C-ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  %d\n  call setline(1, repeat([\"12345678901234567890\"], 100))\n  call cursor(2, 1)\n  call feedkeys(\"A\\<ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<S-ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<S-ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<C-ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<C-ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  set mouse& startofline\n  bw!\nendfunc\n\nfunc Test_edit_PAGEUP_PAGEDOWN()\n  10new\n  call setline(1, repeat(['abc def ghi'], 30))\n  call cursor(1, 1)\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  \" <S-Up> is the same as <PageUp>\n  \" <S-Down> is the same as <PageDown>\n  call cursor(1, 1)\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  set nostartofline\n  call cursor(30, 11)\n  norm! zt\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call cursor(1, 1)\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  \" <S-Up> is the same as <PageUp>\n  \" <S-Down> is the same as <PageDown>\n  call cursor(30, 11)\n  norm! zt\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call cursor(1, 1)\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_forbidden()\n  new\n  \" 1) edit in the sandbox is not allowed\n  call setline(1, 'a')\n  com! Sandbox :sandbox call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_fails(':Sandbox', 'E48:')\n  com! Sandbox :sandbox exe \"norm! i\\<del>\"\n  call assert_fails(':Sandbox', 'E48:')\n  delcom Sandbox\n  call assert_equal(['a'], getline(1,'$'))\n\n  \" 2) edit with textlock set\n  fu! DoIt()\n    call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  endfu\n  au InsertCharPre <buffer> :call DoIt()\n  try\n    call feedkeys(\"ix\\<esc>\", 'tnix')\n    call assert_fails(1, 'textlock')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565: not allowed here\n  endtry\n  \" TODO: Might be a bug: should x really be inserted here\n  call assert_equal(['xa'], getline(1, '$'))\n  delfu DoIt\n  try\n    call feedkeys(\"ix\\<esc>\", 'tnix')\n    call assert_fails(1, 'unknown function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E117/ \" catch E117: unknown function\n  endtry\n  au! InsertCharPre\n\n  \" 3) edit when completion is shown\n  fun! Complete(findstart, base)\n    if a:findstart\n      return col('.')\n    else\n      call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n      return []\n    endif\n  endfun\n  set completefunc=Complete\n  try\n    call feedkeys(\"i\\<c-x>\\<c-u>\\<esc>\", 'tnix')\n    call assert_fails(1, 'change in complete function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565\n  endtry\n  delfu Complete\n  set completefunc=\n\n  if has(\"rightleft\") && exists(\"+fkmap\")\n    \" 4) 'R' when 'fkmap' and 'revins' is set.\n    set revins fkmap\n    try\n      normal Ri\n      call assert_fails(1, \"R with 'fkmap' and 'ri' set\")\n    catch\n    finally\n      set norevins nofkmap\n    endtry\n  endif\n  bw!\nendfunc\n\nfunc Test_edit_rightleft()\n  \" Cursor in rightleft mode moves differently\n  CheckFeature rightleft\n  call NewWindow(10, 20)\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 2)\n  set rightleft\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                 cba\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  \" 2) right moves to the left\n  call feedkeys(\"i\\<right>\\<esc>x\", 'txin')\n  call assert_equal(['bc', 'def', 'ghi'], getline(1,'$'))\n  call cursor(1, 2)\n  call feedkeys(\"i\\<s-right>\\<esc>\", 'txin')\n  call cursor(1, 2)\n  call feedkeys(\"i\\<c-right>\\<esc>\", 'txin')\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                  cb\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  \" 2) left moves to the right\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 2)\n  call feedkeys(\"i\\<left>\\<esc>x\", 'txin')\n  call assert_equal(['ac', 'def', 'ghi'], getline(1,'$'))\n  call cursor(1, 2)\n  call feedkeys(\"i\\<s-left>\\<esc>\", 'txin')\n  call cursor(1, 2)\n  call feedkeys(\"i\\<c-left>\\<esc>\", 'txin')\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                  ca\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  %d _\n  call test_override('redraw_flag', 1)\n  call test_override('char_avail', 1)\n  call feedkeys(\"a\\<C-V>x41\", \"xt\")\n  redraw!\n  call assert_equal(repeat(' ', 19) .. 'A', Screenline(1))\n  call test_override('ALL', 0)\n  set norightleft\n  bw!\nendfunc\n\nfunc Test_edit_complete_very_long_name()\n  \" Long directory names only work on Unix.\n  CheckUnix\n\n  let dirname = getcwd() . \"/Xdir\"\n  let longdirname = dirname . repeat('/' . repeat('d', 255), 4)\n  try\n    call mkdir(longdirname, 'p')\n  catch /E739:/\n    \" Long directory name probably not supported.\n    call delete(dirname, 'rf')\n    return\n  endtry\n\n  \" Try to get the Vim window position before setting 'columns', so that we can\n  \" move the window back to where it was.\n  let winposx = getwinposx()\n  let winposy = getwinposy()\n\n  if winposx >= 0 && winposy >= 0 && !has('gui_running')\n    \" We did get the window position, but xterm may report the wrong numbers.\n    \" Move the window to the reported position and compute any offset.\n    exe 'winpos ' . winposx . ' ' . winposy\n    sleep 100m\n    let x = getwinposx()\n    if x >= 0\n      let winposx += winposx - x\n    endif\n    let y = getwinposy()\n    if y >= 0\n      let winposy += winposy - y\n    endif\n  endif\n\n  let save_columns = &columns\n  \" Need at least about 1100 columns to reproduce the problem.\n  set columns=2000\n  set noswapfile\n\n  let longfilename = longdirname . '/' . repeat('a', 255)\n  call writefile(['Totum', 'Table'], longfilename)\n  new\n  exe \"next Xfile \" . longfilename\n  exe \"normal iT\\<C-N>\"\n\n  bwipe!\n  exe 'bwipe! ' . longfilename\n  call delete(dirname, 'rf')\n  let &columns = save_columns\n  if winposx >= 0 && winposy >= 0\n    exe 'winpos ' . winposx . ' ' . winposy\n  endif\n  set swapfile&\nendfunc\n\nfunc Test_edit_backtick()\n  next a\\`b c\n  call assert_equal('a`b', expand('%'))\n  next\n  call assert_equal('c', expand('%'))\n  call assert_equal('a\\`b c', expand('##'))\nendfunc\n\nfunc Test_edit_quit()\n  edit foo.txt\n  split\n  new\n  call setline(1, 'hello')\n  3wincmd w\n  redraw!\n  call assert_fails('1q', 'E37:')\n  bwipe! foo.txt\n  only\nendfunc\n\nfunc Test_edit_alt()\n  \" Keeping the cursor line didn't happen when the first line has indent.\n  new\n  call setline(1, ['  one', 'two', 'three'])\n  w XAltFile\n  $\n  call assert_equal(3, line('.'))\n  e Xother\n  e #\n  call assert_equal(3, line('.'))\n\n  bwipe XAltFile\n  call delete('XAltFile')\nendfunc\n\nfunc Test_edit_InsertLeave()\n  new\n  au InsertLeavePre * let g:did_au_pre = 1\n  au InsertLeave * let g:did_au = 1\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"afoo\\<Esc>\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(1, g:did_au)\n  call assert_equal('foo', getline(1))\n\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Sbar\\<C-C>\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(0, g:did_au)\n  call assert_equal('bar', getline(1))\n\n  inoremap x xx<Esc>\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Saax\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(1, g:did_au)\n  call assert_equal('aaxx', getline(1))\n\n  inoremap x xx<C-C>\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Sbbx\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(0, g:did_au)\n  call assert_equal('bbxx', getline(1))\n\n  bwipe!\n  au! InsertLeave InsertLeavePre\n  iunmap x\nendfunc\n\nfunc Test_edit_InsertLeave_undo()\n  new XtestUndo\n  set undofile\n  au InsertLeave * wall\n  exe \"normal ofoo\\<Esc>\"\n  call assert_equal(2, line('$'))\n  normal u\n  call assert_equal(1, line('$'))\n\n  bwipe!\n  au! InsertLeave\n  call delete('XtestUndo')\n  call delete(undofile('XtestUndo'))\n  set undofile&\nendfunc\n\n\" Test for inserting characters using CTRL-V followed by a number.\nfunc Test_edit_special_chars()\n  new\n\n  if has(\"ebcdic\")\n    let t = \"o\\<C-V>193\\<C-V>xc2\\<C-V>o303 \\<C-V>90a\\<C-V>xfg\\<C-V>o578\\<Esc>\"\n  else\n    let t = \"o\\<C-V>65\\<C-V>x42\\<C-V>o103 \\<C-V>33a\\<C-V>xfg\\<C-V>o78\\<Esc>\"\n  endif\n\n  exe \"normal \" . t\n  call assert_equal(\"ABC !a\\<C-O>g\\<C-G>8\", getline(2))\n\n  close!\nendfunc\n\nfunc Test_edit_startinsert()\n  new\n  set backspace+=start\n  call setline(1, 'foobar')\n  call feedkeys(\"A\\<C-U>\\<Esc>\", 'xt')\n  call assert_equal('', getline(1))\n\n  call setline(1, 'foobar')\n  call feedkeys(\":startinsert!\\<CR>\\<C-U>\\<Esc>\", 'xt')\n  call assert_equal('', getline(1))\n\n  set backspace&\n  bwipe!\nendfunc\n\n\" Test for :startreplace and :startgreplace\nfunc Test_edit_startreplace()\n  new\n  call setline(1, 'abc')\n  call feedkeys(\"l:startreplace\\<CR>xyz\\e\", 'xt')\n  call assert_equal('axyz', getline(1))\n  call feedkeys(\"0:startreplace!\\<CR>abc\\e\", 'xt')\n  call assert_equal('axyzabc', getline(1))\n  call setline(1, \"a\\tb\")\n  call feedkeys(\"0l:startgreplace\\<CR>xyz\\e\", 'xt')\n  call assert_equal(\"axyz\\tb\", getline(1))\n  call feedkeys(\"0i\\<C-R>=execute('startreplace')\\<CR>12\\e\", 'xt')\n  call assert_equal(\"12axyz\\tb\", getline(1))\n  close!\nendfunc\n\nfunc Test_edit_noesckeys()\n  CheckNotGui\n  new\n\n  \" <Left> moves cursor when 'esckeys' is set\n  exe \"set t_kl=\\<Esc>OD\"\n  set esckeys\n  call feedkeys(\"axyz\\<Esc>ODX\", \"xt\")\n  call assert_equal(\"xyXz\", getline(1))\n\n  \" <Left> exits Insert mode when 'esckeys' is off\n  set noesckeys\n  call setline(1, '')\n  call feedkeys(\"axyz\\<Esc>ODX\", \"xt\")\n  call assert_equal([\"DX\", \"xyz\"], getline(1, 2))\n\n  bwipe!\n  set esckeys\nendfunc\n\n\" Test for running an invalid ex command in insert mode using CTRL-O\nfunc Test_edit_ctrl_o_invalid_cmd()\n  new\n  set showmode showcmd\n  \" Avoid a sleep of 3 seconds. Zero might have side effects.\n  call test_override('ui_delay', 50)\n  let caught_e492 = 0\n  try\n    call feedkeys(\"i\\<C-O>:invalid\\<CR>abc\\<Esc>\", \"xt\")\n  catch /E492:/\n    let caught_e492 = 1\n  endtry\n  call assert_equal(1, caught_e492)\n  call assert_equal('abc', getline(1))\n  set showmode& showcmd&\n  call test_override('ui_delay', 0)\n  close!\nendfunc\n\n\" Test for editing a file with a very long name\nfunc Test_edit_illegal_filename()\n  CheckEnglish\n  new\n  redir => msg\n  exe 'edit ' . repeat('f', 5000)\n  redir END\n  call assert_match(\"Illegal file name$\", split(msg, \"\\n\")[0])\n  close!\nendfunc\n\n\" Test for editing a directory\nfunc Test_edit_is_a_directory()\n  CheckEnglish\n  let dirname = getcwd() . \"/Xdir\"\n  call mkdir(dirname, 'p')\n\n  new\n  redir => msg\n  exe 'edit' dirname\n  redir END\n  call assert_match(\"is a directory$\", split(msg, \"\\n\")[0])\n  bwipe!\n\n  let dirname .= '/'\n\n  new\n  redir => msg\n  exe 'edit' dirname\n  redir END\n  call assert_match(\"is a directory$\", split(msg, \"\\n\")[0])\n  bwipe!\n\n  call delete(dirname, 'rf')\nendfunc\n\n\" Test for editing a file using invalid file encoding\nfunc Test_edit_invalid_encoding()\n  CheckEnglish\n  call writefile([], 'Xfile')\n  redir => msg\n  new ++enc=axbyc Xfile\n  redir END\n  call assert_match('\\[NOT converted\\]', msg)\n  call delete('Xfile')\n  close!\nendfunc\n\n\" Test for the \"charconvert\" option\nfunc Test_edit_charconvert()\n  CheckEnglish\n  call writefile(['one', 'two'], 'Xfile')\n\n  \" set 'charconvert' to a non-existing function\n  set charconvert=NonExitingFunc()\n  new\n  let caught_e117 = v:false\n  try\n    redir => msg\n    edit ++enc=axbyc Xfile\n  catch /E117:/\n    let caught_e117 = v:true\n  finally\n    redir END\n  endtry\n  call assert_true(caught_e117)\n  call assert_equal(['one', 'two'], getline(1, '$'))\n  call assert_match(\"Conversion with 'charconvert' failed\", msg)\n  close!\n  set charconvert&\n\n  \" 'charconvert' function doesn't create a output file\n  func Cconv1()\n  endfunc\n  set charconvert=Cconv1()\n  new\n  redir => msg\n  edit ++enc=axbyc Xfile\n  redir END\n  call assert_equal(['one', 'two'], getline(1, '$'))\n  call assert_match(\"can't read output of 'charconvert'\", msg)\n  close!\n  delfunc Cconv1\n  set charconvert&\n\n  \" 'charconvert' function to convert to upper case\n  func Cconv2()\n    let data = readfile(v:fname_in)\n    call map(data, 'toupper(v:val)')\n    call writefile(data, v:fname_out)\n  endfunc\n  set charconvert=Cconv2()\n  new Xfile\n  write ++enc=ucase Xfile1\n  call assert_equal(['ONE', 'TWO'], readfile('Xfile1'))\n  call delete('Xfile1')\n  close!\n  delfunc Cconv2\n  set charconvert&\n\n  \" 'charconvert' function removes the input file\n  func Cconv3()\n    call delete(v:fname_in)\n  endfunc\n  set charconvert=Cconv3()\n  new\n  call assert_fails('edit ++enc=lcase Xfile', 'E202:')\n  call assert_equal([''], getline(1, '$'))\n  close!\n  delfunc Cconv3\n  set charconvert&\n\n  call delete('Xfile')\nendfunc\n\n\" Test for editing a file without read permission\nfunc Test_edit_file_no_read_perm()\n  CheckUnix\n  CheckNotRoot\n\n  call writefile(['one', 'two'], 'Xfile')\n  call setfperm('Xfile', '-w-------')\n  new\n  redir => msg\n  edit Xfile\n  redir END\n  call assert_equal(1, &readonly)\n  call assert_equal([''], getline(1, '$'))\n  call assert_match('\\[Permission Denied\\]', msg)\n  close!\n  call delete('Xfile')\nendfunc\n\n\" Pressing escape in 'insertmode' should beep\nfunc Test_edit_insertmode_esc_beeps()\n  new\n  set insertmode\n  call assert_beeps(\"call feedkeys(\\\"one\\<Esc>\\\", 'xt')\")\n  set insertmode&\n  \" unsupported CTRL-G command should beep in insert mode.\n  call assert_beeps(\"normal i\\<C-G>l\")\n  close!\nendfunc\n\n\" Test for 'hkmap' and 'hkmapp'\nfunc Test_edit_hkmap()\n  CheckFeature rightleft\n  if has('win32') && !has('gui')\n    throw 'Skipped: fails on the MS-Windows terminal version'\n  endif\n  new\n\n  set revins hkmap\n  let str = 'abcdefghijklmnopqrstuvwxyz'\n  let str ..= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let str ..= '`/'',.;'\n  call feedkeys('i' .. str, 'xt')\n  let expected = \"\u00f3\u00f5\u00fa,.;\"\n  let expected ..= \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n  let expected ..= \"\u00e6\u00e8\u00f1'\u00e4\u00e5\u00e0\u00e3\u00f8/\u00f4\u00ed\u00ee\u00f6\u00ea\u00ec\u00e7\u00ef\u00e9\u00f2\u00eb\u00f7\u00e2\u00e1\u00f0\u00f9\"\n  call assert_equal(expected, getline(1))\n\n  %d\n  set revins hkmap hkmapp\n  let str = 'abcdefghijklmnopqrstuvwxyz'\n  let str ..= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  call feedkeys('i' .. str, 'xt')\n  let expected = \"\u00f5YXWVUTSRQ\u00f3O\u00ef\u00edLKJIHGFED\u00eaBA\"\n  let expected ..= \"\u00f6\u00f2X\u00f9\u00e5\u00e8\u00fa\u00e6\u00f8'\u00f4\u00f1\u00f0\u00ee\u00ec\u00f7\u00e7\u00e9\u00e4\u00e2\u00f3\u01df\u00e3\u00eb\u00e1\u00e0\"\n  call assert_equal(expected, getline(1))\n\n  set revins& hkmap& hkmapp&\n  close!\nendfunc\n\n\" Test for 'allowrevins' and using CTRL-_ in insert mode\nfunc Test_edit_allowrevins()\n  CheckFeature rightleft\n  new\n  set allowrevins\n  call feedkeys(\"iABC\\<C-_>DEF\\<C-_>GHI\", 'xt')\n  call assert_equal('ABCFEDGHI', getline(1))\n  set allowrevins&\n  close!\nendfunc\n\n\" Test for inserting a register in insert mode using CTRL-R\nfunc Test_edit_insert_reg()\n  new\n  let g:Line = ''\n  func SaveFirstLine()\n    let g:Line = Screenline(1)\n    return 'r'\n  endfunc\n  inoremap <expr> <buffer> <F2> SaveFirstLine()\n  call test_override('redraw_flag', 1)\n  call test_override('char_avail', 1)\n  let @r = 'sample'\n  call feedkeys(\"a\\<C-R>=SaveFirstLine()\\<CR>\", \"xt\")\n  call assert_equal('\"', g:Line)\n  call test_override('ALL', 0)\n  close!\nendfunc\n\n\" When a character is inserted at the last position of the last line in a\n\" window, the window contents should be scrolled one line up. If the top line\n\" is part of a fold, then the entire fold should be scrolled up.\nfunc Test_edit_lastline_scroll()\n  new\n  let h = winheight(0)\n  let lines = ['one', 'two', 'three']\n  let lines += repeat(['vim'], h - 4)\n  call setline(1, lines)\n  call setline(h, repeat('x', winwidth(0) - 1))\n  call feedkeys(\"GAx\", 'xt')\n  redraw!\n  call assert_equal(h - 1, winline())\n  call assert_equal(2, line('w0'))\n\n  \" scroll with a fold\n  1,2fold\n  normal gg\n  call setline(h + 1, repeat('x', winwidth(0) - 1))\n  call feedkeys(\"GAx\", 'xt')\n  redraw!\n  call assert_equal(h - 1, winline())\n  call assert_equal(3, line('w0'))\n\n  close!\nendfunc\n\nfunc Test_edit_browse()\n  \" in the GUI this opens a file picker, we only test the terminal behavior\n  CheckNotGui\n\n  \" \":browse xxx\" checks for the FileExplorer augroup and assumes editing \".\"\n  \" works then.\n  augroup FileExplorer\n    au!\n  augroup END\n\n  \" When the USE_FNAME_CASE is defined this used to cause a crash.\n  browse enew\n  bwipe!\n\n  browse split\n  bwipe!\nendfunc\n\nfunc Test_read_invalid()\n  set encoding=latin1\n  \" This was not properly checking for going past the end.\n  call assert_fails('r`=', 'E484')\n  set encoding=utf-8\nendfunc\n\n\" Test for the 'revins' option\nfunc Test_edit_revins()\n  CheckFeature rightleft\n  new\n  set revins\n  exe \"normal! ione\\ttwo three\"\n  call assert_equal(\"eerht owt\\teno\", getline(1))\n  call setline(1, \"one\\ttwo three\")\n  normal! gg$bi a\n  call assert_equal(\"one\\ttwo a three\", getline(1))\n  exe \"normal! $bi\\<BS>\\<BS>\"\n  call assert_equal(\"one\\ttwo a ree\", getline(1))\n  exe \"normal! 0wi\\<C-W>\"\n  call assert_equal(\"one\\t a ree\", getline(1))\n  exe \"normal! 0wi\\<C-U>\"\n  call assert_equal(\"one\\t \", getline(1))\n  \" newline in insert mode starts at the end of the line\n  call setline(1, 'one two three')\n  exe \"normal! wi\\nfour\"\n  call assert_equal(['one two three', 'ruof'], getline(1, '$'))\n  set revins&\n  bw!\nendfunc\n\n\" Test for getting the character of the line below after \"p\"\nfunc Test_edit_put_CTRL_E()\n  set encoding=latin1\n  new\n  let @\" = ''\n  sil! norm or\u0003ggRx\n  sil! norm pr\u0005\n  call assert_equal(['r', 'r'], getline(1, 2))\n  bwipe!\n  set encoding=utf-8\nendfunc\n\n\" Test for ModeChanged pattern\nfunc Test_mode_changes()\n  let g:index = 0\n  let g:mode_seq = ['n', 'i', 'n', 'v', 'V', 'i', 'ix', 'i', 'ic', 'i', 'n', 'no', 'n', 'V', 'v', 's', 'n']\n  func! TestMode()\n    call assert_equal(g:mode_seq[g:index], get(v:event, \"old_mode\"))\n    call assert_equal(g:mode_seq[g:index + 1], get(v:event, \"new_mode\"))\n    call assert_equal(mode(1), get(v:event, \"new_mode\"))\n    let g:index += 1\n  endfunc\n\n  au ModeChanged * :call TestMode()\n  let g:n_to_any = 0\n  au ModeChanged n:* let g:n_to_any += 1\n  call feedkeys(\"i\\<esc>vVca\\<CR>\\<C-X>\\<C-L>\\<esc>ggdG\", 'tnix')\n\n  let g:V_to_v = 0\n  au ModeChanged V:v let g:V_to_v += 1\n  call feedkeys(\"Vv\\<C-G>\\<esc>\", 'tnix')\n  call assert_equal(len(filter(g:mode_seq[1:], {idx, val -> val == 'n'})), g:n_to_any)\n  call assert_equal(1, g:V_to_v)\n  call assert_equal(len(g:mode_seq) - 1, g:index)\n\n  let g:n_to_i = 0\n  au ModeChanged n:i let g:n_to_i += 1\n  let g:n_to_niI = 0\n  au ModeChanged i:niI let g:n_to_niI += 1\n  let g:niI_to_i = 0\n  au ModeChanged niI:i let g:niI_to_i += 1\n  let g:nany_to_i = 0\n  au ModeChanged n*:i let g:nany_to_i += 1\n  let g:i_to_n = 0\n  au ModeChanged i:n let g:i_to_n += 1\n  let g:nori_to_any = 0\n  au ModeChanged [ni]:* let g:nori_to_any += 1\n  let g:i_to_any = 0\n  au ModeChanged i:* let g:i_to_any += 1\n  let g:index = 0\n  let g:mode_seq = ['n', 'i', 'niI', 'i', 'n']\n  call feedkeys(\"a\\<C-O>l\\<esc>\", 'tnix')\n  call assert_equal(len(g:mode_seq) - 1, g:index)\n  call assert_equal(1, g:n_to_i)\n  call assert_equal(1, g:n_to_niI)\n  call assert_equal(1, g:niI_to_i)\n  call assert_equal(2, g:nany_to_i)\n  call assert_equal(1, g:i_to_n)\n  call assert_equal(2, g:i_to_any)\n  call assert_equal(3, g:nori_to_any)\n\n  if has('terminal')\n    let g:mode_seq += ['c', 'n', 't', 'nt', 'c', 'nt', 'n']\n    call feedkeys(\":term\\<CR>\\<C-W>N:bd!\\<CR>\", 'tnix')\n    call assert_equal(len(g:mode_seq) - 1, g:index)\n    call assert_equal(1, g:n_to_i)\n    call assert_equal(1, g:n_to_niI)\n    call assert_equal(1, g:niI_to_i)\n    call assert_equal(2, g:nany_to_i)\n    call assert_equal(1, g:i_to_n)\n    call assert_equal(2, g:i_to_any)\n    call assert_equal(5, g:nori_to_any)\n  endif\n\n  au! ModeChanged\n  delfunc TestMode\n  unlet! g:mode_seq\n  unlet! g:index\n  unlet! g:n_to_any\n  unlet! g:V_to_v\n  unlet! g:n_to_i\n  unlet! g:n_to_niI\n  unlet! g:niI_to_i\n  unlet! g:nany_to_i\n  unlet! g:i_to_n\n  unlet! g:nori_to_any\n  unlet! g:i_to_any\nendfunc\n\nfunc Test_recursive_ModeChanged()\n  au! ModeChanged * norm 0u\n  sil! norm \u0016\n  au! ModeChanged\nendfunc\n\nfunc Test_ModeChanged_starts_visual()\n  \" This was triggering ModeChanged before setting VIsual, causing a crash.\n  au! ModeChanged * norm 0u\n  sil! norm \u0016\n\n  au! ModeChanged\nendfunc\n\n\" Test toggling of input method. See :help i_CTRL-^\nfunc Test_edit_CTRL_hat()\n  CheckFeature xim\n\n  \" FIXME: test fails with Athena and Motif GUI.\n  \"        test also fails when running in the GUI.\n  CheckFeature gui_gtk\n  CheckNotGui\n\n  new\n\n  call assert_equal(0, &iminsert)\n  call feedkeys(\"i\\<C-^>\", 'xt')\n  call assert_equal(2, &iminsert)\n  call feedkeys(\"i\\<C-^>\", 'xt')\n  call assert_equal(0, &iminsert)\n\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * drawscreen.c: Code for updating all the windows on the screen.\n * This is the top level, drawline.c is the middle and screen.c the lower\n * level.\n *\n * update_screen() is the function that updates all windows and status lines.\n * It is called form the main loop when must_redraw is non-zero.  It may be\n * called from other places when an immediate screen update is needed.\n *\n * The part of the buffer that is displayed in a window is set with:\n * - w_topline (first buffer line in window)\n * - w_topfill (filler lines above the first line)\n * - w_leftcol (leftmost window cell in window),\n * - w_skipcol (skipped window cells of first line)\n *\n * Commands that only move the cursor around in a window, do not need to take\n * action to update the display.  The main loop will check if w_topline is\n * valid and update it (scroll the window) when needed.\n *\n * Commands that scroll a window change w_topline and must call\n * check_cursor() to move the cursor into the visible part of the window, and\n * call redraw_later(VALID) to have the window displayed by update_screen()\n * later.\n *\n * Commands that change text in the buffer must call changed_bytes() or\n * changed_lines() to mark the area that changed and will require updating\n * later.  The main loop will call update_screen(), which will update each\n * window that shows the changed buffer.  This assumes text above the change\n * can remain displayed as it is.  Text after the change may need updating for\n * scrolling, folding and syntax highlighting.\n *\n * Commands that change how a window is displayed (e.g., setting 'list') or\n * invalidate the contents of a window in another way (e.g., change fold\n * settings), must call redraw_later(NOT_VALID) to have the whole window\n * redisplayed by update_screen() later.\n *\n * Commands that change how a buffer is displayed (e.g., setting 'tabstop')\n * must call redraw_curbuf_later(NOT_VALID) to have all the windows for the\n * buffer redisplayed by update_screen() later.\n *\n * Commands that change highlighting and possibly cause a scroll too must call\n * redraw_later(SOME_VALID) to update the whole window but still use scrolling\n * to avoid redrawing everything.  But the length of displayed lines must not\n * change, use NOT_VALID then.\n *\n * Commands that move the window position must call redraw_later(NOT_VALID).\n * TODO: should minimize redrawing by scrolling when possible.\n *\n * Commands that change everything (e.g., resizing the screen) must call\n * redraw_all_later(NOT_VALID) or redraw_all_later(CLEAR).\n *\n * Things that are handled indirectly:\n * - When messages scroll the screen up, msg_scrolled will be set and\n *   update_screen() called to redraw.\n */\n\n#include \"vim.h\"\n\nstatic void win_update(win_T *wp);\n#ifdef FEAT_STL_OPT\nstatic void redraw_custom_statusline(win_T *wp);\n#endif\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)\nstatic int  did_update_one_window;\n#endif\n\nstatic void win_redr_status(win_T *wp, int ignore_pum);\n\n/*\n * Based on the current value of curwin->w_topline, transfer a screenfull\n * of stuff from Filemem to ScreenLines[], and update curwin->w_botline.\n * Return OK when the screen was updated, FAIL if it was not done.\n */\n    int\nupdate_screen(int type_arg)\n{\n    int\t\ttype = type_arg;\n    win_T\t*wp;\n    static int\tdid_intro = FALSE;\n#ifdef FEAT_GUI\n    int\t\tdid_one = FALSE;\n    int\t\tdid_undraw = FALSE;\n    int\t\tgui_cursor_col = 0;\n    int\t\tgui_cursor_row = 0;\n#endif\n    int\t\tno_update = FALSE;\n    int\t\tsave_pum_will_redraw = pum_will_redraw;\n\n    // Don't do anything if the screen structures are (not yet) valid.\n    if (!screen_valid(TRUE))\n\treturn FAIL;\n\n    if (type == VALID_NO_UPDATE)\n    {\n\tno_update = TRUE;\n\ttype = 0;\n    }\n\n#ifdef FEAT_EVAL\n    {\n\tbuf_T *buf;\n\n\t// Before updating the screen, notify any listeners of changed text.\n\tFOR_ALL_BUFFERS(buf)\n\t    invoke_listeners(buf);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // May have postponed updating diffs.\n    if (need_diff_redraw)\n\tdiff_redraw(TRUE);\n#endif\n\n    if (must_redraw)\n    {\n\tif (type < must_redraw)\t    // use maximal type\n\t    type = must_redraw;\n\n\t// must_redraw is reset here, so that when we run into some weird\n\t// reason to redraw while busy redrawing (e.g., asynchronous\n\t// scrolling), or update_topline() in win_update() will cause a\n\t// scroll, the screen will be redrawn later or in win_update().\n\tmust_redraw = 0;\n    }\n\n    // May need to update w_lines[].\n    if (curwin->w_lines_valid == 0 && type < NOT_VALID\n#ifdef FEAT_TERMINAL\n\t    && !term_do_update_window(curwin)\n#endif\n\t\t)\n\ttype = NOT_VALID;\n\n    // Postpone the redrawing when it's not needed and when being called\n    // recursively.\n    if (!redrawing() || updating_screen)\n    {\n\tredraw_later(type);\t\t// remember type for next time\n\tmust_redraw = type;\n\tif (type > INVERTED_ALL)\n\t    curwin->w_lines_valid = 0;\t// don't use w_lines[].wl_size now\n\treturn FAIL;\n    }\n    updating_screen = TRUE;\n\n#ifdef FEAT_PROP_POPUP\n    // Update popup_mask if needed.  This may set w_redraw_top and w_redraw_bot\n    // in some windows.\n    may_update_popup_mask(type);\n#endif\n\n#ifdef FEAT_SYN_HL\n    ++display_tick;\t    // let syntax code know we're in a next round of\n\t\t\t    // display updating\n#endif\n    if (no_update)\n\t++no_win_do_lines_ins;\n\n    // if the screen was scrolled up when displaying a message, scroll it down\n    if (msg_scrolled)\n    {\n\tclear_cmdline = TRUE;\n\tif (msg_scrolled > Rows - 5)\t    // clearing is faster\n\t    type = CLEAR;\n\telse if (type != CLEAR)\n\t{\n\t    check_for_delay(FALSE);\n\t    if (screen_ins_lines(0, 0, msg_scrolled, (int)Rows, 0, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\ttype = CLEAR;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp->w_winrow < msg_scrolled)\n\t\t{\n\t\t    if (W_WINROW(wp) + wp->w_height > msg_scrolled\n\t\t\t    && wp->w_redr_type < REDRAW_TOP\n\t\t\t    && wp->w_lines_valid > 0\n\t\t\t    && wp->w_topline == wp->w_lines[0].wl_lnum)\n\t\t    {\n\t\t\twp->w_upd_rows = msg_scrolled - W_WINROW(wp);\n\t\t\twp->w_redr_type = REDRAW_TOP;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\twp->w_redr_type = NOT_VALID;\n\t\t\tif (W_WINROW(wp) + wp->w_height + wp->w_status_height\n\t\t\t\t\t\t\t       <= msg_scrolled)\n\t\t\t    wp->w_redr_status = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!no_update)\n\t\tredraw_cmdline = TRUE;\n\t    redraw_tabline = TRUE;\n\t}\n\tmsg_scrolled = 0;\n\tneed_wait_return = FALSE;\n    }\n\n    // reset cmdline_row now (may have been changed temporarily)\n    compute_cmdrow();\n\n    // Check for changed highlighting\n    if (need_highlight_changed)\n\thighlight_changed();\n\n    if (type == CLEAR)\t\t// first clear screen\n    {\n\tscreenclear();\t\t// will reset clear_cmdline\n\ttype = NOT_VALID;\n\t// must_redraw may be set indirectly, avoid another redraw later\n\tmust_redraw = 0;\n    }\n\n    if (clear_cmdline)\t\t// going to clear cmdline (done below)\n\tcheck_for_delay(FALSE);\n\n#ifdef FEAT_LINEBREAK\n    // Force redraw when width of 'number' or 'relativenumber' column\n    // changes.\n    if (curwin->w_redr_type < NOT_VALID\n\t   && curwin->w_nrwidth != ((curwin->w_p_nu || curwin->w_p_rnu)\n\t\t\t\t    ? number_width(curwin) : 0))\n\tcurwin->w_redr_type = NOT_VALID;\n#endif\n\n    // Only start redrawing if there is really something to do.\n    if (type == INVERTED)\n\tupdate_curswant();\n    if (curwin->w_redr_type < type\n\t    && !((type == VALID\n\t\t    && curwin->w_lines[0].wl_valid\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill == curwin->w_old_topfill\n\t\t    && curwin->w_botfill == curwin->w_old_botfill\n#endif\n\t\t    && curwin->w_topline == curwin->w_lines[0].wl_lnum)\n\t\t|| (type == INVERTED\n\t\t    && VIsual_active\n\t\t    && curwin->w_old_cursor_lnum == curwin->w_cursor.lnum\n\t\t    && curwin->w_old_visual_mode == VIsual_mode\n\t\t    && (curwin->w_valid & VALID_VIRTCOL)\n\t\t    && curwin->w_old_curswant == curwin->w_curswant)\n\t\t))\n\tcurwin->w_redr_type = type;\n\n    // Redraw the tab pages line if needed.\n    if (redraw_tabline || type >= NOT_VALID)\n\tdraw_tabline();\n\n#ifdef FEAT_SYN_HL\n    // Correct stored syntax highlighting info for changes in each displayed\n    // buffer.  Each buffer must only be done once.\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer->b_mod_set)\n\t{\n\t    win_T\t*wwp;\n\n\t    // Check if we already did this buffer.\n\t    for (wwp = firstwin; wwp != wp; wwp = wwp->w_next)\n\t\tif (wwp->w_buffer == wp->w_buffer)\n\t\t    break;\n\t    if (wwp == wp && syntax_present(wp))\n\t\tsyn_stack_apply_changes(wp->w_buffer);\n\t}\n    }\n#endif\n\n    if (pum_redraw_in_same_position())\n\t// Avoid flicker if the popup menu is going to be redrawn in the same\n\t// position.\n\tpum_will_redraw = TRUE;\n\n    // Go from top to bottom through the windows, redrawing the ones that need\n    // it.\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)\n    did_update_one_window = FALSE;\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n    screen_search_hl.rm.regprog = NULL;\n#endif\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_redr_type != 0)\n\t{\n\t    cursor_off();\n#ifdef FEAT_GUI\n\t    if (!did_one)\n\t    {\n\t\tdid_one = TRUE;\n\n\t\t// Remove the cursor before starting to do anything, because\n\t\t// scrolling may make it difficult to redraw the text under\n\t\t// it.\n\t\t// Also remove the cursor if it needs to be hidden due to an\n\t\t// ongoing cursor-less sleep.\n\t\tif (gui.in_use && (wp == curwin || cursor_is_sleeping()))\n\t\t{\n\t\t    gui_cursor_col = gui.cursor_col;\n\t\t    gui_cursor_row = gui.cursor_row;\n\t\t    gui_undraw_cursor();\n\t\t    did_undraw = TRUE;\n\t\t}\n\t    }\n#endif\n\t    win_update(wp);\n\t}\n\n\t// redraw status line after the window to minimize cursor movement\n\tif (wp->w_redr_status)\n\t{\n\t    cursor_off();\n\t    win_redr_status(wp, TRUE); // any popup menu will be redrawn below\n\t}\n    }\n#if defined(FEAT_SEARCH_EXTRA)\n    end_search_hl();\n#endif\n\n    // May need to redraw the popup menu.\n    pum_will_redraw = save_pum_will_redraw;\n    pum_may_redraw();\n\n    // Reset b_mod_set flags.  Going through all windows is probably faster\n    // than going through all buffers (there could be many buffers).\n    FOR_ALL_WINDOWS(wp)\n\twp->w_buffer->b_mod_set = FALSE;\n\n#ifdef FEAT_PROP_POPUP\n    // Display popup windows on top of the windows and command line.\n    update_popups(win_update);\n#endif\n\n#ifdef FEAT_TERMINAL\n    FOR_ALL_WINDOWS(wp)\n\t// If this window contains a terminal, after redrawing all windows, the\n\t// dirty row range can be reset.\n\tterm_did_update_window(wp);\n#endif\n\n    after_updating_screen(TRUE);\n\n    // Clear or redraw the command line.  Done last, because scrolling may\n    // mess up the command line.\n    if (clear_cmdline || redraw_cmdline || redraw_mode)\n\tshowmode();\n\n    if (no_update)\n\t--no_win_do_lines_ins;\n\n    // May put up an introductory message when not editing a file\n    if (!did_intro)\n\tmaybe_intro_message();\n    did_intro = TRUE;\n\n#ifdef FEAT_GUI\n    // Redraw the cursor and update the scrollbars when all screen updating is\n    // done.\n    if (gui.in_use)\n    {\n\tif (did_undraw && !gui_mch_is_blink_off())\n\t{\n\t    mch_disable_flush();\n\t    out_flush();\t// required before updating the cursor\n\t    mch_enable_flush();\n\n\t    // Put the GUI position where the cursor was, gui_update_cursor()\n\t    // uses that.\n\t    gui.col = gui_cursor_col;\n\t    gui.row = gui_cursor_row;\n\t    gui.col = mb_fix_col(gui.col, gui.row);\n\t    gui_update_cursor(FALSE, FALSE);\n\t    gui_may_flush();\n\t    screen_cur_col = gui.col;\n\t    screen_cur_row = gui.row;\n\t}\n\telse\n\t    out_flush();\n\tgui_update_scrollbars(FALSE);\n    }\n#endif\n    return OK;\n}\n\n/*\n * Return the row for drawing the statusline and the ruler of window \"wp\".\n */\n    int\nstatusline_row(win_T *wp)\n{\n#if defined(FEAT_PROP_POPUP)\n    // If the window is really zero height the winbar isn't displayed.\n    if (wp->w_frame->fr_height == wp->w_status_height && !popup_is_popup(wp))\n\treturn wp->w_winrow;\n#endif\n    return W_WINROW(wp) + wp->w_height;\n}\n\n/*\n * Redraw the status line of window wp.\n *\n * If inversion is possible we use it. Else '=' characters are used.\n * If \"ignore_pum\" is TRUE, also redraw statusline when the popup menu is\n * displayed.\n */\n    static void\nwin_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif ((bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n#endif\n\t\t    || bufIsChanged(wp->w_buffer)\n\t\t    || wp->w_buffer->b_p_ro)\n\t\t&& len < MAXPATHL - 1)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}\n\n#ifdef FEAT_STL_OPT\n/*\n * Redraw the status line according to 'statusline' and take care of any\n * errors encountered.\n */\n    static void\nredraw_custom_statusline(win_T *wp)\n{\n    static int\t    entered = FALSE;\n    int\t\t    saved_did_emsg = did_emsg;\n\n    // When called recursively return.  This can happen when the statusline\n    // contains an expression that triggers a redraw.\n    if (entered)\n\treturn;\n    entered = TRUE;\n\n    did_emsg = FALSE;\n    win_redr_custom(wp, FALSE);\n    if (did_emsg)\n    {\n\t// When there is an error disable the statusline, otherwise the\n\t// display is messed up with errors and a redraw triggers the problem\n\t// again and again.\n\tset_string_option_direct((char_u *)\"statusline\", -1,\n\t\t(char_u *)\"\", OPT_FREE | (*wp->w_p_stl != NUL\n\t\t\t\t\t? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);\n    }\n    did_emsg |= saved_did_emsg;\n    entered = FALSE;\n}\n#endif\n\n/*\n * Show current status info in ruler and various other places\n * If always is FALSE, only show ruler if position has changed.\n */\n    void\nshowruler(int always)\n{\n    if (!always && !redrawing())\n\treturn;\n    if (pum_visible())\n    {\n\t// Don't redraw right now, do it later.\n\tcurwin->w_redr_status = TRUE;\n\treturn;\n    }\n#if defined(FEAT_STL_OPT)\n    if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)\n\tredraw_custom_statusline(curwin);\n    else\n#endif\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(curwin, always, FALSE);\n#endif\n\n    if (need_maketitle\n#ifdef FEAT_STL_OPT\n\t    || (p_icon && (stl_syntax & STL_IN_ICON))\n\t    || (p_title && (stl_syntax & STL_IN_TITLE))\n#endif\n       )\n\tmaketitle();\n\n    // Redraw the tab pages line if needed.\n    if (redraw_tabline)\n\tdraw_tabline();\n}\n\n#if defined(FEAT_CMDL_INFO) || defined(PROTO)\n    void\nwin_redr_ruler(win_T *wp, int always, int ignore_pum)\n{\n#define RULER_BUF_LEN 70\n    char_u\tbuffer[RULER_BUF_LEN];\n    int\t\trow;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tempty_line = FALSE;\n    colnr_T\tvirtcol;\n    int\t\ti;\n    size_t\tlen;\n    int\t\to;\n    int\t\tthis_ru_col;\n    int\t\toff = 0;\n    int\t\twidth;\n\n    // If 'ruler' off or redrawing disabled, don't do anything\n    if (!p_ru)\n\treturn;\n\n    /*\n     * Check if cursor.lnum is valid, since win_redr_ruler() may be called\n     * after deleting lines, before cursor.lnum is corrected.\n     */\n    if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)\n\treturn;\n\n    // Don't draw the ruler while doing insert-completion, it might overwrite\n    // the (long) mode message.\n    if (wp == lastwin && lastwin->w_status_height == 0)\n\tif (edit_submode != NULL)\n\t    return;\n    // Don't draw the ruler when the popup menu is visible, it may overlap.\n    // Except when the popup menu will be redrawn anyway.\n    if (!ignore_pum && pum_visible())\n\treturn;\n\n#ifdef FEAT_STL_OPT\n    if (*p_ruf)\n    {\n\tint\tcalled_emsg_before = called_emsg;\n\n\twin_redr_custom(wp, TRUE);\n\tif (called_emsg > called_emsg_before)\n\t    set_string_option_direct((char_u *)\"rulerformat\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\treturn;\n    }\n#endif\n\n    /*\n     * Check if not in Insert mode and the line is empty (will show \"0-1\").\n     */\n    if (!(State & INSERT)\n\t\t&& *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)\n\tempty_line = TRUE;\n\n    /*\n     * Only draw the ruler when something changed.\n     */\n    validate_virtcol_win(wp);\n    if (       redraw_cmdline\n\t    || always\n\t    || wp->w_cursor.lnum != wp->w_ru_cursor.lnum\n\t    || wp->w_cursor.col != wp->w_ru_cursor.col\n\t    || wp->w_virtcol != wp->w_ru_virtcol\n\t    || wp->w_cursor.coladd != wp->w_ru_cursor.coladd\n\t    || wp->w_topline != wp->w_ru_topline\n\t    || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count\n#ifdef FEAT_DIFF\n\t    || wp->w_topfill != wp->w_ru_topfill\n#endif\n\t    || empty_line != wp->w_ru_empty)\n    {\n\tcursor_off();\n\tif (wp->w_status_height)\n\t{\n\t    row = statusline_row(wp);\n\t    fillchar = fillchar_status(&attr, wp);\n\t    off = wp->w_wincol;\n\t    width = wp->w_width;\n\t}\n\telse\n\t{\n\t    row = Rows - 1;\n\t    fillchar = ' ';\n\t    attr = 0;\n\t    width = Columns;\n\t    off = 0;\n\t}\n\n\t// In list mode virtcol needs to be recomputed\n\tvirtcol = wp->w_virtcol;\n\tif (wp->w_p_list && wp->w_lcs_chars.tab1 == NUL)\n\t{\n\t    wp->w_p_list = FALSE;\n\t    getvvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);\n\t    wp->w_p_list = TRUE;\n\t}\n\n\t/*\n\t * Some sprintfs return the length, some return a pointer.\n\t * To avoid portability problems we use strlen() here.\n\t */\n\tvim_snprintf((char *)buffer, RULER_BUF_LEN, \"%ld,\",\n\t\t(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t    ? 0L\n\t\t    : (long)(wp->w_cursor.lnum));\n\tlen = STRLEN(buffer);\n\tcol_print(buffer + len, RULER_BUF_LEN - len,\n\t\t\tempty_line ? 0 : (int)wp->w_cursor.col + 1,\n\t\t\t(int)virtcol + 1);\n\n\t/*\n\t * Add a \"50%\" if there is room for it.\n\t * On the last line, don't print in the last column (scrolls the\n\t * screen up on some terminals).\n\t */\n\ti = (int)STRLEN(buffer);\n\tget_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);\n\to = i + vim_strsize(buffer + i + 1);\n\tif (wp->w_status_height == 0)\t// can't use last char of screen\n\t    ++o;\n\tthis_ru_col = ru_col - (Columns - width);\n\tif (this_ru_col < 0)\n\t    this_ru_col = 0;\n\t// Never use more than half the window/screen width, leave the other\n\t// half for the filename.\n\tif (this_ru_col < (width + 1) / 2)\n\t    this_ru_col = (width + 1) / 2;\n\tif (this_ru_col + o < width)\n\t{\n\t    // need at least 3 chars left for get_rel_pos() + NUL\n\t    while (this_ru_col + o < width && RULER_BUF_LEN > i + 4)\n\t    {\n\t\tif (has_mbyte)\n\t\t    i += (*mb_char2bytes)(fillchar, buffer + i);\n\t\telse\n\t\t    buffer[i++] = fillchar;\n\t\t++o;\n\t    }\n\t    get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);\n\t}\n\t// Truncate at window boundary.\n\tif (has_mbyte)\n\t{\n\t    o = 0;\n\t    for (i = 0; buffer[i] != NUL; i += (*mb_ptr2len)(buffer + i))\n\t    {\n\t\to += (*mb_ptr2cells)(buffer + i);\n\t\tif (this_ru_col + o > width)\n\t\t{\n\t\t    buffer[i] = NUL;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (this_ru_col + (int)STRLEN(buffer) > width)\n\t    buffer[width - this_ru_col] = NUL;\n\n\tscreen_puts(buffer, row, this_ru_col + off, attr);\n\ti = redraw_cmdline;\n\tscreen_fill(row, row + 1,\n\t\tthis_ru_col + off + (int)STRLEN(buffer),\n\t\t(int)(off + width),\n\t\tfillchar, fillchar, attr);\n\t// don't redraw the cmdline because of showing the ruler\n\tredraw_cmdline = i;\n\twp->w_ru_cursor = wp->w_cursor;\n\twp->w_ru_virtcol = wp->w_virtcol;\n\twp->w_ru_empty = empty_line;\n\twp->w_ru_topline = wp->w_topline;\n\twp->w_ru_line_count = wp->w_buffer->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\twp->w_ru_topfill = wp->w_topfill;\n#endif\n    }\n}\n#endif\n\n/*\n * To be called when \"updating_screen\" was set before and now the postponed\n * side effects may take place.\n */\n    void\nafter_updating_screen(int may_resize_shell UNUSED)\n{\n    updating_screen = FALSE;\n#ifdef FEAT_GUI\n    if (may_resize_shell)\n\tgui_may_resize_shell();\n#endif\n#ifdef FEAT_TERMINAL\n    term_check_channel_closed_recently();\n#endif\n\n#ifdef HAVE_DROP_FILE\n    // If handle_drop() was called while updating_screen was TRUE need to\n    // handle the drop now.\n    handle_any_postponed_drop();\n#endif\n}\n\n/*\n * Update all windows that are editing the current buffer.\n */\n    void\nupdate_curbuf(int type)\n{\n    redraw_curbuf_later(type);\n    update_screen(type);\n}\n\n#if defined(FEAT_MENU) || defined(FEAT_FOLDING)\n/*\n * Copy \"text\" to ScreenLines using \"attr\".\n * Returns the next screen column.\n */\n    static int\ntext_to_screenline(win_T *wp, char_u *text, int col)\n{\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n\n    if (has_mbyte)\n    {\n\tint\tcells;\n\tint\tu8c, u8cc[MAX_MCO];\n\tint\ti;\n\tint\tidx;\n\tint\tc_len;\n\tchar_u\t*p;\n# ifdef FEAT_ARABIC\n\tint\tprev_c = 0;\t\t// previous Arabic character\n\tint\tprev_c1 = 0;\t\t// first composing char for prev_c\n# endif\n\n# ifdef FEAT_RIGHTLEFT\n\tif (wp->w_p_rl)\n\t    idx = off;\n\telse\n# endif\n\t    idx = off + col;\n\n\t// Store multibyte characters in ScreenLines[] et al. correctly.\n\tfor (p = text; *p != NUL; )\n\t{\n\t    cells = (*mb_ptr2cells)(p);\n\t    c_len = (*mb_ptr2len)(p);\n\t    if (col + cells > wp->w_width\n# ifdef FEAT_RIGHTLEFT\n\t\t    - (wp->w_p_rl ? col : 0)\n# endif\n\t\t    )\n\t\tbreak;\n\t    ScreenLines[idx] = *p;\n\t    if (enc_utf8)\n\t    {\n\t\tu8c = utfc_ptr2char(p, u8cc);\n\t\tif (*p < 0x80 && u8cc[0] == 0)\n\t\t{\n\t\t    ScreenLinesUC[idx] = 0;\n#ifdef FEAT_ARABIC\n\t\t    prev_c = u8c;\n#endif\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_ARABIC\n\t\t    if (p_arshape && !p_tbidi && ARABIC_CHAR(u8c))\n\t\t    {\n\t\t\t// Do Arabic shaping.\n\t\t\tint\tpc, pc1, nc;\n\t\t\tint\tpcc[MAX_MCO];\n\t\t\tint\tfirstbyte = *p;\n\n\t\t\t// The idea of what is the previous and next\n\t\t\t// character depends on 'rightleft'.\n\t\t\tif (wp->w_p_rl)\n\t\t\t{\n\t\t\t    pc = prev_c;\n\t\t\t    pc1 = prev_c1;\n\t\t\t    nc = utf_ptr2char(p + c_len);\n\t\t\t    prev_c1 = u8cc[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    pc = utfc_ptr2char(p + c_len, pcc);\n\t\t\t    nc = prev_c;\n\t\t\t    pc1 = pcc[0];\n\t\t\t}\n\t\t\tprev_c = u8c;\n\n\t\t\tu8c = arabic_shape(u8c, &firstbyte, &u8cc[0],\n\t\t\t\t\t\t\t\t pc, pc1, nc);\n\t\t\tScreenLines[idx] = firstbyte;\n\t\t    }\n\t\t    else\n\t\t\tprev_c = u8c;\n#endif\n\t\t    // Non-BMP character: display as ? or fullwidth ?.\n\t\t    ScreenLinesUC[idx] = u8c;\n\t\t    for (i = 0; i < Screen_mco; ++i)\n\t\t    {\n\t\t\tScreenLinesC[i][idx] = u8cc[i];\n\t\t\tif (u8cc[i] == 0)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\tif (cells > 1)\n\t\t    ScreenLines[idx + 1] = 0;\n\t    }\n\t    else if (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\t\t// double-byte single width character\n\t\tScreenLines2[idx] = p[1];\n\t    else if (cells > 1)\n\t\t// double-width character\n\t\tScreenLines[idx + 1] = p[1];\n\t    col += cells;\n\t    idx += cells;\n\t    p += c_len;\n\t}\n    }\n    else\n    {\n\tint len = (int)STRLEN(text);\n\n\tif (len > wp->w_width - col)\n\t    len = wp->w_width - col;\n\tif (len > 0)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (wp->w_p_rl)\n\t\tmch_memmove(current_ScreenLine, text, len);\n\t    else\n#endif\n\t\tmch_memmove(current_ScreenLine + col, text, len);\n\t    col += len;\n\t}\n    }\n    return col;\n}\n#endif\n\n#ifdef FEAT_MENU\n/*\n * Draw the window toolbar.\n */\n    static void\nredraw_win_toolbar(win_T *wp)\n{\n    vimmenu_T\t*menu;\n    int\t\titem_idx = 0;\n    int\t\titem_count = 0;\n    int\t\tcol = 0;\n    int\t\tnext_col;\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n    int\t\tfill_attr = syn_name2attr((char_u *)\"ToolbarLine\");\n    int\t\tbutton_attr = syn_name2attr((char_u *)\"ToolbarButton\");\n\n    vim_free(wp->w_winbar_items);\n    FOR_ALL_CHILD_MENUS(wp->w_winbar, menu)\n\t++item_count;\n    wp->w_winbar_items = ALLOC_CLEAR_MULT(winbar_item_T, item_count + 1);\n\n    // TODO: use fewer spaces if there is not enough room\n    for (menu = wp->w_winbar->children;\n\t\t\t  menu != NULL && col < wp->w_width; menu = menu->next)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\tif (col > 1)\n\t{\n\t    space_to_screenline(off + col, fill_attr);\n\t    if (++col >= wp->w_width)\n\t\tbreak;\n\t}\n\n\twp->w_winbar_items[item_idx].wb_startcol = col;\n\tspace_to_screenline(off + col, button_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\n\tnext_col = text_to_screenline(wp, menu->name, col);\n\twhile (col < next_col)\n\t{\n\t    ScreenAttrs[off + col] = button_attr;\n\t    ++col;\n\t}\n\twp->w_winbar_items[item_idx].wb_endcol = col;\n\twp->w_winbar_items[item_idx].wb_menu = menu;\n\t++item_idx;\n\n\tif (col >= wp->w_width)\n\t    break;\n\tspace_to_screenline(off + col, button_attr);\n\t++col;\n    }\n    while (col < wp->w_width)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\t++col;\n    }\n    wp->w_winbar_items[item_idx].wb_menu = NULL; // end marker\n\n    screen_line(wp->w_winrow, wp->w_wincol, (int)wp->w_width,\n\t\t\t\t\t\t\t  (int)wp->w_width, 0);\n}\n#endif\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Copy \"buf[len]\" to ScreenLines[\"off\"] and set attributes to \"attr\".\n */\n    static void\ncopy_text_attr(\n    int\t\toff,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tattr)\n{\n    int\t\ti;\n\n    mch_memmove(ScreenLines + off, buf, (size_t)len);\n    if (enc_utf8)\n\tvim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);\n    for (i = 0; i < len; ++i)\n\tScreenAttrs[off + i] = attr;\n}\n\n/*\n * Display one folded line.\n */\n    static void\nfold_line(\n    win_T\t*wp,\n    long\tfold_count,\n    foldinfo_T\t*foldinfo,\n    linenr_T\tlnum,\n    int\t\trow)\n{\n    // Max value of 'foldcolumn' is 12 and maximum number of bytes in a\n    // multi-byte character is MAX_MCO.\n    char_u\tbuf[MAX_MCO * 12 + 1];\n    pos_T\t*top, *bot;\n    linenr_T\tlnume = lnum + fold_count - 1;\n    int\t\tlen;\n    char_u\t*text;\n    int\t\tfdc;\n    int\t\tcol;\n    int\t\ttxtcol;\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n    int\t\tri;\n\n    // Build the fold line:\n    // 1. Add the cmdwin_type for the command-line window\n    // 2. Add the 'foldcolumn'\n    // 3. Add the 'number' or 'relativenumber' column\n    // 4. Compose the text\n    // 5. Add the text\n    // 6. set highlighting for the Visual area an other text\n    col = 0;\n\n    // 1. Add the cmdwin_type for the command-line window\n    // Ignores 'rightleft', this window is never right-left.\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0 && wp == curwin)\n    {\n\tScreenLines[off] = cmdwin_type;\n\tScreenAttrs[off] = HL_ATTR(HLF_AT);\n\tif (enc_utf8)\n\t    ScreenLinesUC[off] = 0;\n\t++col;\n    }\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n# define RL_MEMSET(p, v, l) \\\n    do { \\\n\tif (wp->w_p_rl) \\\n\t    for (ri = 0; ri < l; ++ri) \\\n\t       ScreenAttrs[off + (wp->w_width - (p) - (l)) + ri] = v; \\\n\t else \\\n\t    for (ri = 0; ri < l; ++ri) \\\n\t       ScreenAttrs[off + (p) + ri] = v; \\\n    } while (0)\n#else\n# define RL_MEMSET(p, v, l) \\\n    do { \\\n\tfor (ri = 0; ri < l; ++ri) \\\n\t    ScreenAttrs[off + (p) + ri] = v; \\\n    } while (0)\n#endif\n\n    // 2. Add the 'foldcolumn'\n    //    Reduce the width when there is not enough space.\n    fdc = compute_foldcolumn(wp, col);\n    if (fdc > 0)\n    {\n\tchar_u\t*p;\n\tint\ti;\n\tint\tidx;\n\n\tfill_foldcolumn(buf, wp, TRUE, lnum);\n\tp = buf;\n\tfor (i = 0; i < fdc; i++)\n\t{\n\t    int\t\tch;\n\n\t    if (has_mbyte)\n\t\tch = mb_ptr2char_adv(&p);\n\t    else\n\t\tch = *p++;\n#ifdef FEAT_RIGHTLEFT\n\t    if (wp->w_p_rl)\n\t\tidx = off + wp->w_width - i - 1 - col;\n\t    else\n#endif\n\t\tidx = off + col + i;\n\t    if (enc_utf8)\n\t    {\n\t\tif (ch >= 0x80)\n\t\t{\n\t\t    ScreenLinesUC[idx] = ch;\n\t\t    ScreenLinesC[0][idx] = 0;\n\t\t    ScreenLines[idx] = 0x80;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ScreenLines[idx] = ch;\n\t\t    ScreenLinesUC[idx] = 0;\n\t\t}\n\t    }\n\t    else\n\t\tScreenLines[idx] = ch;\n\t}\n\n\tRL_MEMSET(col, HL_ATTR(HLF_FC), fdc);\n\tcol += fdc;\n    }\n\n    // Set all attributes of the 'number' or 'relativenumber' column and the\n    // text\n    RL_MEMSET(col, HL_ATTR(HLF_FL), wp->w_width - col);\n\n#ifdef FEAT_SIGNS\n    // If signs are being displayed, add two spaces.\n    if (signcolumn_on(wp))\n    {\n\tlen = wp->w_width - col;\n\tif (len > 0)\n\t{\n\t    if (len > 2)\n\t\tlen = 2;\n# ifdef FEAT_RIGHTLEFT\n\t    if (wp->w_p_rl)\n\t\t// the line number isn't reversed\n\t\tcopy_text_attr(off + wp->w_width - len - col,\n\t\t\t\t\t(char_u *)\"  \", len, HL_ATTR(HLF_FL));\n\t    else\n# endif\n\t\tcopy_text_attr(off + col, (char_u *)\"  \", len, HL_ATTR(HLF_FL));\n\t    col += len;\n\t}\n    }\n#endif\n\n    // 3. Add the 'number' or 'relativenumber' column\n    if (wp->w_p_nu || wp->w_p_rnu)\n    {\n\tlen = wp->w_width - col;\n\tif (len > 0)\n\t{\n\t    int\t    w = number_width(wp);\n\t    long    num;\n\t    char    *fmt = \"%*ld \";\n\n\t    if (len > w + 1)\n\t\tlen = w + 1;\n\n\t    if (wp->w_p_nu && !wp->w_p_rnu)\n\t\t// 'number' + 'norelativenumber'\n\t\tnum = (long)lnum;\n\t    else\n\t    {\n\t\t// 'relativenumber', don't use negative numbers\n\t\tnum = labs((long)get_cursor_rel_lnum(wp, lnum));\n\t\tif (num == 0 && wp->w_p_nu && wp->w_p_rnu)\n\t\t{\n\t\t    // 'number' + 'relativenumber': cursor line shows absolute\n\t\t    // line number\n\t\t    num = lnum;\n\t\t    fmt = \"%-*ld \";\n\t\t}\n\t    }\n\n\t    sprintf((char *)buf, fmt, w, num);\n#ifdef FEAT_RIGHTLEFT\n\t    if (wp->w_p_rl)\n\t\t// the line number isn't reversed\n\t\tcopy_text_attr(off + wp->w_width - len - col, buf, len,\n\t\t\t\t\t\t\t     HL_ATTR(HLF_FL));\n\t    else\n#endif\n\t\tcopy_text_attr(off + col, buf, len, HL_ATTR(HLF_FL));\n\t    col += len;\n\t}\n    }\n\n    // 4. Compose the folded-line string with 'foldtext', if set.\n    text = get_foldtext(wp, lnum, lnume, foldinfo, buf);\n\n    txtcol = col;\t// remember where text starts\n\n    // 5. move the text to current_ScreenLine.  Fill up with \"fill_fold\".\n    //    Right-left text is put in columns 0 - number-col, normal text is put\n    //    in columns number-col - window-width.\n    col = text_to_screenline(wp, text, col);\n\n    // Fill the rest of the line with the fold filler\n#ifdef FEAT_RIGHTLEFT\n    if (wp->w_p_rl)\n\tcol -= txtcol;\n#endif\n    while (col < wp->w_width\n#ifdef FEAT_RIGHTLEFT\n\t\t    - (wp->w_p_rl ? txtcol : 0)\n#endif\n\t    )\n    {\n\tif (enc_utf8)\n\t{\n\t    if (fill_fold >= 0x80)\n\t    {\n\t\tScreenLinesUC[off + col] = fill_fold;\n\t\tScreenLinesC[0][off + col] = 0;\n\t\tScreenLines[off + col] = 0x80; // avoid storing zero\n\t    }\n\t    else\n\t    {\n\t\tScreenLinesUC[off + col] = 0;\n\t\tScreenLines[off + col] = fill_fold;\n\t    }\n\t    col++;\n\t}\n\telse\n\t    ScreenLines[off + col++] = fill_fold;\n    }\n\n    if (text != buf)\n\tvim_free(text);\n\n    // 6. set highlighting for the Visual area an other text.\n    // If all folded lines are in the Visual area, highlight the line.\n    if (VIsual_active && wp->w_buffer == curwin->w_buffer)\n    {\n\tif (LTOREQ_POS(curwin->w_cursor, VIsual))\n\t{\n\t    // Visual is after curwin->w_cursor\n\t    top = &curwin->w_cursor;\n\t    bot = &VIsual;\n\t}\n\telse\n\t{\n\t    // Visual is before curwin->w_cursor\n\t    top = &VIsual;\n\t    bot = &curwin->w_cursor;\n\t}\n\tif (lnum >= top->lnum\n\t\t&& lnume <= bot->lnum\n\t\t&& (VIsual_mode != 'v'\n\t\t    || ((lnum > top->lnum\n\t\t\t    || (lnum == top->lnum\n\t\t\t\t&& top->col == 0))\n\t\t\t&& (lnume < bot->lnum\n\t\t\t    || (lnume == bot->lnum\n\t\t\t\t&& (bot->col - (*p_sel == 'e'))\n\t\t>= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))\n\t{\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n\t\t// Visual block mode: highlight the chars part of the block\n\t\tif (wp->w_old_cursor_fcol + txtcol < (colnr_T)wp->w_width)\n\t\t{\n\t\t    if (wp->w_old_cursor_lcol != MAXCOL\n\t\t\t     && wp->w_old_cursor_lcol + txtcol\n\t\t\t\t\t\t       < (colnr_T)wp->w_width)\n\t\t\tlen = wp->w_old_cursor_lcol;\n\t\t    else\n\t\t\tlen = wp->w_width - txtcol;\n\t\t    RL_MEMSET(wp->w_old_cursor_fcol + txtcol, HL_ATTR(HLF_V),\n\t\t\t\t\t    len - (int)wp->w_old_cursor_fcol);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Set all attributes of the text\n\t\tRL_MEMSET(txtcol, HL_ATTR(HLF_V), wp->w_width - txtcol);\n\t    }\n\t}\n    }\n\n#ifdef FEAT_SYN_HL\n    // Show colorcolumn in the fold line, but let cursorcolumn override it.\n    if (wp->w_p_cc_cols)\n    {\n\tint i = 0;\n\tint j = wp->w_p_cc_cols[i];\n\tint old_txtcol = txtcol;\n\n\twhile (j > -1)\n\t{\n\t    txtcol += j;\n\t    if (wp->w_p_wrap)\n\t\ttxtcol -= wp->w_skipcol;\n\t    else\n\t\ttxtcol -= wp->w_leftcol;\n\t    if (txtcol >= 0 && txtcol < wp->w_width)\n\t\tScreenAttrs[off + txtcol] = hl_combine_attr(\n\t\t\t\t    ScreenAttrs[off + txtcol], HL_ATTR(HLF_MC));\n\t    txtcol = old_txtcol;\n\t    j = wp->w_p_cc_cols[++i];\n\t}\n    }\n\n    // Show 'cursorcolumn' in the fold line.\n    if (wp->w_p_cuc)\n    {\n\ttxtcol += wp->w_virtcol;\n\tif (wp->w_p_wrap)\n\t    txtcol -= wp->w_skipcol;\n\telse\n\t    txtcol -= wp->w_leftcol;\n\tif (txtcol >= 0 && txtcol < wp->w_width)\n\t    ScreenAttrs[off + txtcol] = hl_combine_attr(\n\t\t\t\t ScreenAttrs[off + txtcol], HL_ATTR(HLF_CUC));\n    }\n#endif\n\n    screen_line(row + W_WINROW(wp), wp->w_wincol, (int)wp->w_width,\n\t\t\t\t\t\t     (int)wp->w_width, 0);\n\n    // Update w_cline_height and w_cline_folded if the cursor line was\n    // updated (saves a call to plines() later).\n    if (wp == curwin\n\t    && lnum <= curwin->w_cursor.lnum\n\t    && lnume >= curwin->w_cursor.lnum)\n    {\n\tcurwin->w_cline_row = row;\n\tcurwin->w_cline_height = 1;\n\tcurwin->w_cline_folded = TRUE;\n\tcurwin->w_valid |= (VALID_CHEIGHT|VALID_CROW);\n    }\n\n# ifdef FEAT_CONCEAL\n    // When the line was not folded w_wrow may have been set, recompute it.\n    if (wp == curwin\n\t    && wp->w_cursor.lnum >= lnum\n\t    && wp->w_cursor.lnum <= lnume\n\t    && conceal_cursor_line(wp))\n\tcurs_columns(TRUE);\n# endif\n}\n#endif\n\n/*\n * Update a single window.\n *\n * This may cause the windows below it also to be redrawn (when clearing the\n * screen or scrolling lines).\n *\n * How the window is redrawn depends on wp->w_redr_type.  Each type also\n * implies the one below it.\n * NOT_VALID\tredraw the whole window\n * SOME_VALID\tredraw the whole window but do scroll when possible\n * REDRAW_TOP\tredraw the top w_upd_rows window lines, otherwise like VALID\n * INVERTED\tredraw the changed part of the Visual area\n * INVERTED_ALL\tredraw the whole Visual area\n * VALID\t1. scroll up/down to adjust for a changed w_topline\n *\t\t2. update lines at the top when scrolled down\n *\t\t3. redraw changed text:\n *\t\t   - if wp->w_buffer->b_mod_set set, update lines between\n *\t\t     b_mod_top and b_mod_bot.\n *\t\t   - if wp->w_redraw_top non-zero, redraw lines between\n *\t\t     wp->w_redraw_top and wp->w_redr_bot.\n *\t\t   - continue redrawing when syntax status is invalid.\n *\t\t4. if scrolled up, update lines at the bottom.\n * This results in three areas that may need updating:\n * top:\tfrom first row to top_end (when scrolled down)\n * mid: from mid_start to mid_end (update inversion or changed text)\n * bot: from bot_start to last row (when scrolled up)\n */\n    static void\nwin_update(win_T *wp)\n{\n    buf_T\t*buf = wp->w_buffer;\n    int\t\ttype;\n    int\t\ttop_end = 0;\t// Below last row of the top area that needs\n\t\t\t\t// updating.  0 when no top area updating.\n    int\t\tmid_start = 999;// first row of the mid area that needs\n\t\t\t\t// updating.  999 when no mid area updating.\n    int\t\tmid_end = 0;\t// Below last row of the mid area that needs\n\t\t\t\t// updating.  0 when no mid area updating.\n    int\t\tbot_start = 999;// first row of the bot area that needs\n\t\t\t\t// updating.  999 when no bot area updating\n    int\t\tscrolled_down = FALSE;\t// TRUE when scrolled down when\n\t\t\t\t\t// w_topline got smaller a bit\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\ttop_to_mod = FALSE;    // redraw above mod_top\n#endif\n\n    int\t\trow;\t\t// current window row to display\n    linenr_T\tlnum;\t\t// current buffer lnum to display\n    int\t\tidx;\t\t// current index in w_lines[]\n    int\t\tsrow;\t\t// starting row of the current line\n\n    int\t\teof = FALSE;\t// if TRUE, we hit the end of the file\n    int\t\tdidline = FALSE; // if TRUE, we finished the last line\n    int\t\ti;\n    long\tj;\n    static int\trecursive = FALSE;\t// being called recursively\n    linenr_T\told_botline = wp->w_botline;\n#ifdef FEAT_CONCEAL\n    int\t\told_wrow = wp->w_wrow;\n    int\t\told_wcol = wp->w_wcol;\n#endif\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n#ifdef FEAT_SYN_HL\n    // remember what happened to the previous line, to know if\n    // check_visual_highlight() can be used\n#define DID_NONE 1\t// didn't update a line\n#define DID_LINE 2\t// updated a normal line\n#define DID_FOLD 3\t// updated a folded line\n    int\t\tdid_update = DID_NONE;\n    linenr_T\tsyntax_last_parsed = 0;\t\t// last parsed text line\n#endif\n    linenr_T\tmod_top = 0;\n    linenr_T\tmod_bot = 0;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)\n    int\t\tsave_got_int;\n#endif\n#ifdef SYN_TIME_LIMIT\n    proftime_T\tsyntax_tm;\n#endif\n\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)\n    // This needs to be done only for the first window when update_screen() is\n    // called.\n    if (!did_update_one_window)\n    {\n\tdid_update_one_window = TRUE;\n# ifdef FEAT_SEARCH_EXTRA\n\tstart_search_hl();\n# endif\n# ifdef FEAT_CLIPBOARD\n\t// When Visual area changed, may have to update selection.\n\tif (clip_star.available && clip_isautosel_star())\n\t    clip_update_selection(&clip_star);\n\tif (clip_plus.available && clip_isautosel_plus())\n\t    clip_update_selection(&clip_plus);\n# endif\n    }\n#endif\n\n    type = wp->w_redr_type;\n\n    if (type == NOT_VALID)\n    {\n\twp->w_redr_status = TRUE;\n\twp->w_lines_valid = 0;\n    }\n\n    // Window frame is zero-height: nothing to draw.\n    if (wp->w_height + WINBAR_HEIGHT(wp) == 0\n\t    || (wp->w_frame->fr_height == wp->w_status_height\n#if defined(FEAT_PROP_POPUP)\n\t\t&& !popup_is_popup(wp)\n#endif\n\t       ))\n    {\n\twp->w_redr_type = 0;\n\treturn;\n    }\n\n    // Window is zero-width: Only need to draw the separator.\n    if (wp->w_width == 0)\n    {\n\t// draw the vertical separator right of this window\n\tdraw_vsep_win(wp, 0);\n\twp->w_redr_type = 0;\n\treturn;\n    }\n\n#ifdef FEAT_TERMINAL\n    // If this window contains a terminal, redraw works completely differently.\n    if (term_do_update_window(wp))\n    {\n\tterm_update_window(wp);\n# ifdef FEAT_MENU\n\t// Draw the window toolbar, if there is one.\n\tif (winbar_height(wp) > 0)\n\t    redraw_win_toolbar(wp);\n# endif\n\twp->w_redr_type = 0;\n\treturn;\n    }\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_search_hl(wp, &screen_search_hl);\n#endif\n\n#ifdef FEAT_LINEBREAK\n    // Force redraw when width of 'number' or 'relativenumber' column\n    // changes.\n    i = (wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) : 0;\n    if (wp->w_nrwidth != i)\n    {\n\ttype = NOT_VALID;\n\twp->w_nrwidth = i;\n    }\n    else\n#endif\n\n    if (buf->b_mod_set && buf->b_mod_xlines != 0 && wp->w_redraw_top != 0)\n    {\n\t// When there are both inserted/deleted lines and specific lines to be\n\t// redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw\n\t// everything (only happens when redrawing is off for while).\n\ttype = NOT_VALID;\n    }\n    else\n    {\n\t// Set mod_top to the first line that needs displaying because of\n\t// changes.  Set mod_bot to the first line after the changes.\n\tmod_top = wp->w_redraw_top;\n\tif (wp->w_redraw_bot != 0)\n\t    mod_bot = wp->w_redraw_bot + 1;\n\telse\n\t    mod_bot = 0;\n\tif (buf->b_mod_set)\n\t{\n\t    if (mod_top == 0 || mod_top > buf->b_mod_top)\n\t    {\n\t\tmod_top = buf->b_mod_top;\n#ifdef FEAT_SYN_HL\n\t\t// Need to redraw lines above the change that may be included\n\t\t// in a pattern match.\n\t\tif (syntax_present(wp))\n\t\t{\n\t\t    mod_top -= buf->b_s.b_syn_sync_linebreaks;\n\t\t    if (mod_top < 1)\n\t\t\tmod_top = 1;\n\t\t}\n#endif\n\t    }\n\t    if (mod_bot == 0 || mod_bot < buf->b_mod_bot)\n\t\tmod_bot = buf->b_mod_bot;\n\n#ifdef FEAT_SEARCH_EXTRA\n\t    // When 'hlsearch' is on and using a multi-line search pattern, a\n\t    // change in one line may make the Search highlighting in a\n\t    // previous line invalid.  Simple solution: redraw all visible\n\t    // lines above the change.\n\t    // Same for a match pattern.\n\t    if (screen_search_hl.rm.regprog != NULL\n\t\t    && re_multiline(screen_search_hl.rm.regprog))\n\t\ttop_to_mod = TRUE;\n\t    else\n\t    {\n\t\tmatchitem_T *cur = wp->w_match_head;\n\n\t\twhile (cur != NULL)\n\t\t{\n\t\t    if (cur->match.regprog != NULL\n\t\t\t\t\t   && re_multiline(cur->match.regprog))\n\t\t    {\n\t\t\ttop_to_mod = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t    cur = cur->next;\n\t\t}\n\t    }\n#endif\n\t}\n#ifdef FEAT_FOLDING\n\tif (mod_top != 0 && hasAnyFolding(wp))\n\t{\n\t    linenr_T\tlnumt, lnumb;\n\n\t    // A change in a line can cause lines above it to become folded or\n\t    // unfolded.  Find the top most buffer line that may be affected.\n\t    // If the line was previously folded and displayed, get the first\n\t    // line of that fold.  If the line is folded now, get the first\n\t    // folded line.  Use the minimum of these two.\n\n\t    // Find last valid w_lines[] entry above mod_top.  Set lnumt to\n\t    // the line below it.  If there is no valid entry, use w_topline.\n\t    // Find the first valid w_lines[] entry below mod_bot.  Set lnumb\n\t    // to this line.  If there is no valid entry, use MAXLNUM.\n\t    lnumt = wp->w_topline;\n\t    lnumb = MAXLNUM;\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lastlnum < mod_top)\n\t\t\tlnumt = wp->w_lines[i].wl_lastlnum + 1;\n\t\t    if (lnumb == MAXLNUM && wp->w_lines[i].wl_lnum >= mod_bot)\n\t\t    {\n\t\t\tlnumb = wp->w_lines[i].wl_lnum;\n\t\t\t// When there is a fold column it might need updating\n\t\t\t// in the next line (\"J\" just above an open fold).\n\t\t\tif (compute_foldcolumn(wp, 0) > 0)\n\t\t\t    ++lnumb;\n\t\t    }\n\t\t}\n\n\t    (void)hasFoldingWin(wp, mod_top, &mod_top, NULL, TRUE, NULL);\n\t    if (mod_top > lnumt)\n\t\tmod_top = lnumt;\n\n\t    // Now do the same for the bottom line (one above mod_bot).\n\t    --mod_bot;\n\t    (void)hasFoldingWin(wp, mod_bot, NULL, &mod_bot, TRUE, NULL);\n\t    ++mod_bot;\n\t    if (mod_bot < lnumb)\n\t\tmod_bot = lnumb;\n\t}\n#endif\n\n\t// When a change starts above w_topline and the end is below\n\t// w_topline, start redrawing at w_topline.\n\t// If the end of the change is above w_topline: do like no change was\n\t// made, but redraw the first line to find changes in syntax.\n\tif (mod_top != 0 && mod_top < wp->w_topline)\n\t{\n\t    if (mod_bot > wp->w_topline)\n\t\tmod_top = wp->w_topline;\n#ifdef FEAT_SYN_HL\n\t    else if (syntax_present(wp))\n\t\ttop_end = 1;\n#endif\n\t}\n\n\t// When line numbers are displayed need to redraw all lines below\n\t// inserted/deleted lines.\n\tif (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_p_nu)\n\t    mod_bot = MAXLNUM;\n    }\n    wp->w_redraw_top = 0;\t// reset for next time\n    wp->w_redraw_bot = 0;\n\n    // When only displaying the lines at the top, set top_end.  Used when\n    // window has scrolled down for msg_scrolled.\n    if (type == REDRAW_TOP)\n    {\n\tj = 0;\n\tfor (i = 0; i < wp->w_lines_valid; ++i)\n\t{\n\t    j += wp->w_lines[i].wl_size;\n\t    if (j >= wp->w_upd_rows)\n\t    {\n\t\ttop_end = j;\n\t\tbreak;\n\t    }\n\t}\n\tif (top_end == 0)\n\t    // not found (cannot happen?): redraw everything\n\t    type = NOT_VALID;\n\telse\n\t    // top area defined, the rest is VALID\n\t    type = VALID;\n    }\n\n    // Trick: we want to avoid clearing the screen twice.  screenclear() will\n    // set \"screen_cleared\" to TRUE.  The special value MAYBE (which is still\n    // non-zero and thus not FALSE) will indicate that screenclear() was not\n    // called.\n    if (screen_cleared)\n\tscreen_cleared = MAYBE;\n\n    // If there are no changes on the screen that require a complete redraw,\n    // handle three cases:\n    // 1: we are off the top of the screen by a few lines: scroll down\n    // 2: wp->w_topline is below wp->w_lines[0].wl_lnum: may scroll up\n    // 3: wp->w_topline is wp->w_lines[0].wl_lnum: find first entry in\n    //    w_lines[] that needs updating.\n    if ((type == VALID || type == SOME_VALID\n\t\t\t\t  || type == INVERTED || type == INVERTED_ALL)\n#ifdef FEAT_DIFF\n\t    && !wp->w_botfill && !wp->w_old_botfill\n#endif\n\t    )\n    {\n\tif (mod_top != 0\n\t\t&& wp->w_topline == mod_top\n\t\t&& (!wp->w_lines[0].wl_valid\n\t\t    || wp->w_topline <= wp->w_lines[0].wl_lnum))\n\t{\n\t    // w_topline is the first changed line and window is not scrolled,\n\t    // the scrolling from changed lines will be done further down.\n\t}\n\telse if (wp->w_lines[0].wl_valid\n\t\t&& (wp->w_topline < wp->w_lines[0].wl_lnum\n#ifdef FEAT_DIFF\n\t\t    || (wp->w_topline == wp->w_lines[0].wl_lnum\n\t\t\t&& wp->w_topfill > wp->w_old_topfill)\n#endif\n\t\t   ))\n\t{\n\t    // New topline is above old topline: May scroll down.\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(wp))\n\t    {\n\t\tlinenr_T ln;\n\n\t\t// count the number of lines we are off, counting a sequence\n\t\t// of folded lines as one\n\t\tj = 0;\n\t\tfor (ln = wp->w_topline; ln < wp->w_lines[0].wl_lnum; ++ln)\n\t\t{\n\t\t    ++j;\n\t\t    if (j >= wp->w_height - 2)\n\t\t\tbreak;\n\t\t    (void)hasFoldingWin(wp, ln, NULL, &ln, TRUE, NULL);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tj = wp->w_lines[0].wl_lnum - wp->w_topline;\n\t    if (j < wp->w_height - 2)\t\t// not too far off\n\t    {\n\t\ti = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);\n#ifdef FEAT_DIFF\n\t\t// insert extra lines for previously invisible filler lines\n\t\tif (wp->w_lines[0].wl_lnum != wp->w_topline)\n\t\t    i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)\n\t\t\t\t\t\t\t  - wp->w_old_topfill;\n#endif\n\t\tif (i < wp->w_height - 2)\t// less than a screen off\n\t\t{\n\t\t    // Try to insert the correct number of lines.\n\t\t    // If not the last window, delete the lines at the bottom.\n\t\t    // win_ins_lines may fail when the terminal can't do it.\n\t\t    if (i > 0)\n\t\t\tcheck_for_delay(FALSE);\n\t\t    if (win_ins_lines(wp, 0, i, FALSE, wp == firstwin) == OK)\n\t\t    {\n\t\t\tif (wp->w_lines_valid != 0)\n\t\t\t{\n\t\t\t    // Need to update rows that are new, stop at the\n\t\t\t    // first one that scrolled down.\n\t\t\t    top_end = i;\n\t\t\t    scrolled_down = TRUE;\n\n\t\t\t    // Move the entries that were scrolled, disable\n\t\t\t    // the entries for the lines to be redrawn.\n\t\t\t    if ((wp->w_lines_valid += j) > wp->w_height)\n\t\t\t\twp->w_lines_valid = wp->w_height;\n\t\t\t    for (idx = wp->w_lines_valid; idx - j >= 0; idx--)\n\t\t\t\twp->w_lines[idx] = wp->w_lines[idx - j];\n\t\t\t    while (idx >= 0)\n\t\t\t\twp->w_lines[idx--].wl_valid = FALSE;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tmid_start = 0;\t\t// redraw all lines\n\t\t}\n\t\telse\n\t\t    mid_start = 0;\t\t// redraw all lines\n\t    }\n\t    else\n\t\tmid_start = 0;\t\t// redraw all lines\n\t}\n\telse\n\t{\n\t    // New topline is at or below old topline: May scroll up.\n\t    // When topline didn't change, find first entry in w_lines[] that\n\t    // needs updating.\n\n\t    // try to find wp->w_topline in wp->w_lines[].wl_lnum\n\t    j = -1;\n\t    row = 0;\n\t    for (i = 0; i < wp->w_lines_valid; i++)\n\t    {\n\t\tif (wp->w_lines[i].wl_valid\n\t\t\t&& wp->w_lines[i].wl_lnum == wp->w_topline)\n\t\t{\n\t\t    j = i;\n\t\t    break;\n\t\t}\n\t\trow += wp->w_lines[i].wl_size;\n\t    }\n\t    if (j == -1)\n\t    {\n\t\t// if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all\n\t\t// lines\n\t\tmid_start = 0;\n\t    }\n\t    else\n\t    {\n\t\t// Try to delete the correct number of lines.\n\t\t// wp->w_topline is at wp->w_lines[i].wl_lnum.\n#ifdef FEAT_DIFF\n\t\t// If the topline didn't change, delete old filler lines,\n\t\t// otherwise delete filler lines of the new topline...\n\t\tif (wp->w_lines[0].wl_lnum == wp->w_topline)\n\t\t    row += wp->w_old_topfill;\n\t\telse\n\t\t    row += diff_check_fill(wp, wp->w_topline);\n\t\t// ... but don't delete new filler lines.\n\t\trow -= wp->w_topfill;\n#endif\n\t\tif (row > 0)\n\t\t{\n\t\t    check_for_delay(FALSE);\n\t\t    if (win_del_lines(wp, 0, row, FALSE, wp == firstwin, 0)\n\t\t\t\t\t\t\t\t\t == OK)\n\t\t\tbot_start = wp->w_height - row;\n\t\t    else\n\t\t\tmid_start = 0;\t\t// redraw all lines\n\t\t}\n\t\tif ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0)\n\t\t{\n\t\t    // Skip the lines (below the deleted lines) that are still\n\t\t    // valid and don't need redrawing.\tCopy their info\n\t\t    // upwards, to compensate for the deleted lines.  Set\n\t\t    // bot_start to the first row that needs redrawing.\n\t\t    bot_start = 0;\n\t\t    idx = 0;\n\t\t    for (;;)\n\t\t    {\n\t\t\twp->w_lines[idx] = wp->w_lines[j];\n\t\t\t// stop at line that didn't fit, unless it is still\n\t\t\t// valid (no lines deleted)\n\t\t\tif (row > 0 && bot_start + row\n\t\t\t\t + (int)wp->w_lines[j].wl_size > wp->w_height)\n\t\t\t{\n\t\t\t    wp->w_lines_valid = idx + 1;\n\t\t\t    break;\n\t\t\t}\n\t\t\tbot_start += wp->w_lines[idx++].wl_size;\n\n\t\t\t// stop at the last valid entry in w_lines[].wl_size\n\t\t\tif (++j >= wp->w_lines_valid)\n\t\t\t{\n\t\t\t    wp->w_lines_valid = idx;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n#ifdef FEAT_DIFF\n\t\t    // Correct the first entry for filler lines at the top\n\t\t    // when it won't get updated below.\n\t\t    if (wp->w_p_diff && bot_start > 0)\n\t\t\twp->w_lines[0].wl_size =\n\t\t\t    plines_win_nofill(wp, wp->w_topline, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n#endif\n\t\t}\n\t    }\n\t}\n\n\t// When starting redraw in the first line, redraw all lines.  When\n\t// there is only one window it's probably faster to clear the screen\n\t// first.\n\tif (mid_start == 0)\n\t{\n\t    mid_end = wp->w_height;\n\t    if (ONE_WINDOW && !WIN_IS_POPUP(wp))\n\t    {\n\t\t// Clear the screen when it was not done by win_del_lines() or\n\t\t// win_ins_lines() above, \"screen_cleared\" is FALSE or MAYBE\n\t\t// then.\n\t\tif (screen_cleared != TRUE)\n\t\t    screenclear();\n\t\t// The screen was cleared, redraw the tab pages line.\n\t\tif (redraw_tabline)\n\t\t    draw_tabline();\n\t    }\n\t}\n\n\t// When win_del_lines() or win_ins_lines() caused the screen to be\n\t// cleared (only happens for the first window) or when screenclear()\n\t// was called directly above, \"must_redraw\" will have been set to\n\t// NOT_VALID, need to reset it here to avoid redrawing twice.\n\tif (screen_cleared == TRUE)\n\t    must_redraw = 0;\n    }\n    else\n    {\n\t// Not VALID or INVERTED: redraw all lines.\n\tmid_start = 0;\n\tmid_end = wp->w_height;\n    }\n\n    if (type == SOME_VALID)\n    {\n\t// SOME_VALID: redraw all lines.\n\tmid_start = 0;\n\tmid_end = wp->w_height;\n\ttype = NOT_VALID;\n    }\n\n    // check if we are updating or removing the inverted part\n    if ((VIsual_active && buf == curwin->w_buffer)\n\t    || (wp->w_old_cursor_lnum != 0 && type != NOT_VALID))\n    {\n\tlinenr_T    from, to;\n\n\tif (VIsual_active)\n\t{\n\t    if (VIsual_active\n\t\t    && (VIsual_mode != wp->w_old_visual_mode\n\t\t\t|| type == INVERTED_ALL))\n\t    {\n\t\t// If the type of Visual selection changed, redraw the whole\n\t\t// selection.  Also when the ownership of the X selection is\n\t\t// gained or lost.\n\t\tif (curwin->w_cursor.lnum < VIsual.lnum)\n\t\t{\n\t\t    from = curwin->w_cursor.lnum;\n\t\t    to = VIsual.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    from = VIsual.lnum;\n\t\t    to = curwin->w_cursor.lnum;\n\t\t}\n\t\t// redraw more when the cursor moved as well\n\t\tif (wp->w_old_cursor_lnum < from)\n\t\t    from = wp->w_old_cursor_lnum;\n\t\tif (wp->w_old_cursor_lnum > to)\n\t\t    to = wp->w_old_cursor_lnum;\n\t\tif (wp->w_old_visual_lnum < from)\n\t\t    from = wp->w_old_visual_lnum;\n\t\tif (wp->w_old_visual_lnum > to)\n\t\t    to = wp->w_old_visual_lnum;\n\t    }\n\t    else\n\t    {\n\t\t// Find the line numbers that need to be updated: The lines\n\t\t// between the old cursor position and the current cursor\n\t\t// position.  Also check if the Visual position changed.\n\t\tif (curwin->w_cursor.lnum < wp->w_old_cursor_lnum)\n\t\t{\n\t\t    from = curwin->w_cursor.lnum;\n\t\t    to = wp->w_old_cursor_lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    from = wp->w_old_cursor_lnum;\n\t\t    to = curwin->w_cursor.lnum;\n\t\t    if (from == 0)\t// Visual mode just started\n\t\t\tfrom = to;\n\t\t}\n\n\t\tif (VIsual.lnum != wp->w_old_visual_lnum\n\t\t\t\t\t|| VIsual.col != wp->w_old_visual_col)\n\t\t{\n\t\t    if (wp->w_old_visual_lnum < from\n\t\t\t\t\t\t&& wp->w_old_visual_lnum != 0)\n\t\t\tfrom = wp->w_old_visual_lnum;\n\t\t    if (wp->w_old_visual_lnum > to)\n\t\t\tto = wp->w_old_visual_lnum;\n\t\t    if (VIsual.lnum < from)\n\t\t\tfrom = VIsual.lnum;\n\t\t    if (VIsual.lnum > to)\n\t\t\tto = VIsual.lnum;\n\t\t}\n\t    }\n\n\t    // If in block mode and changed column or curwin->w_curswant:\n\t    // update all lines.\n\t    // First compute the actual start and end column.\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tcolnr_T\t    fromc, toc;\n#if defined(FEAT_LINEBREAK)\n\t\tint\t    save_ve_flags = curwin->w_ve_flags;\n\n\t\tif (curwin->w_p_lbr)\n\t\t    curwin->w_ve_flags = VE_ALL;\n#endif\n\t\tgetvcols(wp, &VIsual, &curwin->w_cursor, &fromc, &toc);\n\t\t++toc;\n#if defined(FEAT_LINEBREAK)\n\t\tcurwin->w_ve_flags = save_ve_flags;\n#endif\n\t\t// Highlight to the end of the line, unless 'virtualedit' has\n\t\t// \"block\".\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t{\n\t\t    if (get_ve_flags() & VE_BLOCK)\n\t\t    {\n\t\t\tpos_T\t    pos;\n\t\t\tint\t    cursor_above =\n\t\t\t\t\t   curwin->w_cursor.lnum < VIsual.lnum;\n\n\t\t\t// Need to find the longest line.\n\t\t\ttoc = 0;\n\t\t\tpos.coladd = 0;\n\t\t\tfor (pos.lnum = curwin->w_cursor.lnum; cursor_above\n\t\t\t\t\t? pos.lnum <= VIsual.lnum\n\t\t\t\t\t: pos.lnum >= VIsual.lnum;\n\t\t\t\t\t     pos.lnum += cursor_above ? 1 : -1)\n\t\t\t{\n\t\t\t    colnr_T t;\n\n\t\t\t    pos.col = (int)STRLEN(ml_get_buf(wp->w_buffer,\n\t\t\t\t\t\t\t     pos.lnum, FALSE));\n\t\t\t    getvvcol(wp, &pos, NULL, NULL, &t);\n\t\t\t    if (toc < t)\n\t\t\t\ttoc = t;\n\t\t\t}\n\t\t\t++toc;\n\t\t    }\n\t\t    else\n\t\t\ttoc = MAXCOL;\n\t\t}\n\n\t\tif (fromc != wp->w_old_cursor_fcol\n\t\t\t|| toc != wp->w_old_cursor_lcol)\n\t\t{\n\t\t    if (from > VIsual.lnum)\n\t\t\tfrom = VIsual.lnum;\n\t\t    if (to < VIsual.lnum)\n\t\t\tto = VIsual.lnum;\n\t\t}\n\t\twp->w_old_cursor_fcol = fromc;\n\t\twp->w_old_cursor_lcol = toc;\n\t    }\n\t}\n\telse\n\t{\n\t    // Use the line numbers of the old Visual area.\n\t    if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum)\n\t    {\n\t\tfrom = wp->w_old_cursor_lnum;\n\t\tto = wp->w_old_visual_lnum;\n\t    }\n\t    else\n\t    {\n\t\tfrom = wp->w_old_visual_lnum;\n\t\tto = wp->w_old_cursor_lnum;\n\t    }\n\t}\n\n\t// There is no need to update lines above the top of the window.\n\tif (from < wp->w_topline)\n\t    from = wp->w_topline;\n\n\t// If we know the value of w_botline, use it to restrict the update to\n\t// the lines that are visible in the window.\n\tif (wp->w_valid & VALID_BOTLINE)\n\t{\n\t    if (from >= wp->w_botline)\n\t\tfrom = wp->w_botline - 1;\n\t    if (to >= wp->w_botline)\n\t\tto = wp->w_botline - 1;\n\t}\n\n\t// Find the minimal part to be updated.\n\t// Watch out for scrolling that made entries in w_lines[] invalid.\n\t// E.g., CTRL-U makes the first half of w_lines[] invalid and sets\n\t// top_end; need to redraw from top_end to the \"to\" line.\n\t// A middle mouse click with a Visual selection may change the text\n\t// above the Visual area and reset wl_valid, do count these for\n\t// mid_end (in srow).\n\tif (mid_start > 0)\n\t{\n\t    lnum = wp->w_topline;\n\t    idx = 0;\n\t    srow = 0;\n\t    if (scrolled_down)\n\t\tmid_start = top_end;\n\t    else\n\t\tmid_start = 0;\n\t    while (lnum < from && idx < wp->w_lines_valid)\t// find start\n\t    {\n\t\tif (wp->w_lines[idx].wl_valid)\n\t\t    mid_start += wp->w_lines[idx].wl_size;\n\t\telse if (!scrolled_down)\n\t\t    srow += wp->w_lines[idx].wl_size;\n\t\t++idx;\n# ifdef FEAT_FOLDING\n\t\tif (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)\n\t\t    lnum = wp->w_lines[idx].wl_lnum;\n\t\telse\n# endif\n\t\t    ++lnum;\n\t    }\n\t    srow += mid_start;\n\t    mid_end = wp->w_height;\n\t    for ( ; idx < wp->w_lines_valid; ++idx)\t\t// find end\n\t    {\n\t\tif (wp->w_lines[idx].wl_valid\n\t\t\t&& wp->w_lines[idx].wl_lnum >= to + 1)\n\t\t{\n\t\t    // Only update until first row of this line\n\t\t    mid_end = srow;\n\t\t    break;\n\t\t}\n\t\tsrow += wp->w_lines[idx].wl_size;\n\t    }\n\t}\n    }\n\n    if (VIsual_active && buf == curwin->w_buffer)\n    {\n\twp->w_old_visual_mode = VIsual_mode;\n\twp->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\twp->w_old_visual_lnum = VIsual.lnum;\n\twp->w_old_visual_col = VIsual.col;\n\twp->w_old_curswant = curwin->w_curswant;\n    }\n    else\n    {\n\twp->w_old_visual_mode = 0;\n\twp->w_old_cursor_lnum = 0;\n\twp->w_old_visual_lnum = 0;\n\twp->w_old_visual_col = 0;\n    }\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)\n    // reset got_int, otherwise regexp won't work\n    save_got_int = got_int;\n    got_int = 0;\n#endif\n#ifdef SYN_TIME_LIMIT\n    // Set the time limit to 'redrawtime'.\n    profile_setlimit(p_rdt, &syntax_tm);\n    syn_set_timeout(&syntax_tm);\n#endif\n#ifdef FEAT_FOLDING\n    win_foldinfo.fi_level = 0;\n#endif\n\n#ifdef FEAT_MENU\n    // Draw the window toolbar, if there is one.\n    // TODO: only when needed.\n    if (winbar_height(wp) > 0)\n\tredraw_win_toolbar(wp);\n#endif\n\n    // Update all the window rows.\n    idx = 0;\t\t// first entry in w_lines[].wl_size\n    row = 0;\n    srow = 0;\n    lnum = wp->w_topline;\t// first line shown in window\n    for (;;)\n    {\n\t// stop updating when reached the end of the window (check for _past_\n\t// the end of the window is at the end of the loop)\n\tif (row == wp->w_height)\n\t{\n\t    didline = TRUE;\n\t    break;\n\t}\n\n\t// stop updating when hit the end of the file\n\tif (lnum > buf->b_ml.ml_line_count)\n\t{\n\t    eof = TRUE;\n\t    break;\n\t}\n\n\t// Remember the starting row of the line that is going to be dealt\n\t// with.  It is used further down when the line doesn't fit.\n\tsrow = row;\n\n\t// Update a line when it is in an area that needs updating, when it\n\t// has changes or w_lines[idx] is invalid.\n\t// \"bot_start\" may be halfway a wrapped line after using\n\t// win_del_lines(), check if the current line includes it.\n\t// When syntax folding is being used, the saved syntax states will\n\t// already have been updated, we can't see where the syntax state is\n\t// the same again, just update until the end of the window.\n\tif (row < top_end\n\t\t|| (row >= mid_start && row < mid_end)\n#ifdef FEAT_SEARCH_EXTRA\n\t\t|| top_to_mod\n#endif\n\t\t|| idx >= wp->w_lines_valid\n\t\t|| (row + wp->w_lines[idx].wl_size > bot_start)\n\t\t|| (mod_top != 0\n\t\t    && (lnum == mod_top\n\t\t\t|| (lnum >= mod_top\n\t\t\t    && (lnum < mod_bot\n#ifdef FEAT_SYN_HL\n\t\t\t\t|| did_update == DID_FOLD\n\t\t\t\t|| (did_update == DID_LINE\n\t\t\t\t    && syntax_present(wp)\n\t\t\t\t    && (\n# ifdef FEAT_FOLDING\n\t\t\t\t\t(foldmethodIsSyntax(wp)\n\t\t\t\t\t\t      && hasAnyFolding(wp)) ||\n# endif\n\t\t\t\t\tsyntax_check_changed(lnum)))\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n\t\t\t\t// match in fixed position might need redraw\n\t\t\t\t// if lines were inserted or deleted\n\t\t\t\t|| (wp->w_match_head != NULL\n\t\t\t\t\t\t    && buf->b_mod_xlines != 0)\n#endif\n\t\t\t\t))))\n#ifdef FEAT_SYN_HL\n\t\t|| (wp->w_p_cul && (lnum == wp->w_cursor.lnum\n\t\t\t\t\t     || lnum == wp->w_last_cursorline))\n#endif\n\t\t\t\t)\n\t{\n#ifdef FEAT_SEARCH_EXTRA\n\t    if (lnum == mod_top)\n\t\ttop_to_mod = FALSE;\n#endif\n\n\t    // When at start of changed lines: May scroll following lines\n\t    // up or down to minimize redrawing.\n\t    // Don't do this when the change continues until the end.\n\t    // Don't scroll when dollar_vcol >= 0, keep the \"$\".\n\t    // Don't scroll when redrawing the top, scrolled already above.\n\t    if (lnum == mod_top\n\t\t    && mod_bot != MAXLNUM\n\t\t    && !(dollar_vcol >= 0 && mod_bot == mod_top + 1)\n\t\t    && row >= top_end)\n\t    {\n\t\tint\t\told_rows = 0;\n\t\tint\t\tnew_rows = 0;\n\t\tint\t\txtra_rows;\n\t\tlinenr_T\tl;\n\n\t\t// Count the old number of window rows, using w_lines[], which\n\t\t// should still contain the sizes for the lines as they are\n\t\t// currently displayed.\n\t\tfor (i = idx; i < wp->w_lines_valid; ++i)\n\t\t{\n\t\t    // Only valid lines have a meaningful wl_lnum.  Invalid\n\t\t    // lines are part of the changed area.\n\t\t    if (wp->w_lines[i].wl_valid\n\t\t\t    && wp->w_lines[i].wl_lnum == mod_bot)\n\t\t\tbreak;\n\t\t    old_rows += wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t\t    if (wp->w_lines[i].wl_valid\n\t\t\t    && wp->w_lines[i].wl_lastlnum + 1 == mod_bot)\n\t\t    {\n\t\t\t// Must have found the last valid entry above mod_bot.\n\t\t\t// Add following invalid entries.\n\t\t\t++i;\n\t\t\twhile (i < wp->w_lines_valid\n\t\t\t\t\t\t  && !wp->w_lines[i].wl_valid)\n\t\t\t    old_rows += wp->w_lines[i++].wl_size;\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\t}\n\n\t\tif (i >= wp->w_lines_valid)\n\t\t{\n\t\t    // We can't find a valid line below the changed lines,\n\t\t    // need to redraw until the end of the window.\n\t\t    // Inserting/deleting lines has no use.\n\t\t    bot_start = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Able to count old number of rows: Count new window\n\t\t    // rows, and may insert/delete lines\n\t\t    j = idx;\n\t\t    for (l = lnum; l < mod_bot; ++l)\n\t\t    {\n#ifdef FEAT_FOLDING\n\t\t\tif (hasFoldingWin(wp, l, NULL, &l, TRUE, NULL))\n\t\t\t    ++new_rows;\n\t\t\telse\n#endif\n\t\t\t{\n#ifdef FEAT_DIFF\n\t\t\t    if (l == wp->w_topline)\n\t\t\t\tnew_rows += plines_win_nofill(wp, l, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\t\t    else\n#endif\n\t\t\t\tnew_rows += plines_win(wp, l, TRUE);\n\t\t\t}\n\t\t\t++j;\n\t\t\tif (new_rows > wp->w_height - row - 2)\n\t\t\t{\n\t\t\t    // it's getting too much, must redraw the rest\n\t\t\t    new_rows = 9999;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    xtra_rows = new_rows - old_rows;\n\t\t    if (xtra_rows < 0)\n\t\t    {\n\t\t\t// May scroll text up.  If there is not enough\n\t\t\t// remaining text or scrolling fails, must redraw the\n\t\t\t// rest.  If scrolling works, must redraw the text\n\t\t\t// below the scrolled text.\n\t\t\tif (row - xtra_rows >= wp->w_height - 2)\n\t\t\t    mod_bot = MAXLNUM;\n\t\t\telse\n\t\t\t{\n\t\t\t    check_for_delay(FALSE);\n\t\t\t    if (win_del_lines(wp, row,\n\t\t\t\t\t  -xtra_rows, FALSE, FALSE, 0) == FAIL)\n\t\t\t\tmod_bot = MAXLNUM;\n\t\t\t    else\n\t\t\t\tbot_start = wp->w_height + xtra_rows;\n\t\t\t}\n\t\t    }\n\t\t    else if (xtra_rows > 0)\n\t\t    {\n\t\t\t// May scroll text down.  If there is not enough\n\t\t\t// remaining text of scrolling fails, must redraw the\n\t\t\t// rest.\n\t\t\tif (row + xtra_rows >= wp->w_height - 2)\n\t\t\t    mod_bot = MAXLNUM;\n\t\t\telse\n\t\t\t{\n\t\t\t    check_for_delay(FALSE);\n\t\t\t    if (win_ins_lines(wp, row + old_rows,\n\t\t\t\t\t     xtra_rows, FALSE, FALSE) == FAIL)\n\t\t\t\tmod_bot = MAXLNUM;\n\t\t\t    else if (top_end > row + old_rows)\n\t\t\t\t// Scrolled the part at the top that requires\n\t\t\t\t// updating down.\n\t\t\t\ttop_end += xtra_rows;\n\t\t\t}\n\t\t    }\n\n\t\t    // When not updating the rest, may need to move w_lines[]\n\t\t    // entries.\n\t\t    if (mod_bot != MAXLNUM && i != j)\n\t\t    {\n\t\t\tif (j < i)\n\t\t\t{\n\t\t\t    int x = row + new_rows;\n\n\t\t\t    // move entries in w_lines[] upwards\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t// stop at last valid entry in w_lines[]\n\t\t\t\tif (i >= wp->w_lines_valid)\n\t\t\t\t{\n\t\t\t\t    wp->w_lines_valid = j;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\twp->w_lines[j] = wp->w_lines[i];\n\t\t\t\t// stop at a line that won't fit\n\t\t\t\tif (x + (int)wp->w_lines[j].wl_size\n\t\t\t\t\t\t\t   > wp->w_height)\n\t\t\t\t{\n\t\t\t\t    wp->w_lines_valid = j + 1;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tx += wp->w_lines[j++].wl_size;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (bot_start > x)\n\t\t\t\tbot_start = x;\n\t\t\t}\n\t\t\telse // j > i\n\t\t\t{\n\t\t\t    // move entries in w_lines[] downwards\n\t\t\t    j -= i;\n\t\t\t    wp->w_lines_valid += j;\n\t\t\t    if (wp->w_lines_valid > wp->w_height)\n\t\t\t\twp->w_lines_valid = wp->w_height;\n\t\t\t    for (i = wp->w_lines_valid; i - j >= idx; --i)\n\t\t\t\twp->w_lines[i] = wp->w_lines[i - j];\n\n\t\t\t    // The w_lines[] entries for inserted lines are\n\t\t\t    // now invalid, but wl_size may be used above.\n\t\t\t    // Reset to zero.\n\t\t\t    while (i >= idx)\n\t\t\t    {\n\t\t\t\twp->w_lines[i].wl_size = 0;\n\t\t\t\twp->w_lines[i--].wl_valid = FALSE;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n#ifdef FEAT_FOLDING\n\t    // When lines are folded, display one line for all of them.\n\t    // Otherwise, display normally (can be several display lines when\n\t    // 'wrap' is on).\n\t    fold_count = foldedCount(wp, lnum, &win_foldinfo);\n\t    if (fold_count != 0)\n\t    {\n\t\tfold_line(wp, fold_count, &win_foldinfo, lnum, row);\n\t\t++row;\n\t\t--fold_count;\n\t\twp->w_lines[idx].wl_folded = TRUE;\n\t\twp->w_lines[idx].wl_lastlnum = lnum + fold_count;\n# ifdef FEAT_SYN_HL\n\t\tdid_update = DID_FOLD;\n# endif\n\t    }\n\t    else\n#endif\n\t    if (idx < wp->w_lines_valid\n\t\t    && wp->w_lines[idx].wl_valid\n\t\t    && wp->w_lines[idx].wl_lnum == lnum\n\t\t    && lnum > wp->w_topline\n\t\t    && !(dy_flags & (DY_LASTLINE | DY_TRUNCATE))\n\t\t    && !WIN_IS_POPUP(wp)\n\t\t    && srow + wp->w_lines[idx].wl_size > wp->w_height\n#ifdef FEAT_DIFF\n\t\t    && diff_check_fill(wp, lnum) == 0\n#endif\n\t\t    )\n\t    {\n\t\t// This line is not going to fit.  Don't draw anything here,\n\t\t// will draw \"@  \" lines below.\n\t\trow = wp->w_height + 1;\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_SEARCH_EXTRA\n\t\tprepare_search_hl(wp, &screen_search_hl, lnum);\n#endif\n#ifdef FEAT_SYN_HL\n\t\t// Let the syntax stuff know we skipped a few lines.\n\t\tif (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum\n\t\t\t\t\t\t       && syntax_present(wp))\n\t\t    syntax_end_parsing(syntax_last_parsed + 1);\n#endif\n\n\t\t// Display one line.\n\t\trow = win_line(wp, lnum, srow, wp->w_height,\n\t\t\t\t\t\t\t  mod_top == 0, FALSE);\n\n#ifdef FEAT_FOLDING\n\t\twp->w_lines[idx].wl_folded = FALSE;\n\t\twp->w_lines[idx].wl_lastlnum = lnum;\n#endif\n#ifdef FEAT_SYN_HL\n\t\tdid_update = DID_LINE;\n\t\tsyntax_last_parsed = lnum;\n#endif\n\t    }\n\n\t    wp->w_lines[idx].wl_lnum = lnum;\n\t    wp->w_lines[idx].wl_valid = TRUE;\n\n\t    // Past end of the window or end of the screen. Note that after\n\t    // resizing wp->w_height may be end up too big. That's a problem\n\t    // elsewhere, but prevent a crash here.\n\t    if (row > wp->w_height || row + wp->w_winrow >= Rows)\n\t    {\n\t\t// we may need the size of that too long line later on\n\t\tif (dollar_vcol == -1)\n\t\t    wp->w_lines[idx].wl_size = plines_win(wp, lnum, TRUE);\n\t\t++idx;\n\t\tbreak;\n\t    }\n\t    if (dollar_vcol == -1)\n\t\twp->w_lines[idx].wl_size = row - srow;\n\t    ++idx;\n#ifdef FEAT_FOLDING\n\t    lnum += fold_count + 1;\n#else\n\t    ++lnum;\n#endif\n\t}\n\telse\n\t{\n\t    if (wp->w_p_rnu)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// 'relativenumber' set: The text doesn't need to be drawn, but\n\t\t// the number column nearly always does.\n\t\tfold_count = foldedCount(wp, lnum, &win_foldinfo);\n\t\tif (fold_count != 0)\n\t\t    fold_line(wp, fold_count, &win_foldinfo, lnum, row);\n\t\telse\n#endif\n\t\t    (void)win_line(wp, lnum, srow, wp->w_height, TRUE, TRUE);\n\t    }\n\n\t    // This line does not need to be drawn, advance to the next one.\n\t    row += wp->w_lines[idx++].wl_size;\n\t    if (row > wp->w_height)\t// past end of screen\n\t\tbreak;\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[idx - 1].wl_lastlnum + 1;\n#else\n\t    ++lnum;\n#endif\n#ifdef FEAT_SYN_HL\n\t    did_update = DID_NONE;\n#endif\n\t}\n\n\tif (lnum > buf->b_ml.ml_line_count)\n\t{\n\t    eof = TRUE;\n\t    break;\n\t}\n    }\n\n    // End of loop over all window lines.\n\n#ifdef FEAT_VTP\n    // Rewrite the character at the end of the screen line.\n    // See the version that was fixed.\n    if (use_vtp() && get_conpty_fix_type() < 1)\n    {\n\tint i;\n\n\tfor (i = 0; i < Rows; ++i)\n\t    if (enc_utf8)\n\t\tif ((*mb_off2cells)(LineOffset[i] + Columns - 2,\n\t\t\t\t\t   LineOffset[i] + screen_Columns) > 1)\n\t\t    screen_draw_rectangle(i, Columns - 2, 1, 2, FALSE);\n\t\telse\n\t\t    screen_draw_rectangle(i, Columns - 1, 1, 1, FALSE);\n\t    else\n\t\tscreen_char(LineOffset[i] + Columns - 1, i, Columns - 1);\n    }\n#endif\n\n    if (idx > wp->w_lines_valid)\n\twp->w_lines_valid = idx;\n\n#ifdef FEAT_SYN_HL\n    // Let the syntax stuff know we stop parsing here.\n    if (syntax_last_parsed != 0 && syntax_present(wp))\n\tsyntax_end_parsing(syntax_last_parsed + 1);\n#endif\n\n    // If we didn't hit the end of the file, and we didn't finish the last\n    // line we were working on, then the line didn't fit.\n    wp->w_empty_rows = 0;\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (!eof && !didline)\n    {\n\tif (lnum == wp->w_topline)\n\t{\n\t    // Single line that does not fit!\n\t    // Don't overwrite it, it can be edited.\n\t    wp->w_botline = lnum + 1;\n\t}\n#ifdef FEAT_DIFF\n\telse if (diff_check_fill(wp, lnum) >= wp->w_height - srow)\n\t{\n\t    // Window ends in filler lines.\n\t    wp->w_botline = lnum;\n\t    wp->w_filler_rows = wp->w_height - srow;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\telse if (WIN_IS_POPUP(wp))\n\t{\n\t    // popup line that doesn't fit is left as-is\n\t    wp->w_botline = lnum;\n\t}\n#endif\n\telse if (dy_flags & DY_TRUNCATE)\t// 'display' has \"truncate\"\n\t{\n\t    int scr_row = W_WINROW(wp) + wp->w_height - 1;\n\n\t    // Last line isn't finished: Display \"@@@\" in the last screen line.\n\t    screen_puts_len((char_u *)\"@@\", 2, scr_row, wp->w_wincol,\n\t\t\t\t\t\t\t      HL_ATTR(HLF_AT));\n\t    screen_fill(scr_row, scr_row + 1,\n\t\t    (int)wp->w_wincol + 2, (int)W_ENDCOL(wp),\n\t\t    '@', ' ', HL_ATTR(HLF_AT));\n\t    set_empty_rows(wp, srow);\n\t    wp->w_botline = lnum;\n\t}\n\telse if (dy_flags & DY_LASTLINE)\t// 'display' has \"lastline\"\n\t{\n\t    // Last line isn't finished: Display \"@@@\" at the end.\n\t    screen_fill(W_WINROW(wp) + wp->w_height - 1,\n\t\t    W_WINROW(wp) + wp->w_height,\n\t\t    (int)W_ENDCOL(wp) - 3, (int)W_ENDCOL(wp),\n\t\t    '@', '@', HL_ATTR(HLF_AT));\n\t    set_empty_rows(wp, srow);\n\t    wp->w_botline = lnum;\n\t}\n\telse\n\t{\n\t    win_draw_end(wp, '@', ' ', TRUE, srow, wp->w_height, HLF_AT);\n\t    wp->w_botline = lnum;\n\t}\n    }\n    else\n    {\n\tdraw_vsep_win(wp, row);\n\tif (eof)\t\t// we hit the end of the file\n\t{\n\t    wp->w_botline = buf->b_ml.ml_line_count + 1;\n#ifdef FEAT_DIFF\n\t    j = diff_check_fill(wp, wp->w_botline);\n\t    if (j > 0 && !wp->w_botfill)\n\t    {\n\t\t// Display filler lines at the end of the file.\n\t\tif (char2cells(fill_diff) > 1)\n\t\t    i = '-';\n\t\telse\n\t\t    i = fill_diff;\n\t\tif (row + j > wp->w_height)\n\t\t    j = wp->w_height - row;\n\t\twin_draw_end(wp, i, i, TRUE, row, row + (int)j, HLF_DED);\n\t\trow += j;\n\t    }\n#endif\n\t}\n\telse if (dollar_vcol == -1)\n\t    wp->w_botline = lnum;\n\n\t// Make sure the rest of the screen is blank\n\t// write the 'fill_eob' character to rows that aren't part of the file\n\tif (WIN_IS_POPUP(wp))\n\t    win_draw_end(wp, ' ', ' ', FALSE, row, wp->w_height, HLF_AT);\n\telse\n\t    win_draw_end(wp, fill_eob, ' ', FALSE, row, wp->w_height, HLF_EOB);\n    }\n\n#ifdef SYN_TIME_LIMIT\n    syn_set_timeout(NULL);\n#endif\n\n    // Reset the type of redrawing required, the window has been updated.\n    wp->w_redr_type = 0;\n#ifdef FEAT_DIFF\n    wp->w_old_topfill = wp->w_topfill;\n    wp->w_old_botfill = wp->w_botfill;\n#endif\n\n    if (dollar_vcol == -1)\n    {\n\t// There is a trick with w_botline.  If we invalidate it on each\n\t// change that might modify it, this will cause a lot of expensive\n\t// calls to plines() in update_topline() each time.  Therefore the\n\t// value of w_botline is often approximated, and this value is used to\n\t// compute the value of w_topline.  If the value of w_botline was\n\t// wrong, check that the value of w_topline is correct (cursor is on\n\t// the visible part of the text).  If it's not, we need to redraw\n\t// again.  Mostly this just means scrolling up a few lines, so it\n\t// doesn't look too bad.  Only do this for the current window (where\n\t// changes are relevant).\n\twp->w_valid |= VALID_BOTLINE;\n\tif (wp == curwin && wp->w_botline != old_botline && !recursive)\n\t{\n\t    win_T\t*wwp;\n#if defined(FEAT_CONCEAL)\n\t    linenr_T\told_topline = wp->w_topline;\n\t    int\t\tnew_wcol = wp->w_wcol;\n#endif\n\t    recursive = TRUE;\n\t    curwin->w_valid &= ~VALID_TOPLINE;\n\t    update_topline();\t// may invalidate w_botline again\n\n#if defined(FEAT_CONCEAL)\n\t    if (old_wcol != new_wcol && (wp->w_valid & (VALID_WCOL|VALID_WROW))\n\t\t\t\t\t\t    != (VALID_WCOL|VALID_WROW))\n\t    {\n\t\t// A win_line() call applied a fix to screen cursor column to\n\t\t// accommodate concealment of cursor line, but in this call to\n\t\t// update_topline() the cursor's row or column got invalidated.\n\t\t// If they are left invalid, setcursor() will recompute them\n\t\t// but there won't be any further win_line() call to re-fix the\n\t\t// column and the cursor will end up misplaced.  So we call\n\t\t// cursor validation now and reapply the fix again (or call\n\t\t// win_line() to do it for us).\n\t\tvalidate_cursor();\n\t\tif (wp->w_wcol == old_wcol && wp->w_wrow == old_wrow\n\t\t\t\t\t       && old_topline == wp->w_topline)\n\t\t    wp->w_wcol = new_wcol;\n\t\telse\n\t\t    redrawWinline(wp, wp->w_cursor.lnum);\n\t    }\n#endif\n\t    // New redraw either due to updated topline or due to wcol fix.\n\t    if (wp->w_redr_type != 0)\n\t    {\n\t\t// Don't update for changes in buffer again.\n\t\ti = curbuf->b_mod_set;\n\t\tcurbuf->b_mod_set = FALSE;\n\t\tj = curbuf->b_mod_xlines;\n\t\tcurbuf->b_mod_xlines = 0;\n\t\twin_update(curwin);\n\t\tcurbuf->b_mod_set = i;\n\t\tcurbuf->b_mod_xlines = j;\n\t    }\n\t    // Other windows might have w_redr_type raised in update_topline().\n\t    must_redraw = 0;\n\t    FOR_ALL_WINDOWS(wwp)\n\t\tif (wwp->w_redr_type > must_redraw)\n\t\t    must_redraw = wwp->w_redr_type;\n\t    recursive = FALSE;\n\t}\n    }\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)\n    // restore got_int, unless CTRL-C was hit while redrawing\n    if (!got_int)\n\tgot_int = save_got_int;\n#endif\n}\n\n#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GUI)\n/*\n * Prepare for updating one or more windows.\n * Caller must check for \"updating_screen\" already set to avoid recursiveness.\n */\n    static void\nupdate_prepare(void)\n{\n    cursor_off();\n    updating_screen = TRUE;\n#ifdef FEAT_GUI\n    // Remove the cursor before starting to do anything, because scrolling may\n    // make it difficult to redraw the text under it.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n    start_search_hl();\n#endif\n#ifdef FEAT_PROP_POPUP\n    // Update popup_mask if needed.\n    may_update_popup_mask(must_redraw);\n#endif\n}\n\n/*\n * Finish updating one or more windows.\n */\n    static void\nupdate_finish(void)\n{\n    if (redraw_cmdline || redraw_mode)\n\tshowmode();\n\n# ifdef FEAT_SEARCH_EXTRA\n    end_search_hl();\n# endif\n\n    after_updating_screen(TRUE);\n\n# ifdef FEAT_GUI\n    // Redraw the cursor and update the scrollbars when all screen updating is\n    // done.\n    if (gui.in_use)\n    {\n\tout_flush_cursor(FALSE, FALSE);\n\tgui_update_scrollbars(FALSE);\n    }\n# endif\n}\n#endif\n\n#if defined(FEAT_NETBEANS_INTG) || defined(PROTO)\n    void\nupdate_debug_sign(buf_T *buf, linenr_T lnum)\n{\n    win_T\t*wp;\n    int\t\tdoit = FALSE;\n\n# ifdef FEAT_FOLDING\n    win_foldinfo.fi_level = 0;\n# endif\n\n    // update/delete a specific sign\n    redraw_buf_line_later(buf, lnum);\n\n    // check if it resulted in the need to redraw a window\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_redr_type != 0)\n\t    doit = TRUE;\n\n    // Return when there is nothing to do, screen updating is already\n    // happening (recursive call), messages on the screen or still starting up.\n    if (!doit || updating_screen\n\t    || State == ASKMORE || State == HITRETURN\n\t    || msg_scrolled\n#ifdef FEAT_GUI\n\t    || gui.starting\n#endif\n\t    || starting)\n\treturn;\n\n    // update all windows that need updating\n    update_prepare();\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_redr_type != 0)\n\t    win_update(wp);\n\tif (wp->w_redr_status)\n\t    win_redr_status(wp, FALSE);\n    }\n\n    update_finish();\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Update a single window, its status line and maybe the command line msg.\n * Used for the GUI scrollbar.\n */\n    void\nupdateWindow(win_T *wp)\n{\n    // return if already busy updating\n    if (updating_screen)\n\treturn;\n\n    update_prepare();\n\n#ifdef FEAT_CLIPBOARD\n    // When Visual area changed, may have to update selection.\n    if (clip_star.available && clip_isautosel_star())\n\tclip_update_selection(&clip_star);\n    if (clip_plus.available && clip_isautosel_plus())\n\tclip_update_selection(&clip_plus);\n#endif\n\n    win_update(wp);\n\n    // When the screen was cleared redraw the tab pages line.\n    if (redraw_tabline)\n\tdraw_tabline();\n\n    if (wp->w_redr_status\n# ifdef FEAT_CMDL_INFO\n\t    || p_ru\n# endif\n# ifdef FEAT_STL_OPT\n\t    || *p_stl != NUL || *wp->w_p_stl != NUL\n# endif\n\t    )\n\twin_redr_status(wp, FALSE);\n\n#ifdef FEAT_PROP_POPUP\n    // Display popup windows on top of everything.\n    update_popups(win_update);\n#endif\n\n    update_finish();\n}\n#endif\n\n#if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * Redraw as soon as possible.  When the command line is not scrolled redraw\n * right away and restore what was on the command line.\n * Return a code indicating what happened.\n */\n    int\nredraw_asap(int type)\n{\n    int\t\trows;\n    int\t\tcols = screen_Columns;\n    int\t\tr;\n    int\t\tret = 0;\n    schar_T\t*screenline;\t// copy from ScreenLines[]\n    sattr_T\t*screenattr;\t// copy from ScreenAttrs[]\n    int\t\ti;\n    u8char_T\t*screenlineUC = NULL;\t// copy from ScreenLinesUC[]\n    u8char_T\t*screenlineC[MAX_MCO];\t// copy from ScreenLinesC[][]\n    schar_T\t*screenline2 = NULL;\t// copy from ScreenLines2[]\n\n    redraw_later(type);\n    if (msg_scrolled || (State != NORMAL && State != NORMAL_BUSY) || exiting)\n\treturn ret;\n\n    // Allocate space to save the text displayed in the command line area.\n    rows = screen_Rows - cmdline_row;\n    screenline = LALLOC_MULT(schar_T, rows * cols);\n    screenattr = LALLOC_MULT(sattr_T, rows * cols);\n    if (screenline == NULL || screenattr == NULL)\n\tret = 2;\n    if (enc_utf8)\n    {\n\tscreenlineUC = LALLOC_MULT(u8char_T, rows * cols);\n\tif (screenlineUC == NULL)\n\t    ret = 2;\n\tfor (i = 0; i < p_mco; ++i)\n\t{\n\t    screenlineC[i] = LALLOC_MULT(u8char_T, rows * cols);\n\t    if (screenlineC[i] == NULL)\n\t\tret = 2;\n\t}\n    }\n    if (enc_dbcs == DBCS_JPNU)\n    {\n\tscreenline2 = LALLOC_MULT(schar_T, rows * cols);\n\tif (screenline2 == NULL)\n\t    ret = 2;\n    }\n\n    if (ret != 2)\n    {\n\t// Save the text displayed in the command line area.\n\tfor (r = 0; r < rows; ++r)\n\t{\n\t    mch_memmove(screenline + r * cols,\n\t\t\tScreenLines + LineOffset[cmdline_row + r],\n\t\t\t(size_t)cols * sizeof(schar_T));\n\t    mch_memmove(screenattr + r * cols,\n\t\t\tScreenAttrs + LineOffset[cmdline_row + r],\n\t\t\t(size_t)cols * sizeof(sattr_T));\n\t    if (enc_utf8)\n\t    {\n\t\tmch_memmove(screenlineUC + r * cols,\n\t\t\t    ScreenLinesUC + LineOffset[cmdline_row + r],\n\t\t\t    (size_t)cols * sizeof(u8char_T));\n\t\tfor (i = 0; i < p_mco; ++i)\n\t\t    mch_memmove(screenlineC[i] + r * cols,\n\t\t\t\tScreenLinesC[i] + LineOffset[cmdline_row + r],\n\t\t\t\t(size_t)cols * sizeof(u8char_T));\n\t    }\n\t    if (enc_dbcs == DBCS_JPNU)\n\t\tmch_memmove(screenline2 + r * cols,\n\t\t\t    ScreenLines2 + LineOffset[cmdline_row + r],\n\t\t\t    (size_t)cols * sizeof(schar_T));\n\t}\n\n\tupdate_screen(0);\n\tret = 3;\n\n\tif (must_redraw == 0)\n\t{\n\t    int\toff = (int)(current_ScreenLine - ScreenLines);\n\n\t    // Restore the text displayed in the command line area.\n\t    for (r = 0; r < rows; ++r)\n\t    {\n\t\tmch_memmove(current_ScreenLine,\n\t\t\t    screenline + r * cols,\n\t\t\t    (size_t)cols * sizeof(schar_T));\n\t\tmch_memmove(ScreenAttrs + off,\n\t\t\t    screenattr + r * cols,\n\t\t\t    (size_t)cols * sizeof(sattr_T));\n\t\tif (enc_utf8)\n\t\t{\n\t\t    mch_memmove(ScreenLinesUC + off,\n\t\t\t\tscreenlineUC + r * cols,\n\t\t\t\t(size_t)cols * sizeof(u8char_T));\n\t\t    for (i = 0; i < p_mco; ++i)\n\t\t\tmch_memmove(ScreenLinesC[i] + off,\n\t\t\t\t    screenlineC[i] + r * cols,\n\t\t\t\t    (size_t)cols * sizeof(u8char_T));\n\t\t}\n\t\tif (enc_dbcs == DBCS_JPNU)\n\t\t    mch_memmove(ScreenLines2 + off,\n\t\t\t\tscreenline2 + r * cols,\n\t\t\t\t(size_t)cols * sizeof(schar_T));\n\t\tscreen_line(cmdline_row + r, 0, cols, cols, 0);\n\t    }\n\t    ret = 4;\n\t}\n    }\n\n    vim_free(screenline);\n    vim_free(screenattr);\n    if (enc_utf8)\n    {\n\tvim_free(screenlineUC);\n\tfor (i = 0; i < p_mco; ++i)\n\t    vim_free(screenlineC[i]);\n    }\n    if (enc_dbcs == DBCS_JPNU)\n\tvim_free(screenline2);\n\n    // Show the intro message when appropriate.\n    maybe_intro_message();\n\n    setcursor();\n\n    return ret;\n}\n#endif\n\n/*\n * Invoked after an asynchronous callback is called.\n * If an echo command was used the cursor needs to be put back where\n * it belongs. If highlighting was changed a redraw is needed.\n * If \"call_update_screen\" is FALSE don't call update_screen() when at the\n * command line.\n * If \"redraw_message\" is TRUE.\n */\n    void\nredraw_after_callback(int call_update_screen, int do_message)\n{\n    ++redrawing_for_callback;\n\n    if (State == HITRETURN || State == ASKMORE || State == SETWSIZE\n\t    || State == EXTERNCMD || State == CONFIRM || exmode_active)\n    {\n\tif (do_message)\n\t    repeat_message();\n    }\n    else if (State & CMDLINE)\n    {\n\t// Don't redraw when in prompt_for_number().\n\tif (cmdline_row > 0)\n\t{\n\t    // Redrawing only works when the screen didn't scroll. Don't clear\n\t    // wildmenu entries.\n\t    if (msg_scrolled == 0\n#ifdef FEAT_WILDMENU\n\t\t    && wild_menu_showing == 0\n#endif\n\t\t    && call_update_screen)\n\t\tupdate_screen(0);\n\n\t    // Redraw in the same position, so that the user can continue\n\t    // editing the command.\n\t    redrawcmdline_ex(FALSE);\n\t}\n    }\n    else if (State & (NORMAL | INSERT | TERMINAL))\n    {\n\t// keep the command line if possible\n\tupdate_screen(VALID_NO_UPDATE);\n\tsetcursor();\n\n\tif (msg_scrolled == 0)\n\t{\n\t    // don't want a hit-enter prompt when something else is displayed\n\t    msg_didany = FALSE;\n\t    need_wait_return = FALSE;\n\t}\n    }\n    cursor_on();\n#ifdef FEAT_GUI\n    if (gui.in_use && !gui_mch_is_blink_off())\n\t// Don't update the cursor when it is blinking and off to avoid\n\t// flicker.\n\tout_flush_cursor(FALSE, FALSE);\n    else\n#endif\n\tout_flush();\n\n    --redrawing_for_callback;\n}\n\n/*\n * Redraw the current window later, with update_screen(type).\n * Set must_redraw only if not already set to a higher value.\n * E.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.\n */\n    void\nredraw_later(int type)\n{\n    redraw_win_later(curwin, type);\n}\n\n    void\nredraw_win_later(\n    win_T\t*wp,\n    int\t\ttype)\n{\n    if (!exiting && wp->w_redr_type < type)\n    {\n\twp->w_redr_type = type;\n\tif (type >= NOT_VALID)\n\t    wp->w_lines_valid = 0;\n\tif (must_redraw < type)\t// must_redraw is the maximum of all windows\n\t    must_redraw = type;\n    }\n}\n\n/*\n * Force a complete redraw later.  Also resets the highlighting.  To be used\n * after executing a shell command that messes up the screen.\n */\n    void\nredraw_later_clear(void)\n{\n    redraw_all_later(CLEAR);\n    reset_screen_attr();\n}\n\n/*\n * Mark all windows to be redrawn later.\n */\n    void\nredraw_all_later(int type)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tredraw_win_later(wp, type);\n    // This may be needed when switching tabs.\n    if (must_redraw < type)\n\tmust_redraw = type;\n}\n\n/*\n * Mark all windows that are editing the current buffer to be updated later.\n */\n    void\nredraw_curbuf_later(int type)\n{\n    redraw_buf_later(curbuf, type);\n}\n\n    void\nredraw_buf_later(buf_T *buf, int type)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == buf)\n\t    redraw_win_later(wp, type);\n    }\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // terminal in popup window is not in list of windows\n    if (curwin->w_buffer == buf)\n\tredraw_win_later(curwin, type);\n#endif\n}\n\n#if defined(FEAT_SIGNS) || defined(PROTO)\n    void\nredraw_buf_line_later(buf_T *buf, linenr_T lnum)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf && lnum >= wp->w_topline\n\t\t\t\t\t\t  && lnum < wp->w_botline)\n\t    redrawWinline(wp, lnum);\n}\n#endif\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n    void\nredraw_buf_and_status_later(buf_T *buf, int type)\n{\n    win_T\t*wp;\n\n#ifdef FEAT_WILDMENU\n    if (wild_menu_showing != 0)\n\t// Don't redraw while the command line completion is displayed, it\n\t// would disappear.\n\treturn;\n#endif\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == buf)\n\t{\n\t    redraw_win_later(wp, type);\n\t    wp->w_redr_status = TRUE;\n\t}\n    }\n}\n#endif\n\n/*\n * mark all status lines for redraw; used after first :cd\n */\n    void\nstatus_redraw_all(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_status_height)\n\t{\n\t    wp->w_redr_status = TRUE;\n\t    redraw_later(VALID);\n\t}\n}\n\n/*\n * mark all status lines of the current buffer for redraw\n */\n    void\nstatus_redraw_curbuf(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_status_height != 0 && wp->w_buffer == curbuf)\n\t{\n\t    wp->w_redr_status = TRUE;\n\t    redraw_later(VALID);\n\t}\n}\n\n/*\n * Redraw all status lines that need to be redrawn.\n */\n    void\nredraw_statuslines(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_redr_status)\n\t    win_redr_status(wp, FALSE);\n    if (redraw_tabline)\n\tdraw_tabline();\n}\n\n#if defined(FEAT_WILDMENU) || defined(PROTO)\n/*\n * Redraw all status lines at the bottom of frame \"frp\".\n */\n    void\nwin_redraw_last_status(frame_T *frp)\n{\n    if (frp->fr_layout == FR_LEAF)\n\tfrp->fr_win->w_redr_status = TRUE;\n    else if (frp->fr_layout == FR_ROW)\n    {\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    win_redraw_last_status(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\twin_redraw_last_status(frp);\n    }\n}\n#endif\n\n/*\n * Changed something in the current window, at buffer line \"lnum\", that\n * requires that line and possibly other lines to be redrawn.\n * Used when entering/leaving Insert mode with the cursor on a folded line.\n * Used to remove the \"$\" from a change command.\n * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot\n * may become invalid and the whole window will have to be redrawn.\n */\n    void\nredrawWinline(\n    win_T\t*wp,\n    linenr_T\tlnum)\n{\n    if (wp->w_redraw_top == 0 || wp->w_redraw_top > lnum)\n\twp->w_redraw_top = lnum;\n    if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lnum)\n\twp->w_redraw_bot = lnum;\n    redraw_win_later(wp, VALID);\n}\n", "\" Test for edit functions\n\nif exists(\"+t_kD\")\n  let &t_kD=\"\u001b[3;*~\"\nendif\n\nsource check.vim\n\n\" Needed for testing basic rightleft: Test_edit_rightleft\nsource view_util.vim\n\n\" Needs to come first until the bug in getchar() is\n\" fixed: https://groups.google.com/d/msg/vim_dev/fXL9yme4H4c/bOR-U6_bAQAJ\nfunc Test_edit_00b()\n  new\n  call setline(1, ['abc '])\n  inoreabbr <buffer> h here some more\n  call cursor(1, 4)\n  \" <c-l> expands the abbreviation and ends insertmode\n  call feedkeys(\":set im\\<cr> h\\<c-l>:set noim\\<cr>\", 'tix')\n  call assert_equal(['abc here some more '], getline(1,'$'))\n  iunabbr <buffer> h\n  bw!\nendfunc\n\nfunc Test_edit_01()\n  \" set for Travis CI?\n  \"  set nocp noesckeys\n  new\n  \" 1) empty buffer\n  call assert_equal([''], getline(1,'$'))\n  \" 2) delete in an empty line\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 3) delete one character\n  call setline(1, 'a')\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 4) delete a multibyte character\n  call setline(1, \"\\u0401\")\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 5.1) delete linebreak with 'bs' option containing eol\n  let _bs=&bs\n  set bs=eol\n  call setline(1, [\"abc def\", \"ghi jkl\"])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<del>\\<esc>\", 'tnix')\n  call assert_equal(['abc defghi jkl'], getline(1, 2))\n  %d\n  \" 5.2) delete linebreak with backspace option w/out eol\n  set bs=\n  call setline(1, [\"abc def\", \"ghi jkl\"])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<del>\\<esc>\", 'tnix')\n  call assert_equal([\"abc def\", \"ghi jkl\"], getline(1, 2))\n  let &bs=_bs\n  bw!\nendfunc\n\nfunc Test_edit_02()\n  \" Change cursor position in InsertCharPre command\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  fu! DoIt(...)\n    call cursor(1, 4)\n    if len(a:000)\n      let v:char=a:1\n    endif\n  endfu\n  au InsertCharPre <buffer> :call DoIt('y')\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  \" Setting <Enter> in InsertCharPre\n  au! InsertCharPre <buffer> :call DoIt(\"\\n\")\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abc', ''], getline(1, '$'))\n  %d\n  au! InsertCharPre\n  \" Change cursor position in InsertEnter command\n  \" 1) when setting v:char, keeps changed cursor position\n  au! InsertEnter <buffer> :call DoIt('y')\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abxc'], getline(1, '$'))\n  \" 2) when not setting v:char, restores changed cursor position\n  au! InsertEnter <buffer> :call DoIt()\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['xabc'], getline(1, '$'))\n  au! InsertEnter\n  delfu DoIt\n  bw!\nendfunc\n\nfunc Test_edit_03()\n  \" Change cursor after <c-o> command to end of line\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>$y\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  %d\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>80|y\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  %d\n  call setline(1, 'abc')\n  call feedkeys(\"Ad\\<c-o>:s/$/efg/\\<cr>hij\", 'tnix')\n  call assert_equal(['hijabcdefg'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_04()\n  \" test for :stopinsert\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>:stopinsert\\<cr>$\", 'tnix')\n  call feedkeys(\"aX\\<esc>\", 'tnix')\n  call assert_equal(['abcX'], getline(1, '$'))\n  %d\n  bw!\nendfunc\n\nfunc Test_edit_05()\n  \" test for folds being opened\n  new\n  call setline(1, ['abcX', 'abcX', 'zzzZ'])\n  call cursor(1, 1)\n  set foldmethod=manual foldopen+=insert\n  \" create fold for those two lines\n  norm! Vjzf\n  call feedkeys(\"$ay\\<esc>\", 'tnix')\n  call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))\n  %d\n  call setline(1, ['abcX', 'abcX', 'zzzZ'])\n  call cursor(1, 1)\n  set foldmethod=manual foldopen-=insert\n  \" create fold for those two lines\n  norm! Vjzf\n  call feedkeys(\"$ay\\<esc>\", 'tnix')\n  call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))\n  %d\n  bw!\nendfunc\n\nfunc Test_edit_06()\n  \" Test in diff mode\n  CheckFeature diff\n  CheckExecutable diff\n  new\n  call setline(1, ['abc', 'xxx', 'yyy'])\n  vnew\n  call setline(1, ['abc', 'zzz', 'xxx', 'yyy'])\n  wincmd p\n  diffthis\n  wincmd p\n  diffthis\n  wincmd p\n  call cursor(2, 1)\n  norm! zt\n  call feedkeys(\"Ozzz\\<esc>\", 'tnix')\n  call assert_equal(['abc', 'zzz', 'xxx', 'yyy'], getline(1,'$'))\n  bw!\n  bw!\nendfunc\n\nfunc Test_edit_07()\n  \" 1) Test with completion <c-l> when popupmenu is visible\n  new\n  call setline(1, 'J')\n\n  func! ListMonths()\n    call complete(col('.')-1, ['January', 'February', 'March',\n    \\ 'April', 'May', 'June', 'July', 'August', 'September',\n    \\ 'October', 'November', 'December'])\n    return ''\n  endfunc\n  inoremap <buffer> <F5> <C-R>=ListMonths()<CR>\n\n  call feedkeys(\"A\\<f5>\\<c-p>\". repeat(\"\\<down>\", 6).\"\\<c-l>\\<down>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal(['July'], getline(1,'$'))\n  \" 1) Test completion when InsertCharPre kicks in\n  %d\n  call setline(1, 'J')\n  fu! DoIt()\n    if v:char=='u'\n      let v:char='an'\n    endif\n  endfu\n  au InsertCharPre <buffer> :call DoIt()\n  call feedkeys(\"A\\<f5>\\<c-p>u\\<cr>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal([\"Jan\\<c-l>\",''], 1->getline('$'))\n  %d\n  call setline(1, 'J')\n  call feedkeys(\"A\\<f5>\\<c-p>u\\<down>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal([\"January\"], 1->getline('$'))\n\n  delfu ListMonths\n  delfu DoIt\n  iunmap <buffer> <f5>\n  bw!\nendfunc\n\nfunc Test_edit_08()\n  \" reset insertmode from i_ctrl-r_=\n  let g:bufnr = bufnr('%')\n  new\n  call setline(1, ['abc'])\n  call cursor(1, 4)\n  call feedkeys(\":set im\\<cr>ZZZ\\<c-r>=setbufvar(g:bufnr,'&im', 0)\\<cr>\",'tnix')\n  call assert_equal(['abZZZc'], getline(1,'$'))\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call assert_false(0, '&im')\n  bw!\n  unlet g:bufnr\nendfunc\n\nfunc Test_edit_09()\n  \" test i_CTRL-\\ combinations\n  new\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 1)\n  \" 1) CTRL-\\ CTLR-N\n  call feedkeys(\":set im\\<cr>\\<c-\\>\\<c-n>ccABC\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'def', 'ghi'], getline(1,'$'))\n  call setline(1, ['ABC', 'def', 'ghi'])\n  \" 2) CTRL-\\ CTLR-G\n  call feedkeys(\"j0\\<c-\\>\\<c-g>ZZZ\\<cr>\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  call feedkeys(\"I\\<c-\\>\\<c-g>YYY\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'ZZZ', 'YYYdef', 'ghi'], getline(1,'$'))\n  set noinsertmode\n  \" 3) CTRL-\\ CTRL-O\n  call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-o>ix\", 'txin')\n  call assert_equal(['ABxC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  call feedkeys(\"A\\<c-\\>\\<c-o>ix\", 'txin')\n  call assert_equal(['ABxCx', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  \" 4) CTRL-\\ a (should be inserted literally, not special after <c-\\>\n  call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-\\>a\", 'txin')\n  call assert_equal([\"ABC\\<c-\\>a\", 'ZZZ', 'def', 'ghi'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_11()\n  \" Test that indenting kicks in\n  new\n  set cindent\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"\\<Insert>/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"/* comment */\"], getline(1, '$'))\n  \" added changed cindentkeys slightly\n  set cindent cinkeys+=*/\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"i/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"\\<tab>/* comment */\"], getline(1, '$'))\n  set cindent cinkeys+==end\n  call feedkeys(\"oend\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"\\<tab>/* comment */\", \"\\tend\", ''], getline(1, '$'))\n  set cinkeys-==end\n  %d\n  \" Use indentexpr instead of cindenting\n  func! Do_Indent()\n    if v:lnum == 3\n      return 3*shiftwidth()\n    else\n      return 2*shiftwidth()\n    endif\n  endfunc\n  setl indentexpr=Do_Indent() indentkeys+=*/\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"i/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>\\<tab>int c;\", \"\\<tab>\\<tab>\\<tab>/* comment */\"], getline(1, '$'))\n  set cinkeys&vim indentkeys&vim\n  set nocindent indentexpr=\n  delfu Do_Indent\n  bw!\nendfunc\n\nfunc Test_edit_11_indentexpr()\n  \" Test that indenting kicks in\n  new\n  \" Use indentexpr instead of cindenting\n  func! Do_Indent()\n    let pline=prevnonblank(v:lnum)\n    if empty(getline(v:lnum))\n      if getline(pline) =~ 'if\\|then'\n        return shiftwidth()\n      else\n        return 0\n      endif\n    else\n        return 0\n    endif\n  endfunc\n  setl indentexpr=Do_Indent() indentkeys+=0=then,0=fi\n  call setline(1, ['if [ $this ]'])\n  call cursor(1, 1)\n  call feedkeys(\"othen\\<cr>that\\<cr>fi\", 'tnix')\n  call assert_equal(['if [ $this ]', \"then\", \"\\<tab>that\", \"fi\"], getline(1, '$'))\n  set cinkeys&vim indentkeys&vim\n  set nocindent indentexpr=\n  delfu Do_Indent\n\n  \" Using a script-local function\n  func s:NewIndentExpr()\n  endfunc\n  set indentexpr=s:NewIndentExpr()\n  call assert_equal(expand('<SID>') .. 'NewIndentExpr()', &indentexpr)\n  set indentexpr=<SID>NewIndentExpr()\n  call assert_equal(expand('<SID>') .. 'NewIndentExpr()', &indentexpr)\n  set indentexpr&\n\n  bw!\nendfunc\n\n\" Test changing indent in replace mode\nfunc Test_edit_12()\n  new\n  call setline(1, [\"\\tabc\", \"\\tdef\"])\n  call cursor(2, 4)\n  call feedkeys(\"R^\\<c-d>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"def\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], '.'->getpos())\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R^\\<c-d>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"def\"], getline(1, '$'))\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  bw!\n  10vnew\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  %d\n  set sw=4\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  set sw&\n\n  \" In replace mode, after hitting enter in a line with tab characters,\n  \" pressing backspace should restore the tab characters.\n  %d\n  setlocal autoindent backspace=2\n  call setline(1, \"\\tone\\t\\ttwo\")\n  exe \"normal ggRred\\<CR>six\" .. repeat(\"\\<BS>\", 8)\n  call assert_equal([\"\\tone\\t\\ttwo\"], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_13()\n  \" Test smartindenting\n  if exists(\"+smartindent\")\n    new\n    set smartindent autoindent\n    call setline(1, [\"\\tabc\"])\n    call feedkeys(\"A {\\<cr>more\\<cr>}\\<esc>\", 'tnix')\n    call assert_equal([\"\\tabc {\", \"\\t\\tmore\", \"\\t}\"], getline(1, '$'))\n    set smartindent& autoindent&\n    bwipe!\n  endif\n\n  \" Test autoindent removing indent of blank line.\n  new\n  call setline(1, '    foo bar baz')\n  set autoindent\n  exe \"normal 0eea\\<CR>\\<CR>\\<Esc>\"\n  call assert_equal(\"    foo bar\", getline(1))\n  call assert_equal(\"\", getline(2))\n  call assert_equal(\"    baz\", getline(3))\n  set autoindent&\n\n  \" pressing <C-U> to erase line should keep the indent with 'autoindent'\n  set backspace=2 autoindent\n  %d\n  exe \"normal i\\tone\\<CR>three\\<C-U>two\"\n  call assert_equal([\"\\tone\", \"\\ttwo\"], getline(1, '$'))\n  set backspace& autoindent&\n\n  bwipe!\nendfunc\n\n\" Test for autoindent removing indent when insert mode is stopped.  Some parts\n\" of the code is exercised only when interactive mode is used. So use Vim in a\n\" terminal.\nfunc Test_autoindent_remove_indent()\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('-N Xfile', {'rows': 6, 'cols' : 20})\n  call TermWait(buf)\n  call term_sendkeys(buf, \":set autoindent\\n\")\n  \" leaving insert mode in a new line with indent added by autoindent, should\n  \" remove the indent.\n  call term_sendkeys(buf, \"i\\<Tab>foo\\<CR>\\<Esc>\")\n  \" Need to delay for some time, otherwise the code in getchar.c will not be\n  \" exercised.\n  call TermWait(buf, 50)\n  \" when a line is wrapped and the cursor is at the start of the second line,\n  \" leaving insert mode, should move the cursor back to the first line.\n  call term_sendkeys(buf, \"o\" .. repeat('x', 20) .. \"\\<Esc>\")\n  \" Need to delay for some time, otherwise the code in getchar.c will not be\n  \" exercised.\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":w\\n\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n  call assert_equal([\"\\tfoo\", '', repeat('x', 20)], readfile('Xfile'))\n  call delete('Xfile')\nendfunc\n\nfunc Test_edit_CR()\n  \" Test for <CR> in insert mode\n  \" basically only in quickfix mode it's tested, the rest\n  \" has been taken care of by other tests\n  CheckFeature quickfix\n  botright new\n  call writefile(range(1, 10), 'Xqflist.txt')\n  call setqflist([{'filename': 'Xqflist.txt', 'lnum': 2}])\n  copen\n  set modifiable\n  call feedkeys(\"A\\<cr>\", 'tnix')\n  call assert_equal('Xqflist.txt', bufname(''))\n  call assert_equal(2, line('.'))\n  cclose\n  botright new\n  call setloclist(0, [{'filename': 'Xqflist.txt', 'lnum': 10}])\n  lopen\n  set modifiable\n  call feedkeys(\"A\\<cr>\", 'tnix')\n  call assert_equal('Xqflist.txt', bufname(''))\n  call assert_equal(10, line('.'))\n  call feedkeys(\"A\\<Enter>\", 'tnix')\n  call feedkeys(\"A\\<kEnter>\", 'tnix')\n  call feedkeys(\"A\\n\", 'tnix')\n  call feedkeys(\"A\\r\", 'tnix')\n  call assert_equal(map(range(1, 10), 'string(v:val)') + ['', '', '', ''], getline(1, '$'))\n  bw!\n  lclose\n  call delete('Xqflist.txt')\nendfunc\n\nfunc Test_edit_CTRL_()\n  CheckFeature rightleft\n  \" disabled for Windows builds, why?\n  CheckNotMSWindows\n  let _encoding=&encoding\n  set encoding=utf-8\n  \" Test for CTRL-_\n  new\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"\\<C-_>xyzabc\"], getline(1, '$'))\n  call assert_false(&revins)\n  set ari\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"\u00e6\u00e8\u00f1abc\"], getline(1, '$'))\n  call assert_true(&revins)\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"xyzabc\"], getline(1, '$'))\n  call assert_false(&revins)\n  set noari\n  let &encoding=_encoding\n  bw!\nendfunc\n\n\" needs to come first, to have the @. register empty\nfunc Test_edit_00a_CTRL_A()\n  \" Test pressing CTRL-A\n  new\n  call setline(1, repeat([''], 5))\n  call cursor(1, 1)\n  try\n    call feedkeys(\"A\\<NUL>\", 'tnix')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E29/\n    call assert_true(1, 'E29 error caught')\n  endtry\n  call cursor(1, 1)\n  call feedkeys(\"Afoobar \\<esc>\", 'tnix')\n  call cursor(2, 1)\n  call feedkeys(\"A\\<c-a>more\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"A\\<NUL>and more\\<esc>\", 'tnix')\n  call assert_equal(['foobar ', 'foobar more', 'foobar morend more', '', ''], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_EY()\n  \" Ctrl-E/ Ctrl-Y in insert mode completion to scroll\n  10new\n  call setline(1, range(1, 100))\n  call cursor(30, 1)\n  norm! z.\n  call feedkeys(\"A\\<c-x>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\", 'tnix')\n  call assert_equal(30, winsaveview()['topline'])\n  call assert_equal([0, 30, 2, 0], getpos('.'))\n  call feedkeys(\"A\\<c-x>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\", 'tnix')\n  call feedkeys(\"A\\<c-x>\".repeat(\"\\<c-y>\", 10), 'tnix')\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 30, 2, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_G()\n  new\n  call setline(1, ['foobar', 'foobar', 'foobar'])\n  call cursor(2, 4)\n  call feedkeys(\"ioooooooo\\<c-g>k\\<c-r>.\\<esc>\", 'tnix')\n  call assert_equal(['foooooooooobar', 'foooooooooobar', 'foobar'], getline(1, '$'))\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call feedkeys(\"i\\<c-g>k\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 10, 0], getpos('.'))\n  call cursor(2, 4)\n  call feedkeys(\"i\\<c-g>jzzzz\\<esc>\", 'tnix')\n  call assert_equal(['foooooooooobar', 'foooooooooobar', 'foozzzzbar'], getline(1, '$'))\n  call assert_equal([0, 3, 7, 0], getpos('.'))\n  call feedkeys(\"i\\<c-g>j\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 6, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_I()\n  \" Tab in completion mode\n  let path=expand(\"%:p:h\")\n  new\n  call setline(1, [path. \"/\", ''])\n  call feedkeys(\"Arunt\\<c-x>\\<c-f>\\<tab>\\<cr>\\<esc>\", 'tnix')\n  call assert_match('runtest\\.vim', getline(1))\n  %d\n  call writefile(['one', 'two', 'three'], 'Xinclude.txt')\n  let include='#include Xinclude.txt'\n  call setline(1, [include, ''])\n  call cursor(2, 1)\n  call feedkeys(\"A\\<c-x>\\<tab>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'one', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'two', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'three', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, '', ''], getline(1, '$'))\n  call delete(\"Xinclude.txt\")\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_K()\n  \" Test pressing CTRL-K (basically only dictionary completion and digraphs\n  \" the rest is already covered\n  call writefile(['A', 'AA', 'AAA', 'AAAA'], 'Xdictionary.txt')\n  set dictionary=Xdictionary.txt\n  new\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA', ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AAA'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AAAA'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['A'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA'], getline(1, '$'))\n\n  \" press an unexpected key after dictionary completion\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-]>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA', ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"AA\\<c-s>\", ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-f>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"AA\\<c-f>\", ''], getline(1, '$'))\n\n  set dictionary=\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  let v:testing = 1\n  try\n    call feedkeys(\"A\\<c-x>\\<c-k>\\<esc>\", 'tnix')\n  catch\n    \" error sleeps 2 seconds, when v:testing is not set\n    let v:testing = 0\n  endtry\n  call delete('Xdictionary.txt')\n\n  call test_override(\"char_avail\", 1)\n  set showcmd\n  %d\n  call feedkeys(\"A\\<c-k>a:\\<esc>\", 'tnix')\n  call assert_equal(['\u00e4'], getline(1, '$'))\n  call test_override(\"char_avail\", 0)\n  set noshowcmd\n\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_L()\n  \" Test Ctrl-X Ctrl-L (line completion)\n  new\n  set complete=.\n  call setline(1, ['one', 'two', 'three', '', '', '', ''])\n  call cursor(4, 1)\n  call feedkeys(\"A\\<c-x>\\<c-l>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<c-p>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  set complete=\n  call cursor(5, 1)\n  call feedkeys(\"A\\<c-x>\\<c-l>\\<c-p>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', \"\\<c-l>\\<c-p>\\<c-n>\", '', ''], getline(1, '$'))\n  set complete&\n  %d\n  if has(\"conceal\") && has(\"syntax\")\n    call setline(1, ['foo', 'bar', 'foobar'])\n    call test_override(\"char_avail\", 1)\n    set conceallevel=2 concealcursor=n\n    syn on\n    syn match ErrorMsg \"^bar\"\n    call matchadd(\"Conceal\", 'oo', 10, -1, {'conceal': 'X'})\n    func! DoIt()\n      let g:change=1\n    endfunc\n    au! TextChangedI <buffer> :call DoIt()\n\n    call cursor(2, 1)\n    call assert_false(exists(\"g:change\"))\n    call feedkeys(\"A \\<esc>\", 'tnix')\n    call assert_equal(['foo', 'bar ', 'foobar'], getline(1, '$'))\n    call assert_equal(1, g:change)\n\n    call test_override(\"char_avail\", 0)\n    call clearmatches()\n    syn off\n    au! TextChangedI\n    delfu DoIt\n    unlet! g:change\n  endif\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_N()\n  \" Check keyword completion\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n    new\n    set complete=.\n    call setline(1, ['INFER', 'loWER', '', '', ])\n    call cursor(3, 1)\n    call feedkeys(\"Ai\\<c-n>\\<cr>\\<esc>\", \"tnix\")\n    call feedkeys(\"ILO\\<c-n>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['INFER', 'loWER', 'i', 'LO', '', ''], getline(1, '$'), e)\n    %d\n    call setline(1, ['INFER', 'loWER', '', '', ])\n    call cursor(3, 1)\n    set ignorecase infercase\n    call feedkeys(\"Ii\\<c-n>\\<cr>\\<esc>\", \"tnix\")\n    call feedkeys(\"ILO\\<c-n>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['INFER', 'loWER', 'infer', 'LOWER', '', ''], getline(1, '$'), e)\n    set noignorecase noinfercase\n    %d\n    call setline(1, ['one word', 'two word'])\n    exe \"normal! Goo\\<C-P>\\<C-X>\\<C-P>\"\n    call assert_equal('one word', getline(3))\n    %d\n    set complete&\n    bw!\n  endfor\nendfunc\n\nfunc Test_edit_CTRL_O()\n  \" Check for CTRL-O in insert mode\n  new\n  inoreabbr <buffer> h here some more\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  \" Ctrl-O after an abbreviation\n  exe \"norm A h\\<c-o>:set nu\\<cr> text\"\n  call assert_equal(['abc here some more text', 'def'], getline(1, '$'))\n  call assert_true(&nu)\n  set nonu\n  iunabbr <buffer> h\n  \" Ctrl-O at end of line with 've'=onemore\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-o>:let g:a=getpos('.')\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 23, 0], g:a)\n  call cursor(1, 1)\n  set ve=onemore\n  call feedkeys(\"A\\<c-o>:let g:a=getpos('.')\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 24, 0], g:a)\n  set ve=\n  unlet! g:a\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_R()\n  \" Insert Register\n  new\n  call test_override(\"ALL\", 1)\n  set showcmd\n  call feedkeys(\"AFOOBAR eins zwei\\<esc>\", 'tnix')\n  call feedkeys(\"O\\<c-r>.\", 'tnix')\n  call feedkeys(\"O\\<c-r>=10*500\\<cr>\\<esc>\", 'tnix')\n  call feedkeys(\"O\\<c-r>=getreg('=', 1)\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"getreg('=', 1)\", '5000', \"FOOBAR eins zwei\", \"FOOBAR eins zwei\"], getline(1, '$'))\n  call test_override(\"ALL\", 0)\n  set noshowcmd\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_S()\n  \" Test pressing CTRL-S (basically only spellfile completion)\n  \" the rest is already covered\n  new\n  if !has(\"spell\")\n    call setline(1, 'vim')\n    call feedkeys(\"A\\<c-x>ss\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['vims', ''], getline(1, '$'))\n    bw!\n    return\n  endif\n  call setline(1, 'vim')\n  \" spell option not yet set\n  try\n    call feedkeys(\"A\\<c-x>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E756/\n    call assert_true(1, 'error caught')\n  endtry\n  call assert_equal(['vim', ''], getline(1, '$'))\n  %d\n  setl spell spelllang=en\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Vim', ''], getline(1, '$'))\n  %d\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Aim'], getline(1, '$'))\n  %d\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['vim', ''], getline(1, '$'))\n  %d\n  \" empty buffer\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['', ''], getline(1, '$'))\n  setl nospell\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_T()\n  \" Check for CTRL-T and CTRL-X CTRL-T in insert mode\n  \" 1) increase indent\n  new\n  call setline(1, \"abc\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-t>xyz\", 'tnix')\n  call assert_equal([\"\\<tab>abcxyz\"], getline(1, '$'))\n  \" 2) also when paste option is set\n  set paste\n  call setline(1, \"abc\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-t>xyz\", 'tnix')\n  call assert_equal([\"\\<tab>abcxyz\"], getline(1, '$'))\n  set nopaste\n  \" CTRL-X CTRL-T (thesaurus complete)\n  call writefile(['angry furious mad enraged'], 'Xthesaurus')\n  set thesaurus=Xthesaurus\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['angry', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['furious', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['enraged', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  \" Using <c-p> <c-n> when 'complete' is empty\n  set complete=\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['angry', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  set complete&\n\n  set thesaurus=\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  let v:testing = 1\n  try\n    call feedkeys(\"A\\<c-x>\\<c-t>\\<esc>\", 'tnix')\n  catch\n    \" error sleeps 2 seconds, when v:testing is not set\n    let v:testing = 0\n  endtry\n  call assert_equal(['mad'], getline(1, '$'))\n  call delete('Xthesaurus')\n  bw!\nendfunc\n\n\" Test thesaurus completion with different encodings\nfunc Test_thesaurus_complete_with_encoding()\n  call writefile(['angry furious mad enraged'], 'Xthesaurus')\n  set thesaurus=Xthesaurus\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n    new\n    call setline(1, 'mad')\n    call cursor(1, 1)\n    call feedkeys(\"A\\<c-x>\\<c-t>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['mad', ''], getline(1, '$'))\n    bw!\n  endfor\n  set thesaurus=\n  call delete('Xthesaurus')\nendfunc\n\n\" Test 'thesaurusfunc'\nfunc MyThesaurus(findstart, base)\n  let mythesaurus = [\n        \\ #{word: \"happy\",\n        \\   synonyms: \"cheerful,blissful,flying high,looking good,peppy\"},\n        \\ #{word: \"kind\",\n        \\   synonyms: \"amiable,bleeding-heart,heart in right place\"}]\n  if a:findstart\n    \" locate the start of the word\n    let line = getline('.')\n    let start = col('.') - 1\n    while start > 0 && line[start - 1] =~ '\\a'\n      let start -= 1\n    endwhile\n    return start\n  else\n    \" find strings matching with \"a:base\"\n    let res = []\n    for w in mythesaurus\n      if w.word =~ '^' . a:base\n        call add(res, w.word)\n        call extend(res, split(w.synonyms, \",\"))\n      endif\n    endfor\n    return res\n  endif\nendfunc\n\nfunc Test_thesaurus_func()\n  new\n  set thesaurus=notused\n  set thesaurusfunc=NotUsed\n  setlocal thesaurusfunc=MyThesaurus\n  call setline(1, \"an ki\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['an amiable', ''], getline(1, '$'))\n\n  setlocal thesaurusfunc=NonExistingFunc\n  call assert_fails(\"normal $a\\<C-X>\\<C-T>\", 'E117:')\n\n  setlocal thesaurusfunc=\n  set thesaurusfunc=NonExistingFunc\n  call assert_fails(\"normal $a\\<C-X>\\<C-T>\", 'E117:')\n  %bw!\n\n  set thesaurusfunc=\n  set thesaurus=\nendfunc\n\nfunc Test_edit_CTRL_U()\n  \" Test 'completefunc'\n  new\n  \" -1, -2 and -3 are special return values\n  let g:special=0\n  fun! CompleteMonths(findstart, base)\n    if a:findstart\n      \" locate the start of the word\n      return g:special\n    else\n      \" find months matching with \"a:base\"\n      let res = []\n      for m in split(\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\")\n        if m =~ '^\\c'.a:base\n          call add(res, {'word': m, 'abbr': m.' Month', 'icase': 0})\n        endif\n      endfor\n      return {'words': res, 'refresh': 'always'}\n    endif\n  endfun\n  set completefunc=CompleteMonths\n  call setline(1, ['', ''])\n  call cursor(1, 1)\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', '', ''], getline(1, '$'))\n  %d\n  let g:special=-1\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['XJan', ''], getline(1, '$'))\n  %d\n  let g:special=-2\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', ''], getline(1, '$'))\n  %d\n  let g:special=-3\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', ''], getline(1, '$'))\n  %d\n  let g:special=0\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Mar', ''], getline(1, '$'))\n  %d\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['May', ''], getline(1, '$'))\n  %d\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['M', ''], getline(1, '$'))\n  delfu CompleteMonths\n  %d\n  try\n    call feedkeys(\"A\\<c-x>\\<c-u>\", 'tnix')\n    call assert_fails(1, 'unknown completion function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E117/\n    call assert_true(1, 'E117 error caught')\n  endtry\n  set completefunc=\n  bw!\nendfunc\n\nfunc Test_edit_completefunc_delete()\n  func CompleteFunc(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    normal dd\n    return ['a', 'b']\n  endfunc\n  new\n  set completefunc=CompleteFunc\n  call setline(1, ['', 'abcd', ''])\n  2d\n  call assert_fails(\"normal 2G$a\\<C-X>\\<C-U>\", 'E578:')\n  bwipe!\nendfunc\n\n\nfunc Test_edit_CTRL_Z()\n  \" Ctrl-Z when insertmode is not set inserts it literally\n  new\n  call setline(1, 'abc')\n  call feedkeys(\"A\\<c-z>\\<esc>\", 'tnix')\n  call assert_equal([\"abc\\<c-z>\"], getline(1,'$'))\n  bw!\n  \" TODO: How to Test Ctrl-Z in insert mode, e.g. suspend?\nendfunc\n\nfunc Test_edit_DROP()\n  CheckFeature dnd\n  new\n  call setline(1, ['abc def ghi'])\n  call cursor(1, 1)\n  try\n    call feedkeys(\"i\\<Drop>\\<Esc>\", 'tnix')\n    call assert_fails(1, 'Invalid register name')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E353/\n    call assert_true(1, 'error caught')\n  endtry\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_V()\n  CheckFeature ebcdic\n  new\n  call setline(1, ['abc'])\n  call cursor(2, 1)\n  \" force some redraws\n  set showmode showcmd\n  \"call test_override_char_avail(1)\n  call test_override('ALL', 1)\n  call feedkeys(\"A\\<c-v>\\<c-n>\\<c-v>\\<c-l>\\<c-v>\\<c-b>\\<esc>\", 'tnix')\n  call assert_equal([\"abc\\x0e\\x0c\\x02\"], getline(1, '$'))\n\n  if has(\"rightleft\") && exists(\"+rl\")\n    set rl\n    call setline(1, ['abc'])\n    call cursor(2, 1)\n    call feedkeys(\"A\\<c-v>\\<c-n>\\<c-v>\\<c-l>\\<c-v>\\<c-b>\\<esc>\", 'tnix')\n    call assert_equal([\"abc\\x0e\\x0c\\x02\"], getline(1, '$'))\n    set norl\n  endif\n\n  call test_override('ALL', 0)\n  set noshowmode showcmd\n  bw!\nendfunc\n\nfunc Test_edit_F1()\n  CheckFeature quickfix\n\n  \" Pressing <f1>\n  new\n  call feedkeys(\":set im\\<cr>\\<f1>\\<c-l>\", 'tnix')\n  set noinsertmode\n  call assert_equal('help', &buftype)\n  bw\n  bw\nendfunc\n\nfunc Test_edit_F21()\n  \" Pressing <f21>\n  \" sends a netbeans command\n  CheckFeature netbeans_intg\n  new\n  \" I have no idea what this is supposed to do :)\n  call feedkeys(\"A\\<F21>\\<F1>\\<esc>\", 'tnix')\n  bw\nendfunc\n\nfunc Test_edit_HOME_END()\n  \" Test Home/End Keys\n  new\n  set foldopen+=hor\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"AX\\<Home>Y\\<esc>\", 'tnix')\n  call cursor(2, 1)\n  call feedkeys(\"iZ\\<End>Y\\<esc>\", 'tnix')\n  call assert_equal(['YabcX', 'ZdefY'], getline(1, '$'))\n\n  set foldopen-=hor\n  bw!\nendfunc\n\nfunc Test_edit_INS()\n  \" Test for Pressing <Insert>\n  new\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<Insert>ZYX>\", 'tnix')\n  call assert_equal(['ZYX>', 'def'], getline(1, '$'))\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<Insert>Z\\<Insert>YX>\", 'tnix')\n  call assert_equal(['ZYX>bc', 'def'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_LEFT_RIGHT()\n  \" Left, Shift-Left, Right, Shift-Right\n  new\n  call setline(1, ['abc def ghi', 'ABC DEF GHI', 'ZZZ YYY XXX'])\n  let _ww=&ww\n  set ww=\n  call cursor(2, 1)\n  call feedkeys(\"i\\<left>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  \" Is this a bug, <s-left> does not respect whichwrap option\n  call feedkeys(\"i\\<s-left>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 8, 0], getpos('.'))\n  call feedkeys(\"i\". repeat(\"\\<s-left>\", 3). \"\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<right>\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 2, 0], getpos('.'))\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 4, 0], getpos('.'))\n  call cursor(3, 11)\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 11, 0], getpos('.'))\n  call cursor(2, 11)\n  \" <S-Right> does not respect 'whichwrap' option\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  \" Check motion when 'whichwrap' contains cursor keys for insert mode\n  set ww+=[,]\n  call cursor(2, 1)\n  call feedkeys(\"i\\<left>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call cursor(2, 11)\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  call cursor(2, 11)\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  let &ww = _ww\n  bw!\nendfunc\n\nfunc Test_edit_MOUSE()\n  \" This is a simple test, since we not really using the mouse here\n  CheckFeature mouse\n  10new\n  call setline(1, range(1, 100))\n  call cursor(1, 1)\n  set mouse=a\n  call feedkeys(\"A\\<ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 4, 1, 0], getpos('.'))\n  \" This should move by one pageDown, but only moves\n  \" by one line when the test is run...\n  call feedkeys(\"A\\<S-ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  set nostartofline\n  call feedkeys(\"A\\<C-ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<LeftMouse>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<RightMouse>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call cursor(1, 100)\n  norm! zt\n  \" this should move by a screen up, but when the test\n  \" is run, it moves up to the top of the buffer...\n  call feedkeys(\"A\\<ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call cursor(1, 30)\n  norm! zt\n  call feedkeys(\"A\\<S-ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call cursor(1, 30)\n  norm! zt\n  call feedkeys(\"A\\<C-ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  %d\n  call setline(1, repeat([\"12345678901234567890\"], 100))\n  call cursor(2, 1)\n  call feedkeys(\"A\\<ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<S-ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<S-ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<C-ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<C-ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  set mouse& startofline\n  bw!\nendfunc\n\nfunc Test_edit_PAGEUP_PAGEDOWN()\n  10new\n  call setline(1, repeat(['abc def ghi'], 30))\n  call cursor(1, 1)\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  \" <S-Up> is the same as <PageUp>\n  \" <S-Down> is the same as <PageDown>\n  call cursor(1, 1)\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  set nostartofline\n  call cursor(30, 11)\n  norm! zt\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call cursor(1, 1)\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  \" <S-Up> is the same as <PageUp>\n  \" <S-Down> is the same as <PageDown>\n  call cursor(30, 11)\n  norm! zt\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call cursor(1, 1)\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_forbidden()\n  new\n  \" 1) edit in the sandbox is not allowed\n  call setline(1, 'a')\n  com! Sandbox :sandbox call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_fails(':Sandbox', 'E48:')\n  com! Sandbox :sandbox exe \"norm! i\\<del>\"\n  call assert_fails(':Sandbox', 'E48:')\n  delcom Sandbox\n  call assert_equal(['a'], getline(1,'$'))\n\n  \" 2) edit with textlock set\n  fu! DoIt()\n    call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  endfu\n  au InsertCharPre <buffer> :call DoIt()\n  try\n    call feedkeys(\"ix\\<esc>\", 'tnix')\n    call assert_fails(1, 'textlock')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565: not allowed here\n  endtry\n  \" TODO: Might be a bug: should x really be inserted here\n  call assert_equal(['xa'], getline(1, '$'))\n  delfu DoIt\n  try\n    call feedkeys(\"ix\\<esc>\", 'tnix')\n    call assert_fails(1, 'unknown function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E117/ \" catch E117: unknown function\n  endtry\n  au! InsertCharPre\n\n  \" 3) edit when completion is shown\n  fun! Complete(findstart, base)\n    if a:findstart\n      return col('.')\n    else\n      call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n      return []\n    endif\n  endfun\n  set completefunc=Complete\n  try\n    call feedkeys(\"i\\<c-x>\\<c-u>\\<esc>\", 'tnix')\n    call assert_fails(1, 'change in complete function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565\n  endtry\n  delfu Complete\n  set completefunc=\n\n  if has(\"rightleft\") && exists(\"+fkmap\")\n    \" 4) 'R' when 'fkmap' and 'revins' is set.\n    set revins fkmap\n    try\n      normal Ri\n      call assert_fails(1, \"R with 'fkmap' and 'ri' set\")\n    catch\n    finally\n      set norevins nofkmap\n    endtry\n  endif\n  bw!\nendfunc\n\nfunc Test_edit_rightleft()\n  \" Cursor in rightleft mode moves differently\n  CheckFeature rightleft\n  call NewWindow(10, 20)\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 2)\n  set rightleft\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                 cba\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  \" 2) right moves to the left\n  call feedkeys(\"i\\<right>\\<esc>x\", 'txin')\n  call assert_equal(['bc', 'def', 'ghi'], getline(1,'$'))\n  call cursor(1, 2)\n  call feedkeys(\"i\\<s-right>\\<esc>\", 'txin')\n  call cursor(1, 2)\n  call feedkeys(\"i\\<c-right>\\<esc>\", 'txin')\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                  cb\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  \" 2) left moves to the right\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 2)\n  call feedkeys(\"i\\<left>\\<esc>x\", 'txin')\n  call assert_equal(['ac', 'def', 'ghi'], getline(1,'$'))\n  call cursor(1, 2)\n  call feedkeys(\"i\\<s-left>\\<esc>\", 'txin')\n  call cursor(1, 2)\n  call feedkeys(\"i\\<c-left>\\<esc>\", 'txin')\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                  ca\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  %d _\n  call test_override('redraw_flag', 1)\n  call test_override('char_avail', 1)\n  call feedkeys(\"a\\<C-V>x41\", \"xt\")\n  redraw!\n  call assert_equal(repeat(' ', 19) .. 'A', Screenline(1))\n  call test_override('ALL', 0)\n  set norightleft\n  bw!\nendfunc\n\nfunc Test_edit_complete_very_long_name()\n  \" Long directory names only work on Unix.\n  CheckUnix\n\n  let dirname = getcwd() . \"/Xdir\"\n  let longdirname = dirname . repeat('/' . repeat('d', 255), 4)\n  try\n    call mkdir(longdirname, 'p')\n  catch /E739:/\n    \" Long directory name probably not supported.\n    call delete(dirname, 'rf')\n    return\n  endtry\n\n  \" Try to get the Vim window position before setting 'columns', so that we can\n  \" move the window back to where it was.\n  let winposx = getwinposx()\n  let winposy = getwinposy()\n\n  if winposx >= 0 && winposy >= 0 && !has('gui_running')\n    \" We did get the window position, but xterm may report the wrong numbers.\n    \" Move the window to the reported position and compute any offset.\n    exe 'winpos ' . winposx . ' ' . winposy\n    sleep 100m\n    let x = getwinposx()\n    if x >= 0\n      let winposx += winposx - x\n    endif\n    let y = getwinposy()\n    if y >= 0\n      let winposy += winposy - y\n    endif\n  endif\n\n  let save_columns = &columns\n  \" Need at least about 1100 columns to reproduce the problem.\n  set columns=2000\n  set noswapfile\n\n  let longfilename = longdirname . '/' . repeat('a', 255)\n  call writefile(['Totum', 'Table'], longfilename)\n  new\n  exe \"next Xfile \" . longfilename\n  exe \"normal iT\\<C-N>\"\n\n  bwipe!\n  exe 'bwipe! ' . longfilename\n  call delete(dirname, 'rf')\n  let &columns = save_columns\n  if winposx >= 0 && winposy >= 0\n    exe 'winpos ' . winposx . ' ' . winposy\n  endif\n  set swapfile&\nendfunc\n\nfunc Test_edit_backtick()\n  next a\\`b c\n  call assert_equal('a`b', expand('%'))\n  next\n  call assert_equal('c', expand('%'))\n  call assert_equal('a\\`b c', expand('##'))\nendfunc\n\nfunc Test_edit_quit()\n  edit foo.txt\n  split\n  new\n  call setline(1, 'hello')\n  3wincmd w\n  redraw!\n  call assert_fails('1q', 'E37:')\n  bwipe! foo.txt\n  only\nendfunc\n\nfunc Test_edit_alt()\n  \" Keeping the cursor line didn't happen when the first line has indent.\n  new\n  call setline(1, ['  one', 'two', 'three'])\n  w XAltFile\n  $\n  call assert_equal(3, line('.'))\n  e Xother\n  e #\n  call assert_equal(3, line('.'))\n\n  bwipe XAltFile\n  call delete('XAltFile')\nendfunc\n\nfunc Test_edit_InsertLeave()\n  new\n  au InsertLeavePre * let g:did_au_pre = 1\n  au InsertLeave * let g:did_au = 1\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"afoo\\<Esc>\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(1, g:did_au)\n  call assert_equal('foo', getline(1))\n\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Sbar\\<C-C>\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(0, g:did_au)\n  call assert_equal('bar', getline(1))\n\n  inoremap x xx<Esc>\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Saax\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(1, g:did_au)\n  call assert_equal('aaxx', getline(1))\n\n  inoremap x xx<C-C>\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Sbbx\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(0, g:did_au)\n  call assert_equal('bbxx', getline(1))\n\n  bwipe!\n  au! InsertLeave InsertLeavePre\n  iunmap x\nendfunc\n\nfunc Test_edit_InsertLeave_undo()\n  new XtestUndo\n  set undofile\n  au InsertLeave * wall\n  exe \"normal ofoo\\<Esc>\"\n  call assert_equal(2, line('$'))\n  normal u\n  call assert_equal(1, line('$'))\n\n  bwipe!\n  au! InsertLeave\n  call delete('XtestUndo')\n  call delete(undofile('XtestUndo'))\n  set undofile&\nendfunc\n\n\" Test for inserting characters using CTRL-V followed by a number.\nfunc Test_edit_special_chars()\n  new\n\n  if has(\"ebcdic\")\n    let t = \"o\\<C-V>193\\<C-V>xc2\\<C-V>o303 \\<C-V>90a\\<C-V>xfg\\<C-V>o578\\<Esc>\"\n  else\n    let t = \"o\\<C-V>65\\<C-V>x42\\<C-V>o103 \\<C-V>33a\\<C-V>xfg\\<C-V>o78\\<Esc>\"\n  endif\n\n  exe \"normal \" . t\n  call assert_equal(\"ABC !a\\<C-O>g\\<C-G>8\", getline(2))\n\n  close!\nendfunc\n\nfunc Test_edit_startinsert()\n  new\n  set backspace+=start\n  call setline(1, 'foobar')\n  call feedkeys(\"A\\<C-U>\\<Esc>\", 'xt')\n  call assert_equal('', getline(1))\n\n  call setline(1, 'foobar')\n  call feedkeys(\":startinsert!\\<CR>\\<C-U>\\<Esc>\", 'xt')\n  call assert_equal('', getline(1))\n\n  set backspace&\n  bwipe!\nendfunc\n\n\" Test for :startreplace and :startgreplace\nfunc Test_edit_startreplace()\n  new\n  call setline(1, 'abc')\n  call feedkeys(\"l:startreplace\\<CR>xyz\\e\", 'xt')\n  call assert_equal('axyz', getline(1))\n  call feedkeys(\"0:startreplace!\\<CR>abc\\e\", 'xt')\n  call assert_equal('axyzabc', getline(1))\n  call setline(1, \"a\\tb\")\n  call feedkeys(\"0l:startgreplace\\<CR>xyz\\e\", 'xt')\n  call assert_equal(\"axyz\\tb\", getline(1))\n  call feedkeys(\"0i\\<C-R>=execute('startreplace')\\<CR>12\\e\", 'xt')\n  call assert_equal(\"12axyz\\tb\", getline(1))\n  close!\nendfunc\n\nfunc Test_edit_noesckeys()\n  CheckNotGui\n  new\n\n  \" <Left> moves cursor when 'esckeys' is set\n  exe \"set t_kl=\\<Esc>OD\"\n  set esckeys\n  call feedkeys(\"axyz\\<Esc>ODX\", \"xt\")\n  call assert_equal(\"xyXz\", getline(1))\n\n  \" <Left> exits Insert mode when 'esckeys' is off\n  set noesckeys\n  call setline(1, '')\n  call feedkeys(\"axyz\\<Esc>ODX\", \"xt\")\n  call assert_equal([\"DX\", \"xyz\"], getline(1, 2))\n\n  bwipe!\n  set esckeys\nendfunc\n\n\" Test for running an invalid ex command in insert mode using CTRL-O\nfunc Test_edit_ctrl_o_invalid_cmd()\n  new\n  set showmode showcmd\n  \" Avoid a sleep of 3 seconds. Zero might have side effects.\n  call test_override('ui_delay', 50)\n  let caught_e492 = 0\n  try\n    call feedkeys(\"i\\<C-O>:invalid\\<CR>abc\\<Esc>\", \"xt\")\n  catch /E492:/\n    let caught_e492 = 1\n  endtry\n  call assert_equal(1, caught_e492)\n  call assert_equal('abc', getline(1))\n  set showmode& showcmd&\n  call test_override('ui_delay', 0)\n  close!\nendfunc\n\n\" Test for editing a file with a very long name\nfunc Test_edit_illegal_filename()\n  CheckEnglish\n  new\n  redir => msg\n  exe 'edit ' . repeat('f', 5000)\n  redir END\n  call assert_match(\"Illegal file name$\", split(msg, \"\\n\")[0])\n  close!\nendfunc\n\n\" Test for editing a directory\nfunc Test_edit_is_a_directory()\n  CheckEnglish\n  let dirname = getcwd() . \"/Xdir\"\n  call mkdir(dirname, 'p')\n\n  new\n  redir => msg\n  exe 'edit' dirname\n  redir END\n  call assert_match(\"is a directory$\", split(msg, \"\\n\")[0])\n  bwipe!\n\n  let dirname .= '/'\n\n  new\n  redir => msg\n  exe 'edit' dirname\n  redir END\n  call assert_match(\"is a directory$\", split(msg, \"\\n\")[0])\n  bwipe!\n\n  call delete(dirname, 'rf')\nendfunc\n\n\" Test for editing a file using invalid file encoding\nfunc Test_edit_invalid_encoding()\n  CheckEnglish\n  call writefile([], 'Xfile')\n  redir => msg\n  new ++enc=axbyc Xfile\n  redir END\n  call assert_match('\\[NOT converted\\]', msg)\n  call delete('Xfile')\n  close!\nendfunc\n\n\" Test for the \"charconvert\" option\nfunc Test_edit_charconvert()\n  CheckEnglish\n  call writefile(['one', 'two'], 'Xfile')\n\n  \" set 'charconvert' to a non-existing function\n  set charconvert=NonExitingFunc()\n  new\n  let caught_e117 = v:false\n  try\n    redir => msg\n    edit ++enc=axbyc Xfile\n  catch /E117:/\n    let caught_e117 = v:true\n  finally\n    redir END\n  endtry\n  call assert_true(caught_e117)\n  call assert_equal(['one', 'two'], getline(1, '$'))\n  call assert_match(\"Conversion with 'charconvert' failed\", msg)\n  close!\n  set charconvert&\n\n  \" 'charconvert' function doesn't create a output file\n  func Cconv1()\n  endfunc\n  set charconvert=Cconv1()\n  new\n  redir => msg\n  edit ++enc=axbyc Xfile\n  redir END\n  call assert_equal(['one', 'two'], getline(1, '$'))\n  call assert_match(\"can't read output of 'charconvert'\", msg)\n  close!\n  delfunc Cconv1\n  set charconvert&\n\n  \" 'charconvert' function to convert to upper case\n  func Cconv2()\n    let data = readfile(v:fname_in)\n    call map(data, 'toupper(v:val)')\n    call writefile(data, v:fname_out)\n  endfunc\n  set charconvert=Cconv2()\n  new Xfile\n  write ++enc=ucase Xfile1\n  call assert_equal(['ONE', 'TWO'], readfile('Xfile1'))\n  call delete('Xfile1')\n  close!\n  delfunc Cconv2\n  set charconvert&\n\n  \" 'charconvert' function removes the input file\n  func Cconv3()\n    call delete(v:fname_in)\n  endfunc\n  set charconvert=Cconv3()\n  new\n  call assert_fails('edit ++enc=lcase Xfile', 'E202:')\n  call assert_equal([''], getline(1, '$'))\n  close!\n  delfunc Cconv3\n  set charconvert&\n\n  call delete('Xfile')\nendfunc\n\n\" Test for editing a file without read permission\nfunc Test_edit_file_no_read_perm()\n  CheckUnix\n  CheckNotRoot\n\n  call writefile(['one', 'two'], 'Xfile')\n  call setfperm('Xfile', '-w-------')\n  new\n  redir => msg\n  edit Xfile\n  redir END\n  call assert_equal(1, &readonly)\n  call assert_equal([''], getline(1, '$'))\n  call assert_match('\\[Permission Denied\\]', msg)\n  close!\n  call delete('Xfile')\nendfunc\n\n\" Pressing escape in 'insertmode' should beep\nfunc Test_edit_insertmode_esc_beeps()\n  new\n  set insertmode\n  call assert_beeps(\"call feedkeys(\\\"one\\<Esc>\\\", 'xt')\")\n  set insertmode&\n  \" unsupported CTRL-G command should beep in insert mode.\n  call assert_beeps(\"normal i\\<C-G>l\")\n  close!\nendfunc\n\n\" Test for 'hkmap' and 'hkmapp'\nfunc Test_edit_hkmap()\n  CheckFeature rightleft\n  if has('win32') && !has('gui')\n    throw 'Skipped: fails on the MS-Windows terminal version'\n  endif\n  new\n\n  set revins hkmap\n  let str = 'abcdefghijklmnopqrstuvwxyz'\n  let str ..= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let str ..= '`/'',.;'\n  call feedkeys('i' .. str, 'xt')\n  let expected = \"\u00f3\u00f5\u00fa,.;\"\n  let expected ..= \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n  let expected ..= \"\u00e6\u00e8\u00f1'\u00e4\u00e5\u00e0\u00e3\u00f8/\u00f4\u00ed\u00ee\u00f6\u00ea\u00ec\u00e7\u00ef\u00e9\u00f2\u00eb\u00f7\u00e2\u00e1\u00f0\u00f9\"\n  call assert_equal(expected, getline(1))\n\n  %d\n  set revins hkmap hkmapp\n  let str = 'abcdefghijklmnopqrstuvwxyz'\n  let str ..= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  call feedkeys('i' .. str, 'xt')\n  let expected = \"\u00f5YXWVUTSRQ\u00f3O\u00ef\u00edLKJIHGFED\u00eaBA\"\n  let expected ..= \"\u00f6\u00f2X\u00f9\u00e5\u00e8\u00fa\u00e6\u00f8'\u00f4\u00f1\u00f0\u00ee\u00ec\u00f7\u00e7\u00e9\u00e4\u00e2\u00f3\u01df\u00e3\u00eb\u00e1\u00e0\"\n  call assert_equal(expected, getline(1))\n\n  set revins& hkmap& hkmapp&\n  close!\nendfunc\n\n\" Test for 'allowrevins' and using CTRL-_ in insert mode\nfunc Test_edit_allowrevins()\n  CheckFeature rightleft\n  new\n  set allowrevins\n  call feedkeys(\"iABC\\<C-_>DEF\\<C-_>GHI\", 'xt')\n  call assert_equal('ABCFEDGHI', getline(1))\n  set allowrevins&\n  close!\nendfunc\n\n\" Test for inserting a register in insert mode using CTRL-R\nfunc Test_edit_insert_reg()\n  new\n  let g:Line = ''\n  func SaveFirstLine()\n    let g:Line = Screenline(1)\n    return 'r'\n  endfunc\n  inoremap <expr> <buffer> <F2> SaveFirstLine()\n  call test_override('redraw_flag', 1)\n  call test_override('char_avail', 1)\n  let @r = 'sample'\n  call feedkeys(\"a\\<C-R>=SaveFirstLine()\\<CR>\", \"xt\")\n  call assert_equal('\"', g:Line)\n  call test_override('ALL', 0)\n  close!\nendfunc\n\n\" When a character is inserted at the last position of the last line in a\n\" window, the window contents should be scrolled one line up. If the top line\n\" is part of a fold, then the entire fold should be scrolled up.\nfunc Test_edit_lastline_scroll()\n  new\n  let h = winheight(0)\n  let lines = ['one', 'two', 'three']\n  let lines += repeat(['vim'], h - 4)\n  call setline(1, lines)\n  call setline(h, repeat('x', winwidth(0) - 1))\n  call feedkeys(\"GAx\", 'xt')\n  redraw!\n  call assert_equal(h - 1, winline())\n  call assert_equal(2, line('w0'))\n\n  \" scroll with a fold\n  1,2fold\n  normal gg\n  call setline(h + 1, repeat('x', winwidth(0) - 1))\n  call feedkeys(\"GAx\", 'xt')\n  redraw!\n  call assert_equal(h - 1, winline())\n  call assert_equal(3, line('w0'))\n\n  close!\nendfunc\n\nfunc Test_edit_browse()\n  \" in the GUI this opens a file picker, we only test the terminal behavior\n  CheckNotGui\n\n  \" \":browse xxx\" checks for the FileExplorer augroup and assumes editing \".\"\n  \" works then.\n  augroup FileExplorer\n    au!\n  augroup END\n\n  \" When the USE_FNAME_CASE is defined this used to cause a crash.\n  browse enew\n  bwipe!\n\n  browse split\n  bwipe!\nendfunc\n\nfunc Test_read_invalid()\n  set encoding=latin1\n  \" This was not properly checking for going past the end.\n  call assert_fails('r`=', 'E484')\n  set encoding=utf-8\nendfunc\n\n\" Test for the 'revins' option\nfunc Test_edit_revins()\n  CheckFeature rightleft\n  new\n  set revins\n  exe \"normal! ione\\ttwo three\"\n  call assert_equal(\"eerht owt\\teno\", getline(1))\n  call setline(1, \"one\\ttwo three\")\n  normal! gg$bi a\n  call assert_equal(\"one\\ttwo a three\", getline(1))\n  exe \"normal! $bi\\<BS>\\<BS>\"\n  call assert_equal(\"one\\ttwo a ree\", getline(1))\n  exe \"normal! 0wi\\<C-W>\"\n  call assert_equal(\"one\\t a ree\", getline(1))\n  exe \"normal! 0wi\\<C-U>\"\n  call assert_equal(\"one\\t \", getline(1))\n  \" newline in insert mode starts at the end of the line\n  call setline(1, 'one two three')\n  exe \"normal! wi\\nfour\"\n  call assert_equal(['one two three', 'ruof'], getline(1, '$'))\n  set revins&\n  bw!\nendfunc\n\n\" Test for getting the character of the line below after \"p\"\nfunc Test_edit_put_CTRL_E()\n  set encoding=latin1\n  new\n  let @\" = ''\n  sil! norm or\u0003ggRx\n  sil! norm pr\u0005\n  call assert_equal(['r', 'r'], getline(1, 2))\n  bwipe!\n  set encoding=utf-8\nendfunc\n\n\" Test for ModeChanged pattern\nfunc Test_mode_changes()\n  let g:index = 0\n  let g:mode_seq = ['n', 'i', 'n', 'v', 'V', 'i', 'ix', 'i', 'ic', 'i', 'n', 'no', 'n', 'V', 'v', 's', 'n']\n  func! TestMode()\n    call assert_equal(g:mode_seq[g:index], get(v:event, \"old_mode\"))\n    call assert_equal(g:mode_seq[g:index + 1], get(v:event, \"new_mode\"))\n    call assert_equal(mode(1), get(v:event, \"new_mode\"))\n    let g:index += 1\n  endfunc\n\n  au ModeChanged * :call TestMode()\n  let g:n_to_any = 0\n  au ModeChanged n:* let g:n_to_any += 1\n  call feedkeys(\"i\\<esc>vVca\\<CR>\\<C-X>\\<C-L>\\<esc>ggdG\", 'tnix')\n\n  let g:V_to_v = 0\n  au ModeChanged V:v let g:V_to_v += 1\n  call feedkeys(\"Vv\\<C-G>\\<esc>\", 'tnix')\n  call assert_equal(len(filter(g:mode_seq[1:], {idx, val -> val == 'n'})), g:n_to_any)\n  call assert_equal(1, g:V_to_v)\n  call assert_equal(len(g:mode_seq) - 1, g:index)\n\n  let g:n_to_i = 0\n  au ModeChanged n:i let g:n_to_i += 1\n  let g:n_to_niI = 0\n  au ModeChanged i:niI let g:n_to_niI += 1\n  let g:niI_to_i = 0\n  au ModeChanged niI:i let g:niI_to_i += 1\n  let g:nany_to_i = 0\n  au ModeChanged n*:i let g:nany_to_i += 1\n  let g:i_to_n = 0\n  au ModeChanged i:n let g:i_to_n += 1\n  let g:nori_to_any = 0\n  au ModeChanged [ni]:* let g:nori_to_any += 1\n  let g:i_to_any = 0\n  au ModeChanged i:* let g:i_to_any += 1\n  let g:index = 0\n  let g:mode_seq = ['n', 'i', 'niI', 'i', 'n']\n  call feedkeys(\"a\\<C-O>l\\<esc>\", 'tnix')\n  call assert_equal(len(g:mode_seq) - 1, g:index)\n  call assert_equal(1, g:n_to_i)\n  call assert_equal(1, g:n_to_niI)\n  call assert_equal(1, g:niI_to_i)\n  call assert_equal(2, g:nany_to_i)\n  call assert_equal(1, g:i_to_n)\n  call assert_equal(2, g:i_to_any)\n  call assert_equal(3, g:nori_to_any)\n\n  if has('terminal')\n    let g:mode_seq += ['c', 'n', 't', 'nt', 'c', 'nt', 'n']\n    call feedkeys(\":term\\<CR>\\<C-W>N:bd!\\<CR>\", 'tnix')\n    call assert_equal(len(g:mode_seq) - 1, g:index)\n    call assert_equal(1, g:n_to_i)\n    call assert_equal(1, g:n_to_niI)\n    call assert_equal(1, g:niI_to_i)\n    call assert_equal(2, g:nany_to_i)\n    call assert_equal(1, g:i_to_n)\n    call assert_equal(2, g:i_to_any)\n    call assert_equal(5, g:nori_to_any)\n  endif\n\n  au! ModeChanged\n  delfunc TestMode\n  unlet! g:mode_seq\n  unlet! g:index\n  unlet! g:n_to_any\n  unlet! g:V_to_v\n  unlet! g:n_to_i\n  unlet! g:n_to_niI\n  unlet! g:niI_to_i\n  unlet! g:nany_to_i\n  unlet! g:i_to_n\n  unlet! g:nori_to_any\n  unlet! g:i_to_any\nendfunc\n\nfunc Test_recursive_ModeChanged()\n  au! ModeChanged * norm 0u\n  sil! norm \u0016\n  au! ModeChanged\nendfunc\n\nfunc Test_ModeChanged_starts_visual()\n  \" This was triggering ModeChanged before setting VIsual, causing a crash.\n  au! ModeChanged * norm 0u\n  sil! norm \u0016\n\n  au! ModeChanged\nendfunc\n\n\" Test toggling of input method. See :help i_CTRL-^\nfunc Test_edit_CTRL_hat()\n  CheckFeature xim\n\n  \" FIXME: test fails with Athena and Motif GUI.\n  \"        test also fails when running in the GUI.\n  CheckFeature gui_gtk\n  CheckNotGui\n\n  new\n\n  call assert_equal(0, &iminsert)\n  call feedkeys(\"i\\<C-^>\", 'xt')\n  call assert_equal(2, &iminsert)\n  call feedkeys(\"i\\<C-^>\", 'xt')\n  call assert_equal(0, &iminsert)\n\n  bwipe!\nendfunc\n\n\" Weird long file name was going over the end of NameBuff\nfunc Test_edit_overlong_file_name()\n  CheckUnix\n\n  file 0000000000000000000000000000\n  file %%%%%%%%%%%%%%%%%%%%%%%%%%\n  file %%%%%%\n  set readonly\n  set ls=2 \n\n  redraw!\n  set noreadonly ls&\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/drawscreen.c", "src/testdir/test_edit.vim", "src/version.c"], "buggy_code_start_loc": [465, 2105, 752], "buggy_code_end_loc": [471, 2105, 752], "fixing_code_start_loc": [465, 2106, 753], "fixing_code_end_loc": [472, 2121, 755], "type": "CWE-122", "message": "vim is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2022-0213", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-14T13:15:07.603", "lastModified": "2022-11-09T03:32:22.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "vim es vulnerable al desbordamiento del b\u00fafer en la regi\u00f3n Heap de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2", "matchCriteriaId": "8E36296E-EE72-4469-A40D-73AF3C7C1825"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/de05bb25733c3319e18dca44e9b59c6ee389eb26", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f3afe1a5-e6f8-4579-b68a-6e5c7e39afed", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/de05bb25733c3319e18dca44e9b59c6ee389eb26"}}