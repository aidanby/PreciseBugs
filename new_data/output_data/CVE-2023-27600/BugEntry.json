{"buggy_code": ["/*\n * Copyright (C) 2009 Voice Sistem SRL\n * Copyright (C) 2009 Andrei Dragus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n *\n */\n\n#include \"../../sr_module.h\"\n#include \"../../parser/msg_parser.h\"\n#include \"../../mem/mem.h\"\n#include \"../../data_lump.h\"\n#include \"../../parser/sdp/sdp.h\"\n#include \"codecs.h\"\n#include \"../../route.h\"\n#include \"../../mod_fix.h\"\n\n#define MAX_STREAMS 64\n\nstatic struct lump *lumps[MAX_STREAMS];\nstatic int lumps_len;\n\nenum{\n\tFIND,\n\tDELETE,\n\tADD_TO_FRONT,\n\tADD_TO_BACK\n};\n\nenum{\n\tDESC_NAME,\n\tDESC_NAME_AND_CLOCK,\n\tDESC_REGEXP,\n\tDESC_REGEXP_COMPLEMENT\n};\n\n\nstatic int do_for_all_streams(struct sip_msg* msg, str* str1,str * str2,\n\t\tregex_t* re, int op,int desc);\nstatic int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\tstr * s, str* ss, regex_t* re, int op,int description);\n\n\n/*\n * Create the necessary lumps from the message\n */\nstatic int create_codec_lumps(struct sip_msg * msg)\n{\n\n\tstruct sdp_session_cell * cur_session;\n\tstruct lump * tmp;\n\tint count;\n\n\t/* get the number of streams */\n\tlumps_len = 0;\n\tcur_session = get_sdp(msg)->sessions;\n\n\twhile(cur_session)\n\t{\n\t\tlumps_len += cur_session->streams_num;\n\t\tcur_session = cur_session->next;\n\t}\n\n\tif (lumps_len>MAX_STREAMS)\n\t{\n\t\tLM_ERR(\"Overflow - too many streams (%d), limit is %d\\n\",\n\t\t\tlumps_len, MAX_STREAMS);\n\t\treturn -1;\n\t}\n\tmemset(lumps, 0, MAX_STREAMS * sizeof(struct lump*));\n\n\t/* for each stream create a specific lump for deletion, skip\n\t * and insertion */\n\n\tLM_DBG(\"creating %d streams\\n\",lumps_len);\n\n\tcount = 0;\n\tcur_session = get_sdp(msg)->sessions;\n\n\twhile(cur_session)\n\t{\n\t\tstruct sdp_stream_cell * cur_cell = cur_session->streams;\n\t\tstruct lump* l;\n\t\tstr text;\n\t\tstr payloads;\n\n\t\twhile(cur_cell)\n\t\t{\n\t\t\tpayloads = cur_cell->payloads;\n\t\t\t/* include the previous whitespaces */\n\t\t\twhile (payloads.s > cur_cell->body.s && *(payloads.s-1) == ' ') {\n\t\t\t\tpayloads.s--;\n\t\t\t\tpayloads.len++;\n\t\t\t}\n\n\t\t\tl = del_lump(msg, payloads.s - msg->buf, payloads.len, 0);\n\n\t\t\tlumps[count] = l;\n\n\t\t\tif( l == NULL)\n\t\t\t{\n\t\t\t\tLM_ERR(\"Error adding delete lump for m=\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tl->flags |= LUMPFLAG_CODEC;\n\n\t\t\ttmp = insert_skip_lump_after( l );\n\t\t\tif(tmp == NULL)\n\t\t\t{\n\t\t\t\tLM_ERR(\"Error adding skip lump for m=\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\ttext.len = payloads.len;\n\t\t\ttext.s = (char*)pkg_malloc(payloads.len);\n\n\t\t\tif( text.s == NULL )\n\t\t\t{\n\t\t\t\tLM_ERR(\"Error allocating lump buffer\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tmemcpy(text.s,payloads.s,payloads.len);\n\n\t\t\ttmp = insert_new_lump_after( tmp, text.s, text.len, 0);\n\t\t\tif(tmp == NULL)\n\t\t\t{\n\t\t\t\tLM_ERR(\"Error adding insert lump for m=\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcount ++;\n\t\t\tcur_cell = cur_cell->next;\n\t\t}\n\n\t\tcur_session = cur_session->next;\n\n\t}\n\n\treturn 0;\n};\n\n\n/*\n * Find the flagged lumps and save them in the global lump array\n * Returns : 0 - codec lumps found\n *           1 - no lump found\n *          -1 - error\n */\nstatic int find_codec_lumps(struct sip_msg * msg)\n{\n\tstruct lump *cur = msg->body_lumps;\n\tint count = 0;\n\n\twhile( cur)\n\t{\n\t\tif( cur->flags & LUMPFLAG_CODEC && cur->after && cur->after->after)\n\t\t\tcount++;\n\t\tcur = cur->next;\n\t}\n\n\tif (count>MAX_STREAMS) {\n\t\tLM_CRIT(\"BUG: too many codec lumps found (%d)\\n\",count);\n\t\treturn -1;\n\t}\n\n\tif( count==0 ) {\n\t\tlumps_len = -1;\n\t\treturn 1;\n\t}\n\n\tlumps_len=0;\n\tcur = msg->body_lumps;\n\twhile( cur)\n\t{\n\t\tif( cur->flags & LUMPFLAG_CODEC && cur->after && cur->after->after)\n\t\t{\n\t\t\tlumps[lumps_len] = cur;\n\t\t\tlumps_len++;\n\t\t}\n\t\tcur = cur->next;\n\t}\n\tLM_DBG(\"found %d streams\\n\",lumps_len);\n\n\treturn 0;\n};\n\n\nstatic int clone_codec_lumps(void)\n{\n\tstruct lump *l;\n\tint i;\n\tchar *s;\n\n\tLM_DBG(\"cloning %d streams\\n\",lumps_len);\n\n\tfor( i=0 ; i<lumps_len ; i++ ) {\n\t\t/* get last lump for stream */\n\t\tfor( l=lumps[i] ; l->after ; l=l->after );\n\n\t\ts = pkg_malloc( l->len+1 );\n\t\tif (s==NULL) {\n\t\t\tLM_ERR(\"failed to alloc new lump pkg buffer\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy( s, l->u.value, l->len);\n\n\t\tif (insert_new_lump_after( l, s, l->len, 0)==NULL) {\n\t\t\tLM_ERR(\"failed to create new lump\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int get_codec_lumps( struct sip_msg *msg )\n{\n\tint rc;\n\n\trc = find_codec_lumps(msg);\n\tif (rc<0) {\n\t\tLM_ERR(\"error while searching for codec flags\\n\");\n\t\treturn -1;\n\t}\n\n\t/* codec lumps not yet created -> create them now */\n\tif (rc==1) {\n\t\tif( create_codec_lumps(msg)<0 ) {\n\t\t\tLM_ERR(\"failed to create codec lumps\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* success - we gave the lumps */\n\t\treturn 0;\n\t}\n\n\t/* seams the lumps are already created */\n\tif( route_type & (REQUEST_ROUTE | ONREPLY_ROUTE | LOCAL_ROUTE)  )\n\t{\n\t\t/* save to use them directly */\n\t\treturn 0;\n\t}\n\n\tif( route_type & (FAILURE_ROUTE | BRANCH_ROUTE) )\n\t{\n\t\t/* clone the inserted lumps */\n\t\tif ( clone_codec_lumps()<0 ) {\n\t\t\tLM_ERR(\"failed to clone codec lumps\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* shoudn't get here */\n\treturn -1;\n};\n\n\n/*\n * Associate a lump with a given cell\n */\nstatic struct lump * get_associated_lump(struct sip_msg * msg,\n\t\t\t\t\t\t\t\t  struct sdp_stream_cell * cell)\n{\n\tstruct lump *lmp;\n\tchar *payload;\n\tint i, have,want;\n\n\tLM_DBG(\"Have %d lumps\\n\",lumps_len);\n\n\tfor( i =0 ; i< lumps_len; i++)\n\t{\n\t\thave = lumps[i]->u.offset;\n\t\tpayload = cell->payloads.s;\n\t\twhile (payload > cell->body.s && *(payload - 1) == ' ')\n\t\t\tpayload--;\n\t\twant = payload - msg->buf;\n\n\t\tLM_DBG(\"have lump at %d want at %d\\n\", have, want );\n\t\tif( have == want ) {\n\t\t\t/* got root lump, return the last data one */\n\t\t\tfor( lmp=lumps[i] ; lmp->after ; lmp=lmp->after);\n\t\t\treturn lmp;\n\t\t}\n\t}\n\n\treturn NULL;\n};\n\n\nstatic int do_for_all_streams(struct sip_msg* msg, str* str1,str * str2,\n\t\t\t\tregex_t* re, int op,int desc)\n{\n\tstruct sdp_session_cell * cur_session;\n\tsdp_info_t *sdp;\n\tint rez;\n\n\tif (msg==NULL || msg==FAKED_REPLY)\n\t\treturn -1;\n\n\tsdp = parse_sdp(msg);\n\tif (!sdp) {\n\t\tLM_DBG(\"Message has no SDP\\n\");\n\t\treturn -1;\n\t}\n\n\tif (get_codec_lumps(msg)<0) {\n\t\tLM_ERR(\"failed to prepare changes for codecs\\n\");\n\t\treturn -1;\n\t}\n\n\tcur_session = sdp->sessions;\n\trez = -1;\n\n\twhile(cur_session)\n\t{\n\t\tstruct sdp_stream_cell * cur_cell = cur_session->streams;\n\n\t\twhile(cur_cell)\n\t\t{\n\t\t\tif(stream_process(msg,cur_cell,str1,str2,re,op,desc)==1)\n\t\t\t\trez = 1;\n\t\t\tcur_cell = cur_cell->next;\n\t\t}\n\n\t\tcur_session = cur_session->next;\n\n\t}\n\n\treturn rez;\n}\n\n\n/* deletes a SDP line (from a stream) by giving a pointer within the line.\n * The stream is used to safeguard the identification of the line boundries.\n */\nint delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)\n{\n\tchar * start,*end;\n\n\tif( !s )\n\t\treturn 1;\n\n\tstart = s;\n\tend  = s;\n\n\twhile(*start != '\\n' && start > stream->body.s)\n\t\tstart--;\n\tstart++;\n\n\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )\n\t\tend++;\n\tend++;\n\n\t/* delete the entry */\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n/* method that processes a stream and keeps the original order\n * of codecs with the same name */\nstatic int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\t\tstr * s, str* ss, regex_t* re, int op,int description)\n{\n\tstatic sdp_payload_attr_t static_payloads[] = {\n\t/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */\n\t{ NULL,0,{ \"0\",1},{\"PCMU\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */\n\t{ NULL,0,{ \"3\",1},{ \"GSM\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */\n\t{ NULL,0,{ \"4\",1},{\"G723\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */\n\t{ NULL,0,{ \"5\",1},{\"DVI4\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */\n\t{ NULL,0,{ \"6\",1},{\"DVI4\",4},{\"16000\",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */\n\t{ NULL,0,{ \"7\",1},{ \"LPC\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */\n\t{ NULL,0,{ \"8\",1},{\"PCMA\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */\n\t{ NULL,0,{ \"9\",1},{\"G722\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */\n\t{ NULL,0,{\"10\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */\n\t{ NULL,0,{\"11\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */\n\t{ NULL,0,{\"12\",2},{\"QCELP\",5},{\"8000\",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */\n\t{ NULL,0,{\"13\",2},{  \"CN\",2},{ \"8000\",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */\n\t{ NULL,0,{\"14\",2},{ \"MPA\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */\n\t{ NULL,0,{\"15\",2},{\"G728\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */\n\t{ NULL,0,{\"16\",2},{\"DVI4\",4},{\"11025\",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */\n\t{ NULL,0,{\"17\",2},{\"DVI4\",4},{\"22050\",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */\n\t{ NULL,0,{\"18\",2},{\"G729\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */\n\t{ NULL,0,{\"25\",2},{\"CelB\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */\n\t{ NULL,0,{\"26\",2},{\"JPEG\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */\n\t{ NULL,0,{\"28\",2},{  \"nv\",2},{\"90000\",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */\n\t{ NULL,0,{\"31\",2},{\"H261\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */\n\t{ NULL,0,{\"32\",2},{ \"MPV\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */\n\t{ NULL,0,{\"33\",2},{\"MP2T\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */\n\t{ NULL,0,{\"34\",2},{\"H263\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */\n\t{ NULL,0,{\"t38\",3},{\"t38\",3},{     \"\",0},{NULL,0},{NULL,0} },   /*T38- fax        */\n\t{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }\n\t};\n\tsdp_payload_attr_t *payload;\n\tchar *cur, *tmp, *buff, temp;\n\tstruct lump * lmp;\n\tstr found;\n\tint ret, i,match, buff_len, is_static;\n\tregmatch_t pmatch;\n\n\n\tlmp = get_associated_lump(msg, cell);\n\tif( lmp == NULL)\n\t{\n\t\tLM_ERR(\"There is no lump for this sdp cell\\n\");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\n\tbuff_len = 0;\n\tret = 0;\n\n\tbuff = pkg_malloc(lmp->len+1);\n\tif( buff == NULL)\n\t{\n\t\tLM_ERR(\"Out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\t/* search through each payload */\n\tis_static = 0;\n\tpayload = cell->payload_attr;\n\n\twhile(payload)\n\t{\n\t\tif( payload->rtp_enc.s == NULL\n\t\t || (payload->rtp_clock.s == NULL && ss != NULL)\n\t\t || payload->rtp_payload.s == NULL)\n\t\t{\n\t\t\tgoto next_payload;\n\t\t}\n\n\t\tmatch = 0;\n\n\t\tif( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )\n\t\t{\n\t\t\t/* try to match a regexp */\n\t\t\tif (is_static) {\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t} else {\n\t\t\t\ttemp = payload->rtp_enc.s[payload->rtp_enc.len];\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = 0;\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = temp;\n\t\t\t}\n\t\t}\n\n\t\tif( description == DESC_REGEXP_COMPLEMENT)\n\t\t\tmatch = !match;\n\n\t\tif( description == DESC_NAME  )\n\t\t{\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\tpayload->rtp_enc.len) == 0;\n\t\t}\n\n\t\tif( description == DESC_NAME_AND_CLOCK)\n\t\t{\n\t\t\t/* try to match name and clock if there is one */\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\n\t\t\t\tpayload->rtp_enc.len) == 0\n\t\t\t&&\n\t\t\t(ss == NULL || ( ss->len == payload->rtp_clock.len &&\n\t\t\tstrncasecmp( ss->s, payload->rtp_clock.s ,\n\t\t\t\tpayload->rtp_clock.len) == 0\n\t\t\t) );\n\t\t}\n\n\t\t/* if found, search its index in the m= line */\n\t\tif (match) {\n\n\t\t\tmatch = 0;\n\n\t\t\tcur = lmp->u.value;\n\t\t\twhile( !match && cur < lmp->u.value + lmp->len)\n\t\t\t{\n\t\t\t\t/* find the end of the number */\n\t\t\t\tfound.s = cur;\n\n\t\t\t\twhile(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )\n\t\t\t\t\tcur++;\n\n\t\t\t\tfound.len = cur - found.s;\n\n\t\t\t\t/* does it matches payload number */\n\t\t\t\tif ( found.len == payload->rtp_payload.len &&\n\t\t\t\tstrncmp( found.s,payload->rtp_payload.s,found.len) == 0) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* continue on searching => skip spaces\n\t\t\t\t\t   if there still are any */\n\t\t\t\t\twhile( cur < lmp->u.value + lmp->len && * cur == ' '  )\n\t\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* have we found both payload and index */\n\t\t\tif (match) {\n\n\t\t\t\tif(op == FIND)\n\t\t\t\t{\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif( op == DELETE && !is_static )\n\t\t\t\t{\n\t\t\t\t\t/* find the full 'a=...' entry */\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t/* take the previous whitespaces as well */\n\t\t\t\t\twhile (found.s > lmp->u.value && *(found.s - 1) == ' ') {\n\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n\t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n\t\t\t\t\t\ttmp = found.s;\n\t\t\t\t\t\twhile (*(--tmp) == ' ') {\n\t\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* delete the string and update iterators */\n\t\t\t\t\tfor(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )\n\t\t\t\t\t\t*tmp  = *(tmp+found.len);\n\n\t\t\t\t\t//cur -= found.len;\n\t\t\t\t\tlmp->len -= found.len;\n\t\t\t\t}\n\n\t\t\t\t/* add the deleted number into a buffer to be addded later */\n\t\t\t\tif( op == ADD_TO_FRONT  || op == ADD_TO_BACK)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&buff[buff_len],\" \",1);\n\t\t\t\t\tbuff_len++;\n\n\t\t\t\t\tmemcpy(&buff[buff_len],payload->rtp_payload.s,\n\t\t\t\t\t\tpayload->rtp_payload.len);\n\n\t\t\t\t\tbuff_len += payload->rtp_payload.len;\n\t\t\t\t}\n\n\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t}\n\n\t\t/* next payload */\n\tnext_payload:\n\t\tif (!is_static) {\n\t\t\tpayload = payload->next;\n\t\t\tif (payload==NULL) {\n\t\t\t\tpayload = static_payloads;\n\t\t\t\tis_static = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpayload ++;\n\t\t\tif (payload->rtp_payload.s==NULL)\n\t\t\t\tpayload=NULL;\n\t\t}\n\t}\n\n\n\tif( op == ADD_TO_FRONT && buff_len >0 )\n\t{\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor( i = lmp->len -1 ; i>=0;i--)\n\t\t\tlmp->u.value[i+buff_len] = lmp->u.value[i];\n\n\t\tmemcpy(lmp->u.value,buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\tif( op == ADD_TO_BACK && buff_len >0 )\n\t{\n\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tmemcpy(&lmp->u.value[lmp->len],buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\t/* if we ended up with a 0-length lump, then it means that all payloads\n\t * have been deleted, therefore we need to disable the media stream */\n\tif (lmp->len == 0) {\n\t\t/* replace the media port with 0 - we also replace the spaces before\n\t\t * and after the port, to make sure we have a larger buffer */\n\t\tlmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);\n\t\tif (!lmp) {\n\t\t\tLM_ERR(\"could not add lump to disable stream!\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\ttmp = pkg_malloc(3);\n\t\tif (!tmp) {\n\t\t\tLM_ERR(\"oom for port 0\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(tmp, \" 0 \", 3);\n\t\tif (!insert_new_lump_after(lmp, tmp, 3, 0))\n\t\t\tLM_ERR(\"could not insert lump to disable stream!\\n\");\n\t}\n\nend:\n\tpkg_free(buff);\n\treturn ret;\n}\n\n\nint codec_find(struct sip_msg* msg, str* codec, str* clock)\n{\n\tLM_DBG(\"searching for codec <%.*s>, clock <%.*s> \\n\",\n\t\tcodec->len, codec->s,\n\t\tclock ? clock->len : 0, clock ? clock->s : NULL);\n\n\treturn do_for_all_streams(msg, codec, clock, NULL, FIND, DESC_NAME);\n}\n\nint codec_find_re (struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams(msg, NULL, NULL, re, FIND, DESC_REGEXP);\n}\n\n\nint codec_delete_re(struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams(msg, NULL, NULL, re, DELETE, DESC_REGEXP);\n}\n\n\nint codec_delete_except_re(struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams( msg, NULL, NULL, re,\n\t\tDELETE, DESC_REGEXP_COMPLEMENT);\n}\n\n\nint codec_delete(struct sip_msg* msg, str* codec, str* clock)\n{\n\tLM_DBG(\"deleting codec <%.*s> with clock <%.*s> \\n\",\n\t\tcodec->len, codec->s, clock ? clock->len : 0, clock ? clock->s : NULL);\n\n\treturn do_for_all_streams( msg, codec, clock, NULL,\n\t\tDELETE, DESC_NAME_AND_CLOCK);\n}\n\n\nint codec_move_up_re(struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams( msg, NULL, NULL, re,\n\t\tADD_TO_FRONT, DESC_REGEXP);\n}\n\n\nint codec_move_up(struct sip_msg* msg, str* codec, str* clock)\n{\n\tLM_DBG(\"moving up codec <%.*s> with clock <%.*s> \\n\",\n\t\tcodec->len, codec->s, clock ? clock->len : 0, clock ? clock->s : NULL);\n\n\treturn do_for_all_streams(msg, codec, clock, NULL,\n\t\tADD_TO_FRONT, DESC_NAME_AND_CLOCK);\n}\n\n\nint codec_move_down_re(struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams( msg, NULL, NULL, re,\n\t\tADD_TO_BACK, DESC_REGEXP);\n}\n\n\nint codec_move_down(struct sip_msg* msg, str* codec, str* clock)\n{\n\tLM_DBG(\"moving down codec <%.*s> with clock <%.*s> \\n\",\n\t\tcodec->len, codec->s, clock ? clock->len : 0, clock ? clock->s : NULL);\n\n\treturn do_for_all_streams( msg, codec, clock, NULL,\n\t\tADD_TO_BACK, DESC_NAME_AND_CLOCK);\n}\n\n\nstatic int handle_streams(struct sip_msg* msg, regex_t* re, regex_t* re2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint delete)\n{\n\tstruct sdp_session_cell *session;\n\tstruct sdp_stream_cell *stream;\n\tstruct sdp_stream_cell *prev_stream;\n\tregmatch_t pmatch;\n\tstruct lump *lmp, *l;\n\tchar *begin, *end;\n\tchar temp;\n\tstr body;\n\tint match;\n\n\tif (msg==NULL || msg==FAKED_REPLY)\n\t\treturn -1;\n\n\tif(!parse_sdp(msg))\n\t{\n\t\tLM_DBG(\"Message has no SDP\\n\");\n\t\treturn -1;\n\t}\n\n\t/* search for the stream */\n\tmatch = 0;\n\tfor (session = get_sdp(msg)->sessions; session && !match;\n\t     session = session->next) {\n\t\tprev_stream = NULL;\n\t\tfor( stream=session->streams ; stream ;\n\t\tprev_stream=stream,stream=stream->next){\n\t\t\t/* check the media in stream, re based */\n\t\t\ttemp = stream->media.s[stream->media.len];\n\t\t\tstream->media.s[stream->media.len] = 0;\n\t\t\tmatch = regexec( re, stream->media.s, 1, &pmatch, 0) == 0;\n\t\t\tstream->media.s[stream->media.len] = temp;\n\t\t\t/* optionally check the transport in stream also */\n\t\t\tif (match && re2) {\n\t\t\t\ttemp = stream->transport.s[stream->transport.len];\n\t\t\t\tstream->transport.s[stream->transport.len] = 0;\n\t\t\t\tmatch = regexec( re2, stream->transport.s, 1, &pmatch, 0) == 0;\n\t\t\t\tstream->transport.s[stream->transport.len] = temp;\n\t\t\t}\n\t\t\tif (match) break;\n\t\t}\n\t}\n\n\tif (!match)\n\t\treturn -1;\n\n\tLM_DBG(\" found stream media [%.*s], transport [%.*s]\\n\",\n\t\tstream->media.len,stream->media.s,\n\t\tstream->transport.len,stream->transport.s);\n\n\t/* stream found */\n\tif (!delete)\n\t\treturn 1;\n\n\n\t/* have to delete the stream*/\n\tif (get_codec_lumps(msg)<0) {\n\t\tLM_ERR(\"failed to get lumps for streams\\n\");\n\t\treturn -1;\n\t}\n\tlmp = get_associated_lump(msg, stream);\n\tif( lmp == NULL) {\n\t\tLM_ERR(\"There is no lump for this sdp cell\\n\");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\t/* search the boundries of the stream */\n\n\t/* look for the beginning of the \"m\" line */\n\tbegin = stream->media.s ;\n\twhile( *(begin-1)!='\\n' && *(begin-1)!='\\r') begin--;\n\n\t/* the end is where the next stream starts */\n\tif (prev_stream) {\n\t\t/* there is a stream after */\n\t\tend = prev_stream->media.s ;\n\t\twhile( *(end-1)!='\\n' && *(end-1)!='\\r') end--;\n\t} else {\n\t\t/* last stream */\n\t\tbody.s = NULL; body.len = 0;\n\t\tget_body(msg, &body);\n\t\tend = body.s + body.len;\n\t}\n\n\t//LM_DBG(\" full stream is [%.*s]\\n\",end-begin, begin);\n\n\tl = del_lump( msg, (unsigned int)(begin-msg->buf),\n\t\t(unsigned int)(end-begin), 0);\n\tif (l==NULL) {\n\t\tLM_ERR(\"failed to create delete lump\\n\");\n\t\treturn -1;\n\t}\n\n\t/* mark stream as deleted */\n\tlmp->len = 0;\n\n\n\treturn 1;\n}\n\n\nint stream_find(struct sip_msg* msg, regex_t* re, regex_t* re2)\n{\n\treturn handle_streams(msg, re, re2, 0);\n}\n\n\nint stream_delete(struct sip_msg* msg, regex_t* re, regex_t* re2)\n{\n\treturn handle_streams(msg, re, re2, 1);\n}\n\n\n\n"], "fixing_code": ["/*\n * Copyright (C) 2009 Voice Sistem SRL\n * Copyright (C) 2009 Andrei Dragus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n *\n */\n\n#include \"../../sr_module.h\"\n#include \"../../parser/msg_parser.h\"\n#include \"../../mem/mem.h\"\n#include \"../../data_lump.h\"\n#include \"../../parser/sdp/sdp.h\"\n#include \"codecs.h\"\n#include \"../../route.h\"\n#include \"../../mod_fix.h\"\n\n#define MAX_STREAMS 64\n\nstatic struct lump *lumps[MAX_STREAMS];\nstatic int lumps_len;\n\nenum{\n\tFIND,\n\tDELETE,\n\tADD_TO_FRONT,\n\tADD_TO_BACK\n};\n\nenum{\n\tDESC_NAME,\n\tDESC_NAME_AND_CLOCK,\n\tDESC_REGEXP,\n\tDESC_REGEXP_COMPLEMENT\n};\n\n\nstatic int do_for_all_streams(struct sip_msg* msg, str* str1,str * str2,\n\t\tregex_t* re, int op,int desc);\nstatic int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\tstr * s, str* ss, regex_t* re, int op,int description);\n\n\n/*\n * Create the necessary lumps from the message\n */\nstatic int create_codec_lumps(struct sip_msg * msg)\n{\n\n\tstruct sdp_session_cell * cur_session;\n\tstruct lump * tmp;\n\tint count;\n\n\t/* get the number of streams */\n\tlumps_len = 0;\n\tcur_session = get_sdp(msg)->sessions;\n\n\twhile(cur_session)\n\t{\n\t\tlumps_len += cur_session->streams_num;\n\t\tcur_session = cur_session->next;\n\t}\n\n\tif (lumps_len>MAX_STREAMS)\n\t{\n\t\tLM_ERR(\"Overflow - too many streams (%d), limit is %d\\n\",\n\t\t\tlumps_len, MAX_STREAMS);\n\t\treturn -1;\n\t}\n\tmemset(lumps, 0, MAX_STREAMS * sizeof(struct lump*));\n\n\t/* for each stream create a specific lump for deletion, skip\n\t * and insertion */\n\n\tLM_DBG(\"creating %d streams\\n\",lumps_len);\n\n\tcount = 0;\n\tcur_session = get_sdp(msg)->sessions;\n\n\twhile(cur_session)\n\t{\n\t\tstruct sdp_stream_cell * cur_cell = cur_session->streams;\n\t\tstruct lump* l;\n\t\tstr text;\n\t\tstr payloads;\n\n\t\twhile(cur_cell)\n\t\t{\n\t\t\tpayloads = cur_cell->payloads;\n\t\t\t/* include the previous whitespaces */\n\t\t\twhile (payloads.s > cur_cell->body.s && *(payloads.s-1) == ' ') {\n\t\t\t\tpayloads.s--;\n\t\t\t\tpayloads.len++;\n\t\t\t}\n\n\t\t\tl = del_lump(msg, payloads.s - msg->buf, payloads.len, 0);\n\n\t\t\tlumps[count] = l;\n\n\t\t\tif( l == NULL)\n\t\t\t{\n\t\t\t\tLM_ERR(\"Error adding delete lump for m=\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tl->flags |= LUMPFLAG_CODEC;\n\n\t\t\ttmp = insert_skip_lump_after( l );\n\t\t\tif(tmp == NULL)\n\t\t\t{\n\t\t\t\tLM_ERR(\"Error adding skip lump for m=\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\ttext.len = payloads.len;\n\t\t\ttext.s = (char*)pkg_malloc(payloads.len);\n\n\t\t\tif( text.s == NULL )\n\t\t\t{\n\t\t\t\tLM_ERR(\"Error allocating lump buffer\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tmemcpy(text.s,payloads.s,payloads.len);\n\n\t\t\ttmp = insert_new_lump_after( tmp, text.s, text.len, 0);\n\t\t\tif(tmp == NULL)\n\t\t\t{\n\t\t\t\tLM_ERR(\"Error adding insert lump for m=\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcount ++;\n\t\t\tcur_cell = cur_cell->next;\n\t\t}\n\n\t\tcur_session = cur_session->next;\n\n\t}\n\n\treturn 0;\n};\n\n\n/*\n * Find the flagged lumps and save them in the global lump array\n * Returns : 0 - codec lumps found\n *           1 - no lump found\n *          -1 - error\n */\nstatic int find_codec_lumps(struct sip_msg * msg)\n{\n\tstruct lump *cur = msg->body_lumps;\n\tint count = 0;\n\n\twhile( cur)\n\t{\n\t\tif( cur->flags & LUMPFLAG_CODEC && cur->after && cur->after->after)\n\t\t\tcount++;\n\t\tcur = cur->next;\n\t}\n\n\tif (count>MAX_STREAMS) {\n\t\tLM_CRIT(\"BUG: too many codec lumps found (%d)\\n\",count);\n\t\treturn -1;\n\t}\n\n\tif( count==0 ) {\n\t\tlumps_len = -1;\n\t\treturn 1;\n\t}\n\n\tlumps_len=0;\n\tcur = msg->body_lumps;\n\twhile( cur)\n\t{\n\t\tif( cur->flags & LUMPFLAG_CODEC && cur->after && cur->after->after)\n\t\t{\n\t\t\tlumps[lumps_len] = cur;\n\t\t\tlumps_len++;\n\t\t}\n\t\tcur = cur->next;\n\t}\n\tLM_DBG(\"found %d streams\\n\",lumps_len);\n\n\treturn 0;\n};\n\n\nstatic int clone_codec_lumps(void)\n{\n\tstruct lump *l;\n\tint i;\n\tchar *s;\n\n\tLM_DBG(\"cloning %d streams\\n\",lumps_len);\n\n\tfor( i=0 ; i<lumps_len ; i++ ) {\n\t\t/* get last lump for stream */\n\t\tfor( l=lumps[i] ; l->after ; l=l->after );\n\n\t\ts = pkg_malloc( l->len+1 );\n\t\tif (s==NULL) {\n\t\t\tLM_ERR(\"failed to alloc new lump pkg buffer\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy( s, l->u.value, l->len);\n\n\t\tif (insert_new_lump_after( l, s, l->len, 0)==NULL) {\n\t\t\tLM_ERR(\"failed to create new lump\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int get_codec_lumps( struct sip_msg *msg )\n{\n\tint rc;\n\n\trc = find_codec_lumps(msg);\n\tif (rc<0) {\n\t\tLM_ERR(\"error while searching for codec flags\\n\");\n\t\treturn -1;\n\t}\n\n\t/* codec lumps not yet created -> create them now */\n\tif (rc==1) {\n\t\tif( create_codec_lumps(msg)<0 ) {\n\t\t\tLM_ERR(\"failed to create codec lumps\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* success - we gave the lumps */\n\t\treturn 0;\n\t}\n\n\t/* seams the lumps are already created */\n\tif( route_type & (REQUEST_ROUTE | ONREPLY_ROUTE | LOCAL_ROUTE)  )\n\t{\n\t\t/* save to use them directly */\n\t\treturn 0;\n\t}\n\n\tif( route_type & (FAILURE_ROUTE | BRANCH_ROUTE) )\n\t{\n\t\t/* clone the inserted lumps */\n\t\tif ( clone_codec_lumps()<0 ) {\n\t\t\tLM_ERR(\"failed to clone codec lumps\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* shoudn't get here */\n\treturn -1;\n};\n\n\n/*\n * Associate a lump with a given cell\n */\nstatic struct lump * get_associated_lump(struct sip_msg * msg,\n\t\t\t\t\t\t\t\t  struct sdp_stream_cell * cell)\n{\n\tstruct lump *lmp;\n\tchar *payload;\n\tint i, have,want;\n\n\tLM_DBG(\"Have %d lumps\\n\",lumps_len);\n\n\tfor( i =0 ; i< lumps_len; i++)\n\t{\n\t\thave = lumps[i]->u.offset;\n\t\tpayload = cell->payloads.s;\n\t\twhile (payload > cell->body.s && *(payload - 1) == ' ')\n\t\t\tpayload--;\n\t\twant = payload - msg->buf;\n\n\t\tLM_DBG(\"have lump at %d want at %d\\n\", have, want );\n\t\tif( have == want ) {\n\t\t\t/* got root lump, return the last data one */\n\t\t\tfor( lmp=lumps[i] ; lmp->after ; lmp=lmp->after);\n\t\t\treturn lmp;\n\t\t}\n\t}\n\n\treturn NULL;\n};\n\n\nstatic int do_for_all_streams(struct sip_msg* msg, str* str1,str * str2,\n\t\t\t\tregex_t* re, int op,int desc)\n{\n\tstruct sdp_session_cell * cur_session;\n\tsdp_info_t *sdp;\n\tint rez;\n\n\tif (msg==NULL || msg==FAKED_REPLY)\n\t\treturn -1;\n\n\tsdp = parse_sdp(msg);\n\tif (!sdp) {\n\t\tLM_DBG(\"Message has no SDP\\n\");\n\t\treturn -1;\n\t}\n\n\tif (get_codec_lumps(msg)<0) {\n\t\tLM_ERR(\"failed to prepare changes for codecs\\n\");\n\t\treturn -1;\n\t}\n\n\tcur_session = sdp->sessions;\n\trez = -1;\n\n\twhile(cur_session)\n\t{\n\t\tstruct sdp_stream_cell * cur_cell = cur_session->streams;\n\n\t\twhile(cur_cell)\n\t\t{\n\t\t\tif(stream_process(msg,cur_cell,str1,str2,re,op,desc)==1)\n\t\t\t\trez = 1;\n\t\t\tcur_cell = cur_cell->next;\n\t\t}\n\n\t\tcur_session = cur_session->next;\n\n\t}\n\n\treturn rez;\n}\n\n\n/* deletes a SDP line (from a stream) by giving a pointer within the line.\n * The stream is used to safeguard the identification of the line boundries.\n */\nint delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)\n{\n\tchar * start,*end;\n\n\tif( !s )\n\t\treturn 1;\n\n\tstart = s;\n\tend  = s;\n\n\twhile(*start != '\\n' && start > stream->body.s)\n\t\tstart--;\n\tstart++;\n\n\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )\n\t\tend++;\n\tif ( *end == '\\n')\n\t\tend++;\n\n\t/* delete the entry */\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n/* method that processes a stream and keeps the original order\n * of codecs with the same name */\nstatic int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\t\tstr * s, str* ss, regex_t* re, int op,int description)\n{\n\tstatic sdp_payload_attr_t static_payloads[] = {\n\t/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */\n\t{ NULL,0,{ \"0\",1},{\"PCMU\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */\n\t{ NULL,0,{ \"3\",1},{ \"GSM\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */\n\t{ NULL,0,{ \"4\",1},{\"G723\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */\n\t{ NULL,0,{ \"5\",1},{\"DVI4\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */\n\t{ NULL,0,{ \"6\",1},{\"DVI4\",4},{\"16000\",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */\n\t{ NULL,0,{ \"7\",1},{ \"LPC\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */\n\t{ NULL,0,{ \"8\",1},{\"PCMA\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */\n\t{ NULL,0,{ \"9\",1},{\"G722\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */\n\t{ NULL,0,{\"10\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */\n\t{ NULL,0,{\"11\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */\n\t{ NULL,0,{\"12\",2},{\"QCELP\",5},{\"8000\",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */\n\t{ NULL,0,{\"13\",2},{  \"CN\",2},{ \"8000\",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */\n\t{ NULL,0,{\"14\",2},{ \"MPA\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */\n\t{ NULL,0,{\"15\",2},{\"G728\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */\n\t{ NULL,0,{\"16\",2},{\"DVI4\",4},{\"11025\",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */\n\t{ NULL,0,{\"17\",2},{\"DVI4\",4},{\"22050\",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */\n\t{ NULL,0,{\"18\",2},{\"G729\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */\n\t{ NULL,0,{\"25\",2},{\"CelB\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */\n\t{ NULL,0,{\"26\",2},{\"JPEG\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */\n\t{ NULL,0,{\"28\",2},{  \"nv\",2},{\"90000\",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */\n\t{ NULL,0,{\"31\",2},{\"H261\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */\n\t{ NULL,0,{\"32\",2},{ \"MPV\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */\n\t{ NULL,0,{\"33\",2},{\"MP2T\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */\n\t{ NULL,0,{\"34\",2},{\"H263\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */\n\t{ NULL,0,{\"t38\",3},{\"t38\",3},{     \"\",0},{NULL,0},{NULL,0} },   /*T38- fax        */\n\t{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }\n\t};\n\tsdp_payload_attr_t *payload;\n\tchar *cur, *tmp, *buff, temp;\n\tstruct lump * lmp;\n\tstr found;\n\tint ret, i,match, buff_len, is_static;\n\tregmatch_t pmatch;\n\n\n\tlmp = get_associated_lump(msg, cell);\n\tif( lmp == NULL)\n\t{\n\t\tLM_ERR(\"There is no lump for this sdp cell\\n\");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\n\tbuff_len = 0;\n\tret = 0;\n\n\tbuff = pkg_malloc(lmp->len+1);\n\tif( buff == NULL)\n\t{\n\t\tLM_ERR(\"Out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\t/* search through each payload */\n\tis_static = 0;\n\tpayload = cell->payload_attr;\n\n\twhile(payload)\n\t{\n\t\tif( payload->rtp_enc.s == NULL\n\t\t || (payload->rtp_clock.s == NULL && ss != NULL)\n\t\t || payload->rtp_payload.s == NULL)\n\t\t{\n\t\t\tgoto next_payload;\n\t\t}\n\n\t\tmatch = 0;\n\n\t\tif( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )\n\t\t{\n\t\t\t/* try to match a regexp */\n\t\t\tif (is_static) {\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t} else {\n\t\t\t\ttemp = payload->rtp_enc.s[payload->rtp_enc.len];\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = 0;\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = temp;\n\t\t\t}\n\t\t}\n\n\t\tif( description == DESC_REGEXP_COMPLEMENT)\n\t\t\tmatch = !match;\n\n\t\tif( description == DESC_NAME  )\n\t\t{\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\tpayload->rtp_enc.len) == 0;\n\t\t}\n\n\t\tif( description == DESC_NAME_AND_CLOCK)\n\t\t{\n\t\t\t/* try to match name and clock if there is one */\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\n\t\t\t\tpayload->rtp_enc.len) == 0\n\t\t\t&&\n\t\t\t(ss == NULL || ( ss->len == payload->rtp_clock.len &&\n\t\t\tstrncasecmp( ss->s, payload->rtp_clock.s ,\n\t\t\t\tpayload->rtp_clock.len) == 0\n\t\t\t) );\n\t\t}\n\n\t\t/* if found, search its index in the m= line */\n\t\tif (match) {\n\n\t\t\tmatch = 0;\n\n\t\t\tcur = lmp->u.value;\n\t\t\twhile( !match && cur < lmp->u.value + lmp->len)\n\t\t\t{\n\t\t\t\t/* find the end of the number */\n\t\t\t\tfound.s = cur;\n\n\t\t\t\twhile(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )\n\t\t\t\t\tcur++;\n\n\t\t\t\tfound.len = cur - found.s;\n\n\t\t\t\t/* does it matches payload number */\n\t\t\t\tif ( found.len == payload->rtp_payload.len &&\n\t\t\t\tstrncmp( found.s,payload->rtp_payload.s,found.len) == 0) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* continue on searching => skip spaces\n\t\t\t\t\t   if there still are any */\n\t\t\t\t\twhile( cur < lmp->u.value + lmp->len && * cur == ' '  )\n\t\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* have we found both payload and index */\n\t\t\tif (match) {\n\n\t\t\t\tif(op == FIND)\n\t\t\t\t{\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif( op == DELETE && !is_static )\n\t\t\t\t{\n\t\t\t\t\t/* find the full 'a=...' entry */\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t/* take the previous whitespaces as well */\n\t\t\t\t\twhile (found.s > lmp->u.value && *(found.s - 1) == ' ') {\n\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n\t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n\t\t\t\t\t\ttmp = found.s;\n\t\t\t\t\t\twhile (*(--tmp) == ' ') {\n\t\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* delete the string and update iterators */\n\t\t\t\t\tfor(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )\n\t\t\t\t\t\t*tmp  = *(tmp+found.len);\n\n\t\t\t\t\t//cur -= found.len;\n\t\t\t\t\tlmp->len -= found.len;\n\t\t\t\t}\n\n\t\t\t\t/* add the deleted number into a buffer to be addded later */\n\t\t\t\tif( op == ADD_TO_FRONT  || op == ADD_TO_BACK)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&buff[buff_len],\" \",1);\n\t\t\t\t\tbuff_len++;\n\n\t\t\t\t\tmemcpy(&buff[buff_len],payload->rtp_payload.s,\n\t\t\t\t\t\tpayload->rtp_payload.len);\n\n\t\t\t\t\tbuff_len += payload->rtp_payload.len;\n\t\t\t\t}\n\n\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t}\n\n\t\t/* next payload */\n\tnext_payload:\n\t\tif (!is_static) {\n\t\t\tpayload = payload->next;\n\t\t\tif (payload==NULL) {\n\t\t\t\tpayload = static_payloads;\n\t\t\t\tis_static = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpayload ++;\n\t\t\tif (payload->rtp_payload.s==NULL)\n\t\t\t\tpayload=NULL;\n\t\t}\n\t}\n\n\n\tif( op == ADD_TO_FRONT && buff_len >0 )\n\t{\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor( i = lmp->len -1 ; i>=0;i--)\n\t\t\tlmp->u.value[i+buff_len] = lmp->u.value[i];\n\n\t\tmemcpy(lmp->u.value,buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\tif( op == ADD_TO_BACK && buff_len >0 )\n\t{\n\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tmemcpy(&lmp->u.value[lmp->len],buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\t/* if we ended up with a 0-length lump, then it means that all payloads\n\t * have been deleted, therefore we need to disable the media stream */\n\tif (lmp->len == 0) {\n\t\t/* replace the media port with 0 - we also replace the spaces before\n\t\t * and after the port, to make sure we have a larger buffer */\n\t\tlmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);\n\t\tif (!lmp) {\n\t\t\tLM_ERR(\"could not add lump to disable stream!\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\ttmp = pkg_malloc(3);\n\t\tif (!tmp) {\n\t\t\tLM_ERR(\"oom for port 0\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(tmp, \" 0 \", 3);\n\t\tif (!insert_new_lump_after(lmp, tmp, 3, 0))\n\t\t\tLM_ERR(\"could not insert lump to disable stream!\\n\");\n\t}\n\nend:\n\tpkg_free(buff);\n\treturn ret;\n}\n\n\nint codec_find(struct sip_msg* msg, str* codec, str* clock)\n{\n\tLM_DBG(\"searching for codec <%.*s>, clock <%.*s> \\n\",\n\t\tcodec->len, codec->s,\n\t\tclock ? clock->len : 0, clock ? clock->s : NULL);\n\n\treturn do_for_all_streams(msg, codec, clock, NULL, FIND, DESC_NAME);\n}\n\nint codec_find_re (struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams(msg, NULL, NULL, re, FIND, DESC_REGEXP);\n}\n\n\nint codec_delete_re(struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams(msg, NULL, NULL, re, DELETE, DESC_REGEXP);\n}\n\n\nint codec_delete_except_re(struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams( msg, NULL, NULL, re,\n\t\tDELETE, DESC_REGEXP_COMPLEMENT);\n}\n\n\nint codec_delete(struct sip_msg* msg, str* codec, str* clock)\n{\n\tLM_DBG(\"deleting codec <%.*s> with clock <%.*s> \\n\",\n\t\tcodec->len, codec->s, clock ? clock->len : 0, clock ? clock->s : NULL);\n\n\treturn do_for_all_streams( msg, codec, clock, NULL,\n\t\tDELETE, DESC_NAME_AND_CLOCK);\n}\n\n\nint codec_move_up_re(struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams( msg, NULL, NULL, re,\n\t\tADD_TO_FRONT, DESC_REGEXP);\n}\n\n\nint codec_move_up(struct sip_msg* msg, str* codec, str* clock)\n{\n\tLM_DBG(\"moving up codec <%.*s> with clock <%.*s> \\n\",\n\t\tcodec->len, codec->s, clock ? clock->len : 0, clock ? clock->s : NULL);\n\n\treturn do_for_all_streams(msg, codec, clock, NULL,\n\t\tADD_TO_FRONT, DESC_NAME_AND_CLOCK);\n}\n\n\nint codec_move_down_re(struct sip_msg* msg, regex_t* re)\n{\n\treturn do_for_all_streams( msg, NULL, NULL, re,\n\t\tADD_TO_BACK, DESC_REGEXP);\n}\n\n\nint codec_move_down(struct sip_msg* msg, str* codec, str* clock)\n{\n\tLM_DBG(\"moving down codec <%.*s> with clock <%.*s> \\n\",\n\t\tcodec->len, codec->s, clock ? clock->len : 0, clock ? clock->s : NULL);\n\n\treturn do_for_all_streams( msg, codec, clock, NULL,\n\t\tADD_TO_BACK, DESC_NAME_AND_CLOCK);\n}\n\n\nstatic int handle_streams(struct sip_msg* msg, regex_t* re, regex_t* re2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint delete)\n{\n\tstruct sdp_session_cell *session;\n\tstruct sdp_stream_cell *stream;\n\tstruct sdp_stream_cell *prev_stream;\n\tregmatch_t pmatch;\n\tstruct lump *lmp, *l;\n\tchar *begin, *end;\n\tchar temp;\n\tstr body;\n\tint match;\n\n\tif (msg==NULL || msg==FAKED_REPLY)\n\t\treturn -1;\n\n\tif(!parse_sdp(msg))\n\t{\n\t\tLM_DBG(\"Message has no SDP\\n\");\n\t\treturn -1;\n\t}\n\n\t/* search for the stream */\n\tmatch = 0;\n\tfor (session = get_sdp(msg)->sessions; session && !match;\n\t     session = session->next) {\n\t\tprev_stream = NULL;\n\t\tfor( stream=session->streams ; stream ;\n\t\tprev_stream=stream,stream=stream->next){\n\t\t\t/* check the media in stream, re based */\n\t\t\ttemp = stream->media.s[stream->media.len];\n\t\t\tstream->media.s[stream->media.len] = 0;\n\t\t\tmatch = regexec( re, stream->media.s, 1, &pmatch, 0) == 0;\n\t\t\tstream->media.s[stream->media.len] = temp;\n\t\t\t/* optionally check the transport in stream also */\n\t\t\tif (match && re2) {\n\t\t\t\ttemp = stream->transport.s[stream->transport.len];\n\t\t\t\tstream->transport.s[stream->transport.len] = 0;\n\t\t\t\tmatch = regexec( re2, stream->transport.s, 1, &pmatch, 0) == 0;\n\t\t\t\tstream->transport.s[stream->transport.len] = temp;\n\t\t\t}\n\t\t\tif (match) break;\n\t\t}\n\t}\n\n\tif (!match)\n\t\treturn -1;\n\n\tLM_DBG(\" found stream media [%.*s], transport [%.*s]\\n\",\n\t\tstream->media.len,stream->media.s,\n\t\tstream->transport.len,stream->transport.s);\n\n\t/* stream found */\n\tif (!delete)\n\t\treturn 1;\n\n\n\t/* have to delete the stream*/\n\tif (get_codec_lumps(msg)<0) {\n\t\tLM_ERR(\"failed to get lumps for streams\\n\");\n\t\treturn -1;\n\t}\n\tlmp = get_associated_lump(msg, stream);\n\tif( lmp == NULL) {\n\t\tLM_ERR(\"There is no lump for this sdp cell\\n\");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\t/* search the boundries of the stream */\n\n\t/* look for the beginning of the \"m\" line */\n\tbegin = stream->media.s ;\n\twhile( *(begin-1)!='\\n' && *(begin-1)!='\\r') begin--;\n\n\t/* the end is where the next stream starts */\n\tif (prev_stream) {\n\t\t/* there is a stream after */\n\t\tend = prev_stream->media.s ;\n\t\twhile( *(end-1)!='\\n' && *(end-1)!='\\r') end--;\n\t} else {\n\t\t/* last stream */\n\t\tbody.s = NULL; body.len = 0;\n\t\tget_body(msg, &body);\n\t\tend = body.s + body.len;\n\t}\n\n\t//LM_DBG(\" full stream is [%.*s]\\n\",end-begin, begin);\n\n\tl = del_lump( msg, (unsigned int)(begin-msg->buf),\n\t\t(unsigned int)(end-begin), 0);\n\tif (l==NULL) {\n\t\tLM_ERR(\"failed to create delete lump\\n\");\n\t\treturn -1;\n\t}\n\n\t/* mark stream as deleted */\n\tlmp->len = 0;\n\n\n\treturn 1;\n}\n\n\nint stream_find(struct sip_msg* msg, regex_t* re, regex_t* re2)\n{\n\treturn handle_streams(msg, re, re2, 0);\n}\n\n\nint stream_delete(struct sip_msg* msg, regex_t* re, regex_t* re2)\n{\n\treturn handle_streams(msg, re, re2, 1);\n}\n\n\n\n"], "filenames": ["modules/sipmsgops/codecs.c"], "buggy_code_start_loc": [369], "buggy_code_end_loc": [370], "fixing_code_start_loc": [369], "fixing_code_end_loc": [371], "type": "NVD-CWE-noinfo", "message": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body is received and is processed by the `delete_sdp_line` function in the sipmsgops module. This issue can be reproduced by calling the function with an SDP body that does not terminate by a line feed (i.e. `\\n`). The vulnerability was found while performing black-box fuzzing against an OpenSIPS server running a configuration that made use of the functions `codec_delete_except_re` and `codec_delete_re`. The same issue was also discovered while performing coverage guided fuzzing on the function `codec_delete_except_re`. The crash happens because the function `delete_sdp_line` expects that an SDP line is terminated by a line feed (`\\n`). By abusing this vulnerability, an attacker is able to crash the server. It affects configurations containing functions that rely on the affected code, such as the function `codec_delete_except_re`. Due to the sanity check that is performed in the `del_lump` function, exploitation of this issue will generate an `abort` in the lumps processing function, resulting in a Denial of Service. This issue is patched in versions 3.1.7 and 3.2.4.", "other": {"cve": {"id": "CVE-2023-27600", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-15T22:15:10.267", "lastModified": "2023-03-21T19:23:58.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body is received and is processed by the `delete_sdp_line` function in the sipmsgops module. This issue can be reproduced by calling the function with an SDP body that does not terminate by a line feed (i.e. `\\n`). The vulnerability was found while performing black-box fuzzing against an OpenSIPS server running a configuration that made use of the functions `codec_delete_except_re` and `codec_delete_re`. The same issue was also discovered while performing coverage guided fuzzing on the function `codec_delete_except_re`. The crash happens because the function `delete_sdp_line` expects that an SDP line is terminated by a line feed (`\\n`). By abusing this vulnerability, an attacker is able to crash the server. It affects configurations containing functions that rely on the affected code, such as the function `codec_delete_except_re`. Due to the sanity check that is performed in the `del_lump` function, exploitation of this issue will generate an `abort` in the lumps processing function, resulting in a Denial of Service. This issue is patched in versions 3.1.7 and 3.2.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.7", "matchCriteriaId": "8EF642AA-D786-40DF-801D-515888AF89BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "3.2.4", "matchCriteriaId": "34713A76-CAED-43CF-A77C-73F1C36208AA"}]}]}], "references": [{"url": "https://github.com/OpenSIPS/opensips/commit/c6ab3bb406c447e30c7d33a1a8970048b4612100", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSIPS/opensips/security/advisories/GHSA-67w7-g4j8-3wcx", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://opensips.org/docs/modules/3.3.x/sipmsgops.html", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenSIPS/opensips/commit/c6ab3bb406c447e30c7d33a1a8970048b4612100"}}