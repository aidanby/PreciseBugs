{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Copyright (c) 2014 Christoph Hellwig.\n */\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM nfsd\n\n#if !defined(_NFSD_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _NFSD_TRACE_H\n\n#include <linux/tracepoint.h>\n#include \"export.h\"\n#include \"nfsfh.h\"\n\n#define NFSD_TRACE_PROC_ARG_FIELDS \\\n\t\t__field(unsigned int, netns_ino) \\\n\t\t__field(u32, xid) \\\n\t\t__array(unsigned char, server, sizeof(struct sockaddr_in6)) \\\n\t\t__array(unsigned char, client, sizeof(struct sockaddr_in6))\n\n#define NFSD_TRACE_PROC_ARG_ASSIGNMENTS \\\n\t\tdo { \\\n\t\t\t__entry->netns_ino = SVC_NET(rqstp)->ns.inum; \\\n\t\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid); \\\n\t\t\tmemcpy(__entry->server, &rqstp->rq_xprt->xpt_local, \\\n\t\t\t       rqstp->rq_xprt->xpt_locallen); \\\n\t\t\tmemcpy(__entry->client, &rqstp->rq_xprt->xpt_remote, \\\n\t\t\t       rqstp->rq_xprt->xpt_remotelen); \\\n\t\t} while (0);\n\n#define NFSD_TRACE_PROC_RES_FIELDS \\\n\t\t__field(unsigned int, netns_ino) \\\n\t\t__field(u32, xid) \\\n\t\t__field(unsigned long, status) \\\n\t\t__array(unsigned char, server, sizeof(struct sockaddr_in6)) \\\n\t\t__array(unsigned char, client, sizeof(struct sockaddr_in6))\n\n#define NFSD_TRACE_PROC_RES_ASSIGNMENTS(error) \\\n\t\tdo { \\\n\t\t\t__entry->netns_ino = SVC_NET(rqstp)->ns.inum; \\\n\t\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid); \\\n\t\t\t__entry->status = be32_to_cpu(error); \\\n\t\t\tmemcpy(__entry->server, &rqstp->rq_xprt->xpt_local, \\\n\t\t\t       rqstp->rq_xprt->xpt_locallen); \\\n\t\t\tmemcpy(__entry->client, &rqstp->rq_xprt->xpt_remote, \\\n\t\t\t       rqstp->rq_xprt->xpt_remotelen); \\\n\t\t} while (0);\n\nTRACE_EVENT(nfsd_garbage_args_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp\n\t),\n\tTP_ARGS(rqstp),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_ARG_FIELDS\n\n\t\t__field(u32, vers)\n\t\t__field(u32, proc)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_ARG_ASSIGNMENTS\n\n\t\t__entry->vers = rqstp->rq_vers;\n\t\t__entry->proc = rqstp->rq_proc;\n\t),\n\tTP_printk(\"xid=0x%08x vers=%u proc=%u\",\n\t\t__entry->xid, __entry->vers, __entry->proc\n\t)\n);\n\nTRACE_EVENT(nfsd_cant_encode_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp\n\t),\n\tTP_ARGS(rqstp),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_ARG_FIELDS\n\n\t\t__field(u32, vers)\n\t\t__field(u32, proc)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_ARG_ASSIGNMENTS\n\n\t\t__entry->vers = rqstp->rq_vers;\n\t\t__entry->proc = rqstp->rq_proc;\n\t),\n\tTP_printk(\"xid=0x%08x vers=%u proc=%u\",\n\t\t__entry->xid, __entry->vers, __entry->proc\n\t)\n);\n\n#define show_nfsd_may_flags(x)\t\t\t\t\t\t\\\n\t__print_flags(x, \"|\",\t\t\t\t\t\t\\\n\t\t{ NFSD_MAY_EXEC,\t\t\"EXEC\" },\t\t\\\n\t\t{ NFSD_MAY_WRITE,\t\t\"WRITE\" },\t\t\\\n\t\t{ NFSD_MAY_READ,\t\t\"READ\" },\t\t\\\n\t\t{ NFSD_MAY_SATTR,\t\t\"SATTR\" },\t\t\\\n\t\t{ NFSD_MAY_TRUNC,\t\t\"TRUNC\" },\t\t\\\n\t\t{ NFSD_MAY_LOCK,\t\t\"LOCK\" },\t\t\\\n\t\t{ NFSD_MAY_OWNER_OVERRIDE,\t\"OWNER_OVERRIDE\" },\t\\\n\t\t{ NFSD_MAY_LOCAL_ACCESS,\t\"LOCAL_ACCESS\" },\t\\\n\t\t{ NFSD_MAY_BYPASS_GSS_ON_ROOT,\t\"BYPASS_GSS_ON_ROOT\" },\t\\\n\t\t{ NFSD_MAY_NOT_BREAK_LEASE,\t\"NOT_BREAK_LEASE\" },\t\\\n\t\t{ NFSD_MAY_BYPASS_GSS,\t\t\"BYPASS_GSS\" },\t\t\\\n\t\t{ NFSD_MAY_READ_IF_EXEC,\t\"READ_IF_EXEC\" },\t\\\n\t\t{ NFSD_MAY_64BIT_COOKIE,\t\"64BIT_COOKIE\" })\n\nTRACE_EVENT(nfsd_compound,\n\tTP_PROTO(const struct svc_rqst *rqst,\n\t\t u32 args_opcnt),\n\tTP_ARGS(rqst, args_opcnt),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, args_opcnt)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqst->rq_xid);\n\t\t__entry->args_opcnt = args_opcnt;\n\t),\n\tTP_printk(\"xid=0x%08x opcnt=%u\",\n\t\t__entry->xid, __entry->args_opcnt)\n)\n\nTRACE_EVENT(nfsd_compound_status,\n\tTP_PROTO(u32 args_opcnt,\n\t\t u32 resp_opcnt,\n\t\t __be32 status,\n\t\t const char *name),\n\tTP_ARGS(args_opcnt, resp_opcnt, status, name),\n\tTP_STRUCT__entry(\n\t\t__field(u32, args_opcnt)\n\t\t__field(u32, resp_opcnt)\n\t\t__field(int, status)\n\t\t__string(name, name)\n\t),\n\tTP_fast_assign(\n\t\t__entry->args_opcnt = args_opcnt;\n\t\t__entry->resp_opcnt = resp_opcnt;\n\t\t__entry->status = be32_to_cpu(status);\n\t\t__assign_str(name, name);\n\t),\n\tTP_printk(\"op=%u/%u %s status=%d\",\n\t\t__entry->resp_opcnt, __entry->args_opcnt,\n\t\t__get_str(name), __entry->status)\n)\n\nTRACE_EVENT(nfsd_compound_decode_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tu32 args_opcnt,\n\t\tu32 resp_opcnt,\n\t\tu32 opnum,\n\t\t__be32 status\n\t),\n\tTP_ARGS(rqstp, args_opcnt, resp_opcnt, opnum, status),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_RES_FIELDS\n\n\t\t__field(u32, args_opcnt)\n\t\t__field(u32, resp_opcnt)\n\t\t__field(u32, opnum)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_RES_ASSIGNMENTS(status)\n\n\t\t__entry->args_opcnt = args_opcnt;\n\t\t__entry->resp_opcnt = resp_opcnt;\n\t\t__entry->opnum = opnum;\n\t),\n\tTP_printk(\"op=%u/%u opnum=%u status=%lu\",\n\t\t__entry->resp_opcnt, __entry->args_opcnt,\n\t\t__entry->opnum, __entry->status)\n);\n\nTRACE_EVENT(nfsd_compound_encode_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tu32 opnum,\n\t\t__be32 status\n\t),\n\tTP_ARGS(rqstp, opnum, status),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_RES_FIELDS\n\n\t\t__field(u32, opnum)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_RES_ASSIGNMENTS(status)\n\n\t\t__entry->opnum = opnum;\n\t),\n\tTP_printk(\"opnum=%u status=%lu\",\n\t\t__entry->opnum, __entry->status)\n);\n\n\nDECLARE_EVENT_CLASS(nfsd_fh_err_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t int\t\tstatus),\n\tTP_ARGS(rqstp, fhp, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x status=%d\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->status)\n)\n\n#define DEFINE_NFSD_FH_ERR_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_fh_err_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t int\t\tstatus),\t\\\n\tTP_ARGS(rqstp, fhp, status))\n\nDEFINE_NFSD_FH_ERR_EVENT(set_fh_dentry_badexport);\nDEFINE_NFSD_FH_ERR_EVENT(set_fh_dentry_badhandle);\n\nTRACE_EVENT(nfsd_exp_find_key,\n\tTP_PROTO(const struct svc_expkey *key,\n\t\t int status),\n\tTP_ARGS(key, status),\n\tTP_STRUCT__entry(\n\t\t__field(int, fsidtype)\n\t\t__array(u32, fsid, 6)\n\t\t__string(auth_domain, key->ek_client->name)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fsidtype = key->ek_fsidtype;\n\t\tmemcpy(__entry->fsid, key->ek_fsid, 4*6);\n\t\t__assign_str(auth_domain, key->ek_client->name);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"fsid=%x::%s domain=%s status=%d\",\n\t\t__entry->fsidtype,\n\t\t__print_array(__entry->fsid, 6, 4),\n\t\t__get_str(auth_domain),\n\t\t__entry->status\n\t)\n);\n\nTRACE_EVENT(nfsd_expkey_update,\n\tTP_PROTO(const struct svc_expkey *key, const char *exp_path),\n\tTP_ARGS(key, exp_path),\n\tTP_STRUCT__entry(\n\t\t__field(int, fsidtype)\n\t\t__array(u32, fsid, 6)\n\t\t__string(auth_domain, key->ek_client->name)\n\t\t__string(path, exp_path)\n\t\t__field(bool, cache)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fsidtype = key->ek_fsidtype;\n\t\tmemcpy(__entry->fsid, key->ek_fsid, 4*6);\n\t\t__assign_str(auth_domain, key->ek_client->name);\n\t\t__assign_str(path, exp_path);\n\t\t__entry->cache = !test_bit(CACHE_NEGATIVE, &key->h.flags);\n\t),\n\tTP_printk(\"fsid=%x::%s domain=%s path=%s cache=%s\",\n\t\t__entry->fsidtype,\n\t\t__print_array(__entry->fsid, 6, 4),\n\t\t__get_str(auth_domain),\n\t\t__get_str(path),\n\t\t__entry->cache ? \"pos\" : \"neg\"\n\t)\n);\n\nTRACE_EVENT(nfsd_exp_get_by_name,\n\tTP_PROTO(const struct svc_export *key,\n\t\t int status),\n\tTP_ARGS(key, status),\n\tTP_STRUCT__entry(\n\t\t__string(path, key->ex_path.dentry->d_name.name)\n\t\t__string(auth_domain, key->ex_client->name)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(path, key->ex_path.dentry->d_name.name);\n\t\t__assign_str(auth_domain, key->ex_client->name);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"path=%s domain=%s status=%d\",\n\t\t__get_str(path),\n\t\t__get_str(auth_domain),\n\t\t__entry->status\n\t)\n);\n\nTRACE_EVENT(nfsd_export_update,\n\tTP_PROTO(const struct svc_export *key),\n\tTP_ARGS(key),\n\tTP_STRUCT__entry(\n\t\t__string(path, key->ex_path.dentry->d_name.name)\n\t\t__string(auth_domain, key->ex_client->name)\n\t\t__field(bool, cache)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(path, key->ex_path.dentry->d_name.name);\n\t\t__assign_str(auth_domain, key->ex_client->name);\n\t\t__entry->cache = !test_bit(CACHE_NEGATIVE, &key->h.flags);\n\t),\n\tTP_printk(\"path=%s domain=%s cache=%s\",\n\t\t__get_str(path),\n\t\t__get_str(auth_domain),\n\t\t__entry->cache ? \"pos\" : \"neg\"\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_io_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t loff_t\t\toffset,\n\t\t unsigned long\tlen),\n\tTP_ARGS(rqstp, fhp, offset, len),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(loff_t, offset)\n\t\t__field(unsigned long, len)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->offset = offset;\n\t\t__entry->len = len;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x offset=%lld len=%lu\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->offset, __entry->len)\n)\n\n#define DEFINE_NFSD_IO_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_io_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t loff_t\t\toffset,\t\t\\\n\t\t unsigned long\tlen),\t\t\\\n\tTP_ARGS(rqstp, fhp, offset, len))\n\nDEFINE_NFSD_IO_EVENT(read_start);\nDEFINE_NFSD_IO_EVENT(read_splice);\nDEFINE_NFSD_IO_EVENT(read_vector);\nDEFINE_NFSD_IO_EVENT(read_io_done);\nDEFINE_NFSD_IO_EVENT(read_done);\nDEFINE_NFSD_IO_EVENT(write_start);\nDEFINE_NFSD_IO_EVENT(write_opened);\nDEFINE_NFSD_IO_EVENT(write_io_done);\nDEFINE_NFSD_IO_EVENT(write_done);\n\nDECLARE_EVENT_CLASS(nfsd_err_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t loff_t\t\toffset,\n\t\t int\t\tstatus),\n\tTP_ARGS(rqstp, fhp, offset, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(loff_t, offset)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->offset = offset;\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x offset=%lld status=%d\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->offset, __entry->status)\n)\n\n#define DEFINE_NFSD_ERR_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_err_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t loff_t\t\toffset,\t\t\\\n\t\t int\t\tlen),\t\t\\\n\tTP_ARGS(rqstp, fhp, offset, len))\n\nDEFINE_NFSD_ERR_EVENT(read_err);\nDEFINE_NFSD_ERR_EVENT(write_err);\n\nTRACE_EVENT(nfsd_dirent,\n\tTP_PROTO(struct svc_fh *fhp,\n\t\t u64 ino,\n\t\t const char *name,\n\t\t int namlen),\n\tTP_ARGS(fhp, ino, name, namlen),\n\tTP_STRUCT__entry(\n\t\t__field(u32, fh_hash)\n\t\t__field(u64, ino)\n\t\t__field(int, len)\n\t\t__dynamic_array(unsigned char, name, namlen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fh_hash = fhp ? knfsd_fh_hash(&fhp->fh_handle) : 0;\n\t\t__entry->ino = ino;\n\t\t__entry->len = namlen;\n\t\tmemcpy(__get_str(name), name, namlen);\n\t\t__assign_str(name, name);\n\t),\n\tTP_printk(\"fh_hash=0x%08x ino=%llu name=%.*s\",\n\t\t__entry->fh_hash, __entry->ino,\n\t\t__entry->len, __get_str(name))\n)\n\n#include \"state.h\"\n#include \"filecache.h\"\n#include \"vfs.h\"\n\nDECLARE_EVENT_CLASS(nfsd_stateid_class,\n\tTP_PROTO(stateid_t *stp),\n\tTP_ARGS(stp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t),\n\tTP_printk(\"client %08x:%08x stateid %08x:%08x\",\n\t\t__entry->cl_boot,\n\t\t__entry->cl_id,\n\t\t__entry->si_id,\n\t\t__entry->si_generation)\n)\n\n#define DEFINE_STATEID_EVENT(name) \\\nDEFINE_EVENT(nfsd_stateid_class, nfsd_##name, \\\n\tTP_PROTO(stateid_t *stp), \\\n\tTP_ARGS(stp))\n\nDEFINE_STATEID_EVENT(layoutstate_alloc);\nDEFINE_STATEID_EVENT(layoutstate_unhash);\nDEFINE_STATEID_EVENT(layoutstate_free);\nDEFINE_STATEID_EVENT(layout_get_lookup_fail);\nDEFINE_STATEID_EVENT(layout_commit_lookup_fail);\nDEFINE_STATEID_EVENT(layout_return_lookup_fail);\nDEFINE_STATEID_EVENT(layout_recall);\nDEFINE_STATEID_EVENT(layout_recall_done);\nDEFINE_STATEID_EVENT(layout_recall_fail);\nDEFINE_STATEID_EVENT(layout_recall_release);\n\nDEFINE_STATEID_EVENT(open);\nDEFINE_STATEID_EVENT(deleg_read);\nDEFINE_STATEID_EVENT(deleg_recall);\n\nDECLARE_EVENT_CLASS(nfsd_stateseqid_class,\n\tTP_PROTO(u32 seqid, const stateid_t *stp),\n\tTP_ARGS(seqid, stp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, seqid)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t),\n\tTP_fast_assign(\n\t\t__entry->seqid = seqid;\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t),\n\tTP_printk(\"seqid=%u client %08x:%08x stateid %08x:%08x\",\n\t\t__entry->seqid, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation)\n)\n\n#define DEFINE_STATESEQID_EVENT(name) \\\nDEFINE_EVENT(nfsd_stateseqid_class, nfsd_##name, \\\n\tTP_PROTO(u32 seqid, const stateid_t *stp), \\\n\tTP_ARGS(seqid, stp))\n\nDEFINE_STATESEQID_EVENT(preprocess);\nDEFINE_STATESEQID_EVENT(open_confirm);\n\nDECLARE_EVENT_CLASS(nfsd_clientid_class,\n\tTP_PROTO(const clientid_t *clid),\n\tTP_ARGS(clid),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clid->cl_boot;\n\t\t__entry->cl_id = clid->cl_id;\n\t),\n\tTP_printk(\"client %08x:%08x\", __entry->cl_boot, __entry->cl_id)\n)\n\n#define DEFINE_CLIENTID_EVENT(name) \\\nDEFINE_EVENT(nfsd_clientid_class, nfsd_clid_##name, \\\n\tTP_PROTO(const clientid_t *clid), \\\n\tTP_ARGS(clid))\n\nDEFINE_CLIENTID_EVENT(expire_unconf);\nDEFINE_CLIENTID_EVENT(reclaim_complete);\nDEFINE_CLIENTID_EVENT(confirmed);\nDEFINE_CLIENTID_EVENT(destroyed);\nDEFINE_CLIENTID_EVENT(admin_expired);\nDEFINE_CLIENTID_EVENT(replaced);\nDEFINE_CLIENTID_EVENT(purged);\nDEFINE_CLIENTID_EVENT(renew);\nDEFINE_CLIENTID_EVENT(stale);\n\nDECLARE_EVENT_CLASS(nfsd_net_class,\n\tTP_PROTO(const struct nfsd_net *nn),\n\tTP_ARGS(nn),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t),\n\tTP_printk(\"boot_time=%16llx\", __entry->boot_time)\n)\n\n#define DEFINE_NET_EVENT(name) \\\nDEFINE_EVENT(nfsd_net_class, nfsd_##name, \\\n\tTP_PROTO(const struct nfsd_net *nn), \\\n\tTP_ARGS(nn))\n\nDEFINE_NET_EVENT(grace_start);\nDEFINE_NET_EVENT(grace_complete);\n\nTRACE_EVENT(nfsd_clid_cred_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct svc_rqst *rqstp\n\t),\n\tTP_ARGS(clp, rqstp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(unsigned long, cl_flavor)\n\t\t__field(unsigned long, new_flavor)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->cl_flavor = clp->cl_cred.cr_flavor;\n\t\t__entry->new_flavor = rqstp->rq_cred.cr_flavor;\n\t\tmemcpy(__entry->addr, &rqstp->rq_xprt->xpt_remote,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"client %08x:%08x flavor=%s, conflict=%s from addr=%pISpc\",\n\t\t__entry->cl_boot, __entry->cl_id,\n\t\tshow_nfsd_authflavor(__entry->cl_flavor),\n\t\tshow_nfsd_authflavor(__entry->new_flavor), __entry->addr\n\t)\n)\n\nTRACE_EVENT(nfsd_clid_verf_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst nfs4_verifier *verf\n\t),\n\tTP_ARGS(clp, rqstp, verf),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, cl_verifier, NFS4_VERIFIER_SIZE)\n\t\t__array(unsigned char, new_verifier, NFS4_VERIFIER_SIZE)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->cl_verifier, (void *)&clp->cl_verifier,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\tmemcpy(__entry->new_verifier, (void *)verf,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\tmemcpy(__entry->addr, &rqstp->rq_xprt->xpt_remote,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"client %08x:%08x verf=0x%s, updated=0x%s from addr=%pISpc\",\n\t\t__entry->cl_boot, __entry->cl_id,\n\t\t__print_hex_str(__entry->cl_verifier, NFS4_VERIFIER_SIZE),\n\t\t__print_hex_str(__entry->new_verifier, NFS4_VERIFIER_SIZE),\n\t\t__entry->addr\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_clid_class,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t\t__field(unsigned long, flavor)\n\t\t__array(unsigned char, verifier, NFS4_VERIFIER_SIZE)\n\t\t__dynamic_array(char, name, clp->cl_name.len + 1)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->addr, &clp->cl_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t\t__entry->flavor = clp->cl_cred.cr_flavor;\n\t\tmemcpy(__entry->verifier, (void *)&clp->cl_verifier,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\tmemcpy(__get_str(name), clp->cl_name.data, clp->cl_name.len);\n\t\t__get_str(name)[clp->cl_name.len] = '\\0';\n\t),\n\tTP_printk(\"addr=%pISpc name='%s' verifier=0x%s flavor=%s client=%08x:%08x\",\n\t\t__entry->addr, __get_str(name),\n\t\t__print_hex_str(__entry->verifier, NFS4_VERIFIER_SIZE),\n\t\tshow_nfsd_authflavor(__entry->flavor),\n\t\t__entry->cl_boot, __entry->cl_id)\n);\n\n#define DEFINE_CLID_EVENT(name) \\\nDEFINE_EVENT(nfsd_clid_class, nfsd_clid_##name, \\\n\tTP_PROTO(const struct nfs4_client *clp), \\\n\tTP_ARGS(clp))\n\nDEFINE_CLID_EVENT(fresh);\nDEFINE_CLID_EVENT(confirmed_r);\n\n/*\n * from fs/nfsd/filecache.h\n */\nTRACE_DEFINE_ENUM(NFSD_FILE_HASHED);\nTRACE_DEFINE_ENUM(NFSD_FILE_PENDING);\nTRACE_DEFINE_ENUM(NFSD_FILE_BREAK_READ);\nTRACE_DEFINE_ENUM(NFSD_FILE_BREAK_WRITE);\nTRACE_DEFINE_ENUM(NFSD_FILE_REFERENCED);\n\n#define show_nf_flags(val)\t\t\t\t\t\t\\\n\t__print_flags(val, \"|\",\t\t\t\t\t\t\\\n\t\t{ 1 << NFSD_FILE_HASHED,\t\"HASHED\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_PENDING,\t\"PENDING\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_BREAK_READ,\t\"BREAK_READ\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_BREAK_WRITE,\t\"BREAK_WRITE\" },\t\\\n\t\t{ 1 << NFSD_FILE_REFERENCED,\t\"REFERENCED\"})\n\nDECLARE_EVENT_CLASS(nfsd_file_class,\n\tTP_PROTO(struct nfsd_file *nf),\n\tTP_ARGS(nf),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, nf_hashval)\n\t\t__field(void *, nf_inode)\n\t\t__field(int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned char, nf_may)\n\t\t__field(struct file *, nf_file)\n\t),\n\tTP_fast_assign(\n\t\t__entry->nf_hashval = nf->nf_hashval;\n\t\t__entry->nf_inode = nf->nf_inode;\n\t\t__entry->nf_ref = refcount_read(&nf->nf_ref);\n\t\t__entry->nf_flags = nf->nf_flags;\n\t\t__entry->nf_may = nf->nf_may;\n\t\t__entry->nf_file = nf->nf_file;\n\t),\n\tTP_printk(\"hash=0x%x inode=%p ref=%d flags=%s may=%s file=%p\",\n\t\t__entry->nf_hashval,\n\t\t__entry->nf_inode,\n\t\t__entry->nf_ref,\n\t\tshow_nf_flags(__entry->nf_flags),\n\t\tshow_nfsd_may_flags(__entry->nf_may),\n\t\t__entry->nf_file)\n)\n\n#define DEFINE_NFSD_FILE_EVENT(name) \\\nDEFINE_EVENT(nfsd_file_class, name, \\\n\tTP_PROTO(struct nfsd_file *nf), \\\n\tTP_ARGS(nf))\n\nDEFINE_NFSD_FILE_EVENT(nfsd_file_alloc);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_put_final);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_unhash);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_put);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_unhash_and_release_locked);\n\nTRACE_EVENT(nfsd_file_acquire,\n\tTP_PROTO(struct svc_rqst *rqstp, unsigned int hash,\n\t\t struct inode *inode, unsigned int may_flags,\n\t\t struct nfsd_file *nf, __be32 status),\n\n\tTP_ARGS(rqstp, hash, inode, may_flags, nf, status),\n\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(unsigned int, hash)\n\t\t__field(void *, inode)\n\t\t__field(unsigned long, may_flags)\n\t\t__field(int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned long, nf_may)\n\t\t__field(struct file *, nf_file)\n\t\t__field(u32, status)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->hash = hash;\n\t\t__entry->inode = inode;\n\t\t__entry->may_flags = may_flags;\n\t\t__entry->nf_ref = nf ? refcount_read(&nf->nf_ref) : 0;\n\t\t__entry->nf_flags = nf ? nf->nf_flags : 0;\n\t\t__entry->nf_may = nf ? nf->nf_may : 0;\n\t\t__entry->nf_file = nf ? nf->nf_file : NULL;\n\t\t__entry->status = be32_to_cpu(status);\n\t),\n\n\tTP_printk(\"xid=0x%x hash=0x%x inode=%p may_flags=%s ref=%d nf_flags=%s nf_may=%s nf_file=%p status=%u\",\n\t\t\t__entry->xid, __entry->hash, __entry->inode,\n\t\t\tshow_nfsd_may_flags(__entry->may_flags),\n\t\t\t__entry->nf_ref, show_nf_flags(__entry->nf_flags),\n\t\t\tshow_nfsd_may_flags(__entry->nf_may),\n\t\t\t__entry->nf_file, __entry->status)\n);\n\nDECLARE_EVENT_CLASS(nfsd_file_search_class,\n\tTP_PROTO(struct inode *inode, unsigned int hash, int found),\n\tTP_ARGS(inode, hash, found),\n\tTP_STRUCT__entry(\n\t\t__field(struct inode *, inode)\n\t\t__field(unsigned int, hash)\n\t\t__field(int, found)\n\t),\n\tTP_fast_assign(\n\t\t__entry->inode = inode;\n\t\t__entry->hash = hash;\n\t\t__entry->found = found;\n\t),\n\tTP_printk(\"hash=0x%x inode=%p found=%d\", __entry->hash,\n\t\t\t__entry->inode, __entry->found)\n);\n\n#define DEFINE_NFSD_FILE_SEARCH_EVENT(name)\t\t\t\t\\\nDEFINE_EVENT(nfsd_file_search_class, name,\t\t\t\t\\\n\tTP_PROTO(struct inode *inode, unsigned int hash, int found),\t\\\n\tTP_ARGS(inode, hash, found))\n\nDEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode_sync);\nDEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode);\nDEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_is_cached);\n\nTRACE_EVENT(nfsd_file_fsnotify_handle_event,\n\tTP_PROTO(struct inode *inode, u32 mask),\n\tTP_ARGS(inode, mask),\n\tTP_STRUCT__entry(\n\t\t__field(struct inode *, inode)\n\t\t__field(unsigned int, nlink)\n\t\t__field(umode_t, mode)\n\t\t__field(u32, mask)\n\t),\n\tTP_fast_assign(\n\t\t__entry->inode = inode;\n\t\t__entry->nlink = inode->i_nlink;\n\t\t__entry->mode = inode->i_mode;\n\t\t__entry->mask = mask;\n\t),\n\tTP_printk(\"inode=%p nlink=%u mode=0%ho mask=0x%x\", __entry->inode,\n\t\t\t__entry->nlink, __entry->mode, __entry->mask)\n);\n\n#include \"cache.h\"\n\nTRACE_DEFINE_ENUM(RC_DROPIT);\nTRACE_DEFINE_ENUM(RC_REPLY);\nTRACE_DEFINE_ENUM(RC_DOIT);\n\n#define show_drc_retval(x)\t\t\t\t\t\t\\\n\t__print_symbolic(x,\t\t\t\t\t\t\\\n\t\t{ RC_DROPIT, \"DROPIT\" },\t\t\t\t\\\n\t\t{ RC_REPLY, \"REPLY\" },\t\t\t\t\t\\\n\t\t{ RC_DOIT, \"DOIT\" })\n\nTRACE_EVENT(nfsd_drc_found,\n\tTP_PROTO(\n\t\tconst struct nfsd_net *nn,\n\t\tconst struct svc_rqst *rqstp,\n\t\tint result\n\t),\n\tTP_ARGS(nn, rqstp, result),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t\t__field(unsigned long, result)\n\t\t__field(u32, xid)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t\t__entry->result = result;\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t),\n\tTP_printk(\"boot_time=%16llx xid=0x%08x result=%s\",\n\t\t__entry->boot_time, __entry->xid,\n\t\tshow_drc_retval(__entry->result))\n\n);\n\nTRACE_EVENT(nfsd_drc_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfsd_net *nn,\n\t\tconst struct svc_cacherep *key,\n\t\tconst struct svc_cacherep *rp\n\t),\n\tTP_ARGS(nn, key, rp),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t\t__field(u32, xid)\n\t\t__field(u32, cached)\n\t\t__field(u32, ingress)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t\t__entry->xid = be32_to_cpu(key->c_key.k_xid);\n\t\t__entry->cached = (__force u32)key->c_key.k_csum;\n\t\t__entry->ingress = (__force u32)rp->c_key.k_csum;\n\t),\n\tTP_printk(\"boot_time=%16llx xid=0x%08x cached-csum=0x%08x ingress-csum=0x%08x\",\n\t\t__entry->boot_time, __entry->xid, __entry->cached,\n\t\t__entry->ingress)\n);\n\nTRACE_EVENT(nfsd_cb_args,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct nfs4_cb_conn *conn\n\t),\n\tTP_ARGS(clp, conn),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, prog)\n\t\t__field(u32, ident)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->prog = conn->cb_prog;\n\t\t__entry->ident = conn->cb_ident;\n\t\tmemcpy(__entry->addr, &conn->cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x prog=%u ident=%u\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->prog, __entry->ident)\n);\n\nTRACE_EVENT(nfsd_cb_nodelegs,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t),\n\tTP_printk(\"client %08x:%08x\", __entry->cl_boot, __entry->cl_id)\n)\n\n#define show_cb_state(val)\t\t\t\t\t\t\\\n\t__print_symbolic(val,\t\t\t\t\t\t\\\n\t\t{ NFSD4_CB_UP,\t\t\"UP\" },\t\t\t\t\\\n\t\t{ NFSD4_CB_UNKNOWN,\t\"UNKNOWN\" },\t\t\t\\\n\t\t{ NFSD4_CB_DOWN,\t\"DOWN\" },\t\t\t\\\n\t\t{ NFSD4_CB_FAULT,\t\"FAULT\"})\n\nDECLARE_EVENT_CLASS(nfsd_cb_class,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long, state)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->state = clp->cl_cb_state;\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x state=%s\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\tshow_cb_state(__entry->state))\n);\n\n#define DEFINE_NFSD_CB_EVENT(name)\t\t\t\\\nDEFINE_EVENT(nfsd_cb_class, nfsd_cb_##name,\t\t\\\n\tTP_PROTO(const struct nfs4_client *clp),\t\\\n\tTP_ARGS(clp))\n\nDEFINE_NFSD_CB_EVENT(state);\nDEFINE_NFSD_CB_EVENT(probe);\nDEFINE_NFSD_CB_EVENT(lost);\nDEFINE_NFSD_CB_EVENT(shutdown);\n\nTRACE_DEFINE_ENUM(RPC_AUTH_NULL);\nTRACE_DEFINE_ENUM(RPC_AUTH_UNIX);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5I);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5P);\n\n#define show_nfsd_authflavor(val)\t\t\t\t\t\\\n\t__print_symbolic(val,\t\t\t\t\t\t\\\n\t\t{ RPC_AUTH_NULL,\t\t\"none\" },\t\t\\\n\t\t{ RPC_AUTH_UNIX,\t\t\"sys\" },\t\t\\\n\t\t{ RPC_AUTH_GSS,\t\t\t\"gss\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5,\t\t\"krb5\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5I,\t\t\"krb5i\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5P,\t\t\"krb5p\" })\n\nTRACE_EVENT(nfsd_cb_setup,\n\tTP_PROTO(const struct nfs4_client *clp,\n\t\t const char *netid,\n\t\t rpc_authflavor_t authflavor\n\t),\n\tTP_ARGS(clp, netid, authflavor),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(unsigned long, authflavor)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t\t__array(unsigned char, netid, 8)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tstrlcpy(__entry->netid, netid, sizeof(__entry->netid));\n\t\t__entry->authflavor = authflavor;\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x proto=%s flavor=%s\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->netid, show_nfsd_authflavor(__entry->authflavor))\n);\n\nTRACE_EVENT(nfsd_cb_setup_err,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tlong error\n\t),\n\tTP_ARGS(clp, error),\n\tTP_STRUCT__entry(\n\t\t__field(long, error)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->error = error;\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x error=%ld\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id, __entry->error)\n);\n\nTRACE_EVENT(nfsd_cb_recall,\n\tTP_PROTO(\n\t\tconst struct nfs4_stid *stid\n\t),\n\tTP_ARGS(stid),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\tconst stateid_t *stp = &stid->sc_stateid;\n\t\tconst struct nfs4_client *clp = stid->sc_client;\n\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t\tif (clp)\n\t\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\t\tsizeof(struct sockaddr_in6));\n\t\telse\n\t\t\tmemset(__entry->addr, 0, sizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x stateid %08x:%08x\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation)\n);\n\nTRACE_EVENT(nfsd_cb_notify_lock,\n\tTP_PROTO(\n\t\tconst struct nfs4_lockowner *lo,\n\t\tconst struct nfsd4_blocked_lock *nbl\n\t),\n\tTP_ARGS(lo, nbl),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, fh_hash)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\tconst struct nfs4_client *clp = lo->lo_owner.so_client;\n\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->fh_hash = knfsd_fh_hash(&nbl->nbl_fh);\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x fh_hash=0x%08x\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->fh_hash)\n);\n\nTRACE_EVENT(nfsd_cb_offload,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst stateid_t *stp,\n\t\tconst struct knfsd_fh *fh,\n\t\tu64 count,\n\t\t__be32 status\n\t),\n\tTP_ARGS(clp, stp, fh, count, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t\t__field(u32, fh_hash)\n\t\t__field(int, status)\n\t\t__field(u64, count)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t\t__entry->fh_hash = knfsd_fh_hash(fh);\n\t\t__entry->status = be32_to_cpu(status);\n\t\t__entry->count = count;\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x stateid %08x:%08x fh_hash=0x%08x count=%llu status=%d\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation,\n\t\t__entry->fh_hash, __entry->count, __entry->status)\n);\n\n#endif /* _NFSD_TRACE_H */\n\n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#define TRACE_INCLUDE_FILE trace\n#include <trace/define_trace.h>\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Copyright (c) 2014 Christoph Hellwig.\n */\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM nfsd\n\n#if !defined(_NFSD_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _NFSD_TRACE_H\n\n#include <linux/tracepoint.h>\n#include \"export.h\"\n#include \"nfsfh.h\"\n\n#define NFSD_TRACE_PROC_ARG_FIELDS \\\n\t\t__field(unsigned int, netns_ino) \\\n\t\t__field(u32, xid) \\\n\t\t__array(unsigned char, server, sizeof(struct sockaddr_in6)) \\\n\t\t__array(unsigned char, client, sizeof(struct sockaddr_in6))\n\n#define NFSD_TRACE_PROC_ARG_ASSIGNMENTS \\\n\t\tdo { \\\n\t\t\t__entry->netns_ino = SVC_NET(rqstp)->ns.inum; \\\n\t\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid); \\\n\t\t\tmemcpy(__entry->server, &rqstp->rq_xprt->xpt_local, \\\n\t\t\t       rqstp->rq_xprt->xpt_locallen); \\\n\t\t\tmemcpy(__entry->client, &rqstp->rq_xprt->xpt_remote, \\\n\t\t\t       rqstp->rq_xprt->xpt_remotelen); \\\n\t\t} while (0);\n\n#define NFSD_TRACE_PROC_RES_FIELDS \\\n\t\t__field(unsigned int, netns_ino) \\\n\t\t__field(u32, xid) \\\n\t\t__field(unsigned long, status) \\\n\t\t__array(unsigned char, server, sizeof(struct sockaddr_in6)) \\\n\t\t__array(unsigned char, client, sizeof(struct sockaddr_in6))\n\n#define NFSD_TRACE_PROC_RES_ASSIGNMENTS(error) \\\n\t\tdo { \\\n\t\t\t__entry->netns_ino = SVC_NET(rqstp)->ns.inum; \\\n\t\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid); \\\n\t\t\t__entry->status = be32_to_cpu(error); \\\n\t\t\tmemcpy(__entry->server, &rqstp->rq_xprt->xpt_local, \\\n\t\t\t       rqstp->rq_xprt->xpt_locallen); \\\n\t\t\tmemcpy(__entry->client, &rqstp->rq_xprt->xpt_remote, \\\n\t\t\t       rqstp->rq_xprt->xpt_remotelen); \\\n\t\t} while (0);\n\nTRACE_EVENT(nfsd_garbage_args_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp\n\t),\n\tTP_ARGS(rqstp),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_ARG_FIELDS\n\n\t\t__field(u32, vers)\n\t\t__field(u32, proc)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_ARG_ASSIGNMENTS\n\n\t\t__entry->vers = rqstp->rq_vers;\n\t\t__entry->proc = rqstp->rq_proc;\n\t),\n\tTP_printk(\"xid=0x%08x vers=%u proc=%u\",\n\t\t__entry->xid, __entry->vers, __entry->proc\n\t)\n);\n\nTRACE_EVENT(nfsd_cant_encode_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp\n\t),\n\tTP_ARGS(rqstp),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_ARG_FIELDS\n\n\t\t__field(u32, vers)\n\t\t__field(u32, proc)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_ARG_ASSIGNMENTS\n\n\t\t__entry->vers = rqstp->rq_vers;\n\t\t__entry->proc = rqstp->rq_proc;\n\t),\n\tTP_printk(\"xid=0x%08x vers=%u proc=%u\",\n\t\t__entry->xid, __entry->vers, __entry->proc\n\t)\n);\n\n#define show_nfsd_may_flags(x)\t\t\t\t\t\t\\\n\t__print_flags(x, \"|\",\t\t\t\t\t\t\\\n\t\t{ NFSD_MAY_EXEC,\t\t\"EXEC\" },\t\t\\\n\t\t{ NFSD_MAY_WRITE,\t\t\"WRITE\" },\t\t\\\n\t\t{ NFSD_MAY_READ,\t\t\"READ\" },\t\t\\\n\t\t{ NFSD_MAY_SATTR,\t\t\"SATTR\" },\t\t\\\n\t\t{ NFSD_MAY_TRUNC,\t\t\"TRUNC\" },\t\t\\\n\t\t{ NFSD_MAY_LOCK,\t\t\"LOCK\" },\t\t\\\n\t\t{ NFSD_MAY_OWNER_OVERRIDE,\t\"OWNER_OVERRIDE\" },\t\\\n\t\t{ NFSD_MAY_LOCAL_ACCESS,\t\"LOCAL_ACCESS\" },\t\\\n\t\t{ NFSD_MAY_BYPASS_GSS_ON_ROOT,\t\"BYPASS_GSS_ON_ROOT\" },\t\\\n\t\t{ NFSD_MAY_NOT_BREAK_LEASE,\t\"NOT_BREAK_LEASE\" },\t\\\n\t\t{ NFSD_MAY_BYPASS_GSS,\t\t\"BYPASS_GSS\" },\t\t\\\n\t\t{ NFSD_MAY_READ_IF_EXEC,\t\"READ_IF_EXEC\" },\t\\\n\t\t{ NFSD_MAY_64BIT_COOKIE,\t\"64BIT_COOKIE\" })\n\nTRACE_EVENT(nfsd_compound,\n\tTP_PROTO(const struct svc_rqst *rqst,\n\t\t u32 args_opcnt),\n\tTP_ARGS(rqst, args_opcnt),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, args_opcnt)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqst->rq_xid);\n\t\t__entry->args_opcnt = args_opcnt;\n\t),\n\tTP_printk(\"xid=0x%08x opcnt=%u\",\n\t\t__entry->xid, __entry->args_opcnt)\n)\n\nTRACE_EVENT(nfsd_compound_status,\n\tTP_PROTO(u32 args_opcnt,\n\t\t u32 resp_opcnt,\n\t\t __be32 status,\n\t\t const char *name),\n\tTP_ARGS(args_opcnt, resp_opcnt, status, name),\n\tTP_STRUCT__entry(\n\t\t__field(u32, args_opcnt)\n\t\t__field(u32, resp_opcnt)\n\t\t__field(int, status)\n\t\t__string(name, name)\n\t),\n\tTP_fast_assign(\n\t\t__entry->args_opcnt = args_opcnt;\n\t\t__entry->resp_opcnt = resp_opcnt;\n\t\t__entry->status = be32_to_cpu(status);\n\t\t__assign_str(name, name);\n\t),\n\tTP_printk(\"op=%u/%u %s status=%d\",\n\t\t__entry->resp_opcnt, __entry->args_opcnt,\n\t\t__get_str(name), __entry->status)\n)\n\nTRACE_EVENT(nfsd_compound_decode_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tu32 args_opcnt,\n\t\tu32 resp_opcnt,\n\t\tu32 opnum,\n\t\t__be32 status\n\t),\n\tTP_ARGS(rqstp, args_opcnt, resp_opcnt, opnum, status),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_RES_FIELDS\n\n\t\t__field(u32, args_opcnt)\n\t\t__field(u32, resp_opcnt)\n\t\t__field(u32, opnum)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_RES_ASSIGNMENTS(status)\n\n\t\t__entry->args_opcnt = args_opcnt;\n\t\t__entry->resp_opcnt = resp_opcnt;\n\t\t__entry->opnum = opnum;\n\t),\n\tTP_printk(\"op=%u/%u opnum=%u status=%lu\",\n\t\t__entry->resp_opcnt, __entry->args_opcnt,\n\t\t__entry->opnum, __entry->status)\n);\n\nTRACE_EVENT(nfsd_compound_encode_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tu32 opnum,\n\t\t__be32 status\n\t),\n\tTP_ARGS(rqstp, opnum, status),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_RES_FIELDS\n\n\t\t__field(u32, opnum)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_RES_ASSIGNMENTS(status)\n\n\t\t__entry->opnum = opnum;\n\t),\n\tTP_printk(\"opnum=%u status=%lu\",\n\t\t__entry->opnum, __entry->status)\n);\n\n\nDECLARE_EVENT_CLASS(nfsd_fh_err_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t int\t\tstatus),\n\tTP_ARGS(rqstp, fhp, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x status=%d\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->status)\n)\n\n#define DEFINE_NFSD_FH_ERR_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_fh_err_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t int\t\tstatus),\t\\\n\tTP_ARGS(rqstp, fhp, status))\n\nDEFINE_NFSD_FH_ERR_EVENT(set_fh_dentry_badexport);\nDEFINE_NFSD_FH_ERR_EVENT(set_fh_dentry_badhandle);\n\nTRACE_EVENT(nfsd_exp_find_key,\n\tTP_PROTO(const struct svc_expkey *key,\n\t\t int status),\n\tTP_ARGS(key, status),\n\tTP_STRUCT__entry(\n\t\t__field(int, fsidtype)\n\t\t__array(u32, fsid, 6)\n\t\t__string(auth_domain, key->ek_client->name)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fsidtype = key->ek_fsidtype;\n\t\tmemcpy(__entry->fsid, key->ek_fsid, 4*6);\n\t\t__assign_str(auth_domain, key->ek_client->name);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"fsid=%x::%s domain=%s status=%d\",\n\t\t__entry->fsidtype,\n\t\t__print_array(__entry->fsid, 6, 4),\n\t\t__get_str(auth_domain),\n\t\t__entry->status\n\t)\n);\n\nTRACE_EVENT(nfsd_expkey_update,\n\tTP_PROTO(const struct svc_expkey *key, const char *exp_path),\n\tTP_ARGS(key, exp_path),\n\tTP_STRUCT__entry(\n\t\t__field(int, fsidtype)\n\t\t__array(u32, fsid, 6)\n\t\t__string(auth_domain, key->ek_client->name)\n\t\t__string(path, exp_path)\n\t\t__field(bool, cache)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fsidtype = key->ek_fsidtype;\n\t\tmemcpy(__entry->fsid, key->ek_fsid, 4*6);\n\t\t__assign_str(auth_domain, key->ek_client->name);\n\t\t__assign_str(path, exp_path);\n\t\t__entry->cache = !test_bit(CACHE_NEGATIVE, &key->h.flags);\n\t),\n\tTP_printk(\"fsid=%x::%s domain=%s path=%s cache=%s\",\n\t\t__entry->fsidtype,\n\t\t__print_array(__entry->fsid, 6, 4),\n\t\t__get_str(auth_domain),\n\t\t__get_str(path),\n\t\t__entry->cache ? \"pos\" : \"neg\"\n\t)\n);\n\nTRACE_EVENT(nfsd_exp_get_by_name,\n\tTP_PROTO(const struct svc_export *key,\n\t\t int status),\n\tTP_ARGS(key, status),\n\tTP_STRUCT__entry(\n\t\t__string(path, key->ex_path.dentry->d_name.name)\n\t\t__string(auth_domain, key->ex_client->name)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(path, key->ex_path.dentry->d_name.name);\n\t\t__assign_str(auth_domain, key->ex_client->name);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"path=%s domain=%s status=%d\",\n\t\t__get_str(path),\n\t\t__get_str(auth_domain),\n\t\t__entry->status\n\t)\n);\n\nTRACE_EVENT(nfsd_export_update,\n\tTP_PROTO(const struct svc_export *key),\n\tTP_ARGS(key),\n\tTP_STRUCT__entry(\n\t\t__string(path, key->ex_path.dentry->d_name.name)\n\t\t__string(auth_domain, key->ex_client->name)\n\t\t__field(bool, cache)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(path, key->ex_path.dentry->d_name.name);\n\t\t__assign_str(auth_domain, key->ex_client->name);\n\t\t__entry->cache = !test_bit(CACHE_NEGATIVE, &key->h.flags);\n\t),\n\tTP_printk(\"path=%s domain=%s cache=%s\",\n\t\t__get_str(path),\n\t\t__get_str(auth_domain),\n\t\t__entry->cache ? \"pos\" : \"neg\"\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_io_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t loff_t\t\toffset,\n\t\t unsigned long\tlen),\n\tTP_ARGS(rqstp, fhp, offset, len),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(loff_t, offset)\n\t\t__field(unsigned long, len)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->offset = offset;\n\t\t__entry->len = len;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x offset=%lld len=%lu\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->offset, __entry->len)\n)\n\n#define DEFINE_NFSD_IO_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_io_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t loff_t\t\toffset,\t\t\\\n\t\t unsigned long\tlen),\t\t\\\n\tTP_ARGS(rqstp, fhp, offset, len))\n\nDEFINE_NFSD_IO_EVENT(read_start);\nDEFINE_NFSD_IO_EVENT(read_splice);\nDEFINE_NFSD_IO_EVENT(read_vector);\nDEFINE_NFSD_IO_EVENT(read_io_done);\nDEFINE_NFSD_IO_EVENT(read_done);\nDEFINE_NFSD_IO_EVENT(write_start);\nDEFINE_NFSD_IO_EVENT(write_opened);\nDEFINE_NFSD_IO_EVENT(write_io_done);\nDEFINE_NFSD_IO_EVENT(write_done);\n\nDECLARE_EVENT_CLASS(nfsd_err_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t loff_t\t\toffset,\n\t\t int\t\tstatus),\n\tTP_ARGS(rqstp, fhp, offset, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(loff_t, offset)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->offset = offset;\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x offset=%lld status=%d\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->offset, __entry->status)\n)\n\n#define DEFINE_NFSD_ERR_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_err_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t loff_t\t\toffset,\t\t\\\n\t\t int\t\tlen),\t\t\\\n\tTP_ARGS(rqstp, fhp, offset, len))\n\nDEFINE_NFSD_ERR_EVENT(read_err);\nDEFINE_NFSD_ERR_EVENT(write_err);\n\nTRACE_EVENT(nfsd_dirent,\n\tTP_PROTO(struct svc_fh *fhp,\n\t\t u64 ino,\n\t\t const char *name,\n\t\t int namlen),\n\tTP_ARGS(fhp, ino, name, namlen),\n\tTP_STRUCT__entry(\n\t\t__field(u32, fh_hash)\n\t\t__field(u64, ino)\n\t\t__field(int, len)\n\t\t__dynamic_array(unsigned char, name, namlen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fh_hash = fhp ? knfsd_fh_hash(&fhp->fh_handle) : 0;\n\t\t__entry->ino = ino;\n\t\t__entry->len = namlen;\n\t\tmemcpy(__get_str(name), name, namlen);\n\t),\n\tTP_printk(\"fh_hash=0x%08x ino=%llu name=%.*s\",\n\t\t__entry->fh_hash, __entry->ino,\n\t\t__entry->len, __get_str(name))\n)\n\n#include \"state.h\"\n#include \"filecache.h\"\n#include \"vfs.h\"\n\nDECLARE_EVENT_CLASS(nfsd_stateid_class,\n\tTP_PROTO(stateid_t *stp),\n\tTP_ARGS(stp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t),\n\tTP_printk(\"client %08x:%08x stateid %08x:%08x\",\n\t\t__entry->cl_boot,\n\t\t__entry->cl_id,\n\t\t__entry->si_id,\n\t\t__entry->si_generation)\n)\n\n#define DEFINE_STATEID_EVENT(name) \\\nDEFINE_EVENT(nfsd_stateid_class, nfsd_##name, \\\n\tTP_PROTO(stateid_t *stp), \\\n\tTP_ARGS(stp))\n\nDEFINE_STATEID_EVENT(layoutstate_alloc);\nDEFINE_STATEID_EVENT(layoutstate_unhash);\nDEFINE_STATEID_EVENT(layoutstate_free);\nDEFINE_STATEID_EVENT(layout_get_lookup_fail);\nDEFINE_STATEID_EVENT(layout_commit_lookup_fail);\nDEFINE_STATEID_EVENT(layout_return_lookup_fail);\nDEFINE_STATEID_EVENT(layout_recall);\nDEFINE_STATEID_EVENT(layout_recall_done);\nDEFINE_STATEID_EVENT(layout_recall_fail);\nDEFINE_STATEID_EVENT(layout_recall_release);\n\nDEFINE_STATEID_EVENT(open);\nDEFINE_STATEID_EVENT(deleg_read);\nDEFINE_STATEID_EVENT(deleg_recall);\n\nDECLARE_EVENT_CLASS(nfsd_stateseqid_class,\n\tTP_PROTO(u32 seqid, const stateid_t *stp),\n\tTP_ARGS(seqid, stp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, seqid)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t),\n\tTP_fast_assign(\n\t\t__entry->seqid = seqid;\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t),\n\tTP_printk(\"seqid=%u client %08x:%08x stateid %08x:%08x\",\n\t\t__entry->seqid, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation)\n)\n\n#define DEFINE_STATESEQID_EVENT(name) \\\nDEFINE_EVENT(nfsd_stateseqid_class, nfsd_##name, \\\n\tTP_PROTO(u32 seqid, const stateid_t *stp), \\\n\tTP_ARGS(seqid, stp))\n\nDEFINE_STATESEQID_EVENT(preprocess);\nDEFINE_STATESEQID_EVENT(open_confirm);\n\nDECLARE_EVENT_CLASS(nfsd_clientid_class,\n\tTP_PROTO(const clientid_t *clid),\n\tTP_ARGS(clid),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clid->cl_boot;\n\t\t__entry->cl_id = clid->cl_id;\n\t),\n\tTP_printk(\"client %08x:%08x\", __entry->cl_boot, __entry->cl_id)\n)\n\n#define DEFINE_CLIENTID_EVENT(name) \\\nDEFINE_EVENT(nfsd_clientid_class, nfsd_clid_##name, \\\n\tTP_PROTO(const clientid_t *clid), \\\n\tTP_ARGS(clid))\n\nDEFINE_CLIENTID_EVENT(expire_unconf);\nDEFINE_CLIENTID_EVENT(reclaim_complete);\nDEFINE_CLIENTID_EVENT(confirmed);\nDEFINE_CLIENTID_EVENT(destroyed);\nDEFINE_CLIENTID_EVENT(admin_expired);\nDEFINE_CLIENTID_EVENT(replaced);\nDEFINE_CLIENTID_EVENT(purged);\nDEFINE_CLIENTID_EVENT(renew);\nDEFINE_CLIENTID_EVENT(stale);\n\nDECLARE_EVENT_CLASS(nfsd_net_class,\n\tTP_PROTO(const struct nfsd_net *nn),\n\tTP_ARGS(nn),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t),\n\tTP_printk(\"boot_time=%16llx\", __entry->boot_time)\n)\n\n#define DEFINE_NET_EVENT(name) \\\nDEFINE_EVENT(nfsd_net_class, nfsd_##name, \\\n\tTP_PROTO(const struct nfsd_net *nn), \\\n\tTP_ARGS(nn))\n\nDEFINE_NET_EVENT(grace_start);\nDEFINE_NET_EVENT(grace_complete);\n\nTRACE_EVENT(nfsd_clid_cred_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct svc_rqst *rqstp\n\t),\n\tTP_ARGS(clp, rqstp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(unsigned long, cl_flavor)\n\t\t__field(unsigned long, new_flavor)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->cl_flavor = clp->cl_cred.cr_flavor;\n\t\t__entry->new_flavor = rqstp->rq_cred.cr_flavor;\n\t\tmemcpy(__entry->addr, &rqstp->rq_xprt->xpt_remote,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"client %08x:%08x flavor=%s, conflict=%s from addr=%pISpc\",\n\t\t__entry->cl_boot, __entry->cl_id,\n\t\tshow_nfsd_authflavor(__entry->cl_flavor),\n\t\tshow_nfsd_authflavor(__entry->new_flavor), __entry->addr\n\t)\n)\n\nTRACE_EVENT(nfsd_clid_verf_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst nfs4_verifier *verf\n\t),\n\tTP_ARGS(clp, rqstp, verf),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, cl_verifier, NFS4_VERIFIER_SIZE)\n\t\t__array(unsigned char, new_verifier, NFS4_VERIFIER_SIZE)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->cl_verifier, (void *)&clp->cl_verifier,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\tmemcpy(__entry->new_verifier, (void *)verf,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\tmemcpy(__entry->addr, &rqstp->rq_xprt->xpt_remote,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"client %08x:%08x verf=0x%s, updated=0x%s from addr=%pISpc\",\n\t\t__entry->cl_boot, __entry->cl_id,\n\t\t__print_hex_str(__entry->cl_verifier, NFS4_VERIFIER_SIZE),\n\t\t__print_hex_str(__entry->new_verifier, NFS4_VERIFIER_SIZE),\n\t\t__entry->addr\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_clid_class,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t\t__field(unsigned long, flavor)\n\t\t__array(unsigned char, verifier, NFS4_VERIFIER_SIZE)\n\t\t__dynamic_array(char, name, clp->cl_name.len + 1)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->addr, &clp->cl_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t\t__entry->flavor = clp->cl_cred.cr_flavor;\n\t\tmemcpy(__entry->verifier, (void *)&clp->cl_verifier,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\tmemcpy(__get_str(name), clp->cl_name.data, clp->cl_name.len);\n\t\t__get_str(name)[clp->cl_name.len] = '\\0';\n\t),\n\tTP_printk(\"addr=%pISpc name='%s' verifier=0x%s flavor=%s client=%08x:%08x\",\n\t\t__entry->addr, __get_str(name),\n\t\t__print_hex_str(__entry->verifier, NFS4_VERIFIER_SIZE),\n\t\tshow_nfsd_authflavor(__entry->flavor),\n\t\t__entry->cl_boot, __entry->cl_id)\n);\n\n#define DEFINE_CLID_EVENT(name) \\\nDEFINE_EVENT(nfsd_clid_class, nfsd_clid_##name, \\\n\tTP_PROTO(const struct nfs4_client *clp), \\\n\tTP_ARGS(clp))\n\nDEFINE_CLID_EVENT(fresh);\nDEFINE_CLID_EVENT(confirmed_r);\n\n/*\n * from fs/nfsd/filecache.h\n */\nTRACE_DEFINE_ENUM(NFSD_FILE_HASHED);\nTRACE_DEFINE_ENUM(NFSD_FILE_PENDING);\nTRACE_DEFINE_ENUM(NFSD_FILE_BREAK_READ);\nTRACE_DEFINE_ENUM(NFSD_FILE_BREAK_WRITE);\nTRACE_DEFINE_ENUM(NFSD_FILE_REFERENCED);\n\n#define show_nf_flags(val)\t\t\t\t\t\t\\\n\t__print_flags(val, \"|\",\t\t\t\t\t\t\\\n\t\t{ 1 << NFSD_FILE_HASHED,\t\"HASHED\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_PENDING,\t\"PENDING\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_BREAK_READ,\t\"BREAK_READ\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_BREAK_WRITE,\t\"BREAK_WRITE\" },\t\\\n\t\t{ 1 << NFSD_FILE_REFERENCED,\t\"REFERENCED\"})\n\nDECLARE_EVENT_CLASS(nfsd_file_class,\n\tTP_PROTO(struct nfsd_file *nf),\n\tTP_ARGS(nf),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, nf_hashval)\n\t\t__field(void *, nf_inode)\n\t\t__field(int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned char, nf_may)\n\t\t__field(struct file *, nf_file)\n\t),\n\tTP_fast_assign(\n\t\t__entry->nf_hashval = nf->nf_hashval;\n\t\t__entry->nf_inode = nf->nf_inode;\n\t\t__entry->nf_ref = refcount_read(&nf->nf_ref);\n\t\t__entry->nf_flags = nf->nf_flags;\n\t\t__entry->nf_may = nf->nf_may;\n\t\t__entry->nf_file = nf->nf_file;\n\t),\n\tTP_printk(\"hash=0x%x inode=%p ref=%d flags=%s may=%s file=%p\",\n\t\t__entry->nf_hashval,\n\t\t__entry->nf_inode,\n\t\t__entry->nf_ref,\n\t\tshow_nf_flags(__entry->nf_flags),\n\t\tshow_nfsd_may_flags(__entry->nf_may),\n\t\t__entry->nf_file)\n)\n\n#define DEFINE_NFSD_FILE_EVENT(name) \\\nDEFINE_EVENT(nfsd_file_class, name, \\\n\tTP_PROTO(struct nfsd_file *nf), \\\n\tTP_ARGS(nf))\n\nDEFINE_NFSD_FILE_EVENT(nfsd_file_alloc);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_put_final);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_unhash);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_put);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_unhash_and_release_locked);\n\nTRACE_EVENT(nfsd_file_acquire,\n\tTP_PROTO(struct svc_rqst *rqstp, unsigned int hash,\n\t\t struct inode *inode, unsigned int may_flags,\n\t\t struct nfsd_file *nf, __be32 status),\n\n\tTP_ARGS(rqstp, hash, inode, may_flags, nf, status),\n\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(unsigned int, hash)\n\t\t__field(void *, inode)\n\t\t__field(unsigned long, may_flags)\n\t\t__field(int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned long, nf_may)\n\t\t__field(struct file *, nf_file)\n\t\t__field(u32, status)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->hash = hash;\n\t\t__entry->inode = inode;\n\t\t__entry->may_flags = may_flags;\n\t\t__entry->nf_ref = nf ? refcount_read(&nf->nf_ref) : 0;\n\t\t__entry->nf_flags = nf ? nf->nf_flags : 0;\n\t\t__entry->nf_may = nf ? nf->nf_may : 0;\n\t\t__entry->nf_file = nf ? nf->nf_file : NULL;\n\t\t__entry->status = be32_to_cpu(status);\n\t),\n\n\tTP_printk(\"xid=0x%x hash=0x%x inode=%p may_flags=%s ref=%d nf_flags=%s nf_may=%s nf_file=%p status=%u\",\n\t\t\t__entry->xid, __entry->hash, __entry->inode,\n\t\t\tshow_nfsd_may_flags(__entry->may_flags),\n\t\t\t__entry->nf_ref, show_nf_flags(__entry->nf_flags),\n\t\t\tshow_nfsd_may_flags(__entry->nf_may),\n\t\t\t__entry->nf_file, __entry->status)\n);\n\nDECLARE_EVENT_CLASS(nfsd_file_search_class,\n\tTP_PROTO(struct inode *inode, unsigned int hash, int found),\n\tTP_ARGS(inode, hash, found),\n\tTP_STRUCT__entry(\n\t\t__field(struct inode *, inode)\n\t\t__field(unsigned int, hash)\n\t\t__field(int, found)\n\t),\n\tTP_fast_assign(\n\t\t__entry->inode = inode;\n\t\t__entry->hash = hash;\n\t\t__entry->found = found;\n\t),\n\tTP_printk(\"hash=0x%x inode=%p found=%d\", __entry->hash,\n\t\t\t__entry->inode, __entry->found)\n);\n\n#define DEFINE_NFSD_FILE_SEARCH_EVENT(name)\t\t\t\t\\\nDEFINE_EVENT(nfsd_file_search_class, name,\t\t\t\t\\\n\tTP_PROTO(struct inode *inode, unsigned int hash, int found),\t\\\n\tTP_ARGS(inode, hash, found))\n\nDEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode_sync);\nDEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_close_inode);\nDEFINE_NFSD_FILE_SEARCH_EVENT(nfsd_file_is_cached);\n\nTRACE_EVENT(nfsd_file_fsnotify_handle_event,\n\tTP_PROTO(struct inode *inode, u32 mask),\n\tTP_ARGS(inode, mask),\n\tTP_STRUCT__entry(\n\t\t__field(struct inode *, inode)\n\t\t__field(unsigned int, nlink)\n\t\t__field(umode_t, mode)\n\t\t__field(u32, mask)\n\t),\n\tTP_fast_assign(\n\t\t__entry->inode = inode;\n\t\t__entry->nlink = inode->i_nlink;\n\t\t__entry->mode = inode->i_mode;\n\t\t__entry->mask = mask;\n\t),\n\tTP_printk(\"inode=%p nlink=%u mode=0%ho mask=0x%x\", __entry->inode,\n\t\t\t__entry->nlink, __entry->mode, __entry->mask)\n);\n\n#include \"cache.h\"\n\nTRACE_DEFINE_ENUM(RC_DROPIT);\nTRACE_DEFINE_ENUM(RC_REPLY);\nTRACE_DEFINE_ENUM(RC_DOIT);\n\n#define show_drc_retval(x)\t\t\t\t\t\t\\\n\t__print_symbolic(x,\t\t\t\t\t\t\\\n\t\t{ RC_DROPIT, \"DROPIT\" },\t\t\t\t\\\n\t\t{ RC_REPLY, \"REPLY\" },\t\t\t\t\t\\\n\t\t{ RC_DOIT, \"DOIT\" })\n\nTRACE_EVENT(nfsd_drc_found,\n\tTP_PROTO(\n\t\tconst struct nfsd_net *nn,\n\t\tconst struct svc_rqst *rqstp,\n\t\tint result\n\t),\n\tTP_ARGS(nn, rqstp, result),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t\t__field(unsigned long, result)\n\t\t__field(u32, xid)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t\t__entry->result = result;\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t),\n\tTP_printk(\"boot_time=%16llx xid=0x%08x result=%s\",\n\t\t__entry->boot_time, __entry->xid,\n\t\tshow_drc_retval(__entry->result))\n\n);\n\nTRACE_EVENT(nfsd_drc_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfsd_net *nn,\n\t\tconst struct svc_cacherep *key,\n\t\tconst struct svc_cacherep *rp\n\t),\n\tTP_ARGS(nn, key, rp),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t\t__field(u32, xid)\n\t\t__field(u32, cached)\n\t\t__field(u32, ingress)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t\t__entry->xid = be32_to_cpu(key->c_key.k_xid);\n\t\t__entry->cached = (__force u32)key->c_key.k_csum;\n\t\t__entry->ingress = (__force u32)rp->c_key.k_csum;\n\t),\n\tTP_printk(\"boot_time=%16llx xid=0x%08x cached-csum=0x%08x ingress-csum=0x%08x\",\n\t\t__entry->boot_time, __entry->xid, __entry->cached,\n\t\t__entry->ingress)\n);\n\nTRACE_EVENT(nfsd_cb_args,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct nfs4_cb_conn *conn\n\t),\n\tTP_ARGS(clp, conn),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, prog)\n\t\t__field(u32, ident)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->prog = conn->cb_prog;\n\t\t__entry->ident = conn->cb_ident;\n\t\tmemcpy(__entry->addr, &conn->cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x prog=%u ident=%u\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->prog, __entry->ident)\n);\n\nTRACE_EVENT(nfsd_cb_nodelegs,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t),\n\tTP_printk(\"client %08x:%08x\", __entry->cl_boot, __entry->cl_id)\n)\n\n#define show_cb_state(val)\t\t\t\t\t\t\\\n\t__print_symbolic(val,\t\t\t\t\t\t\\\n\t\t{ NFSD4_CB_UP,\t\t\"UP\" },\t\t\t\t\\\n\t\t{ NFSD4_CB_UNKNOWN,\t\"UNKNOWN\" },\t\t\t\\\n\t\t{ NFSD4_CB_DOWN,\t\"DOWN\" },\t\t\t\\\n\t\t{ NFSD4_CB_FAULT,\t\"FAULT\"})\n\nDECLARE_EVENT_CLASS(nfsd_cb_class,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long, state)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->state = clp->cl_cb_state;\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x state=%s\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\tshow_cb_state(__entry->state))\n);\n\n#define DEFINE_NFSD_CB_EVENT(name)\t\t\t\\\nDEFINE_EVENT(nfsd_cb_class, nfsd_cb_##name,\t\t\\\n\tTP_PROTO(const struct nfs4_client *clp),\t\\\n\tTP_ARGS(clp))\n\nDEFINE_NFSD_CB_EVENT(state);\nDEFINE_NFSD_CB_EVENT(probe);\nDEFINE_NFSD_CB_EVENT(lost);\nDEFINE_NFSD_CB_EVENT(shutdown);\n\nTRACE_DEFINE_ENUM(RPC_AUTH_NULL);\nTRACE_DEFINE_ENUM(RPC_AUTH_UNIX);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5I);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5P);\n\n#define show_nfsd_authflavor(val)\t\t\t\t\t\\\n\t__print_symbolic(val,\t\t\t\t\t\t\\\n\t\t{ RPC_AUTH_NULL,\t\t\"none\" },\t\t\\\n\t\t{ RPC_AUTH_UNIX,\t\t\"sys\" },\t\t\\\n\t\t{ RPC_AUTH_GSS,\t\t\t\"gss\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5,\t\t\"krb5\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5I,\t\t\"krb5i\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5P,\t\t\"krb5p\" })\n\nTRACE_EVENT(nfsd_cb_setup,\n\tTP_PROTO(const struct nfs4_client *clp,\n\t\t const char *netid,\n\t\t rpc_authflavor_t authflavor\n\t),\n\tTP_ARGS(clp, netid, authflavor),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(unsigned long, authflavor)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t\t__array(unsigned char, netid, 8)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tstrlcpy(__entry->netid, netid, sizeof(__entry->netid));\n\t\t__entry->authflavor = authflavor;\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x proto=%s flavor=%s\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->netid, show_nfsd_authflavor(__entry->authflavor))\n);\n\nTRACE_EVENT(nfsd_cb_setup_err,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tlong error\n\t),\n\tTP_ARGS(clp, error),\n\tTP_STRUCT__entry(\n\t\t__field(long, error)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->error = error;\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x error=%ld\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id, __entry->error)\n);\n\nTRACE_EVENT(nfsd_cb_recall,\n\tTP_PROTO(\n\t\tconst struct nfs4_stid *stid\n\t),\n\tTP_ARGS(stid),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\tconst stateid_t *stp = &stid->sc_stateid;\n\t\tconst struct nfs4_client *clp = stid->sc_client;\n\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t\tif (clp)\n\t\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\t\tsizeof(struct sockaddr_in6));\n\t\telse\n\t\t\tmemset(__entry->addr, 0, sizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x stateid %08x:%08x\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation)\n);\n\nTRACE_EVENT(nfsd_cb_notify_lock,\n\tTP_PROTO(\n\t\tconst struct nfs4_lockowner *lo,\n\t\tconst struct nfsd4_blocked_lock *nbl\n\t),\n\tTP_ARGS(lo, nbl),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, fh_hash)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\tconst struct nfs4_client *clp = lo->lo_owner.so_client;\n\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->fh_hash = knfsd_fh_hash(&nbl->nbl_fh);\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x fh_hash=0x%08x\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->fh_hash)\n);\n\nTRACE_EVENT(nfsd_cb_offload,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst stateid_t *stp,\n\t\tconst struct knfsd_fh *fh,\n\t\tu64 count,\n\t\t__be32 status\n\t),\n\tTP_ARGS(clp, stp, fh, count, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t\t__field(u32, fh_hash)\n\t\t__field(int, status)\n\t\t__field(u64, count)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t\t__entry->fh_hash = knfsd_fh_hash(fh);\n\t\t__entry->status = be32_to_cpu(status);\n\t\t__entry->count = count;\n\t\tmemcpy(__entry->addr, &clp->cl_cb_conn.cb_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x stateid %08x:%08x fh_hash=0x%08x count=%llu status=%d\",\n\t\t__entry->addr, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation,\n\t\t__entry->fh_hash, __entry->count, __entry->status)\n);\n\n#endif /* _NFSD_TRACE_H */\n\n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#define TRACE_INCLUDE_FILE trace\n#include <trace/define_trace.h>\n"], "filenames": ["fs/nfsd/trace.h"], "buggy_code_start_loc": [411], "buggy_code_end_loc": [412], "fixing_code_start_loc": [410], "fixing_code_end_loc": [410], "type": "CWE-125", "message": "fs/nfsd/trace.h in the Linux kernel before 5.13.4 might allow remote attackers to cause a denial of service (out-of-bounds read in strlen) by sending NFS traffic when the trace event framework is being used for nfsd.", "other": {"cve": {"id": "CVE-2021-38202", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.180", "lastModified": "2021-10-07T20:39:27.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fs/nfsd/trace.h in the Linux kernel before 5.13.4 might allow remote attackers to cause a denial of service (out-of-bounds read in strlen) by sending NFS traffic when the trace event framework is being used for nfsd."}, {"lang": "es", "value": "El archivo fs/nfsd/trace.h en el kernel de Linux versiones anteriores a 5.13.4, podr\u00eda permitir a atacantes remotos causar una denegaci\u00f3n de servicio (lectura fuera de los l\u00edmites en strlen) mediante el env\u00edo de tr\u00e1fico NFS cuando el marco de eventos de rastreo se est\u00e1 usando para nfsd"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.13.4", "matchCriteriaId": "4C85356F-2C6C-4FB9-B0CA-949711182223"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_bootstrap_os:-:*:*:*:*:*:*:*", "matchCriteriaId": "1C767AA1-88B7-48F0-9F31-A89D16DCD52C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "02DEB4FB-A21D-4CB1-B522-EEE5093E8521"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/7b08cf62b1239a4322427d677ea9363f0ab677c6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210902-0010/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7b08cf62b1239a4322427d677ea9363f0ab677c6"}}