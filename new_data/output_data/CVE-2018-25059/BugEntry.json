{"buggy_code": ["package main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/buildkite/terminal\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/sourcegraph/syntaxhighlight\"\n)\n\nconst (\n\thtmlBegin string = `<!DOCTYPE html>\n<html lang=\"en-US\">\n<head>\n<meta charset=\"UTF-8\">\n<link rel=\"shortcut icon\" href=\"/static/favicon.ico\" />\n<link rel=\"stylesheet\" media=\"all\" href=\"/static/main.css\"/>\n<link rel=\"stylesheet\" media=\"all\" href=\"/static/ansi.css\"/>\n</head>\n<body>`\n\thtmlEnd string = `</body>\n</html>`\n\n\tserverHelp = `Run the server.`\n)\n\nfunc (cmd *serverCommand) Name() string      { return \"server\" }\nfunc (cmd *serverCommand) Args() string      { return \"[OPTIONS]\" }\nfunc (cmd *serverCommand) ShortHelp() string { return serverHelp }\nfunc (cmd *serverCommand) LongHelp() string  { return serverHelp }\nfunc (cmd *serverCommand) Hidden() bool      { return false }\n\nfunc (cmd *serverCommand) Register(fs *flag.FlagSet) {\n\tfs.StringVar(&cmd.cert, \"cert\", \"\", \"path to ssl cert\")\n\tfs.StringVar(&cmd.key, \"key\", \"\", \"path to ssl key\")\n\tfs.StringVar(&cmd.port, \"port\", \"8080\", \"port for server to run on\")\n\n\tfs.StringVar(&cmd.storage, \"s\", \"/etc/pastebinit/files\", \"directory to store pastes\")\n\tfs.StringVar(&cmd.storage, \"storage\", \"/etc/pastebinit/files\", \"directory to store pastes\")\n\n\tfs.StringVar(&cmd.assetPath, \"asset-path\", \"/src/static\", \"Path to assets and templates\")\n}\n\ntype serverCommand struct {\n\tcert string\n\tkey  string\n\tport string\n\n\tstorage   string\n\tassetPath string\n}\n\n// JSONResponse is a map[string]string\n// response from the web server.\ntype JSONResponse map[string]string\n\n// String returns the string representation of the\n// JSONResponse object.\nfunc (j JSONResponse) String() string {\n\tstr, err := json.MarshalIndent(j, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Sprintf(`{\n  \"error\": \"%v\"\n}`, err)\n\t}\n\n\treturn string(str)\n}\n\nfunc (cmd *serverCommand) Run(ctx context.Context, args []string) error {\n\t// create the storage directory\n\tif err := os.MkdirAll(cmd.storage, 0755); err != nil {\n\t\tlogrus.Fatalf(\"creating storage directory %q failed: %v\", cmd.storage, err)\n\t}\n\n\t// create mux server\n\tmux := http.NewServeMux()\n\n\t// static files handler\n\tstaticHandler := http.StripPrefix(\"/static/\", http.FileServer(http.Dir(cmd.assetPath)))\n\tmux.Handle(\"/static/\", staticHandler)\n\n\t// pastes & view handlers\n\tmux.HandleFunc(\"/paste\", cmd.pasteUploadHandler) // paste upload handler\n\tmux.HandleFunc(\"/\", cmd.pasteHandler)            // index & paste server handler\n\n\t// Set up the server.\n\tserver := &http.Server{\n\t\tAddr:    \":\" + cmd.port,\n\t\tHandler: mux,\n\t}\n\tlogrus.Infof(\"Starting server on port %d\", cmd.port)\n\tif len(cmd.cert) > 0 && len(cmd.key) > 0 {\n\t\treturn server.ListenAndServeTLS(cmd.cert, cmd.key)\n\t}\n\treturn server.ListenAndServe()\n}\n\n// generateIndexHTML generates the html for the index page\n// to list all the pastes, via walking the storage directory.\nfunc (cmd *serverCommand) generateIndexHTML() (string, error) {\n\tvar files string\n\n\t// create the function to walk the pastes files\n\twalkPastes := func(pth string, f os.FileInfo, err error) error {\n\t\tbase := filepath.Base(pth)\n\t\tif base != cmd.storage {\n\t\t\tfiles += fmt.Sprintf(`<tr>\n<td><a href=\"%s%s\">%s</a></td>\n<td>%s</td>\n<td>%d</td>\n</tr>`, baseuri, base, base, f.ModTime().Format(\"2006-01-02T15:04:05Z07:00\"), f.Size())\n\t\t}\n\t\treturn nil\n\t}\n\n\t// walk the pastes\n\tif err := filepath.Walk(cmd.storage, walkPastes); err != nil {\n\t\treturn \"\", fmt.Errorf(\"walking %s failed: %v\", cmd.storage, err)\n\t}\n\n\thtml := fmt.Sprintf(`%s\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>name</th><th>modified</th><th>size</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t%s\n\t</tbody>\n</table>\n%s`, htmlBegin, files, htmlEnd)\n\n\treturn html, nil\n}\n\n// pasteHandler is the request handler for / and /{pasteid}\n// it returns a list of all pastes to / if properly authed\n// and returns the paste to the public if /{pasteid} exists.\nfunc (cmd *serverCommand) pasteHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.URL.Path == \"/\" {\n\t\t// they want the root, make them auth\n\t\tu, p, ok := r.BasicAuth()\n\t\tif (u != username || p != password) || !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+baseuri+`\"`)\n\t\t\tw.WriteHeader(401)\n\t\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t\t\treturn\n\t\t}\n\n\t\thtml, err := cmd.generateIndexHTML()\n\t\tif err != nil {\n\t\t\twriteError(w, fmt.Sprintf(\"generating index html failed: %v\", err))\n\t\t\treturn\n\t\t}\n\n\t\t// write the html\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfmt.Fprint(w, html)\n\t\tlogrus.Info(\"index file rendered\")\n\t\treturn\n\t}\n\n\tfilename := filepath.Join(cmd.storage, strings.Trim(r.URL.Path, \"/\"))\n\n\tvar handler func(data []byte) (string, error)\n\n\tif strings.HasSuffix(filename, \"/raw\") {\n\t\t// if they want the raw file serve a text/plain Content-Type\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\t// trim '/raw' from the filename so we can get the right file\n\t\tfilename = strings.TrimSuffix(filename, \"/raw\")\n\t\thandler = func(data []byte) (string, error) {\n\t\t\treturn string(data), nil\n\t\t}\n\t} else if strings.HasSuffix(filename, \"/html\") {\n\t\t// check if they want html\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfilename = strings.TrimSuffix(filename, \"/html\")\n\t\thandler = func(data []byte) (string, error) {\n\t\t\treturn string(data), nil\n\t\t}\n\t} else if strings.HasSuffix(filename, \"/ansi\") {\n\t\t// check if they want ansi colored text\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfilename = strings.TrimSuffix(filename, \"/ansi\")\n\t\t// try to syntax highlight the file\n\t\thandler = func(data []byte) (string, error) {\n\t\t\treturn fmt.Sprintf(\"%s<pre><code>%s</code></pre>%s\", htmlBegin, terminal.Render(data), htmlEnd), nil\n\t\t}\n\t} else {\n\t\t// check if they want html\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\thandler = func(data []byte) (string, error) {\n\t\t\thighlighted, err := syntaxhighlight.AsHTML(data)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\treturn fmt.Sprintf(\"%s<pre><code>%s</code></pre>%s\", htmlBegin, string(highlighted), htmlEnd), nil\n\t\t}\n\t}\n\n\t// check if the file exists\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\n\t\twriteError(w, fmt.Sprintf(\"No such file or directory: %s\", filename))\n\t\treturn\n\t}\n\n\t// read the file\n\tsrc, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\twriteError(w, fmt.Sprintf(\"Reading file %s failed: %v\", filename, err))\n\t\treturn\n\t}\n\n\tdata, err := handler(src)\n\tif err != nil {\n\t\twriteError(w, fmt.Sprintf(\"Processing file %s failed: %v\", filename, err))\n\t}\n\n\tio.WriteString(w, data)\n\treturn\n}\n\n// pasteUploadHander is the request handler for /paste\n// it creates a uuid for the paste and saves the contents of\n// the paste to that file.\nfunc (cmd *serverCommand) pasteUploadHandler(w http.ResponseWriter, r *http.Request) {\n\t// check basic auth\n\tu, p, ok := r.BasicAuth()\n\tif (u != username || p != password) || !ok {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+baseuri+`\"`)\n\t\tw.WriteHeader(401)\n\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t\treturn\n\t}\n\n\t// set the content type and check to make sure they are POST-ing a paste\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif r.Method != \"POST\" {\n\t\twriteError(w, \"not a valid endpoint\")\n\t\treturn\n\t}\n\n\t// read the body of the paste\n\tcontent, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\twriteError(w, fmt.Sprintf(\"reading from body failed: %v\", err))\n\t\treturn\n\t}\n\n\t// create a unique id for the paste\n\tid, err := uuid()\n\tif err != nil {\n\t\twriteError(w, fmt.Sprintf(\"uuid generation failed: %v\", err))\n\t\treturn\n\t}\n\n\t// write to file\n\tfile := filepath.Join(cmd.storage, id)\n\tif err := ioutil.WriteFile(file, content, 0755); err != nil {\n\t\twriteError(w, fmt.Sprintf(\"writing file to %q failed: %v\", file, err))\n\t\treturn\n\t}\n\n\t// serve the uri for the paste to the requester\n\tfmt.Fprint(w, JSONResponse{\n\t\t\"uri\": baseuri + id,\n\t})\n\tlogrus.Infof(\"paste %q posted successfully\", id)\n\treturn\n}\n\n// uuid generates a uuid for the paste.\n// This really does not need to be perfect.\nfunc uuid() (string, error) {\n\tvar chars = []byte(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")\n\n\tlength := 8\n\tb := make([]byte, length)\n\tr := make([]byte, length+(length/4))\n\tmaxrb := 256 - (256 % len(chars))\n\ti := 0\n\tfor {\n\t\tif _, err := io.ReadFull(rand.Reader, r); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, rb := range r {\n\t\t\tc := int(rb)\n\t\t\tif c > maxrb {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tb[i] = chars[c%len(chars)]\n\t\t\ti++\n\t\t\tif i == length {\n\t\t\t\treturn string(b), nil\n\t\t\t}\n\t\t}\n\t}\n}\n\n// writeError sends an error back to the requester\n// and also logs the error.\nfunc writeError(w http.ResponseWriter, msg string) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tfmt.Fprint(w, JSONResponse{\n\t\t\"error\": msg,\n\t})\n\tlogrus.Printf(\"writing error: %s\", msg)\n\treturn\n}\n"], "fixing_code": ["package main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/buildkite/terminal\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/sourcegraph/syntaxhighlight\"\n)\n\nconst (\n\thtmlBegin string = `<!DOCTYPE html>\n<html lang=\"en-US\">\n<head>\n<meta charset=\"UTF-8\">\n<link rel=\"shortcut icon\" href=\"/static/favicon.ico\" />\n<link rel=\"stylesheet\" media=\"all\" href=\"/static/main.css\"/>\n<link rel=\"stylesheet\" media=\"all\" href=\"/static/ansi.css\"/>\n</head>\n<body>`\n\thtmlEnd string = `</body>\n</html>`\n\n\tserverHelp = `Run the server.`\n)\n\nfunc (cmd *serverCommand) Name() string      { return \"server\" }\nfunc (cmd *serverCommand) Args() string      { return \"[OPTIONS]\" }\nfunc (cmd *serverCommand) ShortHelp() string { return serverHelp }\nfunc (cmd *serverCommand) LongHelp() string  { return serverHelp }\nfunc (cmd *serverCommand) Hidden() bool      { return false }\n\nfunc (cmd *serverCommand) Register(fs *flag.FlagSet) {\n\tfs.StringVar(&cmd.cert, \"cert\", \"\", \"path to ssl cert\")\n\tfs.StringVar(&cmd.key, \"key\", \"\", \"path to ssl key\")\n\tfs.StringVar(&cmd.port, \"port\", \"8080\", \"port for server to run on\")\n\n\tfs.StringVar(&cmd.storage, \"s\", \"/etc/pastebinit/files\", \"directory to store pastes\")\n\tfs.StringVar(&cmd.storage, \"storage\", \"/etc/pastebinit/files\", \"directory to store pastes\")\n\n\tfs.StringVar(&cmd.assetPath, \"asset-path\", \"/src/static\", \"Path to assets and templates\")\n}\n\ntype serverCommand struct {\n\tcert string\n\tkey  string\n\tport string\n\n\tstorage   string\n\tassetPath string\n}\n\n// JSONResponse is a map[string]string\n// response from the web server.\ntype JSONResponse map[string]string\n\n// String returns the string representation of the\n// JSONResponse object.\nfunc (j JSONResponse) String() string {\n\tstr, err := json.MarshalIndent(j, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Sprintf(`{\n  \"error\": \"%v\"\n}`, err)\n\t}\n\n\treturn string(str)\n}\n\nfunc (cmd *serverCommand) Run(ctx context.Context, args []string) error {\n\t// create the storage directory\n\tif err := os.MkdirAll(cmd.storage, 0755); err != nil {\n\t\tlogrus.Fatalf(\"creating storage directory %q failed: %v\", cmd.storage, err)\n\t}\n\n\t// create mux server\n\tmux := http.NewServeMux()\n\n\t// static files handler\n\tstaticHandler := http.StripPrefix(\"/static/\", http.FileServer(http.Dir(cmd.assetPath)))\n\tmux.Handle(\"/static/\", staticHandler)\n\n\t// pastes & view handlers\n\tmux.HandleFunc(\"/paste\", cmd.pasteUploadHandler) // paste upload handler\n\tmux.HandleFunc(\"/\", cmd.pasteHandler)            // index & paste server handler\n\n\t// Set up the server.\n\tserver := &http.Server{\n\t\tAddr:    \":\" + cmd.port,\n\t\tHandler: mux,\n\t}\n\tlogrus.Infof(\"Starting server on port %d\", cmd.port)\n\tif len(cmd.cert) > 0 && len(cmd.key) > 0 {\n\t\treturn server.ListenAndServeTLS(cmd.cert, cmd.key)\n\t}\n\treturn server.ListenAndServe()\n}\n\n// generateIndexHTML generates the html for the index page\n// to list all the pastes, via walking the storage directory.\nfunc (cmd *serverCommand) generateIndexHTML() (string, error) {\n\tvar files string\n\n\t// create the function to walk the pastes files\n\twalkPastes := func(pth string, f os.FileInfo, err error) error {\n\t\tbase := filepath.Base(pth)\n\t\tif base != cmd.storage {\n\t\t\tfiles += fmt.Sprintf(`<tr>\n<td><a href=\"%s%s\">%s</a></td>\n<td>%s</td>\n<td>%d</td>\n</tr>`, baseuri, base, base, f.ModTime().Format(\"2006-01-02T15:04:05Z07:00\"), f.Size())\n\t\t}\n\t\treturn nil\n\t}\n\n\t// walk the pastes\n\tif err := filepath.Walk(cmd.storage, walkPastes); err != nil {\n\t\treturn \"\", fmt.Errorf(\"walking %s failed: %v\", cmd.storage, err)\n\t}\n\n\thtml := fmt.Sprintf(`%s\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>name</th><th>modified</th><th>size</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t%s\n\t</tbody>\n</table>\n%s`, htmlBegin, files, htmlEnd)\n\n\treturn html, nil\n}\n\n// pasteHandler is the request handler for / and /{pasteid}\n// it returns a list of all pastes to / if properly authed\n// and returns the paste to the public if /{pasteid} exists.\nfunc (cmd *serverCommand) pasteHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.URL.Path == \"/\" {\n\t\t// they want the root, make them auth\n\t\tu, p, ok := r.BasicAuth()\n\t\tif (u != username || p != password) || !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+baseuri+`\"`)\n\t\t\tw.WriteHeader(401)\n\t\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t\t\treturn\n\t\t}\n\n\t\thtml, err := cmd.generateIndexHTML()\n\t\tif err != nil {\n\t\t\twriteError(w, fmt.Sprintf(\"generating index html failed: %v\", err))\n\t\t\treturn\n\t\t}\n\n\t\t// write the html\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfmt.Fprint(w, html)\n\t\tlogrus.Info(\"index file rendered\")\n\t\treturn\n\t}\n\n\tfilename := filepath.Join(cmd.storage, filepath.FromSlash(path.Clean(\"/\"+strings.Trim(r.URL.Path, \"/\"))))\n\n\tvar handler func(data []byte) (string, error)\n\n\tif strings.HasSuffix(filename, \"/raw\") {\n\t\t// if they want the raw file serve a text/plain Content-Type\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\t// trim '/raw' from the filename so we can get the right file\n\t\tfilename = strings.TrimSuffix(filename, \"/raw\")\n\t\thandler = func(data []byte) (string, error) {\n\t\t\treturn string(data), nil\n\t\t}\n\t} else if strings.HasSuffix(filename, \"/html\") {\n\t\t// check if they want html\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfilename = strings.TrimSuffix(filename, \"/html\")\n\t\thandler = func(data []byte) (string, error) {\n\t\t\treturn string(data), nil\n\t\t}\n\t} else if strings.HasSuffix(filename, \"/ansi\") {\n\t\t// check if they want ansi colored text\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfilename = strings.TrimSuffix(filename, \"/ansi\")\n\t\t// try to syntax highlight the file\n\t\thandler = func(data []byte) (string, error) {\n\t\t\treturn fmt.Sprintf(\"%s<pre><code>%s</code></pre>%s\", htmlBegin, terminal.Render(data), htmlEnd), nil\n\t\t}\n\t} else {\n\t\t// check if they want html\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\thandler = func(data []byte) (string, error) {\n\t\t\thighlighted, err := syntaxhighlight.AsHTML(data)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\treturn fmt.Sprintf(\"%s<pre><code>%s</code></pre>%s\", htmlBegin, string(highlighted), htmlEnd), nil\n\t\t}\n\t}\n\n\t// check if the file exists\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\n\t\twriteError(w, fmt.Sprintf(\"No such file or directory: %s\", r.URL.Path))\n\t\treturn\n\t}\n\n\t// read the file\n\tsrc, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\twriteError(w, fmt.Sprintf(\"Reading file %s failed: %v\", filename, err))\n\t\treturn\n\t}\n\n\tdata, err := handler(src)\n\tif err != nil {\n\t\twriteError(w, fmt.Sprintf(\"Processing file %s failed: %v\", filename, err))\n\t}\n\n\tio.WriteString(w, data)\n\treturn\n}\n\n// pasteUploadHander is the request handler for /paste\n// it creates a uuid for the paste and saves the contents of\n// the paste to that file.\nfunc (cmd *serverCommand) pasteUploadHandler(w http.ResponseWriter, r *http.Request) {\n\t// check basic auth\n\tu, p, ok := r.BasicAuth()\n\tif (u != username || p != password) || !ok {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+baseuri+`\"`)\n\t\tw.WriteHeader(401)\n\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t\treturn\n\t}\n\n\t// set the content type and check to make sure they are POST-ing a paste\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif r.Method != \"POST\" {\n\t\twriteError(w, \"not a valid endpoint\")\n\t\treturn\n\t}\n\n\t// read the body of the paste\n\tcontent, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\twriteError(w, fmt.Sprintf(\"reading from body failed: %v\", err))\n\t\treturn\n\t}\n\n\t// create a unique id for the paste\n\tid, err := uuid()\n\tif err != nil {\n\t\twriteError(w, fmt.Sprintf(\"uuid generation failed: %v\", err))\n\t\treturn\n\t}\n\n\t// write to file\n\tfile := filepath.Join(cmd.storage, id)\n\tif err := ioutil.WriteFile(file, content, 0755); err != nil {\n\t\twriteError(w, fmt.Sprintf(\"writing file to %q failed: %v\", file, err))\n\t\treturn\n\t}\n\n\t// serve the uri for the paste to the requester\n\tfmt.Fprint(w, JSONResponse{\n\t\t\"uri\": baseuri + id,\n\t})\n\tlogrus.Infof(\"paste %q posted successfully\", id)\n\treturn\n}\n\n// uuid generates a uuid for the paste.\n// This really does not need to be perfect.\nfunc uuid() (string, error) {\n\tvar chars = []byte(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")\n\n\tlength := 8\n\tb := make([]byte, length)\n\tr := make([]byte, length+(length/4))\n\tmaxrb := 256 - (256 % len(chars))\n\ti := 0\n\tfor {\n\t\tif _, err := io.ReadFull(rand.Reader, r); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, rb := range r {\n\t\t\tc := int(rb)\n\t\t\tif c > maxrb {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tb[i] = chars[c%len(chars)]\n\t\t\ti++\n\t\t\tif i == length {\n\t\t\t\treturn string(b), nil\n\t\t\t}\n\t\t}\n\t}\n}\n\n// writeError sends an error back to the requester\n// and also logs the error.\nfunc writeError(w http.ResponseWriter, msg string) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tfmt.Fprint(w, JSONResponse{\n\t\t\"error\": msg,\n\t})\n\tlogrus.Printf(\"writing error: %s\", msg)\n\treturn\n}\n"], "filenames": ["server.go"], "buggy_code_start_loc": [12], "buggy_code_end_loc": [217], "fixing_code_start_loc": [13], "fixing_code_end_loc": [218], "type": "CWE-22", "message": "A vulnerability was found in pastebinit up to 0.2.2 and classified as problematic. Affected by this issue is the function pasteHandler of the file server.go. The manipulation of the argument r.URL.Path leads to path traversal. Upgrading to version 0.2.3 is able to address this issue. The name of the patch is 1af2facb6d95976c532b7f8f82747d454a092272. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217040.", "other": {"cve": {"id": "CVE-2018-25059", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-30T11:15:10.130", "lastModified": "2023-01-09T18:16:12.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in pastebinit up to 0.2.2 and classified as problematic. Affected by this issue is the function pasteHandler of the file server.go. The manipulation of the argument r.URL.Path leads to path traversal. Upgrading to version 0.2.3 is able to address this issue. The name of the patch is 1af2facb6d95976c532b7f8f82747d454a092272. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217040."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7}, "baseSeverity": "LOW", "exploitabilityScore": 5.1, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pastebinit_project:pastebinit:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.2.2", "matchCriteriaId": "5B1DC233-5BED-435C-BB97-B43E74170CB8"}]}]}], "references": [{"url": "https://github.com/jessfraz/pastebinit/commit/1af2facb6d95976c532b7f8f82747d454a092272", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jessfraz/pastebinit/pull/3", "source": "cna@vuldb.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/jessfraz/pastebinit/releases/tag/v0.2.3", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217040", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217040", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jessfraz/pastebinit/commit/1af2facb6d95976c532b7f8f82747d454a092272"}}