{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/platform/errors.h\"\n#define EIGEN_USE_THREADS\n\n// See docs in ../ops/fft_ops.cc.\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/env_var.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\n#if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \\\n    (defined(TENSORFLOW_USE_ROCM) && TENSORFLOW_USE_ROCM)\n#include \"tensorflow/core/platform/stream_executor.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\nclass FFTBase : public OpKernel {\n public:\n  explicit FFTBase(OpKernelConstruction* ctx) : OpKernel(ctx) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in = ctx->input(0);\n    const TensorShape& input_shape = in.shape();\n    const int fft_rank = Rank();\n    OP_REQUIRES(\n        ctx, input_shape.dims() >= fft_rank,\n        errors::InvalidArgument(\"Input must have rank of at least \", fft_rank,\n                                \" but got: \", input_shape.DebugString()));\n\n    Tensor* out;\n    TensorShape output_shape = input_shape;\n    uint64 fft_shape[3] = {0, 0, 0};\n\n    // In R2C or C2R mode, we use a second input to specify the FFT length\n    // instead of inferring it from the input shape.\n    if (IsReal()) {\n      const Tensor& fft_length = ctx->input(1);\n      OP_REQUIRES(ctx,\n                  fft_length.shape().dims() == 1 &&\n                      fft_length.shape().dim_size(0) == fft_rank,\n                  errors::InvalidArgument(\"fft_length must have shape [\",\n                                          fft_rank, \"]\"));\n\n      auto fft_length_as_vec = fft_length.vec<int32>();\n      for (int i = 0; i < fft_rank; ++i) {\n        fft_shape[i] = fft_length_as_vec(i);\n        // Each input dimension must have length of at least fft_shape[i]. For\n        // IRFFTs, the inner-most input dimension must have length of at least\n        // fft_shape[i] / 2 + 1.\n        bool inner_most = (i == fft_rank - 1);\n        uint64 min_input_dim_length =\n            !IsForward() && inner_most ? fft_shape[i] / 2 + 1 : fft_shape[i];\n        auto input_index = input_shape.dims() - fft_rank + i;\n        OP_REQUIRES(\n            ctx,\n            // We pass through empty tensors, so special case them here.\n            input_shape.dim_size(input_index) == 0 ||\n                input_shape.dim_size(input_index) >= min_input_dim_length,\n            errors::InvalidArgument(\n                \"Input dimension \", input_index,\n                \" must have length of at least \", min_input_dim_length,\n                \" but got: \", input_shape.dim_size(input_index)));\n        uint64 dim = IsForward() && inner_most && fft_shape[i] != 0\n                         ? fft_shape[i] / 2 + 1\n                         : fft_shape[i];\n        output_shape.set_dim(output_shape.dims() - fft_rank + i, dim);\n      }\n    } else {\n      for (int i = 0; i < fft_rank; ++i) {\n        fft_shape[i] =\n            output_shape.dim_size(output_shape.dims() - fft_rank + i);\n      }\n    }\n\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &out));\n\n    if (IsReal()) {\n      if (IsForward()) {\n        OP_REQUIRES(\n            ctx,\n            (in.dtype() == DT_FLOAT && out->dtype() == DT_COMPLEX64) ||\n                (in.dtype() == DT_DOUBLE && out->dtype() == DT_COMPLEX128),\n            errors::InvalidArgument(\"Wrong types for forward real FFT: in=\",\n                                    in.dtype(), \" out=\", out->dtype()));\n      } else {\n        OP_REQUIRES(\n            ctx,\n            (in.dtype() == DT_COMPLEX64 && out->dtype() == DT_FLOAT) ||\n                (in.dtype() == DT_COMPLEX128 && out->dtype() == DT_DOUBLE),\n            errors::InvalidArgument(\"Wrong types for backward real FFT: in=\",\n                                    in.dtype(), \" out=\", out->dtype()));\n      }\n    } else {\n      OP_REQUIRES(\n          ctx,\n          (in.dtype() == DT_COMPLEX64 && out->dtype() == DT_COMPLEX64) ||\n              (in.dtype() == DT_COMPLEX128 && out->dtype() == DT_COMPLEX128),\n          errors::InvalidArgument(\"Wrong types for FFT: in=\", in.dtype(),\n                                  \" out=\", out->dtype()));\n    }\n\n    if (input_shape.num_elements() == 0) {\n      DCHECK_EQ(0, output_shape.num_elements());\n      return;\n    }\n\n    DoFFT(ctx, in, fft_shape, out);\n  }\n\n protected:\n  virtual int Rank() const = 0;\n  virtual bool IsForward() const = 0;\n  virtual bool IsReal() const = 0;\n\n  // The function that actually computes the FFT.\n  virtual void DoFFT(OpKernelContext* ctx, const Tensor& in, uint64* fft_shape,\n                     Tensor* out) = 0;\n};\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\ntemplate <bool Forward, bool _Real, int FFTRank>\nclass FFTCPU : public FFTBase {\n public:\n  using FFTBase::FFTBase;\n\n protected:\n  int Rank() const override { return FFTRank; }\n  bool IsForward() const override { return Forward; }\n  bool IsReal() const override { return _Real; }\n\n  void DoFFT(OpKernelContext* ctx, const Tensor& in, uint64* fft_shape,\n             Tensor* out) override {\n    // Create the axes (which are always trailing).\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n\n    const bool is_complex128 =\n        in.dtype() == DT_COMPLEX128 || out->dtype() == DT_COMPLEX128;\n\n    if (!IsReal()) {\n      // Compute the FFT using Eigen.\n      constexpr auto direction =\n          Forward ? Eigen::FFT_FORWARD : Eigen::FFT_REVERSE;\n      if (is_complex128) {\n        DCHECK_EQ(in.dtype(), DT_COMPLEX128);\n        DCHECK_EQ(out->dtype(), DT_COMPLEX128);\n        auto input = Tensor(in).flat_inner_dims<complex128, FFTRank + 1>();\n        auto output = out->flat_inner_dims<complex128, FFTRank + 1>();\n        output.device(device) =\n            input.template fft<Eigen::BothParts, direction>(axes);\n      } else {\n        DCHECK_EQ(in.dtype(), DT_COMPLEX64);\n        DCHECK_EQ(out->dtype(), DT_COMPLEX64);\n        auto input = Tensor(in).flat_inner_dims<complex64, FFTRank + 1>();\n        auto output = out->flat_inner_dims<complex64, FFTRank + 1>();\n        output.device(device) =\n            input.template fft<Eigen::BothParts, direction>(axes);\n      }\n    } else {\n      if (IsForward()) {\n        if (is_complex128) {\n          DCHECK_EQ(in.dtype(), DT_DOUBLE);\n          DCHECK_EQ(out->dtype(), DT_COMPLEX128);\n          DoRealForwardFFT<double, complex128>(ctx, fft_shape, in, out);\n        } else {\n          DCHECK_EQ(in.dtype(), DT_FLOAT);\n          DCHECK_EQ(out->dtype(), DT_COMPLEX64);\n          DoRealForwardFFT<float, complex64>(ctx, fft_shape, in, out);\n        }\n      } else {\n        if (is_complex128) {\n          DCHECK_EQ(in.dtype(), DT_COMPLEX128);\n          DCHECK_EQ(out->dtype(), DT_DOUBLE);\n          DoRealBackwardFFT<complex128, double>(ctx, fft_shape, in, out);\n        } else {\n          DCHECK_EQ(in.dtype(), DT_COMPLEX64);\n          DCHECK_EQ(out->dtype(), DT_FLOAT);\n          DoRealBackwardFFT<complex64, float>(ctx, fft_shape, in, out);\n        }\n      }\n    }\n  }\n\n  template <typename RealT, typename ComplexT>\n  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    // Create the axes (which are always trailing).\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n\n    // Slice input to fft_shape on its inner-most dimensions.\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        temp_shape.DebugString()));\n\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n\n    // Compute the full FFT using a temporary tensor.\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n\n    // Slice away the negative frequency components.\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }\n\n  template <typename ComplexT, typename RealT>\n  void DoRealBackwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                         const Tensor& in, Tensor* out) {\n    auto device = ctx->eigen_device<CPUDevice>();\n    // Reconstruct the full FFT and take the inverse.\n    auto input = Tensor(in).flat_inner_dims<ComplexT, FFTRank + 1>();\n    auto output = out->flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n\n    // Calculate the shape of the temporary tensor for the full FFT and the\n    // region we will slice from input given fft_shape. We slice input to\n    // fft_shape on its inner-most dimensions, except the last (which we\n    // slice to fft_shape[-1] / 2 + 1).\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape full_fft_shape;\n    full_fft_shape.AddDim(input_dims[0]);\n    for (auto i = 1; i <= FFTRank; i++) {\n      input_slice_sizes[i] =\n          i == FFTRank ? fft_shape[i - 1] / 2 + 1 : fft_shape[i - 1];\n      full_fft_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, full_fft_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        full_fft_shape.DebugString()));\n\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           full_fft_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n\n    // Calculate the starting point and range of the source of\n    // negative frequency part.\n    auto neg_sizes = input_slice_sizes;\n    neg_sizes[FFTRank] = fft_shape[FFTRank - 1] - input_slice_sizes[FFTRank];\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> neg_target_indices;\n    neg_target_indices[FFTRank] = input_slice_sizes[FFTRank];\n\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> start_indices;\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> neg_start_indices;\n    neg_start_indices[FFTRank] = 1;\n\n    full_fft.slice(start_indices, input_slice_sizes).device(device) =\n        input.slice(start_indices, input_slice_sizes);\n\n    // First, conduct IFFTs on outer dimensions. We save computation (and\n    // avoid touching uninitialized memory) by slicing full_fft to the\n    // subregion we wrote input to.\n    if (FFTRank > 1) {\n      const auto outer_axes =\n          Eigen::ArrayXi::LinSpaced(FFTRank - 1, 1, FFTRank - 1);\n      full_fft.slice(start_indices, input_slice_sizes).device(device) =\n          full_fft.slice(start_indices, input_slice_sizes)\n              .template fft<Eigen::BothParts, Eigen::FFT_REVERSE>(outer_axes);\n    }\n\n    // Reconstruct the full FFT by appending reversed and conjugated\n    // spectrum as the negative frequency part.\n    Eigen::array<bool, FFTRank + 1> reverse_last_axis;\n    for (auto i = 0; i <= FFTRank; i++) {\n      reverse_last_axis[i] = i == FFTRank;\n    }\n\n    if (neg_sizes[FFTRank] != 0) {\n      full_fft.slice(neg_target_indices, neg_sizes).device(device) =\n          full_fft.slice(neg_start_indices, neg_sizes)\n              .reverse(reverse_last_axis)\n              .conjugate();\n    }\n\n    auto inner_axis = Eigen::array<int, 1>{FFTRank};\n    output.device(device) =\n        full_fft.template fft<Eigen::RealPart, Eigen::FFT_REVERSE>(inner_axis);\n  }\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"FFT\").Device(DEVICE_CPU), FFTCPU<true, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT\").Device(DEVICE_CPU),\n                        FFTCPU<false, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"FFT2D\").Device(DEVICE_CPU),\n                        FFTCPU<true, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT2D\").Device(DEVICE_CPU),\n                        FFTCPU<false, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"FFT3D\").Device(DEVICE_CPU),\n                        FFTCPU<true, false, 3>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT3D\").Device(DEVICE_CPU),\n                        FFTCPU<false, false, 3>);\n\nREGISTER_KERNEL_BUILDER(Name(\"RFFT\").Device(DEVICE_CPU), FFTCPU<true, true, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"IRFFT\").Device(DEVICE_CPU),\n                        FFTCPU<false, true, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"RFFT2D\").Device(DEVICE_CPU),\n                        FFTCPU<true, true, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"IRFFT2D\").Device(DEVICE_CPU),\n                        FFTCPU<false, true, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"RFFT3D\").Device(DEVICE_CPU),\n                        FFTCPU<true, true, 3>);\nREGISTER_KERNEL_BUILDER(Name(\"IRFFT3D\").Device(DEVICE_CPU),\n                        FFTCPU<false, true, 3>);\n\n#if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \\\n    (defined(TENSORFLOW_USE_ROCM) && TENSORFLOW_USE_ROCM)\n\nnamespace {\ntemplate <typename T>\nse::DeviceMemory<T> AsDeviceMemory(const T* cuda_memory) {\n  se::DeviceMemoryBase wrapped(const_cast<T*>(cuda_memory));\n  se::DeviceMemory<T> typed(wrapped);\n  return typed;\n}\n\ntemplate <typename T>\nse::DeviceMemory<T> AsDeviceMemory(const T* cuda_memory, uint64 size) {\n  se::DeviceMemoryBase wrapped(const_cast<T*>(cuda_memory), size * sizeof(T));\n  se::DeviceMemory<T> typed(wrapped);\n  return typed;\n}\n\n// A class to provide scratch-space allocator for Stream-Executor Cufft\n// callback. Tensorflow is responsible for releasing the temporary buffers after\n// the kernel finishes.\n// TODO(yangzihao): Refactor redundant code in subclasses of ScratchAllocator\n// into base class.\nclass CufftScratchAllocator : public se::ScratchAllocator {\n public:\n  ~CufftScratchAllocator() override {}\n  CufftScratchAllocator(int64_t memory_limit, OpKernelContext* context)\n      : memory_limit_(memory_limit), total_byte_size_(0), context_(context) {}\n  int64_t GetMemoryLimitInBytes() override { return memory_limit_; }\n  se::port::StatusOr<se::DeviceMemory<uint8>> AllocateBytes(\n      int64_t byte_size) override {\n    Tensor temporary_memory;\n    if (byte_size > memory_limit_) {\n      return se::port::StatusOr<se::DeviceMemory<uint8>>();\n    }\n    AllocationAttributes allocation_attr;\n    allocation_attr.retry_on_failure = false;\n    Status allocation_status(context_->allocate_temp(\n        DT_UINT8, TensorShape({byte_size}), &temporary_memory,\n        AllocatorAttributes(), allocation_attr));\n    if (!allocation_status.ok()) {\n      return se::port::StatusOr<se::DeviceMemory<uint8>>();\n    }\n    // Hold the reference of the allocated tensors until the end of the\n    // allocator.\n    allocated_tensors_.push_back(temporary_memory);\n    total_byte_size_ += byte_size;\n    return se::port::StatusOr<se::DeviceMemory<uint8>>(\n        AsDeviceMemory(temporary_memory.flat<uint8>().data(),\n                       temporary_memory.flat<uint8>().size()));\n  }\n  int64_t TotalByteSize() { return total_byte_size_; }\n\n private:\n  int64_t memory_limit_;\n  int64_t total_byte_size_;\n  OpKernelContext* context_;\n  std::vector<Tensor> allocated_tensors_;\n};\n\n}  // end namespace\n\nint64_t GetCufftWorkspaceLimit(const string& envvar_in_mb,\n                               int64_t default_value_in_bytes) {\n  const char* workspace_limit_in_mb_str = getenv(envvar_in_mb.c_str());\n  if (workspace_limit_in_mb_str != nullptr &&\n      strcmp(workspace_limit_in_mb_str, \"\") != 0) {\n    int64_t scratch_limit_in_mb = -1;\n    Status status = ReadInt64FromEnvVar(envvar_in_mb, default_value_in_bytes,\n                                        &scratch_limit_in_mb);\n    if (!status.ok()) {\n      LOG(WARNING) << \"Invalid value for env-var \" << envvar_in_mb << \": \"\n                   << workspace_limit_in_mb_str;\n    } else {\n      return scratch_limit_in_mb * (1 << 20);\n    }\n  }\n  return default_value_in_bytes;\n}\n\nclass FFTGPUBase : public FFTBase {\n public:\n  using FFTBase::FFTBase;\n\n protected:\n  static int64_t CufftScratchSize;\n  void DoFFT(OpKernelContext* ctx, const Tensor& in, uint64* fft_shape,\n             Tensor* out) override {\n    auto* stream = ctx->op_device_context()->stream();\n    OP_REQUIRES(ctx, stream, errors::Internal(\"No GPU stream available.\"));\n\n    const TensorShape& input_shape = in.shape();\n    const TensorShape& output_shape = out->shape();\n\n    const int fft_rank = Rank();\n    int batch_size = 1;\n    for (int i = 0; i < input_shape.dims() - fft_rank; ++i) {\n      batch_size *= input_shape.dim_size(i);\n    }\n    uint64 input_embed[3];\n    const uint64 input_stride = 1;\n    uint64 input_distance = 1;\n    uint64 output_embed[3];\n    const uint64 output_stride = 1;\n    uint64 output_distance = 1;\n\n    for (int i = 0; i < fft_rank; ++i) {\n      auto dim_offset = input_shape.dims() - fft_rank + i;\n      input_embed[i] = input_shape.dim_size(dim_offset);\n      input_distance *= input_shape.dim_size(dim_offset);\n      output_embed[i] = output_shape.dim_size(dim_offset);\n      output_distance *= output_shape.dim_size(dim_offset);\n    }\n\n    constexpr bool kInPlaceFft = false;\n    const bool is_complex128 =\n        in.dtype() == DT_COMPLEX128 || out->dtype() == DT_COMPLEX128;\n\n    const auto kFftType =\n        IsReal()\n            ? (IsForward()\n                   ? (is_complex128 ? se::fft::Type::kD2Z : se::fft::Type::kR2C)\n                   : (is_complex128 ? se::fft::Type::kZ2D\n                                    : se::fft::Type::kC2R))\n            : (IsForward() ? (is_complex128 ? se::fft::Type::kZ2ZForward\n                                            : se::fft::Type::kC2CForward)\n                           : (is_complex128 ? se::fft::Type::kZ2ZInverse\n                                            : se::fft::Type::kC2CInverse));\n\n    CufftScratchAllocator scratch_allocator(CufftScratchSize, ctx);\n    auto plan =\n        stream->parent()->AsFft()->CreateBatchedPlanWithScratchAllocator(\n            stream, fft_rank, fft_shape, input_embed, input_stride,\n            input_distance, output_embed, output_stride, output_distance,\n            kFftType, kInPlaceFft, batch_size, &scratch_allocator);\n\n    if (IsReal()) {\n      if (IsForward()) {\n        if (is_complex128) {\n          DCHECK_EQ(in.dtype(), DT_DOUBLE);\n          DCHECK_EQ(out->dtype(), DT_COMPLEX128);\n          DoFFTInternal<double, complex128>(ctx, stream, plan.get(), kFftType,\n                                            output_distance, in, out);\n        } else {\n          DCHECK_EQ(in.dtype(), DT_FLOAT);\n          DCHECK_EQ(out->dtype(), DT_COMPLEX64);\n          DoFFTInternal<float, complex64>(ctx, stream, plan.get(), kFftType,\n                                          output_distance, in, out);\n        }\n      } else {\n        if (is_complex128) {\n          DCHECK_EQ(in.dtype(), DT_COMPLEX128);\n          DCHECK_EQ(out->dtype(), DT_DOUBLE);\n          DoFFTInternal<complex128, double>(ctx, stream, plan.get(), kFftType,\n                                            output_distance, in, out);\n        } else {\n          DCHECK_EQ(in.dtype(), DT_COMPLEX64);\n          DCHECK_EQ(out->dtype(), DT_FLOAT);\n          DoFFTInternal<complex64, float>(ctx, stream, plan.get(), kFftType,\n                                          output_distance, in, out);\n        }\n      }\n    } else {\n      if (is_complex128) {\n        DCHECK_EQ(in.dtype(), DT_COMPLEX128);\n        DCHECK_EQ(out->dtype(), DT_COMPLEX128);\n        DoFFTInternal<complex128, complex128>(ctx, stream, plan.get(), kFftType,\n                                              output_distance, in, out);\n      } else {\n        DCHECK_EQ(in.dtype(), DT_COMPLEX64);\n        DCHECK_EQ(out->dtype(), DT_COMPLEX64);\n        DoFFTInternal<complex64, complex64>(ctx, stream, plan.get(), kFftType,\n                                            output_distance, in, out);\n      }\n    }\n  }\n\n private:\n  template <typename T>\n  struct RealTypeFromComplexType {\n    typedef T RealT;\n  };\n\n  template <typename T>\n  struct RealTypeFromComplexType<std::complex<T>> {\n    typedef T RealT;\n  };\n\n  template <typename InT, typename OutT>\n  void DoFFTInternal(OpKernelContext* ctx, se::Stream* stream,\n                     se::fft::Plan* plan, const se::fft::Type fft_type,\n                     const uint64 output_distance, const Tensor& in,\n                     Tensor* out) {\n    const TensorShape& input_shape = in.shape();\n    const TensorShape& output_shape = out->shape();\n    auto src =\n        AsDeviceMemory<InT>(in.flat<InT>().data(), input_shape.num_elements());\n    auto dst = AsDeviceMemory<OutT>(out->flat<OutT>().data(),\n                                    output_shape.num_elements());\n    OP_REQUIRES(\n        ctx, stream->ThenFft(plan, src, &dst).ok(),\n        errors::Internal(\"fft failed : type=\", static_cast<int>(fft_type),\n                         \" in.shape=\", input_shape.DebugString()));\n    if (!IsForward()) {\n      typedef typename RealTypeFromComplexType<OutT>::RealT RealT;\n      RealT alpha = 1.0 / output_distance;\n      OP_REQUIRES(\n          ctx,\n          stream->ThenBlasScal(output_shape.num_elements(), alpha, &dst, 1)\n              .ok(),\n          errors::Internal(\"BlasScal failed : in.shape=\",\n                           input_shape.DebugString()));\n    }\n  }\n};\n\nint64_t FFTGPUBase::CufftScratchSize = GetCufftWorkspaceLimit(\n    // default value is in bytes despite the name of the environment variable\n    \"TF_CUFFT_WORKSPACE_LIMIT_IN_MB\", 1LL << 32  // 4GB\n);\n\ntemplate <bool Forward, bool _Real, int FFTRank>\nclass FFTGPU : public FFTGPUBase {\n public:\n  static_assert(FFTRank >= 1 && FFTRank <= 3,\n                \"Only 1D, 2D and 3D FFTs supported.\");\n  explicit FFTGPU(OpKernelConstruction* ctx) : FFTGPUBase(ctx) {}\n\n protected:\n  int Rank() const override { return FFTRank; }\n  bool IsForward() const override { return Forward; }\n  bool IsReal() const override { return _Real; }\n};\n\n// Register GPU kernels with priority 1 so that if a custom FFT CPU kernel is\n// registered with priority 1 (to override the default Eigen CPU kernel), the\n// CPU kernel does not outrank the GPU kernel.\nREGISTER_KERNEL_BUILDER(Name(\"FFT\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"FFT2D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT2D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"FFT3D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 3>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT3D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 3>);\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"RFFT\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<true, true, 1>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"IRFFT\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<false, true, 1>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"RFFT2D\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<true, true, 2>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"IRFFT2D\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<false, true, 2>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"RFFT3D\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<true, true, 3>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"IRFFT3D\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<false, true, 3>);\n\n// Deprecated kernels.\nREGISTER_KERNEL_BUILDER(Name(\"BatchFFT\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchIFFT\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchFFT2D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchIFFT2D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchFFT3D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 3>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchIFFT3D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 3>);\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // end namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for fft operations.\"\"\"\n\nimport itertools\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.core.protobuf import config_pb2\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_spectral_ops\nfrom tensorflow.python.ops import gradient_checker_v2\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops.signal import fft_ops\nfrom tensorflow.python.platform import test\n\nVALID_FFT_RANKS = (1, 2, 3)\n\n\n# TODO(rjryan): Investigate precision issues. We should be able to achieve\n# better tolerances, at least for the complex128 tests.\nclass BaseFFTOpsTest(test.TestCase):\n\n  def _compare(self, x, rank, fft_length=None, use_placeholder=False,\n               rtol=1e-4, atol=1e-4):\n    self._compare_forward(x, rank, fft_length, use_placeholder, rtol, atol)\n    self._compare_backward(x, rank, fft_length, use_placeholder, rtol, atol)\n\n  def _compare_forward(self, x, rank, fft_length=None, use_placeholder=False,\n                       rtol=1e-4, atol=1e-4):\n    x_np = self._np_fft(x, rank, fft_length)\n    if use_placeholder:\n      x_ph = array_ops.placeholder(dtype=dtypes.as_dtype(x.dtype))\n      x_tf = self._tf_fft(x_ph, rank, fft_length, feed_dict={x_ph: x})\n    else:\n      x_tf = self._tf_fft(x, rank, fft_length)\n\n    self.assertAllClose(x_np, x_tf, rtol=rtol, atol=atol)\n\n  def _compare_backward(self, x, rank, fft_length=None, use_placeholder=False,\n                        rtol=1e-4, atol=1e-4):\n    x_np = self._np_ifft(x, rank, fft_length)\n    if use_placeholder:\n      x_ph = array_ops.placeholder(dtype=dtypes.as_dtype(x.dtype))\n      x_tf = self._tf_ifft(x_ph, rank, fft_length, feed_dict={x_ph: x})\n    else:\n      x_tf = self._tf_ifft(x, rank, fft_length)\n\n    self.assertAllClose(x_np, x_tf, rtol=rtol, atol=atol)\n\n  def _check_memory_fail(self, x, rank):\n    config = config_pb2.ConfigProto()\n    config.gpu_options.per_process_gpu_memory_fraction = 1e-2\n    with self.cached_session(config=config, force_gpu=True):\n      self._tf_fft(x, rank, fft_length=None)\n\n  def _check_grad_complex(self, func, x, y, result_is_complex=True,\n                          rtol=1e-2, atol=1e-2):\n    with self.cached_session():\n\n      def f(inx, iny):\n        inx.set_shape(x.shape)\n        iny.set_shape(y.shape)\n        # func is a forward or inverse, real or complex, batched or unbatched\n        # FFT function with a complex input.\n        z = func(math_ops.complex(inx, iny))\n        # loss = sum(|z|^2)\n        loss = math_ops.reduce_sum(math_ops.real(z * math_ops.conj(z)))\n        return loss\n\n      ((x_jacob_t, y_jacob_t), (x_jacob_n, y_jacob_n)) = (\n          gradient_checker_v2.compute_gradient(f, [x, y], delta=1e-2))\n\n    self.assertAllClose(x_jacob_t, x_jacob_n, rtol=rtol, atol=atol)\n    self.assertAllClose(y_jacob_t, y_jacob_n, rtol=rtol, atol=atol)\n\n  def _check_grad_real(self, func, x, rtol=1e-2, atol=1e-2):\n    def f(inx):\n      inx.set_shape(x.shape)\n      # func is a forward RFFT function (batched or unbatched).\n      z = func(inx)\n      # loss = sum(|z|^2)\n      loss = math_ops.reduce_sum(math_ops.real(z * math_ops.conj(z)))\n      return loss\n\n    (x_jacob_t,), (x_jacob_n,) = gradient_checker_v2.compute_gradient(\n        f, [x], delta=1e-2)\n    self.assertAllClose(x_jacob_t, x_jacob_n, rtol=rtol, atol=atol)\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass FFTOpsTest(BaseFFTOpsTest, parameterized.TestCase):\n\n  def _tf_fft(self, x, rank, fft_length=None, feed_dict=None):\n    # fft_length unused for complex FFTs.\n    with self.cached_session() as sess:\n      return sess.run(self._tf_fft_for_rank(rank)(x), feed_dict=feed_dict)\n\n  def _tf_ifft(self, x, rank, fft_length=None, feed_dict=None):\n    # fft_length unused for complex FFTs.\n    with self.cached_session() as sess:\n      return sess.run(self._tf_ifft_for_rank(rank)(x), feed_dict=feed_dict)\n\n  def _np_fft(self, x, rank, fft_length=None):\n    if rank == 1:\n      return np.fft.fft2(x, s=fft_length, axes=(-1,))\n    elif rank == 2:\n      return np.fft.fft2(x, s=fft_length, axes=(-2, -1))\n    elif rank == 3:\n      return np.fft.fft2(x, s=fft_length, axes=(-3, -2, -1))\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _np_ifft(self, x, rank, fft_length=None):\n    if rank == 1:\n      return np.fft.ifft2(x, s=fft_length, axes=(-1,))\n    elif rank == 2:\n      return np.fft.ifft2(x, s=fft_length, axes=(-2, -1))\n    elif rank == 3:\n      return np.fft.ifft2(x, s=fft_length, axes=(-3, -2, -1))\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _tf_fft_for_rank(self, rank):\n    if rank == 1:\n      return fft_ops.fft\n    elif rank == 2:\n      return fft_ops.fft2d\n    elif rank == 3:\n      return fft_ops.fft3d\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _tf_ifft_for_rank(self, rank):\n    if rank == 1:\n      return fft_ops.ifft\n    elif rank == 2:\n      return fft_ops.ifft2d\n    elif rank == 3:\n      return fft_ops.ifft3d\n    else:\n      raise ValueError(\"invalid rank\")\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (np.complex64, np.complex128)))\n  def test_empty(self, rank, extra_dims, np_type):\n    dims = rank + extra_dims\n    x = np.zeros((0,) * dims).astype(np_type)\n    self.assertEqual(x.shape, self._tf_fft(x, rank).shape)\n    self.assertEqual(x.shape, self._tf_ifft(x, rank).shape)\n\n  @parameterized.parameters(\n      itertools.product(VALID_FFT_RANKS, range(3),\n                        (np.complex64, np.complex128)))\n  def test_basic(self, rank, extra_dims, np_type):\n    dims = rank + extra_dims\n    tol = 1e-4 if np_type == np.complex64 else 1e-8\n    self._compare(\n        np.mod(np.arange(np.power(4, dims)), 10).reshape(\n            (4,) * dims).astype(np_type), rank, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      (1,), range(3), (np.complex64, np.complex128)))\n  def test_large_batch(self, rank, extra_dims, np_type):\n    dims = rank + extra_dims\n    tol = 1e-4 if np_type == np.complex64 else 5e-5\n    self._compare(\n        np.mod(np.arange(np.power(128, dims)), 10).reshape(\n            (128,) * dims).astype(np_type), rank, rtol=tol, atol=tol)\n\n  # TODO(yangzihao): Disable before we can figure out a way to\n  # properly test memory fail for large batch fft.\n  # def test_large_batch_memory_fail(self):\n  #   if test.is_gpu_available(cuda_only=True):\n  #     rank = 1\n  #     for dims in range(rank, rank + 3):\n  #       self._check_memory_fail(\n  #           np.mod(np.arange(np.power(128, dims)), 64).reshape(\n  #               (128,) * dims).astype(np.complex64), rank)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (np.complex64, np.complex128)))\n  def test_placeholder(self, rank, extra_dims, np_type):\n    if context.executing_eagerly():\n      return\n    tol = 1e-4 if np_type == np.complex64 else 1e-8\n    dims = rank + extra_dims\n    self._compare(\n        np.mod(np.arange(np.power(4, dims)), 10).reshape(\n            (4,) * dims).astype(np_type),\n        rank, use_placeholder=True, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (np.complex64, np.complex128)))\n  def test_random(self, rank, extra_dims, np_type):\n    tol = 1e-4 if np_type == np.complex64 else 5e-6\n    dims = rank + extra_dims\n    def gen(shape):\n      n = np.prod(shape)\n      re = np.random.uniform(size=n)\n      im = np.random.uniform(size=n)\n      return (re + im * 1j).reshape(shape)\n\n    self._compare(gen((4,) * dims).astype(np_type), rank,\n                  rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS,\n      # Check a variety of sizes (power-of-2, odd, etc.)\n      [128, 256, 512, 1024, 127, 255, 511, 1023],\n      (np.complex64, np.complex128)))\n  def test_random_1d(self, rank, dim, np_type):\n    has_gpu = test.is_gpu_available(cuda_only=True)\n    tol = {(np.complex64, True): 1e-4,\n           (np.complex64, False): 1e-2,\n           (np.complex128, True): 1e-4,\n           (np.complex128, False): 1e-2}[(np_type, has_gpu)]\n    def gen(shape):\n      n = np.prod(shape)\n      re = np.random.uniform(size=n)\n      im = np.random.uniform(size=n)\n      return (re + im * 1j).reshape(shape)\n\n    self._compare(gen((dim,)).astype(np_type), 1, rtol=tol, atol=tol)\n\n  def test_error(self):\n    # TODO(rjryan): Fix this test under Eager.\n    if context.executing_eagerly():\n      return\n    for rank in VALID_FFT_RANKS:\n      for dims in range(0, rank):\n        x = np.zeros((1,) * dims).astype(np.complex64)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Shape must be .*rank {}.*\".format(rank)):\n          self._tf_fft(x, rank)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Shape must be .*rank {}.*\".format(rank)):\n          self._tf_ifft(x, rank)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(2), (np.float32, np.float64)))\n  def test_grad_simple(self, rank, extra_dims, np_type):\n    tol = 1e-4 if np_type == np.float32 else 1e-10\n    dims = rank + extra_dims\n    re = np.ones(shape=(4,) * dims, dtype=np_type) / 10.0\n    im = np.zeros(shape=(4,) * dims, dtype=np_type)\n    self._check_grad_complex(self._tf_fft_for_rank(rank), re, im,\n                             rtol=tol, atol=tol)\n    self._check_grad_complex(self._tf_ifft_for_rank(rank), re, im,\n                             rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(2), (np.float32, np.float64)))\n  def test_grad_random(self, rank, extra_dims, np_type):\n    dims = rank + extra_dims\n    tol = 1e-2 if np_type == np.float32 else 1e-10\n    re = np.random.rand(*((3,) * dims)).astype(np_type) * 2 - 1\n    im = np.random.rand(*((3,) * dims)).astype(np_type) * 2 - 1\n    self._check_grad_complex(self._tf_fft_for_rank(rank), re, im,\n                             rtol=tol, atol=tol)\n    self._check_grad_complex(self._tf_ifft_for_rank(rank), re, im,\n                             rtol=tol, atol=tol)\n\n\n@test_util.run_all_in_graph_and_eager_modes\n@test_util.disable_xla(\"b/155276727\")\nclass RFFTOpsTest(BaseFFTOpsTest, parameterized.TestCase):\n\n  def _tf_fft(self, x, rank, fft_length=None, feed_dict=None):\n    with self.cached_session() as sess:\n      return sess.run(\n          self._tf_fft_for_rank(rank)(x, fft_length), feed_dict=feed_dict)\n\n  def _tf_ifft(self, x, rank, fft_length=None, feed_dict=None):\n    with self.cached_session() as sess:\n      return sess.run(\n          self._tf_ifft_for_rank(rank)(x, fft_length), feed_dict=feed_dict)\n\n  def _np_fft(self, x, rank, fft_length=None):\n    if rank == 1:\n      return np.fft.rfft2(x, s=fft_length, axes=(-1,))\n    elif rank == 2:\n      return np.fft.rfft2(x, s=fft_length, axes=(-2, -1))\n    elif rank == 3:\n      return np.fft.rfft2(x, s=fft_length, axes=(-3, -2, -1))\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _np_ifft(self, x, rank, fft_length=None):\n    if rank == 1:\n      return np.fft.irfft2(x, s=fft_length, axes=(-1,))\n    elif rank == 2:\n      return np.fft.irfft2(x, s=fft_length, axes=(-2, -1))\n    elif rank == 3:\n      return np.fft.irfft2(x, s=fft_length, axes=(-3, -2, -1))\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _tf_fft_for_rank(self, rank):\n    if rank == 1:\n      return fft_ops.rfft\n    elif rank == 2:\n      return fft_ops.rfft2d\n    elif rank == 3:\n      return fft_ops.rfft3d\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _tf_ifft_for_rank(self, rank):\n    if rank == 1:\n      return fft_ops.irfft\n    elif rank == 2:\n      return fft_ops.irfft2d\n    elif rank == 3:\n      return fft_ops.irfft3d\n    else:\n      raise ValueError(\"invalid rank\")\n\n  # rocFFT requires/assumes that the input to the irfft transform\n  # is of the form that is a valid output from the rfft transform\n  # (i.e. it cannot be a set of random numbers)\n  # So for ROCm, call rfft and use its output as the input for testing irfft\n  def _generate_valid_irfft_input(self, c2r, np_ctype, r2c, np_rtype, rank,\n                                  fft_length):\n    if test.is_built_with_rocm():\n      return self._np_fft(r2c.astype(np_rtype), rank, fft_length)\n    else:\n      return c2r.astype(np_ctype)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (np.float32, np.float64)))\n\n  def test_empty(self, rank, extra_dims, np_rtype):\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    dims = rank + extra_dims\n    x = np.zeros((0,) * dims).astype(np_rtype)\n    self.assertEqual(x.shape, self._tf_fft(x, rank).shape)\n    x = np.zeros((0,) * dims).astype(np_ctype)\n    self.assertEqual(x.shape, self._tf_ifft(x, rank).shape)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_basic(self, rank, extra_dims, size, np_rtype):\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 5e-5\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    fft_length = (size,) * rank\n    self._compare_forward(\n        r2c.astype(np_rtype), rank, fft_length, rtol=tol, atol=tol)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r, rank, fft_length, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      (1,), range(3), (64, 128), (np.float32, np.float64)))\n  def test_large_batch(self, rank, extra_dims, size, np_rtype):\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 1e-5\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    fft_length = (size,) * rank\n    self._compare_forward(\n        r2c.astype(np_rtype), rank, fft_length, rtol=tol, atol=tol)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r, rank, fft_length, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_placeholder(self, rank, extra_dims, size, np_rtype):\n    if context.executing_eagerly():\n      return\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 1e-8\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    fft_length = (size,) * rank\n    self._compare_forward(\n        r2c.astype(np_rtype),\n        rank,\n        fft_length,\n        use_placeholder=True,\n        rtol=tol,\n        atol=tol)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(\n        c2r, rank, fft_length, use_placeholder=True, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_fft_lenth_truncate(self, rank, extra_dims, size, np_rtype):\n    \"\"\"Test truncation (FFT size < dimensions).\"\"\"\n    if test.is_built_with_rocm() and (rank == 3):\n      # TODO(rocm): fix me\n      # rfft fails for rank == 3 on ROCm\n      self.skipTest(\"Test fails on ROCm...fix me\")\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 8e-5\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    fft_length = (size - 2,) * rank\n    self._compare_forward(r2c.astype(np_rtype), rank, fft_length,\n                          rtol=tol, atol=tol)\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r, rank, fft_length, rtol=tol, atol=tol)\n    # Confirm it works with unknown shapes as well.\n    if not context.executing_eagerly():\n      self._compare_forward(\n          r2c.astype(np_rtype),\n          rank,\n          fft_length,\n          use_placeholder=True,\n          rtol=tol, atol=tol)\n      self._compare_backward(\n          c2r, rank, fft_length, use_placeholder=True, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_fft_lenth_pad(self, rank, extra_dims, size, np_rtype):\n    \"\"\"Test padding (FFT size > dimensions).\"\"\"\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 8e-5\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    fft_length = (size + 2,) * rank\n    self._compare_forward(r2c.astype(np_rtype), rank, fft_length,\n                          rtol=tol, atol=tol)\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r.astype(np_ctype), rank, fft_length,\n                           rtol=tol, atol=tol)\n    # Confirm it works with unknown shapes as well.\n    if not context.executing_eagerly():\n      self._compare_forward(\n          r2c.astype(np_rtype),\n          rank,\n          fft_length,\n          use_placeholder=True,\n          rtol=tol, atol=tol)\n      self._compare_backward(\n          c2r.astype(np_ctype),\n          rank,\n          fft_length,\n          use_placeholder=True,\n          rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_random(self, rank, extra_dims, size, np_rtype):\n    def gen_real(shape):\n      n = np.prod(shape)\n      re = np.random.uniform(size=n)\n      ret = re.reshape(shape)\n      return ret\n\n    def gen_complex(shape):\n      n = np.prod(shape)\n      re = np.random.uniform(size=n)\n      im = np.random.uniform(size=n)\n      ret = (re + im * 1j).reshape(shape)\n      return ret\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 1e-5\n    dims = rank + extra_dims\n    r2c = gen_real((size,) * dims)\n    inner_dim = size // 2 + 1\n    fft_length = (size,) * rank\n    self._compare_forward(\n        r2c.astype(np_rtype), rank, fft_length, rtol=tol, atol=tol)\n    complex_dims = (size,) * (dims - 1) + (inner_dim,)\n    c2r = gen_complex(complex_dims)\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r, rank, fft_length, rtol=tol, atol=tol)\n\n  def test_error(self):\n    # TODO(rjryan): Fix this test under Eager.\n    if context.executing_eagerly():\n      return\n    for rank in VALID_FFT_RANKS:\n      for dims in range(0, rank):\n        x = np.zeros((1,) * dims).astype(np.complex64)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Shape .* must have rank at least {}\".format(rank)):\n          self._tf_fft(x, rank)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Shape .* must have rank at least {}\".format(rank)):\n          self._tf_ifft(x, rank)\n      for dims in range(rank, rank + 2):\n        x = np.zeros((1,) * rank)\n\n        # Test non-rank-1 fft_length produces an error.\n        fft_length = np.zeros((1, 1)).astype(np.int32)\n        with self.assertRaisesWithPredicateMatch(ValueError,\n                                                 \"Shape .* must have rank 1\"):\n          self._tf_fft(x, rank, fft_length)\n        with self.assertRaisesWithPredicateMatch(ValueError,\n                                                 \"Shape .* must have rank 1\"):\n          self._tf_ifft(x, rank, fft_length)\n\n        # Test wrong fft_length length.\n        fft_length = np.zeros((rank + 1,)).astype(np.int32)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Dimension must be .*but is {}.*\".format(rank + 1)):\n          self._tf_fft(x, rank, fft_length)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Dimension must be .*but is {}.*\".format(rank + 1)):\n          self._tf_ifft(x, rank, fft_length)\n\n      # Test that calling the kernel directly without padding to fft_length\n      # produces an error.\n      rffts_for_rank = {\n          1: [gen_spectral_ops.rfft, gen_spectral_ops.irfft],\n          2: [gen_spectral_ops.rfft2d, gen_spectral_ops.irfft2d],\n          3: [gen_spectral_ops.rfft3d, gen_spectral_ops.irfft3d]\n      }\n      rfft_fn, irfft_fn = rffts_for_rank[rank]\n      with self.assertRaisesWithPredicateMatch(\n          errors.InvalidArgumentError,\n          \"Input dimension .* must have length of at least 6 but got: 5\"):\n        x = np.zeros((5,) * rank).astype(np.float32)\n        fft_length = [6] * rank\n        with self.cached_session():\n          self.evaluate(rfft_fn(x, fft_length))\n\n      with self.assertRaisesWithPredicateMatch(\n          errors.InvalidArgumentError,\n          \"Input dimension .* must have length of at least .* but got: 3\"):\n        x = np.zeros((3,) * rank).astype(np.complex64)\n        fft_length = [6] * rank\n        with self.cached_session():\n          self.evaluate(irfft_fn(x, fft_length))\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(2), (5, 6), (np.float32, np.float64)))\n  def test_grad_simple(self, rank, extra_dims, size, np_rtype):\n    # rfft3d/irfft3d do not have gradients yet.\n    if rank == 3:\n      return\n    dims = rank + extra_dims\n    tol = 1e-3 if np_rtype == np.float32 else 1e-10\n    re = np.ones(shape=(size,) * dims, dtype=np_rtype)\n    im = -np.ones(shape=(size,) * dims, dtype=np_rtype)\n    self._check_grad_real(self._tf_fft_for_rank(rank), re,\n                          rtol=tol, atol=tol)\n    if test.is_built_with_rocm():\n      # Fails on ROCm because of irfft peculairity\n      return\n    self._check_grad_complex(\n        self._tf_ifft_for_rank(rank), re, im, result_is_complex=False,\n        rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(2), (5, 6), (np.float32, np.float64)))\n  def test_grad_random(self, rank, extra_dims, size, np_rtype):\n    # rfft3d/irfft3d do not have gradients yet.\n    if rank == 3:\n      return\n    dims = rank + extra_dims\n    tol = 1e-2 if np_rtype == np.float32 else 1e-10\n    re = np.random.rand(*((size,) * dims)).astype(np_rtype) * 2 - 1\n    im = np.random.rand(*((size,) * dims)).astype(np_rtype) * 2 - 1\n    self._check_grad_real(self._tf_fft_for_rank(rank), re,\n                          rtol=tol, atol=tol)\n    if test.is_built_with_rocm():\n      # Fails on ROCm because of irfft peculairity\n      return\n    self._check_grad_complex(\n        self._tf_ifft_for_rank(rank), re, im, result_is_complex=False,\n        rtol=tol, atol=tol)\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass FFTShiftTest(test.TestCase, parameterized.TestCase):\n\n  def test_definition(self):\n    with self.session():\n      x = [0, 1, 2, 3, 4, -4, -3, -2, -1]\n      y = [-4, -3, -2, -1, 0, 1, 2, 3, 4]\n      self.assertAllEqual(fft_ops.fftshift(x), y)\n      self.assertAllEqual(fft_ops.ifftshift(y), x)\n      x = [0, 1, 2, 3, 4, -5, -4, -3, -2, -1]\n      y = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n      self.assertAllEqual(fft_ops.fftshift(x), y)\n      self.assertAllEqual(fft_ops.ifftshift(y), x)\n\n  def test_axes_keyword(self):\n    with self.session():\n      freqs = [[0, 1, 2], [3, 4, -4], [-3, -2, -1]]\n      shifted = [[-1, -3, -2], [2, 0, 1], [-4, 3, 4]]\n      self.assertAllEqual(fft_ops.fftshift(freqs, axes=(0, 1)), shifted)\n      self.assertAllEqual(\n          fft_ops.fftshift(freqs, axes=0),\n          fft_ops.fftshift(freqs, axes=(0,)))\n      self.assertAllEqual(fft_ops.ifftshift(shifted, axes=(0, 1)), freqs)\n      self.assertAllEqual(\n          fft_ops.ifftshift(shifted, axes=0),\n          fft_ops.ifftshift(shifted, axes=(0,)))\n      self.assertAllEqual(fft_ops.fftshift(freqs), shifted)\n      self.assertAllEqual(fft_ops.ifftshift(shifted), freqs)\n\n  def test_numpy_compatibility(self):\n    with self.session():\n      x = [0, 1, 2, 3, 4, -4, -3, -2, -1]\n      y = [-4, -3, -2, -1, 0, 1, 2, 3, 4]\n      self.assertAllEqual(fft_ops.fftshift(x), np.fft.fftshift(x))\n      self.assertAllEqual(fft_ops.ifftshift(y), np.fft.ifftshift(y))\n      x = [0, 1, 2, 3, 4, -5, -4, -3, -2, -1]\n      y = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n      self.assertAllEqual(fft_ops.fftshift(x), np.fft.fftshift(x))\n      self.assertAllEqual(fft_ops.ifftshift(y), np.fft.ifftshift(y))\n      freqs = [[0, 1, 2], [3, 4, -4], [-3, -2, -1]]\n      shifted = [[-1, -3, -2], [2, 0, 1], [-4, 3, 4]]\n      self.assertAllEqual(\n          fft_ops.fftshift(freqs, axes=(0, 1)),\n          np.fft.fftshift(freqs, axes=(0, 1)))\n      self.assertAllEqual(\n          fft_ops.ifftshift(shifted, axes=(0, 1)),\n          np.fft.ifftshift(shifted, axes=(0, 1)))\n\n  @parameterized.parameters(None, 1, ([1, 2],))\n  def test_placeholder(self, axes):\n    if context.executing_eagerly():\n      return\n    x = array_ops.placeholder(shape=[None, None, None], dtype=\"float32\")\n    y_fftshift = fft_ops.fftshift(x, axes=axes)\n    y_ifftshift = fft_ops.ifftshift(x, axes=axes)\n    x_np = np.random.rand(16, 256, 256)\n    with self.session() as sess:\n      y_fftshift_res, y_ifftshift_res = sess.run(\n          [y_fftshift, y_ifftshift],\n          feed_dict={x: x_np})\n    self.assertAllClose(y_fftshift_res, np.fft.fftshift(x_np, axes=axes))\n    self.assertAllClose(y_ifftshift_res, np.fft.ifftshift(x_np, axes=axes))\n\n  def test_negative_axes(self):\n    with self.session():\n      freqs = [[0, 1, 2], [3, 4, -4], [-3, -2, -1]]\n      shifted = [[-1, -3, -2], [2, 0, 1], [-4, 3, 4]]\n      self.assertAllEqual(fft_ops.fftshift(freqs, axes=(0, -1)), shifted)\n      self.assertAllEqual(fft_ops.ifftshift(shifted, axes=(0, -1)), freqs)\n      self.assertAllEqual(\n          fft_ops.fftshift(freqs, axes=-1), fft_ops.fftshift(freqs, axes=(1,)))\n      self.assertAllEqual(\n          fft_ops.ifftshift(shifted, axes=-1),\n          fft_ops.ifftshift(shifted, axes=(1,)))\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/platform/errors.h\"\n#define EIGEN_USE_THREADS\n\n// See docs in ../ops/fft_ops.cc.\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/env_var.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\n#if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \\\n    (defined(TENSORFLOW_USE_ROCM) && TENSORFLOW_USE_ROCM)\n#include \"tensorflow/core/platform/stream_executor.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\nclass FFTBase : public OpKernel {\n public:\n  explicit FFTBase(OpKernelConstruction* ctx) : OpKernel(ctx) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in = ctx->input(0);\n    const TensorShape& input_shape = in.shape();\n    const int fft_rank = Rank();\n    OP_REQUIRES(\n        ctx, input_shape.dims() >= fft_rank,\n        errors::InvalidArgument(\"Input must have rank of at least \", fft_rank,\n                                \" but got: \", input_shape.DebugString()));\n\n    Tensor* out;\n    TensorShape output_shape = input_shape;\n    uint64 fft_shape[3] = {0, 0, 0};\n\n    // In R2C or C2R mode, we use a second input to specify the FFT length\n    // instead of inferring it from the input shape.\n    if (IsReal()) {\n      const Tensor& fft_length = ctx->input(1);\n      OP_REQUIRES(ctx,\n                  fft_length.shape().dims() == 1 &&\n                      fft_length.shape().dim_size(0) == fft_rank,\n                  errors::InvalidArgument(\"fft_length must have shape [\",\n                                          fft_rank, \"]\"));\n\n      auto fft_length_as_vec = fft_length.vec<int32>();\n      for (int i = 0; i < fft_rank; ++i) {\n        OP_REQUIRES(ctx, fft_length_as_vec(i) >= 0,\n                    errors::InvalidArgument(\n                        \"fft_length[\", i,\n                        \"] must >= 0, but got: \", fft_length_as_vec(i)));\n        fft_shape[i] = fft_length_as_vec(i);\n        // Each input dimension must have length of at least fft_shape[i]. For\n        // IRFFTs, the inner-most input dimension must have length of at least\n        // fft_shape[i] / 2 + 1.\n        bool inner_most = (i == fft_rank - 1);\n        uint64 min_input_dim_length =\n            !IsForward() && inner_most ? fft_shape[i] / 2 + 1 : fft_shape[i];\n        auto input_index = input_shape.dims() - fft_rank + i;\n        OP_REQUIRES(\n            ctx,\n            // We pass through empty tensors, so special case them here.\n            input_shape.dim_size(input_index) == 0 ||\n                input_shape.dim_size(input_index) >= min_input_dim_length,\n            errors::InvalidArgument(\n                \"Input dimension \", input_index,\n                \" must have length of at least \", min_input_dim_length,\n                \" but got: \", input_shape.dim_size(input_index)));\n        uint64 dim = IsForward() && inner_most && fft_shape[i] != 0\n                         ? fft_shape[i] / 2 + 1\n                         : fft_shape[i];\n        output_shape.set_dim(output_shape.dims() - fft_rank + i, dim);\n      }\n    } else {\n      for (int i = 0; i < fft_rank; ++i) {\n        fft_shape[i] =\n            output_shape.dim_size(output_shape.dims() - fft_rank + i);\n      }\n    }\n\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &out));\n\n    if (IsReal()) {\n      if (IsForward()) {\n        OP_REQUIRES(\n            ctx,\n            (in.dtype() == DT_FLOAT && out->dtype() == DT_COMPLEX64) ||\n                (in.dtype() == DT_DOUBLE && out->dtype() == DT_COMPLEX128),\n            errors::InvalidArgument(\"Wrong types for forward real FFT: in=\",\n                                    in.dtype(), \" out=\", out->dtype()));\n      } else {\n        OP_REQUIRES(\n            ctx,\n            (in.dtype() == DT_COMPLEX64 && out->dtype() == DT_FLOAT) ||\n                (in.dtype() == DT_COMPLEX128 && out->dtype() == DT_DOUBLE),\n            errors::InvalidArgument(\"Wrong types for backward real FFT: in=\",\n                                    in.dtype(), \" out=\", out->dtype()));\n      }\n    } else {\n      OP_REQUIRES(\n          ctx,\n          (in.dtype() == DT_COMPLEX64 && out->dtype() == DT_COMPLEX64) ||\n              (in.dtype() == DT_COMPLEX128 && out->dtype() == DT_COMPLEX128),\n          errors::InvalidArgument(\"Wrong types for FFT: in=\", in.dtype(),\n                                  \" out=\", out->dtype()));\n    }\n\n    if (input_shape.num_elements() == 0) {\n      DCHECK_EQ(0, output_shape.num_elements());\n      return;\n    }\n\n    DoFFT(ctx, in, fft_shape, out);\n  }\n\n protected:\n  virtual int Rank() const = 0;\n  virtual bool IsForward() const = 0;\n  virtual bool IsReal() const = 0;\n\n  // The function that actually computes the FFT.\n  virtual void DoFFT(OpKernelContext* ctx, const Tensor& in, uint64* fft_shape,\n                     Tensor* out) = 0;\n};\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\ntemplate <bool Forward, bool _Real, int FFTRank>\nclass FFTCPU : public FFTBase {\n public:\n  using FFTBase::FFTBase;\n\n protected:\n  int Rank() const override { return FFTRank; }\n  bool IsForward() const override { return Forward; }\n  bool IsReal() const override { return _Real; }\n\n  void DoFFT(OpKernelContext* ctx, const Tensor& in, uint64* fft_shape,\n             Tensor* out) override {\n    // Create the axes (which are always trailing).\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n\n    const bool is_complex128 =\n        in.dtype() == DT_COMPLEX128 || out->dtype() == DT_COMPLEX128;\n\n    if (!IsReal()) {\n      // Compute the FFT using Eigen.\n      constexpr auto direction =\n          Forward ? Eigen::FFT_FORWARD : Eigen::FFT_REVERSE;\n      if (is_complex128) {\n        DCHECK_EQ(in.dtype(), DT_COMPLEX128);\n        DCHECK_EQ(out->dtype(), DT_COMPLEX128);\n        auto input = Tensor(in).flat_inner_dims<complex128, FFTRank + 1>();\n        auto output = out->flat_inner_dims<complex128, FFTRank + 1>();\n        output.device(device) =\n            input.template fft<Eigen::BothParts, direction>(axes);\n      } else {\n        DCHECK_EQ(in.dtype(), DT_COMPLEX64);\n        DCHECK_EQ(out->dtype(), DT_COMPLEX64);\n        auto input = Tensor(in).flat_inner_dims<complex64, FFTRank + 1>();\n        auto output = out->flat_inner_dims<complex64, FFTRank + 1>();\n        output.device(device) =\n            input.template fft<Eigen::BothParts, direction>(axes);\n      }\n    } else {\n      if (IsForward()) {\n        if (is_complex128) {\n          DCHECK_EQ(in.dtype(), DT_DOUBLE);\n          DCHECK_EQ(out->dtype(), DT_COMPLEX128);\n          DoRealForwardFFT<double, complex128>(ctx, fft_shape, in, out);\n        } else {\n          DCHECK_EQ(in.dtype(), DT_FLOAT);\n          DCHECK_EQ(out->dtype(), DT_COMPLEX64);\n          DoRealForwardFFT<float, complex64>(ctx, fft_shape, in, out);\n        }\n      } else {\n        if (is_complex128) {\n          DCHECK_EQ(in.dtype(), DT_COMPLEX128);\n          DCHECK_EQ(out->dtype(), DT_DOUBLE);\n          DoRealBackwardFFT<complex128, double>(ctx, fft_shape, in, out);\n        } else {\n          DCHECK_EQ(in.dtype(), DT_COMPLEX64);\n          DCHECK_EQ(out->dtype(), DT_FLOAT);\n          DoRealBackwardFFT<complex64, float>(ctx, fft_shape, in, out);\n        }\n      }\n    }\n  }\n\n  template <typename RealT, typename ComplexT>\n  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    // Create the axes (which are always trailing).\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n\n    // Slice input to fft_shape on its inner-most dimensions.\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        temp_shape.DebugString()));\n\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n\n    // Compute the full FFT using a temporary tensor.\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n\n    // Slice away the negative frequency components.\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }\n\n  template <typename ComplexT, typename RealT>\n  void DoRealBackwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                         const Tensor& in, Tensor* out) {\n    auto device = ctx->eigen_device<CPUDevice>();\n    // Reconstruct the full FFT and take the inverse.\n    auto input = Tensor(in).flat_inner_dims<ComplexT, FFTRank + 1>();\n    auto output = out->flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n\n    // Calculate the shape of the temporary tensor for the full FFT and the\n    // region we will slice from input given fft_shape. We slice input to\n    // fft_shape on its inner-most dimensions, except the last (which we\n    // slice to fft_shape[-1] / 2 + 1).\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape full_fft_shape;\n    full_fft_shape.AddDim(input_dims[0]);\n    for (auto i = 1; i <= FFTRank; i++) {\n      input_slice_sizes[i] =\n          i == FFTRank ? fft_shape[i - 1] / 2 + 1 : fft_shape[i - 1];\n      full_fft_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, full_fft_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        full_fft_shape.DebugString()));\n\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           full_fft_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n\n    // Calculate the starting point and range of the source of\n    // negative frequency part.\n    auto neg_sizes = input_slice_sizes;\n    neg_sizes[FFTRank] = fft_shape[FFTRank - 1] - input_slice_sizes[FFTRank];\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> neg_target_indices;\n    neg_target_indices[FFTRank] = input_slice_sizes[FFTRank];\n\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> start_indices;\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> neg_start_indices;\n    neg_start_indices[FFTRank] = 1;\n\n    full_fft.slice(start_indices, input_slice_sizes).device(device) =\n        input.slice(start_indices, input_slice_sizes);\n\n    // First, conduct IFFTs on outer dimensions. We save computation (and\n    // avoid touching uninitialized memory) by slicing full_fft to the\n    // subregion we wrote input to.\n    if (FFTRank > 1) {\n      const auto outer_axes =\n          Eigen::ArrayXi::LinSpaced(FFTRank - 1, 1, FFTRank - 1);\n      full_fft.slice(start_indices, input_slice_sizes).device(device) =\n          full_fft.slice(start_indices, input_slice_sizes)\n              .template fft<Eigen::BothParts, Eigen::FFT_REVERSE>(outer_axes);\n    }\n\n    // Reconstruct the full FFT by appending reversed and conjugated\n    // spectrum as the negative frequency part.\n    Eigen::array<bool, FFTRank + 1> reverse_last_axis;\n    for (auto i = 0; i <= FFTRank; i++) {\n      reverse_last_axis[i] = i == FFTRank;\n    }\n\n    if (neg_sizes[FFTRank] != 0) {\n      full_fft.slice(neg_target_indices, neg_sizes).device(device) =\n          full_fft.slice(neg_start_indices, neg_sizes)\n              .reverse(reverse_last_axis)\n              .conjugate();\n    }\n\n    auto inner_axis = Eigen::array<int, 1>{FFTRank};\n    output.device(device) =\n        full_fft.template fft<Eigen::RealPart, Eigen::FFT_REVERSE>(inner_axis);\n  }\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"FFT\").Device(DEVICE_CPU), FFTCPU<true, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT\").Device(DEVICE_CPU),\n                        FFTCPU<false, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"FFT2D\").Device(DEVICE_CPU),\n                        FFTCPU<true, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT2D\").Device(DEVICE_CPU),\n                        FFTCPU<false, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"FFT3D\").Device(DEVICE_CPU),\n                        FFTCPU<true, false, 3>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT3D\").Device(DEVICE_CPU),\n                        FFTCPU<false, false, 3>);\n\nREGISTER_KERNEL_BUILDER(Name(\"RFFT\").Device(DEVICE_CPU), FFTCPU<true, true, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"IRFFT\").Device(DEVICE_CPU),\n                        FFTCPU<false, true, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"RFFT2D\").Device(DEVICE_CPU),\n                        FFTCPU<true, true, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"IRFFT2D\").Device(DEVICE_CPU),\n                        FFTCPU<false, true, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"RFFT3D\").Device(DEVICE_CPU),\n                        FFTCPU<true, true, 3>);\nREGISTER_KERNEL_BUILDER(Name(\"IRFFT3D\").Device(DEVICE_CPU),\n                        FFTCPU<false, true, 3>);\n\n#if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \\\n    (defined(TENSORFLOW_USE_ROCM) && TENSORFLOW_USE_ROCM)\n\nnamespace {\ntemplate <typename T>\nse::DeviceMemory<T> AsDeviceMemory(const T* cuda_memory) {\n  se::DeviceMemoryBase wrapped(const_cast<T*>(cuda_memory));\n  se::DeviceMemory<T> typed(wrapped);\n  return typed;\n}\n\ntemplate <typename T>\nse::DeviceMemory<T> AsDeviceMemory(const T* cuda_memory, uint64 size) {\n  se::DeviceMemoryBase wrapped(const_cast<T*>(cuda_memory), size * sizeof(T));\n  se::DeviceMemory<T> typed(wrapped);\n  return typed;\n}\n\n// A class to provide scratch-space allocator for Stream-Executor Cufft\n// callback. Tensorflow is responsible for releasing the temporary buffers after\n// the kernel finishes.\n// TODO(yangzihao): Refactor redundant code in subclasses of ScratchAllocator\n// into base class.\nclass CufftScratchAllocator : public se::ScratchAllocator {\n public:\n  ~CufftScratchAllocator() override {}\n  CufftScratchAllocator(int64_t memory_limit, OpKernelContext* context)\n      : memory_limit_(memory_limit), total_byte_size_(0), context_(context) {}\n  int64_t GetMemoryLimitInBytes() override { return memory_limit_; }\n  se::port::StatusOr<se::DeviceMemory<uint8>> AllocateBytes(\n      int64_t byte_size) override {\n    Tensor temporary_memory;\n    if (byte_size > memory_limit_) {\n      return se::port::StatusOr<se::DeviceMemory<uint8>>();\n    }\n    AllocationAttributes allocation_attr;\n    allocation_attr.retry_on_failure = false;\n    Status allocation_status(context_->allocate_temp(\n        DT_UINT8, TensorShape({byte_size}), &temporary_memory,\n        AllocatorAttributes(), allocation_attr));\n    if (!allocation_status.ok()) {\n      return se::port::StatusOr<se::DeviceMemory<uint8>>();\n    }\n    // Hold the reference of the allocated tensors until the end of the\n    // allocator.\n    allocated_tensors_.push_back(temporary_memory);\n    total_byte_size_ += byte_size;\n    return se::port::StatusOr<se::DeviceMemory<uint8>>(\n        AsDeviceMemory(temporary_memory.flat<uint8>().data(),\n                       temporary_memory.flat<uint8>().size()));\n  }\n  int64_t TotalByteSize() { return total_byte_size_; }\n\n private:\n  int64_t memory_limit_;\n  int64_t total_byte_size_;\n  OpKernelContext* context_;\n  std::vector<Tensor> allocated_tensors_;\n};\n\n}  // end namespace\n\nint64_t GetCufftWorkspaceLimit(const string& envvar_in_mb,\n                               int64_t default_value_in_bytes) {\n  const char* workspace_limit_in_mb_str = getenv(envvar_in_mb.c_str());\n  if (workspace_limit_in_mb_str != nullptr &&\n      strcmp(workspace_limit_in_mb_str, \"\") != 0) {\n    int64_t scratch_limit_in_mb = -1;\n    Status status = ReadInt64FromEnvVar(envvar_in_mb, default_value_in_bytes,\n                                        &scratch_limit_in_mb);\n    if (!status.ok()) {\n      LOG(WARNING) << \"Invalid value for env-var \" << envvar_in_mb << \": \"\n                   << workspace_limit_in_mb_str;\n    } else {\n      return scratch_limit_in_mb * (1 << 20);\n    }\n  }\n  return default_value_in_bytes;\n}\n\nclass FFTGPUBase : public FFTBase {\n public:\n  using FFTBase::FFTBase;\n\n protected:\n  static int64_t CufftScratchSize;\n  void DoFFT(OpKernelContext* ctx, const Tensor& in, uint64* fft_shape,\n             Tensor* out) override {\n    auto* stream = ctx->op_device_context()->stream();\n    OP_REQUIRES(ctx, stream, errors::Internal(\"No GPU stream available.\"));\n\n    const TensorShape& input_shape = in.shape();\n    const TensorShape& output_shape = out->shape();\n\n    const int fft_rank = Rank();\n    int batch_size = 1;\n    for (int i = 0; i < input_shape.dims() - fft_rank; ++i) {\n      batch_size *= input_shape.dim_size(i);\n    }\n    uint64 input_embed[3];\n    const uint64 input_stride = 1;\n    uint64 input_distance = 1;\n    uint64 output_embed[3];\n    const uint64 output_stride = 1;\n    uint64 output_distance = 1;\n\n    for (int i = 0; i < fft_rank; ++i) {\n      auto dim_offset = input_shape.dims() - fft_rank + i;\n      input_embed[i] = input_shape.dim_size(dim_offset);\n      input_distance *= input_shape.dim_size(dim_offset);\n      output_embed[i] = output_shape.dim_size(dim_offset);\n      output_distance *= output_shape.dim_size(dim_offset);\n    }\n\n    constexpr bool kInPlaceFft = false;\n    const bool is_complex128 =\n        in.dtype() == DT_COMPLEX128 || out->dtype() == DT_COMPLEX128;\n\n    const auto kFftType =\n        IsReal()\n            ? (IsForward()\n                   ? (is_complex128 ? se::fft::Type::kD2Z : se::fft::Type::kR2C)\n                   : (is_complex128 ? se::fft::Type::kZ2D\n                                    : se::fft::Type::kC2R))\n            : (IsForward() ? (is_complex128 ? se::fft::Type::kZ2ZForward\n                                            : se::fft::Type::kC2CForward)\n                           : (is_complex128 ? se::fft::Type::kZ2ZInverse\n                                            : se::fft::Type::kC2CInverse));\n\n    CufftScratchAllocator scratch_allocator(CufftScratchSize, ctx);\n    auto plan =\n        stream->parent()->AsFft()->CreateBatchedPlanWithScratchAllocator(\n            stream, fft_rank, fft_shape, input_embed, input_stride,\n            input_distance, output_embed, output_stride, output_distance,\n            kFftType, kInPlaceFft, batch_size, &scratch_allocator);\n\n    if (IsReal()) {\n      if (IsForward()) {\n        if (is_complex128) {\n          DCHECK_EQ(in.dtype(), DT_DOUBLE);\n          DCHECK_EQ(out->dtype(), DT_COMPLEX128);\n          DoFFTInternal<double, complex128>(ctx, stream, plan.get(), kFftType,\n                                            output_distance, in, out);\n        } else {\n          DCHECK_EQ(in.dtype(), DT_FLOAT);\n          DCHECK_EQ(out->dtype(), DT_COMPLEX64);\n          DoFFTInternal<float, complex64>(ctx, stream, plan.get(), kFftType,\n                                          output_distance, in, out);\n        }\n      } else {\n        if (is_complex128) {\n          DCHECK_EQ(in.dtype(), DT_COMPLEX128);\n          DCHECK_EQ(out->dtype(), DT_DOUBLE);\n          DoFFTInternal<complex128, double>(ctx, stream, plan.get(), kFftType,\n                                            output_distance, in, out);\n        } else {\n          DCHECK_EQ(in.dtype(), DT_COMPLEX64);\n          DCHECK_EQ(out->dtype(), DT_FLOAT);\n          DoFFTInternal<complex64, float>(ctx, stream, plan.get(), kFftType,\n                                          output_distance, in, out);\n        }\n      }\n    } else {\n      if (is_complex128) {\n        DCHECK_EQ(in.dtype(), DT_COMPLEX128);\n        DCHECK_EQ(out->dtype(), DT_COMPLEX128);\n        DoFFTInternal<complex128, complex128>(ctx, stream, plan.get(), kFftType,\n                                              output_distance, in, out);\n      } else {\n        DCHECK_EQ(in.dtype(), DT_COMPLEX64);\n        DCHECK_EQ(out->dtype(), DT_COMPLEX64);\n        DoFFTInternal<complex64, complex64>(ctx, stream, plan.get(), kFftType,\n                                            output_distance, in, out);\n      }\n    }\n  }\n\n private:\n  template <typename T>\n  struct RealTypeFromComplexType {\n    typedef T RealT;\n  };\n\n  template <typename T>\n  struct RealTypeFromComplexType<std::complex<T>> {\n    typedef T RealT;\n  };\n\n  template <typename InT, typename OutT>\n  void DoFFTInternal(OpKernelContext* ctx, se::Stream* stream,\n                     se::fft::Plan* plan, const se::fft::Type fft_type,\n                     const uint64 output_distance, const Tensor& in,\n                     Tensor* out) {\n    const TensorShape& input_shape = in.shape();\n    const TensorShape& output_shape = out->shape();\n    auto src =\n        AsDeviceMemory<InT>(in.flat<InT>().data(), input_shape.num_elements());\n    auto dst = AsDeviceMemory<OutT>(out->flat<OutT>().data(),\n                                    output_shape.num_elements());\n    OP_REQUIRES(\n        ctx, stream->ThenFft(plan, src, &dst).ok(),\n        errors::Internal(\"fft failed : type=\", static_cast<int>(fft_type),\n                         \" in.shape=\", input_shape.DebugString()));\n    if (!IsForward()) {\n      typedef typename RealTypeFromComplexType<OutT>::RealT RealT;\n      RealT alpha = 1.0 / output_distance;\n      OP_REQUIRES(\n          ctx,\n          stream->ThenBlasScal(output_shape.num_elements(), alpha, &dst, 1)\n              .ok(),\n          errors::Internal(\"BlasScal failed : in.shape=\",\n                           input_shape.DebugString()));\n    }\n  }\n};\n\nint64_t FFTGPUBase::CufftScratchSize = GetCufftWorkspaceLimit(\n    // default value is in bytes despite the name of the environment variable\n    \"TF_CUFFT_WORKSPACE_LIMIT_IN_MB\", 1LL << 32  // 4GB\n);\n\ntemplate <bool Forward, bool _Real, int FFTRank>\nclass FFTGPU : public FFTGPUBase {\n public:\n  static_assert(FFTRank >= 1 && FFTRank <= 3,\n                \"Only 1D, 2D and 3D FFTs supported.\");\n  explicit FFTGPU(OpKernelConstruction* ctx) : FFTGPUBase(ctx) {}\n\n protected:\n  int Rank() const override { return FFTRank; }\n  bool IsForward() const override { return Forward; }\n  bool IsReal() const override { return _Real; }\n};\n\n// Register GPU kernels with priority 1 so that if a custom FFT CPU kernel is\n// registered with priority 1 (to override the default Eigen CPU kernel), the\n// CPU kernel does not outrank the GPU kernel.\nREGISTER_KERNEL_BUILDER(Name(\"FFT\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"FFT2D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT2D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"FFT3D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 3>);\nREGISTER_KERNEL_BUILDER(Name(\"IFFT3D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 3>);\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"RFFT\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<true, true, 1>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"IRFFT\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<false, true, 1>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"RFFT2D\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<true, true, 2>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"IRFFT2D\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<false, true, 2>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"RFFT3D\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<true, true, 3>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"IRFFT3D\").Device(DEVICE_GPU).HostMemory(\"fft_length\").Priority(1),\n    FFTGPU<false, true, 3>);\n\n// Deprecated kernels.\nREGISTER_KERNEL_BUILDER(Name(\"BatchFFT\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchIFFT\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 1>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchFFT2D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchIFFT2D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 2>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchFFT3D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<true, false, 3>);\nREGISTER_KERNEL_BUILDER(Name(\"BatchIFFT3D\").Device(DEVICE_GPU).Priority(1),\n                        FFTGPU<false, false, 3>);\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // end namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for fft operations.\"\"\"\n\nimport itertools\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.core.protobuf import config_pb2\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_spectral_ops\nfrom tensorflow.python.ops import gradient_checker_v2\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops.signal import fft_ops\nfrom tensorflow.python.platform import test\n\nVALID_FFT_RANKS = (1, 2, 3)\n\n\n# TODO(rjryan): Investigate precision issues. We should be able to achieve\n# better tolerances, at least for the complex128 tests.\nclass BaseFFTOpsTest(test.TestCase):\n\n  def _compare(self, x, rank, fft_length=None, use_placeholder=False,\n               rtol=1e-4, atol=1e-4):\n    self._compare_forward(x, rank, fft_length, use_placeholder, rtol, atol)\n    self._compare_backward(x, rank, fft_length, use_placeholder, rtol, atol)\n\n  def _compare_forward(self, x, rank, fft_length=None, use_placeholder=False,\n                       rtol=1e-4, atol=1e-4):\n    x_np = self._np_fft(x, rank, fft_length)\n    if use_placeholder:\n      x_ph = array_ops.placeholder(dtype=dtypes.as_dtype(x.dtype))\n      x_tf = self._tf_fft(x_ph, rank, fft_length, feed_dict={x_ph: x})\n    else:\n      x_tf = self._tf_fft(x, rank, fft_length)\n\n    self.assertAllClose(x_np, x_tf, rtol=rtol, atol=atol)\n\n  def _compare_backward(self, x, rank, fft_length=None, use_placeholder=False,\n                        rtol=1e-4, atol=1e-4):\n    x_np = self._np_ifft(x, rank, fft_length)\n    if use_placeholder:\n      x_ph = array_ops.placeholder(dtype=dtypes.as_dtype(x.dtype))\n      x_tf = self._tf_ifft(x_ph, rank, fft_length, feed_dict={x_ph: x})\n    else:\n      x_tf = self._tf_ifft(x, rank, fft_length)\n\n    self.assertAllClose(x_np, x_tf, rtol=rtol, atol=atol)\n\n  def _check_memory_fail(self, x, rank):\n    config = config_pb2.ConfigProto()\n    config.gpu_options.per_process_gpu_memory_fraction = 1e-2\n    with self.cached_session(config=config, force_gpu=True):\n      self._tf_fft(x, rank, fft_length=None)\n\n  def _check_grad_complex(self, func, x, y, result_is_complex=True,\n                          rtol=1e-2, atol=1e-2):\n    with self.cached_session():\n\n      def f(inx, iny):\n        inx.set_shape(x.shape)\n        iny.set_shape(y.shape)\n        # func is a forward or inverse, real or complex, batched or unbatched\n        # FFT function with a complex input.\n        z = func(math_ops.complex(inx, iny))\n        # loss = sum(|z|^2)\n        loss = math_ops.reduce_sum(math_ops.real(z * math_ops.conj(z)))\n        return loss\n\n      ((x_jacob_t, y_jacob_t), (x_jacob_n, y_jacob_n)) = (\n          gradient_checker_v2.compute_gradient(f, [x, y], delta=1e-2))\n\n    self.assertAllClose(x_jacob_t, x_jacob_n, rtol=rtol, atol=atol)\n    self.assertAllClose(y_jacob_t, y_jacob_n, rtol=rtol, atol=atol)\n\n  def _check_grad_real(self, func, x, rtol=1e-2, atol=1e-2):\n    def f(inx):\n      inx.set_shape(x.shape)\n      # func is a forward RFFT function (batched or unbatched).\n      z = func(inx)\n      # loss = sum(|z|^2)\n      loss = math_ops.reduce_sum(math_ops.real(z * math_ops.conj(z)))\n      return loss\n\n    (x_jacob_t,), (x_jacob_n,) = gradient_checker_v2.compute_gradient(\n        f, [x], delta=1e-2)\n    self.assertAllClose(x_jacob_t, x_jacob_n, rtol=rtol, atol=atol)\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass FFTOpsTest(BaseFFTOpsTest, parameterized.TestCase):\n\n  def _tf_fft(self, x, rank, fft_length=None, feed_dict=None):\n    # fft_length unused for complex FFTs.\n    with self.cached_session() as sess:\n      return sess.run(self._tf_fft_for_rank(rank)(x), feed_dict=feed_dict)\n\n  def _tf_ifft(self, x, rank, fft_length=None, feed_dict=None):\n    # fft_length unused for complex FFTs.\n    with self.cached_session() as sess:\n      return sess.run(self._tf_ifft_for_rank(rank)(x), feed_dict=feed_dict)\n\n  def _np_fft(self, x, rank, fft_length=None):\n    if rank == 1:\n      return np.fft.fft2(x, s=fft_length, axes=(-1,))\n    elif rank == 2:\n      return np.fft.fft2(x, s=fft_length, axes=(-2, -1))\n    elif rank == 3:\n      return np.fft.fft2(x, s=fft_length, axes=(-3, -2, -1))\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _np_ifft(self, x, rank, fft_length=None):\n    if rank == 1:\n      return np.fft.ifft2(x, s=fft_length, axes=(-1,))\n    elif rank == 2:\n      return np.fft.ifft2(x, s=fft_length, axes=(-2, -1))\n    elif rank == 3:\n      return np.fft.ifft2(x, s=fft_length, axes=(-3, -2, -1))\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _tf_fft_for_rank(self, rank):\n    if rank == 1:\n      return fft_ops.fft\n    elif rank == 2:\n      return fft_ops.fft2d\n    elif rank == 3:\n      return fft_ops.fft3d\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _tf_ifft_for_rank(self, rank):\n    if rank == 1:\n      return fft_ops.ifft\n    elif rank == 2:\n      return fft_ops.ifft2d\n    elif rank == 3:\n      return fft_ops.ifft3d\n    else:\n      raise ValueError(\"invalid rank\")\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (np.complex64, np.complex128)))\n  def test_empty(self, rank, extra_dims, np_type):\n    dims = rank + extra_dims\n    x = np.zeros((0,) * dims).astype(np_type)\n    self.assertEqual(x.shape, self._tf_fft(x, rank).shape)\n    self.assertEqual(x.shape, self._tf_ifft(x, rank).shape)\n\n  @parameterized.parameters(\n      itertools.product(VALID_FFT_RANKS, range(3),\n                        (np.complex64, np.complex128)))\n  def test_basic(self, rank, extra_dims, np_type):\n    dims = rank + extra_dims\n    tol = 1e-4 if np_type == np.complex64 else 1e-8\n    self._compare(\n        np.mod(np.arange(np.power(4, dims)), 10).reshape(\n            (4,) * dims).astype(np_type), rank, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      (1,), range(3), (np.complex64, np.complex128)))\n  def test_large_batch(self, rank, extra_dims, np_type):\n    dims = rank + extra_dims\n    tol = 1e-4 if np_type == np.complex64 else 5e-5\n    self._compare(\n        np.mod(np.arange(np.power(128, dims)), 10).reshape(\n            (128,) * dims).astype(np_type), rank, rtol=tol, atol=tol)\n\n  # TODO(yangzihao): Disable before we can figure out a way to\n  # properly test memory fail for large batch fft.\n  # def test_large_batch_memory_fail(self):\n  #   if test.is_gpu_available(cuda_only=True):\n  #     rank = 1\n  #     for dims in range(rank, rank + 3):\n  #       self._check_memory_fail(\n  #           np.mod(np.arange(np.power(128, dims)), 64).reshape(\n  #               (128,) * dims).astype(np.complex64), rank)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (np.complex64, np.complex128)))\n  def test_placeholder(self, rank, extra_dims, np_type):\n    if context.executing_eagerly():\n      return\n    tol = 1e-4 if np_type == np.complex64 else 1e-8\n    dims = rank + extra_dims\n    self._compare(\n        np.mod(np.arange(np.power(4, dims)), 10).reshape(\n            (4,) * dims).astype(np_type),\n        rank, use_placeholder=True, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (np.complex64, np.complex128)))\n  def test_random(self, rank, extra_dims, np_type):\n    tol = 1e-4 if np_type == np.complex64 else 5e-6\n    dims = rank + extra_dims\n    def gen(shape):\n      n = np.prod(shape)\n      re = np.random.uniform(size=n)\n      im = np.random.uniform(size=n)\n      return (re + im * 1j).reshape(shape)\n\n    self._compare(gen((4,) * dims).astype(np_type), rank,\n                  rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS,\n      # Check a variety of sizes (power-of-2, odd, etc.)\n      [128, 256, 512, 1024, 127, 255, 511, 1023],\n      (np.complex64, np.complex128)))\n  def test_random_1d(self, rank, dim, np_type):\n    has_gpu = test.is_gpu_available(cuda_only=True)\n    tol = {(np.complex64, True): 1e-4,\n           (np.complex64, False): 1e-2,\n           (np.complex128, True): 1e-4,\n           (np.complex128, False): 1e-2}[(np_type, has_gpu)]\n    def gen(shape):\n      n = np.prod(shape)\n      re = np.random.uniform(size=n)\n      im = np.random.uniform(size=n)\n      return (re + im * 1j).reshape(shape)\n\n    self._compare(gen((dim,)).astype(np_type), 1, rtol=tol, atol=tol)\n\n  def test_error(self):\n    # TODO(rjryan): Fix this test under Eager.\n    if context.executing_eagerly():\n      return\n    for rank in VALID_FFT_RANKS:\n      for dims in range(0, rank):\n        x = np.zeros((1,) * dims).astype(np.complex64)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Shape must be .*rank {}.*\".format(rank)):\n          self._tf_fft(x, rank)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Shape must be .*rank {}.*\".format(rank)):\n          self._tf_ifft(x, rank)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(2), (np.float32, np.float64)))\n  def test_grad_simple(self, rank, extra_dims, np_type):\n    tol = 1e-4 if np_type == np.float32 else 1e-10\n    dims = rank + extra_dims\n    re = np.ones(shape=(4,) * dims, dtype=np_type) / 10.0\n    im = np.zeros(shape=(4,) * dims, dtype=np_type)\n    self._check_grad_complex(self._tf_fft_for_rank(rank), re, im,\n                             rtol=tol, atol=tol)\n    self._check_grad_complex(self._tf_ifft_for_rank(rank), re, im,\n                             rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(2), (np.float32, np.float64)))\n  def test_grad_random(self, rank, extra_dims, np_type):\n    dims = rank + extra_dims\n    tol = 1e-2 if np_type == np.float32 else 1e-10\n    re = np.random.rand(*((3,) * dims)).astype(np_type) * 2 - 1\n    im = np.random.rand(*((3,) * dims)).astype(np_type) * 2 - 1\n    self._check_grad_complex(self._tf_fft_for_rank(rank), re, im,\n                             rtol=tol, atol=tol)\n    self._check_grad_complex(self._tf_ifft_for_rank(rank), re, im,\n                             rtol=tol, atol=tol)\n\n\n@test_util.run_all_in_graph_and_eager_modes\n@test_util.disable_xla(\"b/155276727\")\nclass RFFTOpsTest(BaseFFTOpsTest, parameterized.TestCase):\n\n  def _tf_fft(self, x, rank, fft_length=None, feed_dict=None):\n    with self.cached_session() as sess:\n      return sess.run(\n          self._tf_fft_for_rank(rank)(x, fft_length), feed_dict=feed_dict)\n\n  def _tf_ifft(self, x, rank, fft_length=None, feed_dict=None):\n    with self.cached_session() as sess:\n      return sess.run(\n          self._tf_ifft_for_rank(rank)(x, fft_length), feed_dict=feed_dict)\n\n  def _np_fft(self, x, rank, fft_length=None):\n    if rank == 1:\n      return np.fft.rfft2(x, s=fft_length, axes=(-1,))\n    elif rank == 2:\n      return np.fft.rfft2(x, s=fft_length, axes=(-2, -1))\n    elif rank == 3:\n      return np.fft.rfft2(x, s=fft_length, axes=(-3, -2, -1))\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _np_ifft(self, x, rank, fft_length=None):\n    if rank == 1:\n      return np.fft.irfft2(x, s=fft_length, axes=(-1,))\n    elif rank == 2:\n      return np.fft.irfft2(x, s=fft_length, axes=(-2, -1))\n    elif rank == 3:\n      return np.fft.irfft2(x, s=fft_length, axes=(-3, -2, -1))\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _tf_fft_for_rank(self, rank):\n    if rank == 1:\n      return fft_ops.rfft\n    elif rank == 2:\n      return fft_ops.rfft2d\n    elif rank == 3:\n      return fft_ops.rfft3d\n    else:\n      raise ValueError(\"invalid rank\")\n\n  def _tf_ifft_for_rank(self, rank):\n    if rank == 1:\n      return fft_ops.irfft\n    elif rank == 2:\n      return fft_ops.irfft2d\n    elif rank == 3:\n      return fft_ops.irfft3d\n    else:\n      raise ValueError(\"invalid rank\")\n\n  # rocFFT requires/assumes that the input to the irfft transform\n  # is of the form that is a valid output from the rfft transform\n  # (i.e. it cannot be a set of random numbers)\n  # So for ROCm, call rfft and use its output as the input for testing irfft\n  def _generate_valid_irfft_input(self, c2r, np_ctype, r2c, np_rtype, rank,\n                                  fft_length):\n    if test.is_built_with_rocm():\n      return self._np_fft(r2c.astype(np_rtype), rank, fft_length)\n    else:\n      return c2r.astype(np_ctype)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (np.float32, np.float64)))\n\n  def test_empty(self, rank, extra_dims, np_rtype):\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    dims = rank + extra_dims\n    x = np.zeros((0,) * dims).astype(np_rtype)\n    self.assertEqual(x.shape, self._tf_fft(x, rank).shape)\n    x = np.zeros((0,) * dims).astype(np_ctype)\n    self.assertEqual(x.shape, self._tf_ifft(x, rank).shape)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_basic(self, rank, extra_dims, size, np_rtype):\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 5e-5\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    fft_length = (size,) * rank\n    self._compare_forward(\n        r2c.astype(np_rtype), rank, fft_length, rtol=tol, atol=tol)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r, rank, fft_length, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      (1,), range(3), (64, 128), (np.float32, np.float64)))\n  def test_large_batch(self, rank, extra_dims, size, np_rtype):\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 1e-5\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    fft_length = (size,) * rank\n    self._compare_forward(\n        r2c.astype(np_rtype), rank, fft_length, rtol=tol, atol=tol)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r, rank, fft_length, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_placeholder(self, rank, extra_dims, size, np_rtype):\n    if context.executing_eagerly():\n      return\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 1e-8\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    fft_length = (size,) * rank\n    self._compare_forward(\n        r2c.astype(np_rtype),\n        rank,\n        fft_length,\n        use_placeholder=True,\n        rtol=tol,\n        atol=tol)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(\n        c2r, rank, fft_length, use_placeholder=True, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_fft_lenth_truncate(self, rank, extra_dims, size, np_rtype):\n    \"\"\"Test truncation (FFT size < dimensions).\"\"\"\n    if test.is_built_with_rocm() and (rank == 3):\n      # TODO(rocm): fix me\n      # rfft fails for rank == 3 on ROCm\n      self.skipTest(\"Test fails on ROCm...fix me\")\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 8e-5\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    fft_length = (size - 2,) * rank\n    self._compare_forward(r2c.astype(np_rtype), rank, fft_length,\n                          rtol=tol, atol=tol)\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r, rank, fft_length, rtol=tol, atol=tol)\n    # Confirm it works with unknown shapes as well.\n    if not context.executing_eagerly():\n      self._compare_forward(\n          r2c.astype(np_rtype),\n          rank,\n          fft_length,\n          use_placeholder=True,\n          rtol=tol, atol=tol)\n      self._compare_backward(\n          c2r, rank, fft_length, use_placeholder=True, rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_fft_lenth_pad(self, rank, extra_dims, size, np_rtype):\n    \"\"\"Test padding (FFT size > dimensions).\"\"\"\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 8e-5\n    dims = rank + extra_dims\n    inner_dim = size // 2 + 1\n    r2c = np.mod(np.arange(np.power(size, dims)), 10).reshape(\n        (size,) * dims)\n    c2r = np.mod(np.arange(np.power(size, dims - 1) * inner_dim),\n                 10).reshape((size,) * (dims - 1) + (inner_dim,))\n    fft_length = (size + 2,) * rank\n    self._compare_forward(r2c.astype(np_rtype), rank, fft_length,\n                          rtol=tol, atol=tol)\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r.astype(np_ctype), rank, fft_length,\n                           rtol=tol, atol=tol)\n    # Confirm it works with unknown shapes as well.\n    if not context.executing_eagerly():\n      self._compare_forward(\n          r2c.astype(np_rtype),\n          rank,\n          fft_length,\n          use_placeholder=True,\n          rtol=tol, atol=tol)\n      self._compare_backward(\n          c2r.astype(np_ctype),\n          rank,\n          fft_length,\n          use_placeholder=True,\n          rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(3), (5, 6), (np.float32, np.float64)))\n  def test_random(self, rank, extra_dims, size, np_rtype):\n    def gen_real(shape):\n      n = np.prod(shape)\n      re = np.random.uniform(size=n)\n      ret = re.reshape(shape)\n      return ret\n\n    def gen_complex(shape):\n      n = np.prod(shape)\n      re = np.random.uniform(size=n)\n      im = np.random.uniform(size=n)\n      ret = (re + im * 1j).reshape(shape)\n      return ret\n    np_ctype = np.complex64 if np_rtype == np.float32 else np.complex128\n    tol = 1e-4 if np_rtype == np.float32 else 1e-5\n    dims = rank + extra_dims\n    r2c = gen_real((size,) * dims)\n    inner_dim = size // 2 + 1\n    fft_length = (size,) * rank\n    self._compare_forward(\n        r2c.astype(np_rtype), rank, fft_length, rtol=tol, atol=tol)\n    complex_dims = (size,) * (dims - 1) + (inner_dim,)\n    c2r = gen_complex(complex_dims)\n    c2r = self._generate_valid_irfft_input(c2r, np_ctype, r2c, np_rtype, rank,\n                                           fft_length)\n    self._compare_backward(c2r, rank, fft_length, rtol=tol, atol=tol)\n\n  def test_error(self):\n    # TODO(rjryan): Fix this test under Eager.\n    if context.executing_eagerly():\n      return\n    for rank in VALID_FFT_RANKS:\n      for dims in range(0, rank):\n        x = np.zeros((1,) * dims).astype(np.complex64)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Shape .* must have rank at least {}\".format(rank)):\n          self._tf_fft(x, rank)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Shape .* must have rank at least {}\".format(rank)):\n          self._tf_ifft(x, rank)\n      for dims in range(rank, rank + 2):\n        x = np.zeros((1,) * rank)\n\n        # Test non-rank-1 fft_length produces an error.\n        fft_length = np.zeros((1, 1)).astype(np.int32)\n        with self.assertRaisesWithPredicateMatch(ValueError,\n                                                 \"Shape .* must have rank 1\"):\n          self._tf_fft(x, rank, fft_length)\n        with self.assertRaisesWithPredicateMatch(ValueError,\n                                                 \"Shape .* must have rank 1\"):\n          self._tf_ifft(x, rank, fft_length)\n\n        # Test wrong fft_length length.\n        fft_length = np.zeros((rank + 1,)).astype(np.int32)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Dimension must be .*but is {}.*\".format(rank + 1)):\n          self._tf_fft(x, rank, fft_length)\n        with self.assertRaisesWithPredicateMatch(\n            ValueError, \"Dimension must be .*but is {}.*\".format(rank + 1)):\n          self._tf_ifft(x, rank, fft_length)\n\n      # Test that calling the kernel directly without padding to fft_length\n      # produces an error.\n      rffts_for_rank = {\n          1: [gen_spectral_ops.rfft, gen_spectral_ops.irfft],\n          2: [gen_spectral_ops.rfft2d, gen_spectral_ops.irfft2d],\n          3: [gen_spectral_ops.rfft3d, gen_spectral_ops.irfft3d]\n      }\n      rfft_fn, irfft_fn = rffts_for_rank[rank]\n      with self.assertRaisesWithPredicateMatch(\n          errors.InvalidArgumentError,\n          \"Input dimension .* must have length of at least 6 but got: 5\"):\n        x = np.zeros((5,) * rank).astype(np.float32)\n        fft_length = [6] * rank\n        with self.cached_session():\n          self.evaluate(rfft_fn(x, fft_length))\n\n      with self.assertRaisesWithPredicateMatch(\n          errors.InvalidArgumentError,\n          \"Input dimension .* must have length of at least .* but got: 3\"):\n        x = np.zeros((3,) * rank).astype(np.complex64)\n        fft_length = [6] * rank\n        with self.cached_session():\n          self.evaluate(irfft_fn(x, fft_length))\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(2), (5, 6), (np.float32, np.float64)))\n  def test_grad_simple(self, rank, extra_dims, size, np_rtype):\n    # rfft3d/irfft3d do not have gradients yet.\n    if rank == 3:\n      return\n    dims = rank + extra_dims\n    tol = 1e-3 if np_rtype == np.float32 else 1e-10\n    re = np.ones(shape=(size,) * dims, dtype=np_rtype)\n    im = -np.ones(shape=(size,) * dims, dtype=np_rtype)\n    self._check_grad_real(self._tf_fft_for_rank(rank), re,\n                          rtol=tol, atol=tol)\n    if test.is_built_with_rocm():\n      # Fails on ROCm because of irfft peculairity\n      return\n    self._check_grad_complex(\n        self._tf_ifft_for_rank(rank), re, im, result_is_complex=False,\n        rtol=tol, atol=tol)\n\n  @parameterized.parameters(itertools.product(\n      VALID_FFT_RANKS, range(2), (5, 6), (np.float32, np.float64)))\n  def test_grad_random(self, rank, extra_dims, size, np_rtype):\n    # rfft3d/irfft3d do not have gradients yet.\n    if rank == 3:\n      return\n    dims = rank + extra_dims\n    tol = 1e-2 if np_rtype == np.float32 else 1e-10\n    re = np.random.rand(*((size,) * dims)).astype(np_rtype) * 2 - 1\n    im = np.random.rand(*((size,) * dims)).astype(np_rtype) * 2 - 1\n    self._check_grad_real(self._tf_fft_for_rank(rank), re,\n                          rtol=tol, atol=tol)\n    if test.is_built_with_rocm():\n      # Fails on ROCm because of irfft peculairity\n      return\n    self._check_grad_complex(\n        self._tf_ifft_for_rank(rank), re, im, result_is_complex=False,\n        rtol=tol, atol=tol)\n\n  def test_invalid_args(self):\n    # Test case for GitHub issue 55263\n    a = np.empty([6, 0])\n    b = np.array([1, -1])\n    with self.assertRaisesRegex(errors.InvalidArgumentError, \"must >= 0\"):\n      with self.session():\n        v = fft_ops.rfft2d(input_tensor=a, fft_length=b)\n        self.evaluate(v)\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass FFTShiftTest(test.TestCase, parameterized.TestCase):\n\n  def test_definition(self):\n    with self.session():\n      x = [0, 1, 2, 3, 4, -4, -3, -2, -1]\n      y = [-4, -3, -2, -1, 0, 1, 2, 3, 4]\n      self.assertAllEqual(fft_ops.fftshift(x), y)\n      self.assertAllEqual(fft_ops.ifftshift(y), x)\n      x = [0, 1, 2, 3, 4, -5, -4, -3, -2, -1]\n      y = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n      self.assertAllEqual(fft_ops.fftshift(x), y)\n      self.assertAllEqual(fft_ops.ifftshift(y), x)\n\n  def test_axes_keyword(self):\n    with self.session():\n      freqs = [[0, 1, 2], [3, 4, -4], [-3, -2, -1]]\n      shifted = [[-1, -3, -2], [2, 0, 1], [-4, 3, 4]]\n      self.assertAllEqual(fft_ops.fftshift(freqs, axes=(0, 1)), shifted)\n      self.assertAllEqual(\n          fft_ops.fftshift(freqs, axes=0),\n          fft_ops.fftshift(freqs, axes=(0,)))\n      self.assertAllEqual(fft_ops.ifftshift(shifted, axes=(0, 1)), freqs)\n      self.assertAllEqual(\n          fft_ops.ifftshift(shifted, axes=0),\n          fft_ops.ifftshift(shifted, axes=(0,)))\n      self.assertAllEqual(fft_ops.fftshift(freqs), shifted)\n      self.assertAllEqual(fft_ops.ifftshift(shifted), freqs)\n\n  def test_numpy_compatibility(self):\n    with self.session():\n      x = [0, 1, 2, 3, 4, -4, -3, -2, -1]\n      y = [-4, -3, -2, -1, 0, 1, 2, 3, 4]\n      self.assertAllEqual(fft_ops.fftshift(x), np.fft.fftshift(x))\n      self.assertAllEqual(fft_ops.ifftshift(y), np.fft.ifftshift(y))\n      x = [0, 1, 2, 3, 4, -5, -4, -3, -2, -1]\n      y = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n      self.assertAllEqual(fft_ops.fftshift(x), np.fft.fftshift(x))\n      self.assertAllEqual(fft_ops.ifftshift(y), np.fft.ifftshift(y))\n      freqs = [[0, 1, 2], [3, 4, -4], [-3, -2, -1]]\n      shifted = [[-1, -3, -2], [2, 0, 1], [-4, 3, 4]]\n      self.assertAllEqual(\n          fft_ops.fftshift(freqs, axes=(0, 1)),\n          np.fft.fftshift(freqs, axes=(0, 1)))\n      self.assertAllEqual(\n          fft_ops.ifftshift(shifted, axes=(0, 1)),\n          np.fft.ifftshift(shifted, axes=(0, 1)))\n\n  @parameterized.parameters(None, 1, ([1, 2],))\n  def test_placeholder(self, axes):\n    if context.executing_eagerly():\n      return\n    x = array_ops.placeholder(shape=[None, None, None], dtype=\"float32\")\n    y_fftshift = fft_ops.fftshift(x, axes=axes)\n    y_ifftshift = fft_ops.ifftshift(x, axes=axes)\n    x_np = np.random.rand(16, 256, 256)\n    with self.session() as sess:\n      y_fftshift_res, y_ifftshift_res = sess.run(\n          [y_fftshift, y_ifftshift],\n          feed_dict={x: x_np})\n    self.assertAllClose(y_fftshift_res, np.fft.fftshift(x_np, axes=axes))\n    self.assertAllClose(y_ifftshift_res, np.fft.ifftshift(x_np, axes=axes))\n\n  def test_negative_axes(self):\n    with self.session():\n      freqs = [[0, 1, 2], [3, 4, -4], [-3, -2, -1]]\n      shifted = [[-1, -3, -2], [2, 0, 1], [-4, 3, 4]]\n      self.assertAllEqual(fft_ops.fftshift(freqs, axes=(0, -1)), shifted)\n      self.assertAllEqual(fft_ops.ifftshift(shifted, axes=(0, -1)), freqs)\n      self.assertAllEqual(\n          fft_ops.fftshift(freqs, axes=-1), fft_ops.fftshift(freqs, axes=(1,)))\n      self.assertAllEqual(\n          fft_ops.ifftshift(shifted, axes=-1),\n          fft_ops.ifftshift(shifted, axes=(1,)))\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/fft_ops.cc", "tensorflow/python/kernel_tests/signal/fft_ops_test.py"], "buggy_code_start_loc": [68, 611], "buggy_code_end_loc": [68, 611], "fixing_code_start_loc": [69, 612], "fixing_code_end_loc": [73, 621], "type": "CWE-20", "message": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the `tf.compat.v1.signal.rfft2d` and `tf.compat.v1.signal.rfft3d` lack input validation and under certain condition can result in crashes (due to `CHECK`-failures). Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "other": {"cve": {"id": "CVE-2022-29213", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-21T00:15:11.787", "lastModified": "2022-06-07T02:20:00.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the `tf.compat.v1.signal.rfft2d` and `tf.compat.v1.signal.rfft3d` lack input validation and under certain condition can result in crashes (due to `CHECK`-failures). Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En versiones anteriores a 2.9.0, 2.8.1, 2.7.2 y 2.6.4, \"tf.compat.v1.signal.rfft2d\" y \"tf.compat.v1.signal.rfft3d\" carecen de comprobaci\u00f3n de entrada y, bajo determinadas condiciones, pueden provocar bloqueos (debido a fallos de \"CHECK\"). Las versiones 2.9.0, 2.8.1, 2.7.2 y 2.6.4 contienen un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.4", "matchCriteriaId": "D9359D32-D090-44CF-AC43-2046084A28BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C4DFBF2D-5283-42F6-8800-D653BFA5CE82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "A58EDA5C-66D6-46F1-962E-60AFB7C784A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "89522760-C2DF-400D-9624-626D8F160CBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "E9EA1898-ACAA-4699-8BAE-54D62C1819FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "130DE3C9-6842-456F-A259-BF8FF8457217"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "BBF2FCEF-989C-409D-9F4C-81418C65B972"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "9CFB1CFC-579D-4647-A472-6DE8BE1951DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F3F3F37E-D27F-4060-830C-0AFF16150777"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/0a8a781e597b18ead006d19b7d23d0a369e9ad73", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/issues/55263", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/pull/55274", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.6.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.7.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.8.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.9.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-5889-7v45-q28m", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/0a8a781e597b18ead006d19b7d23d0a369e9ad73"}}