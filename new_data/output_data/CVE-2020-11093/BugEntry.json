{"buggy_code": ["import pytest\nimport json\n\nfrom enum import Enum, unique\n\nfrom indy.did import create_and_store_my_did, key_for_local_did\n\nfrom plenum.common.constants import (\n    TRUSTEE, STEWARD, NYM, TXN_TYPE, TARGET_NYM, VERKEY, ROLE,\n    CURRENT_PROTOCOL_VERSION)\nfrom plenum.common.exceptions import UnauthorizedClientRequest\nfrom plenum.common.signer_did import DidSigner\nfrom plenum.common.member.member import Member\nfrom plenum.test.helper import sdk_gen_request, sdk_sign_request_objects\n\nfrom indy_common.types import Request\nfrom indy_common.roles import Roles\n\nfrom indy_node.test.helper import createUuidIdentifierAndFullVerkey\n\n\n#   TODO\n#   - more specific string patterns for auth exc check\n\n\nclass DID(object):\n    def __init__(self, did=None, role=Roles.IDENTITY_OWNER, verkey=None, creator=None, wallet_handle=None):\n        self.did = did\n        self.role = role\n        self.verkey = verkey\n        self.creator = creator\n        self.wallet_handle = wallet_handle\n\n    @property\n    def wallet_did(self):\n        return (self.wallet_handle, self.did)\n\n\n@unique\nclass EnumBase(Enum):\n    def __str__(self):\n        return self.name\n\n\nActionIds = Enum('ActionIds', 'add edit', type=EnumBase)\n\n# params for addition:\n# - signer:\n#   - role: Roles\n# - dest:\n#   - verkey in NYM: omitted, None, val\n#   - role: Roles, omitted\nNYMAddDestRoles = Enum(\n    'NYMAddDestRoles',\n    [(r.name, r.value) for r in Roles] + [('omitted', 'omitted')],\n    type=EnumBase)\n\nNYMAddDestVerkeys = Enum('NYMAddDestVerkeys', 'none val omitted', type=EnumBase)\n\n# params for edition:\n# - signer:\n#   - [self, creator] + [other], where other = any of Roles\n# - dest:\n#   - role in ledger: Roles\n#   - verkey in ledger: None, val\n#   - role: Roles, omitted\n#   - verkey in NYM: same, new (not None), demote(None), omitted\nLedgerDIDVerkeys = Enum('LedgerDIDVerkeys', 'none val', type=EnumBase)\nLedgerDIDRoles = Roles\n\nNYMEditSignerTypes = Enum(\n    'NYMEditSignerTypes',\n    [(r.name, r.value) for r in Roles] + [('self', 'self'), ('creator', 'creator')],\n    type=EnumBase\n)\n\nNYMEditDestRoles = NYMAddDestRoles\nNYMEditDestVerkeys = Enum('NYMEditDestVerkeys', 'same new demote omitted', type=EnumBase)\n\ndids = {}\ndid_editor_others = {}\ndid_provisioners = did_editor_others\n\n\n# FIXTURES\n\n\n@pytest.fixture(scope=\"module\")\ndef trustee(looper, sdk_wallet_trustee):\n    wh, did = sdk_wallet_trustee\n    verkey = looper.loop.run_until_complete(key_for_local_did(wh, did))\n    return DID(did=did, role=Roles.TRUSTEE, verkey=verkey, wallet_handle=wh)\n\n\n@pytest.fixture(scope=\"module\")\ndef poolTxnData(looper, poolTxnData, trustee):\n    global dids\n    global did_editor_others\n\n    # TODO non-Trustee creators\n\n    data = poolTxnData\n\n    def _add_did(role, did_name, with_verkey=True):\n        nonlocal data\n\n        data['seeds'][did_name] = did_name + '0' * (32 - len(did_name))\n        t_sgnr = DidSigner(seed=data['seeds'][did_name].encode())\n        verkey = t_sgnr.full_verkey if with_verkey else None\n        data['txns'].append(\n            Member.nym_txn(nym=t_sgnr.identifier,\n                           verkey=verkey,\n                           role=role.value,\n                           name=did_name,\n                           creator=trustee.did)\n        )\n\n        if verkey:\n            (sdk_did, sdk_verkey) = looper.loop.run_until_complete(\n                create_and_store_my_did(\n                    trustee.wallet_handle,\n                    json.dumps({'seed': data['seeds'][did_name]}))\n            )\n\n        return DID(\n            did=t_sgnr.identifier, role=role, verkey=verkey,\n            creator=trustee, wallet_handle=trustee.wallet_handle\n        )\n\n    params = [(dr, dv) for dr in LedgerDIDRoles for dv in LedgerDIDVerkeys]\n    for (dr, dv) in params:\n        dids[(dr, dv)] = _add_did(\n            dr, \"{}-{}\".format(dr.name, dv.name),\n            with_verkey=(dv == LedgerDIDVerkeys.val)\n        )\n\n    for dr in Roles:\n        did_editor_others[dr] = _add_did(dr, \"{}-other\".format(dr.name))\n\n    return data\n\n\n@pytest.fixture(scope=\"module\", params=list(Roles))\ndef provisioner_role(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\")\ndef provisioner(poolTxnData, provisioner_role):\n    return did_provisioners[provisioner_role]\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMAddDestRoles))\ndef nym_add_dest_role(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMAddDestVerkeys))\ndef nym_add_dest_verkey(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"function\")\ndef add_op(nym_add_dest_role, nym_add_dest_verkey):\n    did, verkey = createUuidIdentifierAndFullVerkey()\n\n    op = {\n        TXN_TYPE: NYM,\n        TARGET_NYM: did,\n        ROLE: nym_add_dest_role.value,\n        VERKEY: verkey\n    }\n\n    if nym_add_dest_role == NYMAddDestRoles.omitted:\n        del op[ROLE]\n\n    if nym_add_dest_verkey == NYMAddDestVerkeys.omitted:\n        del op[VERKEY]\n\n    return op\n\n\n@pytest.fixture(scope=\"module\", params=list(LedgerDIDRoles))\ndef edited_ledger_role(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=list(LedgerDIDVerkeys))\ndef edited_ledger_verkey(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"function\")\ndef edited(edited_ledger_role, edited_ledger_verkey):\n    return dids[(edited_ledger_role, edited_ledger_verkey)]\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMEditDestRoles))\ndef edited_nym_role(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMEditDestVerkeys))\ndef edited_nym_verkey(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMEditSignerTypes))\ndef editor_type(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"function\")\ndef editor(editor_type, edited):\n    if editor_type == NYMEditSignerTypes.self:\n        return edited\n    elif editor_type == NYMEditSignerTypes.creator:\n        return edited.creator\n    else:\n        return did_editor_others[Roles(editor_type.value)]\n\n\n@pytest.fixture(scope=\"function\")\ndef edit_op(edited, edited_nym_role, edited_nym_verkey):\n    op = {\n        TXN_TYPE: NYM,\n        TARGET_NYM: edited.did,\n    }\n\n    if edited_nym_role != NYMEditDestRoles.omitted:\n        op[ROLE] = edited_nym_role.value\n\n    if edited_nym_verkey == NYMEditDestVerkeys.same:\n        op[VERKEY] = edited.verkey\n    elif edited_nym_verkey == NYMEditDestVerkeys.new:\n        _, op[VERKEY] = createUuidIdentifierAndFullVerkey()\n    elif edited_nym_verkey == NYMEditDestVerkeys.demote:\n        if edited.verkey is None:\n            return None  # pass that case since it is covered by `same` case as well\n        else:\n            op[VERKEY] = None\n\n    return op\n\n\n# TEST HELPERS\n\ndef auth_check(action_id, signer, op, did_ledger=None):\n    op_role = Roles(op[ROLE]) if ROLE in op else None\n\n    def check_promotion():\n        # omitted role means IDENTITY_OWNER\n        if op_role in (None, Roles.IDENTITY_OWNER):\n            return signer.role in (Roles.TRUSTEE, Roles.STEWARD, Roles.ENDORSER)\n        elif op_role in (Roles.TRUSTEE, Roles.STEWARD):\n            return signer.role == Roles.TRUSTEE\n        elif op_role in (Roles.ENDORSER, Roles.NETWORK_MONITOR):\n            return signer.role in (Roles.TRUSTEE, Roles.STEWARD)\n\n    def check_demotion():\n        if did_ledger.role in (Roles.TRUSTEE, Roles.STEWARD):\n            return signer.role == Roles.TRUSTEE\n        elif did_ledger.role == Roles.ENDORSER:\n            return (signer.role == Roles.TRUSTEE)\n            # FIXME INDY-1968: uncomment when the task is addressed\n            # return ((signer.role == Roles.TRUSTEE) or\n            #        (signer.role == Roles.ENDORSER and\n            #            is_self and is_owner))\n        elif did_ledger.role == Roles.NETWORK_MONITOR:\n            return signer.role in (Roles.TRUSTEE, Roles.STEWARD)\n\n    if action_id == ActionIds.add:\n        return check_promotion()\n\n    elif action_id == ActionIds.edit:\n        # is_self = signer.did == did_ledger.did\n        is_owner = signer == (did_ledger if did_ledger.verkey is not None else\n        did_ledger.creator)\n\n        if (VERKEY in op) and (not is_owner):\n            return False\n\n        if ROLE in op:\n            if op_role == did_ledger.role:\n                # FIXME INDY-1969: related to the task\n                return is_owner  # TODO what is a case here, is it correctly designed\n\n            elif op_role == Roles.IDENTITY_OWNER:  # demotion of existent DID\n                return check_demotion()\n\n            elif did_ledger.role == Roles.IDENTITY_OWNER:  # promotion of existent DID\n                return check_promotion()\n\n            else:  # role updating: demotion + promotion\n                return (check_demotion() and check_promotion())\n        else:\n            return True\n\n    return False\n\n\ndef sign_and_validate(looper, node, action_id, signer, op, did_ledger=None):\n    req_obj = sdk_gen_request(op, protocol_version=CURRENT_PROTOCOL_VERSION,\n                              identifier=signer.did)\n    s_req = sdk_sign_request_objects(looper, signer.wallet_did, [req_obj])[0]\n\n    request = Request(**json.loads(s_req))\n\n    if auth_check(action_id, signer, op, did_ledger):\n        node.write_manager.dynamic_validation(request, 0)\n    else:\n        with pytest.raises(UnauthorizedClientRequest):\n            node.write_manager.dynamic_validation(request, 0)\n\n\n# TESTS\n# Note. some fixtures are referred explicitly just to make test nodeid names predictable\n\ndef test_nym_add(\n        provisioner_role, nym_add_dest_role, nym_add_dest_verkey,\n        looper, txnPoolNodeSet,\n        provisioner, add_op):\n    sign_and_validate(looper, txnPoolNodeSet[0], ActionIds.add, provisioner, add_op)\n\n\ndef test_nym_edit(\n        edited_ledger_role, edited_ledger_verkey, editor_type,\n        edited_nym_role, edited_nym_verkey,\n        looper, txnPoolNodeSet,\n        editor, edited, edit_op):\n    if edit_op is None:  # might be None, means a duplicate test case\n        return\n\n    if editor.verkey is None:  # skip that as well since it doesn't make sense\n        return\n\n    sign_and_validate(looper, txnPoolNodeSet[0], ActionIds.edit, editor, edit_op, did_ledger=edited)\n"], "fixing_code": ["import pytest\nimport json\n\nfrom enum import Enum, unique\n\nfrom indy.did import create_and_store_my_did, key_for_local_did\n\nfrom plenum.common.constants import (\n    TRUSTEE, STEWARD, NYM, TXN_TYPE, TARGET_NYM, VERKEY, ROLE,\n    CURRENT_PROTOCOL_VERSION)\nfrom plenum.common.exceptions import UnauthorizedClientRequest\nfrom plenum.common.signer_did import DidSigner\nfrom plenum.common.member.member import Member\nfrom plenum.test.helper import sdk_gen_request, sdk_sign_request_objects\n\nfrom indy_common.types import Request\nfrom indy_common.roles import Roles\n\nfrom indy_node.test.helper import createUuidIdentifierAndFullVerkey\n\n\n#   TODO\n#   - more specific string patterns for auth exc check\n\n\nclass DID(object):\n    def __init__(self, did=None, role=Roles.IDENTITY_OWNER, verkey=None, creator=None, wallet_handle=None):\n        self.did = did\n        self.role = role\n        self.verkey = verkey\n        self.creator = creator\n        self.wallet_handle = wallet_handle\n\n    @property\n    def wallet_did(self):\n        return (self.wallet_handle, self.did)\n\n\n@unique\nclass EnumBase(Enum):\n    def __str__(self):\n        return self.name\n\n\nActionIds = Enum('ActionIds', 'add edit', type=EnumBase)\n\n# params for addition:\n# - signer:\n#   - role: Roles\n# - dest:\n#   - verkey in NYM: omitted, None, val\n#   - role: Roles, omitted\nNYMAddDestRoles = Enum(\n    'NYMAddDestRoles',\n    [(r.name, r.value) for r in Roles] + [('omitted', 'omitted')],\n    type=EnumBase)\n\nNYMAddDestVerkeys = Enum('NYMAddDestVerkeys', 'none val omitted', type=EnumBase)\n\n# params for edition:\n# - signer:\n#   - [self, creator] + [other], where other = any of Roles\n# - dest:\n#   - role in ledger: Roles\n#   - verkey in ledger: None, val\n#   - role: Roles, omitted\n#   - verkey in NYM: same, new (not None), demote(None), omitted\nLedgerDIDVerkeys = Enum('LedgerDIDVerkeys', 'none val', type=EnumBase)\nLedgerDIDRoles = Roles\n\nNYMEditSignerTypes = Enum(\n    'NYMEditSignerTypes',\n    [(r.name, r.value) for r in Roles] + [('self', 'self'), ('creator', 'creator')],\n    type=EnumBase\n)\n\nNYMEditDestRoles = NYMAddDestRoles\nNYMEditDestVerkeys = Enum('NYMEditDestVerkeys', 'same new demote omitted', type=EnumBase)\n\ndids = {}\ndid_editor_others = {}\ndid_provisioners = did_editor_others\n\n\n# FIXTURES\n\n\n@pytest.fixture(scope=\"module\")\ndef trustee(looper, sdk_wallet_trustee):\n    wh, did = sdk_wallet_trustee\n    verkey = looper.loop.run_until_complete(key_for_local_did(wh, did))\n    return DID(did=did, role=Roles.TRUSTEE, verkey=verkey, wallet_handle=wh)\n\n\n@pytest.fixture(scope=\"module\")\ndef poolTxnData(looper, poolTxnData, trustee):\n    global dids\n    global did_editor_others\n\n    # TODO non-Trustee creators\n\n    data = poolTxnData\n\n    def _add_did(role, did_name, with_verkey=True):\n        nonlocal data\n\n        data['seeds'][did_name] = did_name + '0' * (32 - len(did_name))\n        t_sgnr = DidSigner(seed=data['seeds'][did_name].encode())\n        verkey = t_sgnr.full_verkey if with_verkey else None\n        data['txns'].append(\n            Member.nym_txn(nym=t_sgnr.identifier,\n                           verkey=verkey,\n                           role=role.value,\n                           name=did_name,\n                           creator=trustee.did)\n        )\n\n        if verkey:\n            (sdk_did, sdk_verkey) = looper.loop.run_until_complete(\n                create_and_store_my_did(\n                    trustee.wallet_handle,\n                    json.dumps({'seed': data['seeds'][did_name]}))\n            )\n\n        return DID(\n            did=t_sgnr.identifier, role=role, verkey=verkey,\n            creator=trustee, wallet_handle=trustee.wallet_handle\n        )\n\n    params = [(dr, dv) for dr in LedgerDIDRoles for dv in LedgerDIDVerkeys]\n    for (dr, dv) in params:\n        dids[(dr, dv)] = _add_did(\n            dr, \"{}-{}\".format(dr.name, dv.name),\n            with_verkey=(dv == LedgerDIDVerkeys.val)\n        )\n\n    for dr in Roles:\n        did_editor_others[dr] = _add_did(dr, \"{}-other\".format(dr.name))\n\n    return data\n\n\n@pytest.fixture(scope=\"module\", params=list(Roles))\ndef provisioner_role(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\")\ndef provisioner(poolTxnData, provisioner_role):\n    return did_provisioners[provisioner_role]\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMAddDestRoles))\ndef nym_add_dest_role(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMAddDestVerkeys))\ndef nym_add_dest_verkey(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"function\")\ndef add_op(nym_add_dest_role, nym_add_dest_verkey):\n    did, verkey = createUuidIdentifierAndFullVerkey()\n\n    op = {\n        TXN_TYPE: NYM,\n        TARGET_NYM: did,\n        ROLE: nym_add_dest_role.value,\n        VERKEY: verkey\n    }\n\n    if nym_add_dest_role == NYMAddDestRoles.omitted:\n        del op[ROLE]\n\n    if nym_add_dest_verkey == NYMAddDestVerkeys.omitted:\n        del op[VERKEY]\n\n    return op\n\n\n@pytest.fixture(scope=\"module\", params=list(LedgerDIDRoles))\ndef edited_ledger_role(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=list(LedgerDIDVerkeys))\ndef edited_ledger_verkey(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"function\")\ndef edited(edited_ledger_role, edited_ledger_verkey):\n    return dids[(edited_ledger_role, edited_ledger_verkey)]\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMEditDestRoles))\ndef edited_nym_role(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMEditDestVerkeys))\ndef edited_nym_verkey(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=list(NYMEditSignerTypes))\ndef editor_type(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"function\")\ndef editor(editor_type, edited):\n    if editor_type == NYMEditSignerTypes.self:\n        return edited\n    elif editor_type == NYMEditSignerTypes.creator:\n        return edited.creator\n    else:\n        return did_editor_others[Roles(editor_type.value)]\n\n\n@pytest.fixture(scope=\"function\")\ndef edit_op(edited, edited_nym_role, edited_nym_verkey):\n    op = {\n        TXN_TYPE: NYM,\n        TARGET_NYM: edited.did,\n    }\n\n    if edited_nym_role != NYMEditDestRoles.omitted:\n        op[ROLE] = edited_nym_role.value\n\n    if edited_nym_verkey == NYMEditDestVerkeys.same:\n        op[VERKEY] = edited.verkey\n    elif edited_nym_verkey == NYMEditDestVerkeys.new:\n        _, op[VERKEY] = createUuidIdentifierAndFullVerkey()\n    elif edited_nym_verkey == NYMEditDestVerkeys.demote:\n        if edited.verkey is None:\n            return None  # pass that case since it is covered by `same` case as well\n        else:\n            op[VERKEY] = None\n\n    return op\n\n\n# TEST HELPERS\n\ndef auth_check(action_id, signer, op, did_ledger=None):\n    op_role = Roles(op[ROLE]) if ROLE in op else None\n\n    def check_promotion():\n        # omitted role means IDENTITY_OWNER\n        if op_role in (None, Roles.IDENTITY_OWNER):\n            return signer.role in (Roles.TRUSTEE, Roles.STEWARD, Roles.ENDORSER)\n        elif op_role in (Roles.TRUSTEE, Roles.STEWARD):\n            return signer.role == Roles.TRUSTEE\n        elif op_role in (Roles.ENDORSER, Roles.NETWORK_MONITOR):\n            return signer.role in (Roles.TRUSTEE, Roles.STEWARD)\n\n    def check_demotion():\n        if did_ledger.role in (Roles.TRUSTEE, Roles.STEWARD):\n            return signer.role == Roles.TRUSTEE\n        elif did_ledger.role == Roles.ENDORSER:\n            return (signer.role == Roles.TRUSTEE)\n            # FIXME INDY-1968: uncomment when the task is addressed\n            # return ((signer.role == Roles.TRUSTEE) or\n            #        (signer.role == Roles.ENDORSER and\n            #            is_self and is_owner))\n        elif did_ledger.role == Roles.NETWORK_MONITOR:\n            return signer.role in (Roles.TRUSTEE, Roles.STEWARD)\n\n    if action_id == ActionIds.add:\n        return check_promotion()\n\n    elif action_id == ActionIds.edit:\n        # is_self = signer.did == did_ledger.did\n        is_owner = signer == (did_ledger if did_ledger.verkey is not None else\n        did_ledger.creator)\n\n        if (VERKEY in op) and (not is_owner):\n            return False\n\n        if ROLE in op:\n            if op_role == did_ledger.role:\n                # FIXME INDY-1969: related to the task\n                return is_owner  # TODO what is a case here, is it correctly designed\n\n            elif op_role == Roles.IDENTITY_OWNER:  # demotion of existent DID\n                return check_demotion()\n\n            elif did_ledger.role == Roles.IDENTITY_OWNER:  # promotion of existent DID\n                return check_promotion()\n\n            else:  # role updating: demotion + promotion\n                return (check_demotion() and check_promotion())\n        else:\n            return True\n\n    return False\n\n\ndef sign_and_validate(looper, node, action_id, signer, op, did_ledger=None):\n    req_obj = sdk_gen_request(op, protocol_version=CURRENT_PROTOCOL_VERSION,\n                              identifier=signer.did)\n    s_req = sdk_sign_request_objects(looper, signer.wallet_did, [req_obj])[0]\n\n    request = Request(**json.loads(s_req))\n\n    if auth_check(action_id, signer, op, did_ledger):\n        node.write_manager.dynamic_validation(request, 0)\n    else:\n        with pytest.raises(UnauthorizedClientRequest):\n            node.write_manager.dynamic_validation(request, 0)\n\n\n# TESTS\n# Note. some fixtures are referred explicitly just to make test nodeid names predictable\n\ndef test_nym_add(\n        provisioner_role, nym_add_dest_role, nym_add_dest_verkey,\n        looper, txnPoolNodeSet,\n        provisioner, add_op):\n    sign_and_validate(looper, txnPoolNodeSet[0], ActionIds.add, provisioner, add_op)\n\n\ndef test_nym_edit(\n        edited_ledger_role, edited_ledger_verkey, editor_type,\n        edited_nym_role, edited_nym_verkey,\n        looper, txnPoolNodeSet,\n        editor, edited, edit_op):\n    if edit_op is None:  # might be None, means a duplicate test case\n        return\n\n    if editor.verkey is None:  # skip that as well since it doesn't make sense\n        return\n\n    if not ROLE in edit_op:  # skip if the update operation doesn't changes neither role nor verkey\n        if not VERKEY in edit_op:\n            return\n\n    sign_and_validate(looper, txnPoolNodeSet[0], ActionIds.edit, editor, edit_op, did_ledger=edited)\n"], "filenames": ["indy_node/test/nym_txn/test_nym_auth_rules.py"], "buggy_code_start_loc": [336], "buggy_code_end_loc": [336], "fixing_code_start_loc": [337], "fixing_code_end_loc": [341], "type": "CWE-347", "message": "Hyperledger Indy Node is the server portion of a distributed ledger purpose-built for decentralized identity. In Hyperledger Indy before version 1.12.4, there is lack of signature verification on a specific transaction which enables an attacker to make certain unauthorized alterations to the ledger. Updating a DID with a nym transaction will be written to the ledger if neither ROLE or VERKEY are being changed, regardless of sender. A malicious DID with no particular role can ask an update for another DID (but cannot modify its verkey or role). This is bad because 1) Any DID can write a nym transaction to the ledger (i.e., any DID can spam the ledger with nym transactions), 2) Any DID can change any other DID's alias, 3) The update transaction modifies the ledger metadata associated with a DID.", "other": {"cve": {"id": "CVE-2020-11093", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-24T20:15:12.337", "lastModified": "2020-12-31T19:25:53.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Hyperledger Indy Node is the server portion of a distributed ledger purpose-built for decentralized identity. In Hyperledger Indy before version 1.12.4, there is lack of signature verification on a specific transaction which enables an attacker to make certain unauthorized alterations to the ledger. Updating a DID with a nym transaction will be written to the ledger if neither ROLE or VERKEY are being changed, regardless of sender. A malicious DID with no particular role can ask an update for another DID (but cannot modify its verkey or role). This is bad because 1) Any DID can write a nym transaction to the ledger (i.e., any DID can spam the ledger with nym transactions), 2) Any DID can change any other DID's alias, 3) The update transaction modifies the ledger metadata associated with a DID."}, {"lang": "es", "value": "Hyperledger Indy Node es la parte del servidor de un libro mayor distribuido dise\u00f1ado espec\u00edficamente para la identidad descentralizada.&#xa0;En Hyperledger Indy versiones anteriores a 1.12.4, se presenta una falta de verificaci\u00f3n de firma en una transacci\u00f3n espec\u00edfica que permite a un atacante hacer determinadas alteraciones no autorizadas en el libro mayor.&#xa0;La actualizaci\u00f3n de un DID con una transacci\u00f3n nym ser\u00e1 escrita en el libro mayor si ning\u00fan ROL ni CLAVE, han sido cambiados, independientemente del remitente.&#xa0;Un DID malicioso sin un rol en particular puede requerir una actualizaci\u00f3n para otro DID (pero no puede modificar su clave o rol).&#xa0;Esto es malo porque 1) Cualquier DID puede escribir una transacci\u00f3n nym en el libro mayor (es decir, cualquier DID puede enviar spam al libro mayor con transacciones nym), 2) Cualquier DID puede cambiar el alias de cualquier otro DID, 3) La transacci\u00f3n de actualizaci\u00f3n modifica los metadatos del libro mayor asociado con un DID"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:indy-node:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.4", "matchCriteriaId": "28B5BA5E-162C-424C-A1D5-D9BA9D0FFD6E"}]}]}], "references": [{"url": "https://github.com/hyperledger/indy-node/blob/master/CHANGELOG.md#1124", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/hyperledger/indy-node/blob/master/docs/source/auth_rules.md", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/hyperledger/indy-node/commit/55056f22c83b7c3520488b615e1577e0f895d75a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hyperledger/indy-node/security/advisories/GHSA-wh2w-39f4-rpv2", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hyperledger/indy-node/commit/55056f22c83b7c3520488b615e1577e0f895d75a"}}