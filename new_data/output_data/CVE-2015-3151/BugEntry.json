{"buggy_code": ["#include <gio/gio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#include \"libabrt.h\"\n#include \"abrt-polkit.h\"\n#include \"abrt_glib.h\"\n#include <libreport/dump_dir.h>\n#include \"problem_api.h\"\n\nstatic GMainLoop *loop;\nstatic guint g_timeout_source;\n/* default, settable with -t: */\nstatic unsigned g_timeout_value = 120;\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic GDBusNodeInfo *introspection_data = NULL;\n\n/* Introspection data for the service we are exporting */\nstatic const gchar introspection_xml[] =\n  \"<node>\"\n  \"  <interface name='\"ABRT_DBUS_IFACE\"'>\"\n  \"    <method name='NewProblem'>\"\n  \"      <arg type='a{ss}' name='problem_data' direction='in'/>\"\n  \"      <arg type='s' name='problem_id' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='GetProblems'>\"\n  \"      <arg type='as' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='GetAllProblems'>\"\n  \"      <arg type='as' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='GetForeignProblems'>\"\n  \"      <arg type='as' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='GetInfo'>\"\n  \"      <arg type='s' name='problem_dir' direction='in'/>\"\n  \"      <arg type='as' name='element_names' direction='in'/>\"\n  \"      <arg type='a{ss}' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='SetElement'>\"\n  \"      <arg type='s' name='problem_dir' direction='in'/>\"\n  \"      <arg type='s' name='name' direction='in'/>\"\n  \"      <arg type='s' name='value' direction='in'/>\"\n  \"    </method>\"\n  \"    <method name='DeleteElement'>\"\n  \"      <arg type='s' name='problem_dir' direction='in'/>\"\n  \"      <arg type='s' name='name' direction='in'/>\"\n  \"    </method>\"\n  \"    <method name='ChownProblemDir'>\"\n  \"      <arg type='s' name='problem_dir' direction='in'/>\"\n  \"    </method>\"\n  \"    <method name='DeleteProblem'>\"\n  \"      <arg type='as' name='problem_dir' direction='in'/>\"\n  \"    </method>\"\n  \"    <method name='FindProblemByElementInTimeRange'>\"\n  \"      <arg type='s' name='element' direction='in'/>\"\n  \"      <arg type='s' name='value' direction='in'/>\"\n  \"      <arg type='x' name='timestamp_from' direction='in'/>\"\n  \"      <arg type='x' name='timestamp_to' direction='in'/>\"\n  \"      <arg type='b' name='all_users' direction='in'/>\"\n  \"      <arg type='as' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='Quit' />\"\n  \"  </interface>\"\n  \"</node>\";\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* forward */\nstatic gboolean on_timeout_cb(gpointer user_data);\n\nstatic void reset_timeout(void)\n{\n    if (g_timeout_source > 0)\n    {\n        log_info(\"Removing timeout\");\n        g_source_remove(g_timeout_source);\n    }\n    log_info(\"Setting a new timeout\");\n    g_timeout_source = g_timeout_add_seconds(g_timeout_value, on_timeout_cb, NULL);\n}\n\nstatic uid_t get_caller_uid(GDBusConnection *connection, GDBusMethodInvocation *invocation, const char *caller)\n{\n    GError *error = NULL;\n    guint caller_uid;\n\n    GDBusProxy * proxy = g_dbus_proxy_new_sync(connection,\n                                     G_DBUS_PROXY_FLAGS_NONE,\n                                     NULL,\n                                     \"org.freedesktop.DBus\",\n                                     \"/org/freedesktop/DBus\",\n                                     \"org.freedesktop.DBus\",\n                                     NULL,\n                                     &error);\n\n    GVariant *result = g_dbus_proxy_call_sync(proxy,\n                                     \"GetConnectionUnixUser\",\n                                     g_variant_new (\"(s)\", caller),\n                                     G_DBUS_CALL_FLAGS_NONE,\n                                     -1,\n                                     NULL,\n                                     &error);\n\n    if (result == NULL)\n    {\n        /* we failed to get the uid, so return (uid_t) -1 to indicate the error\n         */\n        if (error)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                      \"org.freedesktop.problems.InvalidUser\",\n                                      error->message);\n            g_error_free(error);\n        }\n        else\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                      \"org.freedesktop.problems.InvalidUser\",\n                                      _(\"Unknown error\"));\n        }\n        return (uid_t) -1;\n    }\n\n    g_variant_get(result, \"(u)\", &caller_uid);\n    g_variant_unref(result);\n\n    log_info(\"Caller uid: %i\", caller_uid);\n    return caller_uid;\n}\n\nbool allowed_problem_dir(const char *dir_name)\n{\n    if (!dir_is_in_dump_location(dir_name))\n    {\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dir_name, g_settings_dump_location);\n        return false;\n    }\n\n    /* We cannot test correct permissions yet because we still need to chown\n     * dump directories before reporting and Chowing changes the file owner to\n     * the reporter, which causes this test to fail and prevents users from\n     * getting problem data after reporting it.\n     *\n     * Fortunately, libreport has been hardened against hard link and symbolic\n     * link attacks and refuses to work with such files, so this test isn't\n     * really necessary, however, we will use it once we get rid of the\n     * chowning files.\n     *\n     * abrt-server refuses to run post-create on directories that have\n     * incorrect owner (not \"root:(abrt|root)\"), incorrect permissions (other\n     * bits are not 0) and are complete (post-create finished). So, there is no\n     * way to run security sensitive event scripts (post-create) on crafted\n     * problem directories.\n     */\n#if 0\n    if (!dir_has_correct_permissions(dir_name))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dir_name);\n        return false;\n    }\n#endif\n    return true;\n}\n\nstatic char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    char *problem_id = NULL;\n    problem_data_t *pd = problem_data_new();\n\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"a{ss}\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n    {\n        if (allowed_new_user_problem_entry(caller_uid, key, value) == false)\n        {\n            *error = xasprintf(\"You are not allowed to create element '%s' containing '%s'\", key, value);\n            goto finito;\n        }\n\n        problem_data_add_text_editable(pd, key, value);\n    }\n\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   /* set uid field to caller's uid if caller is not root or root doesn't pass own uid */\n        log_info(\"Adding UID %d to problem data\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"%d\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n\n    /* At least it should generate local problem identifier UUID */\n    problem_data_add_basics(pd);\n\n    problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"Cannot create a new problem\");\n\nfinito:\n    problem_data_free(pd);\n    return problem_id;\n}\n\nstatic void return_InvalidProblemDir_error(GDBusMethodInvocation *invocation, const char *dir_name)\n{\n    char *msg = xasprintf(_(\"'%s' is not a valid problem directory\"), dir_name);\n    g_dbus_method_invocation_return_dbus_error(invocation,\n                                      \"org.freedesktop.problems.InvalidProblemDir\",\n                                      msg);\n\n    free(msg);\n}\n\n/*\n * Checks element's rights and does not open directory if element is protected.\n * Checks problem's rights and does not open directory if user hasn't got\n * access to a problem.\n *\n * Returns a dump directory opend for writing or NULL.\n *\n * If any operation from the above listed fails, immediately returns D-Bus\n * error to a D-Bus caller.\n */\nstatic struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n\n    int dir_fd = dd_openfd(problem_id);\n    if (dir_fd < 0)\n    {\n        perror_msg(\"can't open problem directory '%s'\", problem_id);\n        return_InvalidProblemDir_error(invocation, problem_id);\n        return NULL;\n    }\n\n    if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n\n        close(dir_fd);\n        return NULL;\n    }\n\n    struct dump_dir *dd = dd_fdopendir(dir_fd, problem_id, /* flags : */ 0);\n    if (!dd)\n    {   /* This should not happen because of the access check above */\n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n\n    return dd;\n}\n\n\n/*\n * Lists problems which have given element and were seen in given time interval\n */\n\nstruct field_and_time_range {\n    GList *list;\n    const char *element;\n    const char *value;\n    unsigned long timestamp_from;\n    unsigned long timestamp_to;\n};\n\nstatic int add_dirname_to_GList_if_matches(struct dump_dir *dd, void *arg)\n{\n    struct field_and_time_range *me = arg;\n\n    char *field_data = dd_load_text(dd, me->element);\n    int brk = (strcmp(field_data, me->value) != 0);\n    free(field_data);\n    if (brk)\n        return 0;\n\n    field_data = dd_load_text(dd, FILENAME_LAST_OCCURRENCE);\n    long val = atol(field_data);\n    free(field_data);\n    if (val < me->timestamp_from || val > me->timestamp_to)\n        return 0;\n\n    me->list = g_list_prepend(me->list, xstrdup(dd->dd_dirname));\n    return 0;\n}\n\nstatic GList *get_problem_dirs_for_element_in_time(uid_t uid,\n                const char *element,\n                const char *value,\n                unsigned long timestamp_from,\n                unsigned long timestamp_to)\n{\n    if (timestamp_to == 0) /* not sure this is possible, but... */\n        timestamp_to = time(NULL);\n\n    struct field_and_time_range me = {\n        .list = NULL,\n        .element = element,\n        .value = value,\n        .timestamp_from = timestamp_from,\n        .timestamp_to = timestamp_to,\n    };\n\n    for_each_problem_in_dir(g_settings_dump_location, uid, add_dirname_to_GList_if_matches, &me);\n\n    return g_list_reverse(me.list);\n}\n\n\nstatic void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}\n\nstatic gboolean on_timeout_cb(gpointer user_data)\n{\n    g_main_loop_quit(loop);\n    return TRUE;\n}\n\nstatic const GDBusInterfaceVTable interface_vtable =\n{\n    .method_call = handle_method_call,\n    .get_property = NULL,\n    .set_property = NULL,\n};\n\nstatic void on_bus_acquired(GDBusConnection *connection,\n                 const gchar     *name,\n                 gpointer         user_data)\n{\n    guint registration_id;\n\n    registration_id = g_dbus_connection_register_object(connection,\n                                                       ABRT_DBUS_OBJECT,\n                                                       introspection_data->interfaces[0],\n                                                       &interface_vtable,\n                                                       NULL,  /* user_data */\n                                                       NULL,  /* user_data_free_func */\n                                                       NULL); /* GError** */\n    g_assert(registration_id > 0);\n\n    reset_timeout();\n}\n\n/* not used\nstatic void on_name_acquired (GDBusConnection *connection,\n                  const gchar     *name,\n                  gpointer         user_data)\n{\n}\n*/\n\nstatic void on_name_lost(GDBusConnection *connection,\n                      const gchar *name,\n                      gpointer user_data)\n{\n    g_print(_(\"The name '%s' has been lost, please check if other \"\n              \"service owning the name is not running.\\n\"), name);\n    exit(1);\n}\n\nint main(int argc, char *argv[])\n{\n    /* I18n */\n    setlocale(LC_ALL, \"\");\n#if ENABLE_NLS\n    bindtextdomain(PACKAGE, LOCALEDIR);\n    textdomain(PACKAGE);\n#endif\n    guint owner_id;\n\n    abrt_init(argv);\n\n    const char *program_usage_string = _(\n        \"& [options]\"\n    );\n    enum {\n        OPT_v = 1 << 0,\n        OPT_t = 1 << 1,\n    };\n    /* Keep enum above and order of options below in sync! */\n    struct options program_options[] = {\n        OPT__VERBOSE(&g_verbose),\n        OPT_INTEGER('t', NULL, &g_timeout_value, _(\"Exit after NUM seconds of inactivity\")),\n        OPT_END()\n    };\n    /*unsigned opts =*/ parse_opts(argc, argv, program_options, program_usage_string);\n\n    export_abrt_envvars(0);\n\n    /* When dbus daemon starts us, it doesn't set PATH\n     * (I saw it set only DBUS_STARTER_ADDRESS and DBUS_STARTER_BUS_TYPE).\n     * In this case, set something sane:\n     */\n    const char *env_path = getenv(\"PATH\");\n    if (!env_path || !env_path[0])\n        putenv((char*)\"PATH=/usr/sbin:/usr/bin:/sbin:/bin\");\n\n    msg_prefix = \"abrt-dbus\"; /* for log(), error_msg() and such */\n\n    if (getuid() != 0)\n        error_msg_and_die(_(\"This program must be run as root.\"));\n\n    glib_init();\n\n    /* We are lazy here - we don't want to manually provide\n    * the introspection data structures - so we just build\n    * them from XML.\n    */\n    introspection_data = g_dbus_node_info_new_for_xml(introspection_xml, NULL);\n    g_assert(introspection_data != NULL);\n\n    owner_id = g_bus_own_name(G_BUS_TYPE_SYSTEM,\n                             ABRT_DBUS_NAME,\n                             G_BUS_NAME_OWNER_FLAGS_NONE,\n                             on_bus_acquired,\n                             NULL,\n                             on_name_lost,\n                             NULL,\n                             NULL);\n\n    /* initialize the g_settings_dump_location */\n    load_abrt_conf();\n\n    loop = g_main_loop_new(NULL, FALSE);\n    g_main_loop_run(loop);\n\n    log_notice(\"Cleaning up\");\n\n    g_bus_unown_name(owner_id);\n\n    g_dbus_node_info_unref(introspection_data);\n\n    free_abrt_conf_data();\n\n    return 0;\n}\n"], "fixing_code": ["#include <gio/gio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#include \"libabrt.h\"\n#include \"abrt-polkit.h\"\n#include \"abrt_glib.h\"\n#include <libreport/dump_dir.h>\n#include \"problem_api.h\"\n\nstatic GMainLoop *loop;\nstatic guint g_timeout_source;\n/* default, settable with -t: */\nstatic unsigned g_timeout_value = 120;\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic GDBusNodeInfo *introspection_data = NULL;\n\n/* Introspection data for the service we are exporting */\nstatic const gchar introspection_xml[] =\n  \"<node>\"\n  \"  <interface name='\"ABRT_DBUS_IFACE\"'>\"\n  \"    <method name='NewProblem'>\"\n  \"      <arg type='a{ss}' name='problem_data' direction='in'/>\"\n  \"      <arg type='s' name='problem_id' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='GetProblems'>\"\n  \"      <arg type='as' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='GetAllProblems'>\"\n  \"      <arg type='as' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='GetForeignProblems'>\"\n  \"      <arg type='as' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='GetInfo'>\"\n  \"      <arg type='s' name='problem_dir' direction='in'/>\"\n  \"      <arg type='as' name='element_names' direction='in'/>\"\n  \"      <arg type='a{ss}' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='SetElement'>\"\n  \"      <arg type='s' name='problem_dir' direction='in'/>\"\n  \"      <arg type='s' name='name' direction='in'/>\"\n  \"      <arg type='s' name='value' direction='in'/>\"\n  \"    </method>\"\n  \"    <method name='DeleteElement'>\"\n  \"      <arg type='s' name='problem_dir' direction='in'/>\"\n  \"      <arg type='s' name='name' direction='in'/>\"\n  \"    </method>\"\n  \"    <method name='ChownProblemDir'>\"\n  \"      <arg type='s' name='problem_dir' direction='in'/>\"\n  \"    </method>\"\n  \"    <method name='DeleteProblem'>\"\n  \"      <arg type='as' name='problem_dir' direction='in'/>\"\n  \"    </method>\"\n  \"    <method name='FindProblemByElementInTimeRange'>\"\n  \"      <arg type='s' name='element' direction='in'/>\"\n  \"      <arg type='s' name='value' direction='in'/>\"\n  \"      <arg type='x' name='timestamp_from' direction='in'/>\"\n  \"      <arg type='x' name='timestamp_to' direction='in'/>\"\n  \"      <arg type='b' name='all_users' direction='in'/>\"\n  \"      <arg type='as' name='response' direction='out'/>\"\n  \"    </method>\"\n  \"    <method name='Quit' />\"\n  \"  </interface>\"\n  \"</node>\";\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* forward */\nstatic gboolean on_timeout_cb(gpointer user_data);\n\nstatic void reset_timeout(void)\n{\n    if (g_timeout_source > 0)\n    {\n        log_info(\"Removing timeout\");\n        g_source_remove(g_timeout_source);\n    }\n    log_info(\"Setting a new timeout\");\n    g_timeout_source = g_timeout_add_seconds(g_timeout_value, on_timeout_cb, NULL);\n}\n\nstatic uid_t get_caller_uid(GDBusConnection *connection, GDBusMethodInvocation *invocation, const char *caller)\n{\n    GError *error = NULL;\n    guint caller_uid;\n\n    GDBusProxy * proxy = g_dbus_proxy_new_sync(connection,\n                                     G_DBUS_PROXY_FLAGS_NONE,\n                                     NULL,\n                                     \"org.freedesktop.DBus\",\n                                     \"/org/freedesktop/DBus\",\n                                     \"org.freedesktop.DBus\",\n                                     NULL,\n                                     &error);\n\n    GVariant *result = g_dbus_proxy_call_sync(proxy,\n                                     \"GetConnectionUnixUser\",\n                                     g_variant_new (\"(s)\", caller),\n                                     G_DBUS_CALL_FLAGS_NONE,\n                                     -1,\n                                     NULL,\n                                     &error);\n\n    if (result == NULL)\n    {\n        /* we failed to get the uid, so return (uid_t) -1 to indicate the error\n         */\n        if (error)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                      \"org.freedesktop.problems.InvalidUser\",\n                                      error->message);\n            g_error_free(error);\n        }\n        else\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                      \"org.freedesktop.problems.InvalidUser\",\n                                      _(\"Unknown error\"));\n        }\n        return (uid_t) -1;\n    }\n\n    g_variant_get(result, \"(u)\", &caller_uid);\n    g_variant_unref(result);\n\n    log_info(\"Caller uid: %i\", caller_uid);\n    return caller_uid;\n}\n\nbool allowed_problem_dir(const char *dir_name)\n{\n    if (!dir_is_in_dump_location(dir_name))\n    {\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dir_name, g_settings_dump_location);\n        return false;\n    }\n\n    /* We cannot test correct permissions yet because we still need to chown\n     * dump directories before reporting and Chowing changes the file owner to\n     * the reporter, which causes this test to fail and prevents users from\n     * getting problem data after reporting it.\n     *\n     * Fortunately, libreport has been hardened against hard link and symbolic\n     * link attacks and refuses to work with such files, so this test isn't\n     * really necessary, however, we will use it once we get rid of the\n     * chowning files.\n     *\n     * abrt-server refuses to run post-create on directories that have\n     * incorrect owner (not \"root:(abrt|root)\"), incorrect permissions (other\n     * bits are not 0) and are complete (post-create finished). So, there is no\n     * way to run security sensitive event scripts (post-create) on crafted\n     * problem directories.\n     */\n#if 0\n    if (!dir_has_correct_permissions(dir_name))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dir_name);\n        return false;\n    }\n#endif\n    return true;\n}\n\nstatic char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    char *problem_id = NULL;\n    problem_data_t *pd = problem_data_new();\n\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"a{ss}\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n    {\n        if (allowed_new_user_problem_entry(caller_uid, key, value) == false)\n        {\n            *error = xasprintf(\"You are not allowed to create element '%s' containing '%s'\", key, value);\n            goto finito;\n        }\n\n        problem_data_add_text_editable(pd, key, value);\n    }\n\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   /* set uid field to caller's uid if caller is not root or root doesn't pass own uid */\n        log_info(\"Adding UID %d to problem data\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"%d\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n\n    /* At least it should generate local problem identifier UUID */\n    problem_data_add_basics(pd);\n\n    problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"Cannot create a new problem\");\n\nfinito:\n    problem_data_free(pd);\n    return problem_id;\n}\n\nstatic void return_InvalidProblemDir_error(GDBusMethodInvocation *invocation, const char *dir_name)\n{\n    char *msg = xasprintf(_(\"'%s' is not a valid problem directory\"), dir_name);\n    g_dbus_method_invocation_return_dbus_error(invocation,\n                                      \"org.freedesktop.problems.InvalidProblemDir\",\n                                      msg);\n\n    free(msg);\n}\n\n/*\n * Checks element's rights and does not open directory if element is protected.\n * Checks problem's rights and does not open directory if user hasn't got\n * access to a problem.\n *\n * Returns a dump directory opend for writing or NULL.\n *\n * If any operation from the above listed fails, immediately returns D-Bus\n * error to a D-Bus caller.\n */\nstatic struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n\n    int dir_fd = dd_openfd(problem_id);\n    if (dir_fd < 0)\n    {\n        perror_msg(\"can't open problem directory '%s'\", problem_id);\n        return_InvalidProblemDir_error(invocation, problem_id);\n        return NULL;\n    }\n\n    if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n\n        close(dir_fd);\n        return NULL;\n    }\n\n    struct dump_dir *dd = dd_fdopendir(dir_fd, problem_id, /* flags : */ 0);\n    if (!dd)\n    {   /* This should not happen because of the access check above */\n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n\n    return dd;\n}\n\n\n/*\n * Lists problems which have given element and were seen in given time interval\n */\n\nstruct field_and_time_range {\n    GList *list;\n    const char *element;\n    const char *value;\n    unsigned long timestamp_from;\n    unsigned long timestamp_to;\n};\n\nstatic int add_dirname_to_GList_if_matches(struct dump_dir *dd, void *arg)\n{\n    struct field_and_time_range *me = arg;\n\n    char *field_data = dd_load_text(dd, me->element);\n    int brk = (strcmp(field_data, me->value) != 0);\n    free(field_data);\n    if (brk)\n        return 0;\n\n    field_data = dd_load_text(dd, FILENAME_LAST_OCCURRENCE);\n    long val = atol(field_data);\n    free(field_data);\n    if (val < me->timestamp_from || val > me->timestamp_to)\n        return 0;\n\n    me->list = g_list_prepend(me->list, xstrdup(dd->dd_dirname));\n    return 0;\n}\n\nstatic GList *get_problem_dirs_for_element_in_time(uid_t uid,\n                const char *element,\n                const char *value,\n                unsigned long timestamp_from,\n                unsigned long timestamp_to)\n{\n    if (timestamp_to == 0) /* not sure this is possible, but... */\n        timestamp_to = time(NULL);\n\n    struct field_and_time_range me = {\n        .list = NULL,\n        .element = element,\n        .value = value,\n        .timestamp_from = timestamp_from,\n        .timestamp_to = timestamp_to,\n    };\n\n    for_each_problem_in_dir(g_settings_dump_location, uid, add_dirname_to_GList_if_matches, &me);\n\n    return g_list_reverse(me.list);\n}\n\n\nstatic void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name\", element);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}\n\nstatic gboolean on_timeout_cb(gpointer user_data)\n{\n    g_main_loop_quit(loop);\n    return TRUE;\n}\n\nstatic const GDBusInterfaceVTable interface_vtable =\n{\n    .method_call = handle_method_call,\n    .get_property = NULL,\n    .set_property = NULL,\n};\n\nstatic void on_bus_acquired(GDBusConnection *connection,\n                 const gchar     *name,\n                 gpointer         user_data)\n{\n    guint registration_id;\n\n    registration_id = g_dbus_connection_register_object(connection,\n                                                       ABRT_DBUS_OBJECT,\n                                                       introspection_data->interfaces[0],\n                                                       &interface_vtable,\n                                                       NULL,  /* user_data */\n                                                       NULL,  /* user_data_free_func */\n                                                       NULL); /* GError** */\n    g_assert(registration_id > 0);\n\n    reset_timeout();\n}\n\n/* not used\nstatic void on_name_acquired (GDBusConnection *connection,\n                  const gchar     *name,\n                  gpointer         user_data)\n{\n}\n*/\n\nstatic void on_name_lost(GDBusConnection *connection,\n                      const gchar *name,\n                      gpointer user_data)\n{\n    g_print(_(\"The name '%s' has been lost, please check if other \"\n              \"service owning the name is not running.\\n\"), name);\n    exit(1);\n}\n\nint main(int argc, char *argv[])\n{\n    /* I18n */\n    setlocale(LC_ALL, \"\");\n#if ENABLE_NLS\n    bindtextdomain(PACKAGE, LOCALEDIR);\n    textdomain(PACKAGE);\n#endif\n    guint owner_id;\n\n    abrt_init(argv);\n\n    const char *program_usage_string = _(\n        \"& [options]\"\n    );\n    enum {\n        OPT_v = 1 << 0,\n        OPT_t = 1 << 1,\n    };\n    /* Keep enum above and order of options below in sync! */\n    struct options program_options[] = {\n        OPT__VERBOSE(&g_verbose),\n        OPT_INTEGER('t', NULL, &g_timeout_value, _(\"Exit after NUM seconds of inactivity\")),\n        OPT_END()\n    };\n    /*unsigned opts =*/ parse_opts(argc, argv, program_options, program_usage_string);\n\n    export_abrt_envvars(0);\n\n    /* When dbus daemon starts us, it doesn't set PATH\n     * (I saw it set only DBUS_STARTER_ADDRESS and DBUS_STARTER_BUS_TYPE).\n     * In this case, set something sane:\n     */\n    const char *env_path = getenv(\"PATH\");\n    if (!env_path || !env_path[0])\n        putenv((char*)\"PATH=/usr/sbin:/usr/bin:/sbin:/bin\");\n\n    msg_prefix = \"abrt-dbus\"; /* for log(), error_msg() and such */\n\n    if (getuid() != 0)\n        error_msg_and_die(_(\"This program must be run as root.\"));\n\n    glib_init();\n\n    /* We are lazy here - we don't want to manually provide\n    * the introspection data structures - so we just build\n    * them from XML.\n    */\n    introspection_data = g_dbus_node_info_new_for_xml(introspection_xml, NULL);\n    g_assert(introspection_data != NULL);\n\n    owner_id = g_bus_own_name(G_BUS_TYPE_SYSTEM,\n                             ABRT_DBUS_NAME,\n                             G_BUS_NAME_OWNER_FLAGS_NONE,\n                             on_bus_acquired,\n                             NULL,\n                             on_name_lost,\n                             NULL,\n                             NULL);\n\n    /* initialize the g_settings_dump_location */\n    load_abrt_conf();\n\n    loop = g_main_loop_new(NULL, FALSE);\n    g_main_loop_run(loop);\n\n    log_notice(\"Cleaning up\");\n\n    g_bus_unown_name(owner_id);\n\n    g_dbus_node_info_unref(introspection_data);\n\n    free_abrt_conf_data();\n\n    return 0;\n}\n"], "filenames": ["src/dbus/abrt-dbus.c"], "buggy_code_start_loc": [609], "buggy_code_end_loc": [784], "fixing_code_start_loc": [610], "fixing_code_end_loc": [809], "type": "CWE-22", "message": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.", "other": {"cve": {"id": "CVE-2015-3151", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-14T18:15:10.773", "lastModified": "2023-02-13T00:47:45.943", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method."}, {"lang": "es", "value": "Una vulnerabilidad de salto de directorio en abrt-dbus en Automatic Bug Reporting Tool (ABRT), permite a usuarios locales leer, escribir o cambiar la propiedad de archivos arbitrarios por medio de vectores no especificados en el m\u00e9todo (1) NewProblem, (2) GetInfo, (3) SetElement, o (4) DeleteElement."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:automatic_bug_reporting_tool:-:*:*:*:*:*:*:*", "matchCriteriaId": "A396CA2B-75FF-4BEE-8C0A-89B7C030D1E5"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2015-3151", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/7a47f57975be0d285a2f20758e4572dca6d9cdd3", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/c796c76341ee846cfb897ed645bac211d7d0a932", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/f3c2a6af3455b2882e28570e8a04f1c2d4500d5b", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/libreport/commit/54ecf8d017580b495d6501e53ca54e453a73a364", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/abrt/abrt/commit/7a47f57975be0d285a2f20758e4572dca6d9cdd3"}}