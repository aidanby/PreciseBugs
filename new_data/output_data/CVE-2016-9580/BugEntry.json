{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2015, Matthieu Darbois\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#ifndef OPJ_HAVE_LIBTIFF\n# error OPJ_HAVE_LIBTIFF_NOT_DEFINED\n#endif /* OPJ_HAVE_LIBTIFF */\n\n#include <tiffio.h>\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\n/* -->> -->> -->> -->>\n \n TIFF IMAGE FORMAT\n \n <<-- <<-- <<-- <<-- */\n#define PUTBITS2(s, nb) \\\n\ttrailing <<= remaining; \\\n\ttrailing |= (unsigned int)((s) >> (nb - remaining)); \\\n\t*pDst++ = (OPJ_BYTE)trailing; \\\n\ttrailing = (unsigned int)((s) & ((1U << (nb - remaining)) - 1U)); \\\n\tif (nb >= (remaining + 8)) { \\\n\t\t*pDst++ = (OPJ_BYTE)(trailing >> (nb - (remaining + 8))); \\\n\t\ttrailing &= (unsigned int)((1U << (nb - (remaining + 8))) - 1U); \\\n\t\tremaining += 16 - nb; \\\n\t} else { \\\n\t\tremaining += 8 - nb; \\\n\t}\n\n#define PUTBITS(s, nb) \\\n  if (nb >= remaining) { \\\n\t\tPUTBITS2(s, nb) \\\n\t} else { \\\n\t\ttrailing <<= nb; \\\n\t\ttrailing |= (unsigned int)(s); \\\n\t\tremaining -= nb; \\\n\t}\n#define FLUSHBITS() \\\n\tif (remaining != 8) { \\\n\t\ttrailing <<= remaining; \\\n\t\t*pDst++ = (OPJ_BYTE)trailing; \\\n\t}\n\nstatic void tif_32sto3u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 5) | (src1 << 2) | (src2 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 7) | (src3 << 4) | (src4 << 1) | (src5 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 6) | (src6 << 3) | (src7));\n\t}\n\t\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS((OPJ_UINT32)pSrc[i+0], 3)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+1], 3)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+2], 3)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+3], 3)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+4], 3)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+5], 3)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+6], 3)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\n\nstatic void tif_32sto5u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 3) | (src1 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 6) | (src2 << 1) | (src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 7) | (src5 << 2) | (src6 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 5) | (src7));\n\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS((OPJ_UINT32)pSrc[i+0], 5)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+1], 5)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+2], 5)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+3], 5)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+4], 5)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+5], 5)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+6], 5)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\n\nstatic void tif_32sto7u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 1) | (src1 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 2) | (src2 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 3) | (src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 5) | (src5 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 6) | (src6 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 7) | (src7));\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS((OPJ_UINT32)pSrc[i+0], 7)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+1], 7)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+2], 7)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+3], 7)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+4], 7)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+5], 7)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+6], 7)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\n\nstatic void tif_32sto9u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 6) | (src2 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 5) | (src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 3) | (src5 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 2) | (src6 >> 7));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 1) | (src7 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS2((OPJ_UINT32)pSrc[i+0], 9)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+1], 9)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+2], 9)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+3], 9)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+4], 9)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+5], 9)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+6], 9)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\n\nstatic void tif_32sto10u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 2);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0x3U) << 6) | (src1 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3FU) << 2) | (src3 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src3);\n\t}\n\t\n\tif (length & 3U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tlength = length & 3U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 2);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0x3U) << 6) | (src1 >> 4));\n\t\tif (length > 1U) {\n\t\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 6));\n\t\t\tif (length > 2U) {\n\t\t\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3FU) << 2));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_32sto11u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 5) | (src1 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 2) | (src2 >> 9));\n\t\t*pDst++ = (OPJ_BYTE)((src2 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 7) | (src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 7));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 1) | (src5 >> 10));\n\t\t*pDst++ = (OPJ_BYTE)((src5 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 6) | (src6 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 3) | (src7 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS2((OPJ_UINT32)pSrc[i+0], 11)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+1], 11)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+2], 11)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+3], 11)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+4], 11)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+5], 11)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+6], 11)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\nstatic void tif_32sto12u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i+=2U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 4);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0xFU) << 4) | (src1 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src1);\n\t}\n\t\n\tif (length & 1U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 4);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0xFU) << 4));\n\t}\n}\nstatic void tif_32sto13u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 3) | (src1 >> 10));\n\t\t*pDst++ = (OPJ_BYTE)((src1 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 6) | (src2 >> 7));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 1) | (src3 >> 12));\n\t\t*pDst++ = (OPJ_BYTE)((src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 9));\n\t\t*pDst++ = (OPJ_BYTE)((src4 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 7) | (src5 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 2) | (src6 >> 11));\n\t\t*pDst++ = (OPJ_BYTE)((src6 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 5) | (src7 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS2((OPJ_UINT32)pSrc[i+0], 13)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+1], 13)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+2], 13)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+3], 13)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+4], 13)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+5], 13)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+6], 13)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\nstatic void tif_32sto14u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 6);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0x3FU) << 2) | (src1 >> 12));\n\t\t*pDst++ = (OPJ_BYTE)(src1 >> 4);\n\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 10));\n\t\t*pDst++ = (OPJ_BYTE)(src2 >> 2);\n\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6) | (src3 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src3);\n\t}\n\t\n\tif (length & 3U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tlength = length & 3U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 6);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0x3FU) << 2) | (src1 >> 12));\n\t\tif (length > 1U) {\n\t\t\t*pDst++ = (OPJ_BYTE)(src1 >> 4);\n\t\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 10));\n\t\t\tif (length > 2U) {\n\t\t\t\t*pDst++ = (OPJ_BYTE)(src2 >> 2);\n\t\t\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_32sto15u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 >> 7));\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 1) | (src1 >> 14));\n\t\t*pDst++ = (OPJ_BYTE)((src1 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 2) | (src2 >> 13));\n\t\t*pDst++ = (OPJ_BYTE)((src2 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 3) | (src3 >> 12));\n\t\t*pDst++ = (OPJ_BYTE)((src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 11));\n\t\t*pDst++ = (OPJ_BYTE)((src4 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 5) | (src5 >> 10));\n\t\t*pDst++ = (OPJ_BYTE)((src5 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 6) | (src6 >> 9));\n\t\t*pDst++ = (OPJ_BYTE)((src6 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 7) | (src7 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS2((OPJ_UINT32)pSrc[i+0], 15)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+1], 15)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+2], 15)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+3], 15)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+4], 15)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+5], 15)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+6], 15)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\nstatic void tif_32sto16u(const OPJ_INT32* pSrc, OPJ_UINT16* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < length; ++i) {\n\t\tpDst[i] = (OPJ_UINT16)pSrc[i];\n\t}\n}\n\nint imagetotif(opj_image_t * image, const char *outfile)\n{\n\tint width, height;\n\tint bps,adjust, sgnd;\n\tint tiPhoto;\n\tTIFF *tif;\n\ttdata_t buf;\n\ttsize_t strip_size;\n\tOPJ_UINT32 i, numcomps;\n\tOPJ_SIZE_T rowStride;\n\tOPJ_INT32* buffer32s = NULL;\n\tOPJ_INT32 const* planes[4];\n\tconvert_32s_PXCX cvtPxToCx = NULL;\n\tconvert_32sXXx_C1R cvt32sToTif = NULL;\n\n\tbps = (int)image->comps[0].prec;\n\tplanes[0] = image->comps[0].data;\n\t\n\tnumcomps = image->numcomps;\n\t\n\tif (image->color_space == OPJ_CLRSPC_CMYK) {\n\t\tif (numcomps < 4U) {\n\t\t\tfprintf(stderr,\"imagetotif: CMYK images shall be composed of at least 4 planes.\\n\");\n\t\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\ttiPhoto = PHOTOMETRIC_SEPARATED;\n\t\tif (numcomps > 4U) {\n\t\t\tnumcomps = 4U; /* Alpha not supported */\n\t\t}\n\t}\n\telse if (numcomps > 2U) {\n\t\ttiPhoto = PHOTOMETRIC_RGB;\n\t\tif (numcomps > 4U) {\n\t\t\tnumcomps = 4U;\n\t\t}\n\t} else {\n\t\ttiPhoto = PHOTOMETRIC_MINISBLACK;\n\t}\n\tfor (i = 1U; i < numcomps; ++i) {\n\t\tif (image->comps[0].dx != image->comps[i].dx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (image->comps[0].dy != image->comps[i].dy) {\n\t\t\tbreak;\n\t\t}\n\t\tif (image->comps[0].prec != image->comps[i].prec) {\n\t\t\tbreak;\n\t\t}\n\t\tif (image->comps[0].sgnd != image->comps[i].sgnd) {\n\t\t\tbreak;\n\t\t}\n\t\tplanes[i] = image->comps[i].data;\n\t}\n\tif (i != numcomps) {\n\t\tfprintf(stderr,\"imagetotif: All components shall have the same subsampling, same bit depth.\\n\");\n\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\treturn 1;\n\t}\n\t\n\tif(bps > 16) bps = 0;\n\tif(bps == 0)\n\t{\n\t\tfprintf(stderr,\"imagetotif: Bits=%d, Only 1 to 16 bits implemented\\n\",bps);\n\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\treturn 1;\n\t}\n\ttif = TIFFOpen(outfile, \"wb\");\n\tif (!tif)\n\t{\n\t\tfprintf(stderr, \"imagetotif:failed to open %s for writing\\n\", outfile);\n\t\treturn 1;\n\t}\n\tfor (i = 0U; i < numcomps; ++i) {\n\t\tclip_component(&(image->comps[i]), image->comps[0].prec);\n\t}\n\tcvtPxToCx = convert_32s_PXCX_LUT[numcomps];\n\tswitch (bps) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 6:\n\t\tcase 8:\n\t\t\tcvt32sToTif = convert_32sXXu_C1R_LUT[bps];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcvt32sToTif = tif_32sto3u;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcvt32sToTif = tif_32sto5u;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcvt32sToTif = tif_32sto7u;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tcvt32sToTif = tif_32sto9u;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tcvt32sToTif = tif_32sto10u;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tcvt32sToTif = tif_32sto11u;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tcvt32sToTif = tif_32sto12u;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tcvt32sToTif = tif_32sto13u;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tcvt32sToTif = tif_32sto14u;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tcvt32sToTif = tif_32sto15u;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tcvt32sToTif = (convert_32sXXx_C1R)tif_32sto16u;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* never here */\n\t\t\tbreak;\n\t}\n\tsgnd = (int)image->comps[0].sgnd;\n\tadjust = sgnd ? 1 << (image->comps[0].prec - 1) : 0;\n\twidth   = (int)image->comps[0].w;\n\theight  = (int)image->comps[0].h;\n\t\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, numcomps);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);\n\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, tiPhoto);\n\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n\t\n\tstrip_size = TIFFStripSize(tif);\n\trowStride = ((OPJ_SIZE_T)width * numcomps * (OPJ_SIZE_T)bps + 7U) / 8U;\n\tif (rowStride != (OPJ_SIZE_T)strip_size) {\n\t\tfprintf(stderr, \"Invalid TIFF strip size\\n\");\n\t\tTIFFClose(tif);\n\t\treturn 1;\n\t}\n\tbuf = _TIFFmalloc(strip_size);\n\tif (buf == NULL) {\n\t\tTIFFClose(tif);\n\t\treturn 1;\n\t}\n\tbuffer32s = (OPJ_INT32 *)malloc((OPJ_SIZE_T)width * numcomps * sizeof(OPJ_INT32));\n\tif (buffer32s == NULL) {\n\t\t_TIFFfree(buf);\n\t\tTIFFClose(tif);\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < image->comps[0].h; ++i) {\n\t\tcvtPxToCx(planes, buffer32s, (OPJ_SIZE_T)width, adjust);\n\t\tcvt32sToTif(buffer32s, (OPJ_BYTE *)buf, (OPJ_SIZE_T)width * numcomps);\n\t\t(void)TIFFWriteEncodedStrip(tif, i, (void*)buf, strip_size);\n\t\tplanes[0] += width;\n\t\tplanes[1] += width;\n\t\tplanes[2] += width;\n\t\tplanes[3] += width;\n\t}\n\t_TIFFfree((void*)buf);\n\tTIFFClose(tif);\n\tfree(buffer32s);\n\t\t\n\treturn 0;\n}/* imagetotif() */\n\n#define GETBITS(dest, nb) { \\\n\tint needed = (nb); \\\n\tunsigned int dst = 0U; \\\n\tif (available == 0) { \\\n\t\tval = *pSrc++; \\\n\t\tavailable = 8; \\\n\t} \\\n\twhile (needed > available) { \\\n\t\tdst |= val & ((1U << available) - 1U); \\\n\t\tneeded -= available; \\\n\t\tdst <<= needed; \\\n\t\tval = *pSrc++; \\\n\t\tavailable = 8; \\\n\t} \\\n\tdst |= (val >> (available - needed)) & ((1U << needed) - 1U); \\\n\tavailable -= needed; \\\n\tdest = (OPJ_INT32)dst; \\\n}\n\nstatic void tif_3uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 >> 5));\n\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x1FU) >> 2));\n\t\tpDst[i+2] = (OPJ_INT32)(((val0 & 0x3U) << 1) | (val1 >> 7));\n\t\tpDst[i+3] = (OPJ_INT32)(((val1 & 0x7FU) >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val1 & 0xFU) >> 1));\n\t\tpDst[i+5] = (OPJ_INT32)(((val1 & 0x1U) << 2) | (val2 >> 6));\n\t\tpDst[i+6] = (OPJ_INT32)(((val2 & 0x3FU) >> 3));\n\t\tpDst[i+7] = (OPJ_INT32)(((val2 & 0x7U)));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 3)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 3)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 3)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 3)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 3)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 3)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 3)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_5uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 >> 3));\n\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x7U) << 2) | (val1 >> 6));\n\t\tpDst[i+2] = (OPJ_INT32)(((val1 & 0x3FU) >> 1));\n\t\tpDst[i+3] = (OPJ_INT32)(((val1 & 0x1U) << 4) | (val2 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val2 & 0xFU) << 1) | (val3 >> 7));\n\t\tpDst[i+5] = (OPJ_INT32)(((val3 & 0x7FU) >> 2));\n\t\tpDst[i+6] = (OPJ_INT32)(((val3 & 0x3U) << 3) | (val4 >> 5));\n\t\tpDst[i+7] = (OPJ_INT32)(((val4 & 0x1FU)));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 5)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 5)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 5)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 5)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 5)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 5)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 5)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_7uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 >> 1));\n\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x1U) << 6) | (val1 >> 2));\n\t\tpDst[i+2] = (OPJ_INT32)(((val1 & 0x3U) << 5) | (val2 >> 3));\n\t\tpDst[i+3] = (OPJ_INT32)(((val2 & 0x7U) << 4) | (val3 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val3 & 0xFU) << 3) | (val4 >> 5));\n\t\tpDst[i+5] = (OPJ_INT32)(((val4 & 0x1FU) << 2) | (val5 >> 6));\n\t\tpDst[i+6] = (OPJ_INT32)(((val5 & 0x3FU) << 1) | (val6 >> 7));\n\t\tpDst[i+7] = (OPJ_INT32)(((val6 & 0x7FU)));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 7)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 7)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 7)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 7)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 7)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 7)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 7)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_9uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\tOPJ_UINT32 val7 = *pSrc++;\n\t\tOPJ_UINT32 val8 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 1) | (val1 >> 7));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x7FU) << 2) | (val2 >> 6));\n\t\tpDst[i+2] = (OPJ_INT32)(((val2 & 0x3FU) << 3) | (val3 >> 5));\n\t\tpDst[i+3] = (OPJ_INT32)(((val3 & 0x1FU) << 4) | (val4 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val4 & 0xFU) << 5) | (val5 >> 3));\n\t\tpDst[i+5] = (OPJ_INT32)(((val5 & 0x7U) << 6) | (val6 >> 2));\n\t\tpDst[i+6] = (OPJ_INT32)(((val6 & 0x3U) << 7) | (val7 >> 1));\n\t\tpDst[i+7] = (OPJ_INT32)(((val7 & 0x1U) << 8) | (val8));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 9)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 9)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 9)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 9)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 9)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 9)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 9)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_10uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 2) | (val1 >> 6));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x3FU) << 4) | (val2 >> 4));\n\t\tpDst[i+2] = (OPJ_INT32)(((val2 & 0xFU) << 6) | (val3 >> 2));\n\t\tpDst[i+3] = (OPJ_INT32)(((val3 & 0x3U) << 8) | val4);\n\t\t\n\t}\n\tif (length & 3U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tlength = length & 3U;\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 2) | (val1 >> 6));\n\t\t\n\t\tif (length > 1U) {\n\t\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x3FU) << 4) | (val2 >> 4));\n\t\t\tif (length > 2U) {\n\t\t\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\t\t\tpDst[i+2] = (OPJ_INT32)(((val2 & 0xFU) << 6) | (val3 >> 2));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_11uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\tOPJ_UINT32 val7 = *pSrc++;\n\t\tOPJ_UINT32 val8 = *pSrc++;\n\t\tOPJ_UINT32 val9 = *pSrc++;\n\t\tOPJ_UINT32 val10 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 3) | (val1 >> 5));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x1FU) << 6) | (val2 >> 2));\n\t\tpDst[i+2] = (OPJ_INT32)(((val2 & 0x3U) << 9) | (val3 << 1) | (val4 >> 7));\n\t\tpDst[i+3] = (OPJ_INT32)(((val4 & 0x7FU) << 4) | (val5 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val5 & 0xFU) << 7) | (val6 >> 1));\n\t\tpDst[i+5] = (OPJ_INT32)(((val6 & 0x1U) << 10) | (val7 << 2) | (val8 >> 6));\n\t\tpDst[i+6] = (OPJ_INT32)(((val8 & 0x3FU) << 5) | (val9 >> 3));\n\t\tpDst[i+7] = (OPJ_INT32)(((val9 & 0x7U) << 8) | (val10));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 11)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 11)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 11)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 11)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 11)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 11)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 11)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_12uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i+=2U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 4) | (val1 >> 4));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0xFU) << 8) | val2);\n\t}\n\tif (length & 1U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 4) | (val1 >> 4));\n\t}\n}\nstatic void tif_13uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\tOPJ_UINT32 val7 = *pSrc++;\n\t\tOPJ_UINT32 val8 = *pSrc++;\n\t\tOPJ_UINT32 val9 = *pSrc++;\n\t\tOPJ_UINT32 val10 = *pSrc++;\n\t\tOPJ_UINT32 val11 = *pSrc++;\n\t\tOPJ_UINT32 val12 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 5) | (val1 >> 3));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x7U) << 10) | (val2 << 2) | (val3 >> 6));\n\t\tpDst[i+2] = (OPJ_INT32)(((val3 & 0x3FU) << 7) | (val4 >> 1));\n\t\tpDst[i+3] = (OPJ_INT32)(((val4 & 0x1U) << 12) | (val5 << 4) | (val6 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val6 & 0xFU) << 9) | (val7 << 1) | (val8 >> 7));\n\t\tpDst[i+5] = (OPJ_INT32)(((val8 & 0x7FU) << 6) | (val9 >> 2));\n\t\tpDst[i+6] = (OPJ_INT32)(((val9 & 0x3U) << 11) | (val10 << 3) | (val11 >> 5));\n\t\tpDst[i+7] = (OPJ_INT32)(((val11 & 0x1FU) << 8) | (val12));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 13)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 13)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 13)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 13)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 13)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 13)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 13)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_14uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 6) | (val1 >> 2));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x3U) << 12) | (val2 << 4) | (val3 >> 4));\n\t\tpDst[i+2] = (OPJ_INT32)(((val3 & 0xFU) << 10) | (val4 << 2) | (val5 >> 6));\n\t\tpDst[i+3] = (OPJ_INT32)(((val5 & 0x3FU) << 8) | val6);\n\t\t\n\t}\n\tif (length & 3U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tlength = length & 3U;\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 6) | (val1 >> 2));\n\t\t\n\t\tif (length > 1U) {\n\t\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x3U) << 12) | (val2 << 4) | (val3 >> 4));\n\t\t\tif (length > 2U) {\n\t\t\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\t\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\t\t\tpDst[i+2] = (OPJ_INT32)(((val3 & 0xFU) << 10) | (val4 << 2) | (val5 >> 6));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_15uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\tOPJ_UINT32 val7 = *pSrc++;\n\t\tOPJ_UINT32 val8 = *pSrc++;\n\t\tOPJ_UINT32 val9 = *pSrc++;\n\t\tOPJ_UINT32 val10 = *pSrc++;\n\t\tOPJ_UINT32 val11 = *pSrc++;\n\t\tOPJ_UINT32 val12 = *pSrc++;\n\t\tOPJ_UINT32 val13 = *pSrc++;\n\t\tOPJ_UINT32 val14 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 7) | (val1 >> 1));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x1U) << 14) | (val2 << 6) | (val3 >> 2));\n\t\tpDst[i+2] = (OPJ_INT32)(((val3 & 0x3U) << 13) | (val4 << 5) | (val5 >> 3));\n\t\tpDst[i+3] = (OPJ_INT32)(((val5 & 0x7U) << 12) | (val6 << 4) | (val7 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val7 & 0xFU) << 11) | (val8 << 3) | (val9 >> 5));\n\t\tpDst[i+5] = (OPJ_INT32)(((val9 & 0x1FU) << 10) | (val10 << 2) | (val11 >> 6));\n\t\tpDst[i+6] = (OPJ_INT32)(((val11 & 0x3FU) << 9) | (val12 << 1) | (val13 >> 7));\n\t\tpDst[i+7] = (OPJ_INT32)(((val13 & 0x7FU) << 8) | (val14));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 15)\n\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 15)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 15)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 15)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 15)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 15)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 15)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* seems that libtiff decodes this to machine endianness */\nstatic void tif_16uto32s(const OPJ_UINT16* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[i] = pSrc[i];\n\t}\n}\n\n/*\n * libtiff/tif_getimage.c : 1,2,4,8,16 bitspersample accepted\n * CINEMA                 : 12 bit precision\n */\nopj_image_t* tiftoimage(const char *filename, opj_cparameters_t *parameters)\n{\n\tint subsampling_dx = parameters->subsampling_dx;\n\tint subsampling_dy = parameters->subsampling_dy;\n\tTIFF *tif;\n\ttdata_t buf;\n\ttstrip_t strip;\n\ttsize_t strip_size;\n\tint j, currentPlane, numcomps = 0, w, h;\n\tOPJ_COLOR_SPACE color_space = OPJ_CLRSPC_UNKNOWN;\n\topj_image_cmptparm_t cmptparm[4]; /* RGBA */\n\topj_image_t *image = NULL;\n\tint has_alpha = 0;\n\tunsigned short tiBps, tiPhoto, tiSf, tiSpp, tiPC;\n\tunsigned int tiWidth, tiHeight;\n\tOPJ_BOOL is_cinema = OPJ_IS_CINEMA(parameters->rsiz);\n\tconvert_XXx32s_C1R cvtTifTo32s = NULL;\n\tconvert_32s_CXPX cvtCxToPx = NULL;\n\tOPJ_INT32* buffer32s = NULL;\n\tOPJ_INT32* planes[4];\n\tOPJ_SIZE_T rowStride;\n\t\n\ttif = TIFFOpen(filename, \"r\");\n\t\n\tif(!tif)\n\t{\n\t\tfprintf(stderr, \"tiftoimage:Failed to open %s for reading\\n\", filename);\n\t\treturn 0;\n\t}\n\ttiBps = tiPhoto = tiSf = tiSpp = tiPC = 0;\n\ttiWidth = tiHeight = 0;\n\t\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &tiWidth);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &tiHeight);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &tiBps);\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &tiSf);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &tiSpp);\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &tiPhoto);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &tiPC);\n\tw= (int)tiWidth;\n\th= (int)tiHeight;\n\t\n\tif(tiBps > 16U) {\n\t\tfprintf(stderr,\"tiftoimage: Bits=%d, Only 1 to 16 bits implemented\\n\",tiBps);\n\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\tif(tiPhoto != PHOTOMETRIC_MINISBLACK && tiPhoto != PHOTOMETRIC_RGB) {\n\t\tfprintf(stderr,\"tiftoimage: Bad color format %d.\\n\\tOnly RGB(A) and GRAY(A) has been implemented\\n\",(int) tiPhoto);\n\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\t\n\tswitch (tiBps) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 6:\n\t\tcase 8:\n\t\t\tcvtTifTo32s = convert_XXu32s_C1R_LUT[tiBps];\n\t\t\tbreak;\n\t\t/* others are specific to TIFF */\n\t\tcase 3:\n\t\t\tcvtTifTo32s = tif_3uto32s;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcvtTifTo32s = tif_5uto32s;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcvtTifTo32s = tif_7uto32s;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tcvtTifTo32s = tif_9uto32s;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tcvtTifTo32s = tif_10uto32s;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tcvtTifTo32s = tif_11uto32s;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tcvtTifTo32s = tif_12uto32s;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tcvtTifTo32s = tif_13uto32s;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tcvtTifTo32s = tif_14uto32s;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tcvtTifTo32s = tif_15uto32s;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tcvtTifTo32s = (convert_XXx32s_C1R)tif_16uto32s;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* never here */\n\t\t\tbreak;\n\t}\n\t\n\t{/* From: tiff-4.0.x/libtiff/tif_getimage.c : */\n\t\tuint16* sampleinfo;\n\t\tuint16 extrasamples;\n\t\t\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&extrasamples, &sampleinfo);\n\t\t\n\t\tif(extrasamples >= 1)\n\t\t{\n\t\t\tswitch(sampleinfo[0])\n\t\t\t{\n\t\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\n\t\t\t\t\t/* Workaround for some images without correct info about alpha channel\n\t\t\t\t\t */\n\t\t\t\t\tif(tiSpp > 3)\n\t\t\t\t\t\thas_alpha = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase EXTRASAMPLE_ASSOCALPHA: /* data pre-multiplied */\n\t\t\t\tcase EXTRASAMPLE_UNASSALPHA: /* data not pre-multiplied */\n\t\t\t\t\thas_alpha = 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse /* extrasamples == 0 */\n\t\t\tif(tiSpp == 4 || tiSpp == 2) has_alpha = 1;\n\t}\n\t\n\t/* initialize image components */\n\tmemset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));\n\t\n\tif ((tiPhoto == PHOTOMETRIC_RGB) && (is_cinema) && (tiBps != 12U)) {\n\t\tfprintf(stdout,\"WARNING:\\n\"\n\t\t\t\t\t\t\"Input image bitdepth is %d bits\\n\"\n\t\t\t\t\t\t\"TIF conversion has automatically rescaled to 12-bits\\n\"\n\t\t\t\t\t\t\"to comply with cinema profiles.\\n\",\n\t\t\t\t\t\ttiBps);\n\t} else {\n\t\tis_cinema = 0U;\n\t}\n\t\n\tif(tiPhoto == PHOTOMETRIC_RGB) /* RGB(A) */\n\t{\n\t\tnumcomps = 3 + has_alpha;\n\t\tcolor_space = OPJ_CLRSPC_SRGB;\n\t}\n\telse if (tiPhoto == PHOTOMETRIC_MINISBLACK) /* GRAY(A) */\n\t{\n\t\tnumcomps = 1 + has_alpha;\n\t\tcolor_space = OPJ_CLRSPC_GRAY;\n\t}\n\t\n\tcvtCxToPx = convert_32s_CXPX_LUT[numcomps];\n\tif (tiPC == PLANARCONFIG_SEPARATE) {\n\t\tcvtCxToPx = convert_32s_CXPX_LUT[1]; /* override */\n\t\ttiSpp = 1U; /* consider only one sample per plane */\n\t}\n\n\tfor(j = 0; j < numcomps; j++)\n\t{\n\t\tcmptparm[j].prec = tiBps;\n\t\tcmptparm[j].bpp = tiBps;\n\t\tcmptparm[j].dx = (OPJ_UINT32)subsampling_dx;\n\t\tcmptparm[j].dy = (OPJ_UINT32)subsampling_dy;\n\t\tcmptparm[j].w = (OPJ_UINT32)w;\n\t\tcmptparm[j].h = (OPJ_UINT32)h;\n\t}\n\t\t\n\timage = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\tif(!image)\n\t{\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\t/* set image offset and reference grid */\n\timage->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n\timage->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n\timage->x1 =\t!image->x0 ? (OPJ_UINT32)(w - 1) * (OPJ_UINT32)subsampling_dx + 1 :\n\timage->x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)subsampling_dx + 1;\n\timage->y1 =\t!image->y0 ? (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1 :\n\timage->y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1;\n\n\tfor(j = 0; j < numcomps; j++)\n\t{\n\t\tplanes[j] = image->comps[j].data;\n\t}\n\timage->comps[numcomps - 1].alpha = (OPJ_UINT16)(1 - (numcomps & 1));\n\t\t\n\tstrip_size = TIFFStripSize(tif);\n\t\n\tbuf = _TIFFmalloc(strip_size);\n\tif (buf == NULL) {\n\t\tTIFFClose(tif);\n\t\topj_image_destroy(image);\n\t\treturn NULL;\n\t}\n\trowStride = ((OPJ_SIZE_T)w * tiSpp * tiBps + 7U) / 8U;\n\tbuffer32s = (OPJ_INT32 *)malloc((OPJ_SIZE_T)w * tiSpp * sizeof(OPJ_INT32));\n\tif (buffer32s == NULL) {\n\t\t_TIFFfree(buf);\n\t\tTIFFClose(tif);\n\t\topj_image_destroy(image);\n\t\treturn NULL;\n\t}\n\t\n\tstrip = 0;\n\tcurrentPlane = 0;\n\tdo\n\t{\n\t\tplanes[0] = image->comps[currentPlane].data; /* to manage planar data */\n\t\th= (int)tiHeight;\n\t\t/* Read the Image components */\n\t\tfor(; (h > 0) && (strip < TIFFNumberOfStrips(tif)); strip++)\n\t\t{\n\t\t\t\tconst OPJ_UINT8 *dat8;\n\t\t\t\tOPJ_SIZE_T ssize;\n\t\t\t\t\n\t\t\t\tssize = (OPJ_SIZE_T)TIFFReadEncodedStrip(tif, strip, buf, strip_size);\n\t\t\t\tdat8 = (const OPJ_UINT8*)buf;\n\t\t\t\t\n\t\t\t\twhile (ssize >= rowStride) {\n\t\t\t\t\tcvtTifTo32s(dat8, buffer32s, (OPJ_SIZE_T)w * tiSpp);\n\t\t\t\t\tcvtCxToPx(buffer32s, planes, (OPJ_SIZE_T)w);\n\t\t\t\t\tplanes[0] += w;\n\t\t\t\t\tplanes[1] += w;\n\t\t\t\t\tplanes[2] += w;\n\t\t\t\t\tplanes[3] += w;\n\t\t\t\t\tdat8  += rowStride;\n\t\t\t\t\tssize -= rowStride;\n\t\t\t\t\th--;\n\t\t\t\t}\n\t\t}\n\t\tcurrentPlane++;\n\t} while ((tiPC == PLANARCONFIG_SEPARATE) && (currentPlane < numcomps));\n\t\n\tfree(buffer32s);\n\t_TIFFfree(buf);\n\tTIFFClose(tif);\n\t\n\tif (is_cinema) {\n\t\tfor (j=0; j < numcomps; ++j) {\n\t\t\tscale_component(&(image->comps[j]), 12);\n\t\t}\n\t\t\n\t}\n\treturn image;\n\n}/* tiftoimage() */\n\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2015, Matthieu Darbois\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#ifndef OPJ_HAVE_LIBTIFF\n# error OPJ_HAVE_LIBTIFF_NOT_DEFINED\n#endif /* OPJ_HAVE_LIBTIFF */\n\n#include <tiffio.h>\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\n/* -->> -->> -->> -->>\n \n TIFF IMAGE FORMAT\n \n <<-- <<-- <<-- <<-- */\n#define PUTBITS2(s, nb) \\\n\ttrailing <<= remaining; \\\n\ttrailing |= (unsigned int)((s) >> (nb - remaining)); \\\n\t*pDst++ = (OPJ_BYTE)trailing; \\\n\ttrailing = (unsigned int)((s) & ((1U << (nb - remaining)) - 1U)); \\\n\tif (nb >= (remaining + 8)) { \\\n\t\t*pDst++ = (OPJ_BYTE)(trailing >> (nb - (remaining + 8))); \\\n\t\ttrailing &= (unsigned int)((1U << (nb - (remaining + 8))) - 1U); \\\n\t\tremaining += 16 - nb; \\\n\t} else { \\\n\t\tremaining += 8 - nb; \\\n\t}\n\n#define PUTBITS(s, nb) \\\n  if (nb >= remaining) { \\\n\t\tPUTBITS2(s, nb) \\\n\t} else { \\\n\t\ttrailing <<= nb; \\\n\t\ttrailing |= (unsigned int)(s); \\\n\t\tremaining -= nb; \\\n\t}\n#define FLUSHBITS() \\\n\tif (remaining != 8) { \\\n\t\ttrailing <<= remaining; \\\n\t\t*pDst++ = (OPJ_BYTE)trailing; \\\n\t}\n\nstatic void tif_32sto3u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 5) | (src1 << 2) | (src2 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 7) | (src3 << 4) | (src4 << 1) | (src5 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 6) | (src6 << 3) | (src7));\n\t}\n\t\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS((OPJ_UINT32)pSrc[i+0], 3)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+1], 3)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+2], 3)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+3], 3)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+4], 3)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+5], 3)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+6], 3)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\n\nstatic void tif_32sto5u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 3) | (src1 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 6) | (src2 << 1) | (src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 7) | (src5 << 2) | (src6 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 5) | (src7));\n\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS((OPJ_UINT32)pSrc[i+0], 5)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+1], 5)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+2], 5)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+3], 5)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+4], 5)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+5], 5)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+6], 5)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\n\nstatic void tif_32sto7u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 1) | (src1 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 2) | (src2 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 3) | (src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 5) | (src5 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 6) | (src6 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 7) | (src7));\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS((OPJ_UINT32)pSrc[i+0], 7)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+1], 7)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+2], 7)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+3], 7)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+4], 7)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+5], 7)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS((OPJ_UINT32)pSrc[i+6], 7)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\n\nstatic void tif_32sto9u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 6) | (src2 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 5) | (src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 3) | (src5 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 2) | (src6 >> 7));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 1) | (src7 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS2((OPJ_UINT32)pSrc[i+0], 9)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+1], 9)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+2], 9)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+3], 9)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+4], 9)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+5], 9)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+6], 9)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\n\nstatic void tif_32sto10u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 2);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0x3U) << 6) | (src1 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3FU) << 2) | (src3 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src3);\n\t}\n\t\n\tif (length & 3U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tlength = length & 3U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 2);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0x3U) << 6) | (src1 >> 4));\n\t\tif (length > 1U) {\n\t\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 6));\n\t\t\tif (length > 2U) {\n\t\t\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3FU) << 2));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_32sto11u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 5) | (src1 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 2) | (src2 >> 9));\n\t\t*pDst++ = (OPJ_BYTE)((src2 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 7) | (src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 7));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 1) | (src5 >> 10));\n\t\t*pDst++ = (OPJ_BYTE)((src5 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 6) | (src6 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 3) | (src7 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS2((OPJ_UINT32)pSrc[i+0], 11)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+1], 11)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+2], 11)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+3], 11)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+4], 11)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+5], 11)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+6], 11)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\nstatic void tif_32sto12u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i+=2U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 4);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0xFU) << 4) | (src1 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src1);\n\t}\n\t\n\tif (length & 1U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 4);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0xFU) << 4));\n\t}\n}\nstatic void tif_32sto13u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 3) | (src1 >> 10));\n\t\t*pDst++ = (OPJ_BYTE)((src1 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 6) | (src2 >> 7));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 1) | (src3 >> 12));\n\t\t*pDst++ = (OPJ_BYTE)((src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 9));\n\t\t*pDst++ = (OPJ_BYTE)((src4 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 7) | (src5 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 2) | (src6 >> 11));\n\t\t*pDst++ = (OPJ_BYTE)((src6 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 5) | (src7 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS2((OPJ_UINT32)pSrc[i+0], 13)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+1], 13)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+2], 13)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+3], 13)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+4], 13)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+5], 13)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+6], 13)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\nstatic void tif_32sto14u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 6);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0x3FU) << 2) | (src1 >> 12));\n\t\t*pDst++ = (OPJ_BYTE)(src1 >> 4);\n\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 10));\n\t\t*pDst++ = (OPJ_BYTE)(src2 >> 2);\n\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6) | (src3 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src3);\n\t}\n\t\n\tif (length & 3U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tlength = length & 3U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)(src0 >> 6);\n\t\t*pDst++ = (OPJ_BYTE)(((src0 & 0x3FU) << 2) | (src1 >> 12));\n\t\tif (length > 1U) {\n\t\t\t*pDst++ = (OPJ_BYTE)(src1 >> 4);\n\t\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 10));\n\t\t\tif (length > 2U) {\n\t\t\t\t*pDst++ = (OPJ_BYTE)(src2 >> 2);\n\t\t\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_32sto15u(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\t\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 >> 7));\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 1) | (src1 >> 14));\n\t\t*pDst++ = (OPJ_BYTE)((src1 >> 6));\n\t\t*pDst++ = (OPJ_BYTE)((src1 << 2) | (src2 >> 13));\n\t\t*pDst++ = (OPJ_BYTE)((src2 >> 5));\n\t\t*pDst++ = (OPJ_BYTE)((src2 << 3) | (src3 >> 12));\n\t\t*pDst++ = (OPJ_BYTE)((src3 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)((src3 << 4) | (src4 >> 11));\n\t\t*pDst++ = (OPJ_BYTE)((src4 >> 3));\n\t\t*pDst++ = (OPJ_BYTE)((src4 << 5) | (src5 >> 10));\n\t\t*pDst++ = (OPJ_BYTE)((src5 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)((src5 << 6) | (src6 >> 9));\n\t\t*pDst++ = (OPJ_BYTE)((src6 >> 1));\n\t\t*pDst++ = (OPJ_BYTE)((src6 << 7) | (src7 >> 8));\n\t\t*pDst++ = (OPJ_BYTE)(src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tunsigned int trailing = 0U;\n\t\tint remaining = 8U;\n\t\tlength &= 7U;\n\t\tPUTBITS2((OPJ_UINT32)pSrc[i+0], 15)\n\t\tif (length > 1U) {\n\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+1], 15)\n\t\t\tif (length > 2U) {\n\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+2], 15)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+3], 15)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+4], 15)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+5], 15)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tPUTBITS2((OPJ_UINT32)pSrc[i+6], 15)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFLUSHBITS()\n\t}\n}\nstatic void tif_32sto16u(const OPJ_INT32* pSrc, OPJ_UINT16* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < length; ++i) {\n\t\tpDst[i] = (OPJ_UINT16)pSrc[i];\n\t}\n}\n\nint imagetotif(opj_image_t * image, const char *outfile)\n{\n\tuint32 width, height, bps, tiPhoto;\n\tint adjust, sgnd;\n\tTIFF *tif;\n\ttdata_t buf;\n\ttmsize_t strip_size, rowStride;\n\tOPJ_UINT32 i, numcomps;\n\tOPJ_INT32* buffer32s = NULL;\n\tOPJ_INT32 const* planes[4];\n\tconvert_32s_PXCX cvtPxToCx = NULL;\n\tconvert_32sXXx_C1R cvt32sToTif = NULL;\n\n\tbps = (uint32)image->comps[0].prec;\n\tplanes[0] = image->comps[0].data;\n\t\n\tnumcomps = image->numcomps;\n\t\n\tif (image->color_space == OPJ_CLRSPC_CMYK) {\n\t\tif (numcomps < 4U) {\n\t\t\tfprintf(stderr,\"imagetotif: CMYK images shall be composed of at least 4 planes.\\n\");\n\t\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\ttiPhoto = PHOTOMETRIC_SEPARATED;\n\t\tif (numcomps > 4U) {\n\t\t\tnumcomps = 4U; /* Alpha not supported */\n\t\t}\n\t}\n\telse if (numcomps > 2U) {\n\t\ttiPhoto = PHOTOMETRIC_RGB;\n\t\tif (numcomps > 4U) {\n\t\t\tnumcomps = 4U;\n\t\t}\n\t} else {\n\t\ttiPhoto = PHOTOMETRIC_MINISBLACK;\n\t}\n\tfor (i = 1U; i < numcomps; ++i) {\n\t\tif (image->comps[0].dx != image->comps[i].dx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (image->comps[0].dy != image->comps[i].dy) {\n\t\t\tbreak;\n\t\t}\n\t\tif (image->comps[0].prec != image->comps[i].prec) {\n\t\t\tbreak;\n\t\t}\n\t\tif (image->comps[0].sgnd != image->comps[i].sgnd) {\n\t\t\tbreak;\n\t\t}\n\t\tplanes[i] = image->comps[i].data;\n\t}\n\tif (i != numcomps) {\n\t\tfprintf(stderr,\"imagetotif: All components shall have the same subsampling, same bit depth.\\n\");\n\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\treturn 1;\n\t}\n\t\n\tif(bps > 16) bps = 0;\n\tif(bps == 0)\n\t{\n\t\tfprintf(stderr,\"imagetotif: Bits=%d, Only 1 to 16 bits implemented\\n\",bps);\n\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\treturn 1;\n\t}\n\ttif = TIFFOpen(outfile, \"wb\");\n\tif (!tif)\n\t{\n\t\tfprintf(stderr, \"imagetotif:failed to open %s for writing\\n\", outfile);\n\t\treturn 1;\n\t}\n\tfor (i = 0U; i < numcomps; ++i) {\n\t\tclip_component(&(image->comps[i]), image->comps[0].prec);\n\t}\n\tcvtPxToCx = convert_32s_PXCX_LUT[numcomps];\n\tswitch (bps) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 6:\n\t\tcase 8:\n\t\t\tcvt32sToTif = convert_32sXXu_C1R_LUT[bps];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcvt32sToTif = tif_32sto3u;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcvt32sToTif = tif_32sto5u;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcvt32sToTif = tif_32sto7u;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tcvt32sToTif = tif_32sto9u;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tcvt32sToTif = tif_32sto10u;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tcvt32sToTif = tif_32sto11u;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tcvt32sToTif = tif_32sto12u;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tcvt32sToTif = tif_32sto13u;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tcvt32sToTif = tif_32sto14u;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tcvt32sToTif = tif_32sto15u;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tcvt32sToTif = (convert_32sXXx_C1R)tif_32sto16u;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* never here */\n\t\t\tbreak;\n\t}\n\tsgnd = (int)image->comps[0].sgnd;\n\tadjust = sgnd ? (int)(1 << (image->comps[0].prec - 1)) : 0;\n\twidth   = (uint32)image->comps[0].w;\n\theight  = (uint32)image->comps[0].h;\n\t\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (uint32)numcomps);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);\n\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, tiPhoto);\n\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n\t\n\tstrip_size = TIFFStripSize(tif);\n\trowStride = (width * numcomps * bps + 7U) / 8U;\n\tif (rowStride != strip_size) {\n\t\tfprintf(stderr, \"Invalid TIFF strip size\\n\");\n\t\tTIFFClose(tif);\n\t\treturn 1;\n\t}\n\tbuf = _TIFFmalloc(strip_size);\n\tif (buf == NULL) {\n\t\tTIFFClose(tif);\n\t\treturn 1;\n\t}\n\tbuffer32s = (OPJ_INT32 *)malloc((OPJ_SIZE_T)(width * numcomps * sizeof(OPJ_INT32)));\n\tif (buffer32s == NULL) {\n\t\t_TIFFfree(buf);\n\t\tTIFFClose(tif);\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < image->comps[0].h; ++i) {\n\t\tcvtPxToCx(planes, buffer32s, (OPJ_SIZE_T)width, adjust);\n\t\tcvt32sToTif(buffer32s, (OPJ_BYTE *)buf, (OPJ_SIZE_T)width * numcomps);\n\t\t(void)TIFFWriteEncodedStrip(tif, i, (void*)buf, strip_size);\n\t\tplanes[0] += width;\n\t\tplanes[1] += width;\n\t\tplanes[2] += width;\n\t\tplanes[3] += width;\n\t}\n\t_TIFFfree((void*)buf);\n\tTIFFClose(tif);\n\tfree(buffer32s);\n\t\t\n\treturn 0;\n}/* imagetotif() */\n\n#define GETBITS(dest, nb) { \\\n\tint needed = (nb); \\\n\tunsigned int dst = 0U; \\\n\tif (available == 0) { \\\n\t\tval = *pSrc++; \\\n\t\tavailable = 8; \\\n\t} \\\n\twhile (needed > available) { \\\n\t\tdst |= val & ((1U << available) - 1U); \\\n\t\tneeded -= available; \\\n\t\tdst <<= needed; \\\n\t\tval = *pSrc++; \\\n\t\tavailable = 8; \\\n\t} \\\n\tdst |= (val >> (available - needed)) & ((1U << needed) - 1U); \\\n\tavailable -= needed; \\\n\tdest = (OPJ_INT32)dst; \\\n}\n\nstatic void tif_3uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 >> 5));\n\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x1FU) >> 2));\n\t\tpDst[i+2] = (OPJ_INT32)(((val0 & 0x3U) << 1) | (val1 >> 7));\n\t\tpDst[i+3] = (OPJ_INT32)(((val1 & 0x7FU) >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val1 & 0xFU) >> 1));\n\t\tpDst[i+5] = (OPJ_INT32)(((val1 & 0x1U) << 2) | (val2 >> 6));\n\t\tpDst[i+6] = (OPJ_INT32)(((val2 & 0x3FU) >> 3));\n\t\tpDst[i+7] = (OPJ_INT32)(((val2 & 0x7U)));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 3)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 3)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 3)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 3)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 3)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 3)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 3)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_5uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 >> 3));\n\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x7U) << 2) | (val1 >> 6));\n\t\tpDst[i+2] = (OPJ_INT32)(((val1 & 0x3FU) >> 1));\n\t\tpDst[i+3] = (OPJ_INT32)(((val1 & 0x1U) << 4) | (val2 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val2 & 0xFU) << 1) | (val3 >> 7));\n\t\tpDst[i+5] = (OPJ_INT32)(((val3 & 0x7FU) >> 2));\n\t\tpDst[i+6] = (OPJ_INT32)(((val3 & 0x3U) << 3) | (val4 >> 5));\n\t\tpDst[i+7] = (OPJ_INT32)(((val4 & 0x1FU)));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 5)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 5)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 5)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 5)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 5)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 5)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 5)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_7uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 >> 1));\n\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x1U) << 6) | (val1 >> 2));\n\t\tpDst[i+2] = (OPJ_INT32)(((val1 & 0x3U) << 5) | (val2 >> 3));\n\t\tpDst[i+3] = (OPJ_INT32)(((val2 & 0x7U) << 4) | (val3 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val3 & 0xFU) << 3) | (val4 >> 5));\n\t\tpDst[i+5] = (OPJ_INT32)(((val4 & 0x1FU) << 2) | (val5 >> 6));\n\t\tpDst[i+6] = (OPJ_INT32)(((val5 & 0x3FU) << 1) | (val6 >> 7));\n\t\tpDst[i+7] = (OPJ_INT32)(((val6 & 0x7FU)));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 7)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 7)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 7)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 7)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 7)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 7)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 7)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_9uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\tOPJ_UINT32 val7 = *pSrc++;\n\t\tOPJ_UINT32 val8 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 1) | (val1 >> 7));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x7FU) << 2) | (val2 >> 6));\n\t\tpDst[i+2] = (OPJ_INT32)(((val2 & 0x3FU) << 3) | (val3 >> 5));\n\t\tpDst[i+3] = (OPJ_INT32)(((val3 & 0x1FU) << 4) | (val4 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val4 & 0xFU) << 5) | (val5 >> 3));\n\t\tpDst[i+5] = (OPJ_INT32)(((val5 & 0x7U) << 6) | (val6 >> 2));\n\t\tpDst[i+6] = (OPJ_INT32)(((val6 & 0x3U) << 7) | (val7 >> 1));\n\t\tpDst[i+7] = (OPJ_INT32)(((val7 & 0x1U) << 8) | (val8));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 9)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 9)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 9)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 9)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 9)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 9)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 9)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_10uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 2) | (val1 >> 6));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x3FU) << 4) | (val2 >> 4));\n\t\tpDst[i+2] = (OPJ_INT32)(((val2 & 0xFU) << 6) | (val3 >> 2));\n\t\tpDst[i+3] = (OPJ_INT32)(((val3 & 0x3U) << 8) | val4);\n\t\t\n\t}\n\tif (length & 3U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tlength = length & 3U;\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 2) | (val1 >> 6));\n\t\t\n\t\tif (length > 1U) {\n\t\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x3FU) << 4) | (val2 >> 4));\n\t\t\tif (length > 2U) {\n\t\t\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\t\t\tpDst[i+2] = (OPJ_INT32)(((val2 & 0xFU) << 6) | (val3 >> 2));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_11uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\tOPJ_UINT32 val7 = *pSrc++;\n\t\tOPJ_UINT32 val8 = *pSrc++;\n\t\tOPJ_UINT32 val9 = *pSrc++;\n\t\tOPJ_UINT32 val10 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 3) | (val1 >> 5));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x1FU) << 6) | (val2 >> 2));\n\t\tpDst[i+2] = (OPJ_INT32)(((val2 & 0x3U) << 9) | (val3 << 1) | (val4 >> 7));\n\t\tpDst[i+3] = (OPJ_INT32)(((val4 & 0x7FU) << 4) | (val5 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val5 & 0xFU) << 7) | (val6 >> 1));\n\t\tpDst[i+5] = (OPJ_INT32)(((val6 & 0x1U) << 10) | (val7 << 2) | (val8 >> 6));\n\t\tpDst[i+6] = (OPJ_INT32)(((val8 & 0x3FU) << 5) | (val9 >> 3));\n\t\tpDst[i+7] = (OPJ_INT32)(((val9 & 0x7U) << 8) | (val10));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 11)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 11)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 11)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 11)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 11)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 11)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 11)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_12uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i+=2U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 4) | (val1 >> 4));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0xFU) << 8) | val2);\n\t}\n\tif (length & 1U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 4) | (val1 >> 4));\n\t}\n}\nstatic void tif_13uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\tOPJ_UINT32 val7 = *pSrc++;\n\t\tOPJ_UINT32 val8 = *pSrc++;\n\t\tOPJ_UINT32 val9 = *pSrc++;\n\t\tOPJ_UINT32 val10 = *pSrc++;\n\t\tOPJ_UINT32 val11 = *pSrc++;\n\t\tOPJ_UINT32 val12 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 5) | (val1 >> 3));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x7U) << 10) | (val2 << 2) | (val3 >> 6));\n\t\tpDst[i+2] = (OPJ_INT32)(((val3 & 0x3FU) << 7) | (val4 >> 1));\n\t\tpDst[i+3] = (OPJ_INT32)(((val4 & 0x1U) << 12) | (val5 << 4) | (val6 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val6 & 0xFU) << 9) | (val7 << 1) | (val8 >> 7));\n\t\tpDst[i+5] = (OPJ_INT32)(((val8 & 0x7FU) << 6) | (val9 >> 2));\n\t\tpDst[i+6] = (OPJ_INT32)(((val9 & 0x3U) << 11) | (val10 << 3) | (val11 >> 5));\n\t\tpDst[i+7] = (OPJ_INT32)(((val11 & 0x1FU) << 8) | (val12));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 13)\n\t\t\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 13)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 13)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 13)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 13)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 13)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 13)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_14uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 6) | (val1 >> 2));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x3U) << 12) | (val2 << 4) | (val3 >> 4));\n\t\tpDst[i+2] = (OPJ_INT32)(((val3 & 0xFU) << 10) | (val4 << 2) | (val5 >> 6));\n\t\tpDst[i+3] = (OPJ_INT32)(((val5 & 0x3FU) << 8) | val6);\n\t\t\n\t}\n\tif (length & 3U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tlength = length & 3U;\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 6) | (val1 >> 2));\n\t\t\n\t\tif (length > 1U) {\n\t\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x3U) << 12) | (val2 << 4) | (val3 >> 4));\n\t\t\tif (length > 2U) {\n\t\t\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\t\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\t\t\tpDst[i+2] = (OPJ_INT32)(((val3 & 0xFU) << 10) | (val4 << 2) | (val5 >> 6));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void tif_15uto32s(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tOPJ_UINT32 val3 = *pSrc++;\n\t\tOPJ_UINT32 val4 = *pSrc++;\n\t\tOPJ_UINT32 val5 = *pSrc++;\n\t\tOPJ_UINT32 val6 = *pSrc++;\n\t\tOPJ_UINT32 val7 = *pSrc++;\n\t\tOPJ_UINT32 val8 = *pSrc++;\n\t\tOPJ_UINT32 val9 = *pSrc++;\n\t\tOPJ_UINT32 val10 = *pSrc++;\n\t\tOPJ_UINT32 val11 = *pSrc++;\n\t\tOPJ_UINT32 val12 = *pSrc++;\n\t\tOPJ_UINT32 val13 = *pSrc++;\n\t\tOPJ_UINT32 val14 = *pSrc++;\n\t\t\n\t\tpDst[i+0] = (OPJ_INT32)((val0 << 7) | (val1 >> 1));\n\t\tpDst[i+1] = (OPJ_INT32)(((val1 & 0x1U) << 14) | (val2 << 6) | (val3 >> 2));\n\t\tpDst[i+2] = (OPJ_INT32)(((val3 & 0x3U) << 13) | (val4 << 5) | (val5 >> 3));\n\t\tpDst[i+3] = (OPJ_INT32)(((val5 & 0x7U) << 12) | (val6 << 4) | (val7 >> 4));\n\t\tpDst[i+4] = (OPJ_INT32)(((val7 & 0xFU) << 11) | (val8 << 3) | (val9 >> 5));\n\t\tpDst[i+5] = (OPJ_INT32)(((val9 & 0x1FU) << 10) | (val10 << 2) | (val11 >> 6));\n\t\tpDst[i+6] = (OPJ_INT32)(((val11 & 0x3FU) << 9) | (val12 << 1) | (val13 >> 7));\n\t\tpDst[i+7] = (OPJ_INT32)(((val13 & 0x7FU) << 8) | (val14));\n\t\t\n\t}\n\tif (length & 7U) {\n\t\tunsigned int val;\n\t\tint available = 0;\n\t\t\n\t\tlength = length & 7U;\n\t\t\n\t\tGETBITS(pDst[i+0], 15)\n\n\t\tif (length > 1U) {\n\t\t\tGETBITS(pDst[i+1], 15)\n\t\t\tif (length > 2U) {\n\t\t\t\tGETBITS(pDst[i+2], 15)\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tGETBITS(pDst[i+3], 15)\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tGETBITS(pDst[i+4], 15)\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tGETBITS(pDst[i+5], 15)\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tGETBITS(pDst[i+6], 15)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* seems that libtiff decodes this to machine endianness */\nstatic void tif_16uto32s(const OPJ_UINT16* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[i] = pSrc[i];\n\t}\n}\n\n/*\n * libtiff/tif_getimage.c : 1,2,4,8,16 bitspersample accepted\n * CINEMA                 : 12 bit precision\n */\nopj_image_t* tiftoimage(const char *filename, opj_cparameters_t *parameters)\n{\n\tint subsampling_dx = parameters->subsampling_dx;\n\tint subsampling_dy = parameters->subsampling_dy;\n\tTIFF *tif;\n\ttdata_t buf;\n\ttstrip_t strip;\n\ttmsize_t strip_size;\n\tint j, currentPlane, numcomps = 0, w, h;\n\tOPJ_COLOR_SPACE color_space = OPJ_CLRSPC_UNKNOWN;\n\topj_image_cmptparm_t cmptparm[4]; /* RGBA */\n\topj_image_t *image = NULL;\n\tint has_alpha = 0;\n\tuint32 tiBps, tiPhoto, tiSf, tiSpp, tiPC, tiWidth, tiHeight;\n\tOPJ_BOOL is_cinema = OPJ_IS_CINEMA(parameters->rsiz);\n\tconvert_XXx32s_C1R cvtTifTo32s = NULL;\n\tconvert_32s_CXPX cvtCxToPx = NULL;\n\tOPJ_INT32* buffer32s = NULL;\n\tOPJ_INT32* planes[4];\n\ttmsize_t rowStride;\n\t\n\ttif = TIFFOpen(filename, \"r\");\n\t\n\tif(!tif)\n\t{\n\t\tfprintf(stderr, \"tiftoimage:Failed to open %s for reading\\n\", filename);\n\t\treturn 0;\n\t}\n\ttiBps = tiPhoto = tiSf = tiSpp = tiPC = 0;\n\ttiWidth = tiHeight = 0;\n\t\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &tiWidth);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &tiHeight);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &tiBps);\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &tiSf);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &tiSpp);\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &tiPhoto);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &tiPC);\n\n\tif(tiSpp == 0 || tiSpp > 4) { /* should be 1 ... 4 */\n\t\tfprintf(stderr,\"tiftoimage: Bad value for samples per pixel == %hu.\\n\"\n\t\t \"\\tAborting.\\n\", tiSpp);\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\tif(tiBps > 16U || tiBps == 0) {\n\t\tfprintf(stderr,\"tiftoimage: Bad values for Bits == %d.\\n\"\n\t\t \"\\tMax. 16 Bits are allowed here.\\n\\tAborting.\\n\",tiBps);\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\tif(tiPhoto != PHOTOMETRIC_MINISBLACK && tiPhoto != PHOTOMETRIC_RGB) {\n\t\tfprintf(stderr,\"tiftoimage: Bad color format %d.\\n\"\n\t\t \"\\tOnly RGB(A) and GRAY(A) has been implemented\\n\",(int) tiPhoto);\n\t\tfprintf(stderr,\"\\tAborting\\n\");\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\tif(tiWidth == 0 || tiHeight == 0) {\n\t\tfprintf(stderr,\"tiftoimage: Bad values for width(%u) \"\n\t\t \"and/or height(%u)\\n\\tAborting.\\n\",tiWidth,tiHeight);\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\tw= (int)tiWidth;\n\th= (int)tiHeight;\n\n\tswitch (tiBps) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 6:\n\t\tcase 8:\n\t\t\tcvtTifTo32s = convert_XXu32s_C1R_LUT[tiBps];\n\t\t\tbreak;\n\t\t/* others are specific to TIFF */\n\t\tcase 3:\n\t\t\tcvtTifTo32s = tif_3uto32s;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcvtTifTo32s = tif_5uto32s;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcvtTifTo32s = tif_7uto32s;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tcvtTifTo32s = tif_9uto32s;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tcvtTifTo32s = tif_10uto32s;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tcvtTifTo32s = tif_11uto32s;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tcvtTifTo32s = tif_12uto32s;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tcvtTifTo32s = tif_13uto32s;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tcvtTifTo32s = tif_14uto32s;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tcvtTifTo32s = tif_15uto32s;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tcvtTifTo32s = (convert_XXx32s_C1R)tif_16uto32s;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* never here */\n\t\t\tbreak;\n\t}\n\t\n\t{/* From: tiff-4.0.x/libtiff/tif_getimage.c : */\n\t\tuint16* sampleinfo;\n\t\tuint16 extrasamples;\n\t\t\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&extrasamples, &sampleinfo);\n\n\t\tif(extrasamples >= 1)\n\t\t{\n\t\t\tswitch(sampleinfo[0])\n\t\t\t{\n\t\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\n\t\t\t\t\t/* Workaround for some images without correct info about alpha channel\n\t\t\t\t\t */\n\t\t\t\t\tif(tiSpp > 3)\n\t\t\t\t\t\thas_alpha = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase EXTRASAMPLE_ASSOCALPHA: /* data pre-multiplied */\n\t\t\t\tcase EXTRASAMPLE_UNASSALPHA: /* data not pre-multiplied */\n\t\t\t\t\thas_alpha = 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse /* extrasamples == 0 */\n\t\t\tif(tiSpp == 4 || tiSpp == 2) has_alpha = 1;\n\t}\n\n\t/* initialize image components */\n\tmemset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));\n\t\n\tif ((tiPhoto == PHOTOMETRIC_RGB) && (is_cinema) && (tiBps != 12U)) {\n\t\tfprintf(stdout,\"WARNING:\\n\"\n\t\t\t\t\t\t\"Input image bitdepth is %d bits\\n\"\n\t\t\t\t\t\t\"TIF conversion has automatically rescaled to 12-bits\\n\"\n\t\t\t\t\t\t\"to comply with cinema profiles.\\n\",\n\t\t\t\t\t\ttiBps);\n\t} else {\n\t\tis_cinema = 0U;\n\t}\n\n\tif(tiPhoto == PHOTOMETRIC_RGB) /* RGB(A) */\n\t{\n\t\tnumcomps = 3 + has_alpha;\n\t\tcolor_space = OPJ_CLRSPC_SRGB;\n\t}\n\telse if (tiPhoto == PHOTOMETRIC_MINISBLACK) /* GRAY(A) */\n\t{\n\t\tnumcomps = 1 + has_alpha;\n\t\tcolor_space = OPJ_CLRSPC_GRAY;\n\t}\n\t\n\tcvtCxToPx = convert_32s_CXPX_LUT[numcomps];\n\tif (tiPC == PLANARCONFIG_SEPARATE) {\n\t\tcvtCxToPx = convert_32s_CXPX_LUT[1]; /* override */\n\t\ttiSpp = 1U; /* consider only one sample per plane */\n\t}\n\n\tfor(j = 0; j < numcomps; j++)\n\t{\n\t\tcmptparm[j].prec = tiBps;\n\t\tcmptparm[j].bpp = tiBps;\n\t\tcmptparm[j].dx = (OPJ_UINT32)subsampling_dx;\n\t\tcmptparm[j].dy = (OPJ_UINT32)subsampling_dy;\n\t\tcmptparm[j].w = (OPJ_UINT32)w;\n\t\tcmptparm[j].h = (OPJ_UINT32)h;\n\t}\n\t\t\n\timage = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\tif(!image)\n\t{\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\t/* set image offset and reference grid */\n\timage->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n\timage->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n\timage->x1 =\t!image->x0 ? (OPJ_UINT32)(w - 1) * (OPJ_UINT32)subsampling_dx + 1 :\n\t image->x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)subsampling_dx + 1;\n\tif(image->x1 <= image->x0) {\n\t\tfprintf(stderr,\"tiftoimage: Bad value for image->x1(%d) vs. \"\n\t\t \"image->x0(%d)\\n\\tAborting.\\n\",image->x1,image->x0);\n\t\tTIFFClose(tif);\n\t\topj_image_destroy(image);\n\t\treturn NULL;\n\t}\n\timage->y1 =\t!image->y0 ? (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1 :\n\t image->y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1;\n\tif(image->y1 <= image->y0) {\n\t\tfprintf(stderr,\"tiftoimage: Bad value for image->y1(%d) vs. \"\n\t\t \"image->y0(%d)\\n\\tAborting.\\n\",image->y1,image->y0);\n\t\tTIFFClose(tif);\n\t\topj_image_destroy(image);\n\t\treturn NULL;\n\t}\n\t\n\tfor(j = 0; j < numcomps; j++)\n\t{\n\t\tplanes[j] = image->comps[j].data;\n\t}\n\timage->comps[numcomps - 1].alpha = (OPJ_UINT16)(1 - (numcomps & 1));\n\t\t\n\tstrip_size = TIFFStripSize(tif);\n\n\tbuf = _TIFFmalloc(strip_size);\n\tif (buf == NULL) {\n\t\tTIFFClose(tif);\n\t\topj_image_destroy(image);\n\t\treturn NULL;\n\t}\n\trowStride = (w * tiSpp * tiBps + 7U) / 8U;\n\tbuffer32s = (OPJ_INT32 *)malloc((OPJ_SIZE_T)(w * tiSpp * sizeof(OPJ_INT32)));\n\tif (buffer32s == NULL) {\n\t\t_TIFFfree(buf);\n\t\tTIFFClose(tif);\n\t\topj_image_destroy(image);\n\t\treturn NULL;\n\t}\n\t\n\tstrip = 0;\n\tcurrentPlane = 0;\n\tdo\n\t{\n\t\tplanes[0] = image->comps[currentPlane].data; /* to manage planar data */\n\t\th= (int)tiHeight;\n\t\t/* Read the Image components */\n\t\tfor(; (h > 0) && (strip < TIFFNumberOfStrips(tif)); strip++)\n\t\t{\n\t\t\t\tconst OPJ_UINT8 *dat8;\n\t\t\t\ttmsize_t ssize;\n\t\t\t\t\n\t\t\t\tssize = TIFFReadEncodedStrip(tif, strip, buf, strip_size);\n\t\t\t\tif(ssize < 1 || ssize > strip_size) {\n\t\t\t\t\tfprintf(stderr,\"tiftoimage: Bad value for ssize(%ld) \"\n                     \"vs. strip_size(%ld).\\n\\tAborting.\\n\",ssize,strip_size);\n\t\t\t\t\t_TIFFfree(buf);\n\t\t\t\t\t_TIFFfree(buffer32s);\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\topj_image_destroy(image);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tdat8 = (const OPJ_UINT8*)buf;\n\n\t\t\t\twhile (ssize >= rowStride) {\n\t\t\t\t\tcvtTifTo32s(dat8, buffer32s, (OPJ_SIZE_T)w * tiSpp);\n\t\t\t\t\tcvtCxToPx(buffer32s, planes, (OPJ_SIZE_T)w);\n\t\t\t\t\tplanes[0] += w;\n\t\t\t\t\tplanes[1] += w;\n\t\t\t\t\tplanes[2] += w;\n\t\t\t\t\tplanes[3] += w;\n\t\t\t\t\tdat8  += rowStride;\n\t\t\t\t\tssize -= rowStride;\n\t\t\t\t\th--;\n\t\t\t\t}\n\t\t}\n\t\tcurrentPlane++;\n\t} while ((tiPC == PLANARCONFIG_SEPARATE) && (currentPlane < numcomps));\n\t\n\tfree(buffer32s);\n\t_TIFFfree(buf);\n\tTIFFClose(tif);\n\t\n\tif (is_cinema) {\n\t\tfor (j=0; j < numcomps; ++j) {\n\t\t\tscale_component(&(image->comps[j]), 12);\n\t\t}\n\t\t\n\t}\n\treturn image;\n\n}/* tiftoimage() */\n\n"], "filenames": ["src/bin/jp2/converttif.c"], "buggy_code_start_loc": [556], "buggy_code_end_loc": [1429], "fixing_code_start_loc": [556], "fixing_code_end_loc": [1462], "type": "CWE-122", "message": "An integer overflow vulnerability was found in tiftoimage function in openjpeg 2.1.2, resulting in heap buffer overflow.", "other": {"cve": {"id": "CVE-2016-9580", "sourceIdentifier": "secalert@redhat.com", "published": "2018-08-01T16:29:00.477", "lastModified": "2023-02-12T23:27:20.057", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An integer overflow vulnerability was found in tiftoimage function in openjpeg 2.1.2, resulting in heap buffer overflow."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad de desbordamiento de enteros en la funci\u00f3n tiftoimage en openjpeg 2.1.2, lo que resulta en un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}, {"lang": "en", "value": "CWE-190"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:2.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "1CFB3AF6-73C9-4567-9FA4-DE81159128D7"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/94822", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-9580", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/szukw000/openjpeg/commit/cadff5fb6e73398de26a92e96d3d7cac893af255", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/871", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-26", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/szukw000/openjpeg/commit/cadff5fb6e73398de26a92e96d3d7cac893af255"}}