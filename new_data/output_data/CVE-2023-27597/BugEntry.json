{"buggy_code": ["/*\n * Copyright (C) 2001-2003 FhG Fokus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n *\n * History:\n * --------\n * 2003-04-04  convenience inbound-uri parser parse_orig_ruri\n *             introduced (jiri)\n * 2003-04-11  new parse_uri introduced (better, parses also some parameters,\n *              works in one pass) (andrei)\n * 2003-04-11  ser_error is now set in parse_uri (andrei)\n * 2003-04-26  ZSW (jiri)\n * 2003-07-03  sips:, r2, lr=on support added (andrei)\n * 2005-02-25  preliminary tel uri support (andrei)\n * 2005-03-03  more tel uri fixes (andrei)\n * 2006-11-28  Added statistic support for the number of bad URI's\n *             (Jeffrey Magder - SOMA Networks)\n *  2011-04-20  added support for URI unknown parameters (osas)\n */\n\n\n#include \"parse_uri.h\"\n#include <string.h>\n#include \"../dprint.h\"\n#include \"../ut.h\"   /* q_memchr */\n#include \"../error.h\"\n#include \"../errinfo.h\"\n#include \"../core_stats.h\"\n#include \"../strcommon.h\"\n\nstatic const str uri_type_names[7] = {\n\t{NULL, 0}, /*This is the error type*/\n\tstr_init(\"sip\"),\n\tstr_init(\"sips\"),\n\tstr_init(\"tel\"),\n\tstr_init(\"tels\"),\n\tstr_init(\"urn:service\"),\n\tstr_init(\"urn:nena:service\")\n};\n\nchar* uri_type2str(const uri_type type, char *result)\n{\n\tif (type == ERROR_URI_T)\n\t\treturn NULL;\n\n\tmemcpy(result, uri_type_names[type].s, uri_type_names[type].len);\n\treturn result + uri_type_names[type].len;\n}\n\nint uri_typestrlen(const uri_type type)\n{\n\treturn uri_type_names[type].len;\n}\n\nuri_type str2uri_type(char * buf)\n{\n\tint scheme = 0;\n\turi_type type = ERROR_URI_T;\n\tscheme=buf[0]+(buf[1]<<8)+(buf[2]<<16)+(buf[3]<<24);\n\tscheme|=0x20202020;\n\tif (scheme==SIP_SCH){\n\t\ttype=SIP_URI_T;\n\t}else if(scheme==SIPS_SCH){\n\t\tif(buf[4]==':')\n\t\t\ttype=SIPS_URI_T;\n\t\telse type = ERROR_URI_T;\n\t}else if (scheme==TEL_SCH){\n\t\ttype=TEL_URI_T;\n\t}else if (scheme==URN_SERVICE_SCH){\n\t\tif (memcmp(buf+3,URN_SERVICE_STR,URN_SERVICE_STR_LEN) == 0) {\n\t\t\ttype=URN_SERVICE_URI_T;\n\t\t}\n\t\telse if (memcmp(buf+3,URN_NENA_SERVICE_STR,URN_NENA_SERVICE_STR_LEN) == 0) {\n\t\t\ttype=URN_NENA_SERVICE_URI_T;\n\t\t}\n\t}\n\treturn type;\n}\n\nint parse_uri_headers(str headers, str h_name[], str h_val[], int h_size)\n{\n\tenum states {URI_H_HEADER, URI_H_VALUE};\n\tregister enum states state;\n\tchar* h; /* header start */\n\tchar* v; /* header value start */\n\tstr* header;\t\t/* current header */\n\tstr* header_val;\t/* current header val */\n\tregister char* p;\n\tchar* end;\n\tunsigned int i = 0;\n\n\t/* init */\n\tend = headers.s + headers.len;\n\tp = h = headers.s;\n\tv = NULL;\n\theader = &h_name[0];\n\theader_val = &h_val[0];\n\tstate = URI_H_HEADER;\n\tmemset(h_name, 0, h_size * sizeof(str));\n\tmemset(h_val, 0, h_size * sizeof(str));\n\n\tfor(;p<end; p++){\n\t\tswitch((unsigned char)state){\n\t\tcase URI_H_HEADER:\n\t\t\tswitch(*p){\n\t\t\tcase '=':\n\t\t\t\tv = p+1;\n\t\t\t\theader->s = h;\n\t\t\t\theader->len = p-h;\n\t\t\t\tstate = URI_H_VALUE;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\tLM_ERR(\"Header without value\\n\");\n\t\t\t\th = p+1;\n\t\t\t\theader->s = h;\n\t\t\t\theader->len = p-h;\n\t\t\t\theader_val->s = NULL;\n\t\t\t\theader_val->len = 0;\n\n\t\t\t\t/* advance header and header_val */\n\t\t\t\ti++;\n\t\t\t\tif(i<h_size){\n\t\t\t\t\theader = &h_name[i];\n\t\t\t\t\theader_val = &h_val[i];\n\t\t\t\t} else {\n\t\t\t\t\tLM_ERR(\"To many URI headers\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase URI_H_VALUE:\n\t\t\tswitch(*p){\n\t\t\tcase '=':\n\t\t\t\tLM_ERR(\"Ignoring unexpected '=' inside URI header value\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\th = p+1;\n\t\t\t\theader_val->s = v;\n\t\t\t\theader_val->len = p-v;\n\t\t\t\tstate = URI_H_HEADER;\n\n\t\t\t\t/* advance header and header_val */\n\t\t\t\ti++;\n\t\t\t\tif(i<h_size){\n\t\t\t\t\theader = &h_name[i];\n\t\t\t\t\theader_val = &h_val[i];\n\t\t\t\t} else {\n\t\t\t\t\tLM_ERR(\"To many URI headers\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_ERR(\"Unexpected state [%d]\\n\", state);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tswitch(state){\n\tcase URI_H_HEADER:\n\t\tLM_ERR(\"Header without value\\n\");\n\t\theader->s = h;\n\t\theader->len = p-h;\n\t\theader_val->s = NULL;\n\t\theader_val->len = 0;\n\t\tbreak;\n\tcase URI_H_VALUE:\n\t\theader_val->s = v;\n\t\theader_val->len = p-v;\n\t\tbreak;\n\t}\n\n#ifdef EXTRA_DEBUG\n\tfor(i=0; i<h_size && h_name[i].s; i++)\n\t\tLM_DBG(\"header=[%p]-><%.*s> val=[%p]-><%.*s>\\n\",\n\t\t\th_name[i].s, h_name[i].len, h_name[i].s,\n\t\t\th_val[i].s, h_val[i].len, h_val[i].s);\n#endif\n\n\treturn 0;\n}\n\nint print_uri(struct sip_uri *uri, str *out_buf)\n{\n#define append_str_chunk(field) \\\n\tdo { \\\n\t\tif (bytes + uri->field.len > out_buf->len) { \\\n\t\t\tLM_ERR(\"no more space left! printed so far: '%.*s'\\n\", \\\n\t\t           bytes, out_buf->s); \\\n\t\t\treturn -1; \\\n\t\t} \\\n\t\tmemcpy(out_buf->s + bytes, uri->field.s, uri->field.len); \\\n\t\tbytes += uri->field.len; \\\n\t} while (0)\n\n#define append_char(ch) \\\n\tdo { \\\n\t\tif (bytes + 1 > out_buf->len) { \\\n\t\t\tLM_ERR(\"no more space left! printed so far: '%.*s'\\n\", \\\n\t\t           bytes, out_buf->s); \\\n\t\t\treturn -1; \\\n\t\t} \\\n\t\tout_buf->s[bytes++] = ch; \\\n\t} while (0)\n\n#define VAL(p) p##_val\n\n#define append_param(p) \\\n\tdo { \\\n\t\tif (uri->p.s) { \\\n\t\t\tappend_char(';'); \\\n\t\t\tappend_str_chunk(p); \\\n\t\t} \\\n\t} while (0)\n\n#define append_uk_param(idx) \\\n\tdo { \\\n\t\tif (uri->u_name[idx].s) { \\\n\t\t\tappend_char(';'); \\\n\t\t\tif (bytes + uri->u_name[idx].len > out_buf->len) { \\\n\t\t\t\tLM_ERR(\"no more space left! printed so far: '%.*s'\\n\", \\\n\t\t\t           bytes, out_buf->s); \\\n\t\t\t\treturn -1; \\\n\t\t\t} \\\n\t\t\tmemcpy(out_buf->s + bytes, uri->u_name[idx].s, uri->u_name[idx].len); \\\n\t\t\tbytes += uri->u_name[idx].len; \\\n\t\t\tif (uri->u_val[idx].s) { \\\n\t\t\t\tappend_char('='); \\\n\t\t\t\tif (bytes + uri->u_val[idx].len > out_buf->len) { \\\n\t\t\t\t\tLM_ERR(\"no more space left! printed so far: '%.*s'\\n\", \\\n\t\t\t\t           bytes, out_buf->s); \\\n\t\t\t\t\treturn -1; \\\n\t\t\t\t} \\\n\t\t\t\tmemcpy(out_buf->s + bytes, uri->u_val[idx].s, uri->u_val[idx].len); \\\n\t\t\t\tbytes += uri->u_val[idx].len; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n\tint bytes = 0;\n\tint i;\n\n\tmemcpy(out_buf->s, uri_type_names[uri->type].s, uri_type_names[uri->type].len);\n\tbytes += uri_type_names[uri->type].len;\n\tappend_char(':');\n\tappend_str_chunk(user);\n\tif (uri->passwd.s) {\n\t\tappend_char(':');\n\t\tappend_str_chunk(passwd);\n\t}\n\tif (uri->host.s) {\n\t\tappend_char('@');\n\t\tappend_str_chunk(host);\n\t}\n\tif (uri->port.s) {\n\t\tappend_char(':');\n\t\tappend_str_chunk(port);\n\t}\n\n\tappend_param(transport);\n\tappend_param(ttl);\n\tappend_param(user_param);\n\tappend_param(maddr);\n\tappend_param(method);\n\tappend_param(lr);\n\tappend_param(r2);\n\tappend_param(gr);\n\tappend_param(pn_provider);\n\tappend_param(pn_prid);\n\tappend_param(pn_param);\n\tappend_param(pn_purr);\n\n\tfor (i = 0; i < uri->u_params_no; i++)\n\t\tappend_uk_param(i);\n\n\tout_buf->len = bytes;\n\n\treturn 0;\n#undef append_str_chunk\n#undef append_char\n#undef VAL\n#undef append_param\n#undef append_uk_param\n}\n\n/* buf= pointer to beginning of uri (sip:x@foo.bar:5060;a=b?h=i)\n * len= len of uri\n * returns: fills uri & returns <0 on error or 0 if ok\n */\nint parse_uri(char* buf, int len, struct sip_uri* uri)\n{\n\tenum states  {\tURI_INIT, URI_USER, URI_PASSWORD, URI_PASSWORD_ALPHA,\n\t\t\t\t\tURI_HOST, URI_HOST_P,\n\t\t\t\t\tURI_HOST6_P, URI_HOST6_END, URI_PORT,\n\t\t\t\t\tURI_PARAM, URI_PARAM_P, URI_PARAM_VAL_P,\n\t\t\t\t\tURI_VAL_P, URI_HEADERS,\n\t\t\t\t\t/* param states */\n\t\t\t\t\t/* transport */\n\t\t\t\t\tPT_T, PT_R, PT_A, PT_N, PT_S, PT_P, PT_O, PT_R2, PT_T2,\n\t\t\t\t\tPT_eq,\n\t\t\t\t\t/* ttl */\n\t\t\t\t\tPTTL_T2, PTTL_L, PTTL_eq,\n\t\t\t\t\t/* user */\n\t\t\t\t\tPU_U, PU_S, PU_E, PU_R, PU_eq,\n\t\t\t\t\t/* method */\n\t\t\t\t\tPM_M, PM_E, PM_T, PM_H, PM_O, PM_D, PM_eq,\n\t\t\t\t\t/* maddr */\n\t\t\t\t\tPMA_A, PMA_D, PMA_D2, PMA_R, PMA_eq,\n\t\t\t\t\t/* lr */\n\t\t\t\t\tPLR_L, PLR_R_FIN, PLR_eq,\n\t\t\t\t\t/* gr */\n\t\t\t\t\tPG_G, PG_G_FIN, PG_eq,\n\t\t\t\t\t/* r2 */\n\t\t\t\t\tPR2_R, PR2_2_FIN, PR2_eq,\n\t\t\t\t\t/* transport values */\n\t\t\t\t\t/* udp */\n\t\t\t\t\tVU_U, VU_D, VU_P_FIN,\n\t\t\t\t\t/* tcp */\n\t\t\t\t\tVT_T, VT_C, VT_P_FIN,\n\t\t\t\t\t/* tls */\n\t\t\t\t\tVTLS_L, VTLS_S_FIN,\n\t\t\t\t\t/* sctp */\n\t\t\t\t\tVS_S, VS_C, VS_T, VS_P_FIN,\n\t\t\t\t\t/* ws */\n\t\t\t\t\tVW_W, VW_S, VW_S_FIN, VWS_S_FIN,\n\n\t\t\t\t\t/* pn-{provider, prid, param, purr} (RFC 8599 - SIP PN) */\n\t\t\t\t\tPN_P, PN_N, PN_dash, PN_P2, PN_PR,\n\t\t\t\t\tPN1_O, PN1_V, PN1_I, PN1_D, PN1_E, PN1_FIN, PN1_eq,\n\t\t\t\t\tPN2_I, PN2_D, PN2_eq,\n\t\t\t\t\tPN3_A, PN3_R, PN3_A2, PN3_M, PN3_eq,\n\t\t\t\t\tPN4_U, PN4_R, PN4_R2, PN4_eq,\n\n\t};\n\tregister enum states state;\n\tchar* s;\n\tchar* b; /* param start */\n\tchar *v; /* value start */\n\tstr* param; /* current param */\n\tstr* param_val; /* current param val */\n\tstr user;\n\tstr password;\n\tint port_no;\n\tregister char* p;\n\tchar* end;\n\tchar* pass;\n\tint found_user;\n\tint error_headers;\n\tunsigned int scheme;\n\turi_type backup;\n#ifdef EXTRA_DEBUG\n\tint i;\n#endif\n\n#define case_port( ch, var) \\\n\tcase ch: \\\n\t\t\t (var)=(var)*10+ch-'0'; \\\n\t\t\t break\n\n#define still_at_user  \\\n\t\t\t\t\t\tif (found_user==0){ \\\n\t\t\t\t\t\t\tuser.s=uri->host.s; \\\n\t\t\t\t\t\t\tif (pass){\\\n\t\t\t\t\t\t\t\tuser.len=pass-user.s; \\\n\t\t\t\t\t\t\t\tpassword.s=pass+1; \\\n\t\t\t\t\t\t\t\tpassword.len=p-password.s; \\\n\t\t\t\t\t\t\t}else{ \\\n\t\t\t\t\t\t\t\tuser.len=p-user.s; \\\n\t\t\t\t\t\t\t}\\\n\t\t\t\t\t\t\t/* save the uri type/scheme */ \\\n\t\t\t\t\t\t\tbackup=uri->type; \\\n\t\t\t\t\t\t\t/* everything else is 0 */ \\\n\t\t\t\t\t\t\tmemset(uri, 0, sizeof(struct sip_uri)); \\\n\t\t\t\t\t\t\t/* restore the scheme, copy user & pass */ \\\n\t\t\t\t\t\t\turi->type=backup; \\\n\t\t\t\t\t\t\turi->user=user; \\\n\t\t\t\t\t\t\tif (pass)\turi->passwd=password;  \\\n\t\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\t\tfound_user=1;\\\n\t\t\t\t\t\t\terror_headers=0; \\\n\t\t\t\t\t\t\tstate=URI_HOST; \\\n\t\t\t\t\t\t}else goto error_bad_char\n\n#define check_host_end \\\n\t\t\t\t\tcase ':': \\\n\t\t\t\t\t\t/* found the host */ \\\n\t\t\t\t\t\turi->host.s=s; \\\n\t\t\t\t\t\turi->host.len=p-s; \\\n\t\t\t\t\t\tstate=URI_PORT; \\\n\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase ';': \\\n\t\t\t\t\t\turi->host.s=s; \\\n\t\t\t\t\t\turi->host.len=p-s; \\\n\t\t\t\t\t\tstate=URI_PARAM; \\\n\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase '?': \\\n\t\t\t\t\t\turi->host.s=s; \\\n\t\t\t\t\t\turi->host.len=p-s; \\\n\t\t\t\t\t\tstate=URI_HEADERS; \\\n\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase '&': \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\tgoto error_bad_char\n\n\n#define param_set(t_start, v_start) \\\n\t\t\t\t\tparam->s=(t_start);\\\n\t\t\t\t\tparam->len=(p-(t_start));\\\n\t\t\t\t\tparam_val->s=(v_start); \\\n\t\t\t\t\tparam_val->len=(p-(v_start))\n\n#define u_param_set(t_start, v_start) \\\n\t\t\tif (uri->u_params_no < URI_MAX_U_PARAMS){ \\\n\t\t\t\tif((v_start)>(t_start)){ \\\n\t\t\t\t\turi->u_name[uri->u_params_no].s=(t_start); \\\n\t\t\t\t\turi->u_name[uri->u_params_no].len=((v_start)-(t_start)-1); \\\n\t\t\t\t\tif(p>(v_start)) { \\\n\t\t\t\t\t\turi->u_val[uri->u_params_no].s=(v_start); \\\n\t\t\t\t\t\turi->u_val[uri->u_params_no].len=(p-(v_start)); \\\n\t\t\t\t\t} \\\n\t\t\t\t} else { \\\n\t\t\t\t\turi->u_name[uri->u_params_no].s=(t_start); \\\n\t\t\t\t\turi->u_name[uri->u_params_no].len=(p-(t_start)); \\\n\t\t\t\t} \\\n\t\t\t\turi->u_params_no++; \\\n\t\t\t} else { \\\n\t\t\t\tLM_ERR(\"unknown URI param list excedeed\\n\"); \\\n\t\t\t}\n\n#define semicolon_case \\\n\t\t\t\t\tcase';': \\\n\t\t\t\t\t\tif (pass){ \\\n\t\t\t\t\t\t\tfound_user=1;/* no user, pass cannot contain ';'*/ \\\n\t\t\t\t\t\t\tpass=0; \\\n\t\t\t\t\t\t} \\\n\t\t\t\t\t\tstate=URI_PARAM   /* new param */\n\n#define question_case \\\n\t\t\t\t\tcase '?': \\\n\t\t\t\t\t\turi->params.s=s; \\\n\t\t\t\t\t\turi->params.len=p-s; \\\n\t\t\t\t\t\tstate=URI_HEADERS; \\\n\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\tif (pass){ \\\n\t\t\t\t\t\t\tfound_user=1;/* no user, pass cannot contain '?'*/ \\\n\t\t\t\t\t\t\tpass=0; \\\n\t\t\t\t\t\t}\n\n#define colon_case \\\n\t\t\t\t\tcase ':': \\\n\t\t\t\t\t\tif (found_user==0){ \\\n\t\t\t\t\t\t\t/*might be pass but only if user not found yet*/ \\\n\t\t\t\t\t\t\tif (pass){ \\\n\t\t\t\t\t\t\t\tfound_user=1; /* no user */ \\\n\t\t\t\t\t\t\t\tpass=0; \\\n\t\t\t\t\t\t\t}else{ \\\n\t\t\t\t\t\t\t\tpass=p; \\\n\t\t\t\t\t\t\t} \\\n\t\t\t\t\t\t} \\\n\t\t\t\t\t\tstate=URI_PARAM_P /* generic param */\n\n#define param_common_cases \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\t/* ughhh, this is still the user */ \\\n\t\t\t\t\t\tstill_at_user; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tsemicolon_case; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tquestion_case; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcolon_case; \\\n\t\t\t\t\t\tbreak\n\n#define u_param_common_cases \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\t/* ughhh, this is still the user */ \\\n\t\t\t\t\t\tstill_at_user; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tsemicolon_case; \\\n\t\t\t\t\t\tu_param_set(b, v); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tquestion_case; \\\n\t\t\t\t\t\tu_param_set(b, v); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcolon_case; \\\n\t\t\t\t\t\tbreak\n\n#define value_common_cases \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\t/* ughhh, this is still the user */ \\\n\t\t\t\t\t\tstill_at_user; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tsemicolon_case; \\\n\t\t\t\t\t\tparam_set(b, v); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tquestion_case; \\\n\t\t\t\t\t\tparam_set(b, v); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcolon_case; \\\n\t\t\t\t\t\tstate=URI_VAL_P; \\\n\t\t\t\t\t\tbreak\n\n#define param_switch(old_state, c1, c2, new_state) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tu_param_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_PARAM_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define param_switch1(old_state, c1, new_state) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\t\tstate=(new_state); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tparam_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_PARAM_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define param_xswitch1(old_state, c1, new_state) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\t\tstate=(new_state); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tgoto error_bad_char; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define param_switch_big(old_state, c1, c2, d1, d2, new_state_c, new_state_d) \\\n\t\t\tcase old_state : \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state_c); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase d1: \\\n\t\t\t\t\tcase d2: \\\n\t\t\t\t\t\tstate=(new_state_d); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tu_param_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_PARAM_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define param_switch_bigger(old_state, c1, c2, d1, d2, e1, e2, new_state_c, new_state_d, new_state_e) \\\n\t\t\tcase old_state : \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state_c); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase d1: \\\n\t\t\t\t\tcase d2: \\\n\t\t\t\t\t\tstate=(new_state_d); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase e1: \\\n\t\t\t\t\tcase e2: \\\n\t\t\t\t\t\tstate=(new_state_e); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tu_param_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_PARAM_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define value_switch(old_state, c1, c2, new_state) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tvalue_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_VAL_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define value_switch_big(old_state, c1, c2, d1, d2, new_state_c, new_state_d) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state_c); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase d1: \\\n\t\t\t\t\tcase d2: \\\n\t\t\t\t\t\tstate=(new_state_d); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tvalue_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_VAL_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n\n#define transport_fin(c_state, proto_no) \\\n\t\t\tcase c_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\tstill_at_user; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tsemicolon_case; \\\n\t\t\t\t\t\tparam_set(b, v); \\\n\t\t\t\t\t\turi->proto=(proto_no); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tquestion_case; \\\n\t\t\t\t\t\tparam_set(b, v); \\\n\t\t\t\t\t\turi->proto=(proto_no); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcolon_case;  \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_VAL_P; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n\n\n\n\t/* init */\n\tend=buf+len;\n\tp=buf+4;\n\tfound_user=0;\n\terror_headers=0;\n\tb=v=0;\n\tparam=param_val=0;\n\tpass=0;\n\tpassword.s = 0;\n\tpassword.len = 0;\n\tport_no=0;\n\tstate=URI_INIT;\n\tmemset(uri, 0, sizeof(struct sip_uri)); /* zero it all, just to be sure*/\n\t/*look for sip:, sips: or tel:*/\n\tif (len<5) goto error_too_short;\n\tscheme=buf[0]+(buf[1]<<8)+(buf[2]<<16)+(buf[3]<<24);\n\tscheme|=0x20202020;\n\tif (scheme==SIP_SCH){\n\t\turi->type=SIP_URI_T;\n\t}else if(scheme==SIPS_SCH){\n\t\tif(buf[4]==':'){ p++; uri->type=SIPS_URI_T;}\n\t\telse goto error_bad_uri;\n\t}else if (scheme==TEL_SCH){\n\t\turi->type=TEL_URI_T;\n\t}else if (scheme==URN_SERVICE_SCH){\n\t\tif ((end-(buf+3)) >= URN_SERVICE_STR_LEN\n\t\t        && memcmp(buf+3,URN_SERVICE_STR,URN_SERVICE_STR_LEN) == 0) {\n\t\t\tp+= URN_SERVICE_STR_LEN-1;\n\t\t\turi->type=URN_SERVICE_URI_T;\n\t\t}\n\t\telse if ((end-(buf+3)) >= URN_NENA_SERVICE_STR_LEN\n\t\t        && memcmp(buf+3,URN_NENA_SERVICE_STR,URN_NENA_SERVICE_STR_LEN) == 0) {\n\t\t\tp+= URN_NENA_SERVICE_STR_LEN-1;\n\t\t\turi->type=URN_NENA_SERVICE_URI_T;\n\t\t}else goto error_bad_uri;\n\t}else goto error_bad_uri;\n\n\ts=p;\n\tfor(;p<end; p++){\n\t\tswitch((unsigned char)state){\n\t\t\tcase URI_INIT:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\t/* uri =  [ipv6address]... */\n\t\t\t\t\t\tstate=URI_HOST6_P;\n\t\t\t\t\t\ts=p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\t/* invalid, no uri can start with ']' */\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\t/* the same as above for ':' */\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t\tcase '@': /* error no user part */\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_USER;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_USER:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\t/* found the user*/\n\t\t\t\t\t\turi->user.s=s;\n\t\t\t\t\t\turi->user.len=p-s;\n\t\t\t\t\t\tstate=URI_HOST;\n\t\t\t\t\t\tfound_user=1;\n\t\t\t\t\t\ts=p+1; /* skip '@' */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\t/* found the user, or the host? */\n\t\t\t\t\t\turi->user.s=s;\n\t\t\t\t\t\turi->user.len=p-s;\n\t\t\t\t\t\tstate=URI_PASSWORD;\n\t\t\t\t\t\ts=p+1; /* skip ':' */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\t/* this could be still the user or\n\t\t\t\t\t\t * params?*/\n\t\t\t\t\t\turi->host.s=s;\n\t\t\t\t\t\turi->host.len=p-s;\n\t\t\t\t\t\tstate=URI_PARAM;\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?': /* still user or headers? */\n\t\t\t\t\t\turi->host.s=s;\n\t\t\t\t\t\turi->host.len=p-s;\n\t\t\t\t\t\tstate=URI_HEADERS;\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/* almost anything permitted in the user part */\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']': /* the user part cannot contain \"[]\" */\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PASSWORD: /* this can also be the port (missing user)*/\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\t/* found the password*/\n\t\t\t\t\t\turi->passwd.s=s;\n\t\t\t\t\t\turi->passwd.len=p-s;\n\t\t\t\t\t\tport_no=0;\n\t\t\t\t\t\tstate=URI_HOST;\n\t\t\t\t\t\tfound_user=1;\n\t\t\t\t\t\ts=p+1; /* skip '@' */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\t/* upps this is the port */\n\t\t\t\t\t\turi->port.s=s;\n\t\t\t\t\t\turi->port.len=p-s;\n\t\t\t\t\t\turi->port_no=port_no;\n\t\t\t\t\t\t/* user contains in fact the host */\n\t\t\t\t\t\turi->host.s=uri->user.s;\n\t\t\t\t\t\turi->host.len=uri->user.len;\n\t\t\t\t\t\turi->user.s=0;\n\t\t\t\t\t\turi->user.len=0;\n\t\t\t\t\t\tstate=URI_PARAM;\n\t\t\t\t\t\tfound_user=1; /*  there is no user part */\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\t/* upps this is the port */\n\t\t\t\t\t\turi->port.s=s;\n\t\t\t\t\t\turi->port.len=p-s;\n\t\t\t\t\t\turi->port_no=port_no;\n\t\t\t\t\t\t/* user contains in fact the host */\n\t\t\t\t\t\turi->host.s=uri->user.s;\n\t\t\t\t\t\turi->host.len=uri->user.len;\n\t\t\t\t\t\turi->user.s=0;\n\t\t\t\t\t\turi->user.len=0;\n\t\t\t\t\t\tstate=URI_HEADERS;\n\t\t\t\t\t\tfound_user=1; /*  there is no user part */\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase_port('0', port_no);\n\t\t\t\t\tcase_port('1', port_no);\n\t\t\t\t\tcase_port('2', port_no);\n\t\t\t\t\tcase_port('3', port_no);\n\t\t\t\t\tcase_port('4', port_no);\n\t\t\t\t\tcase_port('5', port_no);\n\t\t\t\t\tcase_port('6', port_no);\n\t\t\t\t\tcase_port('7', port_no);\n\t\t\t\t\tcase_port('8', port_no);\n\t\t\t\t\tcase_port('9', port_no);\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* it can't be the port, non number found */\n\t\t\t\t\t\tport_no=0;\n\t\t\t\t\t\tstate=URI_PASSWORD_ALPHA;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PASSWORD_ALPHA:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\t/* found the password*/\n\t\t\t\t\t\turi->passwd.s=s;\n\t\t\t\t\t\turi->passwd.len=p-s;\n\t\t\t\t\t\tstate=URI_HOST;\n\t\t\t\t\t\tfound_user=1;\n\t\t\t\t\t\ts=p+1; /* skip '@' */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';': /* contains non-numbers => cannot be port no*/\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tgoto error_bad_port;\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_HOST:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tstate=URI_HOST6_P;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ':':\n\t\t\t\t\tcase ';':\n\t\t\t\t\tcase '?': /* null host name ->invalid */\n\t\t\t\t\tcase '&':\n\t\t\t\t\tcase '@': /*chars not allowed in hosts names */\n\t\t\t\t\t\tgoto error_bad_host;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_HOST_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_HOST_P:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcheck_host_end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_HOST6_END:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcheck_host_end;\n\t\t\t\t\tdefault: /*no chars allowed after [ipv6] */\n\t\t\t\t\t\tgoto error_bad_host;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_HOST6_P:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tstate=URI_HOST6_END;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase '&':\n\t\t\t\t\tcase '@':\n\t\t\t\t\tcase ';':\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tgoto error_bad_host;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PORT:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\turi->port.s=s;\n\t\t\t\t\t\turi->port.len=p-s;\n\t\t\t\t\t\turi->port_no=port_no;\n\t\t\t\t\t\tstate=URI_PARAM;\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\turi->port.s=s;\n\t\t\t\t\t\turi->port.len=p-s;\n\t\t\t\t\t\turi->port_no=port_no;\n\t\t\t\t\t\tstate=URI_HEADERS;\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase_port('0', port_no);\n\t\t\t\t\tcase_port('1', port_no);\n\t\t\t\t\tcase_port('2', port_no);\n\t\t\t\t\tcase_port('3', port_no);\n\t\t\t\t\tcase_port('4', port_no);\n\t\t\t\t\tcase_port('5', port_no);\n\t\t\t\t\tcase_port('6', port_no);\n\t\t\t\t\tcase_port('7', port_no);\n\t\t\t\t\tcase_port('8', port_no);\n\t\t\t\t\tcase_port('9', port_no);\n\t\t\t\t\tcase '&':\n\t\t\t\t\tcase '@':\n\t\t\t\t\tcase ':':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto error_bad_port;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PARAM: /* beginning of a new param */\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\t/* recognized params */\n\t\t\t\t\tcase 't':\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PT_T;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PU_U;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'm':\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PM_M;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'l':\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PLR_L;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'g':\n\t\t\t\t\tcase 'G':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PG_G;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PR2_R;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'p':\n\t\t\t\t\tcase 'P':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PN_P;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PARAM_P: /* ignore current param */\n\t\t\t\t/* supported params:\n\t\t\t\t *  maddr, transport, ttl, lr, user, method, r2  */\n\t\t\t\tswitch(*p){\n\t\t\t\t\tu_param_common_cases;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tv=p + 1;\n\t\t\t\t\t\tstate=URI_PARAM_VAL_P;\n\t\t\t\t\t\tbreak;\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase URI_PARAM_VAL_P: /* value of the ignored current param */\n\t\t\t\tswitch(*p){\n\t\t\t\t\tu_param_common_cases;\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t/* ugly but fast param names parsing */\n\t\t\t/*transport */\n\t\t\tparam_switch_big(PT_T,  'r', 'R', 't', 'T', PT_R, PTTL_T2);\n\t\t\tparam_switch(PT_R,  'a', 'A', PT_A);\n\t\t\tparam_switch(PT_A,  'n', 'N', PT_N);\n\t\t\tparam_switch(PT_N,  's', 'S', PT_S);\n\t\t\tparam_switch(PT_S,  'p', 'P', PT_P);\n\t\t\tparam_switch(PT_P,  'o', 'O', PT_O);\n\t\t\tparam_switch(PT_O,  'r', 'R', PT_R2);\n\t\t\tparam_switch(PT_R2, 't', 'T', PT_T2);\n\t\t\tparam_switch1(PT_T2, '=',  PT_eq);\n\t\t\t/* value parsing */\n\t\t\tcase PT_eq:\n\t\t\t\tparam=&uri->transport;\n\t\t\t\tparam_val=&uri->transport_val;\n\t\t\t\turi->proto = PROTO_OTHER;\n\t\t\t\tswitch (*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=VU_U;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=VT_T;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=VS_S;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'w':\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=VW_W;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* generic value */\n\t\t\tcase URI_VAL_P:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tvalue_common_cases;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t/* udp */\n\t\t\tvalue_switch(VU_U,  'd', 'D', VU_D);\n\t\t\tvalue_switch(VU_D,  'p', 'P', VU_P_FIN);\n\t\t\ttransport_fin(VU_P_FIN, PROTO_UDP);\n\t\t\t/* tcp */\n\t\t\tvalue_switch_big(VT_T,  'c', 'C', 'l', 'L', VT_C, VTLS_L);\n\t\t\tvalue_switch(VT_C,  'p', 'P', VT_P_FIN);\n\t\t\ttransport_fin(VT_P_FIN, PROTO_TCP);\n\t\t\t/* tls */\n\t\t\tvalue_switch(VTLS_L, 's', 'S', VTLS_S_FIN);\n\t\t\ttransport_fin(VTLS_S_FIN, PROTO_TLS);\n\t\t\t/* sctp */\n\t\t\tvalue_switch(VS_S, 'c', 'C', VS_C);\n\t\t\tvalue_switch(VS_C, 't', 'T', VS_T);\n\t\t\tvalue_switch(VS_T, 'p', 'P', VS_P_FIN);\n\t\t\ttransport_fin(VS_P_FIN, PROTO_SCTP);\n\t\t\t/* ws */\n\t\t\tvalue_switch(VW_W, 's', 'S', VW_S);\n\t\t\tcase VW_S:\n\t\t\t\tif (*p == 's' || *p == 'S') {\n\t\t\t\t\tstate=(VWS_S_FIN);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* if not a 's' transiting to VWS_S_FIN, fallback\n\t\t\t\t * to testing as existing VW_S_FIN (NOTE the missing break) */\n\t\t\t\tstate=(VW_S_FIN);\n\t\t\ttransport_fin(VW_S_FIN, PROTO_WS);\n\t\t\ttransport_fin(VWS_S_FIN, PROTO_WSS);\n\n\t\t\t/* ttl */\n\t\t\tparam_switch(PTTL_T2,  'l', 'L', PTTL_L);\n\t\t\tparam_switch1(PTTL_L,  '=', PTTL_eq);\n\t\t\tcase PTTL_eq:\n\t\t\t\tparam=&uri->ttl;\n\t\t\t\tparam_val=&uri->ttl_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* user param */\n\t\t\tparam_switch(PU_U, 's', 'S', PU_S);\n\t\t\tparam_switch(PU_S, 'e', 'E', PU_E);\n\t\t\tparam_switch(PU_E, 'r', 'R', PU_R);\n\t\t\tparam_switch1(PU_R, '=', PU_eq);\n\t\t\tcase PU_eq:\n\t\t\t\tparam=&uri->user_param;\n\t\t\t\tparam_val=&uri->user_param_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* method*/\n\t\t\tparam_switch_big(PM_M, 'e', 'E', 'a', 'A', PM_E, PMA_A);\n\t\t\tparam_switch(PM_E, 't', 'T', PM_T);\n\t\t\tparam_switch(PM_T, 'h', 'H', PM_H);\n\t\t\tparam_switch(PM_H, 'o', 'O', PM_O);\n\t\t\tparam_switch(PM_O, 'd', 'D', PM_D);\n\t\t\tparam_switch1(PM_D, '=', PM_eq);\n\t\t\tcase PM_eq:\n\t\t\t\tparam=&uri->method;\n\t\t\t\tparam_val=&uri->method_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/*maddr*/\n\t\t\tparam_switch(PMA_A,  'd', 'D', PMA_D);\n\t\t\tparam_switch(PMA_D,  'd', 'D', PMA_D2);\n\t\t\tparam_switch(PMA_D2, 'r', 'R', PMA_R);\n\t\t\tparam_switch1(PMA_R, '=', PMA_eq);\n\t\t\tcase PMA_eq:\n\t\t\t\tparam=&uri->maddr;\n\t\t\t\tparam_val=&uri->maddr_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* lr */\n\t\t\tparam_switch(PLR_L,  'r', 'R', PLR_R_FIN);\n\t\t\tcase PLR_R_FIN:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tstate=PLR_eq;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsemicolon_case;\n\t\t\t\t\t\turi->lr.s=b;\n\t\t\t\t\t\turi->lr.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tquestion_case;\n\t\t\t\t\t\turi->lr.s=b;\n\t\t\t\t\t\turi->lr.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcolon_case;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* handle lr=something case */\n\t\t\tcase PLR_eq:\n\t\t\t\tparam=&uri->lr;\n\t\t\t\tparam_val=&uri->lr_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* r2 */\n\t\t\tparam_switch1(PR2_R,  '2', PR2_2_FIN);\n\t\t\tcase PR2_2_FIN:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tstate=PR2_eq;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsemicolon_case;\n\t\t\t\t\t\turi->r2.s=b;\n\t\t\t\t\t\turi->r2.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tquestion_case;\n\t\t\t\t\t\turi->r2.s=b;\n\t\t\t\t\t\turi->r2.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcolon_case;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* handle r2=something case */\n\t\t\tcase PR2_eq:\n\t\t\t\tparam=&uri->r2;\n\t\t\t\tparam_val=&uri->r2_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\t/* gr */\n\t\t\tparam_switch(PG_G,  'r', 'R', PG_G_FIN);\n\t\t\tcase PG_G_FIN:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tstate=PG_eq;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsemicolon_case;\n\t\t\t\t\t\turi->gr.s=b;\n\t\t\t\t\t\turi->gr.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tquestion_case;\n\t\t\t\t\t\turi->gr.s=b;\n\t\t\t\t\t\turi->gr.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcolon_case;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* handle gr=something case */\n\t\t\tcase PG_eq:\n\t\t\t\tparam=&uri->gr;\n\t\t\t\tparam_val=&uri->gr_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\t/* pn-* */\n\t\t\tparam_switch(PN_P, 'n', 'N', PN_N);\n\t\t\tparam_switch1(PN_N, '-', PN_dash);\n\t\t\tparam_switch(PN_dash, 'p', 'P', PN_P2);\n\n\t\t\tparam_switch_bigger(PN_P2, 'r', 'R', 'a', 'A', 'u', 'U',\n\t\t\t                    PN_PR, PN3_A, PN4_U);\n\t\t\tparam_switch_big(PN_PR, 'o', 'O', 'i', 'I', PN1_O, PN2_I);\n\n\t\t\t/* pn-provider */\n\t\t\tparam_switch(PN1_O, 'v', 'V', PN1_V);\n\t\t\tparam_switch(PN1_V, 'i', 'I', PN1_I);\n\t\t\tparam_switch(PN1_I, 'd', 'D', PN1_D);\n\t\t\tparam_switch(PN1_D, 'e', 'E', PN1_E);\n\t\t\tparam_switch(PN1_E, 'r', 'R', PN1_FIN);\n\t\t\tcase PN1_FIN:\n\t\t\t\tparam=&uri->pn_provider;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tstate=PN1_eq;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsemicolon_case;\n\t\t\t\t\t\turi->pn_provider.s=b;\n\t\t\t\t\t\turi->pn_provider.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tquestion_case;\n\t\t\t\t\t\turi->pn_provider.s=b;\n\t\t\t\t\t\turi->pn_provider.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcolon_case;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* handle pn-provider=something case */\n\t\t\tcase PN1_eq:\n\t\t\t\tparam=&uri->pn_provider;\n\t\t\t\tparam_val=&uri->pn_provider_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* pn-prid */\n\t\t\tparam_switch(PN2_I, 'd', 'D', PN2_D);\n\t\t\tparam_xswitch1(PN2_D, '=', PN2_eq);\n\t\t\tcase PN2_eq:\n\t\t\t\tparam=&uri->pn_prid;\n\t\t\t\tparam_val=&uri->pn_prid_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* pn-param */\n\t\t\tparam_switch(PN3_A, 'r', 'R', PN3_R);\n\t\t\tparam_switch(PN3_R, 'a', 'A', PN3_A2);\n\t\t\tparam_switch(PN3_A2, 'm', 'M', PN3_M);\n\t\t\tparam_xswitch1(PN3_M, '=', PN3_eq);\n\t\t\tcase PN3_eq:\n\t\t\t\tparam=&uri->pn_param;\n\t\t\t\tparam_val=&uri->pn_param_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* pn-purr */\n\t\t\tparam_switch(PN4_U, 'r', 'R', PN4_R);\n\t\t\tparam_switch(PN4_R, 'r', 'R', PN4_R2);\n\t\t\tparam_xswitch1(PN4_R2, '=', PN4_eq);\n\t\t\tcase PN4_eq:\n\t\t\t\tparam=&uri->pn_purr;\n\t\t\t\tparam_val=&uri->pn_purr_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\tcase URI_HEADERS:\n\t\t\t\t/* for now nobody needs them so we completely ignore the\n\t\t\t\t * headers (they are not allowed in request uri) --andrei */\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\t/* yak, we are still at user */\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\t/* we might be still parsing user, try it */\n\t\t\t\t\t\tif (found_user) goto error_bad_char;\n\t\t\t\t\t\terror_headers=1; /* if this is not the user\n\t\t\t\t\t\t\t\t\t\t\twe have an error */\n\t\t\t\t\t\t/* if pass is set => it cannot be user:pass\n\t\t\t\t\t\t * => error (';') is illegal in a header */\n\t\t\t\t\t\tif (pass) goto error_headers;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\tif (found_user==0){\n\t\t\t\t\t\t\t/*might be pass but only if user not found yet*/\n\t\t\t\t\t\t\tif (pass){\n\t\t\t\t\t\t\t\tfound_user=1; /* no user */\n\t\t\t\t\t\t\t\tpass=0;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpass=p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tif (pass){\n\t\t\t\t\t\t\tfound_user=1; /* no user, pass cannot contain '?'*/\n\t\t\t\t\t\t\tpass=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto error_bug;\n\t\t}\n\t}\n\n\t/*end of uri */\n\tswitch (state){\n\t\tcase URI_INIT: /* error empty uri */\n\t\t\tgoto error_too_short;\n\t\tcase URI_USER:\n\t\t\t/* this is the host, it can't be the user */\n\t\t\tif (found_user) goto error_bad_uri;\n\t\t\turi->host.s=s;\n\t\t\turi->host.len=p-s;\n\t\t\tstate=URI_HOST;\n\t\t\tbreak;\n\t\tcase URI_PASSWORD:\n\t\t\t/* this is the port, it can't be the passwd */\n\t\t\tif (found_user) goto error_bad_port;\n\t\t\turi->port.s=s;\n\t\t\turi->port.len=p-s;\n\t\t\turi->port_no=port_no;\n\t\t\turi->host=uri->user;\n\t\t\turi->user.s=0;\n\t\t\turi->user.len=0;\n\t\t\tbreak;\n\t\tcase URI_PASSWORD_ALPHA:\n\t\t\t/* this is the port, it can't be the passwd */\n\t\t\tgoto error_bad_port;\n\t\tcase URI_HOST_P:\n\t\tcase URI_HOST6_END:\n\t\t\turi->host.s=s;\n\t\t\turi->host.len=p-s;\n\t\t\tbreak;\n\t\tcase URI_HOST: /* error: null host */\n\t\tcase URI_HOST6_P: /* error: unterminated ipv6 reference*/\n\t\t\tgoto error_bad_host;\n\t\tcase URI_PORT:\n\t\t\turi->port.s=s;\n\t\t\turi->port.len=p-s;\n\t\t\turi->port_no=port_no;\n\t\t\tbreak;\n\t\tcase URI_PARAM:\n\t\tcase URI_PARAM_P:\n\t\tcase URI_PARAM_VAL_P:\n\t\t\tu_param_set(b, v);\n\t\t/* intermediate param states */\n\t\tcase PT_T: /* transport */\n\t\tcase PT_R:\n\t\tcase PT_A:\n\t\tcase PT_N:\n\t\tcase PT_S:\n\t\tcase PT_P:\n\t\tcase PT_O:\n\t\tcase PT_R2:\n\t\tcase PT_T2:\n\t\tcase PT_eq: /* ignore empty transport params */\n\t\tcase PTTL_T2: /* ttl */\n\t\tcase PTTL_L:\n\t\tcase PTTL_eq:\n\t\tcase PU_U:  /* user */\n\t\tcase PU_S:\n\t\tcase PU_E:\n\t\tcase PU_R:\n\t\tcase PU_eq:\n\t\tcase PM_M: /* method */\n\t\tcase PM_E:\n\t\tcase PM_T:\n\t\tcase PM_H:\n\t\tcase PM_O:\n\t\tcase PM_D:\n\t\tcase PM_eq:\n\t\tcase PLR_L: /* lr */\n\t\tcase PR2_R:  /* r2 */\n\t\tcase PG_G: /* gr */\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tbreak;\n\t\t/* fin param states */\n\t\tcase PLR_R_FIN:\n\t\tcase PLR_eq:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\turi->lr.s=b;\n\t\t\turi->lr.len=p-b;\n\t\t\tbreak;\n\t\tcase PR2_2_FIN:\n\t\tcase PR2_eq:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\turi->r2.s=b;\n\t\t\turi->r2.len=p-b;\n\t\t\tbreak;\n\t\tcase PG_G_FIN:\n\t\tcase PG_eq:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\turi->gr.s=b;\n\t\t\turi->gr.len=p-b;\n\t\t\tbreak;\n\t\tcase PN1_FIN:\n\t\tcase PN1_eq:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\turi->pn_provider.s=b;\n\t\t\turi->pn_provider.len=p-b;\n\t\t\tbreak;\n\t\tcase URI_VAL_P:\n\t\t/* intermediate value states */\n\t\tcase VU_U:\n\t\tcase VU_D:\n\t\tcase VT_T:\n\t\tcase VT_C:\n\t\tcase VTLS_L:\n\t\tcase VS_S:\n\t\tcase VS_C:\n\t\tcase VW_W:\n\t\tcase VS_T:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\tbreak;\n\t\t/* fin value states */\n\t\tcase VU_P_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_UDP;\n\t\t\tbreak;\n\t\tcase VT_P_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_TCP;\n\t\t\tbreak;\n\t\tcase VTLS_S_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_TLS;\n\t\t\tbreak;\n\t\tcase VS_P_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_SCTP;\n\t\t\tbreak;\n\t\tcase VW_S:\n\t\tcase VW_S_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_WS;\n\t\t\tbreak;\n\t\tcase VWS_S_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_WSS;\n\t\t\tbreak;\n\t\t/* headers */\n\t\tcase URI_HEADERS:\n\t\t\turi->headers.s=s;\n\t\t\turi->headers.len=p-s;\n\t\t\tif (error_headers) goto error_headers;\n\t\t\tbreak;\n\t\t/* intermediate PN param states */\n\t\tcase PN_P:\n\t\tcase PN_N:\n\t\tcase PN_dash:\n\t\tcase PN_P2:\n\t\tcase PN_PR:\n\t\tcase PN1_O:\n\t\tcase PN1_V:\n\t\tcase PN1_I:\n\t\tcase PN1_D:\n\t\tcase PN1_E:\n\t\tcase PN2_I:\n\t\tcase PN3_A:\n\t\tcase PN3_R:\n\t\tcase PN3_A2:\n\t\tcase PN4_U:\n\t\tcase PN4_R:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tbreak;\n\t\tcase PN2_D:\n\t\tcase PN2_eq:\n\t\tcase PN3_M:\n\t\tcase PN3_eq:\n\t\tcase PN4_R2:\n\t\tcase PN4_eq:\n\t\t\tgoto error_bad_uri;\n\t\tdefault:\n\t\t\tgoto error_bug;\n\t}\n\tswitch(uri->type){\n\t\tcase TEL_URI_T:\n\t\tcase TELS_URI_T:\n\t\t\t/* fix tel uris, move the number in uri and empty the host */\n\t\t\turi->user=uri->host;\n\t\t\turi->host.s=\"\";\n\t\t\turi->host.len=0;\n\t\t\tbreak;\n\t\tcase SIP_URI_T:\n\t\tcase SIPS_URI_T:\n\t\tcase URN_SERVICE_URI_T:\n\t\t\t/* nothing to do for these URIs */\n\t\t\tbreak;\n\t\tcase URN_NENA_SERVICE_URI_T:\n\t\t\turi->user.s=0;\n\t\t\turi->user.len=0;\n\t\t\turi->host.s=\"\";\n\t\t\turi->host.len=0;\n\t\t\tbreak;\n\t\tcase ERROR_URI_T:\n\t\t\tLM_ERR(\"unexpected error (BUG?)\\n\");\n\t\t\tgoto error_bad_uri;\n\t\t\tbreak; /* do nothing, avoids a compilation warning */\n\t}\n#ifdef EXTRA_DEBUG\n\t/* do stuff */\n\tLM_DBG(\"parsed uri:\\n type=%d user=<%.*s>(%d)\\n passwd=<%.*s>(%d)\\n\"\n\t\t\t\" host=<%.*s>(%d)\\n port=<%.*s>(%d): %d\\n params=<%.*s>(%d)\\n\"\n\t\t\t\" headers=<%.*s>(%d)\\n\",\n\t\t\turi->type,\n\t\t\turi->user.len, ZSW(uri->user.s), uri->user.len,\n\t\t\turi->passwd.len, ZSW(uri->passwd.s), uri->passwd.len,\n\t\t\turi->host.len, ZSW(uri->host.s), uri->host.len,\n\t\t\turi->port.len, ZSW(uri->port.s), uri->port.len, uri->port_no,\n\t\t\turi->params.len, ZSW(uri->params.s), uri->params.len,\n\t\t\turi->headers.len, ZSW(uri->headers.s), uri->headers.len\n\t\t);\n\tLM_DBG(\" uri params:\\n   transport=<%.*s>, val=<%.*s>, proto=%d\\n\",\n\t\t\turi->transport.len, ZSW(uri->transport.s), uri->transport_val.len,\n\t\t\tZSW(uri->transport_val.s), uri->proto);\n\tLM_DBG(\"   user-param=<%.*s>, val=<%.*s>\\n\",\n\t\t\turi->user_param.len, ZSW(uri->user_param.s),\n\t\t\turi->user_param_val.len, ZSW(uri->user_param_val.s));\n\tLM_DBG(\"   method=<%.*s>, val=<%.*s>\\n\",\n\t\t\turi->method.len, ZSW(uri->method.s),\n\t\t\turi->method_val.len, ZSW(uri->method_val.s));\n\tLM_DBG(\"   ttl=<%.*s>, val=<%.*s>\\n\",\n\t\t\turi->ttl.len, ZSW(uri->ttl.s),\n\t\t\turi->ttl_val.len, ZSW(uri->ttl_val.s));\n\tLM_DBG(\"   maddr=<%.*s>, val=<%.*s>\\n\",\n\t\t\turi->maddr.len, ZSW(uri->maddr.s),\n\t\t\turi->maddr_val.len, ZSW(uri->maddr_val.s));\n\tLM_DBG(\"   lr=<%.*s>, val=<%.*s>\\n\", uri->lr.len, ZSW(uri->lr.s),\n\t\t\turi->lr_val.len, ZSW(uri->lr_val.s));\n\tLM_DBG(\"   r2=<%.*s>, val=<%.*s>\\n\", uri->r2.len, ZSW(uri->r2.s),\n\t\t\turi->r2_val.len, ZSW(uri->r2_val.s));\n\tfor(i=0; i<URI_MAX_U_PARAMS && uri->u_name[i].s; i++)\n\t\tLM_DBG(\"uname=[%p]-><%.*s> uval=[%p]-><%.*s>\\n\",\n\t\t\turi->u_name[i].s, uri->u_name[i].len, uri->u_name[i].s,\n\t\t\turi->u_val[i].s, uri->u_val[i].len, uri->u_val[i].s);\n\tif (i!=uri->u_params_no)\n\t\tLM_ERR(\"inconsisten # of u_name:[%d]!=[%d]\\n\", i, uri->u_params_no);\n#endif\n\treturn 0;\n\nerror_too_short:\n\tLM_ERR(\"uri too short: <%.*s> (%d)\\n\",\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bad_char:\n\tLM_ERR(\"bad char '%c' in state %d\"\n\t\t\t\" parsed: <%.*s> (%d) / <%.*s> (%d)\\n\",\n\t\t\t*p, state, (int)(p-buf), ZSW(buf), (int)(p-buf),\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bad_host:\n\tLM_ERR(\"bad host in uri (error at char %c in\"\n\t\t\t\" state %d) parsed: <%.*s>(%d) /<%.*s> (%d)\\n\",\n\t\t\t*p, state, (int)(p-buf), ZSW(buf), (int)(p-buf),\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bad_port:\n\tLM_ERR(\"bad port in uri (error at char %c in\"\n\t\t\t\" state %d) parsed: <%.*s>(%d) /<%.*s> (%d)\\n\",\n\t\t\t*p, state, (int)(p-buf), ZSW(buf), (int)(p-buf),\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bad_uri:\n\tLM_ERR(\"bad uri, state %d parsed: <%.*s> (%d) / <%.*s> (%d)\\n\",\n\t\t\t state, (int)(p-buf), ZSW(buf), (int)(p-buf), len,\n\t\t\t ZSW(buf), len);\n\tgoto error_exit;\nerror_headers:\n\tLM_ERR(\"bad uri headers: <%.*s>(%d) / <%.*s>(%d)\\n\",\n\t\t\turi->headers.len, ZSW(uri->headers.s), uri->headers.len,\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bug:\n\tLM_CRIT(\"bad state %d parsed: <%.*s> (%d) / <%.*s> (%d)\\n\",\n\t\t\t state, (int)(p-buf), ZSW(buf), (int)(p-buf), len, ZSW(buf), len);\nerror_exit:\n\tser_error=E_BAD_URI;\n\turi->type=ERROR_URI_T;\n\tupdate_stat(bad_URIs, 1);\n\treturn E_BAD_URI;\n}\n\n\nint parse_sip_msg_uri(struct sip_msg* msg)\n{\n\tchar* tmp;\n\tint tmp_len;\n\tif (msg->parsed_uri_ok) return 1;\n\n\tif (msg->new_uri.s){\n\t\ttmp=msg->new_uri.s;\n\t\ttmp_len=msg->new_uri.len;\n\t}else{\n\t\ttmp=msg->first_line.u.request.uri.s;\n\t\ttmp_len=msg->first_line.u.request.uri.len;\n\t}\n\tif (parse_uri(tmp, tmp_len, &msg->parsed_uri)<0){\n\t\tLM_ERR(\"bad uri <%.*s>\\n\", tmp_len, tmp);\n\t\tmsg->parsed_uri_ok=0;\n\t\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM, \"error parsing r-uri\");\n\t\tset_err_reply(400, \"bad r-uri\");\n\t\treturn -1;\n\t}\n\tmsg->parsed_uri_ok=1;\n\treturn 0;\n}\n\n\nint parse_orig_ruri(struct sip_msg* msg)\n{\n\tstr *uri;\n\n\tif (msg->parsed_orig_ruri_ok)\n\t\treturn 1;\n\n\turi = &REQ_LINE(msg).uri;\n\n\tif (parse_uri(uri->s, uri->len, &msg->parsed_orig_ruri)<0) {\n\t\tLM_ERR(\"bad uri <%.*s>\\n\", uri->len, ZSW(uri->s));\n\t\tmsg->parsed_orig_ruri_ok = 0;\n\t\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,\n\t\t\t\t\"error parsing incoming uri\");\n\t\tset_err_reply(400, \"bad i-uri\");\n\t\treturn -1;\n\t}\n\n\tmsg->parsed_orig_ruri_ok = 1;\n\treturn 0;\n}\n\n#define compare_uri_val(field,cmpfunc) \\\n\tdo { \\\n\t\tif (first.field.len != second.field.len) \\\n\t\t{ \\\n\t\t\tLM_DBG(\"Different URI field - \" #field \"\\n\"); \\\n\t\t\treturn 1; \\\n\t\t} \\\n\t\telse \\\n\t\t{ \\\n\t\t\tif (first.field.len != 0) \\\n\t\t\t\tif (cmpfunc(first.field.s,second.field.s,first.field.len)) \\\n\t\t\t\t{ \\\n\t\t\t\t\tLM_DBG(\"Different URI field - \" #field \"\\n\"); \\\n\t\t\t\t\treturn 1; \\\n\t\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n/* Compare 2 SIP URIs according to RFC 3261\n *\n * Return value : 0 if URIs match\n *\t\t\t\t  1 if URIs don't match\n *\t\t\t\t -1 if errors have occurred\n */\nint compare_uris(str *raw_uri_a,struct sip_uri* parsed_uri_a,\n\t\t\t\t\tstr *raw_uri_b,struct sip_uri *parsed_uri_b)\n{\n\t#define UNESCAPED_BUF_LEN 1024\n\tchar unescaped_a[UNESCAPED_BUF_LEN], unescaped_b[UNESCAPED_BUF_LEN];\n\n\tstr unescaped_userA={unescaped_a, UNESCAPED_BUF_LEN};\n\tstr unescaped_userB={unescaped_b, UNESCAPED_BUF_LEN};\n\n\tstruct sip_uri first;\n\tstruct sip_uri second;\n\tchar matched[URI_MAX_U_PARAMS];\n\tint i,j;\n\n\tif ( (!raw_uri_a && !parsed_uri_a) || (!raw_uri_b && !parsed_uri_b) )\n\t{\n\t\tLM_ERR(\"Provide either a raw or parsed form of a SIP URI\\n\");\n\t\treturn -1;\n\t}\n\n\tif (raw_uri_a && raw_uri_b)\n\t{\n\n\t\t/* maybe we're lucky and straight-forward comparison succeeds */\n\t\tif (raw_uri_a->len == raw_uri_b->len)\n\t\t\tif (strncasecmp(raw_uri_a->s,raw_uri_b->s,raw_uri_a->len) == 0)\n\t\t\t{\n\t\t\t\tLM_DBG(\"straight-forward URI match\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n\n\t/* XXX - maybe if we have two parsed sip_uris,\n\t * or only one parsed and one raw,\n\t * it should be possible to do a straight-forward\n\t * URI match ? */\n\n\tif (parsed_uri_a)\n\t\tfirst = *parsed_uri_a;\n\telse\n\t{\n\t\tif (parse_uri(raw_uri_a->s,raw_uri_a->len,&first) < 0)\n\t\t{\n\t\t\tLM_ERR(\"Failed to parse first URI\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (parsed_uri_b)\n\t\tsecond = *parsed_uri_b;\n\telse\n\t{\n\t\tif (parse_uri(raw_uri_b->s,raw_uri_b->len,&second) < 0)\n\t\t{\n\t\t\tLM_ERR(\"Failed to parse second URI\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (first.type != second.type)\n\t{\n\t\tLM_DBG(\"Different uri types\\n\");\n\t\treturn 1;\n\t}\n\n\tif (unescape_user(&first.user, &unescaped_userA) < 0 ||\n\t\t\tunescape_user(&second.user, &unescaped_userB) < 0) {\n\t\tLM_ERR(\"Failed to unescape user!\\n\");\n\t\treturn -1;\n\t}\n\n\tfirst.user = unescaped_userA;\n\tsecond.user = unescaped_userB;\n\n\tcompare_uri_val(user,strncmp);\n\tcompare_uri_val(passwd,strncmp);\n\tcompare_uri_val(host,strncasecmp);\n\tcompare_uri_val(port,strncmp);\n\n\tcompare_uri_val(transport_val,strncasecmp);\n\tcompare_uri_val(ttl_val,strncasecmp);\n\tcompare_uri_val(user_param_val,strncasecmp);\n\tcompare_uri_val(maddr_val,strncasecmp);\n\tcompare_uri_val(method_val,strncasecmp);\n\tcompare_uri_val(lr_val,strncasecmp);\n\tcompare_uri_val(r2_val,strncasecmp);\n\n\tif (first.u_params_no == 0 || second.u_params_no == 0)\n\t\t/* one URI doesn't have other params,\n\t\t * automatically all unknown params in other URI match\n\t\t */\n\t\tgoto headers_check;\n\n\tmemset(matched,0,URI_MAX_U_PARAMS);\n\n\tfor (i=0;i<first.u_params_no;i++)\n\t\tfor (j=0;j<second.u_params_no;j++)\n\t\t\tif (matched[j] == 0 &&\n\t\t\t\t(first.u_name[i].len == second.u_name[j].len &&\n                strncasecmp(first.u_name[i].s,second.u_name[j].s,\n\t\t\t\t\t\t\tfirst.u_name[i].len) == 0))\n\t\t\t\t{\n                    /* point of no return - matching unknown parameter values */\n\t\t\t\t\tif (first.u_val[i].len != second.u_val[j].len)\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_DBG(\"Different URI param value for param %.*s\\n\",\n\t\t\t\t\t\t\t\tfirst.u_name[i].len,first.u_name[i].s);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (first.u_val[i].len == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* no value for unknown params - match */\n\t\t\t\t\t\t\tmatched[j] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (strncasecmp(first.u_val[i].s,second.u_val[j].s,\n\t\t\t\t\t\t\tsecond.u_val[j].len))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLM_DBG(\"Different URI param value for param %.*s\\n\",\n\t\t\t\t\t\t\t\tfirst.u_name[i].len,first.u_name[i].s);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmatched[j] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t/* got here, it means all unknown params in first URI have been resolved\n\t\t=> first URI matched second URI, and the other way around\n\t*/\n\nheaders_check:\n\t /* XXX Do we really care ? */\n\tcompare_uri_val(headers,strncasecmp);\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2001-2003 FhG Fokus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n *\n * History:\n * --------\n * 2003-04-04  convenience inbound-uri parser parse_orig_ruri\n *             introduced (jiri)\n * 2003-04-11  new parse_uri introduced (better, parses also some parameters,\n *              works in one pass) (andrei)\n * 2003-04-11  ser_error is now set in parse_uri (andrei)\n * 2003-04-26  ZSW (jiri)\n * 2003-07-03  sips:, r2, lr=on support added (andrei)\n * 2005-02-25  preliminary tel uri support (andrei)\n * 2005-03-03  more tel uri fixes (andrei)\n * 2006-11-28  Added statistic support for the number of bad URI's\n *             (Jeffrey Magder - SOMA Networks)\n *  2011-04-20  added support for URI unknown parameters (osas)\n */\n\n\n#include \"parse_uri.h\"\n#include <string.h>\n#include \"../dprint.h\"\n#include \"../ut.h\"   /* q_memchr */\n#include \"../error.h\"\n#include \"../errinfo.h\"\n#include \"../core_stats.h\"\n#include \"../strcommon.h\"\n\nstatic const str uri_type_names[7] = {\n\t{NULL, 0}, /*This is the error type*/\n\tstr_init(\"sip\"),\n\tstr_init(\"sips\"),\n\tstr_init(\"tel\"),\n\tstr_init(\"tels\"),\n\tstr_init(\"urn:service\"),\n\tstr_init(\"urn:nena:service\")\n};\n\nchar* uri_type2str(const uri_type type, char *result)\n{\n\tif (type == ERROR_URI_T)\n\t\treturn NULL;\n\n\tmemcpy(result, uri_type_names[type].s, uri_type_names[type].len);\n\treturn result + uri_type_names[type].len;\n}\n\nint uri_typestrlen(const uri_type type)\n{\n\treturn uri_type_names[type].len;\n}\n\nuri_type str2uri_type(char * buf)\n{\n\tint scheme = 0;\n\turi_type type = ERROR_URI_T;\n\tscheme=buf[0]+(buf[1]<<8)+(buf[2]<<16)+(buf[3]<<24);\n\tscheme|=0x20202020;\n\tif (scheme==SIP_SCH){\n\t\ttype=SIP_URI_T;\n\t}else if(scheme==SIPS_SCH){\n\t\tif(buf[4]==':')\n\t\t\ttype=SIPS_URI_T;\n\t\telse type = ERROR_URI_T;\n\t}else if (scheme==TEL_SCH){\n\t\ttype=TEL_URI_T;\n\t}else if (scheme==URN_SERVICE_SCH){\n\t\tif (memcmp(buf+3,URN_SERVICE_STR,URN_SERVICE_STR_LEN) == 0) {\n\t\t\ttype=URN_SERVICE_URI_T;\n\t\t}\n\t\telse if (memcmp(buf+3,URN_NENA_SERVICE_STR,URN_NENA_SERVICE_STR_LEN) == 0) {\n\t\t\ttype=URN_NENA_SERVICE_URI_T;\n\t\t}\n\t}\n\treturn type;\n}\n\nint parse_uri_headers(str headers, str h_name[], str h_val[], int h_size)\n{\n\tenum states {URI_H_HEADER, URI_H_VALUE};\n\tregister enum states state;\n\tchar* h; /* header start */\n\tchar* v; /* header value start */\n\tstr* header;\t\t/* current header */\n\tstr* header_val;\t/* current header val */\n\tregister char* p;\n\tchar* end;\n\tunsigned int i = 0;\n\n\t/* init */\n\tend = headers.s + headers.len;\n\tp = h = headers.s;\n\tv = NULL;\n\theader = &h_name[0];\n\theader_val = &h_val[0];\n\tstate = URI_H_HEADER;\n\tmemset(h_name, 0, h_size * sizeof(str));\n\tmemset(h_val, 0, h_size * sizeof(str));\n\n\tfor(;p<end; p++){\n\t\tswitch((unsigned char)state){\n\t\tcase URI_H_HEADER:\n\t\t\tswitch(*p){\n\t\t\tcase '=':\n\t\t\t\tv = p+1;\n\t\t\t\theader->s = h;\n\t\t\t\theader->len = p-h;\n\t\t\t\tstate = URI_H_VALUE;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\tLM_ERR(\"Header without value\\n\");\n\t\t\t\th = p+1;\n\t\t\t\theader->s = h;\n\t\t\t\theader->len = p-h;\n\t\t\t\theader_val->s = NULL;\n\t\t\t\theader_val->len = 0;\n\n\t\t\t\t/* advance header and header_val */\n\t\t\t\ti++;\n\t\t\t\tif(i<h_size){\n\t\t\t\t\theader = &h_name[i];\n\t\t\t\t\theader_val = &h_val[i];\n\t\t\t\t} else {\n\t\t\t\t\tLM_ERR(\"To many URI headers\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase URI_H_VALUE:\n\t\t\tswitch(*p){\n\t\t\tcase '=':\n\t\t\t\tLM_ERR(\"Ignoring unexpected '=' inside URI header value\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\th = p+1;\n\t\t\t\theader_val->s = v;\n\t\t\t\theader_val->len = p-v;\n\t\t\t\tstate = URI_H_HEADER;\n\n\t\t\t\t/* advance header and header_val */\n\t\t\t\ti++;\n\t\t\t\tif(i<h_size){\n\t\t\t\t\theader = &h_name[i];\n\t\t\t\t\theader_val = &h_val[i];\n\t\t\t\t} else {\n\t\t\t\t\tLM_ERR(\"To many URI headers\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_ERR(\"Unexpected state [%d]\\n\", state);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tswitch(state){\n\tcase URI_H_HEADER:\n\t\tLM_ERR(\"Header without value\\n\");\n\t\theader->s = h;\n\t\theader->len = p-h;\n\t\theader_val->s = NULL;\n\t\theader_val->len = 0;\n\t\tbreak;\n\tcase URI_H_VALUE:\n\t\theader_val->s = v;\n\t\theader_val->len = p-v;\n\t\tbreak;\n\t}\n\n#ifdef EXTRA_DEBUG\n\tfor(i=0; i<h_size && h_name[i].s; i++)\n\t\tLM_DBG(\"header=[%p]-><%.*s> val=[%p]-><%.*s>\\n\",\n\t\t\th_name[i].s, h_name[i].len, h_name[i].s,\n\t\t\th_val[i].s, h_val[i].len, h_val[i].s);\n#endif\n\n\treturn 0;\n}\n\nint print_uri(struct sip_uri *uri, str *out_buf)\n{\n#define append_str_chunk(field) \\\n\tdo { \\\n\t\tif (bytes + uri->field.len > out_buf->len) { \\\n\t\t\tLM_ERR(\"no more space left! printed so far: '%.*s'\\n\", \\\n\t\t           bytes, out_buf->s); \\\n\t\t\treturn -1; \\\n\t\t} \\\n\t\tmemcpy(out_buf->s + bytes, uri->field.s, uri->field.len); \\\n\t\tbytes += uri->field.len; \\\n\t} while (0)\n\n#define append_char(ch) \\\n\tdo { \\\n\t\tif (bytes + 1 > out_buf->len) { \\\n\t\t\tLM_ERR(\"no more space left! printed so far: '%.*s'\\n\", \\\n\t\t           bytes, out_buf->s); \\\n\t\t\treturn -1; \\\n\t\t} \\\n\t\tout_buf->s[bytes++] = ch; \\\n\t} while (0)\n\n#define VAL(p) p##_val\n\n#define append_param(p) \\\n\tdo { \\\n\t\tif (uri->p.s) { \\\n\t\t\tappend_char(';'); \\\n\t\t\tappend_str_chunk(p); \\\n\t\t} \\\n\t} while (0)\n\n#define append_uk_param(idx) \\\n\tdo { \\\n\t\tif (uri->u_name[idx].s) { \\\n\t\t\tappend_char(';'); \\\n\t\t\tif (bytes + uri->u_name[idx].len > out_buf->len) { \\\n\t\t\t\tLM_ERR(\"no more space left! printed so far: '%.*s'\\n\", \\\n\t\t\t           bytes, out_buf->s); \\\n\t\t\t\treturn -1; \\\n\t\t\t} \\\n\t\t\tmemcpy(out_buf->s + bytes, uri->u_name[idx].s, uri->u_name[idx].len); \\\n\t\t\tbytes += uri->u_name[idx].len; \\\n\t\t\tif (uri->u_val[idx].s) { \\\n\t\t\t\tappend_char('='); \\\n\t\t\t\tif (bytes + uri->u_val[idx].len > out_buf->len) { \\\n\t\t\t\t\tLM_ERR(\"no more space left! printed so far: '%.*s'\\n\", \\\n\t\t\t\t           bytes, out_buf->s); \\\n\t\t\t\t\treturn -1; \\\n\t\t\t\t} \\\n\t\t\t\tmemcpy(out_buf->s + bytes, uri->u_val[idx].s, uri->u_val[idx].len); \\\n\t\t\t\tbytes += uri->u_val[idx].len; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n\tint bytes = 0;\n\tint i;\n\n\tmemcpy(out_buf->s, uri_type_names[uri->type].s, uri_type_names[uri->type].len);\n\tbytes += uri_type_names[uri->type].len;\n\tappend_char(':');\n\tappend_str_chunk(user);\n\tif (uri->passwd.s) {\n\t\tappend_char(':');\n\t\tappend_str_chunk(passwd);\n\t}\n\tif (uri->host.s) {\n\t\tappend_char('@');\n\t\tappend_str_chunk(host);\n\t}\n\tif (uri->port.s) {\n\t\tappend_char(':');\n\t\tappend_str_chunk(port);\n\t}\n\n\tappend_param(transport);\n\tappend_param(ttl);\n\tappend_param(user_param);\n\tappend_param(maddr);\n\tappend_param(method);\n\tappend_param(lr);\n\tappend_param(r2);\n\tappend_param(gr);\n\tappend_param(pn_provider);\n\tappend_param(pn_prid);\n\tappend_param(pn_param);\n\tappend_param(pn_purr);\n\n\tfor (i = 0; i < uri->u_params_no; i++)\n\t\tappend_uk_param(i);\n\n\tout_buf->len = bytes;\n\n\treturn 0;\n#undef append_str_chunk\n#undef append_char\n#undef VAL\n#undef append_param\n#undef append_uk_param\n}\n\n/* buf= pointer to beginning of uri (sip:x@foo.bar:5060;a=b?h=i)\n * len= len of uri\n * returns: fills uri & returns <0 on error or 0 if ok\n */\nint parse_uri(char* buf, int len, struct sip_uri* uri)\n{\n\tenum states  {\tURI_INIT, URI_USER, URI_PASSWORD, URI_PASSWORD_ALPHA,\n\t\t\t\t\tURI_HOST, URI_HOST_P,\n\t\t\t\t\tURI_HOST6_P, URI_HOST6_END, URI_PORT,\n\t\t\t\t\tURI_PARAM, URI_PARAM_P, URI_PARAM_VAL_P,\n\t\t\t\t\tURI_VAL_P, URI_HEADERS,\n\t\t\t\t\t/* param states */\n\t\t\t\t\t/* transport */\n\t\t\t\t\tPT_T, PT_R, PT_A, PT_N, PT_S, PT_P, PT_O, PT_R2, PT_T2,\n\t\t\t\t\tPT_eq,\n\t\t\t\t\t/* ttl */\n\t\t\t\t\tPTTL_T2, PTTL_L, PTTL_eq,\n\t\t\t\t\t/* user */\n\t\t\t\t\tPU_U, PU_S, PU_E, PU_R, PU_eq,\n\t\t\t\t\t/* method */\n\t\t\t\t\tPM_M, PM_E, PM_T, PM_H, PM_O, PM_D, PM_eq,\n\t\t\t\t\t/* maddr */\n\t\t\t\t\tPMA_A, PMA_D, PMA_D2, PMA_R, PMA_eq,\n\t\t\t\t\t/* lr */\n\t\t\t\t\tPLR_L, PLR_R_FIN, PLR_eq,\n\t\t\t\t\t/* gr */\n\t\t\t\t\tPG_G, PG_G_FIN, PG_eq,\n\t\t\t\t\t/* r2 */\n\t\t\t\t\tPR2_R, PR2_2_FIN, PR2_eq,\n\t\t\t\t\t/* transport values */\n\t\t\t\t\t/* udp */\n\t\t\t\t\tVU_U, VU_D, VU_P_FIN,\n\t\t\t\t\t/* tcp */\n\t\t\t\t\tVT_T, VT_C, VT_P_FIN,\n\t\t\t\t\t/* tls */\n\t\t\t\t\tVTLS_L, VTLS_S_FIN,\n\t\t\t\t\t/* sctp */\n\t\t\t\t\tVS_S, VS_C, VS_T, VS_P_FIN,\n\t\t\t\t\t/* ws */\n\t\t\t\t\tVW_W, VW_S, VW_S_FIN, VWS_S_FIN,\n\n\t\t\t\t\t/* pn-{provider, prid, param, purr} (RFC 8599 - SIP PN) */\n\t\t\t\t\tPN_P, PN_N, PN_dash, PN_P2, PN_PR,\n\t\t\t\t\tPN1_O, PN1_V, PN1_I, PN1_D, PN1_E, PN1_FIN, PN1_eq,\n\t\t\t\t\tPN2_I, PN2_D, PN2_eq,\n\t\t\t\t\tPN3_A, PN3_R, PN3_A2, PN3_M, PN3_eq,\n\t\t\t\t\tPN4_U, PN4_R, PN4_R2, PN4_eq,\n\n\t};\n\tregister enum states state;\n\tchar* s;\n\tchar* b; /* param start */\n\tchar *v; /* value start */\n\tstr* param; /* current param */\n\tstr* param_val; /* current param val */\n\tstr user;\n\tstr password;\n\tint port_no;\n\tregister char* p;\n\tchar* end;\n\tchar* pass;\n\tint found_user;\n\tint error_headers;\n\tunsigned int scheme;\n\turi_type backup;\n#ifdef EXTRA_DEBUG\n\tint i;\n#endif\n\n#define case_port( ch, var) \\\n\tcase ch: \\\n\t\t\t (var)=(var)*10+ch-'0'; \\\n\t\t\t break\n\n#define still_at_user  \\\n\t\t\t\t\t\tif (found_user==0){ \\\n\t\t\t\t\t\t\tuser.s=uri->host.s; \\\n\t\t\t\t\t\t\tif (pass){\\\n\t\t\t\t\t\t\t\tuser.len=pass-user.s; \\\n\t\t\t\t\t\t\t\tpassword.s=pass+1; \\\n\t\t\t\t\t\t\t\tpassword.len=p-password.s; \\\n\t\t\t\t\t\t\t}else{ \\\n\t\t\t\t\t\t\t\tuser.len=p-user.s; \\\n\t\t\t\t\t\t\t}\\\n\t\t\t\t\t\t\t/* save the uri type/scheme */ \\\n\t\t\t\t\t\t\tbackup=uri->type; \\\n\t\t\t\t\t\t\t/* everything else is 0 */ \\\n\t\t\t\t\t\t\tmemset(uri, 0, sizeof(struct sip_uri)); \\\n\t\t\t\t\t\t\t/* restore the scheme, copy user & pass */ \\\n\t\t\t\t\t\t\turi->type=backup; \\\n\t\t\t\t\t\t\turi->user=user; \\\n\t\t\t\t\t\t\tif (pass)\turi->passwd=password;  \\\n\t\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\t\tfound_user=1;\\\n\t\t\t\t\t\t\terror_headers=0; \\\n\t\t\t\t\t\t\tstate=URI_HOST; \\\n\t\t\t\t\t\t}else goto error_bad_char\n\n#define check_host_end \\\n\t\t\t\t\tcase ':': \\\n\t\t\t\t\t\t/* found the host */ \\\n\t\t\t\t\t\turi->host.s=s; \\\n\t\t\t\t\t\turi->host.len=p-s; \\\n\t\t\t\t\t\tstate=URI_PORT; \\\n\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase ';': \\\n\t\t\t\t\t\turi->host.s=s; \\\n\t\t\t\t\t\turi->host.len=p-s; \\\n\t\t\t\t\t\tstate=URI_PARAM; \\\n\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase '?': \\\n\t\t\t\t\t\turi->host.s=s; \\\n\t\t\t\t\t\turi->host.len=p-s; \\\n\t\t\t\t\t\tstate=URI_HEADERS; \\\n\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase '&': \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\tgoto error_bad_char\n\n\n#define param_set(t_start, v_start) \\\n\t\t\t\t\tparam->s=(t_start);\\\n\t\t\t\t\tparam->len=(p-(t_start));\\\n\t\t\t\t\tparam_val->s=(v_start); \\\n\t\t\t\t\tparam_val->len=(p-(v_start))\n\n#define u_param_set(t_start, v_start) \\\n\t\t\tif (uri->u_params_no < URI_MAX_U_PARAMS){ \\\n\t\t\t\tif((v_start)>(t_start)){ \\\n\t\t\t\t\turi->u_name[uri->u_params_no].s=(t_start); \\\n\t\t\t\t\turi->u_name[uri->u_params_no].len=((v_start)-(t_start)-1); \\\n\t\t\t\t\tif(p>(v_start)) { \\\n\t\t\t\t\t\turi->u_val[uri->u_params_no].s=(v_start); \\\n\t\t\t\t\t\turi->u_val[uri->u_params_no].len=(p-(v_start)); \\\n\t\t\t\t\t} \\\n\t\t\t\t} else { \\\n\t\t\t\t\turi->u_name[uri->u_params_no].s=(t_start); \\\n\t\t\t\t\turi->u_name[uri->u_params_no].len=(p-(t_start)); \\\n\t\t\t\t} \\\n\t\t\t\turi->u_params_no++; \\\n\t\t\t} else { \\\n\t\t\t\tLM_ERR(\"unknown URI param list excedeed\\n\"); \\\n\t\t\t}\n\n#define semicolon_case \\\n\t\t\t\t\tcase';': \\\n\t\t\t\t\t\tif (pass){ \\\n\t\t\t\t\t\t\tfound_user=1;/* no user, pass cannot contain ';'*/ \\\n\t\t\t\t\t\t\tpass=0; \\\n\t\t\t\t\t\t} \\\n\t\t\t\t\t\tstate=URI_PARAM   /* new param */\n\n#define question_case \\\n\t\t\t\t\tcase '?': \\\n\t\t\t\t\t\turi->params.s=s; \\\n\t\t\t\t\t\turi->params.len=p-s; \\\n\t\t\t\t\t\tstate=URI_HEADERS; \\\n\t\t\t\t\t\ts=p+1; \\\n\t\t\t\t\t\tif (pass){ \\\n\t\t\t\t\t\t\tfound_user=1;/* no user, pass cannot contain '?'*/ \\\n\t\t\t\t\t\t\tpass=0; \\\n\t\t\t\t\t\t}\n\n#define colon_case \\\n\t\t\t\t\tcase ':': \\\n\t\t\t\t\t\tif (found_user==0){ \\\n\t\t\t\t\t\t\t/*might be pass but only if user not found yet*/ \\\n\t\t\t\t\t\t\tif (pass){ \\\n\t\t\t\t\t\t\t\tfound_user=1; /* no user */ \\\n\t\t\t\t\t\t\t\tpass=0; \\\n\t\t\t\t\t\t\t}else{ \\\n\t\t\t\t\t\t\t\tpass=p; \\\n\t\t\t\t\t\t\t} \\\n\t\t\t\t\t\t} \\\n\t\t\t\t\t\tstate=URI_PARAM_P /* generic param */\n\n#define param_common_cases \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\t/* ughhh, this is still the user */ \\\n\t\t\t\t\t\tstill_at_user; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tsemicolon_case; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tquestion_case; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcolon_case; \\\n\t\t\t\t\t\tbreak\n\n#define u_param_common_cases \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\t/* ughhh, this is still the user */ \\\n\t\t\t\t\t\tstill_at_user; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tsemicolon_case; \\\n\t\t\t\t\t\tu_param_set(b, v); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tquestion_case; \\\n\t\t\t\t\t\tu_param_set(b, v); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcolon_case; \\\n\t\t\t\t\t\tbreak\n\n#define value_common_cases \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\t/* ughhh, this is still the user */ \\\n\t\t\t\t\t\tstill_at_user; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tsemicolon_case; \\\n\t\t\t\t\t\tparam_set(b, v); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tquestion_case; \\\n\t\t\t\t\t\tparam_set(b, v); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcolon_case; \\\n\t\t\t\t\t\tstate=URI_VAL_P; \\\n\t\t\t\t\t\tbreak\n\n#define param_switch(old_state, c1, c2, new_state) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tu_param_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_PARAM_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define param_switch1(old_state, c1, new_state) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\t\tstate=(new_state); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tparam_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_PARAM_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define param_xswitch1(old_state, c1, new_state) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\t\tstate=(new_state); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tgoto error_bad_char; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define param_switch_big(old_state, c1, c2, d1, d2, new_state_c, new_state_d) \\\n\t\t\tcase old_state : \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state_c); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase d1: \\\n\t\t\t\t\tcase d2: \\\n\t\t\t\t\t\tstate=(new_state_d); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tu_param_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_PARAM_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define param_switch_bigger(old_state, c1, c2, d1, d2, e1, e2, new_state_c, new_state_d, new_state_e) \\\n\t\t\tcase old_state : \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state_c); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase d1: \\\n\t\t\t\t\tcase d2: \\\n\t\t\t\t\t\tstate=(new_state_d); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase e1: \\\n\t\t\t\t\tcase e2: \\\n\t\t\t\t\t\tstate=(new_state_e); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tu_param_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_PARAM_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define value_switch(old_state, c1, c2, new_state) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tvalue_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_VAL_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n#define value_switch_big(old_state, c1, c2, d1, d2, new_state_c, new_state_d) \\\n\t\t\tcase old_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase c1: \\\n\t\t\t\t\tcase c2: \\\n\t\t\t\t\t\tstate=(new_state_c); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase d1: \\\n\t\t\t\t\tcase d2: \\\n\t\t\t\t\t\tstate=(new_state_d); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tvalue_common_cases; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_VAL_P; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n\n#define transport_fin(c_state, proto_no) \\\n\t\t\tcase c_state: \\\n\t\t\t\tswitch(*p){ \\\n\t\t\t\t\tcase '@': \\\n\t\t\t\t\t\tstill_at_user; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tsemicolon_case; \\\n\t\t\t\t\t\tparam_set(b, v); \\\n\t\t\t\t\t\turi->proto=(proto_no); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tquestion_case; \\\n\t\t\t\t\t\tparam_set(b, v); \\\n\t\t\t\t\t\turi->proto=(proto_no); \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcolon_case;  \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tstate=URI_VAL_P; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t} \\\n\t\t\t\tbreak\n\n\n\n\t/* init */\n\tend=buf+len;\n\tp=buf+4;\n\tfound_user=0;\n\terror_headers=0;\n\tb=v=0;\n\tparam=param_val=0;\n\tpass=0;\n\tpassword.s = 0;\n\tpassword.len = 0;\n\tport_no=0;\n\tstate=URI_INIT;\n\tmemset(uri, 0, sizeof(struct sip_uri)); /* zero it all, just to be sure*/\n\t/*look for sip:, sips: or tel:*/\n\tif (len<5) goto error_too_short;\n\tscheme=buf[0]+(buf[1]<<8)+(buf[2]<<16)+(buf[3]<<24);\n\tscheme|=0x20202020;\n\tif (scheme==SIP_SCH){\n\t\turi->type=SIP_URI_T;\n\t}else if(scheme==SIPS_SCH){\n\t\tif(buf[4]==':'){ p++; uri->type=SIPS_URI_T;}\n\t\telse goto error_bad_uri;\n\t}else if (scheme==TEL_SCH){\n\t\turi->type=TEL_URI_T;\n\t}else if (scheme==URN_SERVICE_SCH){\n\t\tif ((end-(buf+3)) >= URN_SERVICE_STR_LEN\n\t\t        && memcmp(buf+3,URN_SERVICE_STR,URN_SERVICE_STR_LEN) == 0) {\n\t\t\tp+= URN_SERVICE_STR_LEN-1;\n\t\t\turi->type=URN_SERVICE_URI_T;\n\t\t}\n\t\telse if ((end-(buf+3)) >= URN_NENA_SERVICE_STR_LEN\n\t\t        && memcmp(buf+3,URN_NENA_SERVICE_STR,URN_NENA_SERVICE_STR_LEN) == 0) {\n\t\t\tp+= URN_NENA_SERVICE_STR_LEN-1;\n\t\t\turi->type=URN_NENA_SERVICE_URI_T;\n\t\t}else goto error_bad_uri;\n\t}else goto error_bad_uri;\n\n\ts=p;\n\tfor(;p<end; p++){\n\t\tswitch((unsigned char)state){\n\t\t\tcase URI_INIT:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\t/* uri =  [ipv6address]... */\n\t\t\t\t\t\tstate=URI_HOST6_P;\n\t\t\t\t\t\ts=p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\t/* invalid, no uri can start with ']' */\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\t/* the same as above for ':' */\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t\tcase '@': /* error no user part */\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_USER;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_USER:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\t/* found the user*/\n\t\t\t\t\t\turi->user.s=s;\n\t\t\t\t\t\turi->user.len=p-s;\n\t\t\t\t\t\tstate=URI_HOST;\n\t\t\t\t\t\tfound_user=1;\n\t\t\t\t\t\ts=p+1; /* skip '@' */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\t/* found the user, or the host? */\n\t\t\t\t\t\turi->user.s=s;\n\t\t\t\t\t\turi->user.len=p-s;\n\t\t\t\t\t\tstate=URI_PASSWORD;\n\t\t\t\t\t\ts=p+1; /* skip ':' */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\t/* this could be still the user or\n\t\t\t\t\t\t * params?*/\n\t\t\t\t\t\turi->host.s=s;\n\t\t\t\t\t\turi->host.len=p-s;\n\t\t\t\t\t\tstate=URI_PARAM;\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?': /* still user or headers? */\n\t\t\t\t\t\turi->host.s=s;\n\t\t\t\t\t\turi->host.len=p-s;\n\t\t\t\t\t\tstate=URI_HEADERS;\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/* almost anything permitted in the user part */\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']': /* the user part cannot contain \"[]\" */\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PASSWORD: /* this can also be the port (missing user)*/\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\t/* found the password*/\n\t\t\t\t\t\turi->passwd.s=s;\n\t\t\t\t\t\turi->passwd.len=p-s;\n\t\t\t\t\t\tport_no=0;\n\t\t\t\t\t\tstate=URI_HOST;\n\t\t\t\t\t\tfound_user=1;\n\t\t\t\t\t\ts=p+1; /* skip '@' */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\t/* upps this is the port */\n\t\t\t\t\t\turi->port.s=s;\n\t\t\t\t\t\turi->port.len=p-s;\n\t\t\t\t\t\turi->port_no=port_no;\n\t\t\t\t\t\t/* user contains in fact the host */\n\t\t\t\t\t\turi->host.s=uri->user.s;\n\t\t\t\t\t\turi->host.len=uri->user.len;\n\t\t\t\t\t\turi->user.s=0;\n\t\t\t\t\t\turi->user.len=0;\n\t\t\t\t\t\tstate=URI_PARAM;\n\t\t\t\t\t\tfound_user=1; /*  there is no user part */\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\t/* upps this is the port */\n\t\t\t\t\t\turi->port.s=s;\n\t\t\t\t\t\turi->port.len=p-s;\n\t\t\t\t\t\turi->port_no=port_no;\n\t\t\t\t\t\t/* user contains in fact the host */\n\t\t\t\t\t\turi->host.s=uri->user.s;\n\t\t\t\t\t\turi->host.len=uri->user.len;\n\t\t\t\t\t\turi->user.s=0;\n\t\t\t\t\t\turi->user.len=0;\n\t\t\t\t\t\tstate=URI_HEADERS;\n\t\t\t\t\t\tfound_user=1; /*  there is no user part */\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase_port('0', port_no);\n\t\t\t\t\tcase_port('1', port_no);\n\t\t\t\t\tcase_port('2', port_no);\n\t\t\t\t\tcase_port('3', port_no);\n\t\t\t\t\tcase_port('4', port_no);\n\t\t\t\t\tcase_port('5', port_no);\n\t\t\t\t\tcase_port('6', port_no);\n\t\t\t\t\tcase_port('7', port_no);\n\t\t\t\t\tcase_port('8', port_no);\n\t\t\t\t\tcase_port('9', port_no);\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* it can't be the port, non number found */\n\t\t\t\t\t\tport_no=0;\n\t\t\t\t\t\tstate=URI_PASSWORD_ALPHA;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PASSWORD_ALPHA:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\t/* found the password*/\n\t\t\t\t\t\turi->passwd.s=s;\n\t\t\t\t\t\turi->passwd.len=p-s;\n\t\t\t\t\t\tstate=URI_HOST;\n\t\t\t\t\t\tfound_user=1;\n\t\t\t\t\t\ts=p+1; /* skip '@' */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';': /* contains non-numbers => cannot be port no*/\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tgoto error_bad_port;\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\tgoto error_bad_char;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_HOST:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tstate=URI_HOST6_P;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ':':\n\t\t\t\t\tcase ';':\n\t\t\t\t\tcase '?': /* null host name ->invalid */\n\t\t\t\t\tcase '&':\n\t\t\t\t\tcase '@': /*chars not allowed in hosts names */\n\t\t\t\t\t\tgoto error_bad_host;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_HOST_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_HOST_P:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcheck_host_end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_HOST6_END:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcheck_host_end;\n\t\t\t\t\tdefault: /*no chars allowed after [ipv6] */\n\t\t\t\t\t\tgoto error_bad_host;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_HOST6_P:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tstate=URI_HOST6_END;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase '&':\n\t\t\t\t\tcase '@':\n\t\t\t\t\tcase ';':\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tgoto error_bad_host;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PORT:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\turi->port.s=s;\n\t\t\t\t\t\turi->port.len=p-s;\n\t\t\t\t\t\turi->port_no=port_no;\n\t\t\t\t\t\tstate=URI_PARAM;\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\turi->port.s=s;\n\t\t\t\t\t\turi->port.len=p-s;\n\t\t\t\t\t\turi->port_no=port_no;\n\t\t\t\t\t\tstate=URI_HEADERS;\n\t\t\t\t\t\ts=p+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase_port('0', port_no);\n\t\t\t\t\tcase_port('1', port_no);\n\t\t\t\t\tcase_port('2', port_no);\n\t\t\t\t\tcase_port('3', port_no);\n\t\t\t\t\tcase_port('4', port_no);\n\t\t\t\t\tcase_port('5', port_no);\n\t\t\t\t\tcase_port('6', port_no);\n\t\t\t\t\tcase_port('7', port_no);\n\t\t\t\t\tcase_port('8', port_no);\n\t\t\t\t\tcase_port('9', port_no);\n\t\t\t\t\tcase '&':\n\t\t\t\t\tcase '@':\n\t\t\t\t\tcase ':':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto error_bad_port;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PARAM: /* beginning of a new param */\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\t/* recognized params */\n\t\t\t\t\tcase 't':\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PT_T;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PU_U;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'm':\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PM_M;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'l':\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PLR_L;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'g':\n\t\t\t\t\tcase 'G':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PG_G;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PR2_R;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'p':\n\t\t\t\t\tcase 'P':\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=PN_P;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb=p;\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URI_PARAM_P: /* ignore current param */\n\t\t\t\t/* supported params:\n\t\t\t\t *  maddr, transport, ttl, lr, user, method, r2  */\n\t\t\t\tswitch(*p){\n\t\t\t\t\tu_param_common_cases;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tv=p + 1;\n\t\t\t\t\t\tstate=URI_PARAM_VAL_P;\n\t\t\t\t\t\tbreak;\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase URI_PARAM_VAL_P: /* value of the ignored current param */\n\t\t\t\tswitch(*p){\n\t\t\t\t\tu_param_common_cases;\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t/* ugly but fast param names parsing */\n\t\t\t/*transport */\n\t\t\tparam_switch_big(PT_T,  'r', 'R', 't', 'T', PT_R, PTTL_T2);\n\t\t\tparam_switch(PT_R,  'a', 'A', PT_A);\n\t\t\tparam_switch(PT_A,  'n', 'N', PT_N);\n\t\t\tparam_switch(PT_N,  's', 'S', PT_S);\n\t\t\tparam_switch(PT_S,  'p', 'P', PT_P);\n\t\t\tparam_switch(PT_P,  'o', 'O', PT_O);\n\t\t\tparam_switch(PT_O,  'r', 'R', PT_R2);\n\t\t\tparam_switch(PT_R2, 't', 'T', PT_T2);\n\t\t\tparam_switch1(PT_T2, '=',  PT_eq);\n\t\t\t/* value parsing */\n\t\t\tcase PT_eq:\n\t\t\t\tparam=&uri->transport;\n\t\t\t\tparam_val=&uri->transport_val;\n\t\t\t\turi->proto = PROTO_OTHER;\n\t\t\t\tswitch (*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=VU_U;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=VT_T;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=VS_S;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'w':\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=VW_W;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* generic value */\n\t\t\tcase URI_VAL_P:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tvalue_common_cases;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t/* udp */\n\t\t\tvalue_switch(VU_U,  'd', 'D', VU_D);\n\t\t\tvalue_switch(VU_D,  'p', 'P', VU_P_FIN);\n\t\t\ttransport_fin(VU_P_FIN, PROTO_UDP);\n\t\t\t/* tcp */\n\t\t\tvalue_switch_big(VT_T,  'c', 'C', 'l', 'L', VT_C, VTLS_L);\n\t\t\tvalue_switch(VT_C,  'p', 'P', VT_P_FIN);\n\t\t\ttransport_fin(VT_P_FIN, PROTO_TCP);\n\t\t\t/* tls */\n\t\t\tvalue_switch(VTLS_L, 's', 'S', VTLS_S_FIN);\n\t\t\ttransport_fin(VTLS_S_FIN, PROTO_TLS);\n\t\t\t/* sctp */\n\t\t\tvalue_switch(VS_S, 'c', 'C', VS_C);\n\t\t\tvalue_switch(VS_C, 't', 'T', VS_T);\n\t\t\tvalue_switch(VS_T, 'p', 'P', VS_P_FIN);\n\t\t\ttransport_fin(VS_P_FIN, PROTO_SCTP);\n\t\t\t/* ws */\n\t\t\tvalue_switch(VW_W, 's', 'S', VW_S);\n\t\t\tcase VW_S:\n\t\t\t\tif (*p == 's' || *p == 'S') {\n\t\t\t\t\tstate=(VWS_S_FIN);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* if not a 's' transiting to VWS_S_FIN, fallback\n\t\t\t\t * to testing as existing VW_S_FIN (NOTE the missing break) */\n\t\t\t\tstate=(VW_S_FIN);\n\t\t\ttransport_fin(VW_S_FIN, PROTO_WS);\n\t\t\ttransport_fin(VWS_S_FIN, PROTO_WSS);\n\n\t\t\t/* ttl */\n\t\t\tparam_switch(PTTL_T2,  'l', 'L', PTTL_L);\n\t\t\tparam_switch1(PTTL_L,  '=', PTTL_eq);\n\t\t\tcase PTTL_eq:\n\t\t\t\tparam=&uri->ttl;\n\t\t\t\tparam_val=&uri->ttl_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* user param */\n\t\t\tparam_switch(PU_U, 's', 'S', PU_S);\n\t\t\tparam_switch(PU_S, 'e', 'E', PU_E);\n\t\t\tparam_switch(PU_E, 'r', 'R', PU_R);\n\t\t\tparam_switch1(PU_R, '=', PU_eq);\n\t\t\tcase PU_eq:\n\t\t\t\tparam=&uri->user_param;\n\t\t\t\tparam_val=&uri->user_param_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* method*/\n\t\t\tparam_switch_big(PM_M, 'e', 'E', 'a', 'A', PM_E, PMA_A);\n\t\t\tparam_switch(PM_E, 't', 'T', PM_T);\n\t\t\tparam_switch(PM_T, 'h', 'H', PM_H);\n\t\t\tparam_switch(PM_H, 'o', 'O', PM_O);\n\t\t\tparam_switch(PM_O, 'd', 'D', PM_D);\n\t\t\tparam_switch1(PM_D, '=', PM_eq);\n\t\t\tcase PM_eq:\n\t\t\t\tparam=&uri->method;\n\t\t\t\tparam_val=&uri->method_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/*maddr*/\n\t\t\tparam_switch(PMA_A,  'd', 'D', PMA_D);\n\t\t\tparam_switch(PMA_D,  'd', 'D', PMA_D2);\n\t\t\tparam_switch(PMA_D2, 'r', 'R', PMA_R);\n\t\t\tparam_switch1(PMA_R, '=', PMA_eq);\n\t\t\tcase PMA_eq:\n\t\t\t\tparam=&uri->maddr;\n\t\t\t\tparam_val=&uri->maddr_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* lr */\n\t\t\tparam_switch(PLR_L,  'r', 'R', PLR_R_FIN);\n\t\t\tcase PLR_R_FIN:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tstate=PLR_eq;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsemicolon_case;\n\t\t\t\t\t\turi->lr.s=b;\n\t\t\t\t\t\turi->lr.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tquestion_case;\n\t\t\t\t\t\turi->lr.s=b;\n\t\t\t\t\t\turi->lr.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcolon_case;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* handle lr=something case */\n\t\t\tcase PLR_eq:\n\t\t\t\tparam=&uri->lr;\n\t\t\t\tparam_val=&uri->lr_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* r2 */\n\t\t\tparam_switch1(PR2_R,  '2', PR2_2_FIN);\n\t\t\tcase PR2_2_FIN:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tstate=PR2_eq;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsemicolon_case;\n\t\t\t\t\t\turi->r2.s=b;\n\t\t\t\t\t\turi->r2.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tquestion_case;\n\t\t\t\t\t\turi->r2.s=b;\n\t\t\t\t\t\turi->r2.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcolon_case;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* handle r2=something case */\n\t\t\tcase PR2_eq:\n\t\t\t\tparam=&uri->r2;\n\t\t\t\tparam_val=&uri->r2_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\t/* gr */\n\t\t\tparam_switch(PG_G,  'r', 'R', PG_G_FIN);\n\t\t\tcase PG_G_FIN:\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tstate=PG_eq;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsemicolon_case;\n\t\t\t\t\t\turi->gr.s=b;\n\t\t\t\t\t\turi->gr.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tquestion_case;\n\t\t\t\t\t\turi->gr.s=b;\n\t\t\t\t\t\turi->gr.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcolon_case;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* handle gr=something case */\n\t\t\tcase PG_eq:\n\t\t\t\tparam=&uri->gr;\n\t\t\t\tparam_val=&uri->gr_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\t/* pn-* */\n\t\t\tparam_switch(PN_P, 'n', 'N', PN_N);\n\t\t\tparam_switch1(PN_N, '-', PN_dash);\n\t\t\tparam_switch(PN_dash, 'p', 'P', PN_P2);\n\n\t\t\tparam_switch_bigger(PN_P2, 'r', 'R', 'a', 'A', 'u', 'U',\n\t\t\t                    PN_PR, PN3_A, PN4_U);\n\t\t\tparam_switch_big(PN_PR, 'o', 'O', 'i', 'I', PN1_O, PN2_I);\n\n\t\t\t/* pn-provider */\n\t\t\tparam_switch(PN1_O, 'v', 'V', PN1_V);\n\t\t\tparam_switch(PN1_V, 'i', 'I', PN1_I);\n\t\t\tparam_switch(PN1_I, 'd', 'D', PN1_D);\n\t\t\tparam_switch(PN1_D, 'e', 'E', PN1_E);\n\t\t\tparam_switch(PN1_E, 'r', 'R', PN1_FIN);\n\t\t\tcase PN1_FIN:\n\t\t\t\tparam=&uri->pn_provider;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\tstate=PN1_eq;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsemicolon_case;\n\t\t\t\t\t\turi->pn_provider.s=b;\n\t\t\t\t\t\turi->pn_provider.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tquestion_case;\n\t\t\t\t\t\turi->pn_provider.s=b;\n\t\t\t\t\t\turi->pn_provider.len=(p-b);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcolon_case;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate=URI_PARAM_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* handle pn-provider=something case */\n\t\t\tcase PN1_eq:\n\t\t\t\tparam=&uri->pn_provider;\n\t\t\t\tparam_val=&uri->pn_provider_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* pn-prid */\n\t\t\tparam_switch(PN2_I, 'd', 'D', PN2_D);\n\t\t\tparam_xswitch1(PN2_D, '=', PN2_eq);\n\t\t\tcase PN2_eq:\n\t\t\t\tparam=&uri->pn_prid;\n\t\t\t\tparam_val=&uri->pn_prid_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* pn-param */\n\t\t\tparam_switch(PN3_A, 'r', 'R', PN3_R);\n\t\t\tparam_switch(PN3_R, 'a', 'A', PN3_A2);\n\t\t\tparam_switch(PN3_A2, 'm', 'M', PN3_M);\n\t\t\tparam_xswitch1(PN3_M, '=', PN3_eq);\n\t\t\tcase PN3_eq:\n\t\t\t\tparam=&uri->pn_param;\n\t\t\t\tparam_val=&uri->pn_param_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* pn-purr */\n\t\t\tparam_switch(PN4_U, 'r', 'R', PN4_R);\n\t\t\tparam_switch(PN4_R, 'r', 'R', PN4_R2);\n\t\t\tparam_xswitch1(PN4_R2, '=', PN4_eq);\n\t\t\tcase PN4_eq:\n\t\t\t\tparam=&uri->pn_purr;\n\t\t\t\tparam_val=&uri->pn_purr_val;\n\t\t\t\tswitch(*p){\n\t\t\t\t\tparam_common_cases;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tv=p;\n\t\t\t\t\t\tstate=URI_VAL_P;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\tcase URI_HEADERS:\n\t\t\t\t/* for now nobody needs them so we completely ignore the\n\t\t\t\t * headers (they are not allowed in request uri) --andrei */\n\t\t\t\tswitch(*p){\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\t/* yak, we are still at user */\n\t\t\t\t\t\tstill_at_user;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ';':\n\t\t\t\t\t\t/* we might be still parsing user, try it */\n\t\t\t\t\t\tif (found_user) goto error_bad_char;\n\t\t\t\t\t\terror_headers=1; /* if this is not the user\n\t\t\t\t\t\t\t\t\t\t\twe have an error */\n\t\t\t\t\t\t/* if pass is set => it cannot be user:pass\n\t\t\t\t\t\t * => error (';') is illegal in a header */\n\t\t\t\t\t\tif (pass) goto error_headers;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\tif (found_user==0){\n\t\t\t\t\t\t\t/*might be pass but only if user not found yet*/\n\t\t\t\t\t\t\tif (pass){\n\t\t\t\t\t\t\t\tfound_user=1; /* no user */\n\t\t\t\t\t\t\t\tpass=0;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpass=p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tif (pass){\n\t\t\t\t\t\t\tfound_user=1; /* no user, pass cannot contain '?'*/\n\t\t\t\t\t\t\tpass=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto error_bug;\n\t\t}\n\t}\n\n\t/*end of uri */\n\tswitch (state){\n\t\tcase URI_INIT: /* error empty uri */\n\t\t\tgoto error_too_short;\n\t\tcase URI_USER:\n\t\t\t/* this is the host, it can't be the user */\n\t\t\tif (found_user) goto error_bad_uri;\n\t\t\turi->host.s=s;\n\t\t\turi->host.len=p-s;\n\t\t\tstate=URI_HOST;\n\t\t\tbreak;\n\t\tcase URI_PASSWORD:\n\t\t\t/* this is the port, it can't be the passwd */\n\t\t\tif (found_user) goto error_bad_port;\n\t\t\turi->port.s=s;\n\t\t\turi->port.len=p-s;\n\t\t\turi->port_no=port_no;\n\t\t\turi->host=uri->user;\n\t\t\turi->user.s=0;\n\t\t\turi->user.len=0;\n\t\t\tbreak;\n\t\tcase URI_PASSWORD_ALPHA:\n\t\t\t/* this is the port, it can't be the passwd */\n\t\t\tgoto error_bad_port;\n\t\tcase URI_HOST_P:\n\t\tcase URI_HOST6_END:\n\t\t\turi->host.s=s;\n\t\t\turi->host.len=p-s;\n\t\t\tbreak;\n\t\tcase URI_HOST: /* error: null host */\n\t\tcase URI_HOST6_P: /* error: unterminated ipv6 reference*/\n\t\t\tgoto error_bad_host;\n\t\tcase URI_PORT:\n\t\t\turi->port.s=s;\n\t\t\turi->port.len=p-s;\n\t\t\turi->port_no=port_no;\n\t\t\tbreak;\n\t\tcase URI_PARAM:\n\t\tcase URI_PARAM_P:\n\t\tcase URI_PARAM_VAL_P:\n\t\t\tu_param_set(b, v);\n\t\t/* intermediate param states */\n\t\tcase PT_T: /* transport */\n\t\tcase PT_R:\n\t\tcase PT_A:\n\t\tcase PT_N:\n\t\tcase PT_S:\n\t\tcase PT_P:\n\t\tcase PT_O:\n\t\tcase PT_R2:\n\t\tcase PT_T2:\n\t\tcase PT_eq: /* ignore empty transport params */\n\t\tcase PTTL_T2: /* ttl */\n\t\tcase PTTL_L:\n\t\tcase PTTL_eq:\n\t\tcase PU_U:  /* user */\n\t\tcase PU_S:\n\t\tcase PU_E:\n\t\tcase PU_R:\n\t\tcase PU_eq:\n\t\tcase PM_M: /* method */\n\t\tcase PM_E:\n\t\tcase PM_T:\n\t\tcase PM_H:\n\t\tcase PM_O:\n\t\tcase PM_D:\n\t\tcase PM_eq:\n\t\tcase PLR_L: /* lr */\n\t\tcase PR2_R:  /* r2 */\n\t\tcase PG_G: /* gr */\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tbreak;\n\t\t/* fin param states */\n\t\tcase PLR_R_FIN:\n\t\tcase PLR_eq:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\turi->lr.s=b;\n\t\t\turi->lr.len=p-b;\n\t\t\tbreak;\n\t\tcase PR2_2_FIN:\n\t\tcase PR2_eq:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\turi->r2.s=b;\n\t\t\turi->r2.len=p-b;\n\t\t\tbreak;\n\t\tcase PG_G_FIN:\n\t\tcase PG_eq:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\turi->gr.s=b;\n\t\t\turi->gr.len=p-b;\n\t\t\tbreak;\n\t\tcase PN1_FIN:\n\t\tcase PN1_eq:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\turi->pn_provider.s=b;\n\t\t\turi->pn_provider.len=p-b;\n\t\t\tbreak;\n\t\tcase URI_VAL_P:\n\t\t/* intermediate value states */\n\t\tcase VU_U:\n\t\tcase VU_D:\n\t\tcase VT_T:\n\t\tcase VT_C:\n\t\tcase VTLS_L:\n\t\tcase VS_S:\n\t\tcase VS_C:\n\t\tcase VW_W:\n\t\tcase VS_T:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\tbreak;\n\t\t/* fin value states */\n\t\tcase VU_P_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_UDP;\n\t\t\tbreak;\n\t\tcase VT_P_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_TCP;\n\t\t\tbreak;\n\t\tcase VTLS_S_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_TLS;\n\t\t\tbreak;\n\t\tcase VS_P_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_SCTP;\n\t\t\tbreak;\n\t\tcase VW_S:\n\t\tcase VW_S_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_WS;\n\t\t\tbreak;\n\t\tcase VWS_S_FIN:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tparam_set(b, v);\n\t\t\turi->proto=PROTO_WSS;\n\t\t\tbreak;\n\t\t/* headers */\n\t\tcase URI_HEADERS:\n\t\t\turi->headers.s=s;\n\t\t\turi->headers.len=p-s;\n\t\t\tif (error_headers) goto error_headers;\n\t\t\tbreak;\n\t\t/* intermediate PN param states */\n\t\tcase PN_P:\n\t\tcase PN_N:\n\t\tcase PN_dash:\n\t\tcase PN_P2:\n\t\tcase PN_PR:\n\t\tcase PN1_O:\n\t\tcase PN1_V:\n\t\tcase PN1_I:\n\t\tcase PN1_D:\n\t\tcase PN1_E:\n\t\tcase PN2_I:\n\t\tcase PN3_A:\n\t\tcase PN3_R:\n\t\tcase PN3_A2:\n\t\tcase PN4_U:\n\t\tcase PN4_R:\n\t\t\turi->params.s=s;\n\t\t\turi->params.len=p-s;\n\t\t\tbreak;\n\t\tcase PN2_D:\n\t\tcase PN2_eq:\n\t\tcase PN3_M:\n\t\tcase PN3_eq:\n\t\tcase PN4_R2:\n\t\tcase PN4_eq:\n\t\t\tgoto error_bad_uri;\n\t\tdefault:\n\t\t\tgoto error_bug;\n\t}\n\tswitch(uri->type){\n\t\tcase TEL_URI_T:\n\t\tcase TELS_URI_T:\n\t\t\t/* fix tel uris, move the number in uri and empty the host */\n\t\t\turi->user=uri->host;\n\t\t\t/* TEL does not have a host part, still most of the code expects\n\t\t\t * one, so lets keep the pointer, but set a 0 length */\n\t\t\turi->host.len=0;\n\t\t\tbreak;\n\t\tcase SIP_URI_T:\n\t\tcase SIPS_URI_T:\n\t\tcase URN_SERVICE_URI_T:\n\t\t\t/* nothing to do for these URIs */\n\t\t\tbreak;\n\t\tcase URN_NENA_SERVICE_URI_T:\n\t\t\turi->user.s=0;\n\t\t\turi->user.len=0;\n\t\t\t/* keep the service name as host part */\n\t\t\tbreak;\n\t\tcase ERROR_URI_T:\n\t\t\tLM_ERR(\"unexpected error (BUG?)\\n\");\n\t\t\tgoto error_bad_uri;\n\t\t\tbreak; /* do nothing, avoids a compilation warning */\n\t}\n#ifdef EXTRA_DEBUG\n\t/* do stuff */\n\tLM_DBG(\"parsed uri:\\n type=%d user=<%.*s>(%d)\\n passwd=<%.*s>(%d)\\n\"\n\t\t\t\" host=<%.*s>(%d)\\n port=<%.*s>(%d): %d\\n params=<%.*s>(%d)\\n\"\n\t\t\t\" headers=<%.*s>(%d)\\n\",\n\t\t\turi->type,\n\t\t\turi->user.len, ZSW(uri->user.s), uri->user.len,\n\t\t\turi->passwd.len, ZSW(uri->passwd.s), uri->passwd.len,\n\t\t\turi->host.len, ZSW(uri->host.s), uri->host.len,\n\t\t\turi->port.len, ZSW(uri->port.s), uri->port.len, uri->port_no,\n\t\t\turi->params.len, ZSW(uri->params.s), uri->params.len,\n\t\t\turi->headers.len, ZSW(uri->headers.s), uri->headers.len\n\t\t);\n\tLM_DBG(\" uri params:\\n   transport=<%.*s>, val=<%.*s>, proto=%d\\n\",\n\t\t\turi->transport.len, ZSW(uri->transport.s), uri->transport_val.len,\n\t\t\tZSW(uri->transport_val.s), uri->proto);\n\tLM_DBG(\"   user-param=<%.*s>, val=<%.*s>\\n\",\n\t\t\turi->user_param.len, ZSW(uri->user_param.s),\n\t\t\turi->user_param_val.len, ZSW(uri->user_param_val.s));\n\tLM_DBG(\"   method=<%.*s>, val=<%.*s>\\n\",\n\t\t\turi->method.len, ZSW(uri->method.s),\n\t\t\turi->method_val.len, ZSW(uri->method_val.s));\n\tLM_DBG(\"   ttl=<%.*s>, val=<%.*s>\\n\",\n\t\t\turi->ttl.len, ZSW(uri->ttl.s),\n\t\t\turi->ttl_val.len, ZSW(uri->ttl_val.s));\n\tLM_DBG(\"   maddr=<%.*s>, val=<%.*s>\\n\",\n\t\t\turi->maddr.len, ZSW(uri->maddr.s),\n\t\t\turi->maddr_val.len, ZSW(uri->maddr_val.s));\n\tLM_DBG(\"   lr=<%.*s>, val=<%.*s>\\n\", uri->lr.len, ZSW(uri->lr.s),\n\t\t\turi->lr_val.len, ZSW(uri->lr_val.s));\n\tLM_DBG(\"   r2=<%.*s>, val=<%.*s>\\n\", uri->r2.len, ZSW(uri->r2.s),\n\t\t\turi->r2_val.len, ZSW(uri->r2_val.s));\n\tfor(i=0; i<URI_MAX_U_PARAMS && uri->u_name[i].s; i++)\n\t\tLM_DBG(\"uname=[%p]-><%.*s> uval=[%p]-><%.*s>\\n\",\n\t\t\turi->u_name[i].s, uri->u_name[i].len, uri->u_name[i].s,\n\t\t\turi->u_val[i].s, uri->u_val[i].len, uri->u_val[i].s);\n\tif (i!=uri->u_params_no)\n\t\tLM_ERR(\"inconsisten # of u_name:[%d]!=[%d]\\n\", i, uri->u_params_no);\n#endif\n\treturn 0;\n\nerror_too_short:\n\tLM_ERR(\"uri too short: <%.*s> (%d)\\n\",\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bad_char:\n\tLM_ERR(\"bad char '%c' in state %d\"\n\t\t\t\" parsed: <%.*s> (%d) / <%.*s> (%d)\\n\",\n\t\t\t*p, state, (int)(p-buf), ZSW(buf), (int)(p-buf),\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bad_host:\n\tLM_ERR(\"bad host in uri (error at char %c in\"\n\t\t\t\" state %d) parsed: <%.*s>(%d) /<%.*s> (%d)\\n\",\n\t\t\t*p, state, (int)(p-buf), ZSW(buf), (int)(p-buf),\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bad_port:\n\tLM_ERR(\"bad port in uri (error at char %c in\"\n\t\t\t\" state %d) parsed: <%.*s>(%d) /<%.*s> (%d)\\n\",\n\t\t\t*p, state, (int)(p-buf), ZSW(buf), (int)(p-buf),\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bad_uri:\n\tLM_ERR(\"bad uri, state %d parsed: <%.*s> (%d) / <%.*s> (%d)\\n\",\n\t\t\t state, (int)(p-buf), ZSW(buf), (int)(p-buf), len,\n\t\t\t ZSW(buf), len);\n\tgoto error_exit;\nerror_headers:\n\tLM_ERR(\"bad uri headers: <%.*s>(%d) / <%.*s>(%d)\\n\",\n\t\t\turi->headers.len, ZSW(uri->headers.s), uri->headers.len,\n\t\t\tlen, ZSW(buf), len);\n\tgoto error_exit;\nerror_bug:\n\tLM_CRIT(\"bad state %d parsed: <%.*s> (%d) / <%.*s> (%d)\\n\",\n\t\t\t state, (int)(p-buf), ZSW(buf), (int)(p-buf), len, ZSW(buf), len);\nerror_exit:\n\tser_error=E_BAD_URI;\n\turi->type=ERROR_URI_T;\n\tupdate_stat(bad_URIs, 1);\n\treturn E_BAD_URI;\n}\n\n\nint parse_sip_msg_uri(struct sip_msg* msg)\n{\n\tchar* tmp;\n\tint tmp_len;\n\tif (msg->parsed_uri_ok) return 1;\n\n\tif (msg->new_uri.s){\n\t\ttmp=msg->new_uri.s;\n\t\ttmp_len=msg->new_uri.len;\n\t}else{\n\t\ttmp=msg->first_line.u.request.uri.s;\n\t\ttmp_len=msg->first_line.u.request.uri.len;\n\t}\n\tif (parse_uri(tmp, tmp_len, &msg->parsed_uri)<0){\n\t\tLM_ERR(\"bad uri <%.*s>\\n\", tmp_len, tmp);\n\t\tmsg->parsed_uri_ok=0;\n\t\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM, \"error parsing r-uri\");\n\t\tset_err_reply(400, \"bad r-uri\");\n\t\treturn -1;\n\t}\n\tmsg->parsed_uri_ok=1;\n\treturn 0;\n}\n\n\nint parse_orig_ruri(struct sip_msg* msg)\n{\n\tstr *uri;\n\n\tif (msg->parsed_orig_ruri_ok)\n\t\treturn 1;\n\n\turi = &REQ_LINE(msg).uri;\n\n\tif (parse_uri(uri->s, uri->len, &msg->parsed_orig_ruri)<0) {\n\t\tLM_ERR(\"bad uri <%.*s>\\n\", uri->len, ZSW(uri->s));\n\t\tmsg->parsed_orig_ruri_ok = 0;\n\t\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,\n\t\t\t\t\"error parsing incoming uri\");\n\t\tset_err_reply(400, \"bad i-uri\");\n\t\treturn -1;\n\t}\n\n\tmsg->parsed_orig_ruri_ok = 1;\n\treturn 0;\n}\n\n#define compare_uri_val(field,cmpfunc) \\\n\tdo { \\\n\t\tif (first.field.len != second.field.len) \\\n\t\t{ \\\n\t\t\tLM_DBG(\"Different URI field - \" #field \"\\n\"); \\\n\t\t\treturn 1; \\\n\t\t} \\\n\t\telse \\\n\t\t{ \\\n\t\t\tif (first.field.len != 0) \\\n\t\t\t\tif (cmpfunc(first.field.s,second.field.s,first.field.len)) \\\n\t\t\t\t{ \\\n\t\t\t\t\tLM_DBG(\"Different URI field - \" #field \"\\n\"); \\\n\t\t\t\t\treturn 1; \\\n\t\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n/* Compare 2 SIP URIs according to RFC 3261\n *\n * Return value : 0 if URIs match\n *\t\t\t\t  1 if URIs don't match\n *\t\t\t\t -1 if errors have occurred\n */\nint compare_uris(str *raw_uri_a,struct sip_uri* parsed_uri_a,\n\t\t\t\t\tstr *raw_uri_b,struct sip_uri *parsed_uri_b)\n{\n\t#define UNESCAPED_BUF_LEN 1024\n\tchar unescaped_a[UNESCAPED_BUF_LEN], unescaped_b[UNESCAPED_BUF_LEN];\n\n\tstr unescaped_userA={unescaped_a, UNESCAPED_BUF_LEN};\n\tstr unescaped_userB={unescaped_b, UNESCAPED_BUF_LEN};\n\n\tstruct sip_uri first;\n\tstruct sip_uri second;\n\tchar matched[URI_MAX_U_PARAMS];\n\tint i,j;\n\n\tif ( (!raw_uri_a && !parsed_uri_a) || (!raw_uri_b && !parsed_uri_b) )\n\t{\n\t\tLM_ERR(\"Provide either a raw or parsed form of a SIP URI\\n\");\n\t\treturn -1;\n\t}\n\n\tif (raw_uri_a && raw_uri_b)\n\t{\n\n\t\t/* maybe we're lucky and straight-forward comparison succeeds */\n\t\tif (raw_uri_a->len == raw_uri_b->len)\n\t\t\tif (strncasecmp(raw_uri_a->s,raw_uri_b->s,raw_uri_a->len) == 0)\n\t\t\t{\n\t\t\t\tLM_DBG(\"straight-forward URI match\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n\n\t/* XXX - maybe if we have two parsed sip_uris,\n\t * or only one parsed and one raw,\n\t * it should be possible to do a straight-forward\n\t * URI match ? */\n\n\tif (parsed_uri_a)\n\t\tfirst = *parsed_uri_a;\n\telse\n\t{\n\t\tif (parse_uri(raw_uri_a->s,raw_uri_a->len,&first) < 0)\n\t\t{\n\t\t\tLM_ERR(\"Failed to parse first URI\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (parsed_uri_b)\n\t\tsecond = *parsed_uri_b;\n\telse\n\t{\n\t\tif (parse_uri(raw_uri_b->s,raw_uri_b->len,&second) < 0)\n\t\t{\n\t\t\tLM_ERR(\"Failed to parse second URI\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (first.type != second.type)\n\t{\n\t\tLM_DBG(\"Different uri types\\n\");\n\t\treturn 1;\n\t}\n\n\tif (unescape_user(&first.user, &unescaped_userA) < 0 ||\n\t\t\tunescape_user(&second.user, &unescaped_userB) < 0) {\n\t\tLM_ERR(\"Failed to unescape user!\\n\");\n\t\treturn -1;\n\t}\n\n\tfirst.user = unescaped_userA;\n\tsecond.user = unescaped_userB;\n\n\tcompare_uri_val(user,strncmp);\n\tcompare_uri_val(passwd,strncmp);\n\tcompare_uri_val(host,strncasecmp);\n\tcompare_uri_val(port,strncmp);\n\n\tcompare_uri_val(transport_val,strncasecmp);\n\tcompare_uri_val(ttl_val,strncasecmp);\n\tcompare_uri_val(user_param_val,strncasecmp);\n\tcompare_uri_val(maddr_val,strncasecmp);\n\tcompare_uri_val(method_val,strncasecmp);\n\tcompare_uri_val(lr_val,strncasecmp);\n\tcompare_uri_val(r2_val,strncasecmp);\n\n\tif (first.u_params_no == 0 || second.u_params_no == 0)\n\t\t/* one URI doesn't have other params,\n\t\t * automatically all unknown params in other URI match\n\t\t */\n\t\tgoto headers_check;\n\n\tmemset(matched,0,URI_MAX_U_PARAMS);\n\n\tfor (i=0;i<first.u_params_no;i++)\n\t\tfor (j=0;j<second.u_params_no;j++)\n\t\t\tif (matched[j] == 0 &&\n\t\t\t\t(first.u_name[i].len == second.u_name[j].len &&\n                strncasecmp(first.u_name[i].s,second.u_name[j].s,\n\t\t\t\t\t\t\tfirst.u_name[i].len) == 0))\n\t\t\t\t{\n                    /* point of no return - matching unknown parameter values */\n\t\t\t\t\tif (first.u_val[i].len != second.u_val[j].len)\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_DBG(\"Different URI param value for param %.*s\\n\",\n\t\t\t\t\t\t\t\tfirst.u_name[i].len,first.u_name[i].s);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (first.u_val[i].len == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* no value for unknown params - match */\n\t\t\t\t\t\t\tmatched[j] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (strncasecmp(first.u_val[i].s,second.u_val[j].s,\n\t\t\t\t\t\t\tsecond.u_val[j].len))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLM_DBG(\"Different URI param value for param %.*s\\n\",\n\t\t\t\t\t\t\t\tfirst.u_name[i].len,first.u_name[i].s);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmatched[j] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t/* got here, it means all unknown params in first URI have been resolved\n\t\t=> first URI matched second URI, and the other way around\n\t*/\n\nheaders_check:\n\t /* XXX Do we really care ? */\n\tcompare_uri_val(headers,strncasecmp);\n\treturn 0;\n}\n"], "filenames": ["parser/parse_uri.c"], "buggy_code_start_loc": [1535], "buggy_code_end_loc": [1548], "fixing_code_start_loc": [1535], "fixing_code_end_loc": [1548], "type": "NVD-CWE-noinfo", "message": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.8 and 3.2.5, when a specially crafted SIP message is processed by the function `rewrite_ruri`, a crash occurs due to a segmentation fault. This issue causes the server to crash. It affects configurations containing functions that make use of the affected code, such as the function `setport`. This issue has been fixed in version 3.1.8 and 3.2.5.", "other": {"cve": {"id": "CVE-2023-27597", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-15T21:15:09.057", "lastModified": "2023-03-21T19:14:22.760", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.8 and 3.2.5, when a specially crafted SIP message is processed by the function `rewrite_ruri`, a crash occurs due to a segmentation fault. This issue causes the server to crash. It affects configurations containing functions that make use of the affected code, such as the function `setport`. This issue has been fixed in version 3.1.8 and 3.2.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.8", "matchCriteriaId": "BC3084E2-3D4E-4C9F-8830-213591FC1DB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "3.2.5", "matchCriteriaId": "272511B0-B141-4AD0-A4FC-51A5EEC59D97"}]}]}], "references": [{"url": "https://github.com/OpenSIPS/opensips/commit/b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSIPS/opensips/security/advisories/GHSA-358f-935m-7p9c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSIPS/opensips/commit/b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3"}}