{"buggy_code": ["#================\n# FILE          : KIWIBoot.pm\n#----------------\n# PROJECT       : OpenSUSE Build-Service\n# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany\n#               :\n# AUTHOR        : Marcus Schaefer <ms@suse.de>\n#               :\n# BELONGS TO    : Operating System images\n#               :\n# DESCRIPTION   : This module is used to create a boot USB stick\n#               : or boot cd from a previously created initrd\n#               : image\n#               : \n#               :\n# STATUS        : Development\n#----------------\npackage KIWIBoot;\n#==========================================\n# Modules\n#------------------------------------------\nrequire Exporter;\n\n#==========================================\n# Modules\n#------------------------------------------\nuse strict;\nuse Carp qw (cluck);\nuse KIWILog;\nuse KIWIIsoLinux;\nuse FileHandle;\nuse File::Basename;\nuse File::Spec;\nuse Math::BigFloat;\nuse KIWILocator;\nuse KIWIQX;\n\n#==========================================\n# Constructor\n#------------------------------------------\nsub new {\n\t# ...\n\t# Create a new KIWIBoot object which is used to create bootable\n\t# media images like CD/DVD's , USB sticks or Virtual disks \n\t# ---\n\t#==========================================\n\t# Object setup\n\t#------------------------------------------\n\tmy $this  = {};\n\tmy $class = shift;\n\tbless $this,$class;\n\t#==========================================\n\t# Module Parameters\n\t#------------------------------------------\n\tmy $kiwi   = shift;\n\tmy $initrd = shift;\n\tmy $cmdL   = shift;\n\tmy $system = shift;\n\tmy $vmsize = shift;\n\tmy $device = shift;\n\tmy $profile= shift;\n\t#==========================================\n\t# Constructor setup\n\t#------------------------------------------\n\tmy $syszip    = 0;\n\tmy $sysird    = 0;\n\tmy $zipped    = 0;\n\tmy $vga       = \"0x314\";\n\tmy $vgroup    = \"kiwiVG\";\n\tmy $haveTree  = 0;\n\tmy $haveSplit = 0;\n\tmy $vmmbyte;\n\tmy $kernel;\n\tmy $knlink;\n\tmy $tmpdir;\n\tmy $loopdir;\n\tmy $result;\n\tmy $status;\n\tmy $isxen;\n\tmy $xendomain;\n\tmy $xengz;\n\tmy $xml;\n\t#==========================================\n\t# create log object if not done\n\t#------------------------------------------\n\tif (! defined $kiwi) {\n\t\t$kiwi = new KIWILog(\"tiny\");\n\t}\n\t#==========================================\n\t# check initrd file parameter\n\t#------------------------------------------\n\tif ((defined $initrd) && (! -f $initrd)) {\n\t\t$kiwi -> error  (\"Couldn't find initrd file: $initrd\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check for split system\n\t#------------------------------------------\n\tif (-f \"$system/rootfs.tar\") {\n\t\t$kiwi -> error (\"Can't use split root tree, run create first\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# find image type...\n\t#------------------------------------------\n\tif (! defined $cmdL->getBuildType()) {\n\t\tif ($initrd =~ /oemboot/) {\n\t\t\t$cmdL -> setBuildType (\"oem\");\n\t\t}\n\t\tif ($initrd =~ /vmxboot/) {\n\t\t\t$cmdL -> setBuildType (\"vmx\");\n\t\t}\n\t}\n\t#==========================================\n\t# check system image file parameter\n\t#------------------------------------------\n\tif (defined $system) {\n\t\tif ((-f $system) || (-b $system)) {\n\t\t\tmy %fsattr = $main::global -> checkFileSystem ($system);\n\t\t\tif (($fsattr{readonly}) || ($fsattr{type} eq \"luks\")) {\n\t\t\t\t$syszip = $main::global -> isize ($system);\n\t\t\t} else {\n\t\t\t\t$syszip = 0;\n\t\t\t}\n\t\t} elsif (! -d $system) {\n\t\t\t$kiwi -> error  (\"Couldn't find image file/directory: $system\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} elsif (-f \"$system/kiwi-root.cow\") {\n\t\t\t#==========================================\n\t\t\t# Check for overlay structure\n\t\t\t#------------------------------------------\n\t\t\t$this->{overlay} = new KIWIOverlay ($kiwi,$system);\n\t\t\tif (! $this->{overlay}) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$system = $this->{overlay} -> mountOverlay();\n\t\t\tif (! -d $system) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# check if we got the tree or image file\n\t#------------------------------------------\n\tif (-d $system) {\n\t\t$haveTree = 1;\n\t}\n\t#==========================================\n\t# compressed initrd used...\n\t#------------------------------------------\n\tif ($initrd =~ /\\.gz$/) {\n\t\t$zipped = 1;\n\t}\n\t#==========================================\n\t# find kernel file\n\t#------------------------------------------\n\t$kernel = $initrd;\n\tif ($kernel =~ /gz$/) {\n\t\t$kernel =~ s/gz$/kernel/;\n\t} else {\n\t\t$kernel = $kernel.\".kernel\";\n\t}\n\tif (! -e $kernel) {\n\t\t$kernel =~ s/splash\\.kernel$/kernel/;\n\t}\n\tif (-l $kernel) {\n\t\t$knlink = $kernel;\n\t\t$kernel = readlink ($knlink);\n\t\tif (!File::Spec->file_name_is_absolute($kernel)) {\n\t\t\t$kernel = File::Spec->catfile(dirname($initrd), $kernel);\n\t\t}\n\t}\n\tif ((defined $initrd) && (! -f $kernel)) {\n\t\t$kiwi -> error  (\"Couldn't find kernel file: $kernel\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check if Xen system is used\n\t#------------------------------------------\n\t$isxen = 0;\n\t$xengz = $initrd;\n\t$xengz =~ s/\\.gz$//;\n\t$xengz =~ s/\\.splash$//;\n\tforeach my $xen (glob (\"$xengz*xen*.gz\")) {\n\t\t$isxen = 1;\n\t\t$xengz = $xen;\n\t\tlast;\n\t}\n\t#==========================================\n\t# create tmp dir for operations\n\t#------------------------------------------\n\t$tmpdir = qxx (\"mktemp -q -d /tmp/kiwiboot.XXXXXX\"); chomp $tmpdir;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$loopdir = qxx (\"mktemp -q -d /tmp/kiwiloop.XXXXXX\"); chomp $loopdir;\n\t$result  = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $loopdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! $main::global) {\n\t\t$kiwi -> error  (\"Globals object not found\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Store object data (1)\n\t#------------------------------------------\n\t$this->{gdata}    = $main::global -> getGlobals();\n\t$this->{tmpdir}   = $tmpdir;\n\t$this->{loopdir}  = $loopdir;\n\t$this->{lvmgroup} = $vgroup;\n\t$this->{tmpdirs}  = [ $tmpdir, $loopdir ];\n\t$this->{haveTree} = $haveTree;\n\t$this->{kiwi}     = $kiwi;\n\t$this->{bootsize} = 100;\n\n\t#==========================================\n\t# setup pointer to XML configuration\n\t#------------------------------------------\n\tif (defined $system) {\n\t\tif (-d $system) {\n\t\t\tmy $locator = new KIWILocator($kiwi);\n\t\t\tmy $controlFile = $locator -> getControlFile ($system.\"/image\");\n\t\t\tmy $validator = new KIWIXMLValidator (\n\t\t\t\t$kiwi,$controlFile,\n\t\t\t\t$this->{gdata}->{Revision},\n\t\t\t\t$this->{gdata}->{Schema},\n\t\t\t\t$this->{gdata}->{SchemaCVT}\n\t\t\t);\n\t\t\tmy $isValid = $validator ? $validator -> validate() : undef;\n\t\t\tif (! $isValid) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$xml = new KIWIXML (\n\t\t\t\t$kiwi,$system.\"/image\",$cmdL->getBuildType(),$profile,$cmdL\n\t\t\t);\n\t\t\t#==========================================\n\t\t\t# Determine size of /boot area\n\t\t\t#------------------------------------------\n\t\t\tif (defined $initrd) {\n\t\t\t\t$this ->{bootsize} = $this -> __getBootSize ($system);\n\t\t\t}\n\t\t} else {\n\t\t\tmy %fsattr = $main::global -> checkFileSystem ($system);\n\t\t\tif ((! $fsattr{type}) || ($fsattr{type} eq \"auto\")) {\n\t\t\t\t#==========================================\n\t\t\t\t# bind $system to loop device\n\t\t\t\t#------------------------------------------\n\t\t\t\t$kiwi -> info (\"Binding disk to loop device\");\n\t\t\t\tif (! $this -> bindDiskDevice($system)) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$kiwi -> done();\n\t\t\t\t#==========================================\n\t\t\t\t# setup device mapper\n\t\t\t\t#------------------------------------------\n\t\t\t\t$kiwi -> info (\"Setup device mapper for partition access\");\n\t\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$kiwi -> done();\n\t\t\t\t#==========================================\n\t\t\t\t# find partition and mount it\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $sdev = $this->{bindloop}.\"1\";\n\t\t\t\t#==========================================\n\t\t\t\t# check for activated volume group\n\t\t\t\t#------------------------------------------\n\t\t\t\t$sdev = $this -> checkLVMbind ($sdev,$this->{loop});\n\t\t\t\t#==========================================\n\t\t\t\t# perform mount call\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (! $main::global -> mount($sdev, $tmpdir)) {\n\t\t\t\t\t$kiwi -> error (\"System image mount failed: $status\");\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# read disk image XML description\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $locator = new KIWILocator($kiwi);\n\t\t\t\tmy $controlFile = $locator -> getControlFile ($tmpdir.\"/image\");\n\t\t\t\tmy $validator = new KIWIXMLValidator (\n\t\t\t\t\t$kiwi,$controlFile,\n\t\t\t\t\t$this->{gdata}->{Revision},\n\t\t\t\t\t$this->{gdata}->{Schema},\n\t\t\t\t\t$this->{gdata}->{SchemaCVT}\n\t\t\t\t);\n\t\t\t\tmy $isValid = $validator ? $validator -> validate() : undef;\n\t\t\t\tif (! $isValid) {\n\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$xml = new KIWIXML (\n\t\t\t\t\t$kiwi,$tmpdir.\"/image\",$cmdL->getBuildType(),$profile,$cmdL\n\t\t\t\t);\n\t\t\t\t#==========================================\n\t\t\t\t# Determine size of /boot area\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (defined $initrd) {\n\t\t\t\t\t$this ->{bootsize} = $this -> __getBootSize ($tmpdir);\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# clean up\n\t\t\t\t#------------------------------------------\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t} else {\n\t\t\t\t#==========================================\n\t\t\t\t# loop mount system image\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (! $main::global -> mount ($system,$tmpdir)) {\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# check for split type\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (-f \"$tmpdir/rootfs.tar\") {\n\t\t\t\t\t$cmdL -> setBuildType (\"split\");\n\t\t\t\t\t$haveSplit = 1;\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# read disk image XML description\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $locator = new KIWILocator($kiwi);\n\t\t\t\tmy $controlFile = $locator -> getControlFile ($tmpdir.\"/image\");\n\t\t\t\tmy $validator = new KIWIXMLValidator (\n\t\t\t\t\t$kiwi,$controlFile,\n\t\t\t\t\t$this->{gdata}->{Revision},\n\t\t\t\t\t$this->{gdata}->{Schema},\n\t\t\t\t\t$this->{gdata}->{SchemaCVT}\n\t\t\t\t);\n\t\t\t\tmy $isValid = $validator ? $validator -> validate() : undef;\n\t\t\t\tif (! $isValid) {\n\t\t\t\t\t$main::global -> umount();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$xml = new KIWIXML (\n\t\t\t\t\t$kiwi,$tmpdir.\"/image\",$cmdL->getBuildType(),$profile,$cmdL\n\t\t\t\t);\n\t\t\t\t#==========================================\n\t\t\t\t# Determine size of /boot area\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (defined $initrd) {\n\t\t\t\t\t$this ->{bootsize} = $this -> __getBootSize ($tmpdir);\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# clean up\n\t\t\t\t#------------------------------------------\n\t\t\t\t$main::global -> umount();\n\t\t\t}\n\t\t}\n\t\tif (! defined $xml) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# find Xen domain configuration\n\t#------------------------------------------\n\tif ($isxen && defined $xml) {\n\t\tmy %xenc = $xml -> getXenConfig();\n\t\tif (defined $xenc{xen_domain}) {\n\t\t\t$xendomain = $xenc{xen_domain};\n\t\t} else {\n\t\t\t$xendomain = \"dom0\";\n\t\t}\n\t}\n\t#==========================================\n\t# Setup disk size and inode count\n\t#------------------------------------------\n\tif ((defined $system) && (defined $initrd)) {\n\t\tmy $sizeBytes;\n\t\tmy $minInodes;\n\t\tmy $sizeXMLBytes = 0;\n\t\tmy $spare        = 100 * 1024 * 1024; # 100M free\n\t\tmy $fsoverhead   = 1.4;\n\t\tmy $fsopts       = $cmdL -> getFilesystemOptions();\n\t\tmy $inodesize    = $fsopts->[1];\n\t\tmy $inoderatio   = $fsopts->[2];\n\t\tmy $kernelSize   = $main::global -> isize ($kernel);\n\t\tmy $initrdSize   = $main::global -> isize ($initrd);\n\t\t#==========================================\n\t\t# Calculate minimum size of the system\n\t\t#------------------------------------------\n\t\tif (-d $system) {\n\t\t\t# System is specified as a directory...\n\t\t\t$minInodes = qxx (\"find $system | wc -l\");\n\t\t\t$sizeBytes = qxx (\"du -s --block-size=1 $system | cut -f1\");\n\t\t\t$sizeBytes*= $fsoverhead;\n\t\t\tchomp $minInodes;\n\t\t\tchomp $sizeBytes;\n\t\t\t$minInodes*= 2;\n\t\t\t$sizeBytes+= $minInodes * $inodesize;\n\t\t\t$sizeBytes+= $kernelSize;\n\t\t\t$sizeBytes+= $initrdSize;\n\t\t\t$sizeBytes+= $spare;\n\t\t} else {\n\t\t\t# system is specified as a file...\n\t\t\t$sizeBytes = $main::global -> isize ($system);\n\t\t\t$sizeBytes+= $kernelSize;\n\t\t\t$sizeBytes+= $initrdSize;\n\t\t\t$sizeBytes+= $spare;\n\t\t}\n\t\t#==========================================\n\t\t# Store optional size setup from XML\n\t\t#------------------------------------------\n\t\tmy $sizeXMLAddBytes = $xml -> getImageSizeAdditiveBytes();\n\t\tif ($sizeXMLAddBytes) {\n\t\t\t$sizeXMLBytes = $sizeBytes + $sizeXMLAddBytes;\n\t\t} else {\n\t\t\t$sizeXMLBytes = $xml -> getImageSizeBytes();\n\t\t}\n\t\t#==========================================\n\t\t# Store initial disk size\n\t\t#------------------------------------------\n\t\t$this -> __initDiskSize ($sizeBytes,$vmsize,$sizeXMLBytes);\n\t\t#==========================================\n\t\t# Calculate required inode count for root\n\t\t#------------------------------------------\n\t\tif (-d $system) {\n\t\t\t# /.../\n\t\t\t# if the system is a directory the root filesystem\n\t\t\t# will be created during the image creation. In this\n\t\t\t# case we need to create the inode count\n\t\t\t# ----\n\t\t\t$this->{inodes} = int ($this->{vmmbytes} / $inoderatio);\n\t\t\t$kiwi -> loginfo (\n\t\t\t\t\"Using \".$this->{inodes}.\" inodes for the root filesystem\\n\"\n\t\t\t);\n\t\t}\n\t}\n\t#==========================================\n\t# round compressed image size\n\t#------------------------------------------\n\tif ($syszip) {\n\t\t$syszip = $syszip / 1048576;\n\t\t$syszip = sprintf (\"%.0f\", $syszip);\n\t}\n\t#==========================================\n\t# Store a disk label ID for this object\n\t#------------------------------------------\n\t$this->{mbrid} = $main::global -> getMBRDiskLabel (\n\t\t$cmdL -> getMBRID()\n\t);\n\t#==========================================\n\t# find system architecture\n\t#------------------------------------------\n\tmy $arch = qxx (\"uname -m\"); chomp $arch;\n\t#==========================================\n\t# check framebuffer vga value\n\t#------------------------------------------\n\tif (defined $xml) {\n\t\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\t\tif ($type{vga}) {\n\t\t\t$vga = $type{vga};\n\t\t}\n\t\tif ($type{luks}) {\n\t\t\t$main::global -> setGlobals (\"LuksCipher\",$type{luks});\n\t\t}\n\t}\n\t#==========================================\n\t# check partitioner\n\t#------------------------------------------\n\tmy $ptool = $cmdL -> getPartitioner();\n\tif (! $ptool) {\n\t\t$ptool = $this->{gdata}->{Partitioner};\n\t}\n\t#==========================================\n\t# Store object data (2)\n\t#------------------------------------------\n\t$this->{initrd}    = $initrd;\n\t$this->{system}    = $system;\n\t$this->{kernel}    = $kernel;\n\t$this->{syszip}    = $syszip;\n\t$this->{device}    = $device;\n\t$this->{zipped}    = $zipped;\n\t$this->{isxen}     = $isxen;\n\t$this->{xengz}     = $xengz;\n\t$this->{arch}      = $arch;\n\t$this->{ptool}     = $ptool;\n\t$this->{vga}       = $vga;\n\t$this->{xml}       = $xml;\n\t$this->{cmdL}      = $cmdL;\n\t$this->{xendomain} = $xendomain;\n\t$this->{profile}   = $profile;\n\t$this->{haveSplit} = $haveSplit;\n\t$this->{imgtype}   = $cmdL->getBuildType();\n\t$this->{chainload} = $cmdL->getGrubChainload();\n\treturn $this;\n}\n\n#==========================================\n# createBootStructure\n#------------------------------------------\nsub createBootStructure {\n\tmy $this   = shift;\n\tmy $loc    = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $initrd = $this->{initrd};\n\tmy $tmpdir = $this->{tmpdir};\n\tmy $kernel = $this->{kernel};\n\tmy $zipped = $this->{zipped};\n\tmy $isxen  = $this->{isxen};\n\tmy $xengz  = $this->{xengz};\n\tmy $xendomain = $this->{xendomain};\n\tmy $lname  = \"linux\";\n\tmy $iname  = \"initrd\";\n\tmy $xname  = \"xen.gz\";\n\tmy $zipper = $this->{gdata}->{Gzip};\n\tmy $status;\n\tmy $result;\n\tif (defined $loc) {\n\t\t$lname  = $lname.\".\".$loc;\n\t\t$iname  = $iname.\".\".$loc;\n\t\t$xname  = $xname.\".\".$loc;\n\t}\n\tif ($initrd !~ /splash\\.gz$|splash\\.install\\.gz/) {\n\t\t$initrd = $this -> setupSplash();\n\t\t$zipped = 1;\n\t}\n\t$kiwi -> info (\"Creating initial boot structure\");\n\t$status = qxx ( \"mkdir -p $tmpdir/boot 2>&1\" );\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed creating initial directories: $status\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif ($zipped) {\n\t\tif ($isxen) {\n\t\t\t# deflate/inflate initrd to make xen happy\n\t\t\tmy $irdunc = $initrd;\n\t\t\t$irdunc =~ s/\\.gz//;\n\t\t\tqxx (\"$zipper -d $initrd && $zipper $irdunc\");\n\t\t}\n\t\t$status = qxx ( \"cp $initrd $tmpdir/boot/$iname 2>&1\" );\n\t} else {\n\t\t$status = qxx ( \"cat $initrd | $zipper > $tmpdir/boot/$iname\" );\n\t}\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed importing initrd: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$status = qxx ( \"cp $kernel $tmpdir/boot/$lname 2>&1\" );\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed importing kernel: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (($isxen) && ($xendomain eq \"dom0\")) {\n\t\t$status = qxx ( \"cp $xengz $tmpdir/boot/$xname 2>&1\" );\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed importing Xen dom0 kernel: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t$kiwi -> done();\n\treturn $tmpdir;\n}\n\n#==========================================\n# getRemovableUSBStorageDevices\n#------------------------------------------\nsub getRemovableUSBStorageDevices {\n\tmy $this    = shift;\n\tmy %devices = ();\n\tmy @storage = glob (\"/sys/bus/usb/drivers/usb-storage/*\");\n\tforeach my $device (@storage) {\n\t\tif (-l $device) {\n\t\t\tmy @descriptions = glob (\"$device/host*/target*/*/block*\");\n\t\t\tforeach my $description (@descriptions) {\n\t\t\t\tif (! -d $description) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tmy $isremovable = \"$description/removable\";\n\t\t\t\tmy $serial = \"USB Stick (unknown type)\";\n\t\t\t\tif ($description =~ /usb-storage\\/(.*?):.*/) {\n\t\t\t\t\t$serial = \"/sys/bus/usb/devices/$1/serial\";\n\t\t\t\t\tif (open (FD,$serial)) {\n\t\t\t\t\t\t$serial = <FD>;\n\t\t\t\t\t\tchomp $serial;\n\t\t\t\t\t\tclose FD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($description =~ /block:(.*)/) {\n\t\t\t\t\t$description = \"/dev/\".$1;\n\t\t\t\t} else {\n\t\t\t\t\tmy @bdevs = glob (\"$description/*\");\t\n\t\t\t\t\tmy $bdev = basename ($bdevs[0]);\n\t\t\t\t\t$isremovable = $description.\"/\".$bdev.\"/removable\";\n\t\t\t\t\t$description = \"/dev/\".$bdev;\n\t\t\t\t}\n\t\t\t\tif (! open (FD,$isremovable)) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$isremovable = <FD>; close FD;\n\t\t\t\tif ($isremovable == 1) {\n\t\t\t\t\tmy $result = $this -> getStorageSize ($description);\n\t\t\t\t\tif ($result > 0) {\n\t\t\t\t\t\t$devices{$description} = $serial;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn %devices;\n}\n\n#==========================================\n# setupInstallCD\n#------------------------------------------\nsub setupInstallCD {\n\tmy $this      = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $arch      = $this->{arch};\n\tmy $initrd    = $this->{initrd};\n\tmy $system    = $this->{system};\n\tmy $oldird    = $this->{initrd};\n\tmy $zipped    = $this->{zipped};\n\tmy $isxen     = $this->{isxen};\n\tmy $lvm       = $this->{lvm};\n\tmy $xml       = $this->{xml};\n\tmy $md5name   = $system;\n\tmy $destdir   = dirname ($initrd);\n\tmy $gotsys    = 1;\n\tmy $volid     = \"-V \\\"KIWI CD/DVD Installation\\\"\";\n\tmy $bootloader;\n\tif ($arch =~ /ppc|ppc64/) {\n\t\t$bootloader = \"lilo\";\n\t} else {\n\t\t$bootloader = \"grub\";\n\t}\n\tmy $status;\n\tmy $result;\n\tmy $tmpdir;\n\tmy %type;\n\tmy $haveDiskDevice;\n\tmy $version;\n\tmy $FD;\n\t#==========================================\n\t# Check for disk device\n\t#------------------------------------------\n\tif (-b $system) {\n\t\t$haveDiskDevice = $system;\n\t\t$version = $xml -> getImageVersion();\n\t\t$system  = $xml -> getImageName();\n\t\t$system  = $destdir.\"/\".$system.\".\".$arch.\"-\".$version.\".raw\";\n\t\t$md5name = $system;\n\t\t$this->{system} = $system;\n\t}\n\t#==========================================\n\t# read MBR disk label\n\t#------------------------------------------\n\tif (! open $FD,\"dd 2>/dev/null if=$system bs=1 count=4 skip=\\$((0x1b8))|\") {\n\t\t$kiwi -> error  (\"Couldn't open: $system: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $mbrid = sprintf \"0x%08x\", unpack \"V\", <$FD>;\n\tif (($this->{mbrid}) && ($mbrid ne $this->{mbrid})) {\n\t\t$this->{mbrid} = $mbrid;\n\t}\n\tclose $FD;\n\t#==========================================\n\t# read config XML attributes\n\t#------------------------------------------\n\tif (defined $xml) {\n\t\t%type = %{$xml->getImageTypeAndAttributes()};\n\t}\n\t#==========================================\n\t# check for volume id\n\t#------------------------------------------\n\tif ((%type) && ($type{volid})) {\n\t\t$volid = \" -V \\\"$type{volid}\\\"\";\n\t}\n\t#==========================================\n\t# setup boot loader type\n\t#------------------------------------------\n\tif ((%type) && ($type{bootloader})) {\n\t\t$bootloader = $type{bootloader};\n\t}\n\t#==========================================\n\t# create tmp directory\n\t#------------------------------------------\n\tmy $basedir;\n\tif ($system) {\n\t\t$basedir = dirname ($system);\n\t} else {\n\t\t$basedir = dirname ($initrd);\n\t}\n\t$tmpdir = qxx ( \"mktemp -q -d $basedir/kiwicdinst.XXXXXX\" ); chomp $tmpdir;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$this->{tmpdir} = $tmpdir;\n\tpush @{$this->{tmpdirs}},$tmpdir;\n\t#==========================================\n\t# check if initrd is zipped\n\t#------------------------------------------\n\tif (! $zipped) {\n\t\t$kiwi -> error  (\"Compressed boot image required\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check if system image is given\n\t#------------------------------------------\n\tif (! $system) {\n\t\t$system = $initrd;\n\t\t$gotsys = 0;\n\t}\n\t#==========================================\n\t# check image type\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t#==========================================\n\t\t# build label from xml data\n\t\t#------------------------------------------\n\t\t$this->{bootlabel} = $xml -> getImageDisplayName();\n\t\tif (! $haveDiskDevice) {\n\t\t\t#==========================================\n\t\t\t# bind $system to loop device\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> info (\"Binding disk to loop device\");\n\t\t\tif (! $this -> bindDiskDevice($system)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t\t#==========================================\n\t\t\t# setup device mapper\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> info (\"Setup device mapper for partition access\");\n\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> info (\"Using disk device: $haveDiskDevice\");\n\t\t\t$this->{loop}     = $haveDiskDevice;\n\t\t\t$this->{bindloop} = $haveDiskDevice;\n\t\t\tqxx (\"vgchange -a y 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t}\n\t\t#==========================================\n\t\t# find partition to check\n\t\t#------------------------------------------\n\t\tmy $sdev;\n\t\tif ($arch =~ /ppc|ppc64/) {\n\t\t\t$sdev = $this->{bindloop}.\"2\";\n\t\t} else {\n\t\t\t$sdev = $this->{bindloop}.\"1\";\n\t\t\tif (! -e $sdev) {\n\t\t\t\t$sdev = $this->{bindloop}.\"2\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# check for activated volume group\n\t\t#------------------------------------------\n\t\t$sdev = $this -> checkLVMbind ($sdev,$this->{loop});\n\t\t#==========================================\n\t\t# perform mount call\n\t\t#------------------------------------------\n\t\tif (! $main::global -> mount ($sdev, $tmpdir)) {\n\t\t\t$kiwi -> error (\"Failed to mount system partition: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> cleanLoop();\n\t}\n\t#==========================================\n\t# Build md5sum of system image\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\tif (! $haveDiskDevice) {\n\t\t\t$this -> buildMD5Sum ($system);\n\t\t} else {\n\t\t\t$this -> buildMD5Sum ($this->{loop},$system);\n\t\t}\n\t}\n\t#==========================================\n\t# Setup image basename\n\t#------------------------------------------\n\tmy $namecd = basename ($system);\n\t#==========================================\n\t# Compress system image\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t$md5name =~ s/\\.raw$/\\.md5/;\n\t\t$kiwi -> info (\"Compressing installation image...\");\n\t\tif ($haveDiskDevice) {\n\t\t\t$status = qxx (\"cat $haveDiskDevice > $system\");\n\t\t}\n\t\t$status = qxx (\n\t\t\t\"mksquashfs $system $md5name $system.squashfs -no-progress 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to compress system image: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t$system = $system.\".squashfs\";\n\t}\n\t#==========================================\n\t# Setup initrd for install purpose\n\t#------------------------------------------\n\t$initrd = $this -> setupInstallFlags();\n\tif (! defined $initrd) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create CD structure\n\t#------------------------------------------\n\t$this->{initrd} = $initrd;\n\tif (! $this -> createBootStructure()) {\n\t\t$this->{initrd} = $oldird;\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Import boot loader stages\n\t#------------------------------------------\n\tif (! $this -> setupBootLoaderStages ($bootloader,\"iso\")) {\n\t\treturn undef;\n\t}\n\tqxx (\"rm -rf $tmpdir/usr 2>&1\");\n\tqxx (\"rm -rf $tmpdir/image 2>&1\");\n\t$this->{initrd} = $oldird;\n\t#==========================================\n\t# Creating boot loader configuration\n\t#------------------------------------------\n\tmy $title = \"KIWI CD Installation\";\n\tif (! $gotsys) {\n\t\t$title = \"KIWI CD Boot: $namecd\";\n\t}\n\tif (! $this -> setupBootLoaderConfiguration ($bootloader,$title)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for optional config-cdroot archive\n\t#------------------------------------------\n\tmy $cdrootData = \"config-cdroot.tgz\";\n\tif (-f \"$destdir/$cdrootData\") {\n\t\t$kiwi -> info (\"Integrating CD root information...\");\n\t\t$status= qxx (\n\t\t\t\"tar -C $tmpdir -xvf $destdir/$cdrootData\"\n\t\t);\n\t\t$result= $? >> 8;\n\t\tqxx (\"rm -f $destdir/$cdrootData\");\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to integrate CD root data: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Check for optional config-cdroot.sh\n\t#------------------------------------------\n\tmy $cdrootScript = \"config-cdroot.sh\";\n\tif (-x \"$destdir/$cdrootScript\") {\n\t\t$kiwi -> info (\"Calling CD root setup script...\");\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\tmy $script = \"$destdir/$cdrootScript\";\n\t\tif ($script !~ /^\\//) {\n\t\t\t$script = $pwd.\"/\".$script;\n\t\t}\n\t\t$status = qxx (\n\t\t\t\"cd $tmpdir && bash -c $script 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tqxx (\"rm -f $script\");\n\t\tif ($result != 0) {\n\t\t\tchomp $status;\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to call CD root script: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"config-cdroot.sh: $status\");\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Copy system image if given\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\tif (! open (FD,\">$tmpdir/config.isoclient\")) {\n\t\t\t$kiwi -> error  (\"Couldn't create CD install flag file\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"IMAGE=$namecd\\n\";\n\t\tclose FD;\n\t\t$kiwi -> info (\"Importing system image: $system\");\n\t\t$status = qxx (\"mv $system $tmpdir 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed importing system image: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$system =~ s/\\.squashfs$//;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Create an iso image from the tree\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating ISO image...\");\n\tmy $name = $system;\n\tif ($gotsys) {\n\t\t$name =~ s/raw$/iso/;\n\t} else {\n\t\t$name =~ s/gz$/iso/;\n\t}\n\tmy $base;\n\tmy $opts;\n\tif ($bootloader eq \"grub\") {\n\t\t# let isolinux run grub second stage...\n\t\t$base = \"-R -J -f -b boot/grub/stage2 -no-emul-boot $volid\";\n\t\t$opts = \"-boot-load-size 4 -boot-info-table -udf -allow-limited-size \";\n\t\t$opts.= \"-pad -joliet-long\";\n\t} elsif ($bootloader =~ /(sys|ext)linux/) {\n\t\t# turn sys/extlinux configuation into a isolinux configuration...\n\t\tmy $cfg_ext = \"$tmpdir/boot/syslinux/syslinux.cfg\";\n\t\tif (! -f $cfg_ext) {\n\t\t\t$cfg_ext = \"$tmpdir/boot/syslinux/extlinux.conf\";\n\t\t}\n\t\tmy $cfg_iso = \"$tmpdir/boot/syslinux/isolinux.cfg\";\n\t\tqxx (\"mv $cfg_ext $cfg_iso 2>&1\");\n\t\tqxx (\"mv $tmpdir/boot/initrd $tmpdir/boot/syslinux\");\n\t\tqxx (\"mv $tmpdir/boot/linux  $tmpdir/boot/syslinux\");\n\t\tqxx (\"mv $tmpdir/boot/syslinux $tmpdir/boot/loader 2>&1\");\n\t\t$base = \"-R -J -f -b boot/loader/isolinux.bin -no-emul-boot $volid\";\n\t\t$opts = \"-boot-load-size 4 -boot-info-table -udf -allow-limited-size \";\n\t\t$opts.= \"-pad -joliet-long\";\n\t} elsif ($bootloader eq \"lilo\") {\n\t\t$base = \"-r\";\n\t\t$opts = \"-U -chrp-boot -pad -joliet-long\";\n\t} else {\n\t\t# don't know how to use this bootloader together with isolinux\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Bootloader not supported for CD inst: $bootloader\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $wdir = qxx (\"pwd\"); chomp $wdir;\n\tif ($name !~ /^\\//) {\n\t\t$name = $wdir.\"/\".$name;\n\t}\n\tmy $iso = new KIWIIsoLinux (\n\t\t$kiwi,$tmpdir,$name,undef,\"checkmedia\",$this->{cmdL}\n\t);\n\tif (! defined $iso) {\n\t\treturn undef;\n\t}\n\tmy $tool= $iso -> getTool();\n\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\t$iso -> createISOLinuxConfig (\"/boot\");\n\t}\n\t$status = qxx (\"cd $tmpdir && $tool $base $opts -o $name . 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed creating ISO image: $status\");\n\t\t$kiwi -> failed ();\n\t\t$iso  -> cleanISO ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done ();\n\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\tif (! $iso->createHybrid($this->{mbrid})) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\tif ($arch !~ /ppc|ppc64/) {\n\t\tif (! $iso -> relocateCatalog ()) {\n\t\t\t$iso  -> cleanISO ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Clean tmp\n\t#------------------------------------------\n\tqxx (\"rm -rf $tmpdir\");\n\t$kiwi -> info (\"Created $name to be burned on CD\");\n\t$kiwi -> done ();\n\t$iso  -> cleanISO ();\n\treturn $this;\n}\n\n#==========================================\n# setupInstallStick\n#------------------------------------------\nsub setupInstallStick {\n\tmy $this      = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $arch      = $this->{arch};\n\tmy $initrd    = $this->{initrd};\n\tmy $system    = $this->{system};\n\tmy $oldird    = $this->{initrd};\n\tmy $device    = $this->{device};\n\tmy $loopdir   = $this->{loopdir};\n\tmy $zipped    = $this->{zipped};\n\tmy $isxen     = $this->{isxen};\n\tmy $xml       = $this->{xml};\n\tmy $cmdL      = $this->{cmdL};\n\tmy $irdsize   = $main::global -> isize ($initrd);\n\tmy $vmsize    = $main::global -> isize ($system);\n\tmy $diskname  = $system.\".install.raw\";\n\tmy $md5name   = $system;\n\tmy $destdir   = dirname ($initrd);\n\tmy %deviceMap = ();\n\tmy @commands  = ();\n\tmy $gotsys    = 1;\n\tmy $bootloader= \"grub\";\n\tmy $haveDiskDevice;\n\tmy $status;\n\tmy $result;\n\tmy $version;\n\tmy $tmpdir;\n\tmy %type;\n\tmy $stick;\n\t#==========================================\n\t# Check for disk device\n\t#------------------------------------------\n\tif (-b $system) {\n\t\t$haveDiskDevice = $system;\n\t\t$version = $xml -> getImageVersion();\n\t\t$system  = $xml -> getImageName();\n\t\t$system  = $destdir.\"/\".$system.\".\".$arch.\"-\".$version.\".raw\";\n\t\t$diskname= $system.\".install.raw\";\n\t\t$md5name = $system;\n\t\t$this->{system} = $system;\n\t}\n\t#==========================================\n\t# read config XML attributes\n\t#------------------------------------------\n\tif (defined $xml) {\n\t\t%type = %{$xml->getImageTypeAndAttributes()};\n\t}\n\t#==========================================\n\t# setup boot loader type\n\t#------------------------------------------\n\tif ((%type) && ($type{bootloader})) {\n\t\t$bootloader = $type{bootloader};\n\t}\n\t#==========================================\n\t# create tmp directory\n\t#------------------------------------------\n\t$tmpdir = qxx ( \"mktemp -q -d /tmp/kiwistickinst.XXXXXX\" ); chomp $tmpdir;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$this->{tmpdir} = $tmpdir;\n\tpush @{$this->{tmpdirs}},$tmpdir;\n\t#==========================================\n\t# check if initrd is zipped\n\t#------------------------------------------\n\tif (! $zipped) {\n\t\t$kiwi -> error  (\"Compressed boot image required\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check if system image is given\n\t#------------------------------------------\n\tif (! defined $system) {\n\t\t$system   = $initrd;\n\t\t$diskname = $initrd;\n\t\t$diskname =~ s/gz$/raw/;\n\t\t$gotsys   = 0;\n\t}\n\t#==========================================\n\t# check image type\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t#==========================================\n\t\t# build label from xml data\n\t\t#------------------------------------------\n\t\t$this->{bootlabel} = $xml -> getImageDisplayName();\n\t\tif (! $haveDiskDevice) {\n\t\t\t#==========================================\n\t\t\t# bind $system to loop device\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> info (\"Binding disk to loop device\");\n\t\t\tif (! $this -> bindDiskDevice ($system)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t\t#==========================================\n\t\t\t# setup device mapper\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> info (\"Setup device mapper for partition access\");\n\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> info (\"Using disk device: $haveDiskDevice\");\n\t\t\t$this->{loop}     = $haveDiskDevice;\n\t\t\t$this->{bindloop} = $haveDiskDevice;\n\t\t\tqxx (\"vgchange -a y 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t}\n\t\t#==========================================\n\t\t# find partition to check\n\t\t#------------------------------------------\n\t\tmy $sdev = $this->{bindloop}.\"1\";\n\t\tif (! -e $sdev) {\n\t\t\t$sdev = $this->{bindloop}.\"2\";\n\t\t}\n\t\t#==========================================\n\t\t# check for activated volume group\n\t\t#------------------------------------------\n\t\t$sdev = $this -> checkLVMbind ($sdev,$this->{loop});\n\t\t#==========================================\n\t\t# perform mount call\n\t\t#------------------------------------------\n\t\tif (! $main::global -> mount ($sdev, $tmpdir)) {\n\t\t\t$kiwi -> error  (\"Failed to mount system partition: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> cleanLoop();\n\t}\n\t$this->{bootpart}= 0;\n\t#==========================================\n\t# Build md5sum of system image\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\tif (! $haveDiskDevice) {\n\t\t\t$this -> buildMD5Sum ($system);\n\t\t} else {\n\t\t\t$this -> buildMD5Sum ($this->{loop},$system);\n\t\t}\n\t}\n\t#==========================================\n\t# Compress system image\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t$md5name =~ s/\\.raw$/\\.md5/;\n\t\t$kiwi -> info (\"Compressing installation image...\");\n\t\tif ($haveDiskDevice) {\n\t\t\t$status = qxx (\"cat $haveDiskDevice > $system\");\n\t\t}\n\t\t$status = qxx (\n\t\t\t\"mksquashfs $system $md5name $system.squashfs -no-progress 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to compress system image: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t$system = $system.\".squashfs\";\n\t\t$vmsize = -s $system;\n\t}\n\t#==========================================\n\t# setup required disk size\n\t#------------------------------------------\n\t$irdsize= ($irdsize / 1e6) + 20;\n\t$irdsize= sprintf (\"%.0f\", $irdsize);\n\t$vmsize = ($vmsize / 1e6) * 1.3 + $irdsize;\n\t$vmsize = sprintf (\"%.0f\", $vmsize);\n\t$vmsize = $vmsize.\"M\";\n\t#==========================================\n\t# Setup image basename\n\t#------------------------------------------\n\tmy $nameusb = basename ($system);\n\t#==========================================\n\t# Setup initrd for install purpose\n\t#------------------------------------------\n\t$initrd = $this -> setupInstallFlags();\n\tif (! defined $initrd) {\n\t\treturn undef;\n\t}\n\t$this->{initrd} = $initrd;\n\t#==========================================\n\t# Create Disk boot structure\n\t#------------------------------------------\n\tif (! $this -> createBootStructure(\"vmx\")) {\n\t\t$this->{initrd} = $oldird;\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Import boot loader stages\n\t#------------------------------------------\n\tif (! $this -> setupBootLoaderStages ($bootloader)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Creating boot loader configuration\n\t#------------------------------------------\n\tmy $title = \"KIWI USB-Stick Installation\";\n\tif (! $gotsys) {\n\t\t$title = \"KIWI USB Boot: $nameusb\";\n\t}\n\tif (! $this -> setupBootLoaderConfiguration ($bootloader,$title)) {\n\t\treturn undef;\n\t}\n\t$this->{initrd} = $oldird;\n\t#==========================================\n\t# create/use disk\n\t#------------------------------------------\n\tif (! $haveDiskDevice) {\n\t\t#==========================================\n\t\t# Create virtual disk to be dumped on stick\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Creating virtual disk...\");\n\t\t$status = qxx (\"qemu-img create $diskname $vmsize 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed creating virtual disk: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t$kiwi -> info (\"Binding virtual disk to loop device\");\n\t\tif (! $this -> bindDiskDevice ($diskname)) {\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t} else {\n\t\t#==========================================\n\t\t# Find USB stick devices\n\t\t#------------------------------------------\n\t\tmy $stick = $this -> searchUSBStickDevice ();\n\t\tif (! $stick) {\n\t\t\treturn undef;\n\t\t}\n\t\t$this->{loop} = $stick;\n\t}\n\t#==========================================\n\t# create disk partitions\n\t#------------------------------------------\n\t$kiwi -> info (\"Create partition table for disk\");\n\tmy $partid = \"83\";\n\tif ($bootloader eq \"syslinux\" ) {\n\t\t$partid = \"c\";\n\t}\n\tif ($gotsys) {\n\t\t@commands = (\n\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$irdsize.\"M\",\n\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\"t\",\"1\",$partid,\n\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t);\n\t} else {\n\t\t@commands = (\n\t\t\t\"n\",\"p\",\"1\",\".\",\".\",\n\t\t\t\"t\",\"1\",$partid,\n\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t);\n\t}\n\tif (! $this -> setStoragePartition ($this->{loop},\\@commands)) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create partition table\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\tif (! $haveDiskDevice ) {\n\t\t#==========================================\n\t\t# setup device mapper\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Setup device mapper for partition access\");\n\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Create loop device mapping table\n\t\t#------------------------------------------\n\t\t%deviceMap = $this -> setLoopDeviceMap ($this->{loop});\n\t} else {\n\t\t#==========================================\n\t\t# Create disk device mapping table\n\t\t#------------------------------------------\n\t\t%deviceMap = $this -> setDefaultDeviceMap ($this->{loop});\n\t\t#==========================================\n\t\t# Umount possible mounted stick partitions\n\t\t#------------------------------------------\n\t\t$this -> umountDevice ($this->{loop});\n\t\tfor (my $try=0;$try>=2;$try++) {\n\t\t\t$status = qxx (\"/sbin/blockdev --rereadpt $this->{loop} 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\tsleep (1); next;\n\t\t\t}\n\t\t\tlast;\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't reread partition table: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Wait for new partition table to settle\n\t\t#------------------------------------------\n\t\tsleep (1);\n\t\t#==========================================\n\t\t# Umount possible mounted stick partitions\n\t\t#------------------------------------------\n\t\t$this -> umountDevice ($this->{loop});\n\t}\n\tif ($bootloader eq \"extlinux\") {\n\t\t$deviceMap{extlinux} = $deviceMap{1};\n\t}\n\tif ($bootloader eq \"syslinux\") {\n\t\t$deviceMap{fat} = $deviceMap{1};\n\t}\n\tmy $boot = $deviceMap{1};\n\tmy $data;\n\tif ($gotsys) {\n\t\t$data = $deviceMap{2};\n\t}\n\t#==========================================\n\t# Create filesystem on partitions\n\t#------------------------------------------\n\tforeach my $root ($boot,$data) {\n\t\tnext if ! defined $root;\n\t\tif (($root eq $boot) && ($bootloader eq \"syslinux\")) {\n\t\t\t$kiwi -> info (\"Creating DOS boot filesystem\");\n\t\t\t$status = qxx (\"/sbin/mkdosfs $root 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t} else {\n\t\t\t$kiwi -> info (\"Creating ext3 filesystem on $root partition\");\n\t\t\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t\t\t@{$cmdL -> getFilesystemOptions()}\n\t\t\t);\n\t\t\tmy $fsopts = $FSopts{ext3};\n\t\t\tmy $fstool = \"mkfs.ext3\";\n\t\t\tif (($root eq $data) && ($this->{inodes})) {\n\t\t\t\t$fsopts.= \" -N $this->{inodes}\";\n\t\t\t}\n\t\t\t$status = qxx ( \"$fstool $fsopts $root 2>&1\" );\n\t\t\t$result = $? >> 8;\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed creating filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Copy boot data on first partition\n\t#------------------------------------------\n\t$kiwi -> info (\"Installing boot data to disk\");\n\tif (! $main::global -> mount ($boot, $loopdir)) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't mount boot partition: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$status = qxx (\"cp -a $tmpdir/boot $loopdir 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't install boot data: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$main::global -> umount();\n\t$kiwi -> done();\n\t#==========================================\n\t# Check for optional config-cdroot archive\n\t#------------------------------------------\n\tmy $cdrootData = \"config-cdroot.tgz\";\n\tif (-f \"$destdir/$cdrootData\") {\n\t\t$kiwi -> info (\"Integrating CD root information...\");\n\t\t$status= qxx (\n\t\t\t\"tar -C $loopdir -xvf $destdir/$cdrootData\"\n\t\t);\n\t\t$result= $? >> 8;\n\t\tqxx (\"rm -f $destdir/$cdrootData\");\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to integrate CD root data: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Check for optional config-cdroot.sh\n\t#------------------------------------------\n\tmy $cdrootScript = \"config-cdroot.sh\";\n\tif (-x \"$destdir/$cdrootScript\") {\n\t\t$kiwi -> info (\"Calling CD root setup script...\");\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\tmy $script = \"$destdir/$cdrootScript\";\n\t\tif ($script !~ /^\\//) {\n\t\t\t$script = $pwd.\"/\".$script;\n\t\t}\n\t\t$status = qxx (\n\t\t\t\"cd $loopdir && bash -c $script 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tqxx (\"rm -f $script\");\n\t\tif ($result != 0) {\n\t\t\tchomp $status;\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to call CD root script: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"config-cdroot.sh: $status\");\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Copy system image if defined\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t$kiwi -> info (\"Installing image data to disk\");\n\t\tif (! $main::global -> mount($data, $loopdir)) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't mount data partition: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$status = qxx (\"mv $system $loopdir 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed importing system image: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! open (FD,\">$loopdir/config.usbclient\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create USB install flag file\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"IMAGE=$nameusb\\n\";\n\t\tclose FD;\n\t\t$main::global -> umount();\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Install boot loader on disk\n\t#------------------------------------------\n\tmy $bootdevice = $diskname;\n\tif ($haveDiskDevice) {\n\t\t$bootdevice = $this->{loop};\n\t}\n\tif (! $this -> installBootLoader ($bootloader, $bootdevice, \\%deviceMap)) {\n\t\t$this -> cleanLoopMaps();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$this -> cleanLoopMaps();\n\t$this -> cleanLoop();\n\tif (! $haveDiskDevice) {\n\t\t$kiwi -> info (\"Created $diskname to be dd'ed on Stick\");\n\t} else {\n\t\t$kiwi -> info (\"Successfully created install stick on $this->{loop}\");\n\t}\n\t$kiwi -> done ();\n\treturn $this;\n}\n\n#==========================================\n# setupBootDisk\n#------------------------------------------\nsub setupBootDisk {\n\tmy $this      = shift;\n\tmy $device    = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $arch      = $this->{arch};\n\tmy $system    = $this->{system};\n\tmy $syszip    = $this->{syszip};\n\tmy $tmpdir    = $this->{tmpdir};\n\tmy $initrd    = $this->{initrd};\n\tmy $loopdir   = $this->{loopdir};\n\tmy $zipped    = $this->{zipped};\n\tmy $isxen     = $this->{isxen};\n\tmy $lvm       = $this->{lvm};\n\tmy $profile   = $this->{profile};\n\tmy $xendomain = $this->{xendomain};\n\tmy $xml       = $this->{xml};\n\tmy $cmdL      = $this->{cmdL};\n\tmy $haveTree  = $this->{haveTree};\n\tmy $imgtype   = $this->{imgtype};\n\tmy $haveSplit = $this->{haveSplit};\n\tmy $bootsize  = $this->{bootsize};\n\tmy $diskname  = $system.\".raw\";\n\tmy %deviceMap = ();\n\tmy @commands  = ();\n\tmy $bootfix   = \"VMX\";\n\tmy $dmapper   = 0;\n\tmy $haveluks  = 0;\n\tmy $needBootP = 0;\n\tmy $bootloader;\n\tmy $boot;\n\tif ($arch =~ /ppc|ppc64/) {\n\t\t$bootloader = \"lilo\";\n\t} else {\n\t\t$bootloader = \"grub\";\n\t}\n\tmy $haveDiskDevice;\n\tmy $splitfile;\n\tmy $version;\n\tmy $label;\n\tmy $FSTypeRW;\n\tmy $FSTypeRO;\n\tmy $sysname;\n\tmy $sysird;\n\tmy $result;\n\tmy $status;\n\tmy $destdir;\n\tmy %lvmparts;\n\t#==========================================\n\t# check if we got a real device\n\t#------------------------------------------\n\tif ($device) {\n\t\t$haveDiskDevice = $device;\n\t}\n\t#==========================================\n\t# load type attributes...\n\t#------------------------------------------\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\t#==========================================\n\t# Check for LVM...\n\t#------------------------------------------\n\tif (($type{lvm} =~ /true|yes/i) || ($lvm)) {\n\t\t#==========================================\n\t\t# add boot space if lvm based\n\t\t#------------------------------------------\n\t\t$lvm = 1;\n\t\t$this->{lvm}= $lvm;\n\t\t#==========================================\n\t\t# set volume group name\n\t\t#------------------------------------------\n\t\tmy $vgroupName = $xml -> getLVMGroupName();\n\t\tif ($vgroupName) {\n\t\t\t$this->{lvmgroup} = $vgroupName;\n\t\t}\n\t\t#==========================================\n\t\t# check and set LVM volumes setup\n\t\t#------------------------------------------\n\t\t%lvmparts = $xml -> getLVMVolumes();\n\t\tif (%lvmparts) {\n\t\t\tif ( ! -d $system ) {\n\t\t\t\t$kiwi -> error (\n\t\t\t\t\t\"LVM volumes setup requires root tree but got image file\"\n\t\t\t\t);\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tforeach my $vol (keys %lvmparts) {\n\t\t\t\t#==========================================\n\t\t\t\t# check directory per volume\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $pname  = $vol; $pname =~ s/_/\\//g;\n\t\t\t\tif (! -d \"$system/$pname\") {\n\t\t\t\t\t$kiwi -> error (\"LVM: No such directory $system/$pname\");\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# store volume sizes in lvmparts\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $space = 0;\n\t\t\t\tmy $diff  = 0;\n\t\t\t\tmy $haveAbsolute;\n\t\t\t\tif ($lvmparts{$vol}) {\n\t\t\t\t\t$space = $lvmparts{$vol}->[0];\n\t\t\t\t\t$haveAbsolute = $lvmparts{$vol}->[1];\n\t\t\t\t}\n\t\t\t\tmy $lvsize = qxx (\n\t\t\t\t\t\"du -s --block-size=1 $system/$pname | cut -f1\"\n\t\t\t\t);\n\t\t\t\tchomp $lvsize;\n\t\t\t\t$lvsize /= 1048576;\n\t\t\t\tif ($haveAbsolute) {\n\t\t\t\t\tif ($space > ($lvsize + 30)) {\n\t\t\t\t\t\t$diff = $space - $lvsize;\n\t\t\t\t\t\t$lvsize = $space;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$lvsize += 30;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$lvsize = int ( 30 + $lvsize + $space);\n\t\t\t\t}\n\t\t\t\t$lvmparts{$vol}->[2] = $lvsize;\n\t\t\t\t#==========================================\n\t\t\t\t# increase total vm disk size\n\t\t\t\t#------------------------------------------\n\t\t\t\t$kiwi->loginfo (\"Increasing disk size for volume $pname\\n\");\n\t\t\t\tif ($haveAbsolute) {\n\t\t\t\t\t$this -> __updateDiskSize ($diff + 30);\n\t\t\t\t} else {\n\t\t\t\t\t$this -> __updateDiskSize ($space+ 30);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# check for overlay filesystems\n\t#------------------------------------------\n\tif ($type{filesystem} eq \"clicfs\") {\n\t\t$this->{dmapper} = 1;\n\t\t$dmapper  = 1;\n\t}\n\t#==========================================\n\t# check if fs requires a boot partition\n\t#------------------------------------------\n\tif (($type{filesystem} eq \"btrfs\") || ($type{filesystem} eq \"xfs\")) {\n\t\t$needBootP  = 1;\n\t}\n\t#==========================================\n\t# check for LUKS extension\n\t#------------------------------------------\n\tif ($type{luks}) {\n\t\t$haveluks   = 1;\n\t}\n\t#==========================================\n\t# setup boot loader type\n\t#------------------------------------------\n\tif ($type{bootloader}) {\n\t\t$bootloader = $type{bootloader};\n\t}\n\t$this->{bootloader} = $bootloader;\n\t#==========================================\n\t# add boot space if syslinux based\n\t#------------------------------------------\n\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\tmy $fatstorage = $cmdL->getFatStorage();\n\t\tif (defined $fatstorage) {\n\t\t\tif ($bootsize < $fatstorage) {\n\t\t\t\t$bootsize = $fatstorage;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# build disk name and label from xml data\n\t#------------------------------------------\n\t$destdir  = dirname ($initrd);\n\t$label    = $xml -> getImageDisplayName();\n\t$version  = $xml -> getImageVersion();\n\t$diskname = $xml -> getImageName();\n\t$diskname = $destdir.\"/\".$diskname.\".\".$arch.\"-\".$version.\".raw\";\n\t$splitfile= $destdir.\"/\".$label.\"-read-write.\".$arch.\"-\".$version;\n\t$this->{bootlabel}= $label;\n\t#==========================================\n\t# build bootfix for the bootloader on oem\n\t#------------------------------------------\n\tif ($initrd =~ /oemboot/) {\n\t\tmy $oemtitle = $xml -> getOEMBootTitle();\n\t\tif ($oemtitle) {\n\t\t\t$this->{bootlabel} = $oemtitle;\n\t\t\t$bootfix = \"OEM\";\n\t\t}\n\t}\n\t#==========================================\n\t# increase disk size for in-place recovery\n\t#------------------------------------------\n\tmy $inplace = $xml -> getOEMRecoveryInPlace();\n\tif (($inplace) && (\"$inplace\" eq \"true\")) {\n\t\tmy ($FD,$recoMB);\n\t\tmy $sizefile = \"$destdir/recovery.partition.size\";\n\t\tif (open ($FD,$sizefile)) {\n\t\t\t$recoMB = <$FD>; chomp $recoMB;\tclose $FD; unlink $sizefile;\n\t\t\t$kiwi -> info (\n\t\t\t\t\"Adding $recoMB MB spare space for in-place recovery\"\n\t\t\t);\n\t\t\t$this -> __updateDiskSize ($recoMB);\n\t\t\t$kiwi -> done ();\n\t\t}\n\t}\n\t#==========================================\n\t# increase vmsize if image split RW portion\n\t#------------------------------------------\n\tif (($imgtype eq \"split\") && (-f $splitfile)) {\n\t\tmy $splitsize = $main::global -> isize ($splitfile);\n\t\tmy $splitMB = $splitsize / 1048576;\n\t\t$kiwi -> info (\n\t\t\t\"Adding $splitMB MB space for split read-write portion\"\n\t\t);\n\t\t$this -> __updateDiskSize ($splitMB);\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# obtain filesystem type from xml data\n\t#------------------------------------------\n\tif ($type{filesystem} =~ /(.*),(.*)/) {\n\t\t$FSTypeRW = $1;\n\t\t$FSTypeRO = $2;\n\t} else {\n\t\t$FSTypeRW = $type{filesystem};\n\t\t$FSTypeRO = $FSTypeRW;\n\t}\n\tif ($haveSplit) {\n\t\tmy %fsattr = $main::global -> checkFileSystem ($FSTypeRW);\n\t\tif ($fsattr{readonly}) {\n\t\t\t$kiwi -> error (\"Can't copy data into requested RO filesystem\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Create Disk boot structure\n\t#------------------------------------------\n\tif (! $this -> createBootStructure(\"vmx\")) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Setup boot partition ID\n\t#------------------------------------------\n\tmy $bootpart = \"0\";\n\tif (($syszip) || ($haveSplit) || ($haveluks) || ($needBootP)) {\n\t\t$bootpart = \"1\";\n\t}\n\tif ((($syszip) || ($haveSplit)) && ($haveluks)) {\n\t\t$bootpart = \"2\";\n\t}\n\tif ($dmapper) {\n\t\t$bootpart = \"2\"\n\t}\n\tif ($lvm) {\n\t\t$bootpart = \"0\";\n\t}\n\t$this->{bootpart} = $bootpart;\n\t#==========================================\n\t# Update raw disk size if boot part is used\n\t#------------------------------------------\n\tif (($syszip)    ||\n\t\t($haveSplit) ||\n\t\t($haveluks)  ||\n\t\t($needBootP) ||\n\t\t($dmapper)   ||\n\t\t($lvm)\n\t) {\n\t\t$this -> __updateDiskSize ($bootsize);\n\t}\n\t#==========================================\n\t# Import boot loader stages\n\t#------------------------------------------\n\tif (! $this -> setupBootLoaderStages ($bootloader)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# add extra Xen boot options if necessary\n\t#------------------------------------------\n\tmy $extra = \"\";\n\t#==========================================\n\t# Create boot loader configuration\n\t#------------------------------------------\n\tif (! $this -> setupBootLoaderConfiguration ($bootloader,$bootfix,$extra)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# create/use disk\n\t#------------------------------------------\n\tmy $dmap; # device map\n\tmy $root; # root device\n\tif (! defined $system) {\n\t\t$kiwi -> error  (\"No system image given\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! $haveDiskDevice) {\n\t\t$kiwi -> info (\"Creating virtual disk...\");\n\t} else {\n\t\t$kiwi -> info (\"Using disk device $haveDiskDevice...\");\n\t}\n\twhile (1) {\n\t\tif (! $haveDiskDevice) {\n\t\t\t$status = qxx (\"qemu-img create $diskname $this->{vmsize} 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Failed creating virtual disk: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# setup loop device for virtual disk\n\t\t\t#------------------------------------------\n\t\t\tif (! $this -> bindDiskDevice($diskname)) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t} else {\n\t\t\t# /.../\n\t\t\t# the following is required for suse studio to determine the\n\t\t\t# size of the image target disk. It has no relevance for the\n\t\t\t# standard build process and is therefore called without any\n\t\t\t# return value check. \n\t\t\tqxx (\"qemu-img create $diskname $this->{vmsize} 2>&1\");\n\t\t\t# ----\n\t\t\t$this->{loop} = $haveDiskDevice;\n\t\t\tif (! -b $this->{loop}) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"No such block device: $this->{loop}\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# create disk partition\n\t\t#------------------------------------------\n\t\tif ($arch =~ /ppc|ppc64/) {\n\t\t\tmy $prepsize = $bootsize;\n\t\t\tif (! $lvm) {\n\t\t\t\t@commands = (\n\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$prepsize.\"M\",\n\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\"t\",\"1\",\"41\",\n\t\t\t\t\t\"t\",\"2\",\"83\",\n\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t@commands = (\n\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$bootsize.\"M\",\n\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\"t\",\"1\",\"c\",\n\t\t\t\t\t\"t\",\"2\",\"8e\",\n\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\tif (! $lvm) {\n\t\t\tif (($syszip) || ($haveSplit) || ($dmapper)) {\n\t\t\t\t# xda1 ro / xda2 rw\n\t\t\t\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\t\t\t\tmy $partid = \"c\";\n\t\t\t\t\tif ($bootloader eq \"extlinux\" ) {\n\t\t\t\t\t\t$partid = \"83\";\n\t\t\t\t\t}\n\t\t\t\t\tmy $syslsize = $this->{vmmbyte} - $bootsize - $syszip;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syszip.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\"+\".$syslsize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"3\",\".\",\".\",\n\t\t\t\t\t\t\"t\",\"3\",$partid,\n\t\t\t\t\t\t\"a\",\"3\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} elsif ($dmapper) {\n\t\t\t\t\tmy $dmsize = $this->{vmmbyte} - $bootsize - $syszip;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syszip.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\"+\".$dmsize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"3\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"3\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} elsif ($haveluks) {\n\t\t\t\t\tmy $lukssize = $this->{vmmbyte} - $bootsize - $syszip;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syszip.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\"+\".$lukssize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"3\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"3\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syszip.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"2\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t# xda1 rw\n\t\t\t\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\t\t\t\tmy $partid = \"c\";\n\t\t\t\t\tif ($bootloader eq \"extlinux\" ) {\n\t\t\t\t\t\t$partid = \"83\";\n\t\t\t\t\t}\n\t\t\t\t\tmy $syslsize = $this->{vmmbyte} - $bootsize;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syslsize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\t\"t\",\"2\",$partid,\n\t\t\t\t\t\t\"a\",\"2\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} elsif (($haveluks) || ($needBootP)) {\n\t\t\t\t\tmy $lukssize = $this->{vmmbyte} - $bootsize;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$lukssize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"2\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\t\t\tmy $partid = \"c\";\n\t\t\t\tif ($bootloader eq \"extlinux\" ) {\n\t\t\t\t\t$partid = \"83\";\n\t\t\t\t}\n\t\t\t\tmy $lvmsize = $this->{vmmbyte} - $bootsize;\n\t\t\t\tmy $bootpartsize = \"+\".$bootsize.\"M\";\n\t\t\t\t@commands = (\n\t\t\t\t\t\"n\",\"p\",\"1\",\".\",$bootpartsize,\n\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\"t\",\"1\",$partid,\n\t\t\t\t\t\"t\",\"2\",\"8e\",\n\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmy $lvmsize = $this->{vmmbyte} - $bootsize;\n\t\t\t\tmy $bootpartsize = \"+\".$bootsize.\"M\";\n\t\t\t\t@commands = (\n\t\t\t\t\t\"n\",\"p\",\"1\",\".\",$bootpartsize,\n\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\"t\",\"2\",\"8e\",\n\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif (! $this -> setStoragePartition ($this->{loop},\\@commands)) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create partition table\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! $haveDiskDevice ) {\n\t\t\t#==========================================\n\t\t\t# setup device mapper\n\t\t\t#------------------------------------------\n\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# Create loop device mapping table\n\t\t\t#------------------------------------------\n\t\t\t%deviceMap = $this -> setLoopDeviceMap ($this->{loop});\n\t\t} else {\n\t\t\t#==========================================\n\t\t\t# Create disk device mapping table\n\t\t\t#------------------------------------------\n\t\t\tif ($arch =~ /ppc|ppc64/) {\n\t\t\t\t%deviceMap = $this -> setPPCDeviceMap ($this->{loop});\n\t\t\t} else {\n\t\t\t\t%deviceMap = $this -> setDefaultDeviceMap ($this->{loop});\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# Umount possible mounted stick partitions\n\t\t\t#------------------------------------------\n\t\t\t$this -> umountDevice ($this->{loop});\n\t\t\tfor (my $try=0;$try>=2;$try++) {\n\t\t\t\t$status = qxx (\"/sbin/blockdev --rereadpt $this->{loop} 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t\tif ($result != 0) {\n\t\t\t\t\tsleep (1); next;\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't reread partition table: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# Wait for new partition table to settle\n\t\t\t#------------------------------------------\n\t\t\tsleep (1);\n\t\t\t#==========================================\n\t\t\t# Umount possible mounted stick partitions\n\t\t\t#------------------------------------------\n\t\t\t$this -> umountDevice ($this->{loop});\n\t\t}\n\t\t#==========================================\n\t\t# setup volume group if requested\n\t\t#------------------------------------------\n\t\tif ($lvm) {\n\t\t\t%deviceMap = $this -> setVolumeGroup (\n\t\t\t\t\\%deviceMap,$this->{loop},$syszip,$haveSplit,\\%lvmparts\n\t\t\t);\n\t\t\tif (! %deviceMap) {\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# set root device name from deviceMap\n\t\t#------------------------------------------\n\t\tif (($arch =~ /ppc|ppc64/) && (!$lvm)) {\n\t\t\t$root = $deviceMap{2};\n\t\t} else {\n\t\t\t$root = $deviceMap{1};\n\t\t}\n\t\t#==========================================\n\t\t# check partition sizes\n\t\t#------------------------------------------\n\t\tif ($syszip > 0) {\n\t\t\tmy $sizeOK = 1;\n\t\t\tmy $systemPSize = $this->getStorageSize ($deviceMap{1});\n\t\t\tmy $systemISize = $main::global -> isize ($system);\n\t\t\t$systemISize /= 1024;\n\t\t\tchomp $systemPSize;\n\t\t\t#print \"_______A $systemPSize : $systemISize\\n\";\n\t\t\tif ($systemPSize < $systemISize) {\n\t\t\t\t$syszip += 10;\n\t\t\t\t$sizeOK = 0;\n\t\t\t}\n\t\t\tif (! $sizeOK) {\n\t\t\t\t#==========================================\n\t\t\t\t# bad partition alignment try again\n\t\t\t\t#------------------------------------------\n\t\t\t\tsleep (1);\n\t\t\t\t$this -> deleteVolumeGroup();\n\t\t\t\t$this -> cleanLoopMaps();\n\t\t\t\tqxx (\"/sbin/losetup -d $this->{loop}\");\n\t\t\t} else {\n\t\t\t\t#==========================================\n\t\t\t\t# looks good go for it\n\t\t\t\t#------------------------------------------\n\t\t\t\tlast;\n\t\t\t}\n\t\t} else {\n\t\t\t#==========================================\n\t\t\t# entire disk used\n\t\t\t#------------------------------------------\n\t\t\tlast;\n\t\t}\n\t\t$kiwi -> note (\".\");\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# Dump system image on disk\n\t#------------------------------------------\n\tif (! $haveTree) {\n\t\t$kiwi -> info (\"Dumping system image on disk\");\n\t\t$status = qxx (\"dd if=$system of=$root bs=32k 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't dump image to disk: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t$result = 0;\n\t\tmy $mapper = $root;\n\t\tmy %fsattr = $main::global -> checkFileSystem ($root);\n\t\tif ($fsattr{type} eq \"luks\") {\n\t\t\t$mapper = $this -> luksResize ($root,\"luks-resize\");\n\t\t\tif (! $mapper) {\n\t\t\t\t$this -> luksClose();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t%fsattr= $main::global -> checkFileSystem ($mapper);\n\t\t}\n\t\tmy $expanded = $this -> __expandFS (\n\t\t\t$fsattr{type},'system', $mapper\n\t\t);\n\t\tif (! $expanded ) {\n\t\t\treturn undef;\n\t\t}\n\t\tif ($haveSplit) {\n\t\t\t$kiwi -> info (\"Dumping split read/write part on disk\");\n\t\t\t$root = $deviceMap{2};\n\t\t\t$status = qxx (\"dd if=$splitfile of=$root bs=32k 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't dump split file: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t\t$result = 0;\n\t\t\t$mapper = $root;\n\t\t\tmy %fsattr = $main::global -> checkFileSystem ($root);\n\t\t\tif ($fsattr{type} eq \"luks\") {\n\t\t\t\t$mapper = $this -> luksResize ($root,\"luks-resize\");\n\t\t\t\tif (! $mapper) {\n\t\t\t\t\t$this -> luksClose();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t%fsattr= $main::global -> checkFileSystem ($mapper);\n\t\t\t}\n\t\t\tmy $expanded = $this -> __expandFS (\n\t\t\t\t$fsattr{type},'split', $mapper\n\t\t\t);\n\t\t\tif (! $expanded ) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t#==========================================\n\t\t# Create fs on system image partition\n\t\t#------------------------------------------\n\t\tif (! $this -> setupFilesystem ($FSTypeRO,$root,\"root\")) {\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Mount system image partition\n\t\t#------------------------------------------\n\t\tif (! $main::global -> mount ($root, $loopdir)) {\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create LVM volumes filesystems\n\t\t#------------------------------------------\n\t\tif (($lvm) && (%lvmparts)) {\n\t\t\tmy $VGroup = $this->{lvmgroup};\n\t\t\tmy @paths  = ();\n\t\t\tmy %phash  = ();\n\t\t\t#==========================================\n\t\t\t# Create path names in correct order\n\t\t\t#------------------------------------------\n\t\t\tsub numeric {\n\t\t\t\t($a <=> $b) || ($a cmp $b);\n\t\t\t}\n\t\t\tforeach my $name (keys %lvmparts) {\n\t\t\t\tmy $pname  = $name; $pname =~ s/_/\\//g;\n\t\t\t\t$pname =~ s/^\\///;\n\t\t\t\t$pname =~ s/\\s*$//;\n\t\t\t\tpush @paths,$pname;\n\t\t\t}\n\t\t\tforeach my $name (@paths) {\n\t\t\t\tmy $part = split (/\\//,$name);\n\t\t\t\tpush @{$phash{$part}},$name;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# Create filesystems and Mount LVM volumes\n\t\t\t#------------------------------------------\n\t\t\tforeach my $level (sort numeric keys %phash) {\n\t\t\t\tforeach my $pname (@{$phash{$level}}) {\n\t\t\t\t\tmy $lname = $pname; $lname =~ s/\\//_/g;\n\t\t\t\t\tmy $device = \"/dev/$VGroup/LV$lname\";\n\t\t\t\t\t$status = qxx (\"mkdir -p $loopdir/$pname 2>&1\");\n\t\t\t\t\t$result = $? >> 8;\n\t\t\t\t\tif ($result != 0) {\n\t\t\t\t\t\t$kiwi -> error (\"Can't create mount point $loopdir/$pname\");\n\t\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\t\treturn undef;\n\t\t\t\t\t}\n\t\t\t\t\tif (! $this -> setupFilesystem ($FSTypeRO,$device,$pname)) {\n\t\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\t\treturn undef;\n\t\t\t\t\t}\n\t\t\t\t\t$kiwi -> loginfo (\"Mounting logical volume: $pname\\n\");\n\t\t\t\t\tif (! $main::global -> mount ($device, \"$loopdir/$pname\")) {\n\t\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\t\treturn undef;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# Copy root tree to disk\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Copying system image tree on disk\");\n\t\t$status = qxx (\n\t\t\t\"tar --one-file-system -cf - -C $system . | tar -x -C $loopdir 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Can't copy image tree to disk: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tif ($haveDiskDevice) {\n\t\t\t#==========================================\n\t\t\t# fill disk device with zero bytes\n\t\t\t#------------------------------------------\n\t\t\tqxx (\"dd if=/dev/zero of=$loopdir/abc 2>&1\");\n\t\t\tqxx (\"rm -f $loopdir/abc\");\n\t\t}\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Umount system image partition\n\t\t#------------------------------------------\n\t\t$main::global -> umount();\n\t}\n\t#==========================================\n\t# create read/write filesystem if needed\n\t#------------------------------------------\n\tif (($syszip) && (! $haveSplit) && (! $dmapper)) {\n\t\t$root = $deviceMap{2};\n\t\tif ($haveluks) {\n\t\t\tmy $cipher = $type{luks};\n\t\t\tmy $name   = \"luksReadWrite\";\n\t\t\t$kiwi -> info (\"Creating LUKS->ext3 read-write filesystem\");\n\t\t\t$status = qxx (\"echo $cipher|cryptsetup -q luksFormat $root 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($status != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't setup luks format: $root\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$status = qxx (\"echo $cipher|cryptsetup luksOpen $root $name 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't open luks device: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$root = \"/dev/mapper/$name\";\n\t\t\t$this->{luks} = $name;\n\t\t} else {\n\t\t\t$kiwi -> info (\"Creating ext3 read-write filesystem\");\n\t\t}\n\t\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t\t@{$cmdL -> getFilesystemOptions()}\n\t\t);\n\t\tmy $fsopts = $FSopts{ext3};\n\t\tmy $fstool = \"mkfs.ext3\";\n\t\t$status = qxx (\"$fstool $fsopts $root 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> luksClose();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> luksClose();\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# create bootloader filesystem if needed\n\t#------------------------------------------\n\tif ($bootloader eq \"syslinux\") {\n\t\t$root = $deviceMap{fat};\n\t\t$kiwi -> info (\"Creating DOS boot filesystem\");\n\t\t$status = qxx (\"/sbin/mkdosfs $root 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create DOS filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t} elsif (($arch =~ /ppc|ppc64/) && ($lvm)) {\n\t\t$boot = $deviceMap{fat};\n\t\t$kiwi -> info (\"Creating DOS boot filesystem\");\n\t\t$status = qxx (\"/sbin/mkdosfs -F 16 $boot 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create DOS filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t} elsif (\n\t\t($dmapper) || ($haveluks) || ($needBootP) ||\n\t\t($lvm) || ($bootloader eq \"extlinux\")\n\t) {\n\t\t$root = $deviceMap{dmapper};\n\t\t$kiwi -> info (\"Creating ext3 boot filesystem\");\n\t\tif (($haveluks) || ($needBootP)) {\n\t\t\tif (($syszip) || ($haveSplit) || ($dmapper)) {\n\t\t\t\t$root = $deviceMap{3};\n\t\t\t} else {\n\t\t\t\t$root = $deviceMap{2};\n\t\t\t}\n\t\t}\n\t\tif ($lvm) {\n\t\t\t$root = $deviceMap{0};\n\t\t}\n\t\tif ($bootloader eq \"extlinux\") {\n\t\t\t$root = $deviceMap{extlinux};\n\t\t}\n\t\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t\t@{$cmdL -> getFilesystemOptions()}\n\t\t);\n\t\tmy $fsopts = $FSopts{ext3};\n\t\tmy $fstool = \"mkfs.ext3\";\n\t\t$status = qxx (\"$fstool $fsopts $root 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Dump boot image on disk\n\t#------------------------------------------\n\t$kiwi -> info (\"Copying boot image to disk\");\n\t#==========================================\n\t# Mount system image / or rw partition\n\t#------------------------------------------\n\tif ($bootloader eq \"syslinux\") {\n\t\t$root = $deviceMap{fat};\n\t} elsif ($bootloader eq \"extlinux\") {\n\t\t$root = $deviceMap{extlinux};\n\t} elsif ($dmapper) {\n\t\t$root = $deviceMap{dmapper};\n\t} elsif ($arch =~ /ppc|ppc64/){\n\t\tif ($lvm) {\n\t\t\t$boot = $deviceMap{fat};\n\t\t\t$root = $deviceMap{1};\n\t\t} else {\n\t\t\t$root = $deviceMap{2};\n\t\t}\n\t} elsif (($syszip) || ($haveSplit) || ($lvm)) {\n\t\t$root = $deviceMap{2};\n\t\tif ($haveluks) {\n\t\t\t$root = $deviceMap{3};\n\t\t}\n\t\tif ($lvm) {\n\t\t\t$root = $deviceMap{0};\n\t\t}\n\t} elsif (($haveluks) || ($needBootP)) {\n\t\t$root = $deviceMap{2};\n\t} else {\n\t\t$root = $deviceMap{1};\n\t}\n\tif (! $main::global -> mount ($root, $loopdir)) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't mount image: $root\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\tif (($arch =~/ppc|ppc64/) && ($lvm)) {\n\t\t$status = qxx (\"mkdir -p $loopdir/vfat\");\n\t\t$boot = $deviceMap{fat};\n\t\tif (! $main::global -> mount ($boot, $loopdir.\"/vfat\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't mount image: $boot\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Copy boot data on system image\n\t#------------------------------------------\n\t$status = qxx (\"cp -dR $tmpdir/boot $loopdir 2>&1\");\n\t$result = $? >> 8;\n\tif ($arch =~ /ppc|ppc64/) {\n\t\t#==========================================\n\t\t# Copy yaboot.conf\n\t\t#------------------------------------------\n\t\tif (! $lvm) {\n\t\t\t$status = qxx (\"cp $tmpdir/etc/yaboot.conf $loopdir/etc/ 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t} else {\n\t\t\t$status = qxx (\n\t\t\t\t\"cp $tmpdir/etc/yaboot.conf $loopdir/vfat/yaboot.cnf 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\t$status = qxx (\"cp $loopdir/boot/linux.vmx  $loopdir/vfat\");\n\t\t\t$status = qxx (\"cp $loopdir/boot/initrd.vmx $loopdir/vfat\");\n\t\t\t$result = $? >> 8;\n\t\t\t$status = qxx (\n\t\t\t\t\"cp $loopdir/lib/lilo/chrp/yaboot.chrp $loopdir/vfat/yaboot\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\t$status = qxx (\"cp -a $tmpdir/ppc $loopdir/vfat/\");\n\t\t\t$result = $? >> 8;\n\t\t\t$main::global -> umount($boot);\n\t\t\t$status = qxx (\"rm -rf $loopdir/vfat\");\n\t\t\t$result = $? >> 8;\n\t\t}\n\t}\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error (\"Couldn't copy boot data to system image: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$main::global -> umount();\n\t$kiwi -> done();\n\t#==========================================\n\t# Install boot loader on disk\n\t#------------------------------------------\n\tmy $bootdevice = $diskname;\n\tif ($haveDiskDevice) {\n\t\t$bootdevice = $this->{loop};\n\t}\n\tif (! $this->installBootLoader ($bootloader,$bootdevice,\\%deviceMap)) {\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# cleanup device maps and part mount\n\t#------------------------------------------\n\tif ($lvm) {\n\t\tqxx (\"vgchange -an $this->{lvmgroup} 2>&1\");\n\t}\n\t$this -> cleanLoopMaps();\n\t#==========================================\n\t# cleanup temp directory\n\t#------------------------------------------\n\tqxx (\"rm -rf $tmpdir\");\n\tif ($haveDiskDevice)  {\n\t\t#==========================================\n\t\t# create image file from disk device\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Dumping image file from $this->{loop}...\");\n\t\t$status = qxx (\"dd if=$this->{loop} of=$diskname bs=32k 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Image dump failed: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Create image described by given format\n\t#------------------------------------------\n\tif ($initrd =~ /oemboot/) {\n\t\t#==========================================\n\t\t# OEM Install CD...\n\t\t#------------------------------------------\n\t\tif ($type{installiso} =~ /true|yes/i) {\n\t\t\t$this -> {system} = $diskname;\n\t\t\tif ($haveDiskDevice) {\n\t\t\t\t$this -> {system} = $this->{loop};\n\t\t\t}\n\t\t\t$kiwi -> info (\"--> Creating install ISO image\\n\");\n\t\t\t$this -> cleanLoop ();\n\t\t\tif (! $this -> setupInstallCD()) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# OEM Install Stick...\n\t\t#------------------------------------------\n\t\tif ($type{installstick} =~ /true|yes/i) {\n\t\t\t$this -> {system} = $diskname;\n\t\t\tif ($haveDiskDevice) {\n\t\t\t\t$this -> {system} = $this->{loop};\n\t\t\t}\n\t\t\t$kiwi -> info (\"--> Creating install USB Stick image\\n\");\n\t\t\t$this -> cleanLoop ();\n\t\t\tif (! $this -> setupInstallStick()) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# cleanup loop setup and device mapper\n\t#------------------------------------------\n\t$this -> cleanLoop ();\n\treturn $this;\n}\n\n#==========================================\n# setupInstallFlags\n#------------------------------------------\nsub setupInstallFlags {\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $initrd = $this->{initrd};\n\tmy $system = $this->{system};\n\tmy $irddir = $initrd.\"_\".$$.\".vmxsystem\";\n\tmy $xml    = $this->{xml};\n\tmy $zipper = $this->{gdata}->{Gzip};\n\tmy $newird;\n\tif (! mkdir $irddir) {\n\t\t$kiwi -> error  (\"Failed to create vmxsystem directory\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# unpack initrd files\n\t#------------------------------------------\n\tmy $unzip  = \"$this->{gdata}->{Gzip} -cd $initrd 2>&1\";\n\tmy $status = qxx (\"$unzip | (cd $irddir && cpio -di 2>&1)\");\n\tmy $result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Failed to extract initrd data: $!\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $irddir\");\n\t\treturn undef;\n\t}\n\t#===========================================\n\t# add image.md5 / config.vmxsystem to initrd\n\t#-------------------------------------------\n\tif (defined $system) {\n\t\tmy $imd5 = $system;\n\t\t$imd5 =~ s/\\.raw$/\\.md5/;\n\t\tmy $status = qxx (\"cp $imd5 $irddir/etc/image.md5 2>&1\");\n\t\tmy $result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> error  (\"Failed importing md5 file: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $irddir\");\n\t\t\treturn undef;\n\t\t}\n\t\tif (! open (FD,\">$irddir/config.vmxsystem\")) {\n\t\t\t$kiwi -> error  (\"Couldn't create image boot configuration\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $namecd = basename ($system);\n\t\tif (! -f $imd5) {\n\t\t\t$kiwi -> error  (\"Couldn't find md5 file\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $irddir\");\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"IMAGE=$namecd\\n\";\n\t\tclose FD;\n\t}\n\t#==========================================\n\t# create new initrd with vmxsystem file\n\t#------------------------------------------\n\t$newird = $initrd;\n\t$newird =~ s/\\.gz/\\.install\\.gz/;\n\t$status = qxx (\n\t\t\"(cd $irddir && find|cpio --quiet -oH newc | $zipper) > $newird\"\n\t);\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Failed to re-create initrd: $status\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $irddir\");\n\t\treturn undef;\n\t}\n\tqxx (\"rm -rf $irddir\");\n\t#==========================================\n\t# recreate splash data to initrd\n\t#------------------------------------------\n\tmy $splash = $initrd;\n\tif (! ($splash =~ s/splash\\.gz/spl/)) {\n\t\t$splash =~ s/gz/spl/;\n\t}\n\tif (-f $splash) {\n\t\tqxx (\"cat $splash >> $newird\");\n\t}\n\treturn $newird;\n}\n\n#==========================================\n# setupSplash\n#------------------------------------------\nsub setupSplash {\n\t# ...\n\t# we can either use bootsplash or splashy to display\n\t# a splash screen. If /usr/sbin/splashy exists we will\n\t# prefer splashy over bootsplash\n\t# ---\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $initrd = $this->{initrd};\n\tmy $zipped = 0;\n\tmy $status;\n\tmy $newird;\n\tmy $splfile;\n\tmy $result;\n\t#==========================================\n\t# setup file names\n\t#------------------------------------------\n\tif ($initrd =~ /\\.gz$/) {\n\t\t$zipped = 1;\n\t}\n\tif ($zipped) {\n\t\t$newird = $initrd; $newird =~ s/\\.gz/\\.splash.gz/;\n\t\t$splfile= $initrd; $splfile =~ s/\\.gz/\\.spl/;\n\t} else {\n\t\t$newird = $initrd.\".splash.gz\";\n\t\t$splfile= $initrd.\".spl\";\n\t}\n\t#==========================================\n\t# check if splash initrd is already there\n\t#------------------------------------------\n\tif ((! -l $newird) && (-f $newird)) {\n\t\t# splash initrd already created...\n\t\treturn $newird;\n\t}\n\t$kiwi -> info (\"Setting up splash screen...\");\n\t#==========================================\n\t# setup splash in initrd\n\t#------------------------------------------\n\tif (-f $splfile) {\n\t\tqxx (\"cat $initrd $splfile > $newird\");\n\t\t$status = \"ok\";\n\t} else {\n\t\t$status = \"Can't find splash file: $splfile\";\n\t}\n\t#==========================================\n\t# check status and return\n\t#------------------------------------------\n\tif ($status ne \"ok\") {\n\t\t$kiwi -> skipped ();\n\t\t$kiwi -> warning ($status);\n\t\t$kiwi -> skipped ();\n\t\t$kiwi -> info (\"Creating compat splash link...\");\n\t\t$status = $this -> setupSplashLink ($newird);\n\t\tif ($status ne \"ok\") {\n\t\t\t$kiwi -> failed();\n\t\t\t$kiwi -> error ($status);\n\t\t\t$kiwi -> failed();\n\t\t} else {\n\t\t\t$kiwi -> done();\n\t\t}\n\t\treturn $initrd;\n\t}\n\t$kiwi -> done();\n\treturn $newird;\n}\n\n#==========================================\n# setupSplashLink\n#------------------------------------------\nsub setupSplashLink {\n\t# ...\n\t# This function only makes sure the .splash.gz\n\t# file exists. This is done by creating a link to the\n\t# original initrd file\n\t# ---\n\tmy $this   = shift;\n\tmy $newird = shift;\n\tmy $initrd = $this->{initrd};\n\tmy $status;\n\tmy $result;\n\tif ($initrd !~ /.gz$/) {\n\t\t$status = qxx (\"$this->{gdata}->{Gzip} -f $initrd 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\treturn (\"Failed to compress initrd: $status\");\n\t\t}\n\t\t$initrd = $initrd.\".gz\";\n\t}\n\tmy $dirname = dirname  $initrd;\n\tmy $curfile = basename $initrd;\n\tmy $newfile = basename $newird;\n\t$status = qxx (\n\t\t\"cd $dirname && rm -f $newfile && ln -s $curfile $newfile\"\n\t);\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\treturn (\"Failed to create splash link $!\");\n\t}\n\treturn \"ok\";\n}\n\n#==========================================\n# cleanLoop\n#------------------------------------------\nsub cleanLoop {\n\tmy $this = shift;\n\tmy $tmpdir = $this->{tmpdir};\n\tmy $loop   = $this->{loop};\n\tmy $lvm    = $this->{lvm};\n\tmy $loopdir= $this->{loopdir};\n\t$main::global -> umount();\n\tif ((defined $loop) && ($loop =~ /loop/)) {\n\t\tif (defined $lvm) {\n\t\t\tqxx (\"vgchange -an 2>&1\");\n\t\t}\n\t\t$this -> cleanLoopMaps();\n\t\tqxx (\"/sbin/losetup -d $loop 2>&1\");\n\t\tundef $this->{loop};\n\t}\n\treturn $this;\n}\n\n#==========================================\n# cleanLoopMaps\n#------------------------------------------\nsub cleanLoopMaps {\n\tmy $this = shift;\n\tmy $dev  = shift;\n\tmy $loop = $this->{loop};\n\tif ($dev) {\n\t\t$loop = $dev;\n\t}\n\tif ($loop =~ /dev\\/(.*)/) {\n\t\t$loop = $1;\n\t}\n\tforeach my $d (glob (\"/dev/mapper/$loop*\")) {\n\t\tqxx (\"dmsetup remove $d 2>&1\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# buildMD5Sum\n#------------------------------------------\nsub buildMD5Sum {\n\tmy $this = shift;\n\tmy $file = shift;\n\tmy $outf = shift;\n\tmy $kiwi = $this->{kiwi};\n\t$kiwi -> info (\"Creating image MD5 sum...\");\n\tmy $size = $main::global -> isize ($file);\n\tmy $primes = qxx (\"factor $size\"); $primes =~ s/^.*: //;\n\tmy $blocksize = 1;\n\tfor my $factor (split /\\s/,$primes) {\n\t\tlast if ($blocksize * $factor > 8192);\n\t\t$blocksize *= $factor;\n\t}\n\tmy $blocks = $size / $blocksize;\n\tmy $sum  = qxx (\"cat $file | md5sum - | cut -f 1 -d-\");\n\tchomp $sum;\n\tif ($outf) {\n\t\t$file = $outf;\n\t}\n\tif ($file =~ /\\.raw$/) {\n\t\t$file =~ s/raw$/md5/;\n\t}\n\tqxx (\"echo \\\"$sum $blocks $blocksize\\\" > $file\");\n\t$kiwi -> done();\n\treturn $this;\n}\n\n#==========================================\n# writeMBRDiskLabel\n#------------------------------------------\nsub writeMBRDiskLabel {\n\t# ...\n\t# writes a 4byte random ID into the MBR of the\n\t# previosly installed boot manager. The function\n\t# returns the written ID or undef on error\n\t# ---\n\tmy $this  = shift;\n\tmy $file  = shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $nid   = $this->{mbrid};\n\tif (! defined $nid) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"MBR: don't have a mbr id\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $pid = pack \"V\", eval $nid;\n\tif (! open (FD,\"+<$file\")) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"MBR: failed to open file: $file: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tseek FD,440,0;\n\tmy $done = syswrite (FD,$pid,4);\n\tif ($done != 4) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"MBR: only $done bytes written\");\n\t\t$kiwi -> failed ();\n\t\tseek FD,0,2; close FD;\n\t\treturn undef;\n\t}\n\tseek FD,0,2; close FD;\n\treturn $this;\n}\n\n#==========================================\n# setupBootLoaderStages\n#------------------------------------------\nsub setupBootLoaderStages {\n\tmy $this   = shift;\n\tmy $loader = shift;\n\tmy $type   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $tmpdir = $this->{tmpdir};\n\tmy $initrd = $this->{initrd};\n\tmy $zipped = $this->{zipped};\n\tmy $zipper = $this->{gdata}->{Gzip};\n\tmy $status = 0;\n\tmy $result = 0;\n\t#==========================================\n\t# Grub\n\t#------------------------------------------\n\tif ($loader eq \"grub\") {\n\t\tmy $stages = \"'usr/lib/grub/*'\";\n\t\tmy $figure = \"'image/loader/message'\";\n\t\tmy $unzip  = \"$zipper -cd $initrd 2>&1\";\n\t\t$status = qxx ( \"mkdir -p $tmpdir/boot/grub 2>&1\" );\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed creating boot manager directory: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Get Grub graphics boot message\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Importing graphics boot message and stage files\");\n\t\tif ($zipped) {\n\t\t\t$status= qxx (\n\t\t\t\t\"$unzip | (cd $tmpdir && cpio -i -d $figure -d $stages 2>&1)\"\n\t\t\t);\n\t\t} else {\n\t\t\t$status= qxx (\n\t\t\t\t\"cat $initrd|(cd $tmpdir && cpio -i -d $figure -d $stages 2>&1)\"\n\t\t\t);\n\t\t}\n\t\tif (-e $tmpdir.\"/image/loader/message\") {\n\t\t\t$status = qxx (\"mv $tmpdir/$figure $tmpdir/boot/message 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> skipped();\n\t\t}\n\t\t#==========================================\n\t\t# check Grub stage files...\n\t\t#------------------------------------------\n\t\tif (glob($tmpdir.\"/usr/lib/grub/*\")) {\n\t\t\t$status = qxx (\n\t\t\t\t\"mv $tmpdir/usr/lib/grub/* $tmpdir/boot/grub 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tif (($result == 0) && (defined $type) && ($type eq \"iso\")) {\n\t\t\t\tmy $src = \"$tmpdir/boot/grub/stage2_eltorito\";\n\t\t\t\tmy $dst = \"$tmpdir/boot/grub/stage2\";\n\t\t\t\t$status = qxx (\"mv $src $dst 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tchomp $status;\n\t\t\t$kiwi -> error   (\"Failed importing grub stages: $status\");\n\t\t\t$kiwi -> skipped ();\n\t\t\t$kiwi -> info    (\"Trying to use grub stages from local machine\");\n\t\t\t$status = qxx ( \"cp /usr/lib/grub/* $tmpdir/boot/grub 2>&1\" );\n\t\t\t$result = $? >> 8;\n\t\t\tif (($result == 0) && (defined $type) && ($type eq \"iso\")) {\n\t\t\t\tmy $src = \"$tmpdir/boot/grub/stage2_eltorito\";\n\t\t\t\tmy $dst = \"$tmpdir/boot/grub/stage2\";\n\t\t\t\t$status = qxx (\"mv $src $dst 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t}\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> error  (\"Failed importing grub stages: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# syslinux\n\t#------------------------------------------\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\tmy $message= \"'image/loader/*'\";\n\t\tmy $unzip  = \"$zipper -cd $initrd 2>&1\";\n\t\t#==========================================\n\t\t# Create syslinux boot data directory\n\t\t#------------------------------------------\n\t\tqxx (\"mkdir -p $tmpdir/boot/syslinux 2>&1\");\n\t\t#==========================================\n\t\t# Get syslinux graphics data\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Importing graphics boot message\");\n\t\tif ($zipped) {\n\t\t\t$status= qxx (\"$unzip | (cd $tmpdir && cpio -di $message 2>&1)\");\n\t\t} else {\n\t\t\t$status= qxx (\"cat $initrd|(cd $tmpdir && cpio -di $message 2>&1)\");\n\t\t}\n\t\tif (-d $tmpdir.\"/image/loader\") {\n\t\t\t$status = qxx (\n\t\t\t\t\"mv $tmpdir/image/loader/* $tmpdir/boot/syslinux 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> skipped();\n\t\t}\n\t\t#==========================================\n\t\t# Cleanup tmpdir\n\t\t#------------------------------------------\n\t\tqxx (\"rm -rf $tmpdir/image 2>&1\");\n\t}\n\t#==========================================\n\t# more boot managers to come...\n\t#------------------------------------------\n\t# ...\n\treturn $this;\n}\n\n#==========================================\n# setupBootLoaderConfiguration\n#------------------------------------------\nsub setupBootLoaderConfiguration {\n\tmy $this     = shift;\n\tmy $loader   = shift;\n\tmy $type     = shift;\n\tmy $extra    = shift;\n\tmy $kiwi     = $this->{kiwi};\n\tmy $tmpdir   = $this->{tmpdir};\n\tmy $initrd   = $this->{initrd};\n\tmy $isxen    = $this->{isxen};\n\tmy $xendomain= $this->{xendomain};\n\tmy $imgtype  = $this->{imgtype};\n\tmy $bootpart = $this->{bootpart};\n\tmy $label    = $this->{bootlabel};\n\tmy $vga      = $this->{vga};\n\tmy $lvm      = $this->{lvm};\n\tmy $vgroup   = $this->{lvmgroup};\n\tmy $xml      = $this->{xml};\n\tmy $bloader  = \"grub\";\n\tmy $cmdline;\n\tmy %type;\n\tmy $title;\n\t#==========================================\n\t# setup boot loader default boot label/nr\n\t#------------------------------------------\n\tmy $defaultBootNr = 0;\n\tif ($xml) {\n\t\t%type = %{$xml->getImageTypeAndAttributes()};\n\t\t$cmdline  = $type{cmdline};\n\t}\n\tif ($type =~ /^KIWI CD Boot/) {\n\t\t# /.../\n\t\t# use predefined set of parameters for simple boot CD\n\t\t# not including a system image\n\t\t# ----\n\t\t$type{installboot} = \"install\";\n\t\t$type{boottimeout} = 1;\n\t\t$type{fastboot}    = 1;\n\t\t$cmdline=\"kiwistderr=/dev/hvc0\";\n\t\t$vga=\"normal\";\n\t}\n\tif ((($type =~ /^KIWI (CD|USB)/)) && ($type{installboot})) {\n\t\t# In install mode we have the following menu layout\n\t\t# ----\n\t\t# 0 -> Boot from Hard Disk\n\t\t# 1 -> Install/Restore $label\n\t\t# 2 -> Failsafe -- Install/Restore $label\n\t\t# ----\n\t\tif ($type{installboot} eq \"install\") {\n\t\t\t$defaultBootNr = 1;\n\t\t}\n\t\tif ($type{installboot} eq \"failsafe-install\") {\n\t\t\t$defaultBootNr = 2;\n\t\t}\n\t}\n\t#==========================================\n\t# setup boot loader type\n\t#------------------------------------------\n\tif ($type{bootloader}) {\n\t\t$bloader = $type{bootloader};\n\t}\n\t#==========================================\n\t# report additional cmdline options\n\t#------------------------------------------\n\tif ($cmdline) {\n\t\t$kiwi -> loginfo (\n\t\t\t\"Additional commandline options: \\\"$cmdline\\\"\"\n\t\t);\n\t}\n\t#==========================================\n\t# join common options, finish with '\\n'\n\t#------------------------------------------\n\t$cmdline .= \" $extra\" if $extra;\n\t$cmdline .= \" VGROUP=$vgroup\" if $lvm;\n\t$cmdline .= \" COMBINED_IMAGE=yes\" if $imgtype eq \"split\";\n\t$cmdline .= \" showopts\\n\";\n\t# ensure exactly one space at start\n\t$cmdline =~ s/^\\s*/ /;\n\n\t#==========================================\n\t# Check boot partition number\n\t#------------------------------------------\n\tif (! defined $bootpart) {\n\t\t$bootpart = 0;\n\t}\n\t#==========================================\n\t# Grub\n\t#------------------------------------------\n\tif ($loader eq \"grub\") {\n\t\t#==========================================\n\t\t# Create MBR id file for boot device check\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Saving disk label on disk: $this->{mbrid}...\");\n\t\tif (! open (FD,\">$tmpdir/boot/grub/mbrid\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create mbrid file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$this->{mbrid}\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Create menu.lst file\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Creating grub menu list file...\");\n\t\tif (! open (FD,\">$tmpdir/boot/grub/menu.lst\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create menu.lst: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Compat link\n\t\t#------------------------------------------\n\t\tqxx (\"cd $tmpdir/boot/grub && ln -s menu.lst grub.conf\");\n\t\t#==========================================\n\t\t# General grub setup\n\t\t#------------------------------------------\n\t\tprint FD \"color cyan/blue white/blue\\n\";\n\t\tprint FD \"default $defaultBootNr\\n\";\n\t\tmy $bootTimeout = 10;\n\t\tif (defined $type{boottimeout}) {\n\t\t\t$bootTimeout = $type{boottimeout};\n\t\t}\n\t\tif ($type{fastboot}) {\n\t\t\t$bootTimeout = 0;\n\t\t}\n\t\tprint FD \"timeout $bootTimeout\\n\";\n\t\tif ($type =~ /^KIWI (CD|USB)/) {\n\t\t\tmy $dev = $1 eq 'CD' ? '(cd)' : '(hd0,0)';\n\t\t\tif (! $type{fastboot}) {\n\t\t\t\tif (-e \"$tmpdir/boot/grub/splash.xpm.gz\") {\n\t\t\t\t\tprint FD \"splashimage=$dev/boot/grub/splash.xpm.gz\\n\"\n\t\t\t\t} elsif (-e \"$tmpdir/boot/message\") {\n\t\t\t\t\tprint FD \"gfxmenu $dev/boot/message\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprint FD \"title Boot from Hard Disk\\n\";\n\t\t\tif ($dev eq '(cd)') {\n\t\t\t\tprint FD \" rootnoverify (hd0)\\n\";\n\t\t\t\tprint FD \" chainloader (hd0)+1\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprint FD \" chainloader $dev/boot/grub/bootnext\\n\";\n\t\t\t\tmy $bootnext = $this -> addBootNext (\n\t\t\t\t\t\"$tmpdir/boot/grub/bootnext\", hex $this->{mbrid}\n\t\t\t\t);\n\t\t\t\tif (! defined $bootnext) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$kiwi -> error  (\"Failed to write bootnext\\n\");\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$title = $this -> makeLabel (\"Install/Restore $label\");\n\t\t\tprint FD \"title $title\\n\";\n\t\t} else {\n\t\t\t$title = $this -> makeLabel (\"$label [ $type ]\");\n\t\t\tif (-e \"$tmpdir/boot/grub/splash.xpm.gz\") {\n\t\t\t\tprint FD \"splashimage=(hd0,$bootpart)/boot/grub/splash.xpm.gz\\n\"\n\t\t\t} elsif (-e \"$tmpdir/boot/message\") {\n\t\t\t\tprint FD \"gfxmenu (hd0,$bootpart)/boot/message\\n\";\n\t\t\t}\n\t\t\tprint FD \"title $title\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# Standard boot\n\t\t#------------------------------------------\n\t\tif ((! $isxen) || ($isxen && $xendomain eq \"domU\")) {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" kernel (cd)/boot/linux vga=$vga splash=silent\";\n\t\t\t\tprint FD \" ramdisk_size=512000 ramdisk_blocksize=4096\";\n\t\t\t\tprint FD \" cdinst=1 loader=$bloader\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/linux.vmx vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/linux vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD $cmdline;\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" initrd (cd)/boot/initrd\\n\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" initrd /boot/initrd.vmx\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \" initrd /boot/initrd\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" kernel (cd)/boot/xen.gz\\n\";\n\t\t\t\tprint FD \" module /boot/linux vga=$vga splash=silent\";\n\t\t\t\tprint FD \" ramdisk_size=512000 ramdisk_blocksize=4096\";\n\t\t\t\tprint FD \" cdinst=1 loader=$bloader\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/xen.gz.vmx\\n\";\n\t\t\t\tprint FD \" module /boot/linux.vmx vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/xen.gz\\n\";\n\t\t\t\tprint FD \" module /boot/linux vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD $cmdline;\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" module (cd)/boot/initrd\\n\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" module /boot/initrd.vmx\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \" module /boot/initrd\\n\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# Failsafe boot\n\t\t#------------------------------------------\n\t\t$title = $this -> makeLabel (\"Failsafe -- $title\");\n\t\tprint FD \"title $title\\n\";\n\t\tif ((! $isxen) || ($isxen && $xendomain eq \"domU\")) {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" kernel (cd)/boot/linux vga=$vga splash=silent\";\n\t\t\t\tprint FD \" ramdisk_size=512000 ramdisk_blocksize=4096\";\n\t\t\t\tprint FD \" cdinst=1 loader=$bloader\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/linux.vmx vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/linux vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD \" ide=nodma apm=off acpi=off noresume selinux=0 nosmp\";\n\t\t\tprint FD \" noapic maxcpus=0 edd=off\";\n\t\t\tprint FD $cmdline;\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" initrd (cd)/boot/initrd\\n\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" initrd /boot/initrd.vmx\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \" initrd /boot/initrd\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" kernel (cd)/boot/xen.gz\\n\";\n\t\t\t\tprint FD \" module (cd)/boot/linux vga=$vga splash=silent\";\n\t\t\t\tprint FD \" ramdisk_size=512000 ramdisk_blocksize=4096\";\n\t\t\t\tprint FD \" cdinst=1 loader=$bloader\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/xen.gz.vmx\\n\";\n\t\t\t\tprint FD \" module /boot/linux.vmx vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/xen.gz\\n\";\n\t\t\t\tprint FD \" module /boot/linux vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD \" ide=nodma apm=off acpi=off noresume selinux=0 nosmp\";\n\t\t\tprint FD \" noapic maxcpus=0 edd=off\";\n\t\t\tprint FD $cmdline;\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" module (cd)/boot/initrd\\n\"\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" module /boot/initrd.vmx\\n\"\n\t\t\t} else {\n\t\t\t\tprint FD \" module /boot/initrd\\n\";\n\t\t\t}\n\t\t}\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# syslinux\n\t#------------------------------------------\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\t#==========================================\n\t\t# Create MBR id file for boot device check\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Saving disk label on disk: $this->{mbrid}...\");\n\t\tqxx (\"mkdir -p $tmpdir/boot/grub\");\n\t\tif (! open (FD,\">$tmpdir/boot/grub/mbrid\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create mbrid file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$this->{mbrid}\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Create syslinux config file\n\t\t#------------------------------------------\n\t\tmy $syslconfig = \"syslinux.cfg\";\n\t\tif ($loader eq \"extlinux\") {\n\t\t\t$syslconfig = \"extlinux.conf\";\n\t\t}\n\t\t$kiwi -> info (\"Creating $syslconfig config file...\");\n\t\tif (! open (FD,\">$tmpdir/boot/syslinux/$syslconfig\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create $syslconfig: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $syslinux_new_format = 0;\n\t\tmy $gfx = \"$tmpdir/boot/syslinux\";\n\t\tif (-f \"$gfx/gfxboot.com\" || -f \"$gfx/gfxboot.c32\") {\n\t\t\t$syslinux_new_format = 1;\n\t\t}\n\t\t#==========================================\n\t\t# General syslinux setup\n\t\t#------------------------------------------\n\t\tprint FD \"implicit 1\".\"\\n\";\n\t\tprint FD \"prompt   1\".\"\\n\";\n\t\tmy $bootTimeout = 100;\n\t\tif (defined $type{boottimeout}) {\n\t\t\t$bootTimeout = $type{boottimeout};\n\t\t\tif (int ($bootTimeout) == 0) {\n\t\t\t\t# /.../\n\t\t\t\t# a timeout value of 0 disables the timeout in syslinux\n\t\t\t\t# therefore we set the smallest possible value in that case\n\t\t\t\t# which is 1/10 sec\n\t\t\t\t# ----\n\t\t\t\t$bootTimeout = 1;\n\t\t\t}\n\t\t}\n\t\tprint FD \"timeout  $bootTimeout\".\"\\n\";\n\t\tprint FD \"display isolinux.msg\".\"\\n\";\n\t\tmy @labels = ();\n\t\tif (-f \"$gfx/bootlogo\") {\n\t\t\tif ($syslinux_new_format) {\n\t\t\t\tprint FD \"ui gfxboot bootlogo isolinux.msg\".\"\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \"gfxboot bootlogo\".\"\\n\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# Setup default title\n\t\t#------------------------------------------\n\t\tif ($type =~ /^KIWI (CD|USB)/) {\n\t\t\tif ($defaultBootNr == 0) {\n\t\t\t\t$title = $this -> makeLabel (\"Boot from Hard Disk\");\n\t\t\t} elsif ($defaultBootNr == 1) {\n\t\t\t\t$title = $this -> makeLabel (\"Install/Restore $label\");\n\t\t\t} else {\n\t\t\t\t$title = $this -> makeLabel (\n\t\t\t\t\t\"Failsafe -- Install/Restore $label\"\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t$title = $this -> makeLabel (\"$label [ $type ]\");\n\t\t}\n\t\tprint FD \"default $title\".\"\\n\";\n\t\tif ($type =~ /^KIWI (CD|USB)/) {\n\t\t\t$title = $this -> makeLabel (\"Boot from Hard Disk\");\n\t\t\tprint FD \"label $title\\n\";\n\t\t\tprint FD \"localboot 0x80\\n\";\n\t\t\t$title = $this -> makeLabel (\"Install/Restore $label\");\n\t\t} else {\n\t\t\t$title = $this -> makeLabel (\"$label [ $type ]\");\n\t\t}\n\t\tprint FD \"label $title\".\"\\n\";\n\t\tpush @labels,$title;\n\t\t#==========================================\n\t\t# Standard boot\n\t\t#------------------------------------------\n\t\tif (! $isxen) {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \"kernel linux\\n\";\n\t\t\t\tprint FD \"append initrd=initrd \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent \";\n\t\t\t\tprint FD \"ramdisk_size=512000 ramdisk_blocksize=4096 \";\n\t\t\t\tprint FD \"cdinst=1 kiwi_hybrid=1\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \"kernel /boot/linux.vmx\\n\";\n\t\t\t\tprint FD \"append initrd=/boot/initrd.vmx \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \"kernel /boot/linux\\n\";\n\t\t\t\tprint FD \"append initrd=/boot/initrd \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen cdinst not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen boot not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t} else {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen boot not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\tprint FD $cmdline;\n\t\t#==========================================\n\t\t# Failsafe boot\n\t\t#------------------------------------------\n\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t$title = $this -> makeLabel (\"Failsafe -- Install/Restore $label\");\n\t\t\tprint FD \"label $title\".\"\\n\";\n\t\t} elsif ($type =~ /^KIWI USB/) {\n\t\t\t$title = $this -> makeLabel (\"Failsafe -- Install/Restore $label\");\n\t\t\tprint FD \"label $title\".\"\\n\";\n\t\t} else {\n\t\t\t$title = $this -> makeLabel (\"Failsafe -- $label [ $type ]\");\n\t\t\tprint FD \"label $title\".\"\\n\";\n\t\t}\n\t\tpush @labels,$title;\n\t\tif (! $isxen) {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \"kernel linux\\n\";\n\t\t\t\tprint FD \"append initrd=initrd \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent \";\n\t\t\t\tprint FD \"ramdisk_size=512000 ramdisk_blocksize=4096 \";\n\t\t\t\tprint FD \"cdinst=1 kiwi_hybrid=1\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \"kernel /boot/linux.vmx\\n\";\n\t\t\t\tprint FD \"append initrd=/boot/initrd.vmx \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \"kernel /boot/linux\\n\";\n\t\t\t\tprint FD \"append initrd=/boot/initrd \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD \" ide=nodma apm=off acpi=off noresume selinux=0 nosmp\";\n\t\t\tprint FD \" noapic maxcpus=0 edd=off\";\n\t\t} else {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen cdinst not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen boot not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t} else {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen boot not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tprint FD \" ide=nodma apm=off acpi=off noresume selinux=0 nosmp\";\n\t\t\tprint FD \" noapic maxcpus=0 edd=off\";\n\t\t}\n\t\tprint FD $cmdline;\n\t\tclose FD;\n\t\t#==========================================\n\t\t# setup isolinux.msg file\n\t\t#------------------------------------------\n\t\tif (! open (FD,\">$tmpdir/boot/syslinux/isolinux.msg\")) {\n\t\t\t$kiwi -> failed();\n\t\t\t$kiwi -> error  (\"Failed to create isolinux.msg: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"\\n\".\"Welcome !\".\"\\n\\n\";\n\t\tforeach my $label (@labels) {\n\t\t\tprint FD \"$label\".\"\\n\";\n\t\t}\n\t\tprint FD \"\\n\\n\";\n\t\tprint FD \"Have a lot of fun...\".\"\\n\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Zipl\n\t#------------------------------------------\n\tif ($loader eq \"zipl\") {\n\t\t#==========================================\n\t\t# Create MBR id file for boot device check\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Saving disk label on disk: $this->{mbrid}...\");\n\t\tqxx (\"mkdir -p $tmpdir/boot/grub\");\n\t\tqxx (\"mkdir -p $tmpdir/boot/zipl\");\n\t\tif (! open (FD,\">$tmpdir/boot/grub/mbrid\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create mbrid file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$this->{mbrid}\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Create zipl.conf\n\t\t#------------------------------------------\n\t\t$cmdline =~ s/\\n//g;\n\t\tmy $ziplconfig = \"zipl.conf\";\n\t\t$kiwi -> info (\"Creating $ziplconfig config file...\");\n\t\tif ($isxen) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"*** zipl: Xen boot not supported ***\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! -e \"/boot/zipl\") {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Can't find bootloader: /boot/zipl\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! open (FD,\">$tmpdir/boot/$ziplconfig\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create $ziplconfig: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# General zipl setup\n\t\t#------------------------------------------\n\t\tmy $title_standard;\n\t\tmy $title_failsafe;\n\t\tif ($type =~ /^KIWI (CD|USB)/) {\n\t\t\t$title_standard = $this -> makeLabel (\n\t\t\t\t\"Install/Restore $label\"\n\t\t\t);\n\t\t\t$title_failsafe = $this -> makeLabel (\n\t\t\t\t\"Failsafe -- Install/Restore $label\"\n\t\t\t);\n\t\t} else {\n\t\t\t$title_standard = $this -> makeLabel (\n\t\t\t\t\"$label ( $type )\"\n\t\t\t);\n\t\t\t$title_failsafe = $this -> makeLabel (\n\t\t\t\t\"Failsafe -- $label ( $type )\"\n\t\t\t);\n\t\t}\n\t\tprint FD \"[defaultboot]\".\"\\n\";\n\t\tprint FD \"defaultmenu = menu\".\"\\n\\n\";\n\t\tprint FD \":menu\".\"\\n\";\n\t\tprint FD \"\\t\".\"default = 1\".\"\\n\";\n\t\tprint FD \"\\t\".\"prompt  = 1\".\"\\n\";\n\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\tprint FD \"\\t\".\"timeout = 200\".\"\\n\";\n\t\tprint FD \"\\t\".\"1 = $title_standard\".\"\\n\";\n\t\tprint FD \"\\t\".\"2 = $title_failsafe\".\"\\n\\n\";\n\t\t#==========================================\n\t\t# Standard boot\n\t\t#------------------------------------------\n\t\tprint FD \"[$title_standard]\".\"\\n\";\n\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"*** zipl: CD boot not supported ***\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\tprint FD \"\\t\".\"image   = boot/linux.vmx\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"ramdisk = boot/initrd.vmx,0x4000000\".\"\\n\";\n\t\t} else {\n\t\t\tprint FD \"\\t\".\"image   = boot/linux\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"ramdisk = boot/initrd,0x4000000\".\"\\n\";\n\t\t}\n\t\tprint FD \"\\t\".\"parameters = \\\"loader=$bloader\";\n\t\tprint FD \" $cmdline\\\"\".\"\\n\";\n\t\t#==========================================\n\t\t# Failsafe boot\n\t\t#------------------------------------------\n\t\tprint FD \"[$title_failsafe]\".\"\\n\";\n\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"*** zipl: CD boot not supported ***\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\tprint FD \"\\t\".\"image   = boot/linux.vmx\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"ramdisk = boot/initrd.vmx,0x4000000\".\"\\n\";\n\t\t} else {\n\t\t\tprint FD \"\\t\".\"image   = boot/linux\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"ramdisk = boot/initrd,0x4000000\".\"\\n\";\n\t\t}\n\t\tprint FD \"\\t\".\"parameters = \\\"x11failsafe loader=$bloader\";\n\t\tprint FD \" $cmdline\\\"\".\"\\n\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# lilo\n\t#------------------------------------------\n\tif ($loader eq \"lilo\") {\n\t\t$cmdline =~ s/\\n//g;\n\t\tmy $title_standard;\n\t\t$title_standard = $this -> makeLabel (\"$label\");\n\t\t#==========================================\n\t\t# Standard boot\n\t\t#------------------------------------------\n\t\tqxx (\"mkdir -p $tmpdir/etc\");\n\t\tif (! open (FD,\">$tmpdir/etc/yaboot.conf\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create yaboot.conf: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# CD NON-LVM BOOT\n\t\t#-------------------------------------------\n\t\tif (($type =~ /^KIWI CD/) && (!$lvm)) {\n\t\t\tprint FD \"default = $title_standard\\n\";\n\t\t\tprint FD \"image = /boot/linux\\n\";\n\t\t\tprint FD \"\\t\".\"label = $title_standard\\n\";\n\t\t\tprint FD \"\\t\".\"append = \\\"$cmdline\\\"\\n\";\n\t\t\tprint FD \"\\t\".\"initrd = /boot/initrd\\n\";\n\t\t\tclose FD;\n\t\t} elsif (($type =~ /^KIWI CD/) && ($lvm)) {\n\t\t\t#==========================================\n\t\t\t# CD LVM Boot\n\t\t\t#-------------------------------------------\n\t\t\tprint FD \"default = $title_standard\\n\";\n\t\t\tprint FD \"image = /boot/linux\\n\";\n\t\t\tprint FD \"\\t\".\"label = $title_standard\\n\";\n\t\t\tprint FD \"\\t\".\"append = \\\"$cmdline\\\"\\n\";\n\t\t\tprint FD \"\\t\".\"initrd = /boot/initrd\\n\";\n\t\t\tclose FD;\n\t\t} elsif (!($type =~ /^KIWI CD/) && (!$lvm)) {\n\t\t\t#==========================================\n\t\t\t# RAW NON-LVM\n\t\t\t#------------------------------------------\n\t\t\tprint FD \"partition = 2\\n\";\n\t\t\tprint FD \"timeout = 80\\n\";\n\t\t\tprint FD \"default = $title_standard\\n\";\n\t\t\tprint FD \"image = /boot/linux.vmx\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"label = $title_standard\\n\";\n\t\t\tprint FD \"\\t\".\"root = /dev/sda2\\n\";\n\t\t\tprint FD \"\\t\".\"append = \\\"$cmdline\\\"\\n\";\n\t\t\tprint FD \"\\t\".\"initrd = /boot/initrd.vmx\\n\";\n\t\t\tclose FD;\n\t\t} elsif (!($type =~ /^KIWI CD/) && ($lvm)) {\n\t\t\t#==========================================\n\t\t\t# RAW LVM\n\t\t\t#-------------------------------------------\n\t\t\tprint FD \"default = $title_standard\\n\";\n\t\t\tprint FD \"image = linux.vmx\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"label = $title_standard\\n\";\n\t\t\tprint FD \"\\t\".\"append = \\\"$cmdline\\\"\\n\";\n\t\t\tprint FD \"\\t\".\"initrd = initrd.vmx\\n\";\n\t\t\tclose FD;\n\t\t}\n\t\t#==========================================\n\t\t# Create bootinfo.txt (CD and LVM setups)\n\t\t#-------------------------------------------\n\t\tif ($type =~ /^KIWI CD/)  {\n\t\t\tqxx (\"mkdir -p $tmpdir/ppc/\");\n\t\t\tif (! open (FD,\">$tmpdir/ppc/bootinfo.txt\")) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't create bootinfo.txt: $!\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tprint FD \"<chrp-boot>\\n\";\n\t\t\tprint FD \"<description>$title_standard</description>\\n\";\n\t\t\tprint FD \"<os-name>$title_standard</os-name>\\n\";\n\t\t\tprint FD \"<boot-script>boot &device;:1,\\\\suseboot\\\\yaboot.ibm\";\n\t\t\tprint FD \"</boot-script>\\n\";\n\t\t\tprint FD \"</chrp-boot>\\n\";\n\t\t\tclose FD;\n\t\t\tqxx (\"mkdir $tmpdir/suseboot\");\n\t\t\tqxx (\"cp /lib/lilo/chrp/yaboot.chrp $tmpdir/suseboot/yaboot.ibm\");\n\t\t\tqxx (\"cp $tmpdir/etc/yaboot.conf $tmpdir/suseboot/yaboot.cnf\");\n\t\t} elsif (!($type =~ /^KIWI CD/) && ($lvm)) {\n\t\t\tqxx (\"mkdir -p $tmpdir/ppc/\");\n\t\t\tif (! open (FD,\">$tmpdir/ppc/bootinfo.txt\")) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't create bootinfo.txt: $!\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tprint FD \"<chrp-boot>\\n\";\n\t\t\tprint FD \"<description>$title_standard</description>\\n\";\n\t\t\tprint FD \"<os-name>$title_standard</os-name>\\n\";\n\t\t\tprint FD \"<boot-script>boot &device;:1,yaboot</boot-script>\\n\";\n\t\t\tprint FD \"</chrp-boot>\\n\";\n\t\t\tclose FD;\n\t\t}\n\t\t$kiwi -> done ();\n\t}\n\t#==========================================\n\t# more boot managers to come...\n\t#------------------------------------------\n\t# ...\n\treturn $this;\n}\n\n#==========================================\n# installBootLoader\n#------------------------------------------\nsub installBootLoader {\n\tmy $this     = shift;\n\tmy $loader   = shift;\n\tmy $diskname = shift;\n\tmy $deviceMap= shift;\n\tmy $kiwi     = $this->{kiwi};\n\tmy $tmpdir   = $this->{tmpdir};\n\tmy $bootpart = $this->{bootpart};\n\tmy $chainload= $this->{chainload};\n\tmy $lvm\t     = $this->{lvm};\n\tmy $cmdL     = $this->{cmdL};\n\tmy $locator  = new KIWILocator($kiwi);\n\tmy $result;\n\tmy $status;\n\t#==========================================\n\t# Check for edit boot config\n\t#------------------------------------------\n\tif ($cmdL) {\n\t\tmy $editBoot = $cmdL -> getEditBootConfig();\n\t\tif (($editBoot) && (-e $editBoot)) {\n\t\t\tsystem (\"cd $tmpdir && bash --norc -c $editBoot\");\n\t\t}\n\t}\n\t#==========================================\n\t# Check boot partition number\n\t#------------------------------------------\n\tif (! defined $bootpart) {\n\t\t$bootpart = 0;\n\t}\n\t#==========================================\n\t# Grub\n\t#------------------------------------------\n\tif ($loader eq \"grub\") {\n\t\t$kiwi -> info (\"Installing grub on device: $diskname\");\n\t\t#==========================================\n\t\t# Clean loop maps\n\t\t#------------------------------------------\n\t\t$this -> cleanLoopMaps();\n\t\t$this -> cleanLoop();\n\t\t#==========================================\n\t\t# Create device map for the disk\n\t\t#------------------------------------------\n\t\tmy $dmfile = \"$tmpdir/grub-device.map\";\n\t\tmy $dmfd = new FileHandle;\n\t\tif (! $dmfd -> open(\">$dmfile\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Couldn't create grub device map: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint $dmfd \"(hd0) $diskname\\n\";\n\t\t$dmfd -> close();\n\t\t#==========================================\n\t\t# Create command list to install grub\n\t\t#------------------------------------------\n\t\tmy $cmdfile = \"$tmpdir/grub-device.cmds\";\n\t\tif (! $dmfd -> open(\">$cmdfile\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Couldn't create grub command list: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint $dmfd \"device (hd0) $diskname\\n\";\n\t\tprint $dmfd \"root (hd0,$bootpart)\\n\";\n\t\tif ($chainload) {\n\t\t\tprint $dmfd \"setup (hd0,0)\\n\";\n\t\t} else {\n\t\t\tprint $dmfd \"setup (hd0)\\n\";\n\t\t}\n\t\tprint $dmfd \"quit\\n\";\n\t\t$dmfd -> close();\n\t\t#==========================================\n\t\t# Install grub in batch mode\n\t\t#------------------------------------------\n\t\tmy $grub = $locator -> getExecPath ('grub');\n\t\tif (! $grub) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Can't locate grub binary\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $grubOptions = \"--device-map $dmfile --no-floppy --batch\";\n\t\tqxx (\"mount --bind $tmpdir/boot/grub /boot/grub\");\n\t\tqxx (\"$grub $grubOptions < $cmdfile &> $tmpdir/grub.log\");\n\t\tqxx (\"umount /boot/grub\");\n\t\tmy $glog;\n\t\tif ($dmfd -> open (\"$tmpdir/grub.log\")) {\n\t\t\tmy @glog = <$dmfd>; $dmfd -> close();\n\t\t\tif ($dmfd -> open (\"$cmdfile\")) {\n\t\t\t\tmy @cmdlog = <$dmfd>; $dmfd -> close();\n\t\t\t\tpush @glog,\"GRUB: commands:\";\n\t\t\t\tpush @glog,@cmdlog;\n\t\t\t}\n\t\t\tmy $stage1 = grep { /^\\s*Running.*succeeded$/ } @glog;\n\t\t\tmy $stage1_5 = grep { /^\\s*Running.*are embedded\\.$/ } @glog;\n\t\t\t$result = !(($stage1 == 1) && ($stage1_5 == 1));\n\t\t\t$glog = join (\"\\n\",@glog);\n\t\t\t$kiwi -> loginfo (\"GRUB: $glog\\n\");\n\t\t}\n\t\tif ($result != 1) {\n\t\t\tmy $boot = \"'boot sector'\";\n\t\t\tmy $null = \"/dev/null\";\n\t\t\t$status= qxx (\n\t\t\t\t\"dd if=$diskname bs=512 count=1 2>$null|file - | grep -q $boot\"\n\t\t\t);\n\t\t\t$result= $? >> 8;\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't install grub on $diskname: $glog\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tif ($chainload) {\n\t\t\t# /.../\n\t\t\t# chainload grub with master-boot-code\n\t\t\t# zero out sectors between 0x200 - 0x3f0 for preload process\n\t\t\t# store a copy of the master-boot-code at 0x800\n\t\t\t# write FDST flag at 0x190\n\t\t\t# ---\n\t\t\tmy $mbr = \"/usr/lib/boot/master-boot-code\";\n\t\t\tmy $opt = \"conv=notrunc\";\n\t\t\t#==========================================\n\t\t\t# write master-boot-code\n\t\t\t#------------------------------------------\n\t\t\t$status = qxx (\n\t\t\t\t\"dd if=$mbr of=$diskname bs=1 count=446 $opt 2>&1\"\n\t\t\t);\n\t\t\t$result= $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't install master boot code: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# write backup MBR with partition table\n\t\t\t#------------------------------------------\n\t\t\t#my $bmbr= $diskname.\".mbr\";\n\t\t\t#$status = qxx (\n\t\t\t#\t\"dd if=$diskname of=$bmbr bs=1 count=512 2>&1\"\n\t\t\t#);\n\t\t\t#$result= $? >> 8;\n\t\t\t#if ($result != 0) {\n\t\t\t#\t$kiwi -> failed ();\n\t\t\t#\t$kiwi -> error  (\"Couldn't store backup MBR: $status\");\n\t\t\t#\t$kiwi -> failed ();\n\t\t\t#\treturn undef;\n\t\t\t#}\n\t\t\t#$status = qxx (\n\t\t\t#  \"dd if=$bmbr of=$diskname bs=512 count=1 seek=3 skip=0 $opt 2>&1\"\n\t\t\t#);\n\t\t\t#unlink $bmbr;\n\t\t\t#==========================================\n\t\t\t# write FDST flag\n\t\t\t#------------------------------------------\n\t\t\tmy $fdst = \"perl -e \\\"printf '%s', pack 'A4', eval 'FDST';\\\"\";\n\t\t\tqxx (\n\t\t\t\t\"$fdst|dd of=$diskname bs=1 count=4 seek=\\$((0x190)) $opt 2>&1\"\n\t\t\t);\n\t\t\t#==========================================\n\t\t\t# zero out preload range\n\t\t\t#------------------------------------------\n\t\t\t$status = qxx (\n\t\t\t\t\"dd if=/dev/zero of=$diskname bs=1 count=496 seek=512 $opt 2>&1\"\n\t\t\t);\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# syslinux\n\t#------------------------------------------\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\tif (! $deviceMap) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"No device map available\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy %deviceMap = %{$deviceMap};\n\t\tmy $device = $deviceMap{fat};\n\t\tif ($loader eq \"extlinux\") {\n\t\t\t$device = $deviceMap{extlinux};\n\t\t}\n\t\tif (($device =~ /mapper/) && (! -e $device)) {\n\t\t\tif (! $this -> bindDiskPartitions ($diskname)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\tif ($loader eq \"syslinux\") {\n\t\t\t$kiwi -> info (\"Installing syslinux on device: $device\");\n\t\t\t$status = qxx (\"syslinux $device 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t} else {\n\t\t\t$kiwi -> info (\"Installing extlinux on device: $device\");\n\t\t\t$status = qxx (\"mount $device /mnt 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result == 0) {\n\t\t\t\t$status = qxx (\"extlinux --install /mnt/boot/syslinux 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t}\n\t\t\t$status = qxx (\"umount /mnt 2>&1\");\n\t\t}\n\t\tif ($device =~ /mapper/) {\n\t\t\t$this -> cleanLoopMaps ($diskname);\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't install $loader on $device: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $syslmbr = \"/usr/share/syslinux/mbr.bin\";\n\t\t$status = qxx (\n\t\t\t\"dd if=$syslmbr of=$diskname bs=512 count=1 conv=notrunc 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't install syslinux MBR on $diskname\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Zipl\n\t#------------------------------------------\n\tif ($loader eq \"zipl\") {\n\t\t$kiwi -> info (\"Installing zipl on device: $diskname\");\n\t\tmy $bootdev;\n\t\tmy $offset;\n\t\tmy $haveRealDevice = 0;\n\t\tif ($diskname !~ /\\/dev\\//) {\n\t\t\t#==========================================\n\t\t\t# clean loop maps\n\t\t\t#------------------------------------------\n\t\t\t$this -> cleanLoop ();\n\t\t\t#==========================================\n\t\t\t# detect disk offset of disk image file\n\t\t\t#------------------------------------------\n\t\t\t$offset = $this -> diskOffset ($diskname);\n\t\t\tif (! $offset) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Failed to detect disk offset\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# loop mount disk image file\n\t\t\t#------------------------------------------\n\t\t\tif (! $this->bindDiskDevice ($diskname)) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# find boot partition\n\t\t\t#------------------------------------------\n\t\t\t$bootdev = $this->{bindloop}.\"2\";\n\t\t\tif (! -e $bootdev) {\n\t\t\t\t$bootdev = $this->{bindloop}.\"1\";\n\t\t\t} else {\n\t\t\t\tmy $type = qxx (\"blkid $bootdev -s TYPE -o value\");\n\t\t\t\tif ($type =~ /LVM/) {\n\t\t\t\t\t$bootdev = $this->{bindloop}.\"1\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! -e $bootdev) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Can't find loop map: $bootdev\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t} else {\n\t\t\t#==========================================\n\t\t\t# find boot partition\n\t\t\t#------------------------------------------\n\t\t\t$bootdev = $diskname.\"2\";\n\t\t\tif (! -e $bootdev) {\n\t\t\t\t$bootdev = $diskname.\"1\";\n\t\t\t} else {\n\t\t\t\tmy $type = qxx (\"blkid $bootdev -s TYPE -o value\");\n\t\t\t\tif ($type =~ /LVM/) {\n\t\t\t\t\t$bootdev = $diskname.\"1\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t$haveRealDevice = 1;\n\t\t}\n\t\t#==========================================\n\t\t# mount boot device...\n\t\t#------------------------------------------\n\t\t$status = qxx (\"mount $bootdev /mnt 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Can't mount boot partition: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $mount = \"/mnt\";\n\t\tmy $config = \"$mount/boot/zipl.conf\";\n\t\tif (! $haveRealDevice) {\n\t\t\t#==========================================\n\t\t\t# rewrite zipl.conf with additional params\n\t\t\t#------------------------------------------\n\t\t\tif (! open (FD,$config)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Can't open config file for reading: $!\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\tqxx (\"umount $mount 2>&1\");\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tmy @data = <FD>; close FD;\n\t\t\tif (! open (FD,\">$config\")) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Can't open config file for writing: $!\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\tqxx (\"umount $mount 2>&1\");\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> loginfo (\"zipl.conf target values:\\n\");\n\t\t\tforeach my $line (@data) {\n\t\t\t\tprint FD $line;\n\t\t\t\tif ($line =~ /^:menu/) {\n\t\t\t\t\t$kiwi -> loginfo (\"targetbase = $this->{loop}\\n\");\n\t\t\t\t\t$kiwi -> loginfo (\"targetbase = SCSI\\n\");\n\t\t\t\t\t$kiwi -> loginfo (\"targetblocksize = 512\\n\");\n\t\t\t\t\t$kiwi -> loginfo (\"targetoffset = $offset\\n\");\n\t\t\t\t\tprint FD \"\\t\".\"targetbase = $this->{loop}\".\"\\n\";\n\t\t\t\t\tprint FD \"\\t\".\"targettype = SCSI\".\"\\n\";\n\t\t\t\t\tprint FD \"\\t\".\"targetblocksize = 512\".\"\\n\";\n\t\t\t\t\tprint FD \"\\t\".\"targetoffset = $offset\".\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose FD;\n\t\t}\n\t\t#==========================================\n\t\t# call zipl...\n\t\t#------------------------------------------\n\t\t$status = qxx (\"cd $mount && zipl -c $config 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't install zipl on $diskname: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"umount $mount 2>&1\");\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tqxx (\"umount $mount 2>&1\");\n\t\t$this -> cleanLoop ();\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# install lilo\n\t#------------------------------------------\n\tif ($loader eq \"lilo\") {\n\t\t#==========================================\n\t\t# Activate devices\n\t\t#------------------------------------------\n\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# install yaboot on PReP partition\n\t\t#------------------------------------------\n\t\tif (!$lvm) {\n\t\t\tmy %deviceMap = %{$deviceMap};\n\t\t\tmy $device = $deviceMap{1};\n\t\t\t$kiwi -> info (\"Installing yaboot on device: $device\");\n\t\t\t$status = qxx (\"dd if=/lib/lilo/chrp/yaboot.chrp of=$device 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't install yaboot on $device: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# more boot managers to come...\n\t#------------------------------------------\n\t# ...\n\t#==========================================\n\t# Write custom disk label ID to MBR\n\t#------------------------------------------\n\tif ($loader ne \"lilo\") {\n\t\t$kiwi -> info (\"Saving disk label in MBR: $this->{mbrid}...\");\n\t\tif (! $this -> writeMBRDiskLabel ($diskname)) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t$kiwi -> done();\n\treturn $this;\n}\n\n#==========================================\n# bindDiskDevice\n#------------------------------------------\nsub bindDiskDevice {\n\tmy $this   = shift;\n\tmy $system = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $status;\n\tmy $result;\n\tmy $loop;\n\t#==========================================\n\t# bind file to loop device\n\t#------------------------------------------\n\t$status = qxx (\"/sbin/losetup -s -f $system 2>&1\"); chomp $status;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t# /.../\n\t\t# first losetup call has failed, try to find free loop\n\t\t# device manually even though it's most likely that this\n\t\t# search will fail too. The following is only useful for\n\t\t# older version of losetup which doesn't understand the\n\t\t# option combination -s -f\n\t\t# ----\n\t\tmy $loopfound = 0;\n\t\tfor (my $id=0;$id<=7;$id++) {\n\t\t\t$status.= qxx ( \"/sbin/losetup /dev/loop$id $system 2>&1\" );\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result == 0) {\n\t\t\t\t$loopfound = 1;\n\t\t\t\t$loop = \"/dev/loop\".$id;\n\t\t\t\t$this->{loop} = $loop;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tif (! $loopfound) {\n\t\t\t$kiwi -> loginfo (\"Failed binding loop device: $status\");\n\t\t\treturn undef;\n\t\t}\n\t\treturn $this;\n\t}\n\t$loop = $status;\n\t$this->{loop} = $loop;\n\treturn $this;\n}\n\n#==========================================\n# bindDiskPartitions\n#------------------------------------------\nsub bindDiskPartitions {\n\t# ...\n\t# make sure we can access the partitions of the\n\t# loop mounted disk file\n\t# ---\n\tmy $this   = shift;\n\tmy $disk   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $status;\n\tmy $result;\n\tmy $part;\n\t$status = qxx (\"/sbin/kpartx -a $disk 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo (\"Failed mapping partition: $status\");\n\t\treturn undef;\n\t}\n\t$disk =~ s/dev\\///;\n\t$part = \"/dev/mapper\".$disk.\"p\";\n\t$this->{bindloop} = $part;\n\treturn $this;\n}\n\n#==========================================\n# checkLVMbind\n#------------------------------------------\nsub checkLVMbind {\n\t# ...\n\t# check if the volume group was activated due to a\n\t# previos call of kpartx. In this case the image has\n\t# LVM enabled and we have to use the LVM devices\n\t# ---\n\tmy $this = shift;\n\tmy $sdev = shift;\n\tmy $disk = shift;\n\tmy @groups;\n\t#==========================================\n\t# check for lvm flag on disk\n\t#------------------------------------------\n\tif (! $this-> __getPartID ($disk,\"lvm\")) {\n\t\treturn $sdev;\n\t}\n\t#==========================================\n\t# activate volume groups\n\t#------------------------------------------\n\topen (my $SCAN,\"vgscan 2>/dev/null |\");\n\twhile (my $line = <$SCAN>) {\n\t\tif ($line =~ /\\\"(.*)\\\"/) {\n\t\t\tpush (@groups,$1);\n\t\t}\n\t}\n\tclose $SCAN;\n\t#==========================================\n\t# check the device node names for kiwi lvm\n\t#------------------------------------------\n\tforeach my $lvmgroup (@groups) {\n\t\tqxx (\"vgchange -a y $lvmgroup 2>&1\");\n\t\tfor (my $try=0;$try<=3;$try++) {\n\t\t\tif (defined (my $lvroot = glob (\"/dev/mapper/*-LVRoot\"))) {\n\t\t\t\t$this->{lvm} = 1;\n\t\t\t\t$sdev = $lvroot;\n\t\t\t\tif (defined ($lvroot = glob (\"/dev/mapper/*-LVComp\"))) {\n\t\t\t\t\t$sdev = $lvroot;\n\t\t\t\t}\n\t\t\t\tif ($lvroot =~ /mapper\\/(.*)-.*/) {\n\t\t\t\t\t$this->{lvmgroup} = $1;\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t\tsleep 1;\n\t\t}\n\t\tif ($this->{lvm} == 1) {\n\t\t\tlast;\n\t\t}\n\t}\n\treturn $sdev;\n}\n\n#==========================================\n# getCylinderSizeAndCount\n#------------------------------------------\nsub getCylinderSizeAndCount {\n\t# ...\n\t# obtain cylinder size and count for the specified disk.\n\t# The function returns the size in kB (10^3 B) or zero on error\n\t# ---\n\tmy $this = shift;\n\tmy $disk = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $status;\n\tmy $result;\n\tmy $parted;\n\tmy $locator = new KIWILocator($kiwi);\n\tmy $parted_exec = $locator -> getExecPath(\"parted\");\n\t$status = qxx (\"dd if=/dev/zero of=$disk bs=512 count=1 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo ($status);\n\t\treturn 0;\n\t}\n\t$status = qxx (\"$parted_exec -s $disk mklabel msdos 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo ($status);\n\t\treturn 0;\n\t}\n\t$parted = \"$parted_exec -m $disk unit cyl print\";\n\t$status = qxx (\n\t\t\"$parted | head -n 3 | tail -n 1 | cut -f4 -d: | tr -d 'kB;'\"\n\t);\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo ($status);\n\t\treturn 0;\n\t}\n\tchomp $status;\n\t$this->{pDiskCylinderSize} = $status;\n\t$status = qxx (\n\t\t\"$parted | head -n 3 | tail -n 1 | cut -f1 -d:\"\n\t);\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo ($status);\n\t\treturn 0;\n\t}\n\tchomp $status;\n\t$this->{pDiskCylinders} = $status;\n\t$kiwi -> loginfo (\n\t\t\"Disk Cylinder size is: $this->{pDiskCylinderSize} kB\\n\"\n\t);\n\t$kiwi -> loginfo (\n\t\t\"Disk Cylinder count is: $this->{pDiskCylinders}\\n\"\n\t);\n\treturn $status;\n}\n\n#==========================================\n# getCylinder\n#------------------------------------------\nsub getCylinder {\n\t# ...\n\t# given a size in MB this function calculates the\n\t# aligned cylinder count according to the used disk\n\t# if no size is given the maximum value is used\n\t# ---\n\tmy $this  = shift;\n\tmy $size  = shift;\n\tmy $csize = $this->{pDiskCylinderSize};\n\tmy $count = $this->{pDiskCylinders};\n\tmy $cyls;\n\tif (! defined $csize) {\n\t\treturn 0;\n\t}\n\tif ($size =~ /\\+(.*)M$/) {\n\t\t$cyls = sprintf (\"%.0f\",($size * 1048576) / ($csize * 1000));\n\t} else {\n\t\t$cyls = $count;\n\t}\n\treturn $cyls;\n}\n\n#==========================================\n# resetCylinder\n#------------------------------------------\nsub resetCylinder {\n\t# ...\n\t# reset global cylinder size and count\n\t# ---\n\tmy $this = shift;\n\tundef $this->{pDiskCylinders};\n\tundef $this->{pDiskCylinderSize};\n\tundef $this->{pStart};\n\tundef $this->{pStopp};\n\treturn $this;\n}\n\n#==========================================\n# initCylinders\n#------------------------------------------\nsub initCylinders {\n\t# ...\n\t# calculate cylinder size and count for parted to create\n\t# the appropriate partition. On success the cylinder count\n\t# will be returned, on error zero is returned\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $size   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $cmdL   = $this->{cmdL};\n\tmy $cylsize= $this->{pDiskCylinderSize};\n\tmy $secsize= 512;\n\tmy $cyls   = 0;\n\tmy $status;\n\tmy $result;\n\tif (! defined $this->{pDiskCylinders}) {\n\t\tmy $cylcount = $this -> getCylinderSizeAndCount($device);\n\t\tif ($cylcount == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t$cylsize= $this->{pDiskCylinderSize};\n\t}\n\t$cyls = $this -> getCylinder ($size);\n\tif ($cyls == 0) {\n\t\treturn 0;\n\t}\n\tif (! defined $this->{pStart}) {\n\t\t$cylsize *= 1024;\n\t\t$this->{pStart} = sprintf (\n\t\t\t\"%.0f\",(($cmdL->getDiskStartSector() * $secsize) / $cylsize)\n\t\t);\n\t} else {\n\t\t$this->{pStart} = $this->{pStopp};\n\t}\n\t$this->{pStopp} = $this->{pStart} + $cyls;\n\tif ($this->{pStopp} > $this->{pDiskCylinders}) {\n\t\t$this->{pStopp} = $this->{pDiskCylinders}\n\t}\n\treturn $cyls;\n}\n\n#==========================================\n# setStoragePartition\n#------------------------------------------\nsub setStoragePartition {\n\t# ...\n\t# creates the partition table on the given device\n\t# according to the command argument list\n\t# ---\n\tmy $this     = shift;\n\tmy $device   = shift;\n\tmy $cmdref   = shift;\n\tmy $tool     = $this->{ptool};\n\tmy $kiwi     = $this->{kiwi};\n\tmy $xml      = $this->{xml};\n\tmy $tmpdir   = $this->{tmpdir};\n\tmy @commands = @{$cmdref};\n\tmy $result;\n\tmy $status;\n\tmy $ignore;\n\tmy $action;\n\tmy $locator = new KIWILocator($kiwi);\n\tmy $parted_exec = $locator -> getExecPath(\"parted\");\n\tif (! defined $tool) {\n\t\t$tool = \"parted\";\n\t}\n\tSWITCH: for ($tool) {\n\t\t#==========================================\n\t\t# fdasd\n\t\t#------------------------------------------\n\t\t/^fdasd/  && do {\n\t\t\t$kiwi -> loginfo (\n\t\t\t\t\"FDASD input: $device [@commands]\"\n\t\t\t);\n\t\t\t$status = qxx (\"dd if=/dev/zero of=$device bs=4096 count=10 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> loginfo ($status);\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tif (! open (FD,\"|/sbin/fdasd $device &> $tmpdir/fdasd.log\")) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tprint FD \"y\\n\";\n\t\t\tforeach my $cmd (@commands) {\n\t\t\t\tif ($cmd =~ /[ntwq]$/) {\n\t\t\t\t\t$action = $cmd;\n\t\t\t\t}\n\t\t\t\tif (($ignore) && ($cmd =~ /[ntwq]$/)) {\n\t\t\t\t\tundef $ignore;\n\t\t\t\t} elsif ($ignore) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"a\") {\n\t\t\t\t\t$ignore=1;\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"p\") {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif (($cmd =~ /^[0-9]$/) && ($action ne \"t\")) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif (($cmd eq \"83\") || ($cmd eq \"8e\")) {\n\t\t\t\t\t$cmd = 1;\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"82\") {\n\t\t\t\t\t$cmd = 2;\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \".\") {\n\t\t\t\t\tprint FD \"\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tprint FD \"$cmd\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose FD;\n\t\t\t$result = $? >> 8;\n\t\t\tmy $flog;\n\t\t\tif (open (FD,\"$tmpdir/fdasd.log\")) {\n\t\t\t\tmy @flog = <FD>; close FD;\n\t\t\t\t$flog = join (\"\\n\",@flog);\n\t\t\t\t$kiwi -> loginfo (\"FDASD: $flog\");\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# parted\n\t\t#------------------------------------------\n\t\t/^parted/  && do {\n\t\t\tmy @p_cmd = ();\n\t\t\t$this -> resetCylinder();\n\t\t\tfor (my $count=0;$count<@commands;$count++) {\n\t\t\t\tmy $cmd = $commands[$count];\n\t\t\t\tif ($cmd eq \"n\") {\n\t\t\t\t\tmy $size = $commands[$count+4];\n\t\t\t\t\t$this -> initCylinders ($device,$size);\n\t\t\t\t\tpush (@p_cmd,\n\t\t\t\t\t\t\"mkpart primary $this->{pStart} $this->{pStopp}\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"t\") {\n\t\t\t\t\tmy $index= $commands[$count+1];\n\t\t\t\t\tmy $type = $commands[$count+2];\n\t\t\t\t\tpush (@p_cmd,\"set $index type 0x$type\");\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"a\") {\n\t\t\t\t\tmy $index= $commands[$count+1];\n\t\t\t\t\tpush (@p_cmd,\"set $index boot on\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t$kiwi -> loginfo (\n\t\t\t\t\"PARTED input: $device [@p_cmd]\\n\"\n\t\t\t);\n\t\t\tmy $align=\"\";\n\t\t\t$status = qxx (\"$parted_exec --help | grep -q align=\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result == 0) {\n\t\t\t\t$align=\"-a cyl\";\n\t\t\t}\n\t\t\tforeach my $p_cmd (@p_cmd) {\n\t\t\t\t$status= qxx (\n\t\t\t\t\t\"$parted_exec $align -s $device unit cyl $p_cmd 2>&1\"\n\t\t\t\t);\n\t\t\t\t$result= $? >> 8;\n\t\t\t\t$kiwi -> loginfo ($status);\n\t\t\t\tsleep (1);\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# getStorageID\n#------------------------------------------\nsub getStorageID {\n\t# ...\n\t# return the partition id of the given\n\t# partition. If the call fails the function\n\t# returns 0\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $partid = shift;\n\tmy $status = qxx (\"sfdisk --id $device $partid 2>&1\");\n\tmy $result = $? >> 8;\n\tif ($result == 0) {\n\t\tchomp  $status;\n\t\treturn $status;\n\t}\n\treturn 0;\n}\n\n#==========================================\n# getStorageSize\n#------------------------------------------\nsub getStorageSize {\n\t# ...\n\t# return the size of the given disk or disk\n\t# partition in Kb. If the call fails the function\n\t# returns 0\n\t# --- \n\tmy $this = shift;\n\tmy $pdev = shift;\n\tmy $status = qxx (\"blockdev --getsize64 $pdev 2>&1\");\n\tmy $result = $? >> 8;\n\tif ($result == 0) {\n\t\treturn int ($status / 1024);\n\t}\n\treturn 0;\n}\n\n#==========================================\n# setPPCDeviceMap\n#------------------------------------------\nsub setPPCDeviceMap {\n\t# ...\n\t# set default devuce map for PowerSystems\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $loader = $this->{bootloader};\n\tmy $dmapper= $this->{dmapper};\n\tmy $search = \"41\";\n\tmy %result;\n\tif (! defined $device) {\n\t\treturn undef;\n\t}\n\tfor (my $i=1;$i<=3;$i++) {\n\t\t$result{$i} = $device.$i;\n\t}\n\tif ($loader eq \"lilo\") {\n\t\tfor (my $i=1;$i<=2;$i++) {\n\t\t\tmy $type = $this -> getStorageID ($device,$i);\n\t\t\tif ($type = $search) {\n\t\t\t\t$result{prep} = $device.$i;\n\t\t\t}\n\t\t\tlast;\n\t\t}\n\t} elsif ($dmapper) {\n\t\t$result{dmapper} = $device.\"3\";\n\t}\n\treturn %result;\n}\n\n#==========================================\n# setDefaultDeviceMap\n#------------------------------------------\nsub setDefaultDeviceMap {\n\t# ...\n\t# set default device map which creates a mapping for\n\t# device names to a number\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $loader = $this->{bootloader};\n\tmy $dmapper= $this->{dmapper};\n\tmy %result;\n\tif (! defined $device) {\n\t\treturn undef;\n\t}\n\tfor (my $i=1;$i<=3;$i++) {\n\t\t$result{$i} = $device.$i;\n\t}\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\tmy $search = \"c\";\n\t\tif ($loader eq \"extlinux\" ) {\n\t\t\t$search = \"83\";\n\t\t}\n\t\tfor (my $i=3;$i>=1;$i--) {\n\t\t\tmy $type = $this -> getStorageID ($device,$i);\n\t\t\tif ($type eq $search) {\n\t\t\t\tif ($loader eq \"syslinux\" ) {\n\t\t\t\t\t$result{fat} = $device.$i;\n\t\t\t\t} else {\n\t\t\t\t\t$result{extlinux} = $device.$i;\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t} elsif ($dmapper) {\n\t\t$result{dmapper} = $device.\"3\";\n\t}\n\treturn %result;\n}\n\n#==========================================\n# setLoopDeviceMap\n#------------------------------------------\nsub setLoopDeviceMap {\n\t# ...\n\t# set loop device map which creates a mapping for\n\t# /dev/mapper loop device names to a number\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $loader = $this->{bootloader};\n\tmy $dmapper= $this->{dmapper};\n\tmy %result;\n\tif (! defined $device) {\n\t\treturn undef;\n\t}\n\tmy $dmap = $device; $dmap =~ s/dev\\///;\n\tfor (my $i=1;$i<=3;$i++) {\n\t\t$result{$i} = \"/dev/mapper\".$dmap.\"p$i\";\n\t}\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\tmy $search = \"c\";\n\t\tif ($loader eq \"extlinux\" ) {\n\t\t\t$search = \"83\";\n\t\t}\n\t\tfor (my $i=3;$i>=1;$i--) {\n\t\t\tmy $type = $this -> getStorageID ($device,$i);\n\t\t\tif (\"$type\" eq \"$search\") {\n\t\t\t\tif ($loader eq \"syslinux\") {\n\t\t\t\t\t$result{fat} = \"/dev/mapper\".$dmap.\"p$i\";\n\t\t\t\t} else {\n\t\t\t\t\t$result{extlinux} = \"/dev/mapper\".$dmap.\"p$i\";\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t} elsif ($dmapper) {\n\t\t$result{dmapper} = \"/dev/mapper\".$dmap.\"p3\";\n\t}\n\treturn %result;\n}\n\n#==========================================\n# setLVMDeviceMap\n#------------------------------------------\nsub setLVMDeviceMap {\n\t# ...\n\t# set LVM device map which creates a mapping for\n\t# /dev/VG/name volume group device names to a number\n\t# ---\n\tmy $this   = shift;\n\tmy $group  = shift;\n\tmy $device = shift;\n\tmy $names  = shift;\n\tmy @names  = @{$names};\n\tmy $arch   = $this->{arch};\n\tmy $loader = $this->{bootloader};\n\tmy $dmapper= $this->{dmapper};\n\tmy %result;\n\tif (! defined $group) {\n\t\treturn undef;\n\t}\n\tif ($device =~ /loop/) {\n\t\tmy $dmap = $device; $dmap =~ s/dev\\///;\n\t\t$result{0} = \"/dev/mapper\".$dmap.\"p1\";\n\t} else {\n\t\t$result{0} = $device.\"1\";\n\t}\n\tfor (my $i=0;$i<@names;$i++) {\n\t\t$result{$i+1} = \"/dev/$group/\".$names[$i];\n\t}\n\tif (($arch =~ /ppc|ppc64/) || ($loader =~ /(sys|ext)linux/)) {\n\t\tif ($device =~ /loop/) {\n\t\t\tmy $dmap = $device; $dmap =~ s/dev\\///;\n\t\t\tif (($arch =~ /ppc|ppc64/) || ($loader =~ /syslinux/)) {\n\t\t\t\t$result{fat} = \"/dev/mapper\".$dmap.\"p1\";\n\t\t\t} else {\n\t\t\t\t$result{extlinux} = \"/dev/mapper\".$dmap.\"p1\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ($loader eq \"syslinux\") {\n\t\t\t\t$result{fat} = $device.\"1\";\n\t\t\t} else {\n\t\t\t\t$result{extlinux} = $device.\"1\";\n\t\t\t}\n\t\t}\n\t} elsif ($dmapper) {\n\t\tif ($device =~ /loop/) {\n\t\t\tmy $dmap = $device; $dmap =~ s/dev\\///;\n\t\t\t$result{dmapper} = \"/dev/mapper\".$dmap.\"p1\";\n\t\t} else {\n\t\t\t$result{dmapper} = $device.\"1\";\n\t\t}\n\t}\n\treturn %result;\n}\n\n#==========================================\n# setVolumeGroup\n#------------------------------------------\nsub setVolumeGroup {\n\t# ...\n\t# create volume group and required logical \n\t# volumes. The function returns a new device map\n\t# including the volume device names\n\t# ---\n\tmy $this      = shift;\n\tmy $map       = shift;\n\tmy $device    = shift;\n\tmy $syszip    = shift;\n\tmy $haveSplit = shift;\n\tmy $parts     = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $system    = $this->{system};\n\tmy %deviceMap = %{$map};\n\tmy %lvmparts  = %{$parts};\n\tmy $VGroup    = $this->{lvmgroup};\n\tmy %newmap;\n\tmy $status;\n\tmy $result;\n\t$status = qxx (\"vgremove --force $VGroup 2>&1\");\n\t$status = qxx (\"test -d /dev/$VGroup && rm -rf /dev/$VGroup 2>&1\");\n\t$status = qxx (\"pvcreate $deviceMap{2} 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed creating physical extends: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$status = qxx (\"vgcreate $VGroup $deviceMap{2} 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed creating volume group: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\tif (($syszip) || ($haveSplit)) {\n\t\t$status = qxx (\"lvcreate -L $syszip -n LVComp $VGroup 2>&1\");\n\t\t$result = $? >> 8;\n\t\t$status.= qxx (\"lvcreate -l +100%FREE -n LVRoot $VGroup 2>&1\");\n\t\t$result+= $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Logical volume(s) setup failed: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t%newmap = $this -> setLVMDeviceMap (\n\t\t\t$VGroup,$device,[\"LVComp\",\"LVRoot\"]\n\t\t);\n\t} else {\n\t\tif (%lvmparts) {\n\t\t\tmy %ihash = ();\n\t\t\tforeach my $name (keys %lvmparts) {\n\t\t\t\tmy $pname  = $name; $pname =~ s/_/\\//g;\n\t\t\t\tmy $lvsize = $lvmparts{$name}->[2];\n\t\t\t\tmy $lvdev  = \"/dev/$VGroup/LV$name\";\n\t\t\t\t$ihash{$lvdev} = \"no-opts\";\n\t\t\t\t$status = qxx (\"lvcreate -L $lvsize -n LV$name $VGroup 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t\tif ($result != 0) {\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->{deviceinodes} = \\%ihash;\n\t\t}\n\t\tif ($result == 0) {\n\t\t\t$status = qxx (\"lvcreate -l +100%FREE -n LVRoot $VGroup 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Logical volume(s) setup failed: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t%newmap = $this -> setLVMDeviceMap (\n\t\t\t$VGroup,$device,[\"LVRoot\"]\n\t\t);\n\t}\n\treturn %newmap;\n}\n\n#==========================================\n# deleteVolumeGroup\n#------------------------------------------\nsub deleteVolumeGroup {\n\tmy $this   = shift;\n\tmy $lvm    = $this->{lvm};\n\tmy $VGroup = $this->{lvmgroup};\n\tif ($lvm) {\n\t\tqxx (\"vgremove --force $VGroup 2>&1\");\n\t\tqxx (\"test -d /dev/$VGroup && rm -rf /dev/$VGroup 2>&1\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# makeLabel\n#------------------------------------------\nsub makeLabel {\n\t# ...\n\t# grub handles spaces as \"_\", so we replace\n\t# each space with an underscore\n\t# ----\n\tmy $this = shift;\n\tmy $label = shift;\n\t$label =~ s/ /_/g;\n\treturn $label;\n}\n\n#==========================================\n# luksResize\n#------------------------------------------\nsub luksResize {\n\tmy $this   = shift;\n\tmy $source = shift;\n\tmy $name   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $cipher = $this->{gdata}->{LuksCipher};\n\tmy $status;\n\tmy $result;\n\tmy $hald;\n\t#==========================================\n\t# open luks device\n\t#------------------------------------------\n\tif ($cipher) {\n\t\t$status = qxx (\n\t\t\t\"echo $cipher | cryptsetup luksOpen $source $name 2>&1\"\n\t\t);\n\t} else {\n\t\t$status = qxx (\"cryptsetup luksOpen $source $name 2>&1\");\n\t}\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't open luks device: $status\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# resize luks header\n\t#------------------------------------------\n\t$this->{luks} = $name;\n\t$status = qxx (\"cryptsetup resize $name\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't resize luks device: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> luksClose();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# return mapped device name\n\t#------------------------------------------\n\treturn \"/dev/mapper/\".$name;\n}\n\n#==========================================\n# luksClose\n#------------------------------------------\nsub luksClose {\n\tmy $this = shift;\n\tif ($this->{luks}) {\n\t\tqxx (\"cryptsetup luksClose $this->{luks} 2>&1\");\n\t\tundef $this->{luks};\n\t}\n\treturn $this;\n}\n\n#==========================================\n# umountDevice\n#------------------------------------------\nsub umountDevice {\n\t# ...\n\t# umount all mounted filesystems from the given\n\t# storage device. The functions searches the \n\t# /proc/mounts table and umounts all corresponding\n\t# mount entries\n\t# ----\n\tmy $this = shift;\n\tmy $disk = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $MOUNTS;\n\tif (! defined $disk) {\n\t\t$kiwi -> loginfo (\"umountDevice: no disk prefix provided, skipped\");\n\t\treturn undef;\n\t}\n\tif (! open ($MOUNTS, '<', '/proc/mounts')) {\n\t\t$kiwi -> loginfo (\"umountDevice: failed to open proc/mounts: $!\");\n\t\treturn undef;\n\t}\n\tmy @mounts = <$MOUNTS>; close $MOUNTS;\n\tfor my $mount (@mounts) {\n\t\tif ($mount =~ /^$disk/) {\n\t\t\tmy ($device, $mountpoint, $rest) = split / /, $mount, 3;\n\t\t\tqxx (\"umount $device 2>&1\");\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# setupFilesystem\n#------------------------------------------\nsub setupFilesystem {\n\t# ...\n\t# create filesystem according to selected type\n\t# ----\n\tmy $this   = shift;\n\tmy $fstype = shift;\n\tmy $device = shift;\n\tmy $name   = shift;\n\tmy $inodes = $this->{deviceinodes};\n\tmy $kiwi   = $this->{kiwi};\n\tmy $xml    = $this->{xml};\n\tmy $cmdL   = $this->{cmdL};\n\tmy %type   = %{$xml->getImageTypeAndAttributes()};\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL -> getFilesystemOptions()}\n\t);\n\tmy $iorig  = $this->{inodes};\n\tmy $result;\n\tmy $status;\n\tif (($inodes) && ($inodes->{$device})) {\n\t\tif ($inodes->{$device} ne \"no-opts\") {\n\t\t\t$this->{inodes} = $inodes->{$device};\n\t\t} else {\n\t\t\tundef $this->{inodes};\n\t\t}\n\t}\n\tSWITCH: for ($fstype) {\n\t\t/^ext[234]/     && do {\n\t\t\t$kiwi -> info (\"Creating $_ $name filesystem\");\n\t\t\tmy $fsopts = $FSopts{$_};\n\t\t\tmy $fstool = \"mkfs.\".$fstype;\n\t\t\tif ($this->{inodes}) {\n\t\t\t\t$fsopts.= \" -N $this->{inodes}\";\n\t\t\t}\n\t\t\tmy $tuneopts = $type{fsnocheck} eq \"true\" ? \"-c 0 -i 0\" : \"\";\n\t\t\t$tuneopts = $FSopts{extfstune} if $FSopts{extfstune};\n\t\t\t$status = qxx (\"$fstool $fsopts $device 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif (!$result && $tuneopts) {\n\t\t\t\t$status .= qxx (\"/sbin/tune2fs $tuneopts $device 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^reiserfs/ && do {\n\t\t\t$kiwi -> info (\"Creating reiserfs $name filesystem\");\n\t\t\tmy $fsopts = $FSopts{reiserfs};\n\t\t\t$fsopts.= \"-f\";\n\t\t\t$status = qxx (\n\t\t\t\t\"/sbin/mkreiserfs $fsopts $device 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^btrfs/    && do {\n\t\t\t$kiwi -> info (\"Creating btrfs $name filesystem\");\n\t\t\tmy $fsopts = $FSopts{btrfs};\n\t\t\t$status = qxx (\n\t\t\t\t\"/sbin/mkfs.btrfs $fsopts $device 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^xfs/      && do {\n\t\t\t$kiwi -> info (\"Creating xfs $name filesystem\");\n\t\t\tmy $fsopts = $FSopts{xfs};\n\t\t\t$status = qxx (\n\t\t\t\t\"/sbin/mkfs.xfs $fsopts $device 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t$kiwi -> error  (\"Unsupported filesystem type: $fstype\");\n\t\t$kiwi -> failed ();\n\t\t$this->{inodes} = $iorig;\n\t\treturn undef;\n\t};\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create $fstype filesystem: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this->{inodes} = $iorig;\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t$this->{inodes} = $iorig;\n\treturn $this;\n}\n\n#==========================================\n# addBootNext\n#------------------------------------------\nsub addBootNext {\n\t# ...\n\t# Write boot program that boots the firsts drive that\n\t# does _not_ have our mbr id. The boot program source which\n\t# creates $bootnext below is added in the git repo below\n\t# tools/bootnext\n\t# ---\n\tmy $this = shift;\n\tmy $file = shift;\n\tmy $id   = shift;\n\tmy $bn;\n\tmy $bootnext =\n\t\t\"\\x8c\\xc8\\x8e\\xd0\\x31\\xe4\\x8e\\xd8\\x8e\\xc0\\xfc\\xfb\\xbe\\x00\\x7c\\xbf\" .\n\t\t\"\\x00\\x60\\xb9\\x00\\x01\\xf3\\xa5\\xea\\x1c\\x60\\x00\\x00\\xb4\\x08\\x31\\xff\" .\n\t\t\"\\xb2\\x80\\xcd\\x13\\x73\\x02\\xb2\\x01\\x80\\xfa\\x01\\xb0\\x80\\x10\\xc2\\x88\" .\n\t\t\"\\x16\\x29\\x61\\xa2\\x2a\\x61\\xe8\\x8b\\x00\\x73\\x10\\xa0\\x2a\\x61\\x40\\x3a\" .\n\t\t\"\\x06\\x29\\x61\\x72\\xee\\xbe\\x2d\\x61\\xe9\\xb3\\x00\\x80\\x3e\\x2a\\x61\\x80\" .\n\t\t\"\\x74\\x03\\xe8\\x07\\x00\\xb2\\x80\\xea\\x00\\x7c\\x00\\x00\\xa1\\x13\\x04\\x48\" .\n\t\t\"\\xa3\\x13\\x04\\xc1\\xe0\\x06\\x2d\\x00\\x06\\x66\\x8b\\x16\\x4c\\x00\\x66\\x89\" .\n\t\t\"\\x16\\x25\\x61\\x50\\x68\\x89\\x60\\x66\\x8f\\x06\\x4c\\x00\\x50\\x07\\xbe\\x00\" .\n\t\t\"\\x60\\x89\\xf7\\xb9\\x00\\x01\\xf3\\xa5\\xc3\\x9c\\x2e\\x88\\x16\\x2b\\x61\\x2e\" .\n\t\t\"\\x88\\x26\\x2c\\x61\\x2e\\x3a\\x16\\x2a\\x61\\x75\\x04\\xb2\\x80\\xeb\\x0a\\x80\" .\n\t\t\"\\xfa\\x80\\x75\\x05\\x2e\\x8a\\x16\\x2a\\x61\\x2e\\xff\\x1e\\x25\\x61\\x50\\x9f\" .\n\t\t\"\\x67\\x88\\x64\\x24\\x06\\x58\\x2e\\x80\\x3e\\x2c\\x61\\x08\\x74\\x05\\x2e\\x8a\" .\n\t\t\"\\x16\\x2b\\x61\\xcf\\xe8\\x10\\x00\\x72\\x0d\\x66\\xa1\\xb8\\x61\\x66\\x3b\\x06\" .\n\t\t\"\\xb8\\x7d\\xf9\\x74\\x01\\xf8\\xc3\\xb8\\x01\\x02\\xb9\\x01\\x00\\xb6\\x00\\x8a\" .\n\t\t\"\\x16\\x2a\\x61\\xbb\\x00\\x7c\\xcd\\x13\\x72\\x13\\x66\\x83\\x3e\\x00\\x7c\\x00\" .\n\t\t\"\\xf9\\x74\\x0a\\x81\\x3e\\xfe\\x7d\\x55\\xaa\\xf9\\x75\\x01\\xf8\\xc3\\xe8\\x15\" .\n\t\t\"\\x00\\xbe\\x44\\x61\\xe8\\x0f\\x00\\xb4\\x00\\xcd\\x16\\xbe\\x41\\x61\\xe8\\x05\" .\n\t\t\"\\x00\\xcd\\x19\\xf4\\xeb\\xfd\\xac\\x08\\xc0\\x74\\x09\\xbb\\x07\\x00\\xb4\\x0e\" .\n\t\t\"\\xcd\\x10\\xeb\\xf2\\xc3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x4e\\x6f\\x20\" .\n\t\t\"\\x6f\\x70\\x65\\x72\\x61\\x74\\x69\\x6e\\x67\\x20\\x73\\x79\\x73\\x74\\x65\\x6d\" .\n\t\t\"\\x2e\\x0d\\x0a\\x00\\x0a\\x50\\x72\\x65\\x73\\x73\\x20\\x61\\x20\\x6b\\x65\\x79\" .\n\t\t\"\\x20\\x74\\x6f\\x20\\x72\\x65\\x62\\x6f\\x6f\\x74\\x2e\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\xaa\";\n\n\t# we really need a valid id\n\treturn undef unless $id;\n\n\tsubstr $bootnext, 0x1b8, 4, pack(\"V\", $id);\n\n\topen $bn, \">$file\" or return undef;\n\tprint $bn $bootnext;\n\tclose $bn;\n\n\treturn $this;\n}\n\n#==========================================\n# diskOffset\n#------------------------------------------\nsub diskOffset {\n\t# ...\n\t# find the offset to the start of the first partition\n\t# ---\n\tmy $this = shift;\n\tmy $disk = shift;\n\tmy $offset;\n\tmy @table = qx (parted -m $disk unit s print 2>&1);\n\tchomp @table;\n\tforeach my $entry (@table) {\n\t\tif ($entry =~ /^[1-4]:/) {\n\t\t\tmy @items = split (/:/,$entry);\n\t\t\t$offset = $items[1];\n\t\t\tchop $offset;\n\t\t\tlast;\n\t\t}\n\t}\n\tif (! $offset) {\n\t\treturn undef;\n\t}\n\treturn $offset;\n}\n\n#==========================================\n# searchUSBStickDevice\n#------------------------------------------\nsub searchUSBStickDevice {\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $device = $this->{device};\n\tmy $stick;\n\t#==========================================\n\t# Find USB stick devices\n\t#------------------------------------------\n\tmy %storage = $this -> getRemovableUSBStorageDevices();\n\tif (! %storage) {\n\t\t$kiwi -> error  (\"Couldn't find any removable USB storage devices\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $prefix = $kiwi -> getPrefix (1);\n\tprint STDERR $prefix,\"Found following removable USB devices:\\n\";\n\tforeach my $dev (keys %storage) {\n\t\tprint STDERR $prefix,\"---> $storage{$dev} at $dev\\n\";\n\t}\n\tif (! defined $device) {\n\t\t#==========================================\n\t\t# Let the user select the device\n\t\t#------------------------------------------\n\t\twhile (1) {\n\t\t\t$prefix = $kiwi -> getPrefix (1);\n\t\t\tprint STDERR $prefix,\"Your choice (enter device name): \";\n\t\t\tchomp ($stick = <>);\n\t\t\tmy $found = 0;\n\t\t\tforeach my $dev (keys %storage) {\n\t\t\t\tif ($dev eq $stick) {\n\t\t\t\t\t$found = 1; last;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! $found) {\n\t\t\t\tif ($stick) {\n\t\t\t\t\tprint STDERR $prefix,\"Couldn't find [ $stick ] in list\\n\";\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tlast;\n\t\t}\n\t} else {\n\t\t#==========================================\n\t\t# Check the given device\n\t\t#------------------------------------------\n\t\t$stick = $device;\n\t\tmy $found = 0;\n\t\tforeach my $dev (keys %storage) {\n\t\t\tif ($dev eq $stick) {\n\t\t\t\t$found = 1; last;\n\t\t\t}\n\t\t}\n\t\tif (! $found) {\n\t\t\tprint STDERR $prefix,\"Couldn't find [ $stick ] in list\\n\";\n\t\t\treturn undef;\n\t\t}\n\t}\n\treturn $stick;\n}\n\n#==========================================\n# Destructor\n#------------------------------------------\nsub DESTROY {\n\tmy $this = shift;\n\tmy $dirs = $this->{tmpdirs};\n\tforeach my $dir (@{$dirs}) {\n\t\tqxx (\"rm -rf $dir 2>&1\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# Private methods\n#------------------------------------------\n#==========================================\n# getBootSize\n#------------------------------------------\nsub __getBootSize {\n\t# ...\n\t# calculate required size of /boot. This is\n\t# needed if we have a separate boot partition\n\t# The function returns the size in M-Bytes\n\t# ---\n\tmy $this   = shift;\n\tmy $extend = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $boot   = $extend.\"/boot\";\n\tmy $bbytes = qxx (\"du -s --block-size=1 $boot | cut -f1\"); chomp $bbytes;\n\t# 3 times the size should be enough for kernel updates\n\tmy $gotMB  = sprintf (\"%.0f\",(($bbytes / 1048576) * 3));\n\tmy $minMB  = 150;\n\tif ($gotMB < $minMB) {\n\t\t$gotMB = $minMB;\n\t}\n\t$kiwi -> loginfo (\"Set boot space to: \".$gotMB.\"M\\n\");\n\treturn $gotMB;\n}\n\n#==========================================\n# __expandFS\n#------------------------------------------\nsub __expandFS {\n\t# ...\n\t# Expand the file system to its maximum size\n\t# ---\n\tmy $this      = shift;\n\tmy $fsType    = shift;\n\tmy $diskType  = shift;\n\tmy $mapper    = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $locator   = new KIWILocator($kiwi);\n\tmy $result    = 1;\n\tmy $status;\n\t$kiwi->loginfo (\"Resize Operation: Device: $mapper\\n\");\n\t$kiwi->loginfo (\"Resize Operation: Image Disk Type: $diskType\\n\");\n\t$kiwi->loginfo (\"Resize Operation: Filesystem Type: $fsType\\n\");\n\tSWITCH: for ($fsType) {\n\t\t/^ext\\d/    && do {\n\t\t\t$kiwi -> info (\"Resizing $diskType $fsType filesystem\");\n\t\t\tmy $resize = $locator -> getExecPath ('resize2fs');\n\t\t\tif (! $resize) {\n\t\t\t\t$kiwi -> error ('Could not locate resize2fs');\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$status = qxx (\"$resize -f -F -p $mapper 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^reiserfs/ && do {\n\t\t\t$kiwi -> info (\"Resizing $diskType $fsType filesystem\");\n\t\t\tmy $resize = $locator -> getExecPath ('resize_reiserfs');\n\t\t\tif (! $resize) {\n\t\t\t\t$kiwi -> error ('Could not locate resize_reiserfs');\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$status = qxx (\"$resize $mapper 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^btrfs/    && do {\n\t\t\t$kiwi -> info (\"Resizing $diskType $fsType filesystem\");\n\t\t\tmy $bfsctl = $locator -> getExecPath('btrfsctl');\n\t\t\tif (! $bfsctl) {\n\t\t\t\t$kiwi -> error ('Could not locate btrfsctl');\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tmy $bctl = \"$bfsctl -r max /mnt\";\n\t\t\t$status = qxx (\"\n\t\t\t\t\tmount $mapper /mnt && $bctl; umount /mnt 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^xfs/      && do {\n\t\t\t$kiwi -> info (\"Resizing $diskType $fsType filesystem\");\n\t\t\tmy $xfsGrow = $locator -> getExecPath('xfs_growfs');\n\t\t\tif (! $xfsGrow) {\n\t\t\t\t$kiwi -> error ('Could not locate xfs_grow');\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$status = qxx (\"\n\t\t\t\t\tmount $mapper /mnt && $xfsGrow /mnt; umount /mnt 2>&1\"\n\t\t\t );\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t$kiwi->loginfo (\"Resize Operation: no resize\\n\");\n\t\t$result = 0;\n\t};\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't resize $fsType filesystem $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> luksClose();\n\t\treturn undef;\n\t}\n\t$this -> luksClose();\n\tif ($status) {\n\t\t$kiwi -> done();\n\t}\n\treturn $this;\n}\n\n#==========================================\n# __initDiskSize\n#------------------------------------------\nsub __initDiskSize {\n\t# ...\n\t# setup initial disk size value\n\t# ---\n\tmy $this      = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $minBytes  = shift;\n\tmy $cmdlsize  = shift;\n\tmy $XMLBytes  = shift;\n\tmy $cmdlBytes = 0;\n\tmy $vmsize    = 0;\n\tmy $vmmbyte   = 0;\n\t#===========================================\n\t# turn optional size from cmdline into bytes\n\t#-------------------------------------------\n\tif ($cmdlsize =~ /^(\\d+)([MG])$/i) {\n\t\tmy $value= $1;\n\t\tmy $unit = $2;\n\t\tif ($unit eq \"G\") {\n\t\t\t# convert GB to MB...\n\t\t\t$value *= 1024;\n\t\t}\n\t\t# convert MB to Byte\n\t\t$cmdlBytes = $value * 1048576;\n\t}\n\t#===========================================\n\t# adapt min size according to cmdline or XML\n\t#-------------------------------------------\n\tif ($cmdlBytes > 0) {\n\t\tif ($cmdlBytes < $minBytes) {\n\t\t\t$kiwi -> warning (\n\t\t\t\t\"given size is smaller than calculated min size\"\n\t\t\t);\n\t\t\t$kiwi -> oops();\n\t\t}\n\t\t$minBytes = $cmdlBytes;\n\t} elsif ($XMLBytes > 0) {\n\t\tif ($XMLBytes < $minBytes) {\n\t\t\t$kiwi -> warning (\n\t\t\t\t\"given size is smaller than calculated min size\"\n\t\t\t);\n\t\t\t$kiwi -> oops();\n\t\t}\n\t\t$minBytes = $XMLBytes;\n\t}\n\t#==========================================\n\t# Create vmsize MB string and vmmbyte value\n\t#------------------------------------------\n\t$vmsize  = $minBytes / 1048576;\n\t$vmsize  = sprintf (\"%.0f\", $vmsize);\n\t$vmmbyte = $vmsize;\n\t$vmsize  = $vmsize.\"M\";\n\t$kiwi -> loginfo (\n\t\t\"Starting with disk size: $vmsize\\n\"\n\t);\n\t$this->{vmmbyte} = $vmmbyte;\n\t$this->{vmsize}  = $vmsize;\n\treturn $this;\n}\n\n#==========================================\n# __updateDiskSize\n#------------------------------------------\nsub __updateDiskSize {\n\t# ...\n\t# increase the current virtual disk size value\n\t# by the specified value. value is treated as\n\t# number in MB\n\t# ---\n\tmy $this   = shift;\n\tmy $addMB  = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $vmsize = $this->{vmmbyte} + $addMB;\n\t$vmsize = sprintf (\"%.0f\", $vmsize);\n\t$this->{vmmbyte} = $vmsize;\n\t$vmsize = $vmsize.\"M\";\n\t$this->{vmsize}  = $vmsize;\n\t$kiwi->loginfo (\n\t\t\"Increasing disk size by \".$addMB.\"M to: \".$vmsize.\"\\n\"\n\t);\n\treturn $this;\n}\n\n#==========================================\n# __getPartID\n#------------------------------------------\nsub __getPartID {\n\t# ...\n\t# try to find the partition number which references\n\t# the provided flag like \"boot\" or \"lvm\"\n\t# ---\n\tmy $this = shift;\n\tmy $disk = shift;\n\tmy $flag = shift;\n\tmy $fd   = new FileHandle;\n\tif ($fd -> open (\"parted -m $disk print | cut -f1,7 -d:|\")) {\n\t\twhile (my $line = <$fd>) {\n\t\t\tif ($line =~ /^(\\d):[ ,]*$flag/) {\n\t\t\t\treturn $1;\n\t\t\t}\n\t\t}\n\t\t$fd -> close();\n\t}\n\treturn 0;\n}\n\n1;\n", "#================\n# FILE          : KIWIImage.pm\n#----------------\n# PROJECT       : OpenSUSE Build-Service\n# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany\n#               :\n# AUTHOR        : Marcus Schaefer <ms@suse.de>\n#               :\n# BELONGS TO    : Operating System images\n#               :\n# DESCRIPTION   : This module is used to create a logical\n#               : extend, an image file based on a Linux\n#               : filesystem\n#               :\n# STATUS        : Development\n#----------------\npackage KIWIImage;\n#==========================================\n# Modules\n#------------------------------------------\nuse strict;\nuse Carp qw (cluck);\nuse Fcntl ':mode';\nuse File::Basename;\nuse File::Find qw(find);\nuse File::stat;\nuse Math::BigFloat;\nuse POSIX qw(getcwd);\n\n#==========================================\n# KIWI Modules\n#------------------------------------------\nuse KIWIBoot;\nuse KIWICommandLine;\nuse KIWIImageCreator;\nuse KIWIIsoLinux;\nuse KIWILog;\nuse KIWIQX;\nuse KIWIXML;\n\n#==========================================\n# Constructor\n#------------------------------------------\nsub new {\n\t# ...\n\t# Create a new KIWIImage object which is used to create\n\t# the different output image formats from a previosly\n\t# prepared physical extend\n\t# ---\n\t#==========================================\n\t# Object setup\n\t#------------------------------------------\n\tmy $this  = {};\n\tmy $class = shift;\n\tbless $this,$class;\n\t#==========================================\n\t# Module Parameters\n\t#------------------------------------------\n\tmy $kiwi       = shift;\n\tmy $xml        = shift;\n\tmy $imageTree  = shift;\n\tmy $imageDest  = shift;\n\tmy $imageStrip = shift;\n\tmy $baseSystem = shift;\n\tmy $imageOrig  = shift;\n\tmy $initCache  = shift;\n\tmy $cmdL       = shift;\n\tmy $configFile = $xml -> getConfigName();\n\t#==========================================\n\t# Use absolute path for image destination\n\t#------------------------------------------\n\tif ($imageDest !~ /^\\//) {\n\t\tmy $pwd = getcwd();\n\t\t$imageDest = $pwd.\"/\".$imageDest;\n\t}\n\t#==========================================\n\t# Constructor setup\n\t#------------------------------------------\n\tif (! defined $kiwi) {\n\t\t$kiwi = new KIWILog(\"tiny\");\n\t}\n\tif (! defined $cmdL) {\n\t\t$kiwi -> error (\"No Commandline reference specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $xml) {\n\t\t$kiwi -> error (\"No XML reference specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $baseSystem) {\n\t\t$kiwi -> error (\"No base system path specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $imageTree) {\n\t\t$kiwi -> error  (\"No image tree specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! -f $configFile) {\n\t\t$kiwi -> error  (\"Validation of $imageTree failed\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! -d $imageDest) {\n\t\t$kiwi -> error  (\"No valid destdir: $imageDest\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! $main::global) {\n\t\t$kiwi -> error  (\"Globals object not found\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! $cmdL -> getLogFile()) {\n\t\t$imageTree =~ s/\\/$//;\n\t\tif (defined $imageOrig) {\n\t\t\t$kiwi -> setRootLog ($imageOrig.\".\".$$.\".screenrc.log\");\n\t\t} else {\n\t\t\t$kiwi -> setRootLog ($imageTree.\".\".$$.\".screenrc.log\");\n\t\t}\n\t}\n\tmy $arch = qxx (\"uname -m\"); chomp ( $arch );\n\t$arch = \".$arch\";\n\t#==========================================\n\t# Store object data\n\t#------------------------------------------\n\t$this->{kiwi}       = $kiwi;\n\t$this->{cmdL}       = $cmdL;\n\t$this->{initCache}  = $initCache;\n\t$this->{xml}        = $xml;\n\t$this->{imageTree}  = $imageTree;\n\t$this->{imageDest}  = $imageDest;\n\t$this->{imageStrip} = $imageStrip;\n\t$this->{baseSystem} = $baseSystem;\n\t$this->{arch}       = $arch;\n\t$this->{gdata}      = $main::global -> getGlobals();\n\t#==========================================\n\t# Mount overlay tree if required...\n\t#------------------------------------------\n\t$this -> setupOverlay();\n\t#==========================================\n\t# Store a disk label ID for this object\n\t#------------------------------------------\n\t$this->{mbrid} = $main::global -> getMBRDiskLabel (\n\t\t$cmdL -> getMBRID()\n\t);\n\t#==========================================\n\t# Clean kernel mounts if any\n\t#------------------------------------------\n\t$this -> cleanKernelFSMount();\n\treturn $this;\n}\n\n#==========================================\n# getImageTree\n#------------------------------------------\nsub getImageTree {\n\t# ...\n\t# return current value of system image tree. Normally\n\t# this is the same as given in the module parameter list\n\t# but in case of an overlay cache mount the path changes\n\t# ---\n\tmy $this = shift;\n\treturn $this->{imageTree}\n}\n\n#==========================================\n# updateDescription\n#------------------------------------------\nsub updateDescription {\n\t# ...\n\t# Create change set hash from the given XML object\n\t# to be integrated into another XML object at a later\n\t# point in the process.\n\t# ---\n\tmy $this      = shift;\n\tmy $src_xml   = shift;\n\tmy %src_type  = %{$src_xml->getImageTypeAndAttributes()};\n\tmy %changeset = ();\n\tmy @profiles;\n\tmy %repos;\n\tmy @plist;\n\tmy @alist;\n\tmy @falistImage;\n\tmy @fplistImage;\n\tmy @fplistDelete;\n\tmy @driverList;\n\tmy %fixedBootInclude;\n\tmy @node;\n\t#==========================================\n\t# Store general data\n\t#------------------------------------------\n\tif ($src_type{hybrid}) {\n\t\t$changeset{\"hybrid\"}= $src_type{hybrid};\n\t}\n\tif ($src_type{hybridpersistent}) {\n\t\t$changeset{\"hybridpersistent\"} = $src_type{hybridpersistent};\n\t}\n\tif ($src_type{ramonly}) {\n\t\t$changeset{\"ramonly\"} = $src_type{ramonly};\n\t}\n\tif ($src_type{cmdline}) {\n\t\t$changeset{\"kernelcmdline\"} = $src_type{cmdline};\n\t}\n\tif ($src_type{lvm}) {\n\t\t$changeset{\"lvm\"} = $src_type{lvm};\n\t}\n\tif ($src_type{bootloader}) {\n\t\t$changeset{\"bootloader\"} = $src_type{bootloader};\n\t}\n\tif ($src_type{installboot}) {\n\t\t$changeset{\"installboot\"} = $src_type{installboot};\n\t}\n\tif ($src_type{bootprofile}) {\n\t\t$changeset{\"bootprofile\"} = $src_type{bootprofile};\n\t}\n\tif ($src_type{bootkernel}) {\n\t\t$changeset{\"bootkernel\"} = $src_type{bootkernel};\n\t}\n\tif ($src_xml->{reqProfiles}) {\n\t\tpush @profiles,@{$src_xml->{reqProfiles}};\n\t\t$changeset{\"profiles\"} = \\@profiles;\n\t}\n\t#==========================================\n\t# Store general data\n\t#------------------------------------------\n\t$changeset{\"packagemanager\"} = $src_xml->getPackageManager();\n\t$changeset{\"showlicense\"}    = $src_xml->getLicenseNames();\n\t$changeset{\"domain\"}         = $src_xml->getXenDomain();\n\t$changeset{\"displayname\"}    = $src_xml->getImageDisplayName();\n\t$changeset{\"locale\"}         = $src_xml->getLocale();\n\t$changeset{\"boot-theme\"}     = $src_xml->getBootTheme();\n\t$changeset{\"allFreeVolume\"}  = $src_xml->getAllFreeVolume();\n\t#==========================================\n\t# Store repositories\n\t#------------------------------------------\n\t@node = $src_xml->getNodeList() -> get_nodelist();\n\tforeach my $element (@node) {\n\t\tif (! $src_xml -> __requestedProfile ($element)) {\n\t\t\tnext;\n\t\t}\n\t\tmy $type  = $element -> getAttribute(\"type\");\n\t\tmy $alias = $element -> getAttribute(\"alias\");\n\t\tmy $prio  = $element -> getAttribute(\"priority\");\n\t\tmy $user  = $element -> getAttribute(\"username\");\n\t\tmy $pwd   = $element -> getAttribute(\"password\");\n\t\tmy $source= $element -> getElementsByTagName(\"source\")\n\t\t\t-> get_node(1) -> getAttribute (\"path\");\n\t\t$repos{$source} = [$type,$alias,$prio,$user,$pwd];\n\t}\n\t$changeset{\"repositories\"} = \\%repos;\n\t#==========================================\n\t# Store drivers section if any\n\t#------------------------------------------\n\t@node = $src_xml->getDriversNodeList() -> get_nodelist();\n\tforeach my $element (@node) {\n\t\tif (! $src_xml -> __requestedProfile ($element)) {\n\t\t\tnext;\n\t\t}\n\t\tmy @files = $element->getElementsByTagName (\"file\");\n\t\tforeach my $element (@files) {\n\t\t\tmy $driver = $element -> getAttribute (\"name\");\n\t\t\tpush (@driverList,$driver);\n\t\t}\n\t}\n\t$changeset{\"driverList\"} = \\@driverList;\n\t#==========================================\n\t# Store boot included packages\n\t#------------------------------------------\n\t@node = $src_xml->getPackageNodeList() -> get_nodelist();\n\tforeach my $element (@node) {\n\t\tif (! $src_xml -> __requestedProfile ($element)) {\n\t\t\tnext;\n\t\t}\n\t\tmy $type = $element  -> getAttribute (\"type\");\n\t\tif (($type eq \"image\") || ($type eq \"bootstrap\")) {\n\t\t\tpush (@plist,$element->getElementsByTagName (\"package\"));\n\t\t\tpush (@alist,$element->getElementsByTagName (\"archive\"));\n\t\t}\n\t}\n\tforeach my $element (@plist) {\n\t\tmy $package = $element -> getAttribute (\"name\");\n\t\tmy $bootinc = $element -> getAttribute (\"bootinclude\");\n\t\tmy $bootdel = $element -> getAttribute (\"bootdelete\");\n\t\tmy $include = 0;\n\t\tif ((defined $bootinc) && (\"$bootinc\" eq \"true\")) {\n\t\t\tpush (@fplistImage,$package);\n\t\t\t$include++;\n\t\t}\n\t\tif ((defined $bootdel) && (\"$bootdel\" eq \"true\")) {\n\t\t\tpush (@fplistDelete,$package);\n\t\t\t$include--;\n\t\t}\n\t\t$fixedBootInclude{$package} = $include;\n\t}\n\tforeach my $element (@alist) {\n\t\tmy $archive = $element -> getAttribute (\"name\");\n\t\tmy $bootinc = $element -> getAttribute (\"bootinclude\");\n\t\tif ((defined $bootinc) && (\"$bootinc\" eq \"true\")) {\n\t\t\tpush (@falistImage,$archive);\n\t\t}\n\t}\n\t$changeset{\"fixedBootInclude\"} = \\%fixedBootInclude;\n\t$changeset{\"falistImage\"}  = \\@falistImage;\n\t$changeset{\"fplistImage\"}  = \\@fplistImage;\n\t$changeset{\"fplistDelete\"} = \\@fplistDelete;\n\t#==========================================\n\t# Store OEM data\n\t#------------------------------------------\n\t$changeset{\"oem-partition-install\"}    = $src_xml->getOEMPartitionInstall();\n\t$changeset{\"oem-swap\"}                 = $src_xml->getOEMSwap();\n\t$changeset{\"oem-align-partition\"}      = $src_xml->getOEMAlignPartition();\n\t$changeset{\"oem-swapsize\"}             = $src_xml->getOEMSwapSize();\n\t$changeset{\"oem-systemsize\"}           = $src_xml->getOEMSystemSize();\n\t$changeset{\"oem-boot-title\"}           = $src_xml->getOEMBootTitle();\n\t$changeset{\"oem-kiwi-initrd\"}          = $src_xml->getOEMKiwiInitrd();\n\t$changeset{\"oem-reboot\"}               = $src_xml->getOEMReboot();\n\t$changeset{\"oem-reboot-interactive\"}   = $src_xml->getOEMRebootInter();\n\t$changeset{\"oem-silent-boot\"}          = $src_xml->getOEMSilentBoot();\n\t$changeset{\"oem-shutdown\"}             = $src_xml->getOEMShutdown();\n\t$changeset{\"oem-shutdown-interactive\"} = $src_xml->getOEMShutdownInter();\n\t$changeset{\"oem-bootwait\"}             = $src_xml->getOEMBootWait();\n\t$changeset{\"oem-unattended\"}           = $src_xml->getOEMUnattended();\n\t$changeset{\"oem-recovery\"}             = $src_xml->getOEMRecovery();\n\t$changeset{\"oem-recoveryID\"}           = $src_xml->getOEMRecoveryID();\n\t$changeset{\"oem-inplace-recovery\"}     = $src_xml->getOEMRecoveryInPlace();\n\t#==========================================\n\t# Return changeset hash\n\t#------------------------------------------\n\treturn %changeset;\n}\n\n#==========================================\n# checkAndSetupPrebuiltBootImage\n#------------------------------------------\nsub checkAndSetupPrebuiltBootImage {\n\t# ...\n\t# check the xml if a prebuild boot image was requested.\n\t# if yes check if that boot image exists and if yes\n\t# copy it to the destination directory for this build\n\t# ---\n\tmy $this = shift;\n\tmy $ixml = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $cmdL = $this->{cmdL};\n\tmy $idest= $cmdL->getImageTargetDir();\n\tmy %type = %{$ixml->getImageTypeAndAttributes()};\n\tmy $pblt = $type{checkprebuilt};\n\tmy $boot = $type{boot};\n\tmy $ok   = 0;\n\tmy $bootpath = $boot;\n\tif (($boot !~ /^\\//) && (! -d $boot)) {\n\t\t$bootpath = $this->{gdata}->{System}.\"/\".$boot;\n\t}\n\t#==========================================\n\t# open boot image XML object\n\t#------------------------------------------\n\tmy $locator = new KIWILocator($kiwi);\n\tmy $controlFile = $locator -> getControlFile ($bootpath);\n\tif (! $controlFile) {\n\t\treturn undef;\n\t}\n\tmy $validator = new KIWIXMLValidator (\n\t\t$kiwi,$controlFile,\n\t\t$this->{gdata}->{Revision},\n\t\t$this->{gdata}->{Schema},\n\t\t$this->{gdata}->{SchemaCVT}\n\t);\n\tmy $isValid = $validator ? $validator -> validate() : undef;\n\tif (! $isValid) {\n\t\treturn undef;\n\t}\n\tmy $bxml = new KIWIXML ( $kiwi,$bootpath,undef,undef,$cmdL );\n\tif (! $bxml) {\n\t\treturn undef;\n\t}\n\tmy $bootImageName = $bxml -> buildImageName();\n\tundef $bxml;\n\t$kiwi -> info (\"Checking for pre-built boot image\");\n\t#==========================================\n\t# is it requested...\n\t#------------------------------------------\n\tif ((! $pblt) || ($pblt eq \"false\")) {\n\t\t$kiwi -> notset();\n\t\treturn ($bootImageName,0);\n\t}\n\t#==========================================\n\t# check path names for boot image\n\t#------------------------------------------\n\tmy $lookup = $bootpath.\"-prebuilt/\";\n\tmy $prebuiltPath = $cmdL -> getPrebuiltBootImagePath();\n\tif (defined $prebuiltPath) {\n\t\t$lookup = $prebuiltPath.\"/\";\n\t}\n\tmy $pinitrd = $lookup.$bootImageName.\".gz\";\n\tmy $psplash;\n\tif (-f $lookup.$bootImageName.\".splash.gz\") {\n\t\t$psplash = $lookup.$bootImageName.\".splash.gz\";\n\t}\n\tmy $plinux  = $lookup.$bootImageName.\".kernel\";\n\tif (! -f $pinitrd) {\n\t\t$pinitrd = $lookup.$bootImageName;\n\t}\n\tif ((! -f $pinitrd) || (! -f $plinux)) {\n\t\t$kiwi -> skipped();\n\t\t$kiwi -> info (\"Can't find pre-built boot image in $lookup\");\n\t\t$kiwi -> skipped();\n\t\t$ok = 0;\n\t} else {\n\t\t$kiwi -> done();\n\t\t$kiwi -> info (\"Copying pre-built boot image to destination\");\n\t\tmy $lookup = basename $pinitrd;\n\t\tif (-f \"$idest/$lookup\") {\n\t\t\t#==========================================\n\t\t\t# Already exists in destination dir\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> done();\n\t\t\t$ok = 1;\n\t\t} else {\n\t\t\t#==========================================\n\t\t\t# Needs to be copied...\n\t\t\t#------------------------------------------\n\t\t\tif ($psplash) {\n\t\t\t\tqxx (\"cp -a $psplash $idest 2>&1\");\n\t\t\t}\n\t\t\tmy $data = qxx (\"cp -a $pinitrd $idest 2>&1\");\n\t\t\tmy $code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> failed();\n\t\t\t\t$kiwi -> error (\"Can't copy pre-built initrd: $data\");\n\t\t\t\t$kiwi -> failed();\n\t\t\t\t$ok = 0;\n\t\t\t} else {\n\t\t\t\t$data = qxx (\"cp -a $plinux* $idest 2>&1\");\n\t\t\t\t$code = $? >> 8;\n\t\t\t\tif ($code != 0) {\n\t\t\t\t\t$kiwi -> failed();\n\t\t\t\t\t$kiwi -> error (\"Can't copy pre-built kernel: $data\");\n\t\t\t\t\t$kiwi -> failed();\n\t\t\t\t\t$ok = 0;\n\t\t\t\t} else {\n\t\t\t\t\t$kiwi -> done();\n\t\t\t\t\t$ok = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# setup return for ok\n\t#------------------------------------------\n\tif (! $ok) {\n\t\treturn ($bootImageName,0);\n\t}\n\treturn ($bootImageName,1);\n}\n\n#==========================================\n# setupOverlay\n#------------------------------------------\nsub setupOverlay {\n\t# ...\n\t# mount the image cache if the image is based on it\n\t# and register the overlay mount point as new imageTree\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $tree = $this->{imageTree};\n\tmy $xml  = $this->{xml};\n\t$this->{overlay} = new KIWIOverlay ($kiwi,$tree);\n\tif (! $this->{overlay}) {\n\t\treturn undef;\n\t}\n\t$this->{imageTree} = $this->{overlay} -> mountOverlay();\n\tif (! defined $this->{imageTree}) {\n\t\treturn undef;\n\t}\n\t$xml -> writeXMLDescription ($this->{imageTree});\n\treturn $this;\n}\n\n#==========================================\n# stripImage\n#------------------------------------------\nsub stripImage {\n\t# ...\n\t# remove symbols from shared objects and binaries\n\t# using strip -p\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $imageTree = $this->{imageTree};\n\t$kiwi -> info (\"Stripping shared objects/executables...\");\n\tmy @list = qxx (\"find $imageTree -type f -perm -755\");\n\tforeach my $file (@list) {\n\t\tchomp $file;\n\t\tmy $data = qxx (\"file \\\"$file\\\"\");\n\t\tchomp $data;\n\t\tif ($data =~ /not stripped/) {\n\t\tif ($data =~ /shared object/) {\n\t\t\tqxx (\"strip -p $file 2>&1\");\n\t\t}\n\t\tif ($data =~ /executable/) {\n\t\t\tqxx (\"strip -p $file 2>&1\");\n\t\t}\n\t\t}\n\t}\n\t$kiwi -> done ();\n\treturn $this;\n}\n\n#==========================================\n# createImageClicFS\n#------------------------------------------\nsub createImageClicFS {\n\t# ...\n\t# create compressed loop image container\n\t# ---\n\tmy $this    = shift;\n\tmy $rename  = shift;\n\tmy $journal = \"journaled-ext3\";\n\tmy $kiwi    = $this->{kiwi};\n\tmy $data;\n\tmy $code;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ();\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\tif (defined $rename) {\n\t\t$data = qxx (\n\t\t\t\"mv $this->{imageDest}/$name $this->{imageDest}/$rename 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"Can't rename image file\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  ($data);\n\t\t\treturn undef;\n\t\t}\n\t\t$name = $rename;\n\t}\n\t#==========================================\n\t# Create ext3 filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupEXT2 ( $name,$journal )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name,\"nozip\",\"clicfs\")) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Rename filesystem loop file\n\t#------------------------------------------\n\t$data = qxx (\n\t\t\"mv $this->{imageDest}/$name $this->{imageDest}/fsdata.ext3 2>&1\"\n\t);\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Can't move file to fsdata.ext3\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t#==========================================  \n\t# Resize to minimum  \n\t#------------------------------------------\n\tmy $rver= qxx (\n\t\t\"resize2fs --version 2>&1 | head -n 1 | cut -f2 -d ' ' | cut -f1-2 -d.\"\n\t); chomp $rver;\n\tmy $dfs = \"/sbin/debugfs\";\n\tmy $req = \"-R 'show_super_stats -h'\";\n\tmy $bcn = \"'^Block count:'\";\n\tmy $bfr = \"'^Free blocks:'\";\n\tmy $src = \"$this->{imageDest}/fsdata.ext3\";\n\tmy $blocks = 0;\n\t$kiwi -> loginfo (\"Using resize2fs version: $rver\\n\");\n\tif ($rver >= 1.41) {\n\t\t$data = qxx (\n\t\t\t\"resize2fs $this->{imageDest}/fsdata.ext3 -M 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"Failed to resize ext3 container: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t} else {\n\t\t$data = qxx (\n\t\t\t\"$dfs $req $src 2>/dev/null | grep $bcn | sed -e 's,.*: *,,'\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"debugfs: block count request failed: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tchomp $data;\n\t\t$blocks = $data;  \n\t\t$data = qxx (\n\t\t\t\"$dfs $req $src 2>/dev/null | grep $bfr | sed -e 's,.*: *,,'\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"debugfs: free blocks request failed: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}  \n\t\t$kiwi -> info (\"clicfs: blocks count=$blocks free=$data\");\n\t\t$blocks = $blocks - $data;  \n\t\t$data = qxx (\n\t\t\t\"resize2fs $this->{imageDest}/fsdata.ext3 $blocks 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"Failed to resize ext3 container: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Create clicfs filesystem from ext3\n\t#------------------------------------------\n\t$kiwi -> info (\n\t\t\"Creating clicfs container: $this->{imageDest}/$name.clicfs\"\n\t);\n\tmy $clicfs = \"mkclicfs\";\n\tif (defined $ENV{MKCLICFS_COMPRESSION}) {\n\t\tmy $c = int $ENV{MKCLICFS_COMPRESSION};\n\t\tmy $d = $this->{imageDest};\n\t\t$data = qxx (\"$clicfs -c $c $d/fsdata.ext3 $d/$name 2>&1\");\n\t} else {\n\t\tmy $d = $this->{imageDest};\n\t\t$data = qxx (\"$clicfs $d/fsdata.ext3 $d/$name 2>&1\");\n\t}\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create clicfs filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\tqxx (\"mv -f $this->{imageDest}/$name.ext3 $this->{imageDest}/$name.clicfs\");\n\tqxx (\"rm -f $this->{imageDest}/fsdata.ext3\");\n\t$kiwi -> done();\n\t#==========================================\n\t# Create image md5sum\n\t#------------------------------------------\n\tif (! $this -> buildMD5Sum ($name)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageEXT\n#------------------------------------------\nsub createImageEXT {\n\t# ...\n\t# Create EXT2 image from source tree\n\t# ---\n\tmy $this    = shift;\n\tmy $journal = shift;\n\tmy $device  = shift;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ($device);\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupEXT2 ( $name,$journal,$device )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name,undef,undef,$device)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageEXT2\n#------------------------------------------\nsub createImageEXT2 {\n\t# ...\n\t# create journaled EXT2 image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\tmy $journal = \"journaled-ext2\";\n\treturn $this -> createImageEXT ($journal,$device);\n}\n\n#==========================================\n# createImageEXT3\n#------------------------------------------\nsub createImageEXT3 {\n\t# ...\n\t# create journaled EXT3 image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\tmy $journal = \"journaled-ext3\";\n\treturn $this -> createImageEXT ($journal,$device);\n}\n\n#==========================================\n# createImageEXT4\n#------------------------------------------\nsub createImageEXT4 {\n\t# ...\n\t# create journaled EXT4 image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\tmy $journal = \"journaled-ext4\";\n\treturn $this -> createImageEXT ($journal,$device);\n}\n\n#==========================================\n# createImageReiserFS\n#------------------------------------------\nsub createImageReiserFS {\n\t# ...\n\t# create journaled ReiserFS image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ($device);\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupReiser ( $name,$device )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name,undef,undef,$device)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageBTRFS\n#------------------------------------------\nsub createImageBTRFS {\n\t# ...\n\t# create BTRFS image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ($device);\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupBTRFS ( $name,$device )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name,undef,undef,$device)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageXFS\n#------------------------------------------\nsub createImageXFS {\n\t# ...\n\t# create XFS image from source tree\n\t# ---\n\tmy $this = shift;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ();\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupXFS ( $name )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageSquashFS\n#------------------------------------------\nsub createImageSquashFS {\n\t# ...\n\t# create squashfs image from source tree\n\t# ---\n\tmy $this  = shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $xml   = $this->{xml};\n\tmy %type  = %{$xml->getImageTypeAndAttributes()};\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage (\"haveExtend\");\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupSquashFS ( $name )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create image md5sum\n\t#------------------------------------------\n\tif (! $this -> buildMD5Sum ($name)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Compress image using gzip\n\t#------------------------------------------\n\tif (($type{compressed}) && ($type{compressed} eq 'true')) {\n\t\tif (! $this -> compressImage ($name)) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Create image boot configuration\n\t#------------------------------------------\n\tif (! $this -> writeImageConfig ($name)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageCPIO\n#------------------------------------------\nsub createImageCPIO {\n\t# ...\n\t# create cpio archive from the image source tree\n\t# The kernel will use this archive and mount it as\n\t# cpio archive\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $imageTree = $this->{imageTree};\n\tmy $zipper    = $this->{gdata}->{Gzip};\n\tmy $compress  = 1;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage (\"haveExtend\",\"quiet\");\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# PRE Create filesystem on extend\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating cpio archive...\");\n\tmy $pwd  = qxx (\"pwd\"); chomp $pwd;\n\tmy @cpio = (\"--create\", \"--format=newc\", \"--quiet\");\n\tmy $dest = $this->{imageDest}.\"/\".$name.\".gz\";\n\tmy $dspl = $this->{imageDest}.\"/\".$name.\".splash.gz\";\n\tmy $data;\n\tif (! $compress) {\n\t\t$dest = $this->{imageDest}.\"/\".$name;\n\t}\n\tif ($dest !~ /^\\//) {\n\t\t$dest = $pwd.\"/\".$dest;\n\t}\n\tif ($dspl !~ /^\\//) {\n\t\t$dspl = $pwd.\"/\".$dspl;\n\t}\n\tif (-e $dspl) {\n\t\tqxx (\"rm -f $dspl 2>&1\");\n\t}\n\tif ($compress) {\n\t\t$data = qxx (\n\t\t\t\"cd $imageTree && find . | cpio @cpio | $zipper -f > $dest\"\n\t\t);\n\t} else {\n\t\t$data = qxx (\"rm -f $dest && rm -f $dest.gz\");\n\t\t$data = qxx (\n\t\t\t\"cd $imageTree && find . | cpio @cpio > $dest\"\n\t\t);\n\t}\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create cpio archive\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tif ($compress) {\n\t\t$name = $name.\".gz\";\n\t}\n\tif (! $this -> buildMD5Sum ($name)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageRootAndBoot\n#------------------------------------------\nsub createImageRootAndBoot {\n\t# ...\n\t# Create root filesystem image if required according to\n\t# the selected image type and also create the boot image\n\t# including kernel and initrd. This function is required\n\t# to create the preconditions for virtual disk images\n\t# ---\n\t#==========================================\n\t# Create root image\n\t#------------------------------------------\n\tmy $this       = shift;\n\tmy $para       = shift;\n\tmy $text       = shift;\n\tmy $kiwi       = $this->{kiwi};\n\tmy $sxml       = $this->{xml};\n\tmy $cmdL       = $this->{cmdL};\n\tmy $idest      = $cmdL->getImageTargetDir();\n\tmy %stype      = %{$sxml->getImageTypeAndAttributes()};\n\tmy $imageTree  = $this->{imageTree};\n\tmy $baseSystem = $this->{baseSystem};\n\tmy $checkBase  = $cmdL->getRootTargetDir().\"/\".$baseSystem;\n\tmy $treeAccess = 1;\n\tmy @bootdata;\n\tmy $type;\n\tmy $boot;\n\tmy %result;\n\tmy $ok;\n\tif ($para =~ /(.*):(.*)/) {\n\t\t$type = $1;\n\t\t$boot = $2;\n\t}\n\tif ((! defined $type) || (! defined $boot)) {\n\t\t$kiwi -> error  (\"Invalid $text type specified: $para\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for direct tree access\n\t#------------------------------------------\n\tif (($text ne \"VMX\") || ($stype{luks})) {\n\t\t$treeAccess = 0;\n\t}\n\tif ($stype{lvm}) {\n\t\t$treeAccess = 1;\n\t}\n\t#==========================================\n\t# Walk through the types\n\t#------------------------------------------\n\tSWITCH: for ($type) {\n\t\t/^ext2/       && do {\n\t\t\tif (! $treeAccess) {\n\t\t\t\t$ok = $this -> createImageEXT2 ();\n\t\t\t} else {\n\t\t\t\t$ok = $this -> setupLogicalExtend();\n\t\t\t\t$result{imageTree} = $imageTree;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^ext3/       && do {\n\t\t\tif (! $treeAccess) {\n\t\t\t\t$ok = $this -> createImageEXT3 ();\n\t\t\t} else {\n\t\t\t\t$ok = $this -> setupLogicalExtend();\n\t\t\t\t$result{imageTree} = $imageTree;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^ext4/       && do {\n\t\t\tif (! $treeAccess) {\n\t\t\t\t$ok = $this -> createImageEXT4 ();\n\t\t\t} else {\n\t\t\t\t$ok = $this -> setupLogicalExtend();\n\t\t\t\t$result{imageTree} = $imageTree;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^reiserfs/   && do {\n\t\t\tif (! $treeAccess) {\n\t\t\t\t$ok = $this -> createImageReiserFS ();\n\t\t\t} else {\n\t\t\t\t$ok = $this -> setupLogicalExtend();\n\t\t\t\t$result{imageTree} = $imageTree;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^squashfs/   && do {\n\t\t\t$ok = $this -> createImageSquashFS ();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^clicfs/     && do {\n\t\t\t$ok = $this -> createImageClicFS ();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^btrfs/      && do {\n\t\t\t$ok = $this -> createImageBTRFS ();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^xfs/        && do {\n\t\t\t$ok = $this -> createImageXFS ();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t$kiwi -> error  (\"Unsupported $text type: $type\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t};\n\tif (! $ok) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Prepare/Create boot image\n\t#------------------------------------------\n\t$kiwi -> info (\"--> Creating $text boot image: $boot...\\n\");\n\t@bootdata = $this -> checkAndSetupPrebuiltBootImage ($sxml);\n\tif (! @bootdata) {\n\t\treturn undef;\n\t}\n\tif ($bootdata[1] == 0) {\n\t\t#==========================================\n\t\t# Setup changeset to be used by boot image\n\t\t#------------------------------------------\n\t\tmy %XMLChangeSet = $this -> updateDescription ($sxml);\n\t\t#==========================================\n\t\t# Create tmp dir for boot image creation\n\t\t#------------------------------------------\n\t\tmy $tmpdir = qxx (\"mktemp -q -d $idest/boot-$text.XXXXXX\");\n\t\tmy $result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tchomp $tmpdir;\n\t\tpush @{$this->{tmpdirs}},$tmpdir;\n\t\t#==========================================\n\t\t# Prepare boot image...\n\t\t#------------------------------------------\n\t\tmy $configDir;\n\t\tif (($stype{boot} !~ /^\\//) && (! -d $stype{boot})) {\n\t\t\t$configDir = $this->{gdata}->{System}.\"/\".$stype{boot};\n\t\t} else {\n\t\t\t$configDir = $stype{boot};\n\t\t}\n\t\tmy $rootTarget = \"$tmpdir/kiwi-\".$text.\"boot-$$\";\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) ||\t(! $kic -> prepareBootImage (\n\t\t\t$configDir,$rootTarget,$this->{imageTree},\\%XMLChangeSet))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create boot image...\n\t\t#------------------------------------------\n\t\tif ((! $kic) || (! $kic -> createBootImage (\n\t\t\t$rootTarget,$this->{imageDest}))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Clean up tmp directory\n\t\t#------------------------------------------\n\t\tqxx (\"rm -rf $tmpdir\");\n\t}\n\t#==========================================\n\t# setup initrd name\n\t#------------------------------------------\n\tmy $initrd = $idest.\"/\".$bootdata[0].\".gz\";\n\tif (! -f $initrd) {\n\t\t$initrd = $idest.\"/\".$bootdata[0];\n\t}\n\t#==========================================\n\t# Check boot and system image kernel\n\t#------------------------------------------\n\tif ($cmdL->getCheckKernel()) {\n\t\tif (! $this -> checkKernel ($initrd,$imageTree,$bootdata[0])) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Include splash screen to initrd\n\t#------------------------------------------\n\tmy $kboot  = new KIWIBoot ($kiwi,$initrd,$cmdL);\n\tif (! defined $kboot) {\n\t\treturn undef;\n\t}\n\tmy $newinitrd = $kboot -> setupSplash();\n\t#==========================================\n\t# Store meta data for subsequent calls\n\t#------------------------------------------\n\t$result{systemImage} = $sxml -> buildImageName();\n\t$result{bootImage}   = $bootdata[0];\n\tif ($text eq \"VMX\") {\n\t\t$result{format} = $stype{format};\n\t}\n\treturn \\%result;\n}\n\n#==========================================\n# createImagePXE\n#------------------------------------------\nsub createImagePXE {\n\t# ...\n\t# Create Image usable within a PXE boot environment. The\n\t# method will create the specified boot image (initrd) and\n\t# the system image. In order to use this image via PXE the\n\t# administration needs to provide the images via TFTP\n\t# ---\n\t#==========================================\n\t# Create PXE boot and system image\n\t#------------------------------------------\n\tmy $this = shift;\n\tmy $para = shift;\n\tmy $name = $this -> createImageRootAndBoot ($para,\"PXE\");\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageVMX\n#------------------------------------------\nsub createImageVMX {\n\t# ...\n\t# Create virtual machine disks. By default a raw disk image will\n\t# be created from which other types are derived via conversion.\n\t# The output format is specified by the format attribute in the\n\t# type section. Supported formats are: vmdk qcow raw ovf\n\t# The process will create the system image and the appropriate vmx\n\t# boot image plus a .raw and an optional format specific image.\n\t# The boot image description must exist in /usr/share/kiwi/image.\n\t# ---\n\t#==========================================\n\t# Create VMX boot and system image\n\t#------------------------------------------\n\tmy $this = shift;\n\tmy $para = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $cmdL = $this->{cmdL};\n\tmy $idest= $cmdL->getImageTargetDir();\n\tmy %xenc = $xml  -> getXenConfig();\n\tmy $name = $this -> createImageRootAndBoot ($para,\"VMX\");\n\tmy $xendomain;\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\tif (defined $xenc{xen_domain}) {\n\t\t$xendomain = $xenc{xen_domain};\n\t} else {\n\t\t$xendomain = \"dom0\";\n\t}\n\t#==========================================\n\t# Create virtual disk image(s)\n\t#------------------------------------------\n\t$cmdL -> setInitrdFile (\n\t\t$idest.\"/\".$name->{bootImage}.\".splash.gz\"\n\t);\n\tif (defined $name->{imageTree}) {\n\t\t$cmdL -> setSystemLocation (\n\t\t\t$name->{imageTree}\n\t\t);\n\t} else {\n\t\t$cmdL -> setSystemLocation (\n\t\t\t$idest.\"/\".$name->{systemImage}\n\t\t);\n\t}\n\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\tif ((! $kic) || (! $kic->createImageDisk())) {\n\t\tundef $kic;\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create VM format/configuration\n\t#------------------------------------------\n\tif ((defined $name->{format}) || ($xendomain eq \"domU\")) {\n\t\t$cmdL -> setSystemLocation (\n\t\t\t$idest.\"/\".$name->{systemImage}.\".raw\"\n\t\t);\n\t\t$cmdL -> setImageFormat ($name->{format});\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) || (! $kic->createImageFormat())) {\n\t\t\tundef $kic;\n\t\t\treturn undef;\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageLiveCD\n#------------------------------------------\nsub createImageLiveCD {\n\t# ...\n\t# Create a live filesystem on CD using the isoboot boot image\n\t# 1) split physical extend into two parts:\n\t#    part1 -> writable\n\t#    part2 -> readonly\n\t# 2) Setup an ext2 based image for the RW part and a squashfs\n\t#    image if it should be compressed. If no compression is used\n\t#    all RO data will be directly on CD/DVD as part of the ISO\n\t#    filesystem\n\t# 3) Prepare and Create the given iso <$boot> boot image\n\t# 4) Setup the CD structure and copy all files\n\t#    including the syslinux isolinux data\n\t# 5) Create the iso image using isolinux shell script\n\t# ---\n\tmy $this = shift;\n\tmy $para = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $arch = $this->{arch};\n\tmy $sxml = $this->{xml};\n\tmy $cmdL = $this->{cmdL};\n\tmy $idest= $cmdL->getImageTargetDir();\n\tmy $imageTree = $this->{imageTree};\n\tmy $baseSystem= $this->{baseSystem};\n\tmy $checkBase = $cmdL->getRootTargetDir().\"/\".$baseSystem;\n\tmy @bootdata;\n\tmy $error;\n\tmy $data;\n\tmy $code;\n\tmy $imageTreeReadOnly;\n\tmy $hybrid = 0;\n\tmy $isxen  = 0;\n\tmy $hybridpersistent = 0;\n\tmy $cmdline;\n\t#==========================================\n\t# Store arch name used by iso\n\t#------------------------------------------\n\tmy $isoarch = qxx (\"uname -m\"); chomp $isoarch;\n\tif ($isoarch =~ /i.86/) {\n\t\t$isoarch = \"i386\";\n\t}\n\t#==========================================\n\t# Get system image name\n\t#------------------------------------------\n\tmy $systemName = $sxml -> getImageName();\n\tmy $systemDisplayName = $sxml -> getImageDisplayName();\n\t#==========================================\n\t# Get system image type information\n\t#------------------------------------------\n\tmy %stype= %{$sxml->getImageTypeAndAttributes()};\n\tmy $pblt = $stype{checkprebuilt};\n\tmy $vga  = $stype{vga};\n\t#==========================================\n\t# Get boot image name and compressed flag\n\t#------------------------------------------\n\tmy @plist = split (/,/,$para);\n\tmy $boot  = $plist[0];\n\tmy $gzip  = $plist[1];\n\tif (! defined $boot) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"No boot image name specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for hybrid ISO\n\t#------------------------------------------\n\tif ((defined $stype{hybrid}) && ($stype{hybrid} eq 'true')) {\n\t\t$hybrid = 1;\n\t}\n\tif ((defined $stype{hybridpersistent}) &&\n\t\t($stype{hybridpersistent} eq 'true')\n\t) {\n\t\t$hybridpersistent = 1;\n\t}\n\t#==========================================\n\t# Check for user-specified cmdline options\n\t#------------------------------------------\n\tif (defined $stype{cmdline}) {\n\t\t$cmdline = \" $stype{cmdline}\";\n\t}\n\t#==========================================\n\t# Get image creation date and name\n\t#------------------------------------------\n\tmy $namecd = $this -> buildImageName (\";\");\n\tmy $namerw = $this -> buildImageName ();\n\tmy $namero = $this -> buildImageName (\"-\",\"-read-only\");\n\tif (! defined $namerw) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Call images.sh script\n\t#------------------------------------------\n\tif (! $this -> setupLogicalExtend (\"quiet\")) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for config-cdroot and move it\n\t#------------------------------------------\n\tmy $cdrootData = \"config-cdroot.tgz\";\n\tif (-f $imageTree.\"/image/\".$cdrootData) {\n\t\tqxx (\"mv $imageTree/image/$cdrootData $this->{imageDest}\");\n\t}\n\t#==========================================\n\t# Check for config-cdroot.sh and move it\n\t#------------------------------------------\n\tmy $cdrootScript = \"config-cdroot.sh\";\n\tif (-x $imageTree.\"/image/\".$cdrootScript) {\n\t\tqxx (\"mv $imageTree/image/$cdrootScript $this->{imageDest}\");\n\t}\n\t#==========================================\n\t# split physical extend into RW / RO part\n\t#------------------------------------------\n\tif (! defined $gzip) {\n\t\t$imageTreeReadOnly = $imageTree;\n\t\t$imageTreeReadOnly =~ s/\\/+$//;\n\t\t$imageTreeReadOnly.= \"-read-only/\";\n\t\t$this->{imageTreeReadOnly} = $imageTreeReadOnly;\n\t\tif (! -d $imageTreeReadOnly) {\n\t\t\t$kiwi -> info (\"Creating read only image part\");\n\t\t\tif (! mkdir $imageTreeReadOnly) {\n\t\t\t\t$error = $!;\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't create ro directory: $error\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tpush @{$this->{tmpdirs}},$imageTreeReadOnly;\n\t\t\tmy @rodirs = qw (bin boot lib lib64 opt sbin usr);\n\t\t\tforeach my $dir (@rodirs) {\n\t\t\t\tif (! -d \"$imageTree/$dir\") {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$data = qxx (\"mv $imageTree/$dir $imageTreeReadOnly 2>&1\");\n\t\t\t\t$code = $? >> 8;\n\t\t\t\tif ($code != 0) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$kiwi -> error  (\"Couldn't setup ro directory: $data\");\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t}\n\t\t#==========================================\n\t\t# Count disk space for RW extend\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Computing disk space...\");\n\t\tmy ($mbytesrw,$xmlsize) = $this -> getSize ($imageTree);\n\t\t$kiwi -> done ();\n\n\t\t#==========================================\n\t\t# Create RW logical extend\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Image RW part requires $mbytesrw MB of disk space\");\n\t\tif (! $this -> buildLogicalExtend ($namerw,$mbytesrw.\"M\")) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done ();\n\t\t#==========================================\n\t\t# Create EXT2 filesystem on RW extend\n\t\t#------------------------------------------\n\t\tmy $setBlockSize = 0;\n\t\tmy $fsopts       = $cmdL -> getFilesystemOptions();\n\t\tmy $blocksize    = $fsopts->[0];\n\t\tif (! defined $blocksize) {\n\t\t\t$fsopts->[0] = 4096;\n\t\t\t$setBlockSize = 1;\n\t\t\t$cmdL -> setFilesystemOptions (@{$fsopts});\n\t\t}\n\t\tif (! $this -> setupEXT2 ( $namerw )) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\tif ($setBlockSize) {\n\t\t\tundef $fsopts->[0];\n\t\t\t$cmdL -> setFilesystemOptions (@{$fsopts});\n\t\t}\n\t\t#==========================================\n\t\t# mount logical extend for data transfer\n\t\t#------------------------------------------\n\t\tmy $extend = $this -> mountLogicalExtend ($namerw);\n\t\tif (! defined $extend) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# copy physical to logical\n\t\t#------------------------------------------\n\t\tif (! $this -> installLogicalExtend ($extend,$imageTree)) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> cleanMount();\n\t\t$this -> restoreImageDest();\n\t\t$this -> cleanLuks();\n\t}\n\t#==========================================\n\t# Create compressed filesystem on RO extend\n\t#------------------------------------------\n\tif (defined $gzip) {\n\t\tSWITCH: for ($gzip) {\n\t\t\t/^compressed$/ && do {\n\t\t\t\t$kiwi -> info (\"Creating split ext3 + squashfs...\\n\");\n\t\t\t\tif (! $this -> createImageSplit (\"ext3,squashfs\", 1)) {\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$namero = $namerw;\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/^unified$/ && do {\n\t\t\t\t$kiwi -> info (\"Creating squashfs read only filesystem...\\n\");\n\t\t\t\tif (! $this -> setupSquashFS ( $namero,$imageTree )) {\n\t\t\t\t\t$this -> restoreSplitExtend ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/^clic$/ && do {\n\t\t\t\t$kiwi -> info (\"Creating clicfs read only filesystem...\\n\");\n\t\t\t\tif (! $this -> createImageClicFS ( $namero )) {\n\t\t\t\t\t$this -> restoreSplitExtend ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t# invalid flag setup...\n\t\t\t$kiwi -> error  (\"Invalid iso flags: $gzip\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Check / build md5 sum of RW extend\n\t#------------------------------------------\n\tif (! defined $gzip) {\n\t\t#==========================================\n\t\t# Checking RW file system\n\t\t#------------------------------------------\n\t\tqxx (\"/sbin/e2fsck -f -y $this->{imageDest}/$namerw 2>&1\");\n\n\t\t#==========================================\n\t\t# Create image md5sum\n\t\t#------------------------------------------\n\t\tif (! $this -> buildMD5Sum ($namerw)) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Restoring physical extend\n\t\t#------------------------------------------\n\t\tif (! $this -> restoreSplitExtend ()) {\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# compress RW extend\n\t\t#------------------------------------------\n\t\tif (! $this -> compressImage ($namerw)) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# recreate a copy of the read-only data\n\t#------------------------------------------\t\n\tif ((defined $imageTreeReadOnly) && (! -d $imageTreeReadOnly) &&\n\t\t(! defined $gzip)\n\t) {\n\t\t$kiwi -> info (\"Creating read only reference...\");\n\t\tif (! mkdir $imageTreeReadOnly) {\n\t\t\t$error = $!;\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create ro directory: $error\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy @rodirs = qw (bin boot lib lib64 opt sbin usr);\n\t\tforeach my $dir (@rodirs) {\n\t\t\tif (! -d \"$imageTree/$dir\") {\n\t\t\t\tnext;\n\t\t\t}\n\t\t\t$data = qxx (\"cp -a $imageTree/$dir $imageTreeReadOnly 2>&1\");\n\t\t\t$code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't setup ro directory: $data\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Prepare and Create ISO boot image\n\t#------------------------------------------\n\t$kiwi -> info (\"--> Creating ISO boot image: $boot...\\n\");\n\t@bootdata = $this -> checkAndSetupPrebuiltBootImage ($sxml);\n\tif (! @bootdata) {\n\t\treturn undef;\n\t}\n\tif ($bootdata[1] == 0) {\n\t\t#==========================================\n\t\t# Setup changeset to be used by boot image\n\t\t#------------------------------------------\n\t\tmy %XMLChangeSet = $this -> updateDescription ($sxml);\n\t\t#==========================================\n\t\t# Create tmp dir for boot image creation\n\t\t#------------------------------------------\n\t\tmy $tmpdir = qxx (\"mktemp -q -d $idest/boot-iso.XXXXXX\");\n\t\tmy $result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tchomp $tmpdir;\n\t\tpush @{$this->{tmpdirs}},$tmpdir;\n\t\t#==========================================\n\t\t# Prepare boot image...\n\t\t#------------------------------------------\n\t\tmy $configDir;\n\t\tif (($stype{boot} !~ /^\\//) && (! -d $stype{boot})) {\n\t\t\t$configDir = $this->{gdata}->{System}.\"/\".$stype{boot};\n\t\t} else {\n\t\t\t$configDir = $stype{boot};\n\t\t}\n\t\tmy $rootTarget = \"$tmpdir/kiwi-isoboot-$$\";\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) || (! $kic -> prepareBootImage (\n\t\t\t$configDir,$rootTarget,$this->{imageTree},\\%XMLChangeSet))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create boot image...\n\t\t#------------------------------------------\n\t\tif ((! $kic) || (! $kic -> createBootImage (\n\t\t\t$rootTarget,$this->{imageDest}))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Clean up tmp directory\n\t\t#------------------------------------------\n\t\tqxx (\"rm -rf $tmpdir\");\n\t}\n\t#==========================================\n\t# setup initrd/kernel names\n\t#------------------------------------------\n\tmy $pinitrd = $idest.\"/\".$bootdata[0].\".gz\";\n\tmy $plinux  = $idest.\"/\".$bootdata[0].\".kernel\";\n\tmy $pxboot  = glob ($idest.\"/\".$bootdata[0].\"*xen.gz\");\n\tif (-f $pxboot) {\n\t\t$isxen = 1;\n\t}\n\t#==========================================\n\t# Check boot and system image kernel\n\t#------------------------------------------\n\tif ($cmdL->getCheckKernel()) {\n\t\tif (! $this -> checkKernel ($pinitrd,$imageTree,$bootdata[0])) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Include splash screen to initrd\n\t#------------------------------------------\n\tmy $kboot  = new KIWIBoot ($kiwi,$pinitrd,$cmdL);\n\tif (! defined $kboot) {\n\t\treturn undef;\n\t}\n\t$pinitrd = $kboot -> setupSplash();\n\t#==========================================\n\t# Prepare for CD ISO image\n\t#------------------------------------------\n\tmy $CD = $idest.\"/CD\";\n\t$kiwi -> info (\"Creating CD filesystem structure\");\n\tqxx (\"mkdir -p $CD/boot\");\n\tpush @{$this->{tmpdirs}},$CD;\n\t$kiwi -> done ();\n\t#==========================================\n\t# Check for optional config-cdroot archive\n\t#------------------------------------------\n\tif (-f $this->{imageDest}.\"/\".$cdrootData) {\n\t\t$kiwi -> info (\"Integrating CD root information...\");\n\t\tmy $data= qxx (\n\t\t\t\"tar -C $CD -xvf $this->{imageDest}/$cdrootData\"\n\t\t);\n\t\tmy $code= $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to integrate CD root data: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> restoreCDRootData();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Check for optional config-cdroot.sh\n\t#------------------------------------------\n\tif (-x $this->{imageDest}.\"/\".$cdrootScript) {\n\t\t$kiwi -> info (\"Calling CD root setup script...\");\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\tmy $cdrootEnv = $imageTree.\"/.profile\";\n\t\tif ($cdrootEnv !~ /^\\//) {\n\t\t\t$cdrootEnv = $pwd.\"/\".$cdrootEnv;\n\t\t}\n\t\tmy $script = $this->{imageDest}.\"/\".$cdrootScript;\n\t\tif ($script !~ /^\\//) {\n\t\t\t$script = $pwd.\"/\".$script;\n\t\t}\n\t\tmy $data = qxx (\n\t\t\t\"cd $CD && bash -c '. $cdrootEnv && . $script' 2>&1\"\n\t\t);\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\tchomp $data;\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to call CD root script: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> restoreCDRootData();\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"config-cdroot.sh: $data\");\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Restore CD root data and script\n\t#------------------------------------------\n\t$this -> restoreCDRootData();\n\t#==========================================\n\t# Installing system image file(s)\n\t#------------------------------------------\n\t$kiwi -> info (\"Moving CD image data into boot structure\");\n\tif (! defined $gzip) {\n\t\t# /.../\n\t\t# don't symlink these file because in this old live iso\n\t\t# mode we don't allow mkisofs to follow symlinks\n\t\t# ----\n\t\tqxx (\"mv $this->{imageDest}/$namerw.md5 $CD\");\n\t\tqxx (\"mv $this->{imageDest}/$namerw.gz  $CD\");\n\t\tqxx (\"rm $this->{imageDest}/$namerw.*\");\n\t}\n\tif (defined $gzip) {\n\t\t#qxx (\"mv $this->{imageDest}/$namero $CD\");\n\t\t#qxx (\"rm $this->{imageDest}/$namero.*\");\n\t\tqxx (\"ln -s $this->{imageDest}/$namero $CD/$namero\");\n\t} else {\n\t\tqxx (\"mkdir -p $CD/read-only-system\");\n\t\tqxx (\"mv $imageTreeReadOnly/* $CD/read-only-system\");\n\t\trmdir $imageTreeReadOnly;\n\t}\n\t$kiwi -> done ();\n\t#==========================================\n\t# Create MBR id file for boot device check\n\t#------------------------------------------\n\tif ($hybrid) {\n\t\t$kiwi -> info (\"Saving hybrid disk label on ISO: $this->{mbrid}...\");\n\t\tmy $destination = \"$CD/boot/grub\";\n\t\tqxx (\"mkdir -p $destination\");\n\t\tif (! open (FD,\">$destination/mbrid\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create mbrid file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$this->{mbrid}\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# copy boot kernel and initrd\n\t#------------------------------------------\n\t$kiwi -> info (\"Copying boot image and kernel [$isoarch]\");\n\tmy $destination = \"$CD/boot/$isoarch/loader\";\n\tqxx (\"mkdir -p $destination\");\n\t$data = qxx (\"cp $pinitrd $destination/initrd 2>&1\");\n\t$code = $? >> 8;\n\tif ($code == 0) {\n\t\t$data = qxx (\"cp $plinux $destination/linux 2>&1\");\n\t\t$code = $? >> 8;\n\t}\n\tif (($code == 0) && ($isxen)) {\n\t\t$data = qxx (\"cp $pxboot $destination/xen.gz 2>&1\");\n\t\t$code = $? >> 8;\n\t}\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Copy of isolinux boot files failed: $data\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done ();\n\t#==========================================\n\t# check for graphics boot files\n\t#------------------------------------------\n\t$kiwi -> info (\"Extracting initrd for boot graphics data lookup\");\n\tmy $tmpdir = qxx (\"mktemp -q -d $idest/boot-iso.XXXXXX\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tchomp $tmpdir;\n\tpush @{$this->{tmpdirs}},$tmpdir;\n\tmy $zipper = $this->{gdata}->{Gzip};\n\t$data = qxx (\"$zipper -cd $pinitrd | (cd $tmpdir && cpio -di 2>&1)\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error (\"Failed to extract initrd: $data\");\n\t\t$kiwi -> failed();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# copy base graphics boot CD files\n\t#------------------------------------------\n\t$kiwi -> info (\"Setting up isolinux boot CD [$isoarch]\");\n\tmy $gfx = $tmpdir.\"/image/loader\";\n\t$data = qxx (\"cp -a $gfx/* $destination\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Copy failed: $data\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done ();\n\t#==========================================\n\t# setup isolinux boot label name\n\t#------------------------------------------\n\tmy $label = $this->makeLabel ($systemDisplayName);\n\tmy $lsafe = $this->makeLabel (\"Failsafe -- \".$label);\n\t#==========================================\n\t# setup isolinux.cfg file\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating isolinux configuration...\");\n\tmy $syslinux_new_format = 0;\n\tmy $bootTimeout = $stype{boottimeout} ? int $stype{boottimeout} : 200;\n\tif (-f \"$gfx/gfxboot.com\" || -f \"$gfx/gfxboot.c32\") {\n\t\t$syslinux_new_format = 1;\n\t}\n\tif (! open (FD, \">$destination/isolinux.cfg\")) {\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error  (\"Failed to create $destination/isolinux.cfg: $!\");\n\t\t$kiwi -> failed ();\n\t\tif (! -d $checkBase) {\n\t\t\tqxx (\"rm -rf $cmdL->getRootTargetDir()\");\n\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t}\n\t\treturn undef;\n\t}\n\tbinmode(FD, \":utf8\");\n\tprint FD \"default $label\".\"\\n\";\n\tprint FD \"implicit 1\".\"\\n\";\n\tprint FD \"display isolinux.msg\".\"\\n\";\n\tif (-f \"$gfx/bootlogo\" ) {\n\t\tif ($syslinux_new_format) {\n\t\t\tprint FD \"ui gfxboot bootlogo isolinux.msg\".\"\\n\";\n\t\t} else {\n\t\t\tprint FD \"gfxboot bootlogo\".\"\\n\";\n\t\t}\n\t}\n\tprint FD \"prompt   1\".\"\\n\";\n\tprint FD \"timeout  $bootTimeout\".\"\\n\";\n\tif (! $isxen) {\n\t\tprint FD \"label $label\".\"\\n\";\n\t\tprint FD \"  kernel linux\".\"\\n\";\n\t\tprint FD \"  append initrd=initrd ramdisk_size=512000 \";\n\t\tprint FD \"ramdisk_blocksize=4096 splash=silent${cmdline} showopts \";\n\t\t#print FD \"console=ttyS0,9600n8 console=tty0${cmdline} showopts \";\n\t\tif ($vga) {\n\t\t\tprint FD \"vga=$vga \";\n\t\t}\n\t\tprint FD \"\\n\";\n\t\tprint FD \"label $lsafe\".\"\\n\";\n\t\tprint FD \"  kernel linux\".\"\\n\";\n\t\tprint FD \"  append initrd=initrd ramdisk_size=512000 \";\n\t\tprint FD \"ramdisk_blocksize=4096 splash=silent${cmdline} showopts \";\n\t\tprint FD \"ide=nodma apm=off acpi=off noresume selinux=0 nosmp \";\n\t\tprint FD \"noapic maxcpus=0 edd=off\".\"\\n\";\n\t} else {\n\t\tprint FD \"label $label\".\"\\n\";\n\t\tprint FD \"  kernel mboot.c32\".\"\\n\";\n\t\tprint FD \"  append xen.gz --- linux ramdisk_size=512000 \";\n\t\tprint FD \"ramdisk_blocksize=4096 splash=silent${cmdline} \";\n\t\t#print FD \"console=ttyS0,9600n8 console=tty0 \";\n\t\tif ($vga) {\n\t\t\tprint FD \"vga=$vga \";\n\t\t}\n\t\tprint FD \"--- initrd showopts\".\"\\n\";\n\t\tprint FD \"\\n\";\n\t\tprint FD \"label $lsafe\".\"\\n\";\n\t\tprint FD \"  kernel mboot.c32\".\"\\n\";\n\t\tprint FD \"  append xen.gz --- linux ramdisk_size=512000 \";\n\t\tprint FD \"ramdisk_blocksize=4096 splash=silent${cmdline} \";\n\t\tprint FD \"ide=nodma apm=off acpi=off noresume selinux=0 nosmp \";\n\t\tprint FD \"noapic maxcpus=0 edd=off \";\n\t\tprint FD \"--- initrd showopts\".\"\\n\";\n\t}\n\t#==========================================\n\t# setup isolinux checkmedia boot entry\n\t#------------------------------------------\n\tif ($cmdL->getISOCheck()) {\n\t\tprint FD \"\\n\";\n\t\tif (! $isxen) {\n\t\t\tprint FD \"label mediacheck\".\"\\n\";\n\t\t\tprint FD \"  kernel linux\".\"\\n\";\n\t\t\tprint FD \"  append initrd=initrd splash=silent mediacheck=1\";\n\t\t\tprint FD \"$cmdline \";\n\t\t\tprint FD \"showopts\".\"\\n\";\n\t\t} else {\n\t\t\tprint FD \"label mediacheck\".\"\\n\";\n\t\t\tprint FD \"  kernel mboot.c32\".\"\\n\";\n\t\t\tprint FD \"  append xen.gz --- linux splash=silent mediacheck=1\";\n\t\t\tprint FD \"$cmdline \";\n\t\t\tprint FD \"--- initrd showopts\".\"\\n\";\n\t\t}\n\t}\n\t#==========================================\n\t# setup default harddisk/memtest entries\n\t#------------------------------------------\n\tprint FD \"\\n\";\n\tprint FD \"label harddisk\\n\";\n\tprint FD \"  localboot 0x80\".\"\\n\";\n\tprint FD \"\\n\";\n\tprint FD \"label memtest\".\"\\n\";\n\tprint FD \"  kernel memtest\".\"\\n\";\n\tprint FD \"\\n\";\n\tclose FD;\n\t#==========================================\n\t# setup isolinux.msg file\n\t#------------------------------------------\n\tif (! open (FD,\">$destination/isolinux.msg\")) {\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error  (\"Failed to create isolinux.msg: $!\");\n\t\t$kiwi -> failed ();\n\t\tif (! -d $checkBase) {\n\t\t\tqxx (\"rm -rf $cmdL->getRootTargetDir()\");\n\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t}\n\t\treturn undef;\n\t}\n\tprint FD \"\\n\".\"Welcome !\".\"\\n\\n\";\n\tprint FD \"To start the system enter '\".$label.\"' and press <return>\".\"\\n\";\n\tprint FD \"\\n\\n\";\n\tprint FD \"Available boot options:\\n\";\n\tprintf (FD \"%-20s - %s\\n\",$label,\"Live System\");\n\tprintf (FD \"%-20s - %s\\n\",$lsafe,\"Live System failsafe mode\");\n\tprintf (FD \"%-20s - %s\\n\",\"harddisk\",\"Local boot from hard disk\");\n\tprintf (FD \"%-20s - %s\\n\",\"mediacheck\",\"Media check\");\n\tprintf (FD \"%-20s - %s\\n\",\"memtest\",\"Memory Test\");\n\tprint FD \"\\n\";\n\tprint FD \"Have a lot of fun...\".\"\\n\";\n\tclose FD;\n\t$kiwi -> done();\n\t#==========================================\n\t# Cleanup tmpdir\n\t#------------------------------------------\n\tqxx (\"rm -rf $tmpdir\");\n\t#==========================================\n\t# Create boot configuration\n\t#------------------------------------------\n\tif (! open (FD,\">$CD/config.isoclient\")) {\n\t\t$kiwi -> error  (\"Couldn't create image boot configuration\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif ((! defined $gzip) || ($gzip =~ /^(unified|clic)/)) {\n\t\tprint FD \"IMAGE=/dev/ram1;$namecd\\n\";\n\t} else {\n\t\tprint FD \"IMAGE=/dev/loop1;$namecd\\n\";\n\t}\n\tif (defined $gzip) {\n\t\tif ($gzip =~ /^unified/) {\n\t\t\tprint FD \"UNIONFS_CONFIG=/dev/ram1,/dev/loop1,aufs\\n\";\n\t\t} elsif ($gzip =~ /^clic/) {\n\t\t\tprint FD \"UNIONFS_CONFIG=/dev/ram1,/dev/loop1,clicfs\\n\";\n\t\t} else {\n\t\t\tprint FD \"COMBINED_IMAGE=yes\\n\";\n\t\t}\n\t}\n\tclose FD;\n\t#==========================================\n\t# create ISO image\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating ISO image...\\n\");\n\tmy $isoerror = 1;\n\tmy $name = $this->{imageDest}.\"/\".$namerw.\".iso\";\n\tmy $attr = \"-R -J -f -pad -joliet-long\";\n\tif (! defined $gzip) {\n\t\t$attr = \"-R -J -pad -joliet-long\";\n\t}\n\t$attr .= ' -p \"'.$this->{gdata}->{Preparer}.'\"';\n\t$attr .= ' -publisher \"'.$this->{gdata}->{Publisher}.'\"';\n\tif (! defined $gzip) {\n\t\t$attr .= \" -iso-level 4\"; \n\t}\n\tif ($stype{volid}) {\n\t\t$attr .= \" -V \\\"$stype{volid}\\\"\";\n\t}\n\tmy $isolinux = new KIWIIsoLinux (\n\t\t$kiwi,$CD,$name,$attr,\"checkmedia\",$this->{cmdL}\n\t);\n\tif (defined $isolinux) {\n\t\t$isoerror = 0;\n\t\tif (! $isolinux -> callBootMethods()) {\n\t\t\t$isoerror = 1;\n\t\t}\n\t\tif (! $isolinux -> createISO()) {\n\t\t\t$isoerror = 1;\n\t\t}\n\t}\n\tif ($isoerror) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# relocate boot catalog\n\t#------------------------------------------\n\tif (! $isolinux -> relocateCatalog()) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Turn ISO into hybrid if requested\n\t#------------------------------------------\n\tif ($hybrid) {\n\t\t$kiwi -> info (\"Setting up hybrid ISO...\");\n\t\tif (! $isolinux -> createHybrid ($this->{mbrid})) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to create hybrid ISO image\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# tag ISO image with tagmedia\n\t#------------------------------------------\n\tif (-x \"/usr/bin/tagmedia\") {\n\t\t$kiwi -> info (\"Adding checkmedia tag...\");\n\t\tif (! $isolinux -> checkImage()) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to tag ISO image\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageSplit\n#------------------------------------------\nsub createImageSplit {\n\t# ...\n\t# Create all split images and the specified boot image which\n\t# should be used in combination to this split image. The process\n\t# requires subsequent kiwi calls to create the vmx/oemboot\n\t# required virtual disk images or the created images needs\n\t# to be copied into a PXE boot structure for use with\n\t# a netboot setup.\n\t# ---\n\tmy $this = shift;\n\tmy $type = shift;\n\tmy $nopersistent = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $cmdL = $this->{cmdL};\n\tmy $arch = $this->{arch};\n\tmy $imageTree = $this->{imageTree};\n\tmy $baseSystem= $this->{baseSystem};\n\tmy $checkBase = $cmdL->getRootTargetDir().\"/\".$baseSystem;\n\tmy $sxml = $this->{xml};\n\tmy $idest= $cmdL->getImageTargetDir();\n\tmy %xenc = $sxml->getXenConfig();\n\tmy $FSTypeRW;\n\tmy $FSTypeRO;\n\tmy $error;\n\tmy $ok;\n\tmy @bootdata;\n\tmy $imageTreeRW;\n\tmy $imageTreeTmp;\n\tmy $mbytesro;\n\tmy $mbytesrw;\n\tmy $xmlsize;\n\tmy $boot;\n\tmy $plinux;\n\tmy $pinitrd;\n\tmy $data;\n\tmy $code;\n\tmy $name;\n\tmy $treebase;\n\tmy $xendomain;\n\t#==========================================\n\t# check for xen domain setup\n\t#------------------------------------------\n\tif (defined $xenc{xen_domain}) {\n\t\t$xendomain = $xenc{xen_domain};\n\t} else {\n\t\t$xendomain = \"dom0\";\n\t}\n\t#==========================================\n\t# turn image path into absolute path\n\t#------------------------------------------\n\tif ($imageTree !~ /^\\//) {\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\t$imageTree = $pwd.\"/\".$imageTree;\n\t}\n\t#==========================================\n\t# Get filesystem info for split image\n\t#------------------------------------------\n\tif ($type =~ /(.*),(.*):(.*)/) {\n\t\t$FSTypeRW = $1;\n\t\t$FSTypeRO = $2;\n\t\t$boot = $3;\n\t} elsif ($type =~ /(.*),(.*)/) {\n\t\t$FSTypeRW = $1;\n\t\t$FSTypeRO = $2;\n\t} else {\n\t\t$kiwi -> error  (\"Invalid filesystem setup for split type\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Get system image type information\n\t#------------------------------------------\n\tmy %type = %{$sxml->getImageTypeAndAttributes()};\n\tmy $pblt = $type{checkprebuilt};\n\t#==========================================\n\t# Get image creation date and name\n\t#------------------------------------------\n\tmy $namerw = $this -> buildImageName (\"-\",\"-read-write\");\n\tmy $namero = $this -> buildImageName ();\n\tif (! defined $namerw) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Call images.sh script\n\t#------------------------------------------\n\tif (! $this -> setupLogicalExtend (\"quiet\", $namero)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create clone of prepared tree\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating root tree clone for split operations\");\n\t$treebase = basename $imageTree;\n\tif (-d $this->{imageDest}.\"/\".$treebase) {\n\t\tqxx (\"rm -rf $this->{imageDest}/$treebase\");\n\t}\n\t$data = qxx (\"cp -a -x $imageTree $this->{imageDest}\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Can't create copy of image tree: $data\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $imageTree\");\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# split physical extend into RW/RO/tmp part\n\t#------------------------------------------\n\t$imageTree = $this->{imageDest}.\"/\".$treebase;\n\tif ($imageTree !~ /^\\//) {\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\t$imageTree = $pwd.\"/\".$imageTree;\n\t}\n\t$imageTreeTmp = $imageTree;\n\t$imageTreeTmp =~ s/\\/+$//;\n\t$imageTreeTmp.= \"-tmp/\";\n\t$this->{imageTreeTmp} = $imageTreeTmp;\n\t#==========================================\n\t# run split tree creation\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating temporary image part...\\n\");\n\tif (! mkdir $imageTreeTmp) {\n\t\t$error = $!;\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create split tmp directory: $error\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $imageTree\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# walk through except files if any\n\t#------------------------------------------\n\tmy %exceptHash;\n\tforeach my $except ($sxml -> getSplitTmpExceptions()) {\n\t\tmy $globsource = \"${imageTree}${except}\";\n\t\tmy @files = qxx (\"find $globsource -xtype f 2>/dev/null\");\n\t\tmy $code  = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t# excepted file(s) doesn't exist anyway\n\t\t\tnext;\n\t\t}\n\t\tchomp @files;\n\t\tforeach my $file (@files) {\n\t\t\t$exceptHash{$file} = $file;\n\t\t}\n\t}\n\t#==========================================\n\t# create linked list for files, create dirs\n\t#------------------------------------------\n\tmy $createTmpTree = sub {\n\t\tmy $file  = $_;\n\t\tmy $dir   = $File::Find::dir;\n\t\tmy $path  = \"$dir/$file\";\n\t\tmy $target= $path;\n\t\t$target =~ s#$imageTree#$imageTreeTmp#;\n\t\tmy $rerooted = $path;\n\t\t$rerooted =~ s#$imageTree#/read-only/#;\n\t\tmy $st = lstat($path);\n\t\tif (S_ISDIR($st->mode)) {\n\t\t\tmkdir $target;\n\t\t\tchmod S_IMODE($st->mode), $target;\n\t\t\tchown $st->uid, $st->gid, $target;\n\t\t} elsif (\n\t\t\tS_ISCHR($st->mode)  ||\n\t\t\tS_ISBLK($st->mode)  ||\n\t\t\tS_ISLNK($st->mode)\n\t\t) {\n\t\t\tqxx (\"cp -a $path $target\");\n\t\t} else {\n\t\t\t$rerooted =~ s#/+#/#g;\n\t\t\tsymlink ($rerooted, $target);\n\t\t}\n\t};\n\tfind(\\&$createTmpTree, $imageTree);\n\tmy @tempFiles    = $sxml -> getSplitTempFiles ();\n\tmy @persistFiles = $sxml -> getSplitPersistentFiles ();\n\tif ($nopersistent) {\n\t\tpush (@tempFiles, @persistFiles);\n\t\tundef @persistFiles;\n\t}\n\t#==========================================\n\t# search temporary files, respect excepts\n\t#------------------------------------------\n\tmy %tempFiles_new;\n\tif (@tempFiles) {\n\t\tforeach my $temp (@tempFiles) {\n\t\t\tmy $globsource = \"${imageTree}${temp}\";\n\t\t\tmy @files = qxx (\"find $globsource -xtype f 2>/dev/null\");\n\t\t\tmy $code  = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> warning (\"file $globsource doesn't exist\");\n\t\t\t\t$kiwi -> skipped ();\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tchomp @files;\n\t\t\tforeach (@files) {\n\t\t\t\t$tempFiles_new{$_} = $_;\n\t\t\t}\n\t\t}\n\t}\n\t@tempFiles = sort keys %tempFiles_new;\n\tif (@tempFiles) {\n\t\tforeach my $file (@tempFiles) {\n\t\t\tif (defined $exceptHash{$file}) {\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tmy $dest = $file;\n\t\t\t$dest =~ s#$imageTree#$imageTreeTmp#;\n\t\t\tqxx (\"rm -rf $dest\");\n\t\t\tqxx (\"mv $file $dest\");\n\t\t}\n\t}\n\t#==========================================\n\t# find persistent files for the read-write\n\t#------------------------------------------\n\t$imageTreeRW = $imageTree;\n\t$imageTreeRW =~ s/\\/+$//;\n\t$imageTreeRW.= \"-read-write\";\n\tif (@persistFiles) {\n\t\t$kiwi -> info (\"Creating read-write image part...\\n\");\n\t\t#==========================================\n\t\t# Create read-write directory\n\t\t#------------------------------------------\n\t\t$this->{imageTreeRW} = $imageTreeRW;\n\t\tif (! mkdir $imageTreeRW) {\n\t\t\t$error = $!;\n\t\t\t$kiwi -> error  (\n\t\t\t\t\"Couldn't create split read-write directory: $error\"\n\t\t\t);\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $imageTree $imageTreeTmp\");\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# walk through except files if any\n\t\t#------------------------------------------\n\t\tmy %exceptHash;\n\t\tforeach my $except ($sxml -> getSplitPersistentExceptions()) {\n\t\t\tmy $globsource = \"${imageTree}${except}\";\n\t\t\tmy @files = qxx (\"find $globsource -xtype f 2>/dev/null\");\n\t\t\tmy $code  = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t# excepted file(s) doesn't exist anyway\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tchomp @files;\n\t\t\tforeach my $file (@files) {\n\t\t\t\t$exceptHash{$file} = $file;\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# search persistent files, respect excepts\n\t\t#------------------------------------------\n\t\tmy %expandedPersistFiles;\n\t\tforeach my $persist (@persistFiles) {\n\t\t\tmy $globsource = \"${imageTree}${persist}\";\n\t\t\tmy @files = qxx (\"find $globsource 2>/dev/null\");\n\t\t\tmy $code  = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> warning (\"file $globsource doesn't exist\");\n\t\t\t\t$kiwi -> skipped ();\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tchomp @files;\n\t\t\tforeach my $file (@files) {\n\t\t\t\tif (defined $exceptHash{$file}) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$expandedPersistFiles{$file} = $file;\n\t\t\t}\n\t\t}\n\t\t@persistFiles = keys %expandedPersistFiles;\n\t\t#==========================================\n\t\t# relink to read-write, and move files\n\t\t#------------------------------------------\n\t\tforeach my $file (@persistFiles) {\n\t\t\tmy $dest = $file;\n\t\t\tmy $link = $file;\n\t\t\tmy $rlnk = $file;\n\t\t\t$dest =~ s#$imageTree#$imageTreeRW#;\n\t\t\t$link =~ s#$imageTree#$imageTreeTmp#;\n\t\t\t$rlnk =~ s#$imageTree#/read-write#;\n\t\t\tif (-d $file) {\n\t\t\t\t#==========================================\n\t\t\t\t# recreate directory\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $st = stat($file);\n\t\t\t\tqxx (\"mkdir -p $dest\");\n\t\t\t\tchmod S_IMODE($st->mode), $dest;\n\t\t\t\tchown $st->uid, $st->gid, $dest;\n\t\t\t} else {\n\t\t\t\t#==========================================\n\t\t\t\t# move file to read-write area\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $st = stat(dirname $file);\n\t\t\t\tmy $destdir = dirname $dest;\n\t\t\t\tqxx (\"rm -rf $dest\");\n\t\t\t\tqxx (\"mkdir -p $destdir\");\n\t\t\t\tchmod S_IMODE($st->mode), $destdir;\n\t\t\t\tchown $st->uid, $st->gid, $destdir;\n\t\t\t\tqxx (\"mv $file $dest\");\n\t\t\t\t#==========================================\n\t\t\t\t# relink file to read-write area\n\t\t\t\t#------------------------------------------\n\t\t\t\tqxx (\"rm -rf $link\");\n\t\t\t\tqxx (\"ln -s $rlnk $link\");\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# relink if entire directory was set\n\t\t#------------------------------------------\n\t\tforeach my $persist ($sxml -> getSplitPersistentFiles()) {\n\t\t\tmy $globsource = \"${imageTree}${persist}\";\n\t\t\tif (-d $globsource) {\n\t\t\t\tmy $link = $globsource;\n\t\t\t\tmy $rlnk = $globsource;\n\t\t\t\t$link =~ s#$imageTree#$imageTreeTmp#;\n\t\t\t\t$rlnk =~ s#$imageTree#/read-write#;\n\t\t\t\t#==========================================\n\t\t\t\t# relink directory to read-write area\n\t\t\t\t#------------------------------------------\n\t\t\t\tqxx (\"rm -rf $link\");\n\t\t\t\tqxx (\"ln -s $rlnk $link\");\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# Embed tmp extend into ro extend\n\t#------------------------------------------\n\tqxx (\"cd $imageTreeTmp && tar cvf $imageTree/rootfs.tar * 2>&1\");\n\tqxx (\"rm -rf $imageTreeTmp\");\n\n\t#==========================================\n\t# Count disk space for extends\n\t#------------------------------------------\n\t$kiwi -> info (\"Computing disk space...\");\n\t($mbytesro,$xmlsize) = $this -> getSize ($imageTree);\n\tif (defined $this->{imageTreeRW}) {\n\t\t($mbytesrw,$xmlsize) = $this -> getSize ($imageTreeRW);\n\t}\n\t$kiwi -> done ();\n\tif (defined $this->{imageTreeRW}) {\n\t\t#==========================================\n\t\t# Create RW logical extend\n\t\t#------------------------------------------\n\t\tif (defined $this->{imageTreeRW}) {\n\t\t\t$kiwi -> info (\"Image RW part requires $mbytesrw MB of disk space\");\n\t\t\tif (! $this -> buildLogicalExtend ($namerw,$mbytesrw.\"M\")) {\n\t\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t}\n\t\t#==========================================\n\t\t# Create filesystem on RW extend\n\t\t#------------------------------------------\n\t\tSWITCH: for ($FSTypeRW) {\n\t\t\t/ext2/       && do {\n\t\t\t\t$ok = $this -> setupEXT2 ( $namerw );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/ext3/       && do {\n\t\t\t\t$ok = $this -> setupEXT2 ( $namerw,\"journaled-ext3\" );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/ext4/       && do {\n\t\t\t\t$ok = $this -> setupEXT2 ( $namerw,\"journaled-ext4\" );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/reiserfs/   && do {\n\t\t\t\t$ok = $this -> setupReiser ( $namerw );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/btrfs/      && do {\n\t\t\t\t$ok = $this -> setupBTRFS ( $namerw );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/xfs/        && do {\n\t\t\t\t$ok = $this -> setupXFS ( $namerw );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t$kiwi -> error  (\"Unsupported type: $FSTypeRW\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! $ok) {\n\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Create RO logical extend\n\t#------------------------------------------\n\t$kiwi -> info (\"Image RO part requires $mbytesro MB of disk space\");\n\tif (! $this -> buildLogicalExtend ($namero,$mbytesro.\"M\")) {\n\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\tqxx (\"rm -rf $imageTree\");\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# Create filesystem on RO extend\n\t#------------------------------------------\n\tSWITCH: for ($FSTypeRO) {\n\t\t/ext2/       && do {\n\t\t\t$ok = $this -> setupEXT2 ( $namero );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/ext3/       && do {\n\t\t\t$ok = $this -> setupEXT2 ( $namero,\"journaled-ext3\" );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/ext4/       && do {\n\t\t\t$ok = $this -> setupEXT2 ( $namero,\"journaled-ext4\" );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/reiserfs/   && do {\n\t\t\t$ok = $this -> setupReiser ( $namero );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/btrfs/      && do {\n\t\t\t$ok = $this -> setupBTRFS ( $namero );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/squashfs/   && do {\n\t\t\t$ok = $this -> setupSquashFS ( $namero,$imageTree );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/xfs/      && do {\n\t\t\t$ok = $this -> setupXFS ( $namero );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t$kiwi -> error  (\"Unsupported type: $FSTypeRO\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\tqxx (\"rm -rf $imageTree\");\n\t\t$this -> cleanLuks();\n\t\treturn undef;\n\t}\n\tif (! $ok) {\n\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\tqxx (\"rm -rf $imageTree\");\n\t\t$this -> cleanLuks();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Install logical extends\n\t#------------------------------------------\n\tforeach my $name ($namerw,$namero) {\n\t\t#==========================================\n\t\t# select physical extend\n\t\t#------------------------------------------\n\t\tmy $source;\n\t\tmy $type;\n\t\tif ($name eq $namerw) {\n\t\t\t$source = $imageTreeRW;\n\t\t\t$type = $FSTypeRW;\n\t\t} else {\n\t\t\t$source = $imageTree;\n\t\t\t$type = $FSTypeRO;\n\t\t}\n\t\tif (! -d $source) {\n\t\t\tnext;\n\t\t}\n\t\tmy %fsattr = $main::global -> checkFileSystem ($type);\n\t\tif (! $fsattr{readonly}) {\n\t\t\t#==========================================\n\t\t\t# mount logical extend for data transfer\n\t\t\t#------------------------------------------\n\t\t\tmy $extend = $this -> mountLogicalExtend ($name);\n\t\t\tif (! defined $extend) {\n\t\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t\t$this -> cleanLuks();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# copy physical to logical\n\t\t\t#------------------------------------------\n\t\t\tif (! $this -> installLogicalExtend ($extend,$source)) {\n\t\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t\t$this -> cleanLuks();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$this -> cleanMount();\n\t\t}\n\t\t#==========================================\n\t\t# Checking file system\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Checking file system: $type...\");\n\t\tSWITCH: for ($type) {\n\t\t\t/ext2/       && do {\n\t\t\t\tqxx (\"/sbin/e2fsck -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/ext3/       && do {\n\t\t\t\tqxx (\"/sbin/fsck.ext3 -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\t\tqxx (\"/sbin/tune2fs -j $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/ext4/       && do {\n\t\t\t\tqxx (\"/sbin/fsck.ext4 -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\t\tqxx (\"/sbin/tune2fs -j $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/reiserfs/   && do {\n\t\t\t\tqxx (\"/sbin/reiserfsck -y $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/btrfs/      && do {\n\t\t\t\tqxx (\"/sbin/btrfsck $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/squashfs/   && do {\n\t\t\t\t$kiwi -> done ();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/xfs/        && do {\n\t\t\t\tqxx (\"/sbin/mkfs.xfs $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t$kiwi -> error  (\"Unsupported type: $type\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create image md5sum\n\t\t#------------------------------------------\n\t\t$this -> restoreImageDest();\n\t\tif (! $this -> buildMD5Sum ($name)) {\n\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> remapImageDest();\n\t}\n\t$this -> restoreImageDest();\n\t$this -> cleanLuks();\n\t#==========================================\n\t# Create network boot configuration\n\t#------------------------------------------\n\tif (! $this -> writeImageConfig ($namero)) {\n\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\tqxx (\"rm -rf $imageTree\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Cleanup temporary data\n\t#------------------------------------------\n\tqxx (\"rm -rf $imageTreeRW\");\n\tqxx (\"rm -rf $imageTree\");\n\t#==========================================\n\t# build boot image only if specified\n\t#------------------------------------------\n\tif (! defined $boot) {\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# Prepare and Create boot image\n\t#------------------------------------------\n\t$imageTree = $this->{imageTree};\n\t$kiwi -> info (\"--> Creating boot image: $boot...\\n\");\n\t@bootdata = $this -> checkAndSetupPrebuiltBootImage ($sxml);\n\tif (! @bootdata) {\n\t\treturn undef;\n\t}\n\tif ($bootdata[1] == 0) {\n\t\t#==========================================\n\t\t# Setup changeset to be used by boot image\n\t\t#------------------------------------------\n\t\tmy %XMLChangeSet = $this -> updateDescription ($sxml);\n\t\t#==========================================\n\t\t# Create tmp dir for boot image creation\n\t\t#------------------------------------------\n\t\tmy $tmpdir = qxx (\"mktemp -q -d $idest/boot-split.XXXXXX\");\n\t\tmy $result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tchomp $tmpdir;\n\t\tpush @{$this->{tmpdirs}},$tmpdir;\n\t\t#==========================================\n\t\t# Prepare boot image...\n\t\t#------------------------------------------\n\t\tmy $configDir;\n\t\tif (($type{boot} !~ /^\\//) && (! -d $type{boot})) {\n\t\t\t$configDir = $this->{gdata}->{System}.\"/\".$type{boot};\n\t\t} else {\n\t\t\t$configDir = $type{boot};\n\t\t}\n\t\tmy $rootTarget = \"$tmpdir/kiwi-splitboot-$$\";\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) || (! $kic -> prepareBootImage (\n\t\t\t$configDir,$rootTarget,$this->{imageTree},\\%XMLChangeSet))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create boot image...\n\t\t#------------------------------------------\n\t\tif ((! $kic) || (! $kic -> createBootImage (\n\t\t\t$rootTarget,$this->{imageDest}))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Clean up tmp directory\n\t\t#------------------------------------------\n\t\tqxx (\"rm -rf $tmpdir\");\n\t}\n\t#==========================================\n\t# setup initrd name\n\t#------------------------------------------\n\tmy $initrd = $idest.\"/\".$bootdata[0].\".gz\";\n\tif (! -f $initrd) {\n\t\t$initrd = $idest.\"/\".$bootdata[0];\n\t}\n\t#==========================================\n\t# Check boot and system image kernel\n\t#------------------------------------------\n\tif ($cmdL->getCheckKernel()) {\n\t\tif (! $this -> checkKernel ($initrd,$imageTree,$bootdata[0])) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Include splash screen to initrd\n\t#------------------------------------------\n\tmy $kboot  = new KIWIBoot ($kiwi,$initrd,$cmdL);\n\tif (! defined $kboot) {\n\t\treturn undef;\n\t}\n\t$kboot -> setupSplash();\n\t#==========================================\n\t# Store meta data for subsequent calls\n\t#------------------------------------------\n\t$name->{systemImage} = $sxml -> buildImageName();\n\t$name->{bootImage}   = $bootdata[0];\n\t$name->{format}      = $type{format};\n\tif ($boot =~ /vmxboot|oemboot/) {\n\t\t#==========================================\n\t\t# Create virtual disk images if requested\n\t\t#------------------------------------------\n\t\t$cmdL -> setInitrdFile (\n\t\t\t$idest.\"/\".$name->{bootImage}.\".splash.gz\"\n\t\t);\n\t\t$cmdL -> setSystemLocation (\n\t\t\t$idest.\"/\".$name->{systemImage}\n\t\t);\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) || (! $kic->createImageDisk())) {\n\t\t\tundef $kic;\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create VM format/configuration\n\t\t#------------------------------------------\n\t\tif ((defined $name->{format}) || ($xendomain eq \"domU\")) {\n\t\t\t$cmdL -> setSystemLocation (\n\t\t\t\t$idest.\"/\".$name->{systemImage}.\".raw\"\n\t\t\t);\n\t\t\t$cmdL -> setImageFormat ($name->{format});\n\t\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\t\tif ((! $kic) || (! $kic->createImageFormat())) {\n\t\t\t\tundef $kic;\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# getBlocks\n#------------------------------------------\nsub getBlocks {\n\t# ...\n\t# calculate the block size and number of blocks used\n\t# to create a <size> bytes long image. Return list\n\t# (bs,count,seek)\n\t# ---\n\tmy $size = $_[0];\n\tmy $bigimage   = 1048576; # 1M\n\tmy $smallimage = 8192;    # 8K\n\tmy $number;\n\tmy $suffix;\n\tif ($size =~ /(\\d+)(.*)/) {\n\t\t$number = $1;\n\t\t$suffix = $2;\n\t\tif ($suffix eq \"\") {\n\t\t\treturn (($size,1));\n\t\t} else {\n\t\t\tSWITCH: for ($suffix) { \n\t\t\t/K/i   && do {\n\t\t\t\t$number *= 1024;\n\t\t\tlast SWITCH;\n\t\t\t}; \n\t\t\t/M/i   && do {\n\t\t\t\t$number *= 1024 * 1024;\n\t\t\tlast SWITCH;\n\t\t\t}; \n\t\t\t/G/i   && do {\n\t\t\t\t$number *= 1024 * 1024 * 1024;\n\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t# default...\n\t\t\treturn (($size,1));\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn (($size,1));\n\t}\n\tmy $count;\n\tif ($number > 100 * 1024 * 1024) {\n\t\t# big image...\n\t\t$count = $number / $bigimage;\n\t\t$count = Math::BigFloat->new($count)->ffround(0);\n\t\treturn (($bigimage,$count,$count*$bigimage));\n\t} else {\n\t\t# small image...\n\t\t$count = $number / $smallimage;\n\t\t$count = Math::BigFloat->new($count)->ffround(0);\n\t\treturn (($smallimage,$count,$count*$smallimage));\n\t}\n}\n\n#==========================================\n# preImage\n#------------------------------------------\nsub preImage {\n\t# ...\n\t# pre-stage preparation of a logical extend.\n\t# This method includes all common not filesystem\n\t# dependant tasks before the logical extend\n\t# has been created\n\t# ---\n\tmy $this       = shift;\n\tmy $haveExtend = shift;\n\tmy $quiet      = shift;\n\t#==========================================\n\t# Get image creation date and name\n\t#------------------------------------------\n\tmy $name = $this -> buildImageName ();\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Call images.sh script\n\t#------------------------------------------\n\tmy $mBytes = $this -> setupLogicalExtend ($quiet,$name);\n\tif (! defined $mBytes) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create logical extend\n\t#------------------------------------------\n\tif (! defined $haveExtend) {\n\t\tif (! $this -> buildLogicalExtend ($name,$mBytes.\"M\")) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\treturn $name;\n}\n\n#==========================================\n# writeImageConfig\n#------------------------------------------\nsub writeImageConfig {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $configName = $this -> buildImageName() . \".config\";\n\tmy $device = $xml -> getPXEDeployImageDevice ();\n\tmy %type = %{$xml -> getImageTypeAndAttributes()};\n\t#==========================================\n\t# create .config for types which needs it\n\t#------------------------------------------\n\tif (defined $device) {\n\t\t$kiwi -> info (\"Creating boot configuration...\");\n\t\tif (! open (FD,\">$this->{imageDest}/$configName\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create image boot configuration\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $namecd = $this -> buildImageName(\";\");\n\t\tmy $namerw = $this -> buildImageName(\";\", \"-read-write\");\n\t\tmy $server = $xml -> getPXEDeployServer ();\n\t\tmy $blocks = $xml -> getPXEDeployBlockSize ();\n\t\tif (! defined $server) {\n\t\t\t$server = \"\";\n\t\t}\n\t\tif (! defined $blocks) {\n\t\t\t$blocks = \"\";\n\t\t}\n\t\tprint FD \"DISK=${device}\\n\";\n\t\tmy $targetPartition = 2;\n\t\tmy $targetPartitionNext = 3;\n\t\t#==========================================\n\t\t# PART information\n\t\t#------------------------------------------\n\t\tmy @parts = $xml -> getPXEDeployPartitions ();\n\t\tif ((scalar @parts) > 0) {\n\t\t\tprint FD \"PART=\";\n\t\t\tfor my $href (@parts) {\n\t\t\t\tif ($href -> {target}) {\n\t\t\t\t\t$targetPartition = $href -> {number};\n\t\t\t\t\t$targetPartitionNext = $targetPartition + 1;\n\t\t\t\t}\n\t\t\t\tif ($href -> {size} eq \"image\") {\n\t\t\t\t\tmy $size = $main::global -> isize (\n\t\t\t\t\t\t\"$this->{imageDest}/$name\"\n\t\t\t\t\t);\n\t\t\t\t\tprint FD int (($size/1024/1024)+1);\n\t\t\t\t} else {\n\t\t\t\t\tprint FD $href -> {size};\n\t\t\t\t}\n\n\t\t\t\tmy $type = $href -> {type};\n\t\t\t\tmy $mountpoint = $href -> {mountpoint};\n\n\t\t\t\tSWITCH: for ($type) {\n\t\t\t\t\t/swap/i && do {\n\t\t\t\t\t\t$type = \"S\";\n\t\t\t\t\t\tlast SWITCH;\n\t\t\t\t\t};\n\t\t\t\t\t/linux/i && do {\n\t\t\t\t\t\t$type = \"83\";\n\t\t\t\t\t\tlast SWITCH;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tprint FD \";$type;$mountpoint,\";\n\t\t\t}\n\t\t\tprint FD \"\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# IMAGE information\n\t\t#------------------------------------------\n\t\tif (($type{compressed}) && ($type{compressed} eq 'true')) {\n\t\t\tprint FD \"IMAGE=${device}${targetPartition};\";\n\t\t\tprint FD \"$namecd;$server;$blocks;compressed\";\n\t\t\tif (\"$type{type}\" eq \"split\" && defined $this->{imageTreeRW}) {\n\t\t\t\tprint FD \",${device}${targetPartitionNext}\";\n\t\t\t\tprint FD \";$namerw;$server;$blocks;compressed\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \"\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tprint FD \"IMAGE=${device}${targetPartition};\";\n\t\t\tprint FD \"$namecd;$server;$blocks\";\n\t\t\tif (\"$type{type}\" eq \"split\" && defined $this->{imageTreeRW}) {\n\t\t\t\tprint FD \",${device}${targetPartitionNext}\";\n\t\t\t\tprint FD \";$namerw;$server;$blocks\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \"\\n\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# CONF information\n\t\t#------------------------------------------\n\t\tmy %confs = $xml -> getPXEDeployConfiguration ();\n\t\tif ((scalar keys %confs) > 0) {\n\t\t\tprint FD \"CONF=\";\n\t\t\tforeach my $source (keys %confs) {\n\t\t\t\tprint FD \"$source;$confs{$source};$server;$blocks,\";\n\t\t\t}\n\t\t\tprint FD \"\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# COMBINED_IMAGE information\n\t\t#------------------------------------------\n\t\tif (\"$type{type}\" eq \"split\") {\n\t\t\tprint FD \"COMBINED_IMAGE=yes\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# UNIONFS_CONFIG information\n\t\t#------------------------------------------\n\t\tmy %unionConfig = $xml -> getPXEDeployUnionConfig ();\n\t\tif (%unionConfig) {\n\t\t\tmy $valid = 0;\n\t\t\tmy $value;\n\t\t\tif (! $unionConfig{type}) {\n\t\t\t\t$unionConfig{type} = \"aufs\";\n\t\t\t}\n\t\t\tif (($unionConfig{rw}) && ($unionConfig{ro})) {\n\t\t\t\t$value = \"$unionConfig{rw},$unionConfig{ro},$unionConfig{type}\";\n\t\t\t\t$valid = 1;\n\t\t\t}\n\t\t\tif ($valid) {\n\t\t\t\tprint FD \"UNIONFS_CONFIG=$value\\n\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# KIWI_BOOT_TIMEOUT information\n\t\t#------------------------------------------\n\t\tmy $timeout = $xml -> getPXEDeployTimeout ();\n\t\tif (defined $timeout) {\n\t\t\tprint FD \"KIWI_BOOT_TIMEOUT=$timeout\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# KIWI_KERNEL_OPTIONS information\n\t\t#------------------------------------------\n\t\tmy $cmdline = $type{cmdline};\n\t\tif (defined $cmdline) {\n\t\t\tprint FD \"KIWI_KERNEL_OPTIONS='$cmdline'\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# KIWI_KERNEL information\n\t\t#------------------------------------------\n\t\tmy $kernel = $xml -> getPXEDeployKernel ();\n\t\tif (defined $kernel) {\n\t\t\tprint FD \"KIWI_KERNEL=$kernel\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# KIWI_INITRD information\n\t\t#------------------------------------------\n\t\tmy $initrd = $xml -> getPXEDeployInitrd ();\n\t\tif (defined $initrd) {\n\t\t\tprint FD \"KIWI_INITRD=$initrd\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# More to come...\n\t\t#------------------------------------------\n\t\tclose FD;\n\t\t$kiwi -> done ();\n\t}\n\t# Reset main::ImageName...\n\t$this -> buildImageName();\n\treturn $configName;\n}\n\n#==========================================\n# postImage\n#------------------------------------------\nsub postImage {\n\t# ...\n\t# post-stage preparation of a logical extend.\n\t# This method includes all common not filesystem\n\t# dependant tasks after the logical extend has\n\t# been created\n\t# ---\n\tmy $this  = shift;\n\tmy $name  = shift;\n\tmy $nozip = shift;\n\tmy $fstype= shift;\n\tmy $device= shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $xml   = $this->{xml};\n\t#==========================================\n\t# mount logical extend for data transfer\n\t#------------------------------------------\n\tmy $extend = $this -> mountLogicalExtend ($name,undef,$device);\n\tif (! defined $extend) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# copy physical to logical\n\t#------------------------------------------\n\tif (! $this -> installLogicalExtend ($extend,undef,$device)) {\n\t\t$this -> cleanLuks();\n\t\treturn undef;\n\t}\n\t$this -> cleanMount();\n\t#==========================================\n\t# Check image file system\n\t#------------------------------------------\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\tif ((! $type{filesystem}) && ($fstype)) {\n\t\t$type{filesystem} = $fstype;\n\t}\n\tmy $para = $type{type}.\":\".$type{filesystem};\n\tif ($type{filesystem}) {\n\t\t$kiwi -> info (\"Checking file system: $type{filesystem}...\");\n\t} else {\n\t\t$kiwi -> info (\"Checking file system: $type{type}...\");\n\t}\n\tSWITCH: for ($para) {\n\t\t#==========================================\n\t\t# Check EXT3 file system\n\t\t#------------------------------------------\n\t\t/ext3|ec2|clicfs/i && do {\n\t\t\tqxx (\"/sbin/fsck.ext3 -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\tqxx (\"/sbin/tune2fs -j $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check EXT4 file system\n\t\t#------------------------------------------\n\t\t/ext4/i     && do {\n\t\t\tqxx (\"/sbin/fsck.ext4 -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\tqxx (\"/sbin/tune2fs -j $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check EXT2 file system\n\t\t#------------------------------------------\n\t\t/ext2/i     && do {\n\t\t\tqxx (\"/sbin/e2fsck -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check ReiserFS file system\n\t\t#------------------------------------------\n\t\t/reiserfs/i && do {\n\t\t\tqxx (\"/sbin/reiserfsck -y $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check BTRFS file system\n\t\t#------------------------------------------\n\t\t/btrfs/     && do {\n\t\t\tqxx (\"/sbin/btrfsck $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check XFS file system\n\t\t#------------------------------------------\n\t\t/xfs/       && do {\n\t\t\tqxx (\"/sbin/fsck.xfs $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Unknown filesystem type\n\t\t#------------------------------------------\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error (\"Unsupported filesystem type: $type{filesystem}\");\n\t\t$kiwi -> failed();\n\t\t$this -> cleanLuks();\n\t\treturn undef;\n\t}\n\t$this -> restoreImageDest();\n\t$this -> cleanLuks ();\n\t#==========================================\n\t# Create image md5sum\n\t#------------------------------------------\n\tif ($fstype ne \"clicfs\") {\n\t\tif (! $this -> buildMD5Sum ($name)) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Compress image using gzip\n\t#------------------------------------------\n\tif (! defined $nozip) {\n\t\tif (($type{compressed}) && ($type{compressed} eq 'true')) {\n\t\t\tif (! $this -> compressImage ($name)) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# Create image boot configuration\n\t#------------------------------------------\n\tif (! $this -> writeImageConfig ($name)) {\n\t\treturn undef;\n\t}\n\treturn $name;\n}\n\n#==========================================\n# buildLogicalExtend\n#------------------------------------------\nsub buildLogicalExtend {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $size = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $encode = 0;\n\tmy $cipher = 0;\n\tmy $out  = $this->{imageDest}.\"/\".$name;\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\t#==========================================\n\t# Check if luks encoding is requested\n\t#------------------------------------------\n\tif ($type{luks}) {\n\t\t$encode = 1;\n\t\t$cipher = \"$type{luks}\";\n\t\t$main::global -> setGlobals (\"LuksCipher\",$cipher);\n\t}\n\t#==========================================\n\t# Calculate block size and number of blocks\n\t#------------------------------------------\n\tif (! defined $size) {\n\t\treturn undef;\n\t}\n\tmy @bsc  = getBlocks ( $size );\n\tmy $seek = $bsc[2] - 1;\n\t#==========================================\n\t# Create logical extend storage and FS\n\t#------------------------------------------\n\tunlink ($out);\n\tmy $data = qxx (\"dd if=/dev/zero of=$out bs=1 seek=$seek count=1 2>&1\");\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create logical extend\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Setup encoding\n\t#------------------------------------------\n\tif ($encode) {\n\t\t$this -> setupEncoding ($name,$out,$cipher);\n\t}\n\treturn $name;\n}\n\n#==========================================\n# setupEncoding\n#------------------------------------------\nsub setupEncoding {\n\t# ...\n\t# setup LUKS encoding on the given file and remap\n\t# the imageDest variable to the new device mapper\n\t# location\n\t# ---\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $out    = shift;\n\tmy $cipher = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $data;\n\tmy $code;\n\t$data = qxx (\"/sbin/losetup -s -f $out 2>&1\"); chomp $data;\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't loop bind logical extend: $data\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $loop = $data;\n\tmy @luksloop;\n\tif ($this->{luksloop}) {\n\t\t@luksloop = @{$this->{luksloop}};\n\t}\n\tpush @luksloop,$loop;\n\t$this->{luksloop} = \\@luksloop;\n\t$data = qxx (\"echo $cipher | cryptsetup -q luksFormat $loop 2>&1\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't setup luks format: $loop\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLuks ();\n\t\treturn undef;\n\t}\n\t$data = qxx (\"echo $cipher | cryptsetup luksOpen $loop $name 2>&1\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't open luks device: $data\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLuks ();\n\t\treturn undef;\n\t}\n\tmy @luksname;\n\tif ($this->{luksname}) {\n\t\t@luksname = @{$this->{luksname}};\n\t}\n\tpush @luksname,$name;\n\t$this->{luksname} = \\@luksname;\n\tif (! $this->{imageDestOrig}) {\n\t\t$this->{imageDestOrig} = $this->{imageDest};\n\t\t$this->{imageDestMap} = \"/dev/mapper/\";\n\t}\n\t$this->{imageDest} = $this->{imageDestMap};\n\treturn $this;\n}\n\n#==========================================\n# installLogicalExtend\n#------------------------------------------\nsub installLogicalExtend {\n\tmy $this   = shift;\n\tmy $extend = shift;\n\tmy $source = shift;\n\tmy $device = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $imageTree = $this->{imageTree};\n\tif (! defined $source) {\n\t\t$source = $imageTree;\n\t}\n\t#==========================================\n\t# copy physical to logical\n\t#------------------------------------------\n\tmy $name = basename ($source);\n\t$kiwi -> info (\"Copying physical to logical [$name]...\");\n\tmy $free = qxx (\"df -h $extend 2>&1\");\n\t$kiwi -> loginfo (\"getSize: mount: $free\\n\");\n\tmy $data = qxx (\n\t\t\"tar --one-file-system -cf - -C $source . | tar -x -C $extend 2>&1\"\n\t);\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> info   (\"tar based copy failed: $data\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# dump image file from device if requested\n\t#------------------------------------------\n\tif ($device) {\n\t\t$this -> cleanMount();\n\t\t$name = $this -> buildImageName ();\n\t\t$kiwi -> info (\"Dumping filesystem image from $device...\");\n\t\t$data = qxx (\"dd if=$device of=$this->{imageDest}/$name bs=32k 2>&1\");\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to load filesystem image\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  ($data);\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\treturn $extend;\n}\n\n#==========================================\n# setupLogicalExtend\n#------------------------------------------\nsub setupLogicalExtend {\n\tmy $this  = shift;\n\tmy $quiet = shift;\n\tmy $name  = shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $imageTree = $this->{imageTree};\n\tmy $imageStrip= $this->{imageStrip};\n\tmy $initCache = $this->{initCache};\n\t#==========================================\n\t# Call images.sh script\n\t#------------------------------------------\n\tif (-x \"$imageTree/image/images.sh\") {\n\t\t$kiwi -> info (\"Calling image script: images.sh\");\n\t\tmy $data = qxx (\" chroot $imageTree /image/images.sh 2>&1 \");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\t$this -> cleanMount();\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"images.sh: $data\");\n\t\t}\n\t\t$kiwi -> done ();\n\t}\n\t#==========================================\n\t# extract kernel from physical extend\n\t#------------------------------------------\n\tif (! defined $initCache) {\n\t\tif (! $this -> extractKernel ($name)) {\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> extractSplash ($name);\n\t}\n\t#==========================================\n\t# Strip if specified\n\t#------------------------------------------\n\tif (defined $imageStrip) {\n\t\tstripImage();\n\t}\n\t#==========================================\n\t# Calculate needed space\n\t#------------------------------------------\n\t$this -> cleanKernelFSMount();\n\tmy ($mbytes,$xmlsize) = $this -> getSize ($imageTree);\n\tif (! defined $quiet) {\n\t\t$kiwi -> info (\"Image requires \".$mbytes.\"M, got $xmlsize\");\n\t\t$kiwi -> done ();\n\t\t$kiwi -> info (\"Suggested Image size: $mbytes\".\"M\");\n\t\t$kiwi -> done ();\n\t}\n\t#==========================================\n\t# Check given XML size\n\t#------------------------------------------\n\tif ($xmlsize =~ /^(\\d+)([MG])$/i) {\n\t\t$xmlsize = $1;\n\t\tmy $unit = $2;\n\t\tif ($unit eq \"G\") {\n\t\t\t# convert GB to MB...\n\t\t\t$xmlsize *= 1024;\n\t\t}\n\t}\n\t#==========================================\n\t# Return XML size or required size\n\t#------------------------------------------\n\tif (int $xmlsize > $mbytes) {\n\t\treturn $xmlsize;\n\t}\n\treturn $mbytes;\n}\n\n#==========================================\n# mountLogicalExtend\n#------------------------------------------\nsub mountLogicalExtend {\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $opts   = shift;\n\tmy $device = shift;\n\tmy $kiwi   = $this->{kiwi};\n\t#==========================================\n\t# mount logical extend for data transfer\n\t#------------------------------------------\n\tmy $target = \"$this->{imageDest}/$name\";\n\tmy $mount  = \"mount\";\n\tif (defined $opts) {\n\t\t$mount = \"mount $opts\";\n\t}\n\tif ($device) {\n\t\t$target = $device;\n\t} else {\n\t\t$mount .= \" -o loop\";\n\t}\n\tmkdir \"$this->{imageDest}/mnt-$$\";\n\t#==========================================\n\t# check for filesystem options\n\t#------------------------------------------\n\tmy $fstype = qxx (\n\t\t\"/sbin/blkid -c /dev/null -s TYPE -o value $target\"\n\t);\n\tchomp $fstype;\n\tif ($fstype eq \"ext4\") {\n\t\t# /.../\n\t\t# ext4 (currently) should be mounted with 'nodelalloc';\n\t\t# else we might run out of space unexpectedly...\n\t\t# ----\n\t\t$mount .= \",nodelalloc\";\n\t}\n\tmy $data= qxx (\n\t\t\"$mount $target $this->{imageDest}/mnt-$$ 2>&1\"\n\t);\n\tmy $code= $? >> 8;\n\tif ($code != 0) {\n\t\tchomp $data;\n\t\t$kiwi -> error  (\"Image loop mount failed:\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\n\t\t\t\"mnt: $target -> $this->{imageDest}/mnt-$$: $data\"\n\t\t);\n\t\treturn undef;\n\t}\n\treturn \"$this->{imageDest}/mnt-$$\";\n}\n\n#==========================================\n# extractSplash\n#------------------------------------------\nsub extractSplash {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $imageTree = $this->{imageTree};\n\tmy $imageDest = $this->{imageDest};\n\tmy $zipper    = $this->{gdata}->{Gzip};\n\tmy $newspl    = $imageDest.\"/splash\";\n\t#==========================================\n\t# check if boot image\n\t#------------------------------------------\n\tif (! defined $name) {\n\t\treturn $this;\n\t}\n\tif (! $this->isBootImage ($name)) {\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# move out all splash files\n\t#------------------------------------------\n\t$kiwi -> info (\"Extracting splash files...\");\n\tmkdir $newspl;\n\tmy $status = qxx (\"mv $imageTree/image/loader/*.spl $newspl 2>&1\");\n\tmy $result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> skipped ();\n\t\t$kiwi -> info (\"No splash files found in initrd\");\n\t\t$kiwi -> skipped ();\n\t\tunlink $newspl;\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# create new splash with all pictures\n\t#------------------------------------------\n\twhile (my $splash = glob(\"$newspl/*.spl\")) {\n\t\tmkdir \"$splash.dir\";\n\t\tqxx (\"$zipper -cd $splash > $splash.bob\");\n\t\tmy $count = $this -> extractCPIO ( $splash.\".bob\" );\n\t\tfor (my $id=1; $id <= $count; $id++) {\n\t\t\tqxx (\"cat $splash.bob.$id |(cd $splash.dir && cpio -i 2>&1)\");\n\t\t}\n\t\tqxx (\"cp -a $splash.dir/etc $newspl\");\n\t\t$result = 1;\n\t\tif (-e \"$splash.dir/bootsplash\") {\n\t\t\tqxx (\"cat $splash.dir/bootsplash >> $newspl/bootsplash\");\n\t\t\t$result = $? >> 8;\n\t\t}\n\t\tqxx (\"rm -rf $splash.dir\");\n\t\tqxx (\"rm -f  $splash.bob*\");\n\t\tqxx (\"rm -f  $splash\");\n\t\tif ($result != 0) {\n\t\t\tmy $splfile = basename ($splash);\n\t\t\t$kiwi -> skipped ();\n\t\t\t$kiwi -> info (\"No bootsplash file found in $splfile cpio\");\n\t\t\t$kiwi -> skipped ();\n\t\t\treturn $this;\n\t\t}\n\t}\n\tqxx (\"(cd $newspl && \\\n\t\tfind|cpio --quiet -oH newc | $zipper) > $imageDest/$name.spl\"\n\t);\n\tqxx (\"rm -rf $newspl\");\n\t$kiwi -> done();\n\treturn $this;\n}\n\n#==========================================\n# isBootImage\n#------------------------------------------\nsub isBootImage {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $xml  = $this->{xml};\n\tif (! defined $name) {\n\t\treturn $this;\n\t}\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\tmy $para = $type{type};\n\tif (defined $type{filesystem}) {\n\t\t$para = $para.\":\".$type{filesystem};\n\t}\n\tSWITCH: for ($para) {\n\t\t/ext3/i     && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/ext4/i     && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/reiserfs/i && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/iso/i && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/ext2/i && do {\n\t\t\tif ($name !~ /boot/) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/squashfs/i && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/clicfs/i && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/btrfs/i  && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/xfs/i    && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t}\n\treturn 1;\n}\n\n#==========================================\n# extractKernel\n#------------------------------------------\nsub extractKernel {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $imageTree = $this->{imageTree};\n\t#==========================================\n\t# check for boot image\n\t#------------------------------------------\n\tif (! defined $name) {\n\t\treturn $this;\n\t}\n\tif (! $this->isBootImage ($name)) {\n\t\treturn $name;\n\t}\n\t#==========================================\n\t# extract kernel from physical extend\n\t#------------------------------------------\n\treturn $this -> extractLinux (\n\t\t$name,$imageTree,$this->{imageDest}\n\t);\n}\n\n#==========================================\n# extractLinux\n#------------------------------------------\nsub extractLinux {\n\tmy $this      = shift;\n\tmy $name      = shift;\n\tmy $imageTree = shift;\n\tmy $dest      = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $xml       = $this->{xml};\n\tmy %xenc      = $xml->getXenConfig();\n\tif ((-f \"$imageTree/boot/vmlinux.gz\")  ||\n\t\t(-f \"$imageTree/boot/vmlinuz.el5\") ||\n\t\t(-f \"$imageTree/boot/vmlinux\")     ||\n\t\t(-f \"$imageTree/boot/vmlinuz\")\n\t) {\n\t\t$kiwi -> info (\"Extracting kernel...\");\n\t\t#==========================================\n\t\t# setup file names / cleanup...\n\t\t#------------------------------------------\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\tmy $shortfile = \"$name.kernel\";\n\t\tmy $file = \"$dest/$shortfile\";\n\t\tif ($file !~ /^\\//) {\n\t\t\t$file = $pwd.\"/\".$file;\n\t\t}\n\t\tif (-e $file) {\n\t\t\tqxx (\"rm -f $file\");\n\t\t}\n\t\t# /.../\n\t\t# the KIWIConfig::suseStripKernel() function provides the\n\t\t# kernel as common name /boot/vmlinuz. We use this file for\n\t\t# the extraction\n\t\t# ----\n\t\tqxx (\"cp $imageTree/boot/vmlinuz $file\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   (\"Failed to extract kernel: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $kernel = qxx (\"get_kernel_version $file\"); chomp $kernel;\n\t\tqxx (\"mv -f $file $file.$kernel && ln -s $shortfile.$kernel $file\");\n\t\t# /.../\n\t\t# check for the Xen hypervisor and extract them as well\n\t\t# ----\n\t\tif ((defined $xenc{xen_domain}) && ($xenc{xen_domain} eq \"dom0\")) {\n\t\t\tif (! -f \"$imageTree/boot/xen.gz\") {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> info   (\"Xen dom0 requested but no hypervisor found\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\tif (-f \"$imageTree/boot/xen.gz\") {\n\t\t\t$file = \"$dest/$name.kernel-xen\";\n\t\t\tqxx (\"cp $imageTree/boot/xen.gz $file\");\n\t\t\tqxx (\"mv $file $file.$kernel.'gz'\");\n\t\t}\n\t\tqxx (\"rm -rf $imageTree/boot/*\");\n\t\t$kiwi -> done();\n\t}\n\treturn $name;\n}\n\n#==========================================\n# setupEXT2\n#------------------------------------------\nsub setupEXT2 {\n\tmy $this    = shift;\n\tmy $name    = shift;\n\tmy $journal = shift;\n\tmy $device  = shift;\n\tmy $cmdL    = $this->{cmdL};\n\tmy $kiwi    = $this->{kiwi};\n\tmy $xml     = $this->{xml};\n\tmy %type    = %{$xml->getImageTypeAndAttributes()};\n\tmy $fsopts;\n\tmy $tuneopts;\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL->getFilesystemOptions()}\n\t);\n\tmy $fstool;\n\tmy $target = \"$this->{imageDest}/$name\";\n\tif ((defined $journal) && ($journal eq \"journaled-ext3\")) {\n\t\t$fsopts = $FSopts{ext3};\n\t\t$fstool = \"mkfs.ext3\";\n\t} elsif ((defined $journal) && ($journal eq \"journaled-ext4\")) {\n\t\t$fsopts = $FSopts{ext4};\n\t\t$fstool = \"mkfs.ext4\";\n\t} else {\n\t\t$fsopts = $FSopts{ext2};\n\t\t$fstool = \"mkfs.ext2\";\n\t}\n\tif ($this->{inodes}) {\n\t\t$fsopts.= \" -N $this->{inodes}\";\n\t}\n\t$tuneopts = $type{fsnocheck} eq \"true\" ? \"-c 0 -i 0\" : \"\";\n\t$tuneopts = $FSopts{extfstune} if $FSopts{extfstune};\n\tif ($device) {\n\t\t$target = $device;\n\t}\n\tmy $data = qxx (\"$fstool $fsopts $target 2>&1\");\n\tmy $code = $? >> 8;\n\tif (!$code && $tuneopts) {\n\t\t$data = qxx (\"/sbin/tune2fs $tuneopts $target 2>&1\");\n\t\t$code = $? >> 8;\n\t}\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create EXT2 filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\tif ($device) {\n\t\tqxx (\"touch $this->{imageDest}/$name\");\n\t}\n\t$this -> restoreImageDest();\n\tif ((defined $journal) && ($journal eq \"journaled-ext3\")) {\n\t\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.ext3 2>&1\");\n\t} elsif ((defined $journal) && ($journal eq \"journaled-ext4\")) {\n\t\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.ext4 2>&1\");\n\t} else {\n\t\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.ext2 2>&1\");\n\t}\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# setupBTRFS\n#------------------------------------------\nsub setupBTRFS {\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $device = shift;\n\tmy $cmdL   = $this->{cmdL};\n\tmy $kiwi   = $this->{kiwi};\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL->getFilesystemOptions()}\n\t);\n\tmy $fsopts = $FSopts{btrfs};\n\tmy $target = \"$this->{imageDest}/$name\";\n\tif ($device) {\n\t\t$target = $device;\n\t}\n\tmy $data = qxx (\n\t\t\"/sbin/mkfs.btrfs $fsopts $target 2>&1\"\n\t);\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create BTRFS filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\tif ($device) {\n\t\tqxx (\"touch $this->{imageDest}/$name\");\n\t}\n\t$this -> restoreImageDest();\n\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.btrfs 2>&1\");\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# setupReiser\n#------------------------------------------\nsub setupReiser {\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $device = shift;\n\tmy $cmdL   = $this->{cmdL};\n\tmy $kiwi   = $this->{kiwi};\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL->getFilesystemOptions()}\n\t);\n\tmy $fsopts = $FSopts{reiserfs};\n\tmy $target = \"$this->{imageDest}/$name\";\n\tif ($device) {\n\t\t$target = $device;\n\t}\n\t$fsopts.= \"-f\";\n\tmy $data = qxx (\n\t\t\"/sbin/mkreiserfs $fsopts $target 2>&1\"\n\t);\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create Reiser filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\tif ($device) {\n\t\tqxx (\"touch $this->{imageDest}/$name\");\n\t}\n\t$this -> restoreImageDest();\n\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.reiserfs 2>&1\");\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# setupSquashFS\n#------------------------------------------\nsub setupSquashFS {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $tree = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\tmy $imageTree = $this->{imageTree};\n\tmy $locator = new KIWILocator($kiwi);\n\tif (! defined $tree) {\n\t\t$tree = $imageTree;\n\t}\n\tif ($type{luks}) {\n\t\t$this -> restoreImageDest();\n\t}\n\tunlink (\"$this->{imageDest}/$name\");\n\tmy $squashfs_tool = $locator -> getExecPath(\"mksquashfs\");\n\tmy $data = qxx (\"$squashfs_tool $tree $this->{imageDest}/$name 2>&1\");\n\tmy $code = $? >> 8; \n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create squashfs filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for LUKS extension\n\t#------------------------------------------\n\tif ($type{luks}) {\n\t\tmy $outimg = $this->{imageDest}.\"/\".$name;\n\t\tmy $squashimg = $outimg.\".squashfs\";\n\t\tmy $cipher = \"$type{luks}\";\n\t\tmy $data = qxx (\"mv $outimg $squashimg 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to rename squashfs image\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $bytes = int ((-s $squashimg) * 1.1);\n\t\t$data = qxx (\n\t\t\t\"dd if=/dev/zero of=$outimg bs=1 seek=$bytes count=1 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to create luks loop container\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! $this -> setupEncoding ($name.\".squashfs\",$outimg,$cipher)) {\n\t\t\treturn undef;\n\t\t}\n\t\t$data = qxx (\n\t\t\t\"dd if=$squashimg of=$this->{imageDest}/$name.squashfs 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to dump squashfs to luks loop: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t$this -> restoreImageDest();\n\t$data = qxx (\"chmod 644 $this->{imageDest}/$name\");\n\t$data = qxx (\"rm -f $this->{imageDest}/$name.squashfs\");\n\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.squashfs 2>&1\");\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# setupXFS\n#------------------------------------------\nsub setupXFS {\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $cmdL   = $this->{cmdL};\n\tmy $kiwi   = $this->{kiwi};\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL->getFilesystemOptions()}\n\t);\n\tmy $fsopts = $FSopts{xfs};\n\tmy $data = qxx (\n\t\t\"/sbin/mkfs.xfs $fsopts $this->{imageDest}/$name 2>&1\"\n\t);\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create XFS filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t$this -> restoreImageDest();\n\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.xfs 2>&1\");\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# buildMD5Sum\n#------------------------------------------\nsub buildMD5Sum {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $initCache = $this->{initCache};\n\t#==========================================\n\t# Skip this in init cache mode\n\t#------------------------------------------\n\tif (defined $initCache) {\n\t\tif ($name =~ /\\.gz$/) {\n\t\t\t$name =~ s/\\.gz//;\n\t\t}\n\t\treturn $name;\n\t}\n\t#==========================================\n\t# Create image md5sum\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating image MD5 sum...\");\n\tmy $size = $main::global -> isize (\"$this->{imageDest}/$name\");\n\tmy $primes = qxx (\"factor $size\"); $primes =~ s/^.*: //;\n\tmy $blocksize = 1;\n\tfor my $factor (split /\\s/,$primes) {\n\t\tlast if ($blocksize * $factor > 65464);\n\t\t$blocksize *= $factor;\n\t}\n\tmy $blocks = $size / $blocksize;\n\tmy $sum  = qxx (\"cat $this->{imageDest}/$name | md5sum - | cut -f 1 -d-\");\n\tchomp $sum;\n\tif ($name =~ /\\.gz$/) {\n\t\t$name =~ s/\\.gz//;\n\t}\n\tqxx (\"echo \\\"$sum $blocks $blocksize\\\" > $this->{imageDest}/$name.md5\");\n\t$this->{md5file} = $this->{imageDest}.\"/\".$name.\".md5\";\n\t$kiwi -> done();\n\treturn $name;\n}\n\n#==========================================\n# restoreCDRootData\n#------------------------------------------\nsub restoreCDRootData {\n\tmy $this = shift;\n\tmy $imageTree    = $this->{imageTree};\n\tmy $cdrootData   = \"config-cdroot.tgz\";\n\tmy $cdrootScript = \"config-cdroot.sh\";\n\tif (-f $this->{imageDest}.\"/\".$cdrootData) {\n\t\tqxx (\"mv $this->{imageDest}/$cdrootData $imageTree/image\");\n\t}\n\tif (-f $this->{imageDest}.\"/\".$cdrootScript) {\n\t\tqxx (\"mv $this->{imageDest}/$cdrootScript $imageTree/image\");\n\t}\n}\n\n#==========================================\n# restoreSplitExtend\n#------------------------------------------\nsub restoreSplitExtend {\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $imageTreeReadOnly = $this->{imageTreeReadOnly};\n\tmy $imageTree = $this->{imageTree};\n\tif ((! defined $imageTreeReadOnly) || ( ! -d $imageTreeReadOnly)) {\n\t\treturn $imageTreeReadOnly;\n\t}\n\t$kiwi -> info (\"Restoring physical extend...\");\n\tmy @rodirs = qw (bin boot lib lib64 opt sbin usr);\n\tforeach my $dir (@rodirs) {\n\t\tif (! -d \"$imageTreeReadOnly/$dir\") {\n\t\t\tnext;\n\t\t}\n\t\tmy $data = qxx (\"mv $imageTreeReadOnly/$dir $imageTree 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't restore physical extend: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t$kiwi -> done();\n\trmdir  $imageTreeReadOnly;\n\treturn $imageTreeReadOnly;\n}\n\n#==========================================\n# compressImage\n#------------------------------------------\nsub compressImage {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $kiwi = $this->{kiwi};\n\t#==========================================\n\t# Compress image using gzip\n\t#------------------------------------------\n\t$kiwi -> info (\"Compressing image...\");\n\tmy $data = qxx (\"$this->{gdata}->{Gzip} -f $this->{imageDest}/$name\");\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error (\"Compressing image failed: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t$this -> updateMD5File (\"$this->{imageDest}/$name.gz\");\n\treturn $name;\n}\n\n#==========================================\n# updateMD5File\n#------------------------------------------\nsub updateMD5File {\n\tmy $this = shift;\n\tmy $image= shift;\n\tmy $kiwi = $this->{kiwi};\n\t#==========================================\n\t# Update md5file adding zblocks/zblocksize\n\t#------------------------------------------\n\tif (defined $this->{md5file}) {\n\t\t$kiwi -> info (\"Updating md5 file...\");\n\t\tif (! open (FD,$this->{md5file})) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to open md5 file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $line = <FD>; close FD; chomp $line;\n\t\tmy $size = $main::global -> isize ($image);\n\t\tmy $primes = qxx (\"factor $size\"); $primes =~ s/^.*: //;\n\t\tmy $blocksize = 1;\n\t\tfor my $factor (split /\\s/,$primes) {\n\t\t\tlast if ($blocksize * $factor > 65464);\n\t\t\t$blocksize *= $factor;\n\t\t}\n\t\tmy $blocks = $size / $blocksize;\n\t\tmy $md5file= $this->{md5file};\n\t\tqxx (\"echo \\\"$line $blocks $blocksize\\\" > $md5file\");\n\t\t$kiwi -> done();\n\t}\n}\n\n#==========================================\n# getSize\n#------------------------------------------\nsub getSize {\n\t# ...\n\t# calculate size of the logical extend. The\n\t# method returns the size value in MegaByte\n\t# ---\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $cmdL   = $this->{cmdL};\n\tmy $extend = shift;\n\tmy $xml    = $this->{xml};\n\tmy $mini   = qxx (\"find $extend | wc -l\"); chomp $mini;\n\tmy $minsize= qxx (\"du -s --block-size=1 $extend | cut -f1\"); chomp $minsize;\n\tmy $fsohead= 1.4;\n\tmy $spare  = 100 * 1024 * 1024;\n\tmy $files  = $mini;\n\tmy $fsopts = $cmdL -> getFilesystemOptions();\n\tmy $isize  = $fsopts->[1];\n\tmy $iratio = $fsopts->[2];\n\tmy $xmlsize;\n\t#==========================================\n\t# Double minimum inode count\n\t#------------------------------------------\n\t$mini *= 2;\n\t#==========================================\n\t# Minimum size calculated in Byte\n\t#------------------------------------------\n\t$kiwi -> loginfo (\"getSize: files: $files\\n\");\n\t$kiwi -> loginfo (\"getSize: usage: $minsize Bytes\\n\");\n\t$kiwi -> loginfo (\"getSize: inode: $isize Bytes\\n\");\n\t$minsize *= $fsohead;\n\t$minsize += $mini * $isize;\n\t$minsize += $spare;\n\t$xmlsize = $minsize;\n\t$kiwi -> loginfo (\"getSize: minsz: $minsize Bytes\\n\");\n\t#==========================================\n\t# XML size calculated in Byte\n\t#------------------------------------------\n\tmy $additive = $xml -> getImageSizeAdditiveBytes();\n\tif ($additive) {\n\t\t# relative size value specified...\n\t\t$xmlsize = $minsize + $additive;\n\t} else {\n\t\t# absolute size value specified...\n\t\t$xmlsize = $xml -> getImageSize();\n\t\tif ($xmlsize eq \"auto\") {\n\t\t\t$xmlsize = $minsize;\n\t\t} elsif ($xmlsize =~ /^(\\d+)([MG])$/i) {\n\t\t\tmy $value= $1;\n\t\t\tmy $unit = $2;\n\t\t\tif ($unit eq \"G\") {\n\t\t\t\t# convert GB to MB...\n\t\t\t\t$value *= 1024;\n\t\t\t}\n\t\t\t# convert MB to Byte\n\t\t\t$xmlsize = $value * 1048576;\n\t\t\t# check the size value with what kiwi thinks is the minimum\n\t\t\tif ($xmlsize < $minsize) {\n\t\t\t\t$kiwi -> warning (\n\t\t\t\t\t\"--> given xml size might be too small, using it anyhow !\\n\"\n\t\t\t\t);\n\t\t\t\t$kiwi -> warning (\n\t\t\t\t\t\"--> min size changed from $minsize to $xmlsize bytes\\n\"\n\t\t\t\t);\n\t\t\t\t$minsize = $xmlsize;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# Setup used size and inodes, prefer XML\n\t#------------------------------------------\n\tmy $usedsize = $minsize; \n\tif ($xmlsize > $minsize) {\n\t\t$usedsize = $xmlsize;\n\t\t$this->{inodes} = sprintf (\"%.0f\",$usedsize / $iratio);\n\t} else {\n\t\t$this->{inodes} = $mini;\n\t}\n\t#==========================================\n\t# return result list in MB\n\t#------------------------------------------\n\t$minsize = sprintf (\"%.0f\",$minsize  / 1048576);\n\t$usedsize= sprintf (\"%.0f\",$usedsize / 1048576);\n\t$usedsize.= \"M\";\n\treturn ($minsize,$usedsize);\n}\n\n#==========================================\n# checkKernel\n#------------------------------------------\nsub checkKernel {\n\t# ...\n\t# this function receives two parameters. The initrd image\n\t# file and the system image tree directory path. It checks\n\t# whether at least one kernel matches both, the initrd and\n\t# the system image. If not the function tries to copy the\n\t# kernel from the system image into the initrd. If the\n\t# system image specifies more than one kernel an error\n\t# is printed pointing out that the boot image needs to\n\t# specify one of the found system image kernels\n\t# ---\n\tmy $this    = shift;\n\tmy $initrd  = shift;\n\tmy $systree = shift;\n\tmy $name    = shift;\n\tmy $kiwi    = $this->{kiwi};\n\tmy $arch    = $this->{arch};\n\tmy $zipper  = $this->{gdata}->{Gzip};\n\tmy %sysk    = ();\n\tmy %bootk   = ();\n\tmy $status;\n\tmy $tmpdir;\n\t#==========================================\n\t# find system image kernel(s)\n\t#------------------------------------------\n\tforeach my $dir (glob (\"$systree/lib/modules/*\")) {\n\t\tif ($dir =~ /-debug$/) {\n\t\t\tnext;\n\t\t}\n\t\t$dir =~ s/$systree\\///;\n\t\t$sysk{$dir} = \"system-kernel\";\n\t}\n\tif (! %sysk) {\n\t\t$kiwi -> error  (\"Can't find any system image kernel\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# find boot image kernel\n\t#------------------------------------------\n\tmy $cmd = \"cat $initrd\";\n\tmy $zip = 0;\n\tif ($initrd =~ /\\.gz$/) {\n\t\t$cmd = \"$zipper -cd $initrd\";\n\t\t$zip = 1;\n\t}\n\tmy @status = qxx (\"$cmd|cpio -it --quiet 'lib/modules/*'|cut -f1-3 -d/\");\n\tmy $result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Can't find any boot image kernel\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tforeach my $module (@status) {\n\t\tchomp $module;\n\t\t$bootk{$module} = \"boot-kernel\";\n\t}\n\tif (! %bootk) {\n\t\t$kiwi -> error  (\"Can't find any boot image kernel\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# search system image kernel in initrd \n\t#------------------------------------------\n\tforeach my $system (keys %sysk) {\n\t\tif ($bootk{$system}) {\n\t\t\t# found system image kernel in initrd, ok\n\t\t\treturn $this;\n\t\t}\n\t}\n\t#==========================================\n\t# check system image kernel count\n\t#------------------------------------------\n\tif (keys %sysk > 1) {\n\t\t$kiwi -> error  (\"*** kernel check failed ***\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> note (\"Can't find a system kernel matching the initrd\\n\");\n\t\t$kiwi -> note (\"multiple system kernels were found, make sure your\\n\");\n\t\t$kiwi -> note (\"boot image includes the intended kernel\\n\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# fix kernel inconsistency:\n\t#------------------------------------------\n\t$kiwi -> info (\"Fixing kernel inconsistency...\");\n\t$tmpdir = qxx (\"mktemp -q -d /tmp/kiwi-fixboot.XXXXXX\"); chomp $tmpdir;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tpush @{$this->{tmpdirs}},$tmpdir;\n\t#==========================================\n\t# 1) unpack initrd...\n\t#------------------------------------------\n\t$status = qxx (\"cd $tmpdir && $cmd|cpio -di --quiet\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't unpack initrd: $status\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# 2) create images.sh script...\n\t#------------------------------------------\n\tif (! open (FD,\">$tmpdir/images.sh\")) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create image.sh file: $!\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t}\n\tprint FD '#!/bin/sh'.\"\\n\";\n\tprint FD 'test -f /.kconfig && . /.kconfig'.\"\\n\";\n\tprint FD 'test -f /.profile && . /.profile'.\"\\n\";\n\tprint FD 'echo \"*** Fixing kernel inconsistency ***\"'.\"\\n\";\n\tprint FD 'suseStripKernel'.\"\\n\";\n\tprint FD 'exit 0'.\"\\n\";\n\tclose FD;\n\t#==========================================\n\t# 3) copy system kernel to initrd...\n\t#------------------------------------------\n\tqxx (\"rm -rf $tmpdir/boot\");\n\tqxx (\"cp -a  $systree/boot $tmpdir\");\n\tqxx (\"rm -rf $tmpdir/lib/modules\");\n\tqxx (\"cp -a  $systree/lib/modules $tmpdir/lib\");\n\tqxx (\n\t\t\"cp $this->{gdata}->{BasePath}/modules/KIWIConfig.sh $tmpdir/.kconfig\"\n\t);\n\tqxx (\"chmod u+x $tmpdir/images.sh\");\n\t#==========================================\n\t# 4) call images.sh script...\n\t#------------------------------------------\n\t$status = qxx (\"chroot $tmpdir /images.sh 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> info   ($status);\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t} else {\n\t\t$kiwi -> loginfo (\"images.sh: $status\");\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# 5) extract kernel files...\n\t#------------------------------------------\n\tmy $dest = dirname $initrd;\n\tqxx (\"rm -f $dest/$name*\");\n\tif (! $this -> extractLinux ($name,$tmpdir,$dest)) {\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# 6) rebundle initrd...\n\t#------------------------------------------\n\tmy @cpio = (\"--create\", \"--format=newc\", \"--quiet\");\n\t$status = qxx ( \"cd $tmpdir && find . | cpio @cpio > $dest/$name\");\n\tif ($zip) {\n\t\t$status = qxx (\n\t\t\t\"cd $tmpdir && cat $dest/$name | $zipper -f > $initrd\"\n\t\t);\n\t} \n\t#==========================================\n\t# 7) recreate md5 file...\n\t#------------------------------------------\n\tmy $origDest = $this->{imageDest};\n\t$this->{imageDest} = $dest;\n\tif (! $this -> buildMD5Sum ($name)) {\n\t\t$this->{imageDest} = $origDest;\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t}\n\t$this->{imageDest} = $origDest;\n\tqxx (\"rm -rf $tmpdir\");\n\treturn $this;\n}\n\n#==========================================\n# cleanLuks\n#------------------------------------------\nsub cleanLuks {\n\tmy $this = shift;\n\tmy $loop = $this->{luksloop};\n\tmy $name = $this->{luksname};\n\tif ($name) {\n\t\tforeach my $luks (@{$name}) {\n\t\t\tqxx (\"cryptsetup luksClose $luks 2>&1\");\n\t\t}\n\t}\n\tif ($loop) {\n\t\tforeach my $ldev (@{$loop}) {\n\t\t\tqxx (\"losetup -d $ldev 2>&1\");\n\t\t}\n\t}\n}\n\n#==========================================\n# restoreImageDest\n#------------------------------------------\nsub restoreImageDest {\n\tmy $this = shift;\n\tif ($this->{imageDestOrig}) {\n\t\t$this->{imageDest} = $this->{imageDestOrig};\n\t}\n}\n\n#==========================================\n# remapImageDest\n#------------------------------------------\nsub remapImageDest {\n\tmy $this = shift;\n\tif ($this->{imageDestMap}) {\n\t\t$this->{imageDest} = $this->{imageDestMap};\n\t}\n}\n\n#==========================================\n# cleanMount\n#------------------------------------------\nsub cleanMount {\n\tmy $this = shift;\n\tqxx (\"umount $this->{imageDest}/mnt-$$ 2>&1\");\n\trmdir \"$this->{imageDest}/mnt-$$\";\n}\n\n#==========================================\n# cleanKernelFSMount\n#------------------------------------------\nsub cleanKernelFSMount {\n\tmy $this = shift;\n\tmy @kfs  = (\"/proc/sys/fs/binfmt_misc\",\"/proc\",\"/dev/pts\",\"/sys\");\n\tforeach my $system (@kfs) {\n\t\tqxx (\"umount $this->{imageDest}/$system 2>&1\");\n\t}\n}\n\n#==========================================\n# buildImageName\n#------------------------------------------\nsub buildImageName {\n\tmy $this = shift;\n\tmy $xml  = $this->{xml};\n\tmy $arch = $this->{arch};\n\tmy $separator = shift;\n\tmy $extension = shift;\n\tif (! defined $separator) {\n\t\t$separator = \"-\";\n\t}\n\tmy $name = $xml -> getImageName();\n\tmy $iver = $xml -> getImageVersion();\n\tif (defined $extension) {\n\t\t$name = $name.$extension.$arch.$separator.$iver;\n\t} else {\n\t\t$name = $name.$arch.$separator.$iver;\n\t}\n\tchomp  $name;\n\treturn $name;\n}\n\n#==========================================\n# extractCPIO\n#------------------------------------------\nsub extractCPIO {\n\tmy $this = shift;\n\tmy $file = shift;\n\tif (! open FD,$file) {\n\t\treturn 0;\n\t}\n\tlocal $/;\n\tmy $data   = <FD>; close FD;\n\tmy @data   = split (//,$data);\n\tmy $stream = \"\";\n\tmy $count  = 0;\n\tmy $start  = 0;\n\tmy $pos1   = -1;\n\tmy $pos2   = -1;\n\tmy @index;\n\twhile (1) {\n\t\tmy $pos1 = index ($data,\"TRAILER!!!\",$start);\n\t\tif ($pos1 >= $start) {\n\t\t\t$pos2 = index ($data,\"07070\",$pos1);\n\t\t} else {\n\t\t\tlast;\n\t\t}\n\t\tif ($pos2 >= $pos1) {\n\t\t\t$pos2--;\n\t\t\tpush (@index,$pos2);\n\t\t\t#print \"$start -> $pos2\\n\";\n\t\t\t$start = $pos2;\n\t\t} else {\n\t\t\t$pos2 = @data; $pos2--;\n\t\t\tpush (@index,$pos2);\n\t\t\t#print \"$start -> $pos2\\n\";\n\t\t\tlast;\n\t\t}\n\t}\n\tfor (my $i=0;$i<@data;$i++) {\n\t\t$stream .= $data[$i];\n\t\tif ($i == $index[$count]) {\n\t\t\t$count++;\n\t\t\tif (! open FD,\">$file.$count\") {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprint FD $stream;\n\t\t\tclose FD;\n\t\t\t$stream = \"\";\n\t\t}\n\t}\n\treturn $count;\n}\n\n#==========================================\n# makeLabel\n#------------------------------------------\nsub makeLabel {\n\t# ...\n\t# isolinux handles spaces as \"_\", so we replace\n\t# each space with an underscore\n\t# ----\n\tmy $this = shift;\n\tmy $label = shift;\n\t$label =~ s/ /_/g;\n\treturn $label;\n}\n\n#==========================================\n# Destructor\n#------------------------------------------\nsub DESTROY {\n\tmy $this = shift;\n\tmy $dirs = $this->{tmpdirs};\n\tmy $imageDest = $this->{imageDest};\n\tmy $spldir    = $imageDest.\"/splash\";\n\tforeach my $dir (@{$dirs}) {\n\t\tqxx (\"rm -rf $dir 2>&1\");\n\t}\n\tif (-d $spldir) {\n\t\tqxx (\"rm -rf $spldir 2>&1\");\n\t}\n\t$this -> cleanMount();\n\t$this -> cleanLuks();\n\treturn $this;\n}\n\n1;\n\n# vim: set noexpandtab:\n"], "fixing_code": ["#================\n# FILE          : KIWIBoot.pm\n#----------------\n# PROJECT       : OpenSUSE Build-Service\n# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany\n#               :\n# AUTHOR        : Marcus Schaefer <ms@suse.de>\n#               :\n# BELONGS TO    : Operating System images\n#               :\n# DESCRIPTION   : This module is used to create a boot USB stick\n#               : or boot cd from a previously created initrd\n#               : image\n#               : \n#               :\n# STATUS        : Development\n#----------------\npackage KIWIBoot;\n#==========================================\n# Modules\n#------------------------------------------\nrequire Exporter;\n\n#==========================================\n# Modules\n#------------------------------------------\nuse strict;\nuse Carp qw (cluck);\nuse KIWILog;\nuse KIWIIsoLinux;\nuse FileHandle;\nuse File::Basename;\nuse File::Spec;\nuse Math::BigFloat;\nuse KIWILocator;\nuse KIWIQX;\n\n#==========================================\n# Constructor\n#------------------------------------------\nsub new {\n\t# ...\n\t# Create a new KIWIBoot object which is used to create bootable\n\t# media images like CD/DVD's , USB sticks or Virtual disks \n\t# ---\n\t#==========================================\n\t# Object setup\n\t#------------------------------------------\n\tmy $this  = {};\n\tmy $class = shift;\n\tbless $this,$class;\n\t#==========================================\n\t# Module Parameters\n\t#------------------------------------------\n\tmy $kiwi   = shift;\n\tmy $initrd = shift;\n\tmy $cmdL   = shift;\n\tmy $system = shift;\n\tmy $vmsize = shift;\n\tmy $device = shift;\n\tmy $profile= shift;\n\t#==========================================\n\t# Constructor setup\n\t#------------------------------------------\n\tmy $syszip    = 0;\n\tmy $sysird    = 0;\n\tmy $zipped    = 0;\n\tmy $vga       = \"0x314\";\n\tmy $vgroup    = \"kiwiVG\";\n\tmy $haveTree  = 0;\n\tmy $haveSplit = 0;\n\tmy $vmmbyte;\n\tmy $kernel;\n\tmy $knlink;\n\tmy $tmpdir;\n\tmy $loopdir;\n\tmy $result;\n\tmy $status;\n\tmy $isxen;\n\tmy $xendomain;\n\tmy $xengz;\n\tmy $xml;\n\t#==========================================\n\t# create log object if not done\n\t#------------------------------------------\n\tif (! defined $kiwi) {\n\t\t$kiwi = new KIWILog(\"tiny\");\n\t}\n\t#==========================================\n\t# check initrd file parameter\n\t#------------------------------------------\n\tif ((defined $initrd) && (! -f $initrd)) {\n\t\t$kiwi -> error  (\"Couldn't find initrd file: $initrd\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check for split system\n\t#------------------------------------------\n\tif (-f \"$system/rootfs.tar\") {\n\t\t$kiwi -> error (\"Can't use split root tree, run create first\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# find image type...\n\t#------------------------------------------\n\tif (! defined $cmdL->getBuildType()) {\n\t\tif ($initrd =~ /oemboot/) {\n\t\t\t$cmdL -> setBuildType (\"oem\");\n\t\t}\n\t\tif ($initrd =~ /vmxboot/) {\n\t\t\t$cmdL -> setBuildType (\"vmx\");\n\t\t}\n\t}\n\t#==========================================\n\t# check system image file parameter\n\t#------------------------------------------\n\tif (defined $system) {\n\t\tif ((-f $system) || (-b $system)) {\n\t\t\tmy %fsattr = $main::global -> checkFileSystem ($system);\n\t\t\tif (($fsattr{readonly}) || ($fsattr{type} eq \"luks\")) {\n\t\t\t\t$syszip = $main::global -> isize ($system);\n\t\t\t} else {\n\t\t\t\t$syszip = 0;\n\t\t\t}\n\t\t} elsif (! -d $system) {\n\t\t\t$kiwi -> error  (\"Couldn't find image file/directory: $system\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} elsif (-f \"$system/kiwi-root.cow\") {\n\t\t\t#==========================================\n\t\t\t# Check for overlay structure\n\t\t\t#------------------------------------------\n\t\t\t$this->{overlay} = new KIWIOverlay ($kiwi,$system);\n\t\t\tif (! $this->{overlay}) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$system = $this->{overlay} -> mountOverlay();\n\t\t\tif (! -d $system) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# check if we got the tree or image file\n\t#------------------------------------------\n\tif (-d $system) {\n\t\t$haveTree = 1;\n\t}\n\t#==========================================\n\t# compressed initrd used...\n\t#------------------------------------------\n\tif ($initrd =~ /\\.gz$/) {\n\t\t$zipped = 1;\n\t}\n\t#==========================================\n\t# find kernel file\n\t#------------------------------------------\n\t$kernel = $initrd;\n\tif ($kernel =~ /gz$/) {\n\t\t$kernel =~ s/gz$/kernel/;\n\t} else {\n\t\t$kernel = $kernel.\".kernel\";\n\t}\n\tif (! -e $kernel) {\n\t\t$kernel =~ s/splash\\.kernel$/kernel/;\n\t}\n\tif (-l $kernel) {\n\t\t$knlink = $kernel;\n\t\t$kernel = readlink ($knlink);\n\t\tif (!File::Spec->file_name_is_absolute($kernel)) {\n\t\t\t$kernel = File::Spec->catfile(dirname($initrd), $kernel);\n\t\t}\n\t}\n\tif ((defined $initrd) && (! -f $kernel)) {\n\t\t$kiwi -> error  (\"Couldn't find kernel file: $kernel\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check if Xen system is used\n\t#------------------------------------------\n\t$isxen = 0;\n\t$xengz = $initrd;\n\t$xengz =~ s/\\.gz$//;\n\t$xengz =~ s/\\.splash$//;\n\tforeach my $xen (glob (\"$xengz*xen*.gz\")) {\n\t\t$isxen = 1;\n\t\t$xengz = $xen;\n\t\tlast;\n\t}\n\t#==========================================\n\t# create tmp dir for operations\n\t#------------------------------------------\n\t$tmpdir = qxx (\"mktemp -q -d /tmp/kiwiboot.XXXXXX\"); chomp $tmpdir;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$loopdir = qxx (\"mktemp -q -d /tmp/kiwiloop.XXXXXX\"); chomp $loopdir;\n\t$result  = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $loopdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! $main::global) {\n\t\t$kiwi -> error  (\"Globals object not found\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Store object data (1)\n\t#------------------------------------------\n\t$this->{gdata}    = $main::global -> getGlobals();\n\t$this->{tmpdir}   = $tmpdir;\n\t$this->{loopdir}  = $loopdir;\n\t$this->{lvmgroup} = $vgroup;\n\t$this->{tmpdirs}  = [ $tmpdir, $loopdir ];\n\t$this->{haveTree} = $haveTree;\n\t$this->{kiwi}     = $kiwi;\n\t$this->{bootsize} = 100;\n\n\t#==========================================\n\t# setup pointer to XML configuration\n\t#------------------------------------------\n\tif (defined $system) {\n\t\tif (-d $system) {\n\t\t\tmy $locator = new KIWILocator($kiwi);\n\t\t\tmy $controlFile = $locator -> getControlFile ($system.\"/image\");\n\t\t\tmy $validator = new KIWIXMLValidator (\n\t\t\t\t$kiwi,$controlFile,\n\t\t\t\t$this->{gdata}->{Revision},\n\t\t\t\t$this->{gdata}->{Schema},\n\t\t\t\t$this->{gdata}->{SchemaCVT}\n\t\t\t);\n\t\t\tmy $isValid = $validator ? $validator -> validate() : undef;\n\t\t\tif (! $isValid) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$xml = new KIWIXML (\n\t\t\t\t$kiwi,$system.\"/image\",$cmdL->getBuildType(),$profile,$cmdL\n\t\t\t);\n\t\t\t#==========================================\n\t\t\t# Determine size of /boot area\n\t\t\t#------------------------------------------\n\t\t\tif (defined $initrd) {\n\t\t\t\t$this ->{bootsize} = $this -> __getBootSize ($system);\n\t\t\t}\n\t\t} else {\n\t\t\tmy %fsattr = $main::global -> checkFileSystem ($system);\n\t\t\tif ((! $fsattr{type}) || ($fsattr{type} eq \"auto\")) {\n\t\t\t\t#==========================================\n\t\t\t\t# bind $system to loop device\n\t\t\t\t#------------------------------------------\n\t\t\t\t$kiwi -> info (\"Binding disk to loop device\");\n\t\t\t\tif (! $this -> bindDiskDevice($system)) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$kiwi -> done();\n\t\t\t\t#==========================================\n\t\t\t\t# setup device mapper\n\t\t\t\t#------------------------------------------\n\t\t\t\t$kiwi -> info (\"Setup device mapper for partition access\");\n\t\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$kiwi -> done();\n\t\t\t\t#==========================================\n\t\t\t\t# find partition and mount it\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $sdev = $this->{bindloop}.\"1\";\n\t\t\t\t#==========================================\n\t\t\t\t# check for activated volume group\n\t\t\t\t#------------------------------------------\n\t\t\t\t$sdev = $this -> checkLVMbind ($sdev,$this->{loop});\n\t\t\t\t#==========================================\n\t\t\t\t# perform mount call\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (! $main::global -> mount($sdev, $tmpdir)) {\n\t\t\t\t\t$kiwi -> error (\"System image mount failed: $status\");\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# read disk image XML description\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $locator = new KIWILocator($kiwi);\n\t\t\t\tmy $controlFile = $locator -> getControlFile ($tmpdir.\"/image\");\n\t\t\t\tmy $validator = new KIWIXMLValidator (\n\t\t\t\t\t$kiwi,$controlFile,\n\t\t\t\t\t$this->{gdata}->{Revision},\n\t\t\t\t\t$this->{gdata}->{Schema},\n\t\t\t\t\t$this->{gdata}->{SchemaCVT}\n\t\t\t\t);\n\t\t\t\tmy $isValid = $validator ? $validator -> validate() : undef;\n\t\t\t\tif (! $isValid) {\n\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$xml = new KIWIXML (\n\t\t\t\t\t$kiwi,$tmpdir.\"/image\",$cmdL->getBuildType(),$profile,$cmdL\n\t\t\t\t);\n\t\t\t\t#==========================================\n\t\t\t\t# Determine size of /boot area\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (defined $initrd) {\n\t\t\t\t\t$this ->{bootsize} = $this -> __getBootSize ($tmpdir);\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# clean up\n\t\t\t\t#------------------------------------------\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t} else {\n\t\t\t\t#==========================================\n\t\t\t\t# loop mount system image\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (! $main::global -> mount ($system,$tmpdir)) {\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# check for split type\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (-f \"$tmpdir/rootfs.tar\") {\n\t\t\t\t\t$cmdL -> setBuildType (\"split\");\n\t\t\t\t\t$haveSplit = 1;\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# read disk image XML description\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $locator = new KIWILocator($kiwi);\n\t\t\t\tmy $controlFile = $locator -> getControlFile ($tmpdir.\"/image\");\n\t\t\t\tmy $validator = new KIWIXMLValidator (\n\t\t\t\t\t$kiwi,$controlFile,\n\t\t\t\t\t$this->{gdata}->{Revision},\n\t\t\t\t\t$this->{gdata}->{Schema},\n\t\t\t\t\t$this->{gdata}->{SchemaCVT}\n\t\t\t\t);\n\t\t\t\tmy $isValid = $validator ? $validator -> validate() : undef;\n\t\t\t\tif (! $isValid) {\n\t\t\t\t\t$main::global -> umount();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$xml = new KIWIXML (\n\t\t\t\t\t$kiwi,$tmpdir.\"/image\",$cmdL->getBuildType(),$profile,$cmdL\n\t\t\t\t);\n\t\t\t\t#==========================================\n\t\t\t\t# Determine size of /boot area\n\t\t\t\t#------------------------------------------\n\t\t\t\tif (defined $initrd) {\n\t\t\t\t\t$this ->{bootsize} = $this -> __getBootSize ($tmpdir);\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# clean up\n\t\t\t\t#------------------------------------------\n\t\t\t\t$main::global -> umount();\n\t\t\t}\n\t\t}\n\t\tif (! defined $xml) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# find Xen domain configuration\n\t#------------------------------------------\n\tif ($isxen && defined $xml) {\n\t\tmy %xenc = $xml -> getXenConfig();\n\t\tif (defined $xenc{xen_domain}) {\n\t\t\t$xendomain = $xenc{xen_domain};\n\t\t} else {\n\t\t\t$xendomain = \"dom0\";\n\t\t}\n\t}\n\t#==========================================\n\t# Setup disk size and inode count\n\t#------------------------------------------\n\tif ((defined $system) && (defined $initrd)) {\n\t\tmy $sizeBytes;\n\t\tmy $minInodes;\n\t\tmy $sizeXMLBytes = 0;\n\t\tmy $spare        = 100 * 1024 * 1024; # 100M free\n\t\tmy $fsoverhead   = 1.4;\n\t\tmy $fsopts       = $cmdL -> getFilesystemOptions();\n\t\tmy $inodesize    = $fsopts->[1];\n\t\tmy $inoderatio   = $fsopts->[2];\n\t\tmy $kernelSize   = $main::global -> isize ($kernel);\n\t\tmy $initrdSize   = $main::global -> isize ($initrd);\n\t\t#==========================================\n\t\t# Calculate minimum size of the system\n\t\t#------------------------------------------\n\t\tif (-d $system) {\n\t\t\t# System is specified as a directory...\n\t\t\t$minInodes = qxx (\"find $system | wc -l\");\n\t\t\t$sizeBytes = qxx (\"du -s --block-size=1 $system | cut -f1\");\n\t\t\t$sizeBytes*= $fsoverhead;\n\t\t\tchomp $minInodes;\n\t\t\tchomp $sizeBytes;\n\t\t\t$minInodes*= 2;\n\t\t\t$sizeBytes+= $minInodes * $inodesize;\n\t\t\t$sizeBytes+= $kernelSize;\n\t\t\t$sizeBytes+= $initrdSize;\n\t\t\t$sizeBytes+= $spare;\n\t\t} else {\n\t\t\t# system is specified as a file...\n\t\t\t$sizeBytes = $main::global -> isize ($system);\n\t\t\t$sizeBytes+= $kernelSize;\n\t\t\t$sizeBytes+= $initrdSize;\n\t\t\t$sizeBytes+= $spare;\n\t\t}\n\t\t#==========================================\n\t\t# Store optional size setup from XML\n\t\t#------------------------------------------\n\t\tmy $sizeXMLAddBytes = $xml -> getImageSizeAdditiveBytes();\n\t\tif ($sizeXMLAddBytes) {\n\t\t\t$sizeXMLBytes = $sizeBytes + $sizeXMLAddBytes;\n\t\t} else {\n\t\t\t$sizeXMLBytes = $xml -> getImageSizeBytes();\n\t\t}\n\t\t#==========================================\n\t\t# Store initial disk size\n\t\t#------------------------------------------\n\t\t$this -> __initDiskSize ($sizeBytes,$vmsize,$sizeXMLBytes);\n\t\t#==========================================\n\t\t# Calculate required inode count for root\n\t\t#------------------------------------------\n\t\tif (-d $system) {\n\t\t\t# /.../\n\t\t\t# if the system is a directory the root filesystem\n\t\t\t# will be created during the image creation. In this\n\t\t\t# case we need to create the inode count\n\t\t\t# ----\n\t\t\t$this->{inodes} = int ($this->{vmmbytes} / $inoderatio);\n\t\t\t$kiwi -> loginfo (\n\t\t\t\t\"Using \".$this->{inodes}.\" inodes for the root filesystem\\n\"\n\t\t\t);\n\t\t}\n\t}\n\t#==========================================\n\t# round compressed image size\n\t#------------------------------------------\n\tif ($syszip) {\n\t\t$syszip = $syszip / 1048576;\n\t\t$syszip = sprintf (\"%.0f\", $syszip);\n\t}\n\t#==========================================\n\t# Store a disk label ID for this object\n\t#------------------------------------------\n\t$this->{mbrid} = $main::global -> getMBRDiskLabel (\n\t\t$cmdL -> getMBRID()\n\t);\n\t#==========================================\n\t# find system architecture\n\t#------------------------------------------\n\tmy $arch = qxx (\"uname -m\"); chomp $arch;\n\t#==========================================\n\t# check framebuffer vga value\n\t#------------------------------------------\n\tif (defined $xml) {\n\t\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\t\tif ($type{vga}) {\n\t\t\t$vga = $type{vga};\n\t\t}\n\t\tif ($type{luks}) {\n\t\t\t$main::global -> setGlobals (\"LuksCipher\",$type{luks});\n\t\t}\n\t}\n\t#==========================================\n\t# check partitioner\n\t#------------------------------------------\n\tmy $ptool = $cmdL -> getPartitioner();\n\tif (! $ptool) {\n\t\t$ptool = $this->{gdata}->{Partitioner};\n\t}\n\t#==========================================\n\t# Store object data (2)\n\t#------------------------------------------\n\t$this->{initrd}    = $initrd;\n\t$this->{system}    = $system;\n\t$this->{kernel}    = $kernel;\n\t$this->{syszip}    = $syszip;\n\t$this->{device}    = $device;\n\t$this->{zipped}    = $zipped;\n\t$this->{isxen}     = $isxen;\n\t$this->{xengz}     = $xengz;\n\t$this->{arch}      = $arch;\n\t$this->{ptool}     = $ptool;\n\t$this->{vga}       = $vga;\n\t$this->{xml}       = $xml;\n\t$this->{cmdL}      = $cmdL;\n\t$this->{xendomain} = $xendomain;\n\t$this->{profile}   = $profile;\n\t$this->{haveSplit} = $haveSplit;\n\t$this->{imgtype}   = $cmdL->getBuildType();\n\t$this->{chainload} = $cmdL->getGrubChainload();\n\treturn $this;\n}\n\n#==========================================\n# createBootStructure\n#------------------------------------------\nsub createBootStructure {\n\tmy $this   = shift;\n\tmy $loc    = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $initrd = $this->{initrd};\n\tmy $tmpdir = $this->{tmpdir};\n\tmy $kernel = $this->{kernel};\n\tmy $zipped = $this->{zipped};\n\tmy $isxen  = $this->{isxen};\n\tmy $xengz  = $this->{xengz};\n\tmy $xendomain = $this->{xendomain};\n\tmy $lname  = \"linux\";\n\tmy $iname  = \"initrd\";\n\tmy $xname  = \"xen.gz\";\n\tmy $zipper = $this->{gdata}->{Gzip};\n\tmy $status;\n\tmy $result;\n\tif (defined $loc) {\n\t\t$lname  = $lname.\".\".$loc;\n\t\t$iname  = $iname.\".\".$loc;\n\t\t$xname  = $xname.\".\".$loc;\n\t}\n\tif ($initrd !~ /splash\\.gz$|splash\\.install\\.gz/) {\n\t\t$initrd = $this -> setupSplash();\n\t\t$zipped = 1;\n\t}\n\t$kiwi -> info (\"Creating initial boot structure\");\n\t$status = qxx ( \"mkdir -p $tmpdir/boot 2>&1\" );\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed creating initial directories: $status\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif ($zipped) {\n\t\tif ($isxen) {\n\t\t\t# deflate/inflate initrd to make xen happy\n\t\t\tmy $irdunc = $initrd;\n\t\t\t$irdunc =~ s/\\.gz//;\n\t\t\tqxx (\"$zipper -d $initrd && $zipper $irdunc\");\n\t\t}\n\t\t$status = qxx ( \"cp $initrd $tmpdir/boot/$iname 2>&1\" );\n\t} else {\n\t\t$status = qxx ( \"cat $initrd | $zipper > $tmpdir/boot/$iname\" );\n\t}\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed importing initrd: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$status = qxx ( \"cp $kernel $tmpdir/boot/$lname 2>&1\" );\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed importing kernel: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (($isxen) && ($xendomain eq \"dom0\")) {\n\t\t$status = qxx ( \"cp $xengz $tmpdir/boot/$xname 2>&1\" );\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed importing Xen dom0 kernel: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t$kiwi -> done();\n\treturn $tmpdir;\n}\n\n#==========================================\n# getRemovableUSBStorageDevices\n#------------------------------------------\nsub getRemovableUSBStorageDevices {\n\tmy $this    = shift;\n\tmy %devices = ();\n\tmy @storage = glob (\"/sys/bus/usb/drivers/usb-storage/*\");\n\tforeach my $device (@storage) {\n\t\tif (-l $device) {\n\t\t\tmy @descriptions = glob (\"$device/host*/target*/*/block*\");\n\t\t\tforeach my $description (@descriptions) {\n\t\t\t\tif (! -d $description) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tmy $isremovable = \"$description/removable\";\n\t\t\t\tmy $serial = \"USB Stick (unknown type)\";\n\t\t\t\tif ($description =~ /usb-storage\\/(.*?):.*/) {\n\t\t\t\t\t$serial = \"/sys/bus/usb/devices/$1/serial\";\n\t\t\t\t\tif (open (FD,$serial)) {\n\t\t\t\t\t\t$serial = <FD>;\n\t\t\t\t\t\tchomp $serial;\n\t\t\t\t\t\tclose FD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($description =~ /block:(.*)/) {\n\t\t\t\t\t$description = \"/dev/\".$1;\n\t\t\t\t} else {\n\t\t\t\t\tmy @bdevs = glob (\"$description/*\");\t\n\t\t\t\t\tmy $bdev = basename ($bdevs[0]);\n\t\t\t\t\t$isremovable = $description.\"/\".$bdev.\"/removable\";\n\t\t\t\t\t$description = \"/dev/\".$bdev;\n\t\t\t\t}\n\t\t\t\tif (! open (FD,$isremovable)) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$isremovable = <FD>; close FD;\n\t\t\t\tif ($isremovable == 1) {\n\t\t\t\t\tmy $result = $this -> getStorageSize ($description);\n\t\t\t\t\tif ($result > 0) {\n\t\t\t\t\t\t$devices{$description} = $serial;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn %devices;\n}\n\n#==========================================\n# setupInstallCD\n#------------------------------------------\nsub setupInstallCD {\n\tmy $this      = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $arch      = $this->{arch};\n\tmy $initrd    = $this->{initrd};\n\tmy $system    = $this->{system};\n\tmy $oldird    = $this->{initrd};\n\tmy $zipped    = $this->{zipped};\n\tmy $isxen     = $this->{isxen};\n\tmy $lvm       = $this->{lvm};\n\tmy $xml       = $this->{xml};\n\tmy $md5name   = $system;\n\tmy $destdir   = dirname ($initrd);\n\tmy $gotsys    = 1;\n\tmy $volid     = \"-V \\\"KIWI CD/DVD Installation\\\"\";\n\tmy $bootloader;\n\tif ($arch =~ /ppc|ppc64/) {\n\t\t$bootloader = \"lilo\";\n\t} else {\n\t\t$bootloader = \"grub\";\n\t}\n\tmy $status;\n\tmy $result;\n\tmy $tmpdir;\n\tmy %type;\n\tmy $haveDiskDevice;\n\tmy $version;\n\tmy $FD;\n\t#==========================================\n\t# Check for disk device\n\t#------------------------------------------\n\tif (-b $system) {\n\t\t$haveDiskDevice = $system;\n\t\t$version = $xml -> getImageVersion();\n\t\t$system  = $xml -> getImageName();\n\t\t$system  = $destdir.\"/\".$system.\".\".$arch.\"-\".$version.\".raw\";\n\t\t$md5name = $system;\n\t\t$this->{system} = $system;\n\t}\n\t#==========================================\n\t# read MBR disk label\n\t#------------------------------------------\n\tif (! open $FD,\"dd 2>/dev/null if=$system bs=1 count=4 skip=\\$((0x1b8))|\") {\n\t\t$kiwi -> error  (\"Couldn't open: $system: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $mbrid = sprintf \"0x%08x\", unpack \"V\", <$FD>;\n\tif (($this->{mbrid}) && ($mbrid ne $this->{mbrid})) {\n\t\t$this->{mbrid} = $mbrid;\n\t}\n\tclose $FD;\n\t#==========================================\n\t# read config XML attributes\n\t#------------------------------------------\n\tif (defined $xml) {\n\t\t%type = %{$xml->getImageTypeAndAttributes()};\n\t}\n\t#==========================================\n\t# check for volume id\n\t#------------------------------------------\n\tif ((%type) && ($type{volid})) {\n\t\t$volid = \" -V \\\"$type{volid}\\\"\";\n\t}\n\t#==========================================\n\t# setup boot loader type\n\t#------------------------------------------\n\tif ((%type) && ($type{bootloader})) {\n\t\t$bootloader = $type{bootloader};\n\t}\n\t#==========================================\n\t# create tmp directory\n\t#------------------------------------------\n\tmy $basedir;\n\tif ($system) {\n\t\t$basedir = dirname ($system);\n\t} else {\n\t\t$basedir = dirname ($initrd);\n\t}\n\t$tmpdir = qxx ( \"mktemp -q -d $basedir/kiwicdinst.XXXXXX\" ); chomp $tmpdir;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$this->{tmpdir} = $tmpdir;\n\tpush @{$this->{tmpdirs}},$tmpdir;\n\t#==========================================\n\t# check if initrd is zipped\n\t#------------------------------------------\n\tif (! $zipped) {\n\t\t$kiwi -> error  (\"Compressed boot image required\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check if system image is given\n\t#------------------------------------------\n\tif (! $system) {\n\t\t$system = $initrd;\n\t\t$gotsys = 0;\n\t}\n\t#==========================================\n\t# check image type\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t#==========================================\n\t\t# build label from xml data\n\t\t#------------------------------------------\n\t\t$this->{bootlabel} = $xml -> getImageDisplayName();\n\t\tif (! $haveDiskDevice) {\n\t\t\t#==========================================\n\t\t\t# bind $system to loop device\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> info (\"Binding disk to loop device\");\n\t\t\tif (! $this -> bindDiskDevice($system)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t\t#==========================================\n\t\t\t# setup device mapper\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> info (\"Setup device mapper for partition access\");\n\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> info (\"Using disk device: $haveDiskDevice\");\n\t\t\t$this->{loop}     = $haveDiskDevice;\n\t\t\t$this->{bindloop} = $haveDiskDevice;\n\t\t\tqxx (\"vgchange -a y 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t}\n\t\t#==========================================\n\t\t# find partition to check\n\t\t#------------------------------------------\n\t\tmy $sdev;\n\t\tif ($arch =~ /ppc|ppc64/) {\n\t\t\t$sdev = $this->{bindloop}.\"2\";\n\t\t} else {\n\t\t\t$sdev = $this->{bindloop}.\"1\";\n\t\t\tif (! -e $sdev) {\n\t\t\t\t$sdev = $this->{bindloop}.\"2\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# check for activated volume group\n\t\t#------------------------------------------\n\t\t$sdev = $this -> checkLVMbind ($sdev,$this->{loop});\n\t\t#==========================================\n\t\t# perform mount call\n\t\t#------------------------------------------\n\t\tif (! $main::global -> mount ($sdev, $tmpdir)) {\n\t\t\t$kiwi -> error (\"Failed to mount system partition: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> cleanLoop();\n\t}\n\t#==========================================\n\t# Build md5sum of system image\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\tif (! $haveDiskDevice) {\n\t\t\t$this -> buildMD5Sum ($system);\n\t\t} else {\n\t\t\t$this -> buildMD5Sum ($this->{loop},$system);\n\t\t}\n\t}\n\t#==========================================\n\t# Setup image basename\n\t#------------------------------------------\n\tmy $namecd = basename ($system);\n\t#==========================================\n\t# Compress system image\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t$md5name =~ s/\\.raw$/\\.md5/;\n\t\t$kiwi -> info (\"Compressing installation image...\");\n\t\tif ($haveDiskDevice) {\n\t\t\t$status = qxx (\"cat $haveDiskDevice > $system\");\n\t\t}\n\t\t$status = qxx (\n\t\t\t\"mksquashfs $system $md5name $system.squashfs -no-progress 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to compress system image: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t$system = $system.\".squashfs\";\n\t}\n\t#==========================================\n\t# Setup initrd for install purpose\n\t#------------------------------------------\n\t$initrd = $this -> setupInstallFlags();\n\tif (! defined $initrd) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create CD structure\n\t#------------------------------------------\n\t$this->{initrd} = $initrd;\n\tif (! $this -> createBootStructure()) {\n\t\t$this->{initrd} = $oldird;\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Import boot loader stages\n\t#------------------------------------------\n\tif (! $this -> setupBootLoaderStages ($bootloader,\"iso\")) {\n\t\treturn undef;\n\t}\n\tqxx (\"rm -rf $tmpdir/usr 2>&1\");\n\tqxx (\"rm -rf $tmpdir/image 2>&1\");\n\t$this->{initrd} = $oldird;\n\t#==========================================\n\t# Creating boot loader configuration\n\t#------------------------------------------\n\tmy $title = \"KIWI CD Installation\";\n\tif (! $gotsys) {\n\t\t$title = \"KIWI CD Boot: $namecd\";\n\t}\n\tif (! $this -> setupBootLoaderConfiguration ($bootloader,$title)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for optional config-cdroot archive\n\t#------------------------------------------\n\tmy $cdrootData = \"config-cdroot.tgz\";\n\tif (-f \"$destdir/$cdrootData\") {\n\t\t$kiwi -> info (\"Integrating CD root information...\");\n\t\t$status= qxx (\n\t\t\t\"tar -C $tmpdir -xvf $destdir/$cdrootData\"\n\t\t);\n\t\t$result= $? >> 8;\n\t\tqxx (\"rm -f $destdir/$cdrootData\");\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to integrate CD root data: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Check for optional config-cdroot.sh\n\t#------------------------------------------\n\tmy $cdrootScript = \"config-cdroot.sh\";\n\tif (-x \"$destdir/$cdrootScript\") {\n\t\t$kiwi -> info (\"Calling CD root setup script...\");\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\tmy $script = \"$destdir/$cdrootScript\";\n\t\tif ($script !~ /^\\//) {\n\t\t\t$script = $pwd.\"/\".$script;\n\t\t}\n\t\t$status = qxx (\n\t\t\t\"cd $tmpdir && bash -c $script 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tqxx (\"rm -f $script\");\n\t\tif ($result != 0) {\n\t\t\tchomp $status;\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to call CD root script: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"config-cdroot.sh: $status\");\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Copy system image if given\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\tif (! open (FD,\">$tmpdir/config.isoclient\")) {\n\t\t\t$kiwi -> error  (\"Couldn't create CD install flag file\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"IMAGE='\".$namecd.\"'\\n\";\n\t\tclose FD;\n\t\t$kiwi -> info (\"Importing system image: $system\");\n\t\t$status = qxx (\"mv $system $tmpdir 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed importing system image: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$system =~ s/\\.squashfs$//;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Create an iso image from the tree\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating ISO image...\");\n\tmy $name = $system;\n\tif ($gotsys) {\n\t\t$name =~ s/raw$/iso/;\n\t} else {\n\t\t$name =~ s/gz$/iso/;\n\t}\n\tmy $base;\n\tmy $opts;\n\tif ($bootloader eq \"grub\") {\n\t\t# let isolinux run grub second stage...\n\t\t$base = \"-R -J -f -b boot/grub/stage2 -no-emul-boot $volid\";\n\t\t$opts = \"-boot-load-size 4 -boot-info-table -udf -allow-limited-size \";\n\t\t$opts.= \"-pad -joliet-long\";\n\t} elsif ($bootloader =~ /(sys|ext)linux/) {\n\t\t# turn sys/extlinux configuation into a isolinux configuration...\n\t\tmy $cfg_ext = \"$tmpdir/boot/syslinux/syslinux.cfg\";\n\t\tif (! -f $cfg_ext) {\n\t\t\t$cfg_ext = \"$tmpdir/boot/syslinux/extlinux.conf\";\n\t\t}\n\t\tmy $cfg_iso = \"$tmpdir/boot/syslinux/isolinux.cfg\";\n\t\tqxx (\"mv $cfg_ext $cfg_iso 2>&1\");\n\t\tqxx (\"mv $tmpdir/boot/initrd $tmpdir/boot/syslinux\");\n\t\tqxx (\"mv $tmpdir/boot/linux  $tmpdir/boot/syslinux\");\n\t\tqxx (\"mv $tmpdir/boot/syslinux $tmpdir/boot/loader 2>&1\");\n\t\t$base = \"-R -J -f -b boot/loader/isolinux.bin -no-emul-boot $volid\";\n\t\t$opts = \"-boot-load-size 4 -boot-info-table -udf -allow-limited-size \";\n\t\t$opts.= \"-pad -joliet-long\";\n\t} elsif ($bootloader eq \"lilo\") {\n\t\t$base = \"-r\";\n\t\t$opts = \"-U -chrp-boot -pad -joliet-long\";\n\t} else {\n\t\t# don't know how to use this bootloader together with isolinux\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Bootloader not supported for CD inst: $bootloader\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $wdir = qxx (\"pwd\"); chomp $wdir;\n\tif ($name !~ /^\\//) {\n\t\t$name = $wdir.\"/\".$name;\n\t}\n\tmy $iso = new KIWIIsoLinux (\n\t\t$kiwi,$tmpdir,$name,undef,\"checkmedia\",$this->{cmdL}\n\t);\n\tif (! defined $iso) {\n\t\treturn undef;\n\t}\n\tmy $tool= $iso -> getTool();\n\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\t$iso -> createISOLinuxConfig (\"/boot\");\n\t}\n\t$status = qxx (\"cd $tmpdir && $tool $base $opts -o $name . 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed creating ISO image: $status\");\n\t\t$kiwi -> failed ();\n\t\t$iso  -> cleanISO ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done ();\n\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\tif (! $iso->createHybrid($this->{mbrid})) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\tif ($arch !~ /ppc|ppc64/) {\n\t\tif (! $iso -> relocateCatalog ()) {\n\t\t\t$iso  -> cleanISO ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Clean tmp\n\t#------------------------------------------\n\tqxx (\"rm -rf $tmpdir\");\n\t$kiwi -> info (\"Created $name to be burned on CD\");\n\t$kiwi -> done ();\n\t$iso  -> cleanISO ();\n\treturn $this;\n}\n\n#==========================================\n# setupInstallStick\n#------------------------------------------\nsub setupInstallStick {\n\tmy $this      = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $arch      = $this->{arch};\n\tmy $initrd    = $this->{initrd};\n\tmy $system    = $this->{system};\n\tmy $oldird    = $this->{initrd};\n\tmy $device    = $this->{device};\n\tmy $loopdir   = $this->{loopdir};\n\tmy $zipped    = $this->{zipped};\n\tmy $isxen     = $this->{isxen};\n\tmy $xml       = $this->{xml};\n\tmy $cmdL      = $this->{cmdL};\n\tmy $irdsize   = $main::global -> isize ($initrd);\n\tmy $vmsize    = $main::global -> isize ($system);\n\tmy $diskname  = $system.\".install.raw\";\n\tmy $md5name   = $system;\n\tmy $destdir   = dirname ($initrd);\n\tmy %deviceMap = ();\n\tmy @commands  = ();\n\tmy $gotsys    = 1;\n\tmy $bootloader= \"grub\";\n\tmy $haveDiskDevice;\n\tmy $status;\n\tmy $result;\n\tmy $version;\n\tmy $tmpdir;\n\tmy %type;\n\tmy $stick;\n\t#==========================================\n\t# Check for disk device\n\t#------------------------------------------\n\tif (-b $system) {\n\t\t$haveDiskDevice = $system;\n\t\t$version = $xml -> getImageVersion();\n\t\t$system  = $xml -> getImageName();\n\t\t$system  = $destdir.\"/\".$system.\".\".$arch.\"-\".$version.\".raw\";\n\t\t$diskname= $system.\".install.raw\";\n\t\t$md5name = $system;\n\t\t$this->{system} = $system;\n\t}\n\t#==========================================\n\t# read config XML attributes\n\t#------------------------------------------\n\tif (defined $xml) {\n\t\t%type = %{$xml->getImageTypeAndAttributes()};\n\t}\n\t#==========================================\n\t# setup boot loader type\n\t#------------------------------------------\n\tif ((%type) && ($type{bootloader})) {\n\t\t$bootloader = $type{bootloader};\n\t}\n\t#==========================================\n\t# create tmp directory\n\t#------------------------------------------\n\t$tmpdir = qxx ( \"mktemp -q -d /tmp/kiwistickinst.XXXXXX\" ); chomp $tmpdir;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$this->{tmpdir} = $tmpdir;\n\tpush @{$this->{tmpdirs}},$tmpdir;\n\t#==========================================\n\t# check if initrd is zipped\n\t#------------------------------------------\n\tif (! $zipped) {\n\t\t$kiwi -> error  (\"Compressed boot image required\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check if system image is given\n\t#------------------------------------------\n\tif (! defined $system) {\n\t\t$system   = $initrd;\n\t\t$diskname = $initrd;\n\t\t$diskname =~ s/gz$/raw/;\n\t\t$gotsys   = 0;\n\t}\n\t#==========================================\n\t# check image type\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t#==========================================\n\t\t# build label from xml data\n\t\t#------------------------------------------\n\t\t$this->{bootlabel} = $xml -> getImageDisplayName();\n\t\tif (! $haveDiskDevice) {\n\t\t\t#==========================================\n\t\t\t# bind $system to loop device\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> info (\"Binding disk to loop device\");\n\t\t\tif (! $this -> bindDiskDevice ($system)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t\t#==========================================\n\t\t\t# setup device mapper\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> info (\"Setup device mapper for partition access\");\n\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> info (\"Using disk device: $haveDiskDevice\");\n\t\t\t$this->{loop}     = $haveDiskDevice;\n\t\t\t$this->{bindloop} = $haveDiskDevice;\n\t\t\tqxx (\"vgchange -a y 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t}\n\t\t#==========================================\n\t\t# find partition to check\n\t\t#------------------------------------------\n\t\tmy $sdev = $this->{bindloop}.\"1\";\n\t\tif (! -e $sdev) {\n\t\t\t$sdev = $this->{bindloop}.\"2\";\n\t\t}\n\t\t#==========================================\n\t\t# check for activated volume group\n\t\t#------------------------------------------\n\t\t$sdev = $this -> checkLVMbind ($sdev,$this->{loop});\n\t\t#==========================================\n\t\t# perform mount call\n\t\t#------------------------------------------\n\t\tif (! $main::global -> mount ($sdev, $tmpdir)) {\n\t\t\t$kiwi -> error  (\"Failed to mount system partition: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> cleanLoop();\n\t}\n\t$this->{bootpart}= 0;\n\t#==========================================\n\t# Build md5sum of system image\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\tif (! $haveDiskDevice) {\n\t\t\t$this -> buildMD5Sum ($system);\n\t\t} else {\n\t\t\t$this -> buildMD5Sum ($this->{loop},$system);\n\t\t}\n\t}\n\t#==========================================\n\t# Compress system image\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t$md5name =~ s/\\.raw$/\\.md5/;\n\t\t$kiwi -> info (\"Compressing installation image...\");\n\t\tif ($haveDiskDevice) {\n\t\t\t$status = qxx (\"cat $haveDiskDevice > $system\");\n\t\t}\n\t\t$status = qxx (\n\t\t\t\"mksquashfs $system $md5name $system.squashfs -no-progress 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to compress system image: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t$system = $system.\".squashfs\";\n\t\t$vmsize = -s $system;\n\t}\n\t#==========================================\n\t# setup required disk size\n\t#------------------------------------------\n\t$irdsize= ($irdsize / 1e6) + 20;\n\t$irdsize= sprintf (\"%.0f\", $irdsize);\n\t$vmsize = ($vmsize / 1e6) * 1.3 + $irdsize;\n\t$vmsize = sprintf (\"%.0f\", $vmsize);\n\t$vmsize = $vmsize.\"M\";\n\t#==========================================\n\t# Setup image basename\n\t#------------------------------------------\n\tmy $nameusb = basename ($system);\n\t#==========================================\n\t# Setup initrd for install purpose\n\t#------------------------------------------\n\t$initrd = $this -> setupInstallFlags();\n\tif (! defined $initrd) {\n\t\treturn undef;\n\t}\n\t$this->{initrd} = $initrd;\n\t#==========================================\n\t# Create Disk boot structure\n\t#------------------------------------------\n\tif (! $this -> createBootStructure(\"vmx\")) {\n\t\t$this->{initrd} = $oldird;\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Import boot loader stages\n\t#------------------------------------------\n\tif (! $this -> setupBootLoaderStages ($bootloader)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Creating boot loader configuration\n\t#------------------------------------------\n\tmy $title = \"KIWI USB-Stick Installation\";\n\tif (! $gotsys) {\n\t\t$title = \"KIWI USB Boot: $nameusb\";\n\t}\n\tif (! $this -> setupBootLoaderConfiguration ($bootloader,$title)) {\n\t\treturn undef;\n\t}\n\t$this->{initrd} = $oldird;\n\t#==========================================\n\t# create/use disk\n\t#------------------------------------------\n\tif (! $haveDiskDevice) {\n\t\t#==========================================\n\t\t# Create virtual disk to be dumped on stick\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Creating virtual disk...\");\n\t\t$status = qxx (\"qemu-img create $diskname $vmsize 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed creating virtual disk: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t$kiwi -> info (\"Binding virtual disk to loop device\");\n\t\tif (! $this -> bindDiskDevice ($diskname)) {\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t} else {\n\t\t#==========================================\n\t\t# Find USB stick devices\n\t\t#------------------------------------------\n\t\tmy $stick = $this -> searchUSBStickDevice ();\n\t\tif (! $stick) {\n\t\t\treturn undef;\n\t\t}\n\t\t$this->{loop} = $stick;\n\t}\n\t#==========================================\n\t# create disk partitions\n\t#------------------------------------------\n\t$kiwi -> info (\"Create partition table for disk\");\n\tmy $partid = \"83\";\n\tif ($bootloader eq \"syslinux\" ) {\n\t\t$partid = \"c\";\n\t}\n\tif ($gotsys) {\n\t\t@commands = (\n\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$irdsize.\"M\",\n\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\"t\",\"1\",$partid,\n\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t);\n\t} else {\n\t\t@commands = (\n\t\t\t\"n\",\"p\",\"1\",\".\",\".\",\n\t\t\t\"t\",\"1\",$partid,\n\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t);\n\t}\n\tif (! $this -> setStoragePartition ($this->{loop},\\@commands)) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create partition table\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\tif (! $haveDiskDevice ) {\n\t\t#==========================================\n\t\t# setup device mapper\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Setup device mapper for partition access\");\n\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Create loop device mapping table\n\t\t#------------------------------------------\n\t\t%deviceMap = $this -> setLoopDeviceMap ($this->{loop});\n\t} else {\n\t\t#==========================================\n\t\t# Create disk device mapping table\n\t\t#------------------------------------------\n\t\t%deviceMap = $this -> setDefaultDeviceMap ($this->{loop});\n\t\t#==========================================\n\t\t# Umount possible mounted stick partitions\n\t\t#------------------------------------------\n\t\t$this -> umountDevice ($this->{loop});\n\t\tfor (my $try=0;$try>=2;$try++) {\n\t\t\t$status = qxx (\"/sbin/blockdev --rereadpt $this->{loop} 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\tsleep (1); next;\n\t\t\t}\n\t\t\tlast;\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't reread partition table: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Wait for new partition table to settle\n\t\t#------------------------------------------\n\t\tsleep (1);\n\t\t#==========================================\n\t\t# Umount possible mounted stick partitions\n\t\t#------------------------------------------\n\t\t$this -> umountDevice ($this->{loop});\n\t}\n\tif ($bootloader eq \"extlinux\") {\n\t\t$deviceMap{extlinux} = $deviceMap{1};\n\t}\n\tif ($bootloader eq \"syslinux\") {\n\t\t$deviceMap{fat} = $deviceMap{1};\n\t}\n\tmy $boot = $deviceMap{1};\n\tmy $data;\n\tif ($gotsys) {\n\t\t$data = $deviceMap{2};\n\t}\n\t#==========================================\n\t# Create filesystem on partitions\n\t#------------------------------------------\n\tforeach my $root ($boot,$data) {\n\t\tnext if ! defined $root;\n\t\tif (($root eq $boot) && ($bootloader eq \"syslinux\")) {\n\t\t\t$kiwi -> info (\"Creating DOS boot filesystem\");\n\t\t\t$status = qxx (\"/sbin/mkdosfs $root 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t} else {\n\t\t\t$kiwi -> info (\"Creating ext3 filesystem on $root partition\");\n\t\t\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t\t\t@{$cmdL -> getFilesystemOptions()}\n\t\t\t);\n\t\t\tmy $fsopts = $FSopts{ext3};\n\t\t\tmy $fstool = \"mkfs.ext3\";\n\t\t\tif (($root eq $data) && ($this->{inodes})) {\n\t\t\t\t$fsopts.= \" -N $this->{inodes}\";\n\t\t\t}\n\t\t\t$status = qxx ( \"$fstool $fsopts $root 2>&1\" );\n\t\t\t$result = $? >> 8;\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed creating filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Copy boot data on first partition\n\t#------------------------------------------\n\t$kiwi -> info (\"Installing boot data to disk\");\n\tif (! $main::global -> mount ($boot, $loopdir)) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't mount boot partition: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$status = qxx (\"cp -a $tmpdir/boot $loopdir 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't install boot data: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$main::global -> umount();\n\t$kiwi -> done();\n\t#==========================================\n\t# Check for optional config-cdroot archive\n\t#------------------------------------------\n\tmy $cdrootData = \"config-cdroot.tgz\";\n\tif (-f \"$destdir/$cdrootData\") {\n\t\t$kiwi -> info (\"Integrating CD root information...\");\n\t\t$status= qxx (\n\t\t\t\"tar -C $loopdir -xvf $destdir/$cdrootData\"\n\t\t);\n\t\t$result= $? >> 8;\n\t\tqxx (\"rm -f $destdir/$cdrootData\");\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to integrate CD root data: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Check for optional config-cdroot.sh\n\t#------------------------------------------\n\tmy $cdrootScript = \"config-cdroot.sh\";\n\tif (-x \"$destdir/$cdrootScript\") {\n\t\t$kiwi -> info (\"Calling CD root setup script...\");\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\tmy $script = \"$destdir/$cdrootScript\";\n\t\tif ($script !~ /^\\//) {\n\t\t\t$script = $pwd.\"/\".$script;\n\t\t}\n\t\t$status = qxx (\n\t\t\t\"cd $loopdir && bash -c $script 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tqxx (\"rm -f $script\");\n\t\tif ($result != 0) {\n\t\t\tchomp $status;\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to call CD root script: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"config-cdroot.sh: $status\");\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Copy system image if defined\n\t#------------------------------------------\n\tif ($gotsys) {\n\t\t$kiwi -> info (\"Installing image data to disk\");\n\t\tif (! $main::global -> mount($data, $loopdir)) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't mount data partition: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$status = qxx (\"mv $system $loopdir 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed importing system image: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! open (FD,\">$loopdir/config.usbclient\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create USB install flag file\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"IMAGE='\".$nameusb.\"'\\n\";\n\t\tclose FD;\n\t\t$main::global -> umount();\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Install boot loader on disk\n\t#------------------------------------------\n\tmy $bootdevice = $diskname;\n\tif ($haveDiskDevice) {\n\t\t$bootdevice = $this->{loop};\n\t}\n\tif (! $this -> installBootLoader ($bootloader, $bootdevice, \\%deviceMap)) {\n\t\t$this -> cleanLoopMaps();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$this -> cleanLoopMaps();\n\t$this -> cleanLoop();\n\tif (! $haveDiskDevice) {\n\t\t$kiwi -> info (\"Created $diskname to be dd'ed on Stick\");\n\t} else {\n\t\t$kiwi -> info (\"Successfully created install stick on $this->{loop}\");\n\t}\n\t$kiwi -> done ();\n\treturn $this;\n}\n\n#==========================================\n# setupBootDisk\n#------------------------------------------\nsub setupBootDisk {\n\tmy $this      = shift;\n\tmy $device    = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $arch      = $this->{arch};\n\tmy $system    = $this->{system};\n\tmy $syszip    = $this->{syszip};\n\tmy $tmpdir    = $this->{tmpdir};\n\tmy $initrd    = $this->{initrd};\n\tmy $loopdir   = $this->{loopdir};\n\tmy $zipped    = $this->{zipped};\n\tmy $isxen     = $this->{isxen};\n\tmy $lvm       = $this->{lvm};\n\tmy $profile   = $this->{profile};\n\tmy $xendomain = $this->{xendomain};\n\tmy $xml       = $this->{xml};\n\tmy $cmdL      = $this->{cmdL};\n\tmy $haveTree  = $this->{haveTree};\n\tmy $imgtype   = $this->{imgtype};\n\tmy $haveSplit = $this->{haveSplit};\n\tmy $bootsize  = $this->{bootsize};\n\tmy $diskname  = $system.\".raw\";\n\tmy %deviceMap = ();\n\tmy @commands  = ();\n\tmy $bootfix   = \"VMX\";\n\tmy $dmapper   = 0;\n\tmy $haveluks  = 0;\n\tmy $needBootP = 0;\n\tmy $bootloader;\n\tmy $boot;\n\tif ($arch =~ /ppc|ppc64/) {\n\t\t$bootloader = \"lilo\";\n\t} else {\n\t\t$bootloader = \"grub\";\n\t}\n\tmy $haveDiskDevice;\n\tmy $splitfile;\n\tmy $version;\n\tmy $label;\n\tmy $FSTypeRW;\n\tmy $FSTypeRO;\n\tmy $sysname;\n\tmy $sysird;\n\tmy $result;\n\tmy $status;\n\tmy $destdir;\n\tmy %lvmparts;\n\t#==========================================\n\t# check if we got a real device\n\t#------------------------------------------\n\tif ($device) {\n\t\t$haveDiskDevice = $device;\n\t}\n\t#==========================================\n\t# load type attributes...\n\t#------------------------------------------\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\t#==========================================\n\t# Check for LVM...\n\t#------------------------------------------\n\tif (($type{lvm} =~ /true|yes/i) || ($lvm)) {\n\t\t#==========================================\n\t\t# add boot space if lvm based\n\t\t#------------------------------------------\n\t\t$lvm = 1;\n\t\t$this->{lvm}= $lvm;\n\t\t#==========================================\n\t\t# set volume group name\n\t\t#------------------------------------------\n\t\tmy $vgroupName = $xml -> getLVMGroupName();\n\t\tif ($vgroupName) {\n\t\t\t$this->{lvmgroup} = $vgroupName;\n\t\t}\n\t\t#==========================================\n\t\t# check and set LVM volumes setup\n\t\t#------------------------------------------\n\t\t%lvmparts = $xml -> getLVMVolumes();\n\t\tif (%lvmparts) {\n\t\t\tif ( ! -d $system ) {\n\t\t\t\t$kiwi -> error (\n\t\t\t\t\t\"LVM volumes setup requires root tree but got image file\"\n\t\t\t\t);\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tforeach my $vol (keys %lvmparts) {\n\t\t\t\t#==========================================\n\t\t\t\t# check directory per volume\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $pname  = $vol; $pname =~ s/_/\\//g;\n\t\t\t\tif (! -d \"$system/$pname\") {\n\t\t\t\t\t$kiwi -> error (\"LVM: No such directory $system/$pname\");\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t#==========================================\n\t\t\t\t# store volume sizes in lvmparts\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $space = 0;\n\t\t\t\tmy $diff  = 0;\n\t\t\t\tmy $haveAbsolute;\n\t\t\t\tif ($lvmparts{$vol}) {\n\t\t\t\t\t$space = $lvmparts{$vol}->[0];\n\t\t\t\t\t$haveAbsolute = $lvmparts{$vol}->[1];\n\t\t\t\t}\n\t\t\t\tmy $lvsize = qxx (\n\t\t\t\t\t\"du -s --block-size=1 $system/$pname | cut -f1\"\n\t\t\t\t);\n\t\t\t\tchomp $lvsize;\n\t\t\t\t$lvsize /= 1048576;\n\t\t\t\tif ($haveAbsolute) {\n\t\t\t\t\tif ($space > ($lvsize + 30)) {\n\t\t\t\t\t\t$diff = $space - $lvsize;\n\t\t\t\t\t\t$lvsize = $space;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$lvsize += 30;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$lvsize = int ( 30 + $lvsize + $space);\n\t\t\t\t}\n\t\t\t\t$lvmparts{$vol}->[2] = $lvsize;\n\t\t\t\t#==========================================\n\t\t\t\t# increase total vm disk size\n\t\t\t\t#------------------------------------------\n\t\t\t\t$kiwi->loginfo (\"Increasing disk size for volume $pname\\n\");\n\t\t\t\tif ($haveAbsolute) {\n\t\t\t\t\t$this -> __updateDiskSize ($diff + 30);\n\t\t\t\t} else {\n\t\t\t\t\t$this -> __updateDiskSize ($space+ 30);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# check for overlay filesystems\n\t#------------------------------------------\n\tif ($type{filesystem} eq \"clicfs\") {\n\t\t$this->{dmapper} = 1;\n\t\t$dmapper  = 1;\n\t}\n\t#==========================================\n\t# check if fs requires a boot partition\n\t#------------------------------------------\n\tif (($type{filesystem} eq \"btrfs\") || ($type{filesystem} eq \"xfs\")) {\n\t\t$needBootP  = 1;\n\t}\n\t#==========================================\n\t# check for LUKS extension\n\t#------------------------------------------\n\tif ($type{luks}) {\n\t\t$haveluks   = 1;\n\t}\n\t#==========================================\n\t# setup boot loader type\n\t#------------------------------------------\n\tif ($type{bootloader}) {\n\t\t$bootloader = $type{bootloader};\n\t}\n\t$this->{bootloader} = $bootloader;\n\t#==========================================\n\t# add boot space if syslinux based\n\t#------------------------------------------\n\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\tmy $fatstorage = $cmdL->getFatStorage();\n\t\tif (defined $fatstorage) {\n\t\t\tif ($bootsize < $fatstorage) {\n\t\t\t\t$bootsize = $fatstorage;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# build disk name and label from xml data\n\t#------------------------------------------\n\t$destdir  = dirname ($initrd);\n\t$label    = $xml -> getImageDisplayName();\n\t$version  = $xml -> getImageVersion();\n\t$diskname = $xml -> getImageName();\n\t$diskname = $destdir.\"/\".$diskname.\".\".$arch.\"-\".$version.\".raw\";\n\t$splitfile= $destdir.\"/\".$label.\"-read-write.\".$arch.\"-\".$version;\n\t$this->{bootlabel}= $label;\n\t#==========================================\n\t# build bootfix for the bootloader on oem\n\t#------------------------------------------\n\tif ($initrd =~ /oemboot/) {\n\t\tmy $oemtitle = $xml -> getOEMBootTitle();\n\t\tif ($oemtitle) {\n\t\t\t$this->{bootlabel} = $oemtitle;\n\t\t\t$bootfix = \"OEM\";\n\t\t}\n\t}\n\t#==========================================\n\t# increase disk size for in-place recovery\n\t#------------------------------------------\n\tmy $inplace = $xml -> getOEMRecoveryInPlace();\n\tif (($inplace) && (\"$inplace\" eq \"true\")) {\n\t\tmy ($FD,$recoMB);\n\t\tmy $sizefile = \"$destdir/recovery.partition.size\";\n\t\tif (open ($FD,$sizefile)) {\n\t\t\t$recoMB = <$FD>; chomp $recoMB;\tclose $FD; unlink $sizefile;\n\t\t\t$kiwi -> info (\n\t\t\t\t\"Adding $recoMB MB spare space for in-place recovery\"\n\t\t\t);\n\t\t\t$this -> __updateDiskSize ($recoMB);\n\t\t\t$kiwi -> done ();\n\t\t}\n\t}\n\t#==========================================\n\t# increase vmsize if image split RW portion\n\t#------------------------------------------\n\tif (($imgtype eq \"split\") && (-f $splitfile)) {\n\t\tmy $splitsize = $main::global -> isize ($splitfile);\n\t\tmy $splitMB = $splitsize / 1048576;\n\t\t$kiwi -> info (\n\t\t\t\"Adding $splitMB MB space for split read-write portion\"\n\t\t);\n\t\t$this -> __updateDiskSize ($splitMB);\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# obtain filesystem type from xml data\n\t#------------------------------------------\n\tif ($type{filesystem} =~ /(.*),(.*)/) {\n\t\t$FSTypeRW = $1;\n\t\t$FSTypeRO = $2;\n\t} else {\n\t\t$FSTypeRW = $type{filesystem};\n\t\t$FSTypeRO = $FSTypeRW;\n\t}\n\tif ($haveSplit) {\n\t\tmy %fsattr = $main::global -> checkFileSystem ($FSTypeRW);\n\t\tif ($fsattr{readonly}) {\n\t\t\t$kiwi -> error (\"Can't copy data into requested RO filesystem\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Create Disk boot structure\n\t#------------------------------------------\n\tif (! $this -> createBootStructure(\"vmx\")) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Setup boot partition ID\n\t#------------------------------------------\n\tmy $bootpart = \"0\";\n\tif (($syszip) || ($haveSplit) || ($haveluks) || ($needBootP)) {\n\t\t$bootpart = \"1\";\n\t}\n\tif ((($syszip) || ($haveSplit)) && ($haveluks)) {\n\t\t$bootpart = \"2\";\n\t}\n\tif ($dmapper) {\n\t\t$bootpart = \"2\"\n\t}\n\tif ($lvm) {\n\t\t$bootpart = \"0\";\n\t}\n\t$this->{bootpart} = $bootpart;\n\t#==========================================\n\t# Update raw disk size if boot part is used\n\t#------------------------------------------\n\tif (($syszip)    ||\n\t\t($haveSplit) ||\n\t\t($haveluks)  ||\n\t\t($needBootP) ||\n\t\t($dmapper)   ||\n\t\t($lvm)\n\t) {\n\t\t$this -> __updateDiskSize ($bootsize);\n\t}\n\t#==========================================\n\t# Import boot loader stages\n\t#------------------------------------------\n\tif (! $this -> setupBootLoaderStages ($bootloader)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# add extra Xen boot options if necessary\n\t#------------------------------------------\n\tmy $extra = \"\";\n\t#==========================================\n\t# Create boot loader configuration\n\t#------------------------------------------\n\tif (! $this -> setupBootLoaderConfiguration ($bootloader,$bootfix,$extra)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# create/use disk\n\t#------------------------------------------\n\tmy $dmap; # device map\n\tmy $root; # root device\n\tif (! defined $system) {\n\t\t$kiwi -> error  (\"No system image given\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! $haveDiskDevice) {\n\t\t$kiwi -> info (\"Creating virtual disk...\");\n\t} else {\n\t\t$kiwi -> info (\"Using disk device $haveDiskDevice...\");\n\t}\n\twhile (1) {\n\t\tif (! $haveDiskDevice) {\n\t\t\t$status = qxx (\"qemu-img create $diskname $this->{vmsize} 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Failed creating virtual disk: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# setup loop device for virtual disk\n\t\t\t#------------------------------------------\n\t\t\tif (! $this -> bindDiskDevice($diskname)) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t} else {\n\t\t\t# /.../\n\t\t\t# the following is required for suse studio to determine the\n\t\t\t# size of the image target disk. It has no relevance for the\n\t\t\t# standard build process and is therefore called without any\n\t\t\t# return value check. \n\t\t\tqxx (\"qemu-img create $diskname $this->{vmsize} 2>&1\");\n\t\t\t# ----\n\t\t\t$this->{loop} = $haveDiskDevice;\n\t\t\tif (! -b $this->{loop}) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"No such block device: $this->{loop}\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# create disk partition\n\t\t#------------------------------------------\n\t\tif ($arch =~ /ppc|ppc64/) {\n\t\t\tmy $prepsize = $bootsize;\n\t\t\tif (! $lvm) {\n\t\t\t\t@commands = (\n\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$prepsize.\"M\",\n\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\"t\",\"1\",\"41\",\n\t\t\t\t\t\"t\",\"2\",\"83\",\n\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t@commands = (\n\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$bootsize.\"M\",\n\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\"t\",\"1\",\"c\",\n\t\t\t\t\t\"t\",\"2\",\"8e\",\n\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\tif (! $lvm) {\n\t\t\tif (($syszip) || ($haveSplit) || ($dmapper)) {\n\t\t\t\t# xda1 ro / xda2 rw\n\t\t\t\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\t\t\t\tmy $partid = \"c\";\n\t\t\t\t\tif ($bootloader eq \"extlinux\" ) {\n\t\t\t\t\t\t$partid = \"83\";\n\t\t\t\t\t}\n\t\t\t\t\tmy $syslsize = $this->{vmmbyte} - $bootsize - $syszip;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syszip.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\"+\".$syslsize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"3\",\".\",\".\",\n\t\t\t\t\t\t\"t\",\"3\",$partid,\n\t\t\t\t\t\t\"a\",\"3\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} elsif ($dmapper) {\n\t\t\t\t\tmy $dmsize = $this->{vmmbyte} - $bootsize - $syszip;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syszip.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\"+\".$dmsize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"3\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"3\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} elsif ($haveluks) {\n\t\t\t\t\tmy $lukssize = $this->{vmmbyte} - $bootsize - $syszip;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syszip.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\"+\".$lukssize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"3\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"3\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syszip.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"2\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t# xda1 rw\n\t\t\t\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\t\t\t\tmy $partid = \"c\";\n\t\t\t\t\tif ($bootloader eq \"extlinux\" ) {\n\t\t\t\t\t\t$partid = \"83\";\n\t\t\t\t\t}\n\t\t\t\t\tmy $syslsize = $this->{vmmbyte} - $bootsize;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$syslsize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\t\"t\",\"2\",$partid,\n\t\t\t\t\t\t\"a\",\"2\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} elsif (($haveluks) || ($needBootP)) {\n\t\t\t\t\tmy $lukssize = $this->{vmmbyte} - $bootsize;\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\"+\".$lukssize.\"M\",\n\t\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"2\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t@commands = (\n\t\t\t\t\t\t\"n\",\"p\",\"1\",\".\",\".\",\n\t\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ($bootloader =~ /(sys|ext)linux/) {\n\t\t\t\tmy $partid = \"c\";\n\t\t\t\tif ($bootloader eq \"extlinux\" ) {\n\t\t\t\t\t$partid = \"83\";\n\t\t\t\t}\n\t\t\t\tmy $lvmsize = $this->{vmmbyte} - $bootsize;\n\t\t\t\tmy $bootpartsize = \"+\".$bootsize.\"M\";\n\t\t\t\t@commands = (\n\t\t\t\t\t\"n\",\"p\",\"1\",\".\",$bootpartsize,\n\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\"t\",\"1\",$partid,\n\t\t\t\t\t\"t\",\"2\",\"8e\",\n\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmy $lvmsize = $this->{vmmbyte} - $bootsize;\n\t\t\t\tmy $bootpartsize = \"+\".$bootsize.\"M\";\n\t\t\t\t@commands = (\n\t\t\t\t\t\"n\",\"p\",\"1\",\".\",$bootpartsize,\n\t\t\t\t\t\"n\",\"p\",\"2\",\".\",\".\",\n\t\t\t\t\t\"t\",\"2\",\"8e\",\n\t\t\t\t\t\"a\",\"1\",\"w\",\"q\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif (! $this -> setStoragePartition ($this->{loop},\\@commands)) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create partition table\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! $haveDiskDevice ) {\n\t\t\t#==========================================\n\t\t\t# setup device mapper\n\t\t\t#------------------------------------------\n\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# Create loop device mapping table\n\t\t\t#------------------------------------------\n\t\t\t%deviceMap = $this -> setLoopDeviceMap ($this->{loop});\n\t\t} else {\n\t\t\t#==========================================\n\t\t\t# Create disk device mapping table\n\t\t\t#------------------------------------------\n\t\t\tif ($arch =~ /ppc|ppc64/) {\n\t\t\t\t%deviceMap = $this -> setPPCDeviceMap ($this->{loop});\n\t\t\t} else {\n\t\t\t\t%deviceMap = $this -> setDefaultDeviceMap ($this->{loop});\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# Umount possible mounted stick partitions\n\t\t\t#------------------------------------------\n\t\t\t$this -> umountDevice ($this->{loop});\n\t\t\tfor (my $try=0;$try>=2;$try++) {\n\t\t\t\t$status = qxx (\"/sbin/blockdev --rereadpt $this->{loop} 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t\tif ($result != 0) {\n\t\t\t\t\tsleep (1); next;\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't reread partition table: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# Wait for new partition table to settle\n\t\t\t#------------------------------------------\n\t\t\tsleep (1);\n\t\t\t#==========================================\n\t\t\t# Umount possible mounted stick partitions\n\t\t\t#------------------------------------------\n\t\t\t$this -> umountDevice ($this->{loop});\n\t\t}\n\t\t#==========================================\n\t\t# setup volume group if requested\n\t\t#------------------------------------------\n\t\tif ($lvm) {\n\t\t\t%deviceMap = $this -> setVolumeGroup (\n\t\t\t\t\\%deviceMap,$this->{loop},$syszip,$haveSplit,\\%lvmparts\n\t\t\t);\n\t\t\tif (! %deviceMap) {\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# set root device name from deviceMap\n\t\t#------------------------------------------\n\t\tif (($arch =~ /ppc|ppc64/) && (!$lvm)) {\n\t\t\t$root = $deviceMap{2};\n\t\t} else {\n\t\t\t$root = $deviceMap{1};\n\t\t}\n\t\t#==========================================\n\t\t# check partition sizes\n\t\t#------------------------------------------\n\t\tif ($syszip > 0) {\n\t\t\tmy $sizeOK = 1;\n\t\t\tmy $systemPSize = $this->getStorageSize ($deviceMap{1});\n\t\t\tmy $systemISize = $main::global -> isize ($system);\n\t\t\t$systemISize /= 1024;\n\t\t\tchomp $systemPSize;\n\t\t\t#print \"_______A $systemPSize : $systemISize\\n\";\n\t\t\tif ($systemPSize < $systemISize) {\n\t\t\t\t$syszip += 10;\n\t\t\t\t$sizeOK = 0;\n\t\t\t}\n\t\t\tif (! $sizeOK) {\n\t\t\t\t#==========================================\n\t\t\t\t# bad partition alignment try again\n\t\t\t\t#------------------------------------------\n\t\t\t\tsleep (1);\n\t\t\t\t$this -> deleteVolumeGroup();\n\t\t\t\t$this -> cleanLoopMaps();\n\t\t\t\tqxx (\"/sbin/losetup -d $this->{loop}\");\n\t\t\t} else {\n\t\t\t\t#==========================================\n\t\t\t\t# looks good go for it\n\t\t\t\t#------------------------------------------\n\t\t\t\tlast;\n\t\t\t}\n\t\t} else {\n\t\t\t#==========================================\n\t\t\t# entire disk used\n\t\t\t#------------------------------------------\n\t\t\tlast;\n\t\t}\n\t\t$kiwi -> note (\".\");\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# Dump system image on disk\n\t#------------------------------------------\n\tif (! $haveTree) {\n\t\t$kiwi -> info (\"Dumping system image on disk\");\n\t\t$status = qxx (\"dd if=$system of=$root bs=32k 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't dump image to disk: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\t$result = 0;\n\t\tmy $mapper = $root;\n\t\tmy %fsattr = $main::global -> checkFileSystem ($root);\n\t\tif ($fsattr{type} eq \"luks\") {\n\t\t\t$mapper = $this -> luksResize ($root,\"luks-resize\");\n\t\t\tif (! $mapper) {\n\t\t\t\t$this -> luksClose();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t%fsattr= $main::global -> checkFileSystem ($mapper);\n\t\t}\n\t\tmy $expanded = $this -> __expandFS (\n\t\t\t$fsattr{type},'system', $mapper\n\t\t);\n\t\tif (! $expanded ) {\n\t\t\treturn undef;\n\t\t}\n\t\tif ($haveSplit) {\n\t\t\t$kiwi -> info (\"Dumping split read/write part on disk\");\n\t\t\t$root = $deviceMap{2};\n\t\t\t$status = qxx (\"dd if=$splitfile of=$root bs=32k 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't dump split file: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t\t$result = 0;\n\t\t\t$mapper = $root;\n\t\t\tmy %fsattr = $main::global -> checkFileSystem ($root);\n\t\t\tif ($fsattr{type} eq \"luks\") {\n\t\t\t\t$mapper = $this -> luksResize ($root,\"luks-resize\");\n\t\t\t\tif (! $mapper) {\n\t\t\t\t\t$this -> luksClose();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t%fsattr= $main::global -> checkFileSystem ($mapper);\n\t\t\t}\n\t\t\tmy $expanded = $this -> __expandFS (\n\t\t\t\t$fsattr{type},'split', $mapper\n\t\t\t);\n\t\t\tif (! $expanded ) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t#==========================================\n\t\t# Create fs on system image partition\n\t\t#------------------------------------------\n\t\tif (! $this -> setupFilesystem ($FSTypeRO,$root,\"root\")) {\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Mount system image partition\n\t\t#------------------------------------------\n\t\tif (! $main::global -> mount ($root, $loopdir)) {\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create LVM volumes filesystems\n\t\t#------------------------------------------\n\t\tif (($lvm) && (%lvmparts)) {\n\t\t\tmy $VGroup = $this->{lvmgroup};\n\t\t\tmy @paths  = ();\n\t\t\tmy %phash  = ();\n\t\t\t#==========================================\n\t\t\t# Create path names in correct order\n\t\t\t#------------------------------------------\n\t\t\tsub numeric {\n\t\t\t\t($a <=> $b) || ($a cmp $b);\n\t\t\t}\n\t\t\tforeach my $name (keys %lvmparts) {\n\t\t\t\tmy $pname  = $name; $pname =~ s/_/\\//g;\n\t\t\t\t$pname =~ s/^\\///;\n\t\t\t\t$pname =~ s/\\s*$//;\n\t\t\t\tpush @paths,$pname;\n\t\t\t}\n\t\t\tforeach my $name (@paths) {\n\t\t\t\tmy $part = split (/\\//,$name);\n\t\t\t\tpush @{$phash{$part}},$name;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# Create filesystems and Mount LVM volumes\n\t\t\t#------------------------------------------\n\t\t\tforeach my $level (sort numeric keys %phash) {\n\t\t\t\tforeach my $pname (@{$phash{$level}}) {\n\t\t\t\t\tmy $lname = $pname; $lname =~ s/\\//_/g;\n\t\t\t\t\tmy $device = \"/dev/$VGroup/LV$lname\";\n\t\t\t\t\t$status = qxx (\"mkdir -p $loopdir/$pname 2>&1\");\n\t\t\t\t\t$result = $? >> 8;\n\t\t\t\t\tif ($result != 0) {\n\t\t\t\t\t\t$kiwi -> error (\"Can't create mount point $loopdir/$pname\");\n\t\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\t\treturn undef;\n\t\t\t\t\t}\n\t\t\t\t\tif (! $this -> setupFilesystem ($FSTypeRO,$device,$pname)) {\n\t\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\t\treturn undef;\n\t\t\t\t\t}\n\t\t\t\t\t$kiwi -> loginfo (\"Mounting logical volume: $pname\\n\");\n\t\t\t\t\tif (! $main::global -> mount ($device, \"$loopdir/$pname\")) {\n\t\t\t\t\t\t$this -> cleanLoop ();\n\t\t\t\t\t\treturn undef;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# Copy root tree to disk\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Copying system image tree on disk\");\n\t\t$status = qxx (\n\t\t\t\"tar --one-file-system -cf - -C $system . | tar -x -C $loopdir 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Can't copy image tree to disk: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tif ($haveDiskDevice) {\n\t\t\t#==========================================\n\t\t\t# fill disk device with zero bytes\n\t\t\t#------------------------------------------\n\t\t\tqxx (\"dd if=/dev/zero of=$loopdir/abc 2>&1\");\n\t\t\tqxx (\"rm -f $loopdir/abc\");\n\t\t}\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Umount system image partition\n\t\t#------------------------------------------\n\t\t$main::global -> umount();\n\t}\n\t#==========================================\n\t# create read/write filesystem if needed\n\t#------------------------------------------\n\tif (($syszip) && (! $haveSplit) && (! $dmapper)) {\n\t\t$root = $deviceMap{2};\n\t\tif ($haveluks) {\n\t\t\tmy $cipher = $type{luks};\n\t\t\tmy $name   = \"luksReadWrite\";\n\t\t\t$kiwi -> info (\"Creating LUKS->ext3 read-write filesystem\");\n\t\t\t$status = qxx (\"echo $cipher|cryptsetup -q luksFormat $root 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($status != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't setup luks format: $root\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$status = qxx (\"echo $cipher|cryptsetup luksOpen $root $name 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't open luks device: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$root = \"/dev/mapper/$name\";\n\t\t\t$this->{luks} = $name;\n\t\t} else {\n\t\t\t$kiwi -> info (\"Creating ext3 read-write filesystem\");\n\t\t}\n\t\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t\t@{$cmdL -> getFilesystemOptions()}\n\t\t);\n\t\tmy $fsopts = $FSopts{ext3};\n\t\tmy $fstool = \"mkfs.ext3\";\n\t\t$status = qxx (\"$fstool $fsopts $root 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> luksClose();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> luksClose();\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# create bootloader filesystem if needed\n\t#------------------------------------------\n\tif ($bootloader eq \"syslinux\") {\n\t\t$root = $deviceMap{fat};\n\t\t$kiwi -> info (\"Creating DOS boot filesystem\");\n\t\t$status = qxx (\"/sbin/mkdosfs $root 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create DOS filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t} elsif (($arch =~ /ppc|ppc64/) && ($lvm)) {\n\t\t$boot = $deviceMap{fat};\n\t\t$kiwi -> info (\"Creating DOS boot filesystem\");\n\t\t$status = qxx (\"/sbin/mkdosfs -F 16 $boot 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create DOS filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t} elsif (\n\t\t($dmapper) || ($haveluks) || ($needBootP) ||\n\t\t($lvm) || ($bootloader eq \"extlinux\")\n\t) {\n\t\t$root = $deviceMap{dmapper};\n\t\t$kiwi -> info (\"Creating ext3 boot filesystem\");\n\t\tif (($haveluks) || ($needBootP)) {\n\t\t\tif (($syszip) || ($haveSplit) || ($dmapper)) {\n\t\t\t\t$root = $deviceMap{3};\n\t\t\t} else {\n\t\t\t\t$root = $deviceMap{2};\n\t\t\t}\n\t\t}\n\t\tif ($lvm) {\n\t\t\t$root = $deviceMap{0};\n\t\t}\n\t\tif ($bootloader eq \"extlinux\") {\n\t\t\t$root = $deviceMap{extlinux};\n\t\t}\n\t\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t\t@{$cmdL -> getFilesystemOptions()}\n\t\t);\n\t\tmy $fsopts = $FSopts{ext3};\n\t\tmy $fstool = \"mkfs.ext3\";\n\t\t$status = qxx (\"$fstool $fsopts $root 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create filesystem: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Dump boot image on disk\n\t#------------------------------------------\n\t$kiwi -> info (\"Copying boot image to disk\");\n\t#==========================================\n\t# Mount system image / or rw partition\n\t#------------------------------------------\n\tif ($bootloader eq \"syslinux\") {\n\t\t$root = $deviceMap{fat};\n\t} elsif ($bootloader eq \"extlinux\") {\n\t\t$root = $deviceMap{extlinux};\n\t} elsif ($dmapper) {\n\t\t$root = $deviceMap{dmapper};\n\t} elsif ($arch =~ /ppc|ppc64/){\n\t\tif ($lvm) {\n\t\t\t$boot = $deviceMap{fat};\n\t\t\t$root = $deviceMap{1};\n\t\t} else {\n\t\t\t$root = $deviceMap{2};\n\t\t}\n\t} elsif (($syszip) || ($haveSplit) || ($lvm)) {\n\t\t$root = $deviceMap{2};\n\t\tif ($haveluks) {\n\t\t\t$root = $deviceMap{3};\n\t\t}\n\t\tif ($lvm) {\n\t\t\t$root = $deviceMap{0};\n\t\t}\n\t} elsif (($haveluks) || ($needBootP)) {\n\t\t$root = $deviceMap{2};\n\t} else {\n\t\t$root = $deviceMap{1};\n\t}\n\tif (! $main::global -> mount ($root, $loopdir)) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't mount image: $root\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\tif (($arch =~/ppc|ppc64/) && ($lvm)) {\n\t\t$status = qxx (\"mkdir -p $loopdir/vfat\");\n\t\t$boot = $deviceMap{fat};\n\t\tif (! $main::global -> mount ($boot, $loopdir.\"/vfat\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't mount image: $boot\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Copy boot data on system image\n\t#------------------------------------------\n\t$status = qxx (\"cp -dR $tmpdir/boot $loopdir 2>&1\");\n\t$result = $? >> 8;\n\tif ($arch =~ /ppc|ppc64/) {\n\t\t#==========================================\n\t\t# Copy yaboot.conf\n\t\t#------------------------------------------\n\t\tif (! $lvm) {\n\t\t\t$status = qxx (\"cp $tmpdir/etc/yaboot.conf $loopdir/etc/ 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t} else {\n\t\t\t$status = qxx (\n\t\t\t\t\"cp $tmpdir/etc/yaboot.conf $loopdir/vfat/yaboot.cnf 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\t$status = qxx (\"cp $loopdir/boot/linux.vmx  $loopdir/vfat\");\n\t\t\t$status = qxx (\"cp $loopdir/boot/initrd.vmx $loopdir/vfat\");\n\t\t\t$result = $? >> 8;\n\t\t\t$status = qxx (\n\t\t\t\t\"cp $loopdir/lib/lilo/chrp/yaboot.chrp $loopdir/vfat/yaboot\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\t$status = qxx (\"cp -a $tmpdir/ppc $loopdir/vfat/\");\n\t\t\t$result = $? >> 8;\n\t\t\t$main::global -> umount($boot);\n\t\t\t$status = qxx (\"rm -rf $loopdir/vfat\");\n\t\t\t$result = $? >> 8;\n\t\t}\n\t}\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error (\"Couldn't copy boot data to system image: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$main::global -> umount();\n\t$kiwi -> done();\n\t#==========================================\n\t# Install boot loader on disk\n\t#------------------------------------------\n\tmy $bootdevice = $diskname;\n\tif ($haveDiskDevice) {\n\t\t$bootdevice = $this->{loop};\n\t}\n\tif (! $this->installBootLoader ($bootloader,$bootdevice,\\%deviceMap)) {\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# cleanup device maps and part mount\n\t#------------------------------------------\n\tif ($lvm) {\n\t\tqxx (\"vgchange -an $this->{lvmgroup} 2>&1\");\n\t}\n\t$this -> cleanLoopMaps();\n\t#==========================================\n\t# cleanup temp directory\n\t#------------------------------------------\n\tqxx (\"rm -rf $tmpdir\");\n\tif ($haveDiskDevice)  {\n\t\t#==========================================\n\t\t# create image file from disk device\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Dumping image file from $this->{loop}...\");\n\t\t$status = qxx (\"dd if=$this->{loop} of=$diskname bs=32k 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Image dump failed: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Create image described by given format\n\t#------------------------------------------\n\tif ($initrd =~ /oemboot/) {\n\t\t#==========================================\n\t\t# OEM Install CD...\n\t\t#------------------------------------------\n\t\tif ($type{installiso} =~ /true|yes/i) {\n\t\t\t$this -> {system} = $diskname;\n\t\t\tif ($haveDiskDevice) {\n\t\t\t\t$this -> {system} = $this->{loop};\n\t\t\t}\n\t\t\t$kiwi -> info (\"--> Creating install ISO image\\n\");\n\t\t\t$this -> cleanLoop ();\n\t\t\tif (! $this -> setupInstallCD()) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# OEM Install Stick...\n\t\t#------------------------------------------\n\t\tif ($type{installstick} =~ /true|yes/i) {\n\t\t\t$this -> {system} = $diskname;\n\t\t\tif ($haveDiskDevice) {\n\t\t\t\t$this -> {system} = $this->{loop};\n\t\t\t}\n\t\t\t$kiwi -> info (\"--> Creating install USB Stick image\\n\");\n\t\t\t$this -> cleanLoop ();\n\t\t\tif (! $this -> setupInstallStick()) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# cleanup loop setup and device mapper\n\t#------------------------------------------\n\t$this -> cleanLoop ();\n\treturn $this;\n}\n\n#==========================================\n# setupInstallFlags\n#------------------------------------------\nsub setupInstallFlags {\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $initrd = $this->{initrd};\n\tmy $system = $this->{system};\n\tmy $irddir = $initrd.\"_\".$$.\".vmxsystem\";\n\tmy $xml    = $this->{xml};\n\tmy $zipper = $this->{gdata}->{Gzip};\n\tmy $newird;\n\tif (! mkdir $irddir) {\n\t\t$kiwi -> error  (\"Failed to create vmxsystem directory\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# unpack initrd files\n\t#------------------------------------------\n\tmy $unzip  = \"$this->{gdata}->{Gzip} -cd $initrd 2>&1\";\n\tmy $status = qxx (\"$unzip | (cd $irddir && cpio -di 2>&1)\");\n\tmy $result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Failed to extract initrd data: $!\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $irddir\");\n\t\treturn undef;\n\t}\n\t#===========================================\n\t# add image.md5 / config.vmxsystem to initrd\n\t#-------------------------------------------\n\tif (defined $system) {\n\t\tmy $imd5 = $system;\n\t\t$imd5 =~ s/\\.raw$/\\.md5/;\n\t\tmy $status = qxx (\"cp $imd5 $irddir/etc/image.md5 2>&1\");\n\t\tmy $result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> error  (\"Failed importing md5 file: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $irddir\");\n\t\t\treturn undef;\n\t\t}\n\t\tif (! open (FD,\">$irddir/config.vmxsystem\")) {\n\t\t\t$kiwi -> error  (\"Couldn't create image boot configuration\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $namecd = basename ($system);\n\t\tif (! -f $imd5) {\n\t\t\t$kiwi -> error  (\"Couldn't find md5 file\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $irddir\");\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"IMAGE='\".$namecd.\"'\\n\";\n\t\tclose FD;\n\t}\n\t#==========================================\n\t# create new initrd with vmxsystem file\n\t#------------------------------------------\n\t$newird = $initrd;\n\t$newird =~ s/\\.gz/\\.install\\.gz/;\n\t$status = qxx (\n\t\t\"(cd $irddir && find|cpio --quiet -oH newc | $zipper) > $newird\"\n\t);\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Failed to re-create initrd: $status\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $irddir\");\n\t\treturn undef;\n\t}\n\tqxx (\"rm -rf $irddir\");\n\t#==========================================\n\t# recreate splash data to initrd\n\t#------------------------------------------\n\tmy $splash = $initrd;\n\tif (! ($splash =~ s/splash\\.gz/spl/)) {\n\t\t$splash =~ s/gz/spl/;\n\t}\n\tif (-f $splash) {\n\t\tqxx (\"cat $splash >> $newird\");\n\t}\n\treturn $newird;\n}\n\n#==========================================\n# setupSplash\n#------------------------------------------\nsub setupSplash {\n\t# ...\n\t# we can either use bootsplash or splashy to display\n\t# a splash screen. If /usr/sbin/splashy exists we will\n\t# prefer splashy over bootsplash\n\t# ---\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $initrd = $this->{initrd};\n\tmy $zipped = 0;\n\tmy $status;\n\tmy $newird;\n\tmy $splfile;\n\tmy $result;\n\t#==========================================\n\t# setup file names\n\t#------------------------------------------\n\tif ($initrd =~ /\\.gz$/) {\n\t\t$zipped = 1;\n\t}\n\tif ($zipped) {\n\t\t$newird = $initrd; $newird =~ s/\\.gz/\\.splash.gz/;\n\t\t$splfile= $initrd; $splfile =~ s/\\.gz/\\.spl/;\n\t} else {\n\t\t$newird = $initrd.\".splash.gz\";\n\t\t$splfile= $initrd.\".spl\";\n\t}\n\t#==========================================\n\t# check if splash initrd is already there\n\t#------------------------------------------\n\tif ((! -l $newird) && (-f $newird)) {\n\t\t# splash initrd already created...\n\t\treturn $newird;\n\t}\n\t$kiwi -> info (\"Setting up splash screen...\");\n\t#==========================================\n\t# setup splash in initrd\n\t#------------------------------------------\n\tif (-f $splfile) {\n\t\tqxx (\"cat $initrd $splfile > $newird\");\n\t\t$status = \"ok\";\n\t} else {\n\t\t$status = \"Can't find splash file: $splfile\";\n\t}\n\t#==========================================\n\t# check status and return\n\t#------------------------------------------\n\tif ($status ne \"ok\") {\n\t\t$kiwi -> skipped ();\n\t\t$kiwi -> warning ($status);\n\t\t$kiwi -> skipped ();\n\t\t$kiwi -> info (\"Creating compat splash link...\");\n\t\t$status = $this -> setupSplashLink ($newird);\n\t\tif ($status ne \"ok\") {\n\t\t\t$kiwi -> failed();\n\t\t\t$kiwi -> error ($status);\n\t\t\t$kiwi -> failed();\n\t\t} else {\n\t\t\t$kiwi -> done();\n\t\t}\n\t\treturn $initrd;\n\t}\n\t$kiwi -> done();\n\treturn $newird;\n}\n\n#==========================================\n# setupSplashLink\n#------------------------------------------\nsub setupSplashLink {\n\t# ...\n\t# This function only makes sure the .splash.gz\n\t# file exists. This is done by creating a link to the\n\t# original initrd file\n\t# ---\n\tmy $this   = shift;\n\tmy $newird = shift;\n\tmy $initrd = $this->{initrd};\n\tmy $status;\n\tmy $result;\n\tif ($initrd !~ /.gz$/) {\n\t\t$status = qxx (\"$this->{gdata}->{Gzip} -f $initrd 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\treturn (\"Failed to compress initrd: $status\");\n\t\t}\n\t\t$initrd = $initrd.\".gz\";\n\t}\n\tmy $dirname = dirname  $initrd;\n\tmy $curfile = basename $initrd;\n\tmy $newfile = basename $newird;\n\t$status = qxx (\n\t\t\"cd $dirname && rm -f $newfile && ln -s $curfile $newfile\"\n\t);\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\treturn (\"Failed to create splash link $!\");\n\t}\n\treturn \"ok\";\n}\n\n#==========================================\n# cleanLoop\n#------------------------------------------\nsub cleanLoop {\n\tmy $this = shift;\n\tmy $tmpdir = $this->{tmpdir};\n\tmy $loop   = $this->{loop};\n\tmy $lvm    = $this->{lvm};\n\tmy $loopdir= $this->{loopdir};\n\t$main::global -> umount();\n\tif ((defined $loop) && ($loop =~ /loop/)) {\n\t\tif (defined $lvm) {\n\t\t\tqxx (\"vgchange -an 2>&1\");\n\t\t}\n\t\t$this -> cleanLoopMaps();\n\t\tqxx (\"/sbin/losetup -d $loop 2>&1\");\n\t\tundef $this->{loop};\n\t}\n\treturn $this;\n}\n\n#==========================================\n# cleanLoopMaps\n#------------------------------------------\nsub cleanLoopMaps {\n\tmy $this = shift;\n\tmy $dev  = shift;\n\tmy $loop = $this->{loop};\n\tif ($dev) {\n\t\t$loop = $dev;\n\t}\n\tif ($loop =~ /dev\\/(.*)/) {\n\t\t$loop = $1;\n\t}\n\tforeach my $d (glob (\"/dev/mapper/$loop*\")) {\n\t\tqxx (\"dmsetup remove $d 2>&1\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# buildMD5Sum\n#------------------------------------------\nsub buildMD5Sum {\n\tmy $this = shift;\n\tmy $file = shift;\n\tmy $outf = shift;\n\tmy $kiwi = $this->{kiwi};\n\t$kiwi -> info (\"Creating image MD5 sum...\");\n\tmy $size = $main::global -> isize ($file);\n\tmy $primes = qxx (\"factor $size\"); $primes =~ s/^.*: //;\n\tmy $blocksize = 1;\n\tfor my $factor (split /\\s/,$primes) {\n\t\tlast if ($blocksize * $factor > 8192);\n\t\t$blocksize *= $factor;\n\t}\n\tmy $blocks = $size / $blocksize;\n\tmy $sum  = qxx (\"cat $file | md5sum - | cut -f 1 -d-\");\n\tchomp $sum;\n\tif ($outf) {\n\t\t$file = $outf;\n\t}\n\tif ($file =~ /\\.raw$/) {\n\t\t$file =~ s/raw$/md5/;\n\t}\n\tqxx (\"echo \\\"$sum $blocks $blocksize\\\" > $file\");\n\t$kiwi -> done();\n\treturn $this;\n}\n\n#==========================================\n# writeMBRDiskLabel\n#------------------------------------------\nsub writeMBRDiskLabel {\n\t# ...\n\t# writes a 4byte random ID into the MBR of the\n\t# previosly installed boot manager. The function\n\t# returns the written ID or undef on error\n\t# ---\n\tmy $this  = shift;\n\tmy $file  = shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $nid   = $this->{mbrid};\n\tif (! defined $nid) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"MBR: don't have a mbr id\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $pid = pack \"V\", eval $nid;\n\tif (! open (FD,\"+<$file\")) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"MBR: failed to open file: $file: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tseek FD,440,0;\n\tmy $done = syswrite (FD,$pid,4);\n\tif ($done != 4) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"MBR: only $done bytes written\");\n\t\t$kiwi -> failed ();\n\t\tseek FD,0,2; close FD;\n\t\treturn undef;\n\t}\n\tseek FD,0,2; close FD;\n\treturn $this;\n}\n\n#==========================================\n# setupBootLoaderStages\n#------------------------------------------\nsub setupBootLoaderStages {\n\tmy $this   = shift;\n\tmy $loader = shift;\n\tmy $type   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $tmpdir = $this->{tmpdir};\n\tmy $initrd = $this->{initrd};\n\tmy $zipped = $this->{zipped};\n\tmy $zipper = $this->{gdata}->{Gzip};\n\tmy $status = 0;\n\tmy $result = 0;\n\t#==========================================\n\t# Grub\n\t#------------------------------------------\n\tif ($loader eq \"grub\") {\n\t\tmy $stages = \"'usr/lib/grub/*'\";\n\t\tmy $figure = \"'image/loader/message'\";\n\t\tmy $unzip  = \"$zipper -cd $initrd 2>&1\";\n\t\t$status = qxx ( \"mkdir -p $tmpdir/boot/grub 2>&1\" );\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed creating boot manager directory: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Get Grub graphics boot message\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Importing graphics boot message and stage files\");\n\t\tif ($zipped) {\n\t\t\t$status= qxx (\n\t\t\t\t\"$unzip | (cd $tmpdir && cpio -i -d $figure -d $stages 2>&1)\"\n\t\t\t);\n\t\t} else {\n\t\t\t$status= qxx (\n\t\t\t\t\"cat $initrd|(cd $tmpdir && cpio -i -d $figure -d $stages 2>&1)\"\n\t\t\t);\n\t\t}\n\t\tif (-e $tmpdir.\"/image/loader/message\") {\n\t\t\t$status = qxx (\"mv $tmpdir/$figure $tmpdir/boot/message 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> skipped();\n\t\t}\n\t\t#==========================================\n\t\t# check Grub stage files...\n\t\t#------------------------------------------\n\t\tif (glob($tmpdir.\"/usr/lib/grub/*\")) {\n\t\t\t$status = qxx (\n\t\t\t\t\"mv $tmpdir/usr/lib/grub/* $tmpdir/boot/grub 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tif (($result == 0) && (defined $type) && ($type eq \"iso\")) {\n\t\t\t\tmy $src = \"$tmpdir/boot/grub/stage2_eltorito\";\n\t\t\t\tmy $dst = \"$tmpdir/boot/grub/stage2\";\n\t\t\t\t$status = qxx (\"mv $src $dst 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tchomp $status;\n\t\t\t$kiwi -> error   (\"Failed importing grub stages: $status\");\n\t\t\t$kiwi -> skipped ();\n\t\t\t$kiwi -> info    (\"Trying to use grub stages from local machine\");\n\t\t\t$status = qxx ( \"cp /usr/lib/grub/* $tmpdir/boot/grub 2>&1\" );\n\t\t\t$result = $? >> 8;\n\t\t\tif (($result == 0) && (defined $type) && ($type eq \"iso\")) {\n\t\t\t\tmy $src = \"$tmpdir/boot/grub/stage2_eltorito\";\n\t\t\t\tmy $dst = \"$tmpdir/boot/grub/stage2\";\n\t\t\t\t$status = qxx (\"mv $src $dst 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t}\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> error  (\"Failed importing grub stages: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# syslinux\n\t#------------------------------------------\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\tmy $message= \"'image/loader/*'\";\n\t\tmy $unzip  = \"$zipper -cd $initrd 2>&1\";\n\t\t#==========================================\n\t\t# Create syslinux boot data directory\n\t\t#------------------------------------------\n\t\tqxx (\"mkdir -p $tmpdir/boot/syslinux 2>&1\");\n\t\t#==========================================\n\t\t# Get syslinux graphics data\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Importing graphics boot message\");\n\t\tif ($zipped) {\n\t\t\t$status= qxx (\"$unzip | (cd $tmpdir && cpio -di $message 2>&1)\");\n\t\t} else {\n\t\t\t$status= qxx (\"cat $initrd|(cd $tmpdir && cpio -di $message 2>&1)\");\n\t\t}\n\t\tif (-d $tmpdir.\"/image/loader\") {\n\t\t\t$status = qxx (\n\t\t\t\t\"mv $tmpdir/image/loader/* $tmpdir/boot/syslinux 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> skipped();\n\t\t}\n\t\t#==========================================\n\t\t# Cleanup tmpdir\n\t\t#------------------------------------------\n\t\tqxx (\"rm -rf $tmpdir/image 2>&1\");\n\t}\n\t#==========================================\n\t# more boot managers to come...\n\t#------------------------------------------\n\t# ...\n\treturn $this;\n}\n\n#==========================================\n# setupBootLoaderConfiguration\n#------------------------------------------\nsub setupBootLoaderConfiguration {\n\tmy $this     = shift;\n\tmy $loader   = shift;\n\tmy $type     = shift;\n\tmy $extra    = shift;\n\tmy $kiwi     = $this->{kiwi};\n\tmy $tmpdir   = $this->{tmpdir};\n\tmy $initrd   = $this->{initrd};\n\tmy $isxen    = $this->{isxen};\n\tmy $xendomain= $this->{xendomain};\n\tmy $imgtype  = $this->{imgtype};\n\tmy $bootpart = $this->{bootpart};\n\tmy $label    = $this->{bootlabel};\n\tmy $vga      = $this->{vga};\n\tmy $lvm      = $this->{lvm};\n\tmy $vgroup   = $this->{lvmgroup};\n\tmy $xml      = $this->{xml};\n\tmy $bloader  = \"grub\";\n\tmy $cmdline;\n\tmy %type;\n\tmy $title;\n\t#==========================================\n\t# setup boot loader default boot label/nr\n\t#------------------------------------------\n\tmy $defaultBootNr = 0;\n\tif ($xml) {\n\t\t%type = %{$xml->getImageTypeAndAttributes()};\n\t\t$cmdline  = $type{cmdline};\n\t}\n\tif ($type =~ /^KIWI CD Boot/) {\n\t\t# /.../\n\t\t# use predefined set of parameters for simple boot CD\n\t\t# not including a system image\n\t\t# ----\n\t\t$type{installboot} = \"install\";\n\t\t$type{boottimeout} = 1;\n\t\t$type{fastboot}    = 1;\n\t\t$cmdline=\"kiwistderr=/dev/hvc0\";\n\t\t$vga=\"normal\";\n\t}\n\tif ((($type =~ /^KIWI (CD|USB)/)) && ($type{installboot})) {\n\t\t# In install mode we have the following menu layout\n\t\t# ----\n\t\t# 0 -> Boot from Hard Disk\n\t\t# 1 -> Install/Restore $label\n\t\t# 2 -> Failsafe -- Install/Restore $label\n\t\t# ----\n\t\tif ($type{installboot} eq \"install\") {\n\t\t\t$defaultBootNr = 1;\n\t\t}\n\t\tif ($type{installboot} eq \"failsafe-install\") {\n\t\t\t$defaultBootNr = 2;\n\t\t}\n\t}\n\t#==========================================\n\t# setup boot loader type\n\t#------------------------------------------\n\tif ($type{bootloader}) {\n\t\t$bloader = $type{bootloader};\n\t}\n\t#==========================================\n\t# report additional cmdline options\n\t#------------------------------------------\n\tif ($cmdline) {\n\t\t$kiwi -> loginfo (\n\t\t\t\"Additional commandline options: \\\"$cmdline\\\"\"\n\t\t);\n\t}\n\t#==========================================\n\t# join common options, finish with '\\n'\n\t#------------------------------------------\n\t$cmdline .= \" $extra\" if $extra;\n\t$cmdline .= \" VGROUP=$vgroup\" if $lvm;\n\t$cmdline .= \" COMBINED_IMAGE=yes\" if $imgtype eq \"split\";\n\t$cmdline .= \" showopts\\n\";\n\t# ensure exactly one space at start\n\t$cmdline =~ s/^\\s*/ /;\n\n\t#==========================================\n\t# Check boot partition number\n\t#------------------------------------------\n\tif (! defined $bootpart) {\n\t\t$bootpart = 0;\n\t}\n\t#==========================================\n\t# Grub\n\t#------------------------------------------\n\tif ($loader eq \"grub\") {\n\t\t#==========================================\n\t\t# Create MBR id file for boot device check\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Saving disk label on disk: $this->{mbrid}...\");\n\t\tif (! open (FD,\">$tmpdir/boot/grub/mbrid\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create mbrid file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$this->{mbrid}\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Create menu.lst file\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Creating grub menu list file...\");\n\t\tif (! open (FD,\">$tmpdir/boot/grub/menu.lst\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create menu.lst: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Compat link\n\t\t#------------------------------------------\n\t\tqxx (\"cd $tmpdir/boot/grub && ln -s menu.lst grub.conf\");\n\t\t#==========================================\n\t\t# General grub setup\n\t\t#------------------------------------------\n\t\tprint FD \"color cyan/blue white/blue\\n\";\n\t\tprint FD \"default $defaultBootNr\\n\";\n\t\tmy $bootTimeout = 10;\n\t\tif (defined $type{boottimeout}) {\n\t\t\t$bootTimeout = $type{boottimeout};\n\t\t}\n\t\tif ($type{fastboot}) {\n\t\t\t$bootTimeout = 0;\n\t\t}\n\t\tprint FD \"timeout $bootTimeout\\n\";\n\t\tif ($type =~ /^KIWI (CD|USB)/) {\n\t\t\tmy $dev = $1 eq 'CD' ? '(cd)' : '(hd0,0)';\n\t\t\tif (! $type{fastboot}) {\n\t\t\t\tif (-e \"$tmpdir/boot/grub/splash.xpm.gz\") {\n\t\t\t\t\tprint FD \"splashimage=$dev/boot/grub/splash.xpm.gz\\n\"\n\t\t\t\t} elsif (-e \"$tmpdir/boot/message\") {\n\t\t\t\t\tprint FD \"gfxmenu $dev/boot/message\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprint FD \"title Boot from Hard Disk\\n\";\n\t\t\tif ($dev eq '(cd)') {\n\t\t\t\tprint FD \" rootnoverify (hd0)\\n\";\n\t\t\t\tprint FD \" chainloader (hd0)+1\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprint FD \" chainloader $dev/boot/grub/bootnext\\n\";\n\t\t\t\tmy $bootnext = $this -> addBootNext (\n\t\t\t\t\t\"$tmpdir/boot/grub/bootnext\", hex $this->{mbrid}\n\t\t\t\t);\n\t\t\t\tif (! defined $bootnext) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$kiwi -> error  (\"Failed to write bootnext\\n\");\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$title = $this -> makeLabel (\"Install/Restore $label\");\n\t\t\tprint FD \"title $title\\n\";\n\t\t} else {\n\t\t\t$title = $this -> makeLabel (\"$label [ $type ]\");\n\t\t\tif (-e \"$tmpdir/boot/grub/splash.xpm.gz\") {\n\t\t\t\tprint FD \"splashimage=(hd0,$bootpart)/boot/grub/splash.xpm.gz\\n\"\n\t\t\t} elsif (-e \"$tmpdir/boot/message\") {\n\t\t\t\tprint FD \"gfxmenu (hd0,$bootpart)/boot/message\\n\";\n\t\t\t}\n\t\t\tprint FD \"title $title\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# Standard boot\n\t\t#------------------------------------------\n\t\tif ((! $isxen) || ($isxen && $xendomain eq \"domU\")) {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" kernel (cd)/boot/linux vga=$vga splash=silent\";\n\t\t\t\tprint FD \" ramdisk_size=512000 ramdisk_blocksize=4096\";\n\t\t\t\tprint FD \" cdinst=1 loader=$bloader\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/linux.vmx vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/linux vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD $cmdline;\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" initrd (cd)/boot/initrd\\n\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" initrd /boot/initrd.vmx\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \" initrd /boot/initrd\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" kernel (cd)/boot/xen.gz\\n\";\n\t\t\t\tprint FD \" module /boot/linux vga=$vga splash=silent\";\n\t\t\t\tprint FD \" ramdisk_size=512000 ramdisk_blocksize=4096\";\n\t\t\t\tprint FD \" cdinst=1 loader=$bloader\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/xen.gz.vmx\\n\";\n\t\t\t\tprint FD \" module /boot/linux.vmx vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/xen.gz\\n\";\n\t\t\t\tprint FD \" module /boot/linux vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD $cmdline;\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" module (cd)/boot/initrd\\n\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" module /boot/initrd.vmx\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \" module /boot/initrd\\n\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# Failsafe boot\n\t\t#------------------------------------------\n\t\t$title = $this -> makeLabel (\"Failsafe -- $title\");\n\t\tprint FD \"title $title\\n\";\n\t\tif ((! $isxen) || ($isxen && $xendomain eq \"domU\")) {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" kernel (cd)/boot/linux vga=$vga splash=silent\";\n\t\t\t\tprint FD \" ramdisk_size=512000 ramdisk_blocksize=4096\";\n\t\t\t\tprint FD \" cdinst=1 loader=$bloader\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/linux.vmx vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/linux vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD \" ide=nodma apm=off acpi=off noresume selinux=0 nosmp\";\n\t\t\tprint FD \" noapic maxcpus=0 edd=off\";\n\t\t\tprint FD $cmdline;\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" initrd (cd)/boot/initrd\\n\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" initrd /boot/initrd.vmx\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \" initrd /boot/initrd\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" kernel (cd)/boot/xen.gz\\n\";\n\t\t\t\tprint FD \" module (cd)/boot/linux vga=$vga splash=silent\";\n\t\t\t\tprint FD \" ramdisk_size=512000 ramdisk_blocksize=4096\";\n\t\t\t\tprint FD \" cdinst=1 loader=$bloader\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/xen.gz.vmx\\n\";\n\t\t\t\tprint FD \" module /boot/linux.vmx vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \" root (hd0,$bootpart)\\n\";\n\t\t\t\tprint FD \" kernel /boot/xen.gz\\n\";\n\t\t\t\tprint FD \" module /boot/linux vga=$vga\";\n\t\t\t\tprint FD \" loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD \" ide=nodma apm=off acpi=off noresume selinux=0 nosmp\";\n\t\t\tprint FD \" noapic maxcpus=0 edd=off\";\n\t\t\tprint FD $cmdline;\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \" module (cd)/boot/initrd\\n\"\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \" module /boot/initrd.vmx\\n\"\n\t\t\t} else {\n\t\t\t\tprint FD \" module /boot/initrd\\n\";\n\t\t\t}\n\t\t}\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# syslinux\n\t#------------------------------------------\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\t#==========================================\n\t\t# Create MBR id file for boot device check\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Saving disk label on disk: $this->{mbrid}...\");\n\t\tqxx (\"mkdir -p $tmpdir/boot/grub\");\n\t\tif (! open (FD,\">$tmpdir/boot/grub/mbrid\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create mbrid file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$this->{mbrid}\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Create syslinux config file\n\t\t#------------------------------------------\n\t\tmy $syslconfig = \"syslinux.cfg\";\n\t\tif ($loader eq \"extlinux\") {\n\t\t\t$syslconfig = \"extlinux.conf\";\n\t\t}\n\t\t$kiwi -> info (\"Creating $syslconfig config file...\");\n\t\tif (! open (FD,\">$tmpdir/boot/syslinux/$syslconfig\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create $syslconfig: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $syslinux_new_format = 0;\n\t\tmy $gfx = \"$tmpdir/boot/syslinux\";\n\t\tif (-f \"$gfx/gfxboot.com\" || -f \"$gfx/gfxboot.c32\") {\n\t\t\t$syslinux_new_format = 1;\n\t\t}\n\t\t#==========================================\n\t\t# General syslinux setup\n\t\t#------------------------------------------\n\t\tprint FD \"implicit 1\".\"\\n\";\n\t\tprint FD \"prompt   1\".\"\\n\";\n\t\tmy $bootTimeout = 100;\n\t\tif (defined $type{boottimeout}) {\n\t\t\t$bootTimeout = $type{boottimeout};\n\t\t\tif (int ($bootTimeout) == 0) {\n\t\t\t\t# /.../\n\t\t\t\t# a timeout value of 0 disables the timeout in syslinux\n\t\t\t\t# therefore we set the smallest possible value in that case\n\t\t\t\t# which is 1/10 sec\n\t\t\t\t# ----\n\t\t\t\t$bootTimeout = 1;\n\t\t\t}\n\t\t}\n\t\tprint FD \"timeout  $bootTimeout\".\"\\n\";\n\t\tprint FD \"display isolinux.msg\".\"\\n\";\n\t\tmy @labels = ();\n\t\tif (-f \"$gfx/bootlogo\") {\n\t\t\tif ($syslinux_new_format) {\n\t\t\t\tprint FD \"ui gfxboot bootlogo isolinux.msg\".\"\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \"gfxboot bootlogo\".\"\\n\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# Setup default title\n\t\t#------------------------------------------\n\t\tif ($type =~ /^KIWI (CD|USB)/) {\n\t\t\tif ($defaultBootNr == 0) {\n\t\t\t\t$title = $this -> makeLabel (\"Boot from Hard Disk\");\n\t\t\t} elsif ($defaultBootNr == 1) {\n\t\t\t\t$title = $this -> makeLabel (\"Install/Restore $label\");\n\t\t\t} else {\n\t\t\t\t$title = $this -> makeLabel (\n\t\t\t\t\t\"Failsafe -- Install/Restore $label\"\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t$title = $this -> makeLabel (\"$label [ $type ]\");\n\t\t}\n\t\tprint FD \"default $title\".\"\\n\";\n\t\tif ($type =~ /^KIWI (CD|USB)/) {\n\t\t\t$title = $this -> makeLabel (\"Boot from Hard Disk\");\n\t\t\tprint FD \"label $title\\n\";\n\t\t\tprint FD \"localboot 0x80\\n\";\n\t\t\t$title = $this -> makeLabel (\"Install/Restore $label\");\n\t\t} else {\n\t\t\t$title = $this -> makeLabel (\"$label [ $type ]\");\n\t\t}\n\t\tprint FD \"label $title\".\"\\n\";\n\t\tpush @labels,$title;\n\t\t#==========================================\n\t\t# Standard boot\n\t\t#------------------------------------------\n\t\tif (! $isxen) {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \"kernel linux\\n\";\n\t\t\t\tprint FD \"append initrd=initrd \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent \";\n\t\t\t\tprint FD \"ramdisk_size=512000 ramdisk_blocksize=4096 \";\n\t\t\t\tprint FD \"cdinst=1 kiwi_hybrid=1\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \"kernel /boot/linux.vmx\\n\";\n\t\t\t\tprint FD \"append initrd=/boot/initrd.vmx \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \"kernel /boot/linux\\n\";\n\t\t\t\tprint FD \"append initrd=/boot/initrd \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen cdinst not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen boot not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t} else {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen boot not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\tprint FD $cmdline;\n\t\t#==========================================\n\t\t# Failsafe boot\n\t\t#------------------------------------------\n\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t$title = $this -> makeLabel (\"Failsafe -- Install/Restore $label\");\n\t\t\tprint FD \"label $title\".\"\\n\";\n\t\t} elsif ($type =~ /^KIWI USB/) {\n\t\t\t$title = $this -> makeLabel (\"Failsafe -- Install/Restore $label\");\n\t\t\tprint FD \"label $title\".\"\\n\";\n\t\t} else {\n\t\t\t$title = $this -> makeLabel (\"Failsafe -- $label [ $type ]\");\n\t\t\tprint FD \"label $title\".\"\\n\";\n\t\t}\n\t\tpush @labels,$title;\n\t\tif (! $isxen) {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\tprint FD \"kernel linux\\n\";\n\t\t\t\tprint FD \"append initrd=initrd \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent \";\n\t\t\t\tprint FD \"ramdisk_size=512000 ramdisk_blocksize=4096 \";\n\t\t\t\tprint FD \"cdinst=1 kiwi_hybrid=1\";\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\tprint FD \"kernel /boot/linux.vmx\\n\";\n\t\t\t\tprint FD \"append initrd=/boot/initrd.vmx \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent\";\n\t\t\t} else {\n\t\t\t\tprint FD \"kernel /boot/linux\\n\";\n\t\t\t\tprint FD \"append initrd=/boot/initrd \";\n\t\t\t\tprint FD \"vga=$vga loader=$bloader splash=silent\";\n\t\t\t}\n\t\t\tprint FD \" ide=nodma apm=off acpi=off noresume selinux=0 nosmp\";\n\t\t\tprint FD \" noapic maxcpus=0 edd=off\";\n\t\t} else {\n\t\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen cdinst not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen boot not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t} else {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"*** syslinux: Xen boot not supported ***\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tprint FD \" ide=nodma apm=off acpi=off noresume selinux=0 nosmp\";\n\t\t\tprint FD \" noapic maxcpus=0 edd=off\";\n\t\t}\n\t\tprint FD $cmdline;\n\t\tclose FD;\n\t\t#==========================================\n\t\t# setup isolinux.msg file\n\t\t#------------------------------------------\n\t\tif (! open (FD,\">$tmpdir/boot/syslinux/isolinux.msg\")) {\n\t\t\t$kiwi -> failed();\n\t\t\t$kiwi -> error  (\"Failed to create isolinux.msg: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"\\n\".\"Welcome !\".\"\\n\\n\";\n\t\tforeach my $label (@labels) {\n\t\t\tprint FD \"$label\".\"\\n\";\n\t\t}\n\t\tprint FD \"\\n\\n\";\n\t\tprint FD \"Have a lot of fun...\".\"\\n\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Zipl\n\t#------------------------------------------\n\tif ($loader eq \"zipl\") {\n\t\t#==========================================\n\t\t# Create MBR id file for boot device check\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Saving disk label on disk: $this->{mbrid}...\");\n\t\tqxx (\"mkdir -p $tmpdir/boot/grub\");\n\t\tqxx (\"mkdir -p $tmpdir/boot/zipl\");\n\t\tif (! open (FD,\">$tmpdir/boot/grub/mbrid\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create mbrid file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$this->{mbrid}\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t\t#==========================================\n\t\t# Create zipl.conf\n\t\t#------------------------------------------\n\t\t$cmdline =~ s/\\n//g;\n\t\tmy $ziplconfig = \"zipl.conf\";\n\t\t$kiwi -> info (\"Creating $ziplconfig config file...\");\n\t\tif ($isxen) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"*** zipl: Xen boot not supported ***\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! -e \"/boot/zipl\") {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Can't find bootloader: /boot/zipl\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! open (FD,\">$tmpdir/boot/$ziplconfig\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create $ziplconfig: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# General zipl setup\n\t\t#------------------------------------------\n\t\tmy $title_standard;\n\t\tmy $title_failsafe;\n\t\tif ($type =~ /^KIWI (CD|USB)/) {\n\t\t\t$title_standard = $this -> makeLabel (\n\t\t\t\t\"Install/Restore $label\"\n\t\t\t);\n\t\t\t$title_failsafe = $this -> makeLabel (\n\t\t\t\t\"Failsafe -- Install/Restore $label\"\n\t\t\t);\n\t\t} else {\n\t\t\t$title_standard = $this -> makeLabel (\n\t\t\t\t\"$label ( $type )\"\n\t\t\t);\n\t\t\t$title_failsafe = $this -> makeLabel (\n\t\t\t\t\"Failsafe -- $label ( $type )\"\n\t\t\t);\n\t\t}\n\t\tprint FD \"[defaultboot]\".\"\\n\";\n\t\tprint FD \"defaultmenu = menu\".\"\\n\\n\";\n\t\tprint FD \":menu\".\"\\n\";\n\t\tprint FD \"\\t\".\"default = 1\".\"\\n\";\n\t\tprint FD \"\\t\".\"prompt  = 1\".\"\\n\";\n\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\tprint FD \"\\t\".\"timeout = 200\".\"\\n\";\n\t\tprint FD \"\\t\".\"1 = $title_standard\".\"\\n\";\n\t\tprint FD \"\\t\".\"2 = $title_failsafe\".\"\\n\\n\";\n\t\t#==========================================\n\t\t# Standard boot\n\t\t#------------------------------------------\n\t\tprint FD \"[$title_standard]\".\"\\n\";\n\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"*** zipl: CD boot not supported ***\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\tprint FD \"\\t\".\"image   = boot/linux.vmx\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"ramdisk = boot/initrd.vmx,0x4000000\".\"\\n\";\n\t\t} else {\n\t\t\tprint FD \"\\t\".\"image   = boot/linux\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"ramdisk = boot/initrd,0x4000000\".\"\\n\";\n\t\t}\n\t\tprint FD \"\\t\".\"parameters = \\\"loader=$bloader\";\n\t\tprint FD \" $cmdline\\\"\".\"\\n\";\n\t\t#==========================================\n\t\t# Failsafe boot\n\t\t#------------------------------------------\n\t\tprint FD \"[$title_failsafe]\".\"\\n\";\n\t\tif ($type =~ /^KIWI CD/) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"*** zipl: CD boot not supported ***\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t} elsif (($type=~ /^KIWI USB/)||($imgtype=~ /vmx|oem|split/)) {\n\t\t\tprint FD \"\\t\".\"image   = boot/linux.vmx\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"ramdisk = boot/initrd.vmx,0x4000000\".\"\\n\";\n\t\t} else {\n\t\t\tprint FD \"\\t\".\"image   = boot/linux\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"target  = boot/zipl\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"ramdisk = boot/initrd,0x4000000\".\"\\n\";\n\t\t}\n\t\tprint FD \"\\t\".\"parameters = \\\"x11failsafe loader=$bloader\";\n\t\tprint FD \" $cmdline\\\"\".\"\\n\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# lilo\n\t#------------------------------------------\n\tif ($loader eq \"lilo\") {\n\t\t$cmdline =~ s/\\n//g;\n\t\tmy $title_standard;\n\t\t$title_standard = $this -> makeLabel (\"$label\");\n\t\t#==========================================\n\t\t# Standard boot\n\t\t#------------------------------------------\n\t\tqxx (\"mkdir -p $tmpdir/etc\");\n\t\tif (! open (FD,\">$tmpdir/etc/yaboot.conf\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create yaboot.conf: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# CD NON-LVM BOOT\n\t\t#-------------------------------------------\n\t\tif (($type =~ /^KIWI CD/) && (!$lvm)) {\n\t\t\tprint FD \"default = $title_standard\\n\";\n\t\t\tprint FD \"image = /boot/linux\\n\";\n\t\t\tprint FD \"\\t\".\"label = $title_standard\\n\";\n\t\t\tprint FD \"\\t\".\"append = \\\"$cmdline\\\"\\n\";\n\t\t\tprint FD \"\\t\".\"initrd = /boot/initrd\\n\";\n\t\t\tclose FD;\n\t\t} elsif (($type =~ /^KIWI CD/) && ($lvm)) {\n\t\t\t#==========================================\n\t\t\t# CD LVM Boot\n\t\t\t#-------------------------------------------\n\t\t\tprint FD \"default = $title_standard\\n\";\n\t\t\tprint FD \"image = /boot/linux\\n\";\n\t\t\tprint FD \"\\t\".\"label = $title_standard\\n\";\n\t\t\tprint FD \"\\t\".\"append = \\\"$cmdline\\\"\\n\";\n\t\t\tprint FD \"\\t\".\"initrd = /boot/initrd\\n\";\n\t\t\tclose FD;\n\t\t} elsif (!($type =~ /^KIWI CD/) && (!$lvm)) {\n\t\t\t#==========================================\n\t\t\t# RAW NON-LVM\n\t\t\t#------------------------------------------\n\t\t\tprint FD \"partition = 2\\n\";\n\t\t\tprint FD \"timeout = 80\\n\";\n\t\t\tprint FD \"default = $title_standard\\n\";\n\t\t\tprint FD \"image = /boot/linux.vmx\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"label = $title_standard\\n\";\n\t\t\tprint FD \"\\t\".\"root = /dev/sda2\\n\";\n\t\t\tprint FD \"\\t\".\"append = \\\"$cmdline\\\"\\n\";\n\t\t\tprint FD \"\\t\".\"initrd = /boot/initrd.vmx\\n\";\n\t\t\tclose FD;\n\t\t} elsif (!($type =~ /^KIWI CD/) && ($lvm)) {\n\t\t\t#==========================================\n\t\t\t# RAW LVM\n\t\t\t#-------------------------------------------\n\t\t\tprint FD \"default = $title_standard\\n\";\n\t\t\tprint FD \"image = linux.vmx\".\"\\n\";\n\t\t\tprint FD \"\\t\".\"label = $title_standard\\n\";\n\t\t\tprint FD \"\\t\".\"append = \\\"$cmdline\\\"\\n\";\n\t\t\tprint FD \"\\t\".\"initrd = initrd.vmx\\n\";\n\t\t\tclose FD;\n\t\t}\n\t\t#==========================================\n\t\t# Create bootinfo.txt (CD and LVM setups)\n\t\t#-------------------------------------------\n\t\tif ($type =~ /^KIWI CD/)  {\n\t\t\tqxx (\"mkdir -p $tmpdir/ppc/\");\n\t\t\tif (! open (FD,\">$tmpdir/ppc/bootinfo.txt\")) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't create bootinfo.txt: $!\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tprint FD \"<chrp-boot>\\n\";\n\t\t\tprint FD \"<description>$title_standard</description>\\n\";\n\t\t\tprint FD \"<os-name>$title_standard</os-name>\\n\";\n\t\t\tprint FD \"<boot-script>boot &device;:1,\\\\suseboot\\\\yaboot.ibm\";\n\t\t\tprint FD \"</boot-script>\\n\";\n\t\t\tprint FD \"</chrp-boot>\\n\";\n\t\t\tclose FD;\n\t\t\tqxx (\"mkdir $tmpdir/suseboot\");\n\t\t\tqxx (\"cp /lib/lilo/chrp/yaboot.chrp $tmpdir/suseboot/yaboot.ibm\");\n\t\t\tqxx (\"cp $tmpdir/etc/yaboot.conf $tmpdir/suseboot/yaboot.cnf\");\n\t\t} elsif (!($type =~ /^KIWI CD/) && ($lvm)) {\n\t\t\tqxx (\"mkdir -p $tmpdir/ppc/\");\n\t\t\tif (! open (FD,\">$tmpdir/ppc/bootinfo.txt\")) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't create bootinfo.txt: $!\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tprint FD \"<chrp-boot>\\n\";\n\t\t\tprint FD \"<description>$title_standard</description>\\n\";\n\t\t\tprint FD \"<os-name>$title_standard</os-name>\\n\";\n\t\t\tprint FD \"<boot-script>boot &device;:1,yaboot</boot-script>\\n\";\n\t\t\tprint FD \"</chrp-boot>\\n\";\n\t\t\tclose FD;\n\t\t}\n\t\t$kiwi -> done ();\n\t}\n\t#==========================================\n\t# more boot managers to come...\n\t#------------------------------------------\n\t# ...\n\treturn $this;\n}\n\n#==========================================\n# installBootLoader\n#------------------------------------------\nsub installBootLoader {\n\tmy $this     = shift;\n\tmy $loader   = shift;\n\tmy $diskname = shift;\n\tmy $deviceMap= shift;\n\tmy $kiwi     = $this->{kiwi};\n\tmy $tmpdir   = $this->{tmpdir};\n\tmy $bootpart = $this->{bootpart};\n\tmy $chainload= $this->{chainload};\n\tmy $lvm\t     = $this->{lvm};\n\tmy $cmdL     = $this->{cmdL};\n\tmy $locator  = new KIWILocator($kiwi);\n\tmy $result;\n\tmy $status;\n\t#==========================================\n\t# Check for edit boot config\n\t#------------------------------------------\n\tif ($cmdL) {\n\t\tmy $editBoot = $cmdL -> getEditBootConfig();\n\t\tif (($editBoot) && (-e $editBoot)) {\n\t\t\tsystem (\"cd $tmpdir && bash --norc -c $editBoot\");\n\t\t}\n\t}\n\t#==========================================\n\t# Check boot partition number\n\t#------------------------------------------\n\tif (! defined $bootpart) {\n\t\t$bootpart = 0;\n\t}\n\t#==========================================\n\t# Grub\n\t#------------------------------------------\n\tif ($loader eq \"grub\") {\n\t\t$kiwi -> info (\"Installing grub on device: $diskname\");\n\t\t#==========================================\n\t\t# Clean loop maps\n\t\t#------------------------------------------\n\t\t$this -> cleanLoopMaps();\n\t\t$this -> cleanLoop();\n\t\t#==========================================\n\t\t# Create device map for the disk\n\t\t#------------------------------------------\n\t\tmy $dmfile = \"$tmpdir/grub-device.map\";\n\t\tmy $dmfd = new FileHandle;\n\t\tif (! $dmfd -> open(\">$dmfile\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Couldn't create grub device map: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint $dmfd \"(hd0) $diskname\\n\";\n\t\t$dmfd -> close();\n\t\t#==========================================\n\t\t# Create command list to install grub\n\t\t#------------------------------------------\n\t\tmy $cmdfile = \"$tmpdir/grub-device.cmds\";\n\t\tif (! $dmfd -> open(\">$cmdfile\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Couldn't create grub command list: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint $dmfd \"device (hd0) $diskname\\n\";\n\t\tprint $dmfd \"root (hd0,$bootpart)\\n\";\n\t\tif ($chainload) {\n\t\t\tprint $dmfd \"setup (hd0,0)\\n\";\n\t\t} else {\n\t\t\tprint $dmfd \"setup (hd0)\\n\";\n\t\t}\n\t\tprint $dmfd \"quit\\n\";\n\t\t$dmfd -> close();\n\t\t#==========================================\n\t\t# Install grub in batch mode\n\t\t#------------------------------------------\n\t\tmy $grub = $locator -> getExecPath ('grub');\n\t\tif (! $grub) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Can't locate grub binary\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $grubOptions = \"--device-map $dmfile --no-floppy --batch\";\n\t\tqxx (\"mount --bind $tmpdir/boot/grub /boot/grub\");\n\t\tqxx (\"$grub $grubOptions < $cmdfile &> $tmpdir/grub.log\");\n\t\tqxx (\"umount /boot/grub\");\n\t\tmy $glog;\n\t\tif ($dmfd -> open (\"$tmpdir/grub.log\")) {\n\t\t\tmy @glog = <$dmfd>; $dmfd -> close();\n\t\t\tif ($dmfd -> open (\"$cmdfile\")) {\n\t\t\t\tmy @cmdlog = <$dmfd>; $dmfd -> close();\n\t\t\t\tpush @glog,\"GRUB: commands:\";\n\t\t\t\tpush @glog,@cmdlog;\n\t\t\t}\n\t\t\tmy $stage1 = grep { /^\\s*Running.*succeeded$/ } @glog;\n\t\t\tmy $stage1_5 = grep { /^\\s*Running.*are embedded\\.$/ } @glog;\n\t\t\t$result = !(($stage1 == 1) && ($stage1_5 == 1));\n\t\t\t$glog = join (\"\\n\",@glog);\n\t\t\t$kiwi -> loginfo (\"GRUB: $glog\\n\");\n\t\t}\n\t\tif ($result != 1) {\n\t\t\tmy $boot = \"'boot sector'\";\n\t\t\tmy $null = \"/dev/null\";\n\t\t\t$status= qxx (\n\t\t\t\t\"dd if=$diskname bs=512 count=1 2>$null|file - | grep -q $boot\"\n\t\t\t);\n\t\t\t$result= $? >> 8;\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't install grub on $diskname: $glog\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tif ($chainload) {\n\t\t\t# /.../\n\t\t\t# chainload grub with master-boot-code\n\t\t\t# zero out sectors between 0x200 - 0x3f0 for preload process\n\t\t\t# store a copy of the master-boot-code at 0x800\n\t\t\t# write FDST flag at 0x190\n\t\t\t# ---\n\t\t\tmy $mbr = \"/usr/lib/boot/master-boot-code\";\n\t\t\tmy $opt = \"conv=notrunc\";\n\t\t\t#==========================================\n\t\t\t# write master-boot-code\n\t\t\t#------------------------------------------\n\t\t\t$status = qxx (\n\t\t\t\t\"dd if=$mbr of=$diskname bs=1 count=446 $opt 2>&1\"\n\t\t\t);\n\t\t\t$result= $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't install master boot code: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# write backup MBR with partition table\n\t\t\t#------------------------------------------\n\t\t\t#my $bmbr= $diskname.\".mbr\";\n\t\t\t#$status = qxx (\n\t\t\t#\t\"dd if=$diskname of=$bmbr bs=1 count=512 2>&1\"\n\t\t\t#);\n\t\t\t#$result= $? >> 8;\n\t\t\t#if ($result != 0) {\n\t\t\t#\t$kiwi -> failed ();\n\t\t\t#\t$kiwi -> error  (\"Couldn't store backup MBR: $status\");\n\t\t\t#\t$kiwi -> failed ();\n\t\t\t#\treturn undef;\n\t\t\t#}\n\t\t\t#$status = qxx (\n\t\t\t#  \"dd if=$bmbr of=$diskname bs=512 count=1 seek=3 skip=0 $opt 2>&1\"\n\t\t\t#);\n\t\t\t#unlink $bmbr;\n\t\t\t#==========================================\n\t\t\t# write FDST flag\n\t\t\t#------------------------------------------\n\t\t\tmy $fdst = \"perl -e \\\"printf '%s', pack 'A4', eval 'FDST';\\\"\";\n\t\t\tqxx (\n\t\t\t\t\"$fdst|dd of=$diskname bs=1 count=4 seek=\\$((0x190)) $opt 2>&1\"\n\t\t\t);\n\t\t\t#==========================================\n\t\t\t# zero out preload range\n\t\t\t#------------------------------------------\n\t\t\t$status = qxx (\n\t\t\t\t\"dd if=/dev/zero of=$diskname bs=1 count=496 seek=512 $opt 2>&1\"\n\t\t\t);\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# syslinux\n\t#------------------------------------------\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\tif (! $deviceMap) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"No device map available\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy %deviceMap = %{$deviceMap};\n\t\tmy $device = $deviceMap{fat};\n\t\tif ($loader eq \"extlinux\") {\n\t\t\t$device = $deviceMap{extlinux};\n\t\t}\n\t\tif (($device =~ /mapper/) && (! -e $device)) {\n\t\t\tif (! $this -> bindDiskPartitions ($diskname)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\tif ($loader eq \"syslinux\") {\n\t\t\t$kiwi -> info (\"Installing syslinux on device: $device\");\n\t\t\t$status = qxx (\"syslinux $device 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t} else {\n\t\t\t$kiwi -> info (\"Installing extlinux on device: $device\");\n\t\t\t$status = qxx (\"mount $device /mnt 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result == 0) {\n\t\t\t\t$status = qxx (\"extlinux --install /mnt/boot/syslinux 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t}\n\t\t\t$status = qxx (\"umount /mnt 2>&1\");\n\t\t}\n\t\tif ($device =~ /mapper/) {\n\t\t\t$this -> cleanLoopMaps ($diskname);\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't install $loader on $device: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $syslmbr = \"/usr/share/syslinux/mbr.bin\";\n\t\t$status = qxx (\n\t\t\t\"dd if=$syslmbr of=$diskname bs=512 count=1 conv=notrunc 2>&1\"\n\t\t);\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't install syslinux MBR on $diskname\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Zipl\n\t#------------------------------------------\n\tif ($loader eq \"zipl\") {\n\t\t$kiwi -> info (\"Installing zipl on device: $diskname\");\n\t\tmy $bootdev;\n\t\tmy $offset;\n\t\tmy $haveRealDevice = 0;\n\t\tif ($diskname !~ /\\/dev\\//) {\n\t\t\t#==========================================\n\t\t\t# clean loop maps\n\t\t\t#------------------------------------------\n\t\t\t$this -> cleanLoop ();\n\t\t\t#==========================================\n\t\t\t# detect disk offset of disk image file\n\t\t\t#------------------------------------------\n\t\t\t$offset = $this -> diskOffset ($diskname);\n\t\t\tif (! $offset) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Failed to detect disk offset\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# loop mount disk image file\n\t\t\t#------------------------------------------\n\t\t\tif (! $this->bindDiskDevice ($diskname)) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# find boot partition\n\t\t\t#------------------------------------------\n\t\t\t$bootdev = $this->{bindloop}.\"2\";\n\t\t\tif (! -e $bootdev) {\n\t\t\t\t$bootdev = $this->{bindloop}.\"1\";\n\t\t\t} else {\n\t\t\t\tmy $type = qxx (\"blkid $bootdev -s TYPE -o value\");\n\t\t\t\tif ($type =~ /LVM/) {\n\t\t\t\t\t$bootdev = $this->{bindloop}.\"1\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! -e $bootdev) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Can't find loop map: $bootdev\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t} else {\n\t\t\t#==========================================\n\t\t\t# find boot partition\n\t\t\t#------------------------------------------\n\t\t\t$bootdev = $diskname.\"2\";\n\t\t\tif (! -e $bootdev) {\n\t\t\t\t$bootdev = $diskname.\"1\";\n\t\t\t} else {\n\t\t\t\tmy $type = qxx (\"blkid $bootdev -s TYPE -o value\");\n\t\t\t\tif ($type =~ /LVM/) {\n\t\t\t\t\t$bootdev = $diskname.\"1\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t$haveRealDevice = 1;\n\t\t}\n\t\t#==========================================\n\t\t# mount boot device...\n\t\t#------------------------------------------\n\t\t$status = qxx (\"mount $bootdev /mnt 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Can't mount boot partition: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $mount = \"/mnt\";\n\t\tmy $config = \"$mount/boot/zipl.conf\";\n\t\tif (! $haveRealDevice) {\n\t\t\t#==========================================\n\t\t\t# rewrite zipl.conf with additional params\n\t\t\t#------------------------------------------\n\t\t\tif (! open (FD,$config)) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Can't open config file for reading: $!\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\tqxx (\"umount $mount 2>&1\");\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tmy @data = <FD>; close FD;\n\t\t\tif (! open (FD,\">$config\")) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Can't open config file for writing: $!\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\tqxx (\"umount $mount 2>&1\");\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> loginfo (\"zipl.conf target values:\\n\");\n\t\t\tforeach my $line (@data) {\n\t\t\t\tprint FD $line;\n\t\t\t\tif ($line =~ /^:menu/) {\n\t\t\t\t\t$kiwi -> loginfo (\"targetbase = $this->{loop}\\n\");\n\t\t\t\t\t$kiwi -> loginfo (\"targetbase = SCSI\\n\");\n\t\t\t\t\t$kiwi -> loginfo (\"targetblocksize = 512\\n\");\n\t\t\t\t\t$kiwi -> loginfo (\"targetoffset = $offset\\n\");\n\t\t\t\t\tprint FD \"\\t\".\"targetbase = $this->{loop}\".\"\\n\";\n\t\t\t\t\tprint FD \"\\t\".\"targettype = SCSI\".\"\\n\";\n\t\t\t\t\tprint FD \"\\t\".\"targetblocksize = 512\".\"\\n\";\n\t\t\t\t\tprint FD \"\\t\".\"targetoffset = $offset\".\"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose FD;\n\t\t}\n\t\t#==========================================\n\t\t# call zipl...\n\t\t#------------------------------------------\n\t\t$status = qxx (\"cd $mount && zipl -c $config 2>&1\");\n\t\t$result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't install zipl on $diskname: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"umount $mount 2>&1\");\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\tqxx (\"umount $mount 2>&1\");\n\t\t$this -> cleanLoop ();\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# install lilo\n\t#------------------------------------------\n\tif ($loader eq \"lilo\") {\n\t\t#==========================================\n\t\t# Activate devices\n\t\t#------------------------------------------\n\t\tif (! $this -> bindDiskPartitions ($this->{loop})) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# install yaboot on PReP partition\n\t\t#------------------------------------------\n\t\tif (!$lvm) {\n\t\t\tmy %deviceMap = %{$deviceMap};\n\t\t\tmy $device = $deviceMap{1};\n\t\t\t$kiwi -> info (\"Installing yaboot on device: $device\");\n\t\t\t$status = qxx (\"dd if=/lib/lilo/chrp/yaboot.chrp of=$device 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't install yaboot on $device: $status\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$this -> cleanLoop ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# more boot managers to come...\n\t#------------------------------------------\n\t# ...\n\t#==========================================\n\t# Write custom disk label ID to MBR\n\t#------------------------------------------\n\tif ($loader ne \"lilo\") {\n\t\t$kiwi -> info (\"Saving disk label in MBR: $this->{mbrid}...\");\n\t\tif (! $this -> writeMBRDiskLabel ($diskname)) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t$kiwi -> done();\n\treturn $this;\n}\n\n#==========================================\n# bindDiskDevice\n#------------------------------------------\nsub bindDiskDevice {\n\tmy $this   = shift;\n\tmy $system = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $status;\n\tmy $result;\n\tmy $loop;\n\t#==========================================\n\t# bind file to loop device\n\t#------------------------------------------\n\t$status = qxx (\"/sbin/losetup -s -f $system 2>&1\"); chomp $status;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t# /.../\n\t\t# first losetup call has failed, try to find free loop\n\t\t# device manually even though it's most likely that this\n\t\t# search will fail too. The following is only useful for\n\t\t# older version of losetup which doesn't understand the\n\t\t# option combination -s -f\n\t\t# ----\n\t\tmy $loopfound = 0;\n\t\tfor (my $id=0;$id<=7;$id++) {\n\t\t\t$status.= qxx ( \"/sbin/losetup /dev/loop$id $system 2>&1\" );\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result == 0) {\n\t\t\t\t$loopfound = 1;\n\t\t\t\t$loop = \"/dev/loop\".$id;\n\t\t\t\t$this->{loop} = $loop;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tif (! $loopfound) {\n\t\t\t$kiwi -> loginfo (\"Failed binding loop device: $status\");\n\t\t\treturn undef;\n\t\t}\n\t\treturn $this;\n\t}\n\t$loop = $status;\n\t$this->{loop} = $loop;\n\treturn $this;\n}\n\n#==========================================\n# bindDiskPartitions\n#------------------------------------------\nsub bindDiskPartitions {\n\t# ...\n\t# make sure we can access the partitions of the\n\t# loop mounted disk file\n\t# ---\n\tmy $this   = shift;\n\tmy $disk   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $status;\n\tmy $result;\n\tmy $part;\n\t$status = qxx (\"/sbin/kpartx -a $disk 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo (\"Failed mapping partition: $status\");\n\t\treturn undef;\n\t}\n\t$disk =~ s/dev\\///;\n\t$part = \"/dev/mapper\".$disk.\"p\";\n\t$this->{bindloop} = $part;\n\treturn $this;\n}\n\n#==========================================\n# checkLVMbind\n#------------------------------------------\nsub checkLVMbind {\n\t# ...\n\t# check if the volume group was activated due to a\n\t# previos call of kpartx. In this case the image has\n\t# LVM enabled and we have to use the LVM devices\n\t# ---\n\tmy $this = shift;\n\tmy $sdev = shift;\n\tmy $disk = shift;\n\tmy @groups;\n\t#==========================================\n\t# check for lvm flag on disk\n\t#------------------------------------------\n\tif (! $this-> __getPartID ($disk,\"lvm\")) {\n\t\treturn $sdev;\n\t}\n\t#==========================================\n\t# activate volume groups\n\t#------------------------------------------\n\topen (my $SCAN,\"vgscan 2>/dev/null |\");\n\twhile (my $line = <$SCAN>) {\n\t\tif ($line =~ /\\\"(.*)\\\"/) {\n\t\t\tpush (@groups,$1);\n\t\t}\n\t}\n\tclose $SCAN;\n\t#==========================================\n\t# check the device node names for kiwi lvm\n\t#------------------------------------------\n\tforeach my $lvmgroup (@groups) {\n\t\tqxx (\"vgchange -a y $lvmgroup 2>&1\");\n\t\tfor (my $try=0;$try<=3;$try++) {\n\t\t\tif (defined (my $lvroot = glob (\"/dev/mapper/*-LVRoot\"))) {\n\t\t\t\t$this->{lvm} = 1;\n\t\t\t\t$sdev = $lvroot;\n\t\t\t\tif (defined ($lvroot = glob (\"/dev/mapper/*-LVComp\"))) {\n\t\t\t\t\t$sdev = $lvroot;\n\t\t\t\t}\n\t\t\t\tif ($lvroot =~ /mapper\\/(.*)-.*/) {\n\t\t\t\t\t$this->{lvmgroup} = $1;\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t\tsleep 1;\n\t\t}\n\t\tif ($this->{lvm} == 1) {\n\t\t\tlast;\n\t\t}\n\t}\n\treturn $sdev;\n}\n\n#==========================================\n# getCylinderSizeAndCount\n#------------------------------------------\nsub getCylinderSizeAndCount {\n\t# ...\n\t# obtain cylinder size and count for the specified disk.\n\t# The function returns the size in kB (10^3 B) or zero on error\n\t# ---\n\tmy $this = shift;\n\tmy $disk = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $status;\n\tmy $result;\n\tmy $parted;\n\tmy $locator = new KIWILocator($kiwi);\n\tmy $parted_exec = $locator -> getExecPath(\"parted\");\n\t$status = qxx (\"dd if=/dev/zero of=$disk bs=512 count=1 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo ($status);\n\t\treturn 0;\n\t}\n\t$status = qxx (\"$parted_exec -s $disk mklabel msdos 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo ($status);\n\t\treturn 0;\n\t}\n\t$parted = \"$parted_exec -m $disk unit cyl print\";\n\t$status = qxx (\n\t\t\"$parted | head -n 3 | tail -n 1 | cut -f4 -d: | tr -d 'kB;'\"\n\t);\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo ($status);\n\t\treturn 0;\n\t}\n\tchomp $status;\n\t$this->{pDiskCylinderSize} = $status;\n\t$status = qxx (\n\t\t\"$parted | head -n 3 | tail -n 1 | cut -f1 -d:\"\n\t);\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> loginfo ($status);\n\t\treturn 0;\n\t}\n\tchomp $status;\n\t$this->{pDiskCylinders} = $status;\n\t$kiwi -> loginfo (\n\t\t\"Disk Cylinder size is: $this->{pDiskCylinderSize} kB\\n\"\n\t);\n\t$kiwi -> loginfo (\n\t\t\"Disk Cylinder count is: $this->{pDiskCylinders}\\n\"\n\t);\n\treturn $status;\n}\n\n#==========================================\n# getCylinder\n#------------------------------------------\nsub getCylinder {\n\t# ...\n\t# given a size in MB this function calculates the\n\t# aligned cylinder count according to the used disk\n\t# if no size is given the maximum value is used\n\t# ---\n\tmy $this  = shift;\n\tmy $size  = shift;\n\tmy $csize = $this->{pDiskCylinderSize};\n\tmy $count = $this->{pDiskCylinders};\n\tmy $cyls;\n\tif (! defined $csize) {\n\t\treturn 0;\n\t}\n\tif ($size =~ /\\+(.*)M$/) {\n\t\t$cyls = sprintf (\"%.0f\",($size * 1048576) / ($csize * 1000));\n\t} else {\n\t\t$cyls = $count;\n\t}\n\treturn $cyls;\n}\n\n#==========================================\n# resetCylinder\n#------------------------------------------\nsub resetCylinder {\n\t# ...\n\t# reset global cylinder size and count\n\t# ---\n\tmy $this = shift;\n\tundef $this->{pDiskCylinders};\n\tundef $this->{pDiskCylinderSize};\n\tundef $this->{pStart};\n\tundef $this->{pStopp};\n\treturn $this;\n}\n\n#==========================================\n# initCylinders\n#------------------------------------------\nsub initCylinders {\n\t# ...\n\t# calculate cylinder size and count for parted to create\n\t# the appropriate partition. On success the cylinder count\n\t# will be returned, on error zero is returned\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $size   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $cmdL   = $this->{cmdL};\n\tmy $cylsize= $this->{pDiskCylinderSize};\n\tmy $secsize= 512;\n\tmy $cyls   = 0;\n\tmy $status;\n\tmy $result;\n\tif (! defined $this->{pDiskCylinders}) {\n\t\tmy $cylcount = $this -> getCylinderSizeAndCount($device);\n\t\tif ($cylcount == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t$cylsize= $this->{pDiskCylinderSize};\n\t}\n\t$cyls = $this -> getCylinder ($size);\n\tif ($cyls == 0) {\n\t\treturn 0;\n\t}\n\tif (! defined $this->{pStart}) {\n\t\t$cylsize *= 1024;\n\t\t$this->{pStart} = sprintf (\n\t\t\t\"%.0f\",(($cmdL->getDiskStartSector() * $secsize) / $cylsize)\n\t\t);\n\t} else {\n\t\t$this->{pStart} = $this->{pStopp};\n\t}\n\t$this->{pStopp} = $this->{pStart} + $cyls;\n\tif ($this->{pStopp} > $this->{pDiskCylinders}) {\n\t\t$this->{pStopp} = $this->{pDiskCylinders}\n\t}\n\treturn $cyls;\n}\n\n#==========================================\n# setStoragePartition\n#------------------------------------------\nsub setStoragePartition {\n\t# ...\n\t# creates the partition table on the given device\n\t# according to the command argument list\n\t# ---\n\tmy $this     = shift;\n\tmy $device   = shift;\n\tmy $cmdref   = shift;\n\tmy $tool     = $this->{ptool};\n\tmy $kiwi     = $this->{kiwi};\n\tmy $xml      = $this->{xml};\n\tmy $tmpdir   = $this->{tmpdir};\n\tmy @commands = @{$cmdref};\n\tmy $result;\n\tmy $status;\n\tmy $ignore;\n\tmy $action;\n\tmy $locator = new KIWILocator($kiwi);\n\tmy $parted_exec = $locator -> getExecPath(\"parted\");\n\tif (! defined $tool) {\n\t\t$tool = \"parted\";\n\t}\n\tSWITCH: for ($tool) {\n\t\t#==========================================\n\t\t# fdasd\n\t\t#------------------------------------------\n\t\t/^fdasd/  && do {\n\t\t\t$kiwi -> loginfo (\n\t\t\t\t\"FDASD input: $device [@commands]\"\n\t\t\t);\n\t\t\t$status = qxx (\"dd if=/dev/zero of=$device bs=4096 count=10 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result != 0) {\n\t\t\t\t$kiwi -> loginfo ($status);\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tif (! open (FD,\"|/sbin/fdasd $device &> $tmpdir/fdasd.log\")) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tprint FD \"y\\n\";\n\t\t\tforeach my $cmd (@commands) {\n\t\t\t\tif ($cmd =~ /[ntwq]$/) {\n\t\t\t\t\t$action = $cmd;\n\t\t\t\t}\n\t\t\t\tif (($ignore) && ($cmd =~ /[ntwq]$/)) {\n\t\t\t\t\tundef $ignore;\n\t\t\t\t} elsif ($ignore) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"a\") {\n\t\t\t\t\t$ignore=1;\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"p\") {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif (($cmd =~ /^[0-9]$/) && ($action ne \"t\")) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif (($cmd eq \"83\") || ($cmd eq \"8e\")) {\n\t\t\t\t\t$cmd = 1;\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"82\") {\n\t\t\t\t\t$cmd = 2;\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \".\") {\n\t\t\t\t\tprint FD \"\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tprint FD \"$cmd\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose FD;\n\t\t\t$result = $? >> 8;\n\t\t\tmy $flog;\n\t\t\tif (open (FD,\"$tmpdir/fdasd.log\")) {\n\t\t\t\tmy @flog = <FD>; close FD;\n\t\t\t\t$flog = join (\"\\n\",@flog);\n\t\t\t\t$kiwi -> loginfo (\"FDASD: $flog\");\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# parted\n\t\t#------------------------------------------\n\t\t/^parted/  && do {\n\t\t\tmy @p_cmd = ();\n\t\t\t$this -> resetCylinder();\n\t\t\tfor (my $count=0;$count<@commands;$count++) {\n\t\t\t\tmy $cmd = $commands[$count];\n\t\t\t\tif ($cmd eq \"n\") {\n\t\t\t\t\tmy $size = $commands[$count+4];\n\t\t\t\t\t$this -> initCylinders ($device,$size);\n\t\t\t\t\tpush (@p_cmd,\n\t\t\t\t\t\t\"mkpart primary $this->{pStart} $this->{pStopp}\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"t\") {\n\t\t\t\t\tmy $index= $commands[$count+1];\n\t\t\t\t\tmy $type = $commands[$count+2];\n\t\t\t\t\tpush (@p_cmd,\"set $index type 0x$type\");\n\t\t\t\t}\n\t\t\t\tif ($cmd eq \"a\") {\n\t\t\t\t\tmy $index= $commands[$count+1];\n\t\t\t\t\tpush (@p_cmd,\"set $index boot on\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t$kiwi -> loginfo (\n\t\t\t\t\"PARTED input: $device [@p_cmd]\\n\"\n\t\t\t);\n\t\t\tmy $align=\"\";\n\t\t\t$status = qxx (\"$parted_exec --help | grep -q align=\");\n\t\t\t$result = $? >> 8;\n\t\t\tif ($result == 0) {\n\t\t\t\t$align=\"-a cyl\";\n\t\t\t}\n\t\t\tforeach my $p_cmd (@p_cmd) {\n\t\t\t\t$status= qxx (\n\t\t\t\t\t\"$parted_exec $align -s $device unit cyl $p_cmd 2>&1\"\n\t\t\t\t);\n\t\t\t\t$result= $? >> 8;\n\t\t\t\t$kiwi -> loginfo ($status);\n\t\t\t\tsleep (1);\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# getStorageID\n#------------------------------------------\nsub getStorageID {\n\t# ...\n\t# return the partition id of the given\n\t# partition. If the call fails the function\n\t# returns 0\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $partid = shift;\n\tmy $status = qxx (\"sfdisk --id $device $partid 2>&1\");\n\tmy $result = $? >> 8;\n\tif ($result == 0) {\n\t\tchomp  $status;\n\t\treturn $status;\n\t}\n\treturn 0;\n}\n\n#==========================================\n# getStorageSize\n#------------------------------------------\nsub getStorageSize {\n\t# ...\n\t# return the size of the given disk or disk\n\t# partition in Kb. If the call fails the function\n\t# returns 0\n\t# --- \n\tmy $this = shift;\n\tmy $pdev = shift;\n\tmy $status = qxx (\"blockdev --getsize64 $pdev 2>&1\");\n\tmy $result = $? >> 8;\n\tif ($result == 0) {\n\t\treturn int ($status / 1024);\n\t}\n\treturn 0;\n}\n\n#==========================================\n# setPPCDeviceMap\n#------------------------------------------\nsub setPPCDeviceMap {\n\t# ...\n\t# set default devuce map for PowerSystems\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $loader = $this->{bootloader};\n\tmy $dmapper= $this->{dmapper};\n\tmy $search = \"41\";\n\tmy %result;\n\tif (! defined $device) {\n\t\treturn undef;\n\t}\n\tfor (my $i=1;$i<=3;$i++) {\n\t\t$result{$i} = $device.$i;\n\t}\n\tif ($loader eq \"lilo\") {\n\t\tfor (my $i=1;$i<=2;$i++) {\n\t\t\tmy $type = $this -> getStorageID ($device,$i);\n\t\t\tif ($type = $search) {\n\t\t\t\t$result{prep} = $device.$i;\n\t\t\t}\n\t\t\tlast;\n\t\t}\n\t} elsif ($dmapper) {\n\t\t$result{dmapper} = $device.\"3\";\n\t}\n\treturn %result;\n}\n\n#==========================================\n# setDefaultDeviceMap\n#------------------------------------------\nsub setDefaultDeviceMap {\n\t# ...\n\t# set default device map which creates a mapping for\n\t# device names to a number\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $loader = $this->{bootloader};\n\tmy $dmapper= $this->{dmapper};\n\tmy %result;\n\tif (! defined $device) {\n\t\treturn undef;\n\t}\n\tfor (my $i=1;$i<=3;$i++) {\n\t\t$result{$i} = $device.$i;\n\t}\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\tmy $search = \"c\";\n\t\tif ($loader eq \"extlinux\" ) {\n\t\t\t$search = \"83\";\n\t\t}\n\t\tfor (my $i=3;$i>=1;$i--) {\n\t\t\tmy $type = $this -> getStorageID ($device,$i);\n\t\t\tif ($type eq $search) {\n\t\t\t\tif ($loader eq \"syslinux\" ) {\n\t\t\t\t\t$result{fat} = $device.$i;\n\t\t\t\t} else {\n\t\t\t\t\t$result{extlinux} = $device.$i;\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t} elsif ($dmapper) {\n\t\t$result{dmapper} = $device.\"3\";\n\t}\n\treturn %result;\n}\n\n#==========================================\n# setLoopDeviceMap\n#------------------------------------------\nsub setLoopDeviceMap {\n\t# ...\n\t# set loop device map which creates a mapping for\n\t# /dev/mapper loop device names to a number\n\t# ---\n\tmy $this   = shift;\n\tmy $device = shift;\n\tmy $loader = $this->{bootloader};\n\tmy $dmapper= $this->{dmapper};\n\tmy %result;\n\tif (! defined $device) {\n\t\treturn undef;\n\t}\n\tmy $dmap = $device; $dmap =~ s/dev\\///;\n\tfor (my $i=1;$i<=3;$i++) {\n\t\t$result{$i} = \"/dev/mapper\".$dmap.\"p$i\";\n\t}\n\tif ($loader =~ /(sys|ext)linux/) {\n\t\tmy $search = \"c\";\n\t\tif ($loader eq \"extlinux\" ) {\n\t\t\t$search = \"83\";\n\t\t}\n\t\tfor (my $i=3;$i>=1;$i--) {\n\t\t\tmy $type = $this -> getStorageID ($device,$i);\n\t\t\tif (\"$type\" eq \"$search\") {\n\t\t\t\tif ($loader eq \"syslinux\") {\n\t\t\t\t\t$result{fat} = \"/dev/mapper\".$dmap.\"p$i\";\n\t\t\t\t} else {\n\t\t\t\t\t$result{extlinux} = \"/dev/mapper\".$dmap.\"p$i\";\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t} elsif ($dmapper) {\n\t\t$result{dmapper} = \"/dev/mapper\".$dmap.\"p3\";\n\t}\n\treturn %result;\n}\n\n#==========================================\n# setLVMDeviceMap\n#------------------------------------------\nsub setLVMDeviceMap {\n\t# ...\n\t# set LVM device map which creates a mapping for\n\t# /dev/VG/name volume group device names to a number\n\t# ---\n\tmy $this   = shift;\n\tmy $group  = shift;\n\tmy $device = shift;\n\tmy $names  = shift;\n\tmy @names  = @{$names};\n\tmy $arch   = $this->{arch};\n\tmy $loader = $this->{bootloader};\n\tmy $dmapper= $this->{dmapper};\n\tmy %result;\n\tif (! defined $group) {\n\t\treturn undef;\n\t}\n\tif ($device =~ /loop/) {\n\t\tmy $dmap = $device; $dmap =~ s/dev\\///;\n\t\t$result{0} = \"/dev/mapper\".$dmap.\"p1\";\n\t} else {\n\t\t$result{0} = $device.\"1\";\n\t}\n\tfor (my $i=0;$i<@names;$i++) {\n\t\t$result{$i+1} = \"/dev/$group/\".$names[$i];\n\t}\n\tif (($arch =~ /ppc|ppc64/) || ($loader =~ /(sys|ext)linux/)) {\n\t\tif ($device =~ /loop/) {\n\t\t\tmy $dmap = $device; $dmap =~ s/dev\\///;\n\t\t\tif (($arch =~ /ppc|ppc64/) || ($loader =~ /syslinux/)) {\n\t\t\t\t$result{fat} = \"/dev/mapper\".$dmap.\"p1\";\n\t\t\t} else {\n\t\t\t\t$result{extlinux} = \"/dev/mapper\".$dmap.\"p1\";\n\t\t\t}\n\t\t} else {\n\t\t\tif ($loader eq \"syslinux\") {\n\t\t\t\t$result{fat} = $device.\"1\";\n\t\t\t} else {\n\t\t\t\t$result{extlinux} = $device.\"1\";\n\t\t\t}\n\t\t}\n\t} elsif ($dmapper) {\n\t\tif ($device =~ /loop/) {\n\t\t\tmy $dmap = $device; $dmap =~ s/dev\\///;\n\t\t\t$result{dmapper} = \"/dev/mapper\".$dmap.\"p1\";\n\t\t} else {\n\t\t\t$result{dmapper} = $device.\"1\";\n\t\t}\n\t}\n\treturn %result;\n}\n\n#==========================================\n# setVolumeGroup\n#------------------------------------------\nsub setVolumeGroup {\n\t# ...\n\t# create volume group and required logical \n\t# volumes. The function returns a new device map\n\t# including the volume device names\n\t# ---\n\tmy $this      = shift;\n\tmy $map       = shift;\n\tmy $device    = shift;\n\tmy $syszip    = shift;\n\tmy $haveSplit = shift;\n\tmy $parts     = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $system    = $this->{system};\n\tmy %deviceMap = %{$map};\n\tmy %lvmparts  = %{$parts};\n\tmy $VGroup    = $this->{lvmgroup};\n\tmy %newmap;\n\tmy $status;\n\tmy $result;\n\t$status = qxx (\"vgremove --force $VGroup 2>&1\");\n\t$status = qxx (\"test -d /dev/$VGroup && rm -rf /dev/$VGroup 2>&1\");\n\t$status = qxx (\"pvcreate $deviceMap{2} 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed creating physical extends: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\t$status = qxx (\"vgcreate $VGroup $deviceMap{2} 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Failed creating volume group: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLoop ();\n\t\treturn undef;\n\t}\n\tif (($syszip) || ($haveSplit)) {\n\t\t$status = qxx (\"lvcreate -L $syszip -n LVComp $VGroup 2>&1\");\n\t\t$result = $? >> 8;\n\t\t$status.= qxx (\"lvcreate -l +100%FREE -n LVRoot $VGroup 2>&1\");\n\t\t$result+= $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Logical volume(s) setup failed: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t%newmap = $this -> setLVMDeviceMap (\n\t\t\t$VGroup,$device,[\"LVComp\",\"LVRoot\"]\n\t\t);\n\t} else {\n\t\tif (%lvmparts) {\n\t\t\tmy %ihash = ();\n\t\t\tforeach my $name (keys %lvmparts) {\n\t\t\t\tmy $pname  = $name; $pname =~ s/_/\\//g;\n\t\t\t\tmy $lvsize = $lvmparts{$name}->[2];\n\t\t\t\tmy $lvdev  = \"/dev/$VGroup/LV$name\";\n\t\t\t\t$ihash{$lvdev} = \"no-opts\";\n\t\t\t\t$status = qxx (\"lvcreate -L $lvsize -n LV$name $VGroup 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t\tif ($result != 0) {\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->{deviceinodes} = \\%ihash;\n\t\t}\n\t\tif ($result == 0) {\n\t\t\t$status = qxx (\"lvcreate -l +100%FREE -n LVRoot $VGroup 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t}\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Logical volume(s) setup failed: $status\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLoop ();\n\t\t\treturn undef;\n\t\t}\n\t\t%newmap = $this -> setLVMDeviceMap (\n\t\t\t$VGroup,$device,[\"LVRoot\"]\n\t\t);\n\t}\n\treturn %newmap;\n}\n\n#==========================================\n# deleteVolumeGroup\n#------------------------------------------\nsub deleteVolumeGroup {\n\tmy $this   = shift;\n\tmy $lvm    = $this->{lvm};\n\tmy $VGroup = $this->{lvmgroup};\n\tif ($lvm) {\n\t\tqxx (\"vgremove --force $VGroup 2>&1\");\n\t\tqxx (\"test -d /dev/$VGroup && rm -rf /dev/$VGroup 2>&1\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# makeLabel\n#------------------------------------------\nsub makeLabel {\n\t# ...\n\t# grub handles spaces as \"_\", so we replace\n\t# each space with an underscore\n\t# ----\n\tmy $this = shift;\n\tmy $label = shift;\n\t$label =~ s/ /_/g;\n\treturn $label;\n}\n\n#==========================================\n# luksResize\n#------------------------------------------\nsub luksResize {\n\tmy $this   = shift;\n\tmy $source = shift;\n\tmy $name   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $cipher = $this->{gdata}->{LuksCipher};\n\tmy $status;\n\tmy $result;\n\tmy $hald;\n\t#==========================================\n\t# open luks device\n\t#------------------------------------------\n\tif ($cipher) {\n\t\t$status = qxx (\n\t\t\t\"echo $cipher | cryptsetup luksOpen $source $name 2>&1\"\n\t\t);\n\t} else {\n\t\t$status = qxx (\"cryptsetup luksOpen $source $name 2>&1\");\n\t}\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't open luks device: $status\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# resize luks header\n\t#------------------------------------------\n\t$this->{luks} = $name;\n\t$status = qxx (\"cryptsetup resize $name\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't resize luks device: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> luksClose();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# return mapped device name\n\t#------------------------------------------\n\treturn \"/dev/mapper/\".$name;\n}\n\n#==========================================\n# luksClose\n#------------------------------------------\nsub luksClose {\n\tmy $this = shift;\n\tif ($this->{luks}) {\n\t\tqxx (\"cryptsetup luksClose $this->{luks} 2>&1\");\n\t\tundef $this->{luks};\n\t}\n\treturn $this;\n}\n\n#==========================================\n# umountDevice\n#------------------------------------------\nsub umountDevice {\n\t# ...\n\t# umount all mounted filesystems from the given\n\t# storage device. The functions searches the \n\t# /proc/mounts table and umounts all corresponding\n\t# mount entries\n\t# ----\n\tmy $this = shift;\n\tmy $disk = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $MOUNTS;\n\tif (! defined $disk) {\n\t\t$kiwi -> loginfo (\"umountDevice: no disk prefix provided, skipped\");\n\t\treturn undef;\n\t}\n\tif (! open ($MOUNTS, '<', '/proc/mounts')) {\n\t\t$kiwi -> loginfo (\"umountDevice: failed to open proc/mounts: $!\");\n\t\treturn undef;\n\t}\n\tmy @mounts = <$MOUNTS>; close $MOUNTS;\n\tfor my $mount (@mounts) {\n\t\tif ($mount =~ /^$disk/) {\n\t\t\tmy ($device, $mountpoint, $rest) = split / /, $mount, 3;\n\t\t\tqxx (\"umount $device 2>&1\");\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# setupFilesystem\n#------------------------------------------\nsub setupFilesystem {\n\t# ...\n\t# create filesystem according to selected type\n\t# ----\n\tmy $this   = shift;\n\tmy $fstype = shift;\n\tmy $device = shift;\n\tmy $name   = shift;\n\tmy $inodes = $this->{deviceinodes};\n\tmy $kiwi   = $this->{kiwi};\n\tmy $xml    = $this->{xml};\n\tmy $cmdL   = $this->{cmdL};\n\tmy %type   = %{$xml->getImageTypeAndAttributes()};\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL -> getFilesystemOptions()}\n\t);\n\tmy $iorig  = $this->{inodes};\n\tmy $result;\n\tmy $status;\n\tif (($inodes) && ($inodes->{$device})) {\n\t\tif ($inodes->{$device} ne \"no-opts\") {\n\t\t\t$this->{inodes} = $inodes->{$device};\n\t\t} else {\n\t\t\tundef $this->{inodes};\n\t\t}\n\t}\n\tSWITCH: for ($fstype) {\n\t\t/^ext[234]/     && do {\n\t\t\t$kiwi -> info (\"Creating $_ $name filesystem\");\n\t\t\tmy $fsopts = $FSopts{$_};\n\t\t\tmy $fstool = \"mkfs.\".$fstype;\n\t\t\tif ($this->{inodes}) {\n\t\t\t\t$fsopts.= \" -N $this->{inodes}\";\n\t\t\t}\n\t\t\tmy $tuneopts = $type{fsnocheck} eq \"true\" ? \"-c 0 -i 0\" : \"\";\n\t\t\t$tuneopts = $FSopts{extfstune} if $FSopts{extfstune};\n\t\t\t$status = qxx (\"$fstool $fsopts $device 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tif (!$result && $tuneopts) {\n\t\t\t\t$status .= qxx (\"/sbin/tune2fs $tuneopts $device 2>&1\");\n\t\t\t\t$result = $? >> 8;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^reiserfs/ && do {\n\t\t\t$kiwi -> info (\"Creating reiserfs $name filesystem\");\n\t\t\tmy $fsopts = $FSopts{reiserfs};\n\t\t\t$fsopts.= \"-f\";\n\t\t\t$status = qxx (\n\t\t\t\t\"/sbin/mkreiserfs $fsopts $device 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^btrfs/    && do {\n\t\t\t$kiwi -> info (\"Creating btrfs $name filesystem\");\n\t\t\tmy $fsopts = $FSopts{btrfs};\n\t\t\t$status = qxx (\n\t\t\t\t\"/sbin/mkfs.btrfs $fsopts $device 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^xfs/      && do {\n\t\t\t$kiwi -> info (\"Creating xfs $name filesystem\");\n\t\t\tmy $fsopts = $FSopts{xfs};\n\t\t\t$status = qxx (\n\t\t\t\t\"/sbin/mkfs.xfs $fsopts $device 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t$kiwi -> error  (\"Unsupported filesystem type: $fstype\");\n\t\t$kiwi -> failed ();\n\t\t$this->{inodes} = $iorig;\n\t\treturn undef;\n\t};\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create $fstype filesystem: $status\");\n\t\t$kiwi -> failed ();\n\t\t$this->{inodes} = $iorig;\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t$this->{inodes} = $iorig;\n\treturn $this;\n}\n\n#==========================================\n# addBootNext\n#------------------------------------------\nsub addBootNext {\n\t# ...\n\t# Write boot program that boots the firsts drive that\n\t# does _not_ have our mbr id. The boot program source which\n\t# creates $bootnext below is added in the git repo below\n\t# tools/bootnext\n\t# ---\n\tmy $this = shift;\n\tmy $file = shift;\n\tmy $id   = shift;\n\tmy $bn;\n\tmy $bootnext =\n\t\t\"\\x8c\\xc8\\x8e\\xd0\\x31\\xe4\\x8e\\xd8\\x8e\\xc0\\xfc\\xfb\\xbe\\x00\\x7c\\xbf\" .\n\t\t\"\\x00\\x60\\xb9\\x00\\x01\\xf3\\xa5\\xea\\x1c\\x60\\x00\\x00\\xb4\\x08\\x31\\xff\" .\n\t\t\"\\xb2\\x80\\xcd\\x13\\x73\\x02\\xb2\\x01\\x80\\xfa\\x01\\xb0\\x80\\x10\\xc2\\x88\" .\n\t\t\"\\x16\\x29\\x61\\xa2\\x2a\\x61\\xe8\\x8b\\x00\\x73\\x10\\xa0\\x2a\\x61\\x40\\x3a\" .\n\t\t\"\\x06\\x29\\x61\\x72\\xee\\xbe\\x2d\\x61\\xe9\\xb3\\x00\\x80\\x3e\\x2a\\x61\\x80\" .\n\t\t\"\\x74\\x03\\xe8\\x07\\x00\\xb2\\x80\\xea\\x00\\x7c\\x00\\x00\\xa1\\x13\\x04\\x48\" .\n\t\t\"\\xa3\\x13\\x04\\xc1\\xe0\\x06\\x2d\\x00\\x06\\x66\\x8b\\x16\\x4c\\x00\\x66\\x89\" .\n\t\t\"\\x16\\x25\\x61\\x50\\x68\\x89\\x60\\x66\\x8f\\x06\\x4c\\x00\\x50\\x07\\xbe\\x00\" .\n\t\t\"\\x60\\x89\\xf7\\xb9\\x00\\x01\\xf3\\xa5\\xc3\\x9c\\x2e\\x88\\x16\\x2b\\x61\\x2e\" .\n\t\t\"\\x88\\x26\\x2c\\x61\\x2e\\x3a\\x16\\x2a\\x61\\x75\\x04\\xb2\\x80\\xeb\\x0a\\x80\" .\n\t\t\"\\xfa\\x80\\x75\\x05\\x2e\\x8a\\x16\\x2a\\x61\\x2e\\xff\\x1e\\x25\\x61\\x50\\x9f\" .\n\t\t\"\\x67\\x88\\x64\\x24\\x06\\x58\\x2e\\x80\\x3e\\x2c\\x61\\x08\\x74\\x05\\x2e\\x8a\" .\n\t\t\"\\x16\\x2b\\x61\\xcf\\xe8\\x10\\x00\\x72\\x0d\\x66\\xa1\\xb8\\x61\\x66\\x3b\\x06\" .\n\t\t\"\\xb8\\x7d\\xf9\\x74\\x01\\xf8\\xc3\\xb8\\x01\\x02\\xb9\\x01\\x00\\xb6\\x00\\x8a\" .\n\t\t\"\\x16\\x2a\\x61\\xbb\\x00\\x7c\\xcd\\x13\\x72\\x13\\x66\\x83\\x3e\\x00\\x7c\\x00\" .\n\t\t\"\\xf9\\x74\\x0a\\x81\\x3e\\xfe\\x7d\\x55\\xaa\\xf9\\x75\\x01\\xf8\\xc3\\xe8\\x15\" .\n\t\t\"\\x00\\xbe\\x44\\x61\\xe8\\x0f\\x00\\xb4\\x00\\xcd\\x16\\xbe\\x41\\x61\\xe8\\x05\" .\n\t\t\"\\x00\\xcd\\x19\\xf4\\xeb\\xfd\\xac\\x08\\xc0\\x74\\x09\\xbb\\x07\\x00\\xb4\\x0e\" .\n\t\t\"\\xcd\\x10\\xeb\\xf2\\xc3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x4e\\x6f\\x20\" .\n\t\t\"\\x6f\\x70\\x65\\x72\\x61\\x74\\x69\\x6e\\x67\\x20\\x73\\x79\\x73\\x74\\x65\\x6d\" .\n\t\t\"\\x2e\\x0d\\x0a\\x00\\x0a\\x50\\x72\\x65\\x73\\x73\\x20\\x61\\x20\\x6b\\x65\\x79\" .\n\t\t\"\\x20\\x74\\x6f\\x20\\x72\\x65\\x62\\x6f\\x6f\\x74\\x2e\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" .\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\xaa\";\n\n\t# we really need a valid id\n\treturn undef unless $id;\n\n\tsubstr $bootnext, 0x1b8, 4, pack(\"V\", $id);\n\n\topen $bn, \">$file\" or return undef;\n\tprint $bn $bootnext;\n\tclose $bn;\n\n\treturn $this;\n}\n\n#==========================================\n# diskOffset\n#------------------------------------------\nsub diskOffset {\n\t# ...\n\t# find the offset to the start of the first partition\n\t# ---\n\tmy $this = shift;\n\tmy $disk = shift;\n\tmy $offset;\n\tmy @table = qx (parted -m $disk unit s print 2>&1);\n\tchomp @table;\n\tforeach my $entry (@table) {\n\t\tif ($entry =~ /^[1-4]:/) {\n\t\t\tmy @items = split (/:/,$entry);\n\t\t\t$offset = $items[1];\n\t\t\tchop $offset;\n\t\t\tlast;\n\t\t}\n\t}\n\tif (! $offset) {\n\t\treturn undef;\n\t}\n\treturn $offset;\n}\n\n#==========================================\n# searchUSBStickDevice\n#------------------------------------------\nsub searchUSBStickDevice {\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $device = $this->{device};\n\tmy $stick;\n\t#==========================================\n\t# Find USB stick devices\n\t#------------------------------------------\n\tmy %storage = $this -> getRemovableUSBStorageDevices();\n\tif (! %storage) {\n\t\t$kiwi -> error  (\"Couldn't find any removable USB storage devices\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $prefix = $kiwi -> getPrefix (1);\n\tprint STDERR $prefix,\"Found following removable USB devices:\\n\";\n\tforeach my $dev (keys %storage) {\n\t\tprint STDERR $prefix,\"---> $storage{$dev} at $dev\\n\";\n\t}\n\tif (! defined $device) {\n\t\t#==========================================\n\t\t# Let the user select the device\n\t\t#------------------------------------------\n\t\twhile (1) {\n\t\t\t$prefix = $kiwi -> getPrefix (1);\n\t\t\tprint STDERR $prefix,\"Your choice (enter device name): \";\n\t\t\tchomp ($stick = <>);\n\t\t\tmy $found = 0;\n\t\t\tforeach my $dev (keys %storage) {\n\t\t\t\tif ($dev eq $stick) {\n\t\t\t\t\t$found = 1; last;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! $found) {\n\t\t\t\tif ($stick) {\n\t\t\t\t\tprint STDERR $prefix,\"Couldn't find [ $stick ] in list\\n\";\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tlast;\n\t\t}\n\t} else {\n\t\t#==========================================\n\t\t# Check the given device\n\t\t#------------------------------------------\n\t\t$stick = $device;\n\t\tmy $found = 0;\n\t\tforeach my $dev (keys %storage) {\n\t\t\tif ($dev eq $stick) {\n\t\t\t\t$found = 1; last;\n\t\t\t}\n\t\t}\n\t\tif (! $found) {\n\t\t\tprint STDERR $prefix,\"Couldn't find [ $stick ] in list\\n\";\n\t\t\treturn undef;\n\t\t}\n\t}\n\treturn $stick;\n}\n\n#==========================================\n# Destructor\n#------------------------------------------\nsub DESTROY {\n\tmy $this = shift;\n\tmy $dirs = $this->{tmpdirs};\n\tforeach my $dir (@{$dirs}) {\n\t\tqxx (\"rm -rf $dir 2>&1\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# Private methods\n#------------------------------------------\n#==========================================\n# getBootSize\n#------------------------------------------\nsub __getBootSize {\n\t# ...\n\t# calculate required size of /boot. This is\n\t# needed if we have a separate boot partition\n\t# The function returns the size in M-Bytes\n\t# ---\n\tmy $this   = shift;\n\tmy $extend = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $boot   = $extend.\"/boot\";\n\tmy $bbytes = qxx (\"du -s --block-size=1 $boot | cut -f1\"); chomp $bbytes;\n\t# 3 times the size should be enough for kernel updates\n\tmy $gotMB  = sprintf (\"%.0f\",(($bbytes / 1048576) * 3));\n\tmy $minMB  = 150;\n\tif ($gotMB < $minMB) {\n\t\t$gotMB = $minMB;\n\t}\n\t$kiwi -> loginfo (\"Set boot space to: \".$gotMB.\"M\\n\");\n\treturn $gotMB;\n}\n\n#==========================================\n# __expandFS\n#------------------------------------------\nsub __expandFS {\n\t# ...\n\t# Expand the file system to its maximum size\n\t# ---\n\tmy $this      = shift;\n\tmy $fsType    = shift;\n\tmy $diskType  = shift;\n\tmy $mapper    = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $locator   = new KIWILocator($kiwi);\n\tmy $result    = 1;\n\tmy $status;\n\t$kiwi->loginfo (\"Resize Operation: Device: $mapper\\n\");\n\t$kiwi->loginfo (\"Resize Operation: Image Disk Type: $diskType\\n\");\n\t$kiwi->loginfo (\"Resize Operation: Filesystem Type: $fsType\\n\");\n\tSWITCH: for ($fsType) {\n\t\t/^ext\\d/    && do {\n\t\t\t$kiwi -> info (\"Resizing $diskType $fsType filesystem\");\n\t\t\tmy $resize = $locator -> getExecPath ('resize2fs');\n\t\t\tif (! $resize) {\n\t\t\t\t$kiwi -> error ('Could not locate resize2fs');\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$status = qxx (\"$resize -f -F -p $mapper 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^reiserfs/ && do {\n\t\t\t$kiwi -> info (\"Resizing $diskType $fsType filesystem\");\n\t\t\tmy $resize = $locator -> getExecPath ('resize_reiserfs');\n\t\t\tif (! $resize) {\n\t\t\t\t$kiwi -> error ('Could not locate resize_reiserfs');\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$status = qxx (\"$resize $mapper 2>&1\");\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^btrfs/    && do {\n\t\t\t$kiwi -> info (\"Resizing $diskType $fsType filesystem\");\n\t\t\tmy $bfsctl = $locator -> getExecPath('btrfsctl');\n\t\t\tif (! $bfsctl) {\n\t\t\t\t$kiwi -> error ('Could not locate btrfsctl');\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tmy $bctl = \"$bfsctl -r max /mnt\";\n\t\t\t$status = qxx (\"\n\t\t\t\t\tmount $mapper /mnt && $bctl; umount /mnt 2>&1\"\n\t\t\t);\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^xfs/      && do {\n\t\t\t$kiwi -> info (\"Resizing $diskType $fsType filesystem\");\n\t\t\tmy $xfsGrow = $locator -> getExecPath('xfs_growfs');\n\t\t\tif (! $xfsGrow) {\n\t\t\t\t$kiwi -> error ('Could not locate xfs_grow');\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$status = qxx (\"\n\t\t\t\t\tmount $mapper /mnt && $xfsGrow /mnt; umount /mnt 2>&1\"\n\t\t\t );\n\t\t\t$result = $? >> 8;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t$kiwi->loginfo (\"Resize Operation: no resize\\n\");\n\t\t$result = 0;\n\t};\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't resize $fsType filesystem $status\");\n\t\t$kiwi -> failed ();\n\t\t$this -> luksClose();\n\t\treturn undef;\n\t}\n\t$this -> luksClose();\n\tif ($status) {\n\t\t$kiwi -> done();\n\t}\n\treturn $this;\n}\n\n#==========================================\n# __initDiskSize\n#------------------------------------------\nsub __initDiskSize {\n\t# ...\n\t# setup initial disk size value\n\t# ---\n\tmy $this      = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $minBytes  = shift;\n\tmy $cmdlsize  = shift;\n\tmy $XMLBytes  = shift;\n\tmy $cmdlBytes = 0;\n\tmy $vmsize    = 0;\n\tmy $vmmbyte   = 0;\n\t#===========================================\n\t# turn optional size from cmdline into bytes\n\t#-------------------------------------------\n\tif ($cmdlsize =~ /^(\\d+)([MG])$/i) {\n\t\tmy $value= $1;\n\t\tmy $unit = $2;\n\t\tif ($unit eq \"G\") {\n\t\t\t# convert GB to MB...\n\t\t\t$value *= 1024;\n\t\t}\n\t\t# convert MB to Byte\n\t\t$cmdlBytes = $value * 1048576;\n\t}\n\t#===========================================\n\t# adapt min size according to cmdline or XML\n\t#-------------------------------------------\n\tif ($cmdlBytes > 0) {\n\t\tif ($cmdlBytes < $minBytes) {\n\t\t\t$kiwi -> warning (\n\t\t\t\t\"given size is smaller than calculated min size\"\n\t\t\t);\n\t\t\t$kiwi -> oops();\n\t\t}\n\t\t$minBytes = $cmdlBytes;\n\t} elsif ($XMLBytes > 0) {\n\t\tif ($XMLBytes < $minBytes) {\n\t\t\t$kiwi -> warning (\n\t\t\t\t\"given size is smaller than calculated min size\"\n\t\t\t);\n\t\t\t$kiwi -> oops();\n\t\t}\n\t\t$minBytes = $XMLBytes;\n\t}\n\t#==========================================\n\t# Create vmsize MB string and vmmbyte value\n\t#------------------------------------------\n\t$vmsize  = $minBytes / 1048576;\n\t$vmsize  = sprintf (\"%.0f\", $vmsize);\n\t$vmmbyte = $vmsize;\n\t$vmsize  = $vmsize.\"M\";\n\t$kiwi -> loginfo (\n\t\t\"Starting with disk size: $vmsize\\n\"\n\t);\n\t$this->{vmmbyte} = $vmmbyte;\n\t$this->{vmsize}  = $vmsize;\n\treturn $this;\n}\n\n#==========================================\n# __updateDiskSize\n#------------------------------------------\nsub __updateDiskSize {\n\t# ...\n\t# increase the current virtual disk size value\n\t# by the specified value. value is treated as\n\t# number in MB\n\t# ---\n\tmy $this   = shift;\n\tmy $addMB  = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $vmsize = $this->{vmmbyte} + $addMB;\n\t$vmsize = sprintf (\"%.0f\", $vmsize);\n\t$this->{vmmbyte} = $vmsize;\n\t$vmsize = $vmsize.\"M\";\n\t$this->{vmsize}  = $vmsize;\n\t$kiwi->loginfo (\n\t\t\"Increasing disk size by \".$addMB.\"M to: \".$vmsize.\"\\n\"\n\t);\n\treturn $this;\n}\n\n#==========================================\n# __getPartID\n#------------------------------------------\nsub __getPartID {\n\t# ...\n\t# try to find the partition number which references\n\t# the provided flag like \"boot\" or \"lvm\"\n\t# ---\n\tmy $this = shift;\n\tmy $disk = shift;\n\tmy $flag = shift;\n\tmy $fd   = new FileHandle;\n\tif ($fd -> open (\"parted -m $disk print | cut -f1,7 -d:|\")) {\n\t\twhile (my $line = <$fd>) {\n\t\t\tif ($line =~ /^(\\d):[ ,]*$flag/) {\n\t\t\t\treturn $1;\n\t\t\t}\n\t\t}\n\t\t$fd -> close();\n\t}\n\treturn 0;\n}\n\n1;\n", "#================\n# FILE          : KIWIImage.pm\n#----------------\n# PROJECT       : OpenSUSE Build-Service\n# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany\n#               :\n# AUTHOR        : Marcus Schaefer <ms@suse.de>\n#               :\n# BELONGS TO    : Operating System images\n#               :\n# DESCRIPTION   : This module is used to create a logical\n#               : extend, an image file based on a Linux\n#               : filesystem\n#               :\n# STATUS        : Development\n#----------------\npackage KIWIImage;\n#==========================================\n# Modules\n#------------------------------------------\nuse strict;\nuse Carp qw (cluck);\nuse Fcntl ':mode';\nuse File::Basename;\nuse File::Find qw(find);\nuse File::stat;\nuse Math::BigFloat;\nuse POSIX qw(getcwd);\n\n#==========================================\n# KIWI Modules\n#------------------------------------------\nuse KIWIBoot;\nuse KIWICommandLine;\nuse KIWIImageCreator;\nuse KIWIIsoLinux;\nuse KIWILog;\nuse KIWIQX;\nuse KIWIXML;\n\n#==========================================\n# Constructor\n#------------------------------------------\nsub new {\n\t# ...\n\t# Create a new KIWIImage object which is used to create\n\t# the different output image formats from a previosly\n\t# prepared physical extend\n\t# ---\n\t#==========================================\n\t# Object setup\n\t#------------------------------------------\n\tmy $this  = {};\n\tmy $class = shift;\n\tbless $this,$class;\n\t#==========================================\n\t# Module Parameters\n\t#------------------------------------------\n\tmy $kiwi       = shift;\n\tmy $xml        = shift;\n\tmy $imageTree  = shift;\n\tmy $imageDest  = shift;\n\tmy $imageStrip = shift;\n\tmy $baseSystem = shift;\n\tmy $imageOrig  = shift;\n\tmy $initCache  = shift;\n\tmy $cmdL       = shift;\n\tmy $configFile = $xml -> getConfigName();\n\t#==========================================\n\t# Use absolute path for image destination\n\t#------------------------------------------\n\tif ($imageDest !~ /^\\//) {\n\t\tmy $pwd = getcwd();\n\t\t$imageDest = $pwd.\"/\".$imageDest;\n\t}\n\t#==========================================\n\t# Constructor setup\n\t#------------------------------------------\n\tif (! defined $kiwi) {\n\t\t$kiwi = new KIWILog(\"tiny\");\n\t}\n\tif (! defined $cmdL) {\n\t\t$kiwi -> error (\"No Commandline reference specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $xml) {\n\t\t$kiwi -> error (\"No XML reference specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $baseSystem) {\n\t\t$kiwi -> error (\"No base system path specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $imageTree) {\n\t\t$kiwi -> error  (\"No image tree specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! -f $configFile) {\n\t\t$kiwi -> error  (\"Validation of $imageTree failed\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! -d $imageDest) {\n\t\t$kiwi -> error  (\"No valid destdir: $imageDest\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! $main::global) {\n\t\t$kiwi -> error  (\"Globals object not found\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! $cmdL -> getLogFile()) {\n\t\t$imageTree =~ s/\\/$//;\n\t\tif (defined $imageOrig) {\n\t\t\t$kiwi -> setRootLog ($imageOrig.\".\".$$.\".screenrc.log\");\n\t\t} else {\n\t\t\t$kiwi -> setRootLog ($imageTree.\".\".$$.\".screenrc.log\");\n\t\t}\n\t}\n\tmy $arch = qxx (\"uname -m\"); chomp ( $arch );\n\t$arch = \".$arch\";\n\t#==========================================\n\t# Store object data\n\t#------------------------------------------\n\t$this->{kiwi}       = $kiwi;\n\t$this->{cmdL}       = $cmdL;\n\t$this->{initCache}  = $initCache;\n\t$this->{xml}        = $xml;\n\t$this->{imageTree}  = $imageTree;\n\t$this->{imageDest}  = $imageDest;\n\t$this->{imageStrip} = $imageStrip;\n\t$this->{baseSystem} = $baseSystem;\n\t$this->{arch}       = $arch;\n\t$this->{gdata}      = $main::global -> getGlobals();\n\t#==========================================\n\t# Mount overlay tree if required...\n\t#------------------------------------------\n\t$this -> setupOverlay();\n\t#==========================================\n\t# Store a disk label ID for this object\n\t#------------------------------------------\n\t$this->{mbrid} = $main::global -> getMBRDiskLabel (\n\t\t$cmdL -> getMBRID()\n\t);\n\t#==========================================\n\t# Clean kernel mounts if any\n\t#------------------------------------------\n\t$this -> cleanKernelFSMount();\n\treturn $this;\n}\n\n#==========================================\n# getImageTree\n#------------------------------------------\nsub getImageTree {\n\t# ...\n\t# return current value of system image tree. Normally\n\t# this is the same as given in the module parameter list\n\t# but in case of an overlay cache mount the path changes\n\t# ---\n\tmy $this = shift;\n\treturn $this->{imageTree}\n}\n\n#==========================================\n# updateDescription\n#------------------------------------------\nsub updateDescription {\n\t# ...\n\t# Create change set hash from the given XML object\n\t# to be integrated into another XML object at a later\n\t# point in the process.\n\t# ---\n\tmy $this      = shift;\n\tmy $src_xml   = shift;\n\tmy %src_type  = %{$src_xml->getImageTypeAndAttributes()};\n\tmy %changeset = ();\n\tmy @profiles;\n\tmy %repos;\n\tmy @plist;\n\tmy @alist;\n\tmy @falistImage;\n\tmy @fplistImage;\n\tmy @fplistDelete;\n\tmy @driverList;\n\tmy %fixedBootInclude;\n\tmy @node;\n\t#==========================================\n\t# Store general data\n\t#------------------------------------------\n\tif ($src_type{hybrid}) {\n\t\t$changeset{\"hybrid\"}= $src_type{hybrid};\n\t}\n\tif ($src_type{hybridpersistent}) {\n\t\t$changeset{\"hybridpersistent\"} = $src_type{hybridpersistent};\n\t}\n\tif ($src_type{ramonly}) {\n\t\t$changeset{\"ramonly\"} = $src_type{ramonly};\n\t}\n\tif ($src_type{cmdline}) {\n\t\t$changeset{\"kernelcmdline\"} = $src_type{cmdline};\n\t}\n\tif ($src_type{lvm}) {\n\t\t$changeset{\"lvm\"} = $src_type{lvm};\n\t}\n\tif ($src_type{bootloader}) {\n\t\t$changeset{\"bootloader\"} = $src_type{bootloader};\n\t}\n\tif ($src_type{installboot}) {\n\t\t$changeset{\"installboot\"} = $src_type{installboot};\n\t}\n\tif ($src_type{bootprofile}) {\n\t\t$changeset{\"bootprofile\"} = $src_type{bootprofile};\n\t}\n\tif ($src_type{bootkernel}) {\n\t\t$changeset{\"bootkernel\"} = $src_type{bootkernel};\n\t}\n\tif ($src_xml->{reqProfiles}) {\n\t\tpush @profiles,@{$src_xml->{reqProfiles}};\n\t\t$changeset{\"profiles\"} = \\@profiles;\n\t}\n\t#==========================================\n\t# Store general data\n\t#------------------------------------------\n\t$changeset{\"packagemanager\"} = $src_xml->getPackageManager();\n\t$changeset{\"showlicense\"}    = $src_xml->getLicenseNames();\n\t$changeset{\"domain\"}         = $src_xml->getXenDomain();\n\t$changeset{\"displayname\"}    = $src_xml->getImageDisplayName();\n\t$changeset{\"locale\"}         = $src_xml->getLocale();\n\t$changeset{\"boot-theme\"}     = $src_xml->getBootTheme();\n\t$changeset{\"allFreeVolume\"}  = $src_xml->getAllFreeVolume();\n\t#==========================================\n\t# Store repositories\n\t#------------------------------------------\n\t@node = $src_xml->getNodeList() -> get_nodelist();\n\tforeach my $element (@node) {\n\t\tif (! $src_xml -> __requestedProfile ($element)) {\n\t\t\tnext;\n\t\t}\n\t\tmy $type  = $element -> getAttribute(\"type\");\n\t\tmy $alias = $element -> getAttribute(\"alias\");\n\t\tmy $prio  = $element -> getAttribute(\"priority\");\n\t\tmy $user  = $element -> getAttribute(\"username\");\n\t\tmy $pwd   = $element -> getAttribute(\"password\");\n\t\tmy $source= $element -> getElementsByTagName(\"source\")\n\t\t\t-> get_node(1) -> getAttribute (\"path\");\n\t\t$repos{$source} = [$type,$alias,$prio,$user,$pwd];\n\t}\n\t$changeset{\"repositories\"} = \\%repos;\n\t#==========================================\n\t# Store drivers section if any\n\t#------------------------------------------\n\t@node = $src_xml->getDriversNodeList() -> get_nodelist();\n\tforeach my $element (@node) {\n\t\tif (! $src_xml -> __requestedProfile ($element)) {\n\t\t\tnext;\n\t\t}\n\t\tmy @files = $element->getElementsByTagName (\"file\");\n\t\tforeach my $element (@files) {\n\t\t\tmy $driver = $element -> getAttribute (\"name\");\n\t\t\tpush (@driverList,$driver);\n\t\t}\n\t}\n\t$changeset{\"driverList\"} = \\@driverList;\n\t#==========================================\n\t# Store boot included packages\n\t#------------------------------------------\n\t@node = $src_xml->getPackageNodeList() -> get_nodelist();\n\tforeach my $element (@node) {\n\t\tif (! $src_xml -> __requestedProfile ($element)) {\n\t\t\tnext;\n\t\t}\n\t\tmy $type = $element  -> getAttribute (\"type\");\n\t\tif (($type eq \"image\") || ($type eq \"bootstrap\")) {\n\t\t\tpush (@plist,$element->getElementsByTagName (\"package\"));\n\t\t\tpush (@alist,$element->getElementsByTagName (\"archive\"));\n\t\t}\n\t}\n\tforeach my $element (@plist) {\n\t\tmy $package = $element -> getAttribute (\"name\");\n\t\tmy $bootinc = $element -> getAttribute (\"bootinclude\");\n\t\tmy $bootdel = $element -> getAttribute (\"bootdelete\");\n\t\tmy $include = 0;\n\t\tif ((defined $bootinc) && (\"$bootinc\" eq \"true\")) {\n\t\t\tpush (@fplistImage,$package);\n\t\t\t$include++;\n\t\t}\n\t\tif ((defined $bootdel) && (\"$bootdel\" eq \"true\")) {\n\t\t\tpush (@fplistDelete,$package);\n\t\t\t$include--;\n\t\t}\n\t\t$fixedBootInclude{$package} = $include;\n\t}\n\tforeach my $element (@alist) {\n\t\tmy $archive = $element -> getAttribute (\"name\");\n\t\tmy $bootinc = $element -> getAttribute (\"bootinclude\");\n\t\tif ((defined $bootinc) && (\"$bootinc\" eq \"true\")) {\n\t\t\tpush (@falistImage,$archive);\n\t\t}\n\t}\n\t$changeset{\"fixedBootInclude\"} = \\%fixedBootInclude;\n\t$changeset{\"falistImage\"}  = \\@falistImage;\n\t$changeset{\"fplistImage\"}  = \\@fplistImage;\n\t$changeset{\"fplistDelete\"} = \\@fplistDelete;\n\t#==========================================\n\t# Store OEM data\n\t#------------------------------------------\n\t$changeset{\"oem-partition-install\"}    = $src_xml->getOEMPartitionInstall();\n\t$changeset{\"oem-swap\"}                 = $src_xml->getOEMSwap();\n\t$changeset{\"oem-align-partition\"}      = $src_xml->getOEMAlignPartition();\n\t$changeset{\"oem-swapsize\"}             = $src_xml->getOEMSwapSize();\n\t$changeset{\"oem-systemsize\"}           = $src_xml->getOEMSystemSize();\n\t$changeset{\"oem-boot-title\"}           = $src_xml->getOEMBootTitle();\n\t$changeset{\"oem-kiwi-initrd\"}          = $src_xml->getOEMKiwiInitrd();\n\t$changeset{\"oem-reboot\"}               = $src_xml->getOEMReboot();\n\t$changeset{\"oem-reboot-interactive\"}   = $src_xml->getOEMRebootInter();\n\t$changeset{\"oem-silent-boot\"}          = $src_xml->getOEMSilentBoot();\n\t$changeset{\"oem-shutdown\"}             = $src_xml->getOEMShutdown();\n\t$changeset{\"oem-shutdown-interactive\"} = $src_xml->getOEMShutdownInter();\n\t$changeset{\"oem-bootwait\"}             = $src_xml->getOEMBootWait();\n\t$changeset{\"oem-unattended\"}           = $src_xml->getOEMUnattended();\n\t$changeset{\"oem-recovery\"}             = $src_xml->getOEMRecovery();\n\t$changeset{\"oem-recoveryID\"}           = $src_xml->getOEMRecoveryID();\n\t$changeset{\"oem-inplace-recovery\"}     = $src_xml->getOEMRecoveryInPlace();\n\t#==========================================\n\t# Return changeset hash\n\t#------------------------------------------\n\treturn %changeset;\n}\n\n#==========================================\n# checkAndSetupPrebuiltBootImage\n#------------------------------------------\nsub checkAndSetupPrebuiltBootImage {\n\t# ...\n\t# check the xml if a prebuild boot image was requested.\n\t# if yes check if that boot image exists and if yes\n\t# copy it to the destination directory for this build\n\t# ---\n\tmy $this = shift;\n\tmy $ixml = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $cmdL = $this->{cmdL};\n\tmy $idest= $cmdL->getImageTargetDir();\n\tmy %type = %{$ixml->getImageTypeAndAttributes()};\n\tmy $pblt = $type{checkprebuilt};\n\tmy $boot = $type{boot};\n\tmy $ok   = 0;\n\tmy $bootpath = $boot;\n\tif (($boot !~ /^\\//) && (! -d $boot)) {\n\t\t$bootpath = $this->{gdata}->{System}.\"/\".$boot;\n\t}\n\t#==========================================\n\t# open boot image XML object\n\t#------------------------------------------\n\tmy $locator = new KIWILocator($kiwi);\n\tmy $controlFile = $locator -> getControlFile ($bootpath);\n\tif (! $controlFile) {\n\t\treturn undef;\n\t}\n\tmy $validator = new KIWIXMLValidator (\n\t\t$kiwi,$controlFile,\n\t\t$this->{gdata}->{Revision},\n\t\t$this->{gdata}->{Schema},\n\t\t$this->{gdata}->{SchemaCVT}\n\t);\n\tmy $isValid = $validator ? $validator -> validate() : undef;\n\tif (! $isValid) {\n\t\treturn undef;\n\t}\n\tmy $bxml = new KIWIXML ( $kiwi,$bootpath,undef,undef,$cmdL );\n\tif (! $bxml) {\n\t\treturn undef;\n\t}\n\tmy $bootImageName = $bxml -> buildImageName();\n\tundef $bxml;\n\t$kiwi -> info (\"Checking for pre-built boot image\");\n\t#==========================================\n\t# is it requested...\n\t#------------------------------------------\n\tif ((! $pblt) || ($pblt eq \"false\")) {\n\t\t$kiwi -> notset();\n\t\treturn ($bootImageName,0);\n\t}\n\t#==========================================\n\t# check path names for boot image\n\t#------------------------------------------\n\tmy $lookup = $bootpath.\"-prebuilt/\";\n\tmy $prebuiltPath = $cmdL -> getPrebuiltBootImagePath();\n\tif (defined $prebuiltPath) {\n\t\t$lookup = $prebuiltPath.\"/\";\n\t}\n\tmy $pinitrd = $lookup.$bootImageName.\".gz\";\n\tmy $psplash;\n\tif (-f $lookup.$bootImageName.\".splash.gz\") {\n\t\t$psplash = $lookup.$bootImageName.\".splash.gz\";\n\t}\n\tmy $plinux  = $lookup.$bootImageName.\".kernel\";\n\tif (! -f $pinitrd) {\n\t\t$pinitrd = $lookup.$bootImageName;\n\t}\n\tif ((! -f $pinitrd) || (! -f $plinux)) {\n\t\t$kiwi -> skipped();\n\t\t$kiwi -> info (\"Can't find pre-built boot image in $lookup\");\n\t\t$kiwi -> skipped();\n\t\t$ok = 0;\n\t} else {\n\t\t$kiwi -> done();\n\t\t$kiwi -> info (\"Copying pre-built boot image to destination\");\n\t\tmy $lookup = basename $pinitrd;\n\t\tif (-f \"$idest/$lookup\") {\n\t\t\t#==========================================\n\t\t\t# Already exists in destination dir\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> done();\n\t\t\t$ok = 1;\n\t\t} else {\n\t\t\t#==========================================\n\t\t\t# Needs to be copied...\n\t\t\t#------------------------------------------\n\t\t\tif ($psplash) {\n\t\t\t\tqxx (\"cp -a $psplash $idest 2>&1\");\n\t\t\t}\n\t\t\tmy $data = qxx (\"cp -a $pinitrd $idest 2>&1\");\n\t\t\tmy $code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> failed();\n\t\t\t\t$kiwi -> error (\"Can't copy pre-built initrd: $data\");\n\t\t\t\t$kiwi -> failed();\n\t\t\t\t$ok = 0;\n\t\t\t} else {\n\t\t\t\t$data = qxx (\"cp -a $plinux* $idest 2>&1\");\n\t\t\t\t$code = $? >> 8;\n\t\t\t\tif ($code != 0) {\n\t\t\t\t\t$kiwi -> failed();\n\t\t\t\t\t$kiwi -> error (\"Can't copy pre-built kernel: $data\");\n\t\t\t\t\t$kiwi -> failed();\n\t\t\t\t\t$ok = 0;\n\t\t\t\t} else {\n\t\t\t\t\t$kiwi -> done();\n\t\t\t\t\t$ok = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# setup return for ok\n\t#------------------------------------------\n\tif (! $ok) {\n\t\treturn ($bootImageName,0);\n\t}\n\treturn ($bootImageName,1);\n}\n\n#==========================================\n# setupOverlay\n#------------------------------------------\nsub setupOverlay {\n\t# ...\n\t# mount the image cache if the image is based on it\n\t# and register the overlay mount point as new imageTree\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $tree = $this->{imageTree};\n\tmy $xml  = $this->{xml};\n\t$this->{overlay} = new KIWIOverlay ($kiwi,$tree);\n\tif (! $this->{overlay}) {\n\t\treturn undef;\n\t}\n\t$this->{imageTree} = $this->{overlay} -> mountOverlay();\n\tif (! defined $this->{imageTree}) {\n\t\treturn undef;\n\t}\n\t$xml -> writeXMLDescription ($this->{imageTree});\n\treturn $this;\n}\n\n#==========================================\n# stripImage\n#------------------------------------------\nsub stripImage {\n\t# ...\n\t# remove symbols from shared objects and binaries\n\t# using strip -p\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $imageTree = $this->{imageTree};\n\t$kiwi -> info (\"Stripping shared objects/executables...\");\n\tmy @list = qxx (\"find $imageTree -type f -perm -755\");\n\tforeach my $file (@list) {\n\t\tchomp $file;\n\t\tmy $data = qxx (\"file \\\"$file\\\"\");\n\t\tchomp $data;\n\t\tif ($data =~ /not stripped/) {\n\t\tif ($data =~ /shared object/) {\n\t\t\tqxx (\"strip -p $file 2>&1\");\n\t\t}\n\t\tif ($data =~ /executable/) {\n\t\t\tqxx (\"strip -p $file 2>&1\");\n\t\t}\n\t\t}\n\t}\n\t$kiwi -> done ();\n\treturn $this;\n}\n\n#==========================================\n# createImageClicFS\n#------------------------------------------\nsub createImageClicFS {\n\t# ...\n\t# create compressed loop image container\n\t# ---\n\tmy $this    = shift;\n\tmy $rename  = shift;\n\tmy $journal = \"journaled-ext3\";\n\tmy $kiwi    = $this->{kiwi};\n\tmy $data;\n\tmy $code;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ();\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\tif (defined $rename) {\n\t\t$data = qxx (\n\t\t\t\"mv $this->{imageDest}/$name $this->{imageDest}/$rename 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"Can't rename image file\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  ($data);\n\t\t\treturn undef;\n\t\t}\n\t\t$name = $rename;\n\t}\n\t#==========================================\n\t# Create ext3 filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupEXT2 ( $name,$journal )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name,\"nozip\",\"clicfs\")) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Rename filesystem loop file\n\t#------------------------------------------\n\t$data = qxx (\n\t\t\"mv $this->{imageDest}/$name $this->{imageDest}/fsdata.ext3 2>&1\"\n\t);\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Can't move file to fsdata.ext3\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t#==========================================  \n\t# Resize to minimum  \n\t#------------------------------------------\n\tmy $rver= qxx (\n\t\t\"resize2fs --version 2>&1 | head -n 1 | cut -f2 -d ' ' | cut -f1-2 -d.\"\n\t); chomp $rver;\n\tmy $dfs = \"/sbin/debugfs\";\n\tmy $req = \"-R 'show_super_stats -h'\";\n\tmy $bcn = \"'^Block count:'\";\n\tmy $bfr = \"'^Free blocks:'\";\n\tmy $src = \"$this->{imageDest}/fsdata.ext3\";\n\tmy $blocks = 0;\n\t$kiwi -> loginfo (\"Using resize2fs version: $rver\\n\");\n\tif ($rver >= 1.41) {\n\t\t$data = qxx (\n\t\t\t\"resize2fs $this->{imageDest}/fsdata.ext3 -M 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"Failed to resize ext3 container: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t} else {\n\t\t$data = qxx (\n\t\t\t\"$dfs $req $src 2>/dev/null | grep $bcn | sed -e 's,.*: *,,'\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"debugfs: block count request failed: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tchomp $data;\n\t\t$blocks = $data;  \n\t\t$data = qxx (\n\t\t\t\"$dfs $req $src 2>/dev/null | grep $bfr | sed -e 's,.*: *,,'\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"debugfs: free blocks request failed: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}  \n\t\t$kiwi -> info (\"clicfs: blocks count=$blocks free=$data\");\n\t\t$blocks = $blocks - $data;  \n\t\t$data = qxx (\n\t\t\t\"resize2fs $this->{imageDest}/fsdata.ext3 $blocks 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> error  (\"Failed to resize ext3 container: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Create clicfs filesystem from ext3\n\t#------------------------------------------\n\t$kiwi -> info (\n\t\t\"Creating clicfs container: $this->{imageDest}/$name.clicfs\"\n\t);\n\tmy $clicfs = \"mkclicfs\";\n\tif (defined $ENV{MKCLICFS_COMPRESSION}) {\n\t\tmy $c = int $ENV{MKCLICFS_COMPRESSION};\n\t\tmy $d = $this->{imageDest};\n\t\t$data = qxx (\"$clicfs -c $c $d/fsdata.ext3 $d/$name 2>&1\");\n\t} else {\n\t\tmy $d = $this->{imageDest};\n\t\t$data = qxx (\"$clicfs $d/fsdata.ext3 $d/$name 2>&1\");\n\t}\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create clicfs filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\tqxx (\"mv -f $this->{imageDest}/$name.ext3 $this->{imageDest}/$name.clicfs\");\n\tqxx (\"rm -f $this->{imageDest}/fsdata.ext3\");\n\t$kiwi -> done();\n\t#==========================================\n\t# Create image md5sum\n\t#------------------------------------------\n\tif (! $this -> buildMD5Sum ($name)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageEXT\n#------------------------------------------\nsub createImageEXT {\n\t# ...\n\t# Create EXT2 image from source tree\n\t# ---\n\tmy $this    = shift;\n\tmy $journal = shift;\n\tmy $device  = shift;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ($device);\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupEXT2 ( $name,$journal,$device )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name,undef,undef,$device)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageEXT2\n#------------------------------------------\nsub createImageEXT2 {\n\t# ...\n\t# create journaled EXT2 image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\tmy $journal = \"journaled-ext2\";\n\treturn $this -> createImageEXT ($journal,$device);\n}\n\n#==========================================\n# createImageEXT3\n#------------------------------------------\nsub createImageEXT3 {\n\t# ...\n\t# create journaled EXT3 image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\tmy $journal = \"journaled-ext3\";\n\treturn $this -> createImageEXT ($journal,$device);\n}\n\n#==========================================\n# createImageEXT4\n#------------------------------------------\nsub createImageEXT4 {\n\t# ...\n\t# create journaled EXT4 image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\tmy $journal = \"journaled-ext4\";\n\treturn $this -> createImageEXT ($journal,$device);\n}\n\n#==========================================\n# createImageReiserFS\n#------------------------------------------\nsub createImageReiserFS {\n\t# ...\n\t# create journaled ReiserFS image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ($device);\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupReiser ( $name,$device )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name,undef,undef,$device)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageBTRFS\n#------------------------------------------\nsub createImageBTRFS {\n\t# ...\n\t# create BTRFS image from source tree\n\t# ---\n\tmy $this = shift;\n\tmy $device  = shift;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ($device);\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupBTRFS ( $name,$device )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name,undef,undef,$device)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageXFS\n#------------------------------------------\nsub createImageXFS {\n\t# ...\n\t# create XFS image from source tree\n\t# ---\n\tmy $this = shift;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage ();\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupXFS ( $name )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# POST filesystem setup\n\t#------------------------------------------\n\tif (! $this -> postImage ($name)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageSquashFS\n#------------------------------------------\nsub createImageSquashFS {\n\t# ...\n\t# create squashfs image from source tree\n\t# ---\n\tmy $this  = shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $xml   = $this->{xml};\n\tmy %type  = %{$xml->getImageTypeAndAttributes()};\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage (\"haveExtend\");\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create filesystem on extend\n\t#------------------------------------------\n\tif (! $this -> setupSquashFS ( $name )) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create image md5sum\n\t#------------------------------------------\n\tif (! $this -> buildMD5Sum ($name)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Compress image using gzip\n\t#------------------------------------------\n\tif (($type{compressed}) && ($type{compressed} eq 'true')) {\n\t\tif (! $this -> compressImage ($name)) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Create image boot configuration\n\t#------------------------------------------\n\tif (! $this -> writeImageConfig ($name)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageCPIO\n#------------------------------------------\nsub createImageCPIO {\n\t# ...\n\t# create cpio archive from the image source tree\n\t# The kernel will use this archive and mount it as\n\t# cpio archive\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $imageTree = $this->{imageTree};\n\tmy $zipper    = $this->{gdata}->{Gzip};\n\tmy $compress  = 1;\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tmy $name = $this -> preImage (\"haveExtend\",\"quiet\");\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# PRE Create filesystem on extend\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating cpio archive...\");\n\tmy $pwd  = qxx (\"pwd\"); chomp $pwd;\n\tmy @cpio = (\"--create\", \"--format=newc\", \"--quiet\");\n\tmy $dest = $this->{imageDest}.\"/\".$name.\".gz\";\n\tmy $dspl = $this->{imageDest}.\"/\".$name.\".splash.gz\";\n\tmy $data;\n\tif (! $compress) {\n\t\t$dest = $this->{imageDest}.\"/\".$name;\n\t}\n\tif ($dest !~ /^\\//) {\n\t\t$dest = $pwd.\"/\".$dest;\n\t}\n\tif ($dspl !~ /^\\//) {\n\t\t$dspl = $pwd.\"/\".$dspl;\n\t}\n\tif (-e $dspl) {\n\t\tqxx (\"rm -f $dspl 2>&1\");\n\t}\n\tif ($compress) {\n\t\t$data = qxx (\n\t\t\t\"cd $imageTree && find . | cpio @cpio | $zipper -f > $dest\"\n\t\t);\n\t} else {\n\t\t$data = qxx (\"rm -f $dest && rm -f $dest.gz\");\n\t\t$data = qxx (\n\t\t\t\"cd $imageTree && find . | cpio @cpio > $dest\"\n\t\t);\n\t}\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create cpio archive\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# PRE filesystem setup\n\t#------------------------------------------\n\tif ($compress) {\n\t\t$name = $name.\".gz\";\n\t}\n\tif (! $this -> buildMD5Sum ($name)) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageRootAndBoot\n#------------------------------------------\nsub createImageRootAndBoot {\n\t# ...\n\t# Create root filesystem image if required according to\n\t# the selected image type and also create the boot image\n\t# including kernel and initrd. This function is required\n\t# to create the preconditions for virtual disk images\n\t# ---\n\t#==========================================\n\t# Create root image\n\t#------------------------------------------\n\tmy $this       = shift;\n\tmy $para       = shift;\n\tmy $text       = shift;\n\tmy $kiwi       = $this->{kiwi};\n\tmy $sxml       = $this->{xml};\n\tmy $cmdL       = $this->{cmdL};\n\tmy $idest      = $cmdL->getImageTargetDir();\n\tmy %stype      = %{$sxml->getImageTypeAndAttributes()};\n\tmy $imageTree  = $this->{imageTree};\n\tmy $baseSystem = $this->{baseSystem};\n\tmy $checkBase  = $cmdL->getRootTargetDir().\"/\".$baseSystem;\n\tmy $treeAccess = 1;\n\tmy @bootdata;\n\tmy $type;\n\tmy $boot;\n\tmy %result;\n\tmy $ok;\n\tif ($para =~ /(.*):(.*)/) {\n\t\t$type = $1;\n\t\t$boot = $2;\n\t}\n\tif ((! defined $type) || (! defined $boot)) {\n\t\t$kiwi -> error  (\"Invalid $text type specified: $para\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for direct tree access\n\t#------------------------------------------\n\tif (($text ne \"VMX\") || ($stype{luks})) {\n\t\t$treeAccess = 0;\n\t}\n\tif ($stype{lvm}) {\n\t\t$treeAccess = 1;\n\t}\n\t#==========================================\n\t# Walk through the types\n\t#------------------------------------------\n\tSWITCH: for ($type) {\n\t\t/^ext2/       && do {\n\t\t\tif (! $treeAccess) {\n\t\t\t\t$ok = $this -> createImageEXT2 ();\n\t\t\t} else {\n\t\t\t\t$ok = $this -> setupLogicalExtend();\n\t\t\t\t$result{imageTree} = $imageTree;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^ext3/       && do {\n\t\t\tif (! $treeAccess) {\n\t\t\t\t$ok = $this -> createImageEXT3 ();\n\t\t\t} else {\n\t\t\t\t$ok = $this -> setupLogicalExtend();\n\t\t\t\t$result{imageTree} = $imageTree;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^ext4/       && do {\n\t\t\tif (! $treeAccess) {\n\t\t\t\t$ok = $this -> createImageEXT4 ();\n\t\t\t} else {\n\t\t\t\t$ok = $this -> setupLogicalExtend();\n\t\t\t\t$result{imageTree} = $imageTree;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^reiserfs/   && do {\n\t\t\tif (! $treeAccess) {\n\t\t\t\t$ok = $this -> createImageReiserFS ();\n\t\t\t} else {\n\t\t\t\t$ok = $this -> setupLogicalExtend();\n\t\t\t\t$result{imageTree} = $imageTree;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^squashfs/   && do {\n\t\t\t$ok = $this -> createImageSquashFS ();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^clicfs/     && do {\n\t\t\t$ok = $this -> createImageClicFS ();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^btrfs/      && do {\n\t\t\t$ok = $this -> createImageBTRFS ();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/^xfs/        && do {\n\t\t\t$ok = $this -> createImageXFS ();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t$kiwi -> error  (\"Unsupported $text type: $type\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t};\n\tif (! $ok) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Prepare/Create boot image\n\t#------------------------------------------\n\t$kiwi -> info (\"--> Creating $text boot image: $boot...\\n\");\n\t@bootdata = $this -> checkAndSetupPrebuiltBootImage ($sxml);\n\tif (! @bootdata) {\n\t\treturn undef;\n\t}\n\tif ($bootdata[1] == 0) {\n\t\t#==========================================\n\t\t# Setup changeset to be used by boot image\n\t\t#------------------------------------------\n\t\tmy %XMLChangeSet = $this -> updateDescription ($sxml);\n\t\t#==========================================\n\t\t# Create tmp dir for boot image creation\n\t\t#------------------------------------------\n\t\tmy $tmpdir = qxx (\"mktemp -q -d $idest/boot-$text.XXXXXX\");\n\t\tmy $result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tchomp $tmpdir;\n\t\tpush @{$this->{tmpdirs}},$tmpdir;\n\t\t#==========================================\n\t\t# Prepare boot image...\n\t\t#------------------------------------------\n\t\tmy $configDir;\n\t\tif (($stype{boot} !~ /^\\//) && (! -d $stype{boot})) {\n\t\t\t$configDir = $this->{gdata}->{System}.\"/\".$stype{boot};\n\t\t} else {\n\t\t\t$configDir = $stype{boot};\n\t\t}\n\t\tmy $rootTarget = \"$tmpdir/kiwi-\".$text.\"boot-$$\";\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) ||\t(! $kic -> prepareBootImage (\n\t\t\t$configDir,$rootTarget,$this->{imageTree},\\%XMLChangeSet))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create boot image...\n\t\t#------------------------------------------\n\t\tif ((! $kic) || (! $kic -> createBootImage (\n\t\t\t$rootTarget,$this->{imageDest}))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Clean up tmp directory\n\t\t#------------------------------------------\n\t\tqxx (\"rm -rf $tmpdir\");\n\t}\n\t#==========================================\n\t# setup initrd name\n\t#------------------------------------------\n\tmy $initrd = $idest.\"/\".$bootdata[0].\".gz\";\n\tif (! -f $initrd) {\n\t\t$initrd = $idest.\"/\".$bootdata[0];\n\t}\n\t#==========================================\n\t# Check boot and system image kernel\n\t#------------------------------------------\n\tif ($cmdL->getCheckKernel()) {\n\t\tif (! $this -> checkKernel ($initrd,$imageTree,$bootdata[0])) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Include splash screen to initrd\n\t#------------------------------------------\n\tmy $kboot  = new KIWIBoot ($kiwi,$initrd,$cmdL);\n\tif (! defined $kboot) {\n\t\treturn undef;\n\t}\n\tmy $newinitrd = $kboot -> setupSplash();\n\t#==========================================\n\t# Store meta data for subsequent calls\n\t#------------------------------------------\n\t$result{systemImage} = $sxml -> buildImageName();\n\t$result{bootImage}   = $bootdata[0];\n\tif ($text eq \"VMX\") {\n\t\t$result{format} = $stype{format};\n\t}\n\treturn \\%result;\n}\n\n#==========================================\n# createImagePXE\n#------------------------------------------\nsub createImagePXE {\n\t# ...\n\t# Create Image usable within a PXE boot environment. The\n\t# method will create the specified boot image (initrd) and\n\t# the system image. In order to use this image via PXE the\n\t# administration needs to provide the images via TFTP\n\t# ---\n\t#==========================================\n\t# Create PXE boot and system image\n\t#------------------------------------------\n\tmy $this = shift;\n\tmy $para = shift;\n\tmy $name = $this -> createImageRootAndBoot ($para,\"PXE\");\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageVMX\n#------------------------------------------\nsub createImageVMX {\n\t# ...\n\t# Create virtual machine disks. By default a raw disk image will\n\t# be created from which other types are derived via conversion.\n\t# The output format is specified by the format attribute in the\n\t# type section. Supported formats are: vmdk qcow raw ovf\n\t# The process will create the system image and the appropriate vmx\n\t# boot image plus a .raw and an optional format specific image.\n\t# The boot image description must exist in /usr/share/kiwi/image.\n\t# ---\n\t#==========================================\n\t# Create VMX boot and system image\n\t#------------------------------------------\n\tmy $this = shift;\n\tmy $para = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $cmdL = $this->{cmdL};\n\tmy $idest= $cmdL->getImageTargetDir();\n\tmy %xenc = $xml  -> getXenConfig();\n\tmy $name = $this -> createImageRootAndBoot ($para,\"VMX\");\n\tmy $xendomain;\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\tif (defined $xenc{xen_domain}) {\n\t\t$xendomain = $xenc{xen_domain};\n\t} else {\n\t\t$xendomain = \"dom0\";\n\t}\n\t#==========================================\n\t# Create virtual disk image(s)\n\t#------------------------------------------\n\t$cmdL -> setInitrdFile (\n\t\t$idest.\"/\".$name->{bootImage}.\".splash.gz\"\n\t);\n\tif (defined $name->{imageTree}) {\n\t\t$cmdL -> setSystemLocation (\n\t\t\t$name->{imageTree}\n\t\t);\n\t} else {\n\t\t$cmdL -> setSystemLocation (\n\t\t\t$idest.\"/\".$name->{systemImage}\n\t\t);\n\t}\n\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\tif ((! $kic) || (! $kic->createImageDisk())) {\n\t\tundef $kic;\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create VM format/configuration\n\t#------------------------------------------\n\tif ((defined $name->{format}) || ($xendomain eq \"domU\")) {\n\t\t$cmdL -> setSystemLocation (\n\t\t\t$idest.\"/\".$name->{systemImage}.\".raw\"\n\t\t);\n\t\t$cmdL -> setImageFormat ($name->{format});\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) || (! $kic->createImageFormat())) {\n\t\t\tundef $kic;\n\t\t\treturn undef;\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageLiveCD\n#------------------------------------------\nsub createImageLiveCD {\n\t# ...\n\t# Create a live filesystem on CD using the isoboot boot image\n\t# 1) split physical extend into two parts:\n\t#    part1 -> writable\n\t#    part2 -> readonly\n\t# 2) Setup an ext2 based image for the RW part and a squashfs\n\t#    image if it should be compressed. If no compression is used\n\t#    all RO data will be directly on CD/DVD as part of the ISO\n\t#    filesystem\n\t# 3) Prepare and Create the given iso <$boot> boot image\n\t# 4) Setup the CD structure and copy all files\n\t#    including the syslinux isolinux data\n\t# 5) Create the iso image using isolinux shell script\n\t# ---\n\tmy $this = shift;\n\tmy $para = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $arch = $this->{arch};\n\tmy $sxml = $this->{xml};\n\tmy $cmdL = $this->{cmdL};\n\tmy $idest= $cmdL->getImageTargetDir();\n\tmy $imageTree = $this->{imageTree};\n\tmy $baseSystem= $this->{baseSystem};\n\tmy $checkBase = $cmdL->getRootTargetDir().\"/\".$baseSystem;\n\tmy @bootdata;\n\tmy $error;\n\tmy $data;\n\tmy $code;\n\tmy $imageTreeReadOnly;\n\tmy $hybrid = 0;\n\tmy $isxen  = 0;\n\tmy $hybridpersistent = 0;\n\tmy $cmdline;\n\t#==========================================\n\t# Store arch name used by iso\n\t#------------------------------------------\n\tmy $isoarch = qxx (\"uname -m\"); chomp $isoarch;\n\tif ($isoarch =~ /i.86/) {\n\t\t$isoarch = \"i386\";\n\t}\n\t#==========================================\n\t# Get system image name\n\t#------------------------------------------\n\tmy $systemName = $sxml -> getImageName();\n\tmy $systemDisplayName = $sxml -> getImageDisplayName();\n\t#==========================================\n\t# Get system image type information\n\t#------------------------------------------\n\tmy %stype= %{$sxml->getImageTypeAndAttributes()};\n\tmy $pblt = $stype{checkprebuilt};\n\tmy $vga  = $stype{vga};\n\t#==========================================\n\t# Get boot image name and compressed flag\n\t#------------------------------------------\n\tmy @plist = split (/,/,$para);\n\tmy $boot  = $plist[0];\n\tmy $gzip  = $plist[1];\n\tif (! defined $boot) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"No boot image name specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for hybrid ISO\n\t#------------------------------------------\n\tif ((defined $stype{hybrid}) && ($stype{hybrid} eq 'true')) {\n\t\t$hybrid = 1;\n\t}\n\tif ((defined $stype{hybridpersistent}) &&\n\t\t($stype{hybridpersistent} eq 'true')\n\t) {\n\t\t$hybridpersistent = 1;\n\t}\n\t#==========================================\n\t# Check for user-specified cmdline options\n\t#------------------------------------------\n\tif (defined $stype{cmdline}) {\n\t\t$cmdline = \" $stype{cmdline}\";\n\t}\n\t#==========================================\n\t# Get image creation date and name\n\t#------------------------------------------\n\tmy $namecd = $this -> buildImageName (\";\");\n\tmy $namerw = $this -> buildImageName ();\n\tmy $namero = $this -> buildImageName (\"-\",\"-read-only\");\n\tif (! defined $namerw) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Call images.sh script\n\t#------------------------------------------\n\tif (! $this -> setupLogicalExtend (\"quiet\")) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for config-cdroot and move it\n\t#------------------------------------------\n\tmy $cdrootData = \"config-cdroot.tgz\";\n\tif (-f $imageTree.\"/image/\".$cdrootData) {\n\t\tqxx (\"mv $imageTree/image/$cdrootData $this->{imageDest}\");\n\t}\n\t#==========================================\n\t# Check for config-cdroot.sh and move it\n\t#------------------------------------------\n\tmy $cdrootScript = \"config-cdroot.sh\";\n\tif (-x $imageTree.\"/image/\".$cdrootScript) {\n\t\tqxx (\"mv $imageTree/image/$cdrootScript $this->{imageDest}\");\n\t}\n\t#==========================================\n\t# split physical extend into RW / RO part\n\t#------------------------------------------\n\tif (! defined $gzip) {\n\t\t$imageTreeReadOnly = $imageTree;\n\t\t$imageTreeReadOnly =~ s/\\/+$//;\n\t\t$imageTreeReadOnly.= \"-read-only/\";\n\t\t$this->{imageTreeReadOnly} = $imageTreeReadOnly;\n\t\tif (! -d $imageTreeReadOnly) {\n\t\t\t$kiwi -> info (\"Creating read only image part\");\n\t\t\tif (! mkdir $imageTreeReadOnly) {\n\t\t\t\t$error = $!;\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't create ro directory: $error\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\tpush @{$this->{tmpdirs}},$imageTreeReadOnly;\n\t\t\tmy @rodirs = qw (bin boot lib lib64 opt sbin usr);\n\t\t\tforeach my $dir (@rodirs) {\n\t\t\t\tif (! -d \"$imageTree/$dir\") {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$data = qxx (\"mv $imageTree/$dir $imageTreeReadOnly 2>&1\");\n\t\t\t\t$code = $? >> 8;\n\t\t\t\tif ($code != 0) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$kiwi -> error  (\"Couldn't setup ro directory: $data\");\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t}\n\t\t#==========================================\n\t\t# Count disk space for RW extend\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Computing disk space...\");\n\t\tmy ($mbytesrw,$xmlsize) = $this -> getSize ($imageTree);\n\t\t$kiwi -> done ();\n\n\t\t#==========================================\n\t\t# Create RW logical extend\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Image RW part requires $mbytesrw MB of disk space\");\n\t\tif (! $this -> buildLogicalExtend ($namerw,$mbytesrw.\"M\")) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done ();\n\t\t#==========================================\n\t\t# Create EXT2 filesystem on RW extend\n\t\t#------------------------------------------\n\t\tmy $setBlockSize = 0;\n\t\tmy $fsopts       = $cmdL -> getFilesystemOptions();\n\t\tmy $blocksize    = $fsopts->[0];\n\t\tif (! defined $blocksize) {\n\t\t\t$fsopts->[0] = 4096;\n\t\t\t$setBlockSize = 1;\n\t\t\t$cmdL -> setFilesystemOptions (@{$fsopts});\n\t\t}\n\t\tif (! $this -> setupEXT2 ( $namerw )) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\tif ($setBlockSize) {\n\t\t\tundef $fsopts->[0];\n\t\t\t$cmdL -> setFilesystemOptions (@{$fsopts});\n\t\t}\n\t\t#==========================================\n\t\t# mount logical extend for data transfer\n\t\t#------------------------------------------\n\t\tmy $extend = $this -> mountLogicalExtend ($namerw);\n\t\tif (! defined $extend) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# copy physical to logical\n\t\t#------------------------------------------\n\t\tif (! $this -> installLogicalExtend ($extend,$imageTree)) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> cleanMount();\n\t\t$this -> restoreImageDest();\n\t\t$this -> cleanLuks();\n\t}\n\t#==========================================\n\t# Create compressed filesystem on RO extend\n\t#------------------------------------------\n\tif (defined $gzip) {\n\t\tSWITCH: for ($gzip) {\n\t\t\t/^compressed$/ && do {\n\t\t\t\t$kiwi -> info (\"Creating split ext3 + squashfs...\\n\");\n\t\t\t\tif (! $this -> createImageSplit (\"ext3,squashfs\", 1)) {\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\t$namero = $namerw;\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/^unified$/ && do {\n\t\t\t\t$kiwi -> info (\"Creating squashfs read only filesystem...\\n\");\n\t\t\t\tif (! $this -> setupSquashFS ( $namero,$imageTree )) {\n\t\t\t\t\t$this -> restoreSplitExtend ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/^clic$/ && do {\n\t\t\t\t$kiwi -> info (\"Creating clicfs read only filesystem...\\n\");\n\t\t\t\tif (! $this -> createImageClicFS ( $namero )) {\n\t\t\t\t\t$this -> restoreSplitExtend ();\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t# invalid flag setup...\n\t\t\t$kiwi -> error  (\"Invalid iso flags: $gzip\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Check / build md5 sum of RW extend\n\t#------------------------------------------\n\tif (! defined $gzip) {\n\t\t#==========================================\n\t\t# Checking RW file system\n\t\t#------------------------------------------\n\t\tqxx (\"/sbin/e2fsck -f -y $this->{imageDest}/$namerw 2>&1\");\n\n\t\t#==========================================\n\t\t# Create image md5sum\n\t\t#------------------------------------------\n\t\tif (! $this -> buildMD5Sum ($namerw)) {\n\t\t\t$this -> restoreSplitExtend ();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Restoring physical extend\n\t\t#------------------------------------------\n\t\tif (! $this -> restoreSplitExtend ()) {\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# compress RW extend\n\t\t#------------------------------------------\n\t\tif (! $this -> compressImage ($namerw)) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# recreate a copy of the read-only data\n\t#------------------------------------------\t\n\tif ((defined $imageTreeReadOnly) && (! -d $imageTreeReadOnly) &&\n\t\t(! defined $gzip)\n\t) {\n\t\t$kiwi -> info (\"Creating read only reference...\");\n\t\tif (! mkdir $imageTreeReadOnly) {\n\t\t\t$error = $!;\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create ro directory: $error\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy @rodirs = qw (bin boot lib lib64 opt sbin usr);\n\t\tforeach my $dir (@rodirs) {\n\t\t\tif (! -d \"$imageTree/$dir\") {\n\t\t\t\tnext;\n\t\t\t}\n\t\t\t$data = qxx (\"cp -a $imageTree/$dir $imageTreeReadOnly 2>&1\");\n\t\t\t$code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> error  (\"Couldn't setup ro directory: $data\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Prepare and Create ISO boot image\n\t#------------------------------------------\n\t$kiwi -> info (\"--> Creating ISO boot image: $boot...\\n\");\n\t@bootdata = $this -> checkAndSetupPrebuiltBootImage ($sxml);\n\tif (! @bootdata) {\n\t\treturn undef;\n\t}\n\tif ($bootdata[1] == 0) {\n\t\t#==========================================\n\t\t# Setup changeset to be used by boot image\n\t\t#------------------------------------------\n\t\tmy %XMLChangeSet = $this -> updateDescription ($sxml);\n\t\t#==========================================\n\t\t# Create tmp dir for boot image creation\n\t\t#------------------------------------------\n\t\tmy $tmpdir = qxx (\"mktemp -q -d $idest/boot-iso.XXXXXX\");\n\t\tmy $result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tchomp $tmpdir;\n\t\tpush @{$this->{tmpdirs}},$tmpdir;\n\t\t#==========================================\n\t\t# Prepare boot image...\n\t\t#------------------------------------------\n\t\tmy $configDir;\n\t\tif (($stype{boot} !~ /^\\//) && (! -d $stype{boot})) {\n\t\t\t$configDir = $this->{gdata}->{System}.\"/\".$stype{boot};\n\t\t} else {\n\t\t\t$configDir = $stype{boot};\n\t\t}\n\t\tmy $rootTarget = \"$tmpdir/kiwi-isoboot-$$\";\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) || (! $kic -> prepareBootImage (\n\t\t\t$configDir,$rootTarget,$this->{imageTree},\\%XMLChangeSet))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create boot image...\n\t\t#------------------------------------------\n\t\tif ((! $kic) || (! $kic -> createBootImage (\n\t\t\t$rootTarget,$this->{imageDest}))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Clean up tmp directory\n\t\t#------------------------------------------\n\t\tqxx (\"rm -rf $tmpdir\");\n\t}\n\t#==========================================\n\t# setup initrd/kernel names\n\t#------------------------------------------\n\tmy $pinitrd = $idest.\"/\".$bootdata[0].\".gz\";\n\tmy $plinux  = $idest.\"/\".$bootdata[0].\".kernel\";\n\tmy $pxboot  = glob ($idest.\"/\".$bootdata[0].\"*xen.gz\");\n\tif (-f $pxboot) {\n\t\t$isxen = 1;\n\t}\n\t#==========================================\n\t# Check boot and system image kernel\n\t#------------------------------------------\n\tif ($cmdL->getCheckKernel()) {\n\t\tif (! $this -> checkKernel ($pinitrd,$imageTree,$bootdata[0])) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Include splash screen to initrd\n\t#------------------------------------------\n\tmy $kboot  = new KIWIBoot ($kiwi,$pinitrd,$cmdL);\n\tif (! defined $kboot) {\n\t\treturn undef;\n\t}\n\t$pinitrd = $kboot -> setupSplash();\n\t#==========================================\n\t# Prepare for CD ISO image\n\t#------------------------------------------\n\tmy $CD = $idest.\"/CD\";\n\t$kiwi -> info (\"Creating CD filesystem structure\");\n\tqxx (\"mkdir -p $CD/boot\");\n\tpush @{$this->{tmpdirs}},$CD;\n\t$kiwi -> done ();\n\t#==========================================\n\t# Check for optional config-cdroot archive\n\t#------------------------------------------\n\tif (-f $this->{imageDest}.\"/\".$cdrootData) {\n\t\t$kiwi -> info (\"Integrating CD root information...\");\n\t\tmy $data= qxx (\n\t\t\t\"tar -C $CD -xvf $this->{imageDest}/$cdrootData\"\n\t\t);\n\t\tmy $code= $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to integrate CD root data: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> restoreCDRootData();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Check for optional config-cdroot.sh\n\t#------------------------------------------\n\tif (-x $this->{imageDest}.\"/\".$cdrootScript) {\n\t\t$kiwi -> info (\"Calling CD root setup script...\");\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\tmy $cdrootEnv = $imageTree.\"/.profile\";\n\t\tif ($cdrootEnv !~ /^\\//) {\n\t\t\t$cdrootEnv = $pwd.\"/\".$cdrootEnv;\n\t\t}\n\t\tmy $script = $this->{imageDest}.\"/\".$cdrootScript;\n\t\tif ($script !~ /^\\//) {\n\t\t\t$script = $pwd.\"/\".$script;\n\t\t}\n\t\tmy $data = qxx (\n\t\t\t\"cd $CD && bash -c '. $cdrootEnv && . $script' 2>&1\"\n\t\t);\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\tchomp $data;\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to call CD root script: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> restoreCDRootData();\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"config-cdroot.sh: $data\");\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# Restore CD root data and script\n\t#------------------------------------------\n\t$this -> restoreCDRootData();\n\t#==========================================\n\t# Installing system image file(s)\n\t#------------------------------------------\n\t$kiwi -> info (\"Moving CD image data into boot structure\");\n\tif (! defined $gzip) {\n\t\t# /.../\n\t\t# don't symlink these file because in this old live iso\n\t\t# mode we don't allow mkisofs to follow symlinks\n\t\t# ----\n\t\tqxx (\"mv $this->{imageDest}/$namerw.md5 $CD\");\n\t\tqxx (\"mv $this->{imageDest}/$namerw.gz  $CD\");\n\t\tqxx (\"rm $this->{imageDest}/$namerw.*\");\n\t}\n\tif (defined $gzip) {\n\t\t#qxx (\"mv $this->{imageDest}/$namero $CD\");\n\t\t#qxx (\"rm $this->{imageDest}/$namero.*\");\n\t\tqxx (\"ln -s $this->{imageDest}/$namero $CD/$namero\");\n\t} else {\n\t\tqxx (\"mkdir -p $CD/read-only-system\");\n\t\tqxx (\"mv $imageTreeReadOnly/* $CD/read-only-system\");\n\t\trmdir $imageTreeReadOnly;\n\t}\n\t$kiwi -> done ();\n\t#==========================================\n\t# Create MBR id file for boot device check\n\t#------------------------------------------\n\tif ($hybrid) {\n\t\t$kiwi -> info (\"Saving hybrid disk label on ISO: $this->{mbrid}...\");\n\t\tmy $destination = \"$CD/boot/grub\";\n\t\tqxx (\"mkdir -p $destination\");\n\t\tif (! open (FD,\">$destination/mbrid\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create mbrid file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$this->{mbrid}\";\n\t\tclose FD;\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# copy boot kernel and initrd\n\t#------------------------------------------\n\t$kiwi -> info (\"Copying boot image and kernel [$isoarch]\");\n\tmy $destination = \"$CD/boot/$isoarch/loader\";\n\tqxx (\"mkdir -p $destination\");\n\t$data = qxx (\"cp $pinitrd $destination/initrd 2>&1\");\n\t$code = $? >> 8;\n\tif ($code == 0) {\n\t\t$data = qxx (\"cp $plinux $destination/linux 2>&1\");\n\t\t$code = $? >> 8;\n\t}\n\tif (($code == 0) && ($isxen)) {\n\t\t$data = qxx (\"cp $pxboot $destination/xen.gz 2>&1\");\n\t\t$code = $? >> 8;\n\t}\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Copy of isolinux boot files failed: $data\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done ();\n\t#==========================================\n\t# check for graphics boot files\n\t#------------------------------------------\n\t$kiwi -> info (\"Extracting initrd for boot graphics data lookup\");\n\tmy $tmpdir = qxx (\"mktemp -q -d $idest/boot-iso.XXXXXX\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tchomp $tmpdir;\n\tpush @{$this->{tmpdirs}},$tmpdir;\n\tmy $zipper = $this->{gdata}->{Gzip};\n\t$data = qxx (\"$zipper -cd $pinitrd | (cd $tmpdir && cpio -di 2>&1)\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error (\"Failed to extract initrd: $data\");\n\t\t$kiwi -> failed();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# copy base graphics boot CD files\n\t#------------------------------------------\n\t$kiwi -> info (\"Setting up isolinux boot CD [$isoarch]\");\n\tmy $gfx = $tmpdir.\"/image/loader\";\n\t$data = qxx (\"cp -a $gfx/* $destination\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Copy failed: $data\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done ();\n\t#==========================================\n\t# setup isolinux boot label name\n\t#------------------------------------------\n\tmy $label = $this->makeLabel ($systemDisplayName);\n\tmy $lsafe = $this->makeLabel (\"Failsafe -- \".$label);\n\t#==========================================\n\t# setup isolinux.cfg file\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating isolinux configuration...\");\n\tmy $syslinux_new_format = 0;\n\tmy $bootTimeout = $stype{boottimeout} ? int $stype{boottimeout} : 200;\n\tif (-f \"$gfx/gfxboot.com\" || -f \"$gfx/gfxboot.c32\") {\n\t\t$syslinux_new_format = 1;\n\t}\n\tif (! open (FD, \">$destination/isolinux.cfg\")) {\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error  (\"Failed to create $destination/isolinux.cfg: $!\");\n\t\t$kiwi -> failed ();\n\t\tif (! -d $checkBase) {\n\t\t\tqxx (\"rm -rf $cmdL->getRootTargetDir()\");\n\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t}\n\t\treturn undef;\n\t}\n\tbinmode(FD, \":utf8\");\n\tprint FD \"default $label\".\"\\n\";\n\tprint FD \"implicit 1\".\"\\n\";\n\tprint FD \"display isolinux.msg\".\"\\n\";\n\tif (-f \"$gfx/bootlogo\" ) {\n\t\tif ($syslinux_new_format) {\n\t\t\tprint FD \"ui gfxboot bootlogo isolinux.msg\".\"\\n\";\n\t\t} else {\n\t\t\tprint FD \"gfxboot bootlogo\".\"\\n\";\n\t\t}\n\t}\n\tprint FD \"prompt   1\".\"\\n\";\n\tprint FD \"timeout  $bootTimeout\".\"\\n\";\n\tif (! $isxen) {\n\t\tprint FD \"label $label\".\"\\n\";\n\t\tprint FD \"  kernel linux\".\"\\n\";\n\t\tprint FD \"  append initrd=initrd ramdisk_size=512000 \";\n\t\tprint FD \"ramdisk_blocksize=4096 splash=silent${cmdline} showopts \";\n\t\t#print FD \"console=ttyS0,9600n8 console=tty0${cmdline} showopts \";\n\t\tif ($vga) {\n\t\t\tprint FD \"vga=$vga \";\n\t\t}\n\t\tprint FD \"\\n\";\n\t\tprint FD \"label $lsafe\".\"\\n\";\n\t\tprint FD \"  kernel linux\".\"\\n\";\n\t\tprint FD \"  append initrd=initrd ramdisk_size=512000 \";\n\t\tprint FD \"ramdisk_blocksize=4096 splash=silent${cmdline} showopts \";\n\t\tprint FD \"ide=nodma apm=off acpi=off noresume selinux=0 nosmp \";\n\t\tprint FD \"noapic maxcpus=0 edd=off\".\"\\n\";\n\t} else {\n\t\tprint FD \"label $label\".\"\\n\";\n\t\tprint FD \"  kernel mboot.c32\".\"\\n\";\n\t\tprint FD \"  append xen.gz --- linux ramdisk_size=512000 \";\n\t\tprint FD \"ramdisk_blocksize=4096 splash=silent${cmdline} \";\n\t\t#print FD \"console=ttyS0,9600n8 console=tty0 \";\n\t\tif ($vga) {\n\t\t\tprint FD \"vga=$vga \";\n\t\t}\n\t\tprint FD \"--- initrd showopts\".\"\\n\";\n\t\tprint FD \"\\n\";\n\t\tprint FD \"label $lsafe\".\"\\n\";\n\t\tprint FD \"  kernel mboot.c32\".\"\\n\";\n\t\tprint FD \"  append xen.gz --- linux ramdisk_size=512000 \";\n\t\tprint FD \"ramdisk_blocksize=4096 splash=silent${cmdline} \";\n\t\tprint FD \"ide=nodma apm=off acpi=off noresume selinux=0 nosmp \";\n\t\tprint FD \"noapic maxcpus=0 edd=off \";\n\t\tprint FD \"--- initrd showopts\".\"\\n\";\n\t}\n\t#==========================================\n\t# setup isolinux checkmedia boot entry\n\t#------------------------------------------\n\tif ($cmdL->getISOCheck()) {\n\t\tprint FD \"\\n\";\n\t\tif (! $isxen) {\n\t\t\tprint FD \"label mediacheck\".\"\\n\";\n\t\t\tprint FD \"  kernel linux\".\"\\n\";\n\t\t\tprint FD \"  append initrd=initrd splash=silent mediacheck=1\";\n\t\t\tprint FD \"$cmdline \";\n\t\t\tprint FD \"showopts\".\"\\n\";\n\t\t} else {\n\t\t\tprint FD \"label mediacheck\".\"\\n\";\n\t\t\tprint FD \"  kernel mboot.c32\".\"\\n\";\n\t\t\tprint FD \"  append xen.gz --- linux splash=silent mediacheck=1\";\n\t\t\tprint FD \"$cmdline \";\n\t\t\tprint FD \"--- initrd showopts\".\"\\n\";\n\t\t}\n\t}\n\t#==========================================\n\t# setup default harddisk/memtest entries\n\t#------------------------------------------\n\tprint FD \"\\n\";\n\tprint FD \"label harddisk\\n\";\n\tprint FD \"  localboot 0x80\".\"\\n\";\n\tprint FD \"\\n\";\n\tprint FD \"label memtest\".\"\\n\";\n\tprint FD \"  kernel memtest\".\"\\n\";\n\tprint FD \"\\n\";\n\tclose FD;\n\t#==========================================\n\t# setup isolinux.msg file\n\t#------------------------------------------\n\tif (! open (FD,\">$destination/isolinux.msg\")) {\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error  (\"Failed to create isolinux.msg: $!\");\n\t\t$kiwi -> failed ();\n\t\tif (! -d $checkBase) {\n\t\t\tqxx (\"rm -rf $cmdL->getRootTargetDir()\");\n\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t}\n\t\treturn undef;\n\t}\n\tprint FD \"\\n\".\"Welcome !\".\"\\n\\n\";\n\tprint FD \"To start the system enter '\".$label.\"' and press <return>\".\"\\n\";\n\tprint FD \"\\n\\n\";\n\tprint FD \"Available boot options:\\n\";\n\tprintf (FD \"%-20s - %s\\n\",$label,\"Live System\");\n\tprintf (FD \"%-20s - %s\\n\",$lsafe,\"Live System failsafe mode\");\n\tprintf (FD \"%-20s - %s\\n\",\"harddisk\",\"Local boot from hard disk\");\n\tprintf (FD \"%-20s - %s\\n\",\"mediacheck\",\"Media check\");\n\tprintf (FD \"%-20s - %s\\n\",\"memtest\",\"Memory Test\");\n\tprint FD \"\\n\";\n\tprint FD \"Have a lot of fun...\".\"\\n\";\n\tclose FD;\n\t$kiwi -> done();\n\t#==========================================\n\t# Cleanup tmpdir\n\t#------------------------------------------\n\tqxx (\"rm -rf $tmpdir\");\n\t#==========================================\n\t# Create boot configuration\n\t#------------------------------------------\n\tif (! open (FD,\">$CD/config.isoclient\")) {\n\t\t$kiwi -> error  (\"Couldn't create image boot configuration\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif ((! defined $gzip) || ($gzip =~ /^(unified|clic)/)) {\n\t\tprint FD \"IMAGE='/dev/ram1;$namecd'\\n\";\n\t} else {\n\t\tprint FD \"IMAGE='/dev/loop1;$namecd'\\n\";\n\t}\n\tif (defined $gzip) {\n\t\tif ($gzip =~ /^unified/) {\n\t\t\tprint FD \"UNIONFS_CONFIG='/dev/ram1,/dev/loop1,aufs'\\n\";\n\t\t} elsif ($gzip =~ /^clic/) {\n\t\t\tprint FD \"UNIONFS_CONFIG='/dev/ram1,/dev/loop1,clicfs'\\n\";\n\t\t} else {\n\t\t\tprint FD \"COMBINED_IMAGE=yes\\n\";\n\t\t}\n\t}\n\tclose FD;\n\t#==========================================\n\t# create ISO image\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating ISO image...\\n\");\n\tmy $isoerror = 1;\n\tmy $name = $this->{imageDest}.\"/\".$namerw.\".iso\";\n\tmy $attr = \"-R -J -f -pad -joliet-long\";\n\tif (! defined $gzip) {\n\t\t$attr = \"-R -J -pad -joliet-long\";\n\t}\n\t$attr .= ' -p \"'.$this->{gdata}->{Preparer}.'\"';\n\t$attr .= ' -publisher \"'.$this->{gdata}->{Publisher}.'\"';\n\tif (! defined $gzip) {\n\t\t$attr .= \" -iso-level 4\"; \n\t}\n\tif ($stype{volid}) {\n\t\t$attr .= \" -V \\\"$stype{volid}\\\"\";\n\t}\n\tmy $isolinux = new KIWIIsoLinux (\n\t\t$kiwi,$CD,$name,$attr,\"checkmedia\",$this->{cmdL}\n\t);\n\tif (defined $isolinux) {\n\t\t$isoerror = 0;\n\t\tif (! $isolinux -> callBootMethods()) {\n\t\t\t$isoerror = 1;\n\t\t}\n\t\tif (! $isolinux -> createISO()) {\n\t\t\t$isoerror = 1;\n\t\t}\n\t}\n\tif ($isoerror) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# relocate boot catalog\n\t#------------------------------------------\n\tif (! $isolinux -> relocateCatalog()) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Turn ISO into hybrid if requested\n\t#------------------------------------------\n\tif ($hybrid) {\n\t\t$kiwi -> info (\"Setting up hybrid ISO...\");\n\t\tif (! $isolinux -> createHybrid ($this->{mbrid})) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to create hybrid ISO image\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\t#==========================================\n\t# tag ISO image with tagmedia\n\t#------------------------------------------\n\tif (-x \"/usr/bin/tagmedia\") {\n\t\t$kiwi -> info (\"Adding checkmedia tag...\");\n\t\tif (! $isolinux -> checkImage()) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to tag ISO image\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\treturn $this;\n}\n\n#==========================================\n# createImageSplit\n#------------------------------------------\nsub createImageSplit {\n\t# ...\n\t# Create all split images and the specified boot image which\n\t# should be used in combination to this split image. The process\n\t# requires subsequent kiwi calls to create the vmx/oemboot\n\t# required virtual disk images or the created images needs\n\t# to be copied into a PXE boot structure for use with\n\t# a netboot setup.\n\t# ---\n\tmy $this = shift;\n\tmy $type = shift;\n\tmy $nopersistent = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $cmdL = $this->{cmdL};\n\tmy $arch = $this->{arch};\n\tmy $imageTree = $this->{imageTree};\n\tmy $baseSystem= $this->{baseSystem};\n\tmy $checkBase = $cmdL->getRootTargetDir().\"/\".$baseSystem;\n\tmy $sxml = $this->{xml};\n\tmy $idest= $cmdL->getImageTargetDir();\n\tmy %xenc = $sxml->getXenConfig();\n\tmy $FSTypeRW;\n\tmy $FSTypeRO;\n\tmy $error;\n\tmy $ok;\n\tmy @bootdata;\n\tmy $imageTreeRW;\n\tmy $imageTreeTmp;\n\tmy $mbytesro;\n\tmy $mbytesrw;\n\tmy $xmlsize;\n\tmy $boot;\n\tmy $plinux;\n\tmy $pinitrd;\n\tmy $data;\n\tmy $code;\n\tmy $name;\n\tmy $treebase;\n\tmy $xendomain;\n\t#==========================================\n\t# check for xen domain setup\n\t#------------------------------------------\n\tif (defined $xenc{xen_domain}) {\n\t\t$xendomain = $xenc{xen_domain};\n\t} else {\n\t\t$xendomain = \"dom0\";\n\t}\n\t#==========================================\n\t# turn image path into absolute path\n\t#------------------------------------------\n\tif ($imageTree !~ /^\\//) {\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\t$imageTree = $pwd.\"/\".$imageTree;\n\t}\n\t#==========================================\n\t# Get filesystem info for split image\n\t#------------------------------------------\n\tif ($type =~ /(.*),(.*):(.*)/) {\n\t\t$FSTypeRW = $1;\n\t\t$FSTypeRO = $2;\n\t\t$boot = $3;\n\t} elsif ($type =~ /(.*),(.*)/) {\n\t\t$FSTypeRW = $1;\n\t\t$FSTypeRO = $2;\n\t} else {\n\t\t$kiwi -> error  (\"Invalid filesystem setup for split type\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Get system image type information\n\t#------------------------------------------\n\tmy %type = %{$sxml->getImageTypeAndAttributes()};\n\tmy $pblt = $type{checkprebuilt};\n\t#==========================================\n\t# Get image creation date and name\n\t#------------------------------------------\n\tmy $namerw = $this -> buildImageName (\"-\",\"-read-write\");\n\tmy $namero = $this -> buildImageName ();\n\tif (! defined $namerw) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Call images.sh script\n\t#------------------------------------------\n\tif (! $this -> setupLogicalExtend (\"quiet\", $namero)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create clone of prepared tree\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating root tree clone for split operations\");\n\t$treebase = basename $imageTree;\n\tif (-d $this->{imageDest}.\"/\".$treebase) {\n\t\tqxx (\"rm -rf $this->{imageDest}/$treebase\");\n\t}\n\t$data = qxx (\"cp -a -x $imageTree $this->{imageDest}\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Can't create copy of image tree: $data\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $imageTree\");\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# split physical extend into RW/RO/tmp part\n\t#------------------------------------------\n\t$imageTree = $this->{imageDest}.\"/\".$treebase;\n\tif ($imageTree !~ /^\\//) {\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\t$imageTree = $pwd.\"/\".$imageTree;\n\t}\n\t$imageTreeTmp = $imageTree;\n\t$imageTreeTmp =~ s/\\/+$//;\n\t$imageTreeTmp.= \"-tmp/\";\n\t$this->{imageTreeTmp} = $imageTreeTmp;\n\t#==========================================\n\t# run split tree creation\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating temporary image part...\\n\");\n\tif (! mkdir $imageTreeTmp) {\n\t\t$error = $!;\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create split tmp directory: $error\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $imageTree\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# walk through except files if any\n\t#------------------------------------------\n\tmy %exceptHash;\n\tforeach my $except ($sxml -> getSplitTmpExceptions()) {\n\t\tmy $globsource = \"${imageTree}${except}\";\n\t\tmy @files = qxx (\"find $globsource -xtype f 2>/dev/null\");\n\t\tmy $code  = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t# excepted file(s) doesn't exist anyway\n\t\t\tnext;\n\t\t}\n\t\tchomp @files;\n\t\tforeach my $file (@files) {\n\t\t\t$exceptHash{$file} = $file;\n\t\t}\n\t}\n\t#==========================================\n\t# create linked list for files, create dirs\n\t#------------------------------------------\n\tmy $createTmpTree = sub {\n\t\tmy $file  = $_;\n\t\tmy $dir   = $File::Find::dir;\n\t\tmy $path  = \"$dir/$file\";\n\t\tmy $target= $path;\n\t\t$target =~ s#$imageTree#$imageTreeTmp#;\n\t\tmy $rerooted = $path;\n\t\t$rerooted =~ s#$imageTree#/read-only/#;\n\t\tmy $st = lstat($path);\n\t\tif (S_ISDIR($st->mode)) {\n\t\t\tmkdir $target;\n\t\t\tchmod S_IMODE($st->mode), $target;\n\t\t\tchown $st->uid, $st->gid, $target;\n\t\t} elsif (\n\t\t\tS_ISCHR($st->mode)  ||\n\t\t\tS_ISBLK($st->mode)  ||\n\t\t\tS_ISLNK($st->mode)\n\t\t) {\n\t\t\tqxx (\"cp -a $path $target\");\n\t\t} else {\n\t\t\t$rerooted =~ s#/+#/#g;\n\t\t\tsymlink ($rerooted, $target);\n\t\t}\n\t};\n\tfind(\\&$createTmpTree, $imageTree);\n\tmy @tempFiles    = $sxml -> getSplitTempFiles ();\n\tmy @persistFiles = $sxml -> getSplitPersistentFiles ();\n\tif ($nopersistent) {\n\t\tpush (@tempFiles, @persistFiles);\n\t\tundef @persistFiles;\n\t}\n\t#==========================================\n\t# search temporary files, respect excepts\n\t#------------------------------------------\n\tmy %tempFiles_new;\n\tif (@tempFiles) {\n\t\tforeach my $temp (@tempFiles) {\n\t\t\tmy $globsource = \"${imageTree}${temp}\";\n\t\t\tmy @files = qxx (\"find $globsource -xtype f 2>/dev/null\");\n\t\t\tmy $code  = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> warning (\"file $globsource doesn't exist\");\n\t\t\t\t$kiwi -> skipped ();\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tchomp @files;\n\t\t\tforeach (@files) {\n\t\t\t\t$tempFiles_new{$_} = $_;\n\t\t\t}\n\t\t}\n\t}\n\t@tempFiles = sort keys %tempFiles_new;\n\tif (@tempFiles) {\n\t\tforeach my $file (@tempFiles) {\n\t\t\tif (defined $exceptHash{$file}) {\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tmy $dest = $file;\n\t\t\t$dest =~ s#$imageTree#$imageTreeTmp#;\n\t\t\tqxx (\"rm -rf $dest\");\n\t\t\tqxx (\"mv $file $dest\");\n\t\t}\n\t}\n\t#==========================================\n\t# find persistent files for the read-write\n\t#------------------------------------------\n\t$imageTreeRW = $imageTree;\n\t$imageTreeRW =~ s/\\/+$//;\n\t$imageTreeRW.= \"-read-write\";\n\tif (@persistFiles) {\n\t\t$kiwi -> info (\"Creating read-write image part...\\n\");\n\t\t#==========================================\n\t\t# Create read-write directory\n\t\t#------------------------------------------\n\t\t$this->{imageTreeRW} = $imageTreeRW;\n\t\tif (! mkdir $imageTreeRW) {\n\t\t\t$error = $!;\n\t\t\t$kiwi -> error  (\n\t\t\t\t\"Couldn't create split read-write directory: $error\"\n\t\t\t);\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $imageTree $imageTreeTmp\");\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# walk through except files if any\n\t\t#------------------------------------------\n\t\tmy %exceptHash;\n\t\tforeach my $except ($sxml -> getSplitPersistentExceptions()) {\n\t\t\tmy $globsource = \"${imageTree}${except}\";\n\t\t\tmy @files = qxx (\"find $globsource -xtype f 2>/dev/null\");\n\t\t\tmy $code  = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t# excepted file(s) doesn't exist anyway\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tchomp @files;\n\t\t\tforeach my $file (@files) {\n\t\t\t\t$exceptHash{$file} = $file;\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# search persistent files, respect excepts\n\t\t#------------------------------------------\n\t\tmy %expandedPersistFiles;\n\t\tforeach my $persist (@persistFiles) {\n\t\t\tmy $globsource = \"${imageTree}${persist}\";\n\t\t\tmy @files = qxx (\"find $globsource 2>/dev/null\");\n\t\t\tmy $code  = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> warning (\"file $globsource doesn't exist\");\n\t\t\t\t$kiwi -> skipped ();\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tchomp @files;\n\t\t\tforeach my $file (@files) {\n\t\t\t\tif (defined $exceptHash{$file}) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$expandedPersistFiles{$file} = $file;\n\t\t\t}\n\t\t}\n\t\t@persistFiles = keys %expandedPersistFiles;\n\t\t#==========================================\n\t\t# relink to read-write, and move files\n\t\t#------------------------------------------\n\t\tforeach my $file (@persistFiles) {\n\t\t\tmy $dest = $file;\n\t\t\tmy $link = $file;\n\t\t\tmy $rlnk = $file;\n\t\t\t$dest =~ s#$imageTree#$imageTreeRW#;\n\t\t\t$link =~ s#$imageTree#$imageTreeTmp#;\n\t\t\t$rlnk =~ s#$imageTree#/read-write#;\n\t\t\tif (-d $file) {\n\t\t\t\t#==========================================\n\t\t\t\t# recreate directory\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $st = stat($file);\n\t\t\t\tqxx (\"mkdir -p $dest\");\n\t\t\t\tchmod S_IMODE($st->mode), $dest;\n\t\t\t\tchown $st->uid, $st->gid, $dest;\n\t\t\t} else {\n\t\t\t\t#==========================================\n\t\t\t\t# move file to read-write area\n\t\t\t\t#------------------------------------------\n\t\t\t\tmy $st = stat(dirname $file);\n\t\t\t\tmy $destdir = dirname $dest;\n\t\t\t\tqxx (\"rm -rf $dest\");\n\t\t\t\tqxx (\"mkdir -p $destdir\");\n\t\t\t\tchmod S_IMODE($st->mode), $destdir;\n\t\t\t\tchown $st->uid, $st->gid, $destdir;\n\t\t\t\tqxx (\"mv $file $dest\");\n\t\t\t\t#==========================================\n\t\t\t\t# relink file to read-write area\n\t\t\t\t#------------------------------------------\n\t\t\t\tqxx (\"rm -rf $link\");\n\t\t\t\tqxx (\"ln -s $rlnk $link\");\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# relink if entire directory was set\n\t\t#------------------------------------------\n\t\tforeach my $persist ($sxml -> getSplitPersistentFiles()) {\n\t\t\tmy $globsource = \"${imageTree}${persist}\";\n\t\t\tif (-d $globsource) {\n\t\t\t\tmy $link = $globsource;\n\t\t\t\tmy $rlnk = $globsource;\n\t\t\t\t$link =~ s#$imageTree#$imageTreeTmp#;\n\t\t\t\t$rlnk =~ s#$imageTree#/read-write#;\n\t\t\t\t#==========================================\n\t\t\t\t# relink directory to read-write area\n\t\t\t\t#------------------------------------------\n\t\t\t\tqxx (\"rm -rf $link\");\n\t\t\t\tqxx (\"ln -s $rlnk $link\");\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# Embed tmp extend into ro extend\n\t#------------------------------------------\n\tqxx (\"cd $imageTreeTmp && tar cvf $imageTree/rootfs.tar * 2>&1\");\n\tqxx (\"rm -rf $imageTreeTmp\");\n\n\t#==========================================\n\t# Count disk space for extends\n\t#------------------------------------------\n\t$kiwi -> info (\"Computing disk space...\");\n\t($mbytesro,$xmlsize) = $this -> getSize ($imageTree);\n\tif (defined $this->{imageTreeRW}) {\n\t\t($mbytesrw,$xmlsize) = $this -> getSize ($imageTreeRW);\n\t}\n\t$kiwi -> done ();\n\tif (defined $this->{imageTreeRW}) {\n\t\t#==========================================\n\t\t# Create RW logical extend\n\t\t#------------------------------------------\n\t\tif (defined $this->{imageTreeRW}) {\n\t\t\t$kiwi -> info (\"Image RW part requires $mbytesrw MB of disk space\");\n\t\t\tif (! $this -> buildLogicalExtend ($namerw,$mbytesrw.\"M\")) {\n\t\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t}\n\t\t#==========================================\n\t\t# Create filesystem on RW extend\n\t\t#------------------------------------------\n\t\tSWITCH: for ($FSTypeRW) {\n\t\t\t/ext2/       && do {\n\t\t\t\t$ok = $this -> setupEXT2 ( $namerw );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/ext3/       && do {\n\t\t\t\t$ok = $this -> setupEXT2 ( $namerw,\"journaled-ext3\" );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/ext4/       && do {\n\t\t\t\t$ok = $this -> setupEXT2 ( $namerw,\"journaled-ext4\" );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/reiserfs/   && do {\n\t\t\t\t$ok = $this -> setupReiser ( $namerw );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/btrfs/      && do {\n\t\t\t\t$ok = $this -> setupBTRFS ( $namerw );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/xfs/        && do {\n\t\t\t\t$ok = $this -> setupXFS ( $namerw );\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t$kiwi -> error  (\"Unsupported type: $FSTypeRW\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! $ok) {\n\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Create RO logical extend\n\t#------------------------------------------\n\t$kiwi -> info (\"Image RO part requires $mbytesro MB of disk space\");\n\tif (! $this -> buildLogicalExtend ($namero,$mbytesro.\"M\")) {\n\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\tqxx (\"rm -rf $imageTree\");\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# Create filesystem on RO extend\n\t#------------------------------------------\n\tSWITCH: for ($FSTypeRO) {\n\t\t/ext2/       && do {\n\t\t\t$ok = $this -> setupEXT2 ( $namero );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/ext3/       && do {\n\t\t\t$ok = $this -> setupEXT2 ( $namero,\"journaled-ext3\" );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/ext4/       && do {\n\t\t\t$ok = $this -> setupEXT2 ( $namero,\"journaled-ext4\" );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/reiserfs/   && do {\n\t\t\t$ok = $this -> setupReiser ( $namero );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/btrfs/      && do {\n\t\t\t$ok = $this -> setupBTRFS ( $namero );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/squashfs/   && do {\n\t\t\t$ok = $this -> setupSquashFS ( $namero,$imageTree );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/xfs/      && do {\n\t\t\t$ok = $this -> setupXFS ( $namero );\n\t\t\tlast SWITCH;\n\t\t};\n\t\t$kiwi -> error  (\"Unsupported type: $FSTypeRO\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\tqxx (\"rm -rf $imageTree\");\n\t\t$this -> cleanLuks();\n\t\treturn undef;\n\t}\n\tif (! $ok) {\n\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\tqxx (\"rm -rf $imageTree\");\n\t\t$this -> cleanLuks();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Install logical extends\n\t#------------------------------------------\n\tforeach my $name ($namerw,$namero) {\n\t\t#==========================================\n\t\t# select physical extend\n\t\t#------------------------------------------\n\t\tmy $source;\n\t\tmy $type;\n\t\tif ($name eq $namerw) {\n\t\t\t$source = $imageTreeRW;\n\t\t\t$type = $FSTypeRW;\n\t\t} else {\n\t\t\t$source = $imageTree;\n\t\t\t$type = $FSTypeRO;\n\t\t}\n\t\tif (! -d $source) {\n\t\t\tnext;\n\t\t}\n\t\tmy %fsattr = $main::global -> checkFileSystem ($type);\n\t\tif (! $fsattr{readonly}) {\n\t\t\t#==========================================\n\t\t\t# mount logical extend for data transfer\n\t\t\t#------------------------------------------\n\t\t\tmy $extend = $this -> mountLogicalExtend ($name);\n\t\t\tif (! defined $extend) {\n\t\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t\t$this -> cleanLuks();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t#==========================================\n\t\t\t# copy physical to logical\n\t\t\t#------------------------------------------\n\t\t\tif (! $this -> installLogicalExtend ($extend,$source)) {\n\t\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t\t$this -> cleanLuks();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$this -> cleanMount();\n\t\t}\n\t\t#==========================================\n\t\t# Checking file system\n\t\t#------------------------------------------\n\t\t$kiwi -> info (\"Checking file system: $type...\");\n\t\tSWITCH: for ($type) {\n\t\t\t/ext2/       && do {\n\t\t\t\tqxx (\"/sbin/e2fsck -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/ext3/       && do {\n\t\t\t\tqxx (\"/sbin/fsck.ext3 -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\t\tqxx (\"/sbin/tune2fs -j $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/ext4/       && do {\n\t\t\t\tqxx (\"/sbin/fsck.ext4 -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\t\tqxx (\"/sbin/tune2fs -j $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/reiserfs/   && do {\n\t\t\t\tqxx (\"/sbin/reiserfsck -y $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/btrfs/      && do {\n\t\t\t\tqxx (\"/sbin/btrfsck $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/squashfs/   && do {\n\t\t\t\t$kiwi -> done ();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t/xfs/        && do {\n\t\t\t\tqxx (\"/sbin/mkfs.xfs $this->{imageDest}/$name 2>&1\");\n\t\t\t\t$kiwi -> done();\n\t\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t$kiwi -> error  (\"Unsupported type: $type\");\n\t\t\t$kiwi -> failed ();\n\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create image md5sum\n\t\t#------------------------------------------\n\t\t$this -> restoreImageDest();\n\t\tif (! $this -> buildMD5Sum ($name)) {\n\t\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\t\tqxx (\"rm -rf $imageTree\");\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> remapImageDest();\n\t}\n\t$this -> restoreImageDest();\n\t$this -> cleanLuks();\n\t#==========================================\n\t# Create network boot configuration\n\t#------------------------------------------\n\tif (! $this -> writeImageConfig ($namero)) {\n\t\tqxx (\"rm -rf $imageTreeRW\");\n\t\tqxx (\"rm -rf $imageTree\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Cleanup temporary data\n\t#------------------------------------------\n\tqxx (\"rm -rf $imageTreeRW\");\n\tqxx (\"rm -rf $imageTree\");\n\t#==========================================\n\t# build boot image only if specified\n\t#------------------------------------------\n\tif (! defined $boot) {\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# Prepare and Create boot image\n\t#------------------------------------------\n\t$imageTree = $this->{imageTree};\n\t$kiwi -> info (\"--> Creating boot image: $boot...\\n\");\n\t@bootdata = $this -> checkAndSetupPrebuiltBootImage ($sxml);\n\tif (! @bootdata) {\n\t\treturn undef;\n\t}\n\tif ($bootdata[1] == 0) {\n\t\t#==========================================\n\t\t# Setup changeset to be used by boot image\n\t\t#------------------------------------------\n\t\tmy %XMLChangeSet = $this -> updateDescription ($sxml);\n\t\t#==========================================\n\t\t# Create tmp dir for boot image creation\n\t\t#------------------------------------------\n\t\tmy $tmpdir = qxx (\"mktemp -q -d $idest/boot-split.XXXXXX\");\n\t\tmy $result = $? >> 8;\n\t\tif ($result != 0) {\n\t\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tchomp $tmpdir;\n\t\tpush @{$this->{tmpdirs}},$tmpdir;\n\t\t#==========================================\n\t\t# Prepare boot image...\n\t\t#------------------------------------------\n\t\tmy $configDir;\n\t\tif (($type{boot} !~ /^\\//) && (! -d $type{boot})) {\n\t\t\t$configDir = $this->{gdata}->{System}.\"/\".$type{boot};\n\t\t} else {\n\t\t\t$configDir = $type{boot};\n\t\t}\n\t\tmy $rootTarget = \"$tmpdir/kiwi-splitboot-$$\";\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) || (! $kic -> prepareBootImage (\n\t\t\t$configDir,$rootTarget,$this->{imageTree},\\%XMLChangeSet))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create boot image...\n\t\t#------------------------------------------\n\t\tif ((! $kic) || (! $kic -> createBootImage (\n\t\t\t$rootTarget,$this->{imageDest}))\n\t\t) {\n\t\t\tundef $kic;\n\t\t\tif (! -d $checkBase) {\n\t\t\t\tqxx (\"rm -rf $tmpdir\");\n\t\t\t}\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Clean up tmp directory\n\t\t#------------------------------------------\n\t\tqxx (\"rm -rf $tmpdir\");\n\t}\n\t#==========================================\n\t# setup initrd name\n\t#------------------------------------------\n\tmy $initrd = $idest.\"/\".$bootdata[0].\".gz\";\n\tif (! -f $initrd) {\n\t\t$initrd = $idest.\"/\".$bootdata[0];\n\t}\n\t#==========================================\n\t# Check boot and system image kernel\n\t#------------------------------------------\n\tif ($cmdL->getCheckKernel()) {\n\t\tif (! $this -> checkKernel ($initrd,$imageTree,$bootdata[0])) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Include splash screen to initrd\n\t#------------------------------------------\n\tmy $kboot  = new KIWIBoot ($kiwi,$initrd,$cmdL);\n\tif (! defined $kboot) {\n\t\treturn undef;\n\t}\n\t$kboot -> setupSplash();\n\t#==========================================\n\t# Store meta data for subsequent calls\n\t#------------------------------------------\n\t$name->{systemImage} = $sxml -> buildImageName();\n\t$name->{bootImage}   = $bootdata[0];\n\t$name->{format}      = $type{format};\n\tif ($boot =~ /vmxboot|oemboot/) {\n\t\t#==========================================\n\t\t# Create virtual disk images if requested\n\t\t#------------------------------------------\n\t\t$cmdL -> setInitrdFile (\n\t\t\t$idest.\"/\".$name->{bootImage}.\".splash.gz\"\n\t\t);\n\t\t$cmdL -> setSystemLocation (\n\t\t\t$idest.\"/\".$name->{systemImage}\n\t\t);\n\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\tif ((! $kic) || (! $kic->createImageDisk())) {\n\t\t\tundef $kic;\n\t\t\treturn undef;\n\t\t}\n\t\t#==========================================\n\t\t# Create VM format/configuration\n\t\t#------------------------------------------\n\t\tif ((defined $name->{format}) || ($xendomain eq \"domU\")) {\n\t\t\t$cmdL -> setSystemLocation (\n\t\t\t\t$idest.\"/\".$name->{systemImage}.\".raw\"\n\t\t\t);\n\t\t\t$cmdL -> setImageFormat ($name->{format});\n\t\t\tmy $kic = new KIWIImageCreator ($kiwi, $cmdL);\n\t\t\tif ((! $kic) || (! $kic->createImageFormat())) {\n\t\t\t\tundef $kic;\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# getBlocks\n#------------------------------------------\nsub getBlocks {\n\t# ...\n\t# calculate the block size and number of blocks used\n\t# to create a <size> bytes long image. Return list\n\t# (bs,count,seek)\n\t# ---\n\tmy $size = $_[0];\n\tmy $bigimage   = 1048576; # 1M\n\tmy $smallimage = 8192;    # 8K\n\tmy $number;\n\tmy $suffix;\n\tif ($size =~ /(\\d+)(.*)/) {\n\t\t$number = $1;\n\t\t$suffix = $2;\n\t\tif ($suffix eq \"\") {\n\t\t\treturn (($size,1));\n\t\t} else {\n\t\t\tSWITCH: for ($suffix) { \n\t\t\t/K/i   && do {\n\t\t\t\t$number *= 1024;\n\t\t\tlast SWITCH;\n\t\t\t}; \n\t\t\t/M/i   && do {\n\t\t\t\t$number *= 1024 * 1024;\n\t\t\tlast SWITCH;\n\t\t\t}; \n\t\t\t/G/i   && do {\n\t\t\t\t$number *= 1024 * 1024 * 1024;\n\t\t\tlast SWITCH;\n\t\t\t};\n\t\t\t# default...\n\t\t\treturn (($size,1));\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn (($size,1));\n\t}\n\tmy $count;\n\tif ($number > 100 * 1024 * 1024) {\n\t\t# big image...\n\t\t$count = $number / $bigimage;\n\t\t$count = Math::BigFloat->new($count)->ffround(0);\n\t\treturn (($bigimage,$count,$count*$bigimage));\n\t} else {\n\t\t# small image...\n\t\t$count = $number / $smallimage;\n\t\t$count = Math::BigFloat->new($count)->ffround(0);\n\t\treturn (($smallimage,$count,$count*$smallimage));\n\t}\n}\n\n#==========================================\n# preImage\n#------------------------------------------\nsub preImage {\n\t# ...\n\t# pre-stage preparation of a logical extend.\n\t# This method includes all common not filesystem\n\t# dependant tasks before the logical extend\n\t# has been created\n\t# ---\n\tmy $this       = shift;\n\tmy $haveExtend = shift;\n\tmy $quiet      = shift;\n\t#==========================================\n\t# Get image creation date and name\n\t#------------------------------------------\n\tmy $name = $this -> buildImageName ();\n\tif (! defined $name) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Call images.sh script\n\t#------------------------------------------\n\tmy $mBytes = $this -> setupLogicalExtend ($quiet,$name);\n\tif (! defined $mBytes) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create logical extend\n\t#------------------------------------------\n\tif (! defined $haveExtend) {\n\t\tif (! $this -> buildLogicalExtend ($name,$mBytes.\"M\")) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\treturn $name;\n}\n\n#==========================================\n# writeImageConfig\n#------------------------------------------\nsub writeImageConfig {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $configName = $this -> buildImageName() . \".config\";\n\tmy $device = $xml -> getPXEDeployImageDevice ();\n\tmy %type = %{$xml -> getImageTypeAndAttributes()};\n\t#==========================================\n\t# create .config for types which needs it\n\t#------------------------------------------\n\tif (defined $device) {\n\t\t$kiwi -> info (\"Creating boot configuration...\");\n\t\tif (! open (FD,\">$this->{imageDest}/$configName\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't create image boot configuration\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $namecd = $this -> buildImageName(\";\");\n\t\tmy $namerw = $this -> buildImageName(\";\", \"-read-write\");\n\t\tmy $server = $xml -> getPXEDeployServer ();\n\t\tmy $blocks = $xml -> getPXEDeployBlockSize ();\n\t\tif (! defined $server) {\n\t\t\t$server = \"\";\n\t\t}\n\t\tif (! defined $blocks) {\n\t\t\t$blocks = \"\";\n\t\t}\n\t\tprint FD \"DISK=${device}\\n\";\n\t\tmy $targetPartition = 2;\n\t\tmy $targetPartitionNext = 3;\n\t\t#==========================================\n\t\t# PART information\n\t\t#------------------------------------------\n\t\tmy @parts = $xml -> getPXEDeployPartitions ();\n\t\tif ((scalar @parts) > 0) {\n\t\t\tprint FD \"PART=\";\n\t\t\tfor my $href (@parts) {\n\t\t\t\tif ($href -> {target}) {\n\t\t\t\t\t$targetPartition = $href -> {number};\n\t\t\t\t\t$targetPartitionNext = $targetPartition + 1;\n\t\t\t\t}\n\t\t\t\tif ($href -> {size} eq \"image\") {\n\t\t\t\t\tmy $size = $main::global -> isize (\n\t\t\t\t\t\t\"$this->{imageDest}/$name\"\n\t\t\t\t\t);\n\t\t\t\t\tprint FD int (($size/1024/1024)+1);\n\t\t\t\t} else {\n\t\t\t\t\tprint FD $href -> {size};\n\t\t\t\t}\n\n\t\t\t\tmy $type = $href -> {type};\n\t\t\t\tmy $mountpoint = $href -> {mountpoint};\n\n\t\t\t\tSWITCH: for ($type) {\n\t\t\t\t\t/swap/i && do {\n\t\t\t\t\t\t$type = \"S\";\n\t\t\t\t\t\tlast SWITCH;\n\t\t\t\t\t};\n\t\t\t\t\t/linux/i && do {\n\t\t\t\t\t\t$type = \"83\";\n\t\t\t\t\t\tlast SWITCH;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tprint FD \";$type;$mountpoint,\";\n\t\t\t}\n\t\t\tprint FD \"\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# IMAGE information\n\t\t#------------------------------------------\n\t\tif (($type{compressed}) && ($type{compressed} eq 'true')) {\n\t\t\tprint FD \"IMAGE='${device}${targetPartition};\";\n\t\t\tprint FD \"$namecd;$server;$blocks;compressed'\";\n\t\t\tif (\"$type{type}\" eq \"split\" && defined $this->{imageTreeRW}) {\n\t\t\t\tprint FD \",${device}${targetPartitionNext}\";\n\t\t\t\tprint FD \";$namerw;$server;$blocks;compressed\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \"\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tprint FD \"IMAGE='${device}${targetPartition};\";\n\t\t\tprint FD \"$namecd;$server;$blocks'\";\n\t\t\tif (\"$type{type}\" eq \"split\" && defined $this->{imageTreeRW}) {\n\t\t\t\tprint FD \",${device}${targetPartitionNext}\";\n\t\t\t\tprint FD \";$namerw;$server;$blocks\\n\";\n\t\t\t} else {\n\t\t\t\tprint FD \"\\n\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# CONF information\n\t\t#------------------------------------------\n\t\tmy %confs = $xml -> getPXEDeployConfiguration ();\n\t\tif ((scalar keys %confs) > 0) {\n\t\t\tprint FD \"CONF=\";\n\t\t\tforeach my $source (keys %confs) {\n\t\t\t\tprint FD \"$source;$confs{$source};$server;$blocks,\";\n\t\t\t}\n\t\t\tprint FD \"\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# COMBINED_IMAGE information\n\t\t#------------------------------------------\n\t\tif (\"$type{type}\" eq \"split\") {\n\t\t\tprint FD \"COMBINED_IMAGE=yes\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# UNIONFS_CONFIG information\n\t\t#------------------------------------------\n\t\tmy %unionConfig = $xml -> getPXEDeployUnionConfig ();\n\t\tif (%unionConfig) {\n\t\t\tmy $valid = 0;\n\t\t\tmy $value;\n\t\t\tif (! $unionConfig{type}) {\n\t\t\t\t$unionConfig{type} = \"aufs\";\n\t\t\t}\n\t\t\tif (($unionConfig{rw}) && ($unionConfig{ro})) {\n\t\t\t\t$value = \"$unionConfig{rw},$unionConfig{ro},$unionConfig{type}\";\n\t\t\t\t$valid = 1;\n\t\t\t}\n\t\t\tif ($valid) {\n\t\t\t\tprint FD \"UNIONFS_CONFIG='\".$value.\"'\\n\";\n\t\t\t}\n\t\t}\n\t\t#==========================================\n\t\t# KIWI_BOOT_TIMEOUT information\n\t\t#------------------------------------------\n\t\tmy $timeout = $xml -> getPXEDeployTimeout ();\n\t\tif (defined $timeout) {\n\t\t\tprint FD \"KIWI_BOOT_TIMEOUT=$timeout\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# KIWI_KERNEL_OPTIONS information\n\t\t#------------------------------------------\n\t\tmy $cmdline = $type{cmdline};\n\t\tif (defined $cmdline) {\n\t\t\tprint FD \"KIWI_KERNEL_OPTIONS='$cmdline'\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# KIWI_KERNEL information\n\t\t#------------------------------------------\n\t\tmy $kernel = $xml -> getPXEDeployKernel ();\n\t\tif (defined $kernel) {\n\t\t\tprint FD \"KIWI_KERNEL=$kernel\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# KIWI_INITRD information\n\t\t#------------------------------------------\n\t\tmy $initrd = $xml -> getPXEDeployInitrd ();\n\t\tif (defined $initrd) {\n\t\t\tprint FD \"KIWI_INITRD=$initrd\\n\";\n\t\t}\n\t\t#==========================================\n\t\t# More to come...\n\t\t#------------------------------------------\n\t\tclose FD;\n\t\t$kiwi -> done ();\n\t}\n\t# Reset main::ImageName...\n\t$this -> buildImageName();\n\treturn $configName;\n}\n\n#==========================================\n# postImage\n#------------------------------------------\nsub postImage {\n\t# ...\n\t# post-stage preparation of a logical extend.\n\t# This method includes all common not filesystem\n\t# dependant tasks after the logical extend has\n\t# been created\n\t# ---\n\tmy $this  = shift;\n\tmy $name  = shift;\n\tmy $nozip = shift;\n\tmy $fstype= shift;\n\tmy $device= shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $xml   = $this->{xml};\n\t#==========================================\n\t# mount logical extend for data transfer\n\t#------------------------------------------\n\tmy $extend = $this -> mountLogicalExtend ($name,undef,$device);\n\tif (! defined $extend) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# copy physical to logical\n\t#------------------------------------------\n\tif (! $this -> installLogicalExtend ($extend,undef,$device)) {\n\t\t$this -> cleanLuks();\n\t\treturn undef;\n\t}\n\t$this -> cleanMount();\n\t#==========================================\n\t# Check image file system\n\t#------------------------------------------\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\tif ((! $type{filesystem}) && ($fstype)) {\n\t\t$type{filesystem} = $fstype;\n\t}\n\tmy $para = $type{type}.\":\".$type{filesystem};\n\tif ($type{filesystem}) {\n\t\t$kiwi -> info (\"Checking file system: $type{filesystem}...\");\n\t} else {\n\t\t$kiwi -> info (\"Checking file system: $type{type}...\");\n\t}\n\tSWITCH: for ($para) {\n\t\t#==========================================\n\t\t# Check EXT3 file system\n\t\t#------------------------------------------\n\t\t/ext3|ec2|clicfs/i && do {\n\t\t\tqxx (\"/sbin/fsck.ext3 -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\tqxx (\"/sbin/tune2fs -j $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check EXT4 file system\n\t\t#------------------------------------------\n\t\t/ext4/i     && do {\n\t\t\tqxx (\"/sbin/fsck.ext4 -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\tqxx (\"/sbin/tune2fs -j $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check EXT2 file system\n\t\t#------------------------------------------\n\t\t/ext2/i     && do {\n\t\t\tqxx (\"/sbin/e2fsck -f -y $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check ReiserFS file system\n\t\t#------------------------------------------\n\t\t/reiserfs/i && do {\n\t\t\tqxx (\"/sbin/reiserfsck -y $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check BTRFS file system\n\t\t#------------------------------------------\n\t\t/btrfs/     && do {\n\t\t\tqxx (\"/sbin/btrfsck $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Check XFS file system\n\t\t#------------------------------------------\n\t\t/xfs/       && do {\n\t\t\tqxx (\"/sbin/fsck.xfs $this->{imageDest}/$name 2>&1\");\n\t\t\t$kiwi -> done();\n\t\t\tlast SWITCH;\n\t\t};\n\t\t#==========================================\n\t\t# Unknown filesystem type\n\t\t#------------------------------------------\n\t\t$kiwi -> failed();\n\t\t$kiwi -> error (\"Unsupported filesystem type: $type{filesystem}\");\n\t\t$kiwi -> failed();\n\t\t$this -> cleanLuks();\n\t\treturn undef;\n\t}\n\t$this -> restoreImageDest();\n\t$this -> cleanLuks ();\n\t#==========================================\n\t# Create image md5sum\n\t#------------------------------------------\n\tif ($fstype ne \"clicfs\") {\n\t\tif (! $this -> buildMD5Sum ($name)) {\n\t\t\treturn undef;\n\t\t}\n\t}\n\t#==========================================\n\t# Compress image using gzip\n\t#------------------------------------------\n\tif (! defined $nozip) {\n\t\tif (($type{compressed}) && ($type{compressed} eq 'true')) {\n\t\t\tif (! $this -> compressImage ($name)) {\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# Create image boot configuration\n\t#------------------------------------------\n\tif (! $this -> writeImageConfig ($name)) {\n\t\treturn undef;\n\t}\n\treturn $name;\n}\n\n#==========================================\n# buildLogicalExtend\n#------------------------------------------\nsub buildLogicalExtend {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $size = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $encode = 0;\n\tmy $cipher = 0;\n\tmy $out  = $this->{imageDest}.\"/\".$name;\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\t#==========================================\n\t# Check if luks encoding is requested\n\t#------------------------------------------\n\tif ($type{luks}) {\n\t\t$encode = 1;\n\t\t$cipher = \"$type{luks}\";\n\t\t$main::global -> setGlobals (\"LuksCipher\",$cipher);\n\t}\n\t#==========================================\n\t# Calculate block size and number of blocks\n\t#------------------------------------------\n\tif (! defined $size) {\n\t\treturn undef;\n\t}\n\tmy @bsc  = getBlocks ( $size );\n\tmy $seek = $bsc[2] - 1;\n\t#==========================================\n\t# Create logical extend storage and FS\n\t#------------------------------------------\n\tunlink ($out);\n\tmy $data = qxx (\"dd if=/dev/zero of=$out bs=1 seek=$seek count=1 2>&1\");\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create logical extend\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Setup encoding\n\t#------------------------------------------\n\tif ($encode) {\n\t\t$this -> setupEncoding ($name,$out,$cipher);\n\t}\n\treturn $name;\n}\n\n#==========================================\n# setupEncoding\n#------------------------------------------\nsub setupEncoding {\n\t# ...\n\t# setup LUKS encoding on the given file and remap\n\t# the imageDest variable to the new device mapper\n\t# location\n\t# ---\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $out    = shift;\n\tmy $cipher = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $data;\n\tmy $code;\n\t$data = qxx (\"/sbin/losetup -s -f $out 2>&1\"); chomp $data;\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't loop bind logical extend: $data\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $loop = $data;\n\tmy @luksloop;\n\tif ($this->{luksloop}) {\n\t\t@luksloop = @{$this->{luksloop}};\n\t}\n\tpush @luksloop,$loop;\n\t$this->{luksloop} = \\@luksloop;\n\t$data = qxx (\"echo $cipher | cryptsetup -q luksFormat $loop 2>&1\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't setup luks format: $loop\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLuks ();\n\t\treturn undef;\n\t}\n\t$data = qxx (\"echo $cipher | cryptsetup luksOpen $loop $name 2>&1\");\n\t$code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't open luks device: $data\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanLuks ();\n\t\treturn undef;\n\t}\n\tmy @luksname;\n\tif ($this->{luksname}) {\n\t\t@luksname = @{$this->{luksname}};\n\t}\n\tpush @luksname,$name;\n\t$this->{luksname} = \\@luksname;\n\tif (! $this->{imageDestOrig}) {\n\t\t$this->{imageDestOrig} = $this->{imageDest};\n\t\t$this->{imageDestMap} = \"/dev/mapper/\";\n\t}\n\t$this->{imageDest} = $this->{imageDestMap};\n\treturn $this;\n}\n\n#==========================================\n# installLogicalExtend\n#------------------------------------------\nsub installLogicalExtend {\n\tmy $this   = shift;\n\tmy $extend = shift;\n\tmy $source = shift;\n\tmy $device = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $imageTree = $this->{imageTree};\n\tif (! defined $source) {\n\t\t$source = $imageTree;\n\t}\n\t#==========================================\n\t# copy physical to logical\n\t#------------------------------------------\n\tmy $name = basename ($source);\n\t$kiwi -> info (\"Copying physical to logical [$name]...\");\n\tmy $free = qxx (\"df -h $extend 2>&1\");\n\t$kiwi -> loginfo (\"getSize: mount: $free\\n\");\n\tmy $data = qxx (\n\t\t\"tar --one-file-system -cf - -C $source . | tar -x -C $extend 2>&1\"\n\t);\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> info   (\"tar based copy failed: $data\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# dump image file from device if requested\n\t#------------------------------------------\n\tif ($device) {\n\t\t$this -> cleanMount();\n\t\t$name = $this -> buildImageName ();\n\t\t$kiwi -> info (\"Dumping filesystem image from $device...\");\n\t\t$data = qxx (\"dd if=$device of=$this->{imageDest}/$name bs=32k 2>&1\");\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Failed to load filesystem image\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  ($data);\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t}\n\treturn $extend;\n}\n\n#==========================================\n# setupLogicalExtend\n#------------------------------------------\nsub setupLogicalExtend {\n\tmy $this  = shift;\n\tmy $quiet = shift;\n\tmy $name  = shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $imageTree = $this->{imageTree};\n\tmy $imageStrip= $this->{imageStrip};\n\tmy $initCache = $this->{initCache};\n\t#==========================================\n\t# Call images.sh script\n\t#------------------------------------------\n\tif (-x \"$imageTree/image/images.sh\") {\n\t\t$kiwi -> info (\"Calling image script: images.sh\");\n\t\tmy $data = qxx (\" chroot $imageTree /image/images.sh 2>&1 \");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\t$this -> cleanMount();\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"images.sh: $data\");\n\t\t}\n\t\t$kiwi -> done ();\n\t}\n\t#==========================================\n\t# extract kernel from physical extend\n\t#------------------------------------------\n\tif (! defined $initCache) {\n\t\tif (! $this -> extractKernel ($name)) {\n\t\t\treturn undef;\n\t\t}\n\t\t$this -> extractSplash ($name);\n\t}\n\t#==========================================\n\t# Strip if specified\n\t#------------------------------------------\n\tif (defined $imageStrip) {\n\t\tstripImage();\n\t}\n\t#==========================================\n\t# Calculate needed space\n\t#------------------------------------------\n\t$this -> cleanKernelFSMount();\n\tmy ($mbytes,$xmlsize) = $this -> getSize ($imageTree);\n\tif (! defined $quiet) {\n\t\t$kiwi -> info (\"Image requires \".$mbytes.\"M, got $xmlsize\");\n\t\t$kiwi -> done ();\n\t\t$kiwi -> info (\"Suggested Image size: $mbytes\".\"M\");\n\t\t$kiwi -> done ();\n\t}\n\t#==========================================\n\t# Check given XML size\n\t#------------------------------------------\n\tif ($xmlsize =~ /^(\\d+)([MG])$/i) {\n\t\t$xmlsize = $1;\n\t\tmy $unit = $2;\n\t\tif ($unit eq \"G\") {\n\t\t\t# convert GB to MB...\n\t\t\t$xmlsize *= 1024;\n\t\t}\n\t}\n\t#==========================================\n\t# Return XML size or required size\n\t#------------------------------------------\n\tif (int $xmlsize > $mbytes) {\n\t\treturn $xmlsize;\n\t}\n\treturn $mbytes;\n}\n\n#==========================================\n# mountLogicalExtend\n#------------------------------------------\nsub mountLogicalExtend {\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $opts   = shift;\n\tmy $device = shift;\n\tmy $kiwi   = $this->{kiwi};\n\t#==========================================\n\t# mount logical extend for data transfer\n\t#------------------------------------------\n\tmy $target = \"$this->{imageDest}/$name\";\n\tmy $mount  = \"mount\";\n\tif (defined $opts) {\n\t\t$mount = \"mount $opts\";\n\t}\n\tif ($device) {\n\t\t$target = $device;\n\t} else {\n\t\t$mount .= \" -o loop\";\n\t}\n\tmkdir \"$this->{imageDest}/mnt-$$\";\n\t#==========================================\n\t# check for filesystem options\n\t#------------------------------------------\n\tmy $fstype = qxx (\n\t\t\"/sbin/blkid -c /dev/null -s TYPE -o value $target\"\n\t);\n\tchomp $fstype;\n\tif ($fstype eq \"ext4\") {\n\t\t# /.../\n\t\t# ext4 (currently) should be mounted with 'nodelalloc';\n\t\t# else we might run out of space unexpectedly...\n\t\t# ----\n\t\t$mount .= \",nodelalloc\";\n\t}\n\tmy $data= qxx (\n\t\t\"$mount $target $this->{imageDest}/mnt-$$ 2>&1\"\n\t);\n\tmy $code= $? >> 8;\n\tif ($code != 0) {\n\t\tchomp $data;\n\t\t$kiwi -> error  (\"Image loop mount failed:\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\n\t\t\t\"mnt: $target -> $this->{imageDest}/mnt-$$: $data\"\n\t\t);\n\t\treturn undef;\n\t}\n\treturn \"$this->{imageDest}/mnt-$$\";\n}\n\n#==========================================\n# extractSplash\n#------------------------------------------\nsub extractSplash {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $imageTree = $this->{imageTree};\n\tmy $imageDest = $this->{imageDest};\n\tmy $zipper    = $this->{gdata}->{Gzip};\n\tmy $newspl    = $imageDest.\"/splash\";\n\t#==========================================\n\t# check if boot image\n\t#------------------------------------------\n\tif (! defined $name) {\n\t\treturn $this;\n\t}\n\tif (! $this->isBootImage ($name)) {\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# move out all splash files\n\t#------------------------------------------\n\t$kiwi -> info (\"Extracting splash files...\");\n\tmkdir $newspl;\n\tmy $status = qxx (\"mv $imageTree/image/loader/*.spl $newspl 2>&1\");\n\tmy $result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> skipped ();\n\t\t$kiwi -> info (\"No splash files found in initrd\");\n\t\t$kiwi -> skipped ();\n\t\tunlink $newspl;\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# create new splash with all pictures\n\t#------------------------------------------\n\twhile (my $splash = glob(\"$newspl/*.spl\")) {\n\t\tmkdir \"$splash.dir\";\n\t\tqxx (\"$zipper -cd $splash > $splash.bob\");\n\t\tmy $count = $this -> extractCPIO ( $splash.\".bob\" );\n\t\tfor (my $id=1; $id <= $count; $id++) {\n\t\t\tqxx (\"cat $splash.bob.$id |(cd $splash.dir && cpio -i 2>&1)\");\n\t\t}\n\t\tqxx (\"cp -a $splash.dir/etc $newspl\");\n\t\t$result = 1;\n\t\tif (-e \"$splash.dir/bootsplash\") {\n\t\t\tqxx (\"cat $splash.dir/bootsplash >> $newspl/bootsplash\");\n\t\t\t$result = $? >> 8;\n\t\t}\n\t\tqxx (\"rm -rf $splash.dir\");\n\t\tqxx (\"rm -f  $splash.bob*\");\n\t\tqxx (\"rm -f  $splash\");\n\t\tif ($result != 0) {\n\t\t\tmy $splfile = basename ($splash);\n\t\t\t$kiwi -> skipped ();\n\t\t\t$kiwi -> info (\"No bootsplash file found in $splfile cpio\");\n\t\t\t$kiwi -> skipped ();\n\t\t\treturn $this;\n\t\t}\n\t}\n\tqxx (\"(cd $newspl && \\\n\t\tfind|cpio --quiet -oH newc | $zipper) > $imageDest/$name.spl\"\n\t);\n\tqxx (\"rm -rf $newspl\");\n\t$kiwi -> done();\n\treturn $this;\n}\n\n#==========================================\n# isBootImage\n#------------------------------------------\nsub isBootImage {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $xml  = $this->{xml};\n\tif (! defined $name) {\n\t\treturn $this;\n\t}\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\tmy $para = $type{type};\n\tif (defined $type{filesystem}) {\n\t\t$para = $para.\":\".$type{filesystem};\n\t}\n\tSWITCH: for ($para) {\n\t\t/ext3/i     && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/ext4/i     && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/reiserfs/i && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/iso/i && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/ext2/i && do {\n\t\t\tif ($name !~ /boot/) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/squashfs/i && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/clicfs/i && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/btrfs/i  && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t\t/xfs/i    && do {\n\t\t\treturn 0;\n\t\t\tlast SWITCH;\n\t\t};\n\t}\n\treturn 1;\n}\n\n#==========================================\n# extractKernel\n#------------------------------------------\nsub extractKernel {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $imageTree = $this->{imageTree};\n\t#==========================================\n\t# check for boot image\n\t#------------------------------------------\n\tif (! defined $name) {\n\t\treturn $this;\n\t}\n\tif (! $this->isBootImage ($name)) {\n\t\treturn $name;\n\t}\n\t#==========================================\n\t# extract kernel from physical extend\n\t#------------------------------------------\n\treturn $this -> extractLinux (\n\t\t$name,$imageTree,$this->{imageDest}\n\t);\n}\n\n#==========================================\n# extractLinux\n#------------------------------------------\nsub extractLinux {\n\tmy $this      = shift;\n\tmy $name      = shift;\n\tmy $imageTree = shift;\n\tmy $dest      = shift;\n\tmy $kiwi      = $this->{kiwi};\n\tmy $xml       = $this->{xml};\n\tmy %xenc      = $xml->getXenConfig();\n\tif ((-f \"$imageTree/boot/vmlinux.gz\")  ||\n\t\t(-f \"$imageTree/boot/vmlinuz.el5\") ||\n\t\t(-f \"$imageTree/boot/vmlinux\")     ||\n\t\t(-f \"$imageTree/boot/vmlinuz\")\n\t) {\n\t\t$kiwi -> info (\"Extracting kernel...\");\n\t\t#==========================================\n\t\t# setup file names / cleanup...\n\t\t#------------------------------------------\n\t\tmy $pwd = qxx (\"pwd\"); chomp $pwd;\n\t\tmy $shortfile = \"$name.kernel\";\n\t\tmy $file = \"$dest/$shortfile\";\n\t\tif ($file !~ /^\\//) {\n\t\t\t$file = $pwd.\"/\".$file;\n\t\t}\n\t\tif (-e $file) {\n\t\t\tqxx (\"rm -f $file\");\n\t\t}\n\t\t# /.../\n\t\t# the KIWIConfig::suseStripKernel() function provides the\n\t\t# kernel as common name /boot/vmlinuz. We use this file for\n\t\t# the extraction\n\t\t# ----\n\t\tqxx (\"cp $imageTree/boot/vmlinuz $file\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   (\"Failed to extract kernel: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $kernel = qxx (\"get_kernel_version $file\"); chomp $kernel;\n\t\tqxx (\"mv -f $file $file.$kernel && ln -s $shortfile.$kernel $file\");\n\t\t# /.../\n\t\t# check for the Xen hypervisor and extract them as well\n\t\t# ----\n\t\tif ((defined $xenc{xen_domain}) && ($xenc{xen_domain} eq \"dom0\")) {\n\t\t\tif (! -f \"$imageTree/boot/xen.gz\") {\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\t$kiwi -> info   (\"Xen dom0 requested but no hypervisor found\");\n\t\t\t\t$kiwi -> failed ();\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t}\n\t\tif (-f \"$imageTree/boot/xen.gz\") {\n\t\t\t$file = \"$dest/$name.kernel-xen\";\n\t\t\tqxx (\"cp $imageTree/boot/xen.gz $file\");\n\t\t\tqxx (\"mv $file $file.$kernel.'gz'\");\n\t\t}\n\t\tqxx (\"rm -rf $imageTree/boot/*\");\n\t\t$kiwi -> done();\n\t}\n\treturn $name;\n}\n\n#==========================================\n# setupEXT2\n#------------------------------------------\nsub setupEXT2 {\n\tmy $this    = shift;\n\tmy $name    = shift;\n\tmy $journal = shift;\n\tmy $device  = shift;\n\tmy $cmdL    = $this->{cmdL};\n\tmy $kiwi    = $this->{kiwi};\n\tmy $xml     = $this->{xml};\n\tmy %type    = %{$xml->getImageTypeAndAttributes()};\n\tmy $fsopts;\n\tmy $tuneopts;\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL->getFilesystemOptions()}\n\t);\n\tmy $fstool;\n\tmy $target = \"$this->{imageDest}/$name\";\n\tif ((defined $journal) && ($journal eq \"journaled-ext3\")) {\n\t\t$fsopts = $FSopts{ext3};\n\t\t$fstool = \"mkfs.ext3\";\n\t} elsif ((defined $journal) && ($journal eq \"journaled-ext4\")) {\n\t\t$fsopts = $FSopts{ext4};\n\t\t$fstool = \"mkfs.ext4\";\n\t} else {\n\t\t$fsopts = $FSopts{ext2};\n\t\t$fstool = \"mkfs.ext2\";\n\t}\n\tif ($this->{inodes}) {\n\t\t$fsopts.= \" -N $this->{inodes}\";\n\t}\n\t$tuneopts = $type{fsnocheck} eq \"true\" ? \"-c 0 -i 0\" : \"\";\n\t$tuneopts = $FSopts{extfstune} if $FSopts{extfstune};\n\tif ($device) {\n\t\t$target = $device;\n\t}\n\tmy $data = qxx (\"$fstool $fsopts $target 2>&1\");\n\tmy $code = $? >> 8;\n\tif (!$code && $tuneopts) {\n\t\t$data = qxx (\"/sbin/tune2fs $tuneopts $target 2>&1\");\n\t\t$code = $? >> 8;\n\t}\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create EXT2 filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\tif ($device) {\n\t\tqxx (\"touch $this->{imageDest}/$name\");\n\t}\n\t$this -> restoreImageDest();\n\tif ((defined $journal) && ($journal eq \"journaled-ext3\")) {\n\t\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.ext3 2>&1\");\n\t} elsif ((defined $journal) && ($journal eq \"journaled-ext4\")) {\n\t\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.ext4 2>&1\");\n\t} else {\n\t\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.ext2 2>&1\");\n\t}\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# setupBTRFS\n#------------------------------------------\nsub setupBTRFS {\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $device = shift;\n\tmy $cmdL   = $this->{cmdL};\n\tmy $kiwi   = $this->{kiwi};\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL->getFilesystemOptions()}\n\t);\n\tmy $fsopts = $FSopts{btrfs};\n\tmy $target = \"$this->{imageDest}/$name\";\n\tif ($device) {\n\t\t$target = $device;\n\t}\n\tmy $data = qxx (\n\t\t\"/sbin/mkfs.btrfs $fsopts $target 2>&1\"\n\t);\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create BTRFS filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\tif ($device) {\n\t\tqxx (\"touch $this->{imageDest}/$name\");\n\t}\n\t$this -> restoreImageDest();\n\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.btrfs 2>&1\");\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# setupReiser\n#------------------------------------------\nsub setupReiser {\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $device = shift;\n\tmy $cmdL   = $this->{cmdL};\n\tmy $kiwi   = $this->{kiwi};\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL->getFilesystemOptions()}\n\t);\n\tmy $fsopts = $FSopts{reiserfs};\n\tmy $target = \"$this->{imageDest}/$name\";\n\tif ($device) {\n\t\t$target = $device;\n\t}\n\t$fsopts.= \"-f\";\n\tmy $data = qxx (\n\t\t\"/sbin/mkreiserfs $fsopts $target 2>&1\"\n\t);\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create Reiser filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\tif ($device) {\n\t\tqxx (\"touch $this->{imageDest}/$name\");\n\t}\n\t$this -> restoreImageDest();\n\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.reiserfs 2>&1\");\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# setupSquashFS\n#------------------------------------------\nsub setupSquashFS {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $tree = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy %type = %{$xml->getImageTypeAndAttributes()};\n\tmy $imageTree = $this->{imageTree};\n\tmy $locator = new KIWILocator($kiwi);\n\tif (! defined $tree) {\n\t\t$tree = $imageTree;\n\t}\n\tif ($type{luks}) {\n\t\t$this -> restoreImageDest();\n\t}\n\tunlink (\"$this->{imageDest}/$name\");\n\tmy $squashfs_tool = $locator -> getExecPath(\"mksquashfs\");\n\tmy $data = qxx (\"$squashfs_tool $tree $this->{imageDest}/$name 2>&1\");\n\tmy $code = $? >> 8; \n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create squashfs filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for LUKS extension\n\t#------------------------------------------\n\tif ($type{luks}) {\n\t\tmy $outimg = $this->{imageDest}.\"/\".$name;\n\t\tmy $squashimg = $outimg.\".squashfs\";\n\t\tmy $cipher = \"$type{luks}\";\n\t\tmy $data = qxx (\"mv $outimg $squashimg 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to rename squashfs image\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $bytes = int ((-s $squashimg) * 1.1);\n\t\t$data = qxx (\n\t\t\t\"dd if=/dev/zero of=$outimg bs=1 seek=$bytes count=1 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to create luks loop container\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tif (! $this -> setupEncoding ($name.\".squashfs\",$outimg,$cipher)) {\n\t\t\treturn undef;\n\t\t}\n\t\t$data = qxx (\n\t\t\t\"dd if=$squashimg of=$this->{imageDest}/$name.squashfs 2>&1\"\n\t\t);\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to dump squashfs to luks loop: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\t$this -> cleanLuks();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t$this -> restoreImageDest();\n\t$data = qxx (\"chmod 644 $this->{imageDest}/$name\");\n\t$data = qxx (\"rm -f $this->{imageDest}/$name.squashfs\");\n\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.squashfs 2>&1\");\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# setupXFS\n#------------------------------------------\nsub setupXFS {\n\tmy $this   = shift;\n\tmy $name   = shift;\n\tmy $cmdL   = $this->{cmdL};\n\tmy $kiwi   = $this->{kiwi};\n\tmy %FSopts = $main::global -> checkFSOptions(\n\t\t@{$cmdL->getFilesystemOptions()}\n\t);\n\tmy $fsopts = $FSopts{xfs};\n\tmy $data = qxx (\n\t\t\"/sbin/mkfs.xfs $fsopts $this->{imageDest}/$name 2>&1\"\n\t);\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> error  (\"Couldn't create XFS filesystem\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  ($data);\n\t\treturn undef;\n\t}\n\t$this -> restoreImageDest();\n\t$data = qxx (\"cd $this->{imageDest} && ln -vs $name $name.xfs 2>&1\");\n\t$this -> remapImageDest();\n\t$kiwi -> loginfo ($data);\n\treturn $name;\n}\n\n#==========================================\n# buildMD5Sum\n#------------------------------------------\nsub buildMD5Sum {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $initCache = $this->{initCache};\n\t#==========================================\n\t# Skip this in init cache mode\n\t#------------------------------------------\n\tif (defined $initCache) {\n\t\tif ($name =~ /\\.gz$/) {\n\t\t\t$name =~ s/\\.gz//;\n\t\t}\n\t\treturn $name;\n\t}\n\t#==========================================\n\t# Create image md5sum\n\t#------------------------------------------\n\t$kiwi -> info (\"Creating image MD5 sum...\");\n\tmy $size = $main::global -> isize (\"$this->{imageDest}/$name\");\n\tmy $primes = qxx (\"factor $size\"); $primes =~ s/^.*: //;\n\tmy $blocksize = 1;\n\tfor my $factor (split /\\s/,$primes) {\n\t\tlast if ($blocksize * $factor > 65464);\n\t\t$blocksize *= $factor;\n\t}\n\tmy $blocks = $size / $blocksize;\n\tmy $sum  = qxx (\"cat $this->{imageDest}/$name | md5sum - | cut -f 1 -d-\");\n\tchomp $sum;\n\tif ($name =~ /\\.gz$/) {\n\t\t$name =~ s/\\.gz//;\n\t}\n\tqxx (\"echo \\\"$sum $blocks $blocksize\\\" > $this->{imageDest}/$name.md5\");\n\t$this->{md5file} = $this->{imageDest}.\"/\".$name.\".md5\";\n\t$kiwi -> done();\n\treturn $name;\n}\n\n#==========================================\n# restoreCDRootData\n#------------------------------------------\nsub restoreCDRootData {\n\tmy $this = shift;\n\tmy $imageTree    = $this->{imageTree};\n\tmy $cdrootData   = \"config-cdroot.tgz\";\n\tmy $cdrootScript = \"config-cdroot.sh\";\n\tif (-f $this->{imageDest}.\"/\".$cdrootData) {\n\t\tqxx (\"mv $this->{imageDest}/$cdrootData $imageTree/image\");\n\t}\n\tif (-f $this->{imageDest}.\"/\".$cdrootScript) {\n\t\tqxx (\"mv $this->{imageDest}/$cdrootScript $imageTree/image\");\n\t}\n}\n\n#==========================================\n# restoreSplitExtend\n#------------------------------------------\nsub restoreSplitExtend {\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $imageTreeReadOnly = $this->{imageTreeReadOnly};\n\tmy $imageTree = $this->{imageTree};\n\tif ((! defined $imageTreeReadOnly) || ( ! -d $imageTreeReadOnly)) {\n\t\treturn $imageTreeReadOnly;\n\t}\n\t$kiwi -> info (\"Restoring physical extend...\");\n\tmy @rodirs = qw (bin boot lib lib64 opt sbin usr);\n\tforeach my $dir (@rodirs) {\n\t\tif (! -d \"$imageTreeReadOnly/$dir\") {\n\t\t\tnext;\n\t\t}\n\t\tmy $data = qxx (\"mv $imageTreeReadOnly/$dir $imageTree 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't restore physical extend: $data\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t}\n\t$kiwi -> done();\n\trmdir  $imageTreeReadOnly;\n\treturn $imageTreeReadOnly;\n}\n\n#==========================================\n# compressImage\n#------------------------------------------\nsub compressImage {\n\tmy $this = shift;\n\tmy $name = shift;\n\tmy $kiwi = $this->{kiwi};\n\t#==========================================\n\t# Compress image using gzip\n\t#------------------------------------------\n\t$kiwi -> info (\"Compressing image...\");\n\tmy $data = qxx (\"$this->{gdata}->{Gzip} -f $this->{imageDest}/$name\");\n\tmy $code = $? >> 8;\n\tif ($code != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error (\"Compressing image failed: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\t$this -> updateMD5File (\"$this->{imageDest}/$name.gz\");\n\treturn $name;\n}\n\n#==========================================\n# updateMD5File\n#------------------------------------------\nsub updateMD5File {\n\tmy $this = shift;\n\tmy $image= shift;\n\tmy $kiwi = $this->{kiwi};\n\t#==========================================\n\t# Update md5file adding zblocks/zblocksize\n\t#------------------------------------------\n\tif (defined $this->{md5file}) {\n\t\t$kiwi -> info (\"Updating md5 file...\");\n\t\tif (! open (FD,$this->{md5file})) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to open md5 file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tmy $line = <FD>; close FD; chomp $line;\n\t\tmy $size = $main::global -> isize ($image);\n\t\tmy $primes = qxx (\"factor $size\"); $primes =~ s/^.*: //;\n\t\tmy $blocksize = 1;\n\t\tfor my $factor (split /\\s/,$primes) {\n\t\t\tlast if ($blocksize * $factor > 65464);\n\t\t\t$blocksize *= $factor;\n\t\t}\n\t\tmy $blocks = $size / $blocksize;\n\t\tmy $md5file= $this->{md5file};\n\t\tqxx (\"echo \\\"$line $blocks $blocksize\\\" > $md5file\");\n\t\t$kiwi -> done();\n\t}\n}\n\n#==========================================\n# getSize\n#------------------------------------------\nsub getSize {\n\t# ...\n\t# calculate size of the logical extend. The\n\t# method returns the size value in MegaByte\n\t# ---\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $cmdL   = $this->{cmdL};\n\tmy $extend = shift;\n\tmy $xml    = $this->{xml};\n\tmy $mini   = qxx (\"find $extend | wc -l\"); chomp $mini;\n\tmy $minsize= qxx (\"du -s --block-size=1 $extend | cut -f1\"); chomp $minsize;\n\tmy $fsohead= 1.4;\n\tmy $spare  = 100 * 1024 * 1024;\n\tmy $files  = $mini;\n\tmy $fsopts = $cmdL -> getFilesystemOptions();\n\tmy $isize  = $fsopts->[1];\n\tmy $iratio = $fsopts->[2];\n\tmy $xmlsize;\n\t#==========================================\n\t# Double minimum inode count\n\t#------------------------------------------\n\t$mini *= 2;\n\t#==========================================\n\t# Minimum size calculated in Byte\n\t#------------------------------------------\n\t$kiwi -> loginfo (\"getSize: files: $files\\n\");\n\t$kiwi -> loginfo (\"getSize: usage: $minsize Bytes\\n\");\n\t$kiwi -> loginfo (\"getSize: inode: $isize Bytes\\n\");\n\t$minsize *= $fsohead;\n\t$minsize += $mini * $isize;\n\t$minsize += $spare;\n\t$xmlsize = $minsize;\n\t$kiwi -> loginfo (\"getSize: minsz: $minsize Bytes\\n\");\n\t#==========================================\n\t# XML size calculated in Byte\n\t#------------------------------------------\n\tmy $additive = $xml -> getImageSizeAdditiveBytes();\n\tif ($additive) {\n\t\t# relative size value specified...\n\t\t$xmlsize = $minsize + $additive;\n\t} else {\n\t\t# absolute size value specified...\n\t\t$xmlsize = $xml -> getImageSize();\n\t\tif ($xmlsize eq \"auto\") {\n\t\t\t$xmlsize = $minsize;\n\t\t} elsif ($xmlsize =~ /^(\\d+)([MG])$/i) {\n\t\t\tmy $value= $1;\n\t\t\tmy $unit = $2;\n\t\t\tif ($unit eq \"G\") {\n\t\t\t\t# convert GB to MB...\n\t\t\t\t$value *= 1024;\n\t\t\t}\n\t\t\t# convert MB to Byte\n\t\t\t$xmlsize = $value * 1048576;\n\t\t\t# check the size value with what kiwi thinks is the minimum\n\t\t\tif ($xmlsize < $minsize) {\n\t\t\t\t$kiwi -> warning (\n\t\t\t\t\t\"--> given xml size might be too small, using it anyhow !\\n\"\n\t\t\t\t);\n\t\t\t\t$kiwi -> warning (\n\t\t\t\t\t\"--> min size changed from $minsize to $xmlsize bytes\\n\"\n\t\t\t\t);\n\t\t\t\t$minsize = $xmlsize;\n\t\t\t}\n\t\t}\n\t}\n\t#==========================================\n\t# Setup used size and inodes, prefer XML\n\t#------------------------------------------\n\tmy $usedsize = $minsize; \n\tif ($xmlsize > $minsize) {\n\t\t$usedsize = $xmlsize;\n\t\t$this->{inodes} = sprintf (\"%.0f\",$usedsize / $iratio);\n\t} else {\n\t\t$this->{inodes} = $mini;\n\t}\n\t#==========================================\n\t# return result list in MB\n\t#------------------------------------------\n\t$minsize = sprintf (\"%.0f\",$minsize  / 1048576);\n\t$usedsize= sprintf (\"%.0f\",$usedsize / 1048576);\n\t$usedsize.= \"M\";\n\treturn ($minsize,$usedsize);\n}\n\n#==========================================\n# checkKernel\n#------------------------------------------\nsub checkKernel {\n\t# ...\n\t# this function receives two parameters. The initrd image\n\t# file and the system image tree directory path. It checks\n\t# whether at least one kernel matches both, the initrd and\n\t# the system image. If not the function tries to copy the\n\t# kernel from the system image into the initrd. If the\n\t# system image specifies more than one kernel an error\n\t# is printed pointing out that the boot image needs to\n\t# specify one of the found system image kernels\n\t# ---\n\tmy $this    = shift;\n\tmy $initrd  = shift;\n\tmy $systree = shift;\n\tmy $name    = shift;\n\tmy $kiwi    = $this->{kiwi};\n\tmy $arch    = $this->{arch};\n\tmy $zipper  = $this->{gdata}->{Gzip};\n\tmy %sysk    = ();\n\tmy %bootk   = ();\n\tmy $status;\n\tmy $tmpdir;\n\t#==========================================\n\t# find system image kernel(s)\n\t#------------------------------------------\n\tforeach my $dir (glob (\"$systree/lib/modules/*\")) {\n\t\tif ($dir =~ /-debug$/) {\n\t\t\tnext;\n\t\t}\n\t\t$dir =~ s/$systree\\///;\n\t\t$sysk{$dir} = \"system-kernel\";\n\t}\n\tif (! %sysk) {\n\t\t$kiwi -> error  (\"Can't find any system image kernel\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# find boot image kernel\n\t#------------------------------------------\n\tmy $cmd = \"cat $initrd\";\n\tmy $zip = 0;\n\tif ($initrd =~ /\\.gz$/) {\n\t\t$cmd = \"$zipper -cd $initrd\";\n\t\t$zip = 1;\n\t}\n\tmy @status = qxx (\"$cmd|cpio -it --quiet 'lib/modules/*'|cut -f1-3 -d/\");\n\tmy $result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> error  (\"Can't find any boot image kernel\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tforeach my $module (@status) {\n\t\tchomp $module;\n\t\t$bootk{$module} = \"boot-kernel\";\n\t}\n\tif (! %bootk) {\n\t\t$kiwi -> error  (\"Can't find any boot image kernel\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# search system image kernel in initrd \n\t#------------------------------------------\n\tforeach my $system (keys %sysk) {\n\t\tif ($bootk{$system}) {\n\t\t\t# found system image kernel in initrd, ok\n\t\t\treturn $this;\n\t\t}\n\t}\n\t#==========================================\n\t# check system image kernel count\n\t#------------------------------------------\n\tif (keys %sysk > 1) {\n\t\t$kiwi -> error  (\"*** kernel check failed ***\");\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> note (\"Can't find a system kernel matching the initrd\\n\");\n\t\t$kiwi -> note (\"multiple system kernels were found, make sure your\\n\");\n\t\t$kiwi -> note (\"boot image includes the intended kernel\\n\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# fix kernel inconsistency:\n\t#------------------------------------------\n\t$kiwi -> info (\"Fixing kernel inconsistency...\");\n\t$tmpdir = qxx (\"mktemp -q -d /tmp/kiwi-fixboot.XXXXXX\"); chomp $tmpdir;\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create tmp dir: $tmpdir: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tpush @{$this->{tmpdirs}},$tmpdir;\n\t#==========================================\n\t# 1) unpack initrd...\n\t#------------------------------------------\n\t$status = qxx (\"cd $tmpdir && $cmd|cpio -di --quiet\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't unpack initrd: $status\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# 2) create images.sh script...\n\t#------------------------------------------\n\tif (! open (FD,\">$tmpdir/images.sh\")) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create image.sh file: $!\");\n\t\t$kiwi -> failed ();\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t}\n\tprint FD '#!/bin/sh'.\"\\n\";\n\tprint FD 'test -f /.kconfig && . /.kconfig'.\"\\n\";\n\tprint FD 'test -f /.profile && . /.profile'.\"\\n\";\n\tprint FD 'echo \"*** Fixing kernel inconsistency ***\"'.\"\\n\";\n\tprint FD 'suseStripKernel'.\"\\n\";\n\tprint FD 'exit 0'.\"\\n\";\n\tclose FD;\n\t#==========================================\n\t# 3) copy system kernel to initrd...\n\t#------------------------------------------\n\tqxx (\"rm -rf $tmpdir/boot\");\n\tqxx (\"cp -a  $systree/boot $tmpdir\");\n\tqxx (\"rm -rf $tmpdir/lib/modules\");\n\tqxx (\"cp -a  $systree/lib/modules $tmpdir/lib\");\n\tqxx (\n\t\t\"cp $this->{gdata}->{BasePath}/modules/KIWIConfig.sh $tmpdir/.kconfig\"\n\t);\n\tqxx (\"chmod u+x $tmpdir/images.sh\");\n\t#==========================================\n\t# 4) call images.sh script...\n\t#------------------------------------------\n\t$status = qxx (\"chroot $tmpdir /images.sh 2>&1\");\n\t$result = $? >> 8;\n\tif ($result != 0) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> info   ($status);\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t} else {\n\t\t$kiwi -> loginfo (\"images.sh: $status\");\n\t}\n\t$kiwi -> done();\n\t#==========================================\n\t# 5) extract kernel files...\n\t#------------------------------------------\n\tmy $dest = dirname $initrd;\n\tqxx (\"rm -f $dest/$name*\");\n\tif (! $this -> extractLinux ($name,$tmpdir,$dest)) {\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# 6) rebundle initrd...\n\t#------------------------------------------\n\tmy @cpio = (\"--create\", \"--format=newc\", \"--quiet\");\n\t$status = qxx ( \"cd $tmpdir && find . | cpio @cpio > $dest/$name\");\n\tif ($zip) {\n\t\t$status = qxx (\n\t\t\t\"cd $tmpdir && cat $dest/$name | $zipper -f > $initrd\"\n\t\t);\n\t} \n\t#==========================================\n\t# 7) recreate md5 file...\n\t#------------------------------------------\n\tmy $origDest = $this->{imageDest};\n\t$this->{imageDest} = $dest;\n\tif (! $this -> buildMD5Sum ($name)) {\n\t\t$this->{imageDest} = $origDest;\n\t\tqxx (\"rm -rf $tmpdir\");\n\t\treturn undef;\n\t}\n\t$this->{imageDest} = $origDest;\n\tqxx (\"rm -rf $tmpdir\");\n\treturn $this;\n}\n\n#==========================================\n# cleanLuks\n#------------------------------------------\nsub cleanLuks {\n\tmy $this = shift;\n\tmy $loop = $this->{luksloop};\n\tmy $name = $this->{luksname};\n\tif ($name) {\n\t\tforeach my $luks (@{$name}) {\n\t\t\tqxx (\"cryptsetup luksClose $luks 2>&1\");\n\t\t}\n\t}\n\tif ($loop) {\n\t\tforeach my $ldev (@{$loop}) {\n\t\t\tqxx (\"losetup -d $ldev 2>&1\");\n\t\t}\n\t}\n}\n\n#==========================================\n# restoreImageDest\n#------------------------------------------\nsub restoreImageDest {\n\tmy $this = shift;\n\tif ($this->{imageDestOrig}) {\n\t\t$this->{imageDest} = $this->{imageDestOrig};\n\t}\n}\n\n#==========================================\n# remapImageDest\n#------------------------------------------\nsub remapImageDest {\n\tmy $this = shift;\n\tif ($this->{imageDestMap}) {\n\t\t$this->{imageDest} = $this->{imageDestMap};\n\t}\n}\n\n#==========================================\n# cleanMount\n#------------------------------------------\nsub cleanMount {\n\tmy $this = shift;\n\tqxx (\"umount $this->{imageDest}/mnt-$$ 2>&1\");\n\trmdir \"$this->{imageDest}/mnt-$$\";\n}\n\n#==========================================\n# cleanKernelFSMount\n#------------------------------------------\nsub cleanKernelFSMount {\n\tmy $this = shift;\n\tmy @kfs  = (\"/proc/sys/fs/binfmt_misc\",\"/proc\",\"/dev/pts\",\"/sys\");\n\tforeach my $system (@kfs) {\n\t\tqxx (\"umount $this->{imageDest}/$system 2>&1\");\n\t}\n}\n\n#==========================================\n# buildImageName\n#------------------------------------------\nsub buildImageName {\n\tmy $this = shift;\n\tmy $xml  = $this->{xml};\n\tmy $arch = $this->{arch};\n\tmy $separator = shift;\n\tmy $extension = shift;\n\tif (! defined $separator) {\n\t\t$separator = \"-\";\n\t}\n\tmy $name = $xml -> getImageName();\n\tmy $iver = $xml -> getImageVersion();\n\tif (defined $extension) {\n\t\t$name = $name.$extension.$arch.$separator.$iver;\n\t} else {\n\t\t$name = $name.$arch.$separator.$iver;\n\t}\n\tchomp  $name;\n\treturn $name;\n}\n\n#==========================================\n# extractCPIO\n#------------------------------------------\nsub extractCPIO {\n\tmy $this = shift;\n\tmy $file = shift;\n\tif (! open FD,$file) {\n\t\treturn 0;\n\t}\n\tlocal $/;\n\tmy $data   = <FD>; close FD;\n\tmy @data   = split (//,$data);\n\tmy $stream = \"\";\n\tmy $count  = 0;\n\tmy $start  = 0;\n\tmy $pos1   = -1;\n\tmy $pos2   = -1;\n\tmy @index;\n\twhile (1) {\n\t\tmy $pos1 = index ($data,\"TRAILER!!!\",$start);\n\t\tif ($pos1 >= $start) {\n\t\t\t$pos2 = index ($data,\"07070\",$pos1);\n\t\t} else {\n\t\t\tlast;\n\t\t}\n\t\tif ($pos2 >= $pos1) {\n\t\t\t$pos2--;\n\t\t\tpush (@index,$pos2);\n\t\t\t#print \"$start -> $pos2\\n\";\n\t\t\t$start = $pos2;\n\t\t} else {\n\t\t\t$pos2 = @data; $pos2--;\n\t\t\tpush (@index,$pos2);\n\t\t\t#print \"$start -> $pos2\\n\";\n\t\t\tlast;\n\t\t}\n\t}\n\tfor (my $i=0;$i<@data;$i++) {\n\t\t$stream .= $data[$i];\n\t\tif ($i == $index[$count]) {\n\t\t\t$count++;\n\t\t\tif (! open FD,\">$file.$count\") {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprint FD $stream;\n\t\t\tclose FD;\n\t\t\t$stream = \"\";\n\t\t}\n\t}\n\treturn $count;\n}\n\n#==========================================\n# makeLabel\n#------------------------------------------\nsub makeLabel {\n\t# ...\n\t# isolinux handles spaces as \"_\", so we replace\n\t# each space with an underscore\n\t# ----\n\tmy $this = shift;\n\tmy $label = shift;\n\t$label =~ s/ /_/g;\n\treturn $label;\n}\n\n#==========================================\n# Destructor\n#------------------------------------------\nsub DESTROY {\n\tmy $this = shift;\n\tmy $dirs = $this->{tmpdirs};\n\tmy $imageDest = $this->{imageDest};\n\tmy $spldir    = $imageDest.\"/splash\";\n\tforeach my $dir (@{$dirs}) {\n\t\tqxx (\"rm -rf $dir 2>&1\");\n\t}\n\tif (-d $spldir) {\n\t\tqxx (\"rm -rf $spldir 2>&1\");\n\t}\n\t$this -> cleanMount();\n\t$this -> cleanLuks();\n\treturn $this;\n}\n\n1;\n\n# vim: set noexpandtab:\n"], "filenames": ["modules/KIWIBoot.pm", "modules/KIWIImage.pm"], "buggy_code_start_loc": [924, 1934], "buggy_code_end_loc": [2576, 2939], "fixing_code_start_loc": [924, 1934], "fixing_code_end_loc": [2576, 2939], "type": "NVD-CWE-Other", "message": "kiwi before 4.98.05, as used in SUSE Studio Onsite 1.2 before 1.2.1 and SUSE Studio Extension for System z 1.2 before 1.2.1, allows attackers to execute arbitrary commands via shell metacharacters in an image name.", "other": {"cve": {"id": "CVE-2011-4195", "sourceIdentifier": "cve@mitre.org", "published": "2014-04-16T18:37:11.460", "lastModified": "2014-04-17T14:20:13.387", "vulnStatus": "Analyzed", "evaluatorComment": "Per: https://cwe.mitre.org/data/definitions/77.html\n\n\"CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\"", "descriptions": [{"lang": "en", "value": "kiwi before 4.98.05, as used in SUSE Studio Onsite 1.2 before 1.2.1 and SUSE Studio Extension for System z 1.2 before 1.2.1, allows attackers to execute arbitrary commands via shell metacharacters in an image name."}, {"lang": "es", "value": "kiwi anterior a 4.98.05, utilizado en SUSE Studio Onsite 1.2 anterior a 1.2.1 y SUSE Studio Extension para System z 1.2 anterior a 1.2.1, permite a atacantes ejecutar comandos arbitrarios a trav\u00e9s de metacaracteres de shell en un nombre de imagen."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:suse:kiwi:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.98.04", "matchCriteriaId": "C18ACB6C-972F-41D9-947D-F7240DE42296"}, {"vulnerable": true, "criteria": "cpe:2.3:a:suse:studio_extension_for_system_z:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "FA8D3852-BBD8-4E26-BA67-181C29A4E97B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:suse:studio_onsite:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "E523A94D-9ECA-43C2-B96F-0D2C77D3F952"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2011-12/msg00015.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/11/02/4", "source": "cve@mitre.org"}, {"url": "https://github.com/openSUSE/kiwi/commit/88bf491d16942766016c606e4210b4e072c1019f", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/openSUSE/kiwi/commit/88bf491d16942766016c606e4210b4e072c1019f"}}