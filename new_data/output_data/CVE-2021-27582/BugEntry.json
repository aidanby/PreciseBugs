{"buggy_code": ["/*******************************************************************************\n * Copyright 2018 The MIT Internet Trust Consortium\n *\n * Portions copyright 2011-2013 The MITRE Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *******************************************************************************/\n/**\n *\n */\npackage org.mitre.oauth2.web;\n\nimport static org.mitre.openid.connect.request.ConnectRequestParameters.PROMPT;\nimport static org.mitre.openid.connect.request.ConnectRequestParameters.PROMPT_SEPARATOR;\n\nimport java.net.URISyntaxException;\nimport java.security.Principal;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.http.client.utils.URIBuilder;\nimport org.mitre.oauth2.model.ClientDetailsEntity;\nimport org.mitre.oauth2.model.SystemScope;\nimport org.mitre.oauth2.service.ClientDetailsEntityService;\nimport org.mitre.oauth2.service.SystemScopeService;\nimport org.mitre.openid.connect.model.UserInfo;\nimport org.mitre.openid.connect.service.ScopeClaimTranslationService;\nimport org.mitre.openid.connect.service.StatsService;\nimport org.mitre.openid.connect.service.UserInfoService;\nimport org.mitre.openid.connect.view.HttpCodeView;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.security.access.prepost.PreAuthorize;\nimport org.springframework.security.oauth2.common.exceptions.OAuth2Exception;\nimport org.springframework.security.oauth2.provider.AuthorizationRequest;\nimport org.springframework.security.oauth2.provider.endpoint.RedirectResolver;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.SessionAttributes;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Sets;\nimport com.google.gson.JsonObject;\n\n/**\n * @author jricher\n *\n */\n@Controller\n@SessionAttributes(\"authorizationRequest\")\npublic class OAuthConfirmationController {\n\n\n\t@Autowired\n\tprivate ClientDetailsEntityService clientService;\n\n\t@Autowired\n\tprivate SystemScopeService scopeService;\n\n\t@Autowired\n\tprivate ScopeClaimTranslationService scopeClaimTranslationService;\n\n\t@Autowired\n\tprivate UserInfoService userInfoService;\n\n\t@Autowired\n\tprivate StatsService statsService;\n\n\t@Autowired\n\tprivate RedirectResolver redirectResolver;\n\n\t/**\n\t * Logger for this class\n\t */\n\tprivate static final Logger logger = LoggerFactory.getLogger(OAuthConfirmationController.class);\n\n\tpublic OAuthConfirmationController() {\n\n\t}\n\n\tpublic OAuthConfirmationController(ClientDetailsEntityService clientService) {\n\t\tthis.clientService = clientService;\n\t}\n\n\t@PreAuthorize(\"hasRole('ROLE_USER')\")\n\t@RequestMapping(\"/oauth/confirm_access\")\n\tpublic String confimAccess(Map<String, Object> model, @ModelAttribute(\"authorizationRequest\") AuthorizationRequest authRequest,\n\t\t\tPrincipal p) {\n\n\t\t// Check the \"prompt\" parameter to see if we need to do special processing\n\n\t\tString prompt = (String)authRequest.getExtensions().get(PROMPT);\n\t\tList<String> prompts = Splitter.on(PROMPT_SEPARATOR).splitToList(Strings.nullToEmpty(prompt));\n\t\tClientDetailsEntity client = null;\n\n\t\ttry {\n\t\t\tclient = clientService.loadClientByClientId(authRequest.getClientId());\n\t\t} catch (OAuth2Exception e) {\n\t\t\tlogger.error(\"confirmAccess: OAuth2Exception was thrown when attempting to load client\", e);\n\t\t\tmodel.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\n\t\t\treturn HttpCodeView.VIEWNAME;\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tlogger.error(\"confirmAccess: IllegalArgumentException was thrown when attempting to load client\", e);\n\t\t\tmodel.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\n\t\t\treturn HttpCodeView.VIEWNAME;\n\t\t}\n\n\t\tif (client == null) {\n\t\t\tlogger.error(\"confirmAccess: could not find client \" + authRequest.getClientId());\n\t\t\tmodel.put(HttpCodeView.CODE, HttpStatus.NOT_FOUND);\n\t\t\treturn HttpCodeView.VIEWNAME;\n\t\t}\n\n\t\tif (prompts.contains(\"none\")) {\n\t\t\t// if we've got a redirect URI then we'll send it\n\n\t\t\tString url = redirectResolver.resolveRedirect(authRequest.getRedirectUri(), client);\n\n\t\t\ttry {\n\t\t\t\tURIBuilder uriBuilder = new URIBuilder(url);\n\n\t\t\t\turiBuilder.addParameter(\"error\", \"interaction_required\");\n\t\t\t\tif (!Strings.isNullOrEmpty(authRequest.getState())) {\n\t\t\t\t\turiBuilder.addParameter(\"state\", authRequest.getState()); // copy the state parameter if one was given\n\t\t\t\t}\n\n\t\t\t\treturn \"redirect:\" + uriBuilder.toString();\n\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tlogger.error(\"Can't build redirect URI for prompt=none, sending error instead\", e);\n\t\t\t\tmodel.put(\"code\", HttpStatus.FORBIDDEN);\n\t\t\t\treturn HttpCodeView.VIEWNAME;\n\t\t\t}\n\t\t}\n\n\t\tmodel.put(\"auth_request\", authRequest);\n\t\tmodel.put(\"client\", client);\n\n\t\tString redirect_uri = authRequest.getRedirectUri();\n\n\t\tmodel.put(\"redirect_uri\", redirect_uri);\n\n\n\t\t// pre-process the scopes\n\t\tSet<SystemScope> scopes = scopeService.fromStrings(authRequest.getScope());\n\n\t\tSet<SystemScope> sortedScopes = new LinkedHashSet<>(scopes.size());\n\t\tSet<SystemScope> systemScopes = scopeService.getAll();\n\n\t\t// sort scopes for display based on the inherent order of system scopes\n\t\tfor (SystemScope s : systemScopes) {\n\t\t\tif (scopes.contains(s)) {\n\t\t\t\tsortedScopes.add(s);\n\t\t\t}\n\t\t}\n\n\t\t// add in any scopes that aren't system scopes to the end of the list\n\t\tsortedScopes.addAll(Sets.difference(scopes, systemScopes));\n\n\t\tmodel.put(\"scopes\", sortedScopes);\n\n\t\t// get the userinfo claims for each scope\n\t\tUserInfo user = userInfoService.getByUsername(p.getName());\n\t\tMap<String, Map<String, String>> claimsForScopes = new HashMap<>();\n\t\tif (user != null) {\n\t\t\tJsonObject userJson = user.toJson();\n\n\t\t\tfor (SystemScope systemScope : sortedScopes) {\n\t\t\t\tMap<String, String> claimValues = new HashMap<>();\n\n\t\t\t\tSet<String> claims = scopeClaimTranslationService.getClaimsForScope(systemScope.getValue());\n\t\t\t\tfor (String claim : claims) {\n\t\t\t\t\tif (userJson.has(claim) && userJson.get(claim).isJsonPrimitive()) {\n\t\t\t\t\t\t// TODO: this skips the address claim\n\t\t\t\t\t\tclaimValues.put(claim, userJson.get(claim).getAsString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclaimsForScopes.put(systemScope.getValue(), claimValues);\n\t\t\t}\n\t\t}\n\n\t\tmodel.put(\"claims\", claimsForScopes);\n\n\t\t// client stats\n\t\tInteger count = statsService.getCountForClientId(client.getClientId()).getApprovedSiteCount();\n\t\tmodel.put(\"count\", count);\n\n\n\t\t// contacts\n\t\tif (client.getContacts() != null) {\n\t\t\tString contacts = Joiner.on(\", \").join(client.getContacts());\n\t\t\tmodel.put(\"contacts\", contacts);\n\t\t}\n\n\t\t// if the client is over a week old and has more than one registration, don't give such a big warning\n\t\t// instead, tag as \"Generally Recognized As Safe\" (gras)\n\t\tDate lastWeek = new Date(System.currentTimeMillis() - (60 * 60 * 24 * 7 * 1000));\n\t\tif (count > 1 && client.getCreatedAt() != null && client.getCreatedAt().before(lastWeek)) {\n\t\t\tmodel.put(\"gras\", true);\n\t\t} else {\n\t\t\tmodel.put(\"gras\", false);\n\t\t}\n\n\t\treturn \"approve\";\n\t}\n\n\t/**\n\t * @return the clientService\n\t */\n\tpublic ClientDetailsEntityService getClientService() {\n\t\treturn clientService;\n\t}\n\n\t/**\n\t * @param clientService the clientService to set\n\t */\n\tpublic void setClientService(ClientDetailsEntityService clientService) {\n\t\tthis.clientService = clientService;\n\t}\n\n\n}\n"], "fixing_code": ["/*******************************************************************************\n * Copyright 2018 The MIT Internet Trust Consortium\n *\n * Portions copyright 2011-2013 The MITRE Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *******************************************************************************/\n/**\n *\n */\npackage org.mitre.oauth2.web;\n\nimport static org.mitre.openid.connect.request.ConnectRequestParameters.PROMPT;\nimport static org.mitre.openid.connect.request.ConnectRequestParameters.PROMPT_SEPARATOR;\n\nimport java.net.URISyntaxException;\nimport java.security.Principal;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.http.client.utils.URIBuilder;\nimport org.mitre.oauth2.model.ClientDetailsEntity;\nimport org.mitre.oauth2.model.SystemScope;\nimport org.mitre.oauth2.service.ClientDetailsEntityService;\nimport org.mitre.oauth2.service.SystemScopeService;\nimport org.mitre.openid.connect.model.UserInfo;\nimport org.mitre.openid.connect.service.ScopeClaimTranslationService;\nimport org.mitre.openid.connect.service.StatsService;\nimport org.mitre.openid.connect.service.UserInfoService;\nimport org.mitre.openid.connect.view.HttpCodeView;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.security.access.prepost.PreAuthorize;\nimport org.springframework.security.oauth2.common.exceptions.OAuth2Exception;\nimport org.springframework.security.oauth2.provider.AuthorizationRequest;\nimport org.springframework.security.oauth2.provider.endpoint.RedirectResolver;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.SessionAttributes;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Sets;\nimport com.google.gson.JsonObject;\n\n/**\n * @author jricher\n *\n */\n@Controller\n@SessionAttributes(\"authorizationRequest\")\npublic class OAuthConfirmationController {\n\n\n\t@Autowired\n\tprivate ClientDetailsEntityService clientService;\n\n\t@Autowired\n\tprivate SystemScopeService scopeService;\n\n\t@Autowired\n\tprivate ScopeClaimTranslationService scopeClaimTranslationService;\n\n\t@Autowired\n\tprivate UserInfoService userInfoService;\n\n\t@Autowired\n\tprivate StatsService statsService;\n\n\t@Autowired\n\tprivate RedirectResolver redirectResolver;\n\n\t/**\n\t * Logger for this class\n\t */\n\tprivate static final Logger logger = LoggerFactory.getLogger(OAuthConfirmationController.class);\n\n\tpublic OAuthConfirmationController() {\n\n\t}\n\n\tpublic OAuthConfirmationController(ClientDetailsEntityService clientService) {\n\t\tthis.clientService = clientService;\n\t}\n\n\t@PreAuthorize(\"hasRole('ROLE_USER')\")\n\t@RequestMapping(\"/oauth/confirm_access\")\n\tpublic String confirmAccess(Map<String, Object> model, Principal p) {\n\n\t\tAuthorizationRequest authRequest = (AuthorizationRequest) model.get(\"authorizationRequest\");\n\t\t// Check the \"prompt\" parameter to see if we need to do special processing\n\n\t\tString prompt = (String)authRequest.getExtensions().get(PROMPT);\n\t\tList<String> prompts = Splitter.on(PROMPT_SEPARATOR).splitToList(Strings.nullToEmpty(prompt));\n\t\tClientDetailsEntity client = null;\n\n\t\ttry {\n\t\t\tclient = clientService.loadClientByClientId(authRequest.getClientId());\n\t\t} catch (OAuth2Exception e) {\n\t\t\tlogger.error(\"confirmAccess: OAuth2Exception was thrown when attempting to load client\", e);\n\t\t\tmodel.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\n\t\t\treturn HttpCodeView.VIEWNAME;\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tlogger.error(\"confirmAccess: IllegalArgumentException was thrown when attempting to load client\", e);\n\t\t\tmodel.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\n\t\t\treturn HttpCodeView.VIEWNAME;\n\t\t}\n\n\t\tif (client == null) {\n\t\t\tlogger.error(\"confirmAccess: could not find client \" + authRequest.getClientId());\n\t\t\tmodel.put(HttpCodeView.CODE, HttpStatus.NOT_FOUND);\n\t\t\treturn HttpCodeView.VIEWNAME;\n\t\t}\n\n\t\tif (prompts.contains(\"none\")) {\n\t\t\t// if we've got a redirect URI then we'll send it\n\n\t\t\tString url = redirectResolver.resolveRedirect(authRequest.getRedirectUri(), client);\n\n\t\t\ttry {\n\t\t\t\tURIBuilder uriBuilder = new URIBuilder(url);\n\n\t\t\t\turiBuilder.addParameter(\"error\", \"interaction_required\");\n\t\t\t\tif (!Strings.isNullOrEmpty(authRequest.getState())) {\n\t\t\t\t\turiBuilder.addParameter(\"state\", authRequest.getState()); // copy the state parameter if one was given\n\t\t\t\t}\n\n\t\t\t\treturn \"redirect:\" + uriBuilder.toString();\n\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tlogger.error(\"Can't build redirect URI for prompt=none, sending error instead\", e);\n\t\t\t\tmodel.put(\"code\", HttpStatus.FORBIDDEN);\n\t\t\t\treturn HttpCodeView.VIEWNAME;\n\t\t\t}\n\t\t}\n\n\t\tmodel.put(\"auth_request\", authRequest);\n\t\tmodel.put(\"client\", client);\n\n\t\tString redirect_uri = authRequest.getRedirectUri();\n\n\t\tmodel.put(\"redirect_uri\", redirect_uri);\n\n\n\t\t// pre-process the scopes\n\t\tSet<SystemScope> scopes = scopeService.fromStrings(authRequest.getScope());\n\n\t\tSet<SystemScope> sortedScopes = new LinkedHashSet<>(scopes.size());\n\t\tSet<SystemScope> systemScopes = scopeService.getAll();\n\n\t\t// sort scopes for display based on the inherent order of system scopes\n\t\tfor (SystemScope s : systemScopes) {\n\t\t\tif (scopes.contains(s)) {\n\t\t\t\tsortedScopes.add(s);\n\t\t\t}\n\t\t}\n\n\t\t// add in any scopes that aren't system scopes to the end of the list\n\t\tsortedScopes.addAll(Sets.difference(scopes, systemScopes));\n\n\t\tmodel.put(\"scopes\", sortedScopes);\n\n\t\t// get the userinfo claims for each scope\n\t\tUserInfo user = userInfoService.getByUsername(p.getName());\n\t\tMap<String, Map<String, String>> claimsForScopes = new HashMap<>();\n\t\tif (user != null) {\n\t\t\tJsonObject userJson = user.toJson();\n\n\t\t\tfor (SystemScope systemScope : sortedScopes) {\n\t\t\t\tMap<String, String> claimValues = new HashMap<>();\n\n\t\t\t\tSet<String> claims = scopeClaimTranslationService.getClaimsForScope(systemScope.getValue());\n\t\t\t\tfor (String claim : claims) {\n\t\t\t\t\tif (userJson.has(claim) && userJson.get(claim).isJsonPrimitive()) {\n\t\t\t\t\t\t// TODO: this skips the address claim\n\t\t\t\t\t\tclaimValues.put(claim, userJson.get(claim).getAsString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclaimsForScopes.put(systemScope.getValue(), claimValues);\n\t\t\t}\n\t\t}\n\n\t\tmodel.put(\"claims\", claimsForScopes);\n\n\t\t// client stats\n\t\tInteger count = statsService.getCountForClientId(client.getClientId()).getApprovedSiteCount();\n\t\tmodel.put(\"count\", count);\n\n\n\t\t// contacts\n\t\tif (client.getContacts() != null) {\n\t\t\tString contacts = Joiner.on(\", \").join(client.getContacts());\n\t\t\tmodel.put(\"contacts\", contacts);\n\t\t}\n\n\t\t// if the client is over a week old and has more than one registration, don't give such a big warning\n\t\t// instead, tag as \"Generally Recognized As Safe\" (gras)\n\t\tDate lastWeek = new Date(System.currentTimeMillis() - (60 * 60 * 24 * 7 * 1000));\n\t\tif (count > 1 && client.getCreatedAt() != null && client.getCreatedAt().before(lastWeek)) {\n\t\t\tmodel.put(\"gras\", true);\n\t\t} else {\n\t\t\tmodel.put(\"gras\", false);\n\t\t}\n\n\t\treturn \"approve\";\n\t}\n\n\t/**\n\t * @return the clientService\n\t */\n\tpublic ClientDetailsEntityService getClientService() {\n\t\treturn clientService;\n\t}\n\n\t/**\n\t * @param clientService the clientService to set\n\t */\n\tpublic void setClientService(ClientDetailsEntityService clientService) {\n\t\tthis.clientService = clientService;\n\t}\n\n\n}\n"], "filenames": ["openid-connect-server/src/main/java/org/mitre/oauth2/web/OAuthConfirmationController.java"], "buggy_code_start_loc": [106], "buggy_code_end_loc": [109], "fixing_code_start_loc": [106], "fixing_code_end_loc": [109], "type": "CWE-1321", "message": "org/mitre/oauth2/web/OAuthConfirmationController.java in the OpenID Connect server implementation for MITREid Connect through 1.3.3 contains a Mass Assignment (aka Autobinding) vulnerability. This arises due to unsafe usage of the @ModelAttribute annotation during the OAuth authorization flow, in which HTTP request parameters affect an authorizationRequest.", "other": {"cve": {"id": "CVE-2021-27582", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-23T18:15:14.363", "lastModified": "2022-12-02T19:37:41.227", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "org/mitre/oauth2/web/OAuthConfirmationController.java in the OpenID Connect server implementation for MITREid Connect through 1.3.3 contains a Mass Assignment (aka Autobinding) vulnerability. This arises due to unsafe usage of the @ModelAttribute annotation during the OAuth authorization flow, in which HTTP request parameters affect an authorizationRequest."}, {"lang": "es", "value": "El archivo org/mitre/oauth2/web/OAuthConfirmationController.java en la implementaci\u00f3n del servidor OpenID Connect para MITREid Connect versiones hasta 1.3.3, contiene una vulnerabilidad de Asignaci\u00f3n Masiva (tambi\u00e9n se conoce como Autobinding).&#xa0;Esto surge debido al uso no seguro de la anotaci\u00f3n @ModelAttribute durante el flujo de autorizaci\u00f3n de OAuth, en el que los par\u00e1metros de petici\u00f3n HTTP afectan a una autorizaci\u00f3n de petici\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mitreid:connect:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.3.3", "matchCriteriaId": "FC637AA4-26EF-4FB8-8608-6B658EBEDFF9"}]}]}], "references": [{"url": "http://agrrrdog.blogspot.com/2017/03/autobinding-vulns-and-spring-mvc.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/mitreid-connect/OpenID-Connect-Java-Spring-Server/commit/7eba3c12fed82388f917e8dd9b73e86e3a311e4c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://portswigger.net/research/hidden-oauth-attack-vectors", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mitreid-connect/OpenID-Connect-Java-Spring-Server/commit/7eba3c12fed82388f917e8dd9b73e86e3a311e4c"}}