{"buggy_code": ["package yaml\n\nimport (\n\t\"encoding\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n)\n\nconst (\n\tdocumentNode = 1 << iota\n\tmappingNode\n\tsequenceNode\n\tscalarNode\n\taliasNode\n)\n\ntype node struct {\n\tkind         int\n\tline, column int\n\ttag          string\n\t// For an alias node, alias holds the resolved alias.\n\talias    *node\n\tvalue    string\n\timplicit bool\n\tchildren []*node\n\tanchors  map[string]*node\n}\n\n// ----------------------------------------------------------------------------\n// Parser, produces a node tree out of a libyaml event stream.\n\ntype parser struct {\n\tparser   yaml_parser_t\n\tevent    yaml_event_t\n\tdoc      *node\n\tdoneInit bool\n}\n\nfunc newParser(b []byte) *parser {\n\tp := parser{}\n\tif !yaml_parser_initialize(&p.parser) {\n\t\tpanic(\"failed to initialize YAML emitter\")\n\t}\n\tif len(b) == 0 {\n\t\tb = []byte{'\\n'}\n\t}\n\tyaml_parser_set_input_string(&p.parser, b)\n\treturn &p\n}\n\nfunc newParserFromReader(r io.Reader) *parser {\n\tp := parser{}\n\tif !yaml_parser_initialize(&p.parser) {\n\t\tpanic(\"failed to initialize YAML emitter\")\n\t}\n\tyaml_parser_set_input_reader(&p.parser, r)\n\treturn &p\n}\n\nfunc (p *parser) init() {\n\tif p.doneInit {\n\t\treturn\n\t}\n\tp.expect(yaml_STREAM_START_EVENT)\n\tp.doneInit = true\n}\n\nfunc (p *parser) destroy() {\n\tif p.event.typ != yaml_NO_EVENT {\n\t\tyaml_event_delete(&p.event)\n\t}\n\tyaml_parser_delete(&p.parser)\n}\n\n// expect consumes an event from the event stream and\n// checks that it's of the expected type.\nfunc (p *parser) expect(e yaml_event_type_t) {\n\tif p.event.typ == yaml_NO_EVENT {\n\t\tif !yaml_parser_parse(&p.parser, &p.event) {\n\t\t\tp.fail()\n\t\t}\n\t}\n\tif p.event.typ == yaml_STREAM_END_EVENT {\n\t\tfailf(\"attempted to go past the end of stream; corrupted value?\")\n\t}\n\tif p.event.typ != e {\n\t\tp.parser.problem = fmt.Sprintf(\"expected %s event but got %s\", e, p.event.typ)\n\t\tp.fail()\n\t}\n\tyaml_event_delete(&p.event)\n\tp.event.typ = yaml_NO_EVENT\n}\n\n// peek peeks at the next event in the event stream,\n// puts the results into p.event and returns the event type.\nfunc (p *parser) peek() yaml_event_type_t {\n\tif p.event.typ != yaml_NO_EVENT {\n\t\treturn p.event.typ\n\t}\n\tif !yaml_parser_parse(&p.parser, &p.event) {\n\t\tp.fail()\n\t}\n\treturn p.event.typ\n}\n\nfunc (p *parser) fail() {\n\tvar where string\n\tvar line int\n\tif p.parser.problem_mark.line != 0 {\n\t\tline = p.parser.problem_mark.line\n\t\t// Scanner errors don't iterate line before returning error\n\t\tif p.parser.error == yaml_SCANNER_ERROR {\n\t\t\tline++\n\t\t}\n\t} else if p.parser.context_mark.line != 0 {\n\t\tline = p.parser.context_mark.line\n\t}\n\tif line != 0 {\n\t\twhere = \"line \" + strconv.Itoa(line) + \": \"\n\t}\n\tvar msg string\n\tif len(p.parser.problem) > 0 {\n\t\tmsg = p.parser.problem\n\t} else {\n\t\tmsg = \"unknown problem parsing YAML content\"\n\t}\n\tfailf(\"%s%s\", where, msg)\n}\n\nfunc (p *parser) anchor(n *node, anchor []byte) {\n\tif anchor != nil {\n\t\tp.doc.anchors[string(anchor)] = n\n\t}\n}\n\nfunc (p *parser) parse() *node {\n\tp.init()\n\tswitch p.peek() {\n\tcase yaml_SCALAR_EVENT:\n\t\treturn p.scalar()\n\tcase yaml_ALIAS_EVENT:\n\t\treturn p.alias()\n\tcase yaml_MAPPING_START_EVENT:\n\t\treturn p.mapping()\n\tcase yaml_SEQUENCE_START_EVENT:\n\t\treturn p.sequence()\n\tcase yaml_DOCUMENT_START_EVENT:\n\t\treturn p.document()\n\tcase yaml_STREAM_END_EVENT:\n\t\t// Happens when attempting to decode an empty buffer.\n\t\treturn nil\n\tdefault:\n\t\tpanic(\"attempted to parse unknown event: \" + p.event.typ.String())\n\t}\n}\n\nfunc (p *parser) node(kind int) *node {\n\treturn &node{\n\t\tkind:   kind,\n\t\tline:   p.event.start_mark.line,\n\t\tcolumn: p.event.start_mark.column,\n\t}\n}\n\nfunc (p *parser) document() *node {\n\tn := p.node(documentNode)\n\tn.anchors = make(map[string]*node)\n\tp.doc = n\n\tp.expect(yaml_DOCUMENT_START_EVENT)\n\tn.children = append(n.children, p.parse())\n\tp.expect(yaml_DOCUMENT_END_EVENT)\n\treturn n\n}\n\nfunc (p *parser) alias() *node {\n\tn := p.node(aliasNode)\n\tn.value = string(p.event.anchor)\n\tn.alias = p.doc.anchors[n.value]\n\tif n.alias == nil {\n\t\tfailf(\"unknown anchor '%s' referenced\", n.value)\n\t}\n\tp.expect(yaml_ALIAS_EVENT)\n\treturn n\n}\n\nfunc (p *parser) scalar() *node {\n\tn := p.node(scalarNode)\n\tn.value = string(p.event.value)\n\tn.tag = string(p.event.tag)\n\tn.implicit = p.event.implicit\n\tp.anchor(n, p.event.anchor)\n\tp.expect(yaml_SCALAR_EVENT)\n\treturn n\n}\n\nfunc (p *parser) sequence() *node {\n\tn := p.node(sequenceNode)\n\tp.anchor(n, p.event.anchor)\n\tp.expect(yaml_SEQUENCE_START_EVENT)\n\tfor p.peek() != yaml_SEQUENCE_END_EVENT {\n\t\tn.children = append(n.children, p.parse())\n\t}\n\tp.expect(yaml_SEQUENCE_END_EVENT)\n\treturn n\n}\n\nfunc (p *parser) mapping() *node {\n\tn := p.node(mappingNode)\n\tp.anchor(n, p.event.anchor)\n\tp.expect(yaml_MAPPING_START_EVENT)\n\tfor p.peek() != yaml_MAPPING_END_EVENT {\n\t\tn.children = append(n.children, p.parse(), p.parse())\n\t}\n\tp.expect(yaml_MAPPING_END_EVENT)\n\treturn n\n}\n\n// ----------------------------------------------------------------------------\n// Decoder, unmarshals a node into a provided value.\n\ntype decoder struct {\n\tdoc     *node\n\taliases map[*node]bool\n\tmapType reflect.Type\n\tterrors []string\n\tstrict  bool\n}\n\nvar (\n\tmapItemType    = reflect.TypeOf(MapItem{})\n\tdurationType   = reflect.TypeOf(time.Duration(0))\n\tdefaultMapType = reflect.TypeOf(map[interface{}]interface{}{})\n\tifaceType      = defaultMapType.Elem()\n\ttimeType       = reflect.TypeOf(time.Time{})\n\tptrTimeType    = reflect.TypeOf(&time.Time{})\n)\n\nfunc newDecoder(strict bool) *decoder {\n\td := &decoder{mapType: defaultMapType, strict: strict}\n\td.aliases = make(map[*node]bool)\n\treturn d\n}\n\nfunc (d *decoder) terror(n *node, tag string, out reflect.Value) {\n\tif n.tag != \"\" {\n\t\ttag = n.tag\n\t}\n\tvalue := n.value\n\tif tag != yaml_SEQ_TAG && tag != yaml_MAP_TAG {\n\t\tif len(value) > 10 {\n\t\t\tvalue = \" `\" + value[:7] + \"...`\"\n\t\t} else {\n\t\t\tvalue = \" `\" + value + \"`\"\n\t\t}\n\t}\n\td.terrors = append(d.terrors, fmt.Sprintf(\"line %d: cannot unmarshal %s%s into %s\", n.line+1, shortTag(tag), value, out.Type()))\n}\n\nfunc (d *decoder) callUnmarshaler(n *node, u Unmarshaler) (good bool) {\n\tterrlen := len(d.terrors)\n\terr := u.UnmarshalYAML(func(v interface{}) (err error) {\n\t\tdefer handleErr(&err)\n\t\td.unmarshal(n, reflect.ValueOf(v))\n\t\tif len(d.terrors) > terrlen {\n\t\t\tissues := d.terrors[terrlen:]\n\t\t\td.terrors = d.terrors[:terrlen]\n\t\t\treturn &TypeError{issues}\n\t\t}\n\t\treturn nil\n\t})\n\tif e, ok := err.(*TypeError); ok {\n\t\td.terrors = append(d.terrors, e.Errors...)\n\t\treturn false\n\t}\n\tif err != nil {\n\t\tfail(err)\n\t}\n\treturn true\n}\n\n// d.prepare initializes and dereferences pointers and calls UnmarshalYAML\n// if a value is found to implement it.\n// It returns the initialized and dereferenced out value, whether\n// unmarshalling was already done by UnmarshalYAML, and if so whether\n// its types unmarshalled appropriately.\n//\n// If n holds a null value, prepare returns before doing anything.\nfunc (d *decoder) prepare(n *node, out reflect.Value) (newout reflect.Value, unmarshaled, good bool) {\n\tif n.tag == yaml_NULL_TAG || n.kind == scalarNode && n.tag == \"\" && (n.value == \"null\" || n.value == \"~\" || n.value == \"\" && n.implicit) {\n\t\treturn out, false, false\n\t}\n\tagain := true\n\tfor again {\n\t\tagain = false\n\t\tif out.Kind() == reflect.Ptr {\n\t\t\tif out.IsNil() {\n\t\t\t\tout.Set(reflect.New(out.Type().Elem()))\n\t\t\t}\n\t\t\tout = out.Elem()\n\t\t\tagain = true\n\t\t}\n\t\tif out.CanAddr() {\n\t\t\tif u, ok := out.Addr().Interface().(Unmarshaler); ok {\n\t\t\t\tgood = d.callUnmarshaler(n, u)\n\t\t\t\treturn out, true, good\n\t\t\t}\n\t\t}\n\t}\n\treturn out, false, false\n}\n\nfunc (d *decoder) unmarshal(n *node, out reflect.Value) (good bool) {\n\tswitch n.kind {\n\tcase documentNode:\n\t\treturn d.document(n, out)\n\tcase aliasNode:\n\t\treturn d.alias(n, out)\n\t}\n\tout, unmarshaled, good := d.prepare(n, out)\n\tif unmarshaled {\n\t\treturn good\n\t}\n\tswitch n.kind {\n\tcase scalarNode:\n\t\tgood = d.scalar(n, out)\n\tcase mappingNode:\n\t\tgood = d.mapping(n, out)\n\tcase sequenceNode:\n\t\tgood = d.sequence(n, out)\n\tdefault:\n\t\tpanic(\"internal error: unknown node kind: \" + strconv.Itoa(n.kind))\n\t}\n\treturn good\n}\n\nfunc (d *decoder) document(n *node, out reflect.Value) (good bool) {\n\tif len(n.children) == 1 {\n\t\td.doc = n\n\t\td.unmarshal(n.children[0], out)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (d *decoder) alias(n *node, out reflect.Value) (good bool) {\n\tif d.aliases[n] {\n\t\t// TODO this could actually be allowed in some circumstances.\n\t\tfailf(\"anchor '%s' value contains itself\", n.value)\n\t}\n\td.aliases[n] = true\n\tgood = d.unmarshal(n.alias, out)\n\tdelete(d.aliases, n)\n\treturn good\n}\n\nvar zeroValue reflect.Value\n\nfunc resetMap(out reflect.Value) {\n\tfor _, k := range out.MapKeys() {\n\t\tout.SetMapIndex(k, zeroValue)\n\t}\n}\n\nfunc (d *decoder) scalar(n *node, out reflect.Value) bool {\n\tvar tag string\n\tvar resolved interface{}\n\tif n.tag == \"\" && !n.implicit {\n\t\ttag = yaml_STR_TAG\n\t\tresolved = n.value\n\t} else {\n\t\ttag, resolved = resolve(n.tag, n.value)\n\t\tif tag == yaml_BINARY_TAG {\n\t\t\tdata, err := base64.StdEncoding.DecodeString(resolved.(string))\n\t\t\tif err != nil {\n\t\t\t\tfailf(\"!!binary value contains invalid base64 data\")\n\t\t\t}\n\t\t\tresolved = string(data)\n\t\t}\n\t}\n\tif resolved == nil {\n\t\tif out.Kind() == reflect.Map && !out.CanAddr() {\n\t\t\tresetMap(out)\n\t\t} else {\n\t\t\tout.Set(reflect.Zero(out.Type()))\n\t\t}\n\t\treturn true\n\t}\n\tif resolvedv := reflect.ValueOf(resolved); out.Type() == resolvedv.Type() {\n\t\t// We've resolved to exactly the type we want, so use that.\n\t\tout.Set(resolvedv)\n\t\treturn true\n\t}\n\t// Perhaps we can use the value as a TextUnmarshaler to\n\t// set its value.\n\tif out.CanAddr() {\n\t\tu, ok := out.Addr().Interface().(encoding.TextUnmarshaler)\n\t\tif ok {\n\t\t\tvar text []byte\n\t\t\tif tag == yaml_BINARY_TAG {\n\t\t\t\ttext = []byte(resolved.(string))\n\t\t\t} else {\n\t\t\t\t// We let any value be unmarshaled into TextUnmarshaler.\n\t\t\t\t// That might be more lax than we'd like, but the\n\t\t\t\t// TextUnmarshaler itself should bowl out any dubious values.\n\t\t\t\ttext = []byte(n.value)\n\t\t\t}\n\t\t\terr := u.UnmarshalText(text)\n\t\t\tif err != nil {\n\t\t\t\tfail(err)\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t}\n\tswitch out.Kind() {\n\tcase reflect.String:\n\t\tif tag == yaml_BINARY_TAG {\n\t\t\tout.SetString(resolved.(string))\n\t\t\treturn true\n\t\t}\n\t\tif resolved != nil {\n\t\t\tout.SetString(n.value)\n\t\t\treturn true\n\t\t}\n\tcase reflect.Interface:\n\t\tif resolved == nil {\n\t\t\tout.Set(reflect.Zero(out.Type()))\n\t\t} else if tag == yaml_TIMESTAMP_TAG {\n\t\t\t// It looks like a timestamp but for backward compatibility\n\t\t\t// reasons we set it as a string, so that code that unmarshals\n\t\t\t// timestamp-like values into interface{} will continue to\n\t\t\t// see a string and not a time.Time.\n\t\t\t// TODO(v3) Drop this.\n\t\t\tout.Set(reflect.ValueOf(n.value))\n\t\t} else {\n\t\t\tout.Set(reflect.ValueOf(resolved))\n\t\t}\n\t\treturn true\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tswitch resolved := resolved.(type) {\n\t\tcase int:\n\t\t\tif !out.OverflowInt(int64(resolved)) {\n\t\t\t\tout.SetInt(int64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase int64:\n\t\t\tif !out.OverflowInt(resolved) {\n\t\t\t\tout.SetInt(resolved)\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase uint64:\n\t\t\tif resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {\n\t\t\t\tout.SetInt(int64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase float64:\n\t\t\tif resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {\n\t\t\t\tout.SetInt(int64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase string:\n\t\t\tif out.Type() == durationType {\n\t\t\t\td, err := time.ParseDuration(resolved)\n\t\t\t\tif err == nil {\n\t\t\t\t\tout.SetInt(int64(d))\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tswitch resolved := resolved.(type) {\n\t\tcase int:\n\t\t\tif resolved >= 0 && !out.OverflowUint(uint64(resolved)) {\n\t\t\t\tout.SetUint(uint64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase int64:\n\t\t\tif resolved >= 0 && !out.OverflowUint(uint64(resolved)) {\n\t\t\t\tout.SetUint(uint64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase uint64:\n\t\t\tif !out.OverflowUint(uint64(resolved)) {\n\t\t\t\tout.SetUint(uint64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase float64:\n\t\t\tif resolved <= math.MaxUint64 && !out.OverflowUint(uint64(resolved)) {\n\t\t\t\tout.SetUint(uint64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase reflect.Bool:\n\t\tswitch resolved := resolved.(type) {\n\t\tcase bool:\n\t\t\tout.SetBool(resolved)\n\t\t\treturn true\n\t\t}\n\tcase reflect.Float32, reflect.Float64:\n\t\tswitch resolved := resolved.(type) {\n\t\tcase int:\n\t\t\tout.SetFloat(float64(resolved))\n\t\t\treturn true\n\t\tcase int64:\n\t\t\tout.SetFloat(float64(resolved))\n\t\t\treturn true\n\t\tcase uint64:\n\t\t\tout.SetFloat(float64(resolved))\n\t\t\treturn true\n\t\tcase float64:\n\t\t\tout.SetFloat(resolved)\n\t\t\treturn true\n\t\t}\n\tcase reflect.Struct:\n\t\tif resolvedv := reflect.ValueOf(resolved); out.Type() == resolvedv.Type() {\n\t\t\tout.Set(resolvedv)\n\t\t\treturn true\n\t\t}\n\tcase reflect.Ptr:\n\t\tif out.Type().Elem() == reflect.TypeOf(resolved) {\n\t\t\t// TODO DOes this make sense? When is out a Ptr except when decoding a nil value?\n\t\t\telem := reflect.New(out.Type().Elem())\n\t\t\telem.Elem().Set(reflect.ValueOf(resolved))\n\t\t\tout.Set(elem)\n\t\t\treturn true\n\t\t}\n\t}\n\td.terror(n, tag, out)\n\treturn false\n}\n\nfunc settableValueOf(i interface{}) reflect.Value {\n\tv := reflect.ValueOf(i)\n\tsv := reflect.New(v.Type()).Elem()\n\tsv.Set(v)\n\treturn sv\n}\n\nfunc (d *decoder) sequence(n *node, out reflect.Value) (good bool) {\n\tl := len(n.children)\n\n\tvar iface reflect.Value\n\tswitch out.Kind() {\n\tcase reflect.Slice:\n\t\tout.Set(reflect.MakeSlice(out.Type(), l, l))\n\tcase reflect.Array:\n\t\tif l != out.Len() {\n\t\t\tfailf(\"invalid array: want %d elements but got %d\", out.Len(), l)\n\t\t}\n\tcase reflect.Interface:\n\t\t// No type hints. Will have to use a generic sequence.\n\t\tiface = out\n\t\tout = settableValueOf(make([]interface{}, l))\n\tdefault:\n\t\td.terror(n, yaml_SEQ_TAG, out)\n\t\treturn false\n\t}\n\tet := out.Type().Elem()\n\n\tj := 0\n\tfor i := 0; i < l; i++ {\n\t\te := reflect.New(et).Elem()\n\t\tif ok := d.unmarshal(n.children[i], e); ok {\n\t\t\tout.Index(j).Set(e)\n\t\t\tj++\n\t\t}\n\t}\n\tif out.Kind() != reflect.Array {\n\t\tout.Set(out.Slice(0, j))\n\t}\n\tif iface.IsValid() {\n\t\tiface.Set(out)\n\t}\n\treturn true\n}\n\nfunc (d *decoder) mapping(n *node, out reflect.Value) (good bool) {\n\tswitch out.Kind() {\n\tcase reflect.Struct:\n\t\treturn d.mappingStruct(n, out)\n\tcase reflect.Slice:\n\t\treturn d.mappingSlice(n, out)\n\tcase reflect.Map:\n\t\t// okay\n\tcase reflect.Interface:\n\t\tif d.mapType.Kind() == reflect.Map {\n\t\t\tiface := out\n\t\t\tout = reflect.MakeMap(d.mapType)\n\t\t\tiface.Set(out)\n\t\t} else {\n\t\t\tslicev := reflect.New(d.mapType).Elem()\n\t\t\tif !d.mappingSlice(n, slicev) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tout.Set(slicev)\n\t\t\treturn true\n\t\t}\n\tdefault:\n\t\td.terror(n, yaml_MAP_TAG, out)\n\t\treturn false\n\t}\n\toutt := out.Type()\n\tkt := outt.Key()\n\tet := outt.Elem()\n\n\tmapType := d.mapType\n\tif outt.Key() == ifaceType && outt.Elem() == ifaceType {\n\t\td.mapType = outt\n\t}\n\n\tif out.IsNil() {\n\t\tout.Set(reflect.MakeMap(outt))\n\t}\n\tl := len(n.children)\n\tfor i := 0; i < l; i += 2 {\n\t\tif isMerge(n.children[i]) {\n\t\t\td.merge(n.children[i+1], out)\n\t\t\tcontinue\n\t\t}\n\t\tk := reflect.New(kt).Elem()\n\t\tif d.unmarshal(n.children[i], k) {\n\t\t\tkkind := k.Kind()\n\t\t\tif kkind == reflect.Interface {\n\t\t\t\tkkind = k.Elem().Kind()\n\t\t\t}\n\t\t\tif kkind == reflect.Map || kkind == reflect.Slice {\n\t\t\t\tfailf(\"invalid map key: %#v\", k.Interface())\n\t\t\t}\n\t\t\te := reflect.New(et).Elem()\n\t\t\tif d.unmarshal(n.children[i+1], e) {\n\t\t\t\td.setMapIndex(n.children[i+1], out, k, e)\n\t\t\t}\n\t\t}\n\t}\n\td.mapType = mapType\n\treturn true\n}\n\nfunc (d *decoder) setMapIndex(n *node, out, k, v reflect.Value) {\n\tif d.strict && out.MapIndex(k) != zeroValue {\n\t\td.terrors = append(d.terrors, fmt.Sprintf(\"line %d: key %#v already set in map\", n.line+1, k.Interface()))\n\t\treturn\n\t}\n\tout.SetMapIndex(k, v)\n}\n\nfunc (d *decoder) mappingSlice(n *node, out reflect.Value) (good bool) {\n\toutt := out.Type()\n\tif outt.Elem() != mapItemType {\n\t\td.terror(n, yaml_MAP_TAG, out)\n\t\treturn false\n\t}\n\n\tmapType := d.mapType\n\td.mapType = outt\n\n\tvar slice []MapItem\n\tvar l = len(n.children)\n\tfor i := 0; i < l; i += 2 {\n\t\tif isMerge(n.children[i]) {\n\t\t\td.merge(n.children[i+1], out)\n\t\t\tcontinue\n\t\t}\n\t\titem := MapItem{}\n\t\tk := reflect.ValueOf(&item.Key).Elem()\n\t\tif d.unmarshal(n.children[i], k) {\n\t\t\tv := reflect.ValueOf(&item.Value).Elem()\n\t\t\tif d.unmarshal(n.children[i+1], v) {\n\t\t\t\tslice = append(slice, item)\n\t\t\t}\n\t\t}\n\t}\n\tout.Set(reflect.ValueOf(slice))\n\td.mapType = mapType\n\treturn true\n}\n\nfunc (d *decoder) mappingStruct(n *node, out reflect.Value) (good bool) {\n\tsinfo, err := getStructInfo(out.Type())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tname := settableValueOf(\"\")\n\tl := len(n.children)\n\n\tvar inlineMap reflect.Value\n\tvar elemType reflect.Type\n\tif sinfo.InlineMap != -1 {\n\t\tinlineMap = out.Field(sinfo.InlineMap)\n\t\tinlineMap.Set(reflect.New(inlineMap.Type()).Elem())\n\t\telemType = inlineMap.Type().Elem()\n\t}\n\n\tvar doneFields []bool\n\tif d.strict {\n\t\tdoneFields = make([]bool, len(sinfo.FieldsList))\n\t}\n\tfor i := 0; i < l; i += 2 {\n\t\tni := n.children[i]\n\t\tif isMerge(ni) {\n\t\t\td.merge(n.children[i+1], out)\n\t\t\tcontinue\n\t\t}\n\t\tif !d.unmarshal(ni, name) {\n\t\t\tcontinue\n\t\t}\n\t\tif info, ok := sinfo.FieldsMap[name.String()]; ok {\n\t\t\tif d.strict {\n\t\t\t\tif doneFields[info.Id] {\n\t\t\t\t\td.terrors = append(d.terrors, fmt.Sprintf(\"line %d: field %s already set in type %s\", ni.line+1, name.String(), out.Type()))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdoneFields[info.Id] = true\n\t\t\t}\n\t\t\tvar field reflect.Value\n\t\t\tif info.Inline == nil {\n\t\t\t\tfield = out.Field(info.Num)\n\t\t\t} else {\n\t\t\t\tfield = out.FieldByIndex(info.Inline)\n\t\t\t}\n\t\t\td.unmarshal(n.children[i+1], field)\n\t\t} else if sinfo.InlineMap != -1 {\n\t\t\tif inlineMap.IsNil() {\n\t\t\t\tinlineMap.Set(reflect.MakeMap(inlineMap.Type()))\n\t\t\t}\n\t\t\tvalue := reflect.New(elemType).Elem()\n\t\t\td.unmarshal(n.children[i+1], value)\n\t\t\td.setMapIndex(n.children[i+1], inlineMap, name, value)\n\t\t} else if d.strict {\n\t\t\td.terrors = append(d.terrors, fmt.Sprintf(\"line %d: field %s not found in type %s\", ni.line+1, name.String(), out.Type()))\n\t\t}\n\t}\n\treturn true\n}\n\nfunc failWantMap() {\n\tfailf(\"map merge requires map or sequence of maps as the value\")\n}\n\nfunc (d *decoder) merge(n *node, out reflect.Value) {\n\tswitch n.kind {\n\tcase mappingNode:\n\t\td.unmarshal(n, out)\n\tcase aliasNode:\n\t\tan, ok := d.doc.anchors[n.value]\n\t\tif ok && an.kind != mappingNode {\n\t\t\tfailWantMap()\n\t\t}\n\t\td.unmarshal(n, out)\n\tcase sequenceNode:\n\t\t// Step backwards as earlier nodes take precedence.\n\t\tfor i := len(n.children) - 1; i >= 0; i-- {\n\t\t\tni := n.children[i]\n\t\t\tif ni.kind == aliasNode {\n\t\t\t\tan, ok := d.doc.anchors[ni.value]\n\t\t\t\tif ok && an.kind != mappingNode {\n\t\t\t\t\tfailWantMap()\n\t\t\t\t}\n\t\t\t} else if ni.kind != mappingNode {\n\t\t\t\tfailWantMap()\n\t\t\t}\n\t\t\td.unmarshal(ni, out)\n\t\t}\n\tdefault:\n\t\tfailWantMap()\n\t}\n}\n\nfunc isMerge(n *node) bool {\n\treturn n.kind == scalarNode && n.value == \"<<\" && (n.implicit == true || n.tag == yaml_MERGE_TAG)\n}\n", "package yaml_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t. \"gopkg.in/check.v1\"\n\t\"gopkg.in/yaml.v2\"\n)\n\nvar unmarshalIntTest = 123\n\nvar unmarshalTests = []struct {\n\tdata  string\n\tvalue interface{}\n}{\n\t{\n\t\t\"\",\n\t\t(*struct{})(nil),\n\t},\n\t{\n\t\t\"{}\", &struct{}{},\n\t}, {\n\t\t\"v: hi\",\n\t\tmap[string]string{\"v\": \"hi\"},\n\t}, {\n\t\t\"v: hi\", map[string]interface{}{\"v\": \"hi\"},\n\t}, {\n\t\t\"v: true\",\n\t\tmap[string]string{\"v\": \"true\"},\n\t}, {\n\t\t\"v: true\",\n\t\tmap[string]interface{}{\"v\": true},\n\t}, {\n\t\t\"v: 10\",\n\t\tmap[string]interface{}{\"v\": 10},\n\t}, {\n\t\t\"v: 0b10\",\n\t\tmap[string]interface{}{\"v\": 2},\n\t}, {\n\t\t\"v: 0xA\",\n\t\tmap[string]interface{}{\"v\": 10},\n\t}, {\n\t\t\"v: 4294967296\",\n\t\tmap[string]int64{\"v\": 4294967296},\n\t}, {\n\t\t\"v: 0.1\",\n\t\tmap[string]interface{}{\"v\": 0.1},\n\t}, {\n\t\t\"v: .1\",\n\t\tmap[string]interface{}{\"v\": 0.1},\n\t}, {\n\t\t\"v: .Inf\",\n\t\tmap[string]interface{}{\"v\": math.Inf(+1)},\n\t}, {\n\t\t\"v: -.Inf\",\n\t\tmap[string]interface{}{\"v\": math.Inf(-1)},\n\t}, {\n\t\t\"v: -10\",\n\t\tmap[string]interface{}{\"v\": -10},\n\t}, {\n\t\t\"v: -.1\",\n\t\tmap[string]interface{}{\"v\": -0.1},\n\t},\n\n\t// Simple values.\n\t{\n\t\t\"123\",\n\t\t&unmarshalIntTest,\n\t},\n\n\t// Floats from spec\n\t{\n\t\t\"canonical: 6.8523e+5\",\n\t\tmap[string]interface{}{\"canonical\": 6.8523e+5},\n\t}, {\n\t\t\"expo: 685.230_15e+03\",\n\t\tmap[string]interface{}{\"expo\": 685.23015e+03},\n\t}, {\n\t\t\"fixed: 685_230.15\",\n\t\tmap[string]interface{}{\"fixed\": 685230.15},\n\t}, {\n\t\t\"neginf: -.inf\",\n\t\tmap[string]interface{}{\"neginf\": math.Inf(-1)},\n\t}, {\n\t\t\"fixed: 685_230.15\",\n\t\tmap[string]float64{\"fixed\": 685230.15},\n\t},\n\t//{\"sexa: 190:20:30.15\", map[string]interface{}{\"sexa\": 0}}, // Unsupported\n\t//{\"notanum: .NaN\", map[string]interface{}{\"notanum\": math.NaN()}}, // Equality of NaN fails.\n\n\t// Bools from spec\n\t{\n\t\t\"canonical: y\",\n\t\tmap[string]interface{}{\"canonical\": true},\n\t}, {\n\t\t\"answer: NO\",\n\t\tmap[string]interface{}{\"answer\": false},\n\t}, {\n\t\t\"logical: True\",\n\t\tmap[string]interface{}{\"logical\": true},\n\t}, {\n\t\t\"option: on\",\n\t\tmap[string]interface{}{\"option\": true},\n\t}, {\n\t\t\"option: on\",\n\t\tmap[string]bool{\"option\": true},\n\t},\n\t// Ints from spec\n\t{\n\t\t\"canonical: 685230\",\n\t\tmap[string]interface{}{\"canonical\": 685230},\n\t}, {\n\t\t\"decimal: +685_230\",\n\t\tmap[string]interface{}{\"decimal\": 685230},\n\t}, {\n\t\t\"octal: 02472256\",\n\t\tmap[string]interface{}{\"octal\": 685230},\n\t}, {\n\t\t\"hexa: 0x_0A_74_AE\",\n\t\tmap[string]interface{}{\"hexa\": 685230},\n\t}, {\n\t\t\"bin: 0b1010_0111_0100_1010_1110\",\n\t\tmap[string]interface{}{\"bin\": 685230},\n\t}, {\n\t\t\"bin: -0b101010\",\n\t\tmap[string]interface{}{\"bin\": -42},\n\t}, {\n\t\t\"bin: -0b1000000000000000000000000000000000000000000000000000000000000000\",\n\t\tmap[string]interface{}{\"bin\": -9223372036854775808},\n\t}, {\n\t\t\"decimal: +685_230\",\n\t\tmap[string]int{\"decimal\": 685230},\n\t},\n\n\t//{\"sexa: 190:20:30\", map[string]interface{}{\"sexa\": 0}}, // Unsupported\n\n\t// Nulls from spec\n\t{\n\t\t\"empty:\",\n\t\tmap[string]interface{}{\"empty\": nil},\n\t}, {\n\t\t\"canonical: ~\",\n\t\tmap[string]interface{}{\"canonical\": nil},\n\t}, {\n\t\t\"english: null\",\n\t\tmap[string]interface{}{\"english\": nil},\n\t}, {\n\t\t\"~: null key\",\n\t\tmap[interface{}]string{nil: \"null key\"},\n\t}, {\n\t\t\"empty:\",\n\t\tmap[string]*bool{\"empty\": nil},\n\t},\n\n\t// Flow sequence\n\t{\n\t\t\"seq: [A,B]\",\n\t\tmap[string]interface{}{\"seq\": []interface{}{\"A\", \"B\"}},\n\t}, {\n\t\t\"seq: [A,B,C,]\",\n\t\tmap[string][]string{\"seq\": []string{\"A\", \"B\", \"C\"}},\n\t}, {\n\t\t\"seq: [A,1,C]\",\n\t\tmap[string][]string{\"seq\": []string{\"A\", \"1\", \"C\"}},\n\t}, {\n\t\t\"seq: [A,1,C]\",\n\t\tmap[string][]int{\"seq\": []int{1}},\n\t}, {\n\t\t\"seq: [A,1,C]\",\n\t\tmap[string]interface{}{\"seq\": []interface{}{\"A\", 1, \"C\"}},\n\t},\n\t// Block sequence\n\t{\n\t\t\"seq:\\n - A\\n - B\",\n\t\tmap[string]interface{}{\"seq\": []interface{}{\"A\", \"B\"}},\n\t}, {\n\t\t\"seq:\\n - A\\n - B\\n - C\",\n\t\tmap[string][]string{\"seq\": []string{\"A\", \"B\", \"C\"}},\n\t}, {\n\t\t\"seq:\\n - A\\n - 1\\n - C\",\n\t\tmap[string][]string{\"seq\": []string{\"A\", \"1\", \"C\"}},\n\t}, {\n\t\t\"seq:\\n - A\\n - 1\\n - C\",\n\t\tmap[string][]int{\"seq\": []int{1}},\n\t}, {\n\t\t\"seq:\\n - A\\n - 1\\n - C\",\n\t\tmap[string]interface{}{\"seq\": []interface{}{\"A\", 1, \"C\"}},\n\t},\n\n\t// Literal block scalar\n\t{\n\t\t\"scalar: | # Comment\\n\\n literal\\n\\n \\ttext\\n\\n\",\n\t\tmap[string]string{\"scalar\": \"\\nliteral\\n\\n\\ttext\\n\"},\n\t},\n\n\t// Folded block scalar\n\t{\n\t\t\"scalar: > # Comment\\n\\n folded\\n line\\n \\n next\\n line\\n  * one\\n  * two\\n\\n last\\n line\\n\\n\",\n\t\tmap[string]string{\"scalar\": \"\\nfolded line\\nnext line\\n * one\\n * two\\n\\nlast line\\n\"},\n\t},\n\n\t// Map inside interface with no type hints.\n\t{\n\t\t\"a: {b: c}\",\n\t\tmap[interface{}]interface{}{\"a\": map[interface{}]interface{}{\"b\": \"c\"}},\n\t},\n\n\t// Structs and type conversions.\n\t{\n\t\t\"hello: world\",\n\t\t&struct{ Hello string }{\"world\"},\n\t}, {\n\t\t\"a: {b: c}\",\n\t\t&struct{ A struct{ B string } }{struct{ B string }{\"c\"}},\n\t}, {\n\t\t\"a: {b: c}\",\n\t\t&struct{ A *struct{ B string } }{&struct{ B string }{\"c\"}},\n\t}, {\n\t\t\"a: {b: c}\",\n\t\t&struct{ A map[string]string }{map[string]string{\"b\": \"c\"}},\n\t}, {\n\t\t\"a: {b: c}\",\n\t\t&struct{ A *map[string]string }{&map[string]string{\"b\": \"c\"}},\n\t}, {\n\t\t\"a:\",\n\t\t&struct{ A map[string]string }{},\n\t}, {\n\t\t\"a: 1\",\n\t\t&struct{ A int }{1},\n\t}, {\n\t\t\"a: 1\",\n\t\t&struct{ A float64 }{1},\n\t}, {\n\t\t\"a: 1.0\",\n\t\t&struct{ A int }{1},\n\t}, {\n\t\t\"a: 1.0\",\n\t\t&struct{ A uint }{1},\n\t}, {\n\t\t\"a: [1, 2]\",\n\t\t&struct{ A []int }{[]int{1, 2}},\n\t}, {\n\t\t\"a: [1, 2]\",\n\t\t&struct{ A [2]int }{[2]int{1, 2}},\n\t}, {\n\t\t\"a: 1\",\n\t\t&struct{ B int }{0},\n\t}, {\n\t\t\"a: 1\",\n\t\t&struct {\n\t\t\tB int \"a\"\n\t\t}{1},\n\t}, {\n\t\t\"a: y\",\n\t\t&struct{ A bool }{true},\n\t},\n\n\t// Some cross type conversions\n\t{\n\t\t\"v: 42\",\n\t\tmap[string]uint{\"v\": 42},\n\t}, {\n\t\t\"v: -42\",\n\t\tmap[string]uint{},\n\t}, {\n\t\t\"v: 4294967296\",\n\t\tmap[string]uint64{\"v\": 4294967296},\n\t}, {\n\t\t\"v: -4294967296\",\n\t\tmap[string]uint64{},\n\t},\n\n\t// int\n\t{\n\t\t\"int_max: 2147483647\",\n\t\tmap[string]int{\"int_max\": math.MaxInt32},\n\t},\n\t{\n\t\t\"int_min: -2147483648\",\n\t\tmap[string]int{\"int_min\": math.MinInt32},\n\t},\n\t{\n\t\t\"int_overflow: 9223372036854775808\", // math.MaxInt64 + 1\n\t\tmap[string]int{},\n\t},\n\n\t// int64\n\t{\n\t\t\"int64_max: 9223372036854775807\",\n\t\tmap[string]int64{\"int64_max\": math.MaxInt64},\n\t},\n\t{\n\t\t\"int64_max_base2: 0b111111111111111111111111111111111111111111111111111111111111111\",\n\t\tmap[string]int64{\"int64_max_base2\": math.MaxInt64},\n\t},\n\t{\n\t\t\"int64_min: -9223372036854775808\",\n\t\tmap[string]int64{\"int64_min\": math.MinInt64},\n\t},\n\t{\n\t\t\"int64_neg_base2: -0b111111111111111111111111111111111111111111111111111111111111111\",\n\t\tmap[string]int64{\"int64_neg_base2\": -math.MaxInt64},\n\t},\n\t{\n\t\t\"int64_overflow: 9223372036854775808\", // math.MaxInt64 + 1\n\t\tmap[string]int64{},\n\t},\n\n\t// uint\n\t{\n\t\t\"uint_min: 0\",\n\t\tmap[string]uint{\"uint_min\": 0},\n\t},\n\t{\n\t\t\"uint_max: 4294967295\",\n\t\tmap[string]uint{\"uint_max\": math.MaxUint32},\n\t},\n\t{\n\t\t\"uint_underflow: -1\",\n\t\tmap[string]uint{},\n\t},\n\n\t// uint64\n\t{\n\t\t\"uint64_min: 0\",\n\t\tmap[string]uint{\"uint64_min\": 0},\n\t},\n\t{\n\t\t\"uint64_max: 18446744073709551615\",\n\t\tmap[string]uint64{\"uint64_max\": math.MaxUint64},\n\t},\n\t{\n\t\t\"uint64_max_base2: 0b1111111111111111111111111111111111111111111111111111111111111111\",\n\t\tmap[string]uint64{\"uint64_max_base2\": math.MaxUint64},\n\t},\n\t{\n\t\t\"uint64_maxint64: 9223372036854775807\",\n\t\tmap[string]uint64{\"uint64_maxint64\": math.MaxInt64},\n\t},\n\t{\n\t\t\"uint64_underflow: -1\",\n\t\tmap[string]uint64{},\n\t},\n\n\t// float32\n\t{\n\t\t\"float32_max: 3.40282346638528859811704183484516925440e+38\",\n\t\tmap[string]float32{\"float32_max\": math.MaxFloat32},\n\t},\n\t{\n\t\t\"float32_nonzero: 1.401298464324817070923729583289916131280e-45\",\n\t\tmap[string]float32{\"float32_nonzero\": math.SmallestNonzeroFloat32},\n\t},\n\t{\n\t\t\"float32_maxuint64: 18446744073709551615\",\n\t\tmap[string]float32{\"float32_maxuint64\": float32(math.MaxUint64)},\n\t},\n\t{\n\t\t\"float32_maxuint64+1: 18446744073709551616\",\n\t\tmap[string]float32{\"float32_maxuint64+1\": float32(math.MaxUint64 + 1)},\n\t},\n\n\t// float64\n\t{\n\t\t\"float64_max: 1.797693134862315708145274237317043567981e+308\",\n\t\tmap[string]float64{\"float64_max\": math.MaxFloat64},\n\t},\n\t{\n\t\t\"float64_nonzero: 4.940656458412465441765687928682213723651e-324\",\n\t\tmap[string]float64{\"float64_nonzero\": math.SmallestNonzeroFloat64},\n\t},\n\t{\n\t\t\"float64_maxuint64: 18446744073709551615\",\n\t\tmap[string]float64{\"float64_maxuint64\": float64(math.MaxUint64)},\n\t},\n\t{\n\t\t\"float64_maxuint64+1: 18446744073709551616\",\n\t\tmap[string]float64{\"float64_maxuint64+1\": float64(math.MaxUint64 + 1)},\n\t},\n\n\t// Overflow cases.\n\t{\n\t\t\"v: 4294967297\",\n\t\tmap[string]int32{},\n\t}, {\n\t\t\"v: 128\",\n\t\tmap[string]int8{},\n\t},\n\n\t// Quoted values.\n\t{\n\t\t\"'1': '\\\"2\\\"'\",\n\t\tmap[interface{}]interface{}{\"1\": \"\\\"2\\\"\"},\n\t}, {\n\t\t\"v:\\n- A\\n- 'B\\n\\n  C'\\n\",\n\t\tmap[string][]string{\"v\": []string{\"A\", \"B\\nC\"}},\n\t},\n\n\t// Explicit tags.\n\t{\n\t\t\"v: !!float '1.1'\",\n\t\tmap[string]interface{}{\"v\": 1.1},\n\t}, {\n\t\t\"v: !!float 0\",\n\t\tmap[string]interface{}{\"v\": float64(0)},\n\t}, {\n\t\t\"v: !!float -1\",\n\t\tmap[string]interface{}{\"v\": float64(-1)},\n\t}, {\n\t\t\"v: !!null ''\",\n\t\tmap[string]interface{}{\"v\": nil},\n\t}, {\n\t\t\"%TAG !y! tag:yaml.org,2002:\\n---\\nv: !y!int '1'\",\n\t\tmap[string]interface{}{\"v\": 1},\n\t},\n\n\t// Non-specific tag (Issue #75)\n\t{\n\t\t\"v: ! test\",\n\t\tmap[string]interface{}{\"v\": \"test\"},\n\t},\n\n\t// Anchors and aliases.\n\t{\n\t\t\"a: &x 1\\nb: &y 2\\nc: *x\\nd: *y\\n\",\n\t\t&struct{ A, B, C, D int }{1, 2, 1, 2},\n\t}, {\n\t\t\"a: &a {c: 1}\\nb: *a\",\n\t\t&struct {\n\t\t\tA, B struct {\n\t\t\t\tC int\n\t\t\t}\n\t\t}{struct{ C int }{1}, struct{ C int }{1}},\n\t}, {\n\t\t\"a: &a [1, 2]\\nb: *a\",\n\t\t&struct{ B []int }{[]int{1, 2}},\n\t},\n\n\t// Bug #1133337\n\t{\n\t\t\"foo: ''\",\n\t\tmap[string]*string{\"foo\": new(string)},\n\t}, {\n\t\t\"foo: null\",\n\t\tmap[string]*string{\"foo\": nil},\n\t}, {\n\t\t\"foo: null\",\n\t\tmap[string]string{\"foo\": \"\"},\n\t}, {\n\t\t\"foo: null\",\n\t\tmap[string]interface{}{\"foo\": nil},\n\t},\n\n\t// Support for ~\n\t{\n\t\t\"foo: ~\",\n\t\tmap[string]*string{\"foo\": nil},\n\t}, {\n\t\t\"foo: ~\",\n\t\tmap[string]string{\"foo\": \"\"},\n\t}, {\n\t\t\"foo: ~\",\n\t\tmap[string]interface{}{\"foo\": nil},\n\t},\n\n\t// Ignored field\n\t{\n\t\t\"a: 1\\nb: 2\\n\",\n\t\t&struct {\n\t\t\tA int\n\t\t\tB int \"-\"\n\t\t}{1, 0},\n\t},\n\n\t// Bug #1191981\n\t{\n\t\t\"\" +\n\t\t\t\"%YAML 1.1\\n\" +\n\t\t\t\"--- !!str\\n\" +\n\t\t\t`\"Generic line break (no glyph)\\n\\` + \"\\n\" +\n\t\t\t` Generic line break (glyphed)\\n\\` + \"\\n\" +\n\t\t\t` Line separator\\u2028\\` + \"\\n\" +\n\t\t\t` Paragraph separator\\u2029\"` + \"\\n\",\n\t\t\"\" +\n\t\t\t\"Generic line break (no glyph)\\n\" +\n\t\t\t\"Generic line break (glyphed)\\n\" +\n\t\t\t\"Line separator\\u2028Paragraph separator\\u2029\",\n\t},\n\n\t// Struct inlining\n\t{\n\t\t\"a: 1\\nb: 2\\nc: 3\\n\",\n\t\t&struct {\n\t\t\tA int\n\t\t\tC inlineB `yaml:\",inline\"`\n\t\t}{1, inlineB{2, inlineC{3}}},\n\t},\n\n\t// Map inlining\n\t{\n\t\t\"a: 1\\nb: 2\\nc: 3\\n\",\n\t\t&struct {\n\t\t\tA int\n\t\t\tC map[string]int `yaml:\",inline\"`\n\t\t}{1, map[string]int{\"b\": 2, \"c\": 3}},\n\t},\n\n\t// bug 1243827\n\t{\n\t\t\"a: -b_c\",\n\t\tmap[string]interface{}{\"a\": \"-b_c\"},\n\t},\n\t{\n\t\t\"a: +b_c\",\n\t\tmap[string]interface{}{\"a\": \"+b_c\"},\n\t},\n\t{\n\t\t\"a: 50cent_of_dollar\",\n\t\tmap[string]interface{}{\"a\": \"50cent_of_dollar\"},\n\t},\n\n\t// issue #295 (allow scalars with colons in flow mappings and sequences)\n\t{\n\t\t\"a: {b: https://github.com/go-yaml/yaml}\",\n\t\tmap[string]interface{}{\"a\": map[interface{}]interface{}{\n\t\t\t\"b\": \"https://github.com/go-yaml/yaml\",\n\t\t}},\n\t},\n\t{\n\t\t\"a: [https://github.com/go-yaml/yaml]\",\n\t\tmap[string]interface{}{\"a\": []interface{}{\"https://github.com/go-yaml/yaml\"}},\n\t},\n\n\t// Duration\n\t{\n\t\t\"a: 3s\",\n\t\tmap[string]time.Duration{\"a\": 3 * time.Second},\n\t},\n\n\t// Issue #24.\n\t{\n\t\t\"a: <foo>\",\n\t\tmap[string]string{\"a\": \"<foo>\"},\n\t},\n\n\t// Base 60 floats are obsolete and unsupported.\n\t{\n\t\t\"a: 1:1\\n\",\n\t\tmap[string]string{\"a\": \"1:1\"},\n\t},\n\n\t// Binary data.\n\t{\n\t\t\"a: !!binary gIGC\\n\",\n\t\tmap[string]string{\"a\": \"\\x80\\x81\\x82\"},\n\t}, {\n\t\t\"a: !!binary |\\n  \" + strings.Repeat(\"kJCQ\", 17) + \"kJ\\n  CQ\\n\",\n\t\tmap[string]string{\"a\": strings.Repeat(\"\\x90\", 54)},\n\t}, {\n\t\t\"a: !!binary |\\n  \" + strings.Repeat(\"A\", 70) + \"\\n  ==\\n\",\n\t\tmap[string]string{\"a\": strings.Repeat(\"\\x00\", 52)},\n\t},\n\n\t// Ordered maps.\n\t{\n\t\t\"{b: 2, a: 1, d: 4, c: 3, sub: {e: 5}}\",\n\t\t&yaml.MapSlice{{\"b\", 2}, {\"a\", 1}, {\"d\", 4}, {\"c\", 3}, {\"sub\", yaml.MapSlice{{\"e\", 5}}}},\n\t},\n\n\t// Issue #39.\n\t{\n\t\t\"a:\\n b:\\n  c: d\\n\",\n\t\tmap[string]struct{ B interface{} }{\"a\": {map[interface{}]interface{}{\"c\": \"d\"}}},\n\t},\n\n\t// Custom map type.\n\t{\n\t\t\"a: {b: c}\",\n\t\tM{\"a\": M{\"b\": \"c\"}},\n\t},\n\n\t// Support encoding.TextUnmarshaler.\n\t{\n\t\t\"a: 1.2.3.4\\n\",\n\t\tmap[string]textUnmarshaler{\"a\": textUnmarshaler{S: \"1.2.3.4\"}},\n\t},\n\t{\n\t\t\"a: 2015-02-24T18:19:39Z\\n\",\n\t\tmap[string]textUnmarshaler{\"a\": textUnmarshaler{\"2015-02-24T18:19:39Z\"}},\n\t},\n\n\t// Timestamps\n\t{\n\t\t// Date only.\n\t\t\"a: 2015-01-01\\n\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 1, 1, 0, 0, 0, 0, time.UTC)},\n\t},\n\t{\n\t\t// RFC3339\n\t\t\"a: 2015-02-24T18:19:39.12Z\\n\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 2, 24, 18, 19, 39, .12e9, time.UTC)},\n\t},\n\t{\n\t\t// RFC3339 with short dates.\n\t\t\"a: 2015-2-3T3:4:5Z\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 2, 3, 3, 4, 5, 0, time.UTC)},\n\t},\n\t{\n\t\t// ISO8601 lower case t\n\t\t\"a: 2015-02-24t18:19:39Z\\n\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 2, 24, 18, 19, 39, 0, time.UTC)},\n\t},\n\t{\n\t\t// space separate, no time zone\n\t\t\"a: 2015-02-24 18:19:39\\n\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 2, 24, 18, 19, 39, 0, time.UTC)},\n\t},\n\t// Some cases not currently handled. Uncomment these when\n\t// the code is fixed.\n\t//\t{\n\t//\t\t// space separated with time zone\n\t//\t\t\"a: 2001-12-14 21:59:43.10 -5\",\n\t//\t\tmap[string]interface{}{\"a\": time.Date(2001, 12, 14, 21, 59, 43, .1e9, time.UTC)},\n\t//\t},\n\t//\t{\n\t//\t\t// arbitrary whitespace between fields\n\t//\t\t\"a: 2001-12-14 \\t\\t \\t21:59:43.10 \\t Z\",\n\t//\t\tmap[string]interface{}{\"a\": time.Date(2001, 12, 14, 21, 59, 43, .1e9, time.UTC)},\n\t//\t},\n\t{\n\t\t// explicit string tag\n\t\t\"a: !!str 2015-01-01\",\n\t\tmap[string]interface{}{\"a\": \"2015-01-01\"},\n\t},\n\t{\n\t\t// explicit timestamp tag on quoted string\n\t\t\"a: !!timestamp \\\"2015-01-01\\\"\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 1, 1, 0, 0, 0, 0, time.UTC)},\n\t},\n\t{\n\t\t// explicit timestamp tag on unquoted string\n\t\t\"a: !!timestamp 2015-01-01\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 1, 1, 0, 0, 0, 0, time.UTC)},\n\t},\n\t{\n\t\t// quoted string that's a valid timestamp\n\t\t\"a: \\\"2015-01-01\\\"\",\n\t\tmap[string]interface{}{\"a\": \"2015-01-01\"},\n\t},\n\t{\n\t\t// explicit timestamp tag into interface.\n\t\t\"a: !!timestamp \\\"2015-01-01\\\"\",\n\t\tmap[string]interface{}{\"a\": \"2015-01-01\"},\n\t},\n\t{\n\t\t// implicit timestamp tag into interface.\n\t\t\"a: 2015-01-01\",\n\t\tmap[string]interface{}{\"a\": \"2015-01-01\"},\n\t},\n\n\t// Encode empty lists as zero-length slices.\n\t{\n\t\t\"a: []\",\n\t\t&struct{ A []int }{[]int{}},\n\t},\n\n\t// UTF-16-LE\n\t{\n\t\t\"\\xff\\xfe\\xf1\\x00o\\x00\\xf1\\x00o\\x00:\\x00 \\x00v\\x00e\\x00r\\x00y\\x00 \\x00y\\x00e\\x00s\\x00\\n\\x00\",\n\t\tM{\"\u00f1o\u00f1o\": \"very yes\"},\n\t},\n\t// UTF-16-LE with surrogate.\n\t{\n\t\t\"\\xff\\xfe\\xf1\\x00o\\x00\\xf1\\x00o\\x00:\\x00 \\x00v\\x00e\\x00r\\x00y\\x00 \\x00y\\x00e\\x00s\\x00 \\x00=\\xd8\\xd4\\xdf\\n\\x00\",\n\t\tM{\"\u00f1o\u00f1o\": \"very yes \ud83d\udfd4\"},\n\t},\n\n\t// UTF-16-BE\n\t{\n\t\t\"\\xfe\\xff\\x00\\xf1\\x00o\\x00\\xf1\\x00o\\x00:\\x00 \\x00v\\x00e\\x00r\\x00y\\x00 \\x00y\\x00e\\x00s\\x00\\n\",\n\t\tM{\"\u00f1o\u00f1o\": \"very yes\"},\n\t},\n\t// UTF-16-BE with surrogate.\n\t{\n\t\t\"\\xfe\\xff\\x00\\xf1\\x00o\\x00\\xf1\\x00o\\x00:\\x00 \\x00v\\x00e\\x00r\\x00y\\x00 \\x00y\\x00e\\x00s\\x00 \\xd8=\\xdf\\xd4\\x00\\n\",\n\t\tM{\"\u00f1o\u00f1o\": \"very yes \ud83d\udfd4\"},\n\t},\n\n\t// This *is* in fact a float number, per the spec. #171 was a mistake.\n\t{\n\t\t\"a: 123456e1\\n\",\n\t\tM{\"a\": 123456e1},\n\t}, {\n\t\t\"a: 123456E1\\n\",\n\t\tM{\"a\": 123456E1},\n\t},\n\t// yaml-test-suite 3GZX: Spec Example 7.1. Alias Nodes\n\t{\n\t\t\"First occurrence: &anchor Foo\\nSecond occurrence: *anchor\\nOverride anchor: &anchor Bar\\nReuse anchor: *anchor\\n\",\n\t\tmap[interface{}]interface{}{\n\t\t\t\"Reuse anchor\":      \"Bar\",\n\t\t\t\"First occurrence\":  \"Foo\",\n\t\t\t\"Second occurrence\": \"Foo\",\n\t\t\t\"Override anchor\":   \"Bar\",\n\t\t},\n\t},\n\t// Single document with garbage following it.\n\t{\n\t\t\"---\\nhello\\n...\\n}not yaml\",\n\t\t\"hello\",\n\t},\n\t{\n\t\t\"a: 5\\n\",\n\t\t&struct{ A jsonNumberT }{\"5\"},\n\t},\n\t{\n\t\t\"a: 5.5\\n\",\n\t\t&struct{ A jsonNumberT }{\"5.5\"},\n\t},\n}\n\ntype M map[interface{}]interface{}\n\ntype inlineB struct {\n\tB       int\n\tinlineC `yaml:\",inline\"`\n}\n\ntype inlineC struct {\n\tC int\n}\n\nfunc (s *S) TestUnmarshal(c *C) {\n\tfor i, item := range unmarshalTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\tt := reflect.ValueOf(item.value).Type()\n\t\tvalue := reflect.New(t)\n\t\terr := yaml.Unmarshal([]byte(item.data), value.Interface())\n\t\tif _, ok := err.(*yaml.TypeError); !ok {\n\t\t\tc.Assert(err, IsNil)\n\t\t}\n\t\tc.Assert(value.Elem().Interface(), DeepEquals, item.value, Commentf(\"error: %v\", err))\n\t}\n}\n\n// TODO(v3): This test should also work when unmarshaling onto an interface{}.\nfunc (s *S) TestUnmarshalFullTimestamp(c *C) {\n\t// Full timestamp in same format as encoded. This is confirmed to be\n\t// properly decoded by Python as a timestamp as well.\n\tvar str = \"2015-02-24T18:19:39.123456789-03:00\"\n\tvar t time.Time\n\terr := yaml.Unmarshal([]byte(str), &t)\n\tc.Assert(err, IsNil)\n\tc.Assert(t, Equals, time.Date(2015, 2, 24, 18, 19, 39, 123456789, t.Location()))\n\tc.Assert(t.In(time.UTC), Equals, time.Date(2015, 2, 24, 21, 19, 39, 123456789, time.UTC))\n}\n\nfunc (s *S) TestDecoderSingleDocument(c *C) {\n\t// Test that Decoder.Decode works as expected on\n\t// all the unmarshal tests.\n\tfor i, item := range unmarshalTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\tif item.data == \"\" {\n\t\t\t// Behaviour differs when there's no YAML.\n\t\t\tcontinue\n\t\t}\n\t\tt := reflect.ValueOf(item.value).Type()\n\t\tvalue := reflect.New(t)\n\t\terr := yaml.NewDecoder(strings.NewReader(item.data)).Decode(value.Interface())\n\t\tif _, ok := err.(*yaml.TypeError); !ok {\n\t\t\tc.Assert(err, IsNil)\n\t\t}\n\t\tc.Assert(value.Elem().Interface(), DeepEquals, item.value)\n\t}\n}\n\nvar decoderTests = []struct {\n\tdata   string\n\tvalues []interface{}\n}{{\n\t\"\",\n\tnil,\n}, {\n\t\"a: b\",\n\t[]interface{}{\n\t\tmap[interface{}]interface{}{\"a\": \"b\"},\n\t},\n}, {\n\t\"---\\na: b\\n...\\n\",\n\t[]interface{}{\n\t\tmap[interface{}]interface{}{\"a\": \"b\"},\n\t},\n}, {\n\t\"---\\n'hello'\\n...\\n---\\ngoodbye\\n...\\n\",\n\t[]interface{}{\n\t\t\"hello\",\n\t\t\"goodbye\",\n\t},\n}}\n\nfunc (s *S) TestDecoder(c *C) {\n\tfor i, item := range decoderTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\tvar values []interface{}\n\t\tdec := yaml.NewDecoder(strings.NewReader(item.data))\n\t\tfor {\n\t\t\tvar value interface{}\n\t\t\terr := dec.Decode(&value)\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc.Assert(err, IsNil)\n\t\t\tvalues = append(values, value)\n\t\t}\n\t\tc.Assert(values, DeepEquals, item.values)\n\t}\n}\n\ntype errReader struct{}\n\nfunc (errReader) Read([]byte) (int, error) {\n\treturn 0, errors.New(\"some read error\")\n}\n\nfunc (s *S) TestDecoderReadError(c *C) {\n\terr := yaml.NewDecoder(errReader{}).Decode(&struct{}{})\n\tc.Assert(err, ErrorMatches, `yaml: input error: some read error`)\n}\n\nfunc (s *S) TestUnmarshalNaN(c *C) {\n\tvalue := map[string]interface{}{}\n\terr := yaml.Unmarshal([]byte(\"notanum: .NaN\"), &value)\n\tc.Assert(err, IsNil)\n\tc.Assert(math.IsNaN(value[\"notanum\"].(float64)), Equals, true)\n}\n\nvar unmarshalErrorTests = []struct {\n\tdata, error string\n}{\n\t{\"v: !!float 'error'\", \"yaml: cannot decode !!str `error` as a !!float\"},\n\t{\"v: [A,\", \"yaml: line 1: did not find expected node content\"},\n\t{\"v:\\n- [A,\", \"yaml: line 2: did not find expected node content\"},\n\t{\"a:\\n- b: *,\", \"yaml: line 2: did not find expected alphabetic or numeric character\"},\n\t{\"a: *b\\n\", \"yaml: unknown anchor 'b' referenced\"},\n\t{\"a: &a\\n  b: *a\\n\", \"yaml: anchor 'a' value contains itself\"},\n\t{\"value: -\", \"yaml: block sequence entries are not allowed in this context\"},\n\t{\"a: !!binary ==\", \"yaml: !!binary value contains invalid base64 data\"},\n\t{\"{[.]}\", `yaml: invalid map key: \\[\\]interface \\{\\}\\{\"\\.\"\\}`},\n\t{\"{{.}}\", `yaml: invalid map key: map\\[interface\\ \\{\\}\\]interface \\{\\}\\{\".\":interface \\{\\}\\(nil\\)\\}`},\n\t{\"b: *a\\na: &a {c: 1}\", `yaml: unknown anchor 'a' referenced`},\n\t{\"%TAG !%79! tag:yaml.org,2002:\\n---\\nv: !%79!int '1'\", \"yaml: did not find expected whitespace\"},\n}\n\nfunc (s *S) TestUnmarshalErrors(c *C) {\n\tfor i, item := range unmarshalErrorTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\tvar value interface{}\n\t\terr := yaml.Unmarshal([]byte(item.data), &value)\n\t\tc.Assert(err, ErrorMatches, item.error, Commentf(\"Partial unmarshal: %#v\", value))\n\t}\n}\n\nfunc (s *S) TestDecoderErrors(c *C) {\n\tfor _, item := range unmarshalErrorTests {\n\t\tvar value interface{}\n\t\terr := yaml.NewDecoder(strings.NewReader(item.data)).Decode(&value)\n\t\tc.Assert(err, ErrorMatches, item.error, Commentf(\"Partial unmarshal: %#v\", value))\n\t}\n}\n\nvar unmarshalerTests = []struct {\n\tdata, tag string\n\tvalue     interface{}\n}{\n\t{\"_: {hi: there}\", \"!!map\", map[interface{}]interface{}{\"hi\": \"there\"}},\n\t{\"_: [1,A]\", \"!!seq\", []interface{}{1, \"A\"}},\n\t{\"_: 10\", \"!!int\", 10},\n\t{\"_: null\", \"!!null\", nil},\n\t{`_: BAR!`, \"!!str\", \"BAR!\"},\n\t{`_: \"BAR!\"`, \"!!str\", \"BAR!\"},\n\t{\"_: !!foo 'BAR!'\", \"!!foo\", \"BAR!\"},\n\t{`_: \"\"`, \"!!str\", \"\"},\n}\n\nvar unmarshalerResult = map[int]error{}\n\ntype unmarshalerType struct {\n\tvalue interface{}\n}\n\nfunc (o *unmarshalerType) UnmarshalYAML(unmarshal func(v interface{}) error) error {\n\tif err := unmarshal(&o.value); err != nil {\n\t\treturn err\n\t}\n\tif i, ok := o.value.(int); ok {\n\t\tif result, ok := unmarshalerResult[i]; ok {\n\t\t\treturn result\n\t\t}\n\t}\n\treturn nil\n}\n\ntype unmarshalerPointer struct {\n\tField *unmarshalerType \"_\"\n}\n\ntype unmarshalerValue struct {\n\tField unmarshalerType \"_\"\n}\n\nfunc (s *S) TestUnmarshalerPointerField(c *C) {\n\tfor _, item := range unmarshalerTests {\n\t\tobj := &unmarshalerPointer{}\n\t\terr := yaml.Unmarshal([]byte(item.data), obj)\n\t\tc.Assert(err, IsNil)\n\t\tif item.value == nil {\n\t\t\tc.Assert(obj.Field, IsNil)\n\t\t} else {\n\t\t\tc.Assert(obj.Field, NotNil, Commentf(\"Pointer not initialized (%#v)\", item.value))\n\t\t\tc.Assert(obj.Field.value, DeepEquals, item.value)\n\t\t}\n\t}\n}\n\nfunc (s *S) TestUnmarshalerValueField(c *C) {\n\tfor _, item := range unmarshalerTests {\n\t\tobj := &unmarshalerValue{}\n\t\terr := yaml.Unmarshal([]byte(item.data), obj)\n\t\tc.Assert(err, IsNil)\n\t\tc.Assert(obj.Field, NotNil, Commentf(\"Pointer not initialized (%#v)\", item.value))\n\t\tc.Assert(obj.Field.value, DeepEquals, item.value)\n\t}\n}\n\nfunc (s *S) TestUnmarshalerWholeDocument(c *C) {\n\tobj := &unmarshalerType{}\n\terr := yaml.Unmarshal([]byte(unmarshalerTests[0].data), obj)\n\tc.Assert(err, IsNil)\n\tvalue, ok := obj.value.(map[interface{}]interface{})\n\tc.Assert(ok, Equals, true, Commentf(\"value: %#v\", obj.value))\n\tc.Assert(value[\"_\"], DeepEquals, unmarshalerTests[0].value)\n}\n\nfunc (s *S) TestUnmarshalerTypeError(c *C) {\n\tunmarshalerResult[2] = &yaml.TypeError{[]string{\"foo\"}}\n\tunmarshalerResult[4] = &yaml.TypeError{[]string{\"bar\"}}\n\tdefer func() {\n\t\tdelete(unmarshalerResult, 2)\n\t\tdelete(unmarshalerResult, 4)\n\t}()\n\n\ttype T struct {\n\t\tBefore int\n\t\tAfter  int\n\t\tM      map[string]*unmarshalerType\n\t}\n\tvar v T\n\tdata := `{before: A, m: {abc: 1, def: 2, ghi: 3, jkl: 4}, after: B}`\n\terr := yaml.Unmarshal([]byte(data), &v)\n\tc.Assert(err, ErrorMatches, \"\"+\n\t\t\"yaml: unmarshal errors:\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `A` into int\\n\"+\n\t\t\"  foo\\n\"+\n\t\t\"  bar\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `B` into int\")\n\tc.Assert(v.M[\"abc\"], NotNil)\n\tc.Assert(v.M[\"def\"], IsNil)\n\tc.Assert(v.M[\"ghi\"], NotNil)\n\tc.Assert(v.M[\"jkl\"], IsNil)\n\n\tc.Assert(v.M[\"abc\"].value, Equals, 1)\n\tc.Assert(v.M[\"ghi\"].value, Equals, 3)\n}\n\ntype proxyTypeError struct{}\n\nfunc (v *proxyTypeError) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar s string\n\tvar a int32\n\tvar b int64\n\tif err := unmarshal(&s); err != nil {\n\t\tpanic(err)\n\t}\n\tif s == \"a\" {\n\t\tif err := unmarshal(&b); err == nil {\n\t\t\tpanic(\"should have failed\")\n\t\t}\n\t\treturn unmarshal(&a)\n\t}\n\tif err := unmarshal(&a); err == nil {\n\t\tpanic(\"should have failed\")\n\t}\n\treturn unmarshal(&b)\n}\n\nfunc (s *S) TestUnmarshalerTypeErrorProxying(c *C) {\n\ttype T struct {\n\t\tBefore int\n\t\tAfter  int\n\t\tM      map[string]*proxyTypeError\n\t}\n\tvar v T\n\tdata := `{before: A, m: {abc: a, def: b}, after: B}`\n\terr := yaml.Unmarshal([]byte(data), &v)\n\tc.Assert(err, ErrorMatches, \"\"+\n\t\t\"yaml: unmarshal errors:\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `A` into int\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `a` into int32\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `b` into int64\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `B` into int\")\n}\n\ntype failingUnmarshaler struct{}\n\nvar failingErr = errors.New(\"failingErr\")\n\nfunc (ft *failingUnmarshaler) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\treturn failingErr\n}\n\nfunc (s *S) TestUnmarshalerError(c *C) {\n\terr := yaml.Unmarshal([]byte(\"a: b\"), &failingUnmarshaler{})\n\tc.Assert(err, Equals, failingErr)\n}\n\ntype sliceUnmarshaler []int\n\nfunc (su *sliceUnmarshaler) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar slice []int\n\terr := unmarshal(&slice)\n\tif err == nil {\n\t\t*su = slice\n\t\treturn nil\n\t}\n\n\tvar intVal int\n\terr = unmarshal(&intVal)\n\tif err == nil {\n\t\t*su = []int{intVal}\n\t\treturn nil\n\t}\n\n\treturn err\n}\n\nfunc (s *S) TestUnmarshalerRetry(c *C) {\n\tvar su sliceUnmarshaler\n\terr := yaml.Unmarshal([]byte(\"[1, 2, 3]\"), &su)\n\tc.Assert(err, IsNil)\n\tc.Assert(su, DeepEquals, sliceUnmarshaler([]int{1, 2, 3}))\n\n\terr = yaml.Unmarshal([]byte(\"1\"), &su)\n\tc.Assert(err, IsNil)\n\tc.Assert(su, DeepEquals, sliceUnmarshaler([]int{1}))\n}\n\n// From http://yaml.org/type/merge.html\nvar mergeTests = `\nanchors:\n  list:\n    - &CENTER { \"x\": 1, \"y\": 2 }\n    - &LEFT   { \"x\": 0, \"y\": 2 }\n    - &BIG    { \"r\": 10 }\n    - &SMALL  { \"r\": 1 }\n\n# All the following maps are equal:\n\nplain:\n  # Explicit keys\n  \"x\": 1\n  \"y\": 2\n  \"r\": 10\n  label: center/big\n\nmergeOne:\n  # Merge one map\n  << : *CENTER\n  \"r\": 10\n  label: center/big\n\nmergeMultiple:\n  # Merge multiple maps\n  << : [ *CENTER, *BIG ]\n  label: center/big\n\noverride:\n  # Override\n  << : [ *BIG, *LEFT, *SMALL ]\n  \"x\": 1\n  label: center/big\n\nshortTag:\n  # Explicit short merge tag\n  !!merge \"<<\" : [ *CENTER, *BIG ]\n  label: center/big\n\nlongTag:\n  # Explicit merge long tag\n  !<tag:yaml.org,2002:merge> \"<<\" : [ *CENTER, *BIG ]\n  label: center/big\n\ninlineMap:\n  # Inlined map \n  << : {\"x\": 1, \"y\": 2, \"r\": 10}\n  label: center/big\n\ninlineSequenceMap:\n  # Inlined map in sequence\n  << : [ *CENTER, {\"r\": 10} ]\n  label: center/big\n`\n\nfunc (s *S) TestMerge(c *C) {\n\tvar want = map[interface{}]interface{}{\n\t\t\"x\":     1,\n\t\t\"y\":     2,\n\t\t\"r\":     10,\n\t\t\"label\": \"center/big\",\n\t}\n\n\tvar m map[interface{}]interface{}\n\terr := yaml.Unmarshal([]byte(mergeTests), &m)\n\tc.Assert(err, IsNil)\n\tfor name, test := range m {\n\t\tif name == \"anchors\" {\n\t\t\tcontinue\n\t\t}\n\t\tc.Assert(test, DeepEquals, want, Commentf(\"test %q failed\", name))\n\t}\n}\n\nfunc (s *S) TestMergeStruct(c *C) {\n\ttype Data struct {\n\t\tX, Y, R int\n\t\tLabel   string\n\t}\n\twant := Data{1, 2, 10, \"center/big\"}\n\n\tvar m map[string]Data\n\terr := yaml.Unmarshal([]byte(mergeTests), &m)\n\tc.Assert(err, IsNil)\n\tfor name, test := range m {\n\t\tif name == \"anchors\" {\n\t\t\tcontinue\n\t\t}\n\t\tc.Assert(test, Equals, want, Commentf(\"test %q failed\", name))\n\t}\n}\n\nvar unmarshalNullTests = []func() interface{}{\n\tfunc() interface{} { var v interface{}; v = \"v\"; return &v },\n\tfunc() interface{} { var s = \"s\"; return &s },\n\tfunc() interface{} { var s = \"s\"; sptr := &s; return &sptr },\n\tfunc() interface{} { var i = 1; return &i },\n\tfunc() interface{} { var i = 1; iptr := &i; return &iptr },\n\tfunc() interface{} { m := map[string]int{\"s\": 1}; return &m },\n\tfunc() interface{} { m := map[string]int{\"s\": 1}; return m },\n}\n\nfunc (s *S) TestUnmarshalNull(c *C) {\n\tfor _, test := range unmarshalNullTests {\n\t\titem := test()\n\t\tzero := reflect.Zero(reflect.TypeOf(item).Elem()).Interface()\n\t\terr := yaml.Unmarshal([]byte(\"null\"), item)\n\t\tc.Assert(err, IsNil)\n\t\tif reflect.TypeOf(item).Kind() == reflect.Map {\n\t\t\tc.Assert(reflect.ValueOf(item).Interface(), DeepEquals, reflect.MakeMap(reflect.TypeOf(item)).Interface())\n\t\t} else {\n\t\t\tc.Assert(reflect.ValueOf(item).Elem().Interface(), DeepEquals, zero)\n\t\t}\n\t}\n}\n\nfunc (s *S) TestUnmarshalSliceOnPreset(c *C) {\n\t// Issue #48.\n\tv := struct{ A []int }{[]int{1}}\n\tyaml.Unmarshal([]byte(\"a: [2]\"), &v)\n\tc.Assert(v.A, DeepEquals, []int{2})\n}\n\nvar unmarshalStrictTests = []struct {\n\tdata  string\n\tvalue interface{}\n\terror string\n}{{\n\tdata:  \"a: 1\\nc: 2\\n\",\n\tvalue: struct{ A, B int }{A: 1},\n\terror: `yaml: unmarshal errors:\\n  line 2: field c not found in type struct { A int; B int }`,\n}, {\n\tdata:  \"a: 1\\nb: 2\\na: 3\\n\",\n\tvalue: struct{ A, B int }{A: 3, B: 2},\n\terror: `yaml: unmarshal errors:\\n  line 3: field a already set in type struct { A int; B int }`,\n}, {\n\tdata: \"c: 3\\na: 1\\nb: 2\\nc: 4\\n\",\n\tvalue: struct {\n\t\tA       int\n\t\tinlineB `yaml:\",inline\"`\n\t}{\n\t\tA: 1,\n\t\tinlineB: inlineB{\n\t\t\tB: 2,\n\t\t\tinlineC: inlineC{\n\t\t\t\tC: 4,\n\t\t\t},\n\t\t},\n\t},\n\terror: `yaml: unmarshal errors:\\n  line 4: field c already set in type struct { A int; yaml_test.inlineB \"yaml:\\\\\",inline\\\\\"\" }`,\n}, {\n\tdata: \"c: 0\\na: 1\\nb: 2\\nc: 1\\n\",\n\tvalue: struct {\n\t\tA       int\n\t\tinlineB `yaml:\",inline\"`\n\t}{\n\t\tA: 1,\n\t\tinlineB: inlineB{\n\t\t\tB: 2,\n\t\t\tinlineC: inlineC{\n\t\t\t\tC: 1,\n\t\t\t},\n\t\t},\n\t},\n\terror: `yaml: unmarshal errors:\\n  line 4: field c already set in type struct { A int; yaml_test.inlineB \"yaml:\\\\\",inline\\\\\"\" }`,\n}, {\n\tdata: \"c: 1\\na: 1\\nb: 2\\nc: 3\\n\",\n\tvalue: struct {\n\t\tA int\n\t\tM map[string]interface{} `yaml:\",inline\"`\n\t}{\n\t\tA: 1,\n\t\tM: map[string]interface{}{\n\t\t\t\"b\": 2,\n\t\t\t\"c\": 3,\n\t\t},\n\t},\n\terror: `yaml: unmarshal errors:\\n  line 4: key \"c\" already set in map`,\n}, {\n\tdata: \"a: 1\\n9: 2\\nnull: 3\\n9: 4\",\n\tvalue: map[interface{}]interface{}{\n\t\t\"a\": 1,\n\t\tnil: 3,\n\t\t9:   4,\n\t},\n\terror: `yaml: unmarshal errors:\\n  line 4: key 9 already set in map`,\n}}\n\nfunc (s *S) TestUnmarshalStrict(c *C) {\n\tfor i, item := range unmarshalStrictTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\t// First test that normal Unmarshal unmarshals to the expected value.\n\t\tt := reflect.ValueOf(item.value).Type()\n\t\tvalue := reflect.New(t)\n\t\terr := yaml.Unmarshal([]byte(item.data), value.Interface())\n\t\tc.Assert(err, Equals, nil)\n\t\tc.Assert(value.Elem().Interface(), DeepEquals, item.value)\n\n\t\t// Then test that UnmarshalStrict fails on the same thing.\n\t\tt = reflect.ValueOf(item.value).Type()\n\t\tvalue = reflect.New(t)\n\t\terr = yaml.UnmarshalStrict([]byte(item.data), value.Interface())\n\t\tc.Assert(err, ErrorMatches, item.error)\n\t}\n}\n\ntype textUnmarshaler struct {\n\tS string\n}\n\nfunc (t *textUnmarshaler) UnmarshalText(s []byte) error {\n\tt.S = string(s)\n\treturn nil\n}\n\nfunc (s *S) TestFuzzCrashers(c *C) {\n\tcases := []string{\n\t\t// runtime error: index out of range\n\t\t\"\\\"\\\\0\\\\\\r\\n\",\n\n\t\t// should not happen\n\t\t\"  0: [\\n] 0\",\n\t\t\"? ? \\\"\\n\\\" 0\",\n\t\t\"    - {\\n000}0\",\n\t\t\"0:\\n  0: [0\\n] 0\",\n\t\t\"    - \\\"\\n000\\\"0\",\n\t\t\"    - \\\"\\n000\\\"\\\"\",\n\t\t\"0:\\n    - {\\n000}0\",\n\t\t\"0:\\n    - \\\"\\n000\\\"0\",\n\t\t\"0:\\n    - \\\"\\n000\\\"\\\"\",\n\n\t\t// runtime error: index out of range\n\t\t\" \\ufeff\\n\",\n\t\t\"? \\ufeff\\n\",\n\t\t\"? \\ufeff:\\n\",\n\t\t\"0: \\ufeff\\n\",\n\t\t\"? \\ufeff: \\ufeff\\n\",\n\t}\n\tfor _, data := range cases {\n\t\tvar v interface{}\n\t\t_ = yaml.Unmarshal([]byte(data), &v)\n\t}\n}\n\n//var data []byte\n//func init() {\n//\tvar err error\n//\tdata, err = ioutil.ReadFile(\"/tmp/file.yaml\")\n//\tif err != nil {\n//\t\tpanic(err)\n//\t}\n//}\n//\n//func (s *S) BenchmarkUnmarshal(c *C) {\n//\tvar err error\n//\tfor i := 0; i < c.N; i++ {\n//\t\tvar v map[string]interface{}\n//\t\terr = yaml.Unmarshal(data, &v)\n//\t}\n//\tif err != nil {\n//\t\tpanic(err)\n//\t}\n//}\n//\n//func (s *S) BenchmarkMarshal(c *C) {\n//\tvar v map[string]interface{}\n//\tyaml.Unmarshal(data, &v)\n//\tc.ResetTimer()\n//\tfor i := 0; i < c.N; i++ {\n//\t\tyaml.Marshal(&v)\n//\t}\n//}\n"], "fixing_code": ["package yaml\n\nimport (\n\t\"encoding\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n)\n\nconst (\n\tdocumentNode = 1 << iota\n\tmappingNode\n\tsequenceNode\n\tscalarNode\n\taliasNode\n)\n\ntype node struct {\n\tkind         int\n\tline, column int\n\ttag          string\n\t// For an alias node, alias holds the resolved alias.\n\talias    *node\n\tvalue    string\n\timplicit bool\n\tchildren []*node\n\tanchors  map[string]*node\n}\n\n// ----------------------------------------------------------------------------\n// Parser, produces a node tree out of a libyaml event stream.\n\ntype parser struct {\n\tparser   yaml_parser_t\n\tevent    yaml_event_t\n\tdoc      *node\n\tdoneInit bool\n}\n\nfunc newParser(b []byte) *parser {\n\tp := parser{}\n\tif !yaml_parser_initialize(&p.parser) {\n\t\tpanic(\"failed to initialize YAML emitter\")\n\t}\n\tif len(b) == 0 {\n\t\tb = []byte{'\\n'}\n\t}\n\tyaml_parser_set_input_string(&p.parser, b)\n\treturn &p\n}\n\nfunc newParserFromReader(r io.Reader) *parser {\n\tp := parser{}\n\tif !yaml_parser_initialize(&p.parser) {\n\t\tpanic(\"failed to initialize YAML emitter\")\n\t}\n\tyaml_parser_set_input_reader(&p.parser, r)\n\treturn &p\n}\n\nfunc (p *parser) init() {\n\tif p.doneInit {\n\t\treturn\n\t}\n\tp.expect(yaml_STREAM_START_EVENT)\n\tp.doneInit = true\n}\n\nfunc (p *parser) destroy() {\n\tif p.event.typ != yaml_NO_EVENT {\n\t\tyaml_event_delete(&p.event)\n\t}\n\tyaml_parser_delete(&p.parser)\n}\n\n// expect consumes an event from the event stream and\n// checks that it's of the expected type.\nfunc (p *parser) expect(e yaml_event_type_t) {\n\tif p.event.typ == yaml_NO_EVENT {\n\t\tif !yaml_parser_parse(&p.parser, &p.event) {\n\t\t\tp.fail()\n\t\t}\n\t}\n\tif p.event.typ == yaml_STREAM_END_EVENT {\n\t\tfailf(\"attempted to go past the end of stream; corrupted value?\")\n\t}\n\tif p.event.typ != e {\n\t\tp.parser.problem = fmt.Sprintf(\"expected %s event but got %s\", e, p.event.typ)\n\t\tp.fail()\n\t}\n\tyaml_event_delete(&p.event)\n\tp.event.typ = yaml_NO_EVENT\n}\n\n// peek peeks at the next event in the event stream,\n// puts the results into p.event and returns the event type.\nfunc (p *parser) peek() yaml_event_type_t {\n\tif p.event.typ != yaml_NO_EVENT {\n\t\treturn p.event.typ\n\t}\n\tif !yaml_parser_parse(&p.parser, &p.event) {\n\t\tp.fail()\n\t}\n\treturn p.event.typ\n}\n\nfunc (p *parser) fail() {\n\tvar where string\n\tvar line int\n\tif p.parser.problem_mark.line != 0 {\n\t\tline = p.parser.problem_mark.line\n\t\t// Scanner errors don't iterate line before returning error\n\t\tif p.parser.error == yaml_SCANNER_ERROR {\n\t\t\tline++\n\t\t}\n\t} else if p.parser.context_mark.line != 0 {\n\t\tline = p.parser.context_mark.line\n\t}\n\tif line != 0 {\n\t\twhere = \"line \" + strconv.Itoa(line) + \": \"\n\t}\n\tvar msg string\n\tif len(p.parser.problem) > 0 {\n\t\tmsg = p.parser.problem\n\t} else {\n\t\tmsg = \"unknown problem parsing YAML content\"\n\t}\n\tfailf(\"%s%s\", where, msg)\n}\n\nfunc (p *parser) anchor(n *node, anchor []byte) {\n\tif anchor != nil {\n\t\tp.doc.anchors[string(anchor)] = n\n\t}\n}\n\nfunc (p *parser) parse() *node {\n\tp.init()\n\tswitch p.peek() {\n\tcase yaml_SCALAR_EVENT:\n\t\treturn p.scalar()\n\tcase yaml_ALIAS_EVENT:\n\t\treturn p.alias()\n\tcase yaml_MAPPING_START_EVENT:\n\t\treturn p.mapping()\n\tcase yaml_SEQUENCE_START_EVENT:\n\t\treturn p.sequence()\n\tcase yaml_DOCUMENT_START_EVENT:\n\t\treturn p.document()\n\tcase yaml_STREAM_END_EVENT:\n\t\t// Happens when attempting to decode an empty buffer.\n\t\treturn nil\n\tdefault:\n\t\tpanic(\"attempted to parse unknown event: \" + p.event.typ.String())\n\t}\n}\n\nfunc (p *parser) node(kind int) *node {\n\treturn &node{\n\t\tkind:   kind,\n\t\tline:   p.event.start_mark.line,\n\t\tcolumn: p.event.start_mark.column,\n\t}\n}\n\nfunc (p *parser) document() *node {\n\tn := p.node(documentNode)\n\tn.anchors = make(map[string]*node)\n\tp.doc = n\n\tp.expect(yaml_DOCUMENT_START_EVENT)\n\tn.children = append(n.children, p.parse())\n\tp.expect(yaml_DOCUMENT_END_EVENT)\n\treturn n\n}\n\nfunc (p *parser) alias() *node {\n\tn := p.node(aliasNode)\n\tn.value = string(p.event.anchor)\n\tn.alias = p.doc.anchors[n.value]\n\tif n.alias == nil {\n\t\tfailf(\"unknown anchor '%s' referenced\", n.value)\n\t}\n\tp.expect(yaml_ALIAS_EVENT)\n\treturn n\n}\n\nfunc (p *parser) scalar() *node {\n\tn := p.node(scalarNode)\n\tn.value = string(p.event.value)\n\tn.tag = string(p.event.tag)\n\tn.implicit = p.event.implicit\n\tp.anchor(n, p.event.anchor)\n\tp.expect(yaml_SCALAR_EVENT)\n\treturn n\n}\n\nfunc (p *parser) sequence() *node {\n\tn := p.node(sequenceNode)\n\tp.anchor(n, p.event.anchor)\n\tp.expect(yaml_SEQUENCE_START_EVENT)\n\tfor p.peek() != yaml_SEQUENCE_END_EVENT {\n\t\tn.children = append(n.children, p.parse())\n\t}\n\tp.expect(yaml_SEQUENCE_END_EVENT)\n\treturn n\n}\n\nfunc (p *parser) mapping() *node {\n\tn := p.node(mappingNode)\n\tp.anchor(n, p.event.anchor)\n\tp.expect(yaml_MAPPING_START_EVENT)\n\tfor p.peek() != yaml_MAPPING_END_EVENT {\n\t\tn.children = append(n.children, p.parse(), p.parse())\n\t}\n\tp.expect(yaml_MAPPING_END_EVENT)\n\treturn n\n}\n\n// ----------------------------------------------------------------------------\n// Decoder, unmarshals a node into a provided value.\n\ntype decoder struct {\n\tdoc     *node\n\taliases map[*node]bool\n\tmapType reflect.Type\n\tterrors []string\n\tstrict  bool\n\n\tdecodeCount int\n\taliasCount  int\n\taliasDepth  int\n}\n\nvar (\n\tmapItemType    = reflect.TypeOf(MapItem{})\n\tdurationType   = reflect.TypeOf(time.Duration(0))\n\tdefaultMapType = reflect.TypeOf(map[interface{}]interface{}{})\n\tifaceType      = defaultMapType.Elem()\n\ttimeType       = reflect.TypeOf(time.Time{})\n\tptrTimeType    = reflect.TypeOf(&time.Time{})\n)\n\nfunc newDecoder(strict bool) *decoder {\n\td := &decoder{mapType: defaultMapType, strict: strict}\n\td.aliases = make(map[*node]bool)\n\treturn d\n}\n\nfunc (d *decoder) terror(n *node, tag string, out reflect.Value) {\n\tif n.tag != \"\" {\n\t\ttag = n.tag\n\t}\n\tvalue := n.value\n\tif tag != yaml_SEQ_TAG && tag != yaml_MAP_TAG {\n\t\tif len(value) > 10 {\n\t\t\tvalue = \" `\" + value[:7] + \"...`\"\n\t\t} else {\n\t\t\tvalue = \" `\" + value + \"`\"\n\t\t}\n\t}\n\td.terrors = append(d.terrors, fmt.Sprintf(\"line %d: cannot unmarshal %s%s into %s\", n.line+1, shortTag(tag), value, out.Type()))\n}\n\nfunc (d *decoder) callUnmarshaler(n *node, u Unmarshaler) (good bool) {\n\tterrlen := len(d.terrors)\n\terr := u.UnmarshalYAML(func(v interface{}) (err error) {\n\t\tdefer handleErr(&err)\n\t\td.unmarshal(n, reflect.ValueOf(v))\n\t\tif len(d.terrors) > terrlen {\n\t\t\tissues := d.terrors[terrlen:]\n\t\t\td.terrors = d.terrors[:terrlen]\n\t\t\treturn &TypeError{issues}\n\t\t}\n\t\treturn nil\n\t})\n\tif e, ok := err.(*TypeError); ok {\n\t\td.terrors = append(d.terrors, e.Errors...)\n\t\treturn false\n\t}\n\tif err != nil {\n\t\tfail(err)\n\t}\n\treturn true\n}\n\n// d.prepare initializes and dereferences pointers and calls UnmarshalYAML\n// if a value is found to implement it.\n// It returns the initialized and dereferenced out value, whether\n// unmarshalling was already done by UnmarshalYAML, and if so whether\n// its types unmarshalled appropriately.\n//\n// If n holds a null value, prepare returns before doing anything.\nfunc (d *decoder) prepare(n *node, out reflect.Value) (newout reflect.Value, unmarshaled, good bool) {\n\tif n.tag == yaml_NULL_TAG || n.kind == scalarNode && n.tag == \"\" && (n.value == \"null\" || n.value == \"~\" || n.value == \"\" && n.implicit) {\n\t\treturn out, false, false\n\t}\n\tagain := true\n\tfor again {\n\t\tagain = false\n\t\tif out.Kind() == reflect.Ptr {\n\t\t\tif out.IsNil() {\n\t\t\t\tout.Set(reflect.New(out.Type().Elem()))\n\t\t\t}\n\t\t\tout = out.Elem()\n\t\t\tagain = true\n\t\t}\n\t\tif out.CanAddr() {\n\t\t\tif u, ok := out.Addr().Interface().(Unmarshaler); ok {\n\t\t\t\tgood = d.callUnmarshaler(n, u)\n\t\t\t\treturn out, true, good\n\t\t\t}\n\t\t}\n\t}\n\treturn out, false, false\n}\n\nfunc (d *decoder) unmarshal(n *node, out reflect.Value) (good bool) {\n\td.decodeCount++\n\tif d.aliasDepth > 0 {\n\t\td.aliasCount++\n\t}\n\tif d.aliasCount > 100 && d.decodeCount > 1000 && float64(d.aliasCount)/float64(d.decodeCount) > 0.99 {\n\t\tfailf(\"document contains excessive aliasing\")\n\t}\n\tswitch n.kind {\n\tcase documentNode:\n\t\treturn d.document(n, out)\n\tcase aliasNode:\n\t\treturn d.alias(n, out)\n\t}\n\tout, unmarshaled, good := d.prepare(n, out)\n\tif unmarshaled {\n\t\treturn good\n\t}\n\tswitch n.kind {\n\tcase scalarNode:\n\t\tgood = d.scalar(n, out)\n\tcase mappingNode:\n\t\tgood = d.mapping(n, out)\n\tcase sequenceNode:\n\t\tgood = d.sequence(n, out)\n\tdefault:\n\t\tpanic(\"internal error: unknown node kind: \" + strconv.Itoa(n.kind))\n\t}\n\treturn good\n}\n\nfunc (d *decoder) document(n *node, out reflect.Value) (good bool) {\n\tif len(n.children) == 1 {\n\t\td.doc = n\n\t\td.unmarshal(n.children[0], out)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (d *decoder) alias(n *node, out reflect.Value) (good bool) {\n\tif d.aliases[n] {\n\t\t// TODO this could actually be allowed in some circumstances.\n\t\tfailf(\"anchor '%s' value contains itself\", n.value)\n\t}\n\td.aliases[n] = true\n\td.aliasDepth++\n\tgood = d.unmarshal(n.alias, out)\n\td.aliasDepth--\n\tdelete(d.aliases, n)\n\treturn good\n}\n\nvar zeroValue reflect.Value\n\nfunc resetMap(out reflect.Value) {\n\tfor _, k := range out.MapKeys() {\n\t\tout.SetMapIndex(k, zeroValue)\n\t}\n}\n\nfunc (d *decoder) scalar(n *node, out reflect.Value) bool {\n\tvar tag string\n\tvar resolved interface{}\n\tif n.tag == \"\" && !n.implicit {\n\t\ttag = yaml_STR_TAG\n\t\tresolved = n.value\n\t} else {\n\t\ttag, resolved = resolve(n.tag, n.value)\n\t\tif tag == yaml_BINARY_TAG {\n\t\t\tdata, err := base64.StdEncoding.DecodeString(resolved.(string))\n\t\t\tif err != nil {\n\t\t\t\tfailf(\"!!binary value contains invalid base64 data\")\n\t\t\t}\n\t\t\tresolved = string(data)\n\t\t}\n\t}\n\tif resolved == nil {\n\t\tif out.Kind() == reflect.Map && !out.CanAddr() {\n\t\t\tresetMap(out)\n\t\t} else {\n\t\t\tout.Set(reflect.Zero(out.Type()))\n\t\t}\n\t\treturn true\n\t}\n\tif resolvedv := reflect.ValueOf(resolved); out.Type() == resolvedv.Type() {\n\t\t// We've resolved to exactly the type we want, so use that.\n\t\tout.Set(resolvedv)\n\t\treturn true\n\t}\n\t// Perhaps we can use the value as a TextUnmarshaler to\n\t// set its value.\n\tif out.CanAddr() {\n\t\tu, ok := out.Addr().Interface().(encoding.TextUnmarshaler)\n\t\tif ok {\n\t\t\tvar text []byte\n\t\t\tif tag == yaml_BINARY_TAG {\n\t\t\t\ttext = []byte(resolved.(string))\n\t\t\t} else {\n\t\t\t\t// We let any value be unmarshaled into TextUnmarshaler.\n\t\t\t\t// That might be more lax than we'd like, but the\n\t\t\t\t// TextUnmarshaler itself should bowl out any dubious values.\n\t\t\t\ttext = []byte(n.value)\n\t\t\t}\n\t\t\terr := u.UnmarshalText(text)\n\t\t\tif err != nil {\n\t\t\t\tfail(err)\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t}\n\tswitch out.Kind() {\n\tcase reflect.String:\n\t\tif tag == yaml_BINARY_TAG {\n\t\t\tout.SetString(resolved.(string))\n\t\t\treturn true\n\t\t}\n\t\tif resolved != nil {\n\t\t\tout.SetString(n.value)\n\t\t\treturn true\n\t\t}\n\tcase reflect.Interface:\n\t\tif resolved == nil {\n\t\t\tout.Set(reflect.Zero(out.Type()))\n\t\t} else if tag == yaml_TIMESTAMP_TAG {\n\t\t\t// It looks like a timestamp but for backward compatibility\n\t\t\t// reasons we set it as a string, so that code that unmarshals\n\t\t\t// timestamp-like values into interface{} will continue to\n\t\t\t// see a string and not a time.Time.\n\t\t\t// TODO(v3) Drop this.\n\t\t\tout.Set(reflect.ValueOf(n.value))\n\t\t} else {\n\t\t\tout.Set(reflect.ValueOf(resolved))\n\t\t}\n\t\treturn true\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tswitch resolved := resolved.(type) {\n\t\tcase int:\n\t\t\tif !out.OverflowInt(int64(resolved)) {\n\t\t\t\tout.SetInt(int64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase int64:\n\t\t\tif !out.OverflowInt(resolved) {\n\t\t\t\tout.SetInt(resolved)\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase uint64:\n\t\t\tif resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {\n\t\t\t\tout.SetInt(int64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase float64:\n\t\t\tif resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {\n\t\t\t\tout.SetInt(int64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase string:\n\t\t\tif out.Type() == durationType {\n\t\t\t\td, err := time.ParseDuration(resolved)\n\t\t\t\tif err == nil {\n\t\t\t\t\tout.SetInt(int64(d))\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tswitch resolved := resolved.(type) {\n\t\tcase int:\n\t\t\tif resolved >= 0 && !out.OverflowUint(uint64(resolved)) {\n\t\t\t\tout.SetUint(uint64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase int64:\n\t\t\tif resolved >= 0 && !out.OverflowUint(uint64(resolved)) {\n\t\t\t\tout.SetUint(uint64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase uint64:\n\t\t\tif !out.OverflowUint(uint64(resolved)) {\n\t\t\t\tout.SetUint(uint64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase float64:\n\t\t\tif resolved <= math.MaxUint64 && !out.OverflowUint(uint64(resolved)) {\n\t\t\t\tout.SetUint(uint64(resolved))\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase reflect.Bool:\n\t\tswitch resolved := resolved.(type) {\n\t\tcase bool:\n\t\t\tout.SetBool(resolved)\n\t\t\treturn true\n\t\t}\n\tcase reflect.Float32, reflect.Float64:\n\t\tswitch resolved := resolved.(type) {\n\t\tcase int:\n\t\t\tout.SetFloat(float64(resolved))\n\t\t\treturn true\n\t\tcase int64:\n\t\t\tout.SetFloat(float64(resolved))\n\t\t\treturn true\n\t\tcase uint64:\n\t\t\tout.SetFloat(float64(resolved))\n\t\t\treturn true\n\t\tcase float64:\n\t\t\tout.SetFloat(resolved)\n\t\t\treturn true\n\t\t}\n\tcase reflect.Struct:\n\t\tif resolvedv := reflect.ValueOf(resolved); out.Type() == resolvedv.Type() {\n\t\t\tout.Set(resolvedv)\n\t\t\treturn true\n\t\t}\n\tcase reflect.Ptr:\n\t\tif out.Type().Elem() == reflect.TypeOf(resolved) {\n\t\t\t// TODO DOes this make sense? When is out a Ptr except when decoding a nil value?\n\t\t\telem := reflect.New(out.Type().Elem())\n\t\t\telem.Elem().Set(reflect.ValueOf(resolved))\n\t\t\tout.Set(elem)\n\t\t\treturn true\n\t\t}\n\t}\n\td.terror(n, tag, out)\n\treturn false\n}\n\nfunc settableValueOf(i interface{}) reflect.Value {\n\tv := reflect.ValueOf(i)\n\tsv := reflect.New(v.Type()).Elem()\n\tsv.Set(v)\n\treturn sv\n}\n\nfunc (d *decoder) sequence(n *node, out reflect.Value) (good bool) {\n\tl := len(n.children)\n\n\tvar iface reflect.Value\n\tswitch out.Kind() {\n\tcase reflect.Slice:\n\t\tout.Set(reflect.MakeSlice(out.Type(), l, l))\n\tcase reflect.Array:\n\t\tif l != out.Len() {\n\t\t\tfailf(\"invalid array: want %d elements but got %d\", out.Len(), l)\n\t\t}\n\tcase reflect.Interface:\n\t\t// No type hints. Will have to use a generic sequence.\n\t\tiface = out\n\t\tout = settableValueOf(make([]interface{}, l))\n\tdefault:\n\t\td.terror(n, yaml_SEQ_TAG, out)\n\t\treturn false\n\t}\n\tet := out.Type().Elem()\n\n\tj := 0\n\tfor i := 0; i < l; i++ {\n\t\te := reflect.New(et).Elem()\n\t\tif ok := d.unmarshal(n.children[i], e); ok {\n\t\t\tout.Index(j).Set(e)\n\t\t\tj++\n\t\t}\n\t}\n\tif out.Kind() != reflect.Array {\n\t\tout.Set(out.Slice(0, j))\n\t}\n\tif iface.IsValid() {\n\t\tiface.Set(out)\n\t}\n\treturn true\n}\n\nfunc (d *decoder) mapping(n *node, out reflect.Value) (good bool) {\n\tswitch out.Kind() {\n\tcase reflect.Struct:\n\t\treturn d.mappingStruct(n, out)\n\tcase reflect.Slice:\n\t\treturn d.mappingSlice(n, out)\n\tcase reflect.Map:\n\t\t// okay\n\tcase reflect.Interface:\n\t\tif d.mapType.Kind() == reflect.Map {\n\t\t\tiface := out\n\t\t\tout = reflect.MakeMap(d.mapType)\n\t\t\tiface.Set(out)\n\t\t} else {\n\t\t\tslicev := reflect.New(d.mapType).Elem()\n\t\t\tif !d.mappingSlice(n, slicev) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tout.Set(slicev)\n\t\t\treturn true\n\t\t}\n\tdefault:\n\t\td.terror(n, yaml_MAP_TAG, out)\n\t\treturn false\n\t}\n\toutt := out.Type()\n\tkt := outt.Key()\n\tet := outt.Elem()\n\n\tmapType := d.mapType\n\tif outt.Key() == ifaceType && outt.Elem() == ifaceType {\n\t\td.mapType = outt\n\t}\n\n\tif out.IsNil() {\n\t\tout.Set(reflect.MakeMap(outt))\n\t}\n\tl := len(n.children)\n\tfor i := 0; i < l; i += 2 {\n\t\tif isMerge(n.children[i]) {\n\t\t\td.merge(n.children[i+1], out)\n\t\t\tcontinue\n\t\t}\n\t\tk := reflect.New(kt).Elem()\n\t\tif d.unmarshal(n.children[i], k) {\n\t\t\tkkind := k.Kind()\n\t\t\tif kkind == reflect.Interface {\n\t\t\t\tkkind = k.Elem().Kind()\n\t\t\t}\n\t\t\tif kkind == reflect.Map || kkind == reflect.Slice {\n\t\t\t\tfailf(\"invalid map key: %#v\", k.Interface())\n\t\t\t}\n\t\t\te := reflect.New(et).Elem()\n\t\t\tif d.unmarshal(n.children[i+1], e) {\n\t\t\t\td.setMapIndex(n.children[i+1], out, k, e)\n\t\t\t}\n\t\t}\n\t}\n\td.mapType = mapType\n\treturn true\n}\n\nfunc (d *decoder) setMapIndex(n *node, out, k, v reflect.Value) {\n\tif d.strict && out.MapIndex(k) != zeroValue {\n\t\td.terrors = append(d.terrors, fmt.Sprintf(\"line %d: key %#v already set in map\", n.line+1, k.Interface()))\n\t\treturn\n\t}\n\tout.SetMapIndex(k, v)\n}\n\nfunc (d *decoder) mappingSlice(n *node, out reflect.Value) (good bool) {\n\toutt := out.Type()\n\tif outt.Elem() != mapItemType {\n\t\td.terror(n, yaml_MAP_TAG, out)\n\t\treturn false\n\t}\n\n\tmapType := d.mapType\n\td.mapType = outt\n\n\tvar slice []MapItem\n\tvar l = len(n.children)\n\tfor i := 0; i < l; i += 2 {\n\t\tif isMerge(n.children[i]) {\n\t\t\td.merge(n.children[i+1], out)\n\t\t\tcontinue\n\t\t}\n\t\titem := MapItem{}\n\t\tk := reflect.ValueOf(&item.Key).Elem()\n\t\tif d.unmarshal(n.children[i], k) {\n\t\t\tv := reflect.ValueOf(&item.Value).Elem()\n\t\t\tif d.unmarshal(n.children[i+1], v) {\n\t\t\t\tslice = append(slice, item)\n\t\t\t}\n\t\t}\n\t}\n\tout.Set(reflect.ValueOf(slice))\n\td.mapType = mapType\n\treturn true\n}\n\nfunc (d *decoder) mappingStruct(n *node, out reflect.Value) (good bool) {\n\tsinfo, err := getStructInfo(out.Type())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tname := settableValueOf(\"\")\n\tl := len(n.children)\n\n\tvar inlineMap reflect.Value\n\tvar elemType reflect.Type\n\tif sinfo.InlineMap != -1 {\n\t\tinlineMap = out.Field(sinfo.InlineMap)\n\t\tinlineMap.Set(reflect.New(inlineMap.Type()).Elem())\n\t\telemType = inlineMap.Type().Elem()\n\t}\n\n\tvar doneFields []bool\n\tif d.strict {\n\t\tdoneFields = make([]bool, len(sinfo.FieldsList))\n\t}\n\tfor i := 0; i < l; i += 2 {\n\t\tni := n.children[i]\n\t\tif isMerge(ni) {\n\t\t\td.merge(n.children[i+1], out)\n\t\t\tcontinue\n\t\t}\n\t\tif !d.unmarshal(ni, name) {\n\t\t\tcontinue\n\t\t}\n\t\tif info, ok := sinfo.FieldsMap[name.String()]; ok {\n\t\t\tif d.strict {\n\t\t\t\tif doneFields[info.Id] {\n\t\t\t\t\td.terrors = append(d.terrors, fmt.Sprintf(\"line %d: field %s already set in type %s\", ni.line+1, name.String(), out.Type()))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdoneFields[info.Id] = true\n\t\t\t}\n\t\t\tvar field reflect.Value\n\t\t\tif info.Inline == nil {\n\t\t\t\tfield = out.Field(info.Num)\n\t\t\t} else {\n\t\t\t\tfield = out.FieldByIndex(info.Inline)\n\t\t\t}\n\t\t\td.unmarshal(n.children[i+1], field)\n\t\t} else if sinfo.InlineMap != -1 {\n\t\t\tif inlineMap.IsNil() {\n\t\t\t\tinlineMap.Set(reflect.MakeMap(inlineMap.Type()))\n\t\t\t}\n\t\t\tvalue := reflect.New(elemType).Elem()\n\t\t\td.unmarshal(n.children[i+1], value)\n\t\t\td.setMapIndex(n.children[i+1], inlineMap, name, value)\n\t\t} else if d.strict {\n\t\t\td.terrors = append(d.terrors, fmt.Sprintf(\"line %d: field %s not found in type %s\", ni.line+1, name.String(), out.Type()))\n\t\t}\n\t}\n\treturn true\n}\n\nfunc failWantMap() {\n\tfailf(\"map merge requires map or sequence of maps as the value\")\n}\n\nfunc (d *decoder) merge(n *node, out reflect.Value) {\n\tswitch n.kind {\n\tcase mappingNode:\n\t\td.unmarshal(n, out)\n\tcase aliasNode:\n\t\tan, ok := d.doc.anchors[n.value]\n\t\tif ok && an.kind != mappingNode {\n\t\t\tfailWantMap()\n\t\t}\n\t\td.unmarshal(n, out)\n\tcase sequenceNode:\n\t\t// Step backwards as earlier nodes take precedence.\n\t\tfor i := len(n.children) - 1; i >= 0; i-- {\n\t\t\tni := n.children[i]\n\t\t\tif ni.kind == aliasNode {\n\t\t\t\tan, ok := d.doc.anchors[ni.value]\n\t\t\t\tif ok && an.kind != mappingNode {\n\t\t\t\t\tfailWantMap()\n\t\t\t\t}\n\t\t\t} else if ni.kind != mappingNode {\n\t\t\t\tfailWantMap()\n\t\t\t}\n\t\t\td.unmarshal(ni, out)\n\t\t}\n\tdefault:\n\t\tfailWantMap()\n\t}\n}\n\nfunc isMerge(n *node) bool {\n\treturn n.kind == scalarNode && n.value == \"<<\" && (n.implicit == true || n.tag == yaml_MERGE_TAG)\n}\n", "package yaml_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t. \"gopkg.in/check.v1\"\n\t\"gopkg.in/yaml.v2\"\n)\n\nvar unmarshalIntTest = 123\n\nvar unmarshalTests = []struct {\n\tdata  string\n\tvalue interface{}\n}{\n\t{\n\t\t\"\",\n\t\t(*struct{})(nil),\n\t},\n\t{\n\t\t\"{}\", &struct{}{},\n\t}, {\n\t\t\"v: hi\",\n\t\tmap[string]string{\"v\": \"hi\"},\n\t}, {\n\t\t\"v: hi\", map[string]interface{}{\"v\": \"hi\"},\n\t}, {\n\t\t\"v: true\",\n\t\tmap[string]string{\"v\": \"true\"},\n\t}, {\n\t\t\"v: true\",\n\t\tmap[string]interface{}{\"v\": true},\n\t}, {\n\t\t\"v: 10\",\n\t\tmap[string]interface{}{\"v\": 10},\n\t}, {\n\t\t\"v: 0b10\",\n\t\tmap[string]interface{}{\"v\": 2},\n\t}, {\n\t\t\"v: 0xA\",\n\t\tmap[string]interface{}{\"v\": 10},\n\t}, {\n\t\t\"v: 4294967296\",\n\t\tmap[string]int64{\"v\": 4294967296},\n\t}, {\n\t\t\"v: 0.1\",\n\t\tmap[string]interface{}{\"v\": 0.1},\n\t}, {\n\t\t\"v: .1\",\n\t\tmap[string]interface{}{\"v\": 0.1},\n\t}, {\n\t\t\"v: .Inf\",\n\t\tmap[string]interface{}{\"v\": math.Inf(+1)},\n\t}, {\n\t\t\"v: -.Inf\",\n\t\tmap[string]interface{}{\"v\": math.Inf(-1)},\n\t}, {\n\t\t\"v: -10\",\n\t\tmap[string]interface{}{\"v\": -10},\n\t}, {\n\t\t\"v: -.1\",\n\t\tmap[string]interface{}{\"v\": -0.1},\n\t},\n\n\t// Simple values.\n\t{\n\t\t\"123\",\n\t\t&unmarshalIntTest,\n\t},\n\n\t// Floats from spec\n\t{\n\t\t\"canonical: 6.8523e+5\",\n\t\tmap[string]interface{}{\"canonical\": 6.8523e+5},\n\t}, {\n\t\t\"expo: 685.230_15e+03\",\n\t\tmap[string]interface{}{\"expo\": 685.23015e+03},\n\t}, {\n\t\t\"fixed: 685_230.15\",\n\t\tmap[string]interface{}{\"fixed\": 685230.15},\n\t}, {\n\t\t\"neginf: -.inf\",\n\t\tmap[string]interface{}{\"neginf\": math.Inf(-1)},\n\t}, {\n\t\t\"fixed: 685_230.15\",\n\t\tmap[string]float64{\"fixed\": 685230.15},\n\t},\n\t//{\"sexa: 190:20:30.15\", map[string]interface{}{\"sexa\": 0}}, // Unsupported\n\t//{\"notanum: .NaN\", map[string]interface{}{\"notanum\": math.NaN()}}, // Equality of NaN fails.\n\n\t// Bools from spec\n\t{\n\t\t\"canonical: y\",\n\t\tmap[string]interface{}{\"canonical\": true},\n\t}, {\n\t\t\"answer: NO\",\n\t\tmap[string]interface{}{\"answer\": false},\n\t}, {\n\t\t\"logical: True\",\n\t\tmap[string]interface{}{\"logical\": true},\n\t}, {\n\t\t\"option: on\",\n\t\tmap[string]interface{}{\"option\": true},\n\t}, {\n\t\t\"option: on\",\n\t\tmap[string]bool{\"option\": true},\n\t},\n\t// Ints from spec\n\t{\n\t\t\"canonical: 685230\",\n\t\tmap[string]interface{}{\"canonical\": 685230},\n\t}, {\n\t\t\"decimal: +685_230\",\n\t\tmap[string]interface{}{\"decimal\": 685230},\n\t}, {\n\t\t\"octal: 02472256\",\n\t\tmap[string]interface{}{\"octal\": 685230},\n\t}, {\n\t\t\"hexa: 0x_0A_74_AE\",\n\t\tmap[string]interface{}{\"hexa\": 685230},\n\t}, {\n\t\t\"bin: 0b1010_0111_0100_1010_1110\",\n\t\tmap[string]interface{}{\"bin\": 685230},\n\t}, {\n\t\t\"bin: -0b101010\",\n\t\tmap[string]interface{}{\"bin\": -42},\n\t}, {\n\t\t\"bin: -0b1000000000000000000000000000000000000000000000000000000000000000\",\n\t\tmap[string]interface{}{\"bin\": -9223372036854775808},\n\t}, {\n\t\t\"decimal: +685_230\",\n\t\tmap[string]int{\"decimal\": 685230},\n\t},\n\n\t//{\"sexa: 190:20:30\", map[string]interface{}{\"sexa\": 0}}, // Unsupported\n\n\t// Nulls from spec\n\t{\n\t\t\"empty:\",\n\t\tmap[string]interface{}{\"empty\": nil},\n\t}, {\n\t\t\"canonical: ~\",\n\t\tmap[string]interface{}{\"canonical\": nil},\n\t}, {\n\t\t\"english: null\",\n\t\tmap[string]interface{}{\"english\": nil},\n\t}, {\n\t\t\"~: null key\",\n\t\tmap[interface{}]string{nil: \"null key\"},\n\t}, {\n\t\t\"empty:\",\n\t\tmap[string]*bool{\"empty\": nil},\n\t},\n\n\t// Flow sequence\n\t{\n\t\t\"seq: [A,B]\",\n\t\tmap[string]interface{}{\"seq\": []interface{}{\"A\", \"B\"}},\n\t}, {\n\t\t\"seq: [A,B,C,]\",\n\t\tmap[string][]string{\"seq\": []string{\"A\", \"B\", \"C\"}},\n\t}, {\n\t\t\"seq: [A,1,C]\",\n\t\tmap[string][]string{\"seq\": []string{\"A\", \"1\", \"C\"}},\n\t}, {\n\t\t\"seq: [A,1,C]\",\n\t\tmap[string][]int{\"seq\": []int{1}},\n\t}, {\n\t\t\"seq: [A,1,C]\",\n\t\tmap[string]interface{}{\"seq\": []interface{}{\"A\", 1, \"C\"}},\n\t},\n\t// Block sequence\n\t{\n\t\t\"seq:\\n - A\\n - B\",\n\t\tmap[string]interface{}{\"seq\": []interface{}{\"A\", \"B\"}},\n\t}, {\n\t\t\"seq:\\n - A\\n - B\\n - C\",\n\t\tmap[string][]string{\"seq\": []string{\"A\", \"B\", \"C\"}},\n\t}, {\n\t\t\"seq:\\n - A\\n - 1\\n - C\",\n\t\tmap[string][]string{\"seq\": []string{\"A\", \"1\", \"C\"}},\n\t}, {\n\t\t\"seq:\\n - A\\n - 1\\n - C\",\n\t\tmap[string][]int{\"seq\": []int{1}},\n\t}, {\n\t\t\"seq:\\n - A\\n - 1\\n - C\",\n\t\tmap[string]interface{}{\"seq\": []interface{}{\"A\", 1, \"C\"}},\n\t},\n\n\t// Literal block scalar\n\t{\n\t\t\"scalar: | # Comment\\n\\n literal\\n\\n \\ttext\\n\\n\",\n\t\tmap[string]string{\"scalar\": \"\\nliteral\\n\\n\\ttext\\n\"},\n\t},\n\n\t// Folded block scalar\n\t{\n\t\t\"scalar: > # Comment\\n\\n folded\\n line\\n \\n next\\n line\\n  * one\\n  * two\\n\\n last\\n line\\n\\n\",\n\t\tmap[string]string{\"scalar\": \"\\nfolded line\\nnext line\\n * one\\n * two\\n\\nlast line\\n\"},\n\t},\n\n\t// Map inside interface with no type hints.\n\t{\n\t\t\"a: {b: c}\",\n\t\tmap[interface{}]interface{}{\"a\": map[interface{}]interface{}{\"b\": \"c\"}},\n\t},\n\n\t// Structs and type conversions.\n\t{\n\t\t\"hello: world\",\n\t\t&struct{ Hello string }{\"world\"},\n\t}, {\n\t\t\"a: {b: c}\",\n\t\t&struct{ A struct{ B string } }{struct{ B string }{\"c\"}},\n\t}, {\n\t\t\"a: {b: c}\",\n\t\t&struct{ A *struct{ B string } }{&struct{ B string }{\"c\"}},\n\t}, {\n\t\t\"a: {b: c}\",\n\t\t&struct{ A map[string]string }{map[string]string{\"b\": \"c\"}},\n\t}, {\n\t\t\"a: {b: c}\",\n\t\t&struct{ A *map[string]string }{&map[string]string{\"b\": \"c\"}},\n\t}, {\n\t\t\"a:\",\n\t\t&struct{ A map[string]string }{},\n\t}, {\n\t\t\"a: 1\",\n\t\t&struct{ A int }{1},\n\t}, {\n\t\t\"a: 1\",\n\t\t&struct{ A float64 }{1},\n\t}, {\n\t\t\"a: 1.0\",\n\t\t&struct{ A int }{1},\n\t}, {\n\t\t\"a: 1.0\",\n\t\t&struct{ A uint }{1},\n\t}, {\n\t\t\"a: [1, 2]\",\n\t\t&struct{ A []int }{[]int{1, 2}},\n\t}, {\n\t\t\"a: [1, 2]\",\n\t\t&struct{ A [2]int }{[2]int{1, 2}},\n\t}, {\n\t\t\"a: 1\",\n\t\t&struct{ B int }{0},\n\t}, {\n\t\t\"a: 1\",\n\t\t&struct {\n\t\t\tB int \"a\"\n\t\t}{1},\n\t}, {\n\t\t\"a: y\",\n\t\t&struct{ A bool }{true},\n\t},\n\n\t// Some cross type conversions\n\t{\n\t\t\"v: 42\",\n\t\tmap[string]uint{\"v\": 42},\n\t}, {\n\t\t\"v: -42\",\n\t\tmap[string]uint{},\n\t}, {\n\t\t\"v: 4294967296\",\n\t\tmap[string]uint64{\"v\": 4294967296},\n\t}, {\n\t\t\"v: -4294967296\",\n\t\tmap[string]uint64{},\n\t},\n\n\t// int\n\t{\n\t\t\"int_max: 2147483647\",\n\t\tmap[string]int{\"int_max\": math.MaxInt32},\n\t},\n\t{\n\t\t\"int_min: -2147483648\",\n\t\tmap[string]int{\"int_min\": math.MinInt32},\n\t},\n\t{\n\t\t\"int_overflow: 9223372036854775808\", // math.MaxInt64 + 1\n\t\tmap[string]int{},\n\t},\n\n\t// int64\n\t{\n\t\t\"int64_max: 9223372036854775807\",\n\t\tmap[string]int64{\"int64_max\": math.MaxInt64},\n\t},\n\t{\n\t\t\"int64_max_base2: 0b111111111111111111111111111111111111111111111111111111111111111\",\n\t\tmap[string]int64{\"int64_max_base2\": math.MaxInt64},\n\t},\n\t{\n\t\t\"int64_min: -9223372036854775808\",\n\t\tmap[string]int64{\"int64_min\": math.MinInt64},\n\t},\n\t{\n\t\t\"int64_neg_base2: -0b111111111111111111111111111111111111111111111111111111111111111\",\n\t\tmap[string]int64{\"int64_neg_base2\": -math.MaxInt64},\n\t},\n\t{\n\t\t\"int64_overflow: 9223372036854775808\", // math.MaxInt64 + 1\n\t\tmap[string]int64{},\n\t},\n\n\t// uint\n\t{\n\t\t\"uint_min: 0\",\n\t\tmap[string]uint{\"uint_min\": 0},\n\t},\n\t{\n\t\t\"uint_max: 4294967295\",\n\t\tmap[string]uint{\"uint_max\": math.MaxUint32},\n\t},\n\t{\n\t\t\"uint_underflow: -1\",\n\t\tmap[string]uint{},\n\t},\n\n\t// uint64\n\t{\n\t\t\"uint64_min: 0\",\n\t\tmap[string]uint{\"uint64_min\": 0},\n\t},\n\t{\n\t\t\"uint64_max: 18446744073709551615\",\n\t\tmap[string]uint64{\"uint64_max\": math.MaxUint64},\n\t},\n\t{\n\t\t\"uint64_max_base2: 0b1111111111111111111111111111111111111111111111111111111111111111\",\n\t\tmap[string]uint64{\"uint64_max_base2\": math.MaxUint64},\n\t},\n\t{\n\t\t\"uint64_maxint64: 9223372036854775807\",\n\t\tmap[string]uint64{\"uint64_maxint64\": math.MaxInt64},\n\t},\n\t{\n\t\t\"uint64_underflow: -1\",\n\t\tmap[string]uint64{},\n\t},\n\n\t// float32\n\t{\n\t\t\"float32_max: 3.40282346638528859811704183484516925440e+38\",\n\t\tmap[string]float32{\"float32_max\": math.MaxFloat32},\n\t},\n\t{\n\t\t\"float32_nonzero: 1.401298464324817070923729583289916131280e-45\",\n\t\tmap[string]float32{\"float32_nonzero\": math.SmallestNonzeroFloat32},\n\t},\n\t{\n\t\t\"float32_maxuint64: 18446744073709551615\",\n\t\tmap[string]float32{\"float32_maxuint64\": float32(math.MaxUint64)},\n\t},\n\t{\n\t\t\"float32_maxuint64+1: 18446744073709551616\",\n\t\tmap[string]float32{\"float32_maxuint64+1\": float32(math.MaxUint64 + 1)},\n\t},\n\n\t// float64\n\t{\n\t\t\"float64_max: 1.797693134862315708145274237317043567981e+308\",\n\t\tmap[string]float64{\"float64_max\": math.MaxFloat64},\n\t},\n\t{\n\t\t\"float64_nonzero: 4.940656458412465441765687928682213723651e-324\",\n\t\tmap[string]float64{\"float64_nonzero\": math.SmallestNonzeroFloat64},\n\t},\n\t{\n\t\t\"float64_maxuint64: 18446744073709551615\",\n\t\tmap[string]float64{\"float64_maxuint64\": float64(math.MaxUint64)},\n\t},\n\t{\n\t\t\"float64_maxuint64+1: 18446744073709551616\",\n\t\tmap[string]float64{\"float64_maxuint64+1\": float64(math.MaxUint64 + 1)},\n\t},\n\n\t// Overflow cases.\n\t{\n\t\t\"v: 4294967297\",\n\t\tmap[string]int32{},\n\t}, {\n\t\t\"v: 128\",\n\t\tmap[string]int8{},\n\t},\n\n\t// Quoted values.\n\t{\n\t\t\"'1': '\\\"2\\\"'\",\n\t\tmap[interface{}]interface{}{\"1\": \"\\\"2\\\"\"},\n\t}, {\n\t\t\"v:\\n- A\\n- 'B\\n\\n  C'\\n\",\n\t\tmap[string][]string{\"v\": []string{\"A\", \"B\\nC\"}},\n\t},\n\n\t// Explicit tags.\n\t{\n\t\t\"v: !!float '1.1'\",\n\t\tmap[string]interface{}{\"v\": 1.1},\n\t}, {\n\t\t\"v: !!float 0\",\n\t\tmap[string]interface{}{\"v\": float64(0)},\n\t}, {\n\t\t\"v: !!float -1\",\n\t\tmap[string]interface{}{\"v\": float64(-1)},\n\t}, {\n\t\t\"v: !!null ''\",\n\t\tmap[string]interface{}{\"v\": nil},\n\t}, {\n\t\t\"%TAG !y! tag:yaml.org,2002:\\n---\\nv: !y!int '1'\",\n\t\tmap[string]interface{}{\"v\": 1},\n\t},\n\n\t// Non-specific tag (Issue #75)\n\t{\n\t\t\"v: ! test\",\n\t\tmap[string]interface{}{\"v\": \"test\"},\n\t},\n\n\t// Anchors and aliases.\n\t{\n\t\t\"a: &x 1\\nb: &y 2\\nc: *x\\nd: *y\\n\",\n\t\t&struct{ A, B, C, D int }{1, 2, 1, 2},\n\t}, {\n\t\t\"a: &a {c: 1}\\nb: *a\",\n\t\t&struct {\n\t\t\tA, B struct {\n\t\t\t\tC int\n\t\t\t}\n\t\t}{struct{ C int }{1}, struct{ C int }{1}},\n\t}, {\n\t\t\"a: &a [1, 2]\\nb: *a\",\n\t\t&struct{ B []int }{[]int{1, 2}},\n\t},\n\n\t// Bug #1133337\n\t{\n\t\t\"foo: ''\",\n\t\tmap[string]*string{\"foo\": new(string)},\n\t}, {\n\t\t\"foo: null\",\n\t\tmap[string]*string{\"foo\": nil},\n\t}, {\n\t\t\"foo: null\",\n\t\tmap[string]string{\"foo\": \"\"},\n\t}, {\n\t\t\"foo: null\",\n\t\tmap[string]interface{}{\"foo\": nil},\n\t},\n\n\t// Support for ~\n\t{\n\t\t\"foo: ~\",\n\t\tmap[string]*string{\"foo\": nil},\n\t}, {\n\t\t\"foo: ~\",\n\t\tmap[string]string{\"foo\": \"\"},\n\t}, {\n\t\t\"foo: ~\",\n\t\tmap[string]interface{}{\"foo\": nil},\n\t},\n\n\t// Ignored field\n\t{\n\t\t\"a: 1\\nb: 2\\n\",\n\t\t&struct {\n\t\t\tA int\n\t\t\tB int \"-\"\n\t\t}{1, 0},\n\t},\n\n\t// Bug #1191981\n\t{\n\t\t\"\" +\n\t\t\t\"%YAML 1.1\\n\" +\n\t\t\t\"--- !!str\\n\" +\n\t\t\t`\"Generic line break (no glyph)\\n\\` + \"\\n\" +\n\t\t\t` Generic line break (glyphed)\\n\\` + \"\\n\" +\n\t\t\t` Line separator\\u2028\\` + \"\\n\" +\n\t\t\t` Paragraph separator\\u2029\"` + \"\\n\",\n\t\t\"\" +\n\t\t\t\"Generic line break (no glyph)\\n\" +\n\t\t\t\"Generic line break (glyphed)\\n\" +\n\t\t\t\"Line separator\\u2028Paragraph separator\\u2029\",\n\t},\n\n\t// Struct inlining\n\t{\n\t\t\"a: 1\\nb: 2\\nc: 3\\n\",\n\t\t&struct {\n\t\t\tA int\n\t\t\tC inlineB `yaml:\",inline\"`\n\t\t}{1, inlineB{2, inlineC{3}}},\n\t},\n\n\t// Map inlining\n\t{\n\t\t\"a: 1\\nb: 2\\nc: 3\\n\",\n\t\t&struct {\n\t\t\tA int\n\t\t\tC map[string]int `yaml:\",inline\"`\n\t\t}{1, map[string]int{\"b\": 2, \"c\": 3}},\n\t},\n\n\t// bug 1243827\n\t{\n\t\t\"a: -b_c\",\n\t\tmap[string]interface{}{\"a\": \"-b_c\"},\n\t},\n\t{\n\t\t\"a: +b_c\",\n\t\tmap[string]interface{}{\"a\": \"+b_c\"},\n\t},\n\t{\n\t\t\"a: 50cent_of_dollar\",\n\t\tmap[string]interface{}{\"a\": \"50cent_of_dollar\"},\n\t},\n\n\t// issue #295 (allow scalars with colons in flow mappings and sequences)\n\t{\n\t\t\"a: {b: https://github.com/go-yaml/yaml}\",\n\t\tmap[string]interface{}{\"a\": map[interface{}]interface{}{\n\t\t\t\"b\": \"https://github.com/go-yaml/yaml\",\n\t\t}},\n\t},\n\t{\n\t\t\"a: [https://github.com/go-yaml/yaml]\",\n\t\tmap[string]interface{}{\"a\": []interface{}{\"https://github.com/go-yaml/yaml\"}},\n\t},\n\n\t// Duration\n\t{\n\t\t\"a: 3s\",\n\t\tmap[string]time.Duration{\"a\": 3 * time.Second},\n\t},\n\n\t// Issue #24.\n\t{\n\t\t\"a: <foo>\",\n\t\tmap[string]string{\"a\": \"<foo>\"},\n\t},\n\n\t// Base 60 floats are obsolete and unsupported.\n\t{\n\t\t\"a: 1:1\\n\",\n\t\tmap[string]string{\"a\": \"1:1\"},\n\t},\n\n\t// Binary data.\n\t{\n\t\t\"a: !!binary gIGC\\n\",\n\t\tmap[string]string{\"a\": \"\\x80\\x81\\x82\"},\n\t}, {\n\t\t\"a: !!binary |\\n  \" + strings.Repeat(\"kJCQ\", 17) + \"kJ\\n  CQ\\n\",\n\t\tmap[string]string{\"a\": strings.Repeat(\"\\x90\", 54)},\n\t}, {\n\t\t\"a: !!binary |\\n  \" + strings.Repeat(\"A\", 70) + \"\\n  ==\\n\",\n\t\tmap[string]string{\"a\": strings.Repeat(\"\\x00\", 52)},\n\t},\n\n\t// Ordered maps.\n\t{\n\t\t\"{b: 2, a: 1, d: 4, c: 3, sub: {e: 5}}\",\n\t\t&yaml.MapSlice{{\"b\", 2}, {\"a\", 1}, {\"d\", 4}, {\"c\", 3}, {\"sub\", yaml.MapSlice{{\"e\", 5}}}},\n\t},\n\n\t// Issue #39.\n\t{\n\t\t\"a:\\n b:\\n  c: d\\n\",\n\t\tmap[string]struct{ B interface{} }{\"a\": {map[interface{}]interface{}{\"c\": \"d\"}}},\n\t},\n\n\t// Custom map type.\n\t{\n\t\t\"a: {b: c}\",\n\t\tM{\"a\": M{\"b\": \"c\"}},\n\t},\n\n\t// Support encoding.TextUnmarshaler.\n\t{\n\t\t\"a: 1.2.3.4\\n\",\n\t\tmap[string]textUnmarshaler{\"a\": textUnmarshaler{S: \"1.2.3.4\"}},\n\t},\n\t{\n\t\t\"a: 2015-02-24T18:19:39Z\\n\",\n\t\tmap[string]textUnmarshaler{\"a\": textUnmarshaler{\"2015-02-24T18:19:39Z\"}},\n\t},\n\n\t// Timestamps\n\t{\n\t\t// Date only.\n\t\t\"a: 2015-01-01\\n\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 1, 1, 0, 0, 0, 0, time.UTC)},\n\t},\n\t{\n\t\t// RFC3339\n\t\t\"a: 2015-02-24T18:19:39.12Z\\n\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 2, 24, 18, 19, 39, .12e9, time.UTC)},\n\t},\n\t{\n\t\t// RFC3339 with short dates.\n\t\t\"a: 2015-2-3T3:4:5Z\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 2, 3, 3, 4, 5, 0, time.UTC)},\n\t},\n\t{\n\t\t// ISO8601 lower case t\n\t\t\"a: 2015-02-24t18:19:39Z\\n\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 2, 24, 18, 19, 39, 0, time.UTC)},\n\t},\n\t{\n\t\t// space separate, no time zone\n\t\t\"a: 2015-02-24 18:19:39\\n\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 2, 24, 18, 19, 39, 0, time.UTC)},\n\t},\n\t// Some cases not currently handled. Uncomment these when\n\t// the code is fixed.\n\t//\t{\n\t//\t\t// space separated with time zone\n\t//\t\t\"a: 2001-12-14 21:59:43.10 -5\",\n\t//\t\tmap[string]interface{}{\"a\": time.Date(2001, 12, 14, 21, 59, 43, .1e9, time.UTC)},\n\t//\t},\n\t//\t{\n\t//\t\t// arbitrary whitespace between fields\n\t//\t\t\"a: 2001-12-14 \\t\\t \\t21:59:43.10 \\t Z\",\n\t//\t\tmap[string]interface{}{\"a\": time.Date(2001, 12, 14, 21, 59, 43, .1e9, time.UTC)},\n\t//\t},\n\t{\n\t\t// explicit string tag\n\t\t\"a: !!str 2015-01-01\",\n\t\tmap[string]interface{}{\"a\": \"2015-01-01\"},\n\t},\n\t{\n\t\t// explicit timestamp tag on quoted string\n\t\t\"a: !!timestamp \\\"2015-01-01\\\"\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 1, 1, 0, 0, 0, 0, time.UTC)},\n\t},\n\t{\n\t\t// explicit timestamp tag on unquoted string\n\t\t\"a: !!timestamp 2015-01-01\",\n\t\tmap[string]time.Time{\"a\": time.Date(2015, 1, 1, 0, 0, 0, 0, time.UTC)},\n\t},\n\t{\n\t\t// quoted string that's a valid timestamp\n\t\t\"a: \\\"2015-01-01\\\"\",\n\t\tmap[string]interface{}{\"a\": \"2015-01-01\"},\n\t},\n\t{\n\t\t// explicit timestamp tag into interface.\n\t\t\"a: !!timestamp \\\"2015-01-01\\\"\",\n\t\tmap[string]interface{}{\"a\": \"2015-01-01\"},\n\t},\n\t{\n\t\t// implicit timestamp tag into interface.\n\t\t\"a: 2015-01-01\",\n\t\tmap[string]interface{}{\"a\": \"2015-01-01\"},\n\t},\n\n\t// Encode empty lists as zero-length slices.\n\t{\n\t\t\"a: []\",\n\t\t&struct{ A []int }{[]int{}},\n\t},\n\n\t// UTF-16-LE\n\t{\n\t\t\"\\xff\\xfe\\xf1\\x00o\\x00\\xf1\\x00o\\x00:\\x00 \\x00v\\x00e\\x00r\\x00y\\x00 \\x00y\\x00e\\x00s\\x00\\n\\x00\",\n\t\tM{\"\u00f1o\u00f1o\": \"very yes\"},\n\t},\n\t// UTF-16-LE with surrogate.\n\t{\n\t\t\"\\xff\\xfe\\xf1\\x00o\\x00\\xf1\\x00o\\x00:\\x00 \\x00v\\x00e\\x00r\\x00y\\x00 \\x00y\\x00e\\x00s\\x00 \\x00=\\xd8\\xd4\\xdf\\n\\x00\",\n\t\tM{\"\u00f1o\u00f1o\": \"very yes \ud83d\udfd4\"},\n\t},\n\n\t// UTF-16-BE\n\t{\n\t\t\"\\xfe\\xff\\x00\\xf1\\x00o\\x00\\xf1\\x00o\\x00:\\x00 \\x00v\\x00e\\x00r\\x00y\\x00 \\x00y\\x00e\\x00s\\x00\\n\",\n\t\tM{\"\u00f1o\u00f1o\": \"very yes\"},\n\t},\n\t// UTF-16-BE with surrogate.\n\t{\n\t\t\"\\xfe\\xff\\x00\\xf1\\x00o\\x00\\xf1\\x00o\\x00:\\x00 \\x00v\\x00e\\x00r\\x00y\\x00 \\x00y\\x00e\\x00s\\x00 \\xd8=\\xdf\\xd4\\x00\\n\",\n\t\tM{\"\u00f1o\u00f1o\": \"very yes \ud83d\udfd4\"},\n\t},\n\n\t// This *is* in fact a float number, per the spec. #171 was a mistake.\n\t{\n\t\t\"a: 123456e1\\n\",\n\t\tM{\"a\": 123456e1},\n\t}, {\n\t\t\"a: 123456E1\\n\",\n\t\tM{\"a\": 123456E1},\n\t},\n\t// yaml-test-suite 3GZX: Spec Example 7.1. Alias Nodes\n\t{\n\t\t\"First occurrence: &anchor Foo\\nSecond occurrence: *anchor\\nOverride anchor: &anchor Bar\\nReuse anchor: *anchor\\n\",\n\t\tmap[interface{}]interface{}{\n\t\t\t\"Reuse anchor\":      \"Bar\",\n\t\t\t\"First occurrence\":  \"Foo\",\n\t\t\t\"Second occurrence\": \"Foo\",\n\t\t\t\"Override anchor\":   \"Bar\",\n\t\t},\n\t},\n\t// Single document with garbage following it.\n\t{\n\t\t\"---\\nhello\\n...\\n}not yaml\",\n\t\t\"hello\",\n\t},\n\t{\n\t\t\"a: 5\\n\",\n\t\t&struct{ A jsonNumberT }{\"5\"},\n\t},\n\t{\n\t\t\"a: 5.5\\n\",\n\t\t&struct{ A jsonNumberT }{\"5.5\"},\n\t},\n}\n\ntype M map[interface{}]interface{}\n\ntype inlineB struct {\n\tB       int\n\tinlineC `yaml:\",inline\"`\n}\n\ntype inlineC struct {\n\tC int\n}\n\nfunc (s *S) TestUnmarshal(c *C) {\n\tfor i, item := range unmarshalTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\tt := reflect.ValueOf(item.value).Type()\n\t\tvalue := reflect.New(t)\n\t\terr := yaml.Unmarshal([]byte(item.data), value.Interface())\n\t\tif _, ok := err.(*yaml.TypeError); !ok {\n\t\t\tc.Assert(err, IsNil)\n\t\t}\n\t\tc.Assert(value.Elem().Interface(), DeepEquals, item.value, Commentf(\"error: %v\", err))\n\t}\n}\n\n// TODO(v3): This test should also work when unmarshaling onto an interface{}.\nfunc (s *S) TestUnmarshalFullTimestamp(c *C) {\n\t// Full timestamp in same format as encoded. This is confirmed to be\n\t// properly decoded by Python as a timestamp as well.\n\tvar str = \"2015-02-24T18:19:39.123456789-03:00\"\n\tvar t time.Time\n\terr := yaml.Unmarshal([]byte(str), &t)\n\tc.Assert(err, IsNil)\n\tc.Assert(t, Equals, time.Date(2015, 2, 24, 18, 19, 39, 123456789, t.Location()))\n\tc.Assert(t.In(time.UTC), Equals, time.Date(2015, 2, 24, 21, 19, 39, 123456789, time.UTC))\n}\n\nfunc (s *S) TestDecoderSingleDocument(c *C) {\n\t// Test that Decoder.Decode works as expected on\n\t// all the unmarshal tests.\n\tfor i, item := range unmarshalTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\tif item.data == \"\" {\n\t\t\t// Behaviour differs when there's no YAML.\n\t\t\tcontinue\n\t\t}\n\t\tt := reflect.ValueOf(item.value).Type()\n\t\tvalue := reflect.New(t)\n\t\terr := yaml.NewDecoder(strings.NewReader(item.data)).Decode(value.Interface())\n\t\tif _, ok := err.(*yaml.TypeError); !ok {\n\t\t\tc.Assert(err, IsNil)\n\t\t}\n\t\tc.Assert(value.Elem().Interface(), DeepEquals, item.value)\n\t}\n}\n\nvar decoderTests = []struct {\n\tdata   string\n\tvalues []interface{}\n}{{\n\t\"\",\n\tnil,\n}, {\n\t\"a: b\",\n\t[]interface{}{\n\t\tmap[interface{}]interface{}{\"a\": \"b\"},\n\t},\n}, {\n\t\"---\\na: b\\n...\\n\",\n\t[]interface{}{\n\t\tmap[interface{}]interface{}{\"a\": \"b\"},\n\t},\n}, {\n\t\"---\\n'hello'\\n...\\n---\\ngoodbye\\n...\\n\",\n\t[]interface{}{\n\t\t\"hello\",\n\t\t\"goodbye\",\n\t},\n}}\n\nfunc (s *S) TestDecoder(c *C) {\n\tfor i, item := range decoderTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\tvar values []interface{}\n\t\tdec := yaml.NewDecoder(strings.NewReader(item.data))\n\t\tfor {\n\t\t\tvar value interface{}\n\t\t\terr := dec.Decode(&value)\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc.Assert(err, IsNil)\n\t\t\tvalues = append(values, value)\n\t\t}\n\t\tc.Assert(values, DeepEquals, item.values)\n\t}\n}\n\ntype errReader struct{}\n\nfunc (errReader) Read([]byte) (int, error) {\n\treturn 0, errors.New(\"some read error\")\n}\n\nfunc (s *S) TestDecoderReadError(c *C) {\n\terr := yaml.NewDecoder(errReader{}).Decode(&struct{}{})\n\tc.Assert(err, ErrorMatches, `yaml: input error: some read error`)\n}\n\nfunc (s *S) TestUnmarshalNaN(c *C) {\n\tvalue := map[string]interface{}{}\n\terr := yaml.Unmarshal([]byte(\"notanum: .NaN\"), &value)\n\tc.Assert(err, IsNil)\n\tc.Assert(math.IsNaN(value[\"notanum\"].(float64)), Equals, true)\n}\n\nvar unmarshalErrorTests = []struct {\n\tdata, error string\n}{\n\t{\"v: !!float 'error'\", \"yaml: cannot decode !!str `error` as a !!float\"},\n\t{\"v: [A,\", \"yaml: line 1: did not find expected node content\"},\n\t{\"v:\\n- [A,\", \"yaml: line 2: did not find expected node content\"},\n\t{\"a:\\n- b: *,\", \"yaml: line 2: did not find expected alphabetic or numeric character\"},\n\t{\"a: *b\\n\", \"yaml: unknown anchor 'b' referenced\"},\n\t{\"a: &a\\n  b: *a\\n\", \"yaml: anchor 'a' value contains itself\"},\n\t{\"value: -\", \"yaml: block sequence entries are not allowed in this context\"},\n\t{\"a: !!binary ==\", \"yaml: !!binary value contains invalid base64 data\"},\n\t{\"{[.]}\", `yaml: invalid map key: \\[\\]interface \\{\\}\\{\"\\.\"\\}`},\n\t{\"{{.}}\", `yaml: invalid map key: map\\[interface\\ \\{\\}\\]interface \\{\\}\\{\".\":interface \\{\\}\\(nil\\)\\}`},\n\t{\"b: *a\\na: &a {c: 1}\", `yaml: unknown anchor 'a' referenced`},\n\t{\"%TAG !%79! tag:yaml.org,2002:\\n---\\nv: !%79!int '1'\", \"yaml: did not find expected whitespace\"},\n\t{\n\t\t\"a: &a [00,00,00,00,00,00,00,00,00]\\n\" +\n\t\t\"b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]\\n\" +\n\t\t\"c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]\\n\" +\n\t\t\"d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]\\n\" +\n\t\t\"e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]\\n\" +\n\t\t\"f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]\\n\" +\n\t\t\"g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]\\n\" +\n\t\t\"h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]\\n\" +\n\t\t\"i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]\\n\",\n\t\t\"yaml: document contains excessive aliasing\",\n\t},\n}\n\nfunc (s *S) TestUnmarshalErrors(c *C) {\n\tfor i, item := range unmarshalErrorTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\tvar value interface{}\n\t\terr := yaml.Unmarshal([]byte(item.data), &value)\n\t\tc.Assert(err, ErrorMatches, item.error, Commentf(\"Partial unmarshal: %#v\", value))\n\t}\n}\n\nfunc (s *S) TestDecoderErrors(c *C) {\n\tfor _, item := range unmarshalErrorTests {\n\t\tvar value interface{}\n\t\terr := yaml.NewDecoder(strings.NewReader(item.data)).Decode(&value)\n\t\tc.Assert(err, ErrorMatches, item.error, Commentf(\"Partial unmarshal: %#v\", value))\n\t}\n}\n\nvar unmarshalerTests = []struct {\n\tdata, tag string\n\tvalue     interface{}\n}{\n\t{\"_: {hi: there}\", \"!!map\", map[interface{}]interface{}{\"hi\": \"there\"}},\n\t{\"_: [1,A]\", \"!!seq\", []interface{}{1, \"A\"}},\n\t{\"_: 10\", \"!!int\", 10},\n\t{\"_: null\", \"!!null\", nil},\n\t{`_: BAR!`, \"!!str\", \"BAR!\"},\n\t{`_: \"BAR!\"`, \"!!str\", \"BAR!\"},\n\t{\"_: !!foo 'BAR!'\", \"!!foo\", \"BAR!\"},\n\t{`_: \"\"`, \"!!str\", \"\"},\n}\n\nvar unmarshalerResult = map[int]error{}\n\ntype unmarshalerType struct {\n\tvalue interface{}\n}\n\nfunc (o *unmarshalerType) UnmarshalYAML(unmarshal func(v interface{}) error) error {\n\tif err := unmarshal(&o.value); err != nil {\n\t\treturn err\n\t}\n\tif i, ok := o.value.(int); ok {\n\t\tif result, ok := unmarshalerResult[i]; ok {\n\t\t\treturn result\n\t\t}\n\t}\n\treturn nil\n}\n\ntype unmarshalerPointer struct {\n\tField *unmarshalerType \"_\"\n}\n\ntype unmarshalerValue struct {\n\tField unmarshalerType \"_\"\n}\n\nfunc (s *S) TestUnmarshalerPointerField(c *C) {\n\tfor _, item := range unmarshalerTests {\n\t\tobj := &unmarshalerPointer{}\n\t\terr := yaml.Unmarshal([]byte(item.data), obj)\n\t\tc.Assert(err, IsNil)\n\t\tif item.value == nil {\n\t\t\tc.Assert(obj.Field, IsNil)\n\t\t} else {\n\t\t\tc.Assert(obj.Field, NotNil, Commentf(\"Pointer not initialized (%#v)\", item.value))\n\t\t\tc.Assert(obj.Field.value, DeepEquals, item.value)\n\t\t}\n\t}\n}\n\nfunc (s *S) TestUnmarshalerValueField(c *C) {\n\tfor _, item := range unmarshalerTests {\n\t\tobj := &unmarshalerValue{}\n\t\terr := yaml.Unmarshal([]byte(item.data), obj)\n\t\tc.Assert(err, IsNil)\n\t\tc.Assert(obj.Field, NotNil, Commentf(\"Pointer not initialized (%#v)\", item.value))\n\t\tc.Assert(obj.Field.value, DeepEquals, item.value)\n\t}\n}\n\nfunc (s *S) TestUnmarshalerWholeDocument(c *C) {\n\tobj := &unmarshalerType{}\n\terr := yaml.Unmarshal([]byte(unmarshalerTests[0].data), obj)\n\tc.Assert(err, IsNil)\n\tvalue, ok := obj.value.(map[interface{}]interface{})\n\tc.Assert(ok, Equals, true, Commentf(\"value: %#v\", obj.value))\n\tc.Assert(value[\"_\"], DeepEquals, unmarshalerTests[0].value)\n}\n\nfunc (s *S) TestUnmarshalerTypeError(c *C) {\n\tunmarshalerResult[2] = &yaml.TypeError{[]string{\"foo\"}}\n\tunmarshalerResult[4] = &yaml.TypeError{[]string{\"bar\"}}\n\tdefer func() {\n\t\tdelete(unmarshalerResult, 2)\n\t\tdelete(unmarshalerResult, 4)\n\t}()\n\n\ttype T struct {\n\t\tBefore int\n\t\tAfter  int\n\t\tM      map[string]*unmarshalerType\n\t}\n\tvar v T\n\tdata := `{before: A, m: {abc: 1, def: 2, ghi: 3, jkl: 4}, after: B}`\n\terr := yaml.Unmarshal([]byte(data), &v)\n\tc.Assert(err, ErrorMatches, \"\"+\n\t\t\"yaml: unmarshal errors:\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `A` into int\\n\"+\n\t\t\"  foo\\n\"+\n\t\t\"  bar\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `B` into int\")\n\tc.Assert(v.M[\"abc\"], NotNil)\n\tc.Assert(v.M[\"def\"], IsNil)\n\tc.Assert(v.M[\"ghi\"], NotNil)\n\tc.Assert(v.M[\"jkl\"], IsNil)\n\n\tc.Assert(v.M[\"abc\"].value, Equals, 1)\n\tc.Assert(v.M[\"ghi\"].value, Equals, 3)\n}\n\ntype proxyTypeError struct{}\n\nfunc (v *proxyTypeError) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar s string\n\tvar a int32\n\tvar b int64\n\tif err := unmarshal(&s); err != nil {\n\t\tpanic(err)\n\t}\n\tif s == \"a\" {\n\t\tif err := unmarshal(&b); err == nil {\n\t\t\tpanic(\"should have failed\")\n\t\t}\n\t\treturn unmarshal(&a)\n\t}\n\tif err := unmarshal(&a); err == nil {\n\t\tpanic(\"should have failed\")\n\t}\n\treturn unmarshal(&b)\n}\n\nfunc (s *S) TestUnmarshalerTypeErrorProxying(c *C) {\n\ttype T struct {\n\t\tBefore int\n\t\tAfter  int\n\t\tM      map[string]*proxyTypeError\n\t}\n\tvar v T\n\tdata := `{before: A, m: {abc: a, def: b}, after: B}`\n\terr := yaml.Unmarshal([]byte(data), &v)\n\tc.Assert(err, ErrorMatches, \"\"+\n\t\t\"yaml: unmarshal errors:\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `A` into int\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `a` into int32\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `b` into int64\\n\"+\n\t\t\"  line 1: cannot unmarshal !!str `B` into int\")\n}\n\ntype failingUnmarshaler struct{}\n\nvar failingErr = errors.New(\"failingErr\")\n\nfunc (ft *failingUnmarshaler) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\treturn failingErr\n}\n\nfunc (s *S) TestUnmarshalerError(c *C) {\n\terr := yaml.Unmarshal([]byte(\"a: b\"), &failingUnmarshaler{})\n\tc.Assert(err, Equals, failingErr)\n}\n\ntype sliceUnmarshaler []int\n\nfunc (su *sliceUnmarshaler) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar slice []int\n\terr := unmarshal(&slice)\n\tif err == nil {\n\t\t*su = slice\n\t\treturn nil\n\t}\n\n\tvar intVal int\n\terr = unmarshal(&intVal)\n\tif err == nil {\n\t\t*su = []int{intVal}\n\t\treturn nil\n\t}\n\n\treturn err\n}\n\nfunc (s *S) TestUnmarshalerRetry(c *C) {\n\tvar su sliceUnmarshaler\n\terr := yaml.Unmarshal([]byte(\"[1, 2, 3]\"), &su)\n\tc.Assert(err, IsNil)\n\tc.Assert(su, DeepEquals, sliceUnmarshaler([]int{1, 2, 3}))\n\n\terr = yaml.Unmarshal([]byte(\"1\"), &su)\n\tc.Assert(err, IsNil)\n\tc.Assert(su, DeepEquals, sliceUnmarshaler([]int{1}))\n}\n\n// From http://yaml.org/type/merge.html\nvar mergeTests = `\nanchors:\n  list:\n    - &CENTER { \"x\": 1, \"y\": 2 }\n    - &LEFT   { \"x\": 0, \"y\": 2 }\n    - &BIG    { \"r\": 10 }\n    - &SMALL  { \"r\": 1 }\n\n# All the following maps are equal:\n\nplain:\n  # Explicit keys\n  \"x\": 1\n  \"y\": 2\n  \"r\": 10\n  label: center/big\n\nmergeOne:\n  # Merge one map\n  << : *CENTER\n  \"r\": 10\n  label: center/big\n\nmergeMultiple:\n  # Merge multiple maps\n  << : [ *CENTER, *BIG ]\n  label: center/big\n\noverride:\n  # Override\n  << : [ *BIG, *LEFT, *SMALL ]\n  \"x\": 1\n  label: center/big\n\nshortTag:\n  # Explicit short merge tag\n  !!merge \"<<\" : [ *CENTER, *BIG ]\n  label: center/big\n\nlongTag:\n  # Explicit merge long tag\n  !<tag:yaml.org,2002:merge> \"<<\" : [ *CENTER, *BIG ]\n  label: center/big\n\ninlineMap:\n  # Inlined map \n  << : {\"x\": 1, \"y\": 2, \"r\": 10}\n  label: center/big\n\ninlineSequenceMap:\n  # Inlined map in sequence\n  << : [ *CENTER, {\"r\": 10} ]\n  label: center/big\n`\n\nfunc (s *S) TestMerge(c *C) {\n\tvar want = map[interface{}]interface{}{\n\t\t\"x\":     1,\n\t\t\"y\":     2,\n\t\t\"r\":     10,\n\t\t\"label\": \"center/big\",\n\t}\n\n\tvar m map[interface{}]interface{}\n\terr := yaml.Unmarshal([]byte(mergeTests), &m)\n\tc.Assert(err, IsNil)\n\tfor name, test := range m {\n\t\tif name == \"anchors\" {\n\t\t\tcontinue\n\t\t}\n\t\tc.Assert(test, DeepEquals, want, Commentf(\"test %q failed\", name))\n\t}\n}\n\nfunc (s *S) TestMergeStruct(c *C) {\n\ttype Data struct {\n\t\tX, Y, R int\n\t\tLabel   string\n\t}\n\twant := Data{1, 2, 10, \"center/big\"}\n\n\tvar m map[string]Data\n\terr := yaml.Unmarshal([]byte(mergeTests), &m)\n\tc.Assert(err, IsNil)\n\tfor name, test := range m {\n\t\tif name == \"anchors\" {\n\t\t\tcontinue\n\t\t}\n\t\tc.Assert(test, Equals, want, Commentf(\"test %q failed\", name))\n\t}\n}\n\nvar unmarshalNullTests = []func() interface{}{\n\tfunc() interface{} { var v interface{}; v = \"v\"; return &v },\n\tfunc() interface{} { var s = \"s\"; return &s },\n\tfunc() interface{} { var s = \"s\"; sptr := &s; return &sptr },\n\tfunc() interface{} { var i = 1; return &i },\n\tfunc() interface{} { var i = 1; iptr := &i; return &iptr },\n\tfunc() interface{} { m := map[string]int{\"s\": 1}; return &m },\n\tfunc() interface{} { m := map[string]int{\"s\": 1}; return m },\n}\n\nfunc (s *S) TestUnmarshalNull(c *C) {\n\tfor _, test := range unmarshalNullTests {\n\t\titem := test()\n\t\tzero := reflect.Zero(reflect.TypeOf(item).Elem()).Interface()\n\t\terr := yaml.Unmarshal([]byte(\"null\"), item)\n\t\tc.Assert(err, IsNil)\n\t\tif reflect.TypeOf(item).Kind() == reflect.Map {\n\t\t\tc.Assert(reflect.ValueOf(item).Interface(), DeepEquals, reflect.MakeMap(reflect.TypeOf(item)).Interface())\n\t\t} else {\n\t\t\tc.Assert(reflect.ValueOf(item).Elem().Interface(), DeepEquals, zero)\n\t\t}\n\t}\n}\n\nfunc (s *S) TestUnmarshalSliceOnPreset(c *C) {\n\t// Issue #48.\n\tv := struct{ A []int }{[]int{1}}\n\tyaml.Unmarshal([]byte(\"a: [2]\"), &v)\n\tc.Assert(v.A, DeepEquals, []int{2})\n}\n\nvar unmarshalStrictTests = []struct {\n\tdata  string\n\tvalue interface{}\n\terror string\n}{{\n\tdata:  \"a: 1\\nc: 2\\n\",\n\tvalue: struct{ A, B int }{A: 1},\n\terror: `yaml: unmarshal errors:\\n  line 2: field c not found in type struct { A int; B int }`,\n}, {\n\tdata:  \"a: 1\\nb: 2\\na: 3\\n\",\n\tvalue: struct{ A, B int }{A: 3, B: 2},\n\terror: `yaml: unmarshal errors:\\n  line 3: field a already set in type struct { A int; B int }`,\n}, {\n\tdata: \"c: 3\\na: 1\\nb: 2\\nc: 4\\n\",\n\tvalue: struct {\n\t\tA       int\n\t\tinlineB `yaml:\",inline\"`\n\t}{\n\t\tA: 1,\n\t\tinlineB: inlineB{\n\t\t\tB: 2,\n\t\t\tinlineC: inlineC{\n\t\t\t\tC: 4,\n\t\t\t},\n\t\t},\n\t},\n\terror: `yaml: unmarshal errors:\\n  line 4: field c already set in type struct { A int; yaml_test.inlineB \"yaml:\\\\\",inline\\\\\"\" }`,\n}, {\n\tdata: \"c: 0\\na: 1\\nb: 2\\nc: 1\\n\",\n\tvalue: struct {\n\t\tA       int\n\t\tinlineB `yaml:\",inline\"`\n\t}{\n\t\tA: 1,\n\t\tinlineB: inlineB{\n\t\t\tB: 2,\n\t\t\tinlineC: inlineC{\n\t\t\t\tC: 1,\n\t\t\t},\n\t\t},\n\t},\n\terror: `yaml: unmarshal errors:\\n  line 4: field c already set in type struct { A int; yaml_test.inlineB \"yaml:\\\\\",inline\\\\\"\" }`,\n}, {\n\tdata: \"c: 1\\na: 1\\nb: 2\\nc: 3\\n\",\n\tvalue: struct {\n\t\tA int\n\t\tM map[string]interface{} `yaml:\",inline\"`\n\t}{\n\t\tA: 1,\n\t\tM: map[string]interface{}{\n\t\t\t\"b\": 2,\n\t\t\t\"c\": 3,\n\t\t},\n\t},\n\terror: `yaml: unmarshal errors:\\n  line 4: key \"c\" already set in map`,\n}, {\n\tdata: \"a: 1\\n9: 2\\nnull: 3\\n9: 4\",\n\tvalue: map[interface{}]interface{}{\n\t\t\"a\": 1,\n\t\tnil: 3,\n\t\t9:   4,\n\t},\n\terror: `yaml: unmarshal errors:\\n  line 4: key 9 already set in map`,\n}}\n\nfunc (s *S) TestUnmarshalStrict(c *C) {\n\tfor i, item := range unmarshalStrictTests {\n\t\tc.Logf(\"test %d: %q\", i, item.data)\n\t\t// First test that normal Unmarshal unmarshals to the expected value.\n\t\tt := reflect.ValueOf(item.value).Type()\n\t\tvalue := reflect.New(t)\n\t\terr := yaml.Unmarshal([]byte(item.data), value.Interface())\n\t\tc.Assert(err, Equals, nil)\n\t\tc.Assert(value.Elem().Interface(), DeepEquals, item.value)\n\n\t\t// Then test that UnmarshalStrict fails on the same thing.\n\t\tt = reflect.ValueOf(item.value).Type()\n\t\tvalue = reflect.New(t)\n\t\terr = yaml.UnmarshalStrict([]byte(item.data), value.Interface())\n\t\tc.Assert(err, ErrorMatches, item.error)\n\t}\n}\n\ntype textUnmarshaler struct {\n\tS string\n}\n\nfunc (t *textUnmarshaler) UnmarshalText(s []byte) error {\n\tt.S = string(s)\n\treturn nil\n}\n\nfunc (s *S) TestFuzzCrashers(c *C) {\n\tcases := []string{\n\t\t// runtime error: index out of range\n\t\t\"\\\"\\\\0\\\\\\r\\n\",\n\n\t\t// should not happen\n\t\t\"  0: [\\n] 0\",\n\t\t\"? ? \\\"\\n\\\" 0\",\n\t\t\"    - {\\n000}0\",\n\t\t\"0:\\n  0: [0\\n] 0\",\n\t\t\"    - \\\"\\n000\\\"0\",\n\t\t\"    - \\\"\\n000\\\"\\\"\",\n\t\t\"0:\\n    - {\\n000}0\",\n\t\t\"0:\\n    - \\\"\\n000\\\"0\",\n\t\t\"0:\\n    - \\\"\\n000\\\"\\\"\",\n\n\t\t// runtime error: index out of range\n\t\t\" \\ufeff\\n\",\n\t\t\"? \\ufeff\\n\",\n\t\t\"? \\ufeff:\\n\",\n\t\t\"0: \\ufeff\\n\",\n\t\t\"? \\ufeff: \\ufeff\\n\",\n\t}\n\tfor _, data := range cases {\n\t\tvar v interface{}\n\t\t_ = yaml.Unmarshal([]byte(data), &v)\n\t}\n}\n\n//var data []byte\n//func init() {\n//\tvar err error\n//\tdata, err = ioutil.ReadFile(\"/tmp/file.yaml\")\n//\tif err != nil {\n//\t\tpanic(err)\n//\t}\n//}\n//\n//func (s *S) BenchmarkUnmarshal(c *C) {\n//\tvar err error\n//\tfor i := 0; i < c.N; i++ {\n//\t\tvar v map[string]interface{}\n//\t\terr = yaml.Unmarshal(data, &v)\n//\t}\n//\tif err != nil {\n//\t\tpanic(err)\n//\t}\n//}\n//\n//func (s *S) BenchmarkMarshal(c *C) {\n//\tvar v map[string]interface{}\n//\tyaml.Unmarshal(data, &v)\n//\tc.ResetTimer()\n//\tfor i := 0; i < c.N; i++ {\n//\t\tyaml.Marshal(&v)\n//\t}\n//}\n"], "filenames": ["decode.go", "decode_test.go"], "buggy_code_start_loc": [231, 856], "buggy_code_end_loc": [356, 856], "fixing_code_start_loc": [232, 857], "fixing_code_end_loc": [370, 869], "type": "NVD-CWE-noinfo", "message": "Due to unbounded alias chasing, a maliciously crafted YAML file can cause the system to consume significant system resources. If parsing user input, this may be used as a denial of service vector.", "other": {"cve": {"id": "CVE-2021-4235", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.960", "lastModified": "2023-01-06T01:28:42.380", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Due to unbounded alias chasing, a maliciously crafted YAML file can cause the system to consume significant system resources. If parsing user input, this may be used as a denial of service vector."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yaml_project:yaml:*:*:*:*:*:go:*:*", "versionEndExcluding": "2.2.3", "matchCriteriaId": "6ADB4662-19BA-4FB2-88FB-0D8309DE5DB0"}]}]}], "references": [{"url": "https://github.com/go-yaml/yaml/commit/bb4e33bf68bf89cad44d386192cbed201f35b241", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/go-yaml/yaml/pull/375", "source": "security@golang.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2021-0061", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/go-yaml/yaml/commit/bb4e33bf68bf89cad44d386192cbed201f35b241"}}