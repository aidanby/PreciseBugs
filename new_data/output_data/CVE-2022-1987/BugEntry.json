{"buggy_code": ["2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input\n2022-05-02: Fix typo in macro name\n2022-04-27: Fix undefined behavior when passing null to strdup\n2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input\n2022-04-26: Fix text formatting\n2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input\n2022-04-23: Fix formatting\n2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data\n2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer\n2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input\n2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference\n2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read\n2022-04-13: Add packaging status [skip ci]\n2022-04-10: Make random generation return proper error codes\n2022-04-10: Rewrite randombytes for libmobi\n2022-04-07: Add libsodium randombytes.c\n2022-04-10: Fix \"fallthrough\" spelling\n2022-04-10: Make declaration match definition\n2022-04-10: Fix different sign comparison warning\n2022-04-10: Update Xcode project\n2022-04-10: Don't run tests if bash is missing\n2022-04-10: Looking for libxml2, first try pkg-config\n2022-04-04: Update MSVC project\n2022-04-02: Add support for GNU/kFreeBSD and GNU/Hurd\n2022-04-02: Check for inline, noreturn support in CMake\n2022-03-27: Fix format truncation warning\n2022-03-21: Version 0.10\n2022-03-21: Update Xcode project [skip ci]\n2022-03-21: Add functions for retrieving orthographic index entries\n2022-02-27: Add basic CMake support\n2022-02-26: GHA: fetch tags with checkout\n2022-02-26: Minor refactoring of file path manipulation function\n2022-02-26: Fix memory handling issues\n2022-02-26: Add coverity scan workflow\n2022-02-25: Remove obsolete changelog\n2022-02-25: Fix md5sum output on Windows\n2022-02-25: Fix inconsistent separators in path on Windows builds\n2022-02-25: GHA: fix log paths\n2022-02-25: GHA: fix workflow syntax\n2022-02-25: GHA: upload test logs on failure\n2022-02-24: Fix printf format specifier\n2022-02-24: Fix sample path in Makefile\n2022-02-24: Missing autotools in mingw workflow\n2022-02-24: Windows doesn't accept asterisk in file names\n2022-02-24: Update workflow, add badge\n2022-02-24: Add mingw workflow\n2022-02-24: Fix tests in out-of-tree build\n2022-02-24: Update man pages\n2022-02-24: Replace non-portable strptime\n2022-02-24: Make sure both validity period dates are set\n2022-02-21: Fix strptime not found on linux build\n2022-02-21: Add build github action\n2022-02-21: Update README\n2022-02-21: Minor code cleanups\n2022-02-21: Unify boolean and static usage in tools\n2022-02-21: mobimeta: fix null pointer dereference when parsing malformed option\n2022-02-18: Add  hybrid spit option to mobitool\n2022-02-18: Update documentation\n2022-02-18: Test both encrypted hybrid parts\n2022-02-18: Fix: fast decryption routine fails for non-huffman compression\n2022-02-18: Fix mobitool serial decryption\n2022-02-18: Add DRM tests\n2022-02-17: Fix build with encryption disabled\n2022-02-17: Update tests samples\n2022-02-16: Add -h option to tools, update man pages\n2022-02-16: Update Xcode settings\n2022-02-16: Restructure, cleanup encryption related code, add mobidrm tool\n2021-11-19: Improve getopt loop, fix config.h to be accessible from all tools\n2021-11-10: Update xcode project\n2021-11-10: Add functions to split hybrid files\n2021-11-10: Avoid modifying existing records, as caller may keep reference to them\n2021-11-05: Fix: tests fail if pid contains asterisk\n2021-11-05: Fix: decryption may fail for some records with standard compression\n2021-11-05: Replace test samples with self-generated smaller ones\n2021-11-05: Skip test in case of missing checksums\n2021-10-20: Version 0.9\n2021-10-24: Fix out-of-tree build\n2021-10-22: Fix mingw build, code formatting\n2021-10-14: Fix gcc format truncation warning\n2021-10-14: Include autogen.sh in distribution bundle\n2021-10-14: Create codeql-analysis.yml\n2021-10-14: Fix autoconf 2.70 warnings, clean up\n2021-10-14: Build fails with autoconf 2.70\n2021-10-11: Version 0.8\n2021-10-11: Update Xcode project\n2021-10-11: Fix warnings about changed signedness\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #38\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36\n2021-09-09: Version 0.7\n2021-09-09: fix oob write bug inside libmobi\n2021-06-07: Add reference to brew formula\n2020-09-02: Fix null pointer dereference in case of broken fragment\n2020-08-01: Update changelog\n2020-08-01: Version 0.6\n2020-07-31: Fix typo\n2020-07-31: Add Readme to dist package\n2020-07-31: Remove anchor on truncated link\n2020-07-31: Fix missing option in man page\n2020-07-30: Include test samples in dist package\n2020-07-25: Fix gcc 7+ warnings about implicit fall through and format truncation\n2020-07-24: Unique names for internal functions to avoid confilicts with static linking\n2020-06-24: Close file in error branch\n2020-06-24: Fix static compilation with miniz on gcc\n2020-06-24: Minor documentation fixes\n2020-06-23: Version 0.5\n2020-06-23: mobitool: add dump cover option\n2020-06-23: Minor documentation improvement\n2020-06-23: Fix potential buffer over-read\n2019-03-18: Fix: try also \"name\" attribute when searching for link anchor tags, closes #24\n2019-02-22: Add mobi_is_replica function\n2019-02-22: Fix potential read beyond buffer\n2019-02-22: Travis migration\n2018-08-07: Fix: missing items in recreated ncx file\n2018-06-20: Fix: printf format warning on some gcc versions\n2018-06-20: Fix: make dist broken by nonexistent header files\n2018-06-20: VERSION 0.4\n2018-06-20: Fix: buffer overflow (CVE-2018-11726)\n2018-06-20: Fix: buffer overflow (CVE-2018-11724)\n2018-06-20: Fix: read beyond buffer (CVE-2018-11725)\n2018-06-20: Fix: buffer overflow (mobitool), closes #18\n2018-06-20: Fix: read beyond buffer with corrupted KF8 Boundary record, closes #19\n2018-06-20: Fix: read beyond buffer, closes #16, #17\n2018-06-20: Updated xcode project files\n2018-04-03: Fix: ncx part was not scanned for links, fixes #12\n2018-04-02: Fix regression, potential use after free\n2018-04-02: Skip broken resources, fixes #10\n2018-03-05: Allow processing zero length text records, fixes #9\n2017-12-25: Skip broken first resource offset instead of dying\n2017-12-18: Skip broken links reconstruction instead of dying\n2017-11-27: Disable travis OS X builds, as they usually time out\n2017-11-16: Fix: increase max number of dictionary entries per record\n2017-11-14: Fix for some encrypted documents with palmdoc encoding\n2017-11-06: Fix: potential null pointer dereference\n2017-10-16: Manpage cleanup\n2017-09-27: Update README\n2017-09-26: Increase maximum length of attribute name and value, closes #5\n2017-02-26: Remove obsolete files from VS build (closes #3) [ci skip]\n2016-11-05: Mobitool: use epub extension if extracted source resource is epub\n2016-06-10: Update docs\n2016-06-10: Update test files\n2016-06-10: Fix: out of bounds read in corrupt font resource\n2016-06-10: Prevent memory leak in case of corrupt font resources\n2016-06-10: Calculate deobfuscation buffer limit from key length\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-09: Fix: memory leak in tools\n2016-06-09: Fix: potential out of bounds read\n2016-06-09: Fix: memory leak in internal xmlwriter\n2016-06-01: Update README\n2016-05-19: Feature: verify decryption key type\n2016-05-19: Cleanup converting little endian buffer to 32-bit integer\n2016-05-19: Feature: check drm expiration dates\n2016-05-18: Fix: memory leaks in encryption\n2016-05-18: Fix concurrent autotools builds\n2016-05-18: use relative path, as $(top_srcdir) fails to be substituted (?)\n2016-05-18: update vcxproj\n2016-05-18: Include headers in automake sources\n2016-05-18: Fix: automake out-of-tree miniz build\n2016-05-18: Fix: wrongly detected fdst record broke some ancient documents\n2016-05-18: Fix: improve index header parsing, some old dictionaries might not load\n2016-05-18: Fix: convert encoding of opf strings from cp1252 indices\n2016-05-18: Quiet warnings about unused values of wiped variables\n2016-05-18: Fix: potential memory leak\n2016-05-18: Fix: wrongly decoded \"&copy;\" entity\n2016-05-16: Fix: huffdic decompression fails in case of huge documents\n2016-05-14: Simplify buffer_init_null() function\n2016-05-14: Use ARRAYSIZE macro\n2016-05-14: Feature: calculate pid for decryption from device serial number\n2016-04-29: Use endian-independent byte swapping\n2016-04-29: Exclude unused miniz functions from binary\n2016-04-29: Add SHA-1 routines\n2016-04-27: Fix miniz.c formatting\n2016-04-27: Documentation\n2016-04-20: Update changelog\n2016-04-20: Fix potential null pointer dereference\n2016-04-20: Remove useless check\n2016-04-20: Fix text record size calculation\n2016-04-20: Fix buffer checking and freeing\n2016-04-19: Update docs\n2016-04-19: Update ChangeLog\n2016-04-19: Fix comparison between signed and unsigned integer\n2016-04-19: use strdup on linux/glibc\n2016-04-19: Add initial write and metadata editing support. Add mobimeta tool.\n2016-04-19: Always check whether memory allocation succeeded\n2016-04-18: Fix: guarantee array resize step is at least 1\n2016-04-13: Workaround to read some old mobipocket files\n2016-04-13: Improve pdb dates resolving\n2016-04-07: Minor documentation edit\n2016-04-07: Update changelog\n2016-04-06: Fix format warning\n2016-04-06: Update test checksums\n2016-04-06: Fix: <dc:date> \"event\" attribute needs \"opf\" namespace\n2016-04-06: Fix: id attributes in ncx file should be unique\n2016-04-06: Store full name in MOBIMobiHeader structure\n2016-04-05: Fix formatting\n2016-04-05: Fix signedness warning\n2016-04-04: Fix potential buffer overflow, closes #2\n2016-04-04: Fix potential null pointer dereference\n2016-03-23: Fix signedness warnings\n2016-03-22: Fix: _mkdir needs direct.h on MinGW\n2016-03-22: Fix tests on Windows\n2016-03-22: Fix: palmdoc decompression may fail with zero byte in input buffer\n2016-03-21: VERSION 03: internal xmlwriter, metadata handling functions, bug fixes\n2016-03-21: Feature: add helper functions for metadata extraction\n2016-03-21: Load also kf8 data when only kf7 version is requested\n2016-03-21: Fix: wrong exth header length check could discard some valid headers\n2016-03-20: Get rid of extended attributes in release archive on OS X\n2016-03-19: Mobitool: add descriptive error messages based on libmobi return codes\n2016-03-04: Add extra length check for CMET record extraction\n2016-03-04: Always check buffer allocation result\n2016-03-04: Add functions to extract conversion source and log, also add this feature to mobitool\n2016-03-04: Remove some stray printfs\n2016-03-03: Remove not used AC_FUNC_MALLOC/REALLOC macros that break cross-compilation\n2016-03-03: Fix potential illegal memory access in miniz.c\n2016-03-03: Fix potential dereference of null pointer in miniz.c\n2016-03-03: Fix for Android bionic libc bug (SIZE_MAX missing in stdint.h)\n2016-03-03: Fix mobitool compilation on MSVC++\n2016-03-03: Add EPUB creation feature to mobitool\n2016-03-02: Fix potential buffer overflow, null pointer dereference\n2016-03-02: Add travis test for no-external-dependency build\n2016-03-02: Fix missing strdup on linux\n2016-03-02: Add internal xmlwriter (as an alternative to libxml2)\n2016-03-01: Feature: decode html entities in exth header strings\n2016-02-29: Fix: potential buffer overflow\n2016-02-29: Fix: wrong pid calculation (regression introduced in 0.2)\n2016-02-26: VERSION 0.2: increased stability, lots of bugs fixed\n2016-02-26: Add Xcode project file\n2016-02-26: Preliminary support for MSVC++ compiler\n2016-02-26: Do not use variable length arrays\n2016-02-26: Refactor mobi_reconstruct_parts() to use MOBIFragment list\n2016-02-26: Fix compiler warning about sign conversion\n2016-02-26: Fix compiler warning about type conversion\n2016-02-26: Check the result of malloc/calloc\n2016-02-26: Fix inconsistent use of const between some definitions and declarations\n2016-02-24: Fix inconsistence between function declaration and definition\n2016-02-24: Fix various potential crashes in case of corrupt input (afl-fuzz)\n2016-02-24: Fix dead code warnings in miniz\n2015-11-26: Export mobi_get_first_resource_record() function\n2015-11-26: Fix: double free on corrupt cdic\n2015-11-02: Update docs\n2015-11-02: Feature: add helper functions to find resources by flow id\n2015-11-02: Feature: export MOBI_NOTSET macro\n2015-11-02: Feature: give more options to parse rawml function\n2015-10-24: Restore travis.yml\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix multiline inline script\n2015-10-24: Enable multi-OS feature\n2015-10-24: Fix: unique temporary name for parallel tests\n2015-10-24: Fix: decoding video resources falsely reported as failed\n2015-10-24: Fix: tests, some md5sum implementations insert double spaces\n2015-10-24: Fix for automake < 1.13\n2015-10-23: Add simple tests framework\n2015-10-23: Fix: increase max index entries per record count, as some rare samples fail\n2015-10-22: Fix: incorrectly decoded video/audio resources\n2015-10-22: Feature: add option to specify output path\n2015-10-14: Add some internal functions to public API: mobi_get_flow_by_uid, mobi_get_resource_by_uid, mobi_get_part_by_uid, mobi_get_exthrecord_by_tag\n2015-06-13: update changelog\n2015-06-13: fix: various invalid memory access\n2015-06-13: don't quit on invalid input, instead substitute with replacement character\n2015-06-12: fix typo\n2015-06-12: update changelog\n2015-06-12: fix: reconstruction failed when there were gaps between fragments\n2015-06-12: add EXTH tags\n2015-06-12: prevent return of garbage value check return value in case of failed malloc\n2015-06-12: fix invalid memory access\n2015-04-12: Fix reconstruction of \"kindle:embed\" links without mime type (regression)\n2015-04-12: Add sanity checks to link reconstruction functions, allow skipping some malformed patterns\n2015-04-12: Fix infinite loop in guide build while unknown tag was found\n2015-04-12: Increase max recursion level for huffman decompression\n2015-03-28: update docs\n2015-03-28: fix solaris studio compiler warnings\n2015-03-28: fix solaris studio compiler build\n2015-02-18: Fix \"more than one: -compatibility_version specified\" error on powerpc\n2014-11-24: improve docs\n2014-11-24: simplify public header\n2014-11-21: changelog update [ci skip]\n2014-11-21: README\n2014-11-21: fix: add sanity checks\n2014-11-21: Fix: add sanity checks\n2014-11-21: add sanity check to huffcdic indices count\n2014-11-21: fix number of leaks and other minor issues (by coverity scan)\n2014-11-20: missing notification email kills coverity scan\n2014-11-20: update travis.yml\n2014-11-20: upgrade travis.ml with covert scan\n2014-11-20: update README.md\n2014-11-20: add .travis.yml\n2014-11-20: update REAME.md\n2014-11-20: update README.md\n2014-11-20: update docs\n2014-11-20: feature: add decryption support\n2014-11-20: mkdir cleanup\n2014-11-17: documentation\n2014-11-17: strip unneeded <aid/> tags\n2014-11-16: fix: potential leak\n2014-11-16: fix: regression, some image tags were not reconstructed\n2014-11-16: fix: improve ligatures handling\n2014-11-16: override darwin linker default versioning\n2014-11-15: fix: get proper LIGT entries count from index header\n2014-11-15: feature: unpack records into new folder\n2014-11-14: make README readable on github\n2014-11-14: add README for mobitool\n2014-11-14: fix: dictionaries with large inflection rules failed\n2014-11-14: feature: support encoded ligatures in index entry labels\n2014-11-14: readme\n2014-11-14: update changelog\n2014-11-13: feature: support for older inflections scheme\n2014-11-13: bug: files with short tagx header won't open\n2014-11-13: cleanup unneeded include\n2014-11-13: use strdup on linux/glibc\n2014-11-13: debugging cleanup\n2014-11-13: reorganize source files\n2014-11-13: use strdup on linux/glibc\n2014-11-11: update changelog\n2014-11-11: update changeling\n2014-11-11: fix: documents with text record size > 4096 failed to load\n2014-11-11: add: function to decode flat index entries\n2014-11-11: debug: add functions for debugging indices\n2014-11-11: cleanup\n2014-11-11: fix: variable length value wrongly calculated when going backwards\n2014-11-08: update documentation\n2014-11-08: update changelog\n2014-11-08: add support for reconstructing inflections index entries\n2014-11-08: parsing of exth header failed in some cases\n2014-11-08: fix: some links reconstruction in kf7 failed\n2014-11-08: improve debug info\n2014-11-08: failed malloc false reports\n2014-11-03: fix problem with uncompressed documents\n2014-11-03: fix broken locales\n2014-11-03: remove obsolete includes\n2014-11-03: git log > changelog\n2014-11-03: improved buffer handling\n2014-11-03: improved OPF for dictionaries\n2014-11-03: proper rawml->orth initialization and freeing\n2014-11-03: fix subject field in opf\n2014-11-03: handle UTF-16 surrogates, make ORDT lookups locale independent\n2014-11-01: move dict reconstruction to separate function\n2014-11-01: cleanup\n2014-11-01: quiet gcc warning on printf format\n2014-11-01: reconstruction of orth dictionary entries\n2014-09-27: use mobi_list_del_all()\n2014-09-25: postpone conversion to utf8 after all source reconstructions\n2014-09-24: comment\n2014-09-24: comments\n2014-09-12: doxygen comment\n2014-09-12: data size in comment\n2014-09-05: MOBIArray data type fix\n2014-09-05: config.h fixes\n2014-06-29: merge master\n2014-04-11: initial commit", "/** @file index.c\n *  @brief Functions to parse index records\n *\n * Copyright (c) 2020 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD /* for strdup on linux/glibc */\n#endif\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"index.h\"\n#include \"util.h\"\n#include \"memory.h\"\n#include \"debug.h\"\n#include \"buffer.h\"\n\n\n\n/**\n @brief Read index entry label from buffer pointing at index record data\n \n @param[in,out] output Output string\n @param[in,out] buf MOBIBuffer structure, offset pointing at index entry label\n @param[in] length Number of bytes to be read\n @param[in] has_ligatures Decode ligatures if true\n @return Size of read label\n */\nsize_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {\n    if (!output) {\n        buf->error = MOBI_PARAM_ERR;\n        return 0;\n    }\n    if (buf->offset + length > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    const unsigned char replacement = 0x3f;\n    size_t output_length = 0;\n    size_t i = 0;\n    while (i < length && output_length < INDX_LABEL_SIZEMAX) {\n        unsigned char c = mobi_buffer_get8(buf);\n        i++;\n        if (c == 0) {\n            /* FIXME: is it safe to replace zeroes? */\n            debug_print(\"Invalid character: %u\\n\", c);\n            c = replacement;\n        }\n        if (c <= 5 && has_ligatures) {\n            unsigned char c2 = mobi_buffer_get8(buf);\n            c = mobi_ligature_to_cp1252(c, c2);\n            if (c == 0) {\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, -1);\n                c = replacement;\n            } else {\n                i++;\n            }\n        }\n        *output++ = c;\n        output_length++;\n    }\n    *output = '\\0';\n    return output_length;\n}\n\n/**\n @brief Parser of ORDT section of INDX record\n \n @param[in,out] buf MOBIBuffer structure, offset pointing at beginning of TAGX section\n @param[in,out] ordt MOBIOrdt structure to be filled by the function\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_parse_ordt(MOBIBuffer *buf, MOBIOrdt *ordt) {\n    /* read ORDT1 */\n    mobi_buffer_setpos(buf, ordt->ordt1_pos);\n    if (mobi_buffer_match_magic(buf, ORDT_MAGIC)) {\n        debug_print(\"%s\\n\", \"ORDT1 section found\");\n        mobi_buffer_seek(buf, 4);\n        if (ordt->offsets_count + buf->offset > buf->maxlen) {\n            debug_print(\"ORDT1 section too long (%zu)\", ordt->offsets_count);\n            return MOBI_DATA_CORRUPT;\n        }\n        ordt->ordt1 = malloc(ordt->offsets_count * sizeof(*ordt->ordt1));\n        if (ordt->ordt1 == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed for ORDT1 offsets\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        size_t i = 0;\n        while (i < ordt->offsets_count) {\n            ordt->ordt1[i++] = mobi_buffer_get8(buf);\n        }\n        debug_print(\"ORDT1: read %zu entries\\n\", ordt->offsets_count);\n    }\n    /* read ORDT2 */\n    mobi_buffer_setpos(buf, ordt->ordt2_pos);\n    if (mobi_buffer_match_magic(buf, ORDT_MAGIC)) {\n        debug_print(\"%s\\n\", \"ORDT2 section found\");\n        mobi_buffer_seek(buf, 4);\n        if (ordt->offsets_count * 2 + buf->offset > buf->maxlen) {\n            debug_print(\"ORDT2 section too long (%zu)\", ordt->offsets_count);\n            return MOBI_DATA_CORRUPT;\n        }\n        ordt->ordt2 = malloc(ordt->offsets_count * sizeof(*ordt->ordt2));\n        if (ordt->ordt2 == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed for ORDT2 offsets\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        size_t i = 0;\n        while (i < ordt->offsets_count) {\n            ordt->ordt2[i++] = mobi_buffer_get16(buf);\n        }\n        debug_print(\"ORDT2: read %zu entries\\n\", ordt->offsets_count);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parser of TAGX section of INDX record\n \n @param[in,out] buf MOBIBuffer structure, offset pointing at beginning of TAGX section\n @param[in,out] tagx MOBITagx structure to be filled by the function\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_parse_tagx(MOBIBuffer *buf, MOBITagx *tagx) {\n    tagx->control_byte_count = 0;\n    tagx->tags_count = 0;\n    tagx->tags = NULL;\n    mobi_buffer_seek(buf, 4); /* skip header */\n    uint32_t tagx_record_length = mobi_buffer_get32(buf);\n    if (tagx_record_length < 12) {\n        debug_print(\"INDX record too short: %u\\n\", tagx_record_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->control_byte_count = mobi_buffer_get32(buf);\n    tagx_record_length -= 12;\n    if (tagx_record_length + buf->offset > buf->maxlen) {\n        debug_print(\"INDX record too long: %u\\n\", tagx_record_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->tags = malloc(tagx_record_length * sizeof(TAGXTags));\n    if (tagx->tags == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed for TAGX tags\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    const size_t tagx_data_length = tagx_record_length / 4;\n    size_t control_byte_count = 0;\n    while (i < tagx_data_length) {\n        tagx->tags[i].tag = mobi_buffer_get8(buf);\n        tagx->tags[i].values_count = mobi_buffer_get8(buf);\n        tagx->tags[i].bitmask = mobi_buffer_get8(buf);\n        const uint8_t control_byte = mobi_buffer_get8(buf);\n        if (control_byte) { control_byte_count++; }\n        tagx->tags[i].control_byte = control_byte;\n        debug_print(\"tagx[%zu]:\\t%i\\t%i\\t%i\\t%i\\n\", i, tagx->tags[i].tag, tagx->tags[i].values_count, tagx->tags[i].bitmask, control_byte);\n        i++;\n    }\n    if (tagx->control_byte_count != control_byte_count) {\n        debug_print(\"Wrong count of control bytes: %zu != %zu\\n\", tagx->control_byte_count, control_byte_count);\n        free(tagx->tags);\n        tagx->tags = NULL;\n        tagx->control_byte_count = 0;\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->tags_count = i;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parser of IDXT section of INDX record\n \n @param[in,out] buf MOBIBuffer structure, offset pointing at beginning of TAGX section\n @param[in,out] idxt MOBITagx structure to be filled by the function\n @param[in] entries_count Number of index entries\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_parse_idxt(MOBIBuffer *buf, MOBIIdxt *idxt, const size_t entries_count) {\n    const uint32_t idxt_offset = (uint32_t) buf->offset;\n    idxt->offsets_count = 0;\n    char idxt_magic[5];\n    mobi_buffer_getstring(idxt_magic, buf, 4);\n    if (strncmp(idxt_magic, IDXT_MAGIC, 4) != 0) {\n        debug_print(\"IDXT wrong magic: %s\\n\", idxt_magic);\n        return MOBI_DATA_CORRUPT;\n    }\n    size_t i = 0;\n    while (i < entries_count) {\n        /* entry offsets */\n        idxt->offsets[i++] = mobi_buffer_get16(buf);\n    }\n    /* last entry end position is IDXT tag offset */\n    idxt->offsets[i] = idxt_offset;\n    idxt->offsets_count = i;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get encoded character from dictionary index\n The characters are offsets into ORDT table\n \n @param[in] ordt MOBIOrdt structure (ORDT data and metadata)\n @param[in,out] buf MOBIBuffer structure with index data\n @param[in,out] offset Value read from buffer\n @return Number of bytes read (zero in case of error)\n */\nsize_t mobi_ordt_getbuffer(const MOBIOrdt *ordt, MOBIBuffer *buf, uint16_t *offset) {\n    size_t i = 0;\n    if (ordt->type == 1) {\n        *offset = mobi_buffer_get8(buf);\n        i++;\n    } else {\n        *offset = mobi_buffer_get16(buf);\n        i += 2;\n    }\n    return i;\n}\n\n/**\n @brief Fetch UTF-16 value from ORDT2 table\n \n @param[in] ordt MOBIOrdt structure (ORDT data and metadata)\n @param[in] offset Offset in ORDT2 table\n @return UTF-16 code point\n */\nuint16_t mobi_ordt_lookup(const MOBIOrdt *ordt, const uint16_t offset) {\n    uint16_t utf16;\n    if (offset < ordt->offsets_count) {\n        utf16 = ordt->ordt2[offset];\n    } else {\n        utf16 = offset;\n    }\n    return utf16;\n}\n\n/**\n @brief Get UTF-8 string from buffer, decoded by lookups in ORDT2 table\n \n @param[in] ordt MOBIOrdt structure (ORDT data and metadata)\n @param[in,out] buf MOBIBuffer structure with input string\n @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX bytes)\n @param[in] length Length of input string contained in buf\n @return Number of bytes read\n */\nsize_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {\n    size_t i = 0;\n    size_t output_length = 0;\n    const uint32_t bytemask = 0xbf;\n    const uint32_t bytemark = 0x80;\n    const uint32_t uni_replacement = 0xfffd;\n    const uint32_t surrogate_offset = 0x35fdc00;\n    static const uint8_t init_byte[7] = { 0x00, 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc };\n    while (i < length) {\n        uint16_t offset;\n        i += mobi_ordt_getbuffer(ordt, buf, &offset);\n        uint32_t codepoint = mobi_ordt_lookup(ordt, offset);\n        if (codepoint <= 5) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            codepoint = mobi_ligature_to_utf16(codepoint, codepoint2);\n            if (codepoint == uni_replacement) {\n                /* rewind buffer to codepoint2 */\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, - (int) k);\n            } else {\n                i += k;\n            }\n        }\n        /* convert UTF-16 surrogates into UTF-32 */\n        if (codepoint >= 0xd800 && codepoint <= 0xdbff) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            if (codepoint2 >= 0xdc00 && codepoint2 <= 0xdfff) {\n                i += k;\n                codepoint = (codepoint << 10) + codepoint2 - surrogate_offset;\n            } else {\n                /* illegal unpaired high surrogate */\n                /* rewind buffer to codepoint2 */\n                debug_print(\"Invalid code point: %u\\n\", codepoint);\n                mobi_buffer_seek(buf, - (int) k);\n                codepoint = uni_replacement;\n            }\n        }\n        if ((codepoint >= 0xdc00 && codepoint <= 0xdfff) /* unpaired low surrogate */\n            || (codepoint >= 0xfdd0 && codepoint <= 0xfdef) /* invalid characters */\n            || (codepoint & 0xfffe) == 0xfffe /* reserved characters */\n            || codepoint == 0 /* remove zeroes */) {\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        /* Conversion routine based on unicode's ConvertUTF.c */\n        size_t bytes;\n        if (codepoint < 0x80) { bytes = 1; }\n        else if (codepoint < 0x800) { bytes = 2; }\n        else if (codepoint < 0x10000) { bytes = 3; }\n        else if (codepoint < 0x110000) { bytes = 4; }\n        else {\n            bytes = 3;\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        if (output_length + bytes >= INDX_LABEL_SIZEMAX) {\n            debug_print(\"%s\\n\", \"INDX label too long\");\n            break;\n        }\n        output += bytes;\n        switch (bytes) {\n            case 4: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 3: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 2: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 1: *--output = (uint8_t)(codepoint | init_byte[bytes]);\n        }\n        output += bytes;\n        output_length += bytes;\n    }\n    *output = '\\0';\n    return output_length;\n}\n\n/**\n @brief Parser of INDX index entry\n \n @param[in,out] indx MOBIIndx structure, to be filled with parsed data\n @param[in] idxt MOBIIdxt structure with parsed IDXT index\n @param[in] tagx MOBITagx structure with parsed TAGX index\n @param[in,out] buf MOBIBuffer structure with index data\n @param[in] curr_number Sequential number of an index entry for current record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx->tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parser of INDX record\n \n @param[in] indx_record MOBIPdbRecord structure with INDX record\n @param[in,out] indx MOBIIndx structure to be filled with parsed entries\n @param[in,out] tagx MOBITagx structure, will be filled with parsed TAGX section data if present in the INDX record, otherwise TAGX data will be used to parse the record\n @param[in,out] ordt MOBIOrdt structure, will be filled with parsed ORDT sections\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_indx(const MOBIPdbRecord *indx_record, MOBIIndx *indx, MOBITagx *tagx, MOBIOrdt *ordt) {\n    if (indx_record == NULL || indx == NULL || tagx == NULL || ordt == NULL) {\n        debug_print(\"%s\", \"index structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf = mobi_buffer_init_null(indx_record->data, indx_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char indx_magic[5];\n    mobi_buffer_getstring(indx_magic, buf, 4); /* 0: INDX magic */\n    const uint32_t header_length = mobi_buffer_get32(buf); /* 4: header length */\n    if (strncmp(indx_magic, INDX_MAGIC, 4) != 0 ||\n        header_length == 0 || header_length > indx_record->size) {\n        debug_print(\"INDX wrong magic: %s or header length: %u\\n\", indx_magic, header_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    mobi_buffer_seek(buf, 4); /* 8: unk, usually zeroes */\n    const uint32_t type = mobi_buffer_get32(buf); /* 12: 0 - normal, 2 - inflection */\n    mobi_buffer_seek(buf, 4); /* 16: unk */\n    const uint32_t idxt_offset = mobi_buffer_get32(buf); /* 20: IDXT offset */\n    const uint32_t entries_count = mobi_buffer_get32(buf); /* 24: entries count */\n    if (entries_count > INDX_RECORD_MAXCNT) {\n        debug_print(\"Too many index entries (%u)\\n\", entries_count);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* if record contains TAGX section, read it (and ORDT) and return */\n    if (mobi_buffer_match_magic_offset(buf, TAGX_MAGIC, header_length) && indx->total_entries_count == 0) {\n        buf->maxlen = header_length;\n        /* TAGX metadata */\n        uint32_t encoding = mobi_buffer_get32(buf); /* 28: encoding */\n        if (encoding == MOBI_NOTSET) { encoding = MOBI_CP1252; }\n        mobi_buffer_seek(buf, 4); /* 32 */\n        const uint32_t total_entries_count = mobi_buffer_get32(buf); /* 36: total entries count */\n        if (total_entries_count > INDX_TOTAL_MAXCNT) {\n            debug_print(\"Too many total index entries (%u)\\n\", total_entries_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t ordt_offset = mobi_buffer_get32(buf); /* 40: ORDT offset; currently not used */\n        if (ordt_offset + ORDT_RECORD_MAXCNT + 4 > indx_record->size) {\n            ordt_offset = 0;\n        }\n        uint32_t ligt_offset = mobi_buffer_get32(buf); /* 44: LIGT offset; currently static table used instead */\n        uint32_t ligt_entries_count = mobi_buffer_get32(buf); /* 48: LIGT entries count */\n        if (ligt_offset + 4 * ligt_entries_count + 4 > indx_record->size) {\n            ligt_offset = 0;\n            ligt_entries_count = 0;\n        }\n        const uint32_t cncx_records_count = mobi_buffer_get32(buf); /* 52: CNCX entries count */\n        if (cncx_records_count > CNCX_RECORD_MAXCNT) {\n            debug_print(\"Too many CNCX records (%u)\\n\", cncx_records_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* 56: unk count */\n        /* 60-148: phonetizer */\n        uint32_t ordt_type = 0;\n        uint32_t ordt_entries_count = 0;\n        uint32_t ordt1_offset = 0;\n        uint32_t ordt2_offset = 0;\n        uint32_t index_name_offset = 0;\n        uint32_t index_name_length = 0;\n        if (header_length >= 180) {\n            mobi_buffer_setpos(buf, 164);\n            ordt_type = mobi_buffer_get32(buf); /* 164: ORDT type */\n            ordt_entries_count = mobi_buffer_get32(buf); /* 168: ORDT entries count */\n            ordt1_offset = mobi_buffer_get32(buf); /* 172: ORDT1 offset; currently not used */\n            ordt2_offset = mobi_buffer_get32(buf); /* 176: ORDT2 offset */\n            const size_t entry_size = (ordt_type == 0) ? 1 : 2;\n            if (ordt1_offset + entry_size * ordt_entries_count > indx_record->size\n                || ordt2_offset + 2 * ordt_entries_count > indx_record->size) {\n                ordt1_offset = 0;\n                ordt2_offset = 0;\n                ordt_entries_count = 0;\n            }\n            index_name_offset = mobi_buffer_get32(buf); /* 180: Index name offset */\n            index_name_length = mobi_buffer_get32(buf); /* 184: Index name length */\n        }\n        buf->maxlen = indx_record->size;\n        mobi_buffer_setpos(buf, header_length);\n        ret = mobi_parse_tagx(buf, tagx);\n        if (ret != MOBI_SUCCESS) {\n            mobi_buffer_free_null(buf);\n            return ret;\n        }\n        if (ordt_entries_count > 0) {\n            /* parse ORDT sections */\n            ordt->offsets_count = ordt_entries_count;\n            ordt->type = ordt_type;\n            ordt->ordt1_pos = ordt1_offset;\n            ordt->ordt2_pos = ordt2_offset;\n            ret = mobi_parse_ordt(buf, ordt);\n            debug_print(\"ORDT: %u, %u, %u, %u\\n\", ordt_type, ordt_entries_count, ordt1_offset, ordt2_offset);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                return ret;\n            }\n        }\n        if (index_name_offset > 0 && index_name_length > 0) {\n            if (index_name_length <= header_length - index_name_offset && index_name_length < INDX_NAME_SIZEMAX) {\n                mobi_buffer_setpos(buf, index_name_offset);\n                char *name = malloc(index_name_length + 1);\n                if (name == NULL) {\n                    debug_print(\"%s\", \"Memory allocation failed\\n\");\n                    mobi_buffer_free_null(buf);\n                    return MOBI_MALLOC_FAILED;\n                }\n                mobi_buffer_getstring(name, buf, index_name_length);\n                indx->orth_index_name = name;\n                debug_print(\"Orth index name: %s\\n\", name);\n            }\n        }\n        indx->encoding = encoding;\n        indx->type = type;\n        indx->entries_count = entries_count;\n        indx->total_entries_count = total_entries_count;\n        if (ligt_entries_count != 0 && !mobi_buffer_match_magic_offset(buf, LIGT_MAGIC, ligt_offset)) {\n            ligt_offset = 0;\n            ligt_entries_count = 0;\n        }\n        indx->ligt_offset = ligt_offset;\n        indx->ligt_entries_count = ligt_entries_count;\n        indx->ordt_offset = ordt_offset;\n        indx->cncx_records_count = cncx_records_count;\n    } else {\n        /* else parse IDXT entries offsets */\n        if (idxt_offset == 0) {\n            debug_print(\"%s\", \"Missing IDXT offset\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (idxt_offset + 2 * entries_count + 4 > indx_record->size ) {\n            debug_print(\"IDXT entries beyond record end%s\", \"\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, idxt_offset);\n        MOBIIdxt idxt;\n        uint32_t *offsets = malloc((entries_count + 1) * sizeof(uint32_t));\n        if (offsets == NULL) {\n            mobi_buffer_free_null(buf);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        idxt.offsets = offsets;\n        ret = mobi_parse_idxt(buf, &idxt, entries_count);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"IDXT parsing failed\\n\");\n            mobi_buffer_free_null(buf);\n            free(offsets);\n            return ret;\n        }\n        /* parse entries */\n        if (entries_count > 0) {\n            if (indx->entries == NULL) {\n                indx->entries = malloc(indx->total_entries_count * sizeof(MOBIIndexEntry));\n                if (indx->entries == NULL) {\n                    mobi_buffer_free_null(buf);\n                    free(offsets);\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n            }\n            size_t i = 0;\n            while (i < entries_count) {\n                ret = mobi_parse_index_entry(indx, idxt, tagx, ordt, buf, i++);\n                if (ret != MOBI_SUCCESS) {\n                    mobi_buffer_free_null(buf);\n                    free(offsets);\n                    return ret;\n                }\n            }\n            indx->entries_count += entries_count;\n        }\n        free(offsets);\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parser of a set of index records\n \n @param[in] m MOBIData structure containing MOBI file metadata and data\n @param[in,out] indx MOBIIndx structure to be filled with parsed entries\n @param[in] indx_record_number Number of the first record of the set\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_index(const MOBIData *m, MOBIIndx *indx, const size_t indx_record_number) {\n    MOBI_RET ret;\n    /* tagx->tags array will be allocated in mobi_parse_tagx */\n    MOBITagx *tagx = calloc(1, sizeof(MOBITagx));\n    if (tagx == NULL) {\n        mobi_free_indx(indx);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* ordt->ordt1 and ordt.ordt2 arrays will be allocated in mobi_parse_ordt */\n    MOBIOrdt *ordt = calloc(1, sizeof(MOBIOrdt));\n    if (ordt == NULL) {\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse first meta INDX record */\n    MOBIPdbRecord *record = mobi_get_record_by_seqnumber(m, indx_record_number);\n    ret = mobi_parse_indx(record, indx, tagx, ordt);\n    if (ret != MOBI_SUCCESS) {\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        mobi_free_ordt(ordt);\n        return ret;\n    }\n    /* parse remaining INDX records for the index */\n    size_t count = indx->entries_count;\n    indx->entries_count = 0;\n    while (count--) {\n        record = record->next;\n        ret = mobi_parse_indx(record, indx, tagx, ordt);\n        if (ret != MOBI_SUCCESS) {\n            mobi_free_indx(indx);\n            mobi_free_tagx(tagx);\n            mobi_free_ordt(ordt);\n            return ret;\n        }\n    }\n    if (indx->entries_count != indx->total_entries_count) {\n        debug_print(\"Entries count %zu != total entries count %zu\\n\", indx->entries_count, indx->total_entries_count);\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        mobi_free_ordt(ordt);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* copy pointer to first cncx record if present and set info from first record */\n    if (indx->cncx_records_count) {\n        indx->cncx_record = record->next;\n    }\n    mobi_free_tagx(tagx);\n    mobi_free_ordt(ordt);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get a value of tag[tagid][tagindex] for given index entry\n \n @param[in,out] tagvalue Will be set to a tag value\n @param[in] entry Index entry to be search for the value\n @param[in] tag_arr Array: tag_arr[0] = tagid, tag_arr[1] = tagindex\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_indxentry_tagvalue(uint32_t *tagvalue, const MOBIIndexEntry *entry, const unsigned tag_arr[]) {\n    if (entry == NULL) {\n        debug_print(\"%s\", \"INDX entry not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    size_t i = 0;\n    while (i < entry->tags_count) {\n        if (entry->tags[i].tagid == tag_arr[0]) {\n            if (entry->tags[i].tagvalues_count > tag_arr[1]) {\n                *tagvalue = entry->tags[i].tagvalues[tag_arr[1]];\n                return MOBI_SUCCESS;\n            }\n            break;\n        }\n        i++;\n    }\n    //debug_print(\"tag[%i][%i] not found in entry: %s\\n\", tag_arr[0], tag_arr[1], entry->label);\n    return MOBI_DATA_CORRUPT;\n}\n\n/**\n @brief Get array of tagvalues of tag[tagid] for given index entry\n \n @param[in,out] tagarr Pointer to tagvalues array\n @param[in] entry Index entry to be search for the value\n @param[in] tagid Id of the tag\n @return Size of the array (zero on failure)\n */\nsize_t mobi_get_indxentry_tagarray(uint32_t **tagarr, const MOBIIndexEntry *entry, const size_t tagid) {\n    if (entry == NULL) {\n        debug_print(\"%s\", \"INDX entry not initialized\\n\");\n        return 0;\n    }\n    size_t i = 0;\n    while (i < entry->tags_count) {\n        if (entry->tags[i].tagid == tagid) {\n            *tagarr = entry->tags[i].tagvalues;\n            return entry->tags[i].tagvalues_count;\n        }\n        i++;\n    }\n    //debug_print(\"tag[%zu] not found in entry: %s\\n\", tagid, entry->label);\n    return 0;\n}\n\n/**\n @brief Get entry start offset for the orth entry\n @param[in] entry MOBIIndexEntry structure\n @return Start offset, MOBI_NOTSET on failure\n */\nuint32_t mobi_get_orth_entry_offset(const MOBIIndexEntry *entry) {\n\n    uint32_t entry_startpos;\n    MOBI_RET ret = mobi_get_indxentry_tagvalue(&entry_startpos, entry, INDX_TAG_ORTH_POSITION);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_NOTSET;\n    }\n    \n    return entry_startpos;\n}\n\n/**\n @brief Get text length for the orth entry\n @param[in] entry MOBIIndexEntry structure\n @return Text length, MOBI_NOTSET on failure\n */\nuint32_t mobi_get_orth_entry_length(const MOBIIndexEntry *entry) {\n\n    uint32_t entry_textlen;\n    MOBI_RET ret = mobi_get_indxentry_tagvalue(&entry_textlen, entry, INDX_TAG_ORTH_LENGTH);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_NOTSET;\n    }\n\n    return entry_textlen;\n}\n\n/**\n @brief Check if given tagid is present in the index\n \n @param[in] indx Index MOBIIndx structure\n @param[in] tagid Id of the tag\n @return True on success, false otherwise\n */\nbool mobi_indx_has_tag(const MOBIIndx *indx, const size_t tagid) {\n    if (indx) {\n        for (size_t i = 0; i < indx->entries_count; i++) {\n            MOBIIndexEntry entry = indx->entries[i];\n            for(size_t j = 0; j < entry.tags_count; j++) {\n                if (entry.tags[j].tagid == tagid) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n @brief Get compiled index entry string\n\n Allocates memory for the string. Must be freed by caller.\n \n @param[in] cncx_record MOBIPdbRecord structure with cncx record\n @param[in] cncx_offset Offset of string entry from the beginning of the record\n @return Entry string or null if malloc failed\n */\nchar * mobi_get_cncx_string(const MOBIPdbRecord *cncx_record, const uint32_t cncx_offset) {\n    /* TODO: handle multiple cncx records */\n    MOBIBuffer *buf = mobi_buffer_init_null(cncx_record->data, cncx_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return NULL;\n    }\n    mobi_buffer_setpos(buf, cncx_offset);\n    size_t len = 0;\n    const uint32_t string_length = mobi_buffer_get_varlen(buf, &len);\n    char *string = malloc(string_length + 1);\n    if (string) {\n        mobi_buffer_getstring(string, buf, string_length);\n    }\n    mobi_buffer_free_null(buf);\n    return string;\n}\n\n/**\n @brief Get compiled index entry string, converted to utf8 encoding\n \n Allocates memory for the string. Must be freed by caller.\n \n @param[in] cncx_record MOBIPdbRecord structure with cncx record\n @param[in] cncx_offset Offset of string entry from the beginning of the record\n @param[in] cncx_encoding Encoding\n @return Entry string or null if malloc failed\n */\nchar * mobi_get_cncx_string_utf8(const MOBIPdbRecord *cncx_record, const uint32_t cncx_offset, MOBIEncoding cncx_encoding) {\n    char *string = mobi_get_cncx_string(cncx_record, cncx_offset);\n    if (string != NULL && cncx_encoding == MOBI_CP1252) {\n        size_t in_len = strlen(string);\n        size_t out_len = in_len * 3 + 1;\n        char *decoded = malloc(out_len);\n        if (decoded) {\n            mobi_cp1252_to_utf8(decoded, string, &out_len, in_len);\n            free(string);\n            string = strdup(decoded);\n            free(decoded);\n        }\n    }\n    return string;\n}\n\n/**\n @brief Get flat index entry string\n \n Allocates memory for the string. Must be freed by caller.\n \n @param[in] cncx_record MOBIPdbRecord structure with cncx record\n @param[in] cncx_offset Offset of string entry from the beginning of the record\n @param[in] length Length of the string to be extracted\n @return Entry string\n */\nchar * mobi_get_cncx_string_flat(const MOBIPdbRecord *cncx_record, const uint32_t cncx_offset, const size_t length) {\n    /* TODO: handle multiple cncx records */\n    MOBIBuffer *buf = mobi_buffer_init_null(cncx_record->data, cncx_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return NULL;\n    }\n    mobi_buffer_setpos(buf, cncx_offset);\n    char *string = malloc(length + 1);\n    if (string) {\n        mobi_buffer_getstring(string, buf, length);\n    }\n    mobi_buffer_free_null(buf);\n    return string;\n}\n\n/**\n @brief Decode compiled infl index entry\n \n Buffer decoded must be initialized with basic index entry.\n Basic index entry will be transformed into inflected form,\n based on compiled rule.\n Min. size of input buffer (decoded) must be INDX_INFLBUF_SIZEMAX + 1\n \n @param[in,out] decoded Decoded entry string\n @param[in,out] decoded_size Decoded entry size\n @param[in] rule Compiled rule\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; /* insert, delete */\n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; /* left, right */\n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get all matches for given string from trie structure\n \n Matches are made agains reversed string and all its substrings\n \n @param[in,out] infl_strings Array of returned strings\n @param[in,out] root Root node of the tree\n @param[in,out] string Index entry number\n @return Number of returned strings\n */\nsize_t mobi_trie_get_inflgroups(char **infl_strings, MOBITrie * const root, const char *string) {\n    /* travers trie and get values for each substring */\n    if (root == NULL) {\n        return MOBI_PARAM_ERR;\n    }\n    size_t count = 0;\n    size_t length = strlen(string);\n    MOBITrie *node = root;\n    while (node && length > 0) {\n        char **values = NULL;\n        size_t values_count = 0;\n        node = mobi_trie_get_next(&values, &values_count, node, string[length - 1]);\n        length--;\n        for (size_t j = 0; j < values_count; j++) {\n            if (count == INDX_INFLSTRINGS_MAX) {\n                debug_print(\"Inflection strings array too small (%d)\\n\", INDX_INFLSTRINGS_MAX);\n                break;\n            }\n            char infl_string[INDX_LABEL_SIZEMAX + 1];\n            const size_t suffix_length = strlen(values[j]);\n            if (length + suffix_length > INDX_LABEL_SIZEMAX) {\n                debug_print(\"Label too long (%zu + %zu)\\n\", length, suffix_length);\n                continue;\n            }\n            memcpy(infl_string, string, length);\n            memcpy(infl_string + length, values[j], suffix_length);\n            infl_string[length + suffix_length] = '\\0';\n            infl_strings[count++] = strdup(infl_string);\n        }\n    }\n    return count;\n}\n\n/**\n @brief Insert inversed inlection string for given entry into trie structure\n \n @param[in,out] root Root node of the tree, created if NULL\n @param[in,out] indx MOBIIndx infl index records\n @param[in,out] i Index entry number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n"], "fixing_code": ["2022-05-05: Fix: index entry label not being zero-terminated with corrupt input\n2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input\n2022-05-02: Fix typo in macro name\n2022-04-27: Fix undefined behavior when passing null to strdup\n2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input\n2022-04-26: Fix text formatting\n2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input\n2022-04-23: Fix formatting\n2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data\n2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer\n2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input\n2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference\n2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read\n2022-04-13: Add packaging status [skip ci]\n2022-04-10: Make random generation return proper error codes\n2022-04-10: Rewrite randombytes for libmobi\n2022-04-07: Add libsodium randombytes.c\n2022-04-10: Fix \"fallthrough\" spelling\n2022-04-10: Make declaration match definition\n2022-04-10: Fix different sign comparison warning\n2022-04-10: Update Xcode project\n2022-04-10: Don't run tests if bash is missing\n2022-04-10: Looking for libxml2, first try pkg-config\n2022-04-04: Update MSVC project\n2022-04-02: Add support for GNU/kFreeBSD and GNU/Hurd\n2022-04-02: Check for inline, noreturn support in CMake\n2022-03-27: Fix format truncation warning\n2022-03-21: Version 0.10\n2022-03-21: Update Xcode project [skip ci]\n2022-03-21: Add functions for retrieving orthographic index entries\n2022-02-27: Add basic CMake support\n2022-02-26: GHA: fetch tags with checkout\n2022-02-26: Minor refactoring of file path manipulation function\n2022-02-26: Fix memory handling issues\n2022-02-26: Add coverity scan workflow\n2022-02-25: Remove obsolete changelog\n2022-02-25: Fix md5sum output on Windows\n2022-02-25: Fix inconsistent separators in path on Windows builds\n2022-02-25: GHA: fix log paths\n2022-02-25: GHA: fix workflow syntax\n2022-02-25: GHA: upload test logs on failure\n2022-02-24: Fix printf format specifier\n2022-02-24: Fix sample path in Makefile\n2022-02-24: Missing autotools in mingw workflow\n2022-02-24: Windows doesn't accept asterisk in file names\n2022-02-24: Update workflow, add badge\n2022-02-24: Add mingw workflow\n2022-02-24: Fix tests in out-of-tree build\n2022-02-24: Update man pages\n2022-02-24: Replace non-portable strptime\n2022-02-24: Make sure both validity period dates are set\n2022-02-21: Fix strptime not found on linux build\n2022-02-21: Add build github action\n2022-02-21: Update README\n2022-02-21: Minor code cleanups\n2022-02-21: Unify boolean and static usage in tools\n2022-02-21: mobimeta: fix null pointer dereference when parsing malformed option\n2022-02-18: Add  hybrid spit option to mobitool\n2022-02-18: Update documentation\n2022-02-18: Test both encrypted hybrid parts\n2022-02-18: Fix: fast decryption routine fails for non-huffman compression\n2022-02-18: Fix mobitool serial decryption\n2022-02-18: Add DRM tests\n2022-02-17: Fix build with encryption disabled\n2022-02-17: Update tests samples\n2022-02-16: Add -h option to tools, update man pages\n2022-02-16: Update Xcode settings\n2022-02-16: Restructure, cleanup encryption related code, add mobidrm tool\n2021-11-19: Improve getopt loop, fix config.h to be accessible from all tools\n2021-11-10: Update xcode project\n2021-11-10: Add functions to split hybrid files\n2021-11-10: Avoid modifying existing records, as caller may keep reference to them\n2021-11-05: Fix: tests fail if pid contains asterisk\n2021-11-05: Fix: decryption may fail for some records with standard compression\n2021-11-05: Replace test samples with self-generated smaller ones\n2021-11-05: Skip test in case of missing checksums\n2021-10-20: Version 0.9\n2021-10-24: Fix out-of-tree build\n2021-10-22: Fix mingw build, code formatting\n2021-10-14: Fix gcc format truncation warning\n2021-10-14: Include autogen.sh in distribution bundle\n2021-10-14: Create codeql-analysis.yml\n2021-10-14: Fix autoconf 2.70 warnings, clean up\n2021-10-14: Build fails with autoconf 2.70\n2021-10-11: Version 0.8\n2021-10-11: Update Xcode project\n2021-10-11: Fix warnings about changed signedness\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #38\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36\n2021-09-09: Version 0.7\n2021-09-09: fix oob write bug inside libmobi\n2021-06-07: Add reference to brew formula\n2020-09-02: Fix null pointer dereference in case of broken fragment\n2020-08-01: Update changelog\n2020-08-01: Version 0.6\n2020-07-31: Fix typo\n2020-07-31: Add Readme to dist package\n2020-07-31: Remove anchor on truncated link\n2020-07-31: Fix missing option in man page\n2020-07-30: Include test samples in dist package\n2020-07-25: Fix gcc 7+ warnings about implicit fall through and format truncation\n2020-07-24: Unique names for internal functions to avoid confilicts with static linking\n2020-06-24: Close file in error branch\n2020-06-24: Fix static compilation with miniz on gcc\n2020-06-24: Minor documentation fixes\n2020-06-23: Version 0.5\n2020-06-23: mobitool: add dump cover option\n2020-06-23: Minor documentation improvement\n2020-06-23: Fix potential buffer over-read\n2019-03-18: Fix: try also \"name\" attribute when searching for link anchor tags, closes #24\n2019-02-22: Add mobi_is_replica function\n2019-02-22: Fix potential read beyond buffer\n2019-02-22: Travis migration\n2018-08-07: Fix: missing items in recreated ncx file\n2018-06-20: Fix: printf format warning on some gcc versions\n2018-06-20: Fix: make dist broken by nonexistent header files\n2018-06-20: VERSION 0.4\n2018-06-20: Fix: buffer overflow (CVE-2018-11726)\n2018-06-20: Fix: buffer overflow (CVE-2018-11724)\n2018-06-20: Fix: read beyond buffer (CVE-2018-11725)\n2018-06-20: Fix: buffer overflow (mobitool), closes #18\n2018-06-20: Fix: read beyond buffer with corrupted KF8 Boundary record, closes #19\n2018-06-20: Fix: read beyond buffer, closes #16, #17\n2018-06-20: Updated xcode project files\n2018-04-03: Fix: ncx part was not scanned for links, fixes #12\n2018-04-02: Fix regression, potential use after free\n2018-04-02: Skip broken resources, fixes #10\n2018-03-05: Allow processing zero length text records, fixes #9\n2017-12-25: Skip broken first resource offset instead of dying\n2017-12-18: Skip broken links reconstruction instead of dying\n2017-11-27: Disable travis OS X builds, as they usually time out\n2017-11-16: Fix: increase max number of dictionary entries per record\n2017-11-14: Fix for some encrypted documents with palmdoc encoding\n2017-11-06: Fix: potential null pointer dereference\n2017-10-16: Manpage cleanup\n2017-09-27: Update README\n2017-09-26: Increase maximum length of attribute name and value, closes #5\n2017-02-26: Remove obsolete files from VS build (closes #3) [ci skip]\n2016-11-05: Mobitool: use epub extension if extracted source resource is epub\n2016-06-10: Update docs\n2016-06-10: Update test files\n2016-06-10: Fix: out of bounds read in corrupt font resource\n2016-06-10: Prevent memory leak in case of corrupt font resources\n2016-06-10: Calculate deobfuscation buffer limit from key length\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-09: Fix: memory leak in tools\n2016-06-09: Fix: potential out of bounds read\n2016-06-09: Fix: memory leak in internal xmlwriter\n2016-06-01: Update README\n2016-05-19: Feature: verify decryption key type\n2016-05-19: Cleanup converting little endian buffer to 32-bit integer\n2016-05-19: Feature: check drm expiration dates\n2016-05-18: Fix: memory leaks in encryption\n2016-05-18: Fix concurrent autotools builds\n2016-05-18: use relative path, as $(top_srcdir) fails to be substituted (?)\n2016-05-18: update vcxproj\n2016-05-18: Include headers in automake sources\n2016-05-18: Fix: automake out-of-tree miniz build\n2016-05-18: Fix: wrongly detected fdst record broke some ancient documents\n2016-05-18: Fix: improve index header parsing, some old dictionaries might not load\n2016-05-18: Fix: convert encoding of opf strings from cp1252 indices\n2016-05-18: Quiet warnings about unused values of wiped variables\n2016-05-18: Fix: potential memory leak\n2016-05-18: Fix: wrongly decoded \"&copy;\" entity\n2016-05-16: Fix: huffdic decompression fails in case of huge documents\n2016-05-14: Simplify buffer_init_null() function\n2016-05-14: Use ARRAYSIZE macro\n2016-05-14: Feature: calculate pid for decryption from device serial number\n2016-04-29: Use endian-independent byte swapping\n2016-04-29: Exclude unused miniz functions from binary\n2016-04-29: Add SHA-1 routines\n2016-04-27: Fix miniz.c formatting\n2016-04-27: Documentation\n2016-04-20: Update changelog\n2016-04-20: Fix potential null pointer dereference\n2016-04-20: Remove useless check\n2016-04-20: Fix text record size calculation\n2016-04-20: Fix buffer checking and freeing\n2016-04-19: Update docs\n2016-04-19: Update ChangeLog\n2016-04-19: Fix comparison between signed and unsigned integer\n2016-04-19: use strdup on linux/glibc\n2016-04-19: Add initial write and metadata editing support. Add mobimeta tool.\n2016-04-19: Always check whether memory allocation succeeded\n2016-04-18: Fix: guarantee array resize step is at least 1\n2016-04-13: Workaround to read some old mobipocket files\n2016-04-13: Improve pdb dates resolving\n2016-04-07: Minor documentation edit\n2016-04-07: Update changelog\n2016-04-06: Fix format warning\n2016-04-06: Update test checksums\n2016-04-06: Fix: <dc:date> \"event\" attribute needs \"opf\" namespace\n2016-04-06: Fix: id attributes in ncx file should be unique\n2016-04-06: Store full name in MOBIMobiHeader structure\n2016-04-05: Fix formatting\n2016-04-05: Fix signedness warning\n2016-04-04: Fix potential buffer overflow, closes #2\n2016-04-04: Fix potential null pointer dereference\n2016-03-23: Fix signedness warnings\n2016-03-22: Fix: _mkdir needs direct.h on MinGW\n2016-03-22: Fix tests on Windows\n2016-03-22: Fix: palmdoc decompression may fail with zero byte in input buffer\n2016-03-21: VERSION 03: internal xmlwriter, metadata handling functions, bug fixes\n2016-03-21: Feature: add helper functions for metadata extraction\n2016-03-21: Load also kf8 data when only kf7 version is requested\n2016-03-21: Fix: wrong exth header length check could discard some valid headers\n2016-03-20: Get rid of extended attributes in release archive on OS X\n2016-03-19: Mobitool: add descriptive error messages based on libmobi return codes\n2016-03-04: Add extra length check for CMET record extraction\n2016-03-04: Always check buffer allocation result\n2016-03-04: Add functions to extract conversion source and log, also add this feature to mobitool\n2016-03-04: Remove some stray printfs\n2016-03-03: Remove not used AC_FUNC_MALLOC/REALLOC macros that break cross-compilation\n2016-03-03: Fix potential illegal memory access in miniz.c\n2016-03-03: Fix potential dereference of null pointer in miniz.c\n2016-03-03: Fix for Android bionic libc bug (SIZE_MAX missing in stdint.h)\n2016-03-03: Fix mobitool compilation on MSVC++\n2016-03-03: Add EPUB creation feature to mobitool\n2016-03-02: Fix potential buffer overflow, null pointer dereference\n2016-03-02: Add travis test for no-external-dependency build\n2016-03-02: Fix missing strdup on linux\n2016-03-02: Add internal xmlwriter (as an alternative to libxml2)\n2016-03-01: Feature: decode html entities in exth header strings\n2016-02-29: Fix: potential buffer overflow\n2016-02-29: Fix: wrong pid calculation (regression introduced in 0.2)\n2016-02-26: VERSION 0.2: increased stability, lots of bugs fixed\n2016-02-26: Add Xcode project file\n2016-02-26: Preliminary support for MSVC++ compiler\n2016-02-26: Do not use variable length arrays\n2016-02-26: Refactor mobi_reconstruct_parts() to use MOBIFragment list\n2016-02-26: Fix compiler warning about sign conversion\n2016-02-26: Fix compiler warning about type conversion\n2016-02-26: Check the result of malloc/calloc\n2016-02-26: Fix inconsistent use of const between some definitions and declarations\n2016-02-24: Fix inconsistence between function declaration and definition\n2016-02-24: Fix various potential crashes in case of corrupt input (afl-fuzz)\n2016-02-24: Fix dead code warnings in miniz\n2015-11-26: Export mobi_get_first_resource_record() function\n2015-11-26: Fix: double free on corrupt cdic\n2015-11-02: Update docs\n2015-11-02: Feature: add helper functions to find resources by flow id\n2015-11-02: Feature: export MOBI_NOTSET macro\n2015-11-02: Feature: give more options to parse rawml function\n2015-10-24: Restore travis.yml\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix multiline inline script\n2015-10-24: Enable multi-OS feature\n2015-10-24: Fix: unique temporary name for parallel tests\n2015-10-24: Fix: decoding video resources falsely reported as failed\n2015-10-24: Fix: tests, some md5sum implementations insert double spaces\n2015-10-24: Fix for automake < 1.13\n2015-10-23: Add simple tests framework\n2015-10-23: Fix: increase max index entries per record count, as some rare samples fail\n2015-10-22: Fix: incorrectly decoded video/audio resources\n2015-10-22: Feature: add option to specify output path\n2015-10-14: Add some internal functions to public API: mobi_get_flow_by_uid, mobi_get_resource_by_uid, mobi_get_part_by_uid, mobi_get_exthrecord_by_tag\n2015-06-13: update changelog\n2015-06-13: fix: various invalid memory access\n2015-06-13: don't quit on invalid input, instead substitute with replacement character\n2015-06-12: fix typo\n2015-06-12: update changelog\n2015-06-12: fix: reconstruction failed when there were gaps between fragments\n2015-06-12: add EXTH tags\n2015-06-12: prevent return of garbage value check return value in case of failed malloc\n2015-06-12: fix invalid memory access\n2015-04-12: Fix reconstruction of \"kindle:embed\" links without mime type (regression)\n2015-04-12: Add sanity checks to link reconstruction functions, allow skipping some malformed patterns\n2015-04-12: Fix infinite loop in guide build while unknown tag was found\n2015-04-12: Increase max recursion level for huffman decompression\n2015-03-28: update docs\n2015-03-28: fix solaris studio compiler warnings\n2015-03-28: fix solaris studio compiler build\n2015-02-18: Fix \"more than one: -compatibility_version specified\" error on powerpc\n2014-11-24: improve docs\n2014-11-24: simplify public header\n2014-11-21: changelog update [ci skip]\n2014-11-21: README\n2014-11-21: fix: add sanity checks\n2014-11-21: Fix: add sanity checks\n2014-11-21: add sanity check to huffcdic indices count\n2014-11-21: fix number of leaks and other minor issues (by coverity scan)\n2014-11-20: missing notification email kills coverity scan\n2014-11-20: update travis.yml\n2014-11-20: upgrade travis.ml with covert scan\n2014-11-20: update README.md\n2014-11-20: add .travis.yml\n2014-11-20: update REAME.md\n2014-11-20: update README.md\n2014-11-20: update docs\n2014-11-20: feature: add decryption support\n2014-11-20: mkdir cleanup\n2014-11-17: documentation\n2014-11-17: strip unneeded <aid/> tags\n2014-11-16: fix: potential leak\n2014-11-16: fix: regression, some image tags were not reconstructed\n2014-11-16: fix: improve ligatures handling\n2014-11-16: override darwin linker default versioning\n2014-11-15: fix: get proper LIGT entries count from index header\n2014-11-15: feature: unpack records into new folder\n2014-11-14: make README readable on github\n2014-11-14: add README for mobitool\n2014-11-14: fix: dictionaries with large inflection rules failed\n2014-11-14: feature: support encoded ligatures in index entry labels\n2014-11-14: readme\n2014-11-14: update changelog\n2014-11-13: feature: support for older inflections scheme\n2014-11-13: bug: files with short tagx header won't open\n2014-11-13: cleanup unneeded include\n2014-11-13: use strdup on linux/glibc\n2014-11-13: debugging cleanup\n2014-11-13: reorganize source files\n2014-11-13: use strdup on linux/glibc\n2014-11-11: update changelog\n2014-11-11: update changeling\n2014-11-11: fix: documents with text record size > 4096 failed to load\n2014-11-11: add: function to decode flat index entries\n2014-11-11: debug: add functions for debugging indices\n2014-11-11: cleanup\n2014-11-11: fix: variable length value wrongly calculated when going backwards\n2014-11-08: update documentation\n2014-11-08: update changelog\n2014-11-08: add support for reconstructing inflections index entries\n2014-11-08: parsing of exth header failed in some cases\n2014-11-08: fix: some links reconstruction in kf7 failed\n2014-11-08: improve debug info\n2014-11-08: failed malloc false reports\n2014-11-03: fix problem with uncompressed documents\n2014-11-03: fix broken locales\n2014-11-03: remove obsolete includes\n2014-11-03: git log > changelog\n2014-11-03: improved buffer handling\n2014-11-03: improved OPF for dictionaries\n2014-11-03: proper rawml->orth initialization and freeing\n2014-11-03: fix subject field in opf\n2014-11-03: handle UTF-16 surrogates, make ORDT lookups locale independent\n2014-11-01: move dict reconstruction to separate function\n2014-11-01: cleanup\n2014-11-01: quiet gcc warning on printf format\n2014-11-01: reconstruction of orth dictionary entries\n2014-09-27: use mobi_list_del_all()\n2014-09-25: postpone conversion to utf8 after all source reconstructions\n2014-09-24: comment\n2014-09-24: comments\n2014-09-12: doxygen comment\n2014-09-12: data size in comment\n2014-09-05: MOBIArray data type fix\n2014-09-05: config.h fixes\n2014-06-29: merge master\n2014-04-11: initial commit", "/** @file index.c\n *  @brief Functions to parse index records\n *\n * Copyright (c) 2020 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD /* for strdup on linux/glibc */\n#endif\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"index.h\"\n#include \"util.h\"\n#include \"memory.h\"\n#include \"debug.h\"\n#include \"buffer.h\"\n\n\n\n/**\n @brief Read index entry label from buffer pointing at index record data\n \n @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX + 1 bytes)\n @param[in,out] buf MOBIBuffer structure, offset pointing at index entry label\n @param[in] length Number of bytes to be read\n @param[in] has_ligatures Decode ligatures if true\n @return Length of output string (without null terminator), on error buf->error set to MOBI_RET status\n */\nsize_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {\n    if (!output) {\n        buf->error = MOBI_PARAM_ERR;\n        return 0;\n    }\n    if (buf->offset + length > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    const unsigned char replacement = 0x3f;\n    size_t output_length = 0;\n    size_t i = 0;\n    while (i < length && output_length < INDX_LABEL_SIZEMAX) {\n        unsigned char c = mobi_buffer_get8(buf);\n        i++;\n        if (c == 0) {\n            /* FIXME: is it safe to replace zeroes? */\n            debug_print(\"Invalid character: %u\\n\", c);\n            c = replacement;\n        }\n        if (c <= 5 && has_ligatures) {\n            unsigned char c2 = mobi_buffer_get8(buf);\n            c = mobi_ligature_to_cp1252(c, c2);\n            if (c == 0) {\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, -1);\n                c = replacement;\n            } else {\n                i++;\n            }\n        }\n        *output++ = c;\n        output_length++;\n    }\n    *output = '\\0';\n    return output_length;\n}\n\n/**\n @brief Parser of ORDT section of INDX record\n \n @param[in,out] buf MOBIBuffer structure, offset pointing at beginning of TAGX section\n @param[in,out] ordt MOBIOrdt structure to be filled by the function\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_parse_ordt(MOBIBuffer *buf, MOBIOrdt *ordt) {\n    /* read ORDT1 */\n    mobi_buffer_setpos(buf, ordt->ordt1_pos);\n    if (mobi_buffer_match_magic(buf, ORDT_MAGIC)) {\n        debug_print(\"%s\\n\", \"ORDT1 section found\");\n        mobi_buffer_seek(buf, 4);\n        if (ordt->offsets_count + buf->offset > buf->maxlen) {\n            debug_print(\"ORDT1 section too long (%zu)\", ordt->offsets_count);\n            return MOBI_DATA_CORRUPT;\n        }\n        ordt->ordt1 = malloc(ordt->offsets_count * sizeof(*ordt->ordt1));\n        if (ordt->ordt1 == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed for ORDT1 offsets\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        size_t i = 0;\n        while (i < ordt->offsets_count) {\n            ordt->ordt1[i++] = mobi_buffer_get8(buf);\n        }\n        debug_print(\"ORDT1: read %zu entries\\n\", ordt->offsets_count);\n    }\n    /* read ORDT2 */\n    mobi_buffer_setpos(buf, ordt->ordt2_pos);\n    if (mobi_buffer_match_magic(buf, ORDT_MAGIC)) {\n        debug_print(\"%s\\n\", \"ORDT2 section found\");\n        mobi_buffer_seek(buf, 4);\n        if (ordt->offsets_count * 2 + buf->offset > buf->maxlen) {\n            debug_print(\"ORDT2 section too long (%zu)\", ordt->offsets_count);\n            return MOBI_DATA_CORRUPT;\n        }\n        ordt->ordt2 = malloc(ordt->offsets_count * sizeof(*ordt->ordt2));\n        if (ordt->ordt2 == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed for ORDT2 offsets\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        size_t i = 0;\n        while (i < ordt->offsets_count) {\n            ordt->ordt2[i++] = mobi_buffer_get16(buf);\n        }\n        debug_print(\"ORDT2: read %zu entries\\n\", ordt->offsets_count);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parser of TAGX section of INDX record\n \n @param[in,out] buf MOBIBuffer structure, offset pointing at beginning of TAGX section\n @param[in,out] tagx MOBITagx structure to be filled by the function\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_parse_tagx(MOBIBuffer *buf, MOBITagx *tagx) {\n    tagx->control_byte_count = 0;\n    tagx->tags_count = 0;\n    tagx->tags = NULL;\n    mobi_buffer_seek(buf, 4); /* skip header */\n    uint32_t tagx_record_length = mobi_buffer_get32(buf);\n    if (tagx_record_length < 12) {\n        debug_print(\"INDX record too short: %u\\n\", tagx_record_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->control_byte_count = mobi_buffer_get32(buf);\n    tagx_record_length -= 12;\n    if (tagx_record_length + buf->offset > buf->maxlen) {\n        debug_print(\"INDX record too long: %u\\n\", tagx_record_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->tags = malloc(tagx_record_length * sizeof(TAGXTags));\n    if (tagx->tags == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed for TAGX tags\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    const size_t tagx_data_length = tagx_record_length / 4;\n    size_t control_byte_count = 0;\n    while (i < tagx_data_length) {\n        tagx->tags[i].tag = mobi_buffer_get8(buf);\n        tagx->tags[i].values_count = mobi_buffer_get8(buf);\n        tagx->tags[i].bitmask = mobi_buffer_get8(buf);\n        const uint8_t control_byte = mobi_buffer_get8(buf);\n        if (control_byte) { control_byte_count++; }\n        tagx->tags[i].control_byte = control_byte;\n        debug_print(\"tagx[%zu]:\\t%i\\t%i\\t%i\\t%i\\n\", i, tagx->tags[i].tag, tagx->tags[i].values_count, tagx->tags[i].bitmask, control_byte);\n        i++;\n    }\n    if (tagx->control_byte_count != control_byte_count) {\n        debug_print(\"Wrong count of control bytes: %zu != %zu\\n\", tagx->control_byte_count, control_byte_count);\n        free(tagx->tags);\n        tagx->tags = NULL;\n        tagx->control_byte_count = 0;\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->tags_count = i;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parser of IDXT section of INDX record\n \n @param[in,out] buf MOBIBuffer structure, offset pointing at beginning of TAGX section\n @param[in,out] idxt MOBITagx structure to be filled by the function\n @param[in] entries_count Number of index entries\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_parse_idxt(MOBIBuffer *buf, MOBIIdxt *idxt, const size_t entries_count) {\n    const uint32_t idxt_offset = (uint32_t) buf->offset;\n    idxt->offsets_count = 0;\n    char idxt_magic[5];\n    mobi_buffer_getstring(idxt_magic, buf, 4);\n    if (strncmp(idxt_magic, IDXT_MAGIC, 4) != 0) {\n        debug_print(\"IDXT wrong magic: %s\\n\", idxt_magic);\n        return MOBI_DATA_CORRUPT;\n    }\n    size_t i = 0;\n    while (i < entries_count) {\n        /* entry offsets */\n        idxt->offsets[i++] = mobi_buffer_get16(buf);\n    }\n    /* last entry end position is IDXT tag offset */\n    idxt->offsets[i] = idxt_offset;\n    idxt->offsets_count = i;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get encoded character from dictionary index\n The characters are offsets into ORDT table\n \n @param[in] ordt MOBIOrdt structure (ORDT data and metadata)\n @param[in,out] buf MOBIBuffer structure with index data\n @param[in,out] offset Value read from buffer\n @return Number of bytes read (zero in case of error)\n */\nsize_t mobi_ordt_getbuffer(const MOBIOrdt *ordt, MOBIBuffer *buf, uint16_t *offset) {\n    size_t i = 0;\n    if (ordt->type == 1) {\n        *offset = mobi_buffer_get8(buf);\n        i++;\n    } else {\n        *offset = mobi_buffer_get16(buf);\n        i += 2;\n    }\n    return i;\n}\n\n/**\n @brief Fetch UTF-16 value from ORDT2 table\n \n @param[in] ordt MOBIOrdt structure (ORDT data and metadata)\n @param[in] offset Offset in ORDT2 table\n @return UTF-16 code point\n */\nuint16_t mobi_ordt_lookup(const MOBIOrdt *ordt, const uint16_t offset) {\n    uint16_t utf16;\n    if (offset < ordt->offsets_count) {\n        utf16 = ordt->ordt2[offset];\n    } else {\n        utf16 = offset;\n    }\n    return utf16;\n}\n\n/**\n @brief Get UTF-8 string from buffer, decoded by lookups in ORDT2 table\n \n @param[in] ordt MOBIOrdt structure (ORDT data and metadata)\n @param[in,out] buf MOBIBuffer structure with input string\n @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX + 1 bytes)\n @param[in] length Length of input string contained in buf\n @return Length of output string (without null terminator)\n */\nsize_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {\n    size_t i = 0;\n    size_t output_length = 0;\n    const uint32_t bytemask = 0xbf;\n    const uint32_t bytemark = 0x80;\n    const uint32_t uni_replacement = 0xfffd;\n    const uint32_t surrogate_offset = 0x35fdc00;\n    static const uint8_t init_byte[7] = { 0x00, 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc };\n    while (i < length) {\n        uint16_t offset;\n        i += mobi_ordt_getbuffer(ordt, buf, &offset);\n        uint32_t codepoint = mobi_ordt_lookup(ordt, offset);\n        if (codepoint <= 5) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            codepoint = mobi_ligature_to_utf16(codepoint, codepoint2);\n            if (codepoint == uni_replacement) {\n                /* rewind buffer to codepoint2 */\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, - (int) k);\n            } else {\n                i += k;\n            }\n        }\n        /* convert UTF-16 surrogates into UTF-32 */\n        if (codepoint >= 0xd800 && codepoint <= 0xdbff) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            if (codepoint2 >= 0xdc00 && codepoint2 <= 0xdfff) {\n                i += k;\n                codepoint = (codepoint << 10) + codepoint2 - surrogate_offset;\n            } else {\n                /* illegal unpaired high surrogate */\n                /* rewind buffer to codepoint2 */\n                debug_print(\"Invalid code point: %u\\n\", codepoint);\n                mobi_buffer_seek(buf, - (int) k);\n                codepoint = uni_replacement;\n            }\n        }\n        if ((codepoint >= 0xdc00 && codepoint <= 0xdfff) /* unpaired low surrogate */\n            || (codepoint >= 0xfdd0 && codepoint <= 0xfdef) /* invalid characters */\n            || (codepoint & 0xfffe) == 0xfffe /* reserved characters */\n            || codepoint == 0 /* remove zeroes */) {\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        /* Conversion routine based on unicode's ConvertUTF.c */\n        size_t bytes;\n        if (codepoint < 0x80) { bytes = 1; }\n        else if (codepoint < 0x800) { bytes = 2; }\n        else if (codepoint < 0x10000) { bytes = 3; }\n        else if (codepoint < 0x110000) { bytes = 4; }\n        else {\n            bytes = 3;\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        if (output_length + bytes >= INDX_LABEL_SIZEMAX) {\n            debug_print(\"%s\\n\", \"INDX label too long\");\n            break;\n        }\n        output += bytes;\n        switch (bytes) {\n            case 4: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 3: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 2: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 1: *--output = (uint8_t)(codepoint | init_byte[bytes]);\n        }\n        output += bytes;\n        output_length += bytes;\n    }\n    *output = '\\0';\n    return output_length;\n}\n\n/**\n @brief Parser of INDX index entry\n \n @param[in,out] indx MOBIIndx structure, to be filled with parsed data\n @param[in] idxt MOBIIdxt structure with parsed IDXT index\n @param[in] tagx MOBITagx structure with parsed TAGX index\n @param[in,out] buf MOBIBuffer structure with index data\n @param[in] curr_number Sequential number of an index entry for current record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX + 1];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n        if (buf->error != MOBI_SUCCESS) {\n            debug_print(\"Buffer error reading label: %d\\n\", buf->error);\n            return MOBI_DATA_CORRUPT;\n        }\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx->tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parser of INDX record\n \n @param[in] indx_record MOBIPdbRecord structure with INDX record\n @param[in,out] indx MOBIIndx structure to be filled with parsed entries\n @param[in,out] tagx MOBITagx structure, will be filled with parsed TAGX section data if present in the INDX record, otherwise TAGX data will be used to parse the record\n @param[in,out] ordt MOBIOrdt structure, will be filled with parsed ORDT sections\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_indx(const MOBIPdbRecord *indx_record, MOBIIndx *indx, MOBITagx *tagx, MOBIOrdt *ordt) {\n    if (indx_record == NULL || indx == NULL || tagx == NULL || ordt == NULL) {\n        debug_print(\"%s\", \"index structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf = mobi_buffer_init_null(indx_record->data, indx_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char indx_magic[5];\n    mobi_buffer_getstring(indx_magic, buf, 4); /* 0: INDX magic */\n    const uint32_t header_length = mobi_buffer_get32(buf); /* 4: header length */\n    if (strncmp(indx_magic, INDX_MAGIC, 4) != 0 ||\n        header_length == 0 || header_length > indx_record->size) {\n        debug_print(\"INDX wrong magic: %s or header length: %u\\n\", indx_magic, header_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    mobi_buffer_seek(buf, 4); /* 8: unk, usually zeroes */\n    const uint32_t type = mobi_buffer_get32(buf); /* 12: 0 - normal, 2 - inflection */\n    mobi_buffer_seek(buf, 4); /* 16: unk */\n    const uint32_t idxt_offset = mobi_buffer_get32(buf); /* 20: IDXT offset */\n    const uint32_t entries_count = mobi_buffer_get32(buf); /* 24: entries count */\n    if (entries_count > INDX_RECORD_MAXCNT) {\n        debug_print(\"Too many index entries (%u)\\n\", entries_count);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* if record contains TAGX section, read it (and ORDT) and return */\n    if (mobi_buffer_match_magic_offset(buf, TAGX_MAGIC, header_length) && indx->total_entries_count == 0) {\n        buf->maxlen = header_length;\n        /* TAGX metadata */\n        uint32_t encoding = mobi_buffer_get32(buf); /* 28: encoding */\n        if (encoding == MOBI_NOTSET) { encoding = MOBI_CP1252; }\n        mobi_buffer_seek(buf, 4); /* 32 */\n        const uint32_t total_entries_count = mobi_buffer_get32(buf); /* 36: total entries count */\n        if (total_entries_count > INDX_TOTAL_MAXCNT) {\n            debug_print(\"Too many total index entries (%u)\\n\", total_entries_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t ordt_offset = mobi_buffer_get32(buf); /* 40: ORDT offset; currently not used */\n        if (ordt_offset + ORDT_RECORD_MAXCNT + 4 > indx_record->size) {\n            ordt_offset = 0;\n        }\n        uint32_t ligt_offset = mobi_buffer_get32(buf); /* 44: LIGT offset; currently static table used instead */\n        uint32_t ligt_entries_count = mobi_buffer_get32(buf); /* 48: LIGT entries count */\n        if (ligt_offset + 4 * ligt_entries_count + 4 > indx_record->size) {\n            ligt_offset = 0;\n            ligt_entries_count = 0;\n        }\n        const uint32_t cncx_records_count = mobi_buffer_get32(buf); /* 52: CNCX entries count */\n        if (cncx_records_count > CNCX_RECORD_MAXCNT) {\n            debug_print(\"Too many CNCX records (%u)\\n\", cncx_records_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* 56: unk count */\n        /* 60-148: phonetizer */\n        uint32_t ordt_type = 0;\n        uint32_t ordt_entries_count = 0;\n        uint32_t ordt1_offset = 0;\n        uint32_t ordt2_offset = 0;\n        uint32_t index_name_offset = 0;\n        uint32_t index_name_length = 0;\n        if (header_length >= 180) {\n            mobi_buffer_setpos(buf, 164);\n            ordt_type = mobi_buffer_get32(buf); /* 164: ORDT type */\n            ordt_entries_count = mobi_buffer_get32(buf); /* 168: ORDT entries count */\n            ordt1_offset = mobi_buffer_get32(buf); /* 172: ORDT1 offset; currently not used */\n            ordt2_offset = mobi_buffer_get32(buf); /* 176: ORDT2 offset */\n            const size_t entry_size = (ordt_type == 0) ? 1 : 2;\n            if (ordt1_offset + entry_size * ordt_entries_count > indx_record->size\n                || ordt2_offset + 2 * ordt_entries_count > indx_record->size) {\n                ordt1_offset = 0;\n                ordt2_offset = 0;\n                ordt_entries_count = 0;\n            }\n            index_name_offset = mobi_buffer_get32(buf); /* 180: Index name offset */\n            index_name_length = mobi_buffer_get32(buf); /* 184: Index name length */\n        }\n        buf->maxlen = indx_record->size;\n        mobi_buffer_setpos(buf, header_length);\n        ret = mobi_parse_tagx(buf, tagx);\n        if (ret != MOBI_SUCCESS) {\n            mobi_buffer_free_null(buf);\n            return ret;\n        }\n        if (ordt_entries_count > 0) {\n            /* parse ORDT sections */\n            ordt->offsets_count = ordt_entries_count;\n            ordt->type = ordt_type;\n            ordt->ordt1_pos = ordt1_offset;\n            ordt->ordt2_pos = ordt2_offset;\n            ret = mobi_parse_ordt(buf, ordt);\n            debug_print(\"ORDT: %u, %u, %u, %u\\n\", ordt_type, ordt_entries_count, ordt1_offset, ordt2_offset);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                return ret;\n            }\n        }\n        if (index_name_offset > 0 && index_name_length > 0) {\n            if (index_name_length <= header_length - index_name_offset && index_name_length < INDX_NAME_SIZEMAX) {\n                mobi_buffer_setpos(buf, index_name_offset);\n                char *name = malloc(index_name_length + 1);\n                if (name == NULL) {\n                    debug_print(\"%s\", \"Memory allocation failed\\n\");\n                    mobi_buffer_free_null(buf);\n                    return MOBI_MALLOC_FAILED;\n                }\n                mobi_buffer_getstring(name, buf, index_name_length);\n                indx->orth_index_name = name;\n                debug_print(\"Orth index name: %s\\n\", name);\n            }\n        }\n        indx->encoding = encoding;\n        indx->type = type;\n        indx->entries_count = entries_count;\n        indx->total_entries_count = total_entries_count;\n        if (ligt_entries_count != 0 && !mobi_buffer_match_magic_offset(buf, LIGT_MAGIC, ligt_offset)) {\n            ligt_offset = 0;\n            ligt_entries_count = 0;\n        }\n        indx->ligt_offset = ligt_offset;\n        indx->ligt_entries_count = ligt_entries_count;\n        indx->ordt_offset = ordt_offset;\n        indx->cncx_records_count = cncx_records_count;\n    } else {\n        /* else parse IDXT entries offsets */\n        if (idxt_offset == 0) {\n            debug_print(\"%s\", \"Missing IDXT offset\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (idxt_offset + 2 * entries_count + 4 > indx_record->size ) {\n            debug_print(\"IDXT entries beyond record end%s\", \"\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, idxt_offset);\n        MOBIIdxt idxt;\n        uint32_t *offsets = malloc((entries_count + 1) * sizeof(uint32_t));\n        if (offsets == NULL) {\n            mobi_buffer_free_null(buf);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        idxt.offsets = offsets;\n        ret = mobi_parse_idxt(buf, &idxt, entries_count);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"IDXT parsing failed\\n\");\n            mobi_buffer_free_null(buf);\n            free(offsets);\n            return ret;\n        }\n        /* parse entries */\n        if (entries_count > 0) {\n            if (indx->entries == NULL) {\n                indx->entries = malloc(indx->total_entries_count * sizeof(MOBIIndexEntry));\n                if (indx->entries == NULL) {\n                    mobi_buffer_free_null(buf);\n                    free(offsets);\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n            }\n            size_t i = 0;\n            while (i < entries_count) {\n                ret = mobi_parse_index_entry(indx, idxt, tagx, ordt, buf, i++);\n                if (ret != MOBI_SUCCESS) {\n                    mobi_buffer_free_null(buf);\n                    free(offsets);\n                    return ret;\n                }\n            }\n            indx->entries_count += entries_count;\n        }\n        free(offsets);\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parser of a set of index records\n \n @param[in] m MOBIData structure containing MOBI file metadata and data\n @param[in,out] indx MOBIIndx structure to be filled with parsed entries\n @param[in] indx_record_number Number of the first record of the set\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_index(const MOBIData *m, MOBIIndx *indx, const size_t indx_record_number) {\n    MOBI_RET ret;\n    /* tagx->tags array will be allocated in mobi_parse_tagx */\n    MOBITagx *tagx = calloc(1, sizeof(MOBITagx));\n    if (tagx == NULL) {\n        mobi_free_indx(indx);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* ordt->ordt1 and ordt.ordt2 arrays will be allocated in mobi_parse_ordt */\n    MOBIOrdt *ordt = calloc(1, sizeof(MOBIOrdt));\n    if (ordt == NULL) {\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse first meta INDX record */\n    MOBIPdbRecord *record = mobi_get_record_by_seqnumber(m, indx_record_number);\n    ret = mobi_parse_indx(record, indx, tagx, ordt);\n    if (ret != MOBI_SUCCESS) {\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        mobi_free_ordt(ordt);\n        return ret;\n    }\n    /* parse remaining INDX records for the index */\n    size_t count = indx->entries_count;\n    indx->entries_count = 0;\n    while (count--) {\n        record = record->next;\n        ret = mobi_parse_indx(record, indx, tagx, ordt);\n        if (ret != MOBI_SUCCESS) {\n            mobi_free_indx(indx);\n            mobi_free_tagx(tagx);\n            mobi_free_ordt(ordt);\n            return ret;\n        }\n    }\n    if (indx->entries_count != indx->total_entries_count) {\n        debug_print(\"Entries count %zu != total entries count %zu\\n\", indx->entries_count, indx->total_entries_count);\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        mobi_free_ordt(ordt);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* copy pointer to first cncx record if present and set info from first record */\n    if (indx->cncx_records_count) {\n        indx->cncx_record = record->next;\n    }\n    mobi_free_tagx(tagx);\n    mobi_free_ordt(ordt);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get a value of tag[tagid][tagindex] for given index entry\n \n @param[in,out] tagvalue Will be set to a tag value\n @param[in] entry Index entry to be search for the value\n @param[in] tag_arr Array: tag_arr[0] = tagid, tag_arr[1] = tagindex\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_indxentry_tagvalue(uint32_t *tagvalue, const MOBIIndexEntry *entry, const unsigned tag_arr[]) {\n    if (entry == NULL) {\n        debug_print(\"%s\", \"INDX entry not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    size_t i = 0;\n    while (i < entry->tags_count) {\n        if (entry->tags[i].tagid == tag_arr[0]) {\n            if (entry->tags[i].tagvalues_count > tag_arr[1]) {\n                *tagvalue = entry->tags[i].tagvalues[tag_arr[1]];\n                return MOBI_SUCCESS;\n            }\n            break;\n        }\n        i++;\n    }\n    //debug_print(\"tag[%i][%i] not found in entry: %s\\n\", tag_arr[0], tag_arr[1], entry->label);\n    return MOBI_DATA_CORRUPT;\n}\n\n/**\n @brief Get array of tagvalues of tag[tagid] for given index entry\n \n @param[in,out] tagarr Pointer to tagvalues array\n @param[in] entry Index entry to be search for the value\n @param[in] tagid Id of the tag\n @return Size of the array (zero on failure)\n */\nsize_t mobi_get_indxentry_tagarray(uint32_t **tagarr, const MOBIIndexEntry *entry, const size_t tagid) {\n    if (entry == NULL) {\n        debug_print(\"%s\", \"INDX entry not initialized\\n\");\n        return 0;\n    }\n    size_t i = 0;\n    while (i < entry->tags_count) {\n        if (entry->tags[i].tagid == tagid) {\n            *tagarr = entry->tags[i].tagvalues;\n            return entry->tags[i].tagvalues_count;\n        }\n        i++;\n    }\n    //debug_print(\"tag[%zu] not found in entry: %s\\n\", tagid, entry->label);\n    return 0;\n}\n\n/**\n @brief Get entry start offset for the orth entry\n @param[in] entry MOBIIndexEntry structure\n @return Start offset, MOBI_NOTSET on failure\n */\nuint32_t mobi_get_orth_entry_offset(const MOBIIndexEntry *entry) {\n\n    uint32_t entry_startpos;\n    MOBI_RET ret = mobi_get_indxentry_tagvalue(&entry_startpos, entry, INDX_TAG_ORTH_POSITION);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_NOTSET;\n    }\n    \n    return entry_startpos;\n}\n\n/**\n @brief Get text length for the orth entry\n @param[in] entry MOBIIndexEntry structure\n @return Text length, MOBI_NOTSET on failure\n */\nuint32_t mobi_get_orth_entry_length(const MOBIIndexEntry *entry) {\n\n    uint32_t entry_textlen;\n    MOBI_RET ret = mobi_get_indxentry_tagvalue(&entry_textlen, entry, INDX_TAG_ORTH_LENGTH);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_NOTSET;\n    }\n\n    return entry_textlen;\n}\n\n/**\n @brief Check if given tagid is present in the index\n \n @param[in] indx Index MOBIIndx structure\n @param[in] tagid Id of the tag\n @return True on success, false otherwise\n */\nbool mobi_indx_has_tag(const MOBIIndx *indx, const size_t tagid) {\n    if (indx) {\n        for (size_t i = 0; i < indx->entries_count; i++) {\n            MOBIIndexEntry entry = indx->entries[i];\n            for(size_t j = 0; j < entry.tags_count; j++) {\n                if (entry.tags[j].tagid == tagid) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n @brief Get compiled index entry string\n\n Allocates memory for the string. Must be freed by caller.\n \n @param[in] cncx_record MOBIPdbRecord structure with cncx record\n @param[in] cncx_offset Offset of string entry from the beginning of the record\n @return Entry string or null if malloc failed\n */\nchar * mobi_get_cncx_string(const MOBIPdbRecord *cncx_record, const uint32_t cncx_offset) {\n    /* TODO: handle multiple cncx records */\n    MOBIBuffer *buf = mobi_buffer_init_null(cncx_record->data, cncx_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return NULL;\n    }\n    mobi_buffer_setpos(buf, cncx_offset);\n    size_t len = 0;\n    const uint32_t string_length = mobi_buffer_get_varlen(buf, &len);\n    char *string = malloc(string_length + 1);\n    if (string) {\n        mobi_buffer_getstring(string, buf, string_length);\n    }\n    mobi_buffer_free_null(buf);\n    return string;\n}\n\n/**\n @brief Get compiled index entry string, converted to utf8 encoding\n \n Allocates memory for the string. Must be freed by caller.\n \n @param[in] cncx_record MOBIPdbRecord structure with cncx record\n @param[in] cncx_offset Offset of string entry from the beginning of the record\n @param[in] cncx_encoding Encoding\n @return Entry string or null if malloc failed\n */\nchar * mobi_get_cncx_string_utf8(const MOBIPdbRecord *cncx_record, const uint32_t cncx_offset, MOBIEncoding cncx_encoding) {\n    char *string = mobi_get_cncx_string(cncx_record, cncx_offset);\n    if (string != NULL && cncx_encoding == MOBI_CP1252) {\n        size_t in_len = strlen(string);\n        size_t out_len = in_len * 3 + 1;\n        char *decoded = malloc(out_len);\n        if (decoded) {\n            mobi_cp1252_to_utf8(decoded, string, &out_len, in_len);\n            free(string);\n            string = strdup(decoded);\n            free(decoded);\n        }\n    }\n    return string;\n}\n\n/**\n @brief Get flat index entry string\n \n Allocates memory for the string. Must be freed by caller.\n \n @param[in] cncx_record MOBIPdbRecord structure with cncx record\n @param[in] cncx_offset Offset of string entry from the beginning of the record\n @param[in] length Length of the string to be extracted\n @return Entry string\n */\nchar * mobi_get_cncx_string_flat(const MOBIPdbRecord *cncx_record, const uint32_t cncx_offset, const size_t length) {\n    /* TODO: handle multiple cncx records */\n    MOBIBuffer *buf = mobi_buffer_init_null(cncx_record->data, cncx_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return NULL;\n    }\n    mobi_buffer_setpos(buf, cncx_offset);\n    char *string = malloc(length + 1);\n    if (string) {\n        mobi_buffer_getstring(string, buf, length);\n    }\n    mobi_buffer_free_null(buf);\n    return string;\n}\n\n/**\n @brief Decode compiled infl index entry\n \n Buffer decoded must be initialized with basic index entry.\n Basic index entry will be transformed into inflected form,\n based on compiled rule.\n Min. size of input buffer (decoded) must be INDX_INFLBUF_SIZEMAX + 1\n \n @param[in,out] decoded Decoded entry string\n @param[in,out] decoded_size Decoded entry size\n @param[in] rule Compiled rule\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; /* insert, delete */\n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; /* left, right */\n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get all matches for given string from trie structure\n \n Matches are made agains reversed string and all its substrings\n \n @param[in,out] infl_strings Array of returned strings\n @param[in,out] root Root node of the tree\n @param[in,out] string Index entry number\n @return Number of returned strings\n */\nsize_t mobi_trie_get_inflgroups(char **infl_strings, MOBITrie * const root, const char *string) {\n    /* travers trie and get values for each substring */\n    if (root == NULL) {\n        return MOBI_PARAM_ERR;\n    }\n    size_t count = 0;\n    size_t length = strlen(string);\n    MOBITrie *node = root;\n    while (node && length > 0) {\n        char **values = NULL;\n        size_t values_count = 0;\n        node = mobi_trie_get_next(&values, &values_count, node, string[length - 1]);\n        length--;\n        for (size_t j = 0; j < values_count; j++) {\n            if (count == INDX_INFLSTRINGS_MAX) {\n                debug_print(\"Inflection strings array too small (%d)\\n\", INDX_INFLSTRINGS_MAX);\n                break;\n            }\n            char infl_string[INDX_LABEL_SIZEMAX + 1];\n            const size_t suffix_length = strlen(values[j]);\n            if (length + suffix_length > INDX_LABEL_SIZEMAX) {\n                debug_print(\"Label too long (%zu + %zu)\\n\", length, suffix_length);\n                continue;\n            }\n            memcpy(infl_string, string, length);\n            memcpy(infl_string + length, values[j], suffix_length);\n            infl_string[length + suffix_length] = '\\0';\n            infl_strings[count++] = strdup(infl_string);\n        }\n    }\n    return count;\n}\n\n/**\n @brief Insert inversed inlection string for given entry into trie structure\n \n @param[in,out] root Root node of the tree, created if NULL\n @param[in,out] indx MOBIIndx infl index records\n @param[in,out] i Index entry number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n"], "filenames": ["ChangeLog", "src/index.c"], "buggy_code_start_loc": [0, 32], "buggy_code_end_loc": [0, 370], "fixing_code_start_loc": [1, 32], "fixing_code_end_loc": [2, 375], "type": "CWE-125", "message": "Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.", "other": {"cve": {"id": "CVE-2022-1987", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-03T08:15:07.383", "lastModified": "2022-06-12T02:47:07.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11."}, {"lang": "es", "value": "Una lectura excesiva del b\u00fafer en el repositorio de GitHub bfabiszewski/libmobi versiones anteriores a 0.11"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmobi_project:libmobi:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.11", "matchCriteriaId": "6FF60ACA-0257-493F-A0F1-CD257EFDAC33"}]}]}], "references": [{"url": "https://github.com/bfabiszewski/libmobi/commit/612562bc1ea38f1708b044e7a079c47a05b1291d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/e8197737-7557-443e-a59f-2a86e8dda75f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bfabiszewski/libmobi/commit/612562bc1ea38f1708b044e7a079c47a05b1291d"}}