{"buggy_code": ["/*\n** $Id: ldo.c $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n#define ldo_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n#include \"lzio.h\"\n\n\n\n#define errorstatus(s)\t((s) > LUA_YIELD)\n\n\n/*\n** {======================================================\n** Error-recovery functions\n** =======================================================\n*/\n\n/*\n** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By\n** default, Lua handles errors with exceptions when compiling as\n** C++ code, with _longjmp/_setjmp when asked to use them, and with\n** longjmp/setjmp otherwise.\n*/\n#if !defined(LUAI_THROW)\t\t\t\t/* { */\n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)\t/* { */\n\n/* C++ exceptions */\n#define LUAI_THROW(L,c)\t\tthrow(c)\n#define LUAI_TRY(L,c,a) \\\n\ttry { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\t\tint  /* dummy variable */\n\n#elif defined(LUA_USE_POSIX)\t\t\t\t/* }{ */\n\n/* in POSIX, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)\t\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#else\t\t\t\t\t\t\t/* }{ */\n\n/* ISO C handling with long jumps */\n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#endif\t\t\t\t\t\t\t/* } */\n\n#endif\t\t\t\t\t\t\t/* } */\n\n\n\n/* chain list of long jump buffers */\nstruct lua_longjmp {\n  struct lua_longjmp *previous;\n  luai_jmpbuf b;\n  volatile int status;  /* error code */\n};\n\n\nvoid luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {\n  switch (errcode) {\n    case LUA_ERRMEM: {  /* memory error? */\n      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */\n      break;\n    }\n    case LUA_ERRERR: {\n      setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n      break;\n    }\n    case CLOSEPROTECT: {\n      setnilvalue(s2v(oldtop));  /* no error message */\n      break;\n    }\n    default: {\n      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */\n      break;\n    }\n  }\n  L->top = oldtop + 1;\n}\n\n\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {  /* thread has an error handler? */\n    L->errorJmp->status = errcode;  /* set status */\n    LUAI_THROW(L, L->errorJmp);  /* jump to it */\n  }\n  else {  /* thread has no error handler */\n    global_State *g = G(L);\n    errcode = luaF_close(L, L->stack, errcode);  /* close all upvalues */\n    L->status = cast_byte(errcode);  /* mark it as dead */\n    if (g->mainthread->errorJmp) {  /* main thread has a handler? */\n      setobjs2s(L, g->mainthread->top++, L->top - 1);  /* copy error obj. */\n      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */\n    }\n    else {  /* no handler at all; abort */\n      if (g->panic) {  /* panic function? */\n        luaD_seterrorobj(L, errcode, L->top);  /* assume EXTRA_STACK */\n        if (L->ci->top < L->top)\n          L->ci->top = L->top;  /* pushing msg. can break this invariant */\n        lua_unlock(L);\n        g->panic(L);  /* call panic function (last chance to jump out) */\n      }\n      abort();\n    }\n  }\n}\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  global_State *g = G(L);\n  l_uint32 oldnCcalls = g->Cstacklimit - (L->nCcalls + L->nci);\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = g->Cstacklimit - oldnCcalls - L->nci;\n  return lj.status;\n}\n\n/* }====================================================== */\n\n\n/*\n** {==================================================================\n** Stack reallocation\n** ===================================================================\n*/\nstatic void correctstack (lua_State *L, StkId oldstack, StkId newstack) {\n  CallInfo *ci;\n  UpVal *up;\n  if (oldstack == newstack)\n    return;  /* stack address did not change */\n  L->top = (L->top - oldstack) + newstack;\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v = s2v((uplevel(up) - oldstack) + newstack);\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top = (ci->top - oldstack) + newstack;\n    ci->func = (ci->func - oldstack) + newstack;\n    if (isLua(ci))\n      ci->u.l.trap = 1;  /* signal to update 'trap' in 'luaV_execute' */\n  }\n}\n\n\n/* some space for error handling */\n#define ERRORSTACKSIZE\t(LUAI_MAXSTACK + 200)\n\n\nint luaD_reallocstack (lua_State *L, int newsize, int raiseerror) {\n  int lim = L->stacksize;\n  StkId newstack = luaM_reallocvector(L, L->stack, lim, newsize, StackValue);\n  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);\n  if (unlikely(newstack == NULL)) {  /* reallocation failed? */\n    if (raiseerror)\n      luaM_error(L);\n    else return 0;  /* do not raise an error */\n  }\n  for (; lim < newsize; lim++)\n    setnilvalue(s2v(newstack + lim)); /* erase new segment */\n  correctstack(L, L->stack, newstack);\n  L->stack = newstack;\n  L->stacksize = newsize;\n  L->stack_last = L->stack + newsize - EXTRA_STACK;\n  return 1;\n}\n\n\n/*\n** Try to grow the stack by at least 'n' elements. when 'raiseerror'\n** is true, raises any error; otherwise, return 0 in case of errors.\n*/\nint luaD_growstack (lua_State *L, int n, int raiseerror) {\n  int size = L->stacksize;\n  int newsize = 2 * size;  /* tentative new size */\n  if (unlikely(size > LUAI_MAXSTACK)) {  /* need more space after extra size? */\n    if (raiseerror)\n      luaD_throw(L, LUA_ERRERR);  /* error inside message handler */\n    else return 0;\n  }\n  else {\n    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;\n    if (newsize > LUAI_MAXSTACK)  /* cannot cross the limit */\n      newsize = LUAI_MAXSTACK;\n    if (newsize < needed)  /* but must respect what was asked for */\n      newsize = needed;\n    if (unlikely(newsize > LUAI_MAXSTACK)) {  /* stack overflow? */\n      /* add extra size to be able to handle the error message */\n      luaD_reallocstack(L, ERRORSTACKSIZE, raiseerror);\n      if (raiseerror)\n        luaG_runerror(L, \"stack overflow\");\n      else return 0;\n    }\n  }  /* else no errors */\n  return luaD_reallocstack(L, newsize, raiseerror);\n}\n\n\nstatic int stackinuse (lua_State *L) {\n  CallInfo *ci;\n  StkId lim = L->top;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    if (lim < ci->top) lim = ci->top;\n  }\n  lua_assert(lim <= L->stack_last);\n  return cast_int(lim - L->stack) + 1;  /* part of stack in use */\n}\n\n\nvoid luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}\n\n\nvoid luaD_inctop (lua_State *L) {\n  luaD_checkstack(L, 1);\n  L->top++;\n}\n\n/* }================================================================== */\n\n\n/*\n** Call a hook for the given event. Make sure there is a hook to be\n** called. (Both 'L->hook' and 'L->hookmask', which trigger this\n** function, can be changed asynchronously by signals.)\n*/\nvoid luaD_hook (lua_State *L, int event, int line,\n                              int ftransfer, int ntransfer) {\n  lua_Hook hook = L->hook;\n  if (hook && L->allowhook) {  /* make sure there is a hook */\n    int mask = CIST_HOOKED;\n    CallInfo *ci = L->ci;\n    ptrdiff_t top = savestack(L, L->top);\n    ptrdiff_t ci_top = savestack(L, ci->top);\n    lua_Debug ar;\n    ar.event = event;\n    ar.currentline = line;\n    ar.i_ci = ci;\n    if (ntransfer != 0) {\n      mask |= CIST_TRAN;  /* 'ci' has transfer information */\n      ci->u2.transferinfo.ftransfer = ftransfer;\n      ci->u2.transferinfo.ntransfer = ntransfer;\n    }\n    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n    if (L->top + LUA_MINSTACK > ci->top)\n      ci->top = L->top + LUA_MINSTACK;\n    L->allowhook = 0;  /* cannot call hooks inside a hook */\n    ci->callstatus |= mask;\n    lua_unlock(L);\n    (*hook)(L, &ar);\n    lua_lock(L);\n    lua_assert(!L->allowhook);\n    L->allowhook = 1;\n    ci->top = restorestack(L, ci_top);\n    L->top = restorestack(L, top);\n    ci->callstatus &= ~mask;\n  }\n}\n\n\n/*\n** Executes a call hook for Lua functions. This function is called\n** whenever 'hookmask' is not zero, so it checks whether call hooks are\n** active.\n*/\nvoid luaD_hookcall (lua_State *L, CallInfo *ci) {\n  int hook = (ci->callstatus & CIST_TAIL) ? LUA_HOOKTAILCALL : LUA_HOOKCALL;\n  Proto *p;\n  if (!(L->hookmask & LUA_MASKCALL))  /* some other hook? */\n    return;  /* don't call hook */\n  p = clLvalue(s2v(ci->func))->p;\n  L->top = ci->top;  /* prepare top */\n  ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */\n  luaD_hook(L, hook, -1, 1, p->numparams);\n  ci->u.l.savedpc--;  /* correct 'pc' */\n}\n\n\nstatic StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n  ptrdiff_t oldtop = savestack(L, L->top);  /* hook may change top */\n  int delta = 0;\n  if (isLuacode(ci)) {\n    Proto *p = clLvalue(s2v(ci->func))->p;\n    if (p->is_vararg)\n      delta = ci->u.l.nextraargs + p->numparams + 1;\n    if (L->top < ci->top)\n      L->top = ci->top;  /* correct top to run hook */\n  }\n  if (L->hookmask & LUA_MASKRET) {  /* is return hook on? */\n    int ftransfer;\n    ci->func += delta;  /* if vararg, back to virtual 'func' */\n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */\n    ci->func -= delta;\n  }\n  if (isLua(ci->previous))\n    L->oldpc = ci->previous->u.l.savedpc;  /* update 'oldpc' */\n  return restorestack(L, oldtop);\n}\n\n\n/*\n** Check whether 'func' has a '__call' metafield. If so, put it in the\n** stack, below original 'func', so that 'luaD_call' can call it. Raise\n** an error if there is no '__call' metafield.\n*/\nvoid luaD_tryfuncTM (lua_State *L, StkId func) {\n  const TValue *tm = luaT_gettmbyobj(L, s2v(func), TM_CALL);\n  StkId p;\n  if (unlikely(ttisnil(tm)))\n    luaG_typeerror(L, s2v(func), \"call\");  /* nothing to call */\n  for (p = L->top; p > func; p--)  /* open space for metamethod */\n    setobjs2s(L, p, p-1);\n  L->top++;  /* stack space pre-allocated by the caller */\n  setobj2s(L, func, tm);  /* metamethod is the new function to be called */\n}\n\n\n/*\n** Given 'nres' results at 'firstResult', move 'wanted' of them to 'res'.\n** Handle most typical cases (zero results for commands, one result for\n** expressions, multiple results for tail calls/single parameters)\n** separated.\n*/\nstatic void moveresults (lua_State *L, StkId res, int nres, int wanted) {\n  StkId firstresult;\n  int i;\n  switch (wanted) {  /* handle typical cases separately */\n    case 0:  /* no values needed */\n      L->top = res;\n      return;\n    case 1:  /* one value needed */\n      if (nres == 0)   /* no results? */\n        setnilvalue(s2v(res));  /* adjust with nil */\n      else\n        setobjs2s(L, res, L->top - nres);  /* move it to proper place */\n      L->top = res + 1;\n      return;\n    case LUA_MULTRET:\n      wanted = nres;  /* we want all results */\n      break;\n    default:  /* multiple results (or to-be-closed variables) */\n      if (hastocloseCfunc(wanted)) {  /* to-be-closed variables? */\n        ptrdiff_t savedres = savestack(L, res);\n        luaF_close(L, res, LUA_OK);  /* may change the stack */\n        res = restorestack(L, savedres);\n        wanted = codeNresults(wanted);  /* correct value */\n        if (wanted == LUA_MULTRET)\n          wanted = nres;\n      }\n      break;\n  }\n  firstresult = L->top - nres;  /* index of first result */\n  /* move all results to correct place */\n  for (i = 0; i < nres && i < wanted; i++)\n    setobjs2s(L, res + i, firstresult + i);\n  for (; i < wanted; i++)  /* complete wanted number of results */\n    setnilvalue(s2v(res + i));\n  L->top = res + wanted;  /* top points after the last result */\n}\n\n\n/*\n** Finishes a function call: calls hook if necessary, removes CallInfo,\n** moves current number of results to proper place.\n*/\nvoid luaD_poscall (lua_State *L, CallInfo *ci, int nres) {\n  if (L->hookmask)\n    L->top = rethook(L, ci, L->top - nres, nres);\n  L->ci = ci->previous;  /* back to caller */\n  /* move results to proper place */\n  moveresults(L, ci->func, nres, ci->nresults);\n}\n\n\n\n#define next_ci(L)  (L->ci->next ? L->ci->next : luaE_extendCI(L))\n\n\n/*\n** Prepare a function for a tail call, building its call info on top\n** of the current call info. 'narg1' is the number of arguments plus 1\n** (so that it includes the function itself).\n*/\nvoid luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func, int narg1) {\n  Proto *p = clLvalue(s2v(func))->p;\n  int fsize = p->maxstacksize;  /* frame size */\n  int nfixparams = p->numparams;\n  int i;\n  for (i = 0; i < narg1; i++)  /* move down function and arguments */\n    setobjs2s(L, ci->func + i, func + i);\n  checkstackGC(L, fsize);\n  func = ci->func;  /* moved-down function */\n  for (; narg1 <= nfixparams; narg1++)\n    setnilvalue(s2v(func + narg1));  /* complete missing arguments */\n  ci->top = func + 1 + fsize;  /* top for new function */\n  lua_assert(ci->top <= L->stack_last);\n  ci->u.l.savedpc = p->code;  /* starting point */\n  ci->callstatus |= CIST_TAIL;\n  L->top = func + narg1;  /* set top */\n}\n\n\n/*\n** Call a function (C or Lua). The function to be called is at *func.\n** The arguments are on the stack, right after the function.\n** When returns, all the results are on the stack, starting at the original\n** function position.\n*/\nvoid luaD_call (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  /* light C function */\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  /* number of returns */\n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  /* do the actual call */\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  /* complete missing arguments */\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  /* run the function */\n      break;\n    }\n    default: {  /* not a function */\n      checkstackp(L, 1, func);  /* space for metamethod */\n      luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}\n\n\n/*\n** Similar to 'luaD_call', but does not allow yields during the call.\n** If there is a stack overflow, freeing all CI structures will\n** force the subsequent call to invoke 'luaE_extendCI', which then\n** will raise any errors.\n*/\nvoid luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  /* possible stack overflow? */\n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}\n\n\n/*\n** Completes the execution of an interrupted C function, calling its\n** continuation function.\n*/\nstatic void finishCcall (lua_State *L, int status) {\n  CallInfo *ci = L->ci;\n  int n;\n  /* must have a continuation and must be able to call it */\n  lua_assert(ci->u.c.k != NULL && yieldable(L));\n  /* error status can only happen in a protected call */\n  lua_assert((ci->callstatus & CIST_YPCALL) || status == LUA_YIELD);\n  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */\n    ci->callstatus &= ~CIST_YPCALL;  /* continuation is also inside it */\n    L->errfunc = ci->u.c.old_errfunc;  /* with the same error function */\n  }\n  /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already\n     handled */\n  adjustresults(L, ci->nresults);\n  lua_unlock(L);\n  n = (*ci->u.c.k)(L, status, ci->u.c.ctx);  /* call continuation function */\n  lua_lock(L);\n  api_checknelems(L, n);\n  luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n}\n\n\n/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop). If the coroutine is\n** recovering from an error, 'ud' points to the error status, which must\n** be passed to the first continuation function (otherwise the default\n** status is LUA_YIELD).\n*/\nstatic void unroll (lua_State *L, void *ud) {\n  CallInfo *ci;\n  if (ud != NULL)  /* error status? */\n    finishCcall(L, *(int *)ud);  /* finish 'lua_pcallk' callee */\n  while ((ci = L->ci) != &L->base_ci) {  /* something in the stack */\n    if (!isLua(ci))  /* C function? */\n      finishCcall(L, LUA_YIELD);  /* complete its execution */\n    else {  /* Lua function */\n      luaV_finishOp(L);  /* finish interrupted instruction */\n      luaV_execute(L, ci);  /* execute down to higher C 'boundary' */\n    }\n  }\n}\n\n\n/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\nstatic CallInfo *findpcall (lua_State *L) {\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */\n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;  /* no pending pcall */\n}\n\n\n/*\n** Recovers from an error in a coroutine. Finds a recover point (if\n** there is one) and completes the execution of the interrupted\n** 'luaD_pcall'. If there is no recover point, returns zero.\n*/\nstatic int recover (lua_State *L, int status) {\n  StkId oldtop;\n  CallInfo *ci = findpcall(L);\n  if (ci == NULL) return 0;  /* no recovery point */\n  /* \"finish\" luaD_pcall */\n  oldtop = restorestack(L, ci->u2.funcidx);\n  luaF_close(L, oldtop, status);  /* may change the stack */\n  oldtop = restorestack(L, ci->u2.funcidx);\n  luaD_seterrorobj(L, status, oldtop);\n  L->ci = ci;\n  L->allowhook = getoah(ci->callstatus);  /* restore original 'allowhook' */\n  luaD_shrinkstack(L);\n  L->errfunc = ci->u.c.old_errfunc;\n  return 1;  /* continue running the coroutine */\n}\n\n\n/*\n** Signal an error in the call to 'lua_resume', not in the execution\n** of the coroutine itself. (Such errors should not be handled by any\n** coroutine error handler and should not kill the coroutine.)\n*/\nstatic int resume_error (lua_State *L, const char *msg, int narg) {\n  L->top -= narg;  /* remove args from the stack */\n  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */\n  api_incr_top(L);\n  lua_unlock(L);\n  return LUA_ERRRUN;\n}\n\n\n/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\nstatic void resume (lua_State *L, void *ud) {\n  int n = *(cast(int*, ud));  /* number of arguments */\n  StkId firstArg = L->top - n;  /* first argument */\n  CallInfo *ci = L->ci;\n  if (L->status == LUA_OK) {  /* starting a coroutine? */\n    luaD_call(L, firstArg - 1, LUA_MULTRET);\n  }\n  else {  /* resuming from previous yield */\n    lua_assert(L->status == LUA_YIELD);\n    L->status = LUA_OK;  /* mark that it is running (again) */\n    if (isLua(ci))  /* yielded inside a hook? */\n      luaV_execute(L, ci);  /* just continue running Lua code */\n    else {  /* 'common' yield */\n      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */\n        lua_lock(L);\n        api_checknelems(L, n);\n      }\n      luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n    }\n    unroll(L, NULL);  /* run continuation */\n  }\n}\n\nLUA_API int lua_resume (lua_State *L, lua_State *from, int nargs,\n                                      int *nresults) {\n  int status;\n  lua_lock(L);\n  if (L->status == LUA_OK) {  /* may be starting a coroutine */\n    if (L->ci != &L->base_ci)  /* not in base level? */\n      return resume_error(L, \"cannot resume non-suspended coroutine\", nargs);\n    else if (L->top - (L->ci->func + 1) == nargs)  /* no function? */\n      return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  }\n  else if (L->status != LUA_YIELD)  /* ended with errors? */\n    return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  if (from == NULL)\n    L->nCcalls = CSTACKTHREAD;\n  else  /* correct 'nCcalls' for this thread */\n    L->nCcalls = getCcalls(from) + from->nci - L->nci - CSTACKCF;\n  if (L->nCcalls <= CSTACKERR)\n    return resume_error(L, \"C stack overflow\", nargs);\n  luai_userstateresume(L, nargs);\n  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume, &nargs);\n   /* continue running after recoverable errors */\n  while (errorstatus(status) && recover(L, status)) {\n    /* unroll continuation */\n    status = luaD_rawrunprotected(L, unroll, &status);\n  }\n  if (likely(!errorstatus(status)))\n    lua_assert(status == L->status);  /* normal end or yield */\n  else {  /* unrecoverable error */\n    L->status = cast_byte(status);  /* mark thread as 'dead' */\n    luaD_seterrorobj(L, status, L->top);  /* push error message */\n    L->ci->top = L->top;\n  }\n  *nresults = (status == LUA_YIELD) ? L->ci->u2.nyield\n                                    : cast_int(L->top - (L->ci->func + 1));\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_isyieldable (lua_State *L) {\n  return yieldable(L);\n}\n\n\nLUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,\n                        lua_KFunction k) {\n  CallInfo *ci = L->ci;\n  luai_userstateyield(L, nresults);\n  lua_lock(L);\n  api_checknelems(L, nresults);\n  if (unlikely(!yieldable(L))) {\n    if (L != G(L)->mainthread)\n      luaG_runerror(L, \"attempt to yield across a C-call boundary\");\n    else\n      luaG_runerror(L, \"attempt to yield from outside a coroutine\");\n  }\n  L->status = LUA_YIELD;\n  if (isLua(ci)) {  /* inside a hook? */\n    lua_assert(!isLuacode(ci));\n    api_check(L, k == NULL, \"hooks cannot continue after yielding\");\n    ci->u2.nyield = 0;  /* no results */\n  }\n  else {\n    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */\n      ci->u.c.ctx = ctx;  /* save context */\n    ci->u2.nyield = nresults;  /* save number of results */\n    luaD_throw(L, LUA_YIELD);\n  }\n  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */\n  lua_unlock(L);\n  return 0;  /* return to 'luaD_hook' */\n}\n\n\n/*\n** Call the C function 'func' in protected mode, restoring basic\n** thread information ('allowhook', etc.) and in particular\n** its stack level in case of errors.\n*/\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (unlikely(status != LUA_OK)) {  /* an error occurred? */\n    StkId oldtop = restorestack(L, old_top);\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    status = luaF_close(L, oldtop, status);\n    oldtop = restorestack(L, old_top);  /* previous call may change stack */\n    luaD_seterrorobj(L, status, oldtop);\n    luaD_shrinkstack(L);\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\n\n\n/*\n** Execute a protected parser.\n*/\nstruct SParser {  /* data to 'f_parser' */\n  ZIO *z;\n  Mbuffer buff;  /* dynamic structure used by the scanner */\n  Dyndata dyd;  /* dynamic structures used by the parser */\n  const char *mode;\n  const char *name;\n};\n\n\nstatic void checkmode (lua_State *L, const char *mode, const char *x) {\n  if (mode && strchr(mode, x[0]) == NULL) {\n    luaO_pushfstring(L,\n       \"attempt to load a %s chunk (mode is '%s')\", x, mode);\n    luaD_throw(L, LUA_ERRSYNTAX);\n  }\n}\n\n\nstatic void f_parser (lua_State *L, void *ud) {\n  LClosure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = zgetc(p->z);  /* read first character */\n  if (c == LUA_SIGNATURE[0]) {\n    checkmode(L, p->mode, \"binary\");\n    cl = luaU_undump(L, p->z, p->name);\n  }\n  else {\n    checkmode(L, p->mode, \"text\");\n    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);\n  }\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luaF_initupvals(L, cl);\n}\n\n\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                        const char *mode) {\n  struct SParser p;\n  int status;\n  incnny(L);  /* cannot yield during parsing */\n  p.z = z; p.name = name; p.mode = mode;\n  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;\n  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;\n  p.dyd.label.arr = NULL; p.dyd.label.size = 0;\n  luaZ_initbuffer(L, &p.buff);\n  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);\n  luaZ_freebuffer(L, &p.buff);\n  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);\n  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);\n  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);\n  decnny(L);\n  return status;\n}\n\n\n"], "fixing_code": ["/*\n** $Id: ldo.c $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n#define ldo_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n#include \"lzio.h\"\n\n\n\n#define errorstatus(s)\t((s) > LUA_YIELD)\n\n\n/*\n** {======================================================\n** Error-recovery functions\n** =======================================================\n*/\n\n/*\n** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By\n** default, Lua handles errors with exceptions when compiling as\n** C++ code, with _longjmp/_setjmp when asked to use them, and with\n** longjmp/setjmp otherwise.\n*/\n#if !defined(LUAI_THROW)\t\t\t\t/* { */\n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)\t/* { */\n\n/* C++ exceptions */\n#define LUAI_THROW(L,c)\t\tthrow(c)\n#define LUAI_TRY(L,c,a) \\\n\ttry { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\t\tint  /* dummy variable */\n\n#elif defined(LUA_USE_POSIX)\t\t\t\t/* }{ */\n\n/* in POSIX, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)\t\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#else\t\t\t\t\t\t\t/* }{ */\n\n/* ISO C handling with long jumps */\n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#endif\t\t\t\t\t\t\t/* } */\n\n#endif\t\t\t\t\t\t\t/* } */\n\n\n\n/* chain list of long jump buffers */\nstruct lua_longjmp {\n  struct lua_longjmp *previous;\n  luai_jmpbuf b;\n  volatile int status;  /* error code */\n};\n\n\nvoid luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {\n  switch (errcode) {\n    case LUA_ERRMEM: {  /* memory error? */\n      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */\n      break;\n    }\n    case LUA_ERRERR: {\n      setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n      break;\n    }\n    case CLOSEPROTECT: {\n      setnilvalue(s2v(oldtop));  /* no error message */\n      break;\n    }\n    default: {\n      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */\n      break;\n    }\n  }\n  L->top = oldtop + 1;\n}\n\n\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {  /* thread has an error handler? */\n    L->errorJmp->status = errcode;  /* set status */\n    LUAI_THROW(L, L->errorJmp);  /* jump to it */\n  }\n  else {  /* thread has no error handler */\n    global_State *g = G(L);\n    errcode = luaF_close(L, L->stack, errcode);  /* close all upvalues */\n    L->status = cast_byte(errcode);  /* mark it as dead */\n    if (g->mainthread->errorJmp) {  /* main thread has a handler? */\n      setobjs2s(L, g->mainthread->top++, L->top - 1);  /* copy error obj. */\n      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */\n    }\n    else {  /* no handler at all; abort */\n      if (g->panic) {  /* panic function? */\n        luaD_seterrorobj(L, errcode, L->top);  /* assume EXTRA_STACK */\n        if (L->ci->top < L->top)\n          L->ci->top = L->top;  /* pushing msg. can break this invariant */\n        lua_unlock(L);\n        g->panic(L);  /* call panic function (last chance to jump out) */\n      }\n      abort();\n    }\n  }\n}\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  global_State *g = G(L);\n  l_uint32 oldnCcalls = g->Cstacklimit - (L->nCcalls + L->nci);\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = g->Cstacklimit - oldnCcalls - L->nci;\n  return lj.status;\n}\n\n/* }====================================================== */\n\n\n/*\n** {==================================================================\n** Stack reallocation\n** ===================================================================\n*/\nstatic void correctstack (lua_State *L, StkId oldstack, StkId newstack) {\n  CallInfo *ci;\n  UpVal *up;\n  if (oldstack == newstack)\n    return;  /* stack address did not change */\n  L->top = (L->top - oldstack) + newstack;\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v = s2v((uplevel(up) - oldstack) + newstack);\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top = (ci->top - oldstack) + newstack;\n    ci->func = (ci->func - oldstack) + newstack;\n    if (isLua(ci))\n      ci->u.l.trap = 1;  /* signal to update 'trap' in 'luaV_execute' */\n  }\n}\n\n\n/* some space for error handling */\n#define ERRORSTACKSIZE\t(LUAI_MAXSTACK + 200)\n\n\nint luaD_reallocstack (lua_State *L, int newsize, int raiseerror) {\n  int lim = L->stacksize;\n  StkId newstack = luaM_reallocvector(L, L->stack, lim, newsize, StackValue);\n  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);\n  if (unlikely(newstack == NULL)) {  /* reallocation failed? */\n    if (raiseerror)\n      luaM_error(L);\n    else return 0;  /* do not raise an error */\n  }\n  for (; lim < newsize; lim++)\n    setnilvalue(s2v(newstack + lim)); /* erase new segment */\n  correctstack(L, L->stack, newstack);\n  L->stack = newstack;\n  L->stacksize = newsize;\n  L->stack_last = L->stack + newsize - EXTRA_STACK;\n  return 1;\n}\n\n\n/*\n** Try to grow the stack by at least 'n' elements. when 'raiseerror'\n** is true, raises any error; otherwise, return 0 in case of errors.\n*/\nint luaD_growstack (lua_State *L, int n, int raiseerror) {\n  int size = L->stacksize;\n  int newsize = 2 * size;  /* tentative new size */\n  if (unlikely(size > LUAI_MAXSTACK)) {  /* need more space after extra size? */\n    if (raiseerror)\n      luaD_throw(L, LUA_ERRERR);  /* error inside message handler */\n    else return 0;\n  }\n  else {\n    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;\n    if (newsize > LUAI_MAXSTACK)  /* cannot cross the limit */\n      newsize = LUAI_MAXSTACK;\n    if (newsize < needed)  /* but must respect what was asked for */\n      newsize = needed;\n    if (unlikely(newsize > LUAI_MAXSTACK)) {  /* stack overflow? */\n      /* add extra size to be able to handle the error message */\n      luaD_reallocstack(L, ERRORSTACKSIZE, raiseerror);\n      if (raiseerror)\n        luaG_runerror(L, \"stack overflow\");\n      else return 0;\n    }\n  }  /* else no errors */\n  return luaD_reallocstack(L, newsize, raiseerror);\n}\n\n\nstatic int stackinuse (lua_State *L) {\n  CallInfo *ci;\n  StkId lim = L->top;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    if (lim < ci->top) lim = ci->top;\n  }\n  lua_assert(lim <= L->stack_last);\n  return cast_int(lim - L->stack) + 1;  /* part of stack in use */\n}\n\n\nvoid luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + BASIC_STACK_SIZE;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}\n\n\nvoid luaD_inctop (lua_State *L) {\n  luaD_checkstack(L, 1);\n  L->top++;\n}\n\n/* }================================================================== */\n\n\n/*\n** Call a hook for the given event. Make sure there is a hook to be\n** called. (Both 'L->hook' and 'L->hookmask', which trigger this\n** function, can be changed asynchronously by signals.)\n*/\nvoid luaD_hook (lua_State *L, int event, int line,\n                              int ftransfer, int ntransfer) {\n  lua_Hook hook = L->hook;\n  if (hook && L->allowhook) {  /* make sure there is a hook */\n    int mask = CIST_HOOKED;\n    CallInfo *ci = L->ci;\n    ptrdiff_t top = savestack(L, L->top);\n    ptrdiff_t ci_top = savestack(L, ci->top);\n    lua_Debug ar;\n    ar.event = event;\n    ar.currentline = line;\n    ar.i_ci = ci;\n    if (ntransfer != 0) {\n      mask |= CIST_TRAN;  /* 'ci' has transfer information */\n      ci->u2.transferinfo.ftransfer = ftransfer;\n      ci->u2.transferinfo.ntransfer = ntransfer;\n    }\n    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n    if (L->top + LUA_MINSTACK > ci->top)\n      ci->top = L->top + LUA_MINSTACK;\n    L->allowhook = 0;  /* cannot call hooks inside a hook */\n    ci->callstatus |= mask;\n    lua_unlock(L);\n    (*hook)(L, &ar);\n    lua_lock(L);\n    lua_assert(!L->allowhook);\n    L->allowhook = 1;\n    ci->top = restorestack(L, ci_top);\n    L->top = restorestack(L, top);\n    ci->callstatus &= ~mask;\n  }\n}\n\n\n/*\n** Executes a call hook for Lua functions. This function is called\n** whenever 'hookmask' is not zero, so it checks whether call hooks are\n** active.\n*/\nvoid luaD_hookcall (lua_State *L, CallInfo *ci) {\n  int hook = (ci->callstatus & CIST_TAIL) ? LUA_HOOKTAILCALL : LUA_HOOKCALL;\n  Proto *p;\n  if (!(L->hookmask & LUA_MASKCALL))  /* some other hook? */\n    return;  /* don't call hook */\n  p = clLvalue(s2v(ci->func))->p;\n  L->top = ci->top;  /* prepare top */\n  ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */\n  luaD_hook(L, hook, -1, 1, p->numparams);\n  ci->u.l.savedpc--;  /* correct 'pc' */\n}\n\n\nstatic StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n  ptrdiff_t oldtop = savestack(L, L->top);  /* hook may change top */\n  int delta = 0;\n  if (isLuacode(ci)) {\n    Proto *p = clLvalue(s2v(ci->func))->p;\n    if (p->is_vararg)\n      delta = ci->u.l.nextraargs + p->numparams + 1;\n    if (L->top < ci->top)\n      L->top = ci->top;  /* correct top to run hook */\n  }\n  if (L->hookmask & LUA_MASKRET) {  /* is return hook on? */\n    int ftransfer;\n    ci->func += delta;  /* if vararg, back to virtual 'func' */\n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */\n    ci->func -= delta;\n  }\n  if (isLua(ci->previous))\n    L->oldpc = ci->previous->u.l.savedpc;  /* update 'oldpc' */\n  return restorestack(L, oldtop);\n}\n\n\n/*\n** Check whether 'func' has a '__call' metafield. If so, put it in the\n** stack, below original 'func', so that 'luaD_call' can call it. Raise\n** an error if there is no '__call' metafield.\n*/\nvoid luaD_tryfuncTM (lua_State *L, StkId func) {\n  const TValue *tm = luaT_gettmbyobj(L, s2v(func), TM_CALL);\n  StkId p;\n  if (unlikely(ttisnil(tm)))\n    luaG_typeerror(L, s2v(func), \"call\");  /* nothing to call */\n  for (p = L->top; p > func; p--)  /* open space for metamethod */\n    setobjs2s(L, p, p-1);\n  L->top++;  /* stack space pre-allocated by the caller */\n  setobj2s(L, func, tm);  /* metamethod is the new function to be called */\n}\n\n\n/*\n** Given 'nres' results at 'firstResult', move 'wanted' of them to 'res'.\n** Handle most typical cases (zero results for commands, one result for\n** expressions, multiple results for tail calls/single parameters)\n** separated.\n*/\nstatic void moveresults (lua_State *L, StkId res, int nres, int wanted) {\n  StkId firstresult;\n  int i;\n  switch (wanted) {  /* handle typical cases separately */\n    case 0:  /* no values needed */\n      L->top = res;\n      return;\n    case 1:  /* one value needed */\n      if (nres == 0)   /* no results? */\n        setnilvalue(s2v(res));  /* adjust with nil */\n      else\n        setobjs2s(L, res, L->top - nres);  /* move it to proper place */\n      L->top = res + 1;\n      return;\n    case LUA_MULTRET:\n      wanted = nres;  /* we want all results */\n      break;\n    default:  /* multiple results (or to-be-closed variables) */\n      if (hastocloseCfunc(wanted)) {  /* to-be-closed variables? */\n        ptrdiff_t savedres = savestack(L, res);\n        luaF_close(L, res, LUA_OK);  /* may change the stack */\n        res = restorestack(L, savedres);\n        wanted = codeNresults(wanted);  /* correct value */\n        if (wanted == LUA_MULTRET)\n          wanted = nres;\n      }\n      break;\n  }\n  firstresult = L->top - nres;  /* index of first result */\n  /* move all results to correct place */\n  for (i = 0; i < nres && i < wanted; i++)\n    setobjs2s(L, res + i, firstresult + i);\n  for (; i < wanted; i++)  /* complete wanted number of results */\n    setnilvalue(s2v(res + i));\n  L->top = res + wanted;  /* top points after the last result */\n}\n\n\n/*\n** Finishes a function call: calls hook if necessary, removes CallInfo,\n** moves current number of results to proper place.\n*/\nvoid luaD_poscall (lua_State *L, CallInfo *ci, int nres) {\n  if (L->hookmask)\n    L->top = rethook(L, ci, L->top - nres, nres);\n  L->ci = ci->previous;  /* back to caller */\n  /* move results to proper place */\n  moveresults(L, ci->func, nres, ci->nresults);\n}\n\n\n\n#define next_ci(L)  (L->ci->next ? L->ci->next : luaE_extendCI(L))\n\n\n/*\n** Prepare a function for a tail call, building its call info on top\n** of the current call info. 'narg1' is the number of arguments plus 1\n** (so that it includes the function itself).\n*/\nvoid luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func, int narg1) {\n  Proto *p = clLvalue(s2v(func))->p;\n  int fsize = p->maxstacksize;  /* frame size */\n  int nfixparams = p->numparams;\n  int i;\n  for (i = 0; i < narg1; i++)  /* move down function and arguments */\n    setobjs2s(L, ci->func + i, func + i);\n  checkstackGC(L, fsize);\n  func = ci->func;  /* moved-down function */\n  for (; narg1 <= nfixparams; narg1++)\n    setnilvalue(s2v(func + narg1));  /* complete missing arguments */\n  ci->top = func + 1 + fsize;  /* top for new function */\n  lua_assert(ci->top <= L->stack_last);\n  ci->u.l.savedpc = p->code;  /* starting point */\n  ci->callstatus |= CIST_TAIL;\n  L->top = func + narg1;  /* set top */\n}\n\n\n/*\n** Call a function (C or Lua). The function to be called is at *func.\n** The arguments are on the stack, right after the function.\n** When returns, all the results are on the stack, starting at the original\n** function position.\n*/\nvoid luaD_call (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  /* light C function */\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  /* number of returns */\n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  /* do the actual call */\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  /* complete missing arguments */\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  /* run the function */\n      break;\n    }\n    default: {  /* not a function */\n      checkstackp(L, 1, func);  /* space for metamethod */\n      luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}\n\n\n/*\n** Similar to 'luaD_call', but does not allow yields during the call.\n** If there is a stack overflow, freeing all CI structures will\n** force the subsequent call to invoke 'luaE_extendCI', which then\n** will raise any errors.\n*/\nvoid luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  /* possible stack overflow? */\n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}\n\n\n/*\n** Completes the execution of an interrupted C function, calling its\n** continuation function.\n*/\nstatic void finishCcall (lua_State *L, int status) {\n  CallInfo *ci = L->ci;\n  int n;\n  /* must have a continuation and must be able to call it */\n  lua_assert(ci->u.c.k != NULL && yieldable(L));\n  /* error status can only happen in a protected call */\n  lua_assert((ci->callstatus & CIST_YPCALL) || status == LUA_YIELD);\n  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */\n    ci->callstatus &= ~CIST_YPCALL;  /* continuation is also inside it */\n    L->errfunc = ci->u.c.old_errfunc;  /* with the same error function */\n  }\n  /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already\n     handled */\n  adjustresults(L, ci->nresults);\n  lua_unlock(L);\n  n = (*ci->u.c.k)(L, status, ci->u.c.ctx);  /* call continuation function */\n  lua_lock(L);\n  api_checknelems(L, n);\n  luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n}\n\n\n/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop). If the coroutine is\n** recovering from an error, 'ud' points to the error status, which must\n** be passed to the first continuation function (otherwise the default\n** status is LUA_YIELD).\n*/\nstatic void unroll (lua_State *L, void *ud) {\n  CallInfo *ci;\n  if (ud != NULL)  /* error status? */\n    finishCcall(L, *(int *)ud);  /* finish 'lua_pcallk' callee */\n  while ((ci = L->ci) != &L->base_ci) {  /* something in the stack */\n    if (!isLua(ci))  /* C function? */\n      finishCcall(L, LUA_YIELD);  /* complete its execution */\n    else {  /* Lua function */\n      luaV_finishOp(L);  /* finish interrupted instruction */\n      luaV_execute(L, ci);  /* execute down to higher C 'boundary' */\n    }\n  }\n}\n\n\n/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\nstatic CallInfo *findpcall (lua_State *L) {\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */\n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;  /* no pending pcall */\n}\n\n\n/*\n** Recovers from an error in a coroutine. Finds a recover point (if\n** there is one) and completes the execution of the interrupted\n** 'luaD_pcall'. If there is no recover point, returns zero.\n*/\nstatic int recover (lua_State *L, int status) {\n  StkId oldtop;\n  CallInfo *ci = findpcall(L);\n  if (ci == NULL) return 0;  /* no recovery point */\n  /* \"finish\" luaD_pcall */\n  oldtop = restorestack(L, ci->u2.funcidx);\n  luaF_close(L, oldtop, status);  /* may change the stack */\n  oldtop = restorestack(L, ci->u2.funcidx);\n  luaD_seterrorobj(L, status, oldtop);\n  L->ci = ci;\n  L->allowhook = getoah(ci->callstatus);  /* restore original 'allowhook' */\n  luaD_shrinkstack(L);\n  L->errfunc = ci->u.c.old_errfunc;\n  return 1;  /* continue running the coroutine */\n}\n\n\n/*\n** Signal an error in the call to 'lua_resume', not in the execution\n** of the coroutine itself. (Such errors should not be handled by any\n** coroutine error handler and should not kill the coroutine.)\n*/\nstatic int resume_error (lua_State *L, const char *msg, int narg) {\n  L->top -= narg;  /* remove args from the stack */\n  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */\n  api_incr_top(L);\n  lua_unlock(L);\n  return LUA_ERRRUN;\n}\n\n\n/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\nstatic void resume (lua_State *L, void *ud) {\n  int n = *(cast(int*, ud));  /* number of arguments */\n  StkId firstArg = L->top - n;  /* first argument */\n  CallInfo *ci = L->ci;\n  if (L->status == LUA_OK) {  /* starting a coroutine? */\n    luaD_call(L, firstArg - 1, LUA_MULTRET);\n  }\n  else {  /* resuming from previous yield */\n    lua_assert(L->status == LUA_YIELD);\n    L->status = LUA_OK;  /* mark that it is running (again) */\n    if (isLua(ci))  /* yielded inside a hook? */\n      luaV_execute(L, ci);  /* just continue running Lua code */\n    else {  /* 'common' yield */\n      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */\n        lua_lock(L);\n        api_checknelems(L, n);\n      }\n      luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n    }\n    unroll(L, NULL);  /* run continuation */\n  }\n}\n\nLUA_API int lua_resume (lua_State *L, lua_State *from, int nargs,\n                                      int *nresults) {\n  int status;\n  lua_lock(L);\n  if (L->status == LUA_OK) {  /* may be starting a coroutine */\n    if (L->ci != &L->base_ci)  /* not in base level? */\n      return resume_error(L, \"cannot resume non-suspended coroutine\", nargs);\n    else if (L->top - (L->ci->func + 1) == nargs)  /* no function? */\n      return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  }\n  else if (L->status != LUA_YIELD)  /* ended with errors? */\n    return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  if (from == NULL)\n    L->nCcalls = CSTACKTHREAD;\n  else  /* correct 'nCcalls' for this thread */\n    L->nCcalls = getCcalls(from) + from->nci - L->nci - CSTACKCF;\n  if (L->nCcalls <= CSTACKERR)\n    return resume_error(L, \"C stack overflow\", nargs);\n  luai_userstateresume(L, nargs);\n  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume, &nargs);\n   /* continue running after recoverable errors */\n  while (errorstatus(status) && recover(L, status)) {\n    /* unroll continuation */\n    status = luaD_rawrunprotected(L, unroll, &status);\n  }\n  if (likely(!errorstatus(status)))\n    lua_assert(status == L->status);  /* normal end or yield */\n  else {  /* unrecoverable error */\n    L->status = cast_byte(status);  /* mark thread as 'dead' */\n    luaD_seterrorobj(L, status, L->top);  /* push error message */\n    L->ci->top = L->top;\n  }\n  *nresults = (status == LUA_YIELD) ? L->ci->u2.nyield\n                                    : cast_int(L->top - (L->ci->func + 1));\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_isyieldable (lua_State *L) {\n  return yieldable(L);\n}\n\n\nLUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,\n                        lua_KFunction k) {\n  CallInfo *ci = L->ci;\n  luai_userstateyield(L, nresults);\n  lua_lock(L);\n  api_checknelems(L, nresults);\n  if (unlikely(!yieldable(L))) {\n    if (L != G(L)->mainthread)\n      luaG_runerror(L, \"attempt to yield across a C-call boundary\");\n    else\n      luaG_runerror(L, \"attempt to yield from outside a coroutine\");\n  }\n  L->status = LUA_YIELD;\n  if (isLua(ci)) {  /* inside a hook? */\n    lua_assert(!isLuacode(ci));\n    api_check(L, k == NULL, \"hooks cannot continue after yielding\");\n    ci->u2.nyield = 0;  /* no results */\n  }\n  else {\n    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */\n      ci->u.c.ctx = ctx;  /* save context */\n    ci->u2.nyield = nresults;  /* save number of results */\n    luaD_throw(L, LUA_YIELD);\n  }\n  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */\n  lua_unlock(L);\n  return 0;  /* return to 'luaD_hook' */\n}\n\n\n/*\n** Call the C function 'func' in protected mode, restoring basic\n** thread information ('allowhook', etc.) and in particular\n** its stack level in case of errors.\n*/\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (unlikely(status != LUA_OK)) {  /* an error occurred? */\n    StkId oldtop = restorestack(L, old_top);\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    status = luaF_close(L, oldtop, status);\n    oldtop = restorestack(L, old_top);  /* previous call may change stack */\n    luaD_seterrorobj(L, status, oldtop);\n    luaD_shrinkstack(L);\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\n\n\n/*\n** Execute a protected parser.\n*/\nstruct SParser {  /* data to 'f_parser' */\n  ZIO *z;\n  Mbuffer buff;  /* dynamic structure used by the scanner */\n  Dyndata dyd;  /* dynamic structures used by the parser */\n  const char *mode;\n  const char *name;\n};\n\n\nstatic void checkmode (lua_State *L, const char *mode, const char *x) {\n  if (mode && strchr(mode, x[0]) == NULL) {\n    luaO_pushfstring(L,\n       \"attempt to load a %s chunk (mode is '%s')\", x, mode);\n    luaD_throw(L, LUA_ERRSYNTAX);\n  }\n}\n\n\nstatic void f_parser (lua_State *L, void *ud) {\n  LClosure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = zgetc(p->z);  /* read first character */\n  if (c == LUA_SIGNATURE[0]) {\n    checkmode(L, p->mode, \"binary\");\n    cl = luaU_undump(L, p->z, p->name);\n  }\n  else {\n    checkmode(L, p->mode, \"text\");\n    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);\n  }\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luaF_initupvals(L, cl);\n}\n\n\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                        const char *mode) {\n  struct SParser p;\n  int status;\n  incnny(L);  /* cannot yield during parsing */\n  p.z = z; p.name = name; p.mode = mode;\n  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;\n  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;\n  p.dyd.label.arr = NULL; p.dyd.label.size = 0;\n  luaZ_initbuffer(L, &p.buff);\n  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);\n  luaZ_freebuffer(L, &p.buff);\n  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);\n  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);\n  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);\n  decnny(L);\n  return status;\n}\n\n\n"], "filenames": ["ldo.c"], "buggy_code_start_loc": [248], "buggy_code_end_loc": [255], "fixing_code_start_loc": [248], "fixing_code_end_loc": [254], "type": "CWE-125", "message": "Lua through 5.4.0 mishandles the interaction between stack resizes and garbage collection, leading to a heap-based buffer overflow, heap-based buffer over-read, or use-after-free.", "other": {"cve": {"id": "CVE-2020-15888", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-21T22:15:12.090", "lastModified": "2023-05-16T22:31:05.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Lua through 5.4.0 mishandles the interaction between stack resizes and garbage collection, leading to a heap-based buffer overflow, heap-based buffer over-read, or use-after-free."}, {"lang": "es", "value": "Lua versiones hasta 5.4.0, maneja inapropiadamente la interacci\u00f3n entre el cambio de tama\u00f1o de la pila y la recolecci\u00f3n de basura, conllevando a un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria, a una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria o un uso de la memoria previamente liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-416"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lua:lua:5.4.0:-:*:*:*:*:*:*", "matchCriteriaId": "E9F78BF8-B73C-42C6-AF54-2CD935670053"}]}]}], "references": [{"url": "http://lua-users.org/lists/lua-l/2020-07/msg00053.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://lua-users.org/lists/lua-l/2020-07/msg00054.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://lua-users.org/lists/lua-l/2020-07/msg00071.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://lua-users.org/lists/lua-l/2020-07/msg00079.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/lua/lua/commit/6298903e35217ab69c279056f925fb72900ce0b7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lua/lua/commit/eb41999461b6f428186c55abd95f4ce1a76217d5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lua/lua/commit/6298903e35217ab69c279056f925fb72900ce0b7"}}