{"buggy_code": ["// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2022 Parity Technologies (UK) Ltd.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nuse std::sync::Arc;\n\nuse ethereum_types::{H256, U256};\nuse evm::{ExitError, ExitReason};\nuse jsonrpsee::core::RpcResult as Result;\n\nuse sc_client_api::backend::{Backend, StateBackend, StorageProvider};\nuse sc_network::ExHashT;\nuse sc_transaction_pool::ChainApi;\nuse sp_api::{ApiExt, ProvideRuntimeApi};\nuse sp_block_builder::BlockBuilder as BlockBuilderApi;\nuse sp_blockchain::{BlockStatus, HeaderBackend};\nuse sp_runtime::{\n\tgeneric::BlockId,\n\ttraits::{BlakeTwo256, Block as BlockT},\n};\n\nuse fc_rpc_core::types::*;\nuse fp_rpc::EthereumRuntimeRPCApi;\n\nuse crate::{\n\teth::{pending_runtime_api, Eth},\n\tfrontier_backend_client, internal_err,\n};\n\n/// Default JSONRPC error code return by geth\npub const JSON_RPC_ERROR_DEFAULT: i32 = -32000;\n\nimpl<B, C, P, CT, BE, H: ExHashT, A: ChainApi> Eth<B, C, P, CT, BE, H, A>\nwhere\n\tB: BlockT<Hash = H256> + Send + Sync + 'static,\n\tC: ProvideRuntimeApi<B> + StorageProvider<B, BE>,\n\tC: HeaderBackend<B> + Send + Sync + 'static,\n\tC::Api: BlockBuilderApi<B> + EthereumRuntimeRPCApi<B>,\n\tBE: Backend<B> + 'static,\n\tBE::State: StateBackend<BlakeTwo256>,\n\tA: ChainApi<Block = B> + 'static,\n{\n\tpub fn call(&self, request: CallRequest, number: Option<BlockNumber>) -> Result<Bytes> {\n\t\tlet CallRequest {\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tgas_price,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tgas,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\tnonce,\n\t\t\taccess_list,\n\t\t\t..\n\t\t} = request;\n\n\t\tlet (gas_price, max_fee_per_gas, max_priority_fee_per_gas) = {\n\t\t\tlet details = fee_details(gas_price, max_fee_per_gas, max_priority_fee_per_gas)?;\n\t\t\t(\n\t\t\t\tdetails.gas_price,\n\t\t\t\tdetails.max_fee_per_gas,\n\t\t\t\tdetails.max_priority_fee_per_gas,\n\t\t\t)\n\t\t};\n\n\t\tlet (id, api) = match frontier_backend_client::native_block_id::<B, C>(\n\t\t\tself.client.as_ref(),\n\t\t\tself.backend.as_ref(),\n\t\t\tnumber,\n\t\t)? {\n\t\t\tSome(id) => (id, self.client.runtime_api()),\n\t\t\tNone => {\n\t\t\t\t// Not mapped in the db, assume pending.\n\t\t\t\tlet id = BlockId::Hash(self.client.info().best_hash);\n\t\t\t\tlet api = pending_runtime_api(self.client.as_ref(), self.graph.as_ref())?;\n\t\t\t\t(id, api)\n\t\t\t}\n\t\t};\n\n\t\tif let Ok(BlockStatus::Unknown) = self.client.status(id) {\n\t\t\treturn Err(crate::err(JSON_RPC_ERROR_DEFAULT, \"header not found\", None));\n\t\t}\n\n\t\tlet api_version =\n\t\t\tif let Ok(Some(api_version)) = api.api_version::<dyn EthereumRuntimeRPCApi<B>>(&id) {\n\t\t\t\tapi_version\n\t\t\t} else {\n\t\t\t\treturn Err(internal_err(\"failed to retrieve Runtime Api version\"));\n\t\t\t};\n\n\t\tlet block = if api_version > 1 {\n\t\t\tapi.current_block(&id)\n\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t} else {\n\t\t\t#[allow(deprecated)]\n\t\t\tlet legacy_block = api\n\t\t\t\t.current_block_before_version_2(&id)\n\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\tlegacy_block.map(|block| block.into())\n\t\t};\n\n\t\tlet block_gas_limit = block\n\t\t\t.ok_or_else(|| internal_err(\"block unavailable, cannot query gas limit\"))?\n\t\t\t.header\n\t\t\t.gas_limit;\n\t\tlet max_gas_limit = block_gas_limit * self.execute_gas_limit_multiplier;\n\n\t\t// use given gas limit or query current block's limit\n\t\tlet gas_limit = match gas {\n\t\t\tSome(amount) => {\n\t\t\t\tif amount > max_gas_limit {\n\t\t\t\t\treturn Err(internal_err(format!(\n\t\t\t\t\t\t\"provided gas limit is too high (can be up to {}x the block gas limit)\",\n\t\t\t\t\t\tself.execute_gas_limit_multiplier\n\t\t\t\t\t)));\n\t\t\t\t}\n\t\t\t\tamount\n\t\t\t}\n\t\t\tNone => max_gas_limit,\n\t\t};\n\n\t\tlet data = data.map(|d| d.0).unwrap_or_default();\n\t\tmatch to {\n\t\t\tSome(to) => {\n\t\t\t\tif api_version == 1 {\n\t\t\t\t\t// Legacy pre-london\n\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\tlet info = api.call_before_version_2(\n\t\t\t\t\t\t&id,\n\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\tto,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\tnonce,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &info.value)?;\n\t\t\t\t\tOk(Bytes(info.value))\n\t\t\t\t} else if api_version >= 2 && api_version < 4 {\n\t\t\t\t\t// Post-london\n\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\tlet info = api.call_before_version_4(\n\t\t\t\t\t\t&id,\n\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\tto,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\tnonce,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &info.value)?;\n\t\t\t\t\tOk(Bytes(info.value))\n\t\t\t\t} else if api_version == 4 {\n\t\t\t\t\t// Post-london + access list support\n\t\t\t\t\tlet access_list = access_list.unwrap_or_default();\n\t\t\t\t\tlet info = api\n\t\t\t\t\t\t.call(\n\t\t\t\t\t\t\t&id,\n\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\tto,\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tSome(\n\t\t\t\t\t\t\t\taccess_list\n\t\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys))\n\t\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &info.value)?;\n\t\t\t\t\tOk(Bytes(info.value))\n\t\t\t\t} else {\n\t\t\t\t\tErr(internal_err(\"failed to retrieve Runtime Api version\"))\n\t\t\t\t}\n\t\t\t}\n\t\t\tNone => {\n\t\t\t\tif api_version == 1 {\n\t\t\t\t\t// Legacy pre-london\n\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\tlet info = api.create_before_version_2(\n\t\t\t\t\t\t&id,\n\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\tnonce,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &[])?;\n\n\t\t\t\t\tlet code = api\n\t\t\t\t\t\t.account_code_at(&id, info.value)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\t\t\tOk(Bytes(code))\n\t\t\t\t} else if api_version >= 2 && api_version < 4 {\n\t\t\t\t\t// Post-london\n\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\tlet info = api.create_before_version_4(\n\t\t\t\t\t\t&id,\n\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\tnonce,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &[])?;\n\n\t\t\t\t\tlet code = api\n\t\t\t\t\t\t.account_code_at(&id, info.value)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\t\t\tOk(Bytes(code))\n\t\t\t\t} else if api_version == 4 {\n\t\t\t\t\t// Post-london + access list support\n\t\t\t\t\tlet access_list = access_list.unwrap_or_default();\n\t\t\t\t\tlet info = api\n\t\t\t\t\t\t.create(\n\t\t\t\t\t\t\t&id,\n\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tSome(\n\t\t\t\t\t\t\t\taccess_list\n\t\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys))\n\t\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &[])?;\n\n\t\t\t\t\tlet code = api\n\t\t\t\t\t\t.account_code_at(&id, info.value)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\t\t\tOk(Bytes(code))\n\t\t\t\t} else {\n\t\t\t\t\tErr(internal_err(\"failed to retrieve Runtime Api version\"))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub async fn estimate_gas(&self, request: CallRequest, _: Option<BlockNumber>) -> Result<U256> {\n\t\tlet client = Arc::clone(&self.client);\n\t\tlet block_data_cache = Arc::clone(&self.block_data_cache);\n\n\t\t// Define the lower bound of estimate\n\t\tconst MIN_GAS_PER_TX: U256 = U256([21_000, 0, 0, 0]);\n\n\t\t// Get best hash (TODO missing support for estimating gas historically)\n\t\tlet best_hash = client.info().best_hash;\n\n\t\t// For simple transfer to simple account, return MIN_GAS_PER_TX directly\n\t\tlet is_simple_transfer = match &request.data {\n\t\t\tNone => true,\n\t\t\tSome(vec) => vec.0.is_empty(),\n\t\t};\n\t\tif is_simple_transfer {\n\t\t\tif let Some(to) = request.to {\n\t\t\t\tlet to_code = client\n\t\t\t\t\t.runtime_api()\n\t\t\t\t\t.account_code_at(&BlockId::Hash(best_hash), to)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\t\tif to_code.is_empty() {\n\t\t\t\t\treturn Ok(MIN_GAS_PER_TX);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet (gas_price, max_fee_per_gas, max_priority_fee_per_gas) = {\n\t\t\tlet details = fee_details(\n\t\t\t\trequest.gas_price,\n\t\t\t\trequest.max_fee_per_gas,\n\t\t\t\trequest.max_priority_fee_per_gas,\n\t\t\t)?;\n\t\t\t(\n\t\t\t\tdetails.gas_price,\n\t\t\t\tdetails.max_fee_per_gas,\n\t\t\t\tdetails.max_priority_fee_per_gas,\n\t\t\t)\n\t\t};\n\n\t\tlet block_gas_limit = {\n\t\t\tlet substrate_hash = client.info().best_hash;\n\t\t\tlet id = BlockId::Hash(substrate_hash);\n\t\t\tlet schema = frontier_backend_client::onchain_storage_schema::<B, C, BE>(&client, id);\n\t\t\tlet block = block_data_cache.current_block(schema, substrate_hash).await;\n\n\t\t\tblock\n\t\t\t\t.ok_or_else(|| internal_err(\"block unavailable, cannot query gas limit\"))?\n\t\t\t\t.header\n\t\t\t\t.gas_limit\n\t\t};\n\n\t\tlet max_gas_limit = block_gas_limit * self.execute_gas_limit_multiplier;\n\n\t\t// Determine the highest possible gas limits\n\t\tlet mut highest = match request.gas {\n\t\t\tSome(amount) => {\n\t\t\t\tif amount > max_gas_limit {\n\t\t\t\t\treturn Err(internal_err(format!(\n\t\t\t\t\t\t\"provided gas limit is too high (can be up to {}x the block gas limit)\",\n\t\t\t\t\t\tself.execute_gas_limit_multiplier\n\t\t\t\t\t)));\n\t\t\t\t}\n\t\t\t\tamount\n\t\t\t}\n\t\t\tNone => max_gas_limit,\n\t\t};\n\n\t\tlet api = client.runtime_api();\n\n\t\t// Recap the highest gas allowance with account's balance.\n\t\tif let Some(from) = request.from {\n\t\t\tlet gas_price = gas_price.unwrap_or_default();\n\t\t\tif gas_price > U256::zero() {\n\t\t\t\tlet balance = api\n\t\t\t\t\t.account_basic(&BlockId::Hash(best_hash), from)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.balance;\n\t\t\t\tlet mut available = balance;\n\t\t\t\tif let Some(value) = request.value {\n\t\t\t\t\tif value > available {\n\t\t\t\t\t\treturn Err(internal_err(\"insufficient funds for transfer\"));\n\t\t\t\t\t}\n\t\t\t\t\tavailable -= value;\n\t\t\t\t}\n\t\t\t\tlet allowance = available / gas_price;\n\t\t\t\tif highest > allowance {\n\t\t\t\t\tlog::warn!(\n\t\t\t\t\t\t\t\"Gas estimation capped by limited funds original {} balance {} sent {} feecap {} fundable {}\",\n\t\t\t\t\t\t\thighest,\n\t\t\t\t\t\t\tbalance,\n\t\t\t\t\t\t\trequest.value.unwrap_or_default(),\n\t\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\t\tallowance\n\t\t\t\t\t\t);\n\t\t\t\t\thighest = allowance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstruct ExecutableResult {\n\t\t\tdata: Vec<u8>,\n\t\t\texit_reason: ExitReason,\n\t\t\tused_gas: U256,\n\t\t}\n\n\t\t// Create a helper to check if a gas allowance results in an executable transaction.\n\t\t//\n\t\t// A new ApiRef instance needs to be used per execution to avoid the overlayed state to affect\n\t\t// the estimation result of subsequent calls.\n\t\t//\n\t\t// Note that this would have a performance penalty if we introduce gas estimation for past\n\t\t// blocks - and thus, past runtime versions. Substrate has a default `runtime_cache_size` of\n\t\t// 2 slots LRU-style, meaning if users were to access multiple runtime versions in a short period\n\t\t// of time, the RPC response time would degrade a lot, as the VersionedRuntime needs to be compiled.\n\t\t//\n\t\t// To solve that, and if we introduce historical gas estimation, we'd need to increase that default.\n\t\t#[rustfmt::skip]\n\t\t\tlet executable = move |\n\t\t\t\trequest, gas_limit, api_version, api: sp_api::ApiRef<'_, C::Api>, estimate_mode\n\t\t\t| -> Result<ExecutableResult> {\n\t\t\t\tlet CallRequest {\n\t\t\t\t\tfrom,\n\t\t\t\t\tto,\n\t\t\t\t\tgas,\n\t\t\t\t\tvalue,\n\t\t\t\t\tdata,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\t..\n\t\t\t\t} = request;\n\n\t\t\t\t// Use request gas limit only if it less than gas_limit parameter\n\t\t\t\tlet gas_limit = core::cmp::min(gas.unwrap_or(gas_limit), gas_limit);\n\n\t\t\t\tlet data = data.map(|d| d.0).unwrap_or_default();\n\n\t\t\t\tlet (exit_reason, data, used_gas) = match to {\n\t\t\t\t\tSome(to) => {\n\t\t\t\t\t\tlet info = if api_version == 1 {\n\t\t\t\t\t\t\t// Legacy pre-london\n\t\t\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\t\t\tapi.call_before_version_2(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tto,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t} else if api_version < 4 {\n\t\t\t\t\t\t\t// Post-london\n\t\t\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\t\t\tapi.call_before_version_4(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tto,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Post-london + access list support\n\t\t\t\t\t\t\tlet access_list = access_list.unwrap_or_default();\n\t\t\t\t\t\t\tapi.call(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tto,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t\tSome(\n\t\t\t\t\t\t\t\t\taccess_list\n\t\t\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys))\n\t\t\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t(info.exit_reason, info.value, info.used_gas)\n\t\t\t\t\t}\n\t\t\t\t\tNone => {\n\t\t\t\t\t\tlet info = if api_version == 1 {\n\t\t\t\t\t\t\t// Legacy pre-london\n\t\t\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\t\t\tapi.create_before_version_2(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t} else if api_version < 4 {\n\t\t\t\t\t\t\t// Post-london\n\t\t\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\t\t\tapi.create_before_version_4(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Post-london + access list support\n\t\t\t\t\t\t\tlet access_list = access_list.unwrap_or_default();\n\t\t\t\t\t\t\tapi.create(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t\tSome(\n\t\t\t\t\t\t\t\t\taccess_list\n\t\t\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys))\n\t\t\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t(info.exit_reason, Vec::new(), info.used_gas)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tOk(ExecutableResult {\n\t\t\t\t\texit_reason,\n\t\t\t\t\tdata,\n\t\t\t\t\tused_gas,\n\t\t\t\t})\n\t\t\t};\n\t\tlet api_version = if let Ok(Some(api_version)) =\n\t\t\tclient\n\t\t\t\t.runtime_api()\n\t\t\t\t.api_version::<dyn EthereumRuntimeRPCApi<B>>(&BlockId::Hash(best_hash))\n\t\t{\n\t\t\tapi_version\n\t\t} else {\n\t\t\treturn Err(internal_err(\"failed to retrieve Runtime Api version\"));\n\t\t};\n\n\t\t// Verify that the transaction succeed with highest capacity\n\t\tlet cap = highest;\n\t\tlet estimate_mode = !cfg!(feature = \"rpc_binary_search_estimate\");\n\t\tlet ExecutableResult {\n\t\t\tdata,\n\t\t\texit_reason,\n\t\t\tused_gas,\n\t\t} = executable(\n\t\t\trequest.clone(),\n\t\t\thighest,\n\t\t\tapi_version,\n\t\t\tclient.runtime_api(),\n\t\t\testimate_mode,\n\t\t)?;\n\t\tmatch exit_reason {\n\t\t\tExitReason::Succeed(_) => (),\n\t\t\tExitReason::Error(ExitError::OutOfGas) => {\n\t\t\t\treturn Err(internal_err(format!(\n\t\t\t\t\t\"gas required exceeds allowance {}\",\n\t\t\t\t\tcap\n\t\t\t\t)))\n\t\t\t}\n\t\t\t// If the transaction reverts, there are two possible cases,\n\t\t\t// it can revert because the called contract feels that it does not have enough\n\t\t\t// gas left to continue, or it can revert for another reason unrelated to gas.\n\t\t\tExitReason::Revert(revert) => {\n\t\t\t\tif request.gas.is_some() || request.gas_price.is_some() {\n\t\t\t\t\t// If the user has provided a gas limit or a gas price, then we have executed\n\t\t\t\t\t// with less block gas limit, so we must reexecute with block gas limit to\n\t\t\t\t\t// know if the revert is due to a lack of gas or not.\n\t\t\t\t\tlet ExecutableResult {\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\texit_reason,\n\t\t\t\t\t\tused_gas: _,\n\t\t\t\t\t} = executable(\n\t\t\t\t\t\trequest.clone(),\n\t\t\t\t\t\tmax_gas_limit,\n\t\t\t\t\t\tapi_version,\n\t\t\t\t\t\tclient.runtime_api(),\n\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t)?;\n\t\t\t\t\tmatch exit_reason {\n\t\t\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\t\t\treturn Err(internal_err(format!(\n\t\t\t\t\t\t\t\t\"gas required exceeds allowance {}\",\n\t\t\t\t\t\t\t\tcap\n\t\t\t\t\t\t\t)))\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The execution has been done with block gas limit, so it is not a lack of gas from the user.\n\t\t\t\t\t\tother => error_on_execution_failure(&other, &data)?,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// The execution has already been done with block gas limit, so it is not a lack of gas from the user.\n\t\t\t\t\terror_on_execution_failure(&ExitReason::Revert(revert), &data)?\n\t\t\t\t}\n\t\t\t}\n\t\t\tother => error_on_execution_failure(&other, &data)?,\n\t\t};\n\n\t\t#[cfg(not(feature = \"rpc_binary_search_estimate\"))]\n\t\t{\n\t\t\tOk(used_gas)\n\t\t}\n\t\t#[cfg(feature = \"rpc_binary_search_estimate\")]\n\t\t{\n\t\t\t// On binary search, evm estimate mode is disabled\n\t\t\tlet estimate_mode = false;\n\t\t\t// Define the lower bound of the binary search\n\t\t\tlet mut lowest = MIN_GAS_PER_TX;\n\n\t\t\t// Start close to the used gas for faster binary search\n\t\t\tlet mut mid = std::cmp::min(used_gas * 3, (highest + lowest) / 2);\n\n\t\t\t// Execute the binary search and hone in on an executable gas limit.\n\t\t\tlet mut previous_highest = highest;\n\t\t\twhile (highest - lowest) > U256::one() {\n\t\t\t\tlet ExecutableResult {\n\t\t\t\t\tdata,\n\t\t\t\t\texit_reason,\n\t\t\t\t\tused_gas: _,\n\t\t\t\t} = executable(\n\t\t\t\t\trequest.clone(),\n\t\t\t\t\tmid,\n\t\t\t\t\tapi_version,\n\t\t\t\t\tclient.runtime_api(),\n\t\t\t\t\testimate_mode,\n\t\t\t\t)?;\n\t\t\t\tmatch exit_reason {\n\t\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\t\thighest = mid;\n\t\t\t\t\t\t// If the variation in the estimate is less than 10%,\n\t\t\t\t\t\t// then the estimate is considered sufficiently accurate.\n\t\t\t\t\t\tif (previous_highest - highest) * 10 / previous_highest < U256::one() {\n\t\t\t\t\t\t\treturn Ok(highest);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevious_highest = highest;\n\t\t\t\t\t}\n\t\t\t\t\tExitReason::Revert(_) | ExitReason::Error(ExitError::OutOfGas) => {\n\t\t\t\t\t\tlowest = mid;\n\t\t\t\t\t}\n\t\t\t\t\tother => error_on_execution_failure(&other, &data)?,\n\t\t\t\t}\n\t\t\t\tmid = (highest + lowest) / 2;\n\t\t\t}\n\n\t\t\tOk(highest)\n\t\t}\n\t}\n}\n\npub fn error_on_execution_failure(reason: &ExitReason, data: &[u8]) -> Result<()> {\n\tmatch reason {\n\t\tExitReason::Succeed(_) => Ok(()),\n\t\tExitReason::Error(e) => {\n\t\t\tif *e == ExitError::OutOfGas {\n\t\t\t\t// `ServerError(0)` will be useful in estimate gas\n\t\t\t\treturn Err(internal_err(\"out of gas\"));\n\t\t\t}\n\t\t\tErr(crate::internal_err_with_data(\n\t\t\t\tformat!(\"evm error: {:?}\", e),\n\t\t\t\t&[],\n\t\t\t))\n\t\t}\n\t\tExitReason::Revert(_) => {\n\t\t\tlet mut message = \"VM Exception while processing transaction: revert\".to_string();\n\t\t\t// A minimum size of error function selector (4) + offset (32) + string length (32)\n\t\t\t// should contain a utf-8 encoded revert reason.\n\t\t\tif data.len() > 68 {\n\t\t\t\tlet message_len = data[36..68].iter().sum::<u8>();\n\t\t\t\tif data.len() >= 68 + message_len as usize {\n\t\t\t\t\tlet body: &[u8] = &data[68..68 + message_len as usize];\n\t\t\t\t\tif let Ok(reason) = std::str::from_utf8(body) {\n\t\t\t\t\t\tmessage = format!(\"{} {}\", message, reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tErr(crate::internal_err_with_data(message, data))\n\t\t}\n\t\tExitReason::Fatal(e) => Err(crate::internal_err_with_data(\n\t\t\tformat!(\"evm fatal: {:?}\", e),\n\t\t\t&[],\n\t\t)),\n\t}\n}\n\nstruct FeeDetails {\n\tgas_price: Option<U256>,\n\tmax_fee_per_gas: Option<U256>,\n\tmax_priority_fee_per_gas: Option<U256>,\n}\n\nfn fee_details(\n\trequest_gas_price: Option<U256>,\n\trequest_max_fee: Option<U256>,\n\trequest_priority: Option<U256>,\n) -> Result<FeeDetails> {\n\tmatch (request_gas_price, request_max_fee, request_priority) {\n\t\t(gas_price, None, None) => {\n\t\t\t// Legacy request, all default to gas price.\n\t\t\t// A zero-set gas price is None.\n\t\t\tlet gas_price = if gas_price.unwrap_or_default().is_zero() {\n\t\t\t\tNone\n\t\t\t} else {\n\t\t\t\tgas_price\n\t\t\t};\n\t\t\tOk(FeeDetails {\n\t\t\t\tgas_price,\n\t\t\t\tmax_fee_per_gas: gas_price,\n\t\t\t\tmax_priority_fee_per_gas: gas_price,\n\t\t\t})\n\t\t}\n\t\t(_, max_fee, max_priority) => {\n\t\t\t// eip-1559\n\t\t\t// A zero-set max fee is None.\n\t\t\tlet max_fee = if max_fee.unwrap_or_default().is_zero() {\n\t\t\t\tNone\n\t\t\t} else {\n\t\t\t\tmax_fee\n\t\t\t};\n\t\t\t// Ensure `max_priority_fee_per_gas` is less or equal to `max_fee_per_gas`.\n\t\t\tif let Some(max_priority) = max_priority {\n\t\t\t\tlet max_fee = max_fee.unwrap_or_default();\n\t\t\t\tif max_priority > max_fee {\n\t\t\t\t\treturn Err(internal_err(\n\t\t\t\t\t\t\"Invalid input: `max_priority_fee_per_gas` greater than `max_fee_per_gas`\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(FeeDetails {\n\t\t\t\tgas_price: max_fee,\n\t\t\t\tmax_fee_per_gas: max_fee,\n\t\t\t\tmax_priority_fee_per_gas: max_priority,\n\t\t\t})\n\t\t}\n\t}\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2022 Parity Technologies (UK) Ltd.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nuse std::sync::Arc;\n\nuse ethereum_types::{H256, U256};\nuse evm::{ExitError, ExitReason};\nuse jsonrpsee::core::RpcResult as Result;\n\nuse sc_client_api::backend::{Backend, StateBackend, StorageProvider};\nuse sc_network::ExHashT;\nuse sc_transaction_pool::ChainApi;\nuse sp_api::{ApiExt, ProvideRuntimeApi};\nuse sp_block_builder::BlockBuilder as BlockBuilderApi;\nuse sp_blockchain::{BlockStatus, HeaderBackend};\nuse sp_runtime::{\n\tgeneric::BlockId,\n\ttraits::{BlakeTwo256, Block as BlockT},\n\tSaturatedConversion,\n};\n\nuse fc_rpc_core::types::*;\nuse fp_rpc::EthereumRuntimeRPCApi;\n\nuse crate::{\n\teth::{pending_runtime_api, Eth},\n\tfrontier_backend_client, internal_err,\n};\n\n/// Default JSONRPC error code return by geth\npub const JSON_RPC_ERROR_DEFAULT: i32 = -32000;\n\nimpl<B, C, P, CT, BE, H: ExHashT, A: ChainApi> Eth<B, C, P, CT, BE, H, A>\nwhere\n\tB: BlockT<Hash = H256> + Send + Sync + 'static,\n\tC: ProvideRuntimeApi<B> + StorageProvider<B, BE>,\n\tC: HeaderBackend<B> + Send + Sync + 'static,\n\tC::Api: BlockBuilderApi<B> + EthereumRuntimeRPCApi<B>,\n\tBE: Backend<B> + 'static,\n\tBE::State: StateBackend<BlakeTwo256>,\n\tA: ChainApi<Block = B> + 'static,\n{\n\tpub fn call(&self, request: CallRequest, number: Option<BlockNumber>) -> Result<Bytes> {\n\t\tlet CallRequest {\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tgas_price,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tgas,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\tnonce,\n\t\t\taccess_list,\n\t\t\t..\n\t\t} = request;\n\n\t\tlet (gas_price, max_fee_per_gas, max_priority_fee_per_gas) = {\n\t\t\tlet details = fee_details(gas_price, max_fee_per_gas, max_priority_fee_per_gas)?;\n\t\t\t(\n\t\t\t\tdetails.gas_price,\n\t\t\t\tdetails.max_fee_per_gas,\n\t\t\t\tdetails.max_priority_fee_per_gas,\n\t\t\t)\n\t\t};\n\n\t\tlet (id, api) = match frontier_backend_client::native_block_id::<B, C>(\n\t\t\tself.client.as_ref(),\n\t\t\tself.backend.as_ref(),\n\t\t\tnumber,\n\t\t)? {\n\t\t\tSome(id) => (id, self.client.runtime_api()),\n\t\t\tNone => {\n\t\t\t\t// Not mapped in the db, assume pending.\n\t\t\t\tlet id = BlockId::Hash(self.client.info().best_hash);\n\t\t\t\tlet api = pending_runtime_api(self.client.as_ref(), self.graph.as_ref())?;\n\t\t\t\t(id, api)\n\t\t\t}\n\t\t};\n\n\t\tif let Ok(BlockStatus::Unknown) = self.client.status(id) {\n\t\t\treturn Err(crate::err(JSON_RPC_ERROR_DEFAULT, \"header not found\", None));\n\t\t}\n\n\t\tlet api_version =\n\t\t\tif let Ok(Some(api_version)) = api.api_version::<dyn EthereumRuntimeRPCApi<B>>(&id) {\n\t\t\t\tapi_version\n\t\t\t} else {\n\t\t\t\treturn Err(internal_err(\"failed to retrieve Runtime Api version\"));\n\t\t\t};\n\n\t\tlet block = if api_version > 1 {\n\t\t\tapi.current_block(&id)\n\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t} else {\n\t\t\t#[allow(deprecated)]\n\t\t\tlet legacy_block = api\n\t\t\t\t.current_block_before_version_2(&id)\n\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\tlegacy_block.map(|block| block.into())\n\t\t};\n\n\t\tlet block_gas_limit = block\n\t\t\t.ok_or_else(|| internal_err(\"block unavailable, cannot query gas limit\"))?\n\t\t\t.header\n\t\t\t.gas_limit;\n\t\tlet max_gas_limit = block_gas_limit * self.execute_gas_limit_multiplier;\n\n\t\t// use given gas limit or query current block's limit\n\t\tlet gas_limit = match gas {\n\t\t\tSome(amount) => {\n\t\t\t\tif amount > max_gas_limit {\n\t\t\t\t\treturn Err(internal_err(format!(\n\t\t\t\t\t\t\"provided gas limit is too high (can be up to {}x the block gas limit)\",\n\t\t\t\t\t\tself.execute_gas_limit_multiplier\n\t\t\t\t\t)));\n\t\t\t\t}\n\t\t\t\tamount\n\t\t\t}\n\t\t\tNone => max_gas_limit,\n\t\t};\n\n\t\tlet data = data.map(|d| d.0).unwrap_or_default();\n\t\tmatch to {\n\t\t\tSome(to) => {\n\t\t\t\tif api_version == 1 {\n\t\t\t\t\t// Legacy pre-london\n\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\tlet info = api.call_before_version_2(\n\t\t\t\t\t\t&id,\n\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\tto,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\tnonce,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &info.value)?;\n\t\t\t\t\tOk(Bytes(info.value))\n\t\t\t\t} else if api_version >= 2 && api_version < 4 {\n\t\t\t\t\t// Post-london\n\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\tlet info = api.call_before_version_4(\n\t\t\t\t\t\t&id,\n\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\tto,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\tnonce,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &info.value)?;\n\t\t\t\t\tOk(Bytes(info.value))\n\t\t\t\t} else if api_version == 4 {\n\t\t\t\t\t// Post-london + access list support\n\t\t\t\t\tlet access_list = access_list.unwrap_or_default();\n\t\t\t\t\tlet info = api\n\t\t\t\t\t\t.call(\n\t\t\t\t\t\t\t&id,\n\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\tto,\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tSome(\n\t\t\t\t\t\t\t\taccess_list\n\t\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys))\n\t\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &info.value)?;\n\t\t\t\t\tOk(Bytes(info.value))\n\t\t\t\t} else {\n\t\t\t\t\tErr(internal_err(\"failed to retrieve Runtime Api version\"))\n\t\t\t\t}\n\t\t\t}\n\t\t\tNone => {\n\t\t\t\tif api_version == 1 {\n\t\t\t\t\t// Legacy pre-london\n\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\tlet info = api.create_before_version_2(\n\t\t\t\t\t\t&id,\n\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\tnonce,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &[])?;\n\n\t\t\t\t\tlet code = api\n\t\t\t\t\t\t.account_code_at(&id, info.value)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\t\t\tOk(Bytes(code))\n\t\t\t\t} else if api_version >= 2 && api_version < 4 {\n\t\t\t\t\t// Post-london\n\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\tlet info = api.create_before_version_4(\n\t\t\t\t\t\t&id,\n\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\tnonce,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &[])?;\n\n\t\t\t\t\tlet code = api\n\t\t\t\t\t\t.account_code_at(&id, info.value)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\t\t\tOk(Bytes(code))\n\t\t\t\t} else if api_version == 4 {\n\t\t\t\t\t// Post-london + access list support\n\t\t\t\t\tlet access_list = access_list.unwrap_or_default();\n\t\t\t\t\tlet info = api\n\t\t\t\t\t\t.create(\n\t\t\t\t\t\t\t&id,\n\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tSome(\n\t\t\t\t\t\t\t\taccess_list\n\t\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys))\n\t\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?;\n\n\t\t\t\t\terror_on_execution_failure(&info.exit_reason, &[])?;\n\n\t\t\t\t\tlet code = api\n\t\t\t\t\t\t.account_code_at(&id, info.value)\n\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\t\t\tOk(Bytes(code))\n\t\t\t\t} else {\n\t\t\t\t\tErr(internal_err(\"failed to retrieve Runtime Api version\"))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub async fn estimate_gas(&self, request: CallRequest, _: Option<BlockNumber>) -> Result<U256> {\n\t\tlet client = Arc::clone(&self.client);\n\t\tlet block_data_cache = Arc::clone(&self.block_data_cache);\n\n\t\t// Define the lower bound of estimate\n\t\tconst MIN_GAS_PER_TX: U256 = U256([21_000, 0, 0, 0]);\n\n\t\t// Get best hash (TODO missing support for estimating gas historically)\n\t\tlet best_hash = client.info().best_hash;\n\n\t\t// For simple transfer to simple account, return MIN_GAS_PER_TX directly\n\t\tlet is_simple_transfer = match &request.data {\n\t\t\tNone => true,\n\t\t\tSome(vec) => vec.0.is_empty(),\n\t\t};\n\t\tif is_simple_transfer {\n\t\t\tif let Some(to) = request.to {\n\t\t\t\tlet to_code = client\n\t\t\t\t\t.runtime_api()\n\t\t\t\t\t.account_code_at(&BlockId::Hash(best_hash), to)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?;\n\t\t\t\tif to_code.is_empty() {\n\t\t\t\t\treturn Ok(MIN_GAS_PER_TX);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet (gas_price, max_fee_per_gas, max_priority_fee_per_gas) = {\n\t\t\tlet details = fee_details(\n\t\t\t\trequest.gas_price,\n\t\t\t\trequest.max_fee_per_gas,\n\t\t\t\trequest.max_priority_fee_per_gas,\n\t\t\t)?;\n\t\t\t(\n\t\t\t\tdetails.gas_price,\n\t\t\t\tdetails.max_fee_per_gas,\n\t\t\t\tdetails.max_priority_fee_per_gas,\n\t\t\t)\n\t\t};\n\n\t\tlet block_gas_limit = {\n\t\t\tlet substrate_hash = client.info().best_hash;\n\t\t\tlet id = BlockId::Hash(substrate_hash);\n\t\t\tlet schema = frontier_backend_client::onchain_storage_schema::<B, C, BE>(&client, id);\n\t\t\tlet block = block_data_cache.current_block(schema, substrate_hash).await;\n\n\t\t\tblock\n\t\t\t\t.ok_or_else(|| internal_err(\"block unavailable, cannot query gas limit\"))?\n\t\t\t\t.header\n\t\t\t\t.gas_limit\n\t\t};\n\n\t\tlet max_gas_limit = block_gas_limit * self.execute_gas_limit_multiplier;\n\n\t\t// Determine the highest possible gas limits\n\t\tlet mut highest = match request.gas {\n\t\t\tSome(amount) => {\n\t\t\t\tif amount > max_gas_limit {\n\t\t\t\t\treturn Err(internal_err(format!(\n\t\t\t\t\t\t\"provided gas limit is too high (can be up to {}x the block gas limit)\",\n\t\t\t\t\t\tself.execute_gas_limit_multiplier\n\t\t\t\t\t)));\n\t\t\t\t}\n\t\t\t\tamount\n\t\t\t}\n\t\t\tNone => max_gas_limit,\n\t\t};\n\n\t\tlet api = client.runtime_api();\n\n\t\t// Recap the highest gas allowance with account's balance.\n\t\tif let Some(from) = request.from {\n\t\t\tlet gas_price = gas_price.unwrap_or_default();\n\t\t\tif gas_price > U256::zero() {\n\t\t\t\tlet balance = api\n\t\t\t\t\t.account_basic(&BlockId::Hash(best_hash), from)\n\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t.balance;\n\t\t\t\tlet mut available = balance;\n\t\t\t\tif let Some(value) = request.value {\n\t\t\t\t\tif value > available {\n\t\t\t\t\t\treturn Err(internal_err(\"insufficient funds for transfer\"));\n\t\t\t\t\t}\n\t\t\t\t\tavailable -= value;\n\t\t\t\t}\n\t\t\t\tlet allowance = available / gas_price;\n\t\t\t\tif highest > allowance {\n\t\t\t\t\tlog::warn!(\n\t\t\t\t\t\t\t\"Gas estimation capped by limited funds original {} balance {} sent {} feecap {} fundable {}\",\n\t\t\t\t\t\t\thighest,\n\t\t\t\t\t\t\tbalance,\n\t\t\t\t\t\t\trequest.value.unwrap_or_default(),\n\t\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\t\tallowance\n\t\t\t\t\t\t);\n\t\t\t\t\thighest = allowance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstruct ExecutableResult {\n\t\t\tdata: Vec<u8>,\n\t\t\texit_reason: ExitReason,\n\t\t\tused_gas: U256,\n\t\t}\n\n\t\t// Create a helper to check if a gas allowance results in an executable transaction.\n\t\t//\n\t\t// A new ApiRef instance needs to be used per execution to avoid the overlayed state to affect\n\t\t// the estimation result of subsequent calls.\n\t\t//\n\t\t// Note that this would have a performance penalty if we introduce gas estimation for past\n\t\t// blocks - and thus, past runtime versions. Substrate has a default `runtime_cache_size` of\n\t\t// 2 slots LRU-style, meaning if users were to access multiple runtime versions in a short period\n\t\t// of time, the RPC response time would degrade a lot, as the VersionedRuntime needs to be compiled.\n\t\t//\n\t\t// To solve that, and if we introduce historical gas estimation, we'd need to increase that default.\n\t\t#[rustfmt::skip]\n\t\t\tlet executable = move |\n\t\t\t\trequest, gas_limit, api_version, api: sp_api::ApiRef<'_, C::Api>, estimate_mode\n\t\t\t| -> Result<ExecutableResult> {\n\t\t\t\tlet CallRequest {\n\t\t\t\t\tfrom,\n\t\t\t\t\tto,\n\t\t\t\t\tgas,\n\t\t\t\t\tvalue,\n\t\t\t\t\tdata,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\t..\n\t\t\t\t} = request;\n\n\t\t\t\t// Use request gas limit only if it less than gas_limit parameter\n\t\t\t\tlet gas_limit = core::cmp::min(gas.unwrap_or(gas_limit), gas_limit);\n\n\t\t\t\tlet data = data.map(|d| d.0).unwrap_or_default();\n\n\t\t\t\tlet (exit_reason, data, used_gas) = match to {\n\t\t\t\t\tSome(to) => {\n\t\t\t\t\t\tlet info = if api_version == 1 {\n\t\t\t\t\t\t\t// Legacy pre-london\n\t\t\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\t\t\tapi.call_before_version_2(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tto,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t} else if api_version < 4 {\n\t\t\t\t\t\t\t// Post-london\n\t\t\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\t\t\tapi.call_before_version_4(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tto,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Post-london + access list support\n\t\t\t\t\t\t\tlet access_list = access_list.unwrap_or_default();\n\t\t\t\t\t\t\tapi.call(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tto,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t\tSome(\n\t\t\t\t\t\t\t\t\taccess_list\n\t\t\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys))\n\t\t\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t(info.exit_reason, info.value, info.used_gas)\n\t\t\t\t\t}\n\t\t\t\t\tNone => {\n\t\t\t\t\t\tlet info = if api_version == 1 {\n\t\t\t\t\t\t\t// Legacy pre-london\n\t\t\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\t\t\tapi.create_before_version_2(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tgas_price,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t} else if api_version < 4 {\n\t\t\t\t\t\t\t// Post-london\n\t\t\t\t\t\t\t#[allow(deprecated)]\n\t\t\t\t\t\t\tapi.create_before_version_4(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Post-london + access list support\n\t\t\t\t\t\t\tlet access_list = access_list.unwrap_or_default();\n\t\t\t\t\t\t\tapi.create(\n\t\t\t\t\t\t\t\t&BlockId::Hash(best_hash),\n\t\t\t\t\t\t\t\tfrom.unwrap_or_default(),\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tvalue.unwrap_or_default(),\n\t\t\t\t\t\t\t\tgas_limit,\n\t\t\t\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\t\t\t\tnonce,\n\t\t\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t\t\t\tSome(\n\t\t\t\t\t\t\t\t\taccess_list\n\t\t\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys))\n\t\t\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"runtime error: {:?}\", err)))?\n\t\t\t\t\t\t\t.map_err(|err| internal_err(format!(\"execution fatal: {:?}\", err)))?\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t(info.exit_reason, Vec::new(), info.used_gas)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tOk(ExecutableResult {\n\t\t\t\t\texit_reason,\n\t\t\t\t\tdata,\n\t\t\t\t\tused_gas,\n\t\t\t\t})\n\t\t\t};\n\t\tlet api_version = if let Ok(Some(api_version)) =\n\t\t\tclient\n\t\t\t\t.runtime_api()\n\t\t\t\t.api_version::<dyn EthereumRuntimeRPCApi<B>>(&BlockId::Hash(best_hash))\n\t\t{\n\t\t\tapi_version\n\t\t} else {\n\t\t\treturn Err(internal_err(\"failed to retrieve Runtime Api version\"));\n\t\t};\n\n\t\t// Verify that the transaction succeed with highest capacity\n\t\tlet cap = highest;\n\t\tlet estimate_mode = !cfg!(feature = \"rpc_binary_search_estimate\");\n\t\tlet ExecutableResult {\n\t\t\tdata,\n\t\t\texit_reason,\n\t\t\tused_gas,\n\t\t} = executable(\n\t\t\trequest.clone(),\n\t\t\thighest,\n\t\t\tapi_version,\n\t\t\tclient.runtime_api(),\n\t\t\testimate_mode,\n\t\t)?;\n\t\tmatch exit_reason {\n\t\t\tExitReason::Succeed(_) => (),\n\t\t\tExitReason::Error(ExitError::OutOfGas) => {\n\t\t\t\treturn Err(internal_err(format!(\n\t\t\t\t\t\"gas required exceeds allowance {}\",\n\t\t\t\t\tcap\n\t\t\t\t)))\n\t\t\t}\n\t\t\t// If the transaction reverts, there are two possible cases,\n\t\t\t// it can revert because the called contract feels that it does not have enough\n\t\t\t// gas left to continue, or it can revert for another reason unrelated to gas.\n\t\t\tExitReason::Revert(revert) => {\n\t\t\t\tif request.gas.is_some() || request.gas_price.is_some() {\n\t\t\t\t\t// If the user has provided a gas limit or a gas price, then we have executed\n\t\t\t\t\t// with less block gas limit, so we must reexecute with block gas limit to\n\t\t\t\t\t// know if the revert is due to a lack of gas or not.\n\t\t\t\t\tlet ExecutableResult {\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\texit_reason,\n\t\t\t\t\t\tused_gas: _,\n\t\t\t\t\t} = executable(\n\t\t\t\t\t\trequest.clone(),\n\t\t\t\t\t\tmax_gas_limit,\n\t\t\t\t\t\tapi_version,\n\t\t\t\t\t\tclient.runtime_api(),\n\t\t\t\t\t\testimate_mode,\n\t\t\t\t\t)?;\n\t\t\t\t\tmatch exit_reason {\n\t\t\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\t\t\treturn Err(internal_err(format!(\n\t\t\t\t\t\t\t\t\"gas required exceeds allowance {}\",\n\t\t\t\t\t\t\t\tcap\n\t\t\t\t\t\t\t)))\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// The execution has been done with block gas limit, so it is not a lack of gas from the user.\n\t\t\t\t\t\tother => error_on_execution_failure(&other, &data)?,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// The execution has already been done with block gas limit, so it is not a lack of gas from the user.\n\t\t\t\t\terror_on_execution_failure(&ExitReason::Revert(revert), &data)?\n\t\t\t\t}\n\t\t\t}\n\t\t\tother => error_on_execution_failure(&other, &data)?,\n\t\t};\n\n\t\t#[cfg(not(feature = \"rpc_binary_search_estimate\"))]\n\t\t{\n\t\t\tOk(used_gas)\n\t\t}\n\t\t#[cfg(feature = \"rpc_binary_search_estimate\")]\n\t\t{\n\t\t\t// On binary search, evm estimate mode is disabled\n\t\t\tlet estimate_mode = false;\n\t\t\t// Define the lower bound of the binary search\n\t\t\tlet mut lowest = MIN_GAS_PER_TX;\n\n\t\t\t// Start close to the used gas for faster binary search\n\t\t\tlet mut mid = std::cmp::min(used_gas * 3, (highest + lowest) / 2);\n\n\t\t\t// Execute the binary search and hone in on an executable gas limit.\n\t\t\tlet mut previous_highest = highest;\n\t\t\twhile (highest - lowest) > U256::one() {\n\t\t\t\tlet ExecutableResult {\n\t\t\t\t\tdata,\n\t\t\t\t\texit_reason,\n\t\t\t\t\tused_gas: _,\n\t\t\t\t} = executable(\n\t\t\t\t\trequest.clone(),\n\t\t\t\t\tmid,\n\t\t\t\t\tapi_version,\n\t\t\t\t\tclient.runtime_api(),\n\t\t\t\t\testimate_mode,\n\t\t\t\t)?;\n\t\t\t\tmatch exit_reason {\n\t\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\t\thighest = mid;\n\t\t\t\t\t\t// If the variation in the estimate is less than 10%,\n\t\t\t\t\t\t// then the estimate is considered sufficiently accurate.\n\t\t\t\t\t\tif (previous_highest - highest) * 10 / previous_highest < U256::one() {\n\t\t\t\t\t\t\treturn Ok(highest);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevious_highest = highest;\n\t\t\t\t\t}\n\t\t\t\t\tExitReason::Revert(_) | ExitReason::Error(ExitError::OutOfGas) => {\n\t\t\t\t\t\tlowest = mid;\n\t\t\t\t\t}\n\t\t\t\t\tother => error_on_execution_failure(&other, &data)?,\n\t\t\t\t}\n\t\t\t\tmid = (highest + lowest) / 2;\n\t\t\t}\n\n\t\t\tOk(highest)\n\t\t}\n\t}\n}\n\npub fn error_on_execution_failure(reason: &ExitReason, data: &[u8]) -> Result<()> {\n\tmatch reason {\n\t\tExitReason::Succeed(_) => Ok(()),\n\t\tExitReason::Error(e) => {\n\t\t\tif *e == ExitError::OutOfGas {\n\t\t\t\t// `ServerError(0)` will be useful in estimate gas\n\t\t\t\treturn Err(internal_err(\"out of gas\"));\n\t\t\t}\n\t\t\tErr(crate::internal_err_with_data(\n\t\t\t\tformat!(\"evm error: {:?}\", e),\n\t\t\t\t&[],\n\t\t\t))\n\t\t}\n\t\tExitReason::Revert(_) => {\n\t\t\tconst LEN_START: usize = 36;\n\t\t\tconst MESSAGE_START: usize = 68;\n\n\t\t\tlet mut message = \"VM Exception while processing transaction: revert\".to_string();\n\t\t\t// A minimum size of error function selector (4) + offset (32) + string length (32)\n\t\t\t// should contain a utf-8 encoded revert reason.\n\t\t\tif data.len() > MESSAGE_START {\n\t\t\t\tlet message_len =\n\t\t\t\t\tU256::from(&data[LEN_START..MESSAGE_START]).saturated_into::<usize>();\n\t\t\t\tlet message_end = MESSAGE_START.saturating_add(message_len);\n\n\t\t\t\tif data.len() >= message_end {\n\t\t\t\t\tlet body: &[u8] = &data[MESSAGE_START..message_end];\n\t\t\t\t\tif let Ok(reason) = std::str::from_utf8(body) {\n\t\t\t\t\t\tmessage = format!(\"{} {}\", message, reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tErr(crate::internal_err_with_data(message, data))\n\t\t}\n\t\tExitReason::Fatal(e) => Err(crate::internal_err_with_data(\n\t\t\tformat!(\"evm fatal: {:?}\", e),\n\t\t\t&[],\n\t\t)),\n\t}\n}\n\nstruct FeeDetails {\n\tgas_price: Option<U256>,\n\tmax_fee_per_gas: Option<U256>,\n\tmax_priority_fee_per_gas: Option<U256>,\n}\n\nfn fee_details(\n\trequest_gas_price: Option<U256>,\n\trequest_max_fee: Option<U256>,\n\trequest_priority: Option<U256>,\n) -> Result<FeeDetails> {\n\tmatch (request_gas_price, request_max_fee, request_priority) {\n\t\t(gas_price, None, None) => {\n\t\t\t// Legacy request, all default to gas price.\n\t\t\t// A zero-set gas price is None.\n\t\t\tlet gas_price = if gas_price.unwrap_or_default().is_zero() {\n\t\t\t\tNone\n\t\t\t} else {\n\t\t\t\tgas_price\n\t\t\t};\n\t\t\tOk(FeeDetails {\n\t\t\t\tgas_price,\n\t\t\t\tmax_fee_per_gas: gas_price,\n\t\t\t\tmax_priority_fee_per_gas: gas_price,\n\t\t\t})\n\t\t}\n\t\t(_, max_fee, max_priority) => {\n\t\t\t// eip-1559\n\t\t\t// A zero-set max fee is None.\n\t\t\tlet max_fee = if max_fee.unwrap_or_default().is_zero() {\n\t\t\t\tNone\n\t\t\t} else {\n\t\t\t\tmax_fee\n\t\t\t};\n\t\t\t// Ensure `max_priority_fee_per_gas` is less or equal to `max_fee_per_gas`.\n\t\t\tif let Some(max_priority) = max_priority {\n\t\t\t\tlet max_fee = max_fee.unwrap_or_default();\n\t\t\t\tif max_priority > max_fee {\n\t\t\t\t\treturn Err(internal_err(\n\t\t\t\t\t\t\"Invalid input: `max_priority_fee_per_gas` greater than `max_fee_per_gas`\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(FeeDetails {\n\t\t\t\tgas_price: max_fee,\n\t\t\t\tmax_fee_per_gas: max_fee,\n\t\t\t\tmax_priority_fee_per_gas: max_priority,\n\t\t\t})\n\t\t}\n\t}\n}\n"], "filenames": ["client/rpc/src/eth/execute.rs"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [698], "fixing_code_start_loc": [34], "fixing_code_end_loc": [705], "type": "CWE-190", "message": "Frontier is Substrate's Ethereum compatibility layer. A security issue was discovered affecting parsing of the RPC result of the exit reason in case of EVM reversion. In release build, this would cause the exit reason being incorrectly parsed and returned by RPC. In debug build, this would cause an overflow panic. No action is needed unless you have a bridge node that needs to distinguish different reversion exit reasons and you used RPC for this. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-36008", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-19T21:15:08.480", "lastModified": "2022-08-25T16:21:13.253", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Frontier is Substrate's Ethereum compatibility layer. A security issue was discovered affecting parsing of the RPC result of the exit reason in case of EVM reversion. In release build, this would cause the exit reason being incorrectly parsed and returned by RPC. In debug build, this would cause an overflow panic. No action is needed unless you have a bridge node that needs to distinguish different reversion exit reasons and you used RPC for this. There are currently no known workarounds."}, {"lang": "es", "value": "Frontier es la capa de compatibilidad con Ethereum de Substrate. Ha sido detectado un problema de seguridad que afecta al an\u00e1lisis del resultado RPC de la raz\u00f3n de salida en caso de reversi\u00f3n de EVM. En la versi\u00f3n de lanzamiento, esto causaba que la raz\u00f3n de salida fuera analizada y devuelta por RPC de forma incorrecta. En la compilaci\u00f3n de depuraci\u00f3n, esto causar\u00eda un p\u00e1nico de desbordamiento. No es necesario realizar ninguna acci\u00f3n, a menos que tenga un nodo puente que necesite distinguir diferentes motivos de salida de la reversi\u00f3n y utilice RPC para ello. Actualmente no se presentan mitigaciones conocidas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parity:frontier:-:*:*:*:*:*:*:*", "matchCriteriaId": "B181234B-73EA-4932-916B-326F848CE8C6"}]}]}], "references": [{"url": "https://github.com/paritytech/frontier/commit/fff8cc43b7756ce3979a38fc473f38e6e24ac451", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/paritytech/frontier/pull/820", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/paritytech/frontier/security/advisories/GHSA-mjvm-mhgc-q4gp", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/paritytech/frontier/commit/fff8cc43b7756ce3979a38fc473f38e6e24ac451"}}