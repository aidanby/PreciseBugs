{"buggy_code": ["# coding=utf-8\n\nimport os\nimport requests\nimport mimetypes\n\nfrom flask import request, abort, render_template, Response, session, send_file, stream_with_context, Blueprint\nfrom functools import wraps\nfrom urllib.parse import unquote\n\nfrom constants import headers\nfrom sonarr.info import get_sonarr_info, url_sonarr\nfrom radarr.info import get_radarr_info, url_radarr\nfrom utilities.helper import check_credentials\n\nfrom .config import settings, base_url\nfrom .database import System\nfrom .get_args import args\n\nui_bp = Blueprint('ui', __name__,\n                  template_folder=os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))),\n                                               'frontend', 'build'),\n                  static_folder=os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'frontend',\n                                             'build', 'assets'),\n                  static_url_path='/assets')\n\nif os.path.exists(os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'frontend', 'build',\n                               'images')):\n    static_directory = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'frontend', 'build',\n                                    'images')\nelse:\n    static_directory = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'frontend', 'public',\n                                    'images')\nstatic_bp = Blueprint('images', __name__, static_folder=static_directory, static_url_path='/images')\n\nui_bp.register_blueprint(static_bp)\n\n\nmimetypes.add_type('application/javascript', '.js')\nmimetypes.add_type('text/css', '.css')\nmimetypes.add_type('font/woff2', '.woff2')\nmimetypes.add_type('image/svg+xml', '.svg')\nmimetypes.add_type('image/png', '.png')\nmimetypes.add_type('image/x-icon', '.ico')\n\n\ndef check_login(actual_method):\n    @wraps(actual_method)\n    def wrapper(*args, **kwargs):\n        if settings.auth.type == 'basic':\n            auth = request.authorization\n            if not (auth and\n                    check_credentials(request.authorization.username, request.authorization.password, request)):\n                return ('Unauthorized', 401, {\n                    'WWW-Authenticate': 'Basic realm=\"Login Required\"'\n                })\n        elif settings.auth.type == 'form':\n            if 'logged_in' not in session:\n                return abort(401, message=\"Unauthorized\")\n        actual_method(*args, **kwargs)\n\n\n@ui_bp.route('/', defaults={'path': ''})\n@ui_bp.route('/<path:path>')\ndef catch_all(path):\n    auth = True\n    if settings.auth.type == 'basic':\n        auth = request.authorization\n        if not (auth and check_credentials(request.authorization.username, request.authorization.password, request,\n                                           log_success=False)):\n            return ('Unauthorized', 401, {\n                'WWW-Authenticate': 'Basic realm=\"Login Required\"'\n            })\n    elif settings.auth.type == 'form':\n        if 'logged_in' not in session or not session['logged_in']:\n            auth = False\n\n    try:\n        updated = System.get().updated\n    except Exception:\n        updated = '0'\n\n    inject = dict()\n\n    if not path.startswith('api/'):\n        inject[\"baseUrl\"] = base_url\n        inject[\"canUpdate\"] = not args.no_update\n        inject[\"hasUpdate\"] = updated != '0'\n\n        if auth:\n            inject[\"apiKey\"] = settings.auth.apikey\n\n    template_url = base_url\n    if not template_url.endswith(\"/\"):\n        template_url += \"/\"\n\n    return render_template(\"index.html\", BAZARR_SERVER_INJECT=inject, baseUrl=template_url)\n\n\n@check_login\n@ui_bp.route('/bazarr.log')\ndef download_log():\n    return send_file(os.path.join(args.config_dir, 'log', 'bazarr.log'), max_age=0, as_attachment=True)\n\n\n@check_login\n@ui_bp.route('/images/series/<path:url>', methods=['GET'])\ndef series_images(url):\n    url = url.strip(\"/\")\n    apikey = settings.sonarr.apikey\n    baseUrl = settings.sonarr.base_url\n    if get_sonarr_info.is_legacy():\n        url_image = (url_sonarr() + '/api/' + url.lstrip(baseUrl) + '?apikey=' +\n                     apikey).replace('poster-250', 'poster-500')\n    else:\n        url_image = (url_sonarr() + '/api/v3/' + url.lstrip(baseUrl) + '?apikey=' +\n                     apikey).replace('poster-250', 'poster-500')\n    try:\n        req = requests.get(url_image, stream=True, timeout=15, verify=False, headers=headers)\n    except Exception:\n        return '', 404\n    else:\n        return Response(stream_with_context(req.iter_content(2048)), content_type=req.headers['content-type'])\n\n\n@check_login\n@ui_bp.route('/images/movies/<path:url>', methods=['GET'])\ndef movies_images(url):\n    apikey = settings.radarr.apikey\n    baseUrl = settings.radarr.base_url\n    if get_radarr_info.is_legacy():\n        url_image = url_radarr() + '/api/' + url.lstrip(baseUrl) + '?apikey=' + apikey\n    else:\n        url_image = url_radarr() + '/api/v3/' + url.lstrip(baseUrl) + '?apikey=' + apikey\n    try:\n        req = requests.get(url_image, stream=True, timeout=15, verify=False, headers=headers)\n    except Exception:\n        return '', 404\n    else:\n        return Response(stream_with_context(req.iter_content(2048)), content_type=req.headers['content-type'])\n\n\n@check_login\n@ui_bp.route('/system/backup/download/<path:filename>', methods=['GET'])\ndef backup_download(filename):\n    return send_file(os.path.join(settings.backup.folder, filename), max_age=0, as_attachment=True)\n\n\n@ui_bp.route('/api/swaggerui/static/<path:filename>', methods=['GET'])\ndef swaggerui_static(filename):\n    return send_file(os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'libs', 'flask_restx',\n                     'static', filename))\n\n\ndef configured():\n    System.update({System.configured: '1'}).execute()\n\n\n@check_login\n@ui_bp.route('/test', methods=['GET'])\n@ui_bp.route('/test/<protocol>/<path:url>', methods=['GET'])\ndef proxy(protocol, url):\n    url = protocol + '://' + unquote(url)\n    params = request.args\n    try:\n        result = requests.get(url, params, allow_redirects=False, verify=False, timeout=5, headers=headers)\n    except Exception as e:\n        return dict(status=False, error=repr(e))\n    else:\n        if result.status_code == 200:\n            try:\n                version = result.json()['version']\n                return dict(status=True, version=version)\n            except Exception:\n                return dict(status=False, error='Error Occurred. Check your settings.')\n        elif result.status_code == 401:\n            return dict(status=False, error='Access Denied. Check API key.')\n        elif result.status_code == 404:\n            return dict(status=False, error='Cannot get version. Maybe unsupported legacy API call?')\n        elif 300 <= result.status_code <= 399:\n            return dict(status=False, error='Wrong URL Base.')\n        else:\n            return dict(status=False, error=result.raise_for_status())\n"], "fixing_code": ["# coding=utf-8\n\nimport os\nimport requests\nimport mimetypes\n\nfrom flask import request, abort, render_template, Response, session, send_file, stream_with_context, Blueprint\nfrom functools import wraps\nfrom urllib.parse import unquote\n\nfrom constants import headers\nfrom sonarr.info import get_sonarr_info, url_sonarr\nfrom radarr.info import get_radarr_info, url_radarr\nfrom utilities.helper import check_credentials\n\nfrom .config import settings, base_url\nfrom .database import System\nfrom .get_args import args\n\nui_bp = Blueprint('ui', __name__,\n                  template_folder=os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))),\n                                               'frontend', 'build'),\n                  static_folder=os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'frontend',\n                                             'build', 'assets'),\n                  static_url_path='/assets')\n\nif os.path.exists(os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'frontend', 'build',\n                               'images')):\n    static_directory = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'frontend', 'build',\n                                    'images')\nelse:\n    static_directory = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'frontend', 'public',\n                                    'images')\nstatic_bp = Blueprint('images', __name__, static_folder=static_directory, static_url_path='/images')\n\nui_bp.register_blueprint(static_bp)\n\n\nmimetypes.add_type('application/javascript', '.js')\nmimetypes.add_type('text/css', '.css')\nmimetypes.add_type('font/woff2', '.woff2')\nmimetypes.add_type('image/svg+xml', '.svg')\nmimetypes.add_type('image/png', '.png')\nmimetypes.add_type('image/x-icon', '.ico')\n\n\ndef check_login(actual_method):\n    @wraps(actual_method)\n    def wrapper(*args, **kwargs):\n        if settings.auth.type == 'basic':\n            auth = request.authorization\n            if not (auth and\n                    check_credentials(request.authorization.username, request.authorization.password, request)):\n                return ('Unauthorized', 401, {\n                    'WWW-Authenticate': 'Basic realm=\"Login Required\"'\n                })\n        elif settings.auth.type == 'form':\n            if 'logged_in' not in session:\n                return abort(401, message=\"Unauthorized\")\n        actual_method(*args, **kwargs)\n\n\n@ui_bp.route('/', defaults={'path': ''})\n@ui_bp.route('/<path:path>')\ndef catch_all(path):\n    auth = True\n    if settings.auth.type == 'basic':\n        auth = request.authorization\n        if not (auth and check_credentials(request.authorization.username, request.authorization.password, request,\n                                           log_success=False)):\n            return ('Unauthorized', 401, {\n                'WWW-Authenticate': 'Basic realm=\"Login Required\"'\n            })\n    elif settings.auth.type == 'form':\n        if 'logged_in' not in session or not session['logged_in']:\n            auth = False\n\n    try:\n        updated = System.get().updated\n    except Exception:\n        updated = '0'\n\n    inject = dict()\n\n    if not path.startswith('api/'):\n        inject[\"baseUrl\"] = base_url\n        inject[\"canUpdate\"] = not args.no_update\n        inject[\"hasUpdate\"] = updated != '0'\n\n        if auth:\n            inject[\"apiKey\"] = settings.auth.apikey\n\n    template_url = base_url\n    if not template_url.endswith(\"/\"):\n        template_url += \"/\"\n\n    return render_template(\"index.html\", BAZARR_SERVER_INJECT=inject, baseUrl=template_url)\n\n\n@check_login\n@ui_bp.route('/bazarr.log')\ndef download_log():\n    return send_file(os.path.join(args.config_dir, 'log', 'bazarr.log'), max_age=0, as_attachment=True)\n\n\n@check_login\n@ui_bp.route('/images/series/<path:url>', methods=['GET'])\ndef series_images(url):\n    url = url.strip(\"/\")\n    apikey = settings.sonarr.apikey\n    baseUrl = settings.sonarr.base_url\n    if get_sonarr_info.is_legacy():\n        url_image = (url_sonarr() + '/api/' + url.lstrip(baseUrl) + '?apikey=' +\n                     apikey).replace('poster-250', 'poster-500')\n    else:\n        url_image = (url_sonarr() + '/api/v3/' + url.lstrip(baseUrl) + '?apikey=' +\n                     apikey).replace('poster-250', 'poster-500')\n    try:\n        req = requests.get(url_image, stream=True, timeout=15, verify=False, headers=headers)\n    except Exception:\n        return '', 404\n    else:\n        return Response(stream_with_context(req.iter_content(2048)), content_type=req.headers['content-type'])\n\n\n@check_login\n@ui_bp.route('/images/movies/<path:url>', methods=['GET'])\ndef movies_images(url):\n    apikey = settings.radarr.apikey\n    baseUrl = settings.radarr.base_url\n    if get_radarr_info.is_legacy():\n        url_image = url_radarr() + '/api/' + url.lstrip(baseUrl) + '?apikey=' + apikey\n    else:\n        url_image = url_radarr() + '/api/v3/' + url.lstrip(baseUrl) + '?apikey=' + apikey\n    try:\n        req = requests.get(url_image, stream=True, timeout=15, verify=False, headers=headers)\n    except Exception:\n        return '', 404\n    else:\n        return Response(stream_with_context(req.iter_content(2048)), content_type=req.headers['content-type'])\n\n\n@check_login\n@ui_bp.route('/system/backup/download/<path:filename>', methods=['GET'])\ndef backup_download(filename):\n    fullpath = os.path.normpath(os.path.join(settings.backup.folder, filename))\n    if not fullpath.startswith(settings.backup.folder):\n        return '', 404\n    else:\n        return send_file(fullpath, max_age=0, as_attachment=True)\n\n\n@ui_bp.route('/api/swaggerui/static/<path:filename>', methods=['GET'])\ndef swaggerui_static(filename):\n    basepath = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'libs', 'flask_restx',\n                            'static')\n    fullpath = os.path.join(basepath, filename)\n    if not fullpath.startswith(basepath):\n        return '', 404\n    else:\n        return send_file(fullpath)\n\n\ndef configured():\n    System.update({System.configured: '1'}).execute()\n\n\n@check_login\n@ui_bp.route('/test', methods=['GET'])\n@ui_bp.route('/test/<protocol>/<path:url>', methods=['GET'])\ndef proxy(protocol, url):\n    if protocol.lower not in ['http', 'https']:\n        return dict(status=False, error='Unsupported protocol')\n    url = protocol + '://' + unquote(url)\n    params = request.args\n    try:\n        result = requests.get(url, params, allow_redirects=False, verify=False, timeout=5, headers=headers)\n    except Exception as e:\n        return dict(status=False, error=repr(e))\n    else:\n        if result.status_code == 200:\n            try:\n                version = result.json()['version']\n                return dict(status=True, version=version)\n            except Exception:\n                return dict(status=False, error='Error Occurred. Check your settings.')\n        elif result.status_code == 401:\n            return dict(status=False, error='Access Denied. Check API key.')\n        elif result.status_code == 404:\n            return dict(status=False, error='Cannot get version. Maybe unsupported legacy API call?')\n        elif 300 <= result.status_code <= 399:\n            return dict(status=False, error='Wrong URL Base.')\n        else:\n            return dict(status=False, error=result.raise_for_status())\n"], "filenames": ["bazarr/app/ui.py"], "buggy_code_start_loc": [146], "buggy_code_end_loc": [162], "fixing_code_start_loc": [146], "fixing_code_end_loc": [174], "type": "CWE-918", "message": "Bazarr manages and downloads subtitles. In version 1.2.4, the proxy method in bazarr/bazarr/app/ui.py does not validate the user-controlled protocol and url variables and passes them to requests.get() without any sanitization, which leads to a blind server-side request forgery (SSRF). This issue allows for crafting GET requests to internal and external resources on behalf of the server. 1.3.1 contains a partial fix, which limits the vulnerability to HTTP/HTTPS protocols.", "other": {"cve": {"id": "CVE-2023-50266", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-15T21:15:09.147", "lastModified": "2023-12-19T20:38:21.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Bazarr manages and downloads subtitles. In version 1.2.4, the proxy method in bazarr/bazarr/app/ui.py does not validate the user-controlled protocol and url variables and passes them to requests.get() without any sanitization, which leads to a blind server-side request forgery (SSRF). This issue allows for crafting GET requests to internal and external resources on behalf of the server. 1.3.1 contains a partial fix, which limits the vulnerability to HTTP/HTTPS protocols."}, {"lang": "es", "value": "Bazarr gestiona y descarga subt\u00edtulos. En la versi\u00f3n 1.2.4, el m\u00e9todo proxy en bazarr/bazarr/app/ui.py no valida el protocolo controlado por el usuario y las variables de URL y las pasa a request.get() sin ninguna sanitizaci\u00f3n, lo que conduce a blind server-side request forgery (SSRF). Este problema permite elaborar solicitudes GET a recursos internos y externos en nombre del servidor. 1.3.1 contiene una soluci\u00f3n parcial que limita la vulnerabilidad a los protocolos HTTP/HTTPS."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bazarr:bazarr:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "D263E03A-1B55-46E6-A55C-9B9EC77AA07E"}]}]}], "references": [{"url": "https://github.com/morpheus65535/bazarr/commit/17add7fbb3ae1919a40d505470d499d46df9ae6b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/morpheus65535/bazarr/releases/tag/v1.3.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2023-192_GHSL-2023-194_bazarr/", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/morpheus65535/bazarr/commit/17add7fbb3ae1919a40d505470d499d46df9ae6b"}}