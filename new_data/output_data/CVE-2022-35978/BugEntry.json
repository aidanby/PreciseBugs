{"buggy_code": ["/*\nMinetest\nCopyright (C) 2013 PilzAdam <pilzadam@minetest.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation; either version 2.1 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc.,\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"lua_api/l_settings.h\"\n#include \"lua_api/l_internal.h\"\n#include \"cpp_api/s_security.h\"\n#include \"threading/mutex_auto_lock.h\"\n#include \"util/string.h\" // FlagDesc\n#include \"settings.h\"\n#include \"noise.h\"\n#include \"log.h\"\n\n\n/* This protects:\n * 'secure.*' settings from being set\n * some mapgen settings from being set\n *   (not security-criticial, just to avoid messing up user configs)\n */\n#define CHECK_SETTING_SECURITY(L, name) \\\n\tif (o->m_settings == g_settings) { \\\n\t\tif (checkSettingSecurity(L, name) == -1) \\\n\t\t\treturn 0; \\\n\t}\n\nstatic inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempt to set secure setting.\");\n\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nLuaSettings::LuaSettings(Settings *settings, const std::string &filename) :\n\tm_settings(settings),\n\tm_filename(filename)\n{\n}\n\nLuaSettings::LuaSettings(const std::string &filename, bool write_allowed) :\n\tm_filename(filename),\n\tm_is_own_settings(true),\n\tm_write_allowed(write_allowed)\n{\n\tm_settings = new Settings();\n\tm_settings->readConfigFile(filename.c_str());\n}\n\nLuaSettings::~LuaSettings()\n{\n\tif (m_is_own_settings)\n\t\tdelete m_settings;\n}\n\n\nvoid LuaSettings::create(lua_State *L, Settings *settings,\n\t\tconst std::string &filename)\n{\n\tLuaSettings *o = new LuaSettings(settings, filename);\n\t*(void **)(lua_newuserdata(L, sizeof(void *))) = o;\n\tluaL_getmetatable(L, className);\n\tlua_setmetatable(L, -2);\n}\n\n\n// garbage collector\nint LuaSettings::gc_object(lua_State* L)\n{\n\tLuaSettings* o = *(LuaSettings **)(lua_touserdata(L, 1));\n\tdelete o;\n\treturn 0;\n}\n\n\n// get(self, key) -> value\nint LuaSettings::l_get(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tif (o->m_settings->exists(key)) {\n\t\tstd::string value = o->m_settings->get(key);\n\t\tlua_pushstring(L, value.c_str());\n\t} else {\n\t\tlua_pushnil(L);\n\t}\n\n\treturn 1;\n}\n\n// get_bool(self, key) -> boolean\nint LuaSettings::l_get_bool(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tif (o->m_settings->exists(key)) {\n\t\tbool value = o->m_settings->getBool(key);\n\t\tlua_pushboolean(L, value);\n\t} else {\n\t\t// Push default value\n\t\tif (lua_isboolean(L, 3))\n\t\t\tlua_pushboolean(L, readParam<bool>(L, 3));\n\t\telse\n\t\t\tlua_pushnil(L);\n\t}\n\n\treturn 1;\n}\n\n// get_np_group(self, key) -> value\nint LuaSettings::l_get_np_group(lua_State *L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings *o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tif (o->m_settings->exists(key)) {\n\t\tNoiseParams np;\n\t\to->m_settings->getNoiseParams(key, np);\n\t\tpush_noiseparams(L, &np);\n\t} else {\n\t\tlua_pushnil(L);\n\t}\n\n\treturn 1;\n}\n\n// get_flags(self, key) -> table or nil\nint LuaSettings::l_get_flags(lua_State *L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings *o = checkobject(L, 1);\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\n\tu32 flags = 0;\n\tauto flagdesc = o->m_settings->getFlagDescFallback(key);\n\tif (o->m_settings->getFlagStrNoEx(key, flags, flagdesc)) {\n\t\tlua_newtable(L);\n\t\tint table = lua_gettop(L);\n\t\tfor (size_t i = 0; flagdesc[i].name; ++i) {\n\t\t\tlua_pushboolean(L, flags & flagdesc[i].flag);\n\t\t\tlua_setfield(L, table, flagdesc[i].name);\n\t\t}\n\t\tlua_pushvalue(L, table);\n\t} else {\n\t\tlua_pushnil(L);\n\t}\n\n\treturn 1;\n}\n\n// set(self, key, value)\nint LuaSettings::l_set(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tconst char* value = luaL_checkstring(L, 3);\n\n\tCHECK_SETTING_SECURITY(L, key);\n\n\tif (!o->m_settings->set(key, value))\n\t\tthrow LuaError(\"Invalid sequence found in setting parameters\");\n\n\treturn 0;\n}\n\n// set_bool(self, key, value)\nint LuaSettings::l_set_bool(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tbool value = readParam<bool>(L, 3);\n\n\tCHECK_SETTING_SECURITY(L, key);\n\n\to->m_settings->setBool(key, value);\n\n\treturn 0;\n}\n\n// set_np_group(self, key, value)\nint LuaSettings::l_set_np_group(lua_State *L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings *o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tNoiseParams value;\n\tread_noiseparams(L, 3, &value);\n\n\tCHECK_SETTING_SECURITY(L, key);\n\n\to->m_settings->setNoiseParams(key, value);\n\n\treturn 0;\n}\n\n// remove(self, key) -> success\nint LuaSettings::l_remove(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\n\tCHECK_SETTING_SECURITY(L, key);\n\n\tbool success = o->m_settings->remove(key);\n\tlua_pushboolean(L, success);\n\n\treturn 1;\n}\n\n// get_names(self) -> {key1, ...}\nint LuaSettings::l_get_names(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::vector<std::string> keys = o->m_settings->getNames();\n\n\tlua_newtable(L);\n\tfor (unsigned int i=0; i < keys.size(); i++)\n\t{\n\t\tlua_pushstring(L, keys[i].c_str());\n\t\tlua_rawseti(L, -2, i + 1);\n\t}\n\n\treturn 1;\n}\n\n// write(self) -> success\nint LuaSettings::l_write(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tif (!o->m_write_allowed) {\n\t\tthrow LuaError(\"Settings: writing \" + o->m_filename +\n\t\t\t\t\" not allowed with mod security on.\");\n\t}\n\n\tbool success = o->m_settings->updateConfigFile(o->m_filename.c_str());\n\tlua_pushboolean(L, success);\n\n\treturn 1;\n}\n\nstatic void push_settings_table(lua_State *L, const Settings *settings)\n{\n\tstd::vector<std::string> keys = settings->getNames();\n\tlua_newtable(L);\n\tfor (const std::string &key : keys) {\n\t\tstd::string value;\n\t\tSettings *group = nullptr;\n\n\t\tif (settings->getNoEx(key, value)) {\n\t\t\tlua_pushstring(L, value.c_str());\n\t\t} else if (settings->getGroupNoEx(key, group)) {\n\t\t\t// Recursively push tables\n\t\t\tpush_settings_table(L, group);\n\t\t} else {\n\t\t\t// Impossible case (multithreading) due to MutexAutoLock\n\t\t\tcontinue;\n\t\t}\n\n\t\tlua_setfield(L, -2, key.c_str());\n\t}\n}\n\n// to_table(self) -> {[key1]=value1,...}\nint LuaSettings::l_to_table(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tMutexAutoLock(o->m_settings->m_mutex);\n\tpush_settings_table(L, o->m_settings);\n\treturn 1;\n}\n\n\nvoid LuaSettings::Register(lua_State* L)\n{\n\tlua_newtable(L);\n\tint methodtable = lua_gettop(L);\n\tluaL_newmetatable(L, className);\n\tint metatable = lua_gettop(L);\n\n\tlua_pushliteral(L, \"__metatable\");\n\tlua_pushvalue(L, methodtable);\n\tlua_settable(L, metatable);  // hide metatable from Lua getmetatable()\n\n\tlua_pushliteral(L, \"__index\");\n\tlua_pushvalue(L, methodtable);\n\tlua_settable(L, metatable);\n\n\tlua_pushliteral(L, \"__gc\");\n\tlua_pushcfunction(L, gc_object);\n\tlua_settable(L, metatable);\n\n\tlua_pop(L, 1);  // drop metatable\n\n\tluaL_register(L, nullptr, methods);  // fill methodtable\n\tlua_pop(L, 1);  // drop methodtable\n\n\t// Can be created from Lua (Settings(filename))\n\tlua_register(L, className, create_object);\n}\n\n// LuaSettings(filename)\n// Creates a LuaSettings and leaves it on top of the stack\nint LuaSettings::create_object(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tbool write_allowed = true;\n\tconst char* filename = luaL_checkstring(L, 1);\n\tCHECK_SECURE_PATH_POSSIBLE_WRITE(L, filename, &write_allowed);\n\tLuaSettings* o = new LuaSettings(filename, write_allowed);\n\t*(void **)(lua_newuserdata(L, sizeof(void *))) = o;\n\tluaL_getmetatable(L, className);\n\tlua_setmetatable(L, -2);\n\treturn 1;\n}\n\nLuaSettings* LuaSettings::checkobject(lua_State* L, int narg)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tluaL_checktype(L, narg, LUA_TUSERDATA);\n\tvoid *ud = luaL_checkudata(L, narg, className);\n\tif (!ud)\n\t\tluaL_typerror(L, narg, className);\n\treturn *(LuaSettings**) ud;  // unbox pointer\n}\n\nconst char LuaSettings::className[] = \"Settings\";\nconst luaL_Reg LuaSettings::methods[] = {\n\tluamethod(LuaSettings, get),\n\tluamethod(LuaSettings, get_bool),\n\tluamethod(LuaSettings, get_np_group),\n\tluamethod(LuaSettings, get_flags),\n\tluamethod(LuaSettings, set),\n\tluamethod(LuaSettings, set_bool),\n\tluamethod(LuaSettings, set_np_group),\n\tluamethod(LuaSettings, remove),\n\tluamethod(LuaSettings, get_names),\n\tluamethod(LuaSettings, write),\n\tluamethod(LuaSettings, to_table),\n\t{0,0}\n};\n"], "fixing_code": ["/*\nMinetest\nCopyright (C) 2013 PilzAdam <pilzadam@minetest.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation; either version 2.1 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc.,\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"lua_api/l_settings.h\"\n#include \"lua_api/l_internal.h\"\n#include \"cpp_api/s_security.h\"\n#include \"threading/mutex_auto_lock.h\"\n#include \"util/string.h\" // FlagDesc\n#include \"settings.h\"\n#include \"noise.h\"\n#include \"log.h\"\n\n\n/* This protects the following from being set:\n * 'secure.*' settings\n * some security-relevant settings\n *   (better solution pending)\n * some mapgen settings\n *   (not security-criticial, just to avoid messing up user configs)\n */\n#define CHECK_SETTING_SECURITY(L, name) \\\n\tif (o->m_settings == g_settings) { \\\n\t\tif (checkSettingSecurity(L, name) == -1) \\\n\t\t\treturn 0; \\\n\t}\n\nstatic inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempted to set secure setting.\");\n\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\n\tconst char *disallowed[] = {\n\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",\n\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",\n\t};\n\tif (!is_mainmenu) {\n\t\tfor (const char *name2 : disallowed) {\n\t\t\tif (name == name2)\n\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nLuaSettings::LuaSettings(Settings *settings, const std::string &filename) :\n\tm_settings(settings),\n\tm_filename(filename)\n{\n}\n\nLuaSettings::LuaSettings(const std::string &filename, bool write_allowed) :\n\tm_filename(filename),\n\tm_is_own_settings(true),\n\tm_write_allowed(write_allowed)\n{\n\tm_settings = new Settings();\n\tm_settings->readConfigFile(filename.c_str());\n}\n\nLuaSettings::~LuaSettings()\n{\n\tif (m_is_own_settings)\n\t\tdelete m_settings;\n}\n\n\nvoid LuaSettings::create(lua_State *L, Settings *settings,\n\t\tconst std::string &filename)\n{\n\tLuaSettings *o = new LuaSettings(settings, filename);\n\t*(void **)(lua_newuserdata(L, sizeof(void *))) = o;\n\tluaL_getmetatable(L, className);\n\tlua_setmetatable(L, -2);\n}\n\n\n// garbage collector\nint LuaSettings::gc_object(lua_State* L)\n{\n\tLuaSettings* o = *(LuaSettings **)(lua_touserdata(L, 1));\n\tdelete o;\n\treturn 0;\n}\n\n\n// get(self, key) -> value\nint LuaSettings::l_get(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tif (o->m_settings->exists(key)) {\n\t\tstd::string value = o->m_settings->get(key);\n\t\tlua_pushstring(L, value.c_str());\n\t} else {\n\t\tlua_pushnil(L);\n\t}\n\n\treturn 1;\n}\n\n// get_bool(self, key) -> boolean\nint LuaSettings::l_get_bool(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tif (o->m_settings->exists(key)) {\n\t\tbool value = o->m_settings->getBool(key);\n\t\tlua_pushboolean(L, value);\n\t} else {\n\t\t// Push default value\n\t\tif (lua_isboolean(L, 3))\n\t\t\tlua_pushboolean(L, readParam<bool>(L, 3));\n\t\telse\n\t\t\tlua_pushnil(L);\n\t}\n\n\treturn 1;\n}\n\n// get_np_group(self, key) -> value\nint LuaSettings::l_get_np_group(lua_State *L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings *o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tif (o->m_settings->exists(key)) {\n\t\tNoiseParams np;\n\t\to->m_settings->getNoiseParams(key, np);\n\t\tpush_noiseparams(L, &np);\n\t} else {\n\t\tlua_pushnil(L);\n\t}\n\n\treturn 1;\n}\n\n// get_flags(self, key) -> table or nil\nint LuaSettings::l_get_flags(lua_State *L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings *o = checkobject(L, 1);\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\n\tu32 flags = 0;\n\tauto flagdesc = o->m_settings->getFlagDescFallback(key);\n\tif (o->m_settings->getFlagStrNoEx(key, flags, flagdesc)) {\n\t\tlua_newtable(L);\n\t\tint table = lua_gettop(L);\n\t\tfor (size_t i = 0; flagdesc[i].name; ++i) {\n\t\t\tlua_pushboolean(L, flags & flagdesc[i].flag);\n\t\t\tlua_setfield(L, table, flagdesc[i].name);\n\t\t}\n\t\tlua_pushvalue(L, table);\n\t} else {\n\t\tlua_pushnil(L);\n\t}\n\n\treturn 1;\n}\n\n// set(self, key, value)\nint LuaSettings::l_set(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tconst char* value = luaL_checkstring(L, 3);\n\n\tCHECK_SETTING_SECURITY(L, key);\n\n\tif (!o->m_settings->set(key, value))\n\t\tthrow LuaError(\"Invalid sequence found in setting parameters\");\n\n\treturn 0;\n}\n\n// set_bool(self, key, value)\nint LuaSettings::l_set_bool(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tbool value = readParam<bool>(L, 3);\n\n\tCHECK_SETTING_SECURITY(L, key);\n\n\to->m_settings->setBool(key, value);\n\n\treturn 0;\n}\n\n// set_np_group(self, key, value)\nint LuaSettings::l_set_np_group(lua_State *L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings *o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\tNoiseParams value;\n\tread_noiseparams(L, 3, &value);\n\n\tCHECK_SETTING_SECURITY(L, key);\n\n\to->m_settings->setNoiseParams(key, value);\n\n\treturn 0;\n}\n\n// remove(self, key) -> success\nint LuaSettings::l_remove(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::string key = std::string(luaL_checkstring(L, 2));\n\n\tCHECK_SETTING_SECURITY(L, key);\n\n\tbool success = o->m_settings->remove(key);\n\tlua_pushboolean(L, success);\n\n\treturn 1;\n}\n\n// get_names(self) -> {key1, ...}\nint LuaSettings::l_get_names(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tstd::vector<std::string> keys = o->m_settings->getNames();\n\n\tlua_newtable(L);\n\tfor (unsigned int i=0; i < keys.size(); i++)\n\t{\n\t\tlua_pushstring(L, keys[i].c_str());\n\t\tlua_rawseti(L, -2, i + 1);\n\t}\n\n\treturn 1;\n}\n\n// write(self) -> success\nint LuaSettings::l_write(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tif (!o->m_write_allowed) {\n\t\tthrow LuaError(\"Settings: writing \" + o->m_filename +\n\t\t\t\t\" not allowed with mod security on.\");\n\t}\n\n\tbool success = o->m_settings->updateConfigFile(o->m_filename.c_str());\n\tlua_pushboolean(L, success);\n\n\treturn 1;\n}\n\nstatic void push_settings_table(lua_State *L, const Settings *settings)\n{\n\tstd::vector<std::string> keys = settings->getNames();\n\tlua_newtable(L);\n\tfor (const std::string &key : keys) {\n\t\tstd::string value;\n\t\tSettings *group = nullptr;\n\n\t\tif (settings->getNoEx(key, value)) {\n\t\t\tlua_pushstring(L, value.c_str());\n\t\t} else if (settings->getGroupNoEx(key, group)) {\n\t\t\t// Recursively push tables\n\t\t\tpush_settings_table(L, group);\n\t\t} else {\n\t\t\t// Impossible case (multithreading) due to MutexAutoLock\n\t\t\tcontinue;\n\t\t}\n\n\t\tlua_setfield(L, -2, key.c_str());\n\t}\n}\n\n// to_table(self) -> {[key1]=value1,...}\nint LuaSettings::l_to_table(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\n\tMutexAutoLock(o->m_settings->m_mutex);\n\tpush_settings_table(L, o->m_settings);\n\treturn 1;\n}\n\n\nvoid LuaSettings::Register(lua_State* L)\n{\n\tlua_newtable(L);\n\tint methodtable = lua_gettop(L);\n\tluaL_newmetatable(L, className);\n\tint metatable = lua_gettop(L);\n\n\tlua_pushliteral(L, \"__metatable\");\n\tlua_pushvalue(L, methodtable);\n\tlua_settable(L, metatable);  // hide metatable from Lua getmetatable()\n\n\tlua_pushliteral(L, \"__index\");\n\tlua_pushvalue(L, methodtable);\n\tlua_settable(L, metatable);\n\n\tlua_pushliteral(L, \"__gc\");\n\tlua_pushcfunction(L, gc_object);\n\tlua_settable(L, metatable);\n\n\tlua_pop(L, 1);  // drop metatable\n\n\tluaL_register(L, nullptr, methods);  // fill methodtable\n\tlua_pop(L, 1);  // drop methodtable\n\n\t// Can be created from Lua (Settings(filename))\n\tlua_register(L, className, create_object);\n}\n\n// LuaSettings(filename)\n// Creates a LuaSettings and leaves it on top of the stack\nint LuaSettings::create_object(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tbool write_allowed = true;\n\tconst char* filename = luaL_checkstring(L, 1);\n\tCHECK_SECURE_PATH_POSSIBLE_WRITE(L, filename, &write_allowed);\n\tLuaSettings* o = new LuaSettings(filename, write_allowed);\n\t*(void **)(lua_newuserdata(L, sizeof(void *))) = o;\n\tluaL_getmetatable(L, className);\n\tlua_setmetatable(L, -2);\n\treturn 1;\n}\n\nLuaSettings* LuaSettings::checkobject(lua_State* L, int narg)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tluaL_checktype(L, narg, LUA_TUSERDATA);\n\tvoid *ud = luaL_checkudata(L, narg, className);\n\tif (!ud)\n\t\tluaL_typerror(L, narg, className);\n\treturn *(LuaSettings**) ud;  // unbox pointer\n}\n\nconst char LuaSettings::className[] = \"Settings\";\nconst luaL_Reg LuaSettings::methods[] = {\n\tluamethod(LuaSettings, get),\n\tluamethod(LuaSettings, get_bool),\n\tluamethod(LuaSettings, get_np_group),\n\tluamethod(LuaSettings, get_flags),\n\tluamethod(LuaSettings, set),\n\tluamethod(LuaSettings, set_bool),\n\tluamethod(LuaSettings, set_np_group),\n\tluamethod(LuaSettings, remove),\n\tluamethod(LuaSettings, get_names),\n\tluamethod(LuaSettings, write),\n\tluamethod(LuaSettings, to_table),\n\t{0,0}\n};\n"], "filenames": ["src/script/lua_api/l_settings.cpp"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [54], "fixing_code_start_loc": [30], "fixing_code_end_loc": [68], "type": "NVD-CWE-noinfo", "message": "Minetest is a free open-source voxel game engine with easy modding and game creation. In **single player**, a mod can set a global setting that controls the Lua script loaded to display the main menu. The script is then loaded as soon as the game session is exited. The Lua environment the menu runs in is not sandboxed and can directly interfere with the user's system. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-35978", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-15T19:15:08.890", "lastModified": "2022-08-17T14:16:24.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Minetest is a free open-source voxel game engine with easy modding and game creation. In **single player**, a mod can set a global setting that controls the Lua script loaded to display the main menu. The script is then loaded as soon as the game session is exited. The Lua environment the menu runs in is not sandboxed and can directly interfere with the user's system. There are currently no known workarounds."}, {"lang": "es", "value": "Minetest es un motor de juegos voxel de c\u00f3digo abierto que permite modificar y crear juegos f\u00e1cilmente. En **single player**, un mod puede establecer una configuraci\u00f3n global que controla el script Lua cargado para mostrar el men\u00fa principal. El script es cargado en cuanto sale de la sesi\u00f3n de juego. El entorno Lua en el que es ejecutado el men\u00fa no est\u00e1 aislado y puede interferir directamente con el sistema del usuario. Actualmente no se presentan mitigaciones conocidas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.3}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-693"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minetest:minetest:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.0", "matchCriteriaId": "433136C9-13AD-4E1A-AC0E-47402B44EE79"}]}]}], "references": [{"url": "https://dev.minetest.net/Changelog#5.5.0_.E2.86.92_5.6.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/minetest/minetest/commit/da71e86633d0b27cd02d7aac9fdac625d141ca13", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minetest/minetest/security/advisories/GHSA-663q-pcjw-27cc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minetest/minetest/commit/da71e86633d0b27cd02d7aac9fdac625d141ca13"}}