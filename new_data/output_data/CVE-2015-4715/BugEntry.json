{"buggy_code": ["<?php\n\n/**\n * Dropbox OAuth\n * \n * @package Dropbox \n * @copyright Copyright (C) 2011 Daniel Huesken\n * @author Daniel Huesken (http://www.danielhuesken.de/)\n * @license MIT\n */\n\n/**\n * This class is used to sign all requests to dropbox.\n *\n * This specific class uses WordPress WP_Http to authenticate.\n */\nclass Dropbox_OAuth_Curl extends Dropbox_OAuth {\n\n    /**\n     *\n     * @var string ConsumerKey\n     */\n    protected $consumerKey = null;\n    /**\n     *\n     * @var string ConsumerSecret\n     */\n    protected $consumerSecret = null;\n    /**\n     *\n     * @var string ProzessCallBack\n     */\n    public $ProgressFunction = false;\n\t\n    /**\n     * Constructor\n     * \n     * @param string $consumerKey \n     * @param string $consumerSecret \n     */\n    public function __construct($consumerKey, $consumerSecret) {\n        if (!function_exists('curl_exec')) \n            throw new Dropbox_Exception('The PHP curl functions not available!');\n\n        $this->consumerKey = $consumerKey;\n        $this->consumerSecret = $consumerSecret;\n    }\n\n    /**\n     * Fetches a secured oauth url and returns the response body. \n     * \n     * @param string $uri \n     * @param mixed $arguments \n     * @param string $method \n     * @param array $httpHeaders \n     * @return string \n     */\n    public function fetch($uri, $arguments = array(), $method = 'GET', $httpHeaders = array()) {\n\t\t\n\t\t$uri=str_replace('http://', 'https://', $uri); // all https, upload makes problems if not\n\t\tif (is_string($arguments) and strtoupper($method) == 'POST') {\n\t\t    preg_match(\"/\\?file=(.*)$/i\", $uri, $matches);\n\t\t\tif (isset($matches[1])) {\n                $uri = str_replace($matches[0], \"\", $uri);\n                $filename = $matches[1];\n\t\t\t\t$httpHeaders=array_merge($httpHeaders,$this->getOAuthHeader($uri, array(\"file\" => $filename), $method));\n            }\n\t\t} else {\n\t\t\t$httpHeaders=array_merge($httpHeaders,$this->getOAuthHeader($uri, $arguments, $method));\n\t\t}\n\t\t$ch = curl_init();\t\n\t\tif (strtoupper($method) == 'POST') {\n\t\t\tcurl_setopt($ch, CURLOPT_URL, $uri);\n\t\t\tcurl_setopt($ch, CURLOPT_POST, true);\n// \t\t\tif (is_array($arguments))\n// \t\t\t\t$arguments=http_build_query($arguments);\n\t\t\tcurl_setopt($ch, CURLOPT_POSTFIELDS, $arguments);\n// \t\t\t$httpHeaders['Content-Length']=strlen($arguments);\n\t\t} else {\n\t\t\tcurl_setopt($ch, CURLOPT_URL, $uri.'?'.http_build_query($arguments));\n\t\t\tcurl_setopt($ch, CURLOPT_POST, false);\n\t\t}\n\t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\t\tcurl_setopt($ch, CURLOPT_TIMEOUT, 300);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n//         curl_setopt($ch, CURLOPT_CAINFO, \"rootca\");\n\t\tcurl_setopt($ch, CURLOPT_FRESH_CONNECT, true);\n\t\t//Build header\n\t\t$headers = array();\n\t\tforeach ($httpHeaders as $name => $value) {\n\t\t\t$headers[] = \"{$name}: $value\";\n\t\t}\n\t\tcurl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\t\tif (!ini_get('safe_mode') && !ini_get('open_basedir'))\n\t\t\tcurl_setopt($ch, CURLOPT_FOLLOWLOCATION, true );\n\t\tif (function_exists($this->ProgressFunction) and defined('CURLOPT_PROGRESSFUNCTION')) {\n\t\t\tcurl_setopt($ch, CURLOPT_NOPROGRESS, false);\n\t\t\tcurl_setopt($ch, CURLOPT_PROGRESSFUNCTION, $this->ProgressFunction);\n\t\t\tcurl_setopt($ch, CURLOPT_BUFFERSIZE, 512);\n\t\t}\n\t\t$response=curl_exec($ch);\n\t\t$errorno=curl_errno($ch);\n\t\t$error=curl_error($ch);\n\t\t$status=curl_getinfo($ch,CURLINFO_HTTP_CODE);\n\t\tcurl_close($ch);\n\t\t\n\t\t\n\t\tif (!empty($errorno))\n\t\t\tthrow new Dropbox_Exception_NotFound('Curl error: ('.$errorno.') '.$error.\"\\n\");\n\t\t\t\t\t\t\n\t\tif ($status>=300) {\n\t\t\t$body = json_decode($response,true);\n\t\t\tswitch ($status) {\n\t\t\t\t// Not modified\n\t\t\t\tcase 304 :\n\t\t\t\t\treturn array(\n\t\t\t\t\t\t'httpStatus' => 304,\n\t\t\t\t\t\t'body' => null,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 403 :\n\t\t\t\t\tthrow new Dropbox_Exception_Forbidden('Forbidden.\n\t\t\t\t\t\tThis could mean a bad OAuth request, or a file or folder already existing at the target location.\n\t\t\t\t\t\t' . $body[\"error\"] . \"\\n\");\n\t\t\t\tcase 404 :\n\t\t\t\t\tthrow new Dropbox_Exception_NotFound('Resource at uri: ' . $uri . ' could not be found. ' .\n\t\t\t\t\t\t\t$body[\"error\"] . \"\\n\");\n\t\t\t\tcase 507 :\n\t\t\t\t\tthrow new Dropbox_Exception_OverQuota('This dropbox is full. ' .\n\t\t\t\t\t\t\t$body[\"error\"] . \"\\n\");\n\t\t\t}\n\t\t\tif (!empty($body[\"error\"]))\n\t\t\t\tthrow new Dropbox_Exception_RequestToken('Error: ('.$status.') '.$body[\"error\"].\"\\n\");\t\n\t\t}\n\n\t\treturn array(\n\t\t\t'body' => $response,\n            'httpStatus' => $status\n        );\n    }\n\n    /**\n     * Returns named array with oauth parameters for further use\n     * @return array Array with oauth_ parameters\n     */\n    private function getOAuthBaseParams() {\n        $params['oauth_version'] = '1.0';\n        $params['oauth_signature_method'] = 'HMAC-SHA1';\n\n        $params['oauth_consumer_key'] = $this->consumerKey;\n        $tokens = $this->getToken();\n        if (isset($tokens['token']) && $tokens['token']) {\n            $params['oauth_token'] = $tokens['token'];\n        }\n        $params['oauth_timestamp'] = time();\n        $params['oauth_nonce'] = md5(microtime() . mt_rand());\n        return $params;\n    }\n\n    /**\n     * Creates valid Authorization header for OAuth, based on URI and Params\n     *\n     * @param string $uri\n     * @param array $params\n     * @param string $method GET or POST, standard is GET\n     * @param array $oAuthParams optional, pass your own oauth_params here\n     * @return array Array for request's headers section like\n     * array('Authorization' => 'OAuth ...');\n     */\n    private function getOAuthHeader($uri, $params, $method = 'GET', $oAuthParams = null) {\n        $oAuthParams = $oAuthParams ? $oAuthParams : $this->getOAuthBaseParams();\n\n        // create baseString to encode for the sent parameters\n        $baseString = $method . '&';\n        $baseString .= $this->oauth_urlencode($uri) . \"&\";\n\n        // OAuth header does not include GET-Parameters\n        $signatureParams = array_merge($params, $oAuthParams);\n\n        // sorting the parameters\n        ksort($signatureParams);\n\n        $encodedParams = array();\n        foreach ($signatureParams as $key => $value) {\n            $encodedParams[] = $this->oauth_urlencode($key) . '=' . $this->oauth_urlencode($value);\n        }\n\n        $baseString .= $this->oauth_urlencode(implode('&', $encodedParams));\n\n        // encode the signature\n        $tokens = $this->getToken();\n        $hash = $this->hash_hmac_sha1($this->consumerSecret.'&'.$tokens['token_secret'], $baseString);\n        $signature = base64_encode($hash);\n\n        // add signature to oAuthParams\n        $oAuthParams['oauth_signature'] = $signature;\n\n        $oAuthEncoded = array();\n        foreach ($oAuthParams as $key => $value) {\n            $oAuthEncoded[] = $key . '=\"' . $this->oauth_urlencode($value) . '\"';\n        }\n\n        return array('Authorization' => 'OAuth ' . implode(', ', $oAuthEncoded));\n    }\n\n    /**\n     * Requests the OAuth request token.\n     *\n     * @return void \n     */\n    public function getRequestToken() {\n        $result = $this->fetch(self::URI_REQUEST_TOKEN, array(), 'POST');\n        if ($result['httpStatus'] == \"200\") {\n            $tokens = array();\n            parse_str($result['body'], $tokens);\n            $this->setToken($tokens['oauth_token'], $tokens['oauth_token_secret']);\n            return $this->getToken();\n        } else {\n            throw new Dropbox_Exception_RequestToken('We were unable to fetch request tokens. This likely means that your consumer key and/or secret are incorrect.');\n        }\n    }\n\n    /**\n     * Requests the OAuth access tokens.\n     *\n     * This method requires the 'unauthorized' request tokens\n     * and, if successful will set the authorized request tokens.\n     * \n     * @return void \n     */\n    public function getAccessToken() {\n        $result = $this->fetch(self::URI_ACCESS_TOKEN, array(), 'POST');\n        if ($result['httpStatus'] == \"200\") {\n            $tokens = array();\n            parse_str($result['body'], $tokens);\n            $this->setToken($tokens['oauth_token'], $tokens['oauth_token_secret']);\n            return $this->getToken();\n        } else {\n            throw new Dropbox_Exception_RequestToken('We were unable to fetch request tokens. This likely means that your consumer key and/or secret are incorrect.');\n        }\n    }\n\n    /**\n     * Helper function to properly urlencode parameters.\n     * See http://php.net/manual/en/function.oauth-urlencode.php\n     *\n     * @param string $string\n     * @return string\n     */\n    private function oauth_urlencode($string) {\n        return str_replace('%E7', '~', rawurlencode($string));\n    }\n\n    /**\n     * Hash function for hmac_sha1; uses native function if available.\n     *\n     * @param string $key\n     * @param string $data\n     * @return string\n     */\n    private function hash_hmac_sha1($key, $data) {\n        if (function_exists('hash_hmac') && in_array('sha1', hash_algos())) {\n            return hash_hmac('sha1', $data, $key, true);\n        } else {\n            $blocksize = 64;\n            $hashfunc = 'sha1';\n            if (strlen($key) > $blocksize) {\n                $key = pack('H*', $hashfunc($key));\n            }\n\n            $key = str_pad($key, $blocksize, chr(0x00));\n            $ipad = str_repeat(chr(0x36), $blocksize);\n            $opad = str_repeat(chr(0x5c), $blocksize);\n            $hash = pack('H*', $hashfunc(( $key ^ $opad ) . pack('H*', $hashfunc(($key ^ $ipad) . $data))));\n\n            return $hash;\n        }\n    }\n\t\n\n}"], "fixing_code": ["<?php\n\n/**\n * Dropbox OAuth\n * \n * @package Dropbox \n * @copyright Copyright (C) 2011 Daniel Huesken\n * @author Daniel Huesken (http://www.danielhuesken.de/)\n * @license MIT\n */\n\n/**\n * This class is used to sign all requests to dropbox.\n *\n * This specific class uses WordPress WP_Http to authenticate.\n */\nclass Dropbox_OAuth_Curl extends Dropbox_OAuth {\n\n    /**\n     *\n     * @var string ConsumerKey\n     */\n    protected $consumerKey = null;\n    /**\n     *\n     * @var string ConsumerSecret\n     */\n    protected $consumerSecret = null;\n    /**\n     *\n     * @var string ProzessCallBack\n     */\n    public $ProgressFunction = false;\n\t\n    /**\n     * Constructor\n     * \n     * @param string $consumerKey \n     * @param string $consumerSecret \n     */\n    public function __construct($consumerKey, $consumerSecret) {\n        if (!function_exists('curl_exec')) \n            throw new Dropbox_Exception('The PHP curl functions not available!');\n\n        $this->consumerKey = $consumerKey;\n        $this->consumerSecret = $consumerSecret;\n    }\n\n    /**\n     * Fetches a secured oauth url and returns the response body. \n     * \n     * @param string $uri \n     * @param mixed $arguments \n     * @param string $method \n     * @param array $httpHeaders \n     * @return string \n     */\n    public function fetch($uri, $arguments = array(), $method = 'GET', $httpHeaders = array()) {\n\t\t\n\t\t$uri=str_replace('http://', 'https://', $uri); // all https, upload makes problems if not\n\t\tif (is_string($arguments) and strtoupper($method) == 'POST') {\n\t\t    preg_match(\"/\\?file=(.*)$/i\", $uri, $matches);\n\t\t\tif (isset($matches[1])) {\n                $uri = str_replace($matches[0], \"\", $uri);\n                $filename = $matches[1];\n\t\t\t\t$httpHeaders=array_merge($httpHeaders,$this->getOAuthHeader($uri, array(\"file\" => $filename), $method));\n            }\n\t\t} else {\n\t\t\t$httpHeaders=array_merge($httpHeaders,$this->getOAuthHeader($uri, $arguments, $method));\n\t\t}\n\t\t$ch = curl_init();\t\n\t\tif (strtoupper($method) == 'POST') {\n\t\t\tcurl_setopt($ch, CURLOPT_URL, $uri);\n\t\t\tcurl_setopt($ch, CURLOPT_POST, true);\n\n \t\t\t//if (is_array($arguments))\n \t\t\t//\t$arguments=http_build_query($arguments);\n \t\t\tforeach ($arguments as $key => $value) {\n \t\t\t\tif($value[0] === '@') {\n\t\t\t\t\texit();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurl_setopt($ch, CURLOPT_POSTFIELDS, $arguments);\n// \t\t\t$httpHeaders['Content-Length']=strlen($arguments);\n\t\t} else {\n\t\t\tcurl_setopt($ch, CURLOPT_URL, $uri.'?'.http_build_query($arguments));\n\t\t\tcurl_setopt($ch, CURLOPT_POST, false);\n\t\t}\n\t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n\t\tcurl_setopt($ch, CURLOPT_TIMEOUT, 300);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);\n//         curl_setopt($ch, CURLOPT_CAINFO, \"rootca\");\n\t\tcurl_setopt($ch, CURLOPT_FRESH_CONNECT, true);\n\t\t//Build header\n\t\t$headers = array();\n\t\tforeach ($httpHeaders as $name => $value) {\n\t\t\t$headers[] = \"{$name}: $value\";\n\t\t}\n\t\tcurl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n\t\tif (!ini_get('safe_mode') && !ini_get('open_basedir'))\n\t\t\tcurl_setopt($ch, CURLOPT_FOLLOWLOCATION, true );\n\t\tif (function_exists($this->ProgressFunction) and defined('CURLOPT_PROGRESSFUNCTION')) {\n\t\t\tcurl_setopt($ch, CURLOPT_NOPROGRESS, false);\n\t\t\tcurl_setopt($ch, CURLOPT_PROGRESSFUNCTION, $this->ProgressFunction);\n\t\t\tcurl_setopt($ch, CURLOPT_BUFFERSIZE, 512);\n\t\t}\n\t\t$response=curl_exec($ch);\n\t\t$errorno=curl_errno($ch);\n\t\t$error=curl_error($ch);\n\t\t$status=curl_getinfo($ch,CURLINFO_HTTP_CODE);\n\t\tcurl_close($ch);\n\t\t\n\t\t\n\t\tif (!empty($errorno))\n\t\t\tthrow new Dropbox_Exception_NotFound('Curl error: ('.$errorno.') '.$error.\"\\n\");\n\t\t\t\t\t\t\n\t\tif ($status>=300) {\n\t\t\t$body = json_decode($response,true);\n\t\t\tswitch ($status) {\n\t\t\t\t// Not modified\n\t\t\t\tcase 304 :\n\t\t\t\t\treturn array(\n\t\t\t\t\t\t'httpStatus' => 304,\n\t\t\t\t\t\t'body' => null,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 403 :\n\t\t\t\t\tthrow new Dropbox_Exception_Forbidden('Forbidden.\n\t\t\t\t\t\tThis could mean a bad OAuth request, or a file or folder already existing at the target location.\n\t\t\t\t\t\t' . $body[\"error\"] . \"\\n\");\n\t\t\t\tcase 404 :\n\t\t\t\t\tthrow new Dropbox_Exception_NotFound('Resource at uri: ' . $uri . ' could not be found. ' .\n\t\t\t\t\t\t\t$body[\"error\"] . \"\\n\");\n\t\t\t\tcase 507 :\n\t\t\t\t\tthrow new Dropbox_Exception_OverQuota('This dropbox is full. ' .\n\t\t\t\t\t\t\t$body[\"error\"] . \"\\n\");\n\t\t\t}\n\t\t\tif (!empty($body[\"error\"]))\n\t\t\t\tthrow new Dropbox_Exception_RequestToken('Error: ('.$status.') '.$body[\"error\"].\"\\n\");\t\n\t\t}\n\n\t\treturn array(\n\t\t\t'body' => $response,\n            'httpStatus' => $status\n        );\n    }\n\n    /**\n     * Returns named array with oauth parameters for further use\n     * @return array Array with oauth_ parameters\n     */\n    private function getOAuthBaseParams() {\n        $params['oauth_version'] = '1.0';\n        $params['oauth_signature_method'] = 'HMAC-SHA1';\n\n        $params['oauth_consumer_key'] = $this->consumerKey;\n        $tokens = $this->getToken();\n        if (isset($tokens['token']) && $tokens['token']) {\n            $params['oauth_token'] = $tokens['token'];\n        }\n        $params['oauth_timestamp'] = time();\n        $params['oauth_nonce'] = md5(microtime() . mt_rand());\n        return $params;\n    }\n\n    /**\n     * Creates valid Authorization header for OAuth, based on URI and Params\n     *\n     * @param string $uri\n     * @param array $params\n     * @param string $method GET or POST, standard is GET\n     * @param array $oAuthParams optional, pass your own oauth_params here\n     * @return array Array for request's headers section like\n     * array('Authorization' => 'OAuth ...');\n     */\n    private function getOAuthHeader($uri, $params, $method = 'GET', $oAuthParams = null) {\n        $oAuthParams = $oAuthParams ? $oAuthParams : $this->getOAuthBaseParams();\n\n        // create baseString to encode for the sent parameters\n        $baseString = $method . '&';\n        $baseString .= $this->oauth_urlencode($uri) . \"&\";\n\n        // OAuth header does not include GET-Parameters\n        $signatureParams = array_merge($params, $oAuthParams);\n\n        // sorting the parameters\n        ksort($signatureParams);\n\n        $encodedParams = array();\n        foreach ($signatureParams as $key => $value) {\n            $encodedParams[] = $this->oauth_urlencode($key) . '=' . $this->oauth_urlencode($value);\n        }\n\n        $baseString .= $this->oauth_urlencode(implode('&', $encodedParams));\n\n        // encode the signature\n        $tokens = $this->getToken();\n        $hash = $this->hash_hmac_sha1($this->consumerSecret.'&'.$tokens['token_secret'], $baseString);\n        $signature = base64_encode($hash);\n\n        // add signature to oAuthParams\n        $oAuthParams['oauth_signature'] = $signature;\n\n        $oAuthEncoded = array();\n        foreach ($oAuthParams as $key => $value) {\n            $oAuthEncoded[] = $key . '=\"' . $this->oauth_urlencode($value) . '\"';\n        }\n\n        return array('Authorization' => 'OAuth ' . implode(', ', $oAuthEncoded));\n    }\n\n    /**\n     * Requests the OAuth request token.\n     *\n     * @return void \n     */\n    public function getRequestToken() {\n        $result = $this->fetch(self::URI_REQUEST_TOKEN, array(), 'POST');\n        if ($result['httpStatus'] == \"200\") {\n            $tokens = array();\n            parse_str($result['body'], $tokens);\n            $this->setToken($tokens['oauth_token'], $tokens['oauth_token_secret']);\n            return $this->getToken();\n        } else {\n            throw new Dropbox_Exception_RequestToken('We were unable to fetch request tokens. This likely means that your consumer key and/or secret are incorrect.');\n        }\n    }\n\n    /**\n     * Requests the OAuth access tokens.\n     *\n     * This method requires the 'unauthorized' request tokens\n     * and, if successful will set the authorized request tokens.\n     * \n     * @return void \n     */\n    public function getAccessToken() {\n        $result = $this->fetch(self::URI_ACCESS_TOKEN, array(), 'POST');\n        if ($result['httpStatus'] == \"200\") {\n            $tokens = array();\n            parse_str($result['body'], $tokens);\n            $this->setToken($tokens['oauth_token'], $tokens['oauth_token_secret']);\n            return $this->getToken();\n        } else {\n            throw new Dropbox_Exception_RequestToken('We were unable to fetch request tokens. This likely means that your consumer key and/or secret are incorrect.');\n        }\n    }\n\n    /**\n     * Helper function to properly urlencode parameters.\n     * See http://php.net/manual/en/function.oauth-urlencode.php\n     *\n     * @param string $string\n     * @return string\n     */\n    private function oauth_urlencode($string) {\n        return str_replace('%E7', '~', rawurlencode($string));\n    }\n\n    /**\n     * Hash function for hmac_sha1; uses native function if available.\n     *\n     * @param string $key\n     * @param string $data\n     * @return string\n     */\n    private function hash_hmac_sha1($key, $data) {\n        if (function_exists('hash_hmac') && in_array('sha1', hash_algos())) {\n            return hash_hmac('sha1', $data, $key, true);\n        } else {\n            $blocksize = 64;\n            $hashfunc = 'sha1';\n            if (strlen($key) > $blocksize) {\n                $key = pack('H*', $hashfunc($key));\n            }\n\n            $key = str_pad($key, $blocksize, chr(0x00));\n            $ipad = str_repeat(chr(0x36), $blocksize);\n            $opad = str_repeat(chr(0x5c), $blocksize);\n            $hash = pack('H*', $hashfunc(( $key ^ $opad ) . pack('H*', $hashfunc(($key ^ $ipad) . $data))));\n\n            return $hash;\n        }\n    }\n\t\n\n}"], "filenames": ["apps/files_external/3rdparty/Dropbox/OAuth/Curl.php"], "buggy_code_start_loc": [75], "buggy_code_end_loc": [77], "fixing_code_start_loc": [75], "fixing_code_end_loc": [83], "type": "CWE-552", "message": "The fetch function in OAuth/Curl.php in Dropbox-PHP, as used in ownCloud Server before 6.0.8, 7.x before 7.0.6, and 8.x before 8.0.4 when an external Dropbox storage has been mounted, allows remote administrators of Dropbox.com to read arbitrary files via an @ (at sign) character in unspecified POST values.", "other": {"cve": {"id": "CVE-2015-4715", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-17T19:15:11.227", "lastModified": "2020-02-28T19:31:11.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The fetch function in OAuth/Curl.php in Dropbox-PHP, as used in ownCloud Server before 6.0.8, 7.x before 7.0.6, and 8.x before 8.0.4 when an external Dropbox storage has been mounted, allows remote administrators of Dropbox.com to read arbitrary files via an @ (at sign) character in unspecified POST values."}, {"lang": "es", "value": "La funci\u00f3n fetch en el archivo OAuth/Curl.php en Dropbox-PHP, como es usado en ownCloud Server versiones anteriores a 6.0.8, versiones 7.x anteriores a 7.0.6 y versiones 8.x anteriores a 8.0.4, cuando un almacenamiento externo de Dropbox ha sido montado, permite a administradores remotos de Dropbox.com leer archivos arbitrarios por medio de un car\u00e1cter @ (en el signo) en valores POST no especificados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.0.8", "matchCriteriaId": "4F5036FE-87F4-4F7C-BDD7-D17ACEC309FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.6", "matchCriteriaId": "643EF10C-CEDD-4E4C-989F-9EBCD1464BAE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.0.4", "matchCriteriaId": "2ED7A074-1669-4F4E-A299-9B9A76734B72"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/76158", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/owncloud/core/commit/bf0f1a50926a75a26a42a3da4d62e84a489ee77a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://owncloud.org/security/advisories/mounted-dropbox-storage-allows-dropbox-com-access-file/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://owncloud.org/security/advisory/?id=oc-sa-2015-005", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/owncloud/core/commit/bf0f1a50926a75a26a42a3da4d62e84a489ee77a"}}