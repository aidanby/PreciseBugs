{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\EventListener;\n\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent;\nuse Symfony\\Component\\Security\\Http\\Session\\SessionAuthenticationStrategy;\nuse Symfony\\Component\\Security\\Http\\Session\\SessionAuthenticationStrategyInterface;\n\n/**\n * Migrates/invalidates the session after successful login.\n *\n * This should be registered as subscriber to any \"stateful\" firewalls.\n *\n * @see SessionAuthenticationStrategy\n *\n * @author Wouter de Jong <wouter@wouterj.nl>\n */\nclass SessionStrategyListener implements EventSubscriberInterface\n{\n    private $sessionAuthenticationStrategy;\n\n    public function __construct(SessionAuthenticationStrategyInterface $sessionAuthenticationStrategy)\n    {\n        $this->sessionAuthenticationStrategy = $sessionAuthenticationStrategy;\n    }\n\n    public function onSuccessfulLogin(LoginSuccessEvent $event): void\n    {\n        $request = $event->getRequest();\n        $token = $event->getAuthenticatedToken();\n\n        if (!$request->hasSession() || !$request->hasPreviousSession()) {\n            return;\n        }\n\n        if ($previousToken = $event->getPreviousToken()) {\n            // @deprecated since Symfony 5.3, change to $token->getUserIdentifier() in 6.0\n            $user = method_exists($token, 'getUserIdentifier') ? $token->getUserIdentifier() : $token->getUsername();\n            $previousUser = method_exists($previousToken, 'getUserIdentifier') ? $previousToken->getUserIdentifier() : $previousToken->getUsername();\n\n            if ('' !== ($user ?? '') && $user === $previousUser) {\n                return;\n            }\n        }\n\n        $this->sessionAuthenticationStrategy->onAuthentication($request, $token);\n    }\n\n    public static function getSubscribedEvents(): array\n    {\n        return [LoginSuccessEvent::class => 'onSuccessfulLogin'];\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Tests\\EventListener;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\NullToken;\nuse Symfony\\Component\\Security\\Core\\User\\InMemoryUser;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\AuthenticatorInterface;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\UserBadge;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\SelfValidatingPassport;\nuse Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent;\nuse Symfony\\Component\\Security\\Http\\EventListener\\SessionStrategyListener;\nuse Symfony\\Component\\Security\\Http\\Session\\SessionAuthenticationStrategyInterface;\n\nclass SessionStrategyListenerTest extends TestCase\n{\n    private $sessionAuthenticationStrategy;\n    private $listener;\n    private $request;\n    private $token;\n\n    protected function setUp(): void\n    {\n        $this->sessionAuthenticationStrategy = $this->createMock(SessionAuthenticationStrategyInterface::class);\n        $this->listener = new SessionStrategyListener($this->sessionAuthenticationStrategy);\n        $this->request = new Request();\n        $this->token = $this->createMock(NullToken::class);\n    }\n\n    public function testRequestWithSession()\n    {\n        $this->configurePreviousSession();\n\n        $this->sessionAuthenticationStrategy->expects($this->once())->method('onAuthentication')->with($this->request, $this->token);\n\n        $this->listener->onSuccessfulLogin($this->createEvent('main_firewall'));\n    }\n\n    public function testRequestWithoutPreviousSession()\n    {\n        $this->sessionAuthenticationStrategy->expects($this->never())->method('onAuthentication')->with($this->request, $this->token);\n\n        $this->listener->onSuccessfulLogin($this->createEvent('main_firewall'));\n    }\n\n    public function testStatelessFirewalls()\n    {\n        $this->sessionAuthenticationStrategy->expects($this->never())->method('onAuthentication');\n\n        $listener = new SessionStrategyListener($this->sessionAuthenticationStrategy, ['api_firewall']);\n        $listener->onSuccessfulLogin($this->createEvent('api_firewall'));\n    }\n\n    public function testRequestWithSamePreviousUser()\n    {\n        $this->configurePreviousSession();\n        $this->sessionAuthenticationStrategy->expects($this->never())->method('onAuthentication');\n\n        $token = $this->createMock(NullToken::class);\n        $token->expects($this->once())\n            ->method('getUserIdentifier')\n            ->willReturn('test');\n        $previousToken = $this->createMock(NullToken::class);\n        $previousToken->expects($this->once())\n            ->method('getUserIdentifier')\n            ->willReturn('test');\n\n        $event = new LoginSuccessEvent($this->createMock(AuthenticatorInterface::class), new SelfValidatingPassport(new UserBadge('test', function () {})), $token, $this->request, null, 'main_firewall', $previousToken);\n\n        $this->listener->onSuccessfulLogin($event);\n    }\n\n    private function createEvent($firewallName)\n    {\n        return new LoginSuccessEvent($this->createMock(AuthenticatorInterface::class), new SelfValidatingPassport(new UserBadge('test', function ($username) { return new InMemoryUser($username, null); })), $this->token, $this->request, null, $firewallName);\n    }\n\n    private function configurePreviousSession()\n    {\n        $session = $this->createMock(SessionInterface::class);\n        $session->expects($this->any())\n            ->method('getName')\n            ->willReturn('test_session_name');\n        $this->request->setSession($session);\n        $this->request->cookies->set('test_session_name', 'session_cookie_val');\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\EventListener;\n\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent;\nuse Symfony\\Component\\Security\\Http\\Session\\SessionAuthenticationStrategy;\nuse Symfony\\Component\\Security\\Http\\Session\\SessionAuthenticationStrategyInterface;\n\n/**\n * Migrates/invalidates the session after successful login.\n *\n * This should be registered as subscriber to any \"stateful\" firewalls.\n *\n * @see SessionAuthenticationStrategy\n *\n * @author Wouter de Jong <wouter@wouterj.nl>\n */\nclass SessionStrategyListener implements EventSubscriberInterface\n{\n    private $sessionAuthenticationStrategy;\n\n    public function __construct(SessionAuthenticationStrategyInterface $sessionAuthenticationStrategy)\n    {\n        $this->sessionAuthenticationStrategy = $sessionAuthenticationStrategy;\n    }\n\n    public function onSuccessfulLogin(LoginSuccessEvent $event): void\n    {\n        $request = $event->getRequest();\n        $token = $event->getAuthenticatedToken();\n\n        if (!$request->hasSession() || !$request->hasPreviousSession()) {\n            return;\n        }\n\n        if ($previousToken = $event->getPreviousToken()) {\n            // @deprecated since Symfony 5.3, change to $token->getUserIdentifier() in 6.0\n            $user = method_exists($token, 'getUserIdentifier') ? $token->getUserIdentifier() : $token->getUsername();\n            $previousUser = method_exists($previousToken, 'getUserIdentifier') ? $previousToken->getUserIdentifier() : $previousToken->getUsername();\n\n            if ('' !== ($user ?? '') && $user === $previousUser && \\get_class($token) === \\get_class($previousToken)) {\n                return;\n            }\n        }\n\n        $this->sessionAuthenticationStrategy->onAuthentication($request, $token);\n    }\n\n    public static function getSubscribedEvents(): array\n    {\n        return [LoginSuccessEvent::class => 'onSuccessfulLogin'];\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Tests\\EventListener;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\NullToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken;\nuse Symfony\\Component\\Security\\Core\\User\\InMemoryUser;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\AuthenticatorInterface;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\UserBadge;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\SelfValidatingPassport;\nuse Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent;\nuse Symfony\\Component\\Security\\Http\\EventListener\\SessionStrategyListener;\nuse Symfony\\Component\\Security\\Http\\Session\\SessionAuthenticationStrategyInterface;\n\nclass SessionStrategyListenerTest extends TestCase\n{\n    private $sessionAuthenticationStrategy;\n    private $listener;\n    private $request;\n    private $token;\n\n    protected function setUp(): void\n    {\n        $this->sessionAuthenticationStrategy = $this->createMock(SessionAuthenticationStrategyInterface::class);\n        $this->listener = new SessionStrategyListener($this->sessionAuthenticationStrategy);\n        $this->request = new Request();\n        $this->token = $this->createMock(NullToken::class);\n    }\n\n    public function testRequestWithSession()\n    {\n        $this->configurePreviousSession();\n\n        $this->sessionAuthenticationStrategy->expects($this->once())->method('onAuthentication')->with($this->request, $this->token);\n\n        $this->listener->onSuccessfulLogin($this->createEvent('main_firewall'));\n    }\n\n    public function testRequestWithoutPreviousSession()\n    {\n        $this->sessionAuthenticationStrategy->expects($this->never())->method('onAuthentication')->with($this->request, $this->token);\n\n        $this->listener->onSuccessfulLogin($this->createEvent('main_firewall'));\n    }\n\n    public function testStatelessFirewalls()\n    {\n        $this->sessionAuthenticationStrategy->expects($this->never())->method('onAuthentication');\n\n        $listener = new SessionStrategyListener($this->sessionAuthenticationStrategy, ['api_firewall']);\n        $listener->onSuccessfulLogin($this->createEvent('api_firewall'));\n    }\n\n    public function testRequestWithSamePreviousUser()\n    {\n        $this->configurePreviousSession();\n        $this->sessionAuthenticationStrategy->expects($this->never())->method('onAuthentication');\n\n        $token = $this->createMock(NullToken::class);\n        $token->expects($this->once())\n            ->method('getUserIdentifier')\n            ->willReturn('test');\n        $previousToken = $this->createMock(NullToken::class);\n        $previousToken->expects($this->once())\n            ->method('getUserIdentifier')\n            ->willReturn('test');\n\n        $event = new LoginSuccessEvent($this->createMock(AuthenticatorInterface::class), new SelfValidatingPassport(new UserBadge('test', function () {})), $token, $this->request, null, 'main_firewall', $previousToken);\n\n        $this->listener->onSuccessfulLogin($event);\n    }\n\n    public function testRequestWithSamePreviousUserButDifferentTokenType()\n    {\n        $this->configurePreviousSession();\n\n        $token = $this->createMock(NullToken::class);\n        $token->expects($this->once())\n            ->method('getUserIdentifier')\n            ->willReturn('test');\n        $previousToken = $this->createMock(UsernamePasswordToken::class);\n        $previousToken->expects($this->once())\n            ->method('getUserIdentifier')\n            ->willReturn('test');\n\n        $this->sessionAuthenticationStrategy->expects($this->once())->method('onAuthentication')->with($this->request, $token);\n\n        $event = new LoginSuccessEvent($this->createMock(AuthenticatorInterface::class), new SelfValidatingPassport(new UserBadge('test', function () {})), $token, $this->request, null, 'main_firewall', $previousToken);\n\n        $this->listener->onSuccessfulLogin($event);\n    }\n\n    private function createEvent($firewallName)\n    {\n        return new LoginSuccessEvent($this->createMock(AuthenticatorInterface::class), new SelfValidatingPassport(new UserBadge('test', function ($username) { return new InMemoryUser($username, null); })), $this->token, $this->request, null, $firewallName);\n    }\n\n    private function configurePreviousSession()\n    {\n        $session = $this->createMock(SessionInterface::class);\n        $session->expects($this->any())\n            ->method('getName')\n            ->willReturn('test_session_name');\n        $this->request->setSession($session);\n        $this->request->cookies->set('test_session_name', 'session_cookie_val');\n    }\n}\n"], "filenames": ["src/Symfony/Component/Security/Http/EventListener/SessionStrategyListener.php", "src/Symfony/Component/Security/Http/Tests/EventListener/SessionStrategyListenerTest.php"], "buggy_code_start_loc": [51, 17], "buggy_code_end_loc": [52, 83], "fixing_code_start_loc": [51, 18], "fixing_code_end_loc": [52, 105], "type": "CWE-384", "message": "Symfony is a PHP framework for web and console applications and a set of reusable PHP components. Starting in versions 5.4.21 and 6.2.7 and prior to versions 5.4.31 and 6.3.8, `SessionStrategyListener` does not migrate the session after every successful login. It does so only in case the logged in user changes by means of checking the user identifier. In some use cases, the user identifier doesn't change between the verification phase and the successful login, while the token itself changes from one type (partially-authenticated) to another (fully-authenticated). When this happens, the session id should be regenerated to prevent possible session fixations, which is not the case at the moment. As of versions 5.4.31 and 6.3.8, Symfony now checks the type of the token in addition to the user identifier before deciding whether the session id should be regenerated.", "other": {"cve": {"id": "CVE-2023-46733", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-10T18:15:09.050", "lastModified": "2023-11-16T23:57:53.847", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Symfony is a PHP framework for web and console applications and a set of reusable PHP components. Starting in versions 5.4.21 and 6.2.7 and prior to versions 5.4.31 and 6.3.8, `SessionStrategyListener` does not migrate the session after every successful login. It does so only in case the logged in user changes by means of checking the user identifier. In some use cases, the user identifier doesn't change between the verification phase and the successful login, while the token itself changes from one type (partially-authenticated) to another (fully-authenticated). When this happens, the session id should be regenerated to prevent possible session fixations, which is not the case at the moment. As of versions 5.4.31 and 6.3.8, Symfony now checks the type of the token in addition to the user identifier before deciding whether the session id should be regenerated."}, {"lang": "es", "value": "Symfony es un framework PHP para aplicaciones web y de consola y un conjunto de componentes PHP reutilizables. A partir de las versiones 5.4.21 y 6.2.7 y anteriores a las versiones 5.4.31 y 6.3.8, `SessionStrategyListener` no migra la sesi\u00f3n despu\u00e9s de cada inicio de sesi\u00f3n exitoso. Lo hace s\u00f3lo en caso de que el usuario que ha iniciado sesi\u00f3n cambie mediante la verificaci\u00f3n del identificador de usuario. En algunos casos de uso, el identificador de usuario no cambia entre la fase de verificaci\u00f3n y el inicio de sesi\u00f3n exitoso, mientras que el token en s\u00ed cambia de un tipo (parcialmente autenticado) a otro (totalmente autenticado). Cuando esto sucede, se debe regenerar la identificaci\u00f3n de la sesi\u00f3n para evitar posibles arreglos de sesi\u00f3n, lo cual no es el caso en este momento. A partir de las versiones 5.4.31 y 6.3.8, Symfony ahora verifica el tipo de token adem\u00e1s del identificador de usuario antes de decidir si se debe regenerar la identificaci\u00f3n de la sesi\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.21", "versionEndExcluding": "5.4.31", "matchCriteriaId": "534C2D1B-53F9-4E99-9ED7-F31EC02435F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.7", "versionEndExcluding": "6.3.8", "matchCriteriaId": "CE64BA2A-1A7B-478E-958F-D952826345D6"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/7467bd7e3f888b333102bc664b5e02ef1e7f88b9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/symfony/symfony/commit/dc356499d5ceb86f7cf2b4c7f032eca97061ed74", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/symfony/symfony/security/advisories/GHSA-m2wj-r6g3-fxfx", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/7467bd7e3f888b333102bc664b5e02ef1e7f88b9"}}