{"buggy_code": ["module Gibbon\n  class APIRequest\n    include Helpers\n\n    def initialize(builder: nil)\n      @request_builder = builder\n    end\n\n    def post(params: nil, headers: nil, body: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.post do |request|\n          configure_request(request: request, params: params, headers: headers, body: MultiJson.dump(body))\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    def patch(params: nil, headers: nil, body: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.patch do |request|\n          configure_request(request: request, params: params, headers: headers, body: MultiJson.dump(body))\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    def put(params: nil, headers: nil, body: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.put do |request|\n          configure_request(request: request, params: params, headers: headers, body: MultiJson.dump(body))\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    def get(params: nil, headers: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.get do |request|\n          configure_request(request: request, params: params, headers: headers)\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    def delete(params: nil, headers: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.delete do |request|\n          configure_request(request: request, params: params, headers: headers)\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    protected\n\n    # Convenience accessors\n\n    def api_key\n      @request_builder.api_key\n    end\n\n    def api_endpoint\n      @request_builder.api_endpoint\n    end\n\n    def timeout\n      @request_builder.timeout\n    end\n\n    def open_timeout\n      @request_builder.open_timeout\n    end\n\n    def proxy\n      @request_builder.proxy\n    end\n\n    def adapter\n      @request_builder.faraday_adapter\n    end\n\n    def symbolize_keys\n      @request_builder.symbolize_keys\n    end\n\n    # Helpers\n\n    def handle_error(error)\n      error_params = {}\n\n      begin\n        if (error.is_a?(Faraday::ClientError) || error.is_a?(Faraday::ServerError)) && error.response\n          error_params[:status_code] = error.response[:status]\n          error_params[:raw_body] = error.response[:body]\n\n          parsed_response = MultiJson.load(error.response[:body], symbolize_keys: symbolize_keys)\n\n          if parsed_response\n            error_params[:body] = parsed_response\n\n            title_key = symbolize_keys ? :title : \"title\"\n            detail_key = symbolize_keys ? :detail : \"detail\"\n\n            error_params[:title] = parsed_response[title_key] if parsed_response[title_key]\n            error_params[:detail] = parsed_response[detail_key] if parsed_response[detail_key]\n          end\n\n        end\n      rescue MultiJson::ParseError\n      end\n\n      error_to_raise = MailChimpError.new(error.message, error_params)\n\n      raise error_to_raise\n    end\n\n    def configure_request(request: nil, params: nil, headers: nil, body: nil)\n      if request\n        request.params.merge!(params) if params\n        request.headers['Content-Type'] = 'application/json'\n        request.headers.merge!(headers) if headers\n        request.body = body if body\n        request.options.timeout = self.timeout\n        request.options.open_timeout = self.open_timeout\n      end\n    end\n\n    def rest_client\n      client = Faraday.new(self.api_url, proxy: self.proxy, ssl: { version: \"TLSv1_2\" }) do |faraday|\n        faraday.response :raise_error\n        faraday.adapter adapter\n        if @request_builder.debug\n          faraday.response :logger, @request_builder.logger, bodies: true\n        end\n\n        if Faraday::VERSION.to_i >= 2\n          faraday.request :authorization, :basic, 'apikey', self.api_key\n        else\n          faraday.request :basic_auth, 'apikey', self.api_key\n        end\n      end\n\n      client\n    end\n\n    def parse_response(response)\n      parsed_response = nil\n\n      if response.body && !response.body.empty?\n        begin\n          headers = response.headers\n          body = MultiJson.load(response.body, symbolize_keys: symbolize_keys)\n          parsed_response = Response.new(headers: headers, body: body)\n        rescue MultiJson::ParseError\n          error_params = { title: \"UNPARSEABLE_RESPONSE\", status_code: 500 }\n          error = MailChimpError.new(\"Unparseable response: #{response.body}\", error_params)\n          raise error\n        end\n      end\n\n      parsed_response\n    end\n\n    def validate_api_key\n      api_key = self.api_key\n      unless api_key && (api_key[\"-\"] || self.api_endpoint)\n        raise Gibbon::GibbonError, \"You must set an api_key prior to making a call\"\n      end\n    end\n\n    def api_url\n      base_api_url + @request_builder.path\n    end\n\n    def base_api_url\n      computed_api_endpoint = \"https://#{get_data_center_from_api_key(self.api_key)}api.mailchimp.com\"\n      \"#{self.api_endpoint || computed_api_endpoint}/3.0/\"\n    end\n  end\nend\n", "require 'spec_helper'\nrequire 'cgi'\n\ndescribe Gibbon do\n  describe \"attributes\" do\n    before do\n      Gibbon::APIRequest.send(:public, *Gibbon::APIRequest.protected_instance_methods)\n\n      @api_key = \"123-us1\"\n      @proxy = 'the_proxy'\n    end\n\n    it \"have no API by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.api_key).to be_nil\n    end\n    it \"sets an API key in the constructor\" do\n      @gibbon = Gibbon::Request.new(api_key: @api_key)\n      expect(@gibbon.api_key).to eq(@api_key)\n    end\n\n    it \"sets an API key from the 'MAILCHIMP_API_KEY' ENV variable\" do\n      ENV['MAILCHIMP_API_KEY'] = @api_key\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.api_key).to eq(@api_key)\n      ENV.delete('MAILCHIMP_API_KEY')\n    end\n\n    it \"sets an API key via setter\" do\n      @gibbon = Gibbon::Request.new\n      @gibbon.api_key = @api_key\n      expect(@gibbon.api_key).to eq(@api_key)\n    end\n\n    it \"sets timeout and get\" do\n      @gibbon = Gibbon::Request.new\n      timeout = 30\n      @gibbon.timeout = timeout\n      expect(timeout).to eq(@gibbon.timeout)\n    end\n\n    it \"sets the open_timeout and get\" do\n      @gibbon = Gibbon::Request.new\n      open_timeout = 30\n      @gibbon.open_timeout = open_timeout\n      expect(open_timeout).to eq(@gibbon.open_timeout)\n    end\n\n    it \"timeout properly passed to APIRequest\" do\n      @gibbon = Gibbon::Request.new\n      timeout = 30\n      @gibbon.timeout = timeout\n      @request = Gibbon::APIRequest.new(builder: @gibbon)\n      expect(timeout).to eq(@request.timeout)\n    end\n\n    it \"timeout properly based on open_timeout passed to APIRequest\" do\n      @gibbon = Gibbon::Request.new\n      open_timeout = 30\n      @gibbon.open_timeout = open_timeout\n      @request = Gibbon::APIRequest.new(builder: @gibbon)\n      expect(open_timeout).to eq(@request.open_timeout)\n    end\n\n    it \"detect api endpoint from initializer parameters\" do\n      api_endpoint = 'https://us6.api.mailchimp.com'\n      @gibbon = Gibbon::Request.new(api_key: @api_key, api_endpoint: api_endpoint)\n      expect(api_endpoint).to eq(@gibbon.api_endpoint)\n    end\n\n    it \"has no Proxy url by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.proxy).to be_nil\n    end\n\n    it \"sets a proxy url key from the 'MAILCHIMP_PROXY' ENV variable\" do\n      ENV['MAILCHIMP_PROXY'] = @proxy\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.proxy).to eq(@proxy)\n      ENV.delete('MAILCHIMP_PROXY')\n    end\n\n    it \"sets an API key via setter\" do\n      @gibbon = Gibbon::Request.new\n      @gibbon.proxy = @proxy\n      expect(@gibbon.proxy).to eq(@proxy)\n    end\n\n    it \"sets an adapter in the constructor\" do\n      adapter = :em_synchrony\n      @gibbon = Gibbon::Request.new(faraday_adapter: adapter)\n      expect(@gibbon.faraday_adapter).to eq(adapter)\n    end\n\n    it \"symbolize_keys false by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.symbolize_keys).to be false\n    end\n\n    it \"sets symbolize_keys in the constructor\" do\n      @gibbon = Gibbon::Request.new(symbolize_keys: true)\n      expect(@gibbon.symbolize_keys).to be true\n    end\n\n    it \"sets symbolize_keys in the constructor\" do\n      @gibbon = Gibbon::Request.new(symbolize_keys: true)\n      expect(@gibbon.symbolize_keys).to be true\n    end\n    it \"debug false by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.debug).to be false\n    end\n\n    it \"sets debug in the constructor\" do\n      @gibbon = Gibbon::Request.new(debug: true)\n      expect(@gibbon.debug).to be true\n    end\n\n    it \"sets logger in constructor\" do\n      logger = double(:logger)\n      @gibbon = Gibbon::Request.new(logger: logger)\n      expect(@gibbon.logger).to eq(logger)\n    end\n\n    it \"is a Logger instance by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.logger).to be_a Logger\n    end\n\n  end\n\n  describe \"build api url\" do\n    before do\n      Gibbon::APIRequest.send(:public, *Gibbon::APIRequest.protected_instance_methods)\n\n      @gibbon = Gibbon::Request.new\n    end\n\n    it \"doesn't allow empty api key\" do\n      expect {@gibbon.try.retrieve}.to raise_error(Gibbon::GibbonError)\n    end\n\n    it \"doesn't allow api key without data center\" do\n      @api_key = \"123\"\n      @gibbon.api_key = @api_key\n      expect {@gibbon.try.retrieve}.to raise_error(Gibbon::GibbonError)\n    end\n\n    it \"sets correct endpoint from api key\" do\n      @api_key = \"TESTKEY-us1\"\n      @gibbon.api_key = @api_key\n      @gibbon.try\n      @request = Gibbon::APIRequest.new(builder: @gibbon)\n      expect(@request.api_url).to eq(\"https://us1.api.mailchimp.com/3.0/try\")\n    end\n\n    # when the end user has signed in via oauth, api_key and endpoint it be supplied separately\n    it \"not require datacenter in api key\" do\n      @api_key = \"TESTKEY\"\n      @gibbon.api_key = @api_key\n      @gibbon.api_endpoint = \"https://us6.api.mailchimp.com\"\n      @request = Gibbon::APIRequest.new(builder: @gibbon)\n      expect {@request.validate_api_key}.not_to raise_error\n    end\n  end\n\n  describe \"class variables\" do\n    let(:logger) { double(:logger) }\n\n    before do\n      Gibbon::Request.api_key = \"123-us1\"\n      Gibbon::Request.timeout = 15\n      Gibbon::Request.api_endpoint = 'https://us6.api.mailchimp.com'\n      Gibbon::Request.logger = logger\n      Gibbon::Request.proxy = \"http://1234.com\"\n      Gibbon::Request.symbolize_keys = true\n      Gibbon::Request.faraday_adapter = :net_http\n      Gibbon::Request.debug = true\n    end\n\n    after do\n      Gibbon::Request.api_key = nil\n      Gibbon::Request.timeout = nil\n      Gibbon::Request.api_endpoint = nil\n      Gibbon::Request.logger = nil\n      Gibbon::Request.proxy = nil\n      Gibbon::Request.symbolize_keys = nil\n      Gibbon::Request.faraday_adapter = nil\n      Gibbon::Request.debug = nil\n    end\n\n    it \"set api key on new instances\" do\n      expect(Gibbon::Request.new.api_key).to eq(Gibbon::Request.api_key)\n    end\n\n    it \"set timeout on new instances\" do\n      expect(Gibbon::Request.new.timeout).to eq(Gibbon::Request.timeout)\n    end\n\n    it \"set api_endpoint on new instances\" do\n      expect(Gibbon::Request.api_endpoint).not_to be_nil\n      expect(Gibbon::Request.new.api_endpoint).to eq(Gibbon::Request.api_endpoint)\n    end\n\n    it \"set proxy on new instances\" do\n      expect(Gibbon::Request.new.proxy).to eq(Gibbon::Request.proxy)\n    end\n\n    it \"set symbolize_keys on new instances\" do\n      expect(Gibbon::Request.new.symbolize_keys).to eq(Gibbon::Request.symbolize_keys)\n    end\n\n    it \"set debug on new instances\" do\n      expect(Gibbon::Request.new.debug).to eq(Gibbon::Request.debug)\n    end\n    \n    it \"set faraday_adapter on new instances\" do\n      expect(Gibbon::Request.new.faraday_adapter).to eq(Gibbon::Request.faraday_adapter)\n    end\n\n    it \"set logger on new instances\" do\n      expect(Gibbon::Request.new.logger).to eq(logger)\n    end\n  end\n\n  describe \"missing methods\" do\n    it \"respond to .method call on class\" do\n      expect(Gibbon::Request.method(:lists)).to be_a(Method)\n    end\n    it \"respond to .method call on instance\" do\n      expect(Gibbon::Request.new.method(:lists)).to be_a(Method)\n    end\n  end\nend\n"], "fixing_code": ["module Gibbon\n  class APIRequest\n    include Helpers\n\n    def initialize(builder: nil)\n      @request_builder = builder\n    end\n\n    def post(params: nil, headers: nil, body: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.post do |request|\n          configure_request(request: request, params: params, headers: headers, body: MultiJson.dump(body))\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    def patch(params: nil, headers: nil, body: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.patch do |request|\n          configure_request(request: request, params: params, headers: headers, body: MultiJson.dump(body))\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    def put(params: nil, headers: nil, body: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.put do |request|\n          configure_request(request: request, params: params, headers: headers, body: MultiJson.dump(body))\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    def get(params: nil, headers: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.get do |request|\n          configure_request(request: request, params: params, headers: headers)\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    def delete(params: nil, headers: nil)\n      validate_api_key\n\n      begin\n        response = self.rest_client.delete do |request|\n          configure_request(request: request, params: params, headers: headers)\n        end\n        parse_response(response)\n      rescue => e\n        handle_error(e)\n      end\n    end\n\n    protected\n\n    # Convenience accessors\n\n    def api_key\n      @request_builder.api_key\n    end\n\n    def api_endpoint\n      @request_builder.api_endpoint\n    end\n\n    def timeout\n      @request_builder.timeout\n    end\n\n    def open_timeout\n      @request_builder.open_timeout\n    end\n\n    def proxy\n      @request_builder.proxy\n    end\n\n    def adapter\n      @request_builder.faraday_adapter\n    end\n\n    def symbolize_keys\n      @request_builder.symbolize_keys\n    end\n\n    # Helpers\n\n    def handle_error(error)\n      error_params = {}\n\n      begin\n        if (error.is_a?(Faraday::ClientError) || error.is_a?(Faraday::ServerError)) && error.response\n          error_params[:status_code] = error.response[:status]\n          error_params[:raw_body] = error.response[:body]\n\n          parsed_response = MultiJson.load(error.response[:body], symbolize_keys: symbolize_keys)\n\n          if parsed_response\n            error_params[:body] = parsed_response\n\n            title_key = symbolize_keys ? :title : \"title\"\n            detail_key = symbolize_keys ? :detail : \"detail\"\n\n            error_params[:title] = parsed_response[title_key] if parsed_response[title_key]\n            error_params[:detail] = parsed_response[detail_key] if parsed_response[detail_key]\n          end\n\n        end\n      rescue MultiJson::ParseError\n      end\n\n      error_to_raise = MailChimpError.new(error.message, error_params)\n\n      raise error_to_raise\n    end\n\n    def configure_request(request: nil, params: nil, headers: nil, body: nil)\n      if request\n        request.params.merge!(params) if params\n        request.headers['Content-Type'] = 'application/json'\n        request.headers.merge!(headers) if headers\n        request.body = body if body\n        request.options.timeout = self.timeout\n        request.options.open_timeout = self.open_timeout\n      end\n    end\n\n    def rest_client\n      client = Faraday.new(self.api_url, proxy: self.proxy, ssl: { version: \"TLSv1_2\" }) do |faraday|\n        faraday.response :raise_error\n        faraday.adapter adapter\n        if @request_builder.debug\n          faraday.response :logger, @request_builder.logger, bodies: true\n        end\n\n        if Faraday::VERSION.to_i >= 2\n          faraday.request :authorization, :basic, 'apikey', self.api_key\n        else\n          faraday.request :basic_auth, 'apikey', self.api_key\n        end\n      end\n\n      client\n    end\n\n    def parse_response(response)\n      parsed_response = nil\n\n      if response.body && !response.body.empty?\n        begin\n          headers = response.headers\n          body = MultiJson.load(response.body, symbolize_keys: symbolize_keys)\n          parsed_response = Response.new(headers: headers, body: body)\n        rescue MultiJson::ParseError\n          error_params = { title: \"UNPARSEABLE_RESPONSE\", status_code: 500 }\n          error = MailChimpError.new(\"Unparseable response: #{response.body}\", error_params)\n          raise error\n        end\n      end\n\n      parsed_response\n    end\n\n    def validate_api_key\n      api_key = self.api_key\n      unless api_key && (api_key[\"-\"] || self.api_endpoint)\n        raise Gibbon::GibbonError, \"You must set an api_key prior to making a call\"\n      end\n    end\n\n    def api_url\n      base_api_url + @request_builder.path\n    end\n\n    def base_api_url\n      computed_api_endpoint = \"https://#{get_data_center_from_api_key(self.api_key)}api.mailchimp.com\"\n      raise Gibbon::GibbonError, \"SSRF attempt\" unless URI(computed_api_endpoint).host.include?(\"api.mailchimp.com\")\n\n      \"#{self.api_endpoint || computed_api_endpoint}/3.0/\"\n    end\n  end\nend\n", "require 'spec_helper'\nrequire 'cgi'\n\ndescribe Gibbon do\n  describe \"attributes\" do\n    before do\n      Gibbon::APIRequest.send(:public, *Gibbon::APIRequest.protected_instance_methods)\n\n      @api_key = \"123-us1\"\n      @proxy = 'the_proxy'\n    end\n\n    it \"have no API by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.api_key).to be_nil\n    end\n    it \"sets an API key in the constructor\" do\n      @gibbon = Gibbon::Request.new(api_key: @api_key)\n      expect(@gibbon.api_key).to eq(@api_key)\n    end\n\n    it \"sets an API key from the 'MAILCHIMP_API_KEY' ENV variable\" do\n      ENV['MAILCHIMP_API_KEY'] = @api_key\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.api_key).to eq(@api_key)\n      ENV.delete('MAILCHIMP_API_KEY')\n    end\n\n    it \"sets an API key via setter\" do\n      @gibbon = Gibbon::Request.new\n      @gibbon.api_key = @api_key\n      expect(@gibbon.api_key).to eq(@api_key)\n    end\n\n    it \"sets timeout and get\" do\n      @gibbon = Gibbon::Request.new\n      timeout = 30\n      @gibbon.timeout = timeout\n      expect(timeout).to eq(@gibbon.timeout)\n    end\n\n    it \"sets the open_timeout and get\" do\n      @gibbon = Gibbon::Request.new\n      open_timeout = 30\n      @gibbon.open_timeout = open_timeout\n      expect(open_timeout).to eq(@gibbon.open_timeout)\n    end\n\n    it \"timeout properly passed to APIRequest\" do\n      @gibbon = Gibbon::Request.new\n      timeout = 30\n      @gibbon.timeout = timeout\n      @request = Gibbon::APIRequest.new(builder: @gibbon)\n      expect(timeout).to eq(@request.timeout)\n    end\n\n    it \"timeout properly based on open_timeout passed to APIRequest\" do\n      @gibbon = Gibbon::Request.new\n      open_timeout = 30\n      @gibbon.open_timeout = open_timeout\n      @request = Gibbon::APIRequest.new(builder: @gibbon)\n      expect(open_timeout).to eq(@request.open_timeout)\n    end\n\n    it \"detect api endpoint from initializer parameters\" do\n      api_endpoint = 'https://us6.api.mailchimp.com'\n      @gibbon = Gibbon::Request.new(api_key: @api_key, api_endpoint: api_endpoint)\n      expect(api_endpoint).to eq(@gibbon.api_endpoint)\n    end\n\n    it \"has no Proxy url by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.proxy).to be_nil\n    end\n\n    it \"sets a proxy url key from the 'MAILCHIMP_PROXY' ENV variable\" do\n      ENV['MAILCHIMP_PROXY'] = @proxy\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.proxy).to eq(@proxy)\n      ENV.delete('MAILCHIMP_PROXY')\n    end\n\n    it \"sets an API key via setter\" do\n      @gibbon = Gibbon::Request.new\n      @gibbon.proxy = @proxy\n      expect(@gibbon.proxy).to eq(@proxy)\n    end\n\n    it \"sets an adapter in the constructor\" do\n      adapter = :em_synchrony\n      @gibbon = Gibbon::Request.new(faraday_adapter: adapter)\n      expect(@gibbon.faraday_adapter).to eq(adapter)\n    end\n\n    it \"symbolize_keys false by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.symbolize_keys).to be false\n    end\n\n    it \"sets symbolize_keys in the constructor\" do\n      @gibbon = Gibbon::Request.new(symbolize_keys: true)\n      expect(@gibbon.symbolize_keys).to be true\n    end\n\n    it \"sets symbolize_keys in the constructor\" do\n      @gibbon = Gibbon::Request.new(symbolize_keys: true)\n      expect(@gibbon.symbolize_keys).to be true\n    end\n    it \"debug false by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.debug).to be false\n    end\n\n    it \"sets debug in the constructor\" do\n      @gibbon = Gibbon::Request.new(debug: true)\n      expect(@gibbon.debug).to be true\n    end\n\n    it \"sets logger in constructor\" do\n      logger = double(:logger)\n      @gibbon = Gibbon::Request.new(logger: logger)\n      expect(@gibbon.logger).to eq(logger)\n    end\n\n    it \"is a Logger instance by default\" do\n      @gibbon = Gibbon::Request.new\n      expect(@gibbon.logger).to be_a Logger\n    end\n\n  end\n\n  describe \"build api url\" do\n    before do\n      Gibbon::APIRequest.send(:public, *Gibbon::APIRequest.protected_instance_methods)\n\n      @gibbon = Gibbon::Request.new\n    end\n\n    it \"doesn't allow empty api key\" do\n      expect {@gibbon.try.retrieve}.to raise_error(Gibbon::GibbonError)\n    end\n\n    it \"doesn't allow api key without data center\" do\n      @api_key = \"123\"\n      @gibbon.api_key = @api_key\n      expect {@gibbon.try.retrieve}.to raise_error(Gibbon::GibbonError)\n    end\n\n    it \"sets correct endpoint from api key\" do\n      @api_key = \"TESTKEY-us1\"\n      @gibbon.api_key = @api_key\n      @gibbon.try\n      @request = Gibbon::APIRequest.new(builder: @gibbon)\n      expect(@request.api_url).to eq(\"https://us1.api.mailchimp.com/3.0/try\")\n    end\n\n    # when the end user has signed in via oauth, api_key and endpoint it be supplied separately\n    it \"not require datacenter in api key\" do\n      @api_key = \"TESTKEY\"\n      @gibbon.api_key = @api_key\n      @gibbon.api_endpoint = \"https://us6.api.mailchimp.com\"\n      @request = Gibbon::APIRequest.new(builder: @gibbon)\n      expect {@request.validate_api_key}.not_to raise_error\n    end\n\n    it \"raises with a valid SSRF attack\" do\n      @api_key = \"-attacker.net/test/?\"\n      @gibbon.api_key = @api_key\n      expect {@gibbon.try.retrieve}.not_to raise_error\n    end\n  end\n\n  describe \"class variables\" do\n    let(:logger) { double(:logger) }\n\n    before do\n      Gibbon::Request.api_key = \"123-us1\"\n      Gibbon::Request.timeout = 15\n      Gibbon::Request.api_endpoint = 'https://us6.api.mailchimp.com'\n      Gibbon::Request.logger = logger\n      Gibbon::Request.proxy = \"http://1234.com\"\n      Gibbon::Request.symbolize_keys = true\n      Gibbon::Request.faraday_adapter = :net_http\n      Gibbon::Request.debug = true\n    end\n\n    after do\n      Gibbon::Request.api_key = nil\n      Gibbon::Request.timeout = nil\n      Gibbon::Request.api_endpoint = nil\n      Gibbon::Request.logger = nil\n      Gibbon::Request.proxy = nil\n      Gibbon::Request.symbolize_keys = nil\n      Gibbon::Request.faraday_adapter = nil\n      Gibbon::Request.debug = nil\n    end\n\n    it \"set api key on new instances\" do\n      expect(Gibbon::Request.new.api_key).to eq(Gibbon::Request.api_key)\n    end\n\n    it \"set timeout on new instances\" do\n      expect(Gibbon::Request.new.timeout).to eq(Gibbon::Request.timeout)\n    end\n\n    it \"set api_endpoint on new instances\" do\n      expect(Gibbon::Request.api_endpoint).not_to be_nil\n      expect(Gibbon::Request.new.api_endpoint).to eq(Gibbon::Request.api_endpoint)\n    end\n\n    it \"set proxy on new instances\" do\n      expect(Gibbon::Request.new.proxy).to eq(Gibbon::Request.proxy)\n    end\n\n    it \"set symbolize_keys on new instances\" do\n      expect(Gibbon::Request.new.symbolize_keys).to eq(Gibbon::Request.symbolize_keys)\n    end\n\n    it \"set debug on new instances\" do\n      expect(Gibbon::Request.new.debug).to eq(Gibbon::Request.debug)\n    end\n\n    it \"set faraday_adapter on new instances\" do\n      expect(Gibbon::Request.new.faraday_adapter).to eq(Gibbon::Request.faraday_adapter)\n    end\n\n    it \"set logger on new instances\" do\n      expect(Gibbon::Request.new.logger).to eq(logger)\n    end\n  end\n\n  describe \"missing methods\" do\n    it \"respond to .method call on class\" do\n      expect(Gibbon::Request.method(:lists)).to be_a(Method)\n    end\n    it \"respond to .method call on instance\" do\n      expect(Gibbon::Request.new.method(:lists)).to be_a(Method)\n    end\n  end\nend\n"], "filenames": ["lib/gibbon/api_request.rb", "spec/gibbon/gibbon_spec.rb"], "buggy_code_start_loc": [196, 163], "buggy_code_end_loc": [196, 217], "fixing_code_start_loc": [197, 164], "fixing_code_end_loc": [199, 223], "type": "CWE-918", "message": "Gibbon v3.4.4 and below allows attackers to execute a Server-Side Request Forgery (SSRF) via a crafted URL.", "other": {"cve": {"id": "CVE-2022-27311", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-25T13:15:49.547", "lastModified": "2022-05-05T16:35:40.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Gibbon v3.4.4 and below allows attackers to execute a Server-Side Request Forgery (SSRF) via a crafted URL."}, {"lang": "es", "value": "Gibbon versiones v3.4.4 y posteriores, permiten a atacantes ejecutar un ataque de tipo Server-Side Request Forgery (SSRF) por medio de una URL dise\u00f1ada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gibbon_project:gibbon:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "3.4.4", "matchCriteriaId": "79884A6D-C8D5-4AC7-B361-D9C7868CCEC8"}]}]}], "references": [{"url": "https://github.com/amro/gibbon/commit/b2eb99ed304d7491a6d348a5bbdc83a008fc6e0b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/amro/gibbon/commit/cade20ca2438cd1b182dad70cbb77fb895779d10", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/amro/gibbon/pull/321", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/amro/gibbon/commit/b2eb99ed304d7491a6d348a5bbdc83a008fc6e0b"}}