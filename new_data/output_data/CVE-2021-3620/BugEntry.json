{"buggy_code": ["#\n# This code is part of Ansible, but is an independent component.\n# This particular file snippet, and this file snippet only, is BSD licensed.\n# Modules you write using this snippet, which is embedded dynamically by Ansible\n# still belong to the author of the module, and may assign their own license\n# to the complete work.\n#\n# (c) 2017 Red Hat Inc.\n#\n# Redistribution and use in source and binary forms, with or without modification,\n# are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright\n#      notice, this list of conditions and the following disclaimer.\n#    * Redistributions in binary form must reproduce the above copyright notice,\n#      this list of conditions and the following disclaimer in the documentation\n#      and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport hashlib\nimport json\nimport socket\nimport struct\nimport traceback\nimport uuid\n\nfrom functools import partial\nfrom ansible.module_utils._text import to_bytes, to_text\nfrom ansible.module_utils.common.json import AnsibleJSONEncoder\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.six.moves import cPickle\n\n\ndef write_to_file_descriptor(fd, obj):\n    \"\"\"Handles making sure all data is properly written to file descriptor fd.\n\n    In particular, that data is encoded in a character stream-friendly way and\n    that all data gets written before returning.\n    \"\"\"\n    # Need to force a protocol that is compatible with both py2 and py3.\n    # That would be protocol=2 or less.\n    # Also need to force a protocol that excludes certain control chars as\n    # stdin in this case is a pty and control chars will cause problems.\n    # that means only protocol=0 will work.\n    src = cPickle.dumps(obj, protocol=0)\n\n    # raw \\r characters will not survive pty round-trip\n    # They should be rehydrated on the receiving end\n    src = src.replace(b'\\r', br'\\r')\n    data_hash = to_bytes(hashlib.sha1(src).hexdigest())\n\n    os.write(fd, b'%d\\n' % len(src))\n    os.write(fd, src)\n    os.write(fd, b'%s\\n' % data_hash)\n\n\ndef send_data(s, data):\n    packed_len = struct.pack('!Q', len(data))\n    return s.sendall(packed_len + data)\n\n\ndef recv_data(s):\n    header_len = 8  # size of a packed unsigned long long\n    data = to_bytes(\"\")\n    while len(data) < header_len:\n        d = s.recv(header_len - len(data))\n        if not d:\n            return None\n        data += d\n    data_len = struct.unpack('!Q', data[:header_len])[0]\n    data = data[header_len:]\n    while len(data) < data_len:\n        d = s.recv(data_len - len(data))\n        if not d:\n            return None\n        data += d\n    return data\n\n\ndef exec_command(module, command):\n    connection = Connection(module._socket_path)\n    try:\n        out = connection.exec_command(command)\n    except ConnectionError as exc:\n        code = getattr(exc, 'code', 1)\n        message = getattr(exc, 'err', exc)\n        return code, '', to_text(message, errors='surrogate_then_replace')\n    return 0, out, ''\n\n\ndef request_builder(method_, *args, **kwargs):\n    reqid = str(uuid.uuid4())\n    req = {'jsonrpc': '2.0', 'method': method_, 'id': reqid}\n    req['params'] = (args, kwargs)\n\n    return req\n\n\nclass ConnectionError(Exception):\n\n    def __init__(self, message, *args, **kwargs):\n        super(ConnectionError, self).__init__(message)\n        for k, v in iteritems(kwargs):\n            setattr(self, k, v)\n\n\nclass Connection(object):\n\n    def __init__(self, socket_path):\n        if socket_path is None:\n            raise AssertionError('socket_path must be a value')\n        self.socket_path = socket_path\n\n    def __getattr__(self, name):\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            if name.startswith('_'):\n                raise AttributeError(\"'%s' object has no attribute '%s'\" % (self.__class__.__name__, name))\n            return partial(self.__rpc__, name)\n\n    def _exec_jsonrpc(self, name, *args, **kwargs):\n\n        req = request_builder(name, *args, **kwargs)\n        reqid = req['id']\n\n        if not os.path.exists(self.socket_path):\n            raise ConnectionError(\n                'socket path %s does not exist or cannot be found. See Troubleshooting socket '\n                'path issues in the Network Debug and Troubleshooting Guide' % self.socket_path\n            )\n\n        try:\n            data = json.dumps(req, cls=AnsibleJSONEncoder)\n        except TypeError as exc:\n            raise ConnectionError(\n                \"Failed to encode some variables as JSON for communication with ansible-connection. \"\n                \"The original exception was: %s\" % to_text(exc)\n            )\n\n        try:\n            out = self.send(data)\n        except socket.error as e:\n            raise ConnectionError(\n                'unable to connect to socket %s. See Troubleshooting socket path issues '\n                'in the Network Debug and Troubleshooting Guide' % self.socket_path,\n                err=to_text(e, errors='surrogate_then_replace'), exception=traceback.format_exc()\n            )\n\n        try:\n            response = json.loads(out)\n        except ValueError:\n            params = [repr(arg) for arg in args] + ['{0}={1!r}'.format(k, v) for k, v in iteritems(kwargs)]\n            params = ', '.join(params)\n            raise ConnectionError(\n                \"Unable to decode JSON from response to {0}({1}). Received '{2}'.\".format(name, params, out)\n            )\n\n        if response['id'] != reqid:\n            raise ConnectionError('invalid json-rpc id received')\n        if \"result_type\" in response:\n            response[\"result\"] = cPickle.loads(to_bytes(response[\"result\"]))\n\n        return response\n\n    def __rpc__(self, name, *args, **kwargs):\n        \"\"\"Executes the json-rpc and returns the output received\n           from remote device.\n           :name: rpc method to be executed over connection plugin that implements jsonrpc 2.0\n           :args: Ordered list of params passed as arguments to rpc method\n           :kwargs: Dict of valid key, value pairs passed as arguments to rpc method\n\n           For usage refer the respective connection plugin docs.\n        \"\"\"\n\n        response = self._exec_jsonrpc(name, *args, **kwargs)\n\n        if 'error' in response:\n            err = response.get('error')\n            msg = err.get('data') or err['message']\n            code = err['code']\n            raise ConnectionError(to_text(msg, errors='surrogate_then_replace'), code=code)\n\n        return response['result']\n\n    def send(self, data):\n        try:\n            sf = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            sf.connect(self.socket_path)\n\n            send_data(sf, to_bytes(data))\n            response = recv_data(sf)\n\n        except socket.error as e:\n            sf.close()\n            raise ConnectionError(\n                'unable to connect to socket %s. See the socket path issue category in '\n                'Network Debug and Troubleshooting Guide' % self.socket_path,\n                err=to_text(e, errors='surrogate_then_replace'), exception=traceback.format_exc()\n            )\n\n        sf.close()\n\n        return to_text(response, errors='surrogate_or_strict')\n"], "fixing_code": ["#\n# This code is part of Ansible, but is an independent component.\n# This particular file snippet, and this file snippet only, is BSD licensed.\n# Modules you write using this snippet, which is embedded dynamically by Ansible\n# still belong to the author of the module, and may assign their own license\n# to the complete work.\n#\n# (c) 2017 Red Hat Inc.\n#\n# Redistribution and use in source and binary forms, with or without modification,\n# are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright\n#      notice, this list of conditions and the following disclaimer.\n#    * Redistributions in binary form must reproduce the above copyright notice,\n#      this list of conditions and the following disclaimer in the documentation\n#      and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport hashlib\nimport json\nimport socket\nimport struct\nimport traceback\nimport uuid\n\nfrom functools import partial\nfrom ansible import constants as C\nfrom ansible.module_utils._text import to_bytes, to_text\nfrom ansible.module_utils.common.json import AnsibleJSONEncoder\nfrom ansible.module_utils.common.parameters import remove_values\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.six.moves import cPickle\nfrom ansible.utils.helpers import deduplicate_list\n\n\ndef write_to_file_descriptor(fd, obj):\n    \"\"\"Handles making sure all data is properly written to file descriptor fd.\n\n    In particular, that data is encoded in a character stream-friendly way and\n    that all data gets written before returning.\n    \"\"\"\n    # Need to force a protocol that is compatible with both py2 and py3.\n    # That would be protocol=2 or less.\n    # Also need to force a protocol that excludes certain control chars as\n    # stdin in this case is a pty and control chars will cause problems.\n    # that means only protocol=0 will work.\n    src = cPickle.dumps(obj, protocol=0)\n\n    # raw \\r characters will not survive pty round-trip\n    # They should be rehydrated on the receiving end\n    src = src.replace(b'\\r', br'\\r')\n    data_hash = to_bytes(hashlib.sha1(src).hexdigest())\n\n    os.write(fd, b'%d\\n' % len(src))\n    os.write(fd, src)\n    os.write(fd, b'%s\\n' % data_hash)\n\n\ndef send_data(s, data):\n    packed_len = struct.pack('!Q', len(data))\n    return s.sendall(packed_len + data)\n\n\ndef recv_data(s):\n    header_len = 8  # size of a packed unsigned long long\n    data = to_bytes(\"\")\n    while len(data) < header_len:\n        d = s.recv(header_len - len(data))\n        if not d:\n            return None\n        data += d\n    data_len = struct.unpack('!Q', data[:header_len])[0]\n    data = data[header_len:]\n    while len(data) < data_len:\n        d = s.recv(data_len - len(data))\n        if not d:\n            return None\n        data += d\n    return data\n\n\ndef exec_command(module, command):\n    connection = Connection(module._socket_path)\n    try:\n        out = connection.exec_command(command)\n    except ConnectionError as exc:\n        code = getattr(exc, 'code', 1)\n        message = getattr(exc, 'err', exc)\n        return code, '', to_text(message, errors='surrogate_then_replace')\n    return 0, out, ''\n\n\ndef request_builder(method_, *args, **kwargs):\n    reqid = str(uuid.uuid4())\n    req = {'jsonrpc': '2.0', 'method': method_, 'id': reqid}\n    req['params'] = (args, kwargs)\n\n    return req\n\n\nclass ConnectionError(Exception):\n\n    def __init__(self, message, *args, **kwargs):\n        super(ConnectionError, self).__init__(message)\n        for k, v in iteritems(kwargs):\n            setattr(self, k, v)\n\n\nclass Connection(object):\n\n    def __init__(self, socket_path):\n        if socket_path is None:\n            raise AssertionError('socket_path must be a value')\n        self.socket_path = socket_path\n\n    def __getattr__(self, name):\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            if name.startswith('_'):\n                raise AttributeError(\"'%s' object has no attribute '%s'\" % (self.__class__.__name__, name))\n            return partial(self.__rpc__, name)\n\n    def _exec_jsonrpc(self, name, *args, **kwargs):\n\n        req = request_builder(name, *args, **kwargs)\n        reqid = req['id']\n\n        if not os.path.exists(self.socket_path):\n            raise ConnectionError(\n                'socket path %s does not exist or cannot be found. See Troubleshooting socket '\n                'path issues in the Network Debug and Troubleshooting Guide' % self.socket_path\n            )\n\n        try:\n            data = json.dumps(req, cls=AnsibleJSONEncoder)\n        except TypeError as exc:\n            raise ConnectionError(\n                \"Failed to encode some variables as JSON for communication with ansible-connection. \"\n                \"The original exception was: %s\" % to_text(exc)\n            )\n\n        try:\n            out = self.send(data)\n        except socket.error as e:\n            raise ConnectionError(\n                'unable to connect to socket %s. See Troubleshooting socket path issues '\n                'in the Network Debug and Troubleshooting Guide' % self.socket_path,\n                err=to_text(e, errors='surrogate_then_replace'), exception=traceback.format_exc()\n            )\n\n        try:\n            response = json.loads(out)\n        except ValueError:\n            sensitive_keys = list(\n                    C.MAGIC_VARIABLE_MAPPING[\"password\"]\n                    + C.MAGIC_VARIABLE_MAPPING[\"private_key_file\"]\n                    + C.MAGIC_VARIABLE_MAPPING[\"become_pass\"]\n            )\n            sensitive_values = [\n                v2 \n                for k, v in iteritems(kwargs) \n                for k2, v2 in iteritems(v) \n                if k2 in sensitive_keys\n            ]\n            params = [repr(remove_values(arg, sensitive_values)) for arg in args] + [\n                \"{0}={1!r}\".format(k, remove_values(v, sensitive_values)) \n                for k, v in iteritems(kwargs)]\n            params = ', '.join(params)\n            raise ConnectionError(\n                \"Unable to decode JSON from response to {0}({1}). Received '{2}'.\".format(name, params, out)\n            )\n\n\n        if response['id'] != reqid:\n            raise ConnectionError('invalid json-rpc id received')\n        if \"result_type\" in response:\n            response[\"result\"] = cPickle.loads(to_bytes(response[\"result\"]))\n\n        return response\n\n    def __rpc__(self, name, *args, **kwargs):\n        \"\"\"Executes the json-rpc and returns the output received\n           from remote device.\n           :name: rpc method to be executed over connection plugin that implements jsonrpc 2.0\n           :args: Ordered list of params passed as arguments to rpc method\n           :kwargs: Dict of valid key, value pairs passed as arguments to rpc method\n\n           For usage refer the respective connection plugin docs.\n        \"\"\"\n\n        response = self._exec_jsonrpc(name, *args, **kwargs)\n\n        if 'error' in response:\n            err = response.get('error')\n            msg = err.get('data') or err['message']\n            code = err['code']\n            raise ConnectionError(to_text(msg, errors='surrogate_then_replace'), code=code)\n\n        return response['result']\n\n    def send(self, data):\n        try:\n            sf = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            sf.connect(self.socket_path)\n\n            send_data(sf, to_bytes(data))\n            response = recv_data(sf)\n\n        except socket.error as e:\n            sf.close()\n            raise ConnectionError(\n                'unable to connect to socket %s. See the socket path issue category in '\n                'Network Debug and Troubleshooting Guide' % self.socket_path,\n                err=to_text(e, errors='surrogate_then_replace'), exception=traceback.format_exc()\n            )\n\n        sf.close()\n\n        return to_text(response, errors='surrogate_or_strict')\n"], "filenames": ["lib/ansible/module_utils/connection.py"], "buggy_code_start_loc": [40], "buggy_code_end_loc": [170], "fixing_code_start_loc": [41], "fixing_code_end_loc": [188], "type": "CWE-209", "message": "A flaw was found in Ansible Engine's ansible-connection module, where sensitive information such as the Ansible user credentials is disclosed by default in the traceback error message. The highest threat from this vulnerability is to confidentiality.", "other": {"cve": {"id": "CVE-2021-3620", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-03T19:15:08.237", "lastModified": "2023-02-12T23:41:22.313", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in Ansible Engine's ansible-connection module, where sensitive information such as the Ansible user credentials is disclosed by default in the traceback error message. The highest threat from this vulnerability is to confidentiality."}, {"lang": "es", "value": "Se ha encontrado un fallo en el m\u00f3dulo ansible-connection de Ansible Engine, en el que informaci\u00f3n confidencial, como las credenciales de usuario de Ansible, es revelado por defecto en el mensaje de error de rastreo. La mayor amenaza de esta vulnerabilidad es la confidencialidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible_automation_platform_early_access:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "E3871C74-20C4-4212-AEF1-D792637A92B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible_engine:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.27", "matchCriteriaId": "19A338B7-0C96-497E-AF9C-EA78F143CCBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:1:*:*:*:*:*:*:*", "matchCriteriaId": "4B7FF772-FC99-435A-8D6F-6999656B9593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:16.1:*:*:*:*:*:*:*", "matchCriteriaId": "C9D3F4FF-AD3D-4D17-93E8-84CAFCED2F59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6BBD7A51-0590-4DDF-8249-5AFA8D645CB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization_for_ibm_power_little_endian:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "FDE26BBE-BD17-43B4-9C3F-B009F5AD0396"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization_host:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB28F9AF-3D06-4532-B397-96D7E4792503"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization_manager:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "E0E1B0D8-7067-4FE7-A309-917AE4D59E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "47811209-5CE5-4375-8391-B0A7F6A0E420"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1975767", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ansible/ansible/blob/stable-2.9/changelogs/CHANGELOG-v2.9.rst#security-fixes", "source": "secalert@redhat.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ansible/ansible/commit/fe28767970c8ec62aabe493c46b53a5de1e5fac0", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ansible/ansible/commit/fe28767970c8ec62aabe493c46b53a5de1e5fac0"}}