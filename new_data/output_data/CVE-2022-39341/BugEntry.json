{"buggy_code": ["package commands\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"github.com/go-errors/errors\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/utils\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/server/validation\"\n\t\"github.com/openfga/openfga/storage\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/metric\"\n\t\"go.opentelemetry.io/otel/metric/instrument\"\n\t\"go.opentelemetry.io/otel/metric/unit\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nconst AllUsers = \"*\"\n\n// A CheckQuery can be used to Check if a User has a Relation to an Object\n// CheckQuery instances may be safely shared by multiple go-routines\ntype CheckQuery struct {\n\tlogger           logger.Logger\n\ttracer           trace.Tracer\n\tmeter            metric.Meter\n\tdatastore        storage.OpenFGADatastore\n\tresolveNodeLimit uint32\n}\n\n// NewCheckQuery creates a CheckQuery with specified `tupleBackend` and `typeDefinitionReadBackend` to use for storage\nfunc NewCheckQuery(datastore storage.OpenFGADatastore, t trace.Tracer, m metric.Meter, l logger.Logger, resolveNodeLimit uint32) *CheckQuery {\n\treturn &CheckQuery{\n\t\tlogger:           l,\n\t\ttracer:           t,\n\t\tmeter:            m,\n\t\tdatastore:        datastore,\n\t\tresolveNodeLimit: resolveNodeLimit,\n\t}\n}\n\n// Execute the query in `checkRequest`, returning the response or an error.\nfunc (query *CheckQuery) Execute(ctx context.Context, req *openfgapb.CheckRequest) (*openfgapb.CheckResponse, error) {\n\tstatCheckResolutionDepth, _ := query.meter.AsyncInt64().Gauge(\n\t\t\"openfga.check.resolution.depth\",\n\t\tinstrument.WithDescription(\"Number of recursive resolutions needed to execute check requests\"),\n\t\tinstrument.WithUnit(unit.Dimensionless),\n\t)\n\tstatCheckDBCalls, _ := query.meter.AsyncInt64().Gauge(\n\t\t\"openfga.check.db.calls\",\n\t\tinstrument.WithDescription(\"Number of db queries needed to execute check requests\"),\n\t\tinstrument.WithUnit(unit.Dimensionless),\n\t)\n\n\tvar resolutionTracer resolutionTracer = &noopResolutionTracer{}\n\tif req.GetTrace() {\n\t\tresolutionTracer = newStringResolutionTracer()\n\t}\n\n\ttk := req.GetTupleKey()\n\tcontextualTuples, err := validateAndPreprocessTuples(tk, req.GetContextualTuples().GetTupleKeys())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trc := newResolutionContext(req.GetStoreId(), req.GetAuthorizationModelId(), tk, contextualTuples, resolutionTracer, utils.NewResolutionMetadata(), &circuitBreaker{breakerState: false})\n\n\tuserset, err := query.getTypeDefinitionRelationUsersets(ctx, rc)\n\tif err != nil {\n\t\tutils.LogDBStats(ctx, query.logger, \"Check\", rc.metadata.GetReadCalls(), 0)\n\t\treturn nil, err\n\t}\n\n\tif err := query.resolveNode(ctx, rc, userset); err != nil {\n\t\tutils.LogDBStats(ctx, query.logger, \"Check\", rc.metadata.GetReadCalls(), 0)\n\t\treturn nil, err\n\t}\n\n\tvar resolution string\n\tr, ok := rc.users.Get(rc.targetUser)\n\tif ok && r != nil {\n\t\tresolution = r.GetResolution()\n\t}\n\n\tutils.LogDBStats(ctx, query.logger, \"Check\", rc.metadata.GetReadCalls(), 0)\n\tif statCheckResolutionDepth != nil {\n\t\tstatCheckResolutionDepth.Observe(ctx, int64(rc.metadata.GetResolve()))\n\t}\n\tif statCheckDBCalls != nil {\n\t\tstatCheckDBCalls.Observe(ctx, int64(rc.metadata.GetReadCalls()))\n\t}\n\n\treturn &openfgapb.CheckResponse{\n\t\tAllowed:    ok,\n\t\tResolution: resolution,\n\t}, nil\n}\n\nfunc (query *CheckQuery) getTypeDefinitionRelationUsersets(ctx context.Context, rc *resolutionContext) (*openfgapb.Userset, error) {\n\tctx, span := query.tracer.Start(ctx, \"getTypeDefinitionRelationUsersets\")\n\tdefer span.End()\n\n\tuserset, err := validation.ValidateTuple(ctx, query.datastore, rc.store, rc.modelID, rc.tk, rc.metadata)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleTupleValidateError(err)\n\t}\n\treturn userset, nil\n}\n\n// resolveNode recursively resolves userset starting from a supplied UserTree node.\nfunc (query *CheckQuery) resolveNode(ctx context.Context, rc *resolutionContext, nsUS *openfgapb.Userset) error {\n\tif rc.metadata.AddResolve() >= query.resolveNodeLimit {\n\t\tquery.logger.Warn(\"resolution too complex\", zap.String(\"resolution\", rc.tracer.GetResolution()))\n\t\treturn serverErrors.AuthorizationModelResolutionTooComplex\n\t}\n\tctx, span := query.tracer.Start(ctx, \"resolveNode\")\n\tdefer span.End()\n\tif rc.shouldShortCircuit() {\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"short-circuit\")})\n\t\treturn nil // short circuit subsequent operations\n\t}\n\n\tswitch usType := nsUS.Userset.(type) {\n\tcase nil, *openfgapb.Userset_This:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"this\")})\n\t\treturn query.resolveDirectUserSet(ctx, rc)\n\tcase *openfgapb.Userset_Union:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"union\")})\n\t\treturn query.resolveUnion(ctx, rc, usType)\n\tcase *openfgapb.Userset_Intersection:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"intersection\")})\n\t\treturn query.resolveIntersection(ctx, rc, usType)\n\tcase *openfgapb.Userset_Difference:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"difference\")})\n\t\treturn query.resolveDifference(ctx, rc, usType)\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"computed\")})\n\t\treturn query.resolveComputed(ctx, rc, usType)\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"tuple-to-userset\")})\n\t\treturn query.resolveTupleToUserset(ctx, rc, usType)\n\tdefault:\n\t\treturn serverErrors.UnsupportedUserSet\n\t}\n}\n\nfunc (query *CheckQuery) resolveComputed(ctx context.Context, rc *resolutionContext, nodes *openfgapb.Userset_ComputedUserset) error {\n\tcomputedTK := &openfgapb.TupleKey{Object: rc.tk.GetObject(), Relation: nodes.ComputedUserset.GetRelation(), User: rc.tk.GetUser()}\n\ttracer := rc.tracer.AppendComputed().AppendString(tupleUtils.ToObjectRelationString(computedTK.GetObject(), computedTK.GetRelation()))\n\tnestedRC := rc.fork(computedTK, tracer, false)\n\tuserset, err := query.getTypeDefinitionRelationUsersets(ctx, nestedRC)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn query.resolveNode(ctx, nestedRC, userset)\n}\n\n// resolveDirectUserSet attempts to find individual user concurrently by resolving the usersets. If the user is found\n// in the direct user search or in any of the usersets, the peer goroutines will be short-circuited.\nfunc (query *CheckQuery) resolveDirectUserSet(ctx context.Context, rc *resolutionContext) error {\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tvar wg sync.WaitGroup\n\tc := make(chan *chanResolveResult)\n\n\twg.Add(1)\n\tgo func(c chan<- *chanResolveResult) {\n\t\tdefer wg.Done()\n\n\t\tfound := false\n\t\ttk, err := rc.readUserTuple(ctx, query.datastore)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t}\n\n\t\tif tk != nil && err == nil {\n\t\t\trc.users.Add(rc.tracer.AppendDirect(), tk.GetUser())\n\t\t\tfound = true\n\t\t}\n\t\tselect {\n\t\tcase c <- &chanResolveResult{err: err, found: found}:\n\t\tcase <-done:\n\t\t}\n\t}(c)\n\n\titer, err := rc.readUsersetTuples(ctx, query.datastore)\n\tif err != nil {\n\t\treturn serverErrors.HandleError(\"\", err)\n\t}\n\n\tfor {\n\t\tusersetTuple, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn serverErrors.HandleError(\"\", err)\n\t\t}\n\n\t\t// If a single star is available, then assume user exists and break.\n\t\tif usersetTuple.GetUser() == \"*\" {\n\t\t\trc.users.Add(rc.tracer.AppendDirect(), rc.targetUser)\n\t\t\tbreak\n\t\t}\n\n\t\t// Avoid launching more goroutines by checking if the user has been found in another goroutine.\n\t\tif rc.shouldShortCircuit() {\n\t\t\tbreak\n\t\t}\n\n\t\tuserset := usersetTuple.GetUser()\n\t\tobject, relation := tupleUtils.SplitObjectRelation(userset)\n\t\ttracer := rc.tracer.AppendDirect().AppendString(userset)\n\t\ttupleKey := &openfgapb.TupleKey{\n\t\t\tObject:   object,\n\t\t\tRelation: relation,\n\t\t\tUser:     rc.tk.GetUser(),\n\t\t}\n\t\tnestedRC := rc.fork(tupleKey, tracer, false)\n\n\t\twg.Add(1)\n\t\tgo func(c chan<- *chanResolveResult) {\n\t\t\tdefer wg.Done()\n\n\t\t\tuserset, err := query.getTypeDefinitionRelationUsersets(ctx, nestedRC)\n\t\t\tif err == nil {\n\t\t\t\terr = query.resolveNode(ctx, nestedRC, userset)\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase c <- &chanResolveResult{err: err, found: nestedRC.userFound()}:\n\t\t\tcase <-done:\n\t\t\t}\n\t\t}(c)\n\t}\n\n\t// If any `break` was triggered, immediately release any possible resources held by the iterator.\n\titer.Stop()\n\n\tgo func(c chan *chanResolveResult) {\n\t\twg.Wait()\n\t\tclose(c)\n\t}(c)\n\n\tfor res := range c {\n\t\tif res.found {\n\t\t\treturn nil\n\t\t}\n\t\tif res.err != nil {\n\t\t\terr = res.err\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (query *CheckQuery) resolveUnion(ctx context.Context, rc *resolutionContext, nodes *openfgapb.Userset_Union) error {\n\tvar wg sync.WaitGroup\n\tc := make(chan *chanResolveResult, len(nodes.Union.Child))\n\n\tfor idx, userset := range nodes.Union.Child {\n\t\tif rc.shouldShortCircuit() {\n\t\t\tbreak\n\t\t}\n\n\t\tus := userset\n\t\ttracer := rc.tracer.AppendUnion().AppendIndex(idx)\n\t\tnestedRC := rc.fork(rc.tk, tracer, true)\n\n\t\twg.Add(1)\n\t\tgo func(c chan<- *chanResolveResult) {\n\t\t\tdefer wg.Done()\n\t\t\terr := query.resolveNode(ctx, nestedRC, us)\n\t\t\tc <- &chanResolveResult{err: err, found: nestedRC.userFound()}\n\t\t}(c)\n\t}\n\n\tgo func(c chan *chanResolveResult) {\n\t\twg.Wait()\n\t\tclose(c)\n\t}(c)\n\n\tvar err error\n\tfor res := range c {\n\t\tif res.found {\n\t\t\treturn nil\n\t\t}\n\t\tif res.err != nil {\n\t\t\terr = res.err\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (query *CheckQuery) resolveIntersection(ctx context.Context, rc *resolutionContext, nodes *openfgapb.Userset_Intersection) error {\n\tuserSetsPerChild := newUserSets()\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tbreaker := &circuitBreaker{breakerState: false}\n\tfor idx, userset := range nodes.Intersection.Child {\n\t\tidx, userset := idx, userset\n\t\ttracer := rc.tracer.AppendIndex(idx)\n\t\tnestedRC := newResolutionContext(rc.store, rc.modelID, rc.tk, rc.contextualTuples, tracer, rc.metadata, breaker)\n\t\tgrp.Go(func() error {\n\t\t\terr := query.resolveNode(ctx, nestedRC, userset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !nestedRC.userFound() {\n\t\t\t\t// if not found in ANY of them, the shared breaker should open\n\t\t\t\tbreaker.Open()\n\t\t\t}\n\t\t\tuserSetsPerChild.Set(idx, nestedRC.users)\n\t\t\treturn nil\n\t\t})\n\t}\n\n\tif err := grp.Wait(); err != nil {\n\t\treturn err\n\t}\n\tif breaker.IsOpen() {\n\t\treturn nil // if the breaker opened, at least one group is missing the user\n\t}\n\tsmallestUSIdx := 0\n\tusPerNode := userSetsPerChild.AsMap()\n\t// Finding the smallest of the usersets reduces the lookups when finding the intersections of the children\n\t// smallestUSIdx is used to store the index the contains the smallest of the usersets\n\tfor idx, us := range usPerNode {\n\t\tif idx == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif len(usPerNode[smallestUSIdx].AsSlice()) > len(us.AsSlice()) {\n\t\t\tsmallestUSIdx = idx\n\t\t}\n\t}\n\t// Avoid processing the same one twice\n\tsmallestUS := usPerNode[smallestUSIdx].AsSlice()\n\tdelete(usPerNode, smallestUSIdx)\n\tfor _, user := range smallestUS {\n\t\tsit := rc.tracer.CreateIntersectionTracer()\n\t\tsit.AppendTrace(user.r)\n\t\tmissing := false\n\t\tfor _, set := range usPerNode {\n\t\t\trt, ok := set.Get(user.u)\n\t\t\tif !ok {\n\t\t\t\tmissing = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tsit.AppendTrace(rt)\n\t\t}\n\t\tif !missing {\n\t\t\trc.users.Add(rc.tracer.AppendIntersection(sit), user.u)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (query *CheckQuery) resolveDifference(ctx context.Context, rc *resolutionContext, node *openfgapb.Userset_Difference) error {\n\tsets := []*openfgapb.Userset{node.Difference.GetBase(), node.Difference.GetSubtract()}\n\tusPerNode := newUserSets()\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tbreaker := &circuitBreaker{breakerState: false}\n\tfor idx, set := range sets {\n\t\tidx, set := idx, set\n\t\ttracer := rc.tracer.AppendIndex(idx)\n\t\tnestedRC := newResolutionContext(rc.store, rc.modelID, rc.tk, rc.contextualTuples, tracer, rc.metadata, breaker)\n\t\tgrp.Go(func() error {\n\t\t\terr := query.resolveNode(ctx, nestedRC, set)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif idx == 0 && !nestedRC.userFound() {\n\t\t\t\t// if not found in base, no point on resolving subtract completely\n\t\t\t\tbreaker.Open()\n\t\t\t}\n\t\t\tusPerNode.Set(idx, nestedRC.users)\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := grp.Wait(); err != nil {\n\t\treturn err\n\t}\n\tbase, _ := usPerNode.Get(0)\n\tdifference, _ := usPerNode.Get(1)\n\tbase.DeleteFrom(difference)\n\trc.users.AddFrom(base)\n\treturn nil\n}\n\nfunc (query *CheckQuery) resolveTupleToUserset(ctx context.Context, rc *resolutionContext, node *openfgapb.Userset_TupleToUserset) error {\n\trelation := node.TupleToUserset.GetTupleset().GetRelation()\n\tif relation == \"\" {\n\t\trelation = rc.tk.GetRelation()\n\t}\n\tfindTK := &openfgapb.TupleKey{Object: rc.tk.GetObject(), Relation: relation}\n\ttracer := rc.tracer.AppendTupleToUserset().AppendString(tupleUtils.ToObjectRelationString(findTK.GetObject(), relation))\n\titer, err := rc.read(ctx, query.datastore, findTK)\n\tif err != nil {\n\t\treturn serverErrors.HandleError(\"\", err)\n\t}\n\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tvar wg sync.WaitGroup\n\tc := make(chan *chanResolveResult)\n\n\tfor {\n\t\ttuple, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn serverErrors.HandleError(\"\", err)\n\t\t}\n\n\t\tif rc.shouldShortCircuit() {\n\t\t\tbreak // the user was resolved already, avoid launching extra lookups\n\t\t}\n\n\t\tuserObj, userRel := tupleUtils.SplitObjectRelation(tuple.GetUser())\n\n\t\tif !tupleUtils.IsValidObject(userObj) {\n\t\t\tcontinue // TupleToUserset tuplesets should be of the form 'objectType:id' or 'objectType:id#relation' but are not guaranteed to be because it is neither a user or userset\n\t\t}\n\n\t\tusersetRel := node.TupleToUserset.GetComputedUserset().GetRelation()\n\n\t\t// userRel may be empty, and in this case we set it to usersetRel.\n\t\tif userRel == \"\" {\n\t\t\tuserRel = usersetRel\n\t\t}\n\t\t// We only proceed in the case that userRel == usersetRel (=node.TupleToUserset.GetComputedUserset().GetRelation()).\n\t\tif userRel != usersetRel {\n\t\t\tcontinue\n\t\t}\n\n\t\ttupleKey := &openfgapb.TupleKey{\n\t\t\t// user from previous lookup\n\t\t\tObject:   userObj,\n\t\t\tRelation: userRel,\n\t\t\t// original tk user\n\t\t\tUser: rc.tk.GetUser(),\n\t\t}\n\t\ttracer := tracer.AppendString(tupleUtils.ToObjectRelationString(userObj, userRel))\n\t\tnestedRC := rc.fork(tupleKey, tracer, false)\n\n\t\twg.Add(1)\n\t\tgo func(c chan<- *chanResolveResult) {\n\t\t\tdefer wg.Done()\n\n\t\t\tuserset, err := query.getTypeDefinitionRelationUsersets(ctx, nestedRC)\n\t\t\tif err == nil {\n\t\t\t\terr = query.resolveNode(ctx, nestedRC, userset)\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase c <- &chanResolveResult{err: err, found: nestedRC.userFound()}:\n\t\t\tcase <-done:\n\t\t\t}\n\t\t}(c)\n\t}\n\n\t// If any `break` was triggered, immediately release any possible resources held by the iterator.\n\titer.Stop()\n\n\tgo func(c chan *chanResolveResult) {\n\t\twg.Wait()\n\t\tclose(c)\n\t}(c)\n\n\tfor res := range c {\n\t\tif res.found {\n\t\t\treturn nil\n\t\t}\n\t\tif res.err != nil {\n\t\t\terr = res.err\n\t\t}\n\t}\n\n\treturn err\n}\n", "package commands\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\n\ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/utils\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/storage\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\n// Keeping the interface simple for the time being\n// we could make it Append* where * are tupleset, computedset, etc.\n// especially if we want to generate other representations for the trace (e.g. a tree)\ntype resolutionTracer interface {\n\tAppendComputed() resolutionTracer\n\tAppendDirect() resolutionTracer\n\tAppendIndex(i int) resolutionTracer\n\tAppendIntersection(t intersectionTracer) resolutionTracer\n\tAppendString(s string) resolutionTracer\n\tAppendTupleToUserset() resolutionTracer\n\tAppendUnion() resolutionTracer\n\tCreateIntersectionTracer() intersectionTracer\n\tGetResolution() string\n}\n\ntype intersectionTracer interface {\n\tAppendTrace(rt resolutionTracer)\n\tGetResolution() string\n}\n\n// noopResolutionTracer is thread safe as current implementation is immutable\ntype noopResolutionTracer struct{}\n\nfunc (t *noopResolutionTracer) AppendComputed() resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendDirect() resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendIndex(_ int) resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendIntersection(_ intersectionTracer) resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendString(_ string) resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendTupleToUserset() resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendUnion() resolutionTracer {\n\treturn t\n}\n\nvar nit = &noopIntersectionTracer{}\n\nfunc (t *noopResolutionTracer) CreateIntersectionTracer() intersectionTracer {\n\treturn nit\n}\n\nfunc (t *noopResolutionTracer) GetResolution() string {\n\treturn \"\"\n}\n\ntype noopIntersectionTracer struct{}\n\nfunc (t *noopIntersectionTracer) AppendTrace(_ resolutionTracer) {}\n\nfunc (t *noopIntersectionTracer) GetResolution() string {\n\treturn \"\"\n}\n\n// stringResolutionTracer is thread safe as current implementation is immutable\ntype stringResolutionTracer struct {\n\ttrace string\n}\n\nfunc newStringResolutionTracer() resolutionTracer {\n\treturn &stringResolutionTracer{\n\t\ttrace: \".\",\n\t}\n}\n\nfunc (t *stringResolutionTracer) AppendComputed() resolutionTracer {\n\treturn t.AppendString(\"(computed-userset)\")\n}\n\nfunc (t *stringResolutionTracer) AppendDirect() resolutionTracer {\n\treturn t.AppendString(\"(direct)\")\n}\n\n// AppendIndex We create separate append functions so no casting happens externally\n// This aim to minimize overhead added by the no-op implementation\nfunc (t *stringResolutionTracer) AppendIndex(n int) resolutionTracer {\n\treturn &stringResolutionTracer{\n\t\ttrace: fmt.Sprintf(\"%s%d\", t.trace, n),\n\t}\n}\n\nfunc (t *stringResolutionTracer) AppendIntersection(it intersectionTracer) resolutionTracer {\n\treturn &stringResolutionTracer{\n\t\ttrace: fmt.Sprintf(\"%s[%s]\", t.trace, it.GetResolution()),\n\t}\n}\n\nfunc (t *stringResolutionTracer) AppendString(subTrace string) resolutionTracer {\n\treturn &stringResolutionTracer{\n\t\ttrace: fmt.Sprintf(\"%s%s.\", t.trace, subTrace),\n\t}\n}\n\nfunc (t *stringResolutionTracer) AppendTupleToUserset() resolutionTracer {\n\treturn t.AppendString(\"(tuple-to-userset)\")\n}\n\nfunc (t *stringResolutionTracer) AppendUnion() resolutionTracer {\n\treturn t.AppendString(\"union\")\n}\n\nfunc (t *stringResolutionTracer) CreateIntersectionTracer() intersectionTracer {\n\treturn &stringIntersectionTracer{}\n}\n\nfunc (t *stringResolutionTracer) GetResolution() string {\n\treturn t.trace\n}\n\n// stringIntersectionTracer is NOT thread safe. do not call from multiple threads\ntype stringIntersectionTracer struct {\n\ttrace string\n}\n\nfunc (t *stringIntersectionTracer) AppendTrace(rt resolutionTracer) {\n\tif len(t.trace) != 0 {\n\t\tt.trace = fmt.Sprintf(\"%s,%s\", t.trace, rt.GetResolution())\n\t\treturn\n\t}\n\n\tt.trace = rt.GetResolution()\n}\n\nfunc (t *stringIntersectionTracer) GetResolution() string {\n\treturn t.trace\n}\n\ntype userSet struct {\n\tm sync.Mutex\n\tu map[string]resolutionTracer\n}\n\ntype userWithTracer struct {\n\tu string\n\tr resolutionTracer\n}\n\nfunc (u *userSet) Add(r resolutionTracer, values ...string) {\n\tu.m.Lock()\n\tfor _, v := range values {\n\t\tu.u[v] = r\n\t}\n\tu.m.Unlock()\n}\n\nfunc (u *userSet) AddFrom(other *userSet) {\n\tu.m.Lock()\n\tfor _, uwr := range other.AsSlice() {\n\t\tu.u[uwr.u] = uwr.r\n\t}\n\tu.m.Unlock()\n}\n\nfunc (u *userSet) DeleteFrom(other *userSet) {\n\tu.m.Lock()\n\tfor _, uwr := range other.AsSlice() {\n\t\tdelete(u.u, uwr.u)\n\t}\n\tu.m.Unlock()\n}\n\nfunc (u *userSet) Get(value string) (resolutionTracer, bool) {\n\tu.m.Lock()\n\tdefer u.m.Unlock()\n\n\tvar found bool\n\tvar rt resolutionTracer\n\tif rt, found = u.u[value]; !found {\n\t\tif rt, found = u.u[AllUsers]; !found {\n\t\t\treturn nil, false\n\t\t}\n\t}\n\treturn rt, found\n}\n\nfunc (u *userSet) AsSlice() []userWithTracer {\n\tu.m.Lock()\n\tout := make([]userWithTracer, 0, len(u.u))\n\tfor u, rt := range u.u {\n\t\tout = append(out, userWithTracer{\n\t\t\tu: u,\n\t\t\tr: rt,\n\t\t})\n\t}\n\tu.m.Unlock()\n\treturn out\n}\n\nfunc newUserSet() *userSet {\n\treturn &userSet{u: make(map[string]resolutionTracer)}\n}\n\ntype userSets struct {\n\tmu  sync.Mutex\n\tusm map[int]*userSet\n}\n\nfunc newUserSets() *userSets {\n\treturn &userSets{usm: make(map[int]*userSet, 0)}\n}\n\nfunc (u *userSets) Set(idx int, us *userSet) {\n\tu.mu.Lock()\n\tu.usm[idx] = us\n\tu.mu.Unlock()\n}\n\nfunc (u *userSets) Get(idx int) (*userSet, bool) {\n\tu.mu.Lock()\n\tus, ok := u.usm[idx]\n\tu.mu.Unlock()\n\treturn us, ok\n}\n\nfunc (u *userSets) AsMap() map[int]*userSet {\n\treturn u.usm\n}\n\ntype chanResolveResult struct {\n\terr   error\n\tfound bool\n}\n\ntype circuitBreaker struct {\n\tmu           sync.Mutex\n\tbreakerState bool\n}\n\nfunc (sc *circuitBreaker) Open() {\n\tsc.mu.Lock()\n\tdefer sc.mu.Unlock()\n\tsc.breakerState = true\n}\n\nfunc (sc *circuitBreaker) IsOpen() bool {\n\tsc.mu.Lock()\n\tdefer sc.mu.Unlock()\n\treturn sc.breakerState\n}\n\ntype resolutionContext struct {\n\tstore            string\n\tmodelID          string\n\tusers            *userSet\n\ttargetUser       string\n\ttk               *openfgapb.TupleKey\n\tcontextualTuples *contextualTuples\n\ttracer           resolutionTracer\n\tmetadata         *utils.ResolutionMetadata\n\tinternalCB       *circuitBreaker // Opens if the user is found, controlled internally. Primarily used for UNION.\n\texternalCB       *circuitBreaker // Open is controlled from caller, Used for Difference and Intersection.\n}\n\nfunc newResolutionContext(store, modelID string, tk *openfgapb.TupleKey, contextualTuples *contextualTuples, tracer resolutionTracer, metadata *utils.ResolutionMetadata, externalBreaker *circuitBreaker) *resolutionContext {\n\treturn &resolutionContext{\n\t\tstore:            store,\n\t\tmodelID:          modelID,\n\t\tusers:            newUserSet(),\n\t\ttargetUser:       tk.GetUser(),\n\t\ttk:               tk,\n\t\tcontextualTuples: contextualTuples,\n\t\ttracer:           tracer,\n\t\tmetadata:         metadata,\n\t\tinternalCB:       &circuitBreaker{breakerState: false},\n\t\texternalCB:       externalBreaker,\n\t}\n}\n\nfunc (rc *resolutionContext) shouldShortCircuit() bool {\n\tif rc.internalCB.IsOpen() || rc.externalCB.IsOpen() {\n\t\treturn true\n\t}\n\treturn rc.userFound()\n}\n\nfunc (rc *resolutionContext) shortCircuit() {\n\trc.internalCB.Open()\n}\n\nfunc (rc *resolutionContext) userFound() bool {\n\t_, ok := rc.users.Get(rc.targetUser)\n\tif ok {\n\t\trc.shortCircuit()\n\t}\n\treturn ok\n}\n\nfunc (rc *resolutionContext) fork(tk *openfgapb.TupleKey, tracer resolutionTracer, resetResolveCounter bool) *resolutionContext {\n\tmetadata := rc.metadata\n\tif resetResolveCounter {\n\t\tmetadata = rc.metadata.Fork()\n\t}\n\n\treturn &resolutionContext{\n\t\tstore:            rc.store,\n\t\tmodelID:          rc.modelID,\n\t\tusers:            rc.users,\n\t\ttargetUser:       rc.targetUser,\n\t\ttk:               tk,\n\t\tcontextualTuples: rc.contextualTuples,\n\t\ttracer:           tracer,\n\t\tmetadata:         metadata,\n\t\tinternalCB:       rc.internalCB,\n\t\texternalCB:       rc.externalCB,\n\t}\n}\n\nfunc (rc *resolutionContext) readUserTuple(ctx context.Context, backend storage.TupleBackend) (*openfgapb.TupleKey, error) {\n\ttk, ok := rc.contextualTuples.readUserTuple(rc.tk)\n\tif ok {\n\t\treturn tk, nil\n\t}\n\n\trc.metadata.AddReadCall()\n\ttuple, err := backend.ReadUserTuple(ctx, rc.store, rc.tk)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tuple.GetKey(), nil\n}\n\nfunc (rc *resolutionContext) readUsersetTuples(ctx context.Context, backend storage.TupleBackend) (storage.TupleKeyIterator, error) {\n\tcUsersetTuples := rc.contextualTuples.readUsersetTuples(rc.tk)\n\trc.metadata.AddReadCall()\n\tusersetTuples, err := backend.ReadUsersetTuples(ctx, rc.store, rc.tk)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\titer1 := storage.NewStaticTupleKeyIterator(cUsersetTuples)\n\titer2 := storage.NewTupleKeyIteratorFromTupleIterator(usersetTuples)\n\n\treturn storage.NewCombinedIterator(iter1, iter2), nil\n}\n\nfunc (rc *resolutionContext) read(ctx context.Context, backend storage.TupleBackend, tk *openfgapb.TupleKey) (storage.TupleKeyIterator, error) {\n\tcTuples := rc.contextualTuples.read(tk)\n\trc.metadata.AddReadCall()\n\ttuples, err := backend.Read(ctx, rc.store, tk)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\titer1 := storage.NewStaticTupleKeyIterator(cTuples)\n\titer2 := storage.NewTupleKeyIteratorFromTupleIterator(tuples)\n\n\treturn storage.NewCombinedIterator(iter1, iter2), nil\n}\n\ntype contextualTuples struct {\n\tusersets map[string][]*openfgapb.TupleKey\n}\n\nfunc (c *contextualTuples) read(tk *openfgapb.TupleKey) []*openfgapb.TupleKey {\n\treturn c.usersets[tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())]\n}\n\nfunc (c *contextualTuples) readUserTuple(tk *openfgapb.TupleKey) (*openfgapb.TupleKey, bool) {\n\ttuples := c.usersets[tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())]\n\tfor _, t := range tuples {\n\t\tif t.GetUser() == tk.GetUser() {\n\t\t\treturn t, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (c *contextualTuples) readUsersetTuples(tk *openfgapb.TupleKey) []*openfgapb.TupleKey {\n\ttuples := c.usersets[tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())]\n\n\tvar res []*openfgapb.TupleKey\n\tfor _, t := range tuples {\n\t\tif tupleUtils.GetUserTypeFromUser(t.GetUser()) == tupleUtils.UserSet {\n\t\t\tres = append(res, t)\n\t\t}\n\t}\n\treturn res\n}\n\nfunc validateAndPreprocessTuples(keyToCheck *openfgapb.TupleKey, tupleKeys []*openfgapb.TupleKey) (*contextualTuples, error) {\n\tif keyToCheck.GetUser() == \"\" || keyToCheck.GetRelation() == \"\" || keyToCheck.GetObject() == \"\" {\n\t\treturn nil, serverErrors.InvalidCheckInput\n\t}\n\tif !tupleUtils.IsValidUser(keyToCheck.GetUser()) {\n\t\treturn nil, serverErrors.InvalidUser(keyToCheck.GetUser())\n\t}\n\n\ttupleMap := map[string]struct{}{}\n\tusersets := map[string][]*openfgapb.TupleKey{}\n\tfor _, tk := range tupleKeys {\n\t\tif _, ok := tupleMap[tk.String()]; ok {\n\t\t\treturn nil, serverErrors.DuplicateContextualTuple(tk)\n\t\t}\n\t\ttupleMap[tk.String()] = struct{}{}\n\n\t\tif tk.GetUser() == \"\" || tk.GetRelation() == \"\" || tk.GetObject() == \"\" {\n\t\t\treturn nil, serverErrors.InvalidContextualTuple(tk)\n\t\t}\n\t\tif !tupleUtils.IsValidUser(tk.GetUser()) {\n\t\t\treturn nil, serverErrors.InvalidUser(tk.GetUser())\n\t\t}\n\n\t\tkey := tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())\n\t\tusersets[key] = append(usersets[key], tk)\n\t}\n\n\treturn &contextualTuples{usersets: usersets}, nil\n}\n", "package commands\n\nimport (\n\t\"context\"\n\n\t\"github.com/openfga/openfga/pkg/logger\"\n\ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/utils\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/server/validation\"\n\t\"github.com/openfga/openfga/storage\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// ExpandQuery resolves a target TupleKey into a UsersetTree by expanding type definitions.\ntype ExpandQuery struct {\n\tlogger    logger.Logger\n\ttracer    trace.Tracer\n\tdatastore storage.OpenFGADatastore\n}\n\n// NewExpandQuery creates a new ExpandQuery using the supplied backends for retrieving data.\nfunc NewExpandQuery(datastore storage.OpenFGADatastore, tracer trace.Tracer, logger logger.Logger) *ExpandQuery {\n\treturn &ExpandQuery{logger: logger, tracer: tracer, datastore: datastore}\n}\n\nfunc (query *ExpandQuery) Execute(ctx context.Context, req *openfgapb.ExpandRequest) (*openfgapb.ExpandResponse, error) {\n\tstore := req.GetStoreId()\n\tmodelID := req.GetAuthorizationModelId()\n\ttupleKey := req.GetTupleKey()\n\tobject := tupleKey.GetObject()\n\trelation := tupleKey.GetRelation()\n\n\tif object == \"\" || relation == \"\" {\n\t\treturn nil, serverErrors.InvalidExpandInput\n\t}\n\n\ttk := tupleUtils.NewTupleKey(object, relation, \"\")\n\tmetadata := utils.NewResolutionMetadata()\n\tuserset, err := query.getUserset(ctx, store, modelID, tk, metadata)\n\tif err != nil {\n\t\tutils.LogDBStats(ctx, query.logger, \"Expand\", metadata.GetReadCalls(), 0)\n\t\treturn nil, err\n\t}\n\troot, err := query.resolveUserset(ctx, store, modelID, userset, tk, metadata)\n\tif err != nil {\n\t\tutils.LogDBStats(ctx, query.logger, \"Expand\", metadata.GetReadCalls(), 0)\n\t\treturn nil, err\n\t}\n\tutils.LogDBStats(ctx, query.logger, \"Expand\", metadata.GetReadCalls(), 0)\n\n\treturn &openfgapb.ExpandResponse{\n\t\tTree: &openfgapb.UsersetTree{\n\t\t\tRoot: root,\n\t\t},\n\t}, nil\n}\n\nfunc (query *ExpandQuery) resolveUserset(ctx context.Context, store, modelID string, userset *openfgapb.Userset, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveUserset\")\n\tdefer span.End()\n\n\tswitch us := userset.Userset.(type) {\n\tcase nil, *openfgapb.Userset_This:\n\t\treturn query.resolveThis(ctx, store, tk, metadata)\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\treturn query.resolveComputedUserset(ctx, us.ComputedUserset, tk, metadata)\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\treturn query.resolveTupleToUserset(ctx, store, us.TupleToUserset, tk, metadata)\n\tcase *openfgapb.Userset_Union:\n\t\treturn query.resolveUnionUserset(ctx, store, modelID, us.Union, tk, metadata)\n\tcase *openfgapb.Userset_Difference:\n\t\treturn query.resolveDifferenceUserset(ctx, store, modelID, us.Difference, tk, metadata)\n\tcase *openfgapb.Userset_Intersection:\n\t\treturn query.resolveIntersectionUserset(ctx, store, modelID, us.Intersection, tk, metadata)\n\tdefault:\n\t\treturn nil, serverErrors.UnsupportedUserSet\n\t}\n}\n\n// resolveThis resolves a DirectUserset into a leaf node containing a distinct set of users with that relation.\nfunc (query *ExpandQuery) resolveThis(ctx context.Context, store string, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveThis\")\n\tdefer span.End()\n\n\tmetadata.AddReadCall()\n\titer, err := query.datastore.Read(ctx, store, tk)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\tdefer iter.Stop()\n\tdistinctUsers := make(map[string]bool)\n\tfor {\n\t\ttuple, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t\t}\n\t\tdistinctUsers[tuple.GetKey().GetUser()] = true\n\t}\n\tusers := make([]string, 0, len(distinctUsers))\n\tfor u := range distinctUsers {\n\t\tusers = append(users, u)\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\tUsers: users,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveComputedUserset builds a leaf node containing the result of resolving a ComputedUserset rewrite.\nfunc (query *ExpandQuery) resolveComputedUserset(ctx context.Context, userset *openfgapb.ObjectRelation, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\n\tvar span trace.Span\n\t_, span = query.tracer.Start(ctx, \"resolveComputedUserset\")\n\tdefer span.End()\n\n\tcomputed := &openfgapb.TupleKey{\n\t\tObject:   userset.GetObject(),\n\t\tRelation: userset.GetRelation(),\n\t}\n\tif len(computed.Object) == 0 {\n\t\tcomputed.Object = tk.Object\n\t}\n\tif len(computed.Relation) == 0 {\n\t\tcomputed.Relation = tk.Relation\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\tUserset: toObjectRelation(computed),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveTupleToUserset creates a new leaf node containing the result of expanding a TupleToUserset rewrite.\nfunc (query *ExpandQuery) resolveTupleToUserset(ctx context.Context, store string, userset *openfgapb.TupleToUserset, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveTupleToUserset\")\n\tdefer span.End()\n\n\ttsKey := &openfgapb.TupleKey{\n\t\tObject:   tk.GetObject(),\n\t\tRelation: userset.GetTupleset().GetRelation(),\n\t}\n\tif tsKey.GetRelation() == \"\" {\n\t\ttsKey.Relation = tk.GetRelation()\n\t}\n\n\tmetadata.AddReadCall()\n\titer, err := query.datastore.Read(ctx, store, tsKey)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\tdefer iter.Stop()\n\tvar computed []*openfgapb.UsersetTree_Computed\n\tseen := make(map[string]bool)\n\tfor {\n\t\ttuple, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t\t}\n\t\tuser := tuple.GetKey().GetUser()\n\t\t// user must contain a type (i.e., be an object or userset)\n\t\tif tupleUtils.GetType(user) == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\ttObject, tRelation := tupleUtils.SplitObjectRelation(user)\n\t\t// We only proceed in the case that tRelation == userset.GetComputedUserset().GetRelation().\n\t\t// tRelation may be empty, and in this case, we set it to userset.GetComputedUserset().GetRelation().\n\t\tif tRelation == \"\" {\n\t\t\ttRelation = userset.GetComputedUserset().GetRelation()\n\t\t}\n\t\tif tRelation != userset.GetComputedUserset().GetRelation() {\n\t\t\tcontinue\n\t\t}\n\t\tcs := &openfgapb.TupleKey{\n\t\t\tObject:   tObject,\n\t\t\tRelation: tRelation,\n\t\t}\n\t\tcomputedRelation := toObjectRelation(cs)\n\t\tif !seen[computedRelation] {\n\t\t\tcomputed = append(computed, &openfgapb.UsersetTree_Computed{Userset: computedRelation})\n\t\t\tseen[computedRelation] = true\n\t\t}\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\tTupleset: toObjectRelation(tsKey),\n\t\t\t\t\t\tComputed: computed,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveUnionUserset creates an intermediate Usertree node containing the union of its children.\nfunc (query *ExpandQuery) resolveUnionUserset(ctx context.Context, store, modelID string, usersets *openfgapb.Usersets, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveUnionUserset\")\n\tdefer span.End()\n\n\tnodes, err := query.resolveUsersets(ctx, store, modelID, usersets.Child, tk, metadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveIntersectionUserset create an intermediate Usertree node containing the intersection of its children\nfunc (query *ExpandQuery) resolveIntersectionUserset(ctx context.Context, store, modelID string, usersets *openfgapb.Usersets, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveIntersectionUserset\")\n\tdefer span.End()\n\n\tnodes, err := query.resolveUsersets(ctx, store, modelID, usersets.Child, tk, metadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Intersection{\n\t\t\tIntersection: &openfgapb.UsersetTree_Nodes{\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveDifferenceUserset creates and intermediate Usertree node containing the difference of its children\nfunc (query *ExpandQuery) resolveDifferenceUserset(ctx context.Context, store, modelID string, userset *openfgapb.Difference, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveDifferenceUserset\")\n\tdefer span.End()\n\n\tnodes, err := query.resolveUsersets(ctx, store, modelID, []*openfgapb.Userset{userset.Base, userset.Subtract}, tk, metadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbase := nodes[0]\n\tsubtract := nodes[1]\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: subtract,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveUsersets creates Usertree nodes for multiple Usersets\nfunc (query *ExpandQuery) resolveUsersets(ctx context.Context, store, modelID string, usersets []*openfgapb.Userset, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) ([]*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveUsersets\")\n\tdefer span.End()\n\n\tout := make([]*openfgapb.UsersetTree_Node, len(usersets))\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tfor i, us := range usersets {\n\t\t// https://golang.org/doc/faq#closures_and_goroutines\n\t\ti, us := i, us\n\t\tgrp.Go(func() error {\n\t\t\tnode, err := query.resolveUserset(ctx, store, modelID, us, tk, metadata)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tout[i] = node\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := grp.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// getUserset retrieves the authorizationModel configuration for a supplied TupleKey.\nfunc (query *ExpandQuery) getUserset(ctx context.Context, store, modelID string, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.Userset, error) {\n\tctx, span := query.tracer.Start(ctx, \"getUserset\")\n\tdefer span.End()\n\n\tuserset, err := validation.ValidateObjectsRelations(ctx, query.datastore, store, modelID, tk, metadata)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleTupleValidateError(err)\n\t}\n\treturn userset, nil\n}\n\nfunc toObjectRelation(tk *openfgapb.TupleKey) string {\n\treturn tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/openfga/openfga/pkg/id\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/openfga/openfga/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n)\n\nconst (\n\tdefaultResolveNodeLimit = 25\n\tgitHubTestDataFile      = \"testdata/github.json\" // relative to project root\n)\n\nvar githubTuples = []*openfgapb.TupleKey{\n\ttuple.NewTupleKey(\"org:openfga\", \"member\", \"erik\"),\n\ttuple.NewTupleKey(\"org:openfga\", \"repo_admin\", \"org:openfga#member\"),\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"team:openfga/iam#member\"),\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"owner\", \"org:openfga\"),\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"beth\"),\n\ttuple.NewTupleKey(\"team:openfga/iam\", \"member\", \"charles\"),\n\ttuple.NewTupleKey(\"team:openfga/iam\", \"member\", \"team:openfga/protocols#member\"),\n\ttuple.NewTupleKey(\"team:openfga/protocols\", \"member\", \"diane\"),\n}\n\nfunc TestCheckQuery(t *testing.T, datastore storage.OpenFGADatastore) {\n\tvar tests = []struct {\n\t\tname             string\n\t\ttypeDefinitions  []*openfgapb.TypeDefinition\n\t\ttuples           []*openfgapb.TupleKey\n\t\tresolveNodeLimit uint32\n\t\trequest          *openfgapb.CheckRequest\n\t\terr              error\n\t\tresponse         *openfgapb.CheckResponse\n\t}{\n\t\t{\n\t\t\tname: \"ExecuteWithEmptyTupleKey\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{},\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidCheckInput,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithEmptyObject\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"\", \"reader\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidCheckInput,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithEmptyRelation\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidCheckInput,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithEmptyUser\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidCheckInput,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithRequestRelationInexistentInTypeDefinition\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"inexistent\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.RelationNotFound(\"inexistent\", \"repo\", tuple.NewTupleKey(\"repo:openfga/openfga\", \"inexistent\", \"someUser\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteFailsWithInvalidUser\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"john:albert:doe\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidUser(\"john:albert:doe\"),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsErrorNotStackOverflowForInfinitelyRecursiveResolution\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\tRelation: \"reader\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsResolutionTooComplexErrorForComplexResolution\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t},\n\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\tRelation: \"reader\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tresolveNodeLimit: 2,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsResolutionTooComplexErrorForComplexUnionResolution\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t},\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tresolveNodeLimit: 2,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithExistingTupleKeyAndEmptyUserSetReturnsAllowed\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithAllowAllTupleKeyAndEmptyUserSetReturnsAllowed\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"*\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithNonExistingTupleKeyAndEmptyUserSetReturnsNotAllowed\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples:           []*openfgapb.TupleKey{},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithUnionAndDirectUserSetReturnsAllowedIfDirectTupleExists\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"admin\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//\t\tchild { _this {  }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithUnionAndDirectUserSetReturnsAllowedIfAllUsersTupleExists\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"admin\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//\t\tchild { _this {  }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"*\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithUnionAndComputedUserSetReturnsNotAllowedIfComputedUsersetDoesNotIncludeUser\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"admin\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//    child { computed_userset { relation: \"owner\" }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"owner\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"owner\", \"team/iam\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithUnionAndComputedUserSetReturnsAllowedIfComputedUsersetIncludesUser\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"reader\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//    child { _this {  }}\n\t\t\t//    child { computed_userset { relation: \"writer\" }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"writer\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#writer.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteDirectSetReturnsAllowedIfUserHasRelationWithAnObjectThatHasUserAccessToTheTargetObject\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"reader\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//    child { _this {  }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"team_member\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"team_member\", \"github|jose@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"team:iam#team_member\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".(direct).team:iam#team_member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsAllowedIfUserIsHasRelationToAnObjectThatIsInComputedUserSetForAnotherObject\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"writer\": {},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"team_member\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"team_member\", \"github|jose@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"team:iam#team_member\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#writer.(direct).team:iam#team_member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsNotAllowedIfIntersectionIsRequiredAndUserIsInOneUserSetButNotTheOther\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"openfga-store\",\n\t\t\t\t// pretend you can only create an organization user in an openfga store if\n\t\t\t\t// you can create a user AND write an organization in a store\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"create_organization_user\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"write_organization\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"create_user\":        {},\n\t\t\t\t\t\"write_organization\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_user\", \"github|yenkel@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_organization_user\", \"github|yenkel@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsAllowedIfIntersectionIsRequiredAndUserIsInAllUserSets\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"openfga-store\",\n\t\t\t\t// pretend you can only create an organization user in an openfga store if\n\t\t\t\t// you can create a user AND write an organization in a store\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"create_organization_user\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"write_organization\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"write_organization\": {},\n\t\t\t\t\t\"create_user\":        {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_user\", \"github|yenkel@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"write_organization\", \"github|yenkel@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_organization_user\", \"github|yenkel@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".[.0(computed-userset).openfga-store:yenkel-dev#create_user.(direct).,.1(computed-userset).openfga-store:yenkel-dev#write_organization.(direct).]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteSupportsNestedIntersectionAndCorrectlyTraces\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"openfga-store\",\n\t\t\t\t// pretend you can only create an organization user in an openfga store if\n\t\t\t\t// you can create a user AND write an organization in a store\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"create_organization_user\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"write_organization\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"create_user\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user_a\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user_b\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"write_organization\": {},\n\t\t\t\t\t\"create_user_a\":      {},\n\t\t\t\t\t\"create_user_b\":      {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_user_a\", \"github|yenkel@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_user_b\", \"github|yenkel@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"write_organization\", \"github|yenkel@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_organization_user\", \"github|yenkel@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".[.0(computed-userset).openfga-store:yenkel-dev#create_user.[.0(computed-userset).openfga-store:yenkel-dev#create_user.0(computed-userset).openfga-store:yenkel-dev#create_user_a.(direct).,.0(computed-userset).openfga-store:yenkel-dev#create_user.1(computed-userset).openfga-store:yenkel-dev#create_user_b.(direct).],.1(computed-userset).openfga-store:yenkel-dev#write_organization.(direct).]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsAllowedForUserNotRemovedByDifference\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"banned\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"banned\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jon.allie@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"banned\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jon.allie@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsNotAllowedForUserRemovedByDifference\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"banned\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"banned\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jon.allie@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"banned\", \"github|jon.allie@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"banned\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jon.allie@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsAllowedForTupleToUserset\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t// implicit direct?\n\t\t\t\t\t\t\"repo_admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"manager\", \"org:openfga#repo_admin\"),\n\t\t\t\ttuple.NewTupleKey(\"org:openfga\", \"repo_admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(tuple-to-userset).repo:openfga/canaveral#manager.org:openfga#repo_admin.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteCanResolveRecursiveComputedUserSets\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"maintainer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"maintainer\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_writer\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"triager\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"triager\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_reader\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"team:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:openfga\", \"member\", \"github|iaco@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"github|iaco@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#triager.union.1(computed-userset).repo:openfga/openfga#writer.union.0(direct).team:openfga#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteCanResolveRecursiveTupleToUserSets\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\"owner\":  {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\"editor\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"editor\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"parent\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:octo_v2_draft\", \"parent\", \"document:octo_folder\"),\n\t\t\t\ttuple.NewTupleKey(\"document:octo_folder\", \"editor\", \"google|iaco@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:octo_v2_draft\", \"viewer\", \"google|iaco@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.2(tuple-to-userset).document:octo_v2_draft#parent.document:octo_folder#viewer.union.1(computed-userset).document:octo_folder#editor.union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"CheckWithUsersetAsUser\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"team:iam\", \"member\", \"org:openfga#member\"),\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"member\", \"team:engineering#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:engineering\", \"member\", \"org:openfga#member\"),\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"CheckUsersetAsUser_WithContextualTuples\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"team:iam\", \"member\", \"org:openfga#member\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"member\", \"team:engineering#member\"),\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:engineering\", \"member\", \"org:openfga#member\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"CheckUsersetAsUser_WithContextualTuples\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"team:iam\", \"member\", \"org:openfga#member\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"member\", \"team:engineering#member\"),\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:engineering\", \"member\", \"org:openfga#member\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"CheckUsersetAsUser_WithContextualTuples\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"team:iam\", \"member\", \"org:openfga#member\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"member\", \"team:engineering#member\"),\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:engineering\", \"member\", \"org:openfga#member\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"Check with TupleToUserset involving no object or userset\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:doc1\", \"viewer\", \"anne\"),\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset:        &openfgapb.ObjectRelation{Relation: \"parent\"},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"viewer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"folder\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder1\"), // folder1 isn't an object or userset\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"anne\"),\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"TupleToUserset Check Passes when at least one tupleset relation resolves\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:doc1\", \"viewer\", \"anne\"),\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset:        &openfgapb.ObjectRelation{Relation: \"parent\"},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"viewer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"folder\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder1\"), // folder1 isn't an object or userset\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"anne\"),\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tstore := id.Must(id.New()).String()\n\t\t\tmodel := &openfgapb.AuthorizationModel{\n\t\t\t\tId:              id.Must(id.New()).String(),\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\t\t\tTypeDefinitions: test.typeDefinitions,\n\t\t\t}\n\n\t\t\terr := datastore.WriteAuthorizationModel(ctx, store, model)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif test.tuples != nil {\n\t\t\t\terr := datastore.Write(ctx, store, nil, test.tuples)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tcmd := commands.NewCheckQuery(datastore, tracer, meter, logger, test.resolveNodeLimit)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = model.Id\n\t\t\tresp, gotErr := cmd.Execute(ctx, test.request)\n\n\t\t\tif test.err == nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\t\t\t}\n\n\t\t\tif test.err != nil {\n\t\t\t\trequire.EqualError(t, test.err, gotErr.Error())\n\t\t\t}\n\n\t\t\tif test.response != nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\n\t\t\t\trequire.Equal(t, test.response.Allowed, resp.Allowed)\n\n\t\t\t\tif test.response.Allowed {\n\t\t\t\t\trequire.Equal(t, test.response.Resolution, resp.Resolution)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCheckQueryAgainstGitHubModel(t *testing.T, datastore storage.OpenFGADatastore) {\n\tvar tests = []struct {\n\t\tname             string\n\t\tresolveNodeLimit uint32\n\t\trequest          *openfgapb.CheckRequest\n\t\terr              error\n\t\tresponse         *openfgapb.CheckResponse\n\t}{\n\t\t{\n\t\t\tname:             \"GitHubAssertion1\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion2\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"triager\", \"anne\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion3\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"diane\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).team:openfga/iam#member.(direct).team:openfga/protocols#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion4\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"erik\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#triager.union.1(computed-userset).repo:openfga/openfga#writer.union.1(computed-userset).repo:openfga/openfga#maintainer.union.1(computed-userset).repo:openfga/openfga#admin.union.1(tuple-to-userset).repo:openfga/openfga#owner.org:openfga#repo_admin.(direct).org:openfga#member.union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion5\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"charles\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#maintainer.union.1(computed-userset).repo:openfga/openfga#admin.union.0(direct).team:openfga/iam#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion6\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\n\tdata, err := os.ReadFile(gitHubTestDataFile)\n\trequire.NoError(t, err)\n\n\tvar gitHubDefinition openfgapb.WriteAuthorizationModelRequest\n\terr = protojson.Unmarshal(data, &gitHubDefinition)\n\trequire.NoError(t, err)\n\n\tstore := id.Must(id.New()).String()\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: gitHubDefinition.GetTypeDefinitions(),\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(t, err)\n\n\terr = datastore.Write(ctx, store, nil, githubTuples)\n\trequire.NoError(t, err)\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewCheckQuery(datastore, tracer, meter, logger, test.resolveNodeLimit)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = model.Id\n\t\t\tresp, gotErr := cmd.Execute(ctx, test.request)\n\n\t\t\tif test.err == nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\t\t\t}\n\n\t\t\tif test.err != nil {\n\t\t\t\trequire.EqualError(t, test.err, gotErr.Error())\n\t\t\t}\n\n\t\t\tif test.response != nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\n\t\t\t\trequire.Equal(t, test.response.Allowed, resp.Allowed)\n\n\t\t\t\tif test.response.Allowed {\n\t\t\t\t\trequire.Equal(t, test.response.Resolution, resp.Resolution)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCheckQueryWithContextualTuplesAgainstGitHubModel(t *testing.T, datastore storage.OpenFGADatastore) {\n\tvar tests = []struct {\n\t\tname             string\n\t\tresolveNodeLimit uint32\n\t\trequest          *openfgapb.CheckRequest\n\t\terr              error\n\t\tresponse         *openfgapb.CheckResponse\n\t}{\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion1\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion2\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"triager\", \"anne\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion3\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"diane\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).team:openfga/iam#member.(direct).team:openfga/protocols#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion4\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"erik\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#triager.union.1(computed-userset).repo:openfga/openfga#writer.union.1(computed-userset).repo:openfga/openfga#maintainer.union.1(computed-userset).repo:openfga/openfga#admin.union.1(tuple-to-userset).repo:openfga/openfga#owner.org:openfga#repo_admin.(direct).org:openfga#member.union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion5\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"charles\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#maintainer.union.1(computed-userset).repo:openfga/openfga#admin.union.0(direct).team:openfga/iam#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion6\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"RepeatedContextualTuplesShouldError\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTrace: true,\n\t\t\t},\n\t\t\terr: serverErrors.DuplicateContextualTuple(tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\")),\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesWithEmptyUserFails\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"org:openfga\", \"member\", \"\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTrace: true,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidContextualTuple(tuple.NewTupleKey(\"org:openfga\", \"member\", \"\")),\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesWithEmptyRelationFails\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"org:openfga\", \"\", \"anne\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTrace: true,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidContextualTuple(tuple.NewTupleKey(\"org:openfga\", \"\", \"anne\")),\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesWithEmptyObjectFails\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"\", \"member\", \"anne\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTrace: true,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidContextualTuple(tuple.NewTupleKey(\"\", \"member\", \"anne\")),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\n\tdata, err := os.ReadFile(gitHubTestDataFile)\n\trequire.NoError(t, err)\n\n\tvar gitHubDefinition openfgapb.WriteAuthorizationModelRequest\n\terr = protojson.Unmarshal(data, &gitHubDefinition)\n\trequire.NoError(t, err)\n\n\tstoreID := id.Must(id.New()).String()\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: gitHubDefinition.GetTypeDefinitions(),\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, storeID, model)\n\trequire.NoError(t, err)\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewCheckQuery(datastore, tracer, meter, logger, test.resolveNodeLimit)\n\t\t\ttest.request.StoreId = storeID\n\t\t\ttest.request.AuthorizationModelId = model.Id\n\t\t\tresp, gotErr := cmd.Execute(ctx, test.request)\n\n\t\t\tif test.err == nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\t\t\t}\n\n\t\t\tif test.err != nil {\n\t\t\t\trequire.EqualError(t, test.err, gotErr.Error())\n\t\t\t}\n\n\t\t\tif test.response != nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\n\t\t\t\trequire.Equal(t, test.response.Allowed, resp.Allowed)\n\n\t\t\t\tif test.response.Allowed {\n\t\t\t\t\trequire.Equal(t, test.response.Resolution, resp.Resolution)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCheckQueryAuthorizationModelsVersioning(t *testing.T, datastore storage.OpenFGADatastore) {\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\tstore := id.Must(id.New()).String()\n\n\toldModel := &openfgapb.AuthorizationModel{\n\t\tId:            id.Must(id.New()).String(),\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"owner\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\"editor\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{Relation: \"owner\"}}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := datastore.WriteAuthorizationModel(ctx, store, oldModel)\n\trequire.NoError(t, err)\n\n\tupdatedModel := &openfgapb.AuthorizationModel{\n\t\tId:            id.Must(id.New()).String(),\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"owner\":  {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\"editor\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, store, updatedModel)\n\trequire.NoError(t, err)\n\n\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, []*openfgapb.TupleKey{{Object: \"repo:openfgapb\", Relation: \"owner\", User: \"yenkel\"}})\n\trequire.NoError(t, err)\n\n\toldResp, err := commands.NewCheckQuery(datastore, tracer, meter, logger, defaultResolveNodeLimit).Execute(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: oldModel.Id,\n\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\tObject:   \"repo:openfgapb\",\n\t\t\tRelation: \"editor\",\n\t\t\tUser:     \"yenkel\",\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\trequire.True(t, oldResp.Allowed)\n\n\tupdatedResp, err := commands.NewCheckQuery(datastore, tracer, meter, logger, defaultResolveNodeLimit).Execute(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: updatedModel.Id,\n\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\tObject:   \"repo:openfgapb\",\n\t\t\tRelation: \"editor\",\n\t\t\tUser:     \"yenkel\",\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\trequire.False(t, updatedResp.Allowed)\n}\n\nvar tuples = []*openfgapb.TupleKey{\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"team:openfga#member\"),\n\ttuple.NewTupleKey(\"team:openfga\", \"member\", \"github|iaco@openfga\"),\n}\n\n// Used to avoid compiler optimizations (see https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)\nvar result *openfgapb.CheckResponse //nolint\n\nfunc BenchmarkCheckWithoutTrace(b *testing.B, datastore storage.OpenFGADatastore) {\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\tstore := id.Must(id.New()).String()\n\n\tdata, err := os.ReadFile(gitHubTestDataFile)\n\trequire.NoError(b, err)\n\n\tvar gitHubTypeDefinitions openfgapb.WriteAuthorizationModelRequest\n\terr = protojson.Unmarshal(data, &gitHubTypeDefinitions)\n\trequire.NoError(b, err)\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: gitHubTypeDefinitions.GetTypeDefinitions(),\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(b, err)\n\n\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, tuples)\n\trequire.NoError(b, err)\n\n\tcheckQuery := commands.NewCheckQuery(datastore, tracer, meter, logger, defaultResolveNodeLimit)\n\n\tvar r *openfgapb.CheckResponse\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr, _ = checkQuery.Execute(ctx, &openfgapb.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: model.Id,\n\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\tObject:   \"repo:openfga/openfga\",\n\t\t\t\tRelation: \"reader\",\n\t\t\t\tUser:     \"github|iaco@openfga\",\n\t\t\t},\n\t\t})\n\t}\n\n\tresult = r\n}\n\nfunc BenchmarkWithTrace(b *testing.B, datastore storage.OpenFGADatastore) {\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\tstore := id.Must(id.New()).String()\n\n\tdata, err := os.ReadFile(gitHubTestDataFile)\n\trequire.NoError(b, err)\n\n\tvar gitHubTypeDefinitions openfgapb.WriteAuthorizationModelRequest\n\terr = protojson.Unmarshal(data, &gitHubTypeDefinitions)\n\trequire.NoError(b, err)\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: gitHubTypeDefinitions.GetTypeDefinitions(),\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(b, err)\n\n\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, tuples)\n\trequire.NoError(b, err)\n\n\tcheckQuery := commands.NewCheckQuery(datastore, tracer, meter, logger, defaultResolveNodeLimit)\n\n\tvar r *openfgapb.CheckResponse\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr, _ = checkQuery.Execute(ctx, &openfgapb.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: model.Id,\n\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\tObject:   \"repo:openfga/openfga\",\n\t\t\t\tRelation: \"reader\",\n\t\t\t\tUser:     \"github|iaco@openfga\",\n\t\t\t},\n\t\t\tTrace: true,\n\t\t})\n\t}\n\n\tresult = r\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/go-errors/errors\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/openfga/openfga/pkg/id\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/pkg/testutils\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/openfga/openfga/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/protobuf/testing/protocmp\"\n)\n\nfunc setUp(ctx context.Context, store string, datastore storage.OpenFGADatastore, typeDefinitions []*openfgapb.TypeDefinition, tuples []*openfgapb.TupleKey) (string, error) {\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: typeDefinitions,\n\t}\n\n\tif err := datastore.WriteAuthorizationModel(ctx, store, model); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif err := datastore.Write(ctx, store, []*openfgapb.TupleKey{}, tuples); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn model.Id, nil\n}\n\nfunc TestExpandQuery(t *testing.T, datastore storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname            string\n\t\ttypeDefinitions []*openfgapb.TypeDefinition\n\t\ttuples          []*openfgapb.TupleKey\n\t\trequest         *openfgapb.ExpandRequest\n\t\texpected        *openfgapb.ExpandResponse\n\t}{\n\t\t{\n\t\t\tname: \"simple direct\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\tUsers: []string{\"github|jon.allie@openfga\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"computed userset\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tuple to userset\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"manager\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"repo_admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tuple to userset II\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"manager\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"repo_admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"amy\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tuple to userset implicit\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"manager\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"repo_admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple union\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{\"github|jon.allie@openfga\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple difference\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\":  {},\n\t\t\t\t\t\t\"banned\": {},\n\t\t\t\t\t\t\"active_admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"banned\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"active_admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\t\t\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\t\t\t\t\tBase: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSubtract: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#banned\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple intersection\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\t// Writers must be both directly in 'writers', and in 'admins'\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"complex tree\",\n\t\t\t// Users can write if they are direct members of writers, or repo_writers\n\t\t\t// in the org, unless they are also in banned_writers\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\":         {},\n\t\t\t\t\t\t\"owner\":         {},\n\t\t\t\t\t\t\"banned_writer\": {},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"banned_writer\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"repo_writer\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\t\t\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\t\t\t\t\tBase: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{\"github|jon.allie@openfga\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{Userset: \"org:openfga#repo_writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSubtract: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#banned_writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire := require.New(t)\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tstore := testutils.CreateRandomString(20)\n\t\t\tmodelID, err := setUp(ctx, store, datastore, test.typeDefinitions, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tquery := commands.NewExpandQuery(datastore, tracer, logger)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = modelID\n\t\t\tgot, err := query.Execute(ctx, test.request)\n\t\t\trequire.NoError(err)\n\n\t\t\tif diff := cmp.Diff(test.expected, got, protocmp.Transform()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"%s: Execute() (-want, +got):\\n%s\", test.name, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExpandQueryErrors(t *testing.T, datastore storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname            string\n\t\ttypeDefinitions []*openfgapb.TypeDefinition\n\t\ttuples          []*openfgapb.TupleKey\n\t\trequest         *openfgapb.ExpandRequest\n\t\texpected        error\n\t}{\n\t\t{\n\t\t\tname: \"missing object\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidExpandInput,\n\t\t},\n\t\t{\n\t\t\tname: \"missing object id and type\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \":\",\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidObjectFormat(&openfgapb.TupleKey{\n\t\t\t\tObject:   \":\",\n\t\t\t\tRelation: \"bar\",\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"missing object id\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"github:\",\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidObjectFormat(&openfgapb.TupleKey{\n\t\t\t\tObject:   \"github:\",\n\t\t\t\tRelation: \"bar\",\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"missing relation\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidExpandInput,\n\t\t},\n\t\t{\n\t\t\tname: \"type not found\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"foo:bar\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.TypeNotFound(\"foo\"),\n\t\t},\n\t\t{\n\t\t\tname: \"relation not found\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:bar\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.RelationNotFound(\"baz\", \"repo\", &openfgapb.TupleKey{\n\t\t\t\tObject:   \"repo:bar\",\n\t\t\t\tRelation: \"baz\",\n\t\t\t}),\n\t\t},\n\t}\n\n\trequire := require.New(t)\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tstore := testutils.CreateRandomString(20)\n\n\t\t\tmodelID, err := setUp(ctx, store, datastore, test.typeDefinitions, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tquery := commands.NewExpandQuery(datastore, tracer, logger)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = modelID\n\n\t\t\t_, err = query.Execute(ctx, test.request)\n\t\t\tif !errors.Is(err, test.expected) {\n\t\t\t\tt.Fatalf(\"'%s': Execute(), err = %v, want %v\", test.name, err, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["package commands\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\n\t\"github.com/go-errors/errors\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/utils\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/server/validation\"\n\t\"github.com/openfga/openfga/storage\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/metric\"\n\t\"go.opentelemetry.io/otel/metric/instrument\"\n\t\"go.opentelemetry.io/otel/metric/unit\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nconst Wildcard = \"*\"\n\n// A CheckQuery can be used to Check if a User has a Relation to an Object\n// CheckQuery instances may be safely shared by multiple go-routines\ntype CheckQuery struct {\n\tlogger           logger.Logger\n\ttracer           trace.Tracer\n\tmeter            metric.Meter\n\tdatastore        storage.OpenFGADatastore\n\tresolveNodeLimit uint32\n}\n\n// NewCheckQuery creates a CheckQuery with specified `tupleBackend` and `typeDefinitionReadBackend` to use for storage\nfunc NewCheckQuery(datastore storage.OpenFGADatastore, t trace.Tracer, m metric.Meter, l logger.Logger, resolveNodeLimit uint32) *CheckQuery {\n\treturn &CheckQuery{\n\t\tlogger:           l,\n\t\ttracer:           t,\n\t\tmeter:            m,\n\t\tdatastore:        datastore,\n\t\tresolveNodeLimit: resolveNodeLimit,\n\t}\n}\n\n// Execute the query in `checkRequest`, returning the response or an error.\nfunc (query *CheckQuery) Execute(ctx context.Context, req *openfgapb.CheckRequest) (*openfgapb.CheckResponse, error) {\n\tstatCheckResolutionDepth, _ := query.meter.AsyncInt64().Gauge(\n\t\t\"openfga.check.resolution.depth\",\n\t\tinstrument.WithDescription(\"Number of recursive resolutions needed to execute check requests\"),\n\t\tinstrument.WithUnit(unit.Dimensionless),\n\t)\n\tstatCheckDBCalls, _ := query.meter.AsyncInt64().Gauge(\n\t\t\"openfga.check.db.calls\",\n\t\tinstrument.WithDescription(\"Number of db queries needed to execute check requests\"),\n\t\tinstrument.WithUnit(unit.Dimensionless),\n\t)\n\n\tvar resolutionTracer resolutionTracer = &noopResolutionTracer{}\n\tif req.GetTrace() {\n\t\tresolutionTracer = newStringResolutionTracer()\n\t}\n\n\ttk := req.GetTupleKey()\n\tcontextualTuples, err := validateAndPreprocessTuples(tk, req.GetContextualTuples().GetTupleKeys())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trc := newResolutionContext(req.GetStoreId(), req.GetAuthorizationModelId(), tk, contextualTuples, resolutionTracer, utils.NewResolutionMetadata(), &circuitBreaker{breakerState: false})\n\n\tuserset, err := query.getTypeDefinitionRelationUsersets(ctx, rc)\n\tif err != nil {\n\t\tutils.LogDBStats(ctx, query.logger, \"Check\", rc.metadata.GetReadCalls(), 0)\n\t\treturn nil, err\n\t}\n\n\tif err := query.resolveNode(ctx, rc, userset); err != nil {\n\t\tutils.LogDBStats(ctx, query.logger, \"Check\", rc.metadata.GetReadCalls(), 0)\n\t\treturn nil, err\n\t}\n\n\tvar resolution string\n\tr, ok := rc.users.Get(rc.targetUser)\n\tif ok && r != nil {\n\t\tresolution = r.GetResolution()\n\t}\n\n\tutils.LogDBStats(ctx, query.logger, \"Check\", rc.metadata.GetReadCalls(), 0)\n\tif statCheckResolutionDepth != nil {\n\t\tstatCheckResolutionDepth.Observe(ctx, int64(rc.metadata.GetResolve()))\n\t}\n\tif statCheckDBCalls != nil {\n\t\tstatCheckDBCalls.Observe(ctx, int64(rc.metadata.GetReadCalls()))\n\t}\n\n\treturn &openfgapb.CheckResponse{\n\t\tAllowed:    ok,\n\t\tResolution: resolution,\n\t}, nil\n}\n\nfunc (query *CheckQuery) getTypeDefinitionRelationUsersets(ctx context.Context, rc *resolutionContext) (*openfgapb.Userset, error) {\n\tctx, span := query.tracer.Start(ctx, \"getTypeDefinitionRelationUsersets\")\n\tdefer span.End()\n\n\tuserset, err := validation.ValidateTuple(ctx, query.datastore, rc.store, rc.modelID, rc.tk, rc.metadata)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleTupleValidateError(err)\n\t}\n\treturn userset, nil\n}\n\n// resolveNode recursively resolves userset starting from a supplied UserTree node.\nfunc (query *CheckQuery) resolveNode(ctx context.Context, rc *resolutionContext, nsUS *openfgapb.Userset) error {\n\tif rc.metadata.AddResolve() >= query.resolveNodeLimit {\n\t\tquery.logger.Warn(\"resolution too complex\", zap.String(\"resolution\", rc.tracer.GetResolution()))\n\t\treturn serverErrors.AuthorizationModelResolutionTooComplex\n\t}\n\tctx, span := query.tracer.Start(ctx, \"resolveNode\")\n\tdefer span.End()\n\tif rc.shouldShortCircuit() {\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"short-circuit\")})\n\t\treturn nil // short circuit subsequent operations\n\t}\n\n\tswitch usType := nsUS.Userset.(type) {\n\tcase nil, *openfgapb.Userset_This:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"this\")})\n\t\treturn query.resolveDirectUserSet(ctx, rc)\n\tcase *openfgapb.Userset_Union:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"union\")})\n\t\treturn query.resolveUnion(ctx, rc, usType)\n\tcase *openfgapb.Userset_Intersection:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"intersection\")})\n\t\treturn query.resolveIntersection(ctx, rc, usType)\n\tcase *openfgapb.Userset_Difference:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"difference\")})\n\t\treturn query.resolveDifference(ctx, rc, usType)\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"computed\")})\n\t\treturn query.resolveComputed(ctx, rc, usType)\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\tspan.SetAttributes(attribute.KeyValue{Key: \"operation\", Value: attribute.StringValue(\"tuple-to-userset\")})\n\t\treturn query.resolveTupleToUserset(ctx, rc, usType)\n\tdefault:\n\t\treturn serverErrors.UnsupportedUserSet\n\t}\n}\n\nfunc (query *CheckQuery) resolveComputed(ctx context.Context, rc *resolutionContext, nodes *openfgapb.Userset_ComputedUserset) error {\n\tcomputedTK := &openfgapb.TupleKey{Object: rc.tk.GetObject(), Relation: nodes.ComputedUserset.GetRelation(), User: rc.tk.GetUser()}\n\ttracer := rc.tracer.AppendComputed().AppendString(tupleUtils.ToObjectRelationString(computedTK.GetObject(), computedTK.GetRelation()))\n\tnestedRC := rc.fork(computedTK, tracer, false)\n\tuserset, err := query.getTypeDefinitionRelationUsersets(ctx, nestedRC)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn query.resolveNode(ctx, nestedRC, userset)\n}\n\n// resolveDirectUserSet attempts to find individual user concurrently by resolving the usersets. If the user is found\n// in the direct user search or in any of the usersets, the peer goroutines will be short-circuited.\nfunc (query *CheckQuery) resolveDirectUserSet(ctx context.Context, rc *resolutionContext) error {\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tvar wg sync.WaitGroup\n\tc := make(chan *chanResolveResult)\n\n\twg.Add(1)\n\tgo func(c chan<- *chanResolveResult) {\n\t\tdefer wg.Done()\n\n\t\tfound := false\n\t\ttk, err := rc.readUserTuple(ctx, query.datastore)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t}\n\n\t\tif tk != nil && err == nil {\n\t\t\trc.users.Add(rc.tracer.AppendDirect(), tk.GetUser())\n\t\t\tfound = true\n\t\t}\n\t\tselect {\n\t\tcase c <- &chanResolveResult{err: err, found: found}:\n\t\tcase <-done:\n\t\t}\n\t}(c)\n\n\titer, err := rc.readUsersetTuples(ctx, query.datastore)\n\tif err != nil {\n\t\treturn serverErrors.HandleError(\"\", err)\n\t}\n\n\tfor {\n\t\tusersetTuple, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn serverErrors.HandleError(\"\", err)\n\t\t}\n\n\t\t// If a single star is available, then assume user exists and break.\n\t\tif usersetTuple.GetUser() == \"*\" {\n\t\t\trc.users.Add(rc.tracer.AppendDirect(), rc.targetUser)\n\t\t\tbreak\n\t\t}\n\n\t\t// Avoid launching more goroutines by checking if the user has been found in another goroutine.\n\t\tif rc.shouldShortCircuit() {\n\t\t\tbreak\n\t\t}\n\n\t\tuserset := usersetTuple.GetUser()\n\t\tobject, relation := tupleUtils.SplitObjectRelation(userset)\n\t\ttracer := rc.tracer.AppendDirect().AppendString(userset)\n\t\ttupleKey := &openfgapb.TupleKey{\n\t\t\tObject:   object,\n\t\t\tRelation: relation,\n\t\t\tUser:     rc.tk.GetUser(),\n\t\t}\n\t\tnestedRC := rc.fork(tupleKey, tracer, false)\n\n\t\twg.Add(1)\n\t\tgo func(c chan<- *chanResolveResult) {\n\t\t\tdefer wg.Done()\n\n\t\t\tuserset, err := query.getTypeDefinitionRelationUsersets(ctx, nestedRC)\n\t\t\tif err == nil {\n\t\t\t\terr = query.resolveNode(ctx, nestedRC, userset)\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase c <- &chanResolveResult{err: err, found: nestedRC.userFound()}:\n\t\t\tcase <-done:\n\t\t\t}\n\t\t}(c)\n\t}\n\n\t// If any `break` was triggered, immediately release any possible resources held by the iterator.\n\titer.Stop()\n\n\tgo func(c chan *chanResolveResult) {\n\t\twg.Wait()\n\t\tclose(c)\n\t}(c)\n\n\tfor res := range c {\n\t\tif res.found {\n\t\t\treturn nil\n\t\t}\n\t\tif res.err != nil {\n\t\t\terr = res.err\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (query *CheckQuery) resolveUnion(ctx context.Context, rc *resolutionContext, nodes *openfgapb.Userset_Union) error {\n\tvar wg sync.WaitGroup\n\tc := make(chan *chanResolveResult, len(nodes.Union.Child))\n\n\tfor idx, userset := range nodes.Union.Child {\n\t\tif rc.shouldShortCircuit() {\n\t\t\tbreak\n\t\t}\n\n\t\tus := userset\n\t\ttracer := rc.tracer.AppendUnion().AppendIndex(idx)\n\t\tnestedRC := rc.fork(rc.tk, tracer, true)\n\n\t\twg.Add(1)\n\t\tgo func(c chan<- *chanResolveResult) {\n\t\t\tdefer wg.Done()\n\t\t\terr := query.resolveNode(ctx, nestedRC, us)\n\t\t\tc <- &chanResolveResult{err: err, found: nestedRC.userFound()}\n\t\t}(c)\n\t}\n\n\tgo func(c chan *chanResolveResult) {\n\t\twg.Wait()\n\t\tclose(c)\n\t}(c)\n\n\tvar err error\n\tfor res := range c {\n\t\tif res.found {\n\t\t\treturn nil\n\t\t}\n\t\tif res.err != nil {\n\t\t\terr = res.err\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (query *CheckQuery) resolveIntersection(ctx context.Context, rc *resolutionContext, nodes *openfgapb.Userset_Intersection) error {\n\tuserSetsPerChild := newUserSets()\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tbreaker := &circuitBreaker{breakerState: false}\n\tfor idx, userset := range nodes.Intersection.Child {\n\t\tidx, userset := idx, userset\n\t\ttracer := rc.tracer.AppendIndex(idx)\n\t\tnestedRC := newResolutionContext(rc.store, rc.modelID, rc.tk, rc.contextualTuples, tracer, rc.metadata, breaker)\n\t\tgrp.Go(func() error {\n\t\t\terr := query.resolveNode(ctx, nestedRC, userset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !nestedRC.userFound() {\n\t\t\t\t// if not found in ANY of them, the shared breaker should open\n\t\t\t\tbreaker.Open()\n\t\t\t}\n\t\t\tuserSetsPerChild.Set(idx, nestedRC.users)\n\t\t\treturn nil\n\t\t})\n\t}\n\n\tif err := grp.Wait(); err != nil {\n\t\treturn err\n\t}\n\tif breaker.IsOpen() {\n\t\treturn nil // if the breaker opened, at least one group is missing the user\n\t}\n\tsmallestUSIdx := 0\n\tusPerNode := userSetsPerChild.AsMap()\n\t// Finding the smallest of the usersets reduces the lookups when finding the intersections of the children\n\t// smallestUSIdx is used to store the index the contains the smallest of the usersets\n\tfor idx, us := range usPerNode {\n\t\tif idx == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif len(usPerNode[smallestUSIdx].AsSlice()) > len(us.AsSlice()) {\n\t\t\tsmallestUSIdx = idx\n\t\t}\n\t}\n\t// Avoid processing the same one twice\n\tsmallestUS := usPerNode[smallestUSIdx].AsSlice()\n\tdelete(usPerNode, smallestUSIdx)\n\tfor _, user := range smallestUS {\n\t\tsit := rc.tracer.CreateIntersectionTracer()\n\t\tsit.AppendTrace(user.r)\n\t\tmissing := false\n\t\tfor _, set := range usPerNode {\n\t\t\trt, ok := set.Get(user.u)\n\t\t\tif !ok {\n\t\t\t\tmissing = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tsit.AppendTrace(rt)\n\t\t}\n\t\tif !missing {\n\t\t\trc.users.Add(rc.tracer.AppendIntersection(sit), user.u)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (query *CheckQuery) resolveDifference(ctx context.Context, rc *resolutionContext, node *openfgapb.Userset_Difference) error {\n\tsets := []*openfgapb.Userset{node.Difference.GetBase(), node.Difference.GetSubtract()}\n\tusPerNode := newUserSets()\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tbreaker := &circuitBreaker{breakerState: false}\n\tfor idx, set := range sets {\n\t\tidx, set := idx, set\n\t\ttracer := rc.tracer.AppendIndex(idx)\n\t\tnestedRC := newResolutionContext(rc.store, rc.modelID, rc.tk, rc.contextualTuples, tracer, rc.metadata, breaker)\n\t\tgrp.Go(func() error {\n\t\t\terr := query.resolveNode(ctx, nestedRC, set)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif idx == 0 && !nestedRC.userFound() {\n\t\t\t\t// if not found in base, no point on resolving subtract completely\n\t\t\t\tbreaker.Open()\n\t\t\t}\n\t\t\tusPerNode.Set(idx, nestedRC.users)\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := grp.Wait(); err != nil {\n\t\treturn err\n\t}\n\tbase, _ := usPerNode.Get(0)\n\tdifference, _ := usPerNode.Get(1)\n\tbase.DeleteFrom(difference)\n\trc.users.AddFrom(base)\n\treturn nil\n}\n\nfunc (query *CheckQuery) resolveTupleToUserset(ctx context.Context, rc *resolutionContext, node *openfgapb.Userset_TupleToUserset) error {\n\trelation := node.TupleToUserset.GetTupleset().GetRelation()\n\tif relation == \"\" {\n\t\trelation = rc.tk.GetRelation()\n\t}\n\n\tfindTK := tupleUtils.NewTupleKey(rc.tk.GetObject(), relation, \"\")\n\n\ttracer := rc.tracer.AppendTupleToUserset().AppendString(tupleUtils.ToObjectRelationString(findTK.GetObject(), relation))\n\titer, err := rc.read(ctx, query.datastore, findTK)\n\tif err != nil {\n\t\treturn serverErrors.HandleError(\"\", err)\n\t}\n\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tvar wg sync.WaitGroup\n\tc := make(chan *chanResolveResult)\n\n\tfor {\n\t\ttuple, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn serverErrors.HandleError(\"\", err)\n\t\t}\n\n\t\tif rc.shouldShortCircuit() {\n\t\t\tbreak // the user was resolved already, avoid launching extra lookups\n\t\t}\n\n\t\tuserObj, userRel := tupleUtils.SplitObjectRelation(tuple.GetUser())\n\n\t\tif userObj == Wildcard {\n\t\t\tobjectType, _ := tupleUtils.SplitObject(rc.tk.GetObject())\n\n\t\t\tquery.logger.WarnWithContext(\n\t\t\t\tctx,\n\t\t\t\tfmt.Sprintf(\"unexpected wildcard evaluated on tupleset relation '%s'\", relation),\n\t\t\t\tzap.String(\"store_id\", rc.store),\n\t\t\t\tzap.String(\"authorization_model_id\", rc.modelID),\n\t\t\t\tzap.String(\"object_type\", objectType),\n\t\t\t)\n\n\t\t\treturn serverErrors.InvalidTuple(\n\t\t\t\tfmt.Sprintf(\"unexpected wildcard evaluated on relation '%s#%s'\", objectType, relation),\n\t\t\t\ttupleUtils.NewTupleKey(rc.tk.GetObject(), relation, Wildcard),\n\t\t\t)\n\t\t}\n\n\t\tif !tupleUtils.IsValidObject(userObj) {\n\t\t\tcontinue // TupleToUserset tuplesets should be of the form 'objectType:id' or 'objectType:id#relation' but are not guaranteed to be because it is neither a user or userset\n\t\t}\n\n\t\tusersetRel := node.TupleToUserset.GetComputedUserset().GetRelation()\n\n\t\t// userRel may be empty, and in this case we set it to usersetRel.\n\t\tif userRel == \"\" {\n\t\t\tuserRel = usersetRel\n\t\t}\n\t\t// We only proceed in the case that userRel == usersetRel (=node.TupleToUserset.GetComputedUserset().GetRelation()).\n\t\tif userRel != usersetRel {\n\t\t\tcontinue\n\t\t}\n\n\t\ttupleKey := &openfgapb.TupleKey{\n\t\t\t// user from previous lookup\n\t\t\tObject:   userObj,\n\t\t\tRelation: userRel,\n\t\t\t// original tk user\n\t\t\tUser: rc.tk.GetUser(),\n\t\t}\n\t\ttracer := tracer.AppendString(tupleUtils.ToObjectRelationString(userObj, userRel))\n\t\tnestedRC := rc.fork(tupleKey, tracer, false)\n\n\t\twg.Add(1)\n\t\tgo func(c chan<- *chanResolveResult) {\n\t\t\tdefer wg.Done()\n\n\t\t\tuserset, err := query.getTypeDefinitionRelationUsersets(ctx, nestedRC)\n\t\t\tif err == nil {\n\t\t\t\terr = query.resolveNode(ctx, nestedRC, userset)\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase c <- &chanResolveResult{err: err, found: nestedRC.userFound()}:\n\t\t\tcase <-done:\n\t\t\t}\n\t\t}(c)\n\t}\n\n\t// If any `break` was triggered, immediately release any possible resources held by the iterator.\n\titer.Stop()\n\n\tgo func(c chan *chanResolveResult) {\n\t\twg.Wait()\n\t\tclose(c)\n\t}(c)\n\n\tfor res := range c {\n\t\tif res.found {\n\t\t\treturn nil\n\t\t}\n\t\tif res.err != nil {\n\t\t\terr = res.err\n\t\t}\n\t}\n\n\treturn err\n}\n", "package commands\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\n\ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/utils\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/storage\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\n// Keeping the interface simple for the time being\n// we could make it Append* where * are tupleset, computedset, etc.\n// especially if we want to generate other representations for the trace (e.g. a tree)\ntype resolutionTracer interface {\n\tAppendComputed() resolutionTracer\n\tAppendDirect() resolutionTracer\n\tAppendIndex(i int) resolutionTracer\n\tAppendIntersection(t intersectionTracer) resolutionTracer\n\tAppendString(s string) resolutionTracer\n\tAppendTupleToUserset() resolutionTracer\n\tAppendUnion() resolutionTracer\n\tCreateIntersectionTracer() intersectionTracer\n\tGetResolution() string\n}\n\ntype intersectionTracer interface {\n\tAppendTrace(rt resolutionTracer)\n\tGetResolution() string\n}\n\n// noopResolutionTracer is thread safe as current implementation is immutable\ntype noopResolutionTracer struct{}\n\nfunc (t *noopResolutionTracer) AppendComputed() resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendDirect() resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendIndex(_ int) resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendIntersection(_ intersectionTracer) resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendString(_ string) resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendTupleToUserset() resolutionTracer {\n\treturn t\n}\n\nfunc (t *noopResolutionTracer) AppendUnion() resolutionTracer {\n\treturn t\n}\n\nvar nit = &noopIntersectionTracer{}\n\nfunc (t *noopResolutionTracer) CreateIntersectionTracer() intersectionTracer {\n\treturn nit\n}\n\nfunc (t *noopResolutionTracer) GetResolution() string {\n\treturn \"\"\n}\n\ntype noopIntersectionTracer struct{}\n\nfunc (t *noopIntersectionTracer) AppendTrace(_ resolutionTracer) {}\n\nfunc (t *noopIntersectionTracer) GetResolution() string {\n\treturn \"\"\n}\n\n// stringResolutionTracer is thread safe as current implementation is immutable\ntype stringResolutionTracer struct {\n\ttrace string\n}\n\nfunc newStringResolutionTracer() resolutionTracer {\n\treturn &stringResolutionTracer{\n\t\ttrace: \".\",\n\t}\n}\n\nfunc (t *stringResolutionTracer) AppendComputed() resolutionTracer {\n\treturn t.AppendString(\"(computed-userset)\")\n}\n\nfunc (t *stringResolutionTracer) AppendDirect() resolutionTracer {\n\treturn t.AppendString(\"(direct)\")\n}\n\n// AppendIndex We create separate append functions so no casting happens externally\n// This aim to minimize overhead added by the no-op implementation\nfunc (t *stringResolutionTracer) AppendIndex(n int) resolutionTracer {\n\treturn &stringResolutionTracer{\n\t\ttrace: fmt.Sprintf(\"%s%d\", t.trace, n),\n\t}\n}\n\nfunc (t *stringResolutionTracer) AppendIntersection(it intersectionTracer) resolutionTracer {\n\treturn &stringResolutionTracer{\n\t\ttrace: fmt.Sprintf(\"%s[%s]\", t.trace, it.GetResolution()),\n\t}\n}\n\nfunc (t *stringResolutionTracer) AppendString(subTrace string) resolutionTracer {\n\treturn &stringResolutionTracer{\n\t\ttrace: fmt.Sprintf(\"%s%s.\", t.trace, subTrace),\n\t}\n}\n\nfunc (t *stringResolutionTracer) AppendTupleToUserset() resolutionTracer {\n\treturn t.AppendString(\"(tuple-to-userset)\")\n}\n\nfunc (t *stringResolutionTracer) AppendUnion() resolutionTracer {\n\treturn t.AppendString(\"union\")\n}\n\nfunc (t *stringResolutionTracer) CreateIntersectionTracer() intersectionTracer {\n\treturn &stringIntersectionTracer{}\n}\n\nfunc (t *stringResolutionTracer) GetResolution() string {\n\treturn t.trace\n}\n\n// stringIntersectionTracer is NOT thread safe. do not call from multiple threads\ntype stringIntersectionTracer struct {\n\ttrace string\n}\n\nfunc (t *stringIntersectionTracer) AppendTrace(rt resolutionTracer) {\n\tif len(t.trace) != 0 {\n\t\tt.trace = fmt.Sprintf(\"%s,%s\", t.trace, rt.GetResolution())\n\t\treturn\n\t}\n\n\tt.trace = rt.GetResolution()\n}\n\nfunc (t *stringIntersectionTracer) GetResolution() string {\n\treturn t.trace\n}\n\ntype userSet struct {\n\tm sync.Mutex\n\tu map[string]resolutionTracer\n}\n\ntype userWithTracer struct {\n\tu string\n\tr resolutionTracer\n}\n\nfunc (u *userSet) Add(r resolutionTracer, values ...string) {\n\tu.m.Lock()\n\tfor _, v := range values {\n\t\tu.u[v] = r\n\t}\n\tu.m.Unlock()\n}\n\nfunc (u *userSet) AddFrom(other *userSet) {\n\tu.m.Lock()\n\tfor _, uwr := range other.AsSlice() {\n\t\tu.u[uwr.u] = uwr.r\n\t}\n\tu.m.Unlock()\n}\n\nfunc (u *userSet) DeleteFrom(other *userSet) {\n\tu.m.Lock()\n\tfor _, uwr := range other.AsSlice() {\n\t\tdelete(u.u, uwr.u)\n\t}\n\tu.m.Unlock()\n}\n\nfunc (u *userSet) Get(value string) (resolutionTracer, bool) {\n\tu.m.Lock()\n\tdefer u.m.Unlock()\n\n\tvar found bool\n\tvar rt resolutionTracer\n\tif rt, found = u.u[value]; !found {\n\t\tif rt, found = u.u[Wildcard]; !found {\n\t\t\treturn nil, false\n\t\t}\n\t}\n\treturn rt, found\n}\n\nfunc (u *userSet) AsSlice() []userWithTracer {\n\tu.m.Lock()\n\tout := make([]userWithTracer, 0, len(u.u))\n\tfor u, rt := range u.u {\n\t\tout = append(out, userWithTracer{\n\t\t\tu: u,\n\t\t\tr: rt,\n\t\t})\n\t}\n\tu.m.Unlock()\n\treturn out\n}\n\nfunc newUserSet() *userSet {\n\treturn &userSet{u: make(map[string]resolutionTracer)}\n}\n\ntype userSets struct {\n\tmu  sync.Mutex\n\tusm map[int]*userSet\n}\n\nfunc newUserSets() *userSets {\n\treturn &userSets{usm: make(map[int]*userSet, 0)}\n}\n\nfunc (u *userSets) Set(idx int, us *userSet) {\n\tu.mu.Lock()\n\tu.usm[idx] = us\n\tu.mu.Unlock()\n}\n\nfunc (u *userSets) Get(idx int) (*userSet, bool) {\n\tu.mu.Lock()\n\tus, ok := u.usm[idx]\n\tu.mu.Unlock()\n\treturn us, ok\n}\n\nfunc (u *userSets) AsMap() map[int]*userSet {\n\treturn u.usm\n}\n\ntype chanResolveResult struct {\n\terr   error\n\tfound bool\n}\n\ntype circuitBreaker struct {\n\tmu           sync.Mutex\n\tbreakerState bool\n}\n\nfunc (sc *circuitBreaker) Open() {\n\tsc.mu.Lock()\n\tdefer sc.mu.Unlock()\n\tsc.breakerState = true\n}\n\nfunc (sc *circuitBreaker) IsOpen() bool {\n\tsc.mu.Lock()\n\tdefer sc.mu.Unlock()\n\treturn sc.breakerState\n}\n\ntype resolutionContext struct {\n\tstore            string\n\tmodelID          string\n\tusers            *userSet\n\ttargetUser       string\n\ttk               *openfgapb.TupleKey\n\tcontextualTuples *contextualTuples\n\ttracer           resolutionTracer\n\tmetadata         *utils.ResolutionMetadata\n\tinternalCB       *circuitBreaker // Opens if the user is found, controlled internally. Primarily used for UNION.\n\texternalCB       *circuitBreaker // Open is controlled from caller, Used for Difference and Intersection.\n}\n\nfunc newResolutionContext(store, modelID string, tk *openfgapb.TupleKey, contextualTuples *contextualTuples, tracer resolutionTracer, metadata *utils.ResolutionMetadata, externalBreaker *circuitBreaker) *resolutionContext {\n\treturn &resolutionContext{\n\t\tstore:            store,\n\t\tmodelID:          modelID,\n\t\tusers:            newUserSet(),\n\t\ttargetUser:       tk.GetUser(),\n\t\ttk:               tk,\n\t\tcontextualTuples: contextualTuples,\n\t\ttracer:           tracer,\n\t\tmetadata:         metadata,\n\t\tinternalCB:       &circuitBreaker{breakerState: false},\n\t\texternalCB:       externalBreaker,\n\t}\n}\n\nfunc (rc *resolutionContext) shouldShortCircuit() bool {\n\tif rc.internalCB.IsOpen() || rc.externalCB.IsOpen() {\n\t\treturn true\n\t}\n\treturn rc.userFound()\n}\n\nfunc (rc *resolutionContext) shortCircuit() {\n\trc.internalCB.Open()\n}\n\nfunc (rc *resolutionContext) userFound() bool {\n\t_, ok := rc.users.Get(rc.targetUser)\n\tif ok {\n\t\trc.shortCircuit()\n\t}\n\treturn ok\n}\n\nfunc (rc *resolutionContext) fork(tk *openfgapb.TupleKey, tracer resolutionTracer, resetResolveCounter bool) *resolutionContext {\n\tmetadata := rc.metadata\n\tif resetResolveCounter {\n\t\tmetadata = rc.metadata.Fork()\n\t}\n\n\treturn &resolutionContext{\n\t\tstore:            rc.store,\n\t\tmodelID:          rc.modelID,\n\t\tusers:            rc.users,\n\t\ttargetUser:       rc.targetUser,\n\t\ttk:               tk,\n\t\tcontextualTuples: rc.contextualTuples,\n\t\ttracer:           tracer,\n\t\tmetadata:         metadata,\n\t\tinternalCB:       rc.internalCB,\n\t\texternalCB:       rc.externalCB,\n\t}\n}\n\nfunc (rc *resolutionContext) readUserTuple(ctx context.Context, backend storage.TupleBackend) (*openfgapb.TupleKey, error) {\n\ttk, ok := rc.contextualTuples.readUserTuple(rc.tk)\n\tif ok {\n\t\treturn tk, nil\n\t}\n\n\trc.metadata.AddReadCall()\n\ttuple, err := backend.ReadUserTuple(ctx, rc.store, rc.tk)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tuple.GetKey(), nil\n}\n\nfunc (rc *resolutionContext) readUsersetTuples(ctx context.Context, backend storage.TupleBackend) (storage.TupleKeyIterator, error) {\n\tcUsersetTuples := rc.contextualTuples.readUsersetTuples(rc.tk)\n\trc.metadata.AddReadCall()\n\tusersetTuples, err := backend.ReadUsersetTuples(ctx, rc.store, rc.tk)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\titer1 := storage.NewStaticTupleKeyIterator(cUsersetTuples)\n\titer2 := storage.NewTupleKeyIteratorFromTupleIterator(usersetTuples)\n\n\treturn storage.NewCombinedIterator(iter1, iter2), nil\n}\n\nfunc (rc *resolutionContext) read(ctx context.Context, backend storage.TupleBackend, tk *openfgapb.TupleKey) (storage.TupleKeyIterator, error) {\n\tcTuples := rc.contextualTuples.read(tk)\n\trc.metadata.AddReadCall()\n\ttuples, err := backend.Read(ctx, rc.store, tk)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\titer1 := storage.NewStaticTupleKeyIterator(cTuples)\n\titer2 := storage.NewTupleKeyIteratorFromTupleIterator(tuples)\n\n\treturn storage.NewCombinedIterator(iter1, iter2), nil\n}\n\ntype contextualTuples struct {\n\tusersets map[string][]*openfgapb.TupleKey\n}\n\nfunc (c *contextualTuples) read(tk *openfgapb.TupleKey) []*openfgapb.TupleKey {\n\treturn c.usersets[tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())]\n}\n\nfunc (c *contextualTuples) readUserTuple(tk *openfgapb.TupleKey) (*openfgapb.TupleKey, bool) {\n\ttuples := c.usersets[tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())]\n\tfor _, t := range tuples {\n\t\tif t.GetUser() == tk.GetUser() {\n\t\t\treturn t, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (c *contextualTuples) readUsersetTuples(tk *openfgapb.TupleKey) []*openfgapb.TupleKey {\n\ttuples := c.usersets[tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())]\n\n\tvar res []*openfgapb.TupleKey\n\tfor _, t := range tuples {\n\t\tif tupleUtils.GetUserTypeFromUser(t.GetUser()) == tupleUtils.UserSet {\n\t\t\tres = append(res, t)\n\t\t}\n\t}\n\treturn res\n}\n\nfunc validateAndPreprocessTuples(keyToCheck *openfgapb.TupleKey, tupleKeys []*openfgapb.TupleKey) (*contextualTuples, error) {\n\tif keyToCheck.GetUser() == \"\" || keyToCheck.GetRelation() == \"\" || keyToCheck.GetObject() == \"\" {\n\t\treturn nil, serverErrors.InvalidCheckInput\n\t}\n\tif !tupleUtils.IsValidUser(keyToCheck.GetUser()) {\n\t\treturn nil, serverErrors.InvalidUser(keyToCheck.GetUser())\n\t}\n\n\ttupleMap := map[string]struct{}{}\n\tusersets := map[string][]*openfgapb.TupleKey{}\n\tfor _, tk := range tupleKeys {\n\t\tif _, ok := tupleMap[tk.String()]; ok {\n\t\t\treturn nil, serverErrors.DuplicateContextualTuple(tk)\n\t\t}\n\t\ttupleMap[tk.String()] = struct{}{}\n\n\t\tif tk.GetUser() == \"\" || tk.GetRelation() == \"\" || tk.GetObject() == \"\" {\n\t\t\treturn nil, serverErrors.InvalidContextualTuple(tk)\n\t\t}\n\t\tif !tupleUtils.IsValidUser(tk.GetUser()) {\n\t\t\treturn nil, serverErrors.InvalidUser(tk.GetUser())\n\t\t}\n\n\t\tkey := tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())\n\t\tusersets[key] = append(usersets[key], tk)\n\t}\n\n\treturn &contextualTuples{usersets: usersets}, nil\n}\n", "package commands\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/openfga/openfga/pkg/logger\"\n\ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/utils\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/server/validation\"\n\t\"github.com/openfga/openfga/storage\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// ExpandQuery resolves a target TupleKey into a UsersetTree by expanding type definitions.\ntype ExpandQuery struct {\n\tlogger    logger.Logger\n\ttracer    trace.Tracer\n\tdatastore storage.OpenFGADatastore\n}\n\n// NewExpandQuery creates a new ExpandQuery using the supplied backends for retrieving data.\nfunc NewExpandQuery(datastore storage.OpenFGADatastore, tracer trace.Tracer, logger logger.Logger) *ExpandQuery {\n\treturn &ExpandQuery{logger: logger, tracer: tracer, datastore: datastore}\n}\n\nfunc (query *ExpandQuery) Execute(ctx context.Context, req *openfgapb.ExpandRequest) (*openfgapb.ExpandResponse, error) {\n\tstore := req.GetStoreId()\n\tmodelID := req.GetAuthorizationModelId()\n\ttupleKey := req.GetTupleKey()\n\tobject := tupleKey.GetObject()\n\trelation := tupleKey.GetRelation()\n\n\tif object == \"\" || relation == \"\" {\n\t\treturn nil, serverErrors.InvalidExpandInput\n\t}\n\n\ttk := tupleUtils.NewTupleKey(object, relation, \"\")\n\tmetadata := utils.NewResolutionMetadata()\n\tuserset, err := query.getUserset(ctx, store, modelID, tk, metadata)\n\tif err != nil {\n\t\tutils.LogDBStats(ctx, query.logger, \"Expand\", metadata.GetReadCalls(), 0)\n\t\treturn nil, err\n\t}\n\troot, err := query.resolveUserset(ctx, store, modelID, userset, tk, metadata)\n\tif err != nil {\n\t\tutils.LogDBStats(ctx, query.logger, \"Expand\", metadata.GetReadCalls(), 0)\n\t\treturn nil, err\n\t}\n\tutils.LogDBStats(ctx, query.logger, \"Expand\", metadata.GetReadCalls(), 0)\n\n\treturn &openfgapb.ExpandResponse{\n\t\tTree: &openfgapb.UsersetTree{\n\t\t\tRoot: root,\n\t\t},\n\t}, nil\n}\n\nfunc (query *ExpandQuery) resolveUserset(\n\tctx context.Context,\n\tstore, modelID string,\n\tuserset *openfgapb.Userset,\n\ttk *openfgapb.TupleKey,\n\tmetadata *utils.ResolutionMetadata,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveUserset\")\n\tdefer span.End()\n\n\tswitch us := userset.Userset.(type) {\n\tcase nil, *openfgapb.Userset_This:\n\t\treturn query.resolveThis(ctx, store, tk, metadata)\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\treturn query.resolveComputedUserset(ctx, us.ComputedUserset, tk, metadata)\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\treturn query.resolveTupleToUserset(ctx, store, modelID, us.TupleToUserset, tk, metadata)\n\tcase *openfgapb.Userset_Union:\n\t\treturn query.resolveUnionUserset(ctx, store, modelID, us.Union, tk, metadata)\n\tcase *openfgapb.Userset_Difference:\n\t\treturn query.resolveDifferenceUserset(ctx, store, modelID, us.Difference, tk, metadata)\n\tcase *openfgapb.Userset_Intersection:\n\t\treturn query.resolveIntersectionUserset(ctx, store, modelID, us.Intersection, tk, metadata)\n\tdefault:\n\t\treturn nil, serverErrors.UnsupportedUserSet\n\t}\n}\n\n// resolveThis resolves a DirectUserset into a leaf node containing a distinct set of users with that relation.\nfunc (query *ExpandQuery) resolveThis(ctx context.Context, store string, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveThis\")\n\tdefer span.End()\n\n\tmetadata.AddReadCall()\n\titer, err := query.datastore.Read(ctx, store, tk)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\tdefer iter.Stop()\n\tdistinctUsers := make(map[string]bool)\n\tfor {\n\t\ttuple, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t\t}\n\t\tdistinctUsers[tuple.GetKey().GetUser()] = true\n\t}\n\tusers := make([]string, 0, len(distinctUsers))\n\tfor u := range distinctUsers {\n\t\tusers = append(users, u)\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\tUsers: users,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveComputedUserset builds a leaf node containing the result of resolving a ComputedUserset rewrite.\nfunc (query *ExpandQuery) resolveComputedUserset(ctx context.Context, userset *openfgapb.ObjectRelation, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\n\tvar span trace.Span\n\t_, span = query.tracer.Start(ctx, \"resolveComputedUserset\")\n\tdefer span.End()\n\n\tcomputed := &openfgapb.TupleKey{\n\t\tObject:   userset.GetObject(),\n\t\tRelation: userset.GetRelation(),\n\t}\n\tif len(computed.Object) == 0 {\n\t\tcomputed.Object = tk.Object\n\t}\n\tif len(computed.Relation) == 0 {\n\t\tcomputed.Relation = tk.Relation\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\tUserset: toObjectRelation(computed),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveTupleToUserset creates a new leaf node containing the result of expanding a TupleToUserset rewrite.\nfunc (query *ExpandQuery) resolveTupleToUserset(\n\tctx context.Context,\n\tstore, modelID string,\n\tuserset *openfgapb.TupleToUserset,\n\ttk *openfgapb.TupleKey,\n\tmetadata *utils.ResolutionMetadata,\n) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveTupleToUserset\")\n\tdefer span.End()\n\n\ttargetObject := tk.GetObject()\n\n\ttupleset := userset.GetTupleset().GetRelation()\n\ttsKey := &openfgapb.TupleKey{\n\t\tObject:   targetObject,\n\t\tRelation: tupleset,\n\t}\n\n\tif tsKey.GetRelation() == \"\" {\n\t\ttsKey.Relation = tk.GetRelation()\n\t}\n\n\tmetadata.AddReadCall()\n\titer, err := query.datastore.Read(ctx, store, tsKey)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\tdefer iter.Stop()\n\n\tvar computed []*openfgapb.UsersetTree_Computed\n\tseen := make(map[string]bool)\n\tfor {\n\t\ttuple, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t\t}\n\t\tuser := tuple.GetKey().GetUser()\n\n\t\tif user == Wildcard {\n\t\t\tobjectType, _ := tupleUtils.SplitObject(targetObject)\n\n\t\t\tquery.logger.WarnWithContext(\n\t\t\t\tctx,\n\t\t\t\tfmt.Sprintf(\"unexpected wildcard evaluated on tupleset relation '%s'\", tupleset),\n\t\t\t\tzap.String(\"store_id\", store),\n\t\t\t\tzap.String(\"authorization_model_id\", modelID),\n\t\t\t\tzap.String(\"object_type\", objectType),\n\t\t\t)\n\n\t\t\treturn nil, serverErrors.InvalidTuple(\n\t\t\t\tfmt.Sprintf(\"unexpected wildcard evaluated on relation '%s#%s'\", objectType, tupleset),\n\t\t\t\ttupleUtils.NewTupleKey(targetObject, tupleset, Wildcard),\n\t\t\t)\n\t\t}\n\n\t\t// user must contain a type (i.e., be an object or userset)\n\t\tif tupleUtils.GetType(user) == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\ttObject, tRelation := tupleUtils.SplitObjectRelation(user)\n\t\t// We only proceed in the case that tRelation == userset.GetComputedUserset().GetRelation().\n\t\t// tRelation may be empty, and in this case, we set it to userset.GetComputedUserset().GetRelation().\n\t\tif tRelation == \"\" {\n\t\t\ttRelation = userset.GetComputedUserset().GetRelation()\n\t\t}\n\n\t\tif tRelation != userset.GetComputedUserset().GetRelation() {\n\t\t\tcontinue\n\t\t}\n\n\t\tcs := &openfgapb.TupleKey{\n\t\t\tObject:   tObject,\n\t\t\tRelation: tRelation,\n\t\t}\n\n\t\tcomputedRelation := toObjectRelation(cs)\n\t\tif !seen[computedRelation] {\n\t\t\tcomputed = append(computed, &openfgapb.UsersetTree_Computed{Userset: computedRelation})\n\t\t\tseen[computedRelation] = true\n\t\t}\n\t}\n\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\tTupleset: toObjectRelation(tsKey),\n\t\t\t\t\t\tComputed: computed,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveUnionUserset creates an intermediate Usertree node containing the union of its children.\nfunc (query *ExpandQuery) resolveUnionUserset(ctx context.Context, store, modelID string, usersets *openfgapb.Usersets, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveUnionUserset\")\n\tdefer span.End()\n\n\tnodes, err := query.resolveUsersets(ctx, store, modelID, usersets.Child, tk, metadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveIntersectionUserset create an intermediate Usertree node containing the intersection of its children\nfunc (query *ExpandQuery) resolveIntersectionUserset(ctx context.Context, store, modelID string, usersets *openfgapb.Usersets, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveIntersectionUserset\")\n\tdefer span.End()\n\n\tnodes, err := query.resolveUsersets(ctx, store, modelID, usersets.Child, tk, metadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Intersection{\n\t\t\tIntersection: &openfgapb.UsersetTree_Nodes{\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveDifferenceUserset creates and intermediate Usertree node containing the difference of its children\nfunc (query *ExpandQuery) resolveDifferenceUserset(ctx context.Context, store, modelID string, userset *openfgapb.Difference, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveDifferenceUserset\")\n\tdefer span.End()\n\n\tnodes, err := query.resolveUsersets(ctx, store, modelID, []*openfgapb.Userset{userset.Base, userset.Subtract}, tk, metadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbase := nodes[0]\n\tsubtract := nodes[1]\n\treturn &openfgapb.UsersetTree_Node{\n\t\tName: toObjectRelation(tk),\n\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: subtract,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// resolveUsersets creates Usertree nodes for multiple Usersets\nfunc (query *ExpandQuery) resolveUsersets(ctx context.Context, store, modelID string, usersets []*openfgapb.Userset, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) ([]*openfgapb.UsersetTree_Node, error) {\n\tctx, span := query.tracer.Start(ctx, \"resolveUsersets\")\n\tdefer span.End()\n\n\tout := make([]*openfgapb.UsersetTree_Node, len(usersets))\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tfor i, us := range usersets {\n\t\t// https://golang.org/doc/faq#closures_and_goroutines\n\t\ti, us := i, us\n\t\tgrp.Go(func() error {\n\t\t\tnode, err := query.resolveUserset(ctx, store, modelID, us, tk, metadata)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tout[i] = node\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := grp.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// getUserset retrieves the authorizationModel configuration for a supplied TupleKey.\nfunc (query *ExpandQuery) getUserset(ctx context.Context, store, modelID string, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.Userset, error) {\n\tctx, span := query.tracer.Start(ctx, \"getUserset\")\n\tdefer span.End()\n\n\tuserset, err := validation.ValidateObjectsRelations(ctx, query.datastore, store, modelID, tk, metadata)\n\tif err != nil {\n\t\treturn nil, serverErrors.HandleTupleValidateError(err)\n\t}\n\treturn userset, nil\n}\n\nfunc toObjectRelation(tk *openfgapb.TupleKey) string {\n\treturn tupleUtils.ToObjectRelationString(tk.GetObject(), tk.GetRelation())\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/openfga/openfga/pkg/id\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/openfga/openfga/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n)\n\nconst (\n\tdefaultResolveNodeLimit = 25\n\tgitHubTestDataFile      = \"testdata/github.json\" // relative to project root\n)\n\nvar githubTuples = []*openfgapb.TupleKey{\n\ttuple.NewTupleKey(\"org:openfga\", \"member\", \"erik\"),\n\ttuple.NewTupleKey(\"org:openfga\", \"repo_admin\", \"org:openfga#member\"),\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"team:openfga/iam#member\"),\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"owner\", \"org:openfga\"),\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"beth\"),\n\ttuple.NewTupleKey(\"team:openfga/iam\", \"member\", \"charles\"),\n\ttuple.NewTupleKey(\"team:openfga/iam\", \"member\", \"team:openfga/protocols#member\"),\n\ttuple.NewTupleKey(\"team:openfga/protocols\", \"member\", \"diane\"),\n}\n\nfunc TestCheckQuery(t *testing.T, datastore storage.OpenFGADatastore) {\n\tvar tests = []struct {\n\t\tname             string\n\t\ttypeDefinitions  []*openfgapb.TypeDefinition\n\t\ttuples           []*openfgapb.TupleKey\n\t\tresolveNodeLimit uint32\n\t\trequest          *openfgapb.CheckRequest\n\t\terr              error\n\t\tresponse         *openfgapb.CheckResponse\n\t}{\n\t\t{\n\t\t\tname: \"ExecuteWithEmptyTupleKey\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{},\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidCheckInput,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithEmptyObject\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"\", \"reader\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidCheckInput,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithEmptyRelation\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidCheckInput,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithEmptyUser\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidCheckInput,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithRequestRelationInexistentInTypeDefinition\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType:      \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"inexistent\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.RelationNotFound(\"inexistent\", \"repo\", tuple.NewTupleKey(\"repo:openfga/openfga\", \"inexistent\", \"someUser\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteFailsWithInvalidUser\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"john:albert:doe\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.InvalidUser(\"john:albert:doe\"),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsErrorNotStackOverflowForInfinitelyRecursiveResolution\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\tRelation: \"reader\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsResolutionTooComplexErrorForComplexResolution\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t},\n\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\tRelation: \"reader\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tresolveNodeLimit: 2,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsResolutionTooComplexErrorForComplexUnionResolution\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t},\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tresolveNodeLimit: 2,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"someUser\"),\n\t\t\t},\n\t\t\t// output\n\t\t\terr: serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithExistingTupleKeyAndEmptyUserSetReturnsAllowed\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithAllowAllTupleKeyAndEmptyUserSetReturnsAllowed\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"*\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithNonExistingTupleKeyAndEmptyUserSetReturnsNotAllowed\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples:           []*openfgapb.TupleKey{},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithUnionAndDirectUserSetReturnsAllowedIfDirectTupleExists\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"admin\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//\t\tchild { _this {  }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithUnionAndDirectUserSetReturnsAllowedIfAllUsersTupleExists\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"admin\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//\t\tchild { _this {  }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"*\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithUnionAndComputedUserSetReturnsNotAllowedIfComputedUsersetDoesNotIncludeUser\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"admin\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//    child { computed_userset { relation: \"owner\" }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"owner\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"owner\", \"team/iam\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWithUnionAndComputedUserSetReturnsAllowedIfComputedUsersetIncludesUser\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"reader\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//    child { _this {  }}\n\t\t\t//    child { computed_userset { relation: \"writer\" }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"writer\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#writer.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteDirectSetReturnsAllowedIfUserHasRelationWithAnObjectThatHasUserAccessToTheTargetObject\",\n\t\t\t// state\n\t\t\t//relation {\n\t\t\t//\tname: \"reader\"\n\t\t\t//\tuserset_rewrite {\n\t\t\t//    child { _this {  }}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"team_member\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"team_member\", \"github|jose@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"team:iam#team_member\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".(direct).team:iam#team_member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsAllowedIfUserIsHasRelationToAnObjectThatIsInComputedUserSetForAnotherObject\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"writer\": {},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"team_member\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"team_member\", \"github|jose@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"team:iam#team_member\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#writer.(direct).team:iam#team_member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsNotAllowedIfIntersectionIsRequiredAndUserIsInOneUserSetButNotTheOther\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"openfga-store\",\n\t\t\t\t// pretend you can only create an organization user in an openfga store if\n\t\t\t\t// you can create a user AND write an organization in a store\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"create_organization_user\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"write_organization\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"create_user\":        {},\n\t\t\t\t\t\"write_organization\": {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_user\", \"github|yenkel@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_organization_user\", \"github|yenkel@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsAllowedIfIntersectionIsRequiredAndUserIsInAllUserSets\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"openfga-store\",\n\t\t\t\t// pretend you can only create an organization user in an openfga store if\n\t\t\t\t// you can create a user AND write an organization in a store\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"create_organization_user\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"write_organization\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"write_organization\": {},\n\t\t\t\t\t\"create_user\":        {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_user\", \"github|yenkel@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"write_organization\", \"github|yenkel@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_organization_user\", \"github|yenkel@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".[.0(computed-userset).openfga-store:yenkel-dev#create_user.(direct).,.1(computed-userset).openfga-store:yenkel-dev#write_organization.(direct).]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteSupportsNestedIntersectionAndCorrectlyTraces\",\n\t\t\t// state\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{{\n\t\t\t\tType: \"openfga-store\",\n\t\t\t\t// pretend you can only create an organization user in an openfga store if\n\t\t\t\t// you can create a user AND write an organization in a store\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"create_organization_user\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"write_organization\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"create_user\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user_a\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"create_user_b\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"write_organization\": {},\n\t\t\t\t\t\"create_user_a\":      {},\n\t\t\t\t\t\"create_user_b\":      {},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_user_a\", \"github|yenkel@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_user_b\", \"github|yenkel@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"write_organization\", \"github|yenkel@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\t// input\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"openfga-store:yenkel-dev\", \"create_organization_user\", \"github|yenkel@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\t// output\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".[.0(computed-userset).openfga-store:yenkel-dev#create_user.[.0(computed-userset).openfga-store:yenkel-dev#create_user.0(computed-userset).openfga-store:yenkel-dev#create_user_a.(direct).,.0(computed-userset).openfga-store:yenkel-dev#create_user.1(computed-userset).openfga-store:yenkel-dev#create_user_b.(direct).],.1(computed-userset).openfga-store:yenkel-dev#write_organization.(direct).]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsAllowedForUserNotRemovedByDifference\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"banned\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"banned\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jon.allie@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"banned\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jon.allie@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsNotAllowedForUserRemovedByDifference\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"banned\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"banned\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jon.allie@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"banned\", \"github|jon.allie@openfga\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"banned\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jon.allie@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteReturnsAllowedForTupleToUserset\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t// implicit direct?\n\t\t\t\t\t\t\"repo_admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/canaveral\", \"manager\", \"org:openfga#repo_admin\"),\n\t\t\t\ttuple.NewTupleKey(\"org:openfga\", \"repo_admin\", \"github|jose@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/canaveral\", \"admin\", \"github|jose@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(tuple-to-userset).repo:openfga/canaveral#manager.org:openfga#repo_admin.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteCanResolveRecursiveComputedUserSets\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"maintainer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"maintainer\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_writer\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"triager\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"triager\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_reader\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"team:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:openfga\", \"member\", \"github|iaco@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"github|iaco@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#triager.union.1(computed-userset).repo:openfga/openfga#writer.union.0(direct).team:openfga#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteCanResolveRecursiveTupleToUserSets\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\"owner\":  {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\"editor\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"editor\",\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_TupleToUserset{TupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"parent\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:octo_v2_draft\", \"parent\", \"document:octo_folder\"),\n\t\t\t\ttuple.NewTupleKey(\"document:octo_folder\", \"editor\", \"google|iaco@openfga\"),\n\t\t\t},\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:octo_v2_draft\", \"viewer\", \"google|iaco@openfga\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.2(tuple-to-userset).document:octo_v2_draft#parent.document:octo_folder#viewer.union.1(computed-userset).document:octo_folder#editor.union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"CheckWithUsersetAsUser\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"team:iam\", \"member\", \"org:openfga#member\"),\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"member\", \"team:engineering#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:engineering\", \"member\", \"org:openfga#member\"),\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"CheckUsersetAsUser_WithContextualTuples\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"team:iam\", \"member\", \"org:openfga#member\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"member\", \"team:engineering#member\"),\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:engineering\", \"member\", \"org:openfga#member\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"CheckUsersetAsUser_WithContextualTuples\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"team:iam\", \"member\", \"org:openfga#member\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"member\", \"team:engineering#member\"),\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:engineering\", \"member\", \"org:openfga#member\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"CheckUsersetAsUser_WithContextualTuples\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"team:iam\", \"member\", \"org:openfga#member\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:iam\", \"member\", \"team:engineering#member\"),\n\t\t\t\t\t\ttuple.NewTupleKey(\"team:engineering\", \"member\", \"org:openfga#member\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"team\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"Check with TupleToUserset involving no object or userset\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:doc1\", \"viewer\", \"anne\"),\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset:        &openfgapb.ObjectRelation{Relation: \"parent\"},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"viewer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"folder\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder1\"), // folder1 isn't an object or userset\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"anne\"),\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"TupleToUserset Check Passes when at least one tupleset relation resolves\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:doc1\", \"viewer\", \"anne\"),\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset:        &openfgapb.ObjectRelation{Relation: \"parent\"},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"viewer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"folder\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder1\"), // folder1 isn't an object or userset\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"anne\"),\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"Error if * encountered in TupleToUserset evaluation\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:anne\"),\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\"viewer\": typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t},\n\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\ttypesystem.RelationReference(\"folder\", \"\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"folder\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t\t},\n\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\ttypesystem.RelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"*\"), // wildcard not allowed on tupleset relations\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:anne\"),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidTuple(\n\t\t\t\t\"unexpected wildcard evaluated on relation 'document#parent'\",\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", commands.Wildcard),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:             \"Error if * encountered in TTU evaluation including ContextualTuples\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:anne\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"*\"), // wildcard not allowed on tupleset relations\n\t\t\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:anne\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\"viewer\": typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t},\n\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\ttypesystem.RelationReference(\"folder\", \"\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"folder\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t\t},\n\t\t\t\t\tMetadata: &openfgapb.Metadata{\n\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n\t\t\t\t\t\t\t\t\ttypesystem.RelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidTuple(\n\t\t\t\t\"unexpected wildcard evaluated on relation 'document#parent'\",\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", commands.Wildcard),\n\t\t\t),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tstore := id.Must(id.New()).String()\n\t\t\tmodel := &openfgapb.AuthorizationModel{\n\t\t\t\tId:              id.Must(id.New()).String(),\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\t\t\tTypeDefinitions: test.typeDefinitions,\n\t\t\t}\n\n\t\t\terr := datastore.WriteAuthorizationModel(ctx, store, model)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif test.tuples != nil {\n\t\t\t\terr := datastore.Write(ctx, store, nil, test.tuples)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tcmd := commands.NewCheckQuery(datastore, tracer, meter, logger, test.resolveNodeLimit)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = model.Id\n\t\t\tresp, gotErr := cmd.Execute(ctx, test.request)\n\n\t\t\trequire.ErrorIs(t, gotErr, test.err)\n\n\t\t\tif test.response != nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\n\t\t\t\trequire.Equal(t, test.response.Allowed, resp.Allowed)\n\n\t\t\t\tif test.response.Allowed {\n\t\t\t\t\trequire.Equal(t, test.response.Resolution, resp.Resolution)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCheckQueryAgainstGitHubModel(t *testing.T, datastore storage.OpenFGADatastore) {\n\tvar tests = []struct {\n\t\tname             string\n\t\tresolveNodeLimit uint32\n\t\trequest          *openfgapb.CheckRequest\n\t\terr              error\n\t\tresponse         *openfgapb.CheckResponse\n\t}{\n\t\t{\n\t\t\tname:             \"GitHubAssertion1\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion2\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"triager\", \"anne\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion3\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"diane\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).team:openfga/iam#member.(direct).team:openfga/protocols#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion4\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"erik\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#triager.union.1(computed-userset).repo:openfga/openfga#writer.union.1(computed-userset).repo:openfga/openfga#maintainer.union.1(computed-userset).repo:openfga/openfga#admin.union.1(tuple-to-userset).repo:openfga/openfga#owner.org:openfga#repo_admin.(direct).org:openfga#member.union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion5\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"charles\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#maintainer.union.1(computed-userset).repo:openfga/openfga#admin.union.0(direct).team:openfga/iam#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"GitHubAssertion6\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tTrace:    true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\n\tdata, err := os.ReadFile(gitHubTestDataFile)\n\trequire.NoError(t, err)\n\n\tvar gitHubDefinition openfgapb.WriteAuthorizationModelRequest\n\terr = protojson.Unmarshal(data, &gitHubDefinition)\n\trequire.NoError(t, err)\n\n\tstore := id.Must(id.New()).String()\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: gitHubDefinition.GetTypeDefinitions(),\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(t, err)\n\n\terr = datastore.Write(ctx, store, nil, githubTuples)\n\trequire.NoError(t, err)\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewCheckQuery(datastore, tracer, meter, logger, test.resolveNodeLimit)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = model.Id\n\t\t\tresp, gotErr := cmd.Execute(ctx, test.request)\n\n\t\t\tif test.err == nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\t\t\t}\n\n\t\t\tif test.err != nil {\n\t\t\t\trequire.EqualError(t, test.err, gotErr.Error())\n\t\t\t}\n\n\t\t\tif test.response != nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\n\t\t\t\trequire.Equal(t, test.response.Allowed, resp.Allowed)\n\n\t\t\t\tif test.response.Allowed {\n\t\t\t\t\trequire.Equal(t, test.response.Resolution, resp.Resolution)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCheckQueryWithContextualTuplesAgainstGitHubModel(t *testing.T, datastore storage.OpenFGADatastore) {\n\tvar tests = []struct {\n\t\tname             string\n\t\tresolveNodeLimit uint32\n\t\trequest          *openfgapb.CheckRequest\n\t\terr              error\n\t\tresponse         *openfgapb.CheckResponse\n\t}{\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion1\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion2\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"triager\", \"anne\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion3\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"diane\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.0(direct).team:openfga/iam#member.(direct).team:openfga/protocols#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion4\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"erik\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#triager.union.1(computed-userset).repo:openfga/openfga#writer.union.1(computed-userset).repo:openfga/openfga#maintainer.union.1(computed-userset).repo:openfga/openfga#admin.union.1(tuple-to-userset).repo:openfga/openfga#owner.org:openfga#repo_admin.(direct).org:openfga#member.union.0(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion5\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"writer\", \"charles\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed:    true,\n\t\t\t\tResolution: \".union.1(computed-userset).repo:openfga/openfga#maintainer.union.1(computed-userset).repo:openfga/openfga#admin.union.0(direct).team:openfga/iam#member.(direct).\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesGitHubAssertion6\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey:         tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{TupleKeys: githubTuples},\n\t\t\t\tTrace:            true,\n\t\t\t},\n\t\t\tresponse: &openfgapb.CheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"RepeatedContextualTuplesShouldError\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTrace: true,\n\t\t\t},\n\t\t\terr: serverErrors.DuplicateContextualTuple(tuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"anne\")),\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesWithEmptyUserFails\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"org:openfga\", \"member\", \"\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTrace: true,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidContextualTuple(tuple.NewTupleKey(\"org:openfga\", \"member\", \"\")),\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesWithEmptyRelationFails\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"org:openfga\", \"\", \"anne\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTrace: true,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidContextualTuple(tuple.NewTupleKey(\"org:openfga\", \"\", \"anne\")),\n\t\t},\n\t\t{\n\t\t\tname:             \"ContextualTuplesWithEmptyObjectFails\",\n\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n\t\t\trequest: &openfgapb.CheckRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga/openfga\", \"admin\", \"beth\"),\n\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n\t\t\t\t\t\ttuple.NewTupleKey(\"\", \"member\", \"anne\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTrace: true,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidContextualTuple(tuple.NewTupleKey(\"\", \"member\", \"anne\")),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\n\tdata, err := os.ReadFile(gitHubTestDataFile)\n\trequire.NoError(t, err)\n\n\tvar gitHubDefinition openfgapb.WriteAuthorizationModelRequest\n\terr = protojson.Unmarshal(data, &gitHubDefinition)\n\trequire.NoError(t, err)\n\n\tstoreID := id.Must(id.New()).String()\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: gitHubDefinition.GetTypeDefinitions(),\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, storeID, model)\n\trequire.NoError(t, err)\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewCheckQuery(datastore, tracer, meter, logger, test.resolveNodeLimit)\n\t\t\ttest.request.StoreId = storeID\n\t\t\ttest.request.AuthorizationModelId = model.Id\n\t\t\tresp, gotErr := cmd.Execute(ctx, test.request)\n\n\t\t\tif test.err == nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\t\t\t}\n\n\t\t\tif test.err != nil {\n\t\t\t\trequire.EqualError(t, test.err, gotErr.Error())\n\t\t\t}\n\n\t\t\tif test.response != nil {\n\t\t\t\trequire.NoError(t, gotErr)\n\n\t\t\t\trequire.Equal(t, test.response.Allowed, resp.Allowed)\n\n\t\t\t\tif test.response.Allowed {\n\t\t\t\t\trequire.Equal(t, test.response.Resolution, resp.Resolution)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCheckQueryAuthorizationModelsVersioning(t *testing.T, datastore storage.OpenFGADatastore) {\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\tstore := id.Must(id.New()).String()\n\n\toldModel := &openfgapb.AuthorizationModel{\n\t\tId:            id.Must(id.New()).String(),\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"owner\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\"editor\": {\n\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{ComputedUserset: &openfgapb.ObjectRelation{Relation: \"owner\"}}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := datastore.WriteAuthorizationModel(ctx, store, oldModel)\n\trequire.NoError(t, err)\n\n\tupdatedModel := &openfgapb.AuthorizationModel{\n\t\tId:            id.Must(id.New()).String(),\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"repo\",\n\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\"owner\":  {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\"editor\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, store, updatedModel)\n\trequire.NoError(t, err)\n\n\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, []*openfgapb.TupleKey{{Object: \"repo:openfgapb\", Relation: \"owner\", User: \"yenkel\"}})\n\trequire.NoError(t, err)\n\n\toldResp, err := commands.NewCheckQuery(datastore, tracer, meter, logger, defaultResolveNodeLimit).Execute(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: oldModel.Id,\n\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\tObject:   \"repo:openfgapb\",\n\t\t\tRelation: \"editor\",\n\t\t\tUser:     \"yenkel\",\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\trequire.True(t, oldResp.Allowed)\n\n\tupdatedResp, err := commands.NewCheckQuery(datastore, tracer, meter, logger, defaultResolveNodeLimit).Execute(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: updatedModel.Id,\n\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\tObject:   \"repo:openfgapb\",\n\t\t\tRelation: \"editor\",\n\t\t\tUser:     \"yenkel\",\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\trequire.False(t, updatedResp.Allowed)\n}\n\nvar tuples = []*openfgapb.TupleKey{\n\ttuple.NewTupleKey(\"repo:openfga/openfga\", \"reader\", \"team:openfga#member\"),\n\ttuple.NewTupleKey(\"team:openfga\", \"member\", \"github|iaco@openfga\"),\n}\n\n// Used to avoid compiler optimizations (see https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)\nvar result *openfgapb.CheckResponse //nolint\n\nfunc BenchmarkCheckWithoutTrace(b *testing.B, datastore storage.OpenFGADatastore) {\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\tstore := id.Must(id.New()).String()\n\n\tdata, err := os.ReadFile(gitHubTestDataFile)\n\trequire.NoError(b, err)\n\n\tvar gitHubTypeDefinitions openfgapb.WriteAuthorizationModelRequest\n\terr = protojson.Unmarshal(data, &gitHubTypeDefinitions)\n\trequire.NoError(b, err)\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: gitHubTypeDefinitions.GetTypeDefinitions(),\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(b, err)\n\n\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, tuples)\n\trequire.NoError(b, err)\n\n\tcheckQuery := commands.NewCheckQuery(datastore, tracer, meter, logger, defaultResolveNodeLimit)\n\n\tvar r *openfgapb.CheckResponse\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr, _ = checkQuery.Execute(ctx, &openfgapb.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: model.Id,\n\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\tObject:   \"repo:openfga/openfga\",\n\t\t\t\tRelation: \"reader\",\n\t\t\t\tUser:     \"github|iaco@openfga\",\n\t\t\t},\n\t\t})\n\t}\n\n\tresult = r\n}\n\nfunc BenchmarkWithTrace(b *testing.B, datastore storage.OpenFGADatastore) {\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\tlogger := logger.NewNoopLogger()\n\tstore := id.Must(id.New()).String()\n\n\tdata, err := os.ReadFile(gitHubTestDataFile)\n\trequire.NoError(b, err)\n\n\tvar gitHubTypeDefinitions openfgapb.WriteAuthorizationModelRequest\n\terr = protojson.Unmarshal(data, &gitHubTypeDefinitions)\n\trequire.NoError(b, err)\n\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: gitHubTypeDefinitions.GetTypeDefinitions(),\n\t}\n\n\terr = datastore.WriteAuthorizationModel(ctx, store, model)\n\trequire.NoError(b, err)\n\n\terr = datastore.Write(ctx, store, []*openfgapb.TupleKey{}, tuples)\n\trequire.NoError(b, err)\n\n\tcheckQuery := commands.NewCheckQuery(datastore, tracer, meter, logger, defaultResolveNodeLimit)\n\n\tvar r *openfgapb.CheckResponse\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr, _ = checkQuery.Execute(ctx, &openfgapb.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: model.Id,\n\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\tObject:   \"repo:openfga/openfga\",\n\t\t\t\tRelation: \"reader\",\n\t\t\t\tUser:     \"github|iaco@openfga\",\n\t\t\t},\n\t\t\tTrace: true,\n\t\t})\n\t}\n\n\tresult = r\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/openfga/openfga/pkg/id\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/pkg/testutils\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/openfga/openfga/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"google.golang.org/protobuf/testing/protocmp\"\n)\n\nfunc setUp(ctx context.Context, store string, datastore storage.OpenFGADatastore, typeDefinitions []*openfgapb.TypeDefinition, tuples []*openfgapb.TupleKey) (string, error) {\n\tmodel := &openfgapb.AuthorizationModel{\n\t\tId:              id.Must(id.New()).String(),\n\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: typeDefinitions,\n\t}\n\n\tif err := datastore.WriteAuthorizationModel(ctx, store, model); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif err := datastore.Write(ctx, store, []*openfgapb.TupleKey{}, tuples); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn model.Id, nil\n}\n\nfunc TestExpandQuery(t *testing.T, datastore storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname            string\n\t\ttypeDefinitions []*openfgapb.TypeDefinition\n\t\ttuples          []*openfgapb.TupleKey\n\t\trequest         *openfgapb.ExpandRequest\n\t\texpected        *openfgapb.ExpandResponse\n\t}{\n\t\t{\n\t\t\tname: \"simple direct\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\tUsers: []string{\"github|jon.allie@openfga\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"computed userset\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tuple to userset\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"manager\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"repo_admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tuple to userset II\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"manager\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"repo_admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"amy\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"tuple to userset implicit\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"manager\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"repo_admin\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"manager\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"org:openfga\",\n\t\t\t\t\tRelation: \"repo_admin\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#manager\",\n\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"org:openfga#repo_admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple union\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{\"github|jon.allie@openfga\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple difference\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\":  {},\n\t\t\t\t\t\t\"banned\": {},\n\t\t\t\t\t\t\"active_admin\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"banned\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"active_admin\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\t\t\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\t\t\t\t\tBase: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSubtract: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#active_admin\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#banned\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple intersection\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\t// Writers must be both directly in 'writers', and in 'admins'\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\": {},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Intersection{\n\t\t\t\t\t\t\tIntersection: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#admin\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"complex tree\",\n\t\t\t// Users can write if they are direct members of writers, or repo_writers\n\t\t\t// in the org, unless they are also in banned_writers\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"admin\":         {},\n\t\t\t\t\t\t\"owner\":         {},\n\t\t\t\t\t\t\"banned_writer\": {},\n\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis: &openfgapb.DirectUserset{},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject:   \"$TUPLE_USERSET_OBJECT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"repo_writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"banned_writer\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: \"org\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"repo_writer\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\tUser:     \"org:openfga\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\tUser:     \"github|jon.allie@openfga\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:openfga/foo\",\n\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &openfgapb.ExpandResponse{\n\t\t\t\tTree: &openfgapb.UsersetTree{\n\t\t\t\t\tRoot: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Difference{\n\t\t\t\t\t\t\tDifference: &openfgapb.UsersetTree_Difference{\n\t\t\t\t\t\t\t\tBase: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Union{\n\t\t\t\t\t\t\t\t\t\tUnion: &openfgapb.UsersetTree_Nodes{\n\t\t\t\t\t\t\t\t\t\t\tNodes: []*openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: &openfgapb.UsersetTree_Users{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsers: []string{\"github|jon.allie@openfga\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.UsersetTree_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: \"repo:openfga/foo#owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputed: []*openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{Userset: \"org:openfga#repo_writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSubtract: &openfgapb.UsersetTree_Node{\n\t\t\t\t\t\t\t\t\tName: \"repo:openfga/foo#writer\",\n\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Node_Leaf{\n\t\t\t\t\t\t\t\t\t\tLeaf: &openfgapb.UsersetTree_Leaf{\n\t\t\t\t\t\t\t\t\t\t\tValue: &openfgapb.UsersetTree_Leaf_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\tComputed: &openfgapb.UsersetTree_Computed{\n\t\t\t\t\t\t\t\t\t\t\t\t\tUserset: \"repo:openfga/foo#banned_writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire := require.New(t)\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tstore := testutils.CreateRandomString(20)\n\t\t\tmodelID, err := setUp(ctx, store, datastore, test.typeDefinitions, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tquery := commands.NewExpandQuery(datastore, tracer, logger)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = modelID\n\t\t\tgot, err := query.Execute(ctx, test.request)\n\t\t\trequire.NoError(err)\n\n\t\t\tif diff := cmp.Diff(test.expected, got, protocmp.Transform()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"%s: Execute() (-want, +got):\\n%s\", test.name, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExpandQueryErrors(t *testing.T, datastore storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname            string\n\t\ttypeDefinitions []*openfgapb.TypeDefinition\n\t\ttuples          []*openfgapb.TupleKey\n\t\trequest         *openfgapb.ExpandRequest\n\t\texpected        error\n\t}{\n\t\t{\n\t\t\tname: \"missing object\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidExpandInput,\n\t\t},\n\t\t{\n\t\t\tname: \"missing object id and type\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \":\",\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidObjectFormat(&openfgapb.TupleKey{\n\t\t\t\tObject:   \":\",\n\t\t\t\tRelation: \"bar\",\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"missing object id\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"github:\",\n\t\t\t\t\tRelation: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidObjectFormat(&openfgapb.TupleKey{\n\t\t\t\tObject:   \"github:\",\n\t\t\t\tRelation: \"bar\",\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"missing relation\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidExpandInput,\n\t\t},\n\t\t{\n\t\t\tname: \"type not found\",\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"foo:bar\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.TypeNotFound(\"foo\"),\n\t\t},\n\t\t{\n\t\t\tname: \"relation not found\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"repo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: &openfgapb.TupleKey{\n\t\t\t\t\tObject:   \"repo:bar\",\n\t\t\t\t\tRelation: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: serverErrors.RelationNotFound(\"baz\", \"repo\", &openfgapb.TupleKey{\n\t\t\t\tObject:   \"repo:bar\",\n\t\t\t\tRelation: \"baz\",\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"TupleToUserset involving wildcard returns error\",\n\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t{\n\t\t\t\t\tType: \"document\",\n\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\"viewer\": typesystem.Union(\n\t\t\t\t\t\t\ttypesystem.This(), typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttuples: []*openfgapb.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:X\", \"viewer\", \"jon\"),\n\t\t\t},\n\t\t\trequest: &openfgapb.ExpandRequest{\n\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:1\", \"viewer\", \"\"),\n\t\t\t},\n\t\t\texpected: serverErrors.InvalidTuple(\n\t\t\t\t\"unexpected wildcard evaluated on relation 'document#parent'\",\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"*\"),\n\t\t\t),\n\t\t},\n\t}\n\n\trequire := require.New(t)\n\tctx := context.Background()\n\ttracer := telemetry.NewNoopTracer()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tstore := testutils.CreateRandomString(20)\n\n\t\t\tmodelID, err := setUp(ctx, store, datastore, test.typeDefinitions, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tquery := commands.NewExpandQuery(datastore, tracer, logger)\n\t\t\ttest.request.StoreId = store\n\t\t\ttest.request.AuthorizationModelId = modelID\n\n\t\t\t_, err = query.Execute(ctx, test.request)\n\t\t\trequire.ErrorIs(err, test.expected)\n\t\t})\n\t}\n}\n"], "filenames": ["server/commands/check.go", "server/commands/check_utils.go", "server/commands/expand.go", "server/test/check.go", "server/test/expand.go"], "buggy_code_start_loc": [4, 198, 4, 1169, 7], "buggy_code_end_loc": [430, 199, 206, 1206, 836], "fixing_code_start_loc": [5, 198, 5, 1170, 6], "fixing_code_end_loc": [451, 199, 249, 1298, 859], "type": "CWE-863", "message": "OpenFGA is an authorization/permission engine. Versions prior to version 0.2.4 are vulnerable to authorization bypass under certain conditions. Users who have wildcard (`*`) defined on tupleset relations in their authorization model are vulnerable. Version 0.2.4 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2022-39341", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-25T17:15:56.273", "lastModified": "2022-10-26T00:51:40.153", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenFGA is an authorization/permission engine. Versions prior to version 0.2.4 are vulnerable to authorization bypass under certain conditions. Users who have wildcard (`*`) defined on tupleset relations in their authorization model are vulnerable. Version 0.2.4 contains a patch for this issue."}, {"lang": "es", "value": "OpenFGA es un motor de autorizaci\u00f3n/permiso. Las versiones anteriores a 0.2.4, son vulnerables a la omisi\u00f3n de la autorizaci\u00f3n bajo determinadas condiciones. Los usuarios que tienen comodines (\"*\") definidos en las relaciones tupleset en su modelo de autorizaci\u00f3n son vulnerables. La versi\u00f3n 0.2.4 contiene un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openfga:openfga:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.4", "matchCriteriaId": "6C8497C4-6109-40A8-AA89-E20BF94EB4C2"}]}]}], "references": [{"url": "https://github.com/openfga/openfga/commit/b466769cc100b2065047786578718d313f52695b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openfga/openfga/releases/tag/v0.2.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/openfga/openfga/security/advisories/GHSA-vj4m-83m8-xpw5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openfga/openfga/commit/b466769cc100b2065047786578718d313f52695b"}}